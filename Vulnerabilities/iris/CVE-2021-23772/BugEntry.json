{"buggy_code": ["<!-- # History/Changelog <a href=\"HISTORY_ZH.md\"> <img width=\"20px\" src=\"https://iris-go.com/images/flag-china.svg?v=10\" /></a><a href=\"HISTORY_ID.md\"> <img width=\"20px\" src=\"https://iris-go.com/images/flag-indonesia.svg?v=10\" /></a><a href=\"HISTORY_GR.md\"> <img width=\"20px\" src=\"https://iris-go.com/images/flag-greece.svg?v=10\" /></a> -->\r\n\r\n# Changelog\r\n\r\n### Looking for free and real-time support?\r\n\r\n    https://github.com/kataras/iris/issues\r\n    https://chat.iris-go.com\r\n\r\n### Looking for previous versions?\r\n\r\n    https://github.com/kataras/iris/releases\r\n\r\n### Want to be hired?\r\n\r\n    https://facebook.com/iris.framework\r\n\r\n### Should I upgrade my Iris?\r\n\r\nDevelopers are not forced to upgrade if they don't really need it. Upgrade whenever you feel ready.\r\n\r\n**How to upgrade**: Open your command-line and execute this command: `go get github.com/kataras/iris/v12@latest`.\r\n\r\n# Next\r\n\r\nThis release introduces new features and some breaking changes.\r\nThe codebase for Dependency Injection, Internationalization and localization and more have been simplified a lot (fewer LOCs and easier to read and follow up).\r\n\r\n## Fixes and Improvements\r\n\r\n- New `Configuration.Timeout` and `Configuration.TimeoutMessage` fields. Use it to set HTTP timeouts. Note that your http server's (`Application.ConfigureHost`) Read/Write timeouts should be a bit higher than the `Configuration.Timeout` in order to give some time to http timeout handler to kick in and be able to send the `Configuration.TimeoutMessage` properly.\r\n\r\n- New `apps.OnApplicationRegistered` method which listens on new Iris applications hosted under the same binary. Use it on your `init` functions to configure Iris applications by any spot in your project's files.\r\n\r\n- `Context.JSON` respects any object implements the `easyjson.Marshaler` interface and renders the result using the [easyjon](https://github.com/mailru/easyjson)'s writer.\r\n\r\n- minor: `Context` structure implements the standard go Context interface now (includes: Deadline, Done, Err and Value methods). Handlers can now just pass the `ctx iris.Context` as a shortcut of `ctx.Request().Context()` when needed.\r\n\r\n- New [x/jsonx](x/jsonx) sub-package for JSON type helpers.\r\n\r\n- New [x/mathx](x/mathx) sub-package for math related functions.\r\n\r\n- New [/x/client](x/client) HTTP Client sub-package.\r\n\r\n- New `email` builtin path parameter type. Example:\r\n\r\n```go\r\n// +------------------------+\r\n// | {param:email}           |\r\n// +------------------------+\r\n// Email + mx look up path parameter validation. Use it on production.\r\n\r\n// http://localhost:8080/user/kataras2006@hotmail.com -> OK\r\n// http://localhost:8080/user/b-c@invalid_domain      -> NOT FOUND\r\napp.Get(\"/user/{user_email:email}\", func(ctx iris.Context) {\r\n    email := ctx.Params().Get(\"user_email\")\r\n    ctx.WriteString(email)\r\n})\r\n\r\n// +------------------------+\r\n// | {param:mail}           |\r\n// +------------------------+\r\n// Simple email path parameter validation.\r\n\r\n// http://localhost:8080/user/kataras2006@hotmail.com    -> OK\r\n// http://localhost:8080/user/b-c@invalid_domainxxx1.com -> NOT FOUND\r\napp.Get(\"/user/{local_email:mail}\", func(ctx iris.Context) {\r\n    email := ctx.Params().Get(\"local_email\")\r\n    ctx.WriteString(email)\r\n})\r\n```\r\n\r\n- New `iris.IsErrEmptyJSON(err) bool` which reports whether the given \"err\" is caused by a\r\n`Context.ReadJSON` call when the request body didn't start with { (or it was totally empty). \r\n\r\nExample Code:\r\n\r\n```go\r\nfunc handler(ctx iris.Context) {\r\n    var opts SearchOptions\r\n    if err := ctx.ReadJSON(&opts); err != nil && !iris.IsErrEmptyJSON(err) {\r\n        ctx.StopWithJSON(iris.StatusBadRequest, iris.Map{\"message\": \"unable to parse body\"})\r\n        return\r\n    }\r\n\r\n    // [...continue with default values of \"opts\" struct if the client didn't provide some]\r\n}\r\n```\r\n\r\nThat means that the client can optionally set a JSON body.\r\n\t\r\n- New `APIContainer.EnableStrictMode(bool)` to disable automatic payload binding and panic on missing dependencies for exported struct'sfields or function's input parameters on MVC controller or hero function or PartyConfigurator.\r\n\r\n- New `Party.PartyConfigure(relativePath string, partyReg ...PartyConfigurator) Party` helper, registers a children Party like `Party` and `PartyFunc` but instead it accepts a structure value which may contain one or more of the dependencies registered by `RegisterDependency` or `ConfigureContainer().RegisterDependency` methods and fills the unset/zero exported struct's fields respectfully (useful when the api's dependencies amount are too much to pass on a function).\r\n\r\n- **New feature:** add the ability to set custom error handlers on path type parameters errors (existing or custom ones). Example Code:\r\n\r\n```go\r\napp.Macros().Get(\"uuid\").HandleError(func(ctx iris.Context, paramIndex int, err error) {\r\n    ctx.StatusCode(iris.StatusBadRequest)\r\n\r\n    param := ctx.Params().GetEntryAt(paramIndex)\r\n    ctx.JSON(iris.Map{\r\n        \"error\":     err.Error(),\r\n        \"message\":   \"invalid path parameter\",\r\n        \"parameter\": param.Key,\r\n        \"value\":     param.ValueRaw,\r\n    })\r\n})\r\n\r\napp.Get(\"/users/{id:uuid}\", getUser)\r\n```\r\n\r\n- Improve the performance and fix `:int, :int8, :int16, :int32, :int64, :uint, :uint8, :uint16, :uint32, :uint64` path type parameters couldn't accept a positive number written with the plus symbol or with a leading zeroes, e.g. `+42` and `021`.\r\n\r\n- The `iris.WithEmptyFormError` option is respected on `context.ReadQuery` method too, as requested at [#1727](https://github.com/kataras/iris/issues/1727). [Example comments](https://github.com/kataras/iris/blob/master/_examples/request-body/read-query/main.go) were updated.\r\n\r\n- New `httptest.Strict` option setter to enable the `httpexpect.RequireReporter` instead of the default `httpexpect.AssetReporter. Use that to enable complete test failure on the first error. As requested at: [#1722](https://github.com/kataras/iris/issues/1722).\r\n\r\n- New `uuid` builtin path parameter type. Example:\r\n\r\n```go\r\n// +------------------------+\r\n// | {param:uuid}           |\r\n// +------------------------+\r\n// UUIDv4 (and v1) path parameter validation.\r\n\r\n// http://localhost:8080/user/bb4f33e4-dc08-40d8-9f2b-e8b2bb615c0e -> OK\r\n// http://localhost:8080/user/dsadsa-invalid-uuid                  -> NOT FOUND\r\napp.Get(\"/user/{id:uuid}\", func(ctx iris.Context) {\r\n    id := ctx.Params().Get(\"id\")\r\n    ctx.WriteString(id)\r\n})\r\n```\r\n\r\n- New `Configuration.KeepAlive` and `iris.WithKeepAlive(time.Duration) Configurator` added as helpers to start the server using a tcp listener featured with keep-alive.\r\n\r\n- New `DirOptions.ShowHidden bool` is added by [@tuhao1020](https://github.com/tuhao1020) at [PR #1717](https://github.com/kataras/iris/pull/1717) to show or hide the hidden files when `ShowList` is set to true.\r\n\r\n- New `Context.ReadJSONStream` method and `JSONReader` options for `Context.ReadJSON` and `Context.ReadJSONStream`, see the [example](_examples/request-body/read-json-stream/main.go).\r\n\r\n- New `FallbackView` feature, per-party or per handler chain. Example can be found at: [_examples/view/fallback](_examples/view/fallback).\r\n\r\n```go\r\n    app.FallbackView(iris.FallbackViewFunc(func(ctx iris.Context, err iris.ErrViewNotExist) error {\r\n        // err.Name is the previous template name.\r\n        // err.IsLayout reports whether the failure came from the layout template.\r\n        // err.Data is the template data provided to the previous View call.\r\n        // [...custom logic e.g. ctx.View(\"fallback.html\", err.Data)]\r\n        return err\r\n    }))\r\n```\r\n\r\n- New `versioning.Aliases` middleware and up to 80% faster version resolve. Example Code:\r\n\r\n```go\r\napp := iris.New()\r\n\r\napi := app.Party(\"/api\")\r\napi.Use(Aliases(map[string]string{\r\n    versioning.Empty: \"1\", // when no version was provided by the client.\r\n    \"beta\": \"4.0.0\",\r\n    \"stage\": \"5.0.0-alpha\"\r\n}))\r\n\r\nv1 := NewGroup(api, \">=1.0.0 <2.0.0\")\r\nv1.Get/Post...\r\n\r\nv4 := NewGroup(api, \">=4.0.0 <5.0.0\")\r\nv4.Get/Post...\r\n\r\nstage := NewGroup(api, \"5.0.0-alpha\")\r\nstage.Get/Post...\r\n```\r\n\r\n- New [Basic Authentication](https://github.com/kataras/iris/tree/master/middleware/basicauth) middleware. Its `Default` function has not changed, however, the rest, e.g. `New` contains breaking changes as the new middleware features new functionalities.\r\n- Add `iris.DirOptions.SPA bool` field to allow [Single Page Applications](https://github.com/kataras/iris/tree/master/_examples/file-server/single-page-application/basic/main.go) under a file server.\r\n- A generic User interface, see the `Context.SetUser/User` methods in the New Context Methods section for more. In-short, the basicauth middleware's stored user can now be retrieved through `Context.User()` which provides more information than the native `ctx.Request().BasicAuth()` method one. Third-party authentication middleware creators can benefit of these two methods, plus the Logout below. \r\n- A `Context.Logout` method is added, can be used to invalidate [basicauth](https://github.com/kataras/iris/blob/master/_examples/auth/basicauth/basic/main.go) or [jwt](https://github.com/kataras/iris/blob/master/_examples/auth/jwt/blocklist/main.go) client credentials.\r\n- Add the ability to [share functions](https://github.com/kataras/iris/tree/master/_examples/routing/writing-a-middleware/share-funcs) between handlers chain and add an [example](https://github.com/kataras/iris/tree/master/_examples/routing/writing-a-middleware/share-services) on sharing Go structures (aka services).\r\n\r\n- Add the new `Party.UseOnce` method to the `*Route`\r\n- Add a new `*Route.RemoveHandler(...interface{}) int` and `Party.RemoveHandler(...interface{}) Party` methods, delete a handler based on its name or the handler pc function.\r\n\r\n```go\r\nfunc middleware(ctx iris.Context) {\r\n    // [...]\r\n}\r\n\r\nfunc main() {\r\n    app := iris.New()\r\n\r\n    // Register the middleware to all matched routes.\r\n    app.Use(middleware)\r\n\r\n    // Handlers = middleware, other\r\n    app.Get(\"/\", index)\r\n\r\n    // Handlers = other\r\n    app.Get(\"/other\", other).RemoveHandler(middleware)\r\n}\r\n```\r\n\r\n- Redis Driver is now based on the [go-redis](https://github.com/go-redis/redis/) module. Radix and redigo removed entirely. Sessions are now stored in hashes which fixes [issue #1610](https://github.com/kataras/iris/issues/1610). The only breaking change on default configuration is that the `redis.Config.Delim` option was removed. The redis sessions database driver is now defaults to the `&redis.GoRedisDriver{}`. End-developers can implement their own implementations too. The `Database#Close` is now automatically called on interrupt signals, no need to register it by yourself.\r\n\r\n- Add builtin support for **[i18n pluralization](https://github.com/kataras/iris/tree/master/_examples/i18n/plurals)**. Please check out the [following yaml locale example](https://github.com/kataras/iris/tree/master/_examples/i18n/plurals/locales/en-US/welcome.yml) to see an overview of the supported formats.\r\n- Fix [#1650](https://github.com/kataras/iris/issues/1650)\r\n- Fix [#1649](https://github.com/kataras/iris/issues/1649)\r\n- Fix [#1648](https://github.com/kataras/iris/issues/1648)\r\n- Fix [#1641](https://github.com/kataras/iris/issues/1641)\r\n\r\n- Add `Party.SetRoutesNoLog(disable bool) Party` to disable (the new) verbose logging of next routes.\r\n- Add `mvc.Application.SetControllersNoLog(disable bool) *mvc.Application` to disable (the new) verbose logging of next controllers. As requested at [#1630](https://github.com/kataras/iris/issues/1630).\r\n\r\n- Fix [#1621](https://github.com/kataras/iris/issues/1621) and add a new `cache.WithKey` to customize the cached entry key.\r\n\r\n- Add a `Response() *http.Response` to the Response Recorder.\r\n- Fix Response Recorder `Flush` when transfer-encoding is `chunked`.\r\n- Fix Response Recorder `Clone` concurrent access afterwards.\r\n\r\n- Add a `ParseTemplate` method on view engines to manually parse and add a template from a text as [requested](https://github.com/kataras/iris/issues/1617). [Examples](https://github.com/kataras/iris/tree/master/_examples/view/parse-template).\r\n- Full `http.FileSystem` interface support for all **view** engines as [requested](https://github.com/kataras/iris/issues/1575). The first argument of the functions(`HTML`, `Blocks`, `Pug`, `Amber`, `Ace`, `Jet`, `Django`, `Handlebars`) can now be either a directory of `string` type (like before) or a value which completes the `http.FileSystem` interface. The `.Binary` method of all view engines was removed: pass the go-bindata's latest version `AssetFile()` exported function as the first argument instead of string.\r\n\r\n- Add `Route.ExcludeSitemap() *Route` to exclude a route from sitemap as requested in [chat](https://chat.iris-go.com), also offline routes are excluded automatically now.\r\n\r\n- Improved tracing (with `app.Logger().SetLevel(\"debug\")`) for routes. Screens:\r\n\r\n#### DBUG Routes (1)\r\n\r\n![DBUG routes 1](https://iris-go.com/images/v12.2.0-dbug.png?v=0)\r\n\r\n#### DBUG Routes (2)\r\n\r\n![DBUG routes 2](https://iris-go.com/images/v12.2.0-dbug2.png?v=0)\r\n\r\n#### DBUG Routes (3)\r\n\r\n![DBUG routes with Controllers](https://iris-go.com/images/v12.2.0-dbug3.png?v=0)\r\n\r\n- Update the [pprof middleware](https://github.com/kataras/iris/tree/master/middleware/pprof).\r\n\r\n- New `Controller.HandleHTTPError(mvc.Code) <T>` optional Controller method to handle http errors as requested at: [MVC - More Elegent OnErrorCode registration?](https://github.com/kataras/iris/issues/1595). Example can be found [here](https://github.com/kataras/iris/tree/master/_examples/mvc/error-handler-http/main.go).\r\n\r\n![MVC: HTTP Error Handler Method](https://user-images.githubusercontent.com/22900943/90948989-e04cd300-e44c-11ea-8c97-54d90fb0cbb6.png)\r\n\r\n- New [Rewrite Engine Middleware](https://github.com/kataras/iris/tree/master/middleware/rewrite). Set up redirection rules for path patterns using the syntax we all know. [Example Code](https://github.com/kataras/iris/tree/master/_examples/routing/rewrite).\r\n\r\n```yml\r\nRedirectMatch: # REDIRECT_CODE_DIGITS | PATTERN_REGEX | TARGET_REPL\r\n  # Redirects /seo/* to /*\r\n  - 301 /seo/(.*) /$1\r\n\r\n  # Redirects /docs/v12* to /docs\r\n  - 301 /docs/v12(.*) /docs\r\n\r\n  # Redirects /old(.*) to /\r\n  - 301 /old(.*) /\r\n\r\n  # Redirects http or https://test.* to http or https://newtest.*\r\n  - 301 ^(http|https)://test.(.*) $1://newtest.$2\r\n\r\n  # Handles /*.json or .xml as *?format=json or xml,\r\n  # without redirect. See /users route.\r\n  # When Code is 0 then it does not redirect the request,\r\n  # instead it changes the request URL\r\n  # and leaves a route handle the request.\r\n  - 0 /(.*).(json|xml) /$1?format=$2\r\n\r\n# Redirects root domain to www.\r\n# Creation of a www subdomain inside the Application is unnecessary,\r\n# all requests are handled by the root Application itself.\r\nPrimarySubdomain: www\r\n```\r\n\r\n- New `TraceRoute bool` on [middleware/logger](https://github.com/kataras/iris/tree/master/middleware/logger) middleware. Displays information about the executed route. Also marks the handlers executed. Screenshot:\r\n\r\n![logger middleware: TraceRoute screenshot](https://iris-go.com/images/github/logger-trace-route.png)\r\n\r\n- Implement feature request [Log when I18n Translation Fails?](https://github.com/kataras/iris/issues/1593) by using the new `Application.I18n.DefaultMessageFunc` field **before** `I18n.Load`. [Example of usage](https://github.com/kataras/iris/blob/master/_examples/i18n/basic/main.go#L28-L50).\r\n\r\n- Fix [#1594](https://github.com/kataras/iris/issues/1594) and add a new `PathAfterHandler` which can be set to true to enable the old behavior (not recommended though).\r\n\r\n- New [apps](https://github.com/kataras/iris/tree/master/apps) subpackage. [Example of usage](https://github.com/kataras/iris/tree/master/_examples/routing/subdomains/redirect/multi-instances).\r\n\r\n![apps image example](https://user-images.githubusercontent.com/22900943/90459288-8a54f400-e109-11ea-8dea-20631975c9fc.png)\r\n\r\n- Fix `AutoTLS` when used with `iris.TLSNoRedirect` [*](https://github.com/kataras/iris/issues/1577). The `AutoTLS` runner can be customized through the new `iris.AutoTLSNoRedirect` instead, read its go documentation. Example of having both TLS and non-TLS versions of the same application without conflicts with letsencrypt `./well-known` path:\r\n\r\n![](https://iris-go.com/images/github/autotls-1.png)\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"net/http\"\r\n\t\"time\"\r\n\r\n\t\"github.com/kataras/iris/v12\"\r\n)\r\n\r\nfunc main() {\r\n\tapp := iris.New()\r\n\tapp.Logger().SetLevel(\"debug\")\r\n\r\n\tapp.Get(\"/\", func(ctx iris.Context) {\r\n\t\tctx.JSON(iris.Map{\r\n\t\t\t\"time\": time.Now().Unix(),\r\n\t\t\t\"tls\":  ctx.Request().TLS != nil,\r\n\t\t})\r\n\t})\r\n\r\n\tvar fallbackServer = func(acme func(http.Handler) http.Handler) *http.Server {\r\n\t\tsrv := &http.Server{Handler: acme(app)}\r\n\t\tgo srv.ListenAndServe()\r\n\t\treturn srv\r\n\t}\r\n\r\n\tapp.Run(iris.AutoTLS(\":443\", \"example.com\", \"mail@example.com\",\r\n\t\tiris.AutoTLSNoRedirect(fallbackServer)))\r\n}\r\n```\r\n\r\n- `iris.Minify` middleware to minify responses based on their media/content-type.\r\n\r\n- `Context.OnCloseErr` and `Context.OnConnectionCloseErr` - to call a function of `func() error`  instead of an `iris.Handler` when request is closed or manually canceled.\r\n\r\n- `Party.UseError(...Handler)` - to register handlers to run before any http errors (e.g. before `OnErrorCode/OnAnyErrorCode` or default error codes when no handler is responsible to handle a specific http status code).\r\n\r\n- `Party.UseRouter(...Handler) and Party.ResetRouterFilters()` - to register handlers before the main router, useful on handlers that should control whether the router itself should ran or not. Independently of the incoming request's method and path values. These handlers will be executed ALWAYS against ALL incoming matched requests. Example of use-case: CORS.\r\n\r\n- `*versioning.Group` type is a full `Party` now.\r\n\r\n- `Party.UseOnce` - either inserts a middleware, or on the basis of the middleware already existing, replace that existing middleware instead.\r\n\r\n- Ability to register a view engine per group of routes or for the current chain of handlers through `Party.RegisterView` and `Context.ViewEngine` respectfully.\r\n\r\n- Add [Blocks](_examples/view/template_blocks_0) template engine. <!-- Reminder for @kataras: follow https://github.com/flosch/pongo2/pull/236#issuecomment-668950566 discussion so we can get back on using the original pongo2 repository as they fixed the issue about an incompatible 3rd party package (although they need more fixes, that's why I commented there) -->\r\n\r\n- Add [Ace](_examples/view/template_ace_0) template parser to the view engine and other minor improvements.\r\n\r\n- Fix huge repo size of 55.7MB, which slows down the overall Iris installation experience. Now, go-get performs ~3 times faster. I 've managed it using the [bfg-repo-cleaner](https://github.com/rtyley/bfg-repo-cleaner) tool - an alternative to  git-filter-branch command. Watch the small gif below to learn how:\r\n\r\n[![](https://media.giphy.com/media/U8560aiWTurW4iAOLn/giphy.gif)](https://media.giphy.com/media/U8560aiWTurW4iAOLn/giphy.gif)\r\n\r\n- [gRPC](https://grpc.io/) features:\r\n    - New Router [Wrapper](middleware/grpc).\r\n    - New MVC `.Handle(ctrl, mvc.GRPC{...})` option which allows to register gRPC services per-party (without the requirement of a full wrapper) and optionally strict access to gRPC clients only, see the [example here](_examples/mvc/grpc-compatible).\r\n\r\n- Add `Configuration.RemoteAddrHeadersForce bool` to force `Context.RemoteAddr() string` to return the first entry of request headers as a fallback instead of the `Request.RemoteAddr` one, as requested at: [1567#issuecomment-663972620](https://github.com/kataras/iris/issues/1567#issuecomment-663972620).\r\n\r\n- Fix [#1569#issuecomment-663739177](https://github.com/kataras/iris/issues/1569#issuecomment-663739177).\r\n\r\n- Fix [#1564](https://github.com/kataras/iris/issues/1564).\r\n\r\n- Fix [#1553](https://github.com/kataras/iris/issues/1553).\r\n\r\n- New `DirOptions.Cache` to cache assets in-memory among with their compressed contents (in order to be ready to served if client ask). Learn more about this feature by reading [all #1556 comments](https://github.com/kataras/iris/issues/1556#issuecomment-661057446). Usage:\r\n\r\n```go\r\nvar dirOpts = DirOptions{\r\n    // [...other options]\r\n    Cache: DirCacheOptions{\r\n        Enable: true,\r\n        // Don't compress files smaller than 300 bytes.\r\n        CompressMinSize: 300,\r\n        // Ignore compress already compressed file types\r\n        // (some images and pdf).\r\n        CompressIgnore: iris.MatchImagesAssets,\r\n        // Gzip, deflate, br(brotli), snappy.\r\n        Encodings: []string{\"gzip\", \"deflate\", \"br\", \"snappy\"},\r\n        // Log to the stdout the total reduced file size.\r\n        Verbose: 1,\r\n    },\r\n}\r\n```\r\n\r\n- New `DirOptions.PushTargets` and `PushTargetsRegexp` to push index' assets to the client without additional requests. Inspirated by issue [#1562](https://github.com/kataras/iris/issues/1562). Example matching all `.js, .css and .ico` files (recursively):\r\n\r\n```go\r\nvar dirOpts = iris.DirOptions{\r\n    // [...other options]\r\n    IndexName: \"/index.html\",\r\n    PushTargetsRegexp: map[string]*regexp.Regexp{\r\n        \"/\": regexp.MustCompile(\"((.*).js|(.*).css|(.*).ico)$\"),\r\n        // OR:\r\n        // \"/\": iris.MatchCommonAssets,\r\n    },\r\n    Compress: true,\r\n}\r\n```\r\n\r\n- Update jet parser to v5.0.2, closes [#1551](https://github.com/kataras/iris/issues/1551). It contains two breaking changes by its author:\r\n    - Relative paths on `extends, import, include...` tmpl functions, e.g. `{{extends \"../layouts/application.jet\"}}` instead of `layouts/application.jet`\r\n    - the new [jet.Ranger](https://github.com/CloudyKit/jet/pull/165) interface now requires a `ProvidesIndex() bool` method too\r\n    - Example has been [updated](https://github.com/kataras/iris/tree/master/_examples/view/template_jet_0)\r\n\r\n- Fix [#1552](https://github.com/kataras/iris/issues/1552).\r\n\r\n- Proper listing of root directories on `Party.HandleDir` when its `DirOptions.ShowList` was set to true.\r\n    - Customize the file/directory listing page through views, see [example](https://github.com/kataras/iris/tree/master/_examples/file-server/file-server).\r\n\r\n- Socket Sharding as requested at [#1544](https://github.com/kataras/iris/issues/1544). New `iris.WithSocketSharding` Configurator and `SocketSharding bool` setting.\r\n\r\n- Versioned Controllers feature through the new `mvc.Version` option. See [_examples/mvc/versioned-controller](https://github.com/kataras/iris/blob/master/_examples/mvc/versioned-controller/main.go).\r\n\r\n- Fix [#1539](https://github.com/kataras/iris/issues/1539).\r\n\r\n- New [rollbar example](https://github.com/kataras/iris/blob/master/_examples/logging/rollbar/main.go).\r\n\r\n- New builtin [requestid](https://github.com/kataras/iris/tree/master/middleware/requestid) middleware.\r\n\r\n- New builtin [JWT](https://github.com/kataras/iris/tree/master/middleware/jwt) middleware based on the fastest JWT implementation; [kataras/jwt](https://github.com/kataras/jwt) featured with optional wire encryption to set claims with sensitive data when necessary.\r\n\r\n- New `iris.RouteOverlap` route registration rule. `Party.SetRegisterRule(iris.RouteOverlap)` to allow overlapping across multiple routes for the same request subdomain, method, path. See [1536#issuecomment-643719922](https://github.com/kataras/iris/issues/1536#issuecomment-643719922). This allows two or more **MVC Controllers** to listen on the same path based on one or more registered dependencies (see [_examples/mvc/authenticated-controller](https://github.com/kataras/iris/tree/master/_examples/mvc/authenticated-controller)).\r\n\r\n- `Context.ReadForm` now can return an `iris.ErrEmptyForm` instead of `nil` when the new `Configuration.FireEmptyFormError` is true  (when `iris.WithEmptyFormError` is set) on missing form body to read from.\r\n\r\n- `Configuration.EnablePathIntelligence | iris.WithPathIntelligence` to enable path intelligence automatic path redirection on the most closest path (if any), [example]((https://github.com/kataras/iris/blob/master/_examples/routing/intelligence/main.go)\r\n\r\n- Enhanced cookie security and management through new `Context.AddCookieOptions` method and new cookie options (look on New Package-level functions section below), [securecookie](https://github.com/kataras/iris/tree/master/_examples/cookies/securecookie) example has been updated.\r\n- `Context.RemoveCookie` removes also the Request's specific cookie of the same request lifecycle when `iris.CookieAllowReclaim` is set to cookie options, [example](https://github.com/kataras/iris/tree/master/_examples/cookies/options).\r\n\r\n- `iris.TLS` can now accept certificates in form of raw `[]byte` contents too.\r\n- `iris.TLS` registers a secondary http server which redirects \"http://\" to their \"https://\" equivalent requests, unless the new `iris.TLSNoRedirect` host Configurator is provided on `iris.TLS`, e.g. `app.Run(iris.TLS(\"127.0.0.1:443\", \"mycert.cert\", \"mykey.key\", iris.TLSNoRedirect))`. There is `iris.AutoTLSNoRedirect` option for `AutoTLS` too.\r\n\r\n- Fix an [issue](https://github.com/kataras/i18n/issues/1) about i18n loading from path which contains potential language code.\r\n\r\n- Server will not return neither log the `ErrServerClosed` error if `app.Shutdown` was called manually via interrupt signal(CTRL/CMD+C), note that if the server closed by any other reason the error will be fired as previously (unless `iris.WithoutServerError(iris.ErrServerClosed)`).\r\n\r\n- Finally, Log level's and Route debug information colorization is respected across outputs. Previously if the application used more than one output destination (e.g. a file through `app.Logger().AddOutput`) the color support was automatically disabled from all, including the terminal one, this problem is fixed now. Developers can now see colors in their terminals while log files are kept with clear text.\r\n\r\n- New `iris.WithLowercaseRouting` option which forces all routes' paths to be lowercase and converts request paths to their lowercase for matching.\r\n\r\n- New `app.Validator { Struct(interface{}) error }` field and `app.Validate` method were added. The `app.Validator = ` can be used to integrate a 3rd-party package such as [go-playground/validator](https://github.com/go-playground/validator). If set-ed then Iris `Context`'s `ReadJSON`, `ReadXML`, `ReadMsgPack`, `ReadYAML`, `ReadForm`, `ReadQuery`, `ReadBody` methods will return the validation error on data validation failures. The [read-json-struct-validation](_examples/request-body/read-json-struct-validation) example was updated.\r\n\r\n- A result of <T> can implement the new `hero.PreflightResult` interface which contains a single method of `Preflight(iris.Context) error`. If this method exists on a custom struct value which is returned from a handler then it will fire that `Preflight` first and if not errored then it will cotninue by sending the struct value as JSON(by-default) response body.\r\n\r\n- `ctx.JSON, JSONP, XML`: if `iris.WithOptimizations` is NOT passed on `app.Run/Listen` then the indentation defaults to `\"    \"` (four spaces) and `\"  \"` respectfully otherwise it is empty or the provided value.\r\n\r\n- Hero Handlers (and `app.ConfigureContainer().Handle`) do not have to require `iris.Context` just to call `ctx.Next()` anymore, this is done automatically now.\r\n\r\n- Improve Remote Address parsing as requested at: [#1453](https://github.com/kataras/iris/issues/1453). Add `Configuration.RemoteAddrPrivateSubnets` to exclude those addresses when fetched by `Configuration.RemoteAddrHeaders` through `context.RemoteAddr() string`.\r\n\r\n- Fix [#1487](https://github.com/kataras/iris/issues/1487).\r\n\r\n- Fix [#1473](https://github.com/kataras/iris/issues/1473).\r\n\r\n## New Package-level Variables\r\n\r\n- `iris.DirListRichOptions` to pass on `iris.DirListRich` method.\r\n- `iris.DirListRich` to override the default look and feel if the `DirOptions.ShowList` was set to true, can be passed to `DirOptions.DirList` field.\r\n- `DirOptions.PushTargets` for http/2 push on index [*](https://github.com/kataras/iris/tree/master/_examples/file-server/http2push/main.go).\r\n- `iris.Compression` middleware to compress responses and decode compressed request data respectfully.\r\n- `iris.B, KB, MB, GB, TB, PB, EB` for byte units.\r\n- `TLSNoRedirect` to disable automatic \"http://\" to \"https://\" redirections (see below)\r\n- `CookieAllowReclaim`, `CookieAllowSubdomains`, `CookieSameSite`, `CookieSecure` and `CookieEncoding` to bring previously sessions-only features to all cookies in the request.\r\n\r\n## New Context Methods\r\n\r\n- `Context.FormFiles(key string, before ...func(*Context, *multipart.FileHeader) bool) (files []multipart.File, headers []*multipart.FileHeader, err error)` method.\r\n- `Context.ReadURL(ptr interface{}) error` shortcut of `ReadParams` and `ReadQuery`. Binds URL dynamic path parameters and URL query parameters to the given \"ptr\" pointer of a struct value.\r\n- `Context.SetUser(User)` and `Context.User() User` to store and retrieve an authenticated client. Read more [here](https://github.com/iris-contrib/middleware/issues/63).\r\n- `Context.SetLogoutFunc(fn interface{}, persistenceArgs ...interface{})` and `Logout(args ...interface{}) error` methods to allow different kind of auth middlewares to be able to set a \"logout\" a user/client feature with a single function, the route handler may not be aware of the implementation of the authentication used.\r\n- `Context.SetFunc(name string, fn interface{}, persistenceArgs ...interface{})` and `Context.CallFunc(name string, args ...interface{}) ([]reflect.Value, error)` to allow middlewares to share functions dynamically when the type of the function is not predictable, see the [example](https://github.com/kataras/iris/tree/master/_examples/routing/writing-a-middleware/share-funcs) for more.\r\n- `Context.TextYAML(interface{}) error` same as `Context.YAML` but with set the Content-Type to `text/yaml` instead (Google Chrome renders it as text). \r\n- `Context.IsDebug() bool` reports whether the application is running under debug/development mode. It is a shortcut of Application.Logger().Level >= golog.DebugLevel.\r\n- `Context.IsRecovered() bool` reports whether the current request was recovered from the [recover middleware](https://github.com/kataras/iris/tree/master/middleware/recover). Also the `Context.GetErrPublic() (bool, error)`, `Context.SetErrPrivate(err error)` methods and `iris.ErrPrivate` interface have been introduced. \r\n- `Context.RecordRequestBody(bool)` same as the Application's `DisableBodyConsumptionOnUnmarshal` configuration field but registers per chain of handlers. It makes the request body readable more than once.\r\n- `Context.IsRecordingBody() bool` reports whether the request body can be readen multiple times.\r\n- `Context.ReadHeaders(ptr interface{}) error` binds request headers to \"ptr\". [Example](https://github.com/kataras/iris/blob/master/_examples/request-body/read-headers/main.go).\r\n- `Context.ReadParams(ptr interface{}) error` binds dynamic path parameters to \"ptr\". [Example](https://github.com/kataras/iris/blob/master/_examples/request-body/read-params/main.go).\r\n- `Context.SaveFormFile(fh *multipart.FileHeader, dest string) (int64, error)` previously unexported. Accepts a result file of `Context.FormFile` and saves it to the disk.\r\n- `Context.URLParamSlice(name string) []string` is a a shortcut of `ctx.Request().URL.Query()[name]`. Like `URLParam` but it returns all values as a string slice instead of a single string separated by commas. Note that it skips any empty values (e.g. https://iris-go.com?values=).\r\n- `Context.PostValueMany(name string) (string, error)` returns the post data of a given key. The returned value is a single string separated by commas on multiple values. It also reports whether the form was empty or when the \"name\" does not exist or whether the available values are empty. It strips any empty key-values from the slice before return. See `ErrEmptyForm`, `ErrNotFound` and `ErrEmptyFormField` respectfully. The `PostValueInt`, `PostValueInt64`, `PostValueFloat64` and `PostValueBool` now respect the above errors too (the `PostValues` method now returns a second output argument of `error` too, see breaking changes below). \r\n- `Context.URLParamsSorted() []memstore.StringEntry` returns a sorted (by key) slice of key-value entries of the URL Query parameters.\r\n- `Context.ViewEngine(ViewEngine)` to set a view engine on-fly for the current chain of handlers, responsible to render templates through `ctx.View`. [Example](_examples/view/context-view-engine).\r\n- `Context.SetErr(error)` and `Context.GetErr() error` helpers.\r\n- `Context.CompressWriter(bool) error` and `Context.CompressReader(bool) error`.\r\n- `Context.Clone() Context` returns a copy of the Context safe for concurrent access.\r\n- `Context.IsCanceled() bool` reports whether the request has been canceled by the client.\r\n- `Context.IsSSL() bool` reports whether the request is under HTTPS SSL (New `Configuration.SSLProxyHeaders` and `HostProxyHeaders` fields too).\r\n- `Context.CompressReader(enable bool)` method and `iris.CompressReader` middleware to enable future request read body calls to decompress data, [example](_examples/compression/main.go).\r\n- `Context.RegisterDependency(v interface{})` and `Context.UnregisterDependency(typ reflect.Type)` to register/remove struct dependencies on serve-time through a middleware.\r\n- `Context.SetID(id interface{})` and `Context.GetID() interface{}` added to register a custom unique indetifier to the Context, if necessary.\r\n- `Context.Scheme() string` returns the full scheme of the request URL.\r\n- `Context.SubdomainFull() string` returns the full subdomain(s) part of the host (`host[0:rootLevelDomain]`).\r\n- `Context.Domain() string` returns the root level domain.\r\n- `Context.AddCookieOptions(...CookieOption)` adds options for `SetCookie`, `SetCookieKV, UpsertCookie` and `RemoveCookie` methods for the current request.\r\n- `Context.ClearCookieOptions()` clears any cookie options registered through `AddCookieOptions`.\r\n- `Context.SetLanguage(langCode string)` force-sets a language code from inside a middleare, similar to the `app.I18n.ExtractFunc`\r\n- `Context.ServeContentWithRate`, `ServeFileWithRate` and `SendFileWithRate` methods to throttle the \"download\" speed of the client\r\n- `Context.IsHTTP2() bool` reports whether the protocol version for incoming request was HTTP/2\r\n- `Context.IsGRPC() bool` reports whether the request came from a gRPC client\r\n- `Context.UpsertCookie(*http.Cookie, cookieOptions ...context.CookieOption)` upserts a cookie, fixes [#1485](https://github.com/kataras/iris/issues/1485) too\r\n- `Context.StopWithStatus(int)` stops the handlers chain and writes the status code\r\n- `StopWithText(statusCode int, format string, args ...interface{})` stops the handlers chain, writes thre status code and a plain text message\r\n- `Context.StopWithError(int, error)` stops the handlers chain, writes thre status code and the error's message\r\n- `Context.StopWithJSON(int, interface{})` stops the handlers chain, writes the status code and sends a JSON response\r\n- `Context.StopWithProblem(int, iris.Problem)` stops the handlers, writes the status code and sends an `application/problem+json` response\r\n- `Context.Protobuf(proto.Message)` sends protobuf to the client (note that the `Context.JSON` is able to send protobuf as JSON)\r\n- `Context.MsgPack(interface{})` sends msgpack format data to the client\r\n- `Context.ReadProtobuf(ptr)` binds request body to a proto message\r\n- `Context.ReadJSONProtobuf(ptr, ...options)` binds JSON request body to a proto message\r\n- `Context.ReadMsgPack(ptr)` binds request body of a msgpack format to a struct\r\n- `Context.ReadBody(ptr)` binds the request body to the \"ptr\" depending on the request's Method and Content-Type\r\n- `Context.ReflectValue() []reflect.Value` stores and returns the `[]reflect.ValueOf(ctx)`\r\n- `Context.Controller() reflect.Value` returns the current MVC Controller value.\r\n\r\n## MVC & Dependency Injection\r\n\r\nThe new release contains a fresh new and awesome feature....**a function dependency can accept previous registered dependencies and update or return a new value of any type**.\r\n\r\nThe new implementation is **faster** on both design and serve-time.\r\n\r\nThe most common scenario from a route to handle is to:\r\n- accept one or more path parameters and request data, a payload\r\n- send back a response, a payload (JSON, XML,...)\r\n\r\nThe new Iris Dependency Injection feature is about **33.2% faster** than its predecessor on the above case. This drops down even more the performance cost between native handlers and dynamic handlers with dependencies. This reason itself brings us, with safety and performance-wise, to the new `Party.ConfigureContainer(builder ...func(*iris.APIContainer)) *APIContainer` method which returns methods such as `Handle(method, relativePath string, handlersFn ...interface{}) *Route` and `RegisterDependency`.\r\n\r\nLook how clean your codebase can be when using Iris':\r\n\r\n```go\r\npackage main\r\n\r\nimport \"github.com/kataras/iris/v12\"\r\n\r\ntype (\r\n    testInput struct {\r\n        Email string `json:\"email\"`\r\n    }\r\n\r\n    testOutput struct {\r\n        ID   int    `json:\"id\"`\r\n        Name string `json:\"name\"`\r\n    }\r\n)\r\n\r\nfunc handler(id int, in testInput) testOutput {\r\n    return testOutput{\r\n        ID:   id,\r\n        Name: in.Email,\r\n    }\r\n}\r\n\r\nfunc main() {\r\n    app := iris.New()\r\n    app.ConfigureContainer(func(api *iris.APIContainer) {\r\n        api.Post(\"/{id:int}\", handler)\r\n    })\r\n    app.Listen(\":5000\", iris.WithOptimizations)\r\n}\r\n```\r\n\r\nYour eyes don't lie you. You read well, no `ctx.ReadJSON(&v)` and `ctx.JSON(send)` neither `error` handling are presented. It is a huge relief but if you ever need, you still have the control over those, even errors from dependencies. Here is a quick list of the new Party.ConfigureContainer()'s fields and methods:\r\n\r\n```go\r\n// Container holds the DI Container of this Party featured Dependency Injection.\r\n// Use it to manually convert functions or structs(controllers) to a Handler.\r\nContainer *hero.Container\r\n```\r\n\r\n```go\r\n// OnError adds an error handler for this Party's DI Hero Container and its handlers (or controllers).\r\n// The \"errorHandler\" handles any error may occurred and returned\r\n// during dependencies injection of the Party's hero handlers or from the handlers themselves.\r\nOnError(errorHandler func(iris.Context, error))\r\n```\r\n\r\n```go\r\n// RegisterDependency adds a dependency.\r\n// The value can be a single struct value or a function.\r\n// Follow the rules:\r\n// * <T> {structValue}\r\n// * func(accepts <T>)                                 returns <D> or (<D>, error)\r\n// * func(accepts iris.Context)                        returns <D> or (<D>, error)\r\n//\r\n// A Dependency can accept a previous registered dependency and return a new one or the same updated.\r\n// * func(accepts1 <D>, accepts2 <T>)                  returns <E> or (<E>, error) or error\r\n// * func(acceptsPathParameter1 string, id uint64)     returns <T> or (<T>, error)\r\n//\r\n// Usage:\r\n//\r\n// - RegisterDependency(loggerService{prefix: \"dev\"})\r\n// - RegisterDependency(func(ctx iris.Context) User {...})\r\n// - RegisterDependency(func(User) OtherResponse {...})\r\nRegisterDependency(dependency interface{})\r\n\r\n// UseResultHandler adds a result handler to the Container.\r\n// A result handler can be used to inject the returned struct value\r\n// from a request handler or to replace the default renderer.\r\nUseResultHandler(handler func(next iris.ResultHandler) iris.ResultHandler)\r\n```\r\n\r\n<details><summary>ResultHandler</summary>\r\n\r\n```go\r\ntype ResultHandler func(ctx iris.Context, v interface{}) error\r\n```\r\n</details>\r\n\r\n```go\r\n// Use same as a common Party's \"Use\" but it accepts dynamic functions as its \"handlersFn\" input.\r\nUse(handlersFn ...interface{})\r\n// Done same as a common Party's but it accepts dynamic functions as its \"handlersFn\" input.\r\nDone(handlersFn ...interface{})\r\n```\r\n\r\n```go\r\n// Handle same as a common Party's `Handle` but it accepts one or more \"handlersFn\" functions which each one of them\r\n// can accept any input arguments that match with the Party's registered Container's `Dependencies` and\r\n// any output result; like custom structs <T>, string, []byte, int, error,\r\n// a combination of the above, hero.Result(hero.View | hero.Response) and more.\r\n//\r\n// It's common from a hero handler to not even need to accept a `Context`, for that reason,\r\n// the \"handlersFn\" will call `ctx.Next()` automatically when not called manually.\r\n// To stop the execution and not continue to the next \"handlersFn\"\r\n// the end-developer should output an error and return `iris.ErrStopExecution`.\r\nHandle(method, relativePath string, handlersFn ...interface{}) *Route\r\n\r\n// Get registers a GET route, same as `Handle(\"GET\", relativePath, handlersFn....)`.\r\nGet(relativePath string, handlersFn ...interface{}) *Route\r\n// and so on...\r\n```\r\n\r\nPrior to this version the `iris.Context` was the only one dependency that has been automatically binded to the handler's input or a controller's fields and methods, read below to see what types are automatically binded:\r\n\r\n| Type | Maps To |\r\n|------|:---------|\r\n| [*mvc.Application](https://pkg.go.dev/github.com/kataras/iris/v12/mvc?tab=doc#Application) | Current MVC Application |\r\n| [iris.Context](https://pkg.go.dev/github.com/kataras/iris/v12/context?tab=doc#Context) | Current Iris Context |\r\n| [*sessions.Session](https://pkg.go.dev/github.com/kataras/iris/v12/sessions?tab=doc#Session) | Current Iris Session |\r\n| [context.Context](https://golang.org/pkg/context/#Context) | [ctx.Request().Context()](https://golang.org/pkg/net/http/#Request.Context) |\r\n| [*http.Request](https://golang.org/pkg/net/http/#Request) | `ctx.Request()` |\r\n| [http.ResponseWriter](https://golang.org/pkg/net/http/#ResponseWriter) | `ctx.ResponseWriter()` |\r\n| [http.Header](https://golang.org/pkg/net/http/#Header) | `ctx.Request().Header` |\r\n| [time.Time](https://golang.org/pkg/time/#Time) | `time.Now()` |\r\n| [*golog.Logger](https://pkg.go.dev/github.com/kataras/golog) | Iris Logger |\r\n| [net.IP](https://golang.org/pkg/net/#IP) | `net.ParseIP(ctx.RemoteAddr())` |\r\n| [mvc.Code](https://pkg.go.dev/github.com/kataras/iris/v12/mvc?tab=doc#Code) | `ctx.GetStatusCode() int` |\r\n| [mvc.Err](https://pkg.go.dev/github.com/kataras/iris/v12/mvc?tab=doc#Err) | `ctx.GetErr() error` |\r\n| [iris/context.User](https://pkg.go.dev/github.com/kataras/iris/v12/context?tab=doc#User) | `ctx.User()` |\r\n| `string`, | |\r\n| `int, int8, int16, int32, int64`, | |\r\n| `uint, uint8, uint16, uint32, uint64`, | |\r\n| `float, float32, float64`, | |\r\n| `bool`, | |\r\n| `slice` | [Path Parameter](https://github.com/kataras/iris/wiki/Routing-path-parameter-types) |\r\n| Struct | [Request Body](https://github.com/kataras/iris/tree/master/_examples/request-body) of `JSON`, `XML`, `YAML`, `Form`, `URL Query`, `Protobuf`, `MsgPack` |\r\n\r\nHere is a preview of what the new Hero handlers look like:\r\n\r\n### Request & Response & Path Parameters\r\n\r\n**1.** Declare Go types for client's request body and a server's response.\r\n\r\n```go\r\ntype (\r\n\trequest struct {\r\n\t\tFirstname string `json:\"firstname\"`\r\n\t\tLastname  string `json:\"lastname\"`\r\n\t}\r\n\r\n\tresponse struct {\r\n\t\tID      uint64 `json:\"id\"`\r\n\t\tMessage string `json:\"message\"`\r\n\t}\r\n)\r\n```\r\n\r\n**2.** Create the route handler.\r\n\r\nPath parameters and request body are binded automatically.\r\n- **id uint64** binds to \"id:uint64\"\r\n- **input request** binds to client request data such as JSON\r\n\r\n```go\r\nfunc updateUser(id uint64, input request) response {\r\n\treturn response{\r\n\t\tID:      id,\r\n\t\tMessage: \"User updated successfully\",\r\n\t}\r\n}\r\n```\r\n\r\n**3.** Configure the container per group and register the route.\r\n\r\n```go\r\napp.Party(\"/user\").ConfigureContainer(container)\r\n\r\nfunc container(api *iris.APIContainer) {\r\n    api.Put(\"/{id:uint64}\", updateUser)\r\n}\r\n```\r\n\r\n**4.** Simulate a [client](https://curl.haxx.se/download.html) request which sends data to the server and displays the response.\r\n\r\n```sh\r\ncurl --request PUT -d '{\"firstanme\":\"John\",\"lastname\":\"Doe\"}' http://localhost:8080/user/42\r\n```\r\n\r\n```json\r\n{\r\n    \"id\": 42,\r\n    \"message\": \"User updated successfully\"\r\n}\r\n```\r\n\r\n### Custom Preflight\r\n\r\nBefore we continue to the next section, register dependencies, you may want to learn how a response can be customized through the `iris.Context` right before sent to the client.\r\n\r\nThe server will automatically execute the `Preflight(iris.Context) error` method of a function's output struct value right before send the response to the client.\r\n\r\nTake for example that you want to fire different HTTP status codes depending on the custom logic inside your handler and also modify the value(response body) itself before sent to the client. Your response type should contain a `Preflight` method like below.\r\n\r\n```go\r\ntype response struct {\r\n    ID      uint64 `json:\"id,omitempty\"`\r\n    Message string `json:\"message\"`\r\n    Code    int    `json:\"code\"`\r\n    Timestamp int64 `json:\"timestamp,omitempty\"`\r\n}\r\n\r\nfunc (r *response) Preflight(ctx iris.Context) error {\r\n    if r.ID > 0 {\r\n        r.Timestamp = time.Now().Unix()\r\n    }\r\n\r\n    if r.Code > 0 {\r\n        ctx.StatusCode(r.Code)\r\n    }\r\n\r\n    return nil\r\n}\r\n```\r\n\r\nNow, each handler that returns a `*response` value will call the `response.Preflight` method automatically.\r\n\r\n```go\r\nfunc deleteUser(db *sql.DB, id uint64) *response {\r\n    // [...custom logic]\r\n\r\n    return &response{\r\n        Message: \"User has been marked for deletion\",\r\n        Code: iris.StatusAccepted,\r\n    }\r\n}\r\n```\r\n\r\nIf you register the route and fire a request you should see an output like this, the timestamp is filled and the HTTP status code of the response that the client will receive is 202 (Status Accepted).\r\n\r\n```json\r\n{\r\n  \"message\": \"User has been marked for deletion\",\r\n  \"code\": 202,\r\n  \"timestamp\": 1583313026\r\n}\r\n```\r\n\r\n### Register Dependencies\r\n\r\n**1.** Import packages to interact with a database.\r\nThe go-sqlite3 package is a database driver for [SQLite](https://www.sqlite.org/index.html).\r\n\r\n```go\r\nimport \"database/sql\"\r\nimport _ \"github.com/mattn/go-sqlite3\"\r\n```\r\n\r\n**2.** Configure the container ([see above](#request--response--path-parameters)), register your dependencies. Handler expects an *sql.DB instance.\r\n\r\n```go\r\nlocalDB, _ := sql.Open(\"sqlite3\", \"./foo.db\")\r\napi.RegisterDependency(localDB)\r\n```\r\n\r\n**3.** Register a route to create a user.\r\n\r\n```go\r\napi.Post(\"/{id:uint64}\", createUser)\r\n```\r\n\r\n**4.** The create user Handler.\r\n\r\nThe handler accepts a database and some client request data such as JSON, Protobuf, Form, URL Query and e.t.c. It Returns a response.\r\n\r\n```go\r\nfunc createUser(db *sql.DB, user request) *response {\r\n    // [custom logic using the db]\r\n    userID, err := db.CreateUser(user)\r\n    if err != nil {\r\n        return &response{\r\n            Message: err.Error(),\r\n            Code: iris.StatusInternalServerError,\r\n        }\r\n    }\r\n\r\n\treturn &response{\r\n\t\tID:      userID,\r\n\t\tMessage: \"User created\",\r\n\t\tCode:    iris.StatusCreated,\r\n\t}\r\n}\r\n```\r\n\r\n**5.** Simulate a [client](https://curl.haxx.se/download.html) to create a user.\r\n\r\n```sh\r\n# JSON\r\ncurl --request POST -d '{\"firstname\":\"John\",\"lastname\":\"Doe\"}' \\\r\n--header 'Content-Type: application/json' \\\r\nhttp://localhost:8080/user\r\n```\r\n\r\n```sh\r\n# Form (multipart)\r\ncurl --request POST 'http://localhost:8080/users' \\\r\n--header 'Content-Type: multipart/form-data' \\\r\n--form 'firstname=John' \\\r\n--form 'lastname=Doe'\r\n```\r\n\r\n```sh\r\n# Form (URL-encoded)\r\ncurl --request POST 'http://localhost:8080/users' \\\r\n--header 'Content-Type: application/x-www-form-urlencoded' \\\r\n--data-urlencode 'firstname=John' \\\r\n--data-urlencode 'lastname=Doe'\r\n```\r\n\r\n```sh\r\n# URL Query\r\ncurl --request POST 'http://localhost:8080/users?firstname=John&lastname=Doe'\r\n```\r\n\r\nResponse: \r\n\r\n```json\r\n{\r\n    \"id\": 42,\r\n    \"message\": \"User created\",\r\n    \"code\": 201,\r\n    \"timestamp\": 1583313026\r\n}\r\n```\r\n\r\n## Breaking Changes\r\n\r\n- The `versioning.NewMatcher` has been removed entirely in favor of `NewGroup`. Strict versions format on `versioning.NewGroup` is required. E.g. `\"1\"` is not valid anymore, you have to specify `\"1.0.0\"`. Example: `NewGroup(api, \">=1.0.0 <2.0.0\")`. The [routing/versioning](_examples/routing/versioning) examples have been updated.\r\n- Now that `RegisterView` can be used to register different view engines per-Party, there is no need to support registering multiple engines under the same Party. The `app.RegisterView` now upserts the given Engine instead of append. You can now render templates **without file extension**, e.g. `index` instead of `index.ace`, both forms are valid now.\r\n- The `Context.ContentType` does not accept filenames to resolve the mime type anymore (caused issues with  vendor-specific(vnd) MIME types).\r\n- The `Configuration.RemoteAddrPrivateSubnets.IPRange.Start and End` are now type of `string` instead of `net.IP`. The `WithRemoteAddrPrivateSubnet` option remains as it is, already accepts `string`s.\r\n- The `i18n#LoaderConfig.FuncMap template.FuncMap` field was replaced with `Funcs func(iris.Locale) template.FuncMap` in order to give current locale access to the template functions. A new `app.I18n.Loader` was introduced too, in order to make it easier for end-developers to customize the translation key values.\r\n- Request Logger's `Columns bool` field has been removed. Use the new [accesslog](https://github.com/kataras/iris/tree/master/_examples/logging/request-logger/accesslog/main.go) middleware instead.\r\n- The `.Binary` method of all view engines was removed: pass the go-bindata's latest version `AssetFile()` exported function as the first argument instead of string. All examples updated.\r\n- `ContextUploadFormFiles(destDirectory string, before ...func(*Context, *multipart.FileHeader) bool) (uploaded []*multipart.FileHeader, n int64, err error)` now returns the total files uploaded too (as its first parameter) and the \"before\" variadic option should return a boolean, if false then the specific file is skipped.\r\n- `Context.PostValues(name string) ([]string, error)` now returns a second output argument of `error` type too, which reports `ErrEmptyForm` or `ErrNotFound` or `ErrEmptyFormField`. The single post value getters now returns the **last value** if multiple was given instead of the first one (this allows clients to append values on flow updates).\r\n- `Party.GetReporter()` **removed**. The `Application.Build` returns the first error now and the API's errors are logged, this allows the server to run even if some of the routes are invalid but not fatal to the entire application (it was a request from a company).\r\n- `versioning.NewGroup(string)` now accepts a `Party` as its first input argument: `NewGroup(Party, string)`.\r\n- `versioning.RegisterGroups` is **removed** as it is no longer necessary.\r\n- `Configuration.RemoteAddrHeaders` from `map[string]bool` to `[]string`. If you used `With(out)RemoteAddrHeader` then you are ready to proceed without any code changes for that one.\r\n- `ctx.Gzip(boolean)` replaced with `ctx.CompressWriter(boolean) error`.\r\n- `ctx.GzipReader(boolean) error` replaced with `ctx.CompressReader(boolean) error`.\r\n- `iris.Gzip` and `iris.GzipReader` replaced with `iris.Compression` (middleware).\r\n- `ctx.ClientSupportsGzip() bool` replaced with `ctx.ClientSupportsEncoding(\"gzip\", \"br\" ...) bool`.\r\n- `ctx.GzipResponseWriter()` is **removed**.\r\n- `Party.HandleDir/iris.FileServer` now accepts both `http.FileSystem` and `string` and returns a list of `[]*Route` (GET and HEAD) instead of GET only. You can write: both `app.HandleDir(\"/\", iris.Dir(\"./assets\"))` and `app.HandleDir(\"/\", \"./assets\")` and `DirOptions.Asset, AssetNames, AssetInfo` removed, use `go-bindata -fs [..]` and `app.HandleDir(\"/\", AssetFile())` instead.\r\n- `Context.OnClose` and `Context.OnCloseConnection` now both accept an `iris.Handler` instead of a simple `func()` as their callback.\r\n- `Context.StreamWriter(writer func(w io.Writer) bool)` changed to `StreamWriter(writer func(w io.Writer) error) error` and it's now the `Context.Request().Context().Done()` channel that is used to receive any close connection/manual cancel signals, instead of the deprecated `ResponseWriter().CloseNotify()` one. Same for the `Context.OnClose` and `Context.OnCloseConnection` methods.\r\n- Fixed handler's error response not be respected when response recorder was used instead of the common writer. Fixes [#1531](https://github.com/kataras/iris/issues/1531). It contains a **BREAKING CHANGE** of: the new `Configuration.ResetOnFireErrorCode` field should be set **to true** in order to behave as it used before this update (to reset the contents on recorder).\r\n- `Context.String()` (rarely used by end-developers) it does not return a unique string anymore, to achieve the old representation you must call the new `Context.SetID` method first.\r\n- `iris.CookieEncode` and `CookieDecode` are replaced with the `iris.CookieEncoding`.\r\n- `sessions#Config.Encode` and `Decode` are removed in favor of (the existing) `Encoding` field.\r\n- `versioning.GetVersion` now returns an empty string if version wasn't found.\r\n- Change the MIME type of `Javascript .js` and `JSONP` as the HTML specification now recommends to `\"text/javascript\"` instead of the obselete `\"application/javascript\"`. This change was pushed to the `Go` language itself as well. See <https://go-review.googlesource.com/c/go/+/186927/>.\r\n- Remove the last input argument of `enableGzipCompression` in `Context.ServeContent`, `ServeFile` methods. This was deprecated a few versions ago. A middleware (`app.Use(iris.CompressWriter)`) or a prior call to `Context.CompressWriter(true)` will enable compression. Also these two methods and `Context.SendFile` one now support `Content-Range` and `Accept-Ranges` correctly out of the box (`net/http` had a bug, which is now fixed).\r\n- `Context.ServeContent` no longer returns an error, see `ServeContentWithRate`, `ServeFileWithRate` and `SendFileWithRate` new methods too.\r\n- `route.Trace() string` changed to `route.Trace(w io.Writer)`, to achieve the same result just pass a `bytes.Buffer`\r\n- `var mvc.AutoBinding` removed as the default behavior now resolves such dependencies automatically (see [[FEATURE REQUEST] MVC serving gRPC-compatible controller](https://github.com/kataras/iris/issues/1449)).\r\n- `mvc#Application.SortByNumMethods()` removed as the default behavior now binds the \"thinnest\"  empty `interface{}` automatically (see [MVC: service injecting fails](https://github.com/kataras/iris/issues/1343)).\r\n- `mvc#BeforeActivation.Dependencies().Add` should be replaced with `mvc#BeforeActivation.Dependencies().Register` instead\r\n- **REMOVE** the `kataras/iris/v12/typescript` package in favor of the new [iris-cli](https://github.com/kataras/iris-cli). Also, the alm typescript online editor was removed as it is deprecated by its author, please consider using the [designtsx](https://designtsx.com/) instead.\r\n\r\n# Su, 16 February 2020 | v12.1.8\r\n\r\nNew Features:\r\n\r\n-  [[FEATURE REQUEST] MVC serving gRPC-compatible controller](https://github.com/kataras/iris/issues/1449)\r\n\r\nFixes:\r\n\r\n- [App can't find embedded pug template files by go-bindata](https://github.com/kataras/iris/issues/1450)\r\n\r\nNew Examples:\r\n\r\n- [_examples/mvc/grpc-compatible](_examples/mvc/grpc-compatible)\r\n\r\n# Mo, 10 February 2020 | v12.1.7\r\n\r\nImplement **new** `SetRegisterRule(iris.RouteOverride, RouteSkip, RouteError)` to resolve: https://github.com/kataras/iris/issues/1448\r\n\r\nNew Examples:\r\n\r\n- [_examples/routing/route-register-rule](_examples/routing/route-register-rule)\r\n\r\n# We, 05 February 2020 | v12.1.6\r\n\r\nFixes:\r\n\r\n- [jet.View - urlpath error](https://github.com/kataras/iris/issues/1438)\r\n- [Context.ServeFile send 'application/wasm' with a wrong extra field](https://github.com/kataras/iris/issues/1440)\r\n\r\n# Su, 02 February 2020 | v12.1.5\r\n\r\nVarious improvements and linting.\r\n\r\n# Su, 29 December 2019 | v12.1.4\r\n\r\nMinor fix on serving [embedded files](https://github.com/kataras/iris/wiki/File-server).\r\n\r\n# We, 25 December 2019 | v12.1.3\r\n\r\nFix [[BUG] [iris.Default] RegisterView](https://github.com/kataras/iris/issues/1410)\r\n\r\n# Th, 19 December 2019 | v12.1.2\r\n\r\nFix [[BUG]Session works incorrectly when meets the multi-level TLDs](https://github.com/kataras/iris/issues/1407).\r\n\r\n# Mo, 16 December 2019 | v12.1.1\r\n\r\nAdd [Context.FindClosest(n int) []string](https://github.com/kataras/iris/blob/master/_examples/routing/intelligence/manual/main.go#L22)\r\n\r\n```go\r\napp := iris.New()\r\napp.OnErrorCode(iris.StatusNotFound, notFound)\r\n```\r\n\r\n```go\r\nfunc notFound(ctx iris.Context) {\r\n    suggestPaths := ctx.FindClosest(3)\r\n    if len(suggestPaths) == 0 {\r\n        ctx.WriteString(\"404 not found\")\r\n        return\r\n    }\r\n\r\n    ctx.HTML(\"Did you mean?<ul>\")\r\n    for _, s := range suggestPaths {\r\n        ctx.HTML(`<li><a href=\"%s\">%s</a></li>`, s, s)\r\n    }\r\n    ctx.HTML(\"</ul>\")\r\n}\r\n```\r\n\r\n![](https://iris-go.com/images/iris-not-found-suggests.png)\r\n\r\n# Fr, 13 December 2019 | v12.1.0\r\n\r\n## Breaking Changes\r\n\r\nMinor as many of you don't even use them but, indeed, they need to be covered here.\r\n\r\n- Old i18n middleware(iris/middleware/i18n) was replaced by the [i18n](i18n) sub-package which lives as field at your application: `app.I18n.Load(globPathPattern string, languages ...string)` (see below)\r\n- Community-driven i18n middleware(iris-contrib/middleware/go-i18n) has a `NewLoader` function which returns a loader which can be passed at `app.I18n.Reset(loader i18n.Loader, languages ...string)` to change the locales parser\r\n- The Configuration's `TranslateFunctionContextKey` was replaced by `LocaleContextKey` which Context store's value (if i18n is used) returns the current Locale which contains the translate function, the language code, the language tag and the index position of it\r\n- The `context.Translate` method was replaced by `context.Tr` as a shortcut for the new `context.GetLocale().GetMessage(format, args...)` method and it matches the view's function `{{tr format args}}` too\r\n- If you used [Iris Django](https://github.com/kataras/iris/tree/master/_examples/view/template_django_0) view engine with `import _ github.com/flosch/pongo2-addons` you **must change** the import path to `_ github.com/iris-contrib/pongo2-addons` or add a [go mod replace](https://github.com/golang/go/wiki/Modules#when-should-i-use-the-replace-directive) to your `go.mod` file, e.g. `replace github.com/flosch/pongo2-addons => github.com/iris-contrib/pongo2-addons v0.0.1`.\r\n\r\n## Fixes\r\n\r\nAll known issues.\r\n\r\n1. [#1395](https://github.com/kataras/iris/issues/1395) \r\n2. [#1369](https://github.com/kataras/iris/issues/1369)\r\n3. [#1399](https://github.com/kataras/iris/issues/1399) with PR [#1400](https://github.com/kataras/iris/pull/1400)\r\n4. [#1401](https://github.com/kataras/iris/issues/1401) \r\n5. [#1406](https://github.com/kataras/iris/issues/1406)\r\n6. [neffos/#20](https://github.com/kataras/neffos/issues/20)\r\n7. [pio/#5](https://github.com/kataras/pio/issues/5)\r\n\r\n## New Features\r\n\r\n### Internationalization and localization\r\n\r\nSupport for i18n is now a **builtin feature** and is being respected across your entire application, per say [sitemap](https://github.com/kataras/iris/wiki/Sitemap) and [views](https://github.com/kataras/iris/blob/master/_examples/i18n/basic/main.go#L50).\r\n\r\nRefer to the wiki section: https://github.com/kataras/iris/wiki/Sitemap for details.\r\n\r\n### Sitemaps\r\n\r\nIris generates and serves one or more [sitemap.xml](https://www.sitemaps.org/protocol.html) for your static routes.\r\n\r\nNavigate through: https://github.com/kataras/iris/wiki/Sitemap for more.\r\n\r\n## New Examples\r\n\r\n2. [_examples/i18n](_examples/i18n)\r\n1. [_examples/sitemap](_examples/routing/sitemap)\r\n3. [_examples/desktop/blink](_examples/desktop/blink)\r\n4. [_examples/desktop/lorca](_examples/desktop/lorca)\r\n5. [_examples/desktop/webview](_examples/desktop/webview)\r\n\r\n# Sa, 26 October 2019 | v12.0.0\r\n\r\n- Add version suffix of the **import path**, learn why and see what people voted at [issue #1370](https://github.com/kataras/iris/issues/1370)\r\n\r\n![](https://iris-go.com/images/vote-v12-version-suffix_26_oct_2019.png)\r\n\r\n- All errors are now compatible with go1.13 `errors.Is`, `errors.As` and `fmt.Errorf` and a new `core/errgroup` package created\r\n- Fix [#1383](https://github.com/kataras/iris/issues/1383)\r\n- Report whether system couldn't find the directory of view templates\r\n- Remove the `Party#GetReport` method, keep `Party#GetReporter` which is an `error` and an `errgroup.Group`.\r\n- Remove the router's deprecated methods such as StaticWeb and StaticEmbedded_XXX\r\n- The `Context#CheckIfModifiedSince` now returns an `context.ErrPreconditionFailed` type of error when client conditions are not met. Usage: `if errors.Is(err, context.ErrPreconditionFailed) { ... }`\r\n- Add `SourceFileName` and `SourceLineNumber` to the `Route`, reports the exact position of its registration inside your project's source code.\r\n- Fix a bug about the MVC package route binding, see [PR #1364](https://github.com/kataras/iris/pull/1364)\r\n- Add `mvc/Application#SortByNumMethods` as requested at [#1343](https://github.com/kataras/iris/issues/1343#issuecomment-524868164)\r\n- Add status code `103 Early Hints`\r\n- Fix performance of session.UpdateExpiration on 200 thousands+ keys with new radix as reported at [issue #1328](https://github.com/kataras/iris/issues/1328)\r\n- New redis session database configuration field: `Driver: redis.Redigo()` or `redis.Radix()`, see [updated examples](_examples/sessions/database/redis/)\r\n- Add Clusters support for redis:radix session database (`Driver: redis:Radix()`) as requested at [issue #1339](https://github.com/kataras/iris/issues/1339)\r\n- Create Iranian [README_FA](README_FA.md) translation with [PR #1360](https://github.com/kataras/iris/pull/1360) \r\n- Create Korean [README_KO](README_KO.md) translation with [PR #1356](https://github.com/kataras/iris/pull/1356)\r\n- Create Spanish [README_ES](README_ES.md) and [HISTORY_ES](HISTORY_ES.md) translations with [PR #1344](https://github.com/kataras/iris/pull/1344).\r\n\r\nThe iris-contrib/middleare and examples are updated to use the new `github.com/kataras/iris/v12` import path.\r\n\r\n# Fr, 16 August 2019 | v11.2.8\r\n\r\n- Set `Cookie.SameSite` to `Lax` when subdomains sessions share is enabled[*](https://github.com/kataras/iris/commit/6bbdd3db9139f9038641ce6f00f7b4bab6e62550)\r\n- Add and update all [experimental handlers](https://github.com/iris-contrib/middleware) \r\n- New `XMLMap` function which wraps a `map[string]interface{}` and converts it to a valid xml content to render through `Context.XML` method\r\n- Add new `ProblemOptions.XML` and `RenderXML` fields to render the `Problem` as XML(application/problem+xml) instead of JSON(\"application/problem+json) and enrich the `Negotiate` to easily accept the `application/problem+xml` mime.\r\n\r\nCommit log: https://github.com/kataras/iris/compare/v11.2.7...v11.2.8\r\n\r\n# Th, 15 August 2019 | v11.2.7\r\n\r\nThis minor version contains improvements on the Problem Details for HTTP APIs implemented on [v11.2.5](#mo-12-august-2019--v1125).\r\n\r\n- Fix https://github.com/kataras/iris/issues/1335#issuecomment-521319721\r\n- Add `ProblemOptions` with `RetryAfter` as requested at: https://github.com/kataras/iris/issues/1335#issuecomment-521330994.\r\n- Add `iris.JSON` alias for `context#JSON` options type.\r\n\r\n[Example](https://github.com/kataras/iris/blob/45d7c6fedb5adaef22b9730592255f7bb375e809/_examples/routing/http-errors/main.go#L85) and [wikis](https://github.com/kataras/iris/wiki/Routing-error-handlers#the-problem-type) updated. \r\n\r\nReferences:\r\n\r\n- https://tools.ietf.org/html/rfc7231#section-7.1.3\r\n- https://tools.ietf.org/html/rfc7807\r\n\r\nCommit log: https://github.com/kataras/iris/compare/v11.2.6...v11.2.7\r\n\r\n# We, 14 August 2019 | v11.2.6\r\n\r\nAllow [handle more than one route with the same paths and parameter types but different macro validation functions](https://github.com/kataras/iris/issues/1058#issuecomment-521110639).\r\n\r\n```go\r\napp.Get(\"/{alias:string regexp(^[a-z0-9]{1,10}\\\\.xml$)}\", PanoXML)\r\napp.Get(\"/{alias:string regexp(^[a-z0-9]{1,10}$)}\", Tour)\r\n```\r\n\r\nCommit log: https://github.com/kataras/iris/compare/v11.2.5...v11.2.6\r\n\r\n# Mo, 12 August 2019 | v11.2.5\r\n\r\n- [New Feature: Problem Details for HTTP APIs](https://github.com/kataras/iris/pull/1336)\r\n- [Add Context.AbsoluteURI](https://github.com/kataras/iris/pull/1336/files#diff-15cce7299aae8810bcab9b0bf9a2fdb1R2368)\r\n\r\nCommit log: https://github.com/kataras/iris/compare/v11.2.4...v11.2.5\r\n\r\n# Fr, 09 August 2019 | v11.2.4\r\n\r\n- Fixes [iris.Jet: no view engine found for '.jet' or '.html'](https://github.com/kataras/iris/issues/1327)\r\n- Fixes [ctx.ViewData not work with JetEngine](https://github.com/kataras/iris/issues/1330)\r\n- **New Feature**: [HTTP Method Override](https://github.com/kataras/iris/issues/1325)\r\n- Fixes [Poor performance of session.UpdateExpiration on 200 thousands+ keys with new radix lib](https://github.com/kataras/iris/issues/1328) by introducing the `sessions.Config.Driver` configuration field which defaults to `Redigo()` but can be set to `Radix()` too, future additions are welcomed.\r\n\r\nCommit log: https://github.com/kataras/iris/compare/v11.2.3...v11.2.4\r\n\r\n# Tu, 30 July 2019 | v11.2.3\r\n\r\n- [New Feature: Handle different parameter types in the same path](https://github.com/kataras/iris/issues/1315)\r\n- [New Feature: Content Negotiation](https://github.com/kataras/iris/issues/1319)\r\n- [Context.ReadYAML](https://github.com/kataras/iris/tree/master/_examples/request-body/read-yaml)\r\n- Fixes https://github.com/kataras/neffos/issues/1#issuecomment-515698536\r\n\r\n# We, 24 July 2019 | v11.2.2\r\n\r\nSessions as middleware:\r\n\r\n```go\r\nimport \"github.com/kataras/iris/v12/sessions\"\r\n// [...]\r\n\r\napp := iris.New()\r\nsess := sessions.New(sessions.Config{...})\r\n\r\napp.Get(\"/path\", func(ctx iris.Context){\r\n    session := sessions.Get(ctx)\r\n    // [work with session...]\r\n})\r\n```\r\n\r\n- Add `Session.Len() int` to return the total number of stored values/entries.\r\n- Make `Context.HTML` and `Context.Text` to accept an optional, variadic, `args ...interface{}` input arg(s) too.\r\n\r\n## v11.1.1\r\n\r\n- https://github.com/kataras/iris/issues/1298\r\n- https://github.com/kataras/iris/issues/1207\r\n\r\n# Tu, 23 July 2019 | v11.2.0\r\n\r\nRead about the new release at: https://www.facebook.com/iris.framework/posts/3276606095684693\r\n", "package context\n\nimport (\n\t\"bytes\"\n\tstdContext \"context\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/kataras/iris/v12/core/memstore\"\n\t\"github.com/kataras/iris/v12/core/netutil\"\n\n\t\"github.com/Shopify/goreferrer\"\n\t\"github.com/fatih/structs\"\n\t\"github.com/iris-contrib/schema\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"github.com/kataras/golog\"\n\t\"github.com/mailru/easyjson\"\n\t\"github.com/mailru/easyjson/jwriter\"\n\t\"github.com/microcosm-cc/bluemonday\"\n\t\"github.com/russross/blackfriday/v2\"\n\t\"github.com/vmihailenco/msgpack/v5\"\n\t\"golang.org/x/net/publicsuffix\"\n\t\"golang.org/x/time/rate\"\n\t\"google.golang.org/protobuf/encoding/protojson\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"gopkg.in/yaml.v3\"\n)\n\ntype (\n\t// BodyDecoder is an interface which any struct can implement in order to customize the decode action\n\t// from ReadJSON and ReadXML\n\t//\n\t// Trivial example of this could be:\n\t// type User struct { Username string }\n\t//\n\t// func (u *User) Decode(data []byte) error {\n\t//\t  return json.Unmarshal(data, u)\n\t// }\n\t//\n\t// the 'Context.ReadJSON/ReadXML(&User{})' will call the User's\n\t// Decode option to decode the request body\n\t//\n\t// Note: This is totally optionally, the default decoders\n\t// for ReadJSON is the encoding/json and for ReadXML is the encoding/xml.\n\t//\n\t// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-custom-per-type/main.go\n\tBodyDecoder interface {\n\t\tDecode(data []byte) error\n\t}\n\n\t// Unmarshaler is the interface implemented by types that can unmarshal any raw data.\n\t// TIP INFO: Any pointer to a value which implements the BodyDecoder can be override the unmarshaler.\n\tUnmarshaler interface {\n\t\tUnmarshal(data []byte, outPtr interface{}) error\n\t}\n\n\t// UnmarshalerFunc a shortcut for the Unmarshaler interface\n\t//\n\t// See 'Unmarshaler' and 'BodyDecoder' for more.\n\t//\n\t// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-custom-via-unmarshaler/main.go\n\tUnmarshalerFunc func(data []byte, outPtr interface{}) error\n\n\t// DecodeFunc is a generic type of decoder function.\n\t// When the returned error is not nil the decode operation\n\t// is terminated and the error is received by the ReadJSONStream method,\n\t// otherwise it continues to read the next available object.\n\t// Look the `Context.ReadJSONStream` method.\n\tDecodeFunc func(outPtr interface{}) error\n)\n\n// Unmarshal parses the X-encoded data and stores the result in the value pointed to by v.\n// Unmarshal uses the inverse of the encodings that Marshal uses, allocating maps,\n// slices, and pointers as necessary.\nfunc (u UnmarshalerFunc) Unmarshal(data []byte, v interface{}) error {\n\treturn u(data, v)\n}\n\n// LimitRequestBodySize is a middleware which sets a request body size limit\n// for all next handlers in the chain.\nvar LimitRequestBodySize = func(maxRequestBodySizeBytes int64) Handler {\n\treturn func(ctx *Context) {\n\t\tctx.SetMaxRequestBodySize(maxRequestBodySizeBytes)\n\t\tctx.Next()\n\t}\n}\n\n// Map is just a type alias of the map[string]interface{} type.\ntype Map = map[string]interface{}\n\n// Context is the midle-man server's \"object\" dealing with incoming requests.\n//\n// A New context is being acquired from a sync.Pool on each connection.\n// The Context is the most important thing on the iris's http flow.\n//\n// Developers send responses to the client's request through a Context.\n// Developers get request information from the client's request a Context.\ntype Context struct {\n\t// the http.ResponseWriter wrapped by custom writer.\n\twriter ResponseWriter\n\t// the original http.Request\n\trequest *http.Request\n\t// the current route registered to this request path.\n\tcurrentRoute RouteReadOnly\n\n\t// the local key-value storage\n\tparams RequestParams  // url named parameters.\n\tvalues memstore.Store // generic storage, middleware communication.\n\tquery  url.Values     // GET url query temp cache, useful on many URLParamXXX calls.\n\t// the underline application app.\n\tapp Application\n\t// the route's handlers\n\thandlers Handlers\n\t// the current position of the handler's chain\n\tcurrentHandlerIndex int\n\t// proceeded reports whether `Proceed` method\n\t// called before a `Next`. It is a flash field and it is set\n\t// to true on `Next` call when its called on the last handler in the chain.\n\t// Reports whether a `Next` is called,\n\t// even if the handler index remains the same (last handler).\n\t//\n\t// Also it's responsible to keep the old value of the last known handler index\n\t// before StopExecution. See ResumeExecution.\n\tproceeded int\n}\n\n// NewContext returns a new Context instance.\nfunc NewContext(app Application) *Context {\n\treturn &Context{app: app}\n}\n\n/* Not required, unless requested.\n// SetApplication sets an Iris Application on-fly.\n// Do NOT use it after ServeHTTPC is fired.\nfunc (ctx *Context) SetApplication(app Application) {\n\tctx.app = app\n}\n*/\n\n// Clone returns a copy of the context that\n// can be safely used outside the request's scope.\n// Note that if the request-response lifecycle terminated\n// or request canceled by the client (can be checked by `ctx.IsCanceled()`)\n// then the response writer is totally useless.\n// The http.Request pointer value is shared.\nfunc (ctx *Context) Clone() *Context {\n\tvaluesCopy := make(memstore.Store, len(ctx.values))\n\tcopy(valuesCopy, ctx.values)\n\n\tparamsCopy := make(memstore.Store, len(ctx.params.Store))\n\tcopy(paramsCopy, ctx.params.Store)\n\n\tqueryCopy := make(url.Values, len(ctx.query))\n\tfor k, v := range ctx.query {\n\t\tqueryCopy[k] = v\n\t}\n\n\treq := ctx.request.Clone(ctx.request.Context())\n\treturn &Context{\n\t\tapp:                 ctx.app,\n\t\tvalues:              valuesCopy,\n\t\tparams:              RequestParams{Store: paramsCopy},\n\t\tquery:               queryCopy,\n\t\twriter:              ctx.writer.Clone(),\n\t\trequest:             req,\n\t\tcurrentHandlerIndex: stopExecutionIndex,\n\t\tproceeded:           ctx.proceeded,\n\t\tcurrentRoute:        ctx.currentRoute,\n\t}\n}\n\n// BeginRequest is executing once for each request\n// it should prepare the (new or acquired from pool) context's fields for the new request.\n// Do NOT call it manually. Framework calls it automatically.\n//\n// Resets\n// 1. handlers to nil.\n// 2. values to empty.\n// 3. the defer function.\n// 4. response writer to the http.ResponseWriter.\n// 5. request to the *http.Request.\nfunc (ctx *Context) BeginRequest(w http.ResponseWriter, r *http.Request) {\n\tctx.currentRoute = nil\n\tctx.handlers = nil           // will be filled by router.Serve/HTTP\n\tctx.values = ctx.values[0:0] // >>      >>     by context.Values().Set\n\tctx.params.Store = ctx.params.Store[0:0]\n\tctx.query = nil\n\tctx.request = r\n\tctx.currentHandlerIndex = 0\n\tctx.proceeded = 0\n\tctx.writer = AcquireResponseWriter()\n\tctx.writer.BeginResponse(w)\n}\n\n// EndRequest is executing once after a response to the request was sent and this context is useless or released.\n// Do NOT call it manually. Framework calls it automatically.\n//\n// 1. executes the OnClose function (if any).\n// 2. flushes the response writer's result or fire any error handler.\n// 3. releases the response writer.\nfunc (ctx *Context) EndRequest() {\n\tif !ctx.app.ConfigurationReadOnly().GetDisableAutoFireStatusCode() &&\n\t\tStatusCodeNotSuccessful(ctx.GetStatusCode()) {\n\t\tctx.app.FireErrorCode(ctx)\n\t}\n\n\tctx.writer.FlushResponse()\n\tctx.writer.EndResponse()\n}\n\n// IsCanceled reports whether the client canceled the request\n// or the underlying connection has gone.\n// Note that it will always return true\n// when called from a goroutine after the request-response lifecycle.\nfunc (ctx *Context) IsCanceled() bool {\n\tvar err error\n\tif reqCtx := ctx.request.Context(); reqCtx != nil {\n\t\terr = reqCtx.Err()\n\t} else {\n\t\terr = ctx.GetErr()\n\t}\n\n\treturn IsErrCanceled(err)\n}\n\n// IsErrCanceled reports whether the \"err\" is caused by a cancellation or timeout.\nfunc IsErrCanceled(err error) bool {\n\tif err == nil {\n\t\treturn false\n\t}\n\n\tvar netErr net.Error\n\treturn (errors.As(err, &netErr) && netErr.Timeout()) ||\n\t\terrors.Is(err, stdContext.Canceled) ||\n\t\terrors.Is(err, stdContext.DeadlineExceeded) ||\n\t\terrors.Is(err, http.ErrHandlerTimeout) ||\n\t\terr.Error() == \"closed pool\"\n}\n\n// OnConnectionClose registers the \"cb\" Handler\n// which will be fired on its on goroutine on a cloned Context\n// when the underlying connection has gone away.\n//\n// The code inside the given callback is running on its own routine,\n// as explained above, therefore the callback should NOT\n// try to access to handler's Context response writer.\n//\n// This mechanism can be used to cancel long operations on the server\n// if the client has disconnected before the response is ready.\n//\n// It depends on the Request's Context.Done() channel.\n//\n// Finally, it reports whether the protocol supports pipelines (HTTP/1.1 with pipelines disabled is not supported).\n// The \"cb\" will not fire for sure if the output value is false.\n//\n// Note that you can register only one callback per route.\n//\n// See `OnClose` too.\nfunc (ctx *Context) OnConnectionClose(cb Handler) bool {\n\tif cb == nil {\n\t\treturn false\n\t}\n\n\treqCtx := ctx.Request().Context()\n\tif reqCtx == nil {\n\t\treturn false\n\t}\n\n\tnotifyClose := reqCtx.Done()\n\tif notifyClose == nil {\n\t\treturn false\n\t}\n\n\tgo func() {\n\t\t<-notifyClose\n\t\t// Note(@kataras): No need to clone if not canceled,\n\t\t// EndRequest will be called on the end of the handler chain,\n\t\t// no matter the cancelation.\n\t\t// therefore the context will still be there.\n\t\tcb(ctx.Clone())\n\t}()\n\n\treturn true\n}\n\n// OnConnectionCloseErr same as `OnConnectionClose` but instead it\n// receives a function which returns an error.\n// If error is not nil, it will be logged as a debug message.\nfunc (ctx *Context) OnConnectionCloseErr(cb func() error) bool {\n\tif cb == nil {\n\t\treturn false\n\t}\n\n\treqCtx := ctx.Request().Context()\n\tif reqCtx == nil {\n\t\treturn false\n\t}\n\n\tnotifyClose := reqCtx.Done()\n\tif notifyClose == nil {\n\t\treturn false\n\t}\n\n\tgo func() {\n\t\t<-notifyClose\n\t\tif err := cb(); err != nil {\n\t\t\t// Can be ignored.\n\t\t\tctx.app.Logger().Debugf(\"OnConnectionCloseErr: received error: %v\", err)\n\t\t}\n\t}()\n\n\treturn true\n}\n\n// OnClose registers a callback which\n// will be fired when the underlying connection has gone away(request canceled)\n// on its own goroutine or in the end of the request-response lifecylce\n// on the handler's routine itself (Context access).\n//\n// See `OnConnectionClose` too.\nfunc (ctx *Context) OnClose(cb Handler) {\n\tif cb == nil {\n\t\treturn\n\t}\n\n\t// Note(@kataras):\n\t// - on normal request-response lifecycle\n\t// the `SetBeforeFlush` will be called first\n\t// and then `OnConnectionClose`,\n\t// - when request was canceled before handler finish its job\n\t// then the `OnConnectionClose` will be called first instead,\n\t// and when the handler function completed then `SetBeforeFlush` is fired.\n\t// These are synchronized, they cannot be executed the same exact time,\n\t// below we just make sure the \"cb\" is executed once\n\t// by simple boolean check or an atomic one.\n\tvar executed uint32\n\n\tcallback := func(ctx *Context) {\n\t\tif atomic.CompareAndSwapUint32(&executed, 0, 1) {\n\t\t\tcb(ctx)\n\t\t}\n\t}\n\n\tctx.OnConnectionClose(callback)\n\n\tonFlush := func() {\n\t\tcallback(ctx)\n\t}\n\n\tctx.writer.SetBeforeFlush(onFlush)\n}\n\n// OnCloseErr same as `OnClose` but instead it\n// receives a function which returns an error.\n// If error is not nil, it will be logged as a debug message.\nfunc (ctx *Context) OnCloseErr(cb func() error) {\n\tif cb == nil {\n\t\treturn\n\t}\n\n\tvar executed uint32\n\n\tcallback := func() error {\n\t\tif atomic.CompareAndSwapUint32(&executed, 0, 1) {\n\t\t\treturn cb()\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tctx.OnConnectionCloseErr(callback)\n\n\tonFlush := func() {\n\t\tif err := callback(); err != nil {\n\t\t\t// Can be ignored.\n\t\t\tctx.app.Logger().Debugf(\"OnClose: SetBeforeFlush: received error: %v\", err)\n\t\t}\n\t}\n\n\tctx.writer.SetBeforeFlush(onFlush)\n}\n\n/* Note(@kataras): just leave end-developer decide.\nconst goroutinesContextKey = \"iris.goroutines\"\n\ntype goroutines struct {\n\twg     *sync.WaitGroup\n\tlength int\n\tmu     sync.RWMutex\n}\n\nvar acquireGoroutines = func() interface{} {\n\treturn &goroutines{wg: new(sync.WaitGroup)}\n}\n\nfunc (ctx *Context) Go(fn func(cancelCtx stdContext.Context)) (running int) {\n\tg := ctx.values.GetOrSet(goroutinesContextKey, acquireGoroutines).(*goroutines)\n\tif fn != nil {\n\t\tg.wg.Add(1)\n\n\t\tg.mu.Lock()\n\t\tg.length++\n\t\tg.mu.Unlock()\n\n\t\tctx.waitFunc = g.wg.Wait\n\n\t\tgo func(reqCtx stdContext.Context) {\n\t\t\tfn(reqCtx)\n\t\t\tg.wg.Done()\n\n\t\t\tg.mu.Lock()\n\t\t\tg.length--\n\t\t\tg.mu.Unlock()\n\t\t}(ctx.request.Context())\n\t}\n\n\tg.mu.RLock()\n\trunning = g.length\n\tg.mu.RUnlock()\n\treturn\n}\n*/\n\n// ResponseWriter returns an http.ResponseWriter compatible response writer, as expected.\nfunc (ctx *Context) ResponseWriter() ResponseWriter {\n\treturn ctx.writer\n}\n\n// ResetResponseWriter sets a new ResponseWriter implementation\n// to this Context to use as its writer.\n// Note, to change the underline http.ResponseWriter use\n// ctx.ResponseWriter().SetWriter(http.ResponseWriter) instead.\nfunc (ctx *Context) ResetResponseWriter(newResponseWriter ResponseWriter) {\n\tif rec, ok := ctx.IsRecording(); ok {\n\t\treleaseResponseRecorder(rec)\n\t}\n\n\tctx.writer = newResponseWriter\n}\n\n// Request returns the original *http.Request, as expected.\nfunc (ctx *Context) Request() *http.Request {\n\treturn ctx.request\n}\n\n// ResetRequest sets the Context's Request,\n// It is useful to store the new request created by a std *http.Request#WithContext() into Iris' Context.\n// Use `ResetRequest` when for some reason you want to make a full\n// override of the *http.Request.\n// Note that: when you just want to change one of each fields you can use the Request() which returns a pointer to Request,\n// so the changes will have affect without a full override.\n// Usage: you use a native http handler which uses the standard \"context\" package\n// to get values instead of the Iris' Context#Values():\n// r := ctx.Request()\n// stdCtx := context.WithValue(r.Context(), key, val)\n// ctx.ResetRequest(r.WithContext(stdCtx)).\nfunc (ctx *Context) ResetRequest(r *http.Request) {\n\tctx.request = r\n}\n\n// SetCurrentRoute sets the route internally,\n// See `GetCurrentRoute()` method too.\n// It's being initialized by the Router.\n// See `Exec` or `SetHandlers/AddHandler` methods to simulate a request.\nfunc (ctx *Context) SetCurrentRoute(route RouteReadOnly) {\n\tctx.currentRoute = route\n}\n\n// GetCurrentRoute returns the current \"read-only\" route that\n// was registered to this request's path.\nfunc (ctx *Context) GetCurrentRoute() RouteReadOnly {\n\treturn ctx.currentRoute\n}\n\n// Do sets the \"handlers\" as the chain\n// and executes the first handler,\n// handlers should not be empty.\n//\n// It's used by the router, developers may use that\n// to replace and execute handlers immediately.\nfunc (ctx *Context) Do(handlers Handlers) {\n\tif len(handlers) == 0 {\n\t\treturn\n\t}\n\n\tctx.handlers = handlers\n\thandlers[0](ctx)\n}\n\n// AddHandler can add handler(s)\n// to the current request in serve-time,\n// these handlers are not persistenced to the router.\n//\n// Router is calling this function to add the route's handler.\n// If AddHandler called then the handlers will be inserted\n// to the end of the already-defined route's handler.\n//\nfunc (ctx *Context) AddHandler(handlers ...Handler) {\n\tctx.handlers = append(ctx.handlers, handlers...)\n}\n\n// SetHandlers replaces all handlers with the new.\nfunc (ctx *Context) SetHandlers(handlers Handlers) {\n\tctx.handlers = handlers\n}\n\n// Handlers keeps tracking of the current handlers.\nfunc (ctx *Context) Handlers() Handlers {\n\treturn ctx.handlers\n}\n\n// HandlerIndex sets the current index of the\n// current context's handlers chain.\n// If n < 0 or the current handlers length is 0 then it just returns the\n// current handler index without change the current index.\n//\n// Look Handlers(), Next() and StopExecution() too.\nfunc (ctx *Context) HandlerIndex(n int) (currentIndex int) {\n\tif n < 0 || n > len(ctx.handlers)-1 {\n\t\treturn ctx.currentHandlerIndex\n\t}\n\n\tctx.currentHandlerIndex = n\n\treturn n\n}\n\n// Proceed is an alternative way to check if a particular handler\n// has been executed.\n// The given \"h\" Handler can report a failure with `StopXXX` methods\n// or ignore calling a `Next` (see `iris.ExecutionRules` too).\n//\n// This is useful only when you run a handler inside\n// another handler. It justs checks for before index and the after index.\n//\n// A usecase example is when you want to execute a middleware\n// inside controller's `BeginRequest` that calls the `ctx.Next` inside it.\n// The Controller looks the whole flow (BeginRequest, method handler, EndRequest)\n// as one handler, so `ctx.Next` will not be reflected to the method handler\n// if called from the `BeginRequest`.\n//\n// Although `BeginRequest` should NOT be used to call other handlers,\n// the `BeginRequest` has been introduced to be able to set\n// common data to all method handlers before their execution.\n// Controllers can accept middleware(s) from the MVC's Application's Router as normally.\n//\n// That said let's see an example of `ctx.Proceed`:\n//\n// var authMiddleware = basicauth.New(basicauth.Config{\n// \tUsers: map[string]string{\n// \t\t\"admin\": \"password\",\n// \t},\n// })\n//\n// func (c *UsersController) BeginRequest(ctx iris.Context) {\n// \tif !ctx.Proceed(authMiddleware) {\n// \t\tctx.StopExecution()\n// \t}\n// }\n// This Get() will be executed in the same handler as `BeginRequest`,\n// internally controller checks for `ctx.StopExecution`.\n// So it will not be fired if BeginRequest called the `StopExecution`.\n// func(c *UsersController) Get() []models.User {\n//\t  return c.Service.GetAll()\n//}\n// Alternative way is `!ctx.IsStopped()` if middleware make use of the `ctx.StopExecution()` on failure.\nfunc (ctx *Context) Proceed(h Handler) bool {\n\tctx.proceeded = internalPauseExecutionIndex\n\n\t// Store the current index.\n\tbeforeIdx := ctx.currentHandlerIndex\n\th(ctx)\n\t// Retrieve the next one, if Next is called this is beforeIdx + 1 and so on.\n\tafterIdx := ctx.currentHandlerIndex\n\t// Restore prev index, no matter what.\n\tctx.currentHandlerIndex = beforeIdx\n\n\tproceededByNext := ctx.proceeded == internalProceededHandlerIndex\n\tctx.proceeded = beforeIdx\n\n\t// Stop called, return false but keep the handlers index.\n\tif afterIdx == stopExecutionIndex {\n\t\treturn false\n\t}\n\n\tif proceededByNext {\n\t\treturn true\n\t}\n\n\t// Next called or not.\n\treturn afterIdx > beforeIdx\n}\n\n// HandlerName returns the current handler's name, helpful for debugging.\nfunc (ctx *Context) HandlerName() string {\n\treturn HandlerName(ctx.handlers[ctx.currentHandlerIndex])\n}\n\n// HandlerFileLine returns the current running handler's function source file and line information.\n// Useful mostly when debugging.\nfunc (ctx *Context) HandlerFileLine() (file string, line int) {\n\treturn HandlerFileLine(ctx.handlers[ctx.currentHandlerIndex])\n}\n\n// RouteName returns the route name that this handler is running on.\n// Note that it may return empty on not found handlers.\nfunc (ctx *Context) RouteName() string {\n\tif ctx.currentRoute == nil {\n\t\treturn \"\"\n\t}\n\n\treturn ctx.currentRoute.Name()\n}\n\n// Next calls the next handler from the handlers chain,\n// it should be used inside a middleware.\nfunc (ctx *Context) Next() {\n\tif ctx.IsStopped() {\n\t\treturn\n\t}\n\n\tif ctx.proceeded <= internalPauseExecutionIndex /* pause and proceeded */ {\n\t\tctx.proceeded = internalProceededHandlerIndex\n\t\treturn\n\t}\n\n\tnextIndex, n := ctx.currentHandlerIndex+1, len(ctx.handlers)\n\tif nextIndex < n {\n\t\tctx.currentHandlerIndex = nextIndex\n\t\tctx.handlers[nextIndex](ctx)\n\t}\n}\n\n// NextOr checks if chain has a next handler, if so then it executes it\n// otherwise it sets a new chain assigned to this Context based on the given handler(s)\n// and executes its first handler.\n//\n// Returns true if next handler exists and executed, otherwise false.\n//\n// Note that if no next handler found and handlers are missing then\n// it sends a Status Not Found (404) to the client and it stops the execution.\nfunc (ctx *Context) NextOr(handlers ...Handler) bool {\n\tif next := ctx.NextHandler(); next != nil {\n\t\tctx.Skip() // skip this handler from the chain.\n\t\tnext(ctx)\n\t\treturn true\n\t}\n\n\tif len(handlers) == 0 {\n\t\tctx.NotFound()\n\t\tctx.StopExecution()\n\t\treturn false\n\t}\n\n\tctx.Do(handlers)\n\n\treturn false\n}\n\n// NextOrNotFound checks if chain has a next handler, if so then it executes it\n// otherwise it sends a Status Not Found (404) to the client and stops the execution.\n//\n// Returns true if next handler exists and executed, otherwise false.\nfunc (ctx *Context) NextOrNotFound() bool { return ctx.NextOr() }\n\n// NextHandler returns (it doesn't execute) the next handler from the handlers chain.\n//\n// Use .Skip() to skip this handler if needed to execute the next of this returning handler.\nfunc (ctx *Context) NextHandler() Handler {\n\tif ctx.IsStopped() {\n\t\treturn nil\n\t}\n\tnextIndex := ctx.currentHandlerIndex + 1\n\t// check if it has a next middleware\n\tif nextIndex < len(ctx.handlers) {\n\t\treturn ctx.handlers[nextIndex]\n\t}\n\treturn nil\n}\n\n// Skip skips/ignores the next handler from the handlers chain,\n// it should be used inside a middleware.\nfunc (ctx *Context) Skip() {\n\tctx.HandlerIndex(ctx.currentHandlerIndex + 1)\n}\n\nconst (\n\tstopExecutionIndex            = -1\n\tinternalPauseExecutionIndex   = -2\n\tinternalProceededHandlerIndex = -3\n)\n\n// StopExecution stops the handlers chain of this request.\n// Meaning that any following `Next` calls are ignored,\n// as a result the next handlers in the chain will not be fire.\n//\n// See ResumeExecution too.\nfunc (ctx *Context) StopExecution() {\n\tif curIdx := ctx.currentHandlerIndex; curIdx != stopExecutionIndex {\n\t\t// Protect against multiple calls of StopExecution.\n\t\t// Resume should set the last proceeded handler index.\n\t\t// Store the current index.\n\t\tctx.proceeded = curIdx\n\t\t// And stop.\n\t\tctx.currentHandlerIndex = stopExecutionIndex\n\t}\n}\n\n// IsStopped reports whether the current position of the context's handlers is -1,\n// means that the StopExecution() was called at least once.\nfunc (ctx *Context) IsStopped() bool {\n\treturn ctx.currentHandlerIndex == stopExecutionIndex\n}\n\n// ResumeExecution sets the current handler index to the last\n// index of the executed handler before StopExecution method was fired.\n//\n// Reports whether it's restored after a StopExecution call.\nfunc (ctx *Context) ResumeExecution() bool {\n\tif ctx.IsStopped() {\n\t\tctx.currentHandlerIndex = ctx.proceeded\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// StopWithStatus stops the handlers chain and writes the \"statusCode\".\n//\n// If the status code is a failure one then\n// it will also fire the specified error code handler.\nfunc (ctx *Context) StopWithStatus(statusCode int) {\n\tctx.StopExecution()\n\tctx.StatusCode(statusCode)\n}\n\n// StopWithText stops the handlers chain and writes the \"statusCode\"\n// among with a fmt-style text of \"format\" and optional arguments.\n//\n// If the status code is a failure one then\n// it will also fire the specified error code handler.\nfunc (ctx *Context) StopWithText(statusCode int, format string, args ...interface{}) {\n\tctx.StopWithStatus(statusCode)\n\tctx.WriteString(fmt.Sprintf(format, args...))\n}\n\n// StopWithError stops the handlers chain and writes the \"statusCode\"\n// among with the error \"err\".\n// It Calls the `SetErr` method so error handlers can access the given error.\n//\n// If the status code is a failure one then\n// it will also fire the specified error code handler.\n//\n// If the given \"err\" is private then the\n// status code's text is rendered instead (unless a registered error handler overrides it).\nfunc (ctx *Context) StopWithError(statusCode int, err error) {\n\tif err == nil {\n\t\treturn\n\t}\n\n\tctx.SetErr(err)\n\tif _, ok := err.(ErrPrivate); ok {\n\t\t// error is private, we SHOULD not render it,\n\t\t// leave the error handler alone to\n\t\t// render the code's text instead.\n\t\tctx.StopWithStatus(statusCode)\n\t\treturn\n\t}\n\n\tctx.StopWithText(statusCode, err.Error())\n}\n\n// StopWithPlainError like `StopWithError` but it does NOT\n// write anything to the response writer, it stores the error\n// so any error handler matching the given \"statusCode\" can handle it by its own.\nfunc (ctx *Context) StopWithPlainError(statusCode int, err error) {\n\tif err == nil {\n\t\treturn\n\t}\n\n\tctx.SetErr(err)\n\tctx.StopWithStatus(statusCode)\n}\n\n// StopWithJSON stops the handlers chain, writes the status code\n// and sends a JSON response.\n//\n// If the status code is a failure one then\n// it will also fire the specified error code handler.\nfunc (ctx *Context) StopWithJSON(statusCode int, jsonObject interface{}) {\n\tctx.StopWithStatus(statusCode)\n\tctx.JSON(jsonObject)\n}\n\n// StopWithProblem stops the handlers chain, writes the status code\n// and sends an application/problem+json response.\n// See `iris.NewProblem` to build a \"problem\" value correctly.\n//\n// If the status code is a failure one then\n// it will also fire the specified error code handler.\nfunc (ctx *Context) StopWithProblem(statusCode int, problem Problem) {\n\tctx.StopWithStatus(statusCode)\n\tproblem.Status(statusCode)\n\tctx.Problem(problem)\n}\n\n//  +------------------------------------------------------------+\n//  | Current \"user/request\" storage                             |\n//  | and share information between the handlers - Values().     |\n//  | Save and get named path parameters - Params()              |\n//  +------------------------------------------------------------+\n\n// Params returns the current url's named parameters key-value storage.\n// Named path parameters are being saved here.\n// This storage, as the whole context, is per-request lifetime.\nfunc (ctx *Context) Params() *RequestParams {\n\treturn &ctx.params\n}\n\n// Values returns the current \"user\" storage.\n// Named path parameters and any optional data can be saved here.\n// This storage, as the whole context, is per-request lifetime.\n//\n// You can use this function to Set and Get local values\n// that can be used to share information between handlers and middleware.\nfunc (ctx *Context) Values() *memstore.Store {\n\treturn &ctx.values\n}\n\n//  +------------------------------------------------------------+\n//  | Path, Host, Subdomain, IP, Headers etc...                  |\n//  +------------------------------------------------------------+\n\n// Method returns the request.Method, the client's http method to the server.\nfunc (ctx *Context) Method() string {\n\treturn ctx.request.Method\n}\n\n// Path returns the full request path,\n// escaped if EnablePathEscape config field is true.\nfunc (ctx *Context) Path() string {\n\treturn ctx.RequestPath(ctx.app.ConfigurationReadOnly().GetEnablePathEscape())\n}\n\n// DecodeQuery returns the uri parameter as url (string)\n// useful when you want to pass something to a database and be valid to retrieve it via context.Param\n// use it only for special cases, when the default behavior doesn't suits you.\n//\n// http://www.blooberry.com/indexdot/html/topics/urlencoding.htm\n// it uses just the url.QueryUnescape\nfunc DecodeQuery(path string) string {\n\tif path == \"\" {\n\t\treturn \"\"\n\t}\n\tencodedPath, err := url.QueryUnescape(path)\n\tif err != nil {\n\t\treturn path\n\t}\n\treturn encodedPath\n}\n\n// DecodeURL returns the decoded uri\n// useful when you want to pass something to a database and be valid to retrieve it via context.Param\n// use it only for special cases, when the default behavior doesn't suits you.\n//\n// http://www.blooberry.com/indexdot/html/topics/urlencoding.htm\n// it uses just the url.Parse\nfunc DecodeURL(uri string) string {\n\tu, err := url.Parse(uri)\n\tif err != nil {\n\t\treturn uri\n\t}\n\treturn u.String()\n}\n\n// RequestPath returns the full request path,\n// based on the 'escape'.\nfunc (ctx *Context) RequestPath(escape bool) string {\n\tif escape {\n\t\treturn ctx.request.URL.EscapedPath() // DecodeQuery(ctx.request.URL.EscapedPath())\n\t}\n\n\treturn ctx.request.URL.Path // RawPath returns empty, requesturi can be used instead also.\n}\n\nconst sufscheme = \"://\"\n\n// GetScheme returns the full scheme of the request URL (https://, http:// or ws:// and e.t.c.``).\nfunc GetScheme(r *http.Request) string {\n\tscheme := r.URL.Scheme\n\n\tif scheme == \"\" {\n\t\tif r.TLS != nil {\n\t\t\tscheme = netutil.SchemeHTTPS\n\t\t} else {\n\t\t\tscheme = netutil.SchemeHTTP\n\t\t}\n\t}\n\n\treturn scheme + sufscheme\n}\n\n// Scheme returns the full scheme of the request (including :// suffix).\nfunc (ctx *Context) Scheme() string {\n\treturn GetScheme(ctx.Request())\n}\n\n// PathPrefixMap accepts a map of string and a handler.\n// The key of \"m\" is the key, which is the prefix, regular expressions are not valid.\n// The value of \"m\" is the handler that will be executed if HasPrefix(context.Path).\n// func (ctx *Context) PathPrefixMap(m map[string]context.Handler) bool {\n// \tpath := ctx.Path()\n// \tfor k, v := range m {\n// \t\tif strings.HasPrefix(path, k) {\n// \t\t\tv(ctx)\n// \t\t\treturn true\n// \t\t}\n// \t}\n// \treturn false\n// } no, it will not work because map is a random peek data structure.\n\n// GetHost returns the host part of the current URI.\nfunc GetHost(r *http.Request) string {\n\t// contains subdomain.\n\tif host := r.URL.Host; host != \"\" {\n\t\treturn host\n\t}\n\treturn r.Host\n}\n\n// Host returns the host:port part of the request URI, calls the `Request().Host`.\n// To get the subdomain part as well use the `Request().URL.Host` method instead.\n// To get the subdomain only use the `Subdomain` method instead.\n// This method makes use of the `Configuration.HostProxyHeaders` field too.\nfunc (ctx *Context) Host() string {\n\tfor header, ok := range ctx.app.ConfigurationReadOnly().GetHostProxyHeaders() {\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tif host := ctx.GetHeader(header); host != \"\" {\n\t\t\treturn host\n\t\t}\n\t}\n\n\treturn GetHost(ctx.request)\n}\n\n// GetDomain resolves and returns the server's domain.\nfunc GetDomain(hostport string) string {\n\thost := hostport\n\tif tmp, _, err := net.SplitHostPort(hostport); err == nil {\n\t\thost = tmp\n\t}\n\n\tswitch host {\n\t// We could use the netutil.LoopbackRegex but leave it as it's for now, it's faster.\n\tcase \"localhost\", \"127.0.0.1\", \"0.0.0.0\", \"::1\", \"[::1]\", \"0:0:0:0:0:0:0:0\", \"0:0:0:0:0:0:0:1\":\n\t\t// loopback.\n\t\treturn \"localhost\"\n\tdefault:\n\t\tif domain, err := publicsuffix.EffectiveTLDPlusOne(host); err == nil {\n\t\t\thost = domain\n\t\t}\n\n\t\treturn host\n\t}\n}\n\n// Domain returns the root level domain.\nfunc (ctx *Context) Domain() string {\n\treturn GetDomain(ctx.Host())\n}\n\n// GetSubdomainFull returns the full subdomain level, e.g.\n// [test.user.]mydomain.com.\nfunc GetSubdomainFull(r *http.Request) string {\n\thost := GetHost(r)            // host:port\n\trootDomain := GetDomain(host) // mydomain.com\n\trootDomainIdx := strings.Index(host, rootDomain)\n\tif rootDomainIdx == -1 {\n\t\treturn \"\"\n\t}\n\n\treturn host[0:rootDomainIdx]\n}\n\n// SubdomainFull returns the full subdomain level, e.g.\n// [test.user.]mydomain.com.\n// Note that HostProxyHeaders are being respected here.\nfunc (ctx *Context) SubdomainFull() string {\n\thost := ctx.Host()            // host:port\n\trootDomain := GetDomain(host) // mydomain.com\n\trootDomainIdx := strings.Index(host, rootDomain)\n\tif rootDomainIdx == -1 {\n\t\treturn \"\"\n\t}\n\n\treturn host[0:rootDomainIdx]\n}\n\n// Subdomain returns the first subdomain of this request,\n// e.g. [user.]mydomain.com.\n// See `SubdomainFull` too.\nfunc (ctx *Context) Subdomain() (subdomain string) {\n\thost := ctx.Host()\n\tif index := strings.IndexByte(host, '.'); index > 0 {\n\t\tsubdomain = host[0:index]\n\t}\n\n\t// listening on mydomain.com:80\n\t// subdomain = mydomain, but it's wrong, it should return \"\"\n\tvhost := ctx.app.ConfigurationReadOnly().GetVHost()\n\tif strings.Contains(vhost, subdomain) { // then it's not subdomain\n\t\treturn \"\"\n\t}\n\n\treturn\n}\n\n// FindClosest returns a list of \"n\" paths close to\n// this request based on subdomain and request path.\n//\n// Order may change.\n// Example: https://github.com/kataras/iris/tree/master/_examples/routing/intelligence/manual\nfunc (ctx *Context) FindClosest(n int) []string {\n\treturn ctx.app.FindClosestPaths(ctx.Subdomain(), ctx.Path(), n)\n}\n\n// IsWWW returns true if the current subdomain (if any) is www.\nfunc (ctx *Context) IsWWW() bool {\n\thost := ctx.Host()\n\tif index := strings.IndexByte(host, '.'); index > 0 {\n\t\t// if it has a subdomain and it's www then return true.\n\t\tif subdomain := host[0:index]; !strings.Contains(ctx.app.ConfigurationReadOnly().GetVHost(), subdomain) {\n\t\t\treturn subdomain == \"www\"\n\t\t}\n\t}\n\treturn false\n}\n\n// FullRequestURI returns the full URI,\n// including the scheme, the host and the relative requested path/resource.\nfunc (ctx *Context) FullRequestURI() string {\n\treturn ctx.AbsoluteURI(ctx.Path())\n}\n\n// RemoteAddr tries to parse and return the real client's request IP.\n//\n// Based on allowed headers names that can be modified from Configuration.RemoteAddrHeaders.\n//\n// If parse based on these headers fail then it will return the Request's `RemoteAddr` field\n// which is filled by the server before the HTTP handler,\n// unless the Configuration.RemoteAddrHeadersForce was set to true\n// which will force this method to return the first IP from RemoteAddrHeaders\n// even if it's part of a private network.\n//\n// Look `Configuration.RemoteAddrHeaders`,\n//\t\t`Configuration.RemoteAddrHeadersForce`,\n//      `Configuration.WithRemoteAddrHeader(...)`,\n//      `Configuration.WithoutRemoteAddrHeader(...)` and\n//      `Configuration.RemoteAddrPrivateSubnets` for more.\nfunc (ctx *Context) RemoteAddr() string {\n\tif remoteHeaders := ctx.app.ConfigurationReadOnly().GetRemoteAddrHeaders(); len(remoteHeaders) > 0 {\n\t\tprivateSubnets := ctx.app.ConfigurationReadOnly().GetRemoteAddrPrivateSubnets()\n\n\t\tfor _, headerName := range remoteHeaders {\n\t\t\tipAddresses := strings.Split(ctx.GetHeader(headerName), \",\")\n\t\t\tif ip, ok := netutil.GetIPAddress(ipAddresses, privateSubnets); ok {\n\t\t\t\treturn ip\n\t\t\t}\n\t\t}\n\n\t\tif ctx.app.ConfigurationReadOnly().GetRemoteAddrHeadersForce() {\n\t\t\tfor _, headerName := range remoteHeaders {\n\t\t\t\t// return the first valid IP,\n\t\t\t\t//  even if it's a part of a private network.\n\t\t\t\tipAddresses := strings.Split(ctx.GetHeader(headerName), \",\")\n\t\t\t\tfor _, addr := range ipAddresses {\n\t\t\t\t\tif ip, _, err := net.SplitHostPort(addr); err == nil {\n\t\t\t\t\t\treturn ip\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\taddr := strings.TrimSpace(ctx.request.RemoteAddr)\n\tif addr != \"\" {\n\t\t// if addr has port use the net.SplitHostPort otherwise(error occurs) take as it is\n\t\tif ip, _, err := net.SplitHostPort(addr); err == nil {\n\t\t\treturn ip\n\t\t}\n\t}\n\n\treturn addr\n}\n\n// TrimHeaderValue returns the \"v[0:first space or semicolon]\".\nfunc TrimHeaderValue(v string) string {\n\tfor i, char := range v {\n\t\tif char == ' ' || char == ';' {\n\t\t\treturn v[:i]\n\t\t}\n\t}\n\treturn v\n}\n\n// GetHeader returns the request header's value based on its name.\nfunc (ctx *Context) GetHeader(name string) string {\n\treturn ctx.request.Header.Get(name)\n}\n\n// IsAjax returns true if this request is an 'ajax request'( XMLHttpRequest)\n//\n// There is no a 100% way of knowing that a request was made via Ajax.\n// You should never trust data coming from the client, they can be easily overcome by spoofing.\n//\n// Note that \"X-Requested-With\" Header can be modified by any client(because of \"X-\"),\n// so don't rely on IsAjax for really serious stuff,\n// try to find another way of detecting the type(i.e, content type),\n// there are many blogs that describe these problems and provide different kind of solutions,\n// it's always depending on the application you're building,\n// this is the reason why this `IsAjax`` is simple enough for general purpose use.\n//\n// Read more at: https://developer.mozilla.org/en-US/docs/AJAX\n// and https://xhr.spec.whatwg.org/\nfunc (ctx *Context) IsAjax() bool {\n\treturn ctx.GetHeader(\"X-Requested-With\") == \"XMLHttpRequest\"\n}\n\nvar isMobileRegex = regexp.MustCompile(\"(?:hpw|i|web)os|alamofire|alcatel|amoi|android|avantgo|blackberry|blazer|cell|cfnetwork|darwin|dolfin|dolphin|fennec|htc|ip(?:hone|od|ad)|ipaq|j2me|kindle|midp|minimo|mobi|motorola|nec-|netfront|nokia|opera m(ob|in)i|palm|phone|pocket|portable|psp|silk-accelerated|skyfire|sony|ucbrowser|up.browser|up.link|windows ce|xda|zte|zune\")\n\n// IsMobile checks if client is using a mobile device(phone or tablet) to communicate with this server.\n// If the return value is true that means that the http client using a mobile\n// device to communicate with the server, otherwise false.\n//\n// Keep note that this checks the \"User-Agent\" request header.\nfunc (ctx *Context) IsMobile() bool {\n\ts := strings.ToLower(ctx.GetHeader(\"User-Agent\"))\n\treturn isMobileRegex.MatchString(s)\n}\n\nvar isScriptRegex = regexp.MustCompile(\"curl|wget|collectd|python|urllib|java|jakarta|httpclient|phpcrawl|libwww|perl|go-http|okhttp|lua-resty|winhttp|awesomium\")\n\n// IsScript reports whether a client is a script.\nfunc (ctx *Context) IsScript() bool {\n\ts := strings.ToLower(ctx.GetHeader(\"User-Agent\"))\n\treturn isScriptRegex.MatchString(s)\n}\n\n// IsSSL reports whether the client is running under HTTPS SSL.\n//\n// See `IsHTTP2` too.\nfunc (ctx *Context) IsSSL() bool {\n\tssl := strings.EqualFold(ctx.request.URL.Scheme, \"https\") || ctx.request.TLS != nil\n\tif !ssl {\n\t\tfor k, v := range ctx.app.ConfigurationReadOnly().GetSSLProxyHeaders() {\n\t\t\tif ctx.GetHeader(k) == v {\n\t\t\t\tssl = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn ssl\n}\n\n// IsHTTP2 reports whether the protocol version for incoming request was HTTP/2.\n// The client code always uses either HTTP/1.1 or HTTP/2.\n//\n// See `IsSSL` too.\nfunc (ctx *Context) IsHTTP2() bool {\n\treturn ctx.request.ProtoMajor == 2\n}\n\n// IsGRPC reports whether the request came from a gRPC client.\nfunc (ctx *Context) IsGRPC() bool {\n\treturn ctx.IsHTTP2() && strings.Contains(ctx.GetContentTypeRequested(), ContentGRPCHeaderValue)\n}\n\ntype (\n\t// Referrer contains the extracted information from the `GetReferrer`\n\t//\n\t// The structure contains struct tags for JSON, form, XML, YAML and TOML.\n\t// Look the `GetReferrer() Referrer` and `goreferrer` external package.\n\tReferrer struct {\n\t\t// The raw refer(r)er URL.\n\t\tRaw        string                   `json:\"raw\" form:\"raw\" xml:\"Raw\" yaml:\"Raw\" toml:\"Raw\"`\n\t\tType       ReferrerType             `json:\"type\" form:\"referrer_type\" xml:\"Type\" yaml:\"Type\" toml:\"Type\"`\n\t\tLabel      string                   `json:\"label\" form:\"referrer_form\" xml:\"Label\" yaml:\"Label\" toml:\"Label\"`\n\t\tURL        string                   `json:\"url\" form:\"referrer_url\" xml:\"URL\" yaml:\"URL\" toml:\"URL\"`\n\t\tSubdomain  string                   `json:\"subdomain\" form:\"referrer_subdomain\" xml:\"Subdomain\" yaml:\"Subdomain\" toml:\"Subdomain\"`\n\t\tDomain     string                   `json:\"domain\" form:\"referrer_domain\" xml:\"Domain\" yaml:\"Domain\" toml:\"Domain\"`\n\t\tTld        string                   `json:\"tld\" form:\"referrer_tld\" xml:\"Tld\" yaml:\"Tld\" toml:\"Tld\"`\n\t\tPath       string                   `json:\"path\" form:\"referrer_path\" xml:\"Path\" yaml:\"Path\" toml:\"Path\"`\n\t\tQuery      string                   `json:\"query\" form:\"referrer_query\" xml:\"Query\" yaml:\"Query\" toml:\"GoogleType\"`\n\t\tGoogleType ReferrerGoogleSearchType `json:\"googleType\" form:\"referrer_google_type\" xml:\"GoogleType\" yaml:\"GoogleType\" toml:\"GoogleType\"`\n\t}\n\n\t// ReferrerType is the goreferrer enum for a referrer type (indirect, direct, email, search, social).\n\tReferrerType = goreferrer.ReferrerType\n\n\t// ReferrerGoogleSearchType is the goreferrer enum for a google search type (organic, adwords).\n\tReferrerGoogleSearchType = goreferrer.GoogleSearchType\n)\n\n// String returns the raw ref url.\nfunc (ref Referrer) String() string {\n\treturn ref.Raw\n}\n\n// Contains the available values of the goreferrer enums.\nconst (\n\tReferrerInvalid ReferrerType = iota\n\tReferrerIndirect\n\tReferrerDirect\n\tReferrerEmail\n\tReferrerSearch\n\tReferrerSocial\n\n\tReferrerNotGoogleSearch ReferrerGoogleSearchType = iota\n\tReferrerGoogleOrganicSearch\n\tReferrerGoogleAdwords\n)\n\n// unnecessary but good to know the default values upfront.\nvar emptyReferrer = Referrer{Type: ReferrerInvalid, GoogleType: ReferrerNotGoogleSearch}\n\n// GetReferrer extracts and returns the information from the \"Referer\" (or \"Referrer\") header\n// and url query parameter as specified in https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy.\nfunc (ctx *Context) GetReferrer() Referrer {\n\t// the underline net/http follows the https://tools.ietf.org/html/rfc7231#section-5.5.2,\n\t// so there is nothing special left to do.\n\t// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy\n\trefURL := ctx.GetHeader(\"Referer\")\n\tif refURL == \"\" {\n\t\trefURL = ctx.GetHeader(\"Referrer\")\n\t\tif refURL == \"\" {\n\t\t\trefURL = ctx.URLParam(\"referer\")\n\t\t\tif refURL == \"\" {\n\t\t\t\trefURL = ctx.URLParam(\"referrer\")\n\t\t\t}\n\t\t}\n\t}\n\n\tif refURL == \"\" {\n\t\treturn emptyReferrer\n\t}\n\n\tif ref := goreferrer.DefaultRules.Parse(refURL); ref.Type > goreferrer.Invalid {\n\t\treturn Referrer{\n\t\t\tRaw:        refURL,\n\t\t\tType:       ReferrerType(ref.Type),\n\t\t\tLabel:      ref.Label,\n\t\t\tURL:        ref.URL,\n\t\t\tSubdomain:  ref.Subdomain,\n\t\t\tDomain:     ref.Domain,\n\t\t\tTld:        ref.Tld,\n\t\t\tPath:       ref.Path,\n\t\t\tQuery:      ref.Query,\n\t\t\tGoogleType: ReferrerGoogleSearchType(ref.GoogleType),\n\t\t}\n\t}\n\n\treturn emptyReferrer\n}\n\n// SetLanguage force-sets the language for i18n, can be used inside a middleare.\n// It has the highest priority over the rest and if it is empty then it is ignored,\n// if it set to a static string of \"default\" or to the default language's code\n// then the rest of the language extractors will not be called at all and\n// the default language will be set instead.\n//\n// See `i18n.ExtractFunc` for a more organised way of the same feature.\nfunc (ctx *Context) SetLanguage(langCode string) {\n\tctx.values.Set(ctx.app.ConfigurationReadOnly().GetLanguageContextKey(), langCode)\n}\n\n// GetLocale returns the current request's `Locale` found by i18n middleware.\n// It always fallbacks to the default one.\n// See `Tr` too.\nfunc (ctx *Context) GetLocale() Locale {\n\t// Cache the Locale itself for multiple calls of `Tr` method.\n\tcontextKey := ctx.app.ConfigurationReadOnly().GetLocaleContextKey()\n\tif v := ctx.values.Get(contextKey); v != nil {\n\t\tif locale, ok := v.(Locale); ok {\n\t\t\treturn locale\n\t\t}\n\t}\n\n\tif locale := ctx.app.I18nReadOnly().GetLocale(ctx); locale != nil {\n\t\tctx.values.Set(contextKey, locale)\n\t\treturn locale\n\t}\n\n\treturn nil\n}\n\n// Tr returns a i18n localized message based on format with optional arguments.\n// See `GetLocale` too.\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/i18n\nfunc (ctx *Context) Tr(key string, args ...interface{}) string {\n\treturn ctx.app.I18nReadOnly().TrContext(ctx, key, args...)\n}\n\n//  +------------------------------------------------------------+\n//  | Response Headers helpers                                   |\n//  +------------------------------------------------------------+\n\n// Header adds a header to the response, if value is empty\n// it removes the header by its name.\nfunc (ctx *Context) Header(name string, value string) {\n\tif value == \"\" {\n\t\tctx.writer.Header().Del(name)\n\t\treturn\n\t}\n\tctx.writer.Header().Add(name, value)\n}\n\nconst contentTypeContextKey = \"iris.content_type\"\n\nfunc shouldAppendCharset(cType string) bool {\n\tif idx := strings.IndexRune(cType, '/'); idx > 1 && len(cType) > idx+1 {\n\t\ttyp := cType[0:idx]\n\t\tif typ == \"application\" {\n\t\t\tswitch cType[idx+1:] {\n\t\t\tcase \"json\", \"xml\", \"yaml\", \"problem+json\", \"problem+xml\":\n\t\t\t\treturn true\n\t\t\tdefault:\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn true\n}\n\nfunc (ctx *Context) contentTypeOnce(cType string, charset string) {\n\tif charset == \"\" {\n\t\tcharset = ctx.app.ConfigurationReadOnly().GetCharset()\n\t}\n\n\tif shouldAppendCharset(cType) {\n\t\tcType += \"; charset=\" + charset\n\t}\n\n\tctx.values.Set(contentTypeContextKey, cType)\n\tctx.writer.Header().Set(ContentTypeHeaderKey, cType)\n}\n\n// ContentType sets the response writer's\n// header \"Content-Type\" to the 'cType'.\nfunc (ctx *Context) ContentType(cType string) {\n\tif cType == \"\" {\n\t\treturn\n\t}\n\n\tif _, wroteOnce := ctx.values.GetEntry(contentTypeContextKey); wroteOnce {\n\t\treturn\n\t}\n\n\t// 1. if it's path or a filename or an extension,\n\t// then take the content type from that,\n\t// ^ No, it's not always a file,e .g. vnd.$type\n\t// if strings.Contains(cType, \".\") {\n\t// \text := filepath.Ext(cType)\n\t// \tcType = mime.TypeByExtension(ext)\n\t// }\n\t// if doesn't contain a charset already then append it\n\tif shouldAppendCharset(cType) {\n\t\tif !strings.Contains(cType, \"charset\") {\n\t\t\tcType += \"; charset=\" + ctx.app.ConfigurationReadOnly().GetCharset()\n\t\t}\n\t}\n\n\tctx.writer.Header().Set(ContentTypeHeaderKey, cType)\n}\n\n// GetContentType returns the response writer's\n// header value of \"Content-Type\".\nfunc (ctx *Context) GetContentType() string {\n\treturn ctx.writer.Header().Get(ContentTypeHeaderKey)\n}\n\n// GetContentTypeRequested returns the request's\n// trim-ed(without the charset and priority values)\n// header value of \"Content-Type\".\nfunc (ctx *Context) GetContentTypeRequested() string {\n\t// could use mime.ParseMediaType too.\n\treturn TrimHeaderValue(ctx.GetHeader(ContentTypeHeaderKey))\n}\n\n// GetContentLength returns the request's\n// header value of \"Content-Length\".\nfunc (ctx *Context) GetContentLength() int64 {\n\tif v := ctx.GetHeader(ContentLengthHeaderKey); v != \"\" {\n\t\tn, _ := strconv.ParseInt(v, 10, 64)\n\t\treturn n\n\t}\n\treturn 0\n}\n\n// StatusCode sets the status code header to the response.\n// Look .GetStatusCode & .FireStatusCode too.\n//\n// Remember, the last one before .Write matters except recorder and transactions.\nfunc (ctx *Context) StatusCode(statusCode int) {\n\tctx.writer.WriteHeader(statusCode)\n}\n\n// NotFound emits an error 404 to the client, using the specific custom error error handler.\n// Note that you may need to call ctx.StopExecution() if you don't want the next handlers\n// to be executed. Next handlers are being executed on iris because you can alt the\n// error code and change it to a more specific one, i.e\n// users := app.Party(\"/users\")\n// users.Done(func(ctx iris.Context){ if ctx.GetStatusCode() == 400 { /*  custom error code for /users */ }})\nfunc (ctx *Context) NotFound() {\n\tctx.StatusCode(http.StatusNotFound)\n}\n\n// GetStatusCode returns the current status code of the response.\n// Look StatusCode too.\nfunc (ctx *Context) GetStatusCode() int {\n\treturn ctx.writer.StatusCode()\n}\n\n//  +------------------------------------------------------------+\n//  | Various Request and Post Data                              |\n//  +------------------------------------------------------------+\n\nfunc (ctx *Context) getQuery() url.Values {\n\tif ctx.query == nil {\n\t\tctx.query = ctx.request.URL.Query()\n\t}\n\n\treturn ctx.query\n}\n\n// URLParamExists returns true if the url parameter exists, otherwise false.\nfunc (ctx *Context) URLParamExists(name string) bool {\n\t_, exists := ctx.getQuery()[name]\n\treturn exists\n}\n\n// URLParamDefault returns the get parameter from a request, if not found then \"def\" is returned.\nfunc (ctx *Context) URLParamDefault(name string, def string) string {\n\tif v := ctx.getQuery().Get(name); v != \"\" {\n\t\treturn v\n\t}\n\n\treturn def\n}\n\n// URLParam returns the get parameter from a request, if any.\nfunc (ctx *Context) URLParam(name string) string {\n\treturn ctx.URLParamDefault(name, \"\")\n}\n\n// URLParamSlice a shortcut of ctx.Request().URL.Query()[name].\n// Like `URLParam` but it returns all values instead of a single string separated by commas.\n// Returns the values of a url query of the given \"name\" as string slice, e.g.\n// ?name=john&name=doe&name=kataras will return [ john doe kataras].\n//\n// Note that, this method skips any empty entries.\n//\n// See `URLParamsSorted` for sorted values.\nfunc (ctx *Context) URLParamSlice(name string) []string {\n\tvalues := ctx.getQuery()[name]\n\tn := len(values)\n\tif n == 0 {\n\t\treturn values\n\t}\n\n\tnormalizedValues := make([]string, 0, n)\n\n\tfor _, v := range values {\n\t\tif v == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tnormalizedValues = append(normalizedValues, v)\n\t}\n\n\treturn normalizedValues\n}\n\n// URLParamTrim returns the url query parameter with trailing white spaces removed from a request.\nfunc (ctx *Context) URLParamTrim(name string) string {\n\treturn strings.TrimSpace(ctx.URLParam(name))\n}\n\n// URLParamEscape returns the escaped url query parameter from a request.\nfunc (ctx *Context) URLParamEscape(name string) string {\n\treturn DecodeQuery(ctx.URLParam(name))\n}\n\n// ErrNotFound is the type error which API users can make use of\n// to check if a `Context` action of a `Handler` is type of Not Found,\n// e.g. URL Query Parameters.\n// Example:\n//\n// n, err := context.URLParamInt(\"url_query_param_name\")\n// if errors.Is(err, context.ErrNotFound) {\n// \t// [handle error...]\n// }\n// Another usage would be `err == context.ErrNotFound`\n// HOWEVER prefer use the new `errors.Is` as API details may change in the future.\nvar ErrNotFound = errors.New(\"not found\")\n\n// URLParamInt returns the url query parameter as int value from a request,\n// returns -1 and an error if parse failed or not found.\nfunc (ctx *Context) URLParamInt(name string) (int, error) {\n\tif v := ctx.URLParam(name); v != \"\" {\n\t\tn, err := strconv.Atoi(v)\n\t\tif err != nil {\n\t\t\treturn -1, err\n\t\t}\n\t\treturn n, nil\n\t}\n\n\treturn -1, ErrNotFound\n}\n\n// URLParamIntDefault returns the url query parameter as int value from a request,\n// if not found or parse failed then \"def\" is returned.\nfunc (ctx *Context) URLParamIntDefault(name string, def int) int {\n\tv, err := ctx.URLParamInt(name)\n\tif err != nil {\n\t\treturn def\n\t}\n\n\treturn v\n}\n\n// URLParamInt32Default returns the url query parameter as int32 value from a request,\n// if not found or parse failed then \"def\" is returned.\nfunc (ctx *Context) URLParamInt32Default(name string, def int32) int32 {\n\tif v := ctx.URLParam(name); v != \"\" {\n\t\tn, err := strconv.ParseInt(v, 10, 32)\n\t\tif err != nil {\n\t\t\treturn def\n\t\t}\n\n\t\treturn int32(n)\n\t}\n\n\treturn def\n}\n\n// URLParamInt64 returns the url query parameter as int64 value from a request,\n// returns -1 and an error if parse failed or not found.\nfunc (ctx *Context) URLParamInt64(name string) (int64, error) {\n\tif v := ctx.URLParam(name); v != \"\" {\n\t\tn, err := strconv.ParseInt(v, 10, 64)\n\t\tif err != nil {\n\t\t\treturn -1, err\n\t\t}\n\t\treturn n, nil\n\t}\n\n\treturn -1, ErrNotFound\n}\n\n// URLParamInt64Default returns the url query parameter as int64 value from a request,\n// if not found or parse failed then \"def\" is returned.\nfunc (ctx *Context) URLParamInt64Default(name string, def int64) int64 {\n\tv, err := ctx.URLParamInt64(name)\n\tif err != nil {\n\t\treturn def\n\t}\n\n\treturn v\n}\n\n// URLParamUint64 returns the url query parameter as uint64 value from a request.\n// Returns 0 on parse errors or when the URL parameter does not exist in the Query.\nfunc (ctx *Context) URLParamUint64(name string) uint64 {\n\tif v := ctx.URLParam(name); v != \"\" {\n\t\tn, err := strconv.ParseUint(v, 10, 64)\n\t\tif err != nil {\n\t\t\treturn 0\n\t\t}\n\t\treturn n\n\t}\n\n\treturn 0\n}\n\n// URLParamFloat64 returns the url query parameter as float64 value from a request,\n// returns an error and -1 if parse failed.\nfunc (ctx *Context) URLParamFloat64(name string) (float64, error) {\n\tif v := ctx.URLParam(name); v != \"\" {\n\t\tn, err := strconv.ParseFloat(v, 64)\n\t\tif err != nil {\n\t\t\treturn -1, err\n\t\t}\n\t\treturn n, nil\n\t}\n\n\treturn -1, ErrNotFound\n}\n\n// URLParamFloat64Default returns the url query parameter as float64 value from a request,\n// if not found or parse failed then \"def\" is returned.\nfunc (ctx *Context) URLParamFloat64Default(name string, def float64) float64 {\n\tv, err := ctx.URLParamFloat64(name)\n\tif err != nil {\n\t\treturn def\n\t}\n\n\treturn v\n}\n\n// URLParamBool returns the url query parameter as boolean value from a request,\n// returns an error if parse failed.\nfunc (ctx *Context) URLParamBool(name string) (bool, error) {\n\treturn strconv.ParseBool(ctx.URLParam(name))\n}\n\n// URLParams returns a map of URL Query parameters.\n// If the value of a URL parameter is a slice,\n// then it is joined as one separated by comma.\n// It returns an empty map on empty URL query.\n//\n// See URLParamsSorted too.\nfunc (ctx *Context) URLParams() map[string]string {\n\tq := ctx.getQuery()\n\tvalues := make(map[string]string, len(q))\n\n\tfor k, v := range q {\n\t\tvalues[k] = strings.Join(v, \",\")\n\t}\n\n\treturn values\n}\n\n// URLParamsSorted returns a sorted (by key) slice\n// of key-value entries of the URL Query parameters.\nfunc (ctx *Context) URLParamsSorted() []memstore.StringEntry {\n\tq := ctx.getQuery()\n\tn := len(q)\n\tif n == 0 {\n\t\treturn nil\n\t}\n\n\tkeys := make([]string, 0, n)\n\tfor key := range q {\n\t\tkeys = append(keys, key)\n\t}\n\n\tsort.Strings(keys)\n\n\tentries := make([]memstore.StringEntry, 0, n)\n\tfor _, key := range keys {\n\t\tvalue := q[key]\n\t\tentries = append(entries, memstore.StringEntry{\n\t\t\tKey:   key,\n\t\t\tValue: strings.Join(value, \",\"),\n\t\t})\n\t}\n\n\treturn entries\n}\n\n// ResetQuery clears the GET URL Query request, temporary, cache.\n// Any new URLParamXXX calls will receive the new parsed values.\nfunc (ctx *Context) ResetQuery() {\n\tctx.query = nil\n}\n\n// No need anymore, net/http checks for the Form already.\n// func (ctx *Context) askParseForm() error {\n// \tif ctx.request.Form == nil {\n// \t\tif err := ctx.request.ParseForm(); err != nil {\n// \t\t\treturn err\n// \t\t}\n// \t}\n// \treturn nil\n// }\n\n// FormValueDefault returns a single parsed form value by its \"name\",\n// including both the URL field's query parameters and the POST or PUT form data.\n//\n// Returns the \"def\" if not found.\nfunc (ctx *Context) FormValueDefault(name string, def string) string {\n\tif form, has := ctx.form(); has {\n\t\tif v := form[name]; len(v) > 0 {\n\t\t\treturn v[0]\n\t\t}\n\t}\n\treturn def\n}\n\n// FormValueDefault retruns a single parsed form value.\nfunc FormValueDefault(r *http.Request, name string, def string, postMaxMemory int64, resetBody bool) string {\n\tif form, has := GetForm(r, postMaxMemory, resetBody); has {\n\t\tif v := form[name]; len(v) > 0 {\n\t\t\treturn v[0]\n\t\t}\n\t}\n\treturn def\n}\n\n// FormValue returns a single parsed form value by its \"name\",\n// including both the URL field's query parameters and the POST or PUT form data.\nfunc (ctx *Context) FormValue(name string) string {\n\treturn ctx.FormValueDefault(name, \"\")\n}\n\n// FormValues returns the parsed form data, including both the URL\n// field's query parameters and the POST or PUT form data.\n//\n// The default form's memory maximum size is 32MB, it can be changed by the\n// `iris#WithPostMaxMemory` configurator at main configuration passed on `app.Run`'s second argument.\n// NOTE: A check for nil is necessary.\nfunc (ctx *Context) FormValues() map[string][]string {\n\tform, _ := ctx.form()\n\treturn form\n}\n\n// Form contains the parsed form data, including both the URL\n// field's query parameters and the POST or PUT form data.\nfunc (ctx *Context) form() (form map[string][]string, found bool) {\n\treturn GetForm(ctx.request, ctx.app.ConfigurationReadOnly().GetPostMaxMemory(), ctx.app.ConfigurationReadOnly().GetDisableBodyConsumptionOnUnmarshal())\n}\n\n// GetForm returns the request form (url queries, post or multipart) values.\nfunc GetForm(r *http.Request, postMaxMemory int64, resetBody bool) (form map[string][]string, found bool) {\n\t/*\n\t\tnet/http/request.go#1219\n\t\tfor k, v := range f.Value {\n\t\t\tr.Form[k] = append(r.Form[k], v...)\n\t\t\t// r.PostForm should also be populated. See Issue 9305.\n\t\t\tr.PostForm[k] = append(r.PostForm[k], v...)\n\t\t}\n\t*/\n\n\tif form := r.Form; len(form) > 0 {\n\t\treturn form, true\n\t}\n\n\tif form := r.PostForm; len(form) > 0 {\n\t\treturn form, true\n\t}\n\n\tif m := r.MultipartForm; m != nil {\n\t\tif len(m.Value) > 0 {\n\t\t\treturn m.Value, true\n\t\t}\n\t}\n\n\tvar bodyCopy []byte\n\n\tif resetBody {\n\t\t// on POST, PUT and PATCH it will read the form values from request body otherwise from URL queries.\n\t\tif m := r.Method; m == \"POST\" || m == \"PUT\" || m == \"PATCH\" {\n\t\t\tbodyCopy, _ = GetBody(r, resetBody)\n\t\t\tif len(bodyCopy) == 0 {\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t\t// r.Body = ioutil.NopCloser(io.TeeReader(r.Body, buf))\n\t\t} else {\n\t\t\tresetBody = false\n\t\t}\n\t}\n\n\t// ParseMultipartForm calls `request.ParseForm` automatically\n\t// therefore we don't need to call it here, although it doesn't hurt.\n\t// After one call to ParseMultipartForm or ParseForm,\n\t// subsequent calls have no effect, are idempotent.\n\terr := r.ParseMultipartForm(postMaxMemory)\n\tif resetBody {\n\t\tr.Body = ioutil.NopCloser(bytes.NewBuffer(bodyCopy))\n\t}\n\tif err != nil && err != http.ErrNotMultipart {\n\t\treturn nil, false\n\t}\n\n\tif form := r.Form; len(form) > 0 {\n\t\treturn form, true\n\t}\n\n\tif form := r.PostForm; len(form) > 0 {\n\t\treturn form, true\n\t}\n\n\tif m := r.MultipartForm; m != nil {\n\t\tif len(m.Value) > 0 {\n\t\t\treturn m.Value, true\n\t\t}\n\t}\n\n\treturn nil, false\n}\n\n// PostValues returns all the parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\" as a string slice.\n//\n// The default form's memory maximum size is 32MB, it can be changed by the\n// `iris#WithPostMaxMemory` configurator at main configuration passed on `app.Run`'s second argument.\n//\n// In addition, it reports whether the form was empty\n// or when the \"name\" does not exist\n// or whether the available values are empty.\n// It strips any empty key-values from the slice before return.\n//\n// Look ErrEmptyForm, ErrNotFound and ErrEmptyFormField respectfully.\n// See `PostValueMany` method too.\nfunc (ctx *Context) PostValues(name string) ([]string, error) {\n\t_, ok := ctx.form()\n\tif !ok {\n\t\tif !ctx.app.ConfigurationReadOnly().GetFireEmptyFormError() {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\treturn nil, ErrEmptyForm // empty form.\n\t}\n\n\tvalues, ok := ctx.request.PostForm[name]\n\tif !ok {\n\t\treturn nil, ErrNotFound // field does not exist\n\t}\n\n\tif len(values) == 0 ||\n\t\t// Fast check for its first empty value (see below).\n\t\tstrings.TrimSpace(values[0]) == \"\" {\n\t\treturn nil, fmt.Errorf(\"%w: %s\", ErrEmptyFormField, name)\n\t}\n\n\tfor _, value := range values {\n\t\tif value == \"\" { // if at least one empty value, then perform the strip from the beginning.\n\t\t\tresult := make([]string, 0, len(values))\n\t\t\tfor _, value := range values {\n\t\t\t\tif strings.TrimSpace(value) != \"\" {\n\t\t\t\t\tresult = append(result, value) // we store the value as it is, not space-trimmed.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(result) == 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"%w: %s\", ErrEmptyFormField, name)\n\t\t\t}\n\n\t\t\treturn result, nil\n\t\t}\n\t}\n\n\treturn values, nil\n}\n\n// PostValueMany is like `PostValues` method, it returns the post data of a given key.\n// In addition to `PostValues` though, the returned value is a single string\n// separated by commas on multiple values.\n//\n// See ErrEmptyForm, ErrNotFound and ErrEmptyFormField respectfully.\nfunc (ctx *Context) PostValueMany(name string) (string, error) {\n\tvalues, err := ctx.PostValues(name)\n\tif err != nil || len(values) == 0 {\n\t\treturn \"\", err\n\t}\n\n\treturn strings.Join(values, \",\"), nil\n}\n\n// PostValueDefault returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\".\n//\n// If not found then \"def\" is returned instead.\nfunc (ctx *Context) PostValueDefault(name string, def string) string {\n\tvalues, err := ctx.PostValues(name)\n\tif err != nil || len(values) == 0 {\n\t\treturn def // it returns \"def\" even if it's empty here.\n\t}\n\n\treturn values[len(values)-1]\n}\n\n// PostValue returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\".\n//\n// See `PostValueMany` too.\nfunc (ctx *Context) PostValue(name string) string {\n\treturn ctx.PostValueDefault(name, \"\")\n}\n\n// PostValueTrim returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\",  without trailing spaces.\nfunc (ctx *Context) PostValueTrim(name string) string {\n\treturn strings.TrimSpace(ctx.PostValue(name))\n}\n\n// PostValueInt returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\", as int.\n//\n// See ErrEmptyForm, ErrNotFound and ErrEmptyFormField respectfully.\nfunc (ctx *Context) PostValueInt(name string) (int, error) {\n\tvalues, err := ctx.PostValues(name)\n\tif err != nil || len(values) == 0 {\n\t\treturn 0, err\n\t}\n\n\treturn strconv.Atoi(values[len(values)-1])\n}\n\n// PostValueIntDefault returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\", as int.\n//\n// If not found or parse errors returns the \"def\".\nfunc (ctx *Context) PostValueIntDefault(name string, def int) int {\n\tif v, err := ctx.PostValueInt(name); err == nil {\n\t\treturn v\n\t}\n\n\treturn def\n}\n\n// PostValueInt64 returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\", as float64.\n//\n// See ErrEmptyForm, ErrNotFound and ErrEmptyFormField respectfully.\nfunc (ctx *Context) PostValueInt64(name string) (int64, error) {\n\tvalues, err := ctx.PostValues(name)\n\tif err != nil || len(values) == 0 {\n\t\treturn 0, err\n\t}\n\n\treturn strconv.ParseInt(values[len(values)-1], 10, 64)\n}\n\n// PostValueInt64Default returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\", as int64.\n//\n// If not found or parse errors returns the \"def\".\nfunc (ctx *Context) PostValueInt64Default(name string, def int64) int64 {\n\tif v, err := ctx.PostValueInt64(name); err == nil {\n\t\treturn v\n\t}\n\n\treturn def\n}\n\n// PostValueFloat64 returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\", as float64.\n//\n// See ErrEmptyForm, ErrNotFound and ErrEmptyFormField respectfully.\nfunc (ctx *Context) PostValueFloat64(name string) (float64, error) {\n\tvalues, err := ctx.PostValues(name)\n\tif err != nil || len(values) == 0 {\n\t\treturn 0, err\n\t}\n\n\treturn strconv.ParseFloat(values[len(values)-1], 64)\n}\n\n// PostValueFloat64Default returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\", as float64.\n//\n// If not found or parse errors returns the \"def\".\nfunc (ctx *Context) PostValueFloat64Default(name string, def float64) float64 {\n\tif v, err := ctx.PostValueFloat64(name); err == nil {\n\t\treturn v\n\t}\n\n\treturn def\n}\n\n// PostValueBool returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\", as bool.\n// If more than one value was binded to \"name\", then it returns the last one.\n//\n// See ErrEmptyForm, ErrNotFound and ErrEmptyFormField respectfully.\nfunc (ctx *Context) PostValueBool(name string) (bool, error) {\n\tvalues, err := ctx.PostValues(name)\n\tif err != nil || len(values) == 0 {\n\t\treturn false, err\n\t}\n\n\treturn strconv.ParseBool(values[len(values)-1]) // values cannot be empty on this state.\n}\n\n// FormFile returns the first uploaded file that received from the client.\n//\n//\n// The default form's memory maximum size is 32MB, it can be changed by the\n// `iris#WithPostMaxMemory` configurator at main configuration passed on `app.Run`'s second argument.\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/file-server/upload-file\nfunc (ctx *Context) FormFile(key string) (multipart.File, *multipart.FileHeader, error) {\n\t// we don't have access to see if the request is body stream\n\t// and then the ParseMultipartForm can be useless\n\t// here but do it in order to apply the post limit,\n\t// the internal request.FormFile will not do it if that's filled\n\t// and it's not a stream body.\n\tif err := ctx.request.ParseMultipartForm(ctx.app.ConfigurationReadOnly().GetPostMaxMemory()); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn ctx.request.FormFile(key)\n}\n\n// FormFiles same as FormFile but may return multiple file inputs based on a key, e.g. \"files[]\".\nfunc (ctx *Context) FormFiles(key string, before ...func(*Context, *multipart.FileHeader) bool) (files []multipart.File, headers []*multipart.FileHeader, err error) {\n\terr = ctx.request.ParseMultipartForm(ctx.app.ConfigurationReadOnly().GetPostMaxMemory())\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif ctx.request.MultipartForm != nil {\n\t\tfhs := ctx.request.MultipartForm.File\n\t\tif n := len(fhs); n > 0 {\n\t\t\tfiles = make([]multipart.File, 0, n)\n\t\t\theaders = make([]*multipart.FileHeader, 0, n)\n\n\t\tinnerLoop:\n\t\t\tfor _, header := range fhs[key] {\n\t\t\t\t// Fix an issue that net/http has,\n\t\t\t\t// an attacker can push a filename\n\t\t\t\t// which could lead to override existing system files\n\t\t\t\t// by ../../$header.\n\t\t\t\t// Reported by Frank through security reports.\n\t\t\t\theader.Filename = strings.ReplaceAll(header.Filename, \"../\", \"\")\n\t\t\t\theader.Filename = strings.ReplaceAll(header.Filename, \"..\\\\\", \"\")\n\n\t\t\t\tfor _, b := range before {\n\t\t\t\t\tif !b(ctx, header) {\n\t\t\t\t\t\tcontinue innerLoop\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfile, fErr := header.Open()\n\t\t\t\tif fErr != nil { // exit on first error but return the succeed.\n\t\t\t\t\treturn files, headers, fErr\n\t\t\t\t}\n\n\t\t\t\tfiles = append(files, file)\n\t\t\t\theaders = append(headers, header)\n\t\t\t}\n\t\t}\n\n\t\treturn\n\t}\n\n\treturn nil, nil, http.ErrMissingFile\n}\n\n// UploadFormFiles uploads any received file(s) from the client\n// to the system physical location \"destDirectory\".\n//\n// The second optional argument \"before\" gives caller the chance to\n// modify or cancel the *miltipart.FileHeader before saving to the disk,\n// it can be used to change a file's name based on the current request,\n// all FileHeader's options can be changed. You can ignore it if\n// you don't need to use this capability before saving a file to the disk.\n//\n// Note that it doesn't check if request body streamed.\n//\n// Returns the copied length as int64 and\n// a not nil error if at least one new file\n// can't be created due to the operating system's permissions or\n// http.ErrMissingFile if no file received.\n//\n// If you want to receive & accept files and manage them manually you can use the `context#FormFile`\n// instead and create a copy function that suits your needs or use the `SaveFormFile` method,\n// the below is for generic usage.\n//\n// The default form's memory maximum size is 32MB, it can be changed by\n// the `WithPostMaxMemory` configurator or by `SetMaxRequestBodySize` or\n// by the `LimitRequestBodySize` middleware (depends the use case).\n//\n// See `FormFile` and `FormFiles` to a more controlled way to receive a file.\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/file-server/upload-files\nfunc (ctx *Context) UploadFormFiles(destDirectory string, before ...func(*Context, *multipart.FileHeader) bool) (uploaded []*multipart.FileHeader, n int64, err error) {\n\terr = ctx.request.ParseMultipartForm(ctx.app.ConfigurationReadOnly().GetPostMaxMemory())\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tif ctx.request.MultipartForm != nil {\n\t\tif fhs := ctx.request.MultipartForm.File; fhs != nil {\n\t\t\tfor _, files := range fhs {\n\t\t\tinnerLoop:\n\t\t\t\tfor _, file := range files {\n\t\t\t\t\t// Fix an issue that net/http has,\n\t\t\t\t\t// an attacker can push a filename\n\t\t\t\t\t// which could lead to override existing system files\n\t\t\t\t\t// by ../../$file.\n\t\t\t\t\t// Reported by Frank through security reports.\n\t\t\t\t\tfile.Filename = strings.ReplaceAll(file.Filename, \"../\", \"\")\n\t\t\t\t\tfile.Filename = strings.ReplaceAll(file.Filename, \"..\\\\\", \"\")\n\n\t\t\t\t\tfor _, b := range before {\n\t\t\t\t\t\tif !b(ctx, file) {\n\t\t\t\t\t\t\tcontinue innerLoop\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tn0, err0 := ctx.SaveFormFile(file, filepath.Join(destDirectory, file.Filename))\n\t\t\t\t\tif err0 != nil {\n\t\t\t\t\t\treturn nil, 0, err0\n\t\t\t\t\t}\n\t\t\t\t\tn += n0\n\n\t\t\t\t\tuploaded = append(uploaded, file)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uploaded, n, nil\n\t\t}\n\t}\n\n\treturn nil, 0, http.ErrMissingFile\n}\n\n// SaveFormFile saves a result of `FormFile` to the \"dest\" disk full path (directory + filename).\n// See `FormFile` and `UploadFormFiles` too.\nfunc (ctx *Context) SaveFormFile(fh *multipart.FileHeader, dest string) (int64, error) {\n\tsrc, err := fh.Open()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer src.Close()\n\n\tout, err := os.Create(dest)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer out.Close()\n\n\treturn io.Copy(out, src)\n}\n\n// AbsoluteURI parses the \"s\" and returns its absolute URI form.\nfunc (ctx *Context) AbsoluteURI(s string) string {\n\tif s == \"\" {\n\t\treturn \"\"\n\t}\n\n\tif s[0] == '/' {\n\t\tscheme := ctx.request.URL.Scheme\n\t\tif scheme == \"\" {\n\t\t\tif ctx.request.TLS != nil {\n\t\t\t\tscheme = \"https:\"\n\t\t\t} else {\n\t\t\t\tscheme = \"http:\"\n\t\t\t}\n\t\t}\n\n\t\thost := ctx.Host()\n\n\t\treturn scheme + \"//\" + host + path.Clean(s)\n\t}\n\n\tif u, err := url.Parse(s); err == nil {\n\t\tr := ctx.request\n\n\t\tif u.Scheme == \"\" && u.Host == \"\" {\n\t\t\toldpath := r.URL.Path\n\t\t\tif oldpath == \"\" {\n\t\t\t\toldpath = \"/\"\n\t\t\t}\n\n\t\t\tif s == \"\" || s[0] != '/' {\n\t\t\t\tolddir, _ := path.Split(oldpath)\n\t\t\t\ts = olddir + s\n\t\t\t}\n\n\t\t\tvar query string\n\t\t\tif i := strings.Index(s, \"?\"); i != -1 {\n\t\t\t\ts, query = s[:i], s[i:]\n\t\t\t}\n\n\t\t\t// clean up but preserve trailing slash\n\t\t\ttrailing := strings.HasSuffix(s, \"/\")\n\t\t\ts = path.Clean(s)\n\t\t\tif trailing && !strings.HasSuffix(s, \"/\") {\n\t\t\t\ts += \"/\"\n\t\t\t}\n\t\t\ts += query\n\t\t}\n\t}\n\n\treturn s\n}\n\n// Redirect sends a redirect response to the client\n// of an absolute or relative target URL.\n// It accepts 2 input arguments, a string and an optional integer.\n// The first parameter is the target url to redirect.\n// The second one is the HTTP status code should be sent\n// among redirection response,\n// If the second parameter is missing, then it defaults to 302 (StatusFound).\n// It can be set to 301 (Permant redirect), StatusTemporaryRedirect(307)\n// or 303 (StatusSeeOther) if POST method.\nfunc (ctx *Context) Redirect(urlToRedirect string, statusHeader ...int) {\n\tctx.StopExecution()\n\t// get the previous status code given by the end-developer.\n\tstatus := ctx.GetStatusCode()\n\tif status < 300 { // the previous is not a RCF-valid redirect status.\n\t\tstatus = 0\n\t}\n\n\tif len(statusHeader) > 0 {\n\t\t// check if status code is passed via receivers.\n\t\tif s := statusHeader[0]; s > 0 {\n\t\t\tstatus = s\n\t\t}\n\t}\n\tif status == 0 {\n\t\t// if status remains zero then default it.\n\t\t// a 'temporary-redirect-like' which works better than for our purpose\n\t\tstatus = http.StatusFound\n\t}\n\n\thttp.Redirect(ctx.writer, ctx.request, urlToRedirect, status)\n}\n\n//  +------------------------------------------------------------+\n//  | Body Readers                                               |\n//  +------------------------------------------------------------+\n\n// SetMaxRequestBodySize sets a limit to the request body size\n// should be called before reading the request body from the client.\nfunc (ctx *Context) SetMaxRequestBodySize(limitOverBytes int64) {\n\tctx.request.Body = http.MaxBytesReader(ctx.writer, ctx.request.Body, limitOverBytes)\n}\n\n// GetBody reads and returns the request body.\nfunc GetBody(r *http.Request, resetBody bool) ([]byte, error) {\n\tdata, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resetBody {\n\t\t// * remember, Request.Body has no Bytes(), we have to consume them first\n\t\t// and after re-set them to the body, this is the only solution.\n\t\tr.Body = ioutil.NopCloser(bytes.NewBuffer(data))\n\t}\n\n\treturn data, nil\n}\n\nconst disableRequestBodyConsumptionContextKey = \"iris.request.body.record\"\n\n// RecordRequestBody same as the Application's DisableBodyConsumptionOnUnmarshal\n// configuration field but acts only for the current request.\n// It makes the request body readable more than once.\nfunc (ctx *Context) RecordRequestBody(b bool) {\n\tctx.values.Set(disableRequestBodyConsumptionContextKey, b)\n}\n\n// IsRecordingBody reports whether the request body can be readen multiple times.\nfunc (ctx *Context) IsRecordingBody() bool {\n\treturn ctx.values.GetBoolDefault(disableRequestBodyConsumptionContextKey,\n\t\tctx.app.ConfigurationReadOnly().GetDisableBodyConsumptionOnUnmarshal())\n}\n\n// GetBody reads and returns the request body.\n// The default behavior for the http request reader is to consume the data readen\n// but you can change that behavior by passing the `WithoutBodyConsumptionOnUnmarshal` Iris option\n// or by calling the `RecordRequestBody` method.\n//\n// However, whenever you can use the `ctx.Request().Body` instead.\nfunc (ctx *Context) GetBody() ([]byte, error) {\n\treturn GetBody(ctx.request, ctx.IsRecordingBody())\n}\n\n// Validator is the validator for request body on Context methods such as\n// ReadJSON, ReadMsgPack, ReadXML, ReadYAML, ReadForm, ReadQuery, ReadBody and e.t.c.\ntype Validator interface {\n\tStruct(interface{}) error\n\t// If community asks for more than a struct validation on JSON, XML, MsgPack, Form, Query and e.t.c\n\t// then we should add more methods here, alternative approach would be to have a\n\t// `Validator:Validate(interface{}) error` and a map[reflect.Kind]Validator instead.\n}\n\n// UnmarshalBody reads the request's body and binds it to a value or pointer of any type\n// Examples of usage: context.ReadJSON, context.ReadXML.\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-custom-via-unmarshaler/main.go\nfunc (ctx *Context) UnmarshalBody(outPtr interface{}, unmarshaler Unmarshaler) error {\n\tif ctx.request.Body == nil {\n\t\treturn fmt.Errorf(\"unmarshal: empty body: %w\", ErrNotFound)\n\t}\n\n\trawData, err := ctx.GetBody()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// check if the v contains its own decode\n\t// in this case the v should be a pointer also,\n\t// but this is up to the user's custom Decode implementation*\n\t//\n\t// See 'BodyDecoder' for more.\n\tif decoder, isDecoder := outPtr.(BodyDecoder); isDecoder {\n\t\treturn decoder.Decode(rawData)\n\t}\n\n\t// // check if v is already a pointer, if yes then pass as it's\n\t// if reflect.TypeOf(v).Kind() == reflect.Ptr {\n\t// \treturn unmarshaler.Unmarshal(rawData, v)\n\t// } <- no need for that, ReadJSON is documented enough to receive a pointer,\n\t// we don't need to reduce the performance here by using the reflect.TypeOf method.\n\n\t// f the v doesn't contains a self-body decoder use the custom unmarshaler to bind the body.\n\terr = unmarshaler.Unmarshal(rawData, outPtr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(outPtr)\n}\n\n// internalBodyDecoder is a generic type of decoder, usually used to export stream reading functionality\n// of a JSON request.\ntype internalBodyDecoder interface {\n\tDecode(outPutr interface{}) error\n}\n\n// Same as UnmarshalBody but it operates on body stream.\nfunc (ctx *Context) decodeBody(outPtr interface{}, decoder internalBodyDecoder) error {\n\t// check if the v contains its own decode\n\t// in this case the v should be a pointer also,\n\t// but this is up to the user's custom Decode implementation*\n\t//\n\t// See 'BodyDecoder' for more.\n\tif structDecoder, isDecoder := outPtr.(BodyDecoder); isDecoder {\n\t\trawData, err := ctx.GetBody()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn structDecoder.Decode(rawData)\n\t}\n\n\terr := decoder.Decode(outPtr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(outPtr)\n}\n\nfunc (ctx *Context) shouldOptimize() bool {\n\treturn ctx.app.ConfigurationReadOnly().GetEnableOptimizations()\n}\n\n// JSONReader holds the JSON decode options of the `Context.ReadJSON, ReadBody` methods.\ntype JSONReader struct { // Note(@kataras): struct instead of optional funcs to keep consistently with the encoder options.\n\t// DisallowUnknownFields causes the json decoder to return an error when the destination\n\t// is a struct and the input contains object keys which do not match any\n\t// non-ignored, exported fields in the destination.\n\tDisallowUnknownFields bool\n\t// If set to true then a bit faster json decoder is used instead,\n\t// note that if this is true then it overrides\n\t// the Application's EnableOptimizations configuration field.\n\tOptimize bool\n\t// This field only applies to the ReadJSONStream.\n\t// The Optimize field has no effect when this is true.\n\t// If set to true the request body stream MUST start with a `[`\n\t// and end with `]` literals, example:\n\t//  [\n\t//   {\"username\":\"john\"},\n\t//   {\"username\": \"makis\"},\n\t//   {\"username\": \"george\"}\n\t//  ]\n\t// Defaults to false: decodes a json object one by one, example:\n\t//  {\"username\":\"john\"}\n\t//  {\"username\": \"makis\"}\n\t//  {\"username\": \"george\"}\n\tArrayStream bool\n}\n\ntype internalJSONDecoder interface {\n\tinternalBodyDecoder\n\tDisallowUnknownFields()\n\tMore() bool\n}\n\nfunc (cfg JSONReader) getDecoder(r io.Reader, globalShouldOptimize bool) (decoder internalJSONDecoder) {\n\tif cfg.Optimize || globalShouldOptimize {\n\t\tdecoder = jsoniter.ConfigCompatibleWithStandardLibrary.NewDecoder(r)\n\t} else {\n\t\tdecoder = json.NewDecoder(r)\n\t}\n\n\tif cfg.DisallowUnknownFields {\n\t\tdecoder.DisallowUnknownFields()\n\t}\n\n\treturn\n}\n\n// ReadJSON reads JSON from request's body and binds it to a value of any json-valid type.\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-json/main.go\nfunc (ctx *Context) ReadJSON(outPtr interface{}, opts ...JSONReader) error {\n\tshouldOptimize := ctx.shouldOptimize()\n\n\tif len(opts) > 0 {\n\t\tcfg := opts[0]\n\t\treturn ctx.decodeBody(outPtr, cfg.getDecoder(ctx.request.Body, shouldOptimize))\n\t}\n\n\tunmarshaler := json.Unmarshal\n\tif shouldOptimize {\n\t\tunmarshaler = jsoniter.Unmarshal\n\t}\n\n\treturn ctx.UnmarshalBody(outPtr, UnmarshalerFunc(unmarshaler))\n}\n\n// ReadJSONStream is an alternative of ReadJSON which can reduce the memory load\n// by reading only one json object every time.\n// It buffers just the content required for a single json object instead of the entire string,\n// and discards that once it reaches an end of value that can be decoded into the provided struct\n// inside the onDecode's DecodeFunc.\n//\n// It accepts a function which accepts the json Decode function and returns an error.\n// The second variadic argument is optional and can be used to customize the decoder even further.\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-json-stream/main.go\nfunc (ctx *Context) ReadJSONStream(onDecode func(DecodeFunc) error, opts ...JSONReader) error {\n\tvar cfg JSONReader\n\tif len(opts) > 0 {\n\t\tcfg = opts[0]\n\t}\n\n\t// note that only the standard package supports an object\n\t// stream of arrays (when the receiver is not an array).\n\tif cfg.ArrayStream || !cfg.Optimize {\n\t\tdecoder := json.NewDecoder(ctx.request.Body)\n\t\tif cfg.DisallowUnknownFields {\n\t\t\tdecoder.DisallowUnknownFields()\n\t\t}\n\t\tdecodeFunc := decoder.Decode\n\n\t\t_, err := decoder.Token() // read open bracket.\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor decoder.More() { // hile the array contains values.\n\t\t\tif err = onDecode(decodeFunc); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t_, err = decoder.Token() // read closing bracket.\n\t\treturn err\n\t}\n\n\tdec := cfg.getDecoder(ctx.request.Body, ctx.shouldOptimize())\n\tdecodeFunc := dec.Decode\n\n\t// while the array contains values\n\tfor dec.More() {\n\t\tif err := onDecode(decodeFunc); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ReadXML reads XML from request's body and binds it to a value of any xml-valid type.\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-xml/main.go\nfunc (ctx *Context) ReadXML(outPtr interface{}) error {\n\treturn ctx.UnmarshalBody(outPtr, UnmarshalerFunc(xml.Unmarshal))\n}\n\n// ReadYAML reads YAML from request's body and binds it to the \"outPtr\" value.\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-yaml/main.go\nfunc (ctx *Context) ReadYAML(outPtr interface{}) error {\n\treturn ctx.UnmarshalBody(outPtr, UnmarshalerFunc(yaml.Unmarshal))\n}\n\nvar (\n\t// IsErrEmptyJSON reports whether the given \"err\" is caused by a\n\t// Context.ReadJSON call when the request body\n\t// didn't start with { or it was totally empty.\n\tIsErrEmptyJSON = func(err error) bool {\n\t\tif err == nil {\n\t\t\treturn false\n\t\t}\n\n\t\tif v, ok := err.(*json.SyntaxError); ok {\n\t\t\t// standard go json encoder error.\n\t\t\treturn v.Offset == 0 && v.Error() == \"unexpected end of JSON input\"\n\t\t}\n\n\t\t// when optimization is enabled, the jsoniter will report the following error:\n\t\treturn strings.Contains(err.Error(), \"readObjectStart: expect {\")\n\t}\n\n\t// IsErrPath can be used at `context#ReadForm` and `context#ReadQuery`.\n\t// It reports whether the incoming error\n\t// can be ignored when server allows unknown post values to be sent by the client.\n\t//\n\t// A shortcut for the `schema#IsErrPath`.\n\tIsErrPath = schema.IsErrPath\n\n\t// ErrEmptyForm is returned by\n\t// - `context#ReadForm`\n\t// - `context#ReadQuery`\n\t// - `context#ReadBody`\n\t// when the request data (form, query and body respectfully) is empty.\n\tErrEmptyForm = errors.New(\"empty form\")\n\n\t// ErrEmptyFormField reports whether a specific field exists but it's empty.\n\t// Usage: errors.Is(err, ErrEmptyFormField)\n\t// See postValue method. It's only returned on parsed post value methods.\n\tErrEmptyFormField = errors.New(\"empty form field\")\n\n\t// ConnectionCloseErrorSubstr if at least one of the given\n\t// substrings are found in a net.OpError:os.SyscallError error type\n\t// on `IsErrConnectionReset` then the function will report true.\n\tConnectionCloseErrorSubstr = []string{\n\t\t\"broken pipe\",\n\t\t\"connection reset by peer\",\n\t}\n\n\t// IsErrConnectionClosed reports whether the given \"err\"\n\t// is caused because of a broken connection.\n\tIsErrConnectionClosed = func(err error) bool {\n\t\tif err == nil {\n\t\t\treturn false\n\t\t}\n\n\t\tif opErr, ok := err.(*net.OpError); ok {\n\t\t\tif syscallErr, ok := opErr.Err.(*os.SyscallError); ok {\n\t\t\t\terrStr := strings.ToLower(syscallErr.Error())\n\t\t\t\tfor _, s := range ConnectionCloseErrorSubstr {\n\t\t\t\t\tif strings.Contains(errStr, s) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n)\n\n// ReadForm binds the request body of a form to the \"formObject\".\n// It supports any kind of type, including custom structs.\n// It will return nothing if request data are empty.\n// The struct field tag is \"form\".\n// Note that it will return nil error on empty form data if `Configuration.FireEmptyFormError`\n// is false (as defaulted) in this case the caller should check the pointer to\n// see if something was actually binded.\n//\n// If a client sent an unknown field, this method will return an error,\n// in order to ignore that error use the `err != nil && !iris.IsErrPath(err)`.\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-form/main.go\nfunc (ctx *Context) ReadForm(formObject interface{}) error {\n\tvalues := ctx.FormValues()\n\tif len(values) == 0 {\n\t\tif ctx.app.ConfigurationReadOnly().GetFireEmptyFormError() {\n\t\t\treturn ErrEmptyForm\n\t\t}\n\t\treturn nil\n\t}\n\n\terr := schema.DecodeForm(values, formObject)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(formObject)\n}\n\n// ReadQuery binds URL Query to \"ptr\". The struct field tag is \"url\".\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-query/main.go\nfunc (ctx *Context) ReadQuery(ptr interface{}) error {\n\tvalues := ctx.getQuery()\n\tif len(values) == 0 {\n\t\tif ctx.app.ConfigurationReadOnly().GetFireEmptyFormError() {\n\t\t\treturn ErrEmptyForm\n\t\t}\n\t\treturn nil\n\t}\n\n\terr := schema.DecodeQuery(values, ptr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(ptr)\n}\n\n// ReadHeaders binds request headers to \"ptr\". The struct field tag is \"header\".\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-headers/main.go\nfunc (ctx *Context) ReadHeaders(ptr interface{}) error {\n\terr := schema.DecodeHeaders(ctx.request.Header, ptr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(ptr)\n}\n\n// ReadParams binds URI Dynamic Path Parameters to \"ptr\". The struct field tag is \"param\".\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-params/main.go\nfunc (ctx *Context) ReadParams(ptr interface{}) error {\n\tn := ctx.params.Len()\n\tif n == 0 {\n\t\treturn nil\n\t}\n\n\tvalues := make(map[string][]string, n)\n\tctx.params.Visit(func(key string, value string) {\n\t\t// []string on path parameter, e.g.\n\t\t// /.../{tail:path}\n\t\t// Tail []string `param:\"tail\"`\n\t\tvalues[key] = strings.Split(value, \"/\")\n\t})\n\n\terr := schema.DecodeParams(values, ptr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(ptr)\n}\n\n// ReadURL is a shortcut of ReadParams and ReadQuery.\n// It binds dynamic path parameters and URL query parameters\n// to the \"ptr\" pointer struct value.\n// The struct fields may contain \"url\" or \"param\" binding tags.\n// If a validator exists then it validates the result too.\nfunc (ctx *Context) ReadURL(ptr interface{}) error {\n\tvalues := make(map[string][]string, ctx.params.Len())\n\tctx.params.Visit(func(key string, value string) {\n\t\tvalues[key] = strings.Split(value, \"/\")\n\t})\n\n\tfor k, v := range ctx.getQuery() {\n\t\tvalues[k] = append(values[k], v...)\n\t}\n\n\t// Decode using all available binding tags (url, header, param).\n\terr := schema.Decode(values, ptr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(ptr)\n}\n\n// ReadProtobuf binds the body to the \"ptr\" of a proto Message and returns any error.\n// Look `ReadJSONProtobuf` too.\nfunc (ctx *Context) ReadProtobuf(ptr proto.Message) error {\n\trawData, err := ctx.GetBody()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn proto.Unmarshal(rawData, ptr)\n}\n\n// ProtoUnmarshalOptions is a type alias for protojson.UnmarshalOptions.\ntype ProtoUnmarshalOptions = protojson.UnmarshalOptions\n\nvar defaultProtobufUnmarshalOptions ProtoUnmarshalOptions\n\n// ReadJSONProtobuf reads a JSON body request into the given \"ptr\" proto.Message.\n// Look `ReadProtobuf` too.\nfunc (ctx *Context) ReadJSONProtobuf(ptr proto.Message, opts ...ProtoUnmarshalOptions) error {\n\trawData, err := ctx.GetBody()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\topt := defaultProtobufUnmarshalOptions\n\tif len(opts) > 0 {\n\t\topt = opts[0]\n\t}\n\n\treturn opt.Unmarshal(rawData, ptr)\n}\n\n// ReadMsgPack binds the request body of msgpack format to the \"ptr\" and returns any error.\nfunc (ctx *Context) ReadMsgPack(ptr interface{}) error {\n\trawData, err := ctx.GetBody()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = msgpack.Unmarshal(rawData, ptr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(ptr)\n}\n\n// ReadBody binds the request body to the \"ptr\" depending on the HTTP Method and the Request's Content-Type.\n// If a GET method request then it reads from a form (or URL Query), otherwise\n// it tries to match (depending on the request content-type) the data format e.g.\n// JSON, Protobuf, MsgPack, XML, YAML, MultipartForm and binds the result to the \"ptr\".\n// As a special case if the \"ptr\" was a pointer to string or []byte\n// then it will bind it to the request body as it is.\nfunc (ctx *Context) ReadBody(ptr interface{}) error {\n\t// If the ptr is string or byte, read the body as it's.\n\tswitch v := ptr.(type) {\n\tcase *string:\n\t\tb, err := ctx.GetBody()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*v = string(b)\n\tcase *[]byte:\n\t\tb, err := ctx.GetBody()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tcopy(*v, b)\n\t}\n\n\tif ctx.Method() == http.MethodGet {\n\t\tif ctx.Request().URL.RawQuery != \"\" {\n\t\t\t// try read from query.\n\t\t\treturn ctx.ReadQuery(ptr)\n\t\t}\n\n\t\t// otherwise use the ReadForm,\n\t\t// it's actually the same except\n\t\t// ReadQuery will not fire errors on:\n\t\t// 1. unknown or empty url query parameters\n\t\t// 2. empty query or form (if FireEmptyFormError is enabled).\n\t\treturn ctx.ReadForm(ptr)\n\t}\n\n\tswitch ctx.GetContentTypeRequested() {\n\tcase ContentXMLHeaderValue, ContentXMLUnreadableHeaderValue:\n\t\treturn ctx.ReadXML(ptr)\n\t\t// \"%v reflect.Indirect(reflect.ValueOf(ptr)).Interface())\n\tcase ContentYAMLHeaderValue, ContentYAMLTextHeaderValue:\n\t\treturn ctx.ReadYAML(ptr)\n\tcase ContentFormHeaderValue, ContentFormMultipartHeaderValue:\n\t\treturn ctx.ReadForm(ptr)\n\tcase ContentJSONHeaderValue:\n\t\treturn ctx.ReadJSON(ptr)\n\tcase ContentProtobufHeaderValue:\n\t\tmsg, ok := ptr.(proto.Message)\n\t\tif !ok {\n\t\t\treturn ErrContentNotSupported\n\t\t}\n\n\t\treturn ctx.ReadProtobuf(msg)\n\tcase ContentMsgPackHeaderValue, ContentMsgPack2HeaderValue:\n\t\treturn ctx.ReadMsgPack(ptr)\n\tdefault:\n\t\tif ctx.Request().URL.RawQuery != \"\" {\n\t\t\t// try read from query.\n\t\t\treturn ctx.ReadQuery(ptr)\n\t\t}\n\n\t\t// otherwise default to JSON.\n\t\treturn ctx.ReadJSON(ptr)\n\t}\n}\n\n//  +------------------------------------------------------------+\n//  | Body (raw) Writers                                         |\n//  +------------------------------------------------------------+\n\n// Write writes the data to the connection as part of an HTTP reply.\n//\n// If WriteHeader has not yet been called, Write calls\n// WriteHeader(http.StatusOK) before writing the data. If the Header\n// does not contain a Content-Type line, Write adds a Content-Type set\n// to the result of passing the initial 512 bytes of written data to\n// DetectContentType.\n//\n// Depending on the HTTP protocol version and the client, calling\n// Write or WriteHeader may prevent future reads on the\n// Request.Body. For HTTP/1.x requests, handlers should read any\n// needed request body data before writing the response. Once the\n// headers have been flushed (due to either an explicit Flusher.Flush\n// call or writing enough data to trigger a flush), the request body\n// may be unavailable. For HTTP/2 requests, the Go HTTP server permits\n// handlers to continue to read the request body while concurrently\n// writing the response. However, such behavior may not be supported\n// by all HTTP/2 clients. Handlers should read before writing if\n// possible to maximize compatibility.\nfunc (ctx *Context) Write(rawBody []byte) (int, error) {\n\treturn ctx.writer.Write(rawBody)\n}\n\n// Writef formats according to a format specifier and writes to the response.\n//\n// Returns the number of bytes written and any write error encountered.\nfunc (ctx *Context) Writef(format string, a ...interface{}) (n int, err error) {\n\t/* if len(a) == 0 {\n\t \treturn ctx.WriteString(format)\n\t} ^ No, let it complain about arguments, because go test will do even if the app is running.\n\tUsers should use WriteString instead of (format, args)\n\twhen format may contain go-sprintf reserved chars (e.g. %).*/\n\n\treturn fmt.Fprintf(ctx.writer, format, a...)\n}\n\n// WriteString writes a simple string to the response.\n//\n// Returns the number of bytes written and any write error encountered.\nfunc (ctx *Context) WriteString(body string) (n int, err error) {\n\treturn io.WriteString(ctx.writer, body)\n}\n\nconst (\n\t// ContentTypeHeaderKey is the header key of \"Content-Type\".\n\tContentTypeHeaderKey = \"Content-Type\"\n\n\t// LastModifiedHeaderKey is the header key of \"Last-Modified\".\n\tLastModifiedHeaderKey = \"Last-Modified\"\n\t// IfModifiedSinceHeaderKey is the header key of \"If-Modified-Since\".\n\tIfModifiedSinceHeaderKey = \"If-Modified-Since\"\n\t// CacheControlHeaderKey is the header key of \"Cache-Control\".\n\tCacheControlHeaderKey = \"Cache-Control\"\n\t// ETagHeaderKey is the header key of \"ETag\".\n\tETagHeaderKey = \"ETag\"\n\n\t// ContentDispositionHeaderKey is the header key of \"Content-Disposition\".\n\tContentDispositionHeaderKey = \"Content-Disposition\"\n\t// ContentLengthHeaderKey is the header key of \"Content-Length\"\n\tContentLengthHeaderKey = \"Content-Length\"\n\t// ContentEncodingHeaderKey is the header key of \"Content-Encoding\".\n\tContentEncodingHeaderKey = \"Content-Encoding\"\n\t// GzipHeaderValue is the header value of \"gzip\".\n\tGzipHeaderValue = \"gzip\"\n\t// AcceptEncodingHeaderKey is the header key of \"Accept-Encoding\".\n\tAcceptEncodingHeaderKey = \"Accept-Encoding\"\n\t// VaryHeaderKey is the header key of \"Vary\".\n\tVaryHeaderKey = \"Vary\"\n)\n\nvar unixEpochTime = time.Unix(0, 0)\n\n// IsZeroTime reports whether t is obviously unspecified (either zero or Unix()=0).\nfunc IsZeroTime(t time.Time) bool {\n\treturn t.IsZero() || t.Equal(unixEpochTime)\n}\n\n// ParseTime parses a time header (such as the Date: header),\n// trying each forth formats (or three if Application's configuration's TimeFormat is defaulted)\n// that are allowed by HTTP/1.1:\n// Application's configuration's TimeFormat or/and http.TimeFormat,\n// time.RFC850, and time.ANSIC.\n//\n// Look `context#FormatTime` for the opossite operation (Time to string).\nvar ParseTime = func(ctx *Context, text string) (t time.Time, err error) {\n\tt, err = time.Parse(ctx.Application().ConfigurationReadOnly().GetTimeFormat(), text)\n\tif err != nil {\n\t\treturn http.ParseTime(text)\n\t}\n\n\treturn\n}\n\n// FormatTime returns a textual representation of the time value formatted\n// according to the Application's configuration's TimeFormat field\n// which defines the format.\n//\n// Look `context#ParseTime` for the opossite operation (string to Time).\nvar FormatTime = func(ctx *Context, t time.Time) string {\n\treturn t.Format(ctx.Application().ConfigurationReadOnly().GetTimeFormat())\n}\n\n// SetLastModified sets the \"Last-Modified\" based on the \"modtime\" input.\n// If \"modtime\" is zero then it does nothing.\n//\n// It's mostly internally on core/router and context packages.\nfunc (ctx *Context) SetLastModified(modtime time.Time) {\n\tif !IsZeroTime(modtime) {\n\t\tctx.Header(LastModifiedHeaderKey, FormatTime(ctx, modtime.UTC())) // or modtime.UTC()?\n\t}\n}\n\n// ErrPreconditionFailed may be returned from `Context` methods\n// that has to perform one or more client side preconditions before the actual check, e.g. `CheckIfModifiedSince`.\n// Usage:\n// ok, err := context.CheckIfModifiedSince(modTime)\n// if err != nil {\n//    if errors.Is(err, context.ErrPreconditionFailed) {\n//         [handle missing client conditions,such as not valid request method...]\n//     }else {\n//         [the error is probably a time parse error...]\n//    }\n// }\nvar ErrPreconditionFailed = errors.New(\"precondition failed\")\n\n// CheckIfModifiedSince checks if the response is modified since the \"modtime\".\n// Note that it has nothing to do with server-side caching.\n// It does those checks by checking if the \"If-Modified-Since\" request header\n// sent by client or a previous server response header\n// (e.g with WriteWithExpiration or HandleDir or Favicon etc.)\n// is a valid one and it's before the \"modtime\".\n//\n// A check for !modtime && err == nil is necessary to make sure that\n// it's not modified since, because it may return false but without even\n// had the chance to check the client-side (request) header due to some errors,\n// like the HTTP Method is not \"GET\" or \"HEAD\" or if the \"modtime\" is zero\n// or if parsing time from the header failed. See `ErrPreconditionFailed` too.\n//\n// It's mostly used internally, e.g. `context#WriteWithExpiration`.\nfunc (ctx *Context) CheckIfModifiedSince(modtime time.Time) (bool, error) {\n\tif method := ctx.Method(); method != http.MethodGet && method != http.MethodHead {\n\t\treturn false, fmt.Errorf(\"method: %w\", ErrPreconditionFailed)\n\t}\n\tims := ctx.GetHeader(IfModifiedSinceHeaderKey)\n\tif ims == \"\" || IsZeroTime(modtime) {\n\t\treturn false, fmt.Errorf(\"zero time: %w\", ErrPreconditionFailed)\n\t}\n\tt, err := ParseTime(ctx, ims)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\t// sub-second precision, so\n\t// use mtime < t+1s instead of mtime <= t to check for unmodified.\n\tif modtime.UTC().Before(t.Add(1 * time.Second)) {\n\t\treturn false, nil\n\t}\n\treturn true, nil\n}\n\n// WriteNotModified sends a 304 \"Not Modified\" status code to the client,\n// it makes sure that the content type, the content length headers\n// and any \"ETag\" are removed before the response sent.\n//\n// It's mostly used internally on core/router/fs.go and context methods.\nfunc (ctx *Context) WriteNotModified() {\n\t// RFC 7232 section 4.1:\n\t// a sender SHOULD NOT generate representation metadata other than the\n\t// above listed fields unless said metadata exists for the purpose of\n\t// guiding cache updates (e.g.,\" Last-Modified\" might be useful if the\n\t// response does not have an ETag field).\n\th := ctx.ResponseWriter().Header()\n\tdelete(h, ContentTypeHeaderKey)\n\tdelete(h, ContentLengthHeaderKey)\n\tif h.Get(ETagHeaderKey) != \"\" {\n\t\tdelete(h, LastModifiedHeaderKey)\n\t}\n\tctx.StatusCode(http.StatusNotModified)\n}\n\n// WriteWithExpiration works like `Write` but it will check if a resource is modified,\n// based on the \"modtime\" input argument,\n// otherwise sends a 304 status code in order to let the client-side render the cached content.\nfunc (ctx *Context) WriteWithExpiration(body []byte, modtime time.Time) (int, error) {\n\tif modified, err := ctx.CheckIfModifiedSince(modtime); !modified && err == nil {\n\t\tctx.WriteNotModified()\n\t\treturn 0, nil\n\t}\n\n\tctx.SetLastModified(modtime)\n\treturn ctx.writer.Write(body)\n}\n\n// StreamWriter registers the given stream writer for populating\n// response body.\n//\n// Access to context's and/or its' members is forbidden from writer.\n//\n// This function may be used in the following cases:\n//\n//     * if response body is too big (more than iris.LimitRequestBodySize(if set)).\n//     * if response body is streamed from slow external sources.\n//     * if response body must be streamed to the client in chunks.\n//     (aka `http server push`).\nfunc (ctx *Context) StreamWriter(writer func(w io.Writer) error) error {\n\tcancelCtx := ctx.Request().Context()\n\tnotifyClosed := cancelCtx.Done()\n\n\tfor {\n\t\tselect {\n\t\t// response writer forced to close, exit.\n\t\tcase <-notifyClosed:\n\t\t\treturn cancelCtx.Err()\n\t\tdefault:\n\t\t\tif err := writer(ctx.writer); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tctx.writer.Flush()\n\t\t}\n\t}\n}\n\n//  +------------------------------------------------------------+\n//  | Body Writers with compression                              |\n//  +------------------------------------------------------------+\n\n// ClientSupportsEncoding reports whether the\n// client expects one of the given \"encodings\" compression.\n//\n// Note, this method just reports back the first valid encoding it sees,\n// meaning that request accept-encoding offers don't matter here.\n// See `CompressWriter` too.\nfunc (ctx *Context) ClientSupportsEncoding(encodings ...string) bool {\n\tif len(encodings) == 0 {\n\t\treturn false\n\t}\n\n\tif h := ctx.GetHeader(AcceptEncodingHeaderKey); h != \"\" {\n\t\tfor _, v := range strings.Split(h, \",\") {\n\t\t\tfor _, encoding := range encodings {\n\t\t\t\tif strings.Contains(v, encoding) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}\n\n// CompressWriter enables or disables the compress response writer.\n// if the client expects a valid compression algorithm then this\n// will change the response writer to a compress writer instead.\n// All future write and rich write methods will respect this option.\n// Usage:\n// app.Use(func(ctx iris.Context){\n// \terr := ctx.CompressWriter(true)\n// \tctx.Next()\n// })\n// The recommendation is to compress data as much as possible and therefore to use this field,\n// but some types of resources, such as jpeg images, are already compressed.\n// Sometimes, using additional compression doesn't reduce payload size and\n// can even make the payload longer.\nfunc (ctx *Context) CompressWriter(enable bool) error {\n\tswitch w := ctx.writer.(type) {\n\tcase *CompressResponseWriter:\n\t\tif enable {\n\t\t\treturn nil\n\t\t}\n\n\t\tw.Disabled = true\n\tcase *ResponseRecorder:\n\t\tif enable {\n\t\t\t// If it's a recorder which already wraps the compress, exit.\n\t\t\tif _, ok := w.ResponseWriter.(*CompressResponseWriter); ok {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Keep the Recorder as ctx.writer.\n\t\t\t// Wrap the existing net/http response writer\n\t\t\t// with the compressed writer and\n\t\t\t// replace the recorder's response writer\n\t\t\t// reference with that compressed one.\n\t\t\t// Fixes an issue when Record is called before CompressWriter.\n\t\t\tcw, err := AcquireCompressResponseWriter(w.ResponseWriter, ctx.request, -1)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tw.ResponseWriter = cw\n\t\t} else {\n\t\t\tcw, ok := w.ResponseWriter.(*CompressResponseWriter)\n\t\t\tif ok {\n\t\t\t\tcw.Disabled = true\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tif !enable {\n\t\t\treturn nil\n\t\t}\n\n\t\tcw, err := AcquireCompressResponseWriter(w, ctx.request, -1)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.writer = cw\n\t}\n\n\treturn nil\n}\n\n// CompressReader accepts a boolean, which, if set to true\n// it wraps the request body reader with a reader which decompresses request data before read.\n// If the \"enable\" input argument is false then the request body will reset to the default one.\n//\n// Useful when incoming request data are compressed.\n// All future calls of `ctx.GetBody/ReadXXX/UnmarshalBody` methods will respect this option.\n//\n// Usage:\n// app.Use(func(ctx iris.Context){\n// \terr := ctx.CompressReader(true)\n// \tctx.Next()\n// })\n// More:\n// if cr, ok := ctx.Request().Body.(*CompressReader); ok {\n// \tcr.Src // the original request body\n//  cr.Encoding // the compression algorithm.\n// }\n//\n// It returns `ErrRequestNotCompressed` if client's request data are not compressed\n// (or empty)\n// or `ErrNotSupportedCompression` if server missing the decompression algorithm.\nfunc (ctx *Context) CompressReader(enable bool) error {\n\tcr, ok := ctx.request.Body.(*CompressReader)\n\tif enable {\n\t\tif ok {\n\t\t\t// already called.\n\t\t\treturn nil\n\t\t}\n\n\t\tencoding := ctx.GetHeader(ContentEncodingHeaderKey)\n\t\tif encoding == IDENTITY {\n\t\t\t// no transformation whatsoever, return nil error and\n\t\t\t// don't wrap the body reader.\n\t\t\treturn nil\n\t\t}\n\n\t\tr, err := NewCompressReader(ctx.request.Body, encoding)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.request.Body = r\n\t} else if ok {\n\t\tctx.request.Body = cr.Src\n\t}\n\n\treturn nil\n}\n\n//  +------------------------------------------------------------+\n//  | Rich Body Content Writers/Renderers                        |\n//  +------------------------------------------------------------+\n\n// ViewEngine registers a view engine for the current chain of handlers.\n// It overrides any previously registered engines, including the application's root ones.\n// Note that, because performance is everything,\n// the \"engine\" MUST be already ready-to-use,\n// meaning that its `Load` method should be called once before this method call.\n//\n// To register a view engine per-group of groups too see `Party.RegisterView` instead.\nfunc (ctx *Context) ViewEngine(engine ViewEngine) {\n\tctx.values.Set(ctx.app.ConfigurationReadOnly().GetViewEngineContextKey(), engine)\n}\n\n// ViewLayout sets the \"layout\" option if and when .View\n// is being called afterwards, in the same request.\n// Useful when need to set or/and change a layout based on the previous handlers in the chain.\n//\n// Note that the 'layoutTmplFile' argument can be set to iris.NoLayout\n// to disable the layout for a specific view render action,\n// it disables the engine's configuration's layout property.\n//\n// Look .ViewData and .View too.\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/view/context-view-data/\nfunc (ctx *Context) ViewLayout(layoutTmplFile string) {\n\tctx.values.Set(ctx.app.ConfigurationReadOnly().GetViewLayoutContextKey(), layoutTmplFile)\n}\n\n// ViewData saves one or more key-value pair in order to be passed if and when .View\n// is being called afterwards, in the same request.\n// Useful when need to set or/and change template data from previous hanadlers in the chain.\n//\n// If .View's \"binding\" argument is not nil and it's not a type of map\n// then these data are being ignored, binding has the priority, so the main route's handler can still decide.\n// If binding is a map or iris.Map then these data are being added to the view data\n// and passed to the template.\n//\n// After .View, the data are not destroyed, in order to be re-used if needed (again, in the same request as everything else),\n// to clear the view data, developers can call:\n// ctx.Set(ctx.Application().ConfigurationReadOnly().GetViewDataContextKey(), nil)\n//\n// If 'key' is empty then the value is added as it's (struct or map) and developer is unable to add other value.\n//\n// Look .ViewLayout and .View too.\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/view/context-view-data/\nfunc (ctx *Context) ViewData(key string, value interface{}) {\n\tviewDataContextKey := ctx.app.ConfigurationReadOnly().GetViewDataContextKey()\n\tif key == \"\" {\n\t\tctx.values.Set(viewDataContextKey, value)\n\t\treturn\n\t}\n\n\tv := ctx.values.Get(viewDataContextKey)\n\tif v == nil {\n\t\tctx.values.Set(viewDataContextKey, Map{key: value})\n\t\treturn\n\t}\n\n\tif data, ok := v.(map[string]interface{}); ok {\n\t\tdata[key] = value\n\t} else if data, ok := v.(Map); ok {\n\t\tdata[key] = value\n\t}\n}\n\n// GetViewData returns the values registered by `context#ViewData`.\n// The return value is `map[string]interface{}`, this means that\n// if a custom struct registered to ViewData then this function\n// will try to parse it to map, if failed then the return value is nil\n// A check for nil is always a good practise if different\n// kind of values or no data are registered via `ViewData`.\n//\n// Similarly to `viewData := ctx.Values().Get(\"iris.view.data\")` or\n// `viewData := ctx.Values().Get(ctx.Application().ConfigurationReadOnly().GetViewDataContextKey())`.\nfunc (ctx *Context) GetViewData() map[string]interface{} {\n\tviewDataContextKey := ctx.app.ConfigurationReadOnly().GetViewDataContextKey()\n\tv := ctx.values.Get(viewDataContextKey)\n\n\t// if no values found, then return nil\n\tif v == nil {\n\t\treturn nil\n\t}\n\n\t// if struct, convert it to map[string]interface{}\n\tif structs.IsStruct(v) {\n\t\treturn structs.Map(v)\n\t}\n\n\t// if pure map[string]interface{}\n\tif viewData, ok := v.(map[string]interface{}); ok {\n\t\treturn viewData\n\t}\n\n\t// if context#Map\n\tif viewData, ok := v.(Map); ok {\n\t\treturn viewData\n\t}\n\n\t// if failure, then return nil\n\treturn nil\n}\n\n// FallbackViewProvider is an interface which can be registered to the `Party.FallbackView`\n// or `Context.FallbackView` methods to handle fallback views.\n// See FallbackView, FallbackViewLayout and FallbackViewFunc.\ntype FallbackViewProvider interface {\n\tFallbackView(ctx *Context, err ErrViewNotExist) error\n} /* Notes(@kataras): If ever requested, this fallback logic (of ctx, error) can go to all necessary methods.\n   I've designed with a bit more complexity here instead of a simple filename fallback in order to give\n   the freedom to the developer to do whatever he/she wants with that template/layout not exists error,\n   e.g. have a list of fallbacks views to loop through until succeed or fire a different error than the default.\n   We also provide some helpers for common fallback actions (FallbackView, FallbackViewLayout).\n   This naming was chosen in order to be easy to follow up with the previous view-relative context features.\n   Also note that here we catch a specific error, we want the developer\n   to be aware of the rest template errors (e.g. when a template having parsing issues).\n*/\n\n// FallbackViewFunc is a function that can be registered\n// to handle view fallbacks. It accepts the Context and\n// a special error which contains information about the previous template error.\n// It implements the FallbackViewProvider interface.\n//\n// See `Context.View` method.\ntype FallbackViewFunc func(ctx *Context, err ErrViewNotExist) error\n\n// FallbackView completes the FallbackViewProvider interface.\nfunc (fn FallbackViewFunc) FallbackView(ctx *Context, err ErrViewNotExist) error {\n\treturn fn(ctx, err)\n}\n\nvar (\n\t_ FallbackViewProvider = FallbackView(\"\")\n\t_ FallbackViewProvider = FallbackViewLayout(\"\")\n)\n\n// FallbackView is a helper to register a single template filename as a fallback\n// when the provided tempate filename was not found.\ntype FallbackView string\n\n// FallbackView completes the FallbackViewProvider interface.\nfunc (f FallbackView) FallbackView(ctx *Context, err ErrViewNotExist) error {\n\tif err.IsLayout { // Not responsible to render layouts.\n\t\treturn err\n\t}\n\n\t// ctx.StatusCode(200) // Let's keep the previous status code here, developer can change it anyways.\n\treturn ctx.View(string(f), err.Data)\n}\n\n// FallbackViewLayout is a helper to register a single template filename as a fallback\n// layout when the provided layout filename was not found.\ntype FallbackViewLayout string\n\n// FallbackView completes the FallbackViewProvider interface.\nfunc (f FallbackViewLayout) FallbackView(ctx *Context, err ErrViewNotExist) error {\n\tif !err.IsLayout {\n\t\t// Responsible to render layouts only.\n\t\treturn err\n\t}\n\n\tctx.ViewLayout(string(f))\n\treturn ctx.View(err.Name, err.Data)\n}\n\nconst fallbackViewOnce = \"iris.fallback.view.once\"\n\nfunc (ctx *Context) fireFallbackViewOnce(err ErrViewNotExist) error {\n\t// Note(@kataras): this is our way to keep the same View method for\n\t// both fallback and normal views, remember, we export the whole\n\t// Context functionality to the end-developer through the fallback view provider.\n\tif ctx.values.Get(fallbackViewOnce) != nil {\n\t\treturn err\n\t}\n\n\tv := ctx.values.Get(ctx.app.ConfigurationReadOnly().GetFallbackViewContextKey())\n\tif v == nil {\n\t\treturn err\n\t}\n\n\tproviders, ok := v.([]FallbackViewProvider)\n\tif !ok {\n\t\treturn err\n\t}\n\n\tctx.values.Set(fallbackViewOnce, struct{}{})\n\n\tvar pErr error\n\tfor _, provider := range providers {\n\t\tpErr = provider.FallbackView(ctx, err)\n\t\tif pErr != nil {\n\t\t\tif vErr, ok := pErr.(ErrViewNotExist); ok {\n\t\t\t\t// This fallback view does not exist or it's not responsible to handle,\n\t\t\t\t// try the next.\n\t\t\t\tpErr = vErr\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// If OK then we found the correct fallback.\n\t\t// If the error was a parse error and not a template not found\n\t\t// then exit and report the pErr error.\n\t\tbreak\n\t}\n\n\treturn pErr\n}\n\n// FallbackView registers one or more fallback views for a template or a template layout.\n// When View cannot find the given filename to execute then this \"provider\"\n// is responsible to handle the error or render a different view.\n//\n// Usage:\n//  FallbackView(iris.FallbackView(\"fallback.html\"))\n//  FallbackView(iris.FallbackViewLayout(\"layouts/fallback.html\"))\n//  OR\n//  FallbackView(iris.FallbackViewFunc(ctx iris.Context, err iris.ErrViewNotExist) error {\n//    err.Name is the previous template name.\n//    err.IsLayout reports whether the failure came from the layout template.\n//    err.Data is the template data provided to the previous View call.\n//    [...custom logic e.g. ctx.View(\"fallback\", err.Data)]\n//  })\nfunc (ctx *Context) FallbackView(providers ...FallbackViewProvider) {\n\tkey := ctx.app.ConfigurationReadOnly().GetFallbackViewContextKey()\n\tif key == \"\" {\n\t\treturn\n\t}\n\n\tv := ctx.values.Get(key)\n\tif v == nil {\n\t\tctx.values.Set(key, providers)\n\t\treturn\n\t}\n\n\t// Can register more than one.\n\tstoredProviders, ok := v.([]FallbackViewProvider)\n\tif !ok {\n\t\treturn\n\t}\n\n\tstoredProviders = append(storedProviders, providers...)\n\tctx.values.Set(key, storedProviders)\n}\n\n// View renders a template based on the registered view engine(s).\n// First argument accepts the filename, relative to the view engine's Directory and Extension,\n// i.e: if directory is \"./templates\" and want to render the \"./templates/users/index.html\"\n// then you pass the \"users/index.html\" as the filename argument.\n//\n// The second optional argument can receive a single \"view model\".\n// If \"optionalViewModel\" exists, even if it's nil, overrides any previous `ViewData` calls.\n// If second argument is missing then binds the data through previous `ViewData` calls (e.g. middleware).\n//\n// Look .ViewData and .ViewLayout too.\n//\n// Examples: https://github.com/kataras/iris/tree/master/_examples/view\nfunc (ctx *Context) View(filename string, optionalViewModel ...interface{}) error {\n\tctx.ContentType(ContentHTMLHeaderValue)\n\n\terr := ctx.renderView(filename, optionalViewModel...)\n\tif errNotExists, ok := err.(ErrViewNotExist); ok {\n\t\terr = ctx.fireFallbackViewOnce(errNotExists)\n\t}\n\n\tif err != nil {\n\t\tif ctx.app.Logger().Level == golog.DebugLevel {\n\t\t\t// send the error back to the client, when debug mode.\n\t\t\tctx.StopWithError(http.StatusInternalServerError, err)\n\t\t} else {\n\t\t\tctx.StopWithStatus(http.StatusInternalServerError)\n\t\t}\n\t}\n\n\treturn err\n}\n\nfunc (ctx *Context) renderView(filename string, optionalViewModel ...interface{}) error {\n\tcfg := ctx.app.ConfigurationReadOnly()\n\tlayout := ctx.values.GetString(cfg.GetViewLayoutContextKey())\n\n\tvar bindingData interface{}\n\tif len(optionalViewModel) > 0 /* Don't do it: can break a lot of servers: && optionalViewModel[0] != nil */ {\n\t\t// a nil can override the existing data or model sent by `ViewData`.\n\t\tbindingData = optionalViewModel[0]\n\t} else {\n\t\tbindingData = ctx.values.Get(cfg.GetViewDataContextKey())\n\t}\n\n\tif key := cfg.GetViewEngineContextKey(); key != \"\" {\n\t\tif engineV := ctx.values.Get(key); engineV != nil {\n\t\t\tif engine, ok := engineV.(ViewEngine); ok {\n\t\t\t\treturn engine.ExecuteWriter(ctx, filename, layout, bindingData)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ctx.app.View(ctx, filename, layout, bindingData)\n}\n\nconst (\n\t// ContentBinaryHeaderValue header value for binary data.\n\tContentBinaryHeaderValue = \"application/octet-stream\"\n\t// ContentWebassemblyHeaderValue header value for web assembly files.\n\tContentWebassemblyHeaderValue = \"application/wasm\"\n\t// ContentHTMLHeaderValue is the  string of text/html response header's content type value.\n\tContentHTMLHeaderValue = \"text/html\"\n\t// ContentJSONHeaderValue header value for JSON data.\n\tContentJSONHeaderValue = \"application/json\"\n\t// ContentJSONProblemHeaderValue header value for JSON API problem error.\n\t// Read more at: https://tools.ietf.org/html/rfc7807\n\tContentJSONProblemHeaderValue = \"application/problem+json\"\n\t// ContentXMLProblemHeaderValue header value for XML API problem error.\n\t// Read more at: https://tools.ietf.org/html/rfc7807\n\tContentXMLProblemHeaderValue = \"application/problem+xml\"\n\t// ContentJavascriptHeaderValue header value for JSONP & Javascript data.\n\tContentJavascriptHeaderValue = \"text/javascript\"\n\t// ContentTextHeaderValue header value for Text data.\n\tContentTextHeaderValue = \"text/plain\"\n\t// ContentXMLHeaderValue header value for XML data.\n\tContentXMLHeaderValue = \"text/xml\"\n\t// ContentXMLUnreadableHeaderValue obselete header value for XML.\n\tContentXMLUnreadableHeaderValue = \"application/xml\"\n\t// ContentMarkdownHeaderValue custom key/content type, the real is the text/html.\n\tContentMarkdownHeaderValue = \"text/markdown\"\n\t// ContentYAMLHeaderValue header value for YAML data.\n\tContentYAMLHeaderValue = \"application/x-yaml\"\n\t// ContentYAMLTextHeaderValue header value for YAML plain text.\n\tContentYAMLTextHeaderValue = \"text/yaml\"\n\t// ContentProtobufHeaderValue header value for Protobuf messages data.\n\tContentProtobufHeaderValue = \"application/x-protobuf\"\n\t// ContentMsgPackHeaderValue header value for MsgPack data.\n\tContentMsgPackHeaderValue = \"application/msgpack\"\n\t// ContentMsgPack2HeaderValue alternative header value for MsgPack data.\n\tContentMsgPack2HeaderValue = \"application/x-msgpack\"\n\t// ContentFormHeaderValue header value for post form data.\n\tContentFormHeaderValue = \"application/x-www-form-urlencoded\"\n\t// ContentFormMultipartHeaderValue header value for post multipart form data.\n\tContentFormMultipartHeaderValue = \"multipart/form-data\"\n\t// ContentGRPCHeaderValue Content-Type header value for gRPC.\n\tContentGRPCHeaderValue = \"application/grpc\"\n)\n\n// Binary writes out the raw bytes as binary data.\nfunc (ctx *Context) Binary(data []byte) (int, error) {\n\tctx.ContentType(ContentBinaryHeaderValue)\n\treturn ctx.Write(data)\n}\n\n// Text writes out a string as plain text.\nfunc (ctx *Context) Text(format string, args ...interface{}) (int, error) {\n\tctx.ContentType(ContentTextHeaderValue)\n\treturn ctx.Writef(format, args...)\n}\n\n// HTML writes out a string as text/html.\nfunc (ctx *Context) HTML(format string, args ...interface{}) (int, error) {\n\tctx.ContentType(ContentHTMLHeaderValue)\n\treturn ctx.Writef(format, args...)\n}\n\n// ProtoMarshalOptions is a type alias for protojson.MarshalOptions.\ntype ProtoMarshalOptions = protojson.MarshalOptions\n\n// JSON contains the options for the JSON (Context's) Renderer.\ntype JSON struct {\n\t// http-specific\n\tStreamingJSON bool\n\t// content-specific\n\tUnescapeHTML bool\n\tIndent       string\n\tPrefix       string\n\tASCII        bool // if true writes with unicode to ASCII content.\n\tSecure       bool // if true then it prepends a \"while(1);\" when Go slice (to JSON Array) value.\n\t// proto.Message specific marshal options.\n\tProto ProtoMarshalOptions\n}\n\n// JSONP contains the options for the JSONP (Context's) Renderer.\ntype JSONP struct {\n\t// content-specific\n\tIndent   string\n\tCallback string\n}\n\n// XML contains the options for the XML (Context's) Renderer.\ntype XML struct {\n\t// content-specific\n\tIndent string\n\tPrefix string\n}\n\n// Markdown contains the options for the Markdown (Context's) Renderer.\ntype Markdown struct {\n\t// content-specific\n\tSanitize bool\n}\n\nvar (\n\tnewLineB = []byte(\"\\n\")\n\t// the html codes for unescaping.\n\tltHex = []byte(\"\\\\u003c\")\n\tlt    = []byte(\"<\")\n\n\tgtHex = []byte(\"\\\\u003e\")\n\tgt    = []byte(\">\")\n\n\tandHex = []byte(\"\\\\u0026\")\n\tand    = []byte(\"&\")\n\n\t// secure JSON.\n\tjsonArrayPrefix  = []byte(\"[\")\n\tjsonArraySuffix  = []byte(\"]\")\n\tsecureJSONPrefix = []byte(\"while(1);\")\n)\n\n// WriteJSON marshals the given interface object and writes the JSON response to the 'writer'.\n// Ignores StatusCode and StreamingJSON options.\nfunc WriteJSON(writer io.Writer, v interface{}, options JSON, optimize bool) (int, error) {\n\tvar (\n\t\tresult []byte\n\t\terr    error\n\t)\n\n\tif m, ok := v.(proto.Message); ok {\n\t\tresult, err = options.Proto.Marshal(m)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\treturn writer.Write(result)\n\t}\n\n\tif easyObject, ok := v.(easyjson.Marshaler); ok {\n\t\tjw := jwriter.Writer{NoEscapeHTML: !options.UnescapeHTML}\n\t\teasyObject.MarshalEasyJSON(&jw)\n\t\treturn jw.DumpTo(writer)\n\t}\n\n\tif !optimize && options.Indent == \"\" {\n\t\toptions.Indent = \"  \"\n\t}\n\n\tif indent := options.Indent; indent != \"\" {\n\t\tmarshalIndent := json.MarshalIndent\n\t\tif optimize {\n\t\t\tmarshalIndent = jsoniter.ConfigCompatibleWithStandardLibrary.MarshalIndent\n\t\t}\n\n\t\tresult, err = marshalIndent(v, \"\", indent)\n\t\tresult = append(result, newLineB...)\n\t} else {\n\t\tmarshal := json.Marshal\n\t\tif optimize {\n\t\t\tmarshal = jsoniter.ConfigCompatibleWithStandardLibrary.Marshal\n\t\t}\n\n\t\tresult, err = marshal(v)\n\t}\n\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tprependSecure := false\n\tif options.Secure {\n\t\tif bytes.HasPrefix(result, jsonArrayPrefix) {\n\t\t\tif options.Indent == \"\" {\n\t\t\t\tprependSecure = bytes.HasSuffix(result, jsonArraySuffix)\n\t\t\t} else {\n\t\t\t\tprependSecure = bytes.HasSuffix(bytes.TrimRightFunc(result, func(r rune) bool {\n\t\t\t\t\treturn r == '\\n' || r == '\\r'\n\t\t\t\t}), jsonArraySuffix)\n\t\t\t}\n\t\t}\n\t}\n\n\tif options.UnescapeHTML {\n\t\tresult = bytes.ReplaceAll(result, ltHex, lt)\n\t\tresult = bytes.ReplaceAll(result, gtHex, gt)\n\t\tresult = bytes.ReplaceAll(result, andHex, and)\n\t}\n\n\tif prependSecure {\n\t\tresult = append(secureJSONPrefix, result...)\n\t}\n\n\tif options.ASCII {\n\t\tif len(result) > 0 {\n\t\t\tbuf := new(bytes.Buffer)\n\t\t\tfor _, s := range bytesToString(result) {\n\t\t\t\tchar := string(s)\n\t\t\t\tif s >= 128 {\n\t\t\t\t\tchar = fmt.Sprintf(\"\\\\u%04x\", int64(s))\n\t\t\t\t}\n\t\t\t\tbuf.WriteString(char)\n\t\t\t}\n\n\t\t\tresult = buf.Bytes()\n\t\t}\n\t}\n\n\tif prefix := options.Prefix; prefix != \"\" {\n\t\tresult = append(stringToBytes(prefix), result...)\n\t}\n\n\treturn writer.Write(result)\n}\n\n// See https://golang.org/src/strings/builder.go#L45\nfunc bytesToString(b []byte) string {\n\treturn *(*string)(unsafe.Pointer(&b))\n}\n\nfunc stringToBytes(s string) []byte {\n\treturn *(*[]byte)(unsafe.Pointer(&s))\n}\n\n// DefaultJSONOptions is the optional settings that are being used\n// inside `ctx.JSON`.\nvar DefaultJSONOptions = JSON{}\n\n// JSON marshals the given interface object and writes the JSON response to the client.\n// If the value is a compatible `proto.Message` one\n// then it only uses the options.Proto settings to marshal.\nfunc (ctx *Context) JSON(v interface{}, opts ...JSON) (n int, err error) {\n\toptions := DefaultJSONOptions\n\n\tif len(opts) > 0 {\n\t\toptions = opts[0]\n\t}\n\n\tctx.ContentType(ContentJSONHeaderValue)\n\n\tif options.StreamingJSON {\n\t\tif ctx.shouldOptimize() {\n\t\t\tjsoniterConfig := jsoniter.Config{\n\t\t\t\tEscapeHTML:    !options.UnescapeHTML,\n\t\t\t\tIndentionStep: 4,\n\t\t\t}.Froze()\n\t\t\tenc := jsoniterConfig.NewEncoder(ctx.writer)\n\t\t\terr = enc.Encode(v)\n\t\t} else {\n\t\t\tenc := json.NewEncoder(ctx.writer)\n\t\t\tenc.SetEscapeHTML(!options.UnescapeHTML)\n\t\t\tenc.SetIndent(options.Prefix, options.Indent)\n\t\t\terr = enc.Encode(v)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tctx.app.Logger().Debugf(\"JSON: %v\", err)\n\t\t\tctx.StatusCode(http.StatusInternalServerError) // it handles the fallback to normal mode here which also removes any compression headers.\n\t\t\treturn 0, err\n\t\t}\n\t\treturn ctx.writer.Written(), err\n\t}\n\n\tn, err = WriteJSON(ctx.writer, v, options, ctx.shouldOptimize())\n\tif err != nil {\n\t\tctx.app.Logger().Debugf(\"JSON: %v\", err)\n\t\tctx.StatusCode(http.StatusInternalServerError)\n\t\treturn 0, err\n\t}\n\n\treturn n, err\n}\n\nvar finishCallbackB = []byte(\");\")\n\n// WriteJSONP marshals the given interface object and writes the JSON response to the writer.\nfunc WriteJSONP(writer io.Writer, v interface{}, options JSONP, optimize bool) (int, error) {\n\tif callback := options.Callback; callback != \"\" {\n\t\tn, err := writer.Write(stringToBytes(callback + \"(\"))\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\t\tdefer writer.Write(finishCallbackB)\n\t}\n\n\tif !optimize && options.Indent == \"\" {\n\t\toptions.Indent = \"    \"\n\t}\n\n\tif indent := options.Indent; indent != \"\" {\n\t\tmarshalIndent := json.MarshalIndent\n\t\tif optimize {\n\t\t\tmarshalIndent = jsoniter.ConfigCompatibleWithStandardLibrary.MarshalIndent\n\t\t}\n\n\t\tresult, err := marshalIndent(v, \"\", indent)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tresult = append(result, newLineB...)\n\t\treturn writer.Write(result)\n\t}\n\n\tmarshal := json.Marshal\n\tif optimize {\n\t\tmarshal = jsoniter.ConfigCompatibleWithStandardLibrary.Marshal\n\t}\n\n\tresult, err := marshal(v)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn writer.Write(result)\n}\n\n// DefaultJSONPOptions is the optional settings that are being used\n// inside `ctx.JSONP`.\nvar DefaultJSONPOptions = JSONP{}\n\n// JSONP marshals the given interface object and writes the JSON response to the client.\nfunc (ctx *Context) JSONP(v interface{}, opts ...JSONP) (int, error) {\n\toptions := DefaultJSONPOptions\n\n\tif len(opts) > 0 {\n\t\toptions = opts[0]\n\t}\n\n\tctx.ContentType(ContentJavascriptHeaderValue)\n\n\tn, err := WriteJSONP(ctx.writer, v, options, ctx.shouldOptimize())\n\tif err != nil {\n\t\tctx.app.Logger().Debugf(\"JSONP: %v\", err)\n\t\tctx.StatusCode(http.StatusInternalServerError)\n\t\treturn 0, err\n\t}\n\n\treturn n, err\n}\n\ntype xmlMapEntry struct {\n\tXMLName xml.Name\n\tValue   interface{} `xml:\",chardata\"`\n}\n\n// XMLMap wraps a map[string]interface{} to compatible xml marshaler,\n// in order to be able to render maps as XML on the `Context.XML` method.\n//\n// Example: `Context.XML(XMLMap(\"Root\", map[string]interface{}{...})`.\nfunc XMLMap(elementName string, v Map) xml.Marshaler {\n\treturn xmlMap{\n\t\tentries:     v,\n\t\telementName: elementName,\n\t}\n}\n\ntype xmlMap struct {\n\tentries     Map\n\telementName string\n}\n\n// MarshalXML marshals a map to XML.\nfunc (m xmlMap) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n\tif len(m.entries) == 0 {\n\t\treturn nil\n\t}\n\n\tstart.Name = xml.Name{Local: m.elementName}\n\terr := e.EncodeToken(start)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor k, v := range m.entries {\n\t\terr = e.Encode(xmlMapEntry{XMLName: xml.Name{Local: k}, Value: v})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn e.EncodeToken(start.End())\n}\n\n// WriteXML marshals the given interface object and writes the XML response to the writer.\nfunc WriteXML(writer io.Writer, v interface{}, options XML, optimize bool) (int, error) {\n\tif prefix := options.Prefix; prefix != \"\" {\n\t\tn, err := writer.Write(stringToBytes(prefix))\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\t}\n\n\tif !optimize && options.Indent == \"\" {\n\t\toptions.Indent = \"  \" // Two spaces for XML is the default indentation when not optimized.\n\t}\n\n\tif indent := options.Indent; indent != \"\" {\n\t\tresult, err := xml.MarshalIndent(v, \"\", indent)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tresult = append(result, newLineB...)\n\t\treturn writer.Write(result)\n\t}\n\n\tresult, err := xml.Marshal(v)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn writer.Write(result)\n}\n\n// DefaultXMLOptions is the optional settings that are being used\n// from `ctx.XML`.\nvar DefaultXMLOptions = XML{}\n\n// XML marshals the given interface object and writes the XML response to the client.\n// To render maps as XML see the `XMLMap` package-level function.\nfunc (ctx *Context) XML(v interface{}, opts ...XML) (int, error) {\n\toptions := DefaultXMLOptions\n\n\tif len(opts) > 0 {\n\t\toptions = opts[0]\n\t}\n\n\tctx.ContentType(ContentXMLHeaderValue)\n\n\tn, err := WriteXML(ctx.writer, v, options, ctx.shouldOptimize())\n\tif err != nil {\n\t\tctx.app.Logger().Debugf(\"XML: %v\", err)\n\t\tctx.StatusCode(http.StatusInternalServerError)\n\t\treturn 0, err\n\t}\n\n\treturn n, err\n}\n\n// Problem writes a JSON or XML problem response.\n// Order of Problem fields are not always rendered the same.\n//\n// Behaves exactly like `Context.JSON`\n// but with default ProblemOptions.JSON indent of \" \" and\n// a response content type of \"application/problem+json\" instead.\n//\n// Use the options.RenderXML and XML fields to change this behavior and\n// send a response of content type \"application/problem+xml\" instead.\n//\n// Read more at: https://github.com/kataras/iris/wiki/Routing-error-handlers\nfunc (ctx *Context) Problem(v interface{}, opts ...ProblemOptions) (int, error) {\n\toptions := DefaultProblemOptions\n\tif len(opts) > 0 {\n\t\toptions = opts[0]\n\t\t// Currently apply only if custom options passsed, otherwise,\n\t\t// with the current settings, it's not required.\n\t\t// This may change in the future though.\n\t\toptions.Apply(ctx)\n\t}\n\n\tif p, ok := v.(Problem); ok {\n\t\t// if !p.Validate() {\n\t\t// \tctx.StatusCode(http.StatusInternalServerError)\n\t\t// \treturn ErrNotValidProblem\n\t\t// }\n\t\tp.updateURIsToAbs(ctx)\n\t\tcode, _ := p.getStatus()\n\t\tif code == 0 { // get the current status code and set it to the problem.\n\t\t\tcode = ctx.GetStatusCode()\n\t\t\tctx.StatusCode(code)\n\t\t} else {\n\t\t\t// send the problem's status code\n\t\t\tctx.StatusCode(code)\n\t\t}\n\n\t\tif options.RenderXML {\n\t\t\tctx.contentTypeOnce(ContentXMLProblemHeaderValue, \"\")\n\t\t\t// Problem is an xml Marshaler already, don't use `XMLMap`.\n\t\t\treturn ctx.XML(v, options.XML)\n\t\t}\n\t}\n\n\tctx.contentTypeOnce(ContentJSONProblemHeaderValue, \"\")\n\treturn ctx.JSON(v, options.JSON)\n}\n\n// WriteMarkdown parses the markdown to html and writes these contents to the writer.\nfunc WriteMarkdown(writer io.Writer, markdownB []byte, options Markdown) (int, error) {\n\tbuf := blackfriday.Run(markdownB)\n\tif options.Sanitize {\n\t\tbuf = bluemonday.UGCPolicy().SanitizeBytes(buf)\n\t}\n\treturn writer.Write(buf)\n}\n\n// DefaultMarkdownOptions is the optional settings that are being used\n// from `WriteMarkdown` and `ctx.Markdown`.\nvar DefaultMarkdownOptions = Markdown{}\n\n// Markdown parses the markdown to html and renders its result to the client.\nfunc (ctx *Context) Markdown(markdownB []byte, opts ...Markdown) (int, error) {\n\toptions := DefaultMarkdownOptions\n\n\tif len(opts) > 0 {\n\t\toptions = opts[0]\n\t}\n\n\tctx.ContentType(ContentHTMLHeaderValue)\n\n\tn, err := WriteMarkdown(ctx.writer, markdownB, options)\n\tif err != nil {\n\t\tctx.app.Logger().Debugf(\"Markdown: %v\", err)\n\t\tctx.StatusCode(http.StatusInternalServerError)\n\t\treturn 0, err\n\t}\n\n\treturn n, err\n}\n\n// YAML marshals the \"v\" using the yaml marshaler\n// and sends the result to the client.\nfunc (ctx *Context) YAML(v interface{}) (int, error) {\n\tout, err := yaml.Marshal(v)\n\tif err != nil {\n\t\tctx.app.Logger().Debugf(\"YAML: %v\", err)\n\t\tctx.StatusCode(http.StatusInternalServerError)\n\t\treturn 0, err\n\t}\n\n\tctx.ContentType(ContentYAMLHeaderValue)\n\treturn ctx.Write(out)\n}\n\n// TextYAML marshals the \"v\" using the yaml marshaler\n// and renders to the client.\nfunc (ctx *Context) TextYAML(v interface{}) (int, error) {\n\tctx.contentTypeOnce(ContentYAMLTextHeaderValue, \"\")\n\treturn ctx.YAML(v)\n}\n\n// Protobuf parses the \"v\" of proto Message and renders its result to the client.\nfunc (ctx *Context) Protobuf(v proto.Message) (int, error) {\n\tout, err := proto.Marshal(v)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tctx.ContentType(ContentProtobufHeaderValue)\n\treturn ctx.Write(out)\n}\n\n// MsgPack parses the \"v\" of msgpack format and renders its result to the client.\nfunc (ctx *Context) MsgPack(v interface{}) (int, error) {\n\tout, err := msgpack.Marshal(v)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tctx.ContentType(ContentMsgPackHeaderValue)\n\treturn ctx.Write(out)\n}\n\n//  +-----------------------------------------------------------------------+\n//  | Content \u039degotiation                                                   |\n//  | https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation |                                       |\n//  +-----------------------------------------------------------------------+\n\n// ErrContentNotSupported returns from the `Negotiate` method\n// when server responds with 406.\nvar ErrContentNotSupported = errors.New(\"unsupported content\")\n\n// ContentSelector is the interface which structs can implement\n// to manually choose a content based on the negotiated mime (content type).\n// It can be passed to the `Context.Negotiate` method.\n//\n// See the `N` struct too.\ntype ContentSelector interface {\n\tSelectContent(mime string) interface{}\n}\n\n// ContentNegotiator is the interface which structs can implement\n// to override the `Context.Negotiate` default implementation and\n// manually respond to the client based on a manuall call of `Context.Negotiation().Build()`\n// to get the final negotiated mime and charset.\n// It can be passed to the `Context.Negotiate` method.\ntype ContentNegotiator interface {\n\t// mime and charset can be retrieved by:\n\t// mime, charset := Context.Negotiation().Build()\n\t// Pass this method to `Context.Negotiate` method\n\t// to write custom content.\n\t// Overriding the existing behavior of Context.Negotiate for selecting values based on\n\t// content types, although it can accept any custom mime type with []byte.\n\t// Content type is already set.\n\t// Use it with caution, 99.9% you don't need this but it's here for extreme cases.\n\tNegotiate(ctx *Context) (int, error)\n}\n\n// N is a struct which can be passed on the `Context.Negotiate` method.\n// It contains fields which should be filled based on the `Context.Negotiation()`\n// server side values. If no matched mime then its \"Other\" field will be sent,\n// which should be a string or []byte.\n// It completes the `ContentSelector` interface.\ntype N struct {\n\tText, HTML string\n\tMarkdown   []byte\n\tBinary     []byte\n\n\tJSON     interface{}\n\tProblem  Problem\n\tJSONP    interface{}\n\tXML      interface{}\n\tYAML     interface{}\n\tProtobuf interface{}\n\tMsgPack  interface{}\n\n\tOther []byte // custom content types.\n}\n\nvar _ ContentSelector = N{}\n\n// SelectContent returns a content based on the matched negotiated \"mime\".\nfunc (n N) SelectContent(mime string) interface{} {\n\tswitch mime {\n\tcase ContentTextHeaderValue:\n\t\treturn n.Text\n\tcase ContentHTMLHeaderValue:\n\t\treturn n.HTML\n\tcase ContentMarkdownHeaderValue:\n\t\treturn n.Markdown\n\tcase ContentBinaryHeaderValue:\n\t\treturn n.Binary\n\tcase ContentJSONHeaderValue:\n\t\treturn n.JSON\n\tcase ContentJSONProblemHeaderValue:\n\t\treturn n.Problem\n\tcase ContentJavascriptHeaderValue:\n\t\treturn n.JSONP\n\tcase ContentXMLHeaderValue, ContentXMLUnreadableHeaderValue:\n\t\treturn n.XML\n\tcase ContentYAMLHeaderValue:\n\t\treturn n.YAML\n\tcase ContentProtobufHeaderValue:\n\t\treturn n.Protobuf\n\tcase ContentMsgPackHeaderValue, ContentMsgPack2HeaderValue:\n\t\treturn n.MsgPack\n\tdefault:\n\t\treturn n.Other\n\t}\n}\n\nconst negotiationContextKey = \"iris.negotiation_builder\"\n\n// Negotiation creates once and returns the negotiation builder\n// to build server-side available prioritized content\n// for specific content type(s), charset(s) and encoding algorithm(s).\n//\n// See `Negotiate` method too.\nfunc (ctx *Context) Negotiation() *NegotiationBuilder {\n\tif n := ctx.values.Get(negotiationContextKey); n != nil {\n\t\treturn n.(*NegotiationBuilder)\n\t}\n\n\tacceptBuilder := NegotiationAcceptBuilder{}\n\tacceptBuilder.accept = parseHeader(ctx.GetHeader(\"Accept\"))\n\tacceptBuilder.charset = parseHeader(ctx.GetHeader(\"Accept-Charset\"))\n\n\tn := &NegotiationBuilder{Accept: acceptBuilder}\n\n\tctx.values.Set(negotiationContextKey, n)\n\n\treturn n\n}\n\nfunc parseHeader(headerValue string) []string {\n\tin := strings.Split(headerValue, \",\")\n\tout := make([]string, 0, len(in))\n\n\tfor _, value := range in {\n\t\t// remove any spaces and quality values such as ;q=0.8.\n\t\tv := strings.TrimSpace(strings.Split(value, \";\")[0])\n\t\tif v != \"\" {\n\t\t\tout = append(out, v)\n\t\t}\n\t}\n\n\treturn out\n}\n\n// Negotiate used for serving different representations of a resource at the same URI.\n//\n// The \"v\" can be a single `N` struct value.\n// The \"v\" can be any value completes the `ContentSelector` interface.\n// The \"v\" can be any value completes the `ContentNegotiator` interface.\n// The \"v\" can be any value of struct(JSON, JSONP, XML, YAML, Protobuf, MsgPack) or\n// string(TEXT, HTML) or []byte(Markdown, Binary) or []byte with any matched mime type.\n//\n// If the \"v\" is nil, the `Context.Negotitation()` builder's\n// content will be used instead, otherwise \"v\" overrides builder's content\n// (server mime types are still retrieved by its registered, supported, mime list)\n//\n// Set mime type priorities by `Negotiation().JSON().XML().HTML()...`.\n// Set charset priorities by `Negotiation().Charset(...)`.\n// Set encoding algorithm priorities by `Negotiation().Encoding(...)`.\n// Modify the accepted by\n// `Negotiation().Accept./Override()/.XML().JSON().Charset(...).Encoding(...)...`.\n//\n// It returns `ErrContentNotSupported` when not matched mime type(s).\n//\n// Resources:\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Charset\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding\n//\n// Supports the above without quality values.\n//\n// Read more at: https://github.com/kataras/iris/wiki/Content-negotiation\nfunc (ctx *Context) Negotiate(v interface{}) (int, error) {\n\tcontentType, charset, encoding, content := ctx.Negotiation().Build()\n\tif v == nil {\n\t\tv = content\n\t}\n\n\tif contentType == \"\" {\n\t\t// If the server cannot serve any matching set,\n\t\t// it SHOULD send back a 406 (Not Acceptable) error code.\n\t\tctx.StatusCode(http.StatusNotAcceptable)\n\t\treturn -1, ErrContentNotSupported\n\t}\n\n\tif charset == \"\" {\n\t\tcharset = ctx.app.ConfigurationReadOnly().GetCharset()\n\t}\n\n\tif encoding != \"\" {\n\t\tctx.CompressWriter(true)\n\t}\n\n\tctx.contentTypeOnce(contentType, charset)\n\n\tif n, ok := v.(ContentNegotiator); ok {\n\t\treturn n.Negotiate(ctx)\n\t}\n\n\tif s, ok := v.(ContentSelector); ok {\n\t\tv = s.SelectContent(contentType)\n\t}\n\n\t// switch v := value.(type) {\n\t// case []byte:\n\t// \tif contentType == ContentMarkdownHeaderValue {\n\t// \t\treturn ctx.Markdown(v)\n\t// \t}\n\n\t// \treturn ctx.Write(v)\n\t// case string:\n\t// \treturn ctx.WriteString(v)\n\t// default:\n\t// make it switch by content-type only, but we lose custom mime types capability that way:\n\t//                                                 ^ solved with []byte on default case and\n\t//                                                 ^ N.Other and\n\t//                                                 ^ ContentSelector and ContentNegotiator interfaces.\n\n\tswitch contentType {\n\tcase ContentTextHeaderValue, ContentHTMLHeaderValue:\n\t\treturn ctx.WriteString(v.(string))\n\tcase ContentMarkdownHeaderValue:\n\t\treturn ctx.Markdown(v.([]byte))\n\tcase ContentJSONHeaderValue:\n\t\treturn ctx.JSON(v)\n\tcase ContentJSONProblemHeaderValue, ContentXMLProblemHeaderValue:\n\t\treturn ctx.Problem(v)\n\tcase ContentJavascriptHeaderValue:\n\t\treturn ctx.JSONP(v)\n\tcase ContentXMLHeaderValue, ContentXMLUnreadableHeaderValue:\n\t\treturn ctx.XML(v)\n\tcase ContentYAMLHeaderValue:\n\t\treturn ctx.YAML(v)\n\tcase ContentYAMLTextHeaderValue:\n\t\treturn ctx.TextYAML(v)\n\tcase ContentProtobufHeaderValue:\n\t\tmsg, ok := v.(proto.Message)\n\t\tif !ok {\n\t\t\treturn -1, ErrContentNotSupported\n\t\t}\n\n\t\treturn ctx.Protobuf(msg)\n\tcase ContentMsgPackHeaderValue, ContentMsgPack2HeaderValue:\n\t\treturn ctx.MsgPack(v)\n\tdefault:\n\t\t// maybe \"Other\" or v is []byte or string but not a built-in framework mime,\n\t\t// for custom content types,\n\t\t// panic if not correct usage.\n\t\tswitch vv := v.(type) {\n\t\tcase []byte:\n\t\t\treturn ctx.Write(vv)\n\t\tcase string:\n\t\t\treturn ctx.WriteString(vv)\n\t\tdefault:\n\t\t\tctx.StatusCode(http.StatusNotAcceptable)\n\t\t\treturn -1, ErrContentNotSupported\n\t\t}\n\t}\n}\n\n// NegotiationBuilder returns from the `Context.Negotitation`\n// and can be used inside chain of handlers to build server-side\n// mime type(s), charset(s) and encoding algorithm(s)\n// that should match with the client's\n// Accept, Accept-Charset and Accept-Encoding headers (by-default).\n// To modify the client's accept use its \"Accept\" field\n// which it's the `NegotitationAcceptBuilder`.\n//\n// See the `Negotiate` method too.\ntype NegotiationBuilder struct {\n\tAccept NegotiationAcceptBuilder\n\n\tmime     []string               // we need order.\n\tcontents map[string]interface{} // map to the \"mime\" and content should be rendered if that mime requested.\n\tcharset  []string\n\tencoding []string\n}\n\n// MIME registers a mime type and optionally the value that should be rendered\n// through `Context.Negotiate` when this mime type is accepted by client.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) MIME(mime string, content interface{}) *NegotiationBuilder {\n\tmimes := parseHeader(mime) // if contains more than one sep by commas \",\".\n\tif content == nil {\n\t\tn.mime = append(n.mime, mimes...)\n\t\treturn n\n\t}\n\n\tif n.contents == nil {\n\t\tn.contents = make(map[string]interface{})\n\t}\n\n\tfor _, m := range mimes {\n\t\tn.mime = append(n.mime, m)\n\t\tn.contents[m] = content\n\t}\n\n\treturn n\n}\n\n// Text registers the \"text/plain\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"text/plain\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Text(v ...string) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentTextHeaderValue, content)\n}\n\n// HTML registers the \"text/html\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"text/html\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) HTML(v ...string) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentHTMLHeaderValue, content)\n}\n\n// Markdown registers the \"text/markdown\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"text/markdown\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Markdown(v ...[]byte) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v\n\t}\n\treturn n.MIME(ContentMarkdownHeaderValue, content)\n}\n\n// Binary registers the \"application/octet-stream\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"application/octet-stream\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Binary(v ...[]byte) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentBinaryHeaderValue, content)\n}\n\n// JSON registers the \"application/json\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"application/json\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) JSON(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentJSONHeaderValue, content)\n}\n\n// Problem registers the \"application/problem+json\" or \"application/problem+xml\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"application/problem+json\" or the \"application/problem+xml\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Problem(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentJSONProblemHeaderValue+\",\"+ContentXMLProblemHeaderValue, content)\n}\n\n// JSONP registers the \"text/javascript\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"javascript/javascript\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) JSONP(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentJavascriptHeaderValue, content)\n}\n\n// XML registers the \"text/xml\" and \"application/xml\" content types and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts one of the \"text/xml\" or \"application/xml\" content types.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) XML(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentXMLHeaderValue+\",\"+ContentXMLUnreadableHeaderValue, content)\n}\n\n// YAML registers the \"application/x-yaml\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"application/x-yaml\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) YAML(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentYAMLHeaderValue, content)\n}\n\n// TextYAML registers the \"text/yaml\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"application/x-yaml\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) TextYAML(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentYAMLTextHeaderValue, content)\n}\n\n// Protobuf registers the \"application/x-protobuf\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"application/x-protobuf\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Protobuf(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentProtobufHeaderValue, content)\n}\n\n// MsgPack registers the \"application/x-msgpack\" and \"application/msgpack\" content types and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts one of the \"application/x-msgpack\" or \"application/msgpack\" content types.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) MsgPack(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentMsgPackHeaderValue+\",\"+ContentMsgPack2HeaderValue, content)\n}\n\n// Any registers a wildcard that can match any client's accept content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Any(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(\"*\", content)\n}\n\n// Charset overrides the application's config's charset (which defaults to \"utf-8\")\n// that a client should match for\n// (through Accept-Charset header or custom through `NegotitationBuilder.Accept.Override().Charset(...)` call).\n// Do not set it if you don't know what you're doing.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Charset(charset ...string) *NegotiationBuilder {\n\tn.charset = append(n.charset, charset...)\n\treturn n\n}\n\n// Encoding registers one or more encoding algorithms by name, i.e gzip, deflate, br, snappy, s2.\n// that a client should match for (through Accept-Encoding header).\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Encoding(encoding ...string) *NegotiationBuilder {\n\tn.encoding = append(n.encoding, encoding...)\n\treturn n\n}\n\n// EncodingGzip registers the \"gzip\" encoding algorithm\n// that a client should match for (through Accept-Encoding header or call of Accept.Encoding(enc)).\n//\n// It will make resources to served by \"gzip\" if Accept-Encoding contains the \"gzip\" as well.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) EncodingGzip() *NegotiationBuilder {\n\treturn n.Encoding(GzipHeaderValue)\n}\n\n// Build calculates the client's and server's mime type(s), charset(s) and encoding\n// and returns the final content type, charset and encoding that server should render\n// to the client. It does not clear the fields, use the `Clear` method if neeeded.\n//\n// The returned \"content\" can be nil if the matched \"contentType\" does not provide any value,\n// in that case the `Context.Negotiate(v)` must be called with a non-nil value.\nfunc (n *NegotiationBuilder) Build() (contentType, charset, encoding string, content interface{}) {\n\tcontentType = negotiationMatch(n.Accept.accept, n.mime)\n\tcharset = negotiationMatch(n.Accept.charset, n.charset)\n\tencoding = negotiationMatch(n.Accept.encoding, n.encoding)\n\n\tif n.contents != nil {\n\t\tif data, ok := n.contents[contentType]; ok {\n\t\t\tcontent = data\n\t\t}\n\t}\n\n\treturn\n}\n\n// Clear clears the prioritized mime type(s), charset(s) and any contents\n// relative to those mime type(s).\n// The \"Accept\" field is stay as it is, use its `Override` method\n// to clear out the client's accepted mime type(s) and charset(s).\nfunc (n *NegotiationBuilder) Clear() *NegotiationBuilder {\n\tn.mime = n.mime[0:0]\n\tn.contents = nil\n\tn.charset = n.charset[0:0]\n\treturn n\n}\n\n// NegotiationAcceptBuilder builds the accepted mime types and charset\n//\n// and \"Accept-Charset\" headers respectfully.\n// The default values are set by the client side, server can append or override those.\n// The end result will be challenged with runtime preffered set of content types and charsets.\n//\n// See the `Negotiate` method too.\ntype NegotiationAcceptBuilder struct {\n\t// initialized with \"Accept\" request header values.\n\taccept []string\n\t// initialized with \"Accept-Charset\" request header. and if was empty then the\n\t// application's default (which defaults to utf-8).\n\tcharset []string\n\t// initialized with \"Accept-Encoding\" request header values.\n\tencoding []string\n\n\t// To support override in request life cycle.\n\t// We need slice when data is the same format\n\t// for one or more mime types,\n\t// i.e text/xml and obselete application/xml.\n\tlastAccept   []string\n\tlastCharset  []string\n\tlastEncoding []string\n}\n\n// Override clears the default values for accept and accept charset.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Override() *NegotiationAcceptBuilder {\n\t// when called first.\n\tn.accept = n.accept[0:0]\n\tn.charset = n.charset[0:0]\n\tn.encoding = n.encoding[0:0]\n\n\t// when called after.\n\tif len(n.lastAccept) > 0 {\n\t\tn.accept = append(n.accept, n.lastAccept...)\n\t\tn.lastAccept = n.lastAccept[0:0]\n\t}\n\n\tif len(n.lastCharset) > 0 {\n\t\tn.charset = append(n.charset, n.lastCharset...)\n\t\tn.lastCharset = n.lastCharset[0:0]\n\t}\n\n\tif len(n.lastEncoding) > 0 {\n\t\tn.encoding = append(n.encoding, n.lastEncoding...)\n\t\tn.lastEncoding = n.lastEncoding[0:0]\n\t}\n\n\treturn n\n}\n\n// MIME adds accepted client's mime type(s).\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) MIME(mimeType ...string) *NegotiationAcceptBuilder {\n\tn.lastAccept = mimeType\n\tn.accept = append(n.accept, mimeType...)\n\treturn n\n}\n\n// Text adds the \"text/plain\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Text() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentTextHeaderValue)\n}\n\n// HTML adds the \"text/html\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) HTML() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentHTMLHeaderValue)\n}\n\n// Markdown adds the \"text/markdown\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Markdown() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentMarkdownHeaderValue)\n}\n\n// Binary adds the \"application/octet-stream\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Binary() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentBinaryHeaderValue)\n}\n\n// JSON adds the \"application/json\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) JSON() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentJSONHeaderValue)\n}\n\n// Problem adds the \"application/problem+json\" and \"application/problem-xml\"\n// as accepted client content types.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Problem() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentJSONProblemHeaderValue, ContentXMLProblemHeaderValue)\n}\n\n// JSONP adds the \"text/javascript\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) JSONP() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentJavascriptHeaderValue)\n}\n\n// XML adds the \"text/xml\" and \"application/xml\" as accepted client content types.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) XML() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentXMLHeaderValue, ContentXMLUnreadableHeaderValue)\n}\n\n// YAML adds the \"application/x-yaml\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) YAML() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentYAMLHeaderValue)\n}\n\n// TextYAML adds the \"text/yaml\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) TextYAML() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentYAMLTextHeaderValue)\n}\n\n// Protobuf adds the \"application/x-protobuf\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Protobuf() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentYAMLHeaderValue)\n}\n\n// MsgPack adds the \"application/msgpack\" and \"application/x-msgpack\" as accepted client content types.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) MsgPack() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentYAMLHeaderValue)\n}\n\n// Charset adds one or more client accepted charsets.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Charset(charset ...string) *NegotiationAcceptBuilder {\n\tn.lastCharset = charset\n\tn.charset = append(n.charset, charset...)\n\n\treturn n\n}\n\n// Encoding adds one or more client accepted encoding algorithms.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Encoding(encoding ...string) *NegotiationAcceptBuilder {\n\tn.lastEncoding = encoding\n\tn.encoding = append(n.encoding, encoding...)\n\n\treturn n\n}\n\n// EncodingGzip adds the \"gzip\" as accepted encoding.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) EncodingGzip() *NegotiationAcceptBuilder {\n\treturn n.Encoding(GzipHeaderValue)\n}\n\n//  +------------------------------------------------------------+\n//  | Serve files                                                |\n//  +------------------------------------------------------------+\n\n// ServeContent replies to the request using the content in the\n// provided ReadSeeker. The main benefit of ServeContent over io.Copy\n// is that it handles Range requests properly, sets the MIME type, and\n// handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\n// and If-Range requests.\n//\n// If the response's Content-Type header is not set, ServeContent\n// first tries to deduce the type from name's file extension.\n//\n// The name is otherwise unused; in particular it can be empty and is\n// never sent in the response.\n//\n// If modtime is not the zero time or Unix epoch, ServeContent\n// includes it in a Last-Modified header in the response. If the\n// request includes an If-Modified-Since header, ServeContent uses\n// modtime to decide whether the content needs to be sent at all.\n//\n// The content's Seek method must work: ServeContent uses\n// a seek to the end of the content to determine its size.\n//\n// If the caller has set w's ETag header formatted per RFC 7232, section 2.3,\n// ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n//\n// Note that *os.File implements the io.ReadSeeker interface.\n// Note that compression can be registered\n// through `ctx.CompressWriter(true)` or `app.Use(iris.Compression)`.\nfunc (ctx *Context) ServeContent(content io.ReadSeeker, filename string, modtime time.Time) {\n\tctx.ServeContentWithRate(content, filename, modtime, 0, 0)\n}\n\n// rateReadSeeker is a io.ReadSeeker that is rate limited by\n// the given token bucket. Each token in the bucket\n// represents one byte. See \"golang.org/x/time/rate\" package.\ntype rateReadSeeker struct {\n\tio.ReadSeeker\n\tctx     stdContext.Context\n\tlimiter *rate.Limiter\n}\n\nfunc (rs *rateReadSeeker) Read(buf []byte) (int, error) {\n\tn, err := rs.ReadSeeker.Read(buf)\n\tif n <= 0 {\n\t\treturn n, err\n\t}\n\terr = rs.limiter.WaitN(rs.ctx, n)\n\treturn n, err\n}\n\n// ServeContentWithRate same as `ServeContent` but it can throttle the speed of reading\n// and though writing the \"content\" to the client.\nfunc (ctx *Context) ServeContentWithRate(content io.ReadSeeker, filename string, modtime time.Time, limit float64, burst int) {\n\tif limit > 0 {\n\t\tcontent = &rateReadSeeker{\n\t\t\tReadSeeker: content,\n\t\t\tctx:        ctx.request.Context(),\n\t\t\tlimiter:    rate.NewLimiter(rate.Limit(limit), burst),\n\t\t}\n\t}\n\n\tif ctx.GetContentType() == \"\" {\n\t\tctx.ContentType(filename)\n\t}\n\n\thttp.ServeContent(ctx.writer, ctx.request, filename, modtime, content)\n}\n\n// ServeFile replies to the request with the contents of the named\n// file or directory.\n//\n// If the provided file or directory name is a relative path, it is\n// interpreted relative to the current directory and may ascend to\n// parent directories. If the provided name is constructed from user\n// input, it should be sanitized before calling `ServeFile`.\n//\n// Use it when you want to serve assets like css and javascript files.\n// If client should confirm and save the file use the `SendFile` instead.\n// Note that compression can be registered\n// through `ctx.CompressWriter(true)` or `app.Use(iris.Compression)`.\nfunc (ctx *Context) ServeFile(filename string) error {\n\treturn ctx.ServeFileWithRate(filename, 0, 0)\n}\n\n// ServeFileWithRate same as `ServeFile` but it can throttle the speed of reading\n// and though writing the file to the client.\nfunc (ctx *Context) ServeFileWithRate(filename string, limit float64, burst int) error {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\tctx.StatusCode(http.StatusNotFound)\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tst, err := f.Stat()\n\tif err != nil {\n\t\tcode := http.StatusInternalServerError\n\t\tif os.IsNotExist(err) {\n\t\t\tcode = http.StatusNotFound\n\t\t}\n\n\t\tif os.IsPermission(err) {\n\t\t\tcode = http.StatusForbidden\n\t\t}\n\n\t\tctx.StatusCode(code)\n\t\treturn err\n\t}\n\n\tif st.IsDir() {\n\t\treturn ctx.ServeFile(path.Join(filename, \"index.html\"))\n\t}\n\n\tctx.ServeContentWithRate(f, st.Name(), st.ModTime(), limit, burst)\n\treturn nil\n}\n\n// SendFile sends a file as an attachment, that is downloaded and saved locally from client.\n// Note that compression can be registered\n// through `ctx.CompressWriter(true)` or `app.Use(iris.Compression)`.\n// Use `ServeFile` if a file should be served as a page asset instead.\nfunc (ctx *Context) SendFile(src string, destName string) error {\n\treturn ctx.SendFileWithRate(src, destName, 0, 0)\n}\n\n// SendFileWithRate same as `SendFile` but it can throttle the speed of reading\n// and though writing the file to the client.\nfunc (ctx *Context) SendFileWithRate(src, destName string, limit float64, burst int) error {\n\tif destName == \"\" {\n\t\tdestName = filepath.Base(src)\n\t}\n\n\tctx.writer.Header().Set(ContentDispositionHeaderKey, \"attachment;filename=\"+destName)\n\treturn ctx.ServeFileWithRate(src, limit, burst)\n}\n\n//  +------------------------------------------------------------+\n//  | Cookies                                                    |\n//  +------------------------------------------------------------+\n\n// Set of Cookie actions for `CookieOption`.\nconst (\n\tOpCookieGet uint8 = iota\n\tOpCookieSet\n\tOpCookieDel\n)\n\n// CookieOption is the type of function that is accepted on\n// context's methods like `SetCookieKV`, `RemoveCookie` and `SetCookie`\n// as their (last) variadic input argument to amend the to-be-sent cookie.\n//\n// The \"op\" is the operation code, 0 is GET, 1 is SET and 2 is REMOVE.\ntype CookieOption func(ctx *Context, c *http.Cookie, op uint8)\n\n// CookieIncluded reports whether the \"cookie.Name\" is in the list of \"cookieNames\".\n// Notes:\n// If \"cookieNames\" slice is empty then it returns true,\n// If \"cookie.Name\" is empty then it returns false.\nfunc CookieIncluded(cookie *http.Cookie, cookieNames []string) bool {\n\tif cookie.Name == \"\" {\n\t\treturn false\n\t}\n\n\tif len(cookieNames) > 0 {\n\t\tfor _, name := range cookieNames {\n\t\t\tif cookie.Name == name {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nvar cookieNameSanitizer = strings.NewReplacer(\"\\n\", \"-\", \"\\r\", \"-\")\n\nfunc sanitizeCookieName(n string) string {\n\treturn cookieNameSanitizer.Replace(n)\n}\n\n// CookieAllowReclaim accepts the Context itself.\n// If set it will add the cookie to (on `CookieSet`, `CookieSetKV`, `CookieUpsert`)\n// or remove the cookie from (on `CookieRemove`) the Request object too.\nfunc CookieAllowReclaim(cookieNames ...string) CookieOption {\n\treturn func(ctx *Context, c *http.Cookie, op uint8) {\n\t\tif op == OpCookieGet {\n\t\t\treturn\n\t\t}\n\n\t\tif !CookieIncluded(c, cookieNames) {\n\t\t\treturn\n\t\t}\n\n\t\tswitch op {\n\t\tcase OpCookieSet:\n\t\t\t// perform upsert on request cookies or is it too much and not worth the cost?\n\t\t\tctx.Request().AddCookie(c)\n\t\tcase OpCookieDel:\n\t\t\theader := ctx.Request().Header\n\n\t\t\tif cookiesLine := header.Get(\"Cookie\"); cookiesLine != \"\" {\n\t\t\t\tif cookies := strings.Split(cookiesLine, \"; \"); len(cookies) > 1 {\n\t\t\t\t\t// more than one cookie here.\n\t\t\t\t\t// select that one and remove it.\n\t\t\t\t\tname := sanitizeCookieName(c.Name)\n\n\t\t\t\t\tfor _, nameValue := range cookies {\n\t\t\t\t\t\tif strings.HasPrefix(nameValue, name) {\n\t\t\t\t\t\t\tcookiesLine = strings.Replace(cookiesLine, \"; \"+nameValue, \"\", 1)\n\t\t\t\t\t\t\t// current cookiesLine: myapp_session_id=5ccf4e89-8d0e-4ed6-9f4c-6746d7c5e2ee; key1=value1\n\t\t\t\t\t\t\t// found nameValue: key1=value1\n\t\t\t\t\t\t\t// new cookiesLine: myapp_session_id=5ccf4e89-8d0e-4ed6-9f4c-6746d7c5e2ee\n\t\t\t\t\t\t\theader.Set(\"Cookie\", cookiesLine)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theader.Del(\"Cookie\")\n\t\t}\n\t}\n}\n\n// CookieAllowSubdomains set to the Cookie Options\n// in order to allow subdomains to have access to the cookies.\n// It sets the cookie's Domain field (if was empty) and\n// it also sets the cookie's SameSite to lax mode too.\nfunc CookieAllowSubdomains(cookieNames ...string) CookieOption {\n\treturn func(ctx *Context, c *http.Cookie, _ uint8) {\n\t\tif c.Domain != \"\" {\n\t\t\treturn // already set.\n\t\t}\n\n\t\tif !CookieIncluded(c, cookieNames) {\n\t\t\treturn\n\t\t}\n\n\t\tc.Domain = ctx.Domain()\n\t\tc.SameSite = http.SameSiteLaxMode // allow subdomain sharing.\n\t}\n}\n\n// CookieSameSite sets a same-site rule for cookies to set.\n// SameSite allows a server to define a cookie attribute making it impossible for\n// the browser to send this cookie along with cross-site requests. The main\n// goal is to mitigate the risk of cross-origin information leakage, and provide\n// some protection against cross-site request forgery attacks.\n//\n// See https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00 for details.\nfunc CookieSameSite(sameSite http.SameSite) CookieOption {\n\treturn func(_ *Context, c *http.Cookie, op uint8) {\n\t\tif op == OpCookieSet {\n\t\t\tc.SameSite = sameSite\n\t\t}\n\t}\n}\n\n// CookieSecure sets the cookie's Secure option if the current request's\n// connection is using TLS. See `CookieHTTPOnly` too.\nfunc CookieSecure(ctx *Context, c *http.Cookie, op uint8) {\n\tif op == OpCookieSet {\n\t\tif ctx.Request().TLS != nil {\n\t\t\tc.Secure = true\n\t\t}\n\t}\n}\n\n// CookieHTTPOnly is a `CookieOption`.\n// Use it to set the cookie's HttpOnly field to false or true.\n// HttpOnly field defaults to true for `RemoveCookie` and `SetCookieKV`.\n// See `CookieSecure` too.\nfunc CookieHTTPOnly(httpOnly bool) CookieOption {\n\treturn func(_ *Context, c *http.Cookie, op uint8) {\n\t\tif op == OpCookieSet {\n\t\t\tc.HttpOnly = httpOnly\n\t\t}\n\t}\n}\n\n// CookiePath is a `CookieOption`.\n// Use it to change the cookie's Path field.\nfunc CookiePath(path string) CookieOption {\n\treturn func(_ *Context, c *http.Cookie, op uint8) {\n\t\tif op > OpCookieGet { // on set and remove.\n\t\t\tc.Path = path\n\t\t}\n\t}\n}\n\n// CookieCleanPath is a `CookieOption`.\n// Use it to clear the cookie's Path field, exactly the same as `CookiePath(\"\")`.\nfunc CookieCleanPath(_ *Context, c *http.Cookie, op uint8) {\n\tif op > OpCookieGet {\n\t\tc.Path = \"\"\n\t}\n}\n\n// CookieExpires is a `CookieOption`.\n// Use it to change the cookie's Expires and MaxAge fields by passing the lifetime of the cookie.\nfunc CookieExpires(durFromNow time.Duration) CookieOption {\n\treturn func(_ *Context, c *http.Cookie, op uint8) {\n\t\tif op == OpCookieSet {\n\t\t\tc.Expires = time.Now().Add(durFromNow)\n\t\t\tc.MaxAge = int(durFromNow.Seconds())\n\t\t}\n\t}\n}\n\n// SecureCookie should encodes and decodes\n// authenticated and optionally encrypted cookie values.\n// See `CookieEncoding` package-level function.\ntype SecureCookie interface {\n\t// Encode should encode the cookie value.\n\t// Should accept the cookie's name as its first argument\n\t// and as second argument the cookie value ptr.\n\t// Should return an encoded value or an empty one if encode operation failed.\n\t// Should return an error if encode operation failed.\n\t//\n\t// Note: Errors are not printed, so you have to know what you're doing,\n\t// and remember: if you use AES it only supports key sizes of 16, 24 or 32 bytes.\n\t// You either need to provide exactly that amount or you derive the key from what you type in.\n\t//\n\t// See `Decode` too.\n\tEncode(cookieName string, cookieValue interface{}) (string, error)\n\t// Decode should decode the cookie value.\n\t// Should accept the cookie's name as its first argument,\n\t// as second argument the encoded cookie value and as third argument the decoded value ptr.\n\t// Should return a decoded value or an empty one if decode operation failed.\n\t// Should return an error if decode operation failed.\n\t//\n\t// Note: Errors are not printed, so you have to know what you're doing,\n\t// and remember: if you use AES it only supports key sizes of 16, 24 or 32 bytes.\n\t// You either need to provide exactly that amount or you derive the key from what you type in.\n\t//\n\t// See `Encode` too.\n\tDecode(cookieName string, cookieValue string, cookieValuePtr interface{}) error\n}\n\n// CookieEncoding accepts a value which implements `Encode` and `Decode` methods.\n// It calls its `Encode` on `Context.SetCookie, UpsertCookie, and SetCookieKV` methods.\n// And on `Context.GetCookie` method it calls its `Decode`.\n// If \"cookieNames\" slice is not empty then only cookies\n// with that `Name` will be encoded on set and decoded on get, that way you can encrypt\n// specific cookie names (like the session id) and let the rest of the cookies \"insecure\".\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/cookies/securecookie\nfunc CookieEncoding(encoding SecureCookie, cookieNames ...string) CookieOption {\n\treturn func(_ *Context, c *http.Cookie, op uint8) {\n\t\tif op == OpCookieDel {\n\t\t\treturn\n\t\t}\n\n\t\tif !CookieIncluded(c, cookieNames) {\n\t\t\treturn\n\t\t}\n\n\t\tswitch op {\n\t\tcase OpCookieSet:\n\t\t\t// Should encode, it's a write to the client operation.\n\t\t\tnewVal, err := encoding.Encode(c.Name, c.Value)\n\t\t\tif err != nil {\n\t\t\t\tc.Value = \"\"\n\t\t\t} else {\n\t\t\t\tc.Value = newVal\n\t\t\t}\n\t\t\treturn\n\t\tcase OpCookieGet:\n\t\t\t// Should decode, it's a read from the client operation.\n\t\t\tif err := encoding.Decode(c.Name, c.Value, &c.Value); err != nil {\n\t\t\t\tc.Value = \"\"\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst cookieOptionsContextKey = \"iris.cookie.options\"\n\n// AddCookieOptions adds cookie options for `SetCookie`,\n// `SetCookieKV, UpsertCookie` and `RemoveCookie` methods\n// for the current request. It can be called from a middleware before\n// cookies sent or received from the next Handler in the chain.\n//\n// Available builtin Cookie options are:\n//  * CookieAllowReclaim\n//  * CookieAllowSubdomains\n//  * CookieSecure\n//  * CookieHTTPOnly\n//  * CookieSameSite\n//  * CookiePath\n//  * CookieCleanPath\n//  * CookieExpires\n//  * CookieEncoding\n//\n// Example at: https://github.com/kataras/iris/tree/master/_examples/cookies/securecookie\nfunc (ctx *Context) AddCookieOptions(options ...CookieOption) {\n\tif len(options) == 0 {\n\t\treturn\n\t}\n\n\tif v := ctx.values.Get(cookieOptionsContextKey); v != nil {\n\t\tif opts, ok := v.([]CookieOption); ok {\n\t\t\toptions = append(opts, options...)\n\t\t}\n\t}\n\n\tctx.values.Set(cookieOptionsContextKey, options)\n}\n\nfunc (ctx *Context) applyCookieOptions(c *http.Cookie, op uint8, override []CookieOption) {\n\tif v := ctx.values.Get(cookieOptionsContextKey); v != nil {\n\t\tif options, ok := v.([]CookieOption); ok {\n\t\t\tfor _, opt := range options {\n\t\t\t\topt(ctx, c, op)\n\t\t\t}\n\t\t}\n\t}\n\n\t// The function's ones should be called last, so they can override\n\t// the stored ones (i.e by a prior middleware).\n\tfor _, opt := range override {\n\t\topt(ctx, c, op)\n\t}\n}\n\n// ClearCookieOptions clears any previously registered cookie options.\n// See `AddCookieOptions` too.\nfunc (ctx *Context) ClearCookieOptions() {\n\tctx.values.Remove(cookieOptionsContextKey)\n}\n\n// SetCookie adds a cookie.\n// Use of the \"options\" is not required, they can be used to amend the \"cookie\".\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/cookies/basic\nfunc (ctx *Context) SetCookie(cookie *http.Cookie, options ...CookieOption) {\n\tctx.applyCookieOptions(cookie, OpCookieSet, options)\n\thttp.SetCookie(ctx.writer, cookie)\n}\n\nconst setCookieHeaderKey = \"Set-Cookie\"\n\n// UpsertCookie adds a cookie to the response like `SetCookie` does\n// but it will also perform a replacement of the cookie\n// if already set by a previous `SetCookie` call.\n// It reports whether the cookie is new (true) or an existing one was updated (false).\nfunc (ctx *Context) UpsertCookie(cookie *http.Cookie, options ...CookieOption) bool {\n\tctx.applyCookieOptions(cookie, OpCookieSet, options)\n\n\theader := ctx.ResponseWriter().Header()\n\n\tif cookies := header[setCookieHeaderKey]; len(cookies) > 0 {\n\t\ts := cookie.Name + \"=\" // name=?value\n\t\tfor i, c := range cookies {\n\t\t\tif strings.HasPrefix(c, s) {\n\t\t\t\t// We need to update the Set-Cookie (to update the expiration or any other cookie's properties).\n\t\t\t\t// Probably the cookie is set and then updated in the first session creation\n\t\t\t\t// (e.g. UpdateExpiration, see https://github.com/kataras/iris/issues/1485).\n\t\t\t\tcookies[i] = cookie.String()\n\t\t\t\theader[setCookieHeaderKey] = cookies\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\n\theader.Add(setCookieHeaderKey, cookie.String())\n\treturn true\n}\n\n// SetCookieKVExpiration is 365 days by-default\n// you can change it or simple, use the SetCookie for more control.\n//\n// See `CookieExpires` and `AddCookieOptions` for more.\nvar SetCookieKVExpiration = 8760 * time.Hour\n\n// SetCookieKV adds a cookie, requires the name(string) and the value(string).\n//\n// By default it expires after 365 days and it is added to the root URL path,\n// use the `CookieExpires` and `CookiePath` to modify them.\n// Alternatively: ctx.SetCookie(&http.Cookie{...}) or ctx.AddCookieOptions(...)\n//\n// If you want to set custom the path:\n// ctx.SetCookieKV(name, value, iris.CookiePath(\"/custom/path/cookie/will/be/stored\"))\n//\n// If you want to be visible only to current request path:\n// (note that client should be responsible for that if server sent an empty cookie's path, all browsers are compatible)\n// ctx.SetCookieKV(name, value, iris.CookieCleanPath/iris.CookiePath(\"\"))\n// More:\n//                              iris.CookieExpires(time.Duration)\n//                              iris.CookieHTTPOnly(false)\n//\n// Examples: https://github.com/kataras/iris/tree/master/_examples/cookies/basic\nfunc (ctx *Context) SetCookieKV(name, value string, options ...CookieOption) {\n\tc := &http.Cookie{}\n\tc.Path = \"/\"\n\tc.Name = name\n\tc.Value = url.QueryEscape(value)\n\tc.HttpOnly = true\n\n\t// MaxAge=0 means no 'Max-Age' attribute specified.\n\t// MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'\n\t// MaxAge>0 means Max-Age attribute present and given in seconds\n\tc.Expires = time.Now().Add(SetCookieKVExpiration)\n\tc.MaxAge = int(time.Until(c.Expires).Seconds())\n\n\tctx.SetCookie(c, options...)\n}\n\n// GetCookie returns cookie's value by its name\n// returns empty string if nothing was found.\n//\n// If you want more than the value then:\n// cookie, err := ctx.Request().Cookie(\"name\")\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/cookies/basic\nfunc (ctx *Context) GetCookie(name string, options ...CookieOption) string {\n\tc, err := ctx.request.Cookie(name)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\tctx.applyCookieOptions(c, OpCookieGet, options)\n\n\tvalue, _ := url.QueryUnescape(c.Value)\n\treturn value\n}\n\nvar (\n\t// CookieExpireDelete may be set on Cookie.Expire for expiring the given cookie.\n\tCookieExpireDelete = time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)\n\n\t// CookieExpireUnlimited indicates that does expires after 24 years.\n\tCookieExpireUnlimited = time.Now().AddDate(24, 10, 10)\n)\n\n// RemoveCookie deletes a cookie by its name and path = \"/\".\n// Tip: change the cookie's path to the current one by: RemoveCookie(\"name\", iris.CookieCleanPath)\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/cookies/basic\nfunc (ctx *Context) RemoveCookie(name string, options ...CookieOption) {\n\tc := &http.Cookie{}\n\tc.Name = name\n\tc.Value = \"\"\n\tc.Path = \"/\" // if user wants to change it, use of the CookieOption `CookiePath` is required if not `ctx.SetCookie`.\n\tc.HttpOnly = true\n\n\t// RFC says 1 second, but let's do it 1  to make sure is working\n\tc.Expires = CookieExpireDelete\n\tc.MaxAge = -1\n\n\tctx.applyCookieOptions(c, OpCookieDel, options)\n\thttp.SetCookie(ctx.writer, c)\n}\n\n// VisitAllCookies takes a visitor function which is called\n// on each (request's) cookies' name and value.\nfunc (ctx *Context) VisitAllCookies(visitor func(name string, value string)) {\n\tfor _, cookie := range ctx.request.Cookies() {\n\t\tvisitor(cookie.Name, cookie.Value)\n\t}\n}\n\nvar maxAgeExp = regexp.MustCompile(`maxage=(\\d+)`)\n\n// MaxAge returns the \"cache-control\" request header's value\n// seconds as int64\n// if header not found or parse failed then it returns -1.\nfunc (ctx *Context) MaxAge() int64 {\n\theader := ctx.GetHeader(CacheControlHeaderKey)\n\tif header == \"\" {\n\t\treturn -1\n\t}\n\tm := maxAgeExp.FindStringSubmatch(header)\n\tif len(m) == 2 {\n\t\tif v, err := strconv.Atoi(m[1]); err == nil {\n\t\t\treturn int64(v)\n\t\t}\n\t}\n\treturn -1\n}\n\n//  +------------------------------------------------------------+\n//  | Advanced: Response Recorder and Transactions               |\n//  +------------------------------------------------------------+\n\n// Record transforms the context's basic and direct responseWriter to a *ResponseRecorder\n// which can be used to reset the body, reset headers, get the body,\n// get & set the status code at any time and more.\nfunc (ctx *Context) Record() {\n\tswitch w := ctx.writer.(type) {\n\tcase *ResponseRecorder:\n\tdefault:\n\t\trecorder := AcquireResponseRecorder()\n\t\trecorder.BeginRecord(w)\n\t\tctx.ResetResponseWriter(recorder)\n\t}\n}\n\n// Recorder returns the context's ResponseRecorder\n// if not recording then it starts recording and returns the new context's ResponseRecorder\nfunc (ctx *Context) Recorder() *ResponseRecorder {\n\tctx.Record()\n\treturn ctx.writer.(*ResponseRecorder)\n}\n\n// IsRecording returns the response recorder and a true value\n// when the response writer is recording the status code, body, headers and so on,\n// else returns nil and false.\nfunc (ctx *Context) IsRecording() (*ResponseRecorder, bool) {\n\t// NOTE:\n\t// two return values in order to minimize the if statement:\n\t// if (Recording) then writer = Recorder()\n\t// instead we do: recorder,ok = Recording()\n\trr, ok := ctx.writer.(*ResponseRecorder)\n\treturn rr, ok\n}\n\n// ErrTransactionInterrupt can be used to manually force-complete a Context's transaction\n// and log(warn) the wrapped error's message.\n// Usage: `... return fmt.Errorf(\"my custom error message: %w\", context.ErrTransactionInterrupt)`.\nvar ErrTransactionInterrupt = errors.New(\"transaction interrupted\")\n\n// BeginTransaction starts a scoped transaction.\n//\n// Can't say a lot here because it will take more than 200 lines to write about.\n// You can search third-party articles or books on how Business Transaction works (it's quite simple, especially here).\n//\n// Note that this is unique and new\n// (=I haver never seen any other examples or code in Golang on this subject, so far, as with the most of iris features...)\n// it's not covers all paths,\n// such as databases, this should be managed by the libraries you use to make your database connection,\n// this transaction scope is only for context's response.\n// Transactions have their own middleware ecosystem also.\n//\n// See https://github.com/kataras/iris/tree/master/_examples/ for more\nfunc (ctx *Context) BeginTransaction(pipe func(t *Transaction)) {\n\t// do NOT begin a transaction when the previous transaction has been failed\n\t// and it was requested scoped or SkipTransactions called manually.\n\tif ctx.TransactionsSkipped() {\n\t\treturn\n\t}\n\n\t// start recording in order to be able to control the full response writer\n\tctx.Record()\n\n\tt := newTransaction(ctx) // it calls this *context, so the overriding with a new pool's New of context.Context wil not work here.\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tctx.app.Logger().Warn(fmt.Errorf(\"recovery from panic: %w\", ErrTransactionInterrupt))\n\t\t\t// complete (again or not , doesn't matters) the scope without loud\n\t\t\tt.Complete(nil)\n\t\t\t// we continue as normal, no need to return here*\n\t\t}\n\n\t\t// write the temp contents to the original writer\n\t\tt.Context().ResponseWriter().CopyTo(ctx.writer)\n\t\t// give back to the transaction the original writer (SetBeforeFlush works this way and only this way)\n\t\t// this is tricky but nessecery if we want ctx.FireStatusCode to work inside transactions\n\t\tt.Context().ResetResponseWriter(ctx.writer)\n\t}()\n\n\t// run the worker with its context clone inside.\n\tpipe(t)\n}\n\n// skipTransactionsContextKey set this to any value to stop executing next transactions\n// it's a context-key in order to be used from anywhere, set it by calling the SkipTransactions()\nconst skipTransactionsContextKey = \"iris.transactions.skip\"\n\n// SkipTransactions if called then skip the rest of the transactions\n// or all of them if called before the first transaction\nfunc (ctx *Context) SkipTransactions() {\n\tctx.values.Set(skipTransactionsContextKey, 1)\n}\n\n// TransactionsSkipped returns true if the transactions skipped or canceled at all.\nfunc (ctx *Context) TransactionsSkipped() bool {\n\tif n, err := ctx.values.GetInt(skipTransactionsContextKey); err == nil && n == 1 {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Exec calls the framewrok's ServeHTTPC\n// based on this context but with a changed method and path\n// like it was requested by the user, but it is not.\n//\n// Offline means that the route is registered to the iris and have all features that a normal route has\n// BUT it isn't available by browsing, its handlers executed only when other handler's context call them\n// it can validate paths, has sessions, path parameters and all.\n//\n// You can find the Route by app.GetRoute(\"theRouteName\")\n// you can set a route name as: myRoute := app.Get(\"/mypath\", handler)(\"theRouteName\")\n// that will set a name to the route and returns its RouteInfo instance for further usage.\n//\n// It doesn't changes the global state, if a route was \"offline\" it remains offline.\n//\n// app.None(...) and app.GetRoutes().Offline(route)/.Online(route, method)\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/routing/route-state\n//\n// User can get the response by simple using rec := ctx.Recorder(); rec.Body()/rec.StatusCode()/rec.Header().\n//\n// context's Values and the Session are kept in order to be able to communicate via the result route.\n//\n// It's for extreme use cases, 99% of the times will never be useful for you.\nfunc (ctx *Context) Exec(method string, path string) {\n\tif path == \"\" {\n\t\treturn\n\t}\n\n\tif method == \"\" {\n\t\tmethod = \"GET\"\n\t}\n\n\t// backup the handlers\n\tbackupHandlers := ctx.handlers[0:]\n\tbackupPos := ctx.currentHandlerIndex\n\n\treq := ctx.request\n\t// backup the request path information\n\tbackupPath := req.URL.Path\n\tbackupMethod := req.Method\n\t// don't backupValues := ctx.values.ReadOnly()\n\t// set the request to be align with the 'againstRequestPath'\n\treq.RequestURI = path\n\treq.URL.Path = path\n\treq.Method = method\n\n\t// [values stays]\n\t// reset handlers\n\tctx.handlers = ctx.handlers[0:0]\n\tctx.currentHandlerIndex = 0\n\n\t// execute the route from the (internal) context router\n\t// this way we keep the sessions and the values\n\tctx.app.ServeHTTPC(ctx)\n\n\t// set the request back to its previous state\n\treq.RequestURI = backupPath\n\treq.URL.Path = backupPath\n\treq.Method = backupMethod\n\n\t// set back the old handlers and the last known index\n\tctx.handlers = backupHandlers\n\tctx.currentHandlerIndex = backupPos\n}\n\n// RouteExists reports whether a particular route exists\n// It will search from the current subdomain of context's host, if not inside the root domain.\nfunc (ctx *Context) RouteExists(method, path string) bool {\n\treturn ctx.app.RouteExists(ctx, method, path)\n}\n\nconst (\n\treflectValueContextKey = \"iris.context.reflect_value\"\n\t// ControllerContextKey returns the context key from which\n\t// the `Context.Controller` method returns the store's value.\n\tControllerContextKey = \"iris.controller.reflect_value\"\n)\n\n// ReflectValue caches and returns a []reflect.Value{reflect.ValueOf(ctx)}.\n// It's just a helper to maintain variable inside the context itself.\nfunc (ctx *Context) ReflectValue() []reflect.Value {\n\tif v := ctx.values.Get(reflectValueContextKey); v != nil {\n\t\treturn v.([]reflect.Value)\n\t}\n\n\tv := []reflect.Value{reflect.ValueOf(ctx)}\n\tctx.values.Set(reflectValueContextKey, v)\n\treturn v\n}\n\nvar emptyValue reflect.Value\n\n// Controller returns a reflect Value of the custom Controller from which this handler executed.\n// It will return a Kind() == reflect.Invalid if the handler was not executed from within a controller.\nfunc (ctx *Context) Controller() reflect.Value {\n\tif v := ctx.values.Get(ControllerContextKey); v != nil {\n\t\treturn v.(reflect.Value)\n\t}\n\n\treturn emptyValue\n}\n\n// DependenciesContextKey is the context key for the context's value\n// to keep the serve-time static dependencies raw values.\nconst DependenciesContextKey = \"iris.dependencies\"\n\n// DependenciesMap is the type which context serve-time\n// struct dependencies are stored with.\ntype DependenciesMap map[reflect.Type]reflect.Value\n\n// RegisterDependency registers a struct or slice\n// or pointer to struct dependency at request-time\n// for the next handler in the chain. One value per type.\n// Note that it's highly recommended to register\n// your dependencies before server ran\n// through Party.ConfigureContainer or mvc.Application.Register\n// in sake of minimum performance cost.\n//\n// See `UnregisterDependency` too.\nfunc (ctx *Context) RegisterDependency(v interface{}) {\n\tif v == nil {\n\t\treturn\n\t}\n\n\tval, ok := v.(reflect.Value)\n\tif !ok {\n\t\tval = reflect.ValueOf(v)\n\t}\n\n\tcv := ctx.values.Get(DependenciesContextKey)\n\tif cv != nil {\n\t\tm, ok := cv.(DependenciesMap)\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\n\t\tm[val.Type()] = val\n\t\treturn\n\t}\n\n\tctx.values.Set(DependenciesContextKey, DependenciesMap{\n\t\tval.Type(): val,\n\t})\n}\n\n// UnregisterDependency removes a dependency based on its type.\n// Reports whether a dependency with that type was found and removed successfully.\nfunc (ctx *Context) UnregisterDependency(typ reflect.Type) bool {\n\tcv := ctx.values.Get(DependenciesContextKey)\n\tif cv != nil {\n\t\tm, ok := cv.(DependenciesMap)\n\t\tif ok {\n\t\t\tdelete(m, typ)\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// Application returns the iris app instance which belongs to this context.\n// Worth to notice that this function returns an interface\n// of the Application, which contains methods that are safe\n// to be executed at serve-time. The full app's fields\n// and methods are not available here for the developer's safety.\nfunc (ctx *Context) Application() Application {\n\treturn ctx.app\n}\n\n// IsDebug reports whether the application runs with debug log level.\n// It is a shortcut of Application.IsDebug().\nfunc (ctx *Context) IsDebug() bool {\n\treturn ctx.app.IsDebug()\n}\n\n// SetErr is just a helper that sets an error value\n// as a context value, it does nothing more.\n// Also, by-default this error's value is written to the client\n// on failures when no registered error handler is available (see `Party.On(Any)ErrorCode`).\n// See `GetErr` to retrieve it back.\n//\n// To remove an error simply pass nil.\n//\n// Note that, if you want to stop the chain\n// with an error see the `StopWithError/StopWithPlainError` instead.\nfunc (ctx *Context) SetErr(err error) {\n\tif err == nil {\n\t\tctx.values.Remove(errorContextKey)\n\t\treturn\n\t}\n\n\tctx.values.Set(errorContextKey, err)\n}\n\n// GetErr is a helper which retrieves\n// the error value stored by `SetErr`.\n//\n// Note that, if an error was stored by `SetErrPrivate`\n// then it returns the underline/original error instead\n// of the internal error wrapper.\nfunc (ctx *Context) GetErr() error {\n\t_, err := ctx.GetErrPublic()\n\treturn err\n}\n\n// ErrPrivate if provided then the error saved in context\n// should NOT be visible to the client no matter what.\ntype ErrPrivate interface {\n\terror\n\tIrisPrivateError()\n}\n\n// An internal wrapper for the `SetErrPrivate` method.\ntype privateError struct{ error }\n\nfunc (e privateError) IrisPrivateError() {}\n\n// PrivateError accepts an error and returns a wrapped private one.\nfunc PrivateError(err error) ErrPrivate {\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\terrPrivate, ok := err.(ErrPrivate)\n\tif !ok {\n\t\terrPrivate = privateError{err}\n\t}\n\n\treturn errPrivate\n}\n\nconst errorContextKey = \"iris.context.error\"\n\n// SetErrPrivate sets an error that it's only accessible through `GetErr`\n// and it should never be sent to the client.\n//\n// Same as ctx.SetErr with an error that completes the `ErrPrivate` interface.\n// See `GetErrPublic` too.\nfunc (ctx *Context) SetErrPrivate(err error) {\n\tctx.SetErr(PrivateError(err))\n}\n\n// GetErrPublic reports whether the stored error\n// can be displayed to the client without risking\n// to expose security server implementation to the client.\n//\n// If the error is not nil, it is always the original one.\nfunc (ctx *Context) GetErrPublic() (bool, error) {\n\tif v := ctx.values.Get(errorContextKey); v != nil {\n\t\tswitch err := v.(type) {\n\t\tcase privateError:\n\t\t\t// If it's an error set by SetErrPrivate then unwrap it.\n\t\t\treturn false, err.error\n\t\tcase ErrPrivate:\n\t\t\treturn false, err\n\t\tcase error:\n\t\t\treturn true, err\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n// ErrPanicRecovery may be returned from `Context` actions of a `Handler`\n// which recovers from a manual panic.\ntype ErrPanicRecovery struct {\n\tErrPrivate\n\tCause              interface{}\n\tCallers            []string // file:line callers.\n\tStack              []byte   // the full debug stack.\n\tRegisteredHandlers []string // file:line of all registered handlers.\n\tCurrentHandler     string   // the handler panic came from.\n}\n\n// Error implements the Go standard error type.\nfunc (e *ErrPanicRecovery) Error() string {\n\tif e.Cause != nil {\n\t\tif err, ok := e.Cause.(error); ok {\n\t\t\treturn err.Error()\n\t\t}\n\t}\n\n\treturn fmt.Sprintf(\"%v\\n%s\", e.Cause, strings.Join(e.Callers, \"\\n\"))\n}\n\n// Is completes the internal errors.Is interface.\nfunc (e *ErrPanicRecovery) Is(err error) bool {\n\t_, ok := IsErrPanicRecovery(err)\n\treturn ok\n}\n\n// IsErrPanicRecovery reports whether the given \"err\" is a type of ErrPanicRecovery.\nfunc IsErrPanicRecovery(err error) (*ErrPanicRecovery, bool) {\n\tif err == nil {\n\t\treturn nil, false\n\t}\n\tv, ok := err.(*ErrPanicRecovery)\n\treturn v, ok\n}\n\n// IsRecovered reports whether this handler has been recovered\n// by the Iris recover middleware.\nfunc (ctx *Context) IsRecovered() (*ErrPanicRecovery, bool) {\n\tif ctx.GetStatusCode() == http.StatusInternalServerError {\n\t\t// Panic error from recovery middleware is private.\n\t\treturn IsErrPanicRecovery(ctx.GetErr())\n\t}\n\n\treturn nil, false\n}\n\nconst (\n\tfuncsContextPrefixKey = \"iris.funcs.\"\n\tfuncLogoutContextKey  = \"auth.logout_func\"\n)\n\n// SetFunc registers a custom function to this Request.\n// It's a helper to pass dynamic functions across handlers of the same chain.\n// For a more complete solution please use Dependency Injection instead.\n// This is just an easy to way to pass a function to the\n// next handler like ctx.Values().Set/Get does.\n// Sometimes is faster and easier to pass the object as a request value\n// and cast it when you want to use one of its methods instead of using\n// these `SetFunc` and `CallFunc` methods.\n// This implementation is suitable for functions that may change inside the\n// handler chain and the object holding the method is not predictable.\n//\n// The \"name\" argument is the custom name of the function,\n// you will use its name to call it later on, e.g. \"auth.myfunc\".\n//\n// The second, \"fn\" argument is the raw function/method you want\n// to pass through the next handler(s) of the chain.\n//\n// The last variadic input argument is optionally, if set\n// then its arguments are passing into the function's input arguments,\n// they should be always be the first ones to be accepted by the \"fn\" inputs,\n// e.g. an object, a receiver or a static service.\n//\n// See its `CallFunc` to call the \"fn\" on the next handler.\n//\n// Example at:\n// https://github.com/kataras/iris/tree/master/_examples/routing/writing-a-middleware/share-funcs\nfunc (ctx *Context) SetFunc(name string, fn interface{}, persistenceArgs ...interface{}) {\n\tf := newFunc(name, fn, persistenceArgs...)\n\tctx.values.Set(funcsContextPrefixKey+name, f)\n}\n\n// GetFunc returns the context function declaration which holds\n// some information about the function registered under the given \"name\" by\n// the `SetFunc` method.\nfunc (ctx *Context) GetFunc(name string) (*Func, bool) {\n\tfn := ctx.values.Get(funcsContextPrefixKey + name)\n\tif fn == nil {\n\t\treturn nil, false\n\t}\n\n\treturn fn.(*Func), true\n}\n\n// CallFunc calls the function registered by the `SetFunc`.\n// The input arguments MUST match the expected ones.\n//\n// If the registered function was just a handler\n// or a handler which returns an error\n// or a simple function\n// or a simple function which returns an error\n// then this operation will perform without any serious cost,\n// otherwise reflection will be used instead, which may slow down the overall performance.\n//\n// Retruns ErrNotFound if the function was not registered.\n//\n// For a more complete solution without limiations navigate through\n// the Iris Dependency Injection feature instead.\nfunc (ctx *Context) CallFunc(name string, args ...interface{}) ([]reflect.Value, error) {\n\tfn, ok := ctx.GetFunc(name)\n\tif !ok || fn == nil {\n\t\treturn nil, ErrNotFound\n\t}\n\n\treturn fn.call(ctx, args...)\n}\n\n// SetLogoutFunc registers a custom logout function that will be\n// available to use inside the next handler(s). The function\n// may be registered multiple times but the last one is the valid.\n// So a logout function may start with basic authentication\n// and other middleware in the chain may change it to a custom sessions logout one.\n// This method uses the `SetFunc` method under the hoods.\n//\n// See `Logout` method too.\nfunc (ctx *Context) SetLogoutFunc(fn interface{}, persistenceArgs ...interface{}) {\n\tctx.SetFunc(funcLogoutContextKey, fn, persistenceArgs...)\n}\n\n// Logout calls the registered logout function.\n// Returns ErrNotFound if a logout function was not specified\n// by a prior call of `SetLogoutFunc`.\nfunc (ctx *Context) Logout(args ...interface{}) error {\n\t_, err := ctx.CallFunc(funcLogoutContextKey, args...)\n\treturn err\n}\n\nconst userContextKey = \"iris.user\"\n\n// SetUser sets a value as a User for this request.\n// It's used by auth middlewares as a common\n// method to provide user information to the\n// next handlers in the chain.\n//\n// The \"i\" input argument can be:\n// - A value which completes the User interface\n// - A map[string]interface{}.\n// - A value which does not complete the whole User interface\n// - A value which does not complete the User interface at all\n//   (only its `User().GetRaw` method is available).\n//\n// Look the `User` method to retrieve it.\nfunc (ctx *Context) SetUser(i interface{}) error {\n\tif i == nil {\n\t\tctx.values.Remove(userContextKey)\n\t\treturn nil\n\t}\n\n\tu, ok := i.(User)\n\tif !ok {\n\t\tif m, ok := i.(Map); ok { // it's a map, convert it to a User.\n\t\t\tu = UserMap(m)\n\t\t} else {\n\t\t\t// It's a structure, wrap it and let\n\t\t\t// runtime decide the features.\n\t\t\tp := newUserPartial(i)\n\t\t\tif p == nil {\n\t\t\t\treturn ErrNotSupported\n\t\t\t}\n\t\t\tu = p\n\t\t}\n\t}\n\n\tctx.values.Set(userContextKey, u)\n\treturn nil\n}\n\n// User returns the registered User of this request.\n// To get the original value (even if a value set by SetUser does not implement the User interface)\n// use its GetRaw method.\n// /\n// See `SetUser` too.\nfunc (ctx *Context) User() User {\n\tif v := ctx.values.Get(userContextKey); v != nil {\n\t\tif u, ok := v.(User); ok {\n\t\t\treturn u\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Ensure Iris Context implements the standard Context package, build-time.\nvar _ stdContext.Context = (*Context)(nil)\n\n// Deadline returns the time when work done on behalf of this context\n// should be canceled. Deadline returns ok==false when no deadline is\n// set. Successive calls to Deadline return the same results.\n//\n// Shortcut of Request().Context().Deadline().\nfunc (ctx *Context) Deadline() (deadline time.Time, ok bool) {\n\treturn ctx.request.Context().Deadline()\n}\n\n// Done returns a channel that's closed when work done on behalf of this\n// context should be canceled. Done may return nil if this context can\n// never be canceled. Successive calls to Done return the same value.\n// The close of the Done channel may happen asynchronously,\n// after the cancel function returns.\n//\n// WithCancel arranges for Done to be closed when cancel is called;\n// WithDeadline arranges for Done to be closed when the deadline\n// expires; WithTimeout arranges for Done to be closed when the timeout\n// elapses.\n//\n// Done is provided for use in select statements:\n//\n//  // Stream generates values with DoSomething and sends them to out\n//  // until DoSomething returns an error or ctx.Done is closed.\n//  func Stream(ctx context.Context, out chan<- Value) error {\n//  \tfor {\n//  \t\tv, err := DoSomething(ctx)\n//  \t\tif err != nil {\n//  \t\t\treturn err\n//  \t\t}\n//  \t\tselect {\n//  \t\tcase <-ctx.Done():\n//  \t\t\treturn ctx.Err()\n//  \t\tcase out <- v:\n//  \t\t}\n//  \t}\n//  }\n//\n// See https://blog.golang.org/pipelines for more examples of how to use\n// a Done channel for cancellation.\n//\n// Shortcut of Request().Context().Done().\nfunc (ctx *Context) Done() <-chan struct{} {\n\treturn ctx.request.Context().Done()\n}\n\n// If Done is not yet closed, Err returns nil.\n// If Done is closed, Err returns a non-nil error explaining why:\n// Canceled if the context was canceled\n// or DeadlineExceeded if the context's deadline passed.\n// After Err returns a non-nil error, successive calls to Err return the same error.\n//\n// Shortcut of Request().Context().Err().\nfunc (ctx *Context) Err() error {\n\treturn ctx.request.Context().Err()\n}\n\n// Value returns the value associated with this context for key, or nil\n// if no value is associated with key. Successive calls to Value with\n// the same key returns the same result.\n//\n// Shortcut of Request().Context().Value(key interface{}) interface{}.\nfunc (ctx *Context) Value(key interface{}) interface{} {\n\tif keyStr, ok := key.(string); ok { // check if the key is a type of string, which can be retrieved by the mem store.\n\t\tif entry, exists := ctx.values.GetEntry(keyStr); exists {\n\t\t\treturn entry.ValueRaw\n\t\t}\n\t}\n\t// otherwise return the chained value.\n\treturn ctx.request.Context().Value(key)\n}\n\nconst idContextKey = \"iris.context.id\"\n\n// SetID sets an ID, any value, to the Request Context.\n// If possible the \"id\" should implement a `String() string` method\n// so it can be rendered on `Context.String` method.\n//\n// See `GetID` and `middleware/requestid` too.\nfunc (ctx *Context) SetID(id interface{}) {\n\tctx.values.Set(idContextKey, id)\n}\n\n// GetID returns the Request Context's ID.\n// It returns nil if not given by a prior `SetID` call.\n// See `middleware/requestid` too.\nfunc (ctx *Context) GetID() interface{} {\n\treturn ctx.values.Get(idContextKey)\n}\n\n// String returns the string representation of this request.\n//\n// It returns the Context's ID given by a `SetID`call,\n// followed by the client's IP and the method:uri.\nfunc (ctx *Context) String() string {\n\tid := ctx.GetID()\n\tif id != nil {\n\t\tif stringer, ok := id.(fmt.Stringer); ok {\n\t\t\tid = stringer.String()\n\t\t}\n\t}\n\n\treturn fmt.Sprintf(\"[%v] %s \u25b6 %s:%s\", id, ctx.RemoteAddr(), ctx.Method(), ctx.Request().RequestURI)\n}\n"], "fixing_code": ["<!-- # History/Changelog <a href=\"HISTORY_ZH.md\"> <img width=\"20px\" src=\"https://iris-go.com/images/flag-china.svg?v=10\" /></a><a href=\"HISTORY_ID.md\"> <img width=\"20px\" src=\"https://iris-go.com/images/flag-indonesia.svg?v=10\" /></a><a href=\"HISTORY_GR.md\"> <img width=\"20px\" src=\"https://iris-go.com/images/flag-greece.svg?v=10\" /></a> -->\r\n\r\n# Changelog\r\n\r\n### Looking for free and real-time support?\r\n\r\n    https://github.com/kataras/iris/issues\r\n    https://chat.iris-go.com\r\n\r\n### Looking for previous versions?\r\n\r\n    https://github.com/kataras/iris/releases\r\n\r\n### Want to be hired?\r\n\r\n    https://facebook.com/iris.framework\r\n\r\n### Should I upgrade my Iris?\r\n\r\nDevelopers are not forced to upgrade if they don't really need it. Upgrade whenever you feel ready.\r\n\r\n**How to upgrade**: Open your command-line and execute this command: `go get github.com/kataras/iris/v12@latest`.\r\n\r\n# Next\r\n\r\nThis release introduces new features and some breaking changes.\r\nThe codebase for Dependency Injection, Internationalization and localization and more have been simplified a lot (fewer LOCs and easier to read and follow up).\r\n\r\n## Fixes and Improvements\r\n\r\n- Push a security fix reported by [Kirill Efimov](https://github.com/kirill89) for older go runtimes.\r\n\r\n- New `Configuration.Timeout` and `Configuration.TimeoutMessage` fields. Use it to set HTTP timeouts. Note that your http server's (`Application.ConfigureHost`) Read/Write timeouts should be a bit higher than the `Configuration.Timeout` in order to give some time to http timeout handler to kick in and be able to send the `Configuration.TimeoutMessage` properly.\r\n\r\n- New `apps.OnApplicationRegistered` method which listens on new Iris applications hosted under the same binary. Use it on your `init` functions to configure Iris applications by any spot in your project's files.\r\n\r\n- `Context.JSON` respects any object implements the `easyjson.Marshaler` interface and renders the result using the [easyjon](https://github.com/mailru/easyjson)'s writer.\r\n\r\n- minor: `Context` structure implements the standard go Context interface now (includes: Deadline, Done, Err and Value methods). Handlers can now just pass the `ctx iris.Context` as a shortcut of `ctx.Request().Context()` when needed.\r\n\r\n- New [x/jsonx](x/jsonx) sub-package for JSON type helpers.\r\n\r\n- New [x/mathx](x/mathx) sub-package for math related functions.\r\n\r\n- New [/x/client](x/client) HTTP Client sub-package.\r\n\r\n- New `email` builtin path parameter type. Example:\r\n\r\n```go\r\n// +------------------------+\r\n// | {param:email}           |\r\n// +------------------------+\r\n// Email + mx look up path parameter validation. Use it on production.\r\n\r\n// http://localhost:8080/user/kataras2006@hotmail.com -> OK\r\n// http://localhost:8080/user/b-c@invalid_domain      -> NOT FOUND\r\napp.Get(\"/user/{user_email:email}\", func(ctx iris.Context) {\r\n    email := ctx.Params().Get(\"user_email\")\r\n    ctx.WriteString(email)\r\n})\r\n\r\n// +------------------------+\r\n// | {param:mail}           |\r\n// +------------------------+\r\n// Simple email path parameter validation.\r\n\r\n// http://localhost:8080/user/kataras2006@hotmail.com    -> OK\r\n// http://localhost:8080/user/b-c@invalid_domainxxx1.com -> NOT FOUND\r\napp.Get(\"/user/{local_email:mail}\", func(ctx iris.Context) {\r\n    email := ctx.Params().Get(\"local_email\")\r\n    ctx.WriteString(email)\r\n})\r\n```\r\n\r\n- New `iris.IsErrEmptyJSON(err) bool` which reports whether the given \"err\" is caused by a\r\n`Context.ReadJSON` call when the request body didn't start with { (or it was totally empty). \r\n\r\nExample Code:\r\n\r\n```go\r\nfunc handler(ctx iris.Context) {\r\n    var opts SearchOptions\r\n    if err := ctx.ReadJSON(&opts); err != nil && !iris.IsErrEmptyJSON(err) {\r\n        ctx.StopWithJSON(iris.StatusBadRequest, iris.Map{\"message\": \"unable to parse body\"})\r\n        return\r\n    }\r\n\r\n    // [...continue with default values of \"opts\" struct if the client didn't provide some]\r\n}\r\n```\r\n\r\nThat means that the client can optionally set a JSON body.\r\n\t\r\n- New `APIContainer.EnableStrictMode(bool)` to disable automatic payload binding and panic on missing dependencies for exported struct'sfields or function's input parameters on MVC controller or hero function or PartyConfigurator.\r\n\r\n- New `Party.PartyConfigure(relativePath string, partyReg ...PartyConfigurator) Party` helper, registers a children Party like `Party` and `PartyFunc` but instead it accepts a structure value which may contain one or more of the dependencies registered by `RegisterDependency` or `ConfigureContainer().RegisterDependency` methods and fills the unset/zero exported struct's fields respectfully (useful when the api's dependencies amount are too much to pass on a function).\r\n\r\n- **New feature:** add the ability to set custom error handlers on path type parameters errors (existing or custom ones). Example Code:\r\n\r\n```go\r\napp.Macros().Get(\"uuid\").HandleError(func(ctx iris.Context, paramIndex int, err error) {\r\n    ctx.StatusCode(iris.StatusBadRequest)\r\n\r\n    param := ctx.Params().GetEntryAt(paramIndex)\r\n    ctx.JSON(iris.Map{\r\n        \"error\":     err.Error(),\r\n        \"message\":   \"invalid path parameter\",\r\n        \"parameter\": param.Key,\r\n        \"value\":     param.ValueRaw,\r\n    })\r\n})\r\n\r\napp.Get(\"/users/{id:uuid}\", getUser)\r\n```\r\n\r\n- Improve the performance and fix `:int, :int8, :int16, :int32, :int64, :uint, :uint8, :uint16, :uint32, :uint64` path type parameters couldn't accept a positive number written with the plus symbol or with a leading zeroes, e.g. `+42` and `021`.\r\n\r\n- The `iris.WithEmptyFormError` option is respected on `context.ReadQuery` method too, as requested at [#1727](https://github.com/kataras/iris/issues/1727). [Example comments](https://github.com/kataras/iris/blob/master/_examples/request-body/read-query/main.go) were updated.\r\n\r\n- New `httptest.Strict` option setter to enable the `httpexpect.RequireReporter` instead of the default `httpexpect.AssetReporter. Use that to enable complete test failure on the first error. As requested at: [#1722](https://github.com/kataras/iris/issues/1722).\r\n\r\n- New `uuid` builtin path parameter type. Example:\r\n\r\n```go\r\n// +------------------------+\r\n// | {param:uuid}           |\r\n// +------------------------+\r\n// UUIDv4 (and v1) path parameter validation.\r\n\r\n// http://localhost:8080/user/bb4f33e4-dc08-40d8-9f2b-e8b2bb615c0e -> OK\r\n// http://localhost:8080/user/dsadsa-invalid-uuid                  -> NOT FOUND\r\napp.Get(\"/user/{id:uuid}\", func(ctx iris.Context) {\r\n    id := ctx.Params().Get(\"id\")\r\n    ctx.WriteString(id)\r\n})\r\n```\r\n\r\n- New `Configuration.KeepAlive` and `iris.WithKeepAlive(time.Duration) Configurator` added as helpers to start the server using a tcp listener featured with keep-alive.\r\n\r\n- New `DirOptions.ShowHidden bool` is added by [@tuhao1020](https://github.com/tuhao1020) at [PR #1717](https://github.com/kataras/iris/pull/1717) to show or hide the hidden files when `ShowList` is set to true.\r\n\r\n- New `Context.ReadJSONStream` method and `JSONReader` options for `Context.ReadJSON` and `Context.ReadJSONStream`, see the [example](_examples/request-body/read-json-stream/main.go).\r\n\r\n- New `FallbackView` feature, per-party or per handler chain. Example can be found at: [_examples/view/fallback](_examples/view/fallback).\r\n\r\n```go\r\n    app.FallbackView(iris.FallbackViewFunc(func(ctx iris.Context, err iris.ErrViewNotExist) error {\r\n        // err.Name is the previous template name.\r\n        // err.IsLayout reports whether the failure came from the layout template.\r\n        // err.Data is the template data provided to the previous View call.\r\n        // [...custom logic e.g. ctx.View(\"fallback.html\", err.Data)]\r\n        return err\r\n    }))\r\n```\r\n\r\n- New `versioning.Aliases` middleware and up to 80% faster version resolve. Example Code:\r\n\r\n```go\r\napp := iris.New()\r\n\r\napi := app.Party(\"/api\")\r\napi.Use(Aliases(map[string]string{\r\n    versioning.Empty: \"1\", // when no version was provided by the client.\r\n    \"beta\": \"4.0.0\",\r\n    \"stage\": \"5.0.0-alpha\"\r\n}))\r\n\r\nv1 := NewGroup(api, \">=1.0.0 <2.0.0\")\r\nv1.Get/Post...\r\n\r\nv4 := NewGroup(api, \">=4.0.0 <5.0.0\")\r\nv4.Get/Post...\r\n\r\nstage := NewGroup(api, \"5.0.0-alpha\")\r\nstage.Get/Post...\r\n```\r\n\r\n- New [Basic Authentication](https://github.com/kataras/iris/tree/master/middleware/basicauth) middleware. Its `Default` function has not changed, however, the rest, e.g. `New` contains breaking changes as the new middleware features new functionalities.\r\n- Add `iris.DirOptions.SPA bool` field to allow [Single Page Applications](https://github.com/kataras/iris/tree/master/_examples/file-server/single-page-application/basic/main.go) under a file server.\r\n- A generic User interface, see the `Context.SetUser/User` methods in the New Context Methods section for more. In-short, the basicauth middleware's stored user can now be retrieved through `Context.User()` which provides more information than the native `ctx.Request().BasicAuth()` method one. Third-party authentication middleware creators can benefit of these two methods, plus the Logout below. \r\n- A `Context.Logout` method is added, can be used to invalidate [basicauth](https://github.com/kataras/iris/blob/master/_examples/auth/basicauth/basic/main.go) or [jwt](https://github.com/kataras/iris/blob/master/_examples/auth/jwt/blocklist/main.go) client credentials.\r\n- Add the ability to [share functions](https://github.com/kataras/iris/tree/master/_examples/routing/writing-a-middleware/share-funcs) between handlers chain and add an [example](https://github.com/kataras/iris/tree/master/_examples/routing/writing-a-middleware/share-services) on sharing Go structures (aka services).\r\n\r\n- Add the new `Party.UseOnce` method to the `*Route`\r\n- Add a new `*Route.RemoveHandler(...interface{}) int` and `Party.RemoveHandler(...interface{}) Party` methods, delete a handler based on its name or the handler pc function.\r\n\r\n```go\r\nfunc middleware(ctx iris.Context) {\r\n    // [...]\r\n}\r\n\r\nfunc main() {\r\n    app := iris.New()\r\n\r\n    // Register the middleware to all matched routes.\r\n    app.Use(middleware)\r\n\r\n    // Handlers = middleware, other\r\n    app.Get(\"/\", index)\r\n\r\n    // Handlers = other\r\n    app.Get(\"/other\", other).RemoveHandler(middleware)\r\n}\r\n```\r\n\r\n- Redis Driver is now based on the [go-redis](https://github.com/go-redis/redis/) module. Radix and redigo removed entirely. Sessions are now stored in hashes which fixes [issue #1610](https://github.com/kataras/iris/issues/1610). The only breaking change on default configuration is that the `redis.Config.Delim` option was removed. The redis sessions database driver is now defaults to the `&redis.GoRedisDriver{}`. End-developers can implement their own implementations too. The `Database#Close` is now automatically called on interrupt signals, no need to register it by yourself.\r\n\r\n- Add builtin support for **[i18n pluralization](https://github.com/kataras/iris/tree/master/_examples/i18n/plurals)**. Please check out the [following yaml locale example](https://github.com/kataras/iris/tree/master/_examples/i18n/plurals/locales/en-US/welcome.yml) to see an overview of the supported formats.\r\n- Fix [#1650](https://github.com/kataras/iris/issues/1650)\r\n- Fix [#1649](https://github.com/kataras/iris/issues/1649)\r\n- Fix [#1648](https://github.com/kataras/iris/issues/1648)\r\n- Fix [#1641](https://github.com/kataras/iris/issues/1641)\r\n\r\n- Add `Party.SetRoutesNoLog(disable bool) Party` to disable (the new) verbose logging of next routes.\r\n- Add `mvc.Application.SetControllersNoLog(disable bool) *mvc.Application` to disable (the new) verbose logging of next controllers. As requested at [#1630](https://github.com/kataras/iris/issues/1630).\r\n\r\n- Fix [#1621](https://github.com/kataras/iris/issues/1621) and add a new `cache.WithKey` to customize the cached entry key.\r\n\r\n- Add a `Response() *http.Response` to the Response Recorder.\r\n- Fix Response Recorder `Flush` when transfer-encoding is `chunked`.\r\n- Fix Response Recorder `Clone` concurrent access afterwards.\r\n\r\n- Add a `ParseTemplate` method on view engines to manually parse and add a template from a text as [requested](https://github.com/kataras/iris/issues/1617). [Examples](https://github.com/kataras/iris/tree/master/_examples/view/parse-template).\r\n- Full `http.FileSystem` interface support for all **view** engines as [requested](https://github.com/kataras/iris/issues/1575). The first argument of the functions(`HTML`, `Blocks`, `Pug`, `Amber`, `Ace`, `Jet`, `Django`, `Handlebars`) can now be either a directory of `string` type (like before) or a value which completes the `http.FileSystem` interface. The `.Binary` method of all view engines was removed: pass the go-bindata's latest version `AssetFile()` exported function as the first argument instead of string.\r\n\r\n- Add `Route.ExcludeSitemap() *Route` to exclude a route from sitemap as requested in [chat](https://chat.iris-go.com), also offline routes are excluded automatically now.\r\n\r\n- Improved tracing (with `app.Logger().SetLevel(\"debug\")`) for routes. Screens:\r\n\r\n#### DBUG Routes (1)\r\n\r\n![DBUG routes 1](https://iris-go.com/images/v12.2.0-dbug.png?v=0)\r\n\r\n#### DBUG Routes (2)\r\n\r\n![DBUG routes 2](https://iris-go.com/images/v12.2.0-dbug2.png?v=0)\r\n\r\n#### DBUG Routes (3)\r\n\r\n![DBUG routes with Controllers](https://iris-go.com/images/v12.2.0-dbug3.png?v=0)\r\n\r\n- Update the [pprof middleware](https://github.com/kataras/iris/tree/master/middleware/pprof).\r\n\r\n- New `Controller.HandleHTTPError(mvc.Code) <T>` optional Controller method to handle http errors as requested at: [MVC - More Elegent OnErrorCode registration?](https://github.com/kataras/iris/issues/1595). Example can be found [here](https://github.com/kataras/iris/tree/master/_examples/mvc/error-handler-http/main.go).\r\n\r\n![MVC: HTTP Error Handler Method](https://user-images.githubusercontent.com/22900943/90948989-e04cd300-e44c-11ea-8c97-54d90fb0cbb6.png)\r\n\r\n- New [Rewrite Engine Middleware](https://github.com/kataras/iris/tree/master/middleware/rewrite). Set up redirection rules for path patterns using the syntax we all know. [Example Code](https://github.com/kataras/iris/tree/master/_examples/routing/rewrite).\r\n\r\n```yml\r\nRedirectMatch: # REDIRECT_CODE_DIGITS | PATTERN_REGEX | TARGET_REPL\r\n  # Redirects /seo/* to /*\r\n  - 301 /seo/(.*) /$1\r\n\r\n  # Redirects /docs/v12* to /docs\r\n  - 301 /docs/v12(.*) /docs\r\n\r\n  # Redirects /old(.*) to /\r\n  - 301 /old(.*) /\r\n\r\n  # Redirects http or https://test.* to http or https://newtest.*\r\n  - 301 ^(http|https)://test.(.*) $1://newtest.$2\r\n\r\n  # Handles /*.json or .xml as *?format=json or xml,\r\n  # without redirect. See /users route.\r\n  # When Code is 0 then it does not redirect the request,\r\n  # instead it changes the request URL\r\n  # and leaves a route handle the request.\r\n  - 0 /(.*).(json|xml) /$1?format=$2\r\n\r\n# Redirects root domain to www.\r\n# Creation of a www subdomain inside the Application is unnecessary,\r\n# all requests are handled by the root Application itself.\r\nPrimarySubdomain: www\r\n```\r\n\r\n- New `TraceRoute bool` on [middleware/logger](https://github.com/kataras/iris/tree/master/middleware/logger) middleware. Displays information about the executed route. Also marks the handlers executed. Screenshot:\r\n\r\n![logger middleware: TraceRoute screenshot](https://iris-go.com/images/github/logger-trace-route.png)\r\n\r\n- Implement feature request [Log when I18n Translation Fails?](https://github.com/kataras/iris/issues/1593) by using the new `Application.I18n.DefaultMessageFunc` field **before** `I18n.Load`. [Example of usage](https://github.com/kataras/iris/blob/master/_examples/i18n/basic/main.go#L28-L50).\r\n\r\n- Fix [#1594](https://github.com/kataras/iris/issues/1594) and add a new `PathAfterHandler` which can be set to true to enable the old behavior (not recommended though).\r\n\r\n- New [apps](https://github.com/kataras/iris/tree/master/apps) subpackage. [Example of usage](https://github.com/kataras/iris/tree/master/_examples/routing/subdomains/redirect/multi-instances).\r\n\r\n![apps image example](https://user-images.githubusercontent.com/22900943/90459288-8a54f400-e109-11ea-8dea-20631975c9fc.png)\r\n\r\n- Fix `AutoTLS` when used with `iris.TLSNoRedirect` [*](https://github.com/kataras/iris/issues/1577). The `AutoTLS` runner can be customized through the new `iris.AutoTLSNoRedirect` instead, read its go documentation. Example of having both TLS and non-TLS versions of the same application without conflicts with letsencrypt `./well-known` path:\r\n\r\n![](https://iris-go.com/images/github/autotls-1.png)\r\n\r\n```go\r\npackage main\r\n\r\nimport (\r\n\t\"net/http\"\r\n\t\"time\"\r\n\r\n\t\"github.com/kataras/iris/v12\"\r\n)\r\n\r\nfunc main() {\r\n\tapp := iris.New()\r\n\tapp.Logger().SetLevel(\"debug\")\r\n\r\n\tapp.Get(\"/\", func(ctx iris.Context) {\r\n\t\tctx.JSON(iris.Map{\r\n\t\t\t\"time\": time.Now().Unix(),\r\n\t\t\t\"tls\":  ctx.Request().TLS != nil,\r\n\t\t})\r\n\t})\r\n\r\n\tvar fallbackServer = func(acme func(http.Handler) http.Handler) *http.Server {\r\n\t\tsrv := &http.Server{Handler: acme(app)}\r\n\t\tgo srv.ListenAndServe()\r\n\t\treturn srv\r\n\t}\r\n\r\n\tapp.Run(iris.AutoTLS(\":443\", \"example.com\", \"mail@example.com\",\r\n\t\tiris.AutoTLSNoRedirect(fallbackServer)))\r\n}\r\n```\r\n\r\n- `iris.Minify` middleware to minify responses based on their media/content-type.\r\n\r\n- `Context.OnCloseErr` and `Context.OnConnectionCloseErr` - to call a function of `func() error`  instead of an `iris.Handler` when request is closed or manually canceled.\r\n\r\n- `Party.UseError(...Handler)` - to register handlers to run before any http errors (e.g. before `OnErrorCode/OnAnyErrorCode` or default error codes when no handler is responsible to handle a specific http status code).\r\n\r\n- `Party.UseRouter(...Handler) and Party.ResetRouterFilters()` - to register handlers before the main router, useful on handlers that should control whether the router itself should ran or not. Independently of the incoming request's method and path values. These handlers will be executed ALWAYS against ALL incoming matched requests. Example of use-case: CORS.\r\n\r\n- `*versioning.Group` type is a full `Party` now.\r\n\r\n- `Party.UseOnce` - either inserts a middleware, or on the basis of the middleware already existing, replace that existing middleware instead.\r\n\r\n- Ability to register a view engine per group of routes or for the current chain of handlers through `Party.RegisterView` and `Context.ViewEngine` respectfully.\r\n\r\n- Add [Blocks](_examples/view/template_blocks_0) template engine. <!-- Reminder for @kataras: follow https://github.com/flosch/pongo2/pull/236#issuecomment-668950566 discussion so we can get back on using the original pongo2 repository as they fixed the issue about an incompatible 3rd party package (although they need more fixes, that's why I commented there) -->\r\n\r\n- Add [Ace](_examples/view/template_ace_0) template parser to the view engine and other minor improvements.\r\n\r\n- Fix huge repo size of 55.7MB, which slows down the overall Iris installation experience. Now, go-get performs ~3 times faster. I 've managed it using the [bfg-repo-cleaner](https://github.com/rtyley/bfg-repo-cleaner) tool - an alternative to  git-filter-branch command. Watch the small gif below to learn how:\r\n\r\n[![](https://media.giphy.com/media/U8560aiWTurW4iAOLn/giphy.gif)](https://media.giphy.com/media/U8560aiWTurW4iAOLn/giphy.gif)\r\n\r\n- [gRPC](https://grpc.io/) features:\r\n    - New Router [Wrapper](middleware/grpc).\r\n    - New MVC `.Handle(ctrl, mvc.GRPC{...})` option which allows to register gRPC services per-party (without the requirement of a full wrapper) and optionally strict access to gRPC clients only, see the [example here](_examples/mvc/grpc-compatible).\r\n\r\n- Add `Configuration.RemoteAddrHeadersForce bool` to force `Context.RemoteAddr() string` to return the first entry of request headers as a fallback instead of the `Request.RemoteAddr` one, as requested at: [1567#issuecomment-663972620](https://github.com/kataras/iris/issues/1567#issuecomment-663972620).\r\n\r\n- Fix [#1569#issuecomment-663739177](https://github.com/kataras/iris/issues/1569#issuecomment-663739177).\r\n\r\n- Fix [#1564](https://github.com/kataras/iris/issues/1564).\r\n\r\n- Fix [#1553](https://github.com/kataras/iris/issues/1553).\r\n\r\n- New `DirOptions.Cache` to cache assets in-memory among with their compressed contents (in order to be ready to served if client ask). Learn more about this feature by reading [all #1556 comments](https://github.com/kataras/iris/issues/1556#issuecomment-661057446). Usage:\r\n\r\n```go\r\nvar dirOpts = DirOptions{\r\n    // [...other options]\r\n    Cache: DirCacheOptions{\r\n        Enable: true,\r\n        // Don't compress files smaller than 300 bytes.\r\n        CompressMinSize: 300,\r\n        // Ignore compress already compressed file types\r\n        // (some images and pdf).\r\n        CompressIgnore: iris.MatchImagesAssets,\r\n        // Gzip, deflate, br(brotli), snappy.\r\n        Encodings: []string{\"gzip\", \"deflate\", \"br\", \"snappy\"},\r\n        // Log to the stdout the total reduced file size.\r\n        Verbose: 1,\r\n    },\r\n}\r\n```\r\n\r\n- New `DirOptions.PushTargets` and `PushTargetsRegexp` to push index' assets to the client without additional requests. Inspirated by issue [#1562](https://github.com/kataras/iris/issues/1562). Example matching all `.js, .css and .ico` files (recursively):\r\n\r\n```go\r\nvar dirOpts = iris.DirOptions{\r\n    // [...other options]\r\n    IndexName: \"/index.html\",\r\n    PushTargetsRegexp: map[string]*regexp.Regexp{\r\n        \"/\": regexp.MustCompile(\"((.*).js|(.*).css|(.*).ico)$\"),\r\n        // OR:\r\n        // \"/\": iris.MatchCommonAssets,\r\n    },\r\n    Compress: true,\r\n}\r\n```\r\n\r\n- Update jet parser to v5.0.2, closes [#1551](https://github.com/kataras/iris/issues/1551). It contains two breaking changes by its author:\r\n    - Relative paths on `extends, import, include...` tmpl functions, e.g. `{{extends \"../layouts/application.jet\"}}` instead of `layouts/application.jet`\r\n    - the new [jet.Ranger](https://github.com/CloudyKit/jet/pull/165) interface now requires a `ProvidesIndex() bool` method too\r\n    - Example has been [updated](https://github.com/kataras/iris/tree/master/_examples/view/template_jet_0)\r\n\r\n- Fix [#1552](https://github.com/kataras/iris/issues/1552).\r\n\r\n- Proper listing of root directories on `Party.HandleDir` when its `DirOptions.ShowList` was set to true.\r\n    - Customize the file/directory listing page through views, see [example](https://github.com/kataras/iris/tree/master/_examples/file-server/file-server).\r\n\r\n- Socket Sharding as requested at [#1544](https://github.com/kataras/iris/issues/1544). New `iris.WithSocketSharding` Configurator and `SocketSharding bool` setting.\r\n\r\n- Versioned Controllers feature through the new `mvc.Version` option. See [_examples/mvc/versioned-controller](https://github.com/kataras/iris/blob/master/_examples/mvc/versioned-controller/main.go).\r\n\r\n- Fix [#1539](https://github.com/kataras/iris/issues/1539).\r\n\r\n- New [rollbar example](https://github.com/kataras/iris/blob/master/_examples/logging/rollbar/main.go).\r\n\r\n- New builtin [requestid](https://github.com/kataras/iris/tree/master/middleware/requestid) middleware.\r\n\r\n- New builtin [JWT](https://github.com/kataras/iris/tree/master/middleware/jwt) middleware based on the fastest JWT implementation; [kataras/jwt](https://github.com/kataras/jwt) featured with optional wire encryption to set claims with sensitive data when necessary.\r\n\r\n- New `iris.RouteOverlap` route registration rule. `Party.SetRegisterRule(iris.RouteOverlap)` to allow overlapping across multiple routes for the same request subdomain, method, path. See [1536#issuecomment-643719922](https://github.com/kataras/iris/issues/1536#issuecomment-643719922). This allows two or more **MVC Controllers** to listen on the same path based on one or more registered dependencies (see [_examples/mvc/authenticated-controller](https://github.com/kataras/iris/tree/master/_examples/mvc/authenticated-controller)).\r\n\r\n- `Context.ReadForm` now can return an `iris.ErrEmptyForm` instead of `nil` when the new `Configuration.FireEmptyFormError` is true  (when `iris.WithEmptyFormError` is set) on missing form body to read from.\r\n\r\n- `Configuration.EnablePathIntelligence | iris.WithPathIntelligence` to enable path intelligence automatic path redirection on the most closest path (if any), [example]((https://github.com/kataras/iris/blob/master/_examples/routing/intelligence/main.go)\r\n\r\n- Enhanced cookie security and management through new `Context.AddCookieOptions` method and new cookie options (look on New Package-level functions section below), [securecookie](https://github.com/kataras/iris/tree/master/_examples/cookies/securecookie) example has been updated.\r\n- `Context.RemoveCookie` removes also the Request's specific cookie of the same request lifecycle when `iris.CookieAllowReclaim` is set to cookie options, [example](https://github.com/kataras/iris/tree/master/_examples/cookies/options).\r\n\r\n- `iris.TLS` can now accept certificates in form of raw `[]byte` contents too.\r\n- `iris.TLS` registers a secondary http server which redirects \"http://\" to their \"https://\" equivalent requests, unless the new `iris.TLSNoRedirect` host Configurator is provided on `iris.TLS`, e.g. `app.Run(iris.TLS(\"127.0.0.1:443\", \"mycert.cert\", \"mykey.key\", iris.TLSNoRedirect))`. There is `iris.AutoTLSNoRedirect` option for `AutoTLS` too.\r\n\r\n- Fix an [issue](https://github.com/kataras/i18n/issues/1) about i18n loading from path which contains potential language code.\r\n\r\n- Server will not return neither log the `ErrServerClosed` error if `app.Shutdown` was called manually via interrupt signal(CTRL/CMD+C), note that if the server closed by any other reason the error will be fired as previously (unless `iris.WithoutServerError(iris.ErrServerClosed)`).\r\n\r\n- Finally, Log level's and Route debug information colorization is respected across outputs. Previously if the application used more than one output destination (e.g. a file through `app.Logger().AddOutput`) the color support was automatically disabled from all, including the terminal one, this problem is fixed now. Developers can now see colors in their terminals while log files are kept with clear text.\r\n\r\n- New `iris.WithLowercaseRouting` option which forces all routes' paths to be lowercase and converts request paths to their lowercase for matching.\r\n\r\n- New `app.Validator { Struct(interface{}) error }` field and `app.Validate` method were added. The `app.Validator = ` can be used to integrate a 3rd-party package such as [go-playground/validator](https://github.com/go-playground/validator). If set-ed then Iris `Context`'s `ReadJSON`, `ReadXML`, `ReadMsgPack`, `ReadYAML`, `ReadForm`, `ReadQuery`, `ReadBody` methods will return the validation error on data validation failures. The [read-json-struct-validation](_examples/request-body/read-json-struct-validation) example was updated.\r\n\r\n- A result of <T> can implement the new `hero.PreflightResult` interface which contains a single method of `Preflight(iris.Context) error`. If this method exists on a custom struct value which is returned from a handler then it will fire that `Preflight` first and if not errored then it will cotninue by sending the struct value as JSON(by-default) response body.\r\n\r\n- `ctx.JSON, JSONP, XML`: if `iris.WithOptimizations` is NOT passed on `app.Run/Listen` then the indentation defaults to `\"    \"` (four spaces) and `\"  \"` respectfully otherwise it is empty or the provided value.\r\n\r\n- Hero Handlers (and `app.ConfigureContainer().Handle`) do not have to require `iris.Context` just to call `ctx.Next()` anymore, this is done automatically now.\r\n\r\n- Improve Remote Address parsing as requested at: [#1453](https://github.com/kataras/iris/issues/1453). Add `Configuration.RemoteAddrPrivateSubnets` to exclude those addresses when fetched by `Configuration.RemoteAddrHeaders` through `context.RemoteAddr() string`.\r\n\r\n- Fix [#1487](https://github.com/kataras/iris/issues/1487).\r\n\r\n- Fix [#1473](https://github.com/kataras/iris/issues/1473).\r\n\r\n## New Package-level Variables\r\n\r\n- `iris.DirListRichOptions` to pass on `iris.DirListRich` method.\r\n- `iris.DirListRich` to override the default look and feel if the `DirOptions.ShowList` was set to true, can be passed to `DirOptions.DirList` field.\r\n- `DirOptions.PushTargets` for http/2 push on index [*](https://github.com/kataras/iris/tree/master/_examples/file-server/http2push/main.go).\r\n- `iris.Compression` middleware to compress responses and decode compressed request data respectfully.\r\n- `iris.B, KB, MB, GB, TB, PB, EB` for byte units.\r\n- `TLSNoRedirect` to disable automatic \"http://\" to \"https://\" redirections (see below)\r\n- `CookieAllowReclaim`, `CookieAllowSubdomains`, `CookieSameSite`, `CookieSecure` and `CookieEncoding` to bring previously sessions-only features to all cookies in the request.\r\n\r\n## New Context Methods\r\n\r\n- `Context.FormFiles(key string, before ...func(*Context, *multipart.FileHeader) bool) (files []multipart.File, headers []*multipart.FileHeader, err error)` method.\r\n- `Context.ReadURL(ptr interface{}) error` shortcut of `ReadParams` and `ReadQuery`. Binds URL dynamic path parameters and URL query parameters to the given \"ptr\" pointer of a struct value.\r\n- `Context.SetUser(User)` and `Context.User() User` to store and retrieve an authenticated client. Read more [here](https://github.com/iris-contrib/middleware/issues/63).\r\n- `Context.SetLogoutFunc(fn interface{}, persistenceArgs ...interface{})` and `Logout(args ...interface{}) error` methods to allow different kind of auth middlewares to be able to set a \"logout\" a user/client feature with a single function, the route handler may not be aware of the implementation of the authentication used.\r\n- `Context.SetFunc(name string, fn interface{}, persistenceArgs ...interface{})` and `Context.CallFunc(name string, args ...interface{}) ([]reflect.Value, error)` to allow middlewares to share functions dynamically when the type of the function is not predictable, see the [example](https://github.com/kataras/iris/tree/master/_examples/routing/writing-a-middleware/share-funcs) for more.\r\n- `Context.TextYAML(interface{}) error` same as `Context.YAML` but with set the Content-Type to `text/yaml` instead (Google Chrome renders it as text). \r\n- `Context.IsDebug() bool` reports whether the application is running under debug/development mode. It is a shortcut of Application.Logger().Level >= golog.DebugLevel.\r\n- `Context.IsRecovered() bool` reports whether the current request was recovered from the [recover middleware](https://github.com/kataras/iris/tree/master/middleware/recover). Also the `Context.GetErrPublic() (bool, error)`, `Context.SetErrPrivate(err error)` methods and `iris.ErrPrivate` interface have been introduced. \r\n- `Context.RecordRequestBody(bool)` same as the Application's `DisableBodyConsumptionOnUnmarshal` configuration field but registers per chain of handlers. It makes the request body readable more than once.\r\n- `Context.IsRecordingBody() bool` reports whether the request body can be readen multiple times.\r\n- `Context.ReadHeaders(ptr interface{}) error` binds request headers to \"ptr\". [Example](https://github.com/kataras/iris/blob/master/_examples/request-body/read-headers/main.go).\r\n- `Context.ReadParams(ptr interface{}) error` binds dynamic path parameters to \"ptr\". [Example](https://github.com/kataras/iris/blob/master/_examples/request-body/read-params/main.go).\r\n- `Context.SaveFormFile(fh *multipart.FileHeader, dest string) (int64, error)` previously unexported. Accepts a result file of `Context.FormFile` and saves it to the disk.\r\n- `Context.URLParamSlice(name string) []string` is a a shortcut of `ctx.Request().URL.Query()[name]`. Like `URLParam` but it returns all values as a string slice instead of a single string separated by commas. Note that it skips any empty values (e.g. https://iris-go.com?values=).\r\n- `Context.PostValueMany(name string) (string, error)` returns the post data of a given key. The returned value is a single string separated by commas on multiple values. It also reports whether the form was empty or when the \"name\" does not exist or whether the available values are empty. It strips any empty key-values from the slice before return. See `ErrEmptyForm`, `ErrNotFound` and `ErrEmptyFormField` respectfully. The `PostValueInt`, `PostValueInt64`, `PostValueFloat64` and `PostValueBool` now respect the above errors too (the `PostValues` method now returns a second output argument of `error` too, see breaking changes below). \r\n- `Context.URLParamsSorted() []memstore.StringEntry` returns a sorted (by key) slice of key-value entries of the URL Query parameters.\r\n- `Context.ViewEngine(ViewEngine)` to set a view engine on-fly for the current chain of handlers, responsible to render templates through `ctx.View`. [Example](_examples/view/context-view-engine).\r\n- `Context.SetErr(error)` and `Context.GetErr() error` helpers.\r\n- `Context.CompressWriter(bool) error` and `Context.CompressReader(bool) error`.\r\n- `Context.Clone() Context` returns a copy of the Context safe for concurrent access.\r\n- `Context.IsCanceled() bool` reports whether the request has been canceled by the client.\r\n- `Context.IsSSL() bool` reports whether the request is under HTTPS SSL (New `Configuration.SSLProxyHeaders` and `HostProxyHeaders` fields too).\r\n- `Context.CompressReader(enable bool)` method and `iris.CompressReader` middleware to enable future request read body calls to decompress data, [example](_examples/compression/main.go).\r\n- `Context.RegisterDependency(v interface{})` and `Context.UnregisterDependency(typ reflect.Type)` to register/remove struct dependencies on serve-time through a middleware.\r\n- `Context.SetID(id interface{})` and `Context.GetID() interface{}` added to register a custom unique indetifier to the Context, if necessary.\r\n- `Context.Scheme() string` returns the full scheme of the request URL.\r\n- `Context.SubdomainFull() string` returns the full subdomain(s) part of the host (`host[0:rootLevelDomain]`).\r\n- `Context.Domain() string` returns the root level domain.\r\n- `Context.AddCookieOptions(...CookieOption)` adds options for `SetCookie`, `SetCookieKV, UpsertCookie` and `RemoveCookie` methods for the current request.\r\n- `Context.ClearCookieOptions()` clears any cookie options registered through `AddCookieOptions`.\r\n- `Context.SetLanguage(langCode string)` force-sets a language code from inside a middleare, similar to the `app.I18n.ExtractFunc`\r\n- `Context.ServeContentWithRate`, `ServeFileWithRate` and `SendFileWithRate` methods to throttle the \"download\" speed of the client\r\n- `Context.IsHTTP2() bool` reports whether the protocol version for incoming request was HTTP/2\r\n- `Context.IsGRPC() bool` reports whether the request came from a gRPC client\r\n- `Context.UpsertCookie(*http.Cookie, cookieOptions ...context.CookieOption)` upserts a cookie, fixes [#1485](https://github.com/kataras/iris/issues/1485) too\r\n- `Context.StopWithStatus(int)` stops the handlers chain and writes the status code\r\n- `StopWithText(statusCode int, format string, args ...interface{})` stops the handlers chain, writes thre status code and a plain text message\r\n- `Context.StopWithError(int, error)` stops the handlers chain, writes thre status code and the error's message\r\n- `Context.StopWithJSON(int, interface{})` stops the handlers chain, writes the status code and sends a JSON response\r\n- `Context.StopWithProblem(int, iris.Problem)` stops the handlers, writes the status code and sends an `application/problem+json` response\r\n- `Context.Protobuf(proto.Message)` sends protobuf to the client (note that the `Context.JSON` is able to send protobuf as JSON)\r\n- `Context.MsgPack(interface{})` sends msgpack format data to the client\r\n- `Context.ReadProtobuf(ptr)` binds request body to a proto message\r\n- `Context.ReadJSONProtobuf(ptr, ...options)` binds JSON request body to a proto message\r\n- `Context.ReadMsgPack(ptr)` binds request body of a msgpack format to a struct\r\n- `Context.ReadBody(ptr)` binds the request body to the \"ptr\" depending on the request's Method and Content-Type\r\n- `Context.ReflectValue() []reflect.Value` stores and returns the `[]reflect.ValueOf(ctx)`\r\n- `Context.Controller() reflect.Value` returns the current MVC Controller value.\r\n\r\n## MVC & Dependency Injection\r\n\r\nThe new release contains a fresh new and awesome feature....**a function dependency can accept previous registered dependencies and update or return a new value of any type**.\r\n\r\nThe new implementation is **faster** on both design and serve-time.\r\n\r\nThe most common scenario from a route to handle is to:\r\n- accept one or more path parameters and request data, a payload\r\n- send back a response, a payload (JSON, XML,...)\r\n\r\nThe new Iris Dependency Injection feature is about **33.2% faster** than its predecessor on the above case. This drops down even more the performance cost between native handlers and dynamic handlers with dependencies. This reason itself brings us, with safety and performance-wise, to the new `Party.ConfigureContainer(builder ...func(*iris.APIContainer)) *APIContainer` method which returns methods such as `Handle(method, relativePath string, handlersFn ...interface{}) *Route` and `RegisterDependency`.\r\n\r\nLook how clean your codebase can be when using Iris':\r\n\r\n```go\r\npackage main\r\n\r\nimport \"github.com/kataras/iris/v12\"\r\n\r\ntype (\r\n    testInput struct {\r\n        Email string `json:\"email\"`\r\n    }\r\n\r\n    testOutput struct {\r\n        ID   int    `json:\"id\"`\r\n        Name string `json:\"name\"`\r\n    }\r\n)\r\n\r\nfunc handler(id int, in testInput) testOutput {\r\n    return testOutput{\r\n        ID:   id,\r\n        Name: in.Email,\r\n    }\r\n}\r\n\r\nfunc main() {\r\n    app := iris.New()\r\n    app.ConfigureContainer(func(api *iris.APIContainer) {\r\n        api.Post(\"/{id:int}\", handler)\r\n    })\r\n    app.Listen(\":5000\", iris.WithOptimizations)\r\n}\r\n```\r\n\r\nYour eyes don't lie you. You read well, no `ctx.ReadJSON(&v)` and `ctx.JSON(send)` neither `error` handling are presented. It is a huge relief but if you ever need, you still have the control over those, even errors from dependencies. Here is a quick list of the new Party.ConfigureContainer()'s fields and methods:\r\n\r\n```go\r\n// Container holds the DI Container of this Party featured Dependency Injection.\r\n// Use it to manually convert functions or structs(controllers) to a Handler.\r\nContainer *hero.Container\r\n```\r\n\r\n```go\r\n// OnError adds an error handler for this Party's DI Hero Container and its handlers (or controllers).\r\n// The \"errorHandler\" handles any error may occurred and returned\r\n// during dependencies injection of the Party's hero handlers or from the handlers themselves.\r\nOnError(errorHandler func(iris.Context, error))\r\n```\r\n\r\n```go\r\n// RegisterDependency adds a dependency.\r\n// The value can be a single struct value or a function.\r\n// Follow the rules:\r\n// * <T> {structValue}\r\n// * func(accepts <T>)                                 returns <D> or (<D>, error)\r\n// * func(accepts iris.Context)                        returns <D> or (<D>, error)\r\n//\r\n// A Dependency can accept a previous registered dependency and return a new one or the same updated.\r\n// * func(accepts1 <D>, accepts2 <T>)                  returns <E> or (<E>, error) or error\r\n// * func(acceptsPathParameter1 string, id uint64)     returns <T> or (<T>, error)\r\n//\r\n// Usage:\r\n//\r\n// - RegisterDependency(loggerService{prefix: \"dev\"})\r\n// - RegisterDependency(func(ctx iris.Context) User {...})\r\n// - RegisterDependency(func(User) OtherResponse {...})\r\nRegisterDependency(dependency interface{})\r\n\r\n// UseResultHandler adds a result handler to the Container.\r\n// A result handler can be used to inject the returned struct value\r\n// from a request handler or to replace the default renderer.\r\nUseResultHandler(handler func(next iris.ResultHandler) iris.ResultHandler)\r\n```\r\n\r\n<details><summary>ResultHandler</summary>\r\n\r\n```go\r\ntype ResultHandler func(ctx iris.Context, v interface{}) error\r\n```\r\n</details>\r\n\r\n```go\r\n// Use same as a common Party's \"Use\" but it accepts dynamic functions as its \"handlersFn\" input.\r\nUse(handlersFn ...interface{})\r\n// Done same as a common Party's but it accepts dynamic functions as its \"handlersFn\" input.\r\nDone(handlersFn ...interface{})\r\n```\r\n\r\n```go\r\n// Handle same as a common Party's `Handle` but it accepts one or more \"handlersFn\" functions which each one of them\r\n// can accept any input arguments that match with the Party's registered Container's `Dependencies` and\r\n// any output result; like custom structs <T>, string, []byte, int, error,\r\n// a combination of the above, hero.Result(hero.View | hero.Response) and more.\r\n//\r\n// It's common from a hero handler to not even need to accept a `Context`, for that reason,\r\n// the \"handlersFn\" will call `ctx.Next()` automatically when not called manually.\r\n// To stop the execution and not continue to the next \"handlersFn\"\r\n// the end-developer should output an error and return `iris.ErrStopExecution`.\r\nHandle(method, relativePath string, handlersFn ...interface{}) *Route\r\n\r\n// Get registers a GET route, same as `Handle(\"GET\", relativePath, handlersFn....)`.\r\nGet(relativePath string, handlersFn ...interface{}) *Route\r\n// and so on...\r\n```\r\n\r\nPrior to this version the `iris.Context` was the only one dependency that has been automatically binded to the handler's input or a controller's fields and methods, read below to see what types are automatically binded:\r\n\r\n| Type | Maps To |\r\n|------|:---------|\r\n| [*mvc.Application](https://pkg.go.dev/github.com/kataras/iris/v12/mvc?tab=doc#Application) | Current MVC Application |\r\n| [iris.Context](https://pkg.go.dev/github.com/kataras/iris/v12/context?tab=doc#Context) | Current Iris Context |\r\n| [*sessions.Session](https://pkg.go.dev/github.com/kataras/iris/v12/sessions?tab=doc#Session) | Current Iris Session |\r\n| [context.Context](https://golang.org/pkg/context/#Context) | [ctx.Request().Context()](https://golang.org/pkg/net/http/#Request.Context) |\r\n| [*http.Request](https://golang.org/pkg/net/http/#Request) | `ctx.Request()` |\r\n| [http.ResponseWriter](https://golang.org/pkg/net/http/#ResponseWriter) | `ctx.ResponseWriter()` |\r\n| [http.Header](https://golang.org/pkg/net/http/#Header) | `ctx.Request().Header` |\r\n| [time.Time](https://golang.org/pkg/time/#Time) | `time.Now()` |\r\n| [*golog.Logger](https://pkg.go.dev/github.com/kataras/golog) | Iris Logger |\r\n| [net.IP](https://golang.org/pkg/net/#IP) | `net.ParseIP(ctx.RemoteAddr())` |\r\n| [mvc.Code](https://pkg.go.dev/github.com/kataras/iris/v12/mvc?tab=doc#Code) | `ctx.GetStatusCode() int` |\r\n| [mvc.Err](https://pkg.go.dev/github.com/kataras/iris/v12/mvc?tab=doc#Err) | `ctx.GetErr() error` |\r\n| [iris/context.User](https://pkg.go.dev/github.com/kataras/iris/v12/context?tab=doc#User) | `ctx.User()` |\r\n| `string`, | |\r\n| `int, int8, int16, int32, int64`, | |\r\n| `uint, uint8, uint16, uint32, uint64`, | |\r\n| `float, float32, float64`, | |\r\n| `bool`, | |\r\n| `slice` | [Path Parameter](https://github.com/kataras/iris/wiki/Routing-path-parameter-types) |\r\n| Struct | [Request Body](https://github.com/kataras/iris/tree/master/_examples/request-body) of `JSON`, `XML`, `YAML`, `Form`, `URL Query`, `Protobuf`, `MsgPack` |\r\n\r\nHere is a preview of what the new Hero handlers look like:\r\n\r\n### Request & Response & Path Parameters\r\n\r\n**1.** Declare Go types for client's request body and a server's response.\r\n\r\n```go\r\ntype (\r\n\trequest struct {\r\n\t\tFirstname string `json:\"firstname\"`\r\n\t\tLastname  string `json:\"lastname\"`\r\n\t}\r\n\r\n\tresponse struct {\r\n\t\tID      uint64 `json:\"id\"`\r\n\t\tMessage string `json:\"message\"`\r\n\t}\r\n)\r\n```\r\n\r\n**2.** Create the route handler.\r\n\r\nPath parameters and request body are binded automatically.\r\n- **id uint64** binds to \"id:uint64\"\r\n- **input request** binds to client request data such as JSON\r\n\r\n```go\r\nfunc updateUser(id uint64, input request) response {\r\n\treturn response{\r\n\t\tID:      id,\r\n\t\tMessage: \"User updated successfully\",\r\n\t}\r\n}\r\n```\r\n\r\n**3.** Configure the container per group and register the route.\r\n\r\n```go\r\napp.Party(\"/user\").ConfigureContainer(container)\r\n\r\nfunc container(api *iris.APIContainer) {\r\n    api.Put(\"/{id:uint64}\", updateUser)\r\n}\r\n```\r\n\r\n**4.** Simulate a [client](https://curl.haxx.se/download.html) request which sends data to the server and displays the response.\r\n\r\n```sh\r\ncurl --request PUT -d '{\"firstanme\":\"John\",\"lastname\":\"Doe\"}' http://localhost:8080/user/42\r\n```\r\n\r\n```json\r\n{\r\n    \"id\": 42,\r\n    \"message\": \"User updated successfully\"\r\n}\r\n```\r\n\r\n### Custom Preflight\r\n\r\nBefore we continue to the next section, register dependencies, you may want to learn how a response can be customized through the `iris.Context` right before sent to the client.\r\n\r\nThe server will automatically execute the `Preflight(iris.Context) error` method of a function's output struct value right before send the response to the client.\r\n\r\nTake for example that you want to fire different HTTP status codes depending on the custom logic inside your handler and also modify the value(response body) itself before sent to the client. Your response type should contain a `Preflight` method like below.\r\n\r\n```go\r\ntype response struct {\r\n    ID      uint64 `json:\"id,omitempty\"`\r\n    Message string `json:\"message\"`\r\n    Code    int    `json:\"code\"`\r\n    Timestamp int64 `json:\"timestamp,omitempty\"`\r\n}\r\n\r\nfunc (r *response) Preflight(ctx iris.Context) error {\r\n    if r.ID > 0 {\r\n        r.Timestamp = time.Now().Unix()\r\n    }\r\n\r\n    if r.Code > 0 {\r\n        ctx.StatusCode(r.Code)\r\n    }\r\n\r\n    return nil\r\n}\r\n```\r\n\r\nNow, each handler that returns a `*response` value will call the `response.Preflight` method automatically.\r\n\r\n```go\r\nfunc deleteUser(db *sql.DB, id uint64) *response {\r\n    // [...custom logic]\r\n\r\n    return &response{\r\n        Message: \"User has been marked for deletion\",\r\n        Code: iris.StatusAccepted,\r\n    }\r\n}\r\n```\r\n\r\nIf you register the route and fire a request you should see an output like this, the timestamp is filled and the HTTP status code of the response that the client will receive is 202 (Status Accepted).\r\n\r\n```json\r\n{\r\n  \"message\": \"User has been marked for deletion\",\r\n  \"code\": 202,\r\n  \"timestamp\": 1583313026\r\n}\r\n```\r\n\r\n### Register Dependencies\r\n\r\n**1.** Import packages to interact with a database.\r\nThe go-sqlite3 package is a database driver for [SQLite](https://www.sqlite.org/index.html).\r\n\r\n```go\r\nimport \"database/sql\"\r\nimport _ \"github.com/mattn/go-sqlite3\"\r\n```\r\n\r\n**2.** Configure the container ([see above](#request--response--path-parameters)), register your dependencies. Handler expects an *sql.DB instance.\r\n\r\n```go\r\nlocalDB, _ := sql.Open(\"sqlite3\", \"./foo.db\")\r\napi.RegisterDependency(localDB)\r\n```\r\n\r\n**3.** Register a route to create a user.\r\n\r\n```go\r\napi.Post(\"/{id:uint64}\", createUser)\r\n```\r\n\r\n**4.** The create user Handler.\r\n\r\nThe handler accepts a database and some client request data such as JSON, Protobuf, Form, URL Query and e.t.c. It Returns a response.\r\n\r\n```go\r\nfunc createUser(db *sql.DB, user request) *response {\r\n    // [custom logic using the db]\r\n    userID, err := db.CreateUser(user)\r\n    if err != nil {\r\n        return &response{\r\n            Message: err.Error(),\r\n            Code: iris.StatusInternalServerError,\r\n        }\r\n    }\r\n\r\n\treturn &response{\r\n\t\tID:      userID,\r\n\t\tMessage: \"User created\",\r\n\t\tCode:    iris.StatusCreated,\r\n\t}\r\n}\r\n```\r\n\r\n**5.** Simulate a [client](https://curl.haxx.se/download.html) to create a user.\r\n\r\n```sh\r\n# JSON\r\ncurl --request POST -d '{\"firstname\":\"John\",\"lastname\":\"Doe\"}' \\\r\n--header 'Content-Type: application/json' \\\r\nhttp://localhost:8080/user\r\n```\r\n\r\n```sh\r\n# Form (multipart)\r\ncurl --request POST 'http://localhost:8080/users' \\\r\n--header 'Content-Type: multipart/form-data' \\\r\n--form 'firstname=John' \\\r\n--form 'lastname=Doe'\r\n```\r\n\r\n```sh\r\n# Form (URL-encoded)\r\ncurl --request POST 'http://localhost:8080/users' \\\r\n--header 'Content-Type: application/x-www-form-urlencoded' \\\r\n--data-urlencode 'firstname=John' \\\r\n--data-urlencode 'lastname=Doe'\r\n```\r\n\r\n```sh\r\n# URL Query\r\ncurl --request POST 'http://localhost:8080/users?firstname=John&lastname=Doe'\r\n```\r\n\r\nResponse: \r\n\r\n```json\r\n{\r\n    \"id\": 42,\r\n    \"message\": \"User created\",\r\n    \"code\": 201,\r\n    \"timestamp\": 1583313026\r\n}\r\n```\r\n\r\n## Breaking Changes\r\n\r\n- The `versioning.NewMatcher` has been removed entirely in favor of `NewGroup`. Strict versions format on `versioning.NewGroup` is required. E.g. `\"1\"` is not valid anymore, you have to specify `\"1.0.0\"`. Example: `NewGroup(api, \">=1.0.0 <2.0.0\")`. The [routing/versioning](_examples/routing/versioning) examples have been updated.\r\n- Now that `RegisterView` can be used to register different view engines per-Party, there is no need to support registering multiple engines under the same Party. The `app.RegisterView` now upserts the given Engine instead of append. You can now render templates **without file extension**, e.g. `index` instead of `index.ace`, both forms are valid now.\r\n- The `Context.ContentType` does not accept filenames to resolve the mime type anymore (caused issues with  vendor-specific(vnd) MIME types).\r\n- The `Configuration.RemoteAddrPrivateSubnets.IPRange.Start and End` are now type of `string` instead of `net.IP`. The `WithRemoteAddrPrivateSubnet` option remains as it is, already accepts `string`s.\r\n- The `i18n#LoaderConfig.FuncMap template.FuncMap` field was replaced with `Funcs func(iris.Locale) template.FuncMap` in order to give current locale access to the template functions. A new `app.I18n.Loader` was introduced too, in order to make it easier for end-developers to customize the translation key values.\r\n- Request Logger's `Columns bool` field has been removed. Use the new [accesslog](https://github.com/kataras/iris/tree/master/_examples/logging/request-logger/accesslog/main.go) middleware instead.\r\n- The `.Binary` method of all view engines was removed: pass the go-bindata's latest version `AssetFile()` exported function as the first argument instead of string. All examples updated.\r\n- `ContextUploadFormFiles(destDirectory string, before ...func(*Context, *multipart.FileHeader) bool) (uploaded []*multipart.FileHeader, n int64, err error)` now returns the total files uploaded too (as its first parameter) and the \"before\" variadic option should return a boolean, if false then the specific file is skipped.\r\n- `Context.PostValues(name string) ([]string, error)` now returns a second output argument of `error` type too, which reports `ErrEmptyForm` or `ErrNotFound` or `ErrEmptyFormField`. The single post value getters now returns the **last value** if multiple was given instead of the first one (this allows clients to append values on flow updates).\r\n- `Party.GetReporter()` **removed**. The `Application.Build` returns the first error now and the API's errors are logged, this allows the server to run even if some of the routes are invalid but not fatal to the entire application (it was a request from a company).\r\n- `versioning.NewGroup(string)` now accepts a `Party` as its first input argument: `NewGroup(Party, string)`.\r\n- `versioning.RegisterGroups` is **removed** as it is no longer necessary.\r\n- `Configuration.RemoteAddrHeaders` from `map[string]bool` to `[]string`. If you used `With(out)RemoteAddrHeader` then you are ready to proceed without any code changes for that one.\r\n- `ctx.Gzip(boolean)` replaced with `ctx.CompressWriter(boolean) error`.\r\n- `ctx.GzipReader(boolean) error` replaced with `ctx.CompressReader(boolean) error`.\r\n- `iris.Gzip` and `iris.GzipReader` replaced with `iris.Compression` (middleware).\r\n- `ctx.ClientSupportsGzip() bool` replaced with `ctx.ClientSupportsEncoding(\"gzip\", \"br\" ...) bool`.\r\n- `ctx.GzipResponseWriter()` is **removed**.\r\n- `Party.HandleDir/iris.FileServer` now accepts both `http.FileSystem` and `string` and returns a list of `[]*Route` (GET and HEAD) instead of GET only. You can write: both `app.HandleDir(\"/\", iris.Dir(\"./assets\"))` and `app.HandleDir(\"/\", \"./assets\")` and `DirOptions.Asset, AssetNames, AssetInfo` removed, use `go-bindata -fs [..]` and `app.HandleDir(\"/\", AssetFile())` instead.\r\n- `Context.OnClose` and `Context.OnCloseConnection` now both accept an `iris.Handler` instead of a simple `func()` as their callback.\r\n- `Context.StreamWriter(writer func(w io.Writer) bool)` changed to `StreamWriter(writer func(w io.Writer) error) error` and it's now the `Context.Request().Context().Done()` channel that is used to receive any close connection/manual cancel signals, instead of the deprecated `ResponseWriter().CloseNotify()` one. Same for the `Context.OnClose` and `Context.OnCloseConnection` methods.\r\n- Fixed handler's error response not be respected when response recorder was used instead of the common writer. Fixes [#1531](https://github.com/kataras/iris/issues/1531). It contains a **BREAKING CHANGE** of: the new `Configuration.ResetOnFireErrorCode` field should be set **to true** in order to behave as it used before this update (to reset the contents on recorder).\r\n- `Context.String()` (rarely used by end-developers) it does not return a unique string anymore, to achieve the old representation you must call the new `Context.SetID` method first.\r\n- `iris.CookieEncode` and `CookieDecode` are replaced with the `iris.CookieEncoding`.\r\n- `sessions#Config.Encode` and `Decode` are removed in favor of (the existing) `Encoding` field.\r\n- `versioning.GetVersion` now returns an empty string if version wasn't found.\r\n- Change the MIME type of `Javascript .js` and `JSONP` as the HTML specification now recommends to `\"text/javascript\"` instead of the obselete `\"application/javascript\"`. This change was pushed to the `Go` language itself as well. See <https://go-review.googlesource.com/c/go/+/186927/>.\r\n- Remove the last input argument of `enableGzipCompression` in `Context.ServeContent`, `ServeFile` methods. This was deprecated a few versions ago. A middleware (`app.Use(iris.CompressWriter)`) or a prior call to `Context.CompressWriter(true)` will enable compression. Also these two methods and `Context.SendFile` one now support `Content-Range` and `Accept-Ranges` correctly out of the box (`net/http` had a bug, which is now fixed).\r\n- `Context.ServeContent` no longer returns an error, see `ServeContentWithRate`, `ServeFileWithRate` and `SendFileWithRate` new methods too.\r\n- `route.Trace() string` changed to `route.Trace(w io.Writer)`, to achieve the same result just pass a `bytes.Buffer`\r\n- `var mvc.AutoBinding` removed as the default behavior now resolves such dependencies automatically (see [[FEATURE REQUEST] MVC serving gRPC-compatible controller](https://github.com/kataras/iris/issues/1449)).\r\n- `mvc#Application.SortByNumMethods()` removed as the default behavior now binds the \"thinnest\"  empty `interface{}` automatically (see [MVC: service injecting fails](https://github.com/kataras/iris/issues/1343)).\r\n- `mvc#BeforeActivation.Dependencies().Add` should be replaced with `mvc#BeforeActivation.Dependencies().Register` instead\r\n- **REMOVE** the `kataras/iris/v12/typescript` package in favor of the new [iris-cli](https://github.com/kataras/iris-cli). Also, the alm typescript online editor was removed as it is deprecated by its author, please consider using the [designtsx](https://designtsx.com/) instead.\r\n\r\n# Su, 16 February 2020 | v12.1.8\r\n\r\nNew Features:\r\n\r\n-  [[FEATURE REQUEST] MVC serving gRPC-compatible controller](https://github.com/kataras/iris/issues/1449)\r\n\r\nFixes:\r\n\r\n- [App can't find embedded pug template files by go-bindata](https://github.com/kataras/iris/issues/1450)\r\n\r\nNew Examples:\r\n\r\n- [_examples/mvc/grpc-compatible](_examples/mvc/grpc-compatible)\r\n\r\n# Mo, 10 February 2020 | v12.1.7\r\n\r\nImplement **new** `SetRegisterRule(iris.RouteOverride, RouteSkip, RouteError)` to resolve: https://github.com/kataras/iris/issues/1448\r\n\r\nNew Examples:\r\n\r\n- [_examples/routing/route-register-rule](_examples/routing/route-register-rule)\r\n\r\n# We, 05 February 2020 | v12.1.6\r\n\r\nFixes:\r\n\r\n- [jet.View - urlpath error](https://github.com/kataras/iris/issues/1438)\r\n- [Context.ServeFile send 'application/wasm' with a wrong extra field](https://github.com/kataras/iris/issues/1440)\r\n\r\n# Su, 02 February 2020 | v12.1.5\r\n\r\nVarious improvements and linting.\r\n\r\n# Su, 29 December 2019 | v12.1.4\r\n\r\nMinor fix on serving [embedded files](https://github.com/kataras/iris/wiki/File-server).\r\n\r\n# We, 25 December 2019 | v12.1.3\r\n\r\nFix [[BUG] [iris.Default] RegisterView](https://github.com/kataras/iris/issues/1410)\r\n\r\n# Th, 19 December 2019 | v12.1.2\r\n\r\nFix [[BUG]Session works incorrectly when meets the multi-level TLDs](https://github.com/kataras/iris/issues/1407).\r\n\r\n# Mo, 16 December 2019 | v12.1.1\r\n\r\nAdd [Context.FindClosest(n int) []string](https://github.com/kataras/iris/blob/master/_examples/routing/intelligence/manual/main.go#L22)\r\n\r\n```go\r\napp := iris.New()\r\napp.OnErrorCode(iris.StatusNotFound, notFound)\r\n```\r\n\r\n```go\r\nfunc notFound(ctx iris.Context) {\r\n    suggestPaths := ctx.FindClosest(3)\r\n    if len(suggestPaths) == 0 {\r\n        ctx.WriteString(\"404 not found\")\r\n        return\r\n    }\r\n\r\n    ctx.HTML(\"Did you mean?<ul>\")\r\n    for _, s := range suggestPaths {\r\n        ctx.HTML(`<li><a href=\"%s\">%s</a></li>`, s, s)\r\n    }\r\n    ctx.HTML(\"</ul>\")\r\n}\r\n```\r\n\r\n![](https://iris-go.com/images/iris-not-found-suggests.png)\r\n\r\n# Fr, 13 December 2019 | v12.1.0\r\n\r\n## Breaking Changes\r\n\r\nMinor as many of you don't even use them but, indeed, they need to be covered here.\r\n\r\n- Old i18n middleware(iris/middleware/i18n) was replaced by the [i18n](i18n) sub-package which lives as field at your application: `app.I18n.Load(globPathPattern string, languages ...string)` (see below)\r\n- Community-driven i18n middleware(iris-contrib/middleware/go-i18n) has a `NewLoader` function which returns a loader which can be passed at `app.I18n.Reset(loader i18n.Loader, languages ...string)` to change the locales parser\r\n- The Configuration's `TranslateFunctionContextKey` was replaced by `LocaleContextKey` which Context store's value (if i18n is used) returns the current Locale which contains the translate function, the language code, the language tag and the index position of it\r\n- The `context.Translate` method was replaced by `context.Tr` as a shortcut for the new `context.GetLocale().GetMessage(format, args...)` method and it matches the view's function `{{tr format args}}` too\r\n- If you used [Iris Django](https://github.com/kataras/iris/tree/master/_examples/view/template_django_0) view engine with `import _ github.com/flosch/pongo2-addons` you **must change** the import path to `_ github.com/iris-contrib/pongo2-addons` or add a [go mod replace](https://github.com/golang/go/wiki/Modules#when-should-i-use-the-replace-directive) to your `go.mod` file, e.g. `replace github.com/flosch/pongo2-addons => github.com/iris-contrib/pongo2-addons v0.0.1`.\r\n\r\n## Fixes\r\n\r\nAll known issues.\r\n\r\n1. [#1395](https://github.com/kataras/iris/issues/1395) \r\n2. [#1369](https://github.com/kataras/iris/issues/1369)\r\n3. [#1399](https://github.com/kataras/iris/issues/1399) with PR [#1400](https://github.com/kataras/iris/pull/1400)\r\n4. [#1401](https://github.com/kataras/iris/issues/1401) \r\n5. [#1406](https://github.com/kataras/iris/issues/1406)\r\n6. [neffos/#20](https://github.com/kataras/neffos/issues/20)\r\n7. [pio/#5](https://github.com/kataras/pio/issues/5)\r\n\r\n## New Features\r\n\r\n### Internationalization and localization\r\n\r\nSupport for i18n is now a **builtin feature** and is being respected across your entire application, per say [sitemap](https://github.com/kataras/iris/wiki/Sitemap) and [views](https://github.com/kataras/iris/blob/master/_examples/i18n/basic/main.go#L50).\r\n\r\nRefer to the wiki section: https://github.com/kataras/iris/wiki/Sitemap for details.\r\n\r\n### Sitemaps\r\n\r\nIris generates and serves one or more [sitemap.xml](https://www.sitemaps.org/protocol.html) for your static routes.\r\n\r\nNavigate through: https://github.com/kataras/iris/wiki/Sitemap for more.\r\n\r\n## New Examples\r\n\r\n2. [_examples/i18n](_examples/i18n)\r\n1. [_examples/sitemap](_examples/routing/sitemap)\r\n3. [_examples/desktop/blink](_examples/desktop/blink)\r\n4. [_examples/desktop/lorca](_examples/desktop/lorca)\r\n5. [_examples/desktop/webview](_examples/desktop/webview)\r\n\r\n# Sa, 26 October 2019 | v12.0.0\r\n\r\n- Add version suffix of the **import path**, learn why and see what people voted at [issue #1370](https://github.com/kataras/iris/issues/1370)\r\n\r\n![](https://iris-go.com/images/vote-v12-version-suffix_26_oct_2019.png)\r\n\r\n- All errors are now compatible with go1.13 `errors.Is`, `errors.As` and `fmt.Errorf` and a new `core/errgroup` package created\r\n- Fix [#1383](https://github.com/kataras/iris/issues/1383)\r\n- Report whether system couldn't find the directory of view templates\r\n- Remove the `Party#GetReport` method, keep `Party#GetReporter` which is an `error` and an `errgroup.Group`.\r\n- Remove the router's deprecated methods such as StaticWeb and StaticEmbedded_XXX\r\n- The `Context#CheckIfModifiedSince` now returns an `context.ErrPreconditionFailed` type of error when client conditions are not met. Usage: `if errors.Is(err, context.ErrPreconditionFailed) { ... }`\r\n- Add `SourceFileName` and `SourceLineNumber` to the `Route`, reports the exact position of its registration inside your project's source code.\r\n- Fix a bug about the MVC package route binding, see [PR #1364](https://github.com/kataras/iris/pull/1364)\r\n- Add `mvc/Application#SortByNumMethods` as requested at [#1343](https://github.com/kataras/iris/issues/1343#issuecomment-524868164)\r\n- Add status code `103 Early Hints`\r\n- Fix performance of session.UpdateExpiration on 200 thousands+ keys with new radix as reported at [issue #1328](https://github.com/kataras/iris/issues/1328)\r\n- New redis session database configuration field: `Driver: redis.Redigo()` or `redis.Radix()`, see [updated examples](_examples/sessions/database/redis/)\r\n- Add Clusters support for redis:radix session database (`Driver: redis:Radix()`) as requested at [issue #1339](https://github.com/kataras/iris/issues/1339)\r\n- Create Iranian [README_FA](README_FA.md) translation with [PR #1360](https://github.com/kataras/iris/pull/1360) \r\n- Create Korean [README_KO](README_KO.md) translation with [PR #1356](https://github.com/kataras/iris/pull/1356)\r\n- Create Spanish [README_ES](README_ES.md) and [HISTORY_ES](HISTORY_ES.md) translations with [PR #1344](https://github.com/kataras/iris/pull/1344).\r\n\r\nThe iris-contrib/middleare and examples are updated to use the new `github.com/kataras/iris/v12` import path.\r\n\r\n# Fr, 16 August 2019 | v11.2.8\r\n\r\n- Set `Cookie.SameSite` to `Lax` when subdomains sessions share is enabled[*](https://github.com/kataras/iris/commit/6bbdd3db9139f9038641ce6f00f7b4bab6e62550)\r\n- Add and update all [experimental handlers](https://github.com/iris-contrib/middleware) \r\n- New `XMLMap` function which wraps a `map[string]interface{}` and converts it to a valid xml content to render through `Context.XML` method\r\n- Add new `ProblemOptions.XML` and `RenderXML` fields to render the `Problem` as XML(application/problem+xml) instead of JSON(\"application/problem+json) and enrich the `Negotiate` to easily accept the `application/problem+xml` mime.\r\n\r\nCommit log: https://github.com/kataras/iris/compare/v11.2.7...v11.2.8\r\n\r\n# Th, 15 August 2019 | v11.2.7\r\n\r\nThis minor version contains improvements on the Problem Details for HTTP APIs implemented on [v11.2.5](#mo-12-august-2019--v1125).\r\n\r\n- Fix https://github.com/kataras/iris/issues/1335#issuecomment-521319721\r\n- Add `ProblemOptions` with `RetryAfter` as requested at: https://github.com/kataras/iris/issues/1335#issuecomment-521330994.\r\n- Add `iris.JSON` alias for `context#JSON` options type.\r\n\r\n[Example](https://github.com/kataras/iris/blob/45d7c6fedb5adaef22b9730592255f7bb375e809/_examples/routing/http-errors/main.go#L85) and [wikis](https://github.com/kataras/iris/wiki/Routing-error-handlers#the-problem-type) updated. \r\n\r\nReferences:\r\n\r\n- https://tools.ietf.org/html/rfc7231#section-7.1.3\r\n- https://tools.ietf.org/html/rfc7807\r\n\r\nCommit log: https://github.com/kataras/iris/compare/v11.2.6...v11.2.7\r\n\r\n# We, 14 August 2019 | v11.2.6\r\n\r\nAllow [handle more than one route with the same paths and parameter types but different macro validation functions](https://github.com/kataras/iris/issues/1058#issuecomment-521110639).\r\n\r\n```go\r\napp.Get(\"/{alias:string regexp(^[a-z0-9]{1,10}\\\\.xml$)}\", PanoXML)\r\napp.Get(\"/{alias:string regexp(^[a-z0-9]{1,10}$)}\", Tour)\r\n```\r\n\r\nCommit log: https://github.com/kataras/iris/compare/v11.2.5...v11.2.6\r\n\r\n# Mo, 12 August 2019 | v11.2.5\r\n\r\n- [New Feature: Problem Details for HTTP APIs](https://github.com/kataras/iris/pull/1336)\r\n- [Add Context.AbsoluteURI](https://github.com/kataras/iris/pull/1336/files#diff-15cce7299aae8810bcab9b0bf9a2fdb1R2368)\r\n\r\nCommit log: https://github.com/kataras/iris/compare/v11.2.4...v11.2.5\r\n\r\n# Fr, 09 August 2019 | v11.2.4\r\n\r\n- Fixes [iris.Jet: no view engine found for '.jet' or '.html'](https://github.com/kataras/iris/issues/1327)\r\n- Fixes [ctx.ViewData not work with JetEngine](https://github.com/kataras/iris/issues/1330)\r\n- **New Feature**: [HTTP Method Override](https://github.com/kataras/iris/issues/1325)\r\n- Fixes [Poor performance of session.UpdateExpiration on 200 thousands+ keys with new radix lib](https://github.com/kataras/iris/issues/1328) by introducing the `sessions.Config.Driver` configuration field which defaults to `Redigo()` but can be set to `Radix()` too, future additions are welcomed.\r\n\r\nCommit log: https://github.com/kataras/iris/compare/v11.2.3...v11.2.4\r\n\r\n# Tu, 30 July 2019 | v11.2.3\r\n\r\n- [New Feature: Handle different parameter types in the same path](https://github.com/kataras/iris/issues/1315)\r\n- [New Feature: Content Negotiation](https://github.com/kataras/iris/issues/1319)\r\n- [Context.ReadYAML](https://github.com/kataras/iris/tree/master/_examples/request-body/read-yaml)\r\n- Fixes https://github.com/kataras/neffos/issues/1#issuecomment-515698536\r\n\r\n# We, 24 July 2019 | v11.2.2\r\n\r\nSessions as middleware:\r\n\r\n```go\r\nimport \"github.com/kataras/iris/v12/sessions\"\r\n// [...]\r\n\r\napp := iris.New()\r\nsess := sessions.New(sessions.Config{...})\r\n\r\napp.Get(\"/path\", func(ctx iris.Context){\r\n    session := sessions.Get(ctx)\r\n    // [work with session...]\r\n})\r\n```\r\n\r\n- Add `Session.Len() int` to return the total number of stored values/entries.\r\n- Make `Context.HTML` and `Context.Text` to accept an optional, variadic, `args ...interface{}` input arg(s) too.\r\n\r\n## v11.1.1\r\n\r\n- https://github.com/kataras/iris/issues/1298\r\n- https://github.com/kataras/iris/issues/1207\r\n\r\n# Tu, 23 July 2019 | v11.2.0\r\n\r\nRead about the new release at: https://www.facebook.com/iris.framework/posts/3276606095684693\r\n", "package context\n\nimport (\n\t\"bytes\"\n\tstdContext \"context\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/kataras/iris/v12/core/memstore\"\n\t\"github.com/kataras/iris/v12/core/netutil\"\n\n\t\"github.com/Shopify/goreferrer\"\n\t\"github.com/fatih/structs\"\n\t\"github.com/iris-contrib/schema\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"github.com/kataras/golog\"\n\t\"github.com/mailru/easyjson\"\n\t\"github.com/mailru/easyjson/jwriter\"\n\t\"github.com/microcosm-cc/bluemonday\"\n\t\"github.com/russross/blackfriday/v2\"\n\t\"github.com/vmihailenco/msgpack/v5\"\n\t\"golang.org/x/net/publicsuffix\"\n\t\"golang.org/x/time/rate\"\n\t\"google.golang.org/protobuf/encoding/protojson\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"gopkg.in/yaml.v3\"\n)\n\ntype (\n\t// BodyDecoder is an interface which any struct can implement in order to customize the decode action\n\t// from ReadJSON and ReadXML\n\t//\n\t// Trivial example of this could be:\n\t// type User struct { Username string }\n\t//\n\t// func (u *User) Decode(data []byte) error {\n\t//\t  return json.Unmarshal(data, u)\n\t// }\n\t//\n\t// the 'Context.ReadJSON/ReadXML(&User{})' will call the User's\n\t// Decode option to decode the request body\n\t//\n\t// Note: This is totally optionally, the default decoders\n\t// for ReadJSON is the encoding/json and for ReadXML is the encoding/xml.\n\t//\n\t// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-custom-per-type/main.go\n\tBodyDecoder interface {\n\t\tDecode(data []byte) error\n\t}\n\n\t// Unmarshaler is the interface implemented by types that can unmarshal any raw data.\n\t// TIP INFO: Any pointer to a value which implements the BodyDecoder can be override the unmarshaler.\n\tUnmarshaler interface {\n\t\tUnmarshal(data []byte, outPtr interface{}) error\n\t}\n\n\t// UnmarshalerFunc a shortcut for the Unmarshaler interface\n\t//\n\t// See 'Unmarshaler' and 'BodyDecoder' for more.\n\t//\n\t// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-custom-via-unmarshaler/main.go\n\tUnmarshalerFunc func(data []byte, outPtr interface{}) error\n\n\t// DecodeFunc is a generic type of decoder function.\n\t// When the returned error is not nil the decode operation\n\t// is terminated and the error is received by the ReadJSONStream method,\n\t// otherwise it continues to read the next available object.\n\t// Look the `Context.ReadJSONStream` method.\n\tDecodeFunc func(outPtr interface{}) error\n)\n\n// Unmarshal parses the X-encoded data and stores the result in the value pointed to by v.\n// Unmarshal uses the inverse of the encodings that Marshal uses, allocating maps,\n// slices, and pointers as necessary.\nfunc (u UnmarshalerFunc) Unmarshal(data []byte, v interface{}) error {\n\treturn u(data, v)\n}\n\n// LimitRequestBodySize is a middleware which sets a request body size limit\n// for all next handlers in the chain.\nvar LimitRequestBodySize = func(maxRequestBodySizeBytes int64) Handler {\n\treturn func(ctx *Context) {\n\t\tctx.SetMaxRequestBodySize(maxRequestBodySizeBytes)\n\t\tctx.Next()\n\t}\n}\n\n// Map is just a type alias of the map[string]interface{} type.\ntype Map = map[string]interface{}\n\n// Context is the midle-man server's \"object\" dealing with incoming requests.\n//\n// A New context is being acquired from a sync.Pool on each connection.\n// The Context is the most important thing on the iris's http flow.\n//\n// Developers send responses to the client's request through a Context.\n// Developers get request information from the client's request a Context.\ntype Context struct {\n\t// the http.ResponseWriter wrapped by custom writer.\n\twriter ResponseWriter\n\t// the original http.Request\n\trequest *http.Request\n\t// the current route registered to this request path.\n\tcurrentRoute RouteReadOnly\n\n\t// the local key-value storage\n\tparams RequestParams  // url named parameters.\n\tvalues memstore.Store // generic storage, middleware communication.\n\tquery  url.Values     // GET url query temp cache, useful on many URLParamXXX calls.\n\t// the underline application app.\n\tapp Application\n\t// the route's handlers\n\thandlers Handlers\n\t// the current position of the handler's chain\n\tcurrentHandlerIndex int\n\t// proceeded reports whether `Proceed` method\n\t// called before a `Next`. It is a flash field and it is set\n\t// to true on `Next` call when its called on the last handler in the chain.\n\t// Reports whether a `Next` is called,\n\t// even if the handler index remains the same (last handler).\n\t//\n\t// Also it's responsible to keep the old value of the last known handler index\n\t// before StopExecution. See ResumeExecution.\n\tproceeded int\n}\n\n// NewContext returns a new Context instance.\nfunc NewContext(app Application) *Context {\n\treturn &Context{app: app}\n}\n\n/* Not required, unless requested.\n// SetApplication sets an Iris Application on-fly.\n// Do NOT use it after ServeHTTPC is fired.\nfunc (ctx *Context) SetApplication(app Application) {\n\tctx.app = app\n}\n*/\n\n// Clone returns a copy of the context that\n// can be safely used outside the request's scope.\n// Note that if the request-response lifecycle terminated\n// or request canceled by the client (can be checked by `ctx.IsCanceled()`)\n// then the response writer is totally useless.\n// The http.Request pointer value is shared.\nfunc (ctx *Context) Clone() *Context {\n\tvaluesCopy := make(memstore.Store, len(ctx.values))\n\tcopy(valuesCopy, ctx.values)\n\n\tparamsCopy := make(memstore.Store, len(ctx.params.Store))\n\tcopy(paramsCopy, ctx.params.Store)\n\n\tqueryCopy := make(url.Values, len(ctx.query))\n\tfor k, v := range ctx.query {\n\t\tqueryCopy[k] = v\n\t}\n\n\treq := ctx.request.Clone(ctx.request.Context())\n\treturn &Context{\n\t\tapp:                 ctx.app,\n\t\tvalues:              valuesCopy,\n\t\tparams:              RequestParams{Store: paramsCopy},\n\t\tquery:               queryCopy,\n\t\twriter:              ctx.writer.Clone(),\n\t\trequest:             req,\n\t\tcurrentHandlerIndex: stopExecutionIndex,\n\t\tproceeded:           ctx.proceeded,\n\t\tcurrentRoute:        ctx.currentRoute,\n\t}\n}\n\n// BeginRequest is executing once for each request\n// it should prepare the (new or acquired from pool) context's fields for the new request.\n// Do NOT call it manually. Framework calls it automatically.\n//\n// Resets\n// 1. handlers to nil.\n// 2. values to empty.\n// 3. the defer function.\n// 4. response writer to the http.ResponseWriter.\n// 5. request to the *http.Request.\nfunc (ctx *Context) BeginRequest(w http.ResponseWriter, r *http.Request) {\n\tctx.currentRoute = nil\n\tctx.handlers = nil           // will be filled by router.Serve/HTTP\n\tctx.values = ctx.values[0:0] // >>      >>     by context.Values().Set\n\tctx.params.Store = ctx.params.Store[0:0]\n\tctx.query = nil\n\tctx.request = r\n\tctx.currentHandlerIndex = 0\n\tctx.proceeded = 0\n\tctx.writer = AcquireResponseWriter()\n\tctx.writer.BeginResponse(w)\n}\n\n// EndRequest is executing once after a response to the request was sent and this context is useless or released.\n// Do NOT call it manually. Framework calls it automatically.\n//\n// 1. executes the OnClose function (if any).\n// 2. flushes the response writer's result or fire any error handler.\n// 3. releases the response writer.\nfunc (ctx *Context) EndRequest() {\n\tif !ctx.app.ConfigurationReadOnly().GetDisableAutoFireStatusCode() &&\n\t\tStatusCodeNotSuccessful(ctx.GetStatusCode()) {\n\t\tctx.app.FireErrorCode(ctx)\n\t}\n\n\tctx.writer.FlushResponse()\n\tctx.writer.EndResponse()\n}\n\n// IsCanceled reports whether the client canceled the request\n// or the underlying connection has gone.\n// Note that it will always return true\n// when called from a goroutine after the request-response lifecycle.\nfunc (ctx *Context) IsCanceled() bool {\n\tvar err error\n\tif reqCtx := ctx.request.Context(); reqCtx != nil {\n\t\terr = reqCtx.Err()\n\t} else {\n\t\terr = ctx.GetErr()\n\t}\n\n\treturn IsErrCanceled(err)\n}\n\n// IsErrCanceled reports whether the \"err\" is caused by a cancellation or timeout.\nfunc IsErrCanceled(err error) bool {\n\tif err == nil {\n\t\treturn false\n\t}\n\n\tvar netErr net.Error\n\treturn (errors.As(err, &netErr) && netErr.Timeout()) ||\n\t\terrors.Is(err, stdContext.Canceled) ||\n\t\terrors.Is(err, stdContext.DeadlineExceeded) ||\n\t\terrors.Is(err, http.ErrHandlerTimeout) ||\n\t\terr.Error() == \"closed pool\"\n}\n\n// OnConnectionClose registers the \"cb\" Handler\n// which will be fired on its on goroutine on a cloned Context\n// when the underlying connection has gone away.\n//\n// The code inside the given callback is running on its own routine,\n// as explained above, therefore the callback should NOT\n// try to access to handler's Context response writer.\n//\n// This mechanism can be used to cancel long operations on the server\n// if the client has disconnected before the response is ready.\n//\n// It depends on the Request's Context.Done() channel.\n//\n// Finally, it reports whether the protocol supports pipelines (HTTP/1.1 with pipelines disabled is not supported).\n// The \"cb\" will not fire for sure if the output value is false.\n//\n// Note that you can register only one callback per route.\n//\n// See `OnClose` too.\nfunc (ctx *Context) OnConnectionClose(cb Handler) bool {\n\tif cb == nil {\n\t\treturn false\n\t}\n\n\treqCtx := ctx.Request().Context()\n\tif reqCtx == nil {\n\t\treturn false\n\t}\n\n\tnotifyClose := reqCtx.Done()\n\tif notifyClose == nil {\n\t\treturn false\n\t}\n\n\tgo func() {\n\t\t<-notifyClose\n\t\t// Note(@kataras): No need to clone if not canceled,\n\t\t// EndRequest will be called on the end of the handler chain,\n\t\t// no matter the cancelation.\n\t\t// therefore the context will still be there.\n\t\tcb(ctx.Clone())\n\t}()\n\n\treturn true\n}\n\n// OnConnectionCloseErr same as `OnConnectionClose` but instead it\n// receives a function which returns an error.\n// If error is not nil, it will be logged as a debug message.\nfunc (ctx *Context) OnConnectionCloseErr(cb func() error) bool {\n\tif cb == nil {\n\t\treturn false\n\t}\n\n\treqCtx := ctx.Request().Context()\n\tif reqCtx == nil {\n\t\treturn false\n\t}\n\n\tnotifyClose := reqCtx.Done()\n\tif notifyClose == nil {\n\t\treturn false\n\t}\n\n\tgo func() {\n\t\t<-notifyClose\n\t\tif err := cb(); err != nil {\n\t\t\t// Can be ignored.\n\t\t\tctx.app.Logger().Debugf(\"OnConnectionCloseErr: received error: %v\", err)\n\t\t}\n\t}()\n\n\treturn true\n}\n\n// OnClose registers a callback which\n// will be fired when the underlying connection has gone away(request canceled)\n// on its own goroutine or in the end of the request-response lifecylce\n// on the handler's routine itself (Context access).\n//\n// See `OnConnectionClose` too.\nfunc (ctx *Context) OnClose(cb Handler) {\n\tif cb == nil {\n\t\treturn\n\t}\n\n\t// Note(@kataras):\n\t// - on normal request-response lifecycle\n\t// the `SetBeforeFlush` will be called first\n\t// and then `OnConnectionClose`,\n\t// - when request was canceled before handler finish its job\n\t// then the `OnConnectionClose` will be called first instead,\n\t// and when the handler function completed then `SetBeforeFlush` is fired.\n\t// These are synchronized, they cannot be executed the same exact time,\n\t// below we just make sure the \"cb\" is executed once\n\t// by simple boolean check or an atomic one.\n\tvar executed uint32\n\n\tcallback := func(ctx *Context) {\n\t\tif atomic.CompareAndSwapUint32(&executed, 0, 1) {\n\t\t\tcb(ctx)\n\t\t}\n\t}\n\n\tctx.OnConnectionClose(callback)\n\n\tonFlush := func() {\n\t\tcallback(ctx)\n\t}\n\n\tctx.writer.SetBeforeFlush(onFlush)\n}\n\n// OnCloseErr same as `OnClose` but instead it\n// receives a function which returns an error.\n// If error is not nil, it will be logged as a debug message.\nfunc (ctx *Context) OnCloseErr(cb func() error) {\n\tif cb == nil {\n\t\treturn\n\t}\n\n\tvar executed uint32\n\n\tcallback := func() error {\n\t\tif atomic.CompareAndSwapUint32(&executed, 0, 1) {\n\t\t\treturn cb()\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tctx.OnConnectionCloseErr(callback)\n\n\tonFlush := func() {\n\t\tif err := callback(); err != nil {\n\t\t\t// Can be ignored.\n\t\t\tctx.app.Logger().Debugf(\"OnClose: SetBeforeFlush: received error: %v\", err)\n\t\t}\n\t}\n\n\tctx.writer.SetBeforeFlush(onFlush)\n}\n\n/* Note(@kataras): just leave end-developer decide.\nconst goroutinesContextKey = \"iris.goroutines\"\n\ntype goroutines struct {\n\twg     *sync.WaitGroup\n\tlength int\n\tmu     sync.RWMutex\n}\n\nvar acquireGoroutines = func() interface{} {\n\treturn &goroutines{wg: new(sync.WaitGroup)}\n}\n\nfunc (ctx *Context) Go(fn func(cancelCtx stdContext.Context)) (running int) {\n\tg := ctx.values.GetOrSet(goroutinesContextKey, acquireGoroutines).(*goroutines)\n\tif fn != nil {\n\t\tg.wg.Add(1)\n\n\t\tg.mu.Lock()\n\t\tg.length++\n\t\tg.mu.Unlock()\n\n\t\tctx.waitFunc = g.wg.Wait\n\n\t\tgo func(reqCtx stdContext.Context) {\n\t\t\tfn(reqCtx)\n\t\t\tg.wg.Done()\n\n\t\t\tg.mu.Lock()\n\t\t\tg.length--\n\t\t\tg.mu.Unlock()\n\t\t}(ctx.request.Context())\n\t}\n\n\tg.mu.RLock()\n\trunning = g.length\n\tg.mu.RUnlock()\n\treturn\n}\n*/\n\n// ResponseWriter returns an http.ResponseWriter compatible response writer, as expected.\nfunc (ctx *Context) ResponseWriter() ResponseWriter {\n\treturn ctx.writer\n}\n\n// ResetResponseWriter sets a new ResponseWriter implementation\n// to this Context to use as its writer.\n// Note, to change the underline http.ResponseWriter use\n// ctx.ResponseWriter().SetWriter(http.ResponseWriter) instead.\nfunc (ctx *Context) ResetResponseWriter(newResponseWriter ResponseWriter) {\n\tif rec, ok := ctx.IsRecording(); ok {\n\t\treleaseResponseRecorder(rec)\n\t}\n\n\tctx.writer = newResponseWriter\n}\n\n// Request returns the original *http.Request, as expected.\nfunc (ctx *Context) Request() *http.Request {\n\treturn ctx.request\n}\n\n// ResetRequest sets the Context's Request,\n// It is useful to store the new request created by a std *http.Request#WithContext() into Iris' Context.\n// Use `ResetRequest` when for some reason you want to make a full\n// override of the *http.Request.\n// Note that: when you just want to change one of each fields you can use the Request() which returns a pointer to Request,\n// so the changes will have affect without a full override.\n// Usage: you use a native http handler which uses the standard \"context\" package\n// to get values instead of the Iris' Context#Values():\n// r := ctx.Request()\n// stdCtx := context.WithValue(r.Context(), key, val)\n// ctx.ResetRequest(r.WithContext(stdCtx)).\nfunc (ctx *Context) ResetRequest(r *http.Request) {\n\tctx.request = r\n}\n\n// SetCurrentRoute sets the route internally,\n// See `GetCurrentRoute()` method too.\n// It's being initialized by the Router.\n// See `Exec` or `SetHandlers/AddHandler` methods to simulate a request.\nfunc (ctx *Context) SetCurrentRoute(route RouteReadOnly) {\n\tctx.currentRoute = route\n}\n\n// GetCurrentRoute returns the current \"read-only\" route that\n// was registered to this request's path.\nfunc (ctx *Context) GetCurrentRoute() RouteReadOnly {\n\treturn ctx.currentRoute\n}\n\n// Do sets the \"handlers\" as the chain\n// and executes the first handler,\n// handlers should not be empty.\n//\n// It's used by the router, developers may use that\n// to replace and execute handlers immediately.\nfunc (ctx *Context) Do(handlers Handlers) {\n\tif len(handlers) == 0 {\n\t\treturn\n\t}\n\n\tctx.handlers = handlers\n\thandlers[0](ctx)\n}\n\n// AddHandler can add handler(s)\n// to the current request in serve-time,\n// these handlers are not persistenced to the router.\n//\n// Router is calling this function to add the route's handler.\n// If AddHandler called then the handlers will be inserted\n// to the end of the already-defined route's handler.\n//\nfunc (ctx *Context) AddHandler(handlers ...Handler) {\n\tctx.handlers = append(ctx.handlers, handlers...)\n}\n\n// SetHandlers replaces all handlers with the new.\nfunc (ctx *Context) SetHandlers(handlers Handlers) {\n\tctx.handlers = handlers\n}\n\n// Handlers keeps tracking of the current handlers.\nfunc (ctx *Context) Handlers() Handlers {\n\treturn ctx.handlers\n}\n\n// HandlerIndex sets the current index of the\n// current context's handlers chain.\n// If n < 0 or the current handlers length is 0 then it just returns the\n// current handler index without change the current index.\n//\n// Look Handlers(), Next() and StopExecution() too.\nfunc (ctx *Context) HandlerIndex(n int) (currentIndex int) {\n\tif n < 0 || n > len(ctx.handlers)-1 {\n\t\treturn ctx.currentHandlerIndex\n\t}\n\n\tctx.currentHandlerIndex = n\n\treturn n\n}\n\n// Proceed is an alternative way to check if a particular handler\n// has been executed.\n// The given \"h\" Handler can report a failure with `StopXXX` methods\n// or ignore calling a `Next` (see `iris.ExecutionRules` too).\n//\n// This is useful only when you run a handler inside\n// another handler. It justs checks for before index and the after index.\n//\n// A usecase example is when you want to execute a middleware\n// inside controller's `BeginRequest` that calls the `ctx.Next` inside it.\n// The Controller looks the whole flow (BeginRequest, method handler, EndRequest)\n// as one handler, so `ctx.Next` will not be reflected to the method handler\n// if called from the `BeginRequest`.\n//\n// Although `BeginRequest` should NOT be used to call other handlers,\n// the `BeginRequest` has been introduced to be able to set\n// common data to all method handlers before their execution.\n// Controllers can accept middleware(s) from the MVC's Application's Router as normally.\n//\n// That said let's see an example of `ctx.Proceed`:\n//\n// var authMiddleware = basicauth.New(basicauth.Config{\n// \tUsers: map[string]string{\n// \t\t\"admin\": \"password\",\n// \t},\n// })\n//\n// func (c *UsersController) BeginRequest(ctx iris.Context) {\n// \tif !ctx.Proceed(authMiddleware) {\n// \t\tctx.StopExecution()\n// \t}\n// }\n// This Get() will be executed in the same handler as `BeginRequest`,\n// internally controller checks for `ctx.StopExecution`.\n// So it will not be fired if BeginRequest called the `StopExecution`.\n// func(c *UsersController) Get() []models.User {\n//\t  return c.Service.GetAll()\n//}\n// Alternative way is `!ctx.IsStopped()` if middleware make use of the `ctx.StopExecution()` on failure.\nfunc (ctx *Context) Proceed(h Handler) bool {\n\tctx.proceeded = internalPauseExecutionIndex\n\n\t// Store the current index.\n\tbeforeIdx := ctx.currentHandlerIndex\n\th(ctx)\n\t// Retrieve the next one, if Next is called this is beforeIdx + 1 and so on.\n\tafterIdx := ctx.currentHandlerIndex\n\t// Restore prev index, no matter what.\n\tctx.currentHandlerIndex = beforeIdx\n\n\tproceededByNext := ctx.proceeded == internalProceededHandlerIndex\n\tctx.proceeded = beforeIdx\n\n\t// Stop called, return false but keep the handlers index.\n\tif afterIdx == stopExecutionIndex {\n\t\treturn false\n\t}\n\n\tif proceededByNext {\n\t\treturn true\n\t}\n\n\t// Next called or not.\n\treturn afterIdx > beforeIdx\n}\n\n// HandlerName returns the current handler's name, helpful for debugging.\nfunc (ctx *Context) HandlerName() string {\n\treturn HandlerName(ctx.handlers[ctx.currentHandlerIndex])\n}\n\n// HandlerFileLine returns the current running handler's function source file and line information.\n// Useful mostly when debugging.\nfunc (ctx *Context) HandlerFileLine() (file string, line int) {\n\treturn HandlerFileLine(ctx.handlers[ctx.currentHandlerIndex])\n}\n\n// RouteName returns the route name that this handler is running on.\n// Note that it may return empty on not found handlers.\nfunc (ctx *Context) RouteName() string {\n\tif ctx.currentRoute == nil {\n\t\treturn \"\"\n\t}\n\n\treturn ctx.currentRoute.Name()\n}\n\n// Next calls the next handler from the handlers chain,\n// it should be used inside a middleware.\nfunc (ctx *Context) Next() {\n\tif ctx.IsStopped() {\n\t\treturn\n\t}\n\n\tif ctx.proceeded <= internalPauseExecutionIndex /* pause and proceeded */ {\n\t\tctx.proceeded = internalProceededHandlerIndex\n\t\treturn\n\t}\n\n\tnextIndex, n := ctx.currentHandlerIndex+1, len(ctx.handlers)\n\tif nextIndex < n {\n\t\tctx.currentHandlerIndex = nextIndex\n\t\tctx.handlers[nextIndex](ctx)\n\t}\n}\n\n// NextOr checks if chain has a next handler, if so then it executes it\n// otherwise it sets a new chain assigned to this Context based on the given handler(s)\n// and executes its first handler.\n//\n// Returns true if next handler exists and executed, otherwise false.\n//\n// Note that if no next handler found and handlers are missing then\n// it sends a Status Not Found (404) to the client and it stops the execution.\nfunc (ctx *Context) NextOr(handlers ...Handler) bool {\n\tif next := ctx.NextHandler(); next != nil {\n\t\tctx.Skip() // skip this handler from the chain.\n\t\tnext(ctx)\n\t\treturn true\n\t}\n\n\tif len(handlers) == 0 {\n\t\tctx.NotFound()\n\t\tctx.StopExecution()\n\t\treturn false\n\t}\n\n\tctx.Do(handlers)\n\n\treturn false\n}\n\n// NextOrNotFound checks if chain has a next handler, if so then it executes it\n// otherwise it sends a Status Not Found (404) to the client and stops the execution.\n//\n// Returns true if next handler exists and executed, otherwise false.\nfunc (ctx *Context) NextOrNotFound() bool { return ctx.NextOr() }\n\n// NextHandler returns (it doesn't execute) the next handler from the handlers chain.\n//\n// Use .Skip() to skip this handler if needed to execute the next of this returning handler.\nfunc (ctx *Context) NextHandler() Handler {\n\tif ctx.IsStopped() {\n\t\treturn nil\n\t}\n\tnextIndex := ctx.currentHandlerIndex + 1\n\t// check if it has a next middleware\n\tif nextIndex < len(ctx.handlers) {\n\t\treturn ctx.handlers[nextIndex]\n\t}\n\treturn nil\n}\n\n// Skip skips/ignores the next handler from the handlers chain,\n// it should be used inside a middleware.\nfunc (ctx *Context) Skip() {\n\tctx.HandlerIndex(ctx.currentHandlerIndex + 1)\n}\n\nconst (\n\tstopExecutionIndex            = -1\n\tinternalPauseExecutionIndex   = -2\n\tinternalProceededHandlerIndex = -3\n)\n\n// StopExecution stops the handlers chain of this request.\n// Meaning that any following `Next` calls are ignored,\n// as a result the next handlers in the chain will not be fire.\n//\n// See ResumeExecution too.\nfunc (ctx *Context) StopExecution() {\n\tif curIdx := ctx.currentHandlerIndex; curIdx != stopExecutionIndex {\n\t\t// Protect against multiple calls of StopExecution.\n\t\t// Resume should set the last proceeded handler index.\n\t\t// Store the current index.\n\t\tctx.proceeded = curIdx\n\t\t// And stop.\n\t\tctx.currentHandlerIndex = stopExecutionIndex\n\t}\n}\n\n// IsStopped reports whether the current position of the context's handlers is -1,\n// means that the StopExecution() was called at least once.\nfunc (ctx *Context) IsStopped() bool {\n\treturn ctx.currentHandlerIndex == stopExecutionIndex\n}\n\n// ResumeExecution sets the current handler index to the last\n// index of the executed handler before StopExecution method was fired.\n//\n// Reports whether it's restored after a StopExecution call.\nfunc (ctx *Context) ResumeExecution() bool {\n\tif ctx.IsStopped() {\n\t\tctx.currentHandlerIndex = ctx.proceeded\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// StopWithStatus stops the handlers chain and writes the \"statusCode\".\n//\n// If the status code is a failure one then\n// it will also fire the specified error code handler.\nfunc (ctx *Context) StopWithStatus(statusCode int) {\n\tctx.StopExecution()\n\tctx.StatusCode(statusCode)\n}\n\n// StopWithText stops the handlers chain and writes the \"statusCode\"\n// among with a fmt-style text of \"format\" and optional arguments.\n//\n// If the status code is a failure one then\n// it will also fire the specified error code handler.\nfunc (ctx *Context) StopWithText(statusCode int, format string, args ...interface{}) {\n\tctx.StopWithStatus(statusCode)\n\tctx.WriteString(fmt.Sprintf(format, args...))\n}\n\n// StopWithError stops the handlers chain and writes the \"statusCode\"\n// among with the error \"err\".\n// It Calls the `SetErr` method so error handlers can access the given error.\n//\n// If the status code is a failure one then\n// it will also fire the specified error code handler.\n//\n// If the given \"err\" is private then the\n// status code's text is rendered instead (unless a registered error handler overrides it).\nfunc (ctx *Context) StopWithError(statusCode int, err error) {\n\tif err == nil {\n\t\treturn\n\t}\n\n\tctx.SetErr(err)\n\tif _, ok := err.(ErrPrivate); ok {\n\t\t// error is private, we SHOULD not render it,\n\t\t// leave the error handler alone to\n\t\t// render the code's text instead.\n\t\tctx.StopWithStatus(statusCode)\n\t\treturn\n\t}\n\n\tctx.StopWithText(statusCode, err.Error())\n}\n\n// StopWithPlainError like `StopWithError` but it does NOT\n// write anything to the response writer, it stores the error\n// so any error handler matching the given \"statusCode\" can handle it by its own.\nfunc (ctx *Context) StopWithPlainError(statusCode int, err error) {\n\tif err == nil {\n\t\treturn\n\t}\n\n\tctx.SetErr(err)\n\tctx.StopWithStatus(statusCode)\n}\n\n// StopWithJSON stops the handlers chain, writes the status code\n// and sends a JSON response.\n//\n// If the status code is a failure one then\n// it will also fire the specified error code handler.\nfunc (ctx *Context) StopWithJSON(statusCode int, jsonObject interface{}) {\n\tctx.StopWithStatus(statusCode)\n\tctx.JSON(jsonObject)\n}\n\n// StopWithProblem stops the handlers chain, writes the status code\n// and sends an application/problem+json response.\n// See `iris.NewProblem` to build a \"problem\" value correctly.\n//\n// If the status code is a failure one then\n// it will also fire the specified error code handler.\nfunc (ctx *Context) StopWithProblem(statusCode int, problem Problem) {\n\tctx.StopWithStatus(statusCode)\n\tproblem.Status(statusCode)\n\tctx.Problem(problem)\n}\n\n//  +------------------------------------------------------------+\n//  | Current \"user/request\" storage                             |\n//  | and share information between the handlers - Values().     |\n//  | Save and get named path parameters - Params()              |\n//  +------------------------------------------------------------+\n\n// Params returns the current url's named parameters key-value storage.\n// Named path parameters are being saved here.\n// This storage, as the whole context, is per-request lifetime.\nfunc (ctx *Context) Params() *RequestParams {\n\treturn &ctx.params\n}\n\n// Values returns the current \"user\" storage.\n// Named path parameters and any optional data can be saved here.\n// This storage, as the whole context, is per-request lifetime.\n//\n// You can use this function to Set and Get local values\n// that can be used to share information between handlers and middleware.\nfunc (ctx *Context) Values() *memstore.Store {\n\treturn &ctx.values\n}\n\n//  +------------------------------------------------------------+\n//  | Path, Host, Subdomain, IP, Headers etc...                  |\n//  +------------------------------------------------------------+\n\n// Method returns the request.Method, the client's http method to the server.\nfunc (ctx *Context) Method() string {\n\treturn ctx.request.Method\n}\n\n// Path returns the full request path,\n// escaped if EnablePathEscape config field is true.\nfunc (ctx *Context) Path() string {\n\treturn ctx.RequestPath(ctx.app.ConfigurationReadOnly().GetEnablePathEscape())\n}\n\n// DecodeQuery returns the uri parameter as url (string)\n// useful when you want to pass something to a database and be valid to retrieve it via context.Param\n// use it only for special cases, when the default behavior doesn't suits you.\n//\n// http://www.blooberry.com/indexdot/html/topics/urlencoding.htm\n// it uses just the url.QueryUnescape\nfunc DecodeQuery(path string) string {\n\tif path == \"\" {\n\t\treturn \"\"\n\t}\n\tencodedPath, err := url.QueryUnescape(path)\n\tif err != nil {\n\t\treturn path\n\t}\n\treturn encodedPath\n}\n\n// DecodeURL returns the decoded uri\n// useful when you want to pass something to a database and be valid to retrieve it via context.Param\n// use it only for special cases, when the default behavior doesn't suits you.\n//\n// http://www.blooberry.com/indexdot/html/topics/urlencoding.htm\n// it uses just the url.Parse\nfunc DecodeURL(uri string) string {\n\tu, err := url.Parse(uri)\n\tif err != nil {\n\t\treturn uri\n\t}\n\treturn u.String()\n}\n\n// RequestPath returns the full request path,\n// based on the 'escape'.\nfunc (ctx *Context) RequestPath(escape bool) string {\n\tif escape {\n\t\treturn ctx.request.URL.EscapedPath() // DecodeQuery(ctx.request.URL.EscapedPath())\n\t}\n\n\treturn ctx.request.URL.Path // RawPath returns empty, requesturi can be used instead also.\n}\n\nconst sufscheme = \"://\"\n\n// GetScheme returns the full scheme of the request URL (https://, http:// or ws:// and e.t.c.``).\nfunc GetScheme(r *http.Request) string {\n\tscheme := r.URL.Scheme\n\n\tif scheme == \"\" {\n\t\tif r.TLS != nil {\n\t\t\tscheme = netutil.SchemeHTTPS\n\t\t} else {\n\t\t\tscheme = netutil.SchemeHTTP\n\t\t}\n\t}\n\n\treturn scheme + sufscheme\n}\n\n// Scheme returns the full scheme of the request (including :// suffix).\nfunc (ctx *Context) Scheme() string {\n\treturn GetScheme(ctx.Request())\n}\n\n// PathPrefixMap accepts a map of string and a handler.\n// The key of \"m\" is the key, which is the prefix, regular expressions are not valid.\n// The value of \"m\" is the handler that will be executed if HasPrefix(context.Path).\n// func (ctx *Context) PathPrefixMap(m map[string]context.Handler) bool {\n// \tpath := ctx.Path()\n// \tfor k, v := range m {\n// \t\tif strings.HasPrefix(path, k) {\n// \t\t\tv(ctx)\n// \t\t\treturn true\n// \t\t}\n// \t}\n// \treturn false\n// } no, it will not work because map is a random peek data structure.\n\n// GetHost returns the host part of the current URI.\nfunc GetHost(r *http.Request) string {\n\t// contains subdomain.\n\tif host := r.URL.Host; host != \"\" {\n\t\treturn host\n\t}\n\treturn r.Host\n}\n\n// Host returns the host:port part of the request URI, calls the `Request().Host`.\n// To get the subdomain part as well use the `Request().URL.Host` method instead.\n// To get the subdomain only use the `Subdomain` method instead.\n// This method makes use of the `Configuration.HostProxyHeaders` field too.\nfunc (ctx *Context) Host() string {\n\tfor header, ok := range ctx.app.ConfigurationReadOnly().GetHostProxyHeaders() {\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tif host := ctx.GetHeader(header); host != \"\" {\n\t\t\treturn host\n\t\t}\n\t}\n\n\treturn GetHost(ctx.request)\n}\n\n// GetDomain resolves and returns the server's domain.\nfunc GetDomain(hostport string) string {\n\thost := hostport\n\tif tmp, _, err := net.SplitHostPort(hostport); err == nil {\n\t\thost = tmp\n\t}\n\n\tswitch host {\n\t// We could use the netutil.LoopbackRegex but leave it as it's for now, it's faster.\n\tcase \"localhost\", \"127.0.0.1\", \"0.0.0.0\", \"::1\", \"[::1]\", \"0:0:0:0:0:0:0:0\", \"0:0:0:0:0:0:0:1\":\n\t\t// loopback.\n\t\treturn \"localhost\"\n\tdefault:\n\t\tif domain, err := publicsuffix.EffectiveTLDPlusOne(host); err == nil {\n\t\t\thost = domain\n\t\t}\n\n\t\treturn host\n\t}\n}\n\n// Domain returns the root level domain.\nfunc (ctx *Context) Domain() string {\n\treturn GetDomain(ctx.Host())\n}\n\n// GetSubdomainFull returns the full subdomain level, e.g.\n// [test.user.]mydomain.com.\nfunc GetSubdomainFull(r *http.Request) string {\n\thost := GetHost(r)            // host:port\n\trootDomain := GetDomain(host) // mydomain.com\n\trootDomainIdx := strings.Index(host, rootDomain)\n\tif rootDomainIdx == -1 {\n\t\treturn \"\"\n\t}\n\n\treturn host[0:rootDomainIdx]\n}\n\n// SubdomainFull returns the full subdomain level, e.g.\n// [test.user.]mydomain.com.\n// Note that HostProxyHeaders are being respected here.\nfunc (ctx *Context) SubdomainFull() string {\n\thost := ctx.Host()            // host:port\n\trootDomain := GetDomain(host) // mydomain.com\n\trootDomainIdx := strings.Index(host, rootDomain)\n\tif rootDomainIdx == -1 {\n\t\treturn \"\"\n\t}\n\n\treturn host[0:rootDomainIdx]\n}\n\n// Subdomain returns the first subdomain of this request,\n// e.g. [user.]mydomain.com.\n// See `SubdomainFull` too.\nfunc (ctx *Context) Subdomain() (subdomain string) {\n\thost := ctx.Host()\n\tif index := strings.IndexByte(host, '.'); index > 0 {\n\t\tsubdomain = host[0:index]\n\t}\n\n\t// listening on mydomain.com:80\n\t// subdomain = mydomain, but it's wrong, it should return \"\"\n\tvhost := ctx.app.ConfigurationReadOnly().GetVHost()\n\tif strings.Contains(vhost, subdomain) { // then it's not subdomain\n\t\treturn \"\"\n\t}\n\n\treturn\n}\n\n// FindClosest returns a list of \"n\" paths close to\n// this request based on subdomain and request path.\n//\n// Order may change.\n// Example: https://github.com/kataras/iris/tree/master/_examples/routing/intelligence/manual\nfunc (ctx *Context) FindClosest(n int) []string {\n\treturn ctx.app.FindClosestPaths(ctx.Subdomain(), ctx.Path(), n)\n}\n\n// IsWWW returns true if the current subdomain (if any) is www.\nfunc (ctx *Context) IsWWW() bool {\n\thost := ctx.Host()\n\tif index := strings.IndexByte(host, '.'); index > 0 {\n\t\t// if it has a subdomain and it's www then return true.\n\t\tif subdomain := host[0:index]; !strings.Contains(ctx.app.ConfigurationReadOnly().GetVHost(), subdomain) {\n\t\t\treturn subdomain == \"www\"\n\t\t}\n\t}\n\treturn false\n}\n\n// FullRequestURI returns the full URI,\n// including the scheme, the host and the relative requested path/resource.\nfunc (ctx *Context) FullRequestURI() string {\n\treturn ctx.AbsoluteURI(ctx.Path())\n}\n\n// RemoteAddr tries to parse and return the real client's request IP.\n//\n// Based on allowed headers names that can be modified from Configuration.RemoteAddrHeaders.\n//\n// If parse based on these headers fail then it will return the Request's `RemoteAddr` field\n// which is filled by the server before the HTTP handler,\n// unless the Configuration.RemoteAddrHeadersForce was set to true\n// which will force this method to return the first IP from RemoteAddrHeaders\n// even if it's part of a private network.\n//\n// Look `Configuration.RemoteAddrHeaders`,\n//\t\t`Configuration.RemoteAddrHeadersForce`,\n//      `Configuration.WithRemoteAddrHeader(...)`,\n//      `Configuration.WithoutRemoteAddrHeader(...)` and\n//      `Configuration.RemoteAddrPrivateSubnets` for more.\nfunc (ctx *Context) RemoteAddr() string {\n\tif remoteHeaders := ctx.app.ConfigurationReadOnly().GetRemoteAddrHeaders(); len(remoteHeaders) > 0 {\n\t\tprivateSubnets := ctx.app.ConfigurationReadOnly().GetRemoteAddrPrivateSubnets()\n\n\t\tfor _, headerName := range remoteHeaders {\n\t\t\tipAddresses := strings.Split(ctx.GetHeader(headerName), \",\")\n\t\t\tif ip, ok := netutil.GetIPAddress(ipAddresses, privateSubnets); ok {\n\t\t\t\treturn ip\n\t\t\t}\n\t\t}\n\n\t\tif ctx.app.ConfigurationReadOnly().GetRemoteAddrHeadersForce() {\n\t\t\tfor _, headerName := range remoteHeaders {\n\t\t\t\t// return the first valid IP,\n\t\t\t\t//  even if it's a part of a private network.\n\t\t\t\tipAddresses := strings.Split(ctx.GetHeader(headerName), \",\")\n\t\t\t\tfor _, addr := range ipAddresses {\n\t\t\t\t\tif ip, _, err := net.SplitHostPort(addr); err == nil {\n\t\t\t\t\t\treturn ip\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\taddr := strings.TrimSpace(ctx.request.RemoteAddr)\n\tif addr != \"\" {\n\t\t// if addr has port use the net.SplitHostPort otherwise(error occurs) take as it is\n\t\tif ip, _, err := net.SplitHostPort(addr); err == nil {\n\t\t\treturn ip\n\t\t}\n\t}\n\n\treturn addr\n}\n\n// TrimHeaderValue returns the \"v[0:first space or semicolon]\".\nfunc TrimHeaderValue(v string) string {\n\tfor i, char := range v {\n\t\tif char == ' ' || char == ';' {\n\t\t\treturn v[:i]\n\t\t}\n\t}\n\treturn v\n}\n\n// GetHeader returns the request header's value based on its name.\nfunc (ctx *Context) GetHeader(name string) string {\n\treturn ctx.request.Header.Get(name)\n}\n\n// IsAjax returns true if this request is an 'ajax request'( XMLHttpRequest)\n//\n// There is no a 100% way of knowing that a request was made via Ajax.\n// You should never trust data coming from the client, they can be easily overcome by spoofing.\n//\n// Note that \"X-Requested-With\" Header can be modified by any client(because of \"X-\"),\n// so don't rely on IsAjax for really serious stuff,\n// try to find another way of detecting the type(i.e, content type),\n// there are many blogs that describe these problems and provide different kind of solutions,\n// it's always depending on the application you're building,\n// this is the reason why this `IsAjax`` is simple enough for general purpose use.\n//\n// Read more at: https://developer.mozilla.org/en-US/docs/AJAX\n// and https://xhr.spec.whatwg.org/\nfunc (ctx *Context) IsAjax() bool {\n\treturn ctx.GetHeader(\"X-Requested-With\") == \"XMLHttpRequest\"\n}\n\nvar isMobileRegex = regexp.MustCompile(\"(?:hpw|i|web)os|alamofire|alcatel|amoi|android|avantgo|blackberry|blazer|cell|cfnetwork|darwin|dolfin|dolphin|fennec|htc|ip(?:hone|od|ad)|ipaq|j2me|kindle|midp|minimo|mobi|motorola|nec-|netfront|nokia|opera m(ob|in)i|palm|phone|pocket|portable|psp|silk-accelerated|skyfire|sony|ucbrowser|up.browser|up.link|windows ce|xda|zte|zune\")\n\n// IsMobile checks if client is using a mobile device(phone or tablet) to communicate with this server.\n// If the return value is true that means that the http client using a mobile\n// device to communicate with the server, otherwise false.\n//\n// Keep note that this checks the \"User-Agent\" request header.\nfunc (ctx *Context) IsMobile() bool {\n\ts := strings.ToLower(ctx.GetHeader(\"User-Agent\"))\n\treturn isMobileRegex.MatchString(s)\n}\n\nvar isScriptRegex = regexp.MustCompile(\"curl|wget|collectd|python|urllib|java|jakarta|httpclient|phpcrawl|libwww|perl|go-http|okhttp|lua-resty|winhttp|awesomium\")\n\n// IsScript reports whether a client is a script.\nfunc (ctx *Context) IsScript() bool {\n\ts := strings.ToLower(ctx.GetHeader(\"User-Agent\"))\n\treturn isScriptRegex.MatchString(s)\n}\n\n// IsSSL reports whether the client is running under HTTPS SSL.\n//\n// See `IsHTTP2` too.\nfunc (ctx *Context) IsSSL() bool {\n\tssl := strings.EqualFold(ctx.request.URL.Scheme, \"https\") || ctx.request.TLS != nil\n\tif !ssl {\n\t\tfor k, v := range ctx.app.ConfigurationReadOnly().GetSSLProxyHeaders() {\n\t\t\tif ctx.GetHeader(k) == v {\n\t\t\t\tssl = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn ssl\n}\n\n// IsHTTP2 reports whether the protocol version for incoming request was HTTP/2.\n// The client code always uses either HTTP/1.1 or HTTP/2.\n//\n// See `IsSSL` too.\nfunc (ctx *Context) IsHTTP2() bool {\n\treturn ctx.request.ProtoMajor == 2\n}\n\n// IsGRPC reports whether the request came from a gRPC client.\nfunc (ctx *Context) IsGRPC() bool {\n\treturn ctx.IsHTTP2() && strings.Contains(ctx.GetContentTypeRequested(), ContentGRPCHeaderValue)\n}\n\ntype (\n\t// Referrer contains the extracted information from the `GetReferrer`\n\t//\n\t// The structure contains struct tags for JSON, form, XML, YAML and TOML.\n\t// Look the `GetReferrer() Referrer` and `goreferrer` external package.\n\tReferrer struct {\n\t\t// The raw refer(r)er URL.\n\t\tRaw        string                   `json:\"raw\" form:\"raw\" xml:\"Raw\" yaml:\"Raw\" toml:\"Raw\"`\n\t\tType       ReferrerType             `json:\"type\" form:\"referrer_type\" xml:\"Type\" yaml:\"Type\" toml:\"Type\"`\n\t\tLabel      string                   `json:\"label\" form:\"referrer_form\" xml:\"Label\" yaml:\"Label\" toml:\"Label\"`\n\t\tURL        string                   `json:\"url\" form:\"referrer_url\" xml:\"URL\" yaml:\"URL\" toml:\"URL\"`\n\t\tSubdomain  string                   `json:\"subdomain\" form:\"referrer_subdomain\" xml:\"Subdomain\" yaml:\"Subdomain\" toml:\"Subdomain\"`\n\t\tDomain     string                   `json:\"domain\" form:\"referrer_domain\" xml:\"Domain\" yaml:\"Domain\" toml:\"Domain\"`\n\t\tTld        string                   `json:\"tld\" form:\"referrer_tld\" xml:\"Tld\" yaml:\"Tld\" toml:\"Tld\"`\n\t\tPath       string                   `json:\"path\" form:\"referrer_path\" xml:\"Path\" yaml:\"Path\" toml:\"Path\"`\n\t\tQuery      string                   `json:\"query\" form:\"referrer_query\" xml:\"Query\" yaml:\"Query\" toml:\"GoogleType\"`\n\t\tGoogleType ReferrerGoogleSearchType `json:\"googleType\" form:\"referrer_google_type\" xml:\"GoogleType\" yaml:\"GoogleType\" toml:\"GoogleType\"`\n\t}\n\n\t// ReferrerType is the goreferrer enum for a referrer type (indirect, direct, email, search, social).\n\tReferrerType = goreferrer.ReferrerType\n\n\t// ReferrerGoogleSearchType is the goreferrer enum for a google search type (organic, adwords).\n\tReferrerGoogleSearchType = goreferrer.GoogleSearchType\n)\n\n// String returns the raw ref url.\nfunc (ref Referrer) String() string {\n\treturn ref.Raw\n}\n\n// Contains the available values of the goreferrer enums.\nconst (\n\tReferrerInvalid ReferrerType = iota\n\tReferrerIndirect\n\tReferrerDirect\n\tReferrerEmail\n\tReferrerSearch\n\tReferrerSocial\n\n\tReferrerNotGoogleSearch ReferrerGoogleSearchType = iota\n\tReferrerGoogleOrganicSearch\n\tReferrerGoogleAdwords\n)\n\n// unnecessary but good to know the default values upfront.\nvar emptyReferrer = Referrer{Type: ReferrerInvalid, GoogleType: ReferrerNotGoogleSearch}\n\n// GetReferrer extracts and returns the information from the \"Referer\" (or \"Referrer\") header\n// and url query parameter as specified in https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy.\nfunc (ctx *Context) GetReferrer() Referrer {\n\t// the underline net/http follows the https://tools.ietf.org/html/rfc7231#section-5.5.2,\n\t// so there is nothing special left to do.\n\t// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy\n\trefURL := ctx.GetHeader(\"Referer\")\n\tif refURL == \"\" {\n\t\trefURL = ctx.GetHeader(\"Referrer\")\n\t\tif refURL == \"\" {\n\t\t\trefURL = ctx.URLParam(\"referer\")\n\t\t\tif refURL == \"\" {\n\t\t\t\trefURL = ctx.URLParam(\"referrer\")\n\t\t\t}\n\t\t}\n\t}\n\n\tif refURL == \"\" {\n\t\treturn emptyReferrer\n\t}\n\n\tif ref := goreferrer.DefaultRules.Parse(refURL); ref.Type > goreferrer.Invalid {\n\t\treturn Referrer{\n\t\t\tRaw:        refURL,\n\t\t\tType:       ReferrerType(ref.Type),\n\t\t\tLabel:      ref.Label,\n\t\t\tURL:        ref.URL,\n\t\t\tSubdomain:  ref.Subdomain,\n\t\t\tDomain:     ref.Domain,\n\t\t\tTld:        ref.Tld,\n\t\t\tPath:       ref.Path,\n\t\t\tQuery:      ref.Query,\n\t\t\tGoogleType: ReferrerGoogleSearchType(ref.GoogleType),\n\t\t}\n\t}\n\n\treturn emptyReferrer\n}\n\n// SetLanguage force-sets the language for i18n, can be used inside a middleare.\n// It has the highest priority over the rest and if it is empty then it is ignored,\n// if it set to a static string of \"default\" or to the default language's code\n// then the rest of the language extractors will not be called at all and\n// the default language will be set instead.\n//\n// See `i18n.ExtractFunc` for a more organised way of the same feature.\nfunc (ctx *Context) SetLanguage(langCode string) {\n\tctx.values.Set(ctx.app.ConfigurationReadOnly().GetLanguageContextKey(), langCode)\n}\n\n// GetLocale returns the current request's `Locale` found by i18n middleware.\n// It always fallbacks to the default one.\n// See `Tr` too.\nfunc (ctx *Context) GetLocale() Locale {\n\t// Cache the Locale itself for multiple calls of `Tr` method.\n\tcontextKey := ctx.app.ConfigurationReadOnly().GetLocaleContextKey()\n\tif v := ctx.values.Get(contextKey); v != nil {\n\t\tif locale, ok := v.(Locale); ok {\n\t\t\treturn locale\n\t\t}\n\t}\n\n\tif locale := ctx.app.I18nReadOnly().GetLocale(ctx); locale != nil {\n\t\tctx.values.Set(contextKey, locale)\n\t\treturn locale\n\t}\n\n\treturn nil\n}\n\n// Tr returns a i18n localized message based on format with optional arguments.\n// See `GetLocale` too.\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/i18n\nfunc (ctx *Context) Tr(key string, args ...interface{}) string {\n\treturn ctx.app.I18nReadOnly().TrContext(ctx, key, args...)\n}\n\n//  +------------------------------------------------------------+\n//  | Response Headers helpers                                   |\n//  +------------------------------------------------------------+\n\n// Header adds a header to the response, if value is empty\n// it removes the header by its name.\nfunc (ctx *Context) Header(name string, value string) {\n\tif value == \"\" {\n\t\tctx.writer.Header().Del(name)\n\t\treturn\n\t}\n\tctx.writer.Header().Add(name, value)\n}\n\nconst contentTypeContextKey = \"iris.content_type\"\n\nfunc shouldAppendCharset(cType string) bool {\n\tif idx := strings.IndexRune(cType, '/'); idx > 1 && len(cType) > idx+1 {\n\t\ttyp := cType[0:idx]\n\t\tif typ == \"application\" {\n\t\t\tswitch cType[idx+1:] {\n\t\t\tcase \"json\", \"xml\", \"yaml\", \"problem+json\", \"problem+xml\":\n\t\t\t\treturn true\n\t\t\tdefault:\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn true\n}\n\nfunc (ctx *Context) contentTypeOnce(cType string, charset string) {\n\tif charset == \"\" {\n\t\tcharset = ctx.app.ConfigurationReadOnly().GetCharset()\n\t}\n\n\tif shouldAppendCharset(cType) {\n\t\tcType += \"; charset=\" + charset\n\t}\n\n\tctx.values.Set(contentTypeContextKey, cType)\n\tctx.writer.Header().Set(ContentTypeHeaderKey, cType)\n}\n\n// ContentType sets the response writer's\n// header \"Content-Type\" to the 'cType'.\nfunc (ctx *Context) ContentType(cType string) {\n\tif cType == \"\" {\n\t\treturn\n\t}\n\n\tif _, wroteOnce := ctx.values.GetEntry(contentTypeContextKey); wroteOnce {\n\t\treturn\n\t}\n\n\t// 1. if it's path or a filename or an extension,\n\t// then take the content type from that,\n\t// ^ No, it's not always a file,e .g. vnd.$type\n\t// if strings.Contains(cType, \".\") {\n\t// \text := filepath.Ext(cType)\n\t// \tcType = mime.TypeByExtension(ext)\n\t// }\n\t// if doesn't contain a charset already then append it\n\tif shouldAppendCharset(cType) {\n\t\tif !strings.Contains(cType, \"charset\") {\n\t\t\tcType += \"; charset=\" + ctx.app.ConfigurationReadOnly().GetCharset()\n\t\t}\n\t}\n\n\tctx.writer.Header().Set(ContentTypeHeaderKey, cType)\n}\n\n// GetContentType returns the response writer's\n// header value of \"Content-Type\".\nfunc (ctx *Context) GetContentType() string {\n\treturn ctx.writer.Header().Get(ContentTypeHeaderKey)\n}\n\n// GetContentTypeRequested returns the request's\n// trim-ed(without the charset and priority values)\n// header value of \"Content-Type\".\nfunc (ctx *Context) GetContentTypeRequested() string {\n\t// could use mime.ParseMediaType too.\n\treturn TrimHeaderValue(ctx.GetHeader(ContentTypeHeaderKey))\n}\n\n// GetContentLength returns the request's\n// header value of \"Content-Length\".\nfunc (ctx *Context) GetContentLength() int64 {\n\tif v := ctx.GetHeader(ContentLengthHeaderKey); v != \"\" {\n\t\tn, _ := strconv.ParseInt(v, 10, 64)\n\t\treturn n\n\t}\n\treturn 0\n}\n\n// StatusCode sets the status code header to the response.\n// Look .GetStatusCode & .FireStatusCode too.\n//\n// Remember, the last one before .Write matters except recorder and transactions.\nfunc (ctx *Context) StatusCode(statusCode int) {\n\tctx.writer.WriteHeader(statusCode)\n}\n\n// NotFound emits an error 404 to the client, using the specific custom error error handler.\n// Note that you may need to call ctx.StopExecution() if you don't want the next handlers\n// to be executed. Next handlers are being executed on iris because you can alt the\n// error code and change it to a more specific one, i.e\n// users := app.Party(\"/users\")\n// users.Done(func(ctx iris.Context){ if ctx.GetStatusCode() == 400 { /*  custom error code for /users */ }})\nfunc (ctx *Context) NotFound() {\n\tctx.StatusCode(http.StatusNotFound)\n}\n\n// GetStatusCode returns the current status code of the response.\n// Look StatusCode too.\nfunc (ctx *Context) GetStatusCode() int {\n\treturn ctx.writer.StatusCode()\n}\n\n//  +------------------------------------------------------------+\n//  | Various Request and Post Data                              |\n//  +------------------------------------------------------------+\n\nfunc (ctx *Context) getQuery() url.Values {\n\tif ctx.query == nil {\n\t\tctx.query = ctx.request.URL.Query()\n\t}\n\n\treturn ctx.query\n}\n\n// URLParamExists returns true if the url parameter exists, otherwise false.\nfunc (ctx *Context) URLParamExists(name string) bool {\n\t_, exists := ctx.getQuery()[name]\n\treturn exists\n}\n\n// URLParamDefault returns the get parameter from a request, if not found then \"def\" is returned.\nfunc (ctx *Context) URLParamDefault(name string, def string) string {\n\tif v := ctx.getQuery().Get(name); v != \"\" {\n\t\treturn v\n\t}\n\n\treturn def\n}\n\n// URLParam returns the get parameter from a request, if any.\nfunc (ctx *Context) URLParam(name string) string {\n\treturn ctx.URLParamDefault(name, \"\")\n}\n\n// URLParamSlice a shortcut of ctx.Request().URL.Query()[name].\n// Like `URLParam` but it returns all values instead of a single string separated by commas.\n// Returns the values of a url query of the given \"name\" as string slice, e.g.\n// ?name=john&name=doe&name=kataras will return [ john doe kataras].\n//\n// Note that, this method skips any empty entries.\n//\n// See `URLParamsSorted` for sorted values.\nfunc (ctx *Context) URLParamSlice(name string) []string {\n\tvalues := ctx.getQuery()[name]\n\tn := len(values)\n\tif n == 0 {\n\t\treturn values\n\t}\n\n\tnormalizedValues := make([]string, 0, n)\n\n\tfor _, v := range values {\n\t\tif v == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tnormalizedValues = append(normalizedValues, v)\n\t}\n\n\treturn normalizedValues\n}\n\n// URLParamTrim returns the url query parameter with trailing white spaces removed from a request.\nfunc (ctx *Context) URLParamTrim(name string) string {\n\treturn strings.TrimSpace(ctx.URLParam(name))\n}\n\n// URLParamEscape returns the escaped url query parameter from a request.\nfunc (ctx *Context) URLParamEscape(name string) string {\n\treturn DecodeQuery(ctx.URLParam(name))\n}\n\n// ErrNotFound is the type error which API users can make use of\n// to check if a `Context` action of a `Handler` is type of Not Found,\n// e.g. URL Query Parameters.\n// Example:\n//\n// n, err := context.URLParamInt(\"url_query_param_name\")\n// if errors.Is(err, context.ErrNotFound) {\n// \t// [handle error...]\n// }\n// Another usage would be `err == context.ErrNotFound`\n// HOWEVER prefer use the new `errors.Is` as API details may change in the future.\nvar ErrNotFound = errors.New(\"not found\")\n\n// URLParamInt returns the url query parameter as int value from a request,\n// returns -1 and an error if parse failed or not found.\nfunc (ctx *Context) URLParamInt(name string) (int, error) {\n\tif v := ctx.URLParam(name); v != \"\" {\n\t\tn, err := strconv.Atoi(v)\n\t\tif err != nil {\n\t\t\treturn -1, err\n\t\t}\n\t\treturn n, nil\n\t}\n\n\treturn -1, ErrNotFound\n}\n\n// URLParamIntDefault returns the url query parameter as int value from a request,\n// if not found or parse failed then \"def\" is returned.\nfunc (ctx *Context) URLParamIntDefault(name string, def int) int {\n\tv, err := ctx.URLParamInt(name)\n\tif err != nil {\n\t\treturn def\n\t}\n\n\treturn v\n}\n\n// URLParamInt32Default returns the url query parameter as int32 value from a request,\n// if not found or parse failed then \"def\" is returned.\nfunc (ctx *Context) URLParamInt32Default(name string, def int32) int32 {\n\tif v := ctx.URLParam(name); v != \"\" {\n\t\tn, err := strconv.ParseInt(v, 10, 32)\n\t\tif err != nil {\n\t\t\treturn def\n\t\t}\n\n\t\treturn int32(n)\n\t}\n\n\treturn def\n}\n\n// URLParamInt64 returns the url query parameter as int64 value from a request,\n// returns -1 and an error if parse failed or not found.\nfunc (ctx *Context) URLParamInt64(name string) (int64, error) {\n\tif v := ctx.URLParam(name); v != \"\" {\n\t\tn, err := strconv.ParseInt(v, 10, 64)\n\t\tif err != nil {\n\t\t\treturn -1, err\n\t\t}\n\t\treturn n, nil\n\t}\n\n\treturn -1, ErrNotFound\n}\n\n// URLParamInt64Default returns the url query parameter as int64 value from a request,\n// if not found or parse failed then \"def\" is returned.\nfunc (ctx *Context) URLParamInt64Default(name string, def int64) int64 {\n\tv, err := ctx.URLParamInt64(name)\n\tif err != nil {\n\t\treturn def\n\t}\n\n\treturn v\n}\n\n// URLParamUint64 returns the url query parameter as uint64 value from a request.\n// Returns 0 on parse errors or when the URL parameter does not exist in the Query.\nfunc (ctx *Context) URLParamUint64(name string) uint64 {\n\tif v := ctx.URLParam(name); v != \"\" {\n\t\tn, err := strconv.ParseUint(v, 10, 64)\n\t\tif err != nil {\n\t\t\treturn 0\n\t\t}\n\t\treturn n\n\t}\n\n\treturn 0\n}\n\n// URLParamFloat64 returns the url query parameter as float64 value from a request,\n// returns an error and -1 if parse failed.\nfunc (ctx *Context) URLParamFloat64(name string) (float64, error) {\n\tif v := ctx.URLParam(name); v != \"\" {\n\t\tn, err := strconv.ParseFloat(v, 64)\n\t\tif err != nil {\n\t\t\treturn -1, err\n\t\t}\n\t\treturn n, nil\n\t}\n\n\treturn -1, ErrNotFound\n}\n\n// URLParamFloat64Default returns the url query parameter as float64 value from a request,\n// if not found or parse failed then \"def\" is returned.\nfunc (ctx *Context) URLParamFloat64Default(name string, def float64) float64 {\n\tv, err := ctx.URLParamFloat64(name)\n\tif err != nil {\n\t\treturn def\n\t}\n\n\treturn v\n}\n\n// URLParamBool returns the url query parameter as boolean value from a request,\n// returns an error if parse failed.\nfunc (ctx *Context) URLParamBool(name string) (bool, error) {\n\treturn strconv.ParseBool(ctx.URLParam(name))\n}\n\n// URLParams returns a map of URL Query parameters.\n// If the value of a URL parameter is a slice,\n// then it is joined as one separated by comma.\n// It returns an empty map on empty URL query.\n//\n// See URLParamsSorted too.\nfunc (ctx *Context) URLParams() map[string]string {\n\tq := ctx.getQuery()\n\tvalues := make(map[string]string, len(q))\n\n\tfor k, v := range q {\n\t\tvalues[k] = strings.Join(v, \",\")\n\t}\n\n\treturn values\n}\n\n// URLParamsSorted returns a sorted (by key) slice\n// of key-value entries of the URL Query parameters.\nfunc (ctx *Context) URLParamsSorted() []memstore.StringEntry {\n\tq := ctx.getQuery()\n\tn := len(q)\n\tif n == 0 {\n\t\treturn nil\n\t}\n\n\tkeys := make([]string, 0, n)\n\tfor key := range q {\n\t\tkeys = append(keys, key)\n\t}\n\n\tsort.Strings(keys)\n\n\tentries := make([]memstore.StringEntry, 0, n)\n\tfor _, key := range keys {\n\t\tvalue := q[key]\n\t\tentries = append(entries, memstore.StringEntry{\n\t\t\tKey:   key,\n\t\t\tValue: strings.Join(value, \",\"),\n\t\t})\n\t}\n\n\treturn entries\n}\n\n// ResetQuery clears the GET URL Query request, temporary, cache.\n// Any new URLParamXXX calls will receive the new parsed values.\nfunc (ctx *Context) ResetQuery() {\n\tctx.query = nil\n}\n\n// No need anymore, net/http checks for the Form already.\n// func (ctx *Context) askParseForm() error {\n// \tif ctx.request.Form == nil {\n// \t\tif err := ctx.request.ParseForm(); err != nil {\n// \t\t\treturn err\n// \t\t}\n// \t}\n// \treturn nil\n// }\n\n// FormValueDefault returns a single parsed form value by its \"name\",\n// including both the URL field's query parameters and the POST or PUT form data.\n//\n// Returns the \"def\" if not found.\nfunc (ctx *Context) FormValueDefault(name string, def string) string {\n\tif form, has := ctx.form(); has {\n\t\tif v := form[name]; len(v) > 0 {\n\t\t\treturn v[0]\n\t\t}\n\t}\n\treturn def\n}\n\n// FormValueDefault retruns a single parsed form value.\nfunc FormValueDefault(r *http.Request, name string, def string, postMaxMemory int64, resetBody bool) string {\n\tif form, has := GetForm(r, postMaxMemory, resetBody); has {\n\t\tif v := form[name]; len(v) > 0 {\n\t\t\treturn v[0]\n\t\t}\n\t}\n\treturn def\n}\n\n// FormValue returns a single parsed form value by its \"name\",\n// including both the URL field's query parameters and the POST or PUT form data.\nfunc (ctx *Context) FormValue(name string) string {\n\treturn ctx.FormValueDefault(name, \"\")\n}\n\n// FormValues returns the parsed form data, including both the URL\n// field's query parameters and the POST or PUT form data.\n//\n// The default form's memory maximum size is 32MB, it can be changed by the\n// `iris#WithPostMaxMemory` configurator at main configuration passed on `app.Run`'s second argument.\n// NOTE: A check for nil is necessary.\nfunc (ctx *Context) FormValues() map[string][]string {\n\tform, _ := ctx.form()\n\treturn form\n}\n\n// Form contains the parsed form data, including both the URL\n// field's query parameters and the POST or PUT form data.\nfunc (ctx *Context) form() (form map[string][]string, found bool) {\n\treturn GetForm(ctx.request, ctx.app.ConfigurationReadOnly().GetPostMaxMemory(), ctx.app.ConfigurationReadOnly().GetDisableBodyConsumptionOnUnmarshal())\n}\n\n// GetForm returns the request form (url queries, post or multipart) values.\nfunc GetForm(r *http.Request, postMaxMemory int64, resetBody bool) (form map[string][]string, found bool) {\n\t/*\n\t\tnet/http/request.go#1219\n\t\tfor k, v := range f.Value {\n\t\t\tr.Form[k] = append(r.Form[k], v...)\n\t\t\t// r.PostForm should also be populated. See Issue 9305.\n\t\t\tr.PostForm[k] = append(r.PostForm[k], v...)\n\t\t}\n\t*/\n\n\tif form := r.Form; len(form) > 0 {\n\t\treturn form, true\n\t}\n\n\tif form := r.PostForm; len(form) > 0 {\n\t\treturn form, true\n\t}\n\n\tif m := r.MultipartForm; m != nil {\n\t\tif len(m.Value) > 0 {\n\t\t\treturn m.Value, true\n\t\t}\n\t}\n\n\tvar bodyCopy []byte\n\n\tif resetBody {\n\t\t// on POST, PUT and PATCH it will read the form values from request body otherwise from URL queries.\n\t\tif m := r.Method; m == \"POST\" || m == \"PUT\" || m == \"PATCH\" {\n\t\t\tbodyCopy, _ = GetBody(r, resetBody)\n\t\t\tif len(bodyCopy) == 0 {\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t\t// r.Body = ioutil.NopCloser(io.TeeReader(r.Body, buf))\n\t\t} else {\n\t\t\tresetBody = false\n\t\t}\n\t}\n\n\t// ParseMultipartForm calls `request.ParseForm` automatically\n\t// therefore we don't need to call it here, although it doesn't hurt.\n\t// After one call to ParseMultipartForm or ParseForm,\n\t// subsequent calls have no effect, are idempotent.\n\terr := r.ParseMultipartForm(postMaxMemory)\n\tif resetBody {\n\t\tr.Body = ioutil.NopCloser(bytes.NewBuffer(bodyCopy))\n\t}\n\tif err != nil && err != http.ErrNotMultipart {\n\t\treturn nil, false\n\t}\n\n\tif form := r.Form; len(form) > 0 {\n\t\treturn form, true\n\t}\n\n\tif form := r.PostForm; len(form) > 0 {\n\t\treturn form, true\n\t}\n\n\tif m := r.MultipartForm; m != nil {\n\t\tif len(m.Value) > 0 {\n\t\t\treturn m.Value, true\n\t\t}\n\t}\n\n\treturn nil, false\n}\n\n// PostValues returns all the parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\" as a string slice.\n//\n// The default form's memory maximum size is 32MB, it can be changed by the\n// `iris#WithPostMaxMemory` configurator at main configuration passed on `app.Run`'s second argument.\n//\n// In addition, it reports whether the form was empty\n// or when the \"name\" does not exist\n// or whether the available values are empty.\n// It strips any empty key-values from the slice before return.\n//\n// Look ErrEmptyForm, ErrNotFound and ErrEmptyFormField respectfully.\n// See `PostValueMany` method too.\nfunc (ctx *Context) PostValues(name string) ([]string, error) {\n\t_, ok := ctx.form()\n\tif !ok {\n\t\tif !ctx.app.ConfigurationReadOnly().GetFireEmptyFormError() {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\treturn nil, ErrEmptyForm // empty form.\n\t}\n\n\tvalues, ok := ctx.request.PostForm[name]\n\tif !ok {\n\t\treturn nil, ErrNotFound // field does not exist\n\t}\n\n\tif len(values) == 0 ||\n\t\t// Fast check for its first empty value (see below).\n\t\tstrings.TrimSpace(values[0]) == \"\" {\n\t\treturn nil, fmt.Errorf(\"%w: %s\", ErrEmptyFormField, name)\n\t}\n\n\tfor _, value := range values {\n\t\tif value == \"\" { // if at least one empty value, then perform the strip from the beginning.\n\t\t\tresult := make([]string, 0, len(values))\n\t\t\tfor _, value := range values {\n\t\t\t\tif strings.TrimSpace(value) != \"\" {\n\t\t\t\t\tresult = append(result, value) // we store the value as it is, not space-trimmed.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(result) == 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"%w: %s\", ErrEmptyFormField, name)\n\t\t\t}\n\n\t\t\treturn result, nil\n\t\t}\n\t}\n\n\treturn values, nil\n}\n\n// PostValueMany is like `PostValues` method, it returns the post data of a given key.\n// In addition to `PostValues` though, the returned value is a single string\n// separated by commas on multiple values.\n//\n// See ErrEmptyForm, ErrNotFound and ErrEmptyFormField respectfully.\nfunc (ctx *Context) PostValueMany(name string) (string, error) {\n\tvalues, err := ctx.PostValues(name)\n\tif err != nil || len(values) == 0 {\n\t\treturn \"\", err\n\t}\n\n\treturn strings.Join(values, \",\"), nil\n}\n\n// PostValueDefault returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\".\n//\n// If not found then \"def\" is returned instead.\nfunc (ctx *Context) PostValueDefault(name string, def string) string {\n\tvalues, err := ctx.PostValues(name)\n\tif err != nil || len(values) == 0 {\n\t\treturn def // it returns \"def\" even if it's empty here.\n\t}\n\n\treturn values[len(values)-1]\n}\n\n// PostValue returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\".\n//\n// See `PostValueMany` too.\nfunc (ctx *Context) PostValue(name string) string {\n\treturn ctx.PostValueDefault(name, \"\")\n}\n\n// PostValueTrim returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\",  without trailing spaces.\nfunc (ctx *Context) PostValueTrim(name string) string {\n\treturn strings.TrimSpace(ctx.PostValue(name))\n}\n\n// PostValueInt returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\", as int.\n//\n// See ErrEmptyForm, ErrNotFound and ErrEmptyFormField respectfully.\nfunc (ctx *Context) PostValueInt(name string) (int, error) {\n\tvalues, err := ctx.PostValues(name)\n\tif err != nil || len(values) == 0 {\n\t\treturn 0, err\n\t}\n\n\treturn strconv.Atoi(values[len(values)-1])\n}\n\n// PostValueIntDefault returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\", as int.\n//\n// If not found or parse errors returns the \"def\".\nfunc (ctx *Context) PostValueIntDefault(name string, def int) int {\n\tif v, err := ctx.PostValueInt(name); err == nil {\n\t\treturn v\n\t}\n\n\treturn def\n}\n\n// PostValueInt64 returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\", as float64.\n//\n// See ErrEmptyForm, ErrNotFound and ErrEmptyFormField respectfully.\nfunc (ctx *Context) PostValueInt64(name string) (int64, error) {\n\tvalues, err := ctx.PostValues(name)\n\tif err != nil || len(values) == 0 {\n\t\treturn 0, err\n\t}\n\n\treturn strconv.ParseInt(values[len(values)-1], 10, 64)\n}\n\n// PostValueInt64Default returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\", as int64.\n//\n// If not found or parse errors returns the \"def\".\nfunc (ctx *Context) PostValueInt64Default(name string, def int64) int64 {\n\tif v, err := ctx.PostValueInt64(name); err == nil {\n\t\treturn v\n\t}\n\n\treturn def\n}\n\n// PostValueFloat64 returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\", as float64.\n//\n// See ErrEmptyForm, ErrNotFound and ErrEmptyFormField respectfully.\nfunc (ctx *Context) PostValueFloat64(name string) (float64, error) {\n\tvalues, err := ctx.PostValues(name)\n\tif err != nil || len(values) == 0 {\n\t\treturn 0, err\n\t}\n\n\treturn strconv.ParseFloat(values[len(values)-1], 64)\n}\n\n// PostValueFloat64Default returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\", as float64.\n//\n// If not found or parse errors returns the \"def\".\nfunc (ctx *Context) PostValueFloat64Default(name string, def float64) float64 {\n\tif v, err := ctx.PostValueFloat64(name); err == nil {\n\t\treturn v\n\t}\n\n\treturn def\n}\n\n// PostValueBool returns the last parsed form data from POST, PATCH,\n// or PUT body parameters based on a \"name\", as bool.\n// If more than one value was binded to \"name\", then it returns the last one.\n//\n// See ErrEmptyForm, ErrNotFound and ErrEmptyFormField respectfully.\nfunc (ctx *Context) PostValueBool(name string) (bool, error) {\n\tvalues, err := ctx.PostValues(name)\n\tif err != nil || len(values) == 0 {\n\t\treturn false, err\n\t}\n\n\treturn strconv.ParseBool(values[len(values)-1]) // values cannot be empty on this state.\n}\n\n// FormFile returns the first uploaded file that received from the client.\n//\n//\n// The default form's memory maximum size is 32MB, it can be changed by the\n// `iris#WithPostMaxMemory` configurator at main configuration passed on `app.Run`'s second argument.\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/file-server/upload-file\nfunc (ctx *Context) FormFile(key string) (multipart.File, *multipart.FileHeader, error) {\n\t// we don't have access to see if the request is body stream\n\t// and then the ParseMultipartForm can be useless\n\t// here but do it in order to apply the post limit,\n\t// the internal request.FormFile will not do it if that's filled\n\t// and it's not a stream body.\n\tif err := ctx.request.ParseMultipartForm(ctx.app.ConfigurationReadOnly().GetPostMaxMemory()); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn ctx.request.FormFile(key)\n}\n\n// FormFiles same as FormFile but may return multiple file inputs based on a key, e.g. \"files[]\".\nfunc (ctx *Context) FormFiles(key string, before ...func(*Context, *multipart.FileHeader) bool) (files []multipart.File, headers []*multipart.FileHeader, err error) {\n\terr = ctx.request.ParseMultipartForm(ctx.app.ConfigurationReadOnly().GetPostMaxMemory())\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif ctx.request.MultipartForm != nil {\n\t\tfhs := ctx.request.MultipartForm.File\n\t\tif n := len(fhs); n > 0 {\n\t\t\tfiles = make([]multipart.File, 0, n)\n\t\t\theaders = make([]*multipart.FileHeader, 0, n)\n\n\t\tinnerLoop:\n\t\t\tfor _, header := range fhs[key] {\n\t\t\t\theader.Filename = filepath.Base(header.Filename)\n\n\t\t\t\tfor _, b := range before {\n\t\t\t\t\tif !b(ctx, header) {\n\t\t\t\t\t\tcontinue innerLoop\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfile, fErr := header.Open()\n\t\t\t\tif fErr != nil { // exit on first error but return the succeed.\n\t\t\t\t\treturn files, headers, fErr\n\t\t\t\t}\n\n\t\t\t\tfiles = append(files, file)\n\t\t\t\theaders = append(headers, header)\n\t\t\t}\n\t\t}\n\n\t\treturn\n\t}\n\n\treturn nil, nil, http.ErrMissingFile\n}\n\n// UploadFormFiles uploads any received file(s) from the client\n// to the system physical location \"destDirectory\".\n//\n// The second optional argument \"before\" gives caller the chance to\n// modify or cancel the *miltipart.FileHeader before saving to the disk,\n// it can be used to change a file's name based on the current request,\n// all FileHeader's options can be changed. You can ignore it if\n// you don't need to use this capability before saving a file to the disk.\n//\n// Note that it doesn't check if request body streamed.\n//\n// Returns the copied length as int64 and\n// a not nil error if at least one new file\n// can't be created due to the operating system's permissions or\n// http.ErrMissingFile if no file received.\n//\n// If you want to receive & accept files and manage them manually you can use the `context#FormFile`\n// instead and create a copy function that suits your needs or use the `SaveFormFile` method,\n// the below is for generic usage.\n//\n// The default form's memory maximum size is 32MB, it can be changed by\n// the `WithPostMaxMemory` configurator or by `SetMaxRequestBodySize` or\n// by the `LimitRequestBodySize` middleware (depends the use case).\n//\n// See `FormFile` and `FormFiles` to a more controlled way to receive a file.\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/file-server/upload-files\nfunc (ctx *Context) UploadFormFiles(destDirectory string, before ...func(*Context, *multipart.FileHeader) bool) (uploaded []*multipart.FileHeader, n int64, err error) {\n\terr = ctx.request.ParseMultipartForm(ctx.app.ConfigurationReadOnly().GetPostMaxMemory())\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\tif ctx.request.MultipartForm != nil {\n\t\tif fhs := ctx.request.MultipartForm.File; fhs != nil {\n\t\t\tfor _, files := range fhs {\n\t\t\tinnerLoop:\n\t\t\t\tfor _, file := range files {\n\t\t\t\t\t// Security fix for go < 1.17.5:\n\t\t\t\t\t// Reported by Kirill Efimov (snyk.io) through security reports.\n\t\t\t\t\tfile.Filename = filepath.Base(file.Filename)\n\n\t\t\t\t\tfor _, b := range before {\n\t\t\t\t\t\tif !b(ctx, file) {\n\t\t\t\t\t\t\tcontinue innerLoop\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tn0, err0 := ctx.SaveFormFile(file, filepath.Join(destDirectory, file.Filename))\n\t\t\t\t\tif err0 != nil {\n\t\t\t\t\t\treturn nil, 0, err0\n\t\t\t\t\t}\n\t\t\t\t\tn += n0\n\n\t\t\t\t\tuploaded = append(uploaded, file)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uploaded, n, nil\n\t\t}\n\t}\n\n\treturn nil, 0, http.ErrMissingFile\n}\n\n// SaveFormFile saves a result of `FormFile` to the \"dest\" disk full path (directory + filename).\n// See `FormFile` and `UploadFormFiles` too.\nfunc (ctx *Context) SaveFormFile(fh *multipart.FileHeader, dest string) (int64, error) {\n\tsrc, err := fh.Open()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer src.Close()\n\n\tout, err := os.Create(dest)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer out.Close()\n\n\treturn io.Copy(out, src)\n}\n\n// AbsoluteURI parses the \"s\" and returns its absolute URI form.\nfunc (ctx *Context) AbsoluteURI(s string) string {\n\tif s == \"\" {\n\t\treturn \"\"\n\t}\n\n\tif s[0] == '/' {\n\t\tscheme := ctx.request.URL.Scheme\n\t\tif scheme == \"\" {\n\t\t\tif ctx.request.TLS != nil {\n\t\t\t\tscheme = \"https:\"\n\t\t\t} else {\n\t\t\t\tscheme = \"http:\"\n\t\t\t}\n\t\t}\n\n\t\thost := ctx.Host()\n\n\t\treturn scheme + \"//\" + host + path.Clean(s)\n\t}\n\n\tif u, err := url.Parse(s); err == nil {\n\t\tr := ctx.request\n\n\t\tif u.Scheme == \"\" && u.Host == \"\" {\n\t\t\toldpath := r.URL.Path\n\t\t\tif oldpath == \"\" {\n\t\t\t\toldpath = \"/\"\n\t\t\t}\n\n\t\t\tif s == \"\" || s[0] != '/' {\n\t\t\t\tolddir, _ := path.Split(oldpath)\n\t\t\t\ts = olddir + s\n\t\t\t}\n\n\t\t\tvar query string\n\t\t\tif i := strings.Index(s, \"?\"); i != -1 {\n\t\t\t\ts, query = s[:i], s[i:]\n\t\t\t}\n\n\t\t\t// clean up but preserve trailing slash\n\t\t\ttrailing := strings.HasSuffix(s, \"/\")\n\t\t\ts = path.Clean(s)\n\t\t\tif trailing && !strings.HasSuffix(s, \"/\") {\n\t\t\t\ts += \"/\"\n\t\t\t}\n\t\t\ts += query\n\t\t}\n\t}\n\n\treturn s\n}\n\n// Redirect sends a redirect response to the client\n// of an absolute or relative target URL.\n// It accepts 2 input arguments, a string and an optional integer.\n// The first parameter is the target url to redirect.\n// The second one is the HTTP status code should be sent\n// among redirection response,\n// If the second parameter is missing, then it defaults to 302 (StatusFound).\n// It can be set to 301 (Permant redirect), StatusTemporaryRedirect(307)\n// or 303 (StatusSeeOther) if POST method.\nfunc (ctx *Context) Redirect(urlToRedirect string, statusHeader ...int) {\n\tctx.StopExecution()\n\t// get the previous status code given by the end-developer.\n\tstatus := ctx.GetStatusCode()\n\tif status < 300 { // the previous is not a RCF-valid redirect status.\n\t\tstatus = 0\n\t}\n\n\tif len(statusHeader) > 0 {\n\t\t// check if status code is passed via receivers.\n\t\tif s := statusHeader[0]; s > 0 {\n\t\t\tstatus = s\n\t\t}\n\t}\n\tif status == 0 {\n\t\t// if status remains zero then default it.\n\t\t// a 'temporary-redirect-like' which works better than for our purpose\n\t\tstatus = http.StatusFound\n\t}\n\n\thttp.Redirect(ctx.writer, ctx.request, urlToRedirect, status)\n}\n\n//  +------------------------------------------------------------+\n//  | Body Readers                                               |\n//  +------------------------------------------------------------+\n\n// SetMaxRequestBodySize sets a limit to the request body size\n// should be called before reading the request body from the client.\nfunc (ctx *Context) SetMaxRequestBodySize(limitOverBytes int64) {\n\tctx.request.Body = http.MaxBytesReader(ctx.writer, ctx.request.Body, limitOverBytes)\n}\n\n// GetBody reads and returns the request body.\nfunc GetBody(r *http.Request, resetBody bool) ([]byte, error) {\n\tdata, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resetBody {\n\t\t// * remember, Request.Body has no Bytes(), we have to consume them first\n\t\t// and after re-set them to the body, this is the only solution.\n\t\tr.Body = ioutil.NopCloser(bytes.NewBuffer(data))\n\t}\n\n\treturn data, nil\n}\n\nconst disableRequestBodyConsumptionContextKey = \"iris.request.body.record\"\n\n// RecordRequestBody same as the Application's DisableBodyConsumptionOnUnmarshal\n// configuration field but acts only for the current request.\n// It makes the request body readable more than once.\nfunc (ctx *Context) RecordRequestBody(b bool) {\n\tctx.values.Set(disableRequestBodyConsumptionContextKey, b)\n}\n\n// IsRecordingBody reports whether the request body can be readen multiple times.\nfunc (ctx *Context) IsRecordingBody() bool {\n\treturn ctx.values.GetBoolDefault(disableRequestBodyConsumptionContextKey,\n\t\tctx.app.ConfigurationReadOnly().GetDisableBodyConsumptionOnUnmarshal())\n}\n\n// GetBody reads and returns the request body.\n// The default behavior for the http request reader is to consume the data readen\n// but you can change that behavior by passing the `WithoutBodyConsumptionOnUnmarshal` Iris option\n// or by calling the `RecordRequestBody` method.\n//\n// However, whenever you can use the `ctx.Request().Body` instead.\nfunc (ctx *Context) GetBody() ([]byte, error) {\n\treturn GetBody(ctx.request, ctx.IsRecordingBody())\n}\n\n// Validator is the validator for request body on Context methods such as\n// ReadJSON, ReadMsgPack, ReadXML, ReadYAML, ReadForm, ReadQuery, ReadBody and e.t.c.\ntype Validator interface {\n\tStruct(interface{}) error\n\t// If community asks for more than a struct validation on JSON, XML, MsgPack, Form, Query and e.t.c\n\t// then we should add more methods here, alternative approach would be to have a\n\t// `Validator:Validate(interface{}) error` and a map[reflect.Kind]Validator instead.\n}\n\n// UnmarshalBody reads the request's body and binds it to a value or pointer of any type\n// Examples of usage: context.ReadJSON, context.ReadXML.\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-custom-via-unmarshaler/main.go\nfunc (ctx *Context) UnmarshalBody(outPtr interface{}, unmarshaler Unmarshaler) error {\n\tif ctx.request.Body == nil {\n\t\treturn fmt.Errorf(\"unmarshal: empty body: %w\", ErrNotFound)\n\t}\n\n\trawData, err := ctx.GetBody()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// check if the v contains its own decode\n\t// in this case the v should be a pointer also,\n\t// but this is up to the user's custom Decode implementation*\n\t//\n\t// See 'BodyDecoder' for more.\n\tif decoder, isDecoder := outPtr.(BodyDecoder); isDecoder {\n\t\treturn decoder.Decode(rawData)\n\t}\n\n\t// // check if v is already a pointer, if yes then pass as it's\n\t// if reflect.TypeOf(v).Kind() == reflect.Ptr {\n\t// \treturn unmarshaler.Unmarshal(rawData, v)\n\t// } <- no need for that, ReadJSON is documented enough to receive a pointer,\n\t// we don't need to reduce the performance here by using the reflect.TypeOf method.\n\n\t// f the v doesn't contains a self-body decoder use the custom unmarshaler to bind the body.\n\terr = unmarshaler.Unmarshal(rawData, outPtr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(outPtr)\n}\n\n// internalBodyDecoder is a generic type of decoder, usually used to export stream reading functionality\n// of a JSON request.\ntype internalBodyDecoder interface {\n\tDecode(outPutr interface{}) error\n}\n\n// Same as UnmarshalBody but it operates on body stream.\nfunc (ctx *Context) decodeBody(outPtr interface{}, decoder internalBodyDecoder) error {\n\t// check if the v contains its own decode\n\t// in this case the v should be a pointer also,\n\t// but this is up to the user's custom Decode implementation*\n\t//\n\t// See 'BodyDecoder' for more.\n\tif structDecoder, isDecoder := outPtr.(BodyDecoder); isDecoder {\n\t\trawData, err := ctx.GetBody()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn structDecoder.Decode(rawData)\n\t}\n\n\terr := decoder.Decode(outPtr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(outPtr)\n}\n\nfunc (ctx *Context) shouldOptimize() bool {\n\treturn ctx.app.ConfigurationReadOnly().GetEnableOptimizations()\n}\n\n// JSONReader holds the JSON decode options of the `Context.ReadJSON, ReadBody` methods.\ntype JSONReader struct { // Note(@kataras): struct instead of optional funcs to keep consistently with the encoder options.\n\t// DisallowUnknownFields causes the json decoder to return an error when the destination\n\t// is a struct and the input contains object keys which do not match any\n\t// non-ignored, exported fields in the destination.\n\tDisallowUnknownFields bool\n\t// If set to true then a bit faster json decoder is used instead,\n\t// note that if this is true then it overrides\n\t// the Application's EnableOptimizations configuration field.\n\tOptimize bool\n\t// This field only applies to the ReadJSONStream.\n\t// The Optimize field has no effect when this is true.\n\t// If set to true the request body stream MUST start with a `[`\n\t// and end with `]` literals, example:\n\t//  [\n\t//   {\"username\":\"john\"},\n\t//   {\"username\": \"makis\"},\n\t//   {\"username\": \"george\"}\n\t//  ]\n\t// Defaults to false: decodes a json object one by one, example:\n\t//  {\"username\":\"john\"}\n\t//  {\"username\": \"makis\"}\n\t//  {\"username\": \"george\"}\n\tArrayStream bool\n}\n\ntype internalJSONDecoder interface {\n\tinternalBodyDecoder\n\tDisallowUnknownFields()\n\tMore() bool\n}\n\nfunc (cfg JSONReader) getDecoder(r io.Reader, globalShouldOptimize bool) (decoder internalJSONDecoder) {\n\tif cfg.Optimize || globalShouldOptimize {\n\t\tdecoder = jsoniter.ConfigCompatibleWithStandardLibrary.NewDecoder(r)\n\t} else {\n\t\tdecoder = json.NewDecoder(r)\n\t}\n\n\tif cfg.DisallowUnknownFields {\n\t\tdecoder.DisallowUnknownFields()\n\t}\n\n\treturn\n}\n\n// ReadJSON reads JSON from request's body and binds it to a value of any json-valid type.\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-json/main.go\nfunc (ctx *Context) ReadJSON(outPtr interface{}, opts ...JSONReader) error {\n\tshouldOptimize := ctx.shouldOptimize()\n\n\tif len(opts) > 0 {\n\t\tcfg := opts[0]\n\t\treturn ctx.decodeBody(outPtr, cfg.getDecoder(ctx.request.Body, shouldOptimize))\n\t}\n\n\tunmarshaler := json.Unmarshal\n\tif shouldOptimize {\n\t\tunmarshaler = jsoniter.Unmarshal\n\t}\n\n\treturn ctx.UnmarshalBody(outPtr, UnmarshalerFunc(unmarshaler))\n}\n\n// ReadJSONStream is an alternative of ReadJSON which can reduce the memory load\n// by reading only one json object every time.\n// It buffers just the content required for a single json object instead of the entire string,\n// and discards that once it reaches an end of value that can be decoded into the provided struct\n// inside the onDecode's DecodeFunc.\n//\n// It accepts a function which accepts the json Decode function and returns an error.\n// The second variadic argument is optional and can be used to customize the decoder even further.\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-json-stream/main.go\nfunc (ctx *Context) ReadJSONStream(onDecode func(DecodeFunc) error, opts ...JSONReader) error {\n\tvar cfg JSONReader\n\tif len(opts) > 0 {\n\t\tcfg = opts[0]\n\t}\n\n\t// note that only the standard package supports an object\n\t// stream of arrays (when the receiver is not an array).\n\tif cfg.ArrayStream || !cfg.Optimize {\n\t\tdecoder := json.NewDecoder(ctx.request.Body)\n\t\tif cfg.DisallowUnknownFields {\n\t\t\tdecoder.DisallowUnknownFields()\n\t\t}\n\t\tdecodeFunc := decoder.Decode\n\n\t\t_, err := decoder.Token() // read open bracket.\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor decoder.More() { // hile the array contains values.\n\t\t\tif err = onDecode(decodeFunc); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t_, err = decoder.Token() // read closing bracket.\n\t\treturn err\n\t}\n\n\tdec := cfg.getDecoder(ctx.request.Body, ctx.shouldOptimize())\n\tdecodeFunc := dec.Decode\n\n\t// while the array contains values\n\tfor dec.More() {\n\t\tif err := onDecode(decodeFunc); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ReadXML reads XML from request's body and binds it to a value of any xml-valid type.\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-xml/main.go\nfunc (ctx *Context) ReadXML(outPtr interface{}) error {\n\treturn ctx.UnmarshalBody(outPtr, UnmarshalerFunc(xml.Unmarshal))\n}\n\n// ReadYAML reads YAML from request's body and binds it to the \"outPtr\" value.\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-yaml/main.go\nfunc (ctx *Context) ReadYAML(outPtr interface{}) error {\n\treturn ctx.UnmarshalBody(outPtr, UnmarshalerFunc(yaml.Unmarshal))\n}\n\nvar (\n\t// IsErrEmptyJSON reports whether the given \"err\" is caused by a\n\t// Context.ReadJSON call when the request body\n\t// didn't start with { or it was totally empty.\n\tIsErrEmptyJSON = func(err error) bool {\n\t\tif err == nil {\n\t\t\treturn false\n\t\t}\n\n\t\tif v, ok := err.(*json.SyntaxError); ok {\n\t\t\t// standard go json encoder error.\n\t\t\treturn v.Offset == 0 && v.Error() == \"unexpected end of JSON input\"\n\t\t}\n\n\t\t// when optimization is enabled, the jsoniter will report the following error:\n\t\treturn strings.Contains(err.Error(), \"readObjectStart: expect {\")\n\t}\n\n\t// IsErrPath can be used at `context#ReadForm` and `context#ReadQuery`.\n\t// It reports whether the incoming error\n\t// can be ignored when server allows unknown post values to be sent by the client.\n\t//\n\t// A shortcut for the `schema#IsErrPath`.\n\tIsErrPath = schema.IsErrPath\n\n\t// ErrEmptyForm is returned by\n\t// - `context#ReadForm`\n\t// - `context#ReadQuery`\n\t// - `context#ReadBody`\n\t// when the request data (form, query and body respectfully) is empty.\n\tErrEmptyForm = errors.New(\"empty form\")\n\n\t// ErrEmptyFormField reports whether a specific field exists but it's empty.\n\t// Usage: errors.Is(err, ErrEmptyFormField)\n\t// See postValue method. It's only returned on parsed post value methods.\n\tErrEmptyFormField = errors.New(\"empty form field\")\n\n\t// ConnectionCloseErrorSubstr if at least one of the given\n\t// substrings are found in a net.OpError:os.SyscallError error type\n\t// on `IsErrConnectionReset` then the function will report true.\n\tConnectionCloseErrorSubstr = []string{\n\t\t\"broken pipe\",\n\t\t\"connection reset by peer\",\n\t}\n\n\t// IsErrConnectionClosed reports whether the given \"err\"\n\t// is caused because of a broken connection.\n\tIsErrConnectionClosed = func(err error) bool {\n\t\tif err == nil {\n\t\t\treturn false\n\t\t}\n\n\t\tif opErr, ok := err.(*net.OpError); ok {\n\t\t\tif syscallErr, ok := opErr.Err.(*os.SyscallError); ok {\n\t\t\t\terrStr := strings.ToLower(syscallErr.Error())\n\t\t\t\tfor _, s := range ConnectionCloseErrorSubstr {\n\t\t\t\t\tif strings.Contains(errStr, s) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n)\n\n// ReadForm binds the request body of a form to the \"formObject\".\n// It supports any kind of type, including custom structs.\n// It will return nothing if request data are empty.\n// The struct field tag is \"form\".\n// Note that it will return nil error on empty form data if `Configuration.FireEmptyFormError`\n// is false (as defaulted) in this case the caller should check the pointer to\n// see if something was actually binded.\n//\n// If a client sent an unknown field, this method will return an error,\n// in order to ignore that error use the `err != nil && !iris.IsErrPath(err)`.\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-form/main.go\nfunc (ctx *Context) ReadForm(formObject interface{}) error {\n\tvalues := ctx.FormValues()\n\tif len(values) == 0 {\n\t\tif ctx.app.ConfigurationReadOnly().GetFireEmptyFormError() {\n\t\t\treturn ErrEmptyForm\n\t\t}\n\t\treturn nil\n\t}\n\n\terr := schema.DecodeForm(values, formObject)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(formObject)\n}\n\n// ReadQuery binds URL Query to \"ptr\". The struct field tag is \"url\".\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-query/main.go\nfunc (ctx *Context) ReadQuery(ptr interface{}) error {\n\tvalues := ctx.getQuery()\n\tif len(values) == 0 {\n\t\tif ctx.app.ConfigurationReadOnly().GetFireEmptyFormError() {\n\t\t\treturn ErrEmptyForm\n\t\t}\n\t\treturn nil\n\t}\n\n\terr := schema.DecodeQuery(values, ptr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(ptr)\n}\n\n// ReadHeaders binds request headers to \"ptr\". The struct field tag is \"header\".\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-headers/main.go\nfunc (ctx *Context) ReadHeaders(ptr interface{}) error {\n\terr := schema.DecodeHeaders(ctx.request.Header, ptr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(ptr)\n}\n\n// ReadParams binds URI Dynamic Path Parameters to \"ptr\". The struct field tag is \"param\".\n//\n// Example: https://github.com/kataras/iris/blob/master/_examples/request-body/read-params/main.go\nfunc (ctx *Context) ReadParams(ptr interface{}) error {\n\tn := ctx.params.Len()\n\tif n == 0 {\n\t\treturn nil\n\t}\n\n\tvalues := make(map[string][]string, n)\n\tctx.params.Visit(func(key string, value string) {\n\t\t// []string on path parameter, e.g.\n\t\t// /.../{tail:path}\n\t\t// Tail []string `param:\"tail\"`\n\t\tvalues[key] = strings.Split(value, \"/\")\n\t})\n\n\terr := schema.DecodeParams(values, ptr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(ptr)\n}\n\n// ReadURL is a shortcut of ReadParams and ReadQuery.\n// It binds dynamic path parameters and URL query parameters\n// to the \"ptr\" pointer struct value.\n// The struct fields may contain \"url\" or \"param\" binding tags.\n// If a validator exists then it validates the result too.\nfunc (ctx *Context) ReadURL(ptr interface{}) error {\n\tvalues := make(map[string][]string, ctx.params.Len())\n\tctx.params.Visit(func(key string, value string) {\n\t\tvalues[key] = strings.Split(value, \"/\")\n\t})\n\n\tfor k, v := range ctx.getQuery() {\n\t\tvalues[k] = append(values[k], v...)\n\t}\n\n\t// Decode using all available binding tags (url, header, param).\n\terr := schema.Decode(values, ptr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(ptr)\n}\n\n// ReadProtobuf binds the body to the \"ptr\" of a proto Message and returns any error.\n// Look `ReadJSONProtobuf` too.\nfunc (ctx *Context) ReadProtobuf(ptr proto.Message) error {\n\trawData, err := ctx.GetBody()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn proto.Unmarshal(rawData, ptr)\n}\n\n// ProtoUnmarshalOptions is a type alias for protojson.UnmarshalOptions.\ntype ProtoUnmarshalOptions = protojson.UnmarshalOptions\n\nvar defaultProtobufUnmarshalOptions ProtoUnmarshalOptions\n\n// ReadJSONProtobuf reads a JSON body request into the given \"ptr\" proto.Message.\n// Look `ReadProtobuf` too.\nfunc (ctx *Context) ReadJSONProtobuf(ptr proto.Message, opts ...ProtoUnmarshalOptions) error {\n\trawData, err := ctx.GetBody()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\topt := defaultProtobufUnmarshalOptions\n\tif len(opts) > 0 {\n\t\topt = opts[0]\n\t}\n\n\treturn opt.Unmarshal(rawData, ptr)\n}\n\n// ReadMsgPack binds the request body of msgpack format to the \"ptr\" and returns any error.\nfunc (ctx *Context) ReadMsgPack(ptr interface{}) error {\n\trawData, err := ctx.GetBody()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = msgpack.Unmarshal(rawData, ptr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ctx.app.Validate(ptr)\n}\n\n// ReadBody binds the request body to the \"ptr\" depending on the HTTP Method and the Request's Content-Type.\n// If a GET method request then it reads from a form (or URL Query), otherwise\n// it tries to match (depending on the request content-type) the data format e.g.\n// JSON, Protobuf, MsgPack, XML, YAML, MultipartForm and binds the result to the \"ptr\".\n// As a special case if the \"ptr\" was a pointer to string or []byte\n// then it will bind it to the request body as it is.\nfunc (ctx *Context) ReadBody(ptr interface{}) error {\n\t// If the ptr is string or byte, read the body as it's.\n\tswitch v := ptr.(type) {\n\tcase *string:\n\t\tb, err := ctx.GetBody()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*v = string(b)\n\tcase *[]byte:\n\t\tb, err := ctx.GetBody()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tcopy(*v, b)\n\t}\n\n\tif ctx.Method() == http.MethodGet {\n\t\tif ctx.Request().URL.RawQuery != \"\" {\n\t\t\t// try read from query.\n\t\t\treturn ctx.ReadQuery(ptr)\n\t\t}\n\n\t\t// otherwise use the ReadForm,\n\t\t// it's actually the same except\n\t\t// ReadQuery will not fire errors on:\n\t\t// 1. unknown or empty url query parameters\n\t\t// 2. empty query or form (if FireEmptyFormError is enabled).\n\t\treturn ctx.ReadForm(ptr)\n\t}\n\n\tswitch ctx.GetContentTypeRequested() {\n\tcase ContentXMLHeaderValue, ContentXMLUnreadableHeaderValue:\n\t\treturn ctx.ReadXML(ptr)\n\t\t// \"%v reflect.Indirect(reflect.ValueOf(ptr)).Interface())\n\tcase ContentYAMLHeaderValue, ContentYAMLTextHeaderValue:\n\t\treturn ctx.ReadYAML(ptr)\n\tcase ContentFormHeaderValue, ContentFormMultipartHeaderValue:\n\t\treturn ctx.ReadForm(ptr)\n\tcase ContentJSONHeaderValue:\n\t\treturn ctx.ReadJSON(ptr)\n\tcase ContentProtobufHeaderValue:\n\t\tmsg, ok := ptr.(proto.Message)\n\t\tif !ok {\n\t\t\treturn ErrContentNotSupported\n\t\t}\n\n\t\treturn ctx.ReadProtobuf(msg)\n\tcase ContentMsgPackHeaderValue, ContentMsgPack2HeaderValue:\n\t\treturn ctx.ReadMsgPack(ptr)\n\tdefault:\n\t\tif ctx.Request().URL.RawQuery != \"\" {\n\t\t\t// try read from query.\n\t\t\treturn ctx.ReadQuery(ptr)\n\t\t}\n\n\t\t// otherwise default to JSON.\n\t\treturn ctx.ReadJSON(ptr)\n\t}\n}\n\n//  +------------------------------------------------------------+\n//  | Body (raw) Writers                                         |\n//  +------------------------------------------------------------+\n\n// Write writes the data to the connection as part of an HTTP reply.\n//\n// If WriteHeader has not yet been called, Write calls\n// WriteHeader(http.StatusOK) before writing the data. If the Header\n// does not contain a Content-Type line, Write adds a Content-Type set\n// to the result of passing the initial 512 bytes of written data to\n// DetectContentType.\n//\n// Depending on the HTTP protocol version and the client, calling\n// Write or WriteHeader may prevent future reads on the\n// Request.Body. For HTTP/1.x requests, handlers should read any\n// needed request body data before writing the response. Once the\n// headers have been flushed (due to either an explicit Flusher.Flush\n// call or writing enough data to trigger a flush), the request body\n// may be unavailable. For HTTP/2 requests, the Go HTTP server permits\n// handlers to continue to read the request body while concurrently\n// writing the response. However, such behavior may not be supported\n// by all HTTP/2 clients. Handlers should read before writing if\n// possible to maximize compatibility.\nfunc (ctx *Context) Write(rawBody []byte) (int, error) {\n\treturn ctx.writer.Write(rawBody)\n}\n\n// Writef formats according to a format specifier and writes to the response.\n//\n// Returns the number of bytes written and any write error encountered.\nfunc (ctx *Context) Writef(format string, a ...interface{}) (n int, err error) {\n\t/* if len(a) == 0 {\n\t \treturn ctx.WriteString(format)\n\t} ^ No, let it complain about arguments, because go test will do even if the app is running.\n\tUsers should use WriteString instead of (format, args)\n\twhen format may contain go-sprintf reserved chars (e.g. %).*/\n\n\treturn fmt.Fprintf(ctx.writer, format, a...)\n}\n\n// WriteString writes a simple string to the response.\n//\n// Returns the number of bytes written and any write error encountered.\nfunc (ctx *Context) WriteString(body string) (n int, err error) {\n\treturn io.WriteString(ctx.writer, body)\n}\n\nconst (\n\t// ContentTypeHeaderKey is the header key of \"Content-Type\".\n\tContentTypeHeaderKey = \"Content-Type\"\n\n\t// LastModifiedHeaderKey is the header key of \"Last-Modified\".\n\tLastModifiedHeaderKey = \"Last-Modified\"\n\t// IfModifiedSinceHeaderKey is the header key of \"If-Modified-Since\".\n\tIfModifiedSinceHeaderKey = \"If-Modified-Since\"\n\t// CacheControlHeaderKey is the header key of \"Cache-Control\".\n\tCacheControlHeaderKey = \"Cache-Control\"\n\t// ETagHeaderKey is the header key of \"ETag\".\n\tETagHeaderKey = \"ETag\"\n\n\t// ContentDispositionHeaderKey is the header key of \"Content-Disposition\".\n\tContentDispositionHeaderKey = \"Content-Disposition\"\n\t// ContentLengthHeaderKey is the header key of \"Content-Length\"\n\tContentLengthHeaderKey = \"Content-Length\"\n\t// ContentEncodingHeaderKey is the header key of \"Content-Encoding\".\n\tContentEncodingHeaderKey = \"Content-Encoding\"\n\t// GzipHeaderValue is the header value of \"gzip\".\n\tGzipHeaderValue = \"gzip\"\n\t// AcceptEncodingHeaderKey is the header key of \"Accept-Encoding\".\n\tAcceptEncodingHeaderKey = \"Accept-Encoding\"\n\t// VaryHeaderKey is the header key of \"Vary\".\n\tVaryHeaderKey = \"Vary\"\n)\n\nvar unixEpochTime = time.Unix(0, 0)\n\n// IsZeroTime reports whether t is obviously unspecified (either zero or Unix()=0).\nfunc IsZeroTime(t time.Time) bool {\n\treturn t.IsZero() || t.Equal(unixEpochTime)\n}\n\n// ParseTime parses a time header (such as the Date: header),\n// trying each forth formats (or three if Application's configuration's TimeFormat is defaulted)\n// that are allowed by HTTP/1.1:\n// Application's configuration's TimeFormat or/and http.TimeFormat,\n// time.RFC850, and time.ANSIC.\n//\n// Look `context#FormatTime` for the opossite operation (Time to string).\nvar ParseTime = func(ctx *Context, text string) (t time.Time, err error) {\n\tt, err = time.Parse(ctx.Application().ConfigurationReadOnly().GetTimeFormat(), text)\n\tif err != nil {\n\t\treturn http.ParseTime(text)\n\t}\n\n\treturn\n}\n\n// FormatTime returns a textual representation of the time value formatted\n// according to the Application's configuration's TimeFormat field\n// which defines the format.\n//\n// Look `context#ParseTime` for the opossite operation (string to Time).\nvar FormatTime = func(ctx *Context, t time.Time) string {\n\treturn t.Format(ctx.Application().ConfigurationReadOnly().GetTimeFormat())\n}\n\n// SetLastModified sets the \"Last-Modified\" based on the \"modtime\" input.\n// If \"modtime\" is zero then it does nothing.\n//\n// It's mostly internally on core/router and context packages.\nfunc (ctx *Context) SetLastModified(modtime time.Time) {\n\tif !IsZeroTime(modtime) {\n\t\tctx.Header(LastModifiedHeaderKey, FormatTime(ctx, modtime.UTC())) // or modtime.UTC()?\n\t}\n}\n\n// ErrPreconditionFailed may be returned from `Context` methods\n// that has to perform one or more client side preconditions before the actual check, e.g. `CheckIfModifiedSince`.\n// Usage:\n// ok, err := context.CheckIfModifiedSince(modTime)\n// if err != nil {\n//    if errors.Is(err, context.ErrPreconditionFailed) {\n//         [handle missing client conditions,such as not valid request method...]\n//     }else {\n//         [the error is probably a time parse error...]\n//    }\n// }\nvar ErrPreconditionFailed = errors.New(\"precondition failed\")\n\n// CheckIfModifiedSince checks if the response is modified since the \"modtime\".\n// Note that it has nothing to do with server-side caching.\n// It does those checks by checking if the \"If-Modified-Since\" request header\n// sent by client or a previous server response header\n// (e.g with WriteWithExpiration or HandleDir or Favicon etc.)\n// is a valid one and it's before the \"modtime\".\n//\n// A check for !modtime && err == nil is necessary to make sure that\n// it's not modified since, because it may return false but without even\n// had the chance to check the client-side (request) header due to some errors,\n// like the HTTP Method is not \"GET\" or \"HEAD\" or if the \"modtime\" is zero\n// or if parsing time from the header failed. See `ErrPreconditionFailed` too.\n//\n// It's mostly used internally, e.g. `context#WriteWithExpiration`.\nfunc (ctx *Context) CheckIfModifiedSince(modtime time.Time) (bool, error) {\n\tif method := ctx.Method(); method != http.MethodGet && method != http.MethodHead {\n\t\treturn false, fmt.Errorf(\"method: %w\", ErrPreconditionFailed)\n\t}\n\tims := ctx.GetHeader(IfModifiedSinceHeaderKey)\n\tif ims == \"\" || IsZeroTime(modtime) {\n\t\treturn false, fmt.Errorf(\"zero time: %w\", ErrPreconditionFailed)\n\t}\n\tt, err := ParseTime(ctx, ims)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\t// sub-second precision, so\n\t// use mtime < t+1s instead of mtime <= t to check for unmodified.\n\tif modtime.UTC().Before(t.Add(1 * time.Second)) {\n\t\treturn false, nil\n\t}\n\treturn true, nil\n}\n\n// WriteNotModified sends a 304 \"Not Modified\" status code to the client,\n// it makes sure that the content type, the content length headers\n// and any \"ETag\" are removed before the response sent.\n//\n// It's mostly used internally on core/router/fs.go and context methods.\nfunc (ctx *Context) WriteNotModified() {\n\t// RFC 7232 section 4.1:\n\t// a sender SHOULD NOT generate representation metadata other than the\n\t// above listed fields unless said metadata exists for the purpose of\n\t// guiding cache updates (e.g.,\" Last-Modified\" might be useful if the\n\t// response does not have an ETag field).\n\th := ctx.ResponseWriter().Header()\n\tdelete(h, ContentTypeHeaderKey)\n\tdelete(h, ContentLengthHeaderKey)\n\tif h.Get(ETagHeaderKey) != \"\" {\n\t\tdelete(h, LastModifiedHeaderKey)\n\t}\n\tctx.StatusCode(http.StatusNotModified)\n}\n\n// WriteWithExpiration works like `Write` but it will check if a resource is modified,\n// based on the \"modtime\" input argument,\n// otherwise sends a 304 status code in order to let the client-side render the cached content.\nfunc (ctx *Context) WriteWithExpiration(body []byte, modtime time.Time) (int, error) {\n\tif modified, err := ctx.CheckIfModifiedSince(modtime); !modified && err == nil {\n\t\tctx.WriteNotModified()\n\t\treturn 0, nil\n\t}\n\n\tctx.SetLastModified(modtime)\n\treturn ctx.writer.Write(body)\n}\n\n// StreamWriter registers the given stream writer for populating\n// response body.\n//\n// Access to context's and/or its' members is forbidden from writer.\n//\n// This function may be used in the following cases:\n//\n//     * if response body is too big (more than iris.LimitRequestBodySize(if set)).\n//     * if response body is streamed from slow external sources.\n//     * if response body must be streamed to the client in chunks.\n//     (aka `http server push`).\nfunc (ctx *Context) StreamWriter(writer func(w io.Writer) error) error {\n\tcancelCtx := ctx.Request().Context()\n\tnotifyClosed := cancelCtx.Done()\n\n\tfor {\n\t\tselect {\n\t\t// response writer forced to close, exit.\n\t\tcase <-notifyClosed:\n\t\t\treturn cancelCtx.Err()\n\t\tdefault:\n\t\t\tif err := writer(ctx.writer); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tctx.writer.Flush()\n\t\t}\n\t}\n}\n\n//  +------------------------------------------------------------+\n//  | Body Writers with compression                              |\n//  +------------------------------------------------------------+\n\n// ClientSupportsEncoding reports whether the\n// client expects one of the given \"encodings\" compression.\n//\n// Note, this method just reports back the first valid encoding it sees,\n// meaning that request accept-encoding offers don't matter here.\n// See `CompressWriter` too.\nfunc (ctx *Context) ClientSupportsEncoding(encodings ...string) bool {\n\tif len(encodings) == 0 {\n\t\treturn false\n\t}\n\n\tif h := ctx.GetHeader(AcceptEncodingHeaderKey); h != \"\" {\n\t\tfor _, v := range strings.Split(h, \",\") {\n\t\t\tfor _, encoding := range encodings {\n\t\t\t\tif strings.Contains(v, encoding) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}\n\n// CompressWriter enables or disables the compress response writer.\n// if the client expects a valid compression algorithm then this\n// will change the response writer to a compress writer instead.\n// All future write and rich write methods will respect this option.\n// Usage:\n// app.Use(func(ctx iris.Context){\n// \terr := ctx.CompressWriter(true)\n// \tctx.Next()\n// })\n// The recommendation is to compress data as much as possible and therefore to use this field,\n// but some types of resources, such as jpeg images, are already compressed.\n// Sometimes, using additional compression doesn't reduce payload size and\n// can even make the payload longer.\nfunc (ctx *Context) CompressWriter(enable bool) error {\n\tswitch w := ctx.writer.(type) {\n\tcase *CompressResponseWriter:\n\t\tif enable {\n\t\t\treturn nil\n\t\t}\n\n\t\tw.Disabled = true\n\tcase *ResponseRecorder:\n\t\tif enable {\n\t\t\t// If it's a recorder which already wraps the compress, exit.\n\t\t\tif _, ok := w.ResponseWriter.(*CompressResponseWriter); ok {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Keep the Recorder as ctx.writer.\n\t\t\t// Wrap the existing net/http response writer\n\t\t\t// with the compressed writer and\n\t\t\t// replace the recorder's response writer\n\t\t\t// reference with that compressed one.\n\t\t\t// Fixes an issue when Record is called before CompressWriter.\n\t\t\tcw, err := AcquireCompressResponseWriter(w.ResponseWriter, ctx.request, -1)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tw.ResponseWriter = cw\n\t\t} else {\n\t\t\tcw, ok := w.ResponseWriter.(*CompressResponseWriter)\n\t\t\tif ok {\n\t\t\t\tcw.Disabled = true\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tif !enable {\n\t\t\treturn nil\n\t\t}\n\n\t\tcw, err := AcquireCompressResponseWriter(w, ctx.request, -1)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.writer = cw\n\t}\n\n\treturn nil\n}\n\n// CompressReader accepts a boolean, which, if set to true\n// it wraps the request body reader with a reader which decompresses request data before read.\n// If the \"enable\" input argument is false then the request body will reset to the default one.\n//\n// Useful when incoming request data are compressed.\n// All future calls of `ctx.GetBody/ReadXXX/UnmarshalBody` methods will respect this option.\n//\n// Usage:\n// app.Use(func(ctx iris.Context){\n// \terr := ctx.CompressReader(true)\n// \tctx.Next()\n// })\n// More:\n// if cr, ok := ctx.Request().Body.(*CompressReader); ok {\n// \tcr.Src // the original request body\n//  cr.Encoding // the compression algorithm.\n// }\n//\n// It returns `ErrRequestNotCompressed` if client's request data are not compressed\n// (or empty)\n// or `ErrNotSupportedCompression` if server missing the decompression algorithm.\nfunc (ctx *Context) CompressReader(enable bool) error {\n\tcr, ok := ctx.request.Body.(*CompressReader)\n\tif enable {\n\t\tif ok {\n\t\t\t// already called.\n\t\t\treturn nil\n\t\t}\n\n\t\tencoding := ctx.GetHeader(ContentEncodingHeaderKey)\n\t\tif encoding == IDENTITY {\n\t\t\t// no transformation whatsoever, return nil error and\n\t\t\t// don't wrap the body reader.\n\t\t\treturn nil\n\t\t}\n\n\t\tr, err := NewCompressReader(ctx.request.Body, encoding)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.request.Body = r\n\t} else if ok {\n\t\tctx.request.Body = cr.Src\n\t}\n\n\treturn nil\n}\n\n//  +------------------------------------------------------------+\n//  | Rich Body Content Writers/Renderers                        |\n//  +------------------------------------------------------------+\n\n// ViewEngine registers a view engine for the current chain of handlers.\n// It overrides any previously registered engines, including the application's root ones.\n// Note that, because performance is everything,\n// the \"engine\" MUST be already ready-to-use,\n// meaning that its `Load` method should be called once before this method call.\n//\n// To register a view engine per-group of groups too see `Party.RegisterView` instead.\nfunc (ctx *Context) ViewEngine(engine ViewEngine) {\n\tctx.values.Set(ctx.app.ConfigurationReadOnly().GetViewEngineContextKey(), engine)\n}\n\n// ViewLayout sets the \"layout\" option if and when .View\n// is being called afterwards, in the same request.\n// Useful when need to set or/and change a layout based on the previous handlers in the chain.\n//\n// Note that the 'layoutTmplFile' argument can be set to iris.NoLayout\n// to disable the layout for a specific view render action,\n// it disables the engine's configuration's layout property.\n//\n// Look .ViewData and .View too.\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/view/context-view-data/\nfunc (ctx *Context) ViewLayout(layoutTmplFile string) {\n\tctx.values.Set(ctx.app.ConfigurationReadOnly().GetViewLayoutContextKey(), layoutTmplFile)\n}\n\n// ViewData saves one or more key-value pair in order to be passed if and when .View\n// is being called afterwards, in the same request.\n// Useful when need to set or/and change template data from previous hanadlers in the chain.\n//\n// If .View's \"binding\" argument is not nil and it's not a type of map\n// then these data are being ignored, binding has the priority, so the main route's handler can still decide.\n// If binding is a map or iris.Map then these data are being added to the view data\n// and passed to the template.\n//\n// After .View, the data are not destroyed, in order to be re-used if needed (again, in the same request as everything else),\n// to clear the view data, developers can call:\n// ctx.Set(ctx.Application().ConfigurationReadOnly().GetViewDataContextKey(), nil)\n//\n// If 'key' is empty then the value is added as it's (struct or map) and developer is unable to add other value.\n//\n// Look .ViewLayout and .View too.\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/view/context-view-data/\nfunc (ctx *Context) ViewData(key string, value interface{}) {\n\tviewDataContextKey := ctx.app.ConfigurationReadOnly().GetViewDataContextKey()\n\tif key == \"\" {\n\t\tctx.values.Set(viewDataContextKey, value)\n\t\treturn\n\t}\n\n\tv := ctx.values.Get(viewDataContextKey)\n\tif v == nil {\n\t\tctx.values.Set(viewDataContextKey, Map{key: value})\n\t\treturn\n\t}\n\n\tif data, ok := v.(map[string]interface{}); ok {\n\t\tdata[key] = value\n\t} else if data, ok := v.(Map); ok {\n\t\tdata[key] = value\n\t}\n}\n\n// GetViewData returns the values registered by `context#ViewData`.\n// The return value is `map[string]interface{}`, this means that\n// if a custom struct registered to ViewData then this function\n// will try to parse it to map, if failed then the return value is nil\n// A check for nil is always a good practise if different\n// kind of values or no data are registered via `ViewData`.\n//\n// Similarly to `viewData := ctx.Values().Get(\"iris.view.data\")` or\n// `viewData := ctx.Values().Get(ctx.Application().ConfigurationReadOnly().GetViewDataContextKey())`.\nfunc (ctx *Context) GetViewData() map[string]interface{} {\n\tviewDataContextKey := ctx.app.ConfigurationReadOnly().GetViewDataContextKey()\n\tv := ctx.values.Get(viewDataContextKey)\n\n\t// if no values found, then return nil\n\tif v == nil {\n\t\treturn nil\n\t}\n\n\t// if struct, convert it to map[string]interface{}\n\tif structs.IsStruct(v) {\n\t\treturn structs.Map(v)\n\t}\n\n\t// if pure map[string]interface{}\n\tif viewData, ok := v.(map[string]interface{}); ok {\n\t\treturn viewData\n\t}\n\n\t// if context#Map\n\tif viewData, ok := v.(Map); ok {\n\t\treturn viewData\n\t}\n\n\t// if failure, then return nil\n\treturn nil\n}\n\n// FallbackViewProvider is an interface which can be registered to the `Party.FallbackView`\n// or `Context.FallbackView` methods to handle fallback views.\n// See FallbackView, FallbackViewLayout and FallbackViewFunc.\ntype FallbackViewProvider interface {\n\tFallbackView(ctx *Context, err ErrViewNotExist) error\n} /* Notes(@kataras): If ever requested, this fallback logic (of ctx, error) can go to all necessary methods.\n   I've designed with a bit more complexity here instead of a simple filename fallback in order to give\n   the freedom to the developer to do whatever he/she wants with that template/layout not exists error,\n   e.g. have a list of fallbacks views to loop through until succeed or fire a different error than the default.\n   We also provide some helpers for common fallback actions (FallbackView, FallbackViewLayout).\n   This naming was chosen in order to be easy to follow up with the previous view-relative context features.\n   Also note that here we catch a specific error, we want the developer\n   to be aware of the rest template errors (e.g. when a template having parsing issues).\n*/\n\n// FallbackViewFunc is a function that can be registered\n// to handle view fallbacks. It accepts the Context and\n// a special error which contains information about the previous template error.\n// It implements the FallbackViewProvider interface.\n//\n// See `Context.View` method.\ntype FallbackViewFunc func(ctx *Context, err ErrViewNotExist) error\n\n// FallbackView completes the FallbackViewProvider interface.\nfunc (fn FallbackViewFunc) FallbackView(ctx *Context, err ErrViewNotExist) error {\n\treturn fn(ctx, err)\n}\n\nvar (\n\t_ FallbackViewProvider = FallbackView(\"\")\n\t_ FallbackViewProvider = FallbackViewLayout(\"\")\n)\n\n// FallbackView is a helper to register a single template filename as a fallback\n// when the provided tempate filename was not found.\ntype FallbackView string\n\n// FallbackView completes the FallbackViewProvider interface.\nfunc (f FallbackView) FallbackView(ctx *Context, err ErrViewNotExist) error {\n\tif err.IsLayout { // Not responsible to render layouts.\n\t\treturn err\n\t}\n\n\t// ctx.StatusCode(200) // Let's keep the previous status code here, developer can change it anyways.\n\treturn ctx.View(string(f), err.Data)\n}\n\n// FallbackViewLayout is a helper to register a single template filename as a fallback\n// layout when the provided layout filename was not found.\ntype FallbackViewLayout string\n\n// FallbackView completes the FallbackViewProvider interface.\nfunc (f FallbackViewLayout) FallbackView(ctx *Context, err ErrViewNotExist) error {\n\tif !err.IsLayout {\n\t\t// Responsible to render layouts only.\n\t\treturn err\n\t}\n\n\tctx.ViewLayout(string(f))\n\treturn ctx.View(err.Name, err.Data)\n}\n\nconst fallbackViewOnce = \"iris.fallback.view.once\"\n\nfunc (ctx *Context) fireFallbackViewOnce(err ErrViewNotExist) error {\n\t// Note(@kataras): this is our way to keep the same View method for\n\t// both fallback and normal views, remember, we export the whole\n\t// Context functionality to the end-developer through the fallback view provider.\n\tif ctx.values.Get(fallbackViewOnce) != nil {\n\t\treturn err\n\t}\n\n\tv := ctx.values.Get(ctx.app.ConfigurationReadOnly().GetFallbackViewContextKey())\n\tif v == nil {\n\t\treturn err\n\t}\n\n\tproviders, ok := v.([]FallbackViewProvider)\n\tif !ok {\n\t\treturn err\n\t}\n\n\tctx.values.Set(fallbackViewOnce, struct{}{})\n\n\tvar pErr error\n\tfor _, provider := range providers {\n\t\tpErr = provider.FallbackView(ctx, err)\n\t\tif pErr != nil {\n\t\t\tif vErr, ok := pErr.(ErrViewNotExist); ok {\n\t\t\t\t// This fallback view does not exist or it's not responsible to handle,\n\t\t\t\t// try the next.\n\t\t\t\tpErr = vErr\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// If OK then we found the correct fallback.\n\t\t// If the error was a parse error and not a template not found\n\t\t// then exit and report the pErr error.\n\t\tbreak\n\t}\n\n\treturn pErr\n}\n\n// FallbackView registers one or more fallback views for a template or a template layout.\n// When View cannot find the given filename to execute then this \"provider\"\n// is responsible to handle the error or render a different view.\n//\n// Usage:\n//  FallbackView(iris.FallbackView(\"fallback.html\"))\n//  FallbackView(iris.FallbackViewLayout(\"layouts/fallback.html\"))\n//  OR\n//  FallbackView(iris.FallbackViewFunc(ctx iris.Context, err iris.ErrViewNotExist) error {\n//    err.Name is the previous template name.\n//    err.IsLayout reports whether the failure came from the layout template.\n//    err.Data is the template data provided to the previous View call.\n//    [...custom logic e.g. ctx.View(\"fallback\", err.Data)]\n//  })\nfunc (ctx *Context) FallbackView(providers ...FallbackViewProvider) {\n\tkey := ctx.app.ConfigurationReadOnly().GetFallbackViewContextKey()\n\tif key == \"\" {\n\t\treturn\n\t}\n\n\tv := ctx.values.Get(key)\n\tif v == nil {\n\t\tctx.values.Set(key, providers)\n\t\treturn\n\t}\n\n\t// Can register more than one.\n\tstoredProviders, ok := v.([]FallbackViewProvider)\n\tif !ok {\n\t\treturn\n\t}\n\n\tstoredProviders = append(storedProviders, providers...)\n\tctx.values.Set(key, storedProviders)\n}\n\n// View renders a template based on the registered view engine(s).\n// First argument accepts the filename, relative to the view engine's Directory and Extension,\n// i.e: if directory is \"./templates\" and want to render the \"./templates/users/index.html\"\n// then you pass the \"users/index.html\" as the filename argument.\n//\n// The second optional argument can receive a single \"view model\".\n// If \"optionalViewModel\" exists, even if it's nil, overrides any previous `ViewData` calls.\n// If second argument is missing then binds the data through previous `ViewData` calls (e.g. middleware).\n//\n// Look .ViewData and .ViewLayout too.\n//\n// Examples: https://github.com/kataras/iris/tree/master/_examples/view\nfunc (ctx *Context) View(filename string, optionalViewModel ...interface{}) error {\n\tctx.ContentType(ContentHTMLHeaderValue)\n\n\terr := ctx.renderView(filename, optionalViewModel...)\n\tif errNotExists, ok := err.(ErrViewNotExist); ok {\n\t\terr = ctx.fireFallbackViewOnce(errNotExists)\n\t}\n\n\tif err != nil {\n\t\tif ctx.app.Logger().Level == golog.DebugLevel {\n\t\t\t// send the error back to the client, when debug mode.\n\t\t\tctx.StopWithError(http.StatusInternalServerError, err)\n\t\t} else {\n\t\t\tctx.StopWithStatus(http.StatusInternalServerError)\n\t\t}\n\t}\n\n\treturn err\n}\n\nfunc (ctx *Context) renderView(filename string, optionalViewModel ...interface{}) error {\n\tcfg := ctx.app.ConfigurationReadOnly()\n\tlayout := ctx.values.GetString(cfg.GetViewLayoutContextKey())\n\n\tvar bindingData interface{}\n\tif len(optionalViewModel) > 0 /* Don't do it: can break a lot of servers: && optionalViewModel[0] != nil */ {\n\t\t// a nil can override the existing data or model sent by `ViewData`.\n\t\tbindingData = optionalViewModel[0]\n\t} else {\n\t\tbindingData = ctx.values.Get(cfg.GetViewDataContextKey())\n\t}\n\n\tif key := cfg.GetViewEngineContextKey(); key != \"\" {\n\t\tif engineV := ctx.values.Get(key); engineV != nil {\n\t\t\tif engine, ok := engineV.(ViewEngine); ok {\n\t\t\t\treturn engine.ExecuteWriter(ctx, filename, layout, bindingData)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ctx.app.View(ctx, filename, layout, bindingData)\n}\n\nconst (\n\t// ContentBinaryHeaderValue header value for binary data.\n\tContentBinaryHeaderValue = \"application/octet-stream\"\n\t// ContentWebassemblyHeaderValue header value for web assembly files.\n\tContentWebassemblyHeaderValue = \"application/wasm\"\n\t// ContentHTMLHeaderValue is the  string of text/html response header's content type value.\n\tContentHTMLHeaderValue = \"text/html\"\n\t// ContentJSONHeaderValue header value for JSON data.\n\tContentJSONHeaderValue = \"application/json\"\n\t// ContentJSONProblemHeaderValue header value for JSON API problem error.\n\t// Read more at: https://tools.ietf.org/html/rfc7807\n\tContentJSONProblemHeaderValue = \"application/problem+json\"\n\t// ContentXMLProblemHeaderValue header value for XML API problem error.\n\t// Read more at: https://tools.ietf.org/html/rfc7807\n\tContentXMLProblemHeaderValue = \"application/problem+xml\"\n\t// ContentJavascriptHeaderValue header value for JSONP & Javascript data.\n\tContentJavascriptHeaderValue = \"text/javascript\"\n\t// ContentTextHeaderValue header value for Text data.\n\tContentTextHeaderValue = \"text/plain\"\n\t// ContentXMLHeaderValue header value for XML data.\n\tContentXMLHeaderValue = \"text/xml\"\n\t// ContentXMLUnreadableHeaderValue obselete header value for XML.\n\tContentXMLUnreadableHeaderValue = \"application/xml\"\n\t// ContentMarkdownHeaderValue custom key/content type, the real is the text/html.\n\tContentMarkdownHeaderValue = \"text/markdown\"\n\t// ContentYAMLHeaderValue header value for YAML data.\n\tContentYAMLHeaderValue = \"application/x-yaml\"\n\t// ContentYAMLTextHeaderValue header value for YAML plain text.\n\tContentYAMLTextHeaderValue = \"text/yaml\"\n\t// ContentProtobufHeaderValue header value for Protobuf messages data.\n\tContentProtobufHeaderValue = \"application/x-protobuf\"\n\t// ContentMsgPackHeaderValue header value for MsgPack data.\n\tContentMsgPackHeaderValue = \"application/msgpack\"\n\t// ContentMsgPack2HeaderValue alternative header value for MsgPack data.\n\tContentMsgPack2HeaderValue = \"application/x-msgpack\"\n\t// ContentFormHeaderValue header value for post form data.\n\tContentFormHeaderValue = \"application/x-www-form-urlencoded\"\n\t// ContentFormMultipartHeaderValue header value for post multipart form data.\n\tContentFormMultipartHeaderValue = \"multipart/form-data\"\n\t// ContentGRPCHeaderValue Content-Type header value for gRPC.\n\tContentGRPCHeaderValue = \"application/grpc\"\n)\n\n// Binary writes out the raw bytes as binary data.\nfunc (ctx *Context) Binary(data []byte) (int, error) {\n\tctx.ContentType(ContentBinaryHeaderValue)\n\treturn ctx.Write(data)\n}\n\n// Text writes out a string as plain text.\nfunc (ctx *Context) Text(format string, args ...interface{}) (int, error) {\n\tctx.ContentType(ContentTextHeaderValue)\n\treturn ctx.Writef(format, args...)\n}\n\n// HTML writes out a string as text/html.\nfunc (ctx *Context) HTML(format string, args ...interface{}) (int, error) {\n\tctx.ContentType(ContentHTMLHeaderValue)\n\treturn ctx.Writef(format, args...)\n}\n\n// ProtoMarshalOptions is a type alias for protojson.MarshalOptions.\ntype ProtoMarshalOptions = protojson.MarshalOptions\n\n// JSON contains the options for the JSON (Context's) Renderer.\ntype JSON struct {\n\t// http-specific\n\tStreamingJSON bool\n\t// content-specific\n\tUnescapeHTML bool\n\tIndent       string\n\tPrefix       string\n\tASCII        bool // if true writes with unicode to ASCII content.\n\tSecure       bool // if true then it prepends a \"while(1);\" when Go slice (to JSON Array) value.\n\t// proto.Message specific marshal options.\n\tProto ProtoMarshalOptions\n}\n\n// JSONP contains the options for the JSONP (Context's) Renderer.\ntype JSONP struct {\n\t// content-specific\n\tIndent   string\n\tCallback string\n}\n\n// XML contains the options for the XML (Context's) Renderer.\ntype XML struct {\n\t// content-specific\n\tIndent string\n\tPrefix string\n}\n\n// Markdown contains the options for the Markdown (Context's) Renderer.\ntype Markdown struct {\n\t// content-specific\n\tSanitize bool\n}\n\nvar (\n\tnewLineB = []byte(\"\\n\")\n\t// the html codes for unescaping.\n\tltHex = []byte(\"\\\\u003c\")\n\tlt    = []byte(\"<\")\n\n\tgtHex = []byte(\"\\\\u003e\")\n\tgt    = []byte(\">\")\n\n\tandHex = []byte(\"\\\\u0026\")\n\tand    = []byte(\"&\")\n\n\t// secure JSON.\n\tjsonArrayPrefix  = []byte(\"[\")\n\tjsonArraySuffix  = []byte(\"]\")\n\tsecureJSONPrefix = []byte(\"while(1);\")\n)\n\n// WriteJSON marshals the given interface object and writes the JSON response to the 'writer'.\n// Ignores StatusCode and StreamingJSON options.\nfunc WriteJSON(writer io.Writer, v interface{}, options JSON, optimize bool) (int, error) {\n\tvar (\n\t\tresult []byte\n\t\terr    error\n\t)\n\n\tif m, ok := v.(proto.Message); ok {\n\t\tresult, err = options.Proto.Marshal(m)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\treturn writer.Write(result)\n\t}\n\n\tif easyObject, ok := v.(easyjson.Marshaler); ok {\n\t\tjw := jwriter.Writer{NoEscapeHTML: !options.UnescapeHTML}\n\t\teasyObject.MarshalEasyJSON(&jw)\n\t\treturn jw.DumpTo(writer)\n\t}\n\n\tif !optimize && options.Indent == \"\" {\n\t\toptions.Indent = \"  \"\n\t}\n\n\tif indent := options.Indent; indent != \"\" {\n\t\tmarshalIndent := json.MarshalIndent\n\t\tif optimize {\n\t\t\tmarshalIndent = jsoniter.ConfigCompatibleWithStandardLibrary.MarshalIndent\n\t\t}\n\n\t\tresult, err = marshalIndent(v, \"\", indent)\n\t\tresult = append(result, newLineB...)\n\t} else {\n\t\tmarshal := json.Marshal\n\t\tif optimize {\n\t\t\tmarshal = jsoniter.ConfigCompatibleWithStandardLibrary.Marshal\n\t\t}\n\n\t\tresult, err = marshal(v)\n\t}\n\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tprependSecure := false\n\tif options.Secure {\n\t\tif bytes.HasPrefix(result, jsonArrayPrefix) {\n\t\t\tif options.Indent == \"\" {\n\t\t\t\tprependSecure = bytes.HasSuffix(result, jsonArraySuffix)\n\t\t\t} else {\n\t\t\t\tprependSecure = bytes.HasSuffix(bytes.TrimRightFunc(result, func(r rune) bool {\n\t\t\t\t\treturn r == '\\n' || r == '\\r'\n\t\t\t\t}), jsonArraySuffix)\n\t\t\t}\n\t\t}\n\t}\n\n\tif options.UnescapeHTML {\n\t\tresult = bytes.ReplaceAll(result, ltHex, lt)\n\t\tresult = bytes.ReplaceAll(result, gtHex, gt)\n\t\tresult = bytes.ReplaceAll(result, andHex, and)\n\t}\n\n\tif prependSecure {\n\t\tresult = append(secureJSONPrefix, result...)\n\t}\n\n\tif options.ASCII {\n\t\tif len(result) > 0 {\n\t\t\tbuf := new(bytes.Buffer)\n\t\t\tfor _, s := range bytesToString(result) {\n\t\t\t\tchar := string(s)\n\t\t\t\tif s >= 128 {\n\t\t\t\t\tchar = fmt.Sprintf(\"\\\\u%04x\", int64(s))\n\t\t\t\t}\n\t\t\t\tbuf.WriteString(char)\n\t\t\t}\n\n\t\t\tresult = buf.Bytes()\n\t\t}\n\t}\n\n\tif prefix := options.Prefix; prefix != \"\" {\n\t\tresult = append(stringToBytes(prefix), result...)\n\t}\n\n\treturn writer.Write(result)\n}\n\n// See https://golang.org/src/strings/builder.go#L45\nfunc bytesToString(b []byte) string {\n\treturn *(*string)(unsafe.Pointer(&b))\n}\n\nfunc stringToBytes(s string) []byte {\n\treturn *(*[]byte)(unsafe.Pointer(&s))\n}\n\n// DefaultJSONOptions is the optional settings that are being used\n// inside `ctx.JSON`.\nvar DefaultJSONOptions = JSON{}\n\n// JSON marshals the given interface object and writes the JSON response to the client.\n// If the value is a compatible `proto.Message` one\n// then it only uses the options.Proto settings to marshal.\nfunc (ctx *Context) JSON(v interface{}, opts ...JSON) (n int, err error) {\n\toptions := DefaultJSONOptions\n\n\tif len(opts) > 0 {\n\t\toptions = opts[0]\n\t}\n\n\tctx.ContentType(ContentJSONHeaderValue)\n\n\tif options.StreamingJSON {\n\t\tif ctx.shouldOptimize() {\n\t\t\tjsoniterConfig := jsoniter.Config{\n\t\t\t\tEscapeHTML:    !options.UnescapeHTML,\n\t\t\t\tIndentionStep: 4,\n\t\t\t}.Froze()\n\t\t\tenc := jsoniterConfig.NewEncoder(ctx.writer)\n\t\t\terr = enc.Encode(v)\n\t\t} else {\n\t\t\tenc := json.NewEncoder(ctx.writer)\n\t\t\tenc.SetEscapeHTML(!options.UnescapeHTML)\n\t\t\tenc.SetIndent(options.Prefix, options.Indent)\n\t\t\terr = enc.Encode(v)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tctx.app.Logger().Debugf(\"JSON: %v\", err)\n\t\t\tctx.StatusCode(http.StatusInternalServerError) // it handles the fallback to normal mode here which also removes any compression headers.\n\t\t\treturn 0, err\n\t\t}\n\t\treturn ctx.writer.Written(), err\n\t}\n\n\tn, err = WriteJSON(ctx.writer, v, options, ctx.shouldOptimize())\n\tif err != nil {\n\t\tctx.app.Logger().Debugf(\"JSON: %v\", err)\n\t\tctx.StatusCode(http.StatusInternalServerError)\n\t\treturn 0, err\n\t}\n\n\treturn n, err\n}\n\nvar finishCallbackB = []byte(\");\")\n\n// WriteJSONP marshals the given interface object and writes the JSON response to the writer.\nfunc WriteJSONP(writer io.Writer, v interface{}, options JSONP, optimize bool) (int, error) {\n\tif callback := options.Callback; callback != \"\" {\n\t\tn, err := writer.Write(stringToBytes(callback + \"(\"))\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\t\tdefer writer.Write(finishCallbackB)\n\t}\n\n\tif !optimize && options.Indent == \"\" {\n\t\toptions.Indent = \"    \"\n\t}\n\n\tif indent := options.Indent; indent != \"\" {\n\t\tmarshalIndent := json.MarshalIndent\n\t\tif optimize {\n\t\t\tmarshalIndent = jsoniter.ConfigCompatibleWithStandardLibrary.MarshalIndent\n\t\t}\n\n\t\tresult, err := marshalIndent(v, \"\", indent)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tresult = append(result, newLineB...)\n\t\treturn writer.Write(result)\n\t}\n\n\tmarshal := json.Marshal\n\tif optimize {\n\t\tmarshal = jsoniter.ConfigCompatibleWithStandardLibrary.Marshal\n\t}\n\n\tresult, err := marshal(v)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn writer.Write(result)\n}\n\n// DefaultJSONPOptions is the optional settings that are being used\n// inside `ctx.JSONP`.\nvar DefaultJSONPOptions = JSONP{}\n\n// JSONP marshals the given interface object and writes the JSON response to the client.\nfunc (ctx *Context) JSONP(v interface{}, opts ...JSONP) (int, error) {\n\toptions := DefaultJSONPOptions\n\n\tif len(opts) > 0 {\n\t\toptions = opts[0]\n\t}\n\n\tctx.ContentType(ContentJavascriptHeaderValue)\n\n\tn, err := WriteJSONP(ctx.writer, v, options, ctx.shouldOptimize())\n\tif err != nil {\n\t\tctx.app.Logger().Debugf(\"JSONP: %v\", err)\n\t\tctx.StatusCode(http.StatusInternalServerError)\n\t\treturn 0, err\n\t}\n\n\treturn n, err\n}\n\ntype xmlMapEntry struct {\n\tXMLName xml.Name\n\tValue   interface{} `xml:\",chardata\"`\n}\n\n// XMLMap wraps a map[string]interface{} to compatible xml marshaler,\n// in order to be able to render maps as XML on the `Context.XML` method.\n//\n// Example: `Context.XML(XMLMap(\"Root\", map[string]interface{}{...})`.\nfunc XMLMap(elementName string, v Map) xml.Marshaler {\n\treturn xmlMap{\n\t\tentries:     v,\n\t\telementName: elementName,\n\t}\n}\n\ntype xmlMap struct {\n\tentries     Map\n\telementName string\n}\n\n// MarshalXML marshals a map to XML.\nfunc (m xmlMap) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n\tif len(m.entries) == 0 {\n\t\treturn nil\n\t}\n\n\tstart.Name = xml.Name{Local: m.elementName}\n\terr := e.EncodeToken(start)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor k, v := range m.entries {\n\t\terr = e.Encode(xmlMapEntry{XMLName: xml.Name{Local: k}, Value: v})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn e.EncodeToken(start.End())\n}\n\n// WriteXML marshals the given interface object and writes the XML response to the writer.\nfunc WriteXML(writer io.Writer, v interface{}, options XML, optimize bool) (int, error) {\n\tif prefix := options.Prefix; prefix != \"\" {\n\t\tn, err := writer.Write(stringToBytes(prefix))\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\t}\n\n\tif !optimize && options.Indent == \"\" {\n\t\toptions.Indent = \"  \" // Two spaces for XML is the default indentation when not optimized.\n\t}\n\n\tif indent := options.Indent; indent != \"\" {\n\t\tresult, err := xml.MarshalIndent(v, \"\", indent)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tresult = append(result, newLineB...)\n\t\treturn writer.Write(result)\n\t}\n\n\tresult, err := xml.Marshal(v)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn writer.Write(result)\n}\n\n// DefaultXMLOptions is the optional settings that are being used\n// from `ctx.XML`.\nvar DefaultXMLOptions = XML{}\n\n// XML marshals the given interface object and writes the XML response to the client.\n// To render maps as XML see the `XMLMap` package-level function.\nfunc (ctx *Context) XML(v interface{}, opts ...XML) (int, error) {\n\toptions := DefaultXMLOptions\n\n\tif len(opts) > 0 {\n\t\toptions = opts[0]\n\t}\n\n\tctx.ContentType(ContentXMLHeaderValue)\n\n\tn, err := WriteXML(ctx.writer, v, options, ctx.shouldOptimize())\n\tif err != nil {\n\t\tctx.app.Logger().Debugf(\"XML: %v\", err)\n\t\tctx.StatusCode(http.StatusInternalServerError)\n\t\treturn 0, err\n\t}\n\n\treturn n, err\n}\n\n// Problem writes a JSON or XML problem response.\n// Order of Problem fields are not always rendered the same.\n//\n// Behaves exactly like `Context.JSON`\n// but with default ProblemOptions.JSON indent of \" \" and\n// a response content type of \"application/problem+json\" instead.\n//\n// Use the options.RenderXML and XML fields to change this behavior and\n// send a response of content type \"application/problem+xml\" instead.\n//\n// Read more at: https://github.com/kataras/iris/wiki/Routing-error-handlers\nfunc (ctx *Context) Problem(v interface{}, opts ...ProblemOptions) (int, error) {\n\toptions := DefaultProblemOptions\n\tif len(opts) > 0 {\n\t\toptions = opts[0]\n\t\t// Currently apply only if custom options passsed, otherwise,\n\t\t// with the current settings, it's not required.\n\t\t// This may change in the future though.\n\t\toptions.Apply(ctx)\n\t}\n\n\tif p, ok := v.(Problem); ok {\n\t\t// if !p.Validate() {\n\t\t// \tctx.StatusCode(http.StatusInternalServerError)\n\t\t// \treturn ErrNotValidProblem\n\t\t// }\n\t\tp.updateURIsToAbs(ctx)\n\t\tcode, _ := p.getStatus()\n\t\tif code == 0 { // get the current status code and set it to the problem.\n\t\t\tcode = ctx.GetStatusCode()\n\t\t\tctx.StatusCode(code)\n\t\t} else {\n\t\t\t// send the problem's status code\n\t\t\tctx.StatusCode(code)\n\t\t}\n\n\t\tif options.RenderXML {\n\t\t\tctx.contentTypeOnce(ContentXMLProblemHeaderValue, \"\")\n\t\t\t// Problem is an xml Marshaler already, don't use `XMLMap`.\n\t\t\treturn ctx.XML(v, options.XML)\n\t\t}\n\t}\n\n\tctx.contentTypeOnce(ContentJSONProblemHeaderValue, \"\")\n\treturn ctx.JSON(v, options.JSON)\n}\n\n// WriteMarkdown parses the markdown to html and writes these contents to the writer.\nfunc WriteMarkdown(writer io.Writer, markdownB []byte, options Markdown) (int, error) {\n\tbuf := blackfriday.Run(markdownB)\n\tif options.Sanitize {\n\t\tbuf = bluemonday.UGCPolicy().SanitizeBytes(buf)\n\t}\n\treturn writer.Write(buf)\n}\n\n// DefaultMarkdownOptions is the optional settings that are being used\n// from `WriteMarkdown` and `ctx.Markdown`.\nvar DefaultMarkdownOptions = Markdown{}\n\n// Markdown parses the markdown to html and renders its result to the client.\nfunc (ctx *Context) Markdown(markdownB []byte, opts ...Markdown) (int, error) {\n\toptions := DefaultMarkdownOptions\n\n\tif len(opts) > 0 {\n\t\toptions = opts[0]\n\t}\n\n\tctx.ContentType(ContentHTMLHeaderValue)\n\n\tn, err := WriteMarkdown(ctx.writer, markdownB, options)\n\tif err != nil {\n\t\tctx.app.Logger().Debugf(\"Markdown: %v\", err)\n\t\tctx.StatusCode(http.StatusInternalServerError)\n\t\treturn 0, err\n\t}\n\n\treturn n, err\n}\n\n// YAML marshals the \"v\" using the yaml marshaler\n// and sends the result to the client.\nfunc (ctx *Context) YAML(v interface{}) (int, error) {\n\tout, err := yaml.Marshal(v)\n\tif err != nil {\n\t\tctx.app.Logger().Debugf(\"YAML: %v\", err)\n\t\tctx.StatusCode(http.StatusInternalServerError)\n\t\treturn 0, err\n\t}\n\n\tctx.ContentType(ContentYAMLHeaderValue)\n\treturn ctx.Write(out)\n}\n\n// TextYAML marshals the \"v\" using the yaml marshaler\n// and renders to the client.\nfunc (ctx *Context) TextYAML(v interface{}) (int, error) {\n\tctx.contentTypeOnce(ContentYAMLTextHeaderValue, \"\")\n\treturn ctx.YAML(v)\n}\n\n// Protobuf parses the \"v\" of proto Message and renders its result to the client.\nfunc (ctx *Context) Protobuf(v proto.Message) (int, error) {\n\tout, err := proto.Marshal(v)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tctx.ContentType(ContentProtobufHeaderValue)\n\treturn ctx.Write(out)\n}\n\n// MsgPack parses the \"v\" of msgpack format and renders its result to the client.\nfunc (ctx *Context) MsgPack(v interface{}) (int, error) {\n\tout, err := msgpack.Marshal(v)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tctx.ContentType(ContentMsgPackHeaderValue)\n\treturn ctx.Write(out)\n}\n\n//  +-----------------------------------------------------------------------+\n//  | Content \u039degotiation                                                   |\n//  | https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation |                                       |\n//  +-----------------------------------------------------------------------+\n\n// ErrContentNotSupported returns from the `Negotiate` method\n// when server responds with 406.\nvar ErrContentNotSupported = errors.New(\"unsupported content\")\n\n// ContentSelector is the interface which structs can implement\n// to manually choose a content based on the negotiated mime (content type).\n// It can be passed to the `Context.Negotiate` method.\n//\n// See the `N` struct too.\ntype ContentSelector interface {\n\tSelectContent(mime string) interface{}\n}\n\n// ContentNegotiator is the interface which structs can implement\n// to override the `Context.Negotiate` default implementation and\n// manually respond to the client based on a manuall call of `Context.Negotiation().Build()`\n// to get the final negotiated mime and charset.\n// It can be passed to the `Context.Negotiate` method.\ntype ContentNegotiator interface {\n\t// mime and charset can be retrieved by:\n\t// mime, charset := Context.Negotiation().Build()\n\t// Pass this method to `Context.Negotiate` method\n\t// to write custom content.\n\t// Overriding the existing behavior of Context.Negotiate for selecting values based on\n\t// content types, although it can accept any custom mime type with []byte.\n\t// Content type is already set.\n\t// Use it with caution, 99.9% you don't need this but it's here for extreme cases.\n\tNegotiate(ctx *Context) (int, error)\n}\n\n// N is a struct which can be passed on the `Context.Negotiate` method.\n// It contains fields which should be filled based on the `Context.Negotiation()`\n// server side values. If no matched mime then its \"Other\" field will be sent,\n// which should be a string or []byte.\n// It completes the `ContentSelector` interface.\ntype N struct {\n\tText, HTML string\n\tMarkdown   []byte\n\tBinary     []byte\n\n\tJSON     interface{}\n\tProblem  Problem\n\tJSONP    interface{}\n\tXML      interface{}\n\tYAML     interface{}\n\tProtobuf interface{}\n\tMsgPack  interface{}\n\n\tOther []byte // custom content types.\n}\n\nvar _ ContentSelector = N{}\n\n// SelectContent returns a content based on the matched negotiated \"mime\".\nfunc (n N) SelectContent(mime string) interface{} {\n\tswitch mime {\n\tcase ContentTextHeaderValue:\n\t\treturn n.Text\n\tcase ContentHTMLHeaderValue:\n\t\treturn n.HTML\n\tcase ContentMarkdownHeaderValue:\n\t\treturn n.Markdown\n\tcase ContentBinaryHeaderValue:\n\t\treturn n.Binary\n\tcase ContentJSONHeaderValue:\n\t\treturn n.JSON\n\tcase ContentJSONProblemHeaderValue:\n\t\treturn n.Problem\n\tcase ContentJavascriptHeaderValue:\n\t\treturn n.JSONP\n\tcase ContentXMLHeaderValue, ContentXMLUnreadableHeaderValue:\n\t\treturn n.XML\n\tcase ContentYAMLHeaderValue:\n\t\treturn n.YAML\n\tcase ContentProtobufHeaderValue:\n\t\treturn n.Protobuf\n\tcase ContentMsgPackHeaderValue, ContentMsgPack2HeaderValue:\n\t\treturn n.MsgPack\n\tdefault:\n\t\treturn n.Other\n\t}\n}\n\nconst negotiationContextKey = \"iris.negotiation_builder\"\n\n// Negotiation creates once and returns the negotiation builder\n// to build server-side available prioritized content\n// for specific content type(s), charset(s) and encoding algorithm(s).\n//\n// See `Negotiate` method too.\nfunc (ctx *Context) Negotiation() *NegotiationBuilder {\n\tif n := ctx.values.Get(negotiationContextKey); n != nil {\n\t\treturn n.(*NegotiationBuilder)\n\t}\n\n\tacceptBuilder := NegotiationAcceptBuilder{}\n\tacceptBuilder.accept = parseHeader(ctx.GetHeader(\"Accept\"))\n\tacceptBuilder.charset = parseHeader(ctx.GetHeader(\"Accept-Charset\"))\n\n\tn := &NegotiationBuilder{Accept: acceptBuilder}\n\n\tctx.values.Set(negotiationContextKey, n)\n\n\treturn n\n}\n\nfunc parseHeader(headerValue string) []string {\n\tin := strings.Split(headerValue, \",\")\n\tout := make([]string, 0, len(in))\n\n\tfor _, value := range in {\n\t\t// remove any spaces and quality values such as ;q=0.8.\n\t\tv := strings.TrimSpace(strings.Split(value, \";\")[0])\n\t\tif v != \"\" {\n\t\t\tout = append(out, v)\n\t\t}\n\t}\n\n\treturn out\n}\n\n// Negotiate used for serving different representations of a resource at the same URI.\n//\n// The \"v\" can be a single `N` struct value.\n// The \"v\" can be any value completes the `ContentSelector` interface.\n// The \"v\" can be any value completes the `ContentNegotiator` interface.\n// The \"v\" can be any value of struct(JSON, JSONP, XML, YAML, Protobuf, MsgPack) or\n// string(TEXT, HTML) or []byte(Markdown, Binary) or []byte with any matched mime type.\n//\n// If the \"v\" is nil, the `Context.Negotitation()` builder's\n// content will be used instead, otherwise \"v\" overrides builder's content\n// (server mime types are still retrieved by its registered, supported, mime list)\n//\n// Set mime type priorities by `Negotiation().JSON().XML().HTML()...`.\n// Set charset priorities by `Negotiation().Charset(...)`.\n// Set encoding algorithm priorities by `Negotiation().Encoding(...)`.\n// Modify the accepted by\n// `Negotiation().Accept./Override()/.XML().JSON().Charset(...).Encoding(...)...`.\n//\n// It returns `ErrContentNotSupported` when not matched mime type(s).\n//\n// Resources:\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Charset\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding\n//\n// Supports the above without quality values.\n//\n// Read more at: https://github.com/kataras/iris/wiki/Content-negotiation\nfunc (ctx *Context) Negotiate(v interface{}) (int, error) {\n\tcontentType, charset, encoding, content := ctx.Negotiation().Build()\n\tif v == nil {\n\t\tv = content\n\t}\n\n\tif contentType == \"\" {\n\t\t// If the server cannot serve any matching set,\n\t\t// it SHOULD send back a 406 (Not Acceptable) error code.\n\t\tctx.StatusCode(http.StatusNotAcceptable)\n\t\treturn -1, ErrContentNotSupported\n\t}\n\n\tif charset == \"\" {\n\t\tcharset = ctx.app.ConfigurationReadOnly().GetCharset()\n\t}\n\n\tif encoding != \"\" {\n\t\tctx.CompressWriter(true)\n\t}\n\n\tctx.contentTypeOnce(contentType, charset)\n\n\tif n, ok := v.(ContentNegotiator); ok {\n\t\treturn n.Negotiate(ctx)\n\t}\n\n\tif s, ok := v.(ContentSelector); ok {\n\t\tv = s.SelectContent(contentType)\n\t}\n\n\t// switch v := value.(type) {\n\t// case []byte:\n\t// \tif contentType == ContentMarkdownHeaderValue {\n\t// \t\treturn ctx.Markdown(v)\n\t// \t}\n\n\t// \treturn ctx.Write(v)\n\t// case string:\n\t// \treturn ctx.WriteString(v)\n\t// default:\n\t// make it switch by content-type only, but we lose custom mime types capability that way:\n\t//                                                 ^ solved with []byte on default case and\n\t//                                                 ^ N.Other and\n\t//                                                 ^ ContentSelector and ContentNegotiator interfaces.\n\n\tswitch contentType {\n\tcase ContentTextHeaderValue, ContentHTMLHeaderValue:\n\t\treturn ctx.WriteString(v.(string))\n\tcase ContentMarkdownHeaderValue:\n\t\treturn ctx.Markdown(v.([]byte))\n\tcase ContentJSONHeaderValue:\n\t\treturn ctx.JSON(v)\n\tcase ContentJSONProblemHeaderValue, ContentXMLProblemHeaderValue:\n\t\treturn ctx.Problem(v)\n\tcase ContentJavascriptHeaderValue:\n\t\treturn ctx.JSONP(v)\n\tcase ContentXMLHeaderValue, ContentXMLUnreadableHeaderValue:\n\t\treturn ctx.XML(v)\n\tcase ContentYAMLHeaderValue:\n\t\treturn ctx.YAML(v)\n\tcase ContentYAMLTextHeaderValue:\n\t\treturn ctx.TextYAML(v)\n\tcase ContentProtobufHeaderValue:\n\t\tmsg, ok := v.(proto.Message)\n\t\tif !ok {\n\t\t\treturn -1, ErrContentNotSupported\n\t\t}\n\n\t\treturn ctx.Protobuf(msg)\n\tcase ContentMsgPackHeaderValue, ContentMsgPack2HeaderValue:\n\t\treturn ctx.MsgPack(v)\n\tdefault:\n\t\t// maybe \"Other\" or v is []byte or string but not a built-in framework mime,\n\t\t// for custom content types,\n\t\t// panic if not correct usage.\n\t\tswitch vv := v.(type) {\n\t\tcase []byte:\n\t\t\treturn ctx.Write(vv)\n\t\tcase string:\n\t\t\treturn ctx.WriteString(vv)\n\t\tdefault:\n\t\t\tctx.StatusCode(http.StatusNotAcceptable)\n\t\t\treturn -1, ErrContentNotSupported\n\t\t}\n\t}\n}\n\n// NegotiationBuilder returns from the `Context.Negotitation`\n// and can be used inside chain of handlers to build server-side\n// mime type(s), charset(s) and encoding algorithm(s)\n// that should match with the client's\n// Accept, Accept-Charset and Accept-Encoding headers (by-default).\n// To modify the client's accept use its \"Accept\" field\n// which it's the `NegotitationAcceptBuilder`.\n//\n// See the `Negotiate` method too.\ntype NegotiationBuilder struct {\n\tAccept NegotiationAcceptBuilder\n\n\tmime     []string               // we need order.\n\tcontents map[string]interface{} // map to the \"mime\" and content should be rendered if that mime requested.\n\tcharset  []string\n\tencoding []string\n}\n\n// MIME registers a mime type and optionally the value that should be rendered\n// through `Context.Negotiate` when this mime type is accepted by client.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) MIME(mime string, content interface{}) *NegotiationBuilder {\n\tmimes := parseHeader(mime) // if contains more than one sep by commas \",\".\n\tif content == nil {\n\t\tn.mime = append(n.mime, mimes...)\n\t\treturn n\n\t}\n\n\tif n.contents == nil {\n\t\tn.contents = make(map[string]interface{})\n\t}\n\n\tfor _, m := range mimes {\n\t\tn.mime = append(n.mime, m)\n\t\tn.contents[m] = content\n\t}\n\n\treturn n\n}\n\n// Text registers the \"text/plain\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"text/plain\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Text(v ...string) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentTextHeaderValue, content)\n}\n\n// HTML registers the \"text/html\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"text/html\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) HTML(v ...string) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentHTMLHeaderValue, content)\n}\n\n// Markdown registers the \"text/markdown\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"text/markdown\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Markdown(v ...[]byte) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v\n\t}\n\treturn n.MIME(ContentMarkdownHeaderValue, content)\n}\n\n// Binary registers the \"application/octet-stream\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"application/octet-stream\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Binary(v ...[]byte) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentBinaryHeaderValue, content)\n}\n\n// JSON registers the \"application/json\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"application/json\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) JSON(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentJSONHeaderValue, content)\n}\n\n// Problem registers the \"application/problem+json\" or \"application/problem+xml\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"application/problem+json\" or the \"application/problem+xml\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Problem(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentJSONProblemHeaderValue+\",\"+ContentXMLProblemHeaderValue, content)\n}\n\n// JSONP registers the \"text/javascript\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"javascript/javascript\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) JSONP(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentJavascriptHeaderValue, content)\n}\n\n// XML registers the \"text/xml\" and \"application/xml\" content types and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts one of the \"text/xml\" or \"application/xml\" content types.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) XML(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentXMLHeaderValue+\",\"+ContentXMLUnreadableHeaderValue, content)\n}\n\n// YAML registers the \"application/x-yaml\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"application/x-yaml\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) YAML(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentYAMLHeaderValue, content)\n}\n\n// TextYAML registers the \"text/yaml\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"application/x-yaml\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) TextYAML(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentYAMLTextHeaderValue, content)\n}\n\n// Protobuf registers the \"application/x-protobuf\" content type and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts the \"application/x-protobuf\" content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Protobuf(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentProtobufHeaderValue, content)\n}\n\n// MsgPack registers the \"application/x-msgpack\" and \"application/msgpack\" content types and, optionally,\n// a value that `Context.Negotiate` will render\n// when a client accepts one of the \"application/x-msgpack\" or \"application/msgpack\" content types.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) MsgPack(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(ContentMsgPackHeaderValue+\",\"+ContentMsgPack2HeaderValue, content)\n}\n\n// Any registers a wildcard that can match any client's accept content type.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Any(v ...interface{}) *NegotiationBuilder {\n\tvar content interface{}\n\tif len(v) > 0 {\n\t\tcontent = v[0]\n\t}\n\treturn n.MIME(\"*\", content)\n}\n\n// Charset overrides the application's config's charset (which defaults to \"utf-8\")\n// that a client should match for\n// (through Accept-Charset header or custom through `NegotitationBuilder.Accept.Override().Charset(...)` call).\n// Do not set it if you don't know what you're doing.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Charset(charset ...string) *NegotiationBuilder {\n\tn.charset = append(n.charset, charset...)\n\treturn n\n}\n\n// Encoding registers one or more encoding algorithms by name, i.e gzip, deflate, br, snappy, s2.\n// that a client should match for (through Accept-Encoding header).\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) Encoding(encoding ...string) *NegotiationBuilder {\n\tn.encoding = append(n.encoding, encoding...)\n\treturn n\n}\n\n// EncodingGzip registers the \"gzip\" encoding algorithm\n// that a client should match for (through Accept-Encoding header or call of Accept.Encoding(enc)).\n//\n// It will make resources to served by \"gzip\" if Accept-Encoding contains the \"gzip\" as well.\n//\n// Returns itself for recursive calls.\nfunc (n *NegotiationBuilder) EncodingGzip() *NegotiationBuilder {\n\treturn n.Encoding(GzipHeaderValue)\n}\n\n// Build calculates the client's and server's mime type(s), charset(s) and encoding\n// and returns the final content type, charset and encoding that server should render\n// to the client. It does not clear the fields, use the `Clear` method if neeeded.\n//\n// The returned \"content\" can be nil if the matched \"contentType\" does not provide any value,\n// in that case the `Context.Negotiate(v)` must be called with a non-nil value.\nfunc (n *NegotiationBuilder) Build() (contentType, charset, encoding string, content interface{}) {\n\tcontentType = negotiationMatch(n.Accept.accept, n.mime)\n\tcharset = negotiationMatch(n.Accept.charset, n.charset)\n\tencoding = negotiationMatch(n.Accept.encoding, n.encoding)\n\n\tif n.contents != nil {\n\t\tif data, ok := n.contents[contentType]; ok {\n\t\t\tcontent = data\n\t\t}\n\t}\n\n\treturn\n}\n\n// Clear clears the prioritized mime type(s), charset(s) and any contents\n// relative to those mime type(s).\n// The \"Accept\" field is stay as it is, use its `Override` method\n// to clear out the client's accepted mime type(s) and charset(s).\nfunc (n *NegotiationBuilder) Clear() *NegotiationBuilder {\n\tn.mime = n.mime[0:0]\n\tn.contents = nil\n\tn.charset = n.charset[0:0]\n\treturn n\n}\n\n// NegotiationAcceptBuilder builds the accepted mime types and charset\n//\n// and \"Accept-Charset\" headers respectfully.\n// The default values are set by the client side, server can append or override those.\n// The end result will be challenged with runtime preffered set of content types and charsets.\n//\n// See the `Negotiate` method too.\ntype NegotiationAcceptBuilder struct {\n\t// initialized with \"Accept\" request header values.\n\taccept []string\n\t// initialized with \"Accept-Charset\" request header. and if was empty then the\n\t// application's default (which defaults to utf-8).\n\tcharset []string\n\t// initialized with \"Accept-Encoding\" request header values.\n\tencoding []string\n\n\t// To support override in request life cycle.\n\t// We need slice when data is the same format\n\t// for one or more mime types,\n\t// i.e text/xml and obselete application/xml.\n\tlastAccept   []string\n\tlastCharset  []string\n\tlastEncoding []string\n}\n\n// Override clears the default values for accept and accept charset.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Override() *NegotiationAcceptBuilder {\n\t// when called first.\n\tn.accept = n.accept[0:0]\n\tn.charset = n.charset[0:0]\n\tn.encoding = n.encoding[0:0]\n\n\t// when called after.\n\tif len(n.lastAccept) > 0 {\n\t\tn.accept = append(n.accept, n.lastAccept...)\n\t\tn.lastAccept = n.lastAccept[0:0]\n\t}\n\n\tif len(n.lastCharset) > 0 {\n\t\tn.charset = append(n.charset, n.lastCharset...)\n\t\tn.lastCharset = n.lastCharset[0:0]\n\t}\n\n\tif len(n.lastEncoding) > 0 {\n\t\tn.encoding = append(n.encoding, n.lastEncoding...)\n\t\tn.lastEncoding = n.lastEncoding[0:0]\n\t}\n\n\treturn n\n}\n\n// MIME adds accepted client's mime type(s).\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) MIME(mimeType ...string) *NegotiationAcceptBuilder {\n\tn.lastAccept = mimeType\n\tn.accept = append(n.accept, mimeType...)\n\treturn n\n}\n\n// Text adds the \"text/plain\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Text() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentTextHeaderValue)\n}\n\n// HTML adds the \"text/html\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) HTML() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentHTMLHeaderValue)\n}\n\n// Markdown adds the \"text/markdown\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Markdown() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentMarkdownHeaderValue)\n}\n\n// Binary adds the \"application/octet-stream\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Binary() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentBinaryHeaderValue)\n}\n\n// JSON adds the \"application/json\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) JSON() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentJSONHeaderValue)\n}\n\n// Problem adds the \"application/problem+json\" and \"application/problem-xml\"\n// as accepted client content types.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Problem() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentJSONProblemHeaderValue, ContentXMLProblemHeaderValue)\n}\n\n// JSONP adds the \"text/javascript\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) JSONP() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentJavascriptHeaderValue)\n}\n\n// XML adds the \"text/xml\" and \"application/xml\" as accepted client content types.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) XML() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentXMLHeaderValue, ContentXMLUnreadableHeaderValue)\n}\n\n// YAML adds the \"application/x-yaml\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) YAML() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentYAMLHeaderValue)\n}\n\n// TextYAML adds the \"text/yaml\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) TextYAML() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentYAMLTextHeaderValue)\n}\n\n// Protobuf adds the \"application/x-protobuf\" as accepted client content type.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Protobuf() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentYAMLHeaderValue)\n}\n\n// MsgPack adds the \"application/msgpack\" and \"application/x-msgpack\" as accepted client content types.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) MsgPack() *NegotiationAcceptBuilder {\n\treturn n.MIME(ContentYAMLHeaderValue)\n}\n\n// Charset adds one or more client accepted charsets.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Charset(charset ...string) *NegotiationAcceptBuilder {\n\tn.lastCharset = charset\n\tn.charset = append(n.charset, charset...)\n\n\treturn n\n}\n\n// Encoding adds one or more client accepted encoding algorithms.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) Encoding(encoding ...string) *NegotiationAcceptBuilder {\n\tn.lastEncoding = encoding\n\tn.encoding = append(n.encoding, encoding...)\n\n\treturn n\n}\n\n// EncodingGzip adds the \"gzip\" as accepted encoding.\n// Returns itself.\nfunc (n *NegotiationAcceptBuilder) EncodingGzip() *NegotiationAcceptBuilder {\n\treturn n.Encoding(GzipHeaderValue)\n}\n\n//  +------------------------------------------------------------+\n//  | Serve files                                                |\n//  +------------------------------------------------------------+\n\n// ServeContent replies to the request using the content in the\n// provided ReadSeeker. The main benefit of ServeContent over io.Copy\n// is that it handles Range requests properly, sets the MIME type, and\n// handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\n// and If-Range requests.\n//\n// If the response's Content-Type header is not set, ServeContent\n// first tries to deduce the type from name's file extension.\n//\n// The name is otherwise unused; in particular it can be empty and is\n// never sent in the response.\n//\n// If modtime is not the zero time or Unix epoch, ServeContent\n// includes it in a Last-Modified header in the response. If the\n// request includes an If-Modified-Since header, ServeContent uses\n// modtime to decide whether the content needs to be sent at all.\n//\n// The content's Seek method must work: ServeContent uses\n// a seek to the end of the content to determine its size.\n//\n// If the caller has set w's ETag header formatted per RFC 7232, section 2.3,\n// ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n//\n// Note that *os.File implements the io.ReadSeeker interface.\n// Note that compression can be registered\n// through `ctx.CompressWriter(true)` or `app.Use(iris.Compression)`.\nfunc (ctx *Context) ServeContent(content io.ReadSeeker, filename string, modtime time.Time) {\n\tctx.ServeContentWithRate(content, filename, modtime, 0, 0)\n}\n\n// rateReadSeeker is a io.ReadSeeker that is rate limited by\n// the given token bucket. Each token in the bucket\n// represents one byte. See \"golang.org/x/time/rate\" package.\ntype rateReadSeeker struct {\n\tio.ReadSeeker\n\tctx     stdContext.Context\n\tlimiter *rate.Limiter\n}\n\nfunc (rs *rateReadSeeker) Read(buf []byte) (int, error) {\n\tn, err := rs.ReadSeeker.Read(buf)\n\tif n <= 0 {\n\t\treturn n, err\n\t}\n\terr = rs.limiter.WaitN(rs.ctx, n)\n\treturn n, err\n}\n\n// ServeContentWithRate same as `ServeContent` but it can throttle the speed of reading\n// and though writing the \"content\" to the client.\nfunc (ctx *Context) ServeContentWithRate(content io.ReadSeeker, filename string, modtime time.Time, limit float64, burst int) {\n\tif limit > 0 {\n\t\tcontent = &rateReadSeeker{\n\t\t\tReadSeeker: content,\n\t\t\tctx:        ctx.request.Context(),\n\t\t\tlimiter:    rate.NewLimiter(rate.Limit(limit), burst),\n\t\t}\n\t}\n\n\tif ctx.GetContentType() == \"\" {\n\t\tctx.ContentType(filename)\n\t}\n\n\thttp.ServeContent(ctx.writer, ctx.request, filename, modtime, content)\n}\n\n// ServeFile replies to the request with the contents of the named\n// file or directory.\n//\n// If the provided file or directory name is a relative path, it is\n// interpreted relative to the current directory and may ascend to\n// parent directories. If the provided name is constructed from user\n// input, it should be sanitized before calling `ServeFile`.\n//\n// Use it when you want to serve assets like css and javascript files.\n// If client should confirm and save the file use the `SendFile` instead.\n// Note that compression can be registered\n// through `ctx.CompressWriter(true)` or `app.Use(iris.Compression)`.\nfunc (ctx *Context) ServeFile(filename string) error {\n\treturn ctx.ServeFileWithRate(filename, 0, 0)\n}\n\n// ServeFileWithRate same as `ServeFile` but it can throttle the speed of reading\n// and though writing the file to the client.\nfunc (ctx *Context) ServeFileWithRate(filename string, limit float64, burst int) error {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\tctx.StatusCode(http.StatusNotFound)\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tst, err := f.Stat()\n\tif err != nil {\n\t\tcode := http.StatusInternalServerError\n\t\tif os.IsNotExist(err) {\n\t\t\tcode = http.StatusNotFound\n\t\t}\n\n\t\tif os.IsPermission(err) {\n\t\t\tcode = http.StatusForbidden\n\t\t}\n\n\t\tctx.StatusCode(code)\n\t\treturn err\n\t}\n\n\tif st.IsDir() {\n\t\treturn ctx.ServeFile(path.Join(filename, \"index.html\"))\n\t}\n\n\tctx.ServeContentWithRate(f, st.Name(), st.ModTime(), limit, burst)\n\treturn nil\n}\n\n// SendFile sends a file as an attachment, that is downloaded and saved locally from client.\n// Note that compression can be registered\n// through `ctx.CompressWriter(true)` or `app.Use(iris.Compression)`.\n// Use `ServeFile` if a file should be served as a page asset instead.\nfunc (ctx *Context) SendFile(src string, destName string) error {\n\treturn ctx.SendFileWithRate(src, destName, 0, 0)\n}\n\n// SendFileWithRate same as `SendFile` but it can throttle the speed of reading\n// and though writing the file to the client.\nfunc (ctx *Context) SendFileWithRate(src, destName string, limit float64, burst int) error {\n\tif destName == \"\" {\n\t\tdestName = filepath.Base(src)\n\t}\n\n\tctx.writer.Header().Set(ContentDispositionHeaderKey, \"attachment;filename=\"+destName)\n\treturn ctx.ServeFileWithRate(src, limit, burst)\n}\n\n//  +------------------------------------------------------------+\n//  | Cookies                                                    |\n//  +------------------------------------------------------------+\n\n// Set of Cookie actions for `CookieOption`.\nconst (\n\tOpCookieGet uint8 = iota\n\tOpCookieSet\n\tOpCookieDel\n)\n\n// CookieOption is the type of function that is accepted on\n// context's methods like `SetCookieKV`, `RemoveCookie` and `SetCookie`\n// as their (last) variadic input argument to amend the to-be-sent cookie.\n//\n// The \"op\" is the operation code, 0 is GET, 1 is SET and 2 is REMOVE.\ntype CookieOption func(ctx *Context, c *http.Cookie, op uint8)\n\n// CookieIncluded reports whether the \"cookie.Name\" is in the list of \"cookieNames\".\n// Notes:\n// If \"cookieNames\" slice is empty then it returns true,\n// If \"cookie.Name\" is empty then it returns false.\nfunc CookieIncluded(cookie *http.Cookie, cookieNames []string) bool {\n\tif cookie.Name == \"\" {\n\t\treturn false\n\t}\n\n\tif len(cookieNames) > 0 {\n\t\tfor _, name := range cookieNames {\n\t\t\tif cookie.Name == name {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nvar cookieNameSanitizer = strings.NewReplacer(\"\\n\", \"-\", \"\\r\", \"-\")\n\nfunc sanitizeCookieName(n string) string {\n\treturn cookieNameSanitizer.Replace(n)\n}\n\n// CookieAllowReclaim accepts the Context itself.\n// If set it will add the cookie to (on `CookieSet`, `CookieSetKV`, `CookieUpsert`)\n// or remove the cookie from (on `CookieRemove`) the Request object too.\nfunc CookieAllowReclaim(cookieNames ...string) CookieOption {\n\treturn func(ctx *Context, c *http.Cookie, op uint8) {\n\t\tif op == OpCookieGet {\n\t\t\treturn\n\t\t}\n\n\t\tif !CookieIncluded(c, cookieNames) {\n\t\t\treturn\n\t\t}\n\n\t\tswitch op {\n\t\tcase OpCookieSet:\n\t\t\t// perform upsert on request cookies or is it too much and not worth the cost?\n\t\t\tctx.Request().AddCookie(c)\n\t\tcase OpCookieDel:\n\t\t\theader := ctx.Request().Header\n\n\t\t\tif cookiesLine := header.Get(\"Cookie\"); cookiesLine != \"\" {\n\t\t\t\tif cookies := strings.Split(cookiesLine, \"; \"); len(cookies) > 1 {\n\t\t\t\t\t// more than one cookie here.\n\t\t\t\t\t// select that one and remove it.\n\t\t\t\t\tname := sanitizeCookieName(c.Name)\n\n\t\t\t\t\tfor _, nameValue := range cookies {\n\t\t\t\t\t\tif strings.HasPrefix(nameValue, name) {\n\t\t\t\t\t\t\tcookiesLine = strings.Replace(cookiesLine, \"; \"+nameValue, \"\", 1)\n\t\t\t\t\t\t\t// current cookiesLine: myapp_session_id=5ccf4e89-8d0e-4ed6-9f4c-6746d7c5e2ee; key1=value1\n\t\t\t\t\t\t\t// found nameValue: key1=value1\n\t\t\t\t\t\t\t// new cookiesLine: myapp_session_id=5ccf4e89-8d0e-4ed6-9f4c-6746d7c5e2ee\n\t\t\t\t\t\t\theader.Set(\"Cookie\", cookiesLine)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\theader.Del(\"Cookie\")\n\t\t}\n\t}\n}\n\n// CookieAllowSubdomains set to the Cookie Options\n// in order to allow subdomains to have access to the cookies.\n// It sets the cookie's Domain field (if was empty) and\n// it also sets the cookie's SameSite to lax mode too.\nfunc CookieAllowSubdomains(cookieNames ...string) CookieOption {\n\treturn func(ctx *Context, c *http.Cookie, _ uint8) {\n\t\tif c.Domain != \"\" {\n\t\t\treturn // already set.\n\t\t}\n\n\t\tif !CookieIncluded(c, cookieNames) {\n\t\t\treturn\n\t\t}\n\n\t\tc.Domain = ctx.Domain()\n\t\tc.SameSite = http.SameSiteLaxMode // allow subdomain sharing.\n\t}\n}\n\n// CookieSameSite sets a same-site rule for cookies to set.\n// SameSite allows a server to define a cookie attribute making it impossible for\n// the browser to send this cookie along with cross-site requests. The main\n// goal is to mitigate the risk of cross-origin information leakage, and provide\n// some protection against cross-site request forgery attacks.\n//\n// See https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00 for details.\nfunc CookieSameSite(sameSite http.SameSite) CookieOption {\n\treturn func(_ *Context, c *http.Cookie, op uint8) {\n\t\tif op == OpCookieSet {\n\t\t\tc.SameSite = sameSite\n\t\t}\n\t}\n}\n\n// CookieSecure sets the cookie's Secure option if the current request's\n// connection is using TLS. See `CookieHTTPOnly` too.\nfunc CookieSecure(ctx *Context, c *http.Cookie, op uint8) {\n\tif op == OpCookieSet {\n\t\tif ctx.Request().TLS != nil {\n\t\t\tc.Secure = true\n\t\t}\n\t}\n}\n\n// CookieHTTPOnly is a `CookieOption`.\n// Use it to set the cookie's HttpOnly field to false or true.\n// HttpOnly field defaults to true for `RemoveCookie` and `SetCookieKV`.\n// See `CookieSecure` too.\nfunc CookieHTTPOnly(httpOnly bool) CookieOption {\n\treturn func(_ *Context, c *http.Cookie, op uint8) {\n\t\tif op == OpCookieSet {\n\t\t\tc.HttpOnly = httpOnly\n\t\t}\n\t}\n}\n\n// CookiePath is a `CookieOption`.\n// Use it to change the cookie's Path field.\nfunc CookiePath(path string) CookieOption {\n\treturn func(_ *Context, c *http.Cookie, op uint8) {\n\t\tif op > OpCookieGet { // on set and remove.\n\t\t\tc.Path = path\n\t\t}\n\t}\n}\n\n// CookieCleanPath is a `CookieOption`.\n// Use it to clear the cookie's Path field, exactly the same as `CookiePath(\"\")`.\nfunc CookieCleanPath(_ *Context, c *http.Cookie, op uint8) {\n\tif op > OpCookieGet {\n\t\tc.Path = \"\"\n\t}\n}\n\n// CookieExpires is a `CookieOption`.\n// Use it to change the cookie's Expires and MaxAge fields by passing the lifetime of the cookie.\nfunc CookieExpires(durFromNow time.Duration) CookieOption {\n\treturn func(_ *Context, c *http.Cookie, op uint8) {\n\t\tif op == OpCookieSet {\n\t\t\tc.Expires = time.Now().Add(durFromNow)\n\t\t\tc.MaxAge = int(durFromNow.Seconds())\n\t\t}\n\t}\n}\n\n// SecureCookie should encodes and decodes\n// authenticated and optionally encrypted cookie values.\n// See `CookieEncoding` package-level function.\ntype SecureCookie interface {\n\t// Encode should encode the cookie value.\n\t// Should accept the cookie's name as its first argument\n\t// and as second argument the cookie value ptr.\n\t// Should return an encoded value or an empty one if encode operation failed.\n\t// Should return an error if encode operation failed.\n\t//\n\t// Note: Errors are not printed, so you have to know what you're doing,\n\t// and remember: if you use AES it only supports key sizes of 16, 24 or 32 bytes.\n\t// You either need to provide exactly that amount or you derive the key from what you type in.\n\t//\n\t// See `Decode` too.\n\tEncode(cookieName string, cookieValue interface{}) (string, error)\n\t// Decode should decode the cookie value.\n\t// Should accept the cookie's name as its first argument,\n\t// as second argument the encoded cookie value and as third argument the decoded value ptr.\n\t// Should return a decoded value or an empty one if decode operation failed.\n\t// Should return an error if decode operation failed.\n\t//\n\t// Note: Errors are not printed, so you have to know what you're doing,\n\t// and remember: if you use AES it only supports key sizes of 16, 24 or 32 bytes.\n\t// You either need to provide exactly that amount or you derive the key from what you type in.\n\t//\n\t// See `Encode` too.\n\tDecode(cookieName string, cookieValue string, cookieValuePtr interface{}) error\n}\n\n// CookieEncoding accepts a value which implements `Encode` and `Decode` methods.\n// It calls its `Encode` on `Context.SetCookie, UpsertCookie, and SetCookieKV` methods.\n// And on `Context.GetCookie` method it calls its `Decode`.\n// If \"cookieNames\" slice is not empty then only cookies\n// with that `Name` will be encoded on set and decoded on get, that way you can encrypt\n// specific cookie names (like the session id) and let the rest of the cookies \"insecure\".\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/cookies/securecookie\nfunc CookieEncoding(encoding SecureCookie, cookieNames ...string) CookieOption {\n\treturn func(_ *Context, c *http.Cookie, op uint8) {\n\t\tif op == OpCookieDel {\n\t\t\treturn\n\t\t}\n\n\t\tif !CookieIncluded(c, cookieNames) {\n\t\t\treturn\n\t\t}\n\n\t\tswitch op {\n\t\tcase OpCookieSet:\n\t\t\t// Should encode, it's a write to the client operation.\n\t\t\tnewVal, err := encoding.Encode(c.Name, c.Value)\n\t\t\tif err != nil {\n\t\t\t\tc.Value = \"\"\n\t\t\t} else {\n\t\t\t\tc.Value = newVal\n\t\t\t}\n\t\t\treturn\n\t\tcase OpCookieGet:\n\t\t\t// Should decode, it's a read from the client operation.\n\t\t\tif err := encoding.Decode(c.Name, c.Value, &c.Value); err != nil {\n\t\t\t\tc.Value = \"\"\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst cookieOptionsContextKey = \"iris.cookie.options\"\n\n// AddCookieOptions adds cookie options for `SetCookie`,\n// `SetCookieKV, UpsertCookie` and `RemoveCookie` methods\n// for the current request. It can be called from a middleware before\n// cookies sent or received from the next Handler in the chain.\n//\n// Available builtin Cookie options are:\n//  * CookieAllowReclaim\n//  * CookieAllowSubdomains\n//  * CookieSecure\n//  * CookieHTTPOnly\n//  * CookieSameSite\n//  * CookiePath\n//  * CookieCleanPath\n//  * CookieExpires\n//  * CookieEncoding\n//\n// Example at: https://github.com/kataras/iris/tree/master/_examples/cookies/securecookie\nfunc (ctx *Context) AddCookieOptions(options ...CookieOption) {\n\tif len(options) == 0 {\n\t\treturn\n\t}\n\n\tif v := ctx.values.Get(cookieOptionsContextKey); v != nil {\n\t\tif opts, ok := v.([]CookieOption); ok {\n\t\t\toptions = append(opts, options...)\n\t\t}\n\t}\n\n\tctx.values.Set(cookieOptionsContextKey, options)\n}\n\nfunc (ctx *Context) applyCookieOptions(c *http.Cookie, op uint8, override []CookieOption) {\n\tif v := ctx.values.Get(cookieOptionsContextKey); v != nil {\n\t\tif options, ok := v.([]CookieOption); ok {\n\t\t\tfor _, opt := range options {\n\t\t\t\topt(ctx, c, op)\n\t\t\t}\n\t\t}\n\t}\n\n\t// The function's ones should be called last, so they can override\n\t// the stored ones (i.e by a prior middleware).\n\tfor _, opt := range override {\n\t\topt(ctx, c, op)\n\t}\n}\n\n// ClearCookieOptions clears any previously registered cookie options.\n// See `AddCookieOptions` too.\nfunc (ctx *Context) ClearCookieOptions() {\n\tctx.values.Remove(cookieOptionsContextKey)\n}\n\n// SetCookie adds a cookie.\n// Use of the \"options\" is not required, they can be used to amend the \"cookie\".\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/cookies/basic\nfunc (ctx *Context) SetCookie(cookie *http.Cookie, options ...CookieOption) {\n\tctx.applyCookieOptions(cookie, OpCookieSet, options)\n\thttp.SetCookie(ctx.writer, cookie)\n}\n\nconst setCookieHeaderKey = \"Set-Cookie\"\n\n// UpsertCookie adds a cookie to the response like `SetCookie` does\n// but it will also perform a replacement of the cookie\n// if already set by a previous `SetCookie` call.\n// It reports whether the cookie is new (true) or an existing one was updated (false).\nfunc (ctx *Context) UpsertCookie(cookie *http.Cookie, options ...CookieOption) bool {\n\tctx.applyCookieOptions(cookie, OpCookieSet, options)\n\n\theader := ctx.ResponseWriter().Header()\n\n\tif cookies := header[setCookieHeaderKey]; len(cookies) > 0 {\n\t\ts := cookie.Name + \"=\" // name=?value\n\t\tfor i, c := range cookies {\n\t\t\tif strings.HasPrefix(c, s) {\n\t\t\t\t// We need to update the Set-Cookie (to update the expiration or any other cookie's properties).\n\t\t\t\t// Probably the cookie is set and then updated in the first session creation\n\t\t\t\t// (e.g. UpdateExpiration, see https://github.com/kataras/iris/issues/1485).\n\t\t\t\tcookies[i] = cookie.String()\n\t\t\t\theader[setCookieHeaderKey] = cookies\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\n\theader.Add(setCookieHeaderKey, cookie.String())\n\treturn true\n}\n\n// SetCookieKVExpiration is 365 days by-default\n// you can change it or simple, use the SetCookie for more control.\n//\n// See `CookieExpires` and `AddCookieOptions` for more.\nvar SetCookieKVExpiration = 8760 * time.Hour\n\n// SetCookieKV adds a cookie, requires the name(string) and the value(string).\n//\n// By default it expires after 365 days and it is added to the root URL path,\n// use the `CookieExpires` and `CookiePath` to modify them.\n// Alternatively: ctx.SetCookie(&http.Cookie{...}) or ctx.AddCookieOptions(...)\n//\n// If you want to set custom the path:\n// ctx.SetCookieKV(name, value, iris.CookiePath(\"/custom/path/cookie/will/be/stored\"))\n//\n// If you want to be visible only to current request path:\n// (note that client should be responsible for that if server sent an empty cookie's path, all browsers are compatible)\n// ctx.SetCookieKV(name, value, iris.CookieCleanPath/iris.CookiePath(\"\"))\n// More:\n//                              iris.CookieExpires(time.Duration)\n//                              iris.CookieHTTPOnly(false)\n//\n// Examples: https://github.com/kataras/iris/tree/master/_examples/cookies/basic\nfunc (ctx *Context) SetCookieKV(name, value string, options ...CookieOption) {\n\tc := &http.Cookie{}\n\tc.Path = \"/\"\n\tc.Name = name\n\tc.Value = url.QueryEscape(value)\n\tc.HttpOnly = true\n\n\t// MaxAge=0 means no 'Max-Age' attribute specified.\n\t// MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'\n\t// MaxAge>0 means Max-Age attribute present and given in seconds\n\tc.Expires = time.Now().Add(SetCookieKVExpiration)\n\tc.MaxAge = int(time.Until(c.Expires).Seconds())\n\n\tctx.SetCookie(c, options...)\n}\n\n// GetCookie returns cookie's value by its name\n// returns empty string if nothing was found.\n//\n// If you want more than the value then:\n// cookie, err := ctx.Request().Cookie(\"name\")\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/cookies/basic\nfunc (ctx *Context) GetCookie(name string, options ...CookieOption) string {\n\tc, err := ctx.request.Cookie(name)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\n\tctx.applyCookieOptions(c, OpCookieGet, options)\n\n\tvalue, _ := url.QueryUnescape(c.Value)\n\treturn value\n}\n\nvar (\n\t// CookieExpireDelete may be set on Cookie.Expire for expiring the given cookie.\n\tCookieExpireDelete = time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)\n\n\t// CookieExpireUnlimited indicates that does expires after 24 years.\n\tCookieExpireUnlimited = time.Now().AddDate(24, 10, 10)\n)\n\n// RemoveCookie deletes a cookie by its name and path = \"/\".\n// Tip: change the cookie's path to the current one by: RemoveCookie(\"name\", iris.CookieCleanPath)\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/cookies/basic\nfunc (ctx *Context) RemoveCookie(name string, options ...CookieOption) {\n\tc := &http.Cookie{}\n\tc.Name = name\n\tc.Value = \"\"\n\tc.Path = \"/\" // if user wants to change it, use of the CookieOption `CookiePath` is required if not `ctx.SetCookie`.\n\tc.HttpOnly = true\n\n\t// RFC says 1 second, but let's do it 1  to make sure is working\n\tc.Expires = CookieExpireDelete\n\tc.MaxAge = -1\n\n\tctx.applyCookieOptions(c, OpCookieDel, options)\n\thttp.SetCookie(ctx.writer, c)\n}\n\n// VisitAllCookies takes a visitor function which is called\n// on each (request's) cookies' name and value.\nfunc (ctx *Context) VisitAllCookies(visitor func(name string, value string)) {\n\tfor _, cookie := range ctx.request.Cookies() {\n\t\tvisitor(cookie.Name, cookie.Value)\n\t}\n}\n\nvar maxAgeExp = regexp.MustCompile(`maxage=(\\d+)`)\n\n// MaxAge returns the \"cache-control\" request header's value\n// seconds as int64\n// if header not found or parse failed then it returns -1.\nfunc (ctx *Context) MaxAge() int64 {\n\theader := ctx.GetHeader(CacheControlHeaderKey)\n\tif header == \"\" {\n\t\treturn -1\n\t}\n\tm := maxAgeExp.FindStringSubmatch(header)\n\tif len(m) == 2 {\n\t\tif v, err := strconv.Atoi(m[1]); err == nil {\n\t\t\treturn int64(v)\n\t\t}\n\t}\n\treturn -1\n}\n\n//  +------------------------------------------------------------+\n//  | Advanced: Response Recorder and Transactions               |\n//  +------------------------------------------------------------+\n\n// Record transforms the context's basic and direct responseWriter to a *ResponseRecorder\n// which can be used to reset the body, reset headers, get the body,\n// get & set the status code at any time and more.\nfunc (ctx *Context) Record() {\n\tswitch w := ctx.writer.(type) {\n\tcase *ResponseRecorder:\n\tdefault:\n\t\trecorder := AcquireResponseRecorder()\n\t\trecorder.BeginRecord(w)\n\t\tctx.ResetResponseWriter(recorder)\n\t}\n}\n\n// Recorder returns the context's ResponseRecorder\n// if not recording then it starts recording and returns the new context's ResponseRecorder\nfunc (ctx *Context) Recorder() *ResponseRecorder {\n\tctx.Record()\n\treturn ctx.writer.(*ResponseRecorder)\n}\n\n// IsRecording returns the response recorder and a true value\n// when the response writer is recording the status code, body, headers and so on,\n// else returns nil and false.\nfunc (ctx *Context) IsRecording() (*ResponseRecorder, bool) {\n\t// NOTE:\n\t// two return values in order to minimize the if statement:\n\t// if (Recording) then writer = Recorder()\n\t// instead we do: recorder,ok = Recording()\n\trr, ok := ctx.writer.(*ResponseRecorder)\n\treturn rr, ok\n}\n\n// ErrTransactionInterrupt can be used to manually force-complete a Context's transaction\n// and log(warn) the wrapped error's message.\n// Usage: `... return fmt.Errorf(\"my custom error message: %w\", context.ErrTransactionInterrupt)`.\nvar ErrTransactionInterrupt = errors.New(\"transaction interrupted\")\n\n// BeginTransaction starts a scoped transaction.\n//\n// Can't say a lot here because it will take more than 200 lines to write about.\n// You can search third-party articles or books on how Business Transaction works (it's quite simple, especially here).\n//\n// Note that this is unique and new\n// (=I haver never seen any other examples or code in Golang on this subject, so far, as with the most of iris features...)\n// it's not covers all paths,\n// such as databases, this should be managed by the libraries you use to make your database connection,\n// this transaction scope is only for context's response.\n// Transactions have their own middleware ecosystem also.\n//\n// See https://github.com/kataras/iris/tree/master/_examples/ for more\nfunc (ctx *Context) BeginTransaction(pipe func(t *Transaction)) {\n\t// do NOT begin a transaction when the previous transaction has been failed\n\t// and it was requested scoped or SkipTransactions called manually.\n\tif ctx.TransactionsSkipped() {\n\t\treturn\n\t}\n\n\t// start recording in order to be able to control the full response writer\n\tctx.Record()\n\n\tt := newTransaction(ctx) // it calls this *context, so the overriding with a new pool's New of context.Context wil not work here.\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tctx.app.Logger().Warn(fmt.Errorf(\"recovery from panic: %w\", ErrTransactionInterrupt))\n\t\t\t// complete (again or not , doesn't matters) the scope without loud\n\t\t\tt.Complete(nil)\n\t\t\t// we continue as normal, no need to return here*\n\t\t}\n\n\t\t// write the temp contents to the original writer\n\t\tt.Context().ResponseWriter().CopyTo(ctx.writer)\n\t\t// give back to the transaction the original writer (SetBeforeFlush works this way and only this way)\n\t\t// this is tricky but nessecery if we want ctx.FireStatusCode to work inside transactions\n\t\tt.Context().ResetResponseWriter(ctx.writer)\n\t}()\n\n\t// run the worker with its context clone inside.\n\tpipe(t)\n}\n\n// skipTransactionsContextKey set this to any value to stop executing next transactions\n// it's a context-key in order to be used from anywhere, set it by calling the SkipTransactions()\nconst skipTransactionsContextKey = \"iris.transactions.skip\"\n\n// SkipTransactions if called then skip the rest of the transactions\n// or all of them if called before the first transaction\nfunc (ctx *Context) SkipTransactions() {\n\tctx.values.Set(skipTransactionsContextKey, 1)\n}\n\n// TransactionsSkipped returns true if the transactions skipped or canceled at all.\nfunc (ctx *Context) TransactionsSkipped() bool {\n\tif n, err := ctx.values.GetInt(skipTransactionsContextKey); err == nil && n == 1 {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Exec calls the framewrok's ServeHTTPC\n// based on this context but with a changed method and path\n// like it was requested by the user, but it is not.\n//\n// Offline means that the route is registered to the iris and have all features that a normal route has\n// BUT it isn't available by browsing, its handlers executed only when other handler's context call them\n// it can validate paths, has sessions, path parameters and all.\n//\n// You can find the Route by app.GetRoute(\"theRouteName\")\n// you can set a route name as: myRoute := app.Get(\"/mypath\", handler)(\"theRouteName\")\n// that will set a name to the route and returns its RouteInfo instance for further usage.\n//\n// It doesn't changes the global state, if a route was \"offline\" it remains offline.\n//\n// app.None(...) and app.GetRoutes().Offline(route)/.Online(route, method)\n//\n// Example: https://github.com/kataras/iris/tree/master/_examples/routing/route-state\n//\n// User can get the response by simple using rec := ctx.Recorder(); rec.Body()/rec.StatusCode()/rec.Header().\n//\n// context's Values and the Session are kept in order to be able to communicate via the result route.\n//\n// It's for extreme use cases, 99% of the times will never be useful for you.\nfunc (ctx *Context) Exec(method string, path string) {\n\tif path == \"\" {\n\t\treturn\n\t}\n\n\tif method == \"\" {\n\t\tmethod = \"GET\"\n\t}\n\n\t// backup the handlers\n\tbackupHandlers := ctx.handlers[0:]\n\tbackupPos := ctx.currentHandlerIndex\n\n\treq := ctx.request\n\t// backup the request path information\n\tbackupPath := req.URL.Path\n\tbackupMethod := req.Method\n\t// don't backupValues := ctx.values.ReadOnly()\n\t// set the request to be align with the 'againstRequestPath'\n\treq.RequestURI = path\n\treq.URL.Path = path\n\treq.Method = method\n\n\t// [values stays]\n\t// reset handlers\n\tctx.handlers = ctx.handlers[0:0]\n\tctx.currentHandlerIndex = 0\n\n\t// execute the route from the (internal) context router\n\t// this way we keep the sessions and the values\n\tctx.app.ServeHTTPC(ctx)\n\n\t// set the request back to its previous state\n\treq.RequestURI = backupPath\n\treq.URL.Path = backupPath\n\treq.Method = backupMethod\n\n\t// set back the old handlers and the last known index\n\tctx.handlers = backupHandlers\n\tctx.currentHandlerIndex = backupPos\n}\n\n// RouteExists reports whether a particular route exists\n// It will search from the current subdomain of context's host, if not inside the root domain.\nfunc (ctx *Context) RouteExists(method, path string) bool {\n\treturn ctx.app.RouteExists(ctx, method, path)\n}\n\nconst (\n\treflectValueContextKey = \"iris.context.reflect_value\"\n\t// ControllerContextKey returns the context key from which\n\t// the `Context.Controller` method returns the store's value.\n\tControllerContextKey = \"iris.controller.reflect_value\"\n)\n\n// ReflectValue caches and returns a []reflect.Value{reflect.ValueOf(ctx)}.\n// It's just a helper to maintain variable inside the context itself.\nfunc (ctx *Context) ReflectValue() []reflect.Value {\n\tif v := ctx.values.Get(reflectValueContextKey); v != nil {\n\t\treturn v.([]reflect.Value)\n\t}\n\n\tv := []reflect.Value{reflect.ValueOf(ctx)}\n\tctx.values.Set(reflectValueContextKey, v)\n\treturn v\n}\n\nvar emptyValue reflect.Value\n\n// Controller returns a reflect Value of the custom Controller from which this handler executed.\n// It will return a Kind() == reflect.Invalid if the handler was not executed from within a controller.\nfunc (ctx *Context) Controller() reflect.Value {\n\tif v := ctx.values.Get(ControllerContextKey); v != nil {\n\t\treturn v.(reflect.Value)\n\t}\n\n\treturn emptyValue\n}\n\n// DependenciesContextKey is the context key for the context's value\n// to keep the serve-time static dependencies raw values.\nconst DependenciesContextKey = \"iris.dependencies\"\n\n// DependenciesMap is the type which context serve-time\n// struct dependencies are stored with.\ntype DependenciesMap map[reflect.Type]reflect.Value\n\n// RegisterDependency registers a struct or slice\n// or pointer to struct dependency at request-time\n// for the next handler in the chain. One value per type.\n// Note that it's highly recommended to register\n// your dependencies before server ran\n// through Party.ConfigureContainer or mvc.Application.Register\n// in sake of minimum performance cost.\n//\n// See `UnregisterDependency` too.\nfunc (ctx *Context) RegisterDependency(v interface{}) {\n\tif v == nil {\n\t\treturn\n\t}\n\n\tval, ok := v.(reflect.Value)\n\tif !ok {\n\t\tval = reflect.ValueOf(v)\n\t}\n\n\tcv := ctx.values.Get(DependenciesContextKey)\n\tif cv != nil {\n\t\tm, ok := cv.(DependenciesMap)\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\n\t\tm[val.Type()] = val\n\t\treturn\n\t}\n\n\tctx.values.Set(DependenciesContextKey, DependenciesMap{\n\t\tval.Type(): val,\n\t})\n}\n\n// UnregisterDependency removes a dependency based on its type.\n// Reports whether a dependency with that type was found and removed successfully.\nfunc (ctx *Context) UnregisterDependency(typ reflect.Type) bool {\n\tcv := ctx.values.Get(DependenciesContextKey)\n\tif cv != nil {\n\t\tm, ok := cv.(DependenciesMap)\n\t\tif ok {\n\t\t\tdelete(m, typ)\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// Application returns the iris app instance which belongs to this context.\n// Worth to notice that this function returns an interface\n// of the Application, which contains methods that are safe\n// to be executed at serve-time. The full app's fields\n// and methods are not available here for the developer's safety.\nfunc (ctx *Context) Application() Application {\n\treturn ctx.app\n}\n\n// IsDebug reports whether the application runs with debug log level.\n// It is a shortcut of Application.IsDebug().\nfunc (ctx *Context) IsDebug() bool {\n\treturn ctx.app.IsDebug()\n}\n\n// SetErr is just a helper that sets an error value\n// as a context value, it does nothing more.\n// Also, by-default this error's value is written to the client\n// on failures when no registered error handler is available (see `Party.On(Any)ErrorCode`).\n// See `GetErr` to retrieve it back.\n//\n// To remove an error simply pass nil.\n//\n// Note that, if you want to stop the chain\n// with an error see the `StopWithError/StopWithPlainError` instead.\nfunc (ctx *Context) SetErr(err error) {\n\tif err == nil {\n\t\tctx.values.Remove(errorContextKey)\n\t\treturn\n\t}\n\n\tctx.values.Set(errorContextKey, err)\n}\n\n// GetErr is a helper which retrieves\n// the error value stored by `SetErr`.\n//\n// Note that, if an error was stored by `SetErrPrivate`\n// then it returns the underline/original error instead\n// of the internal error wrapper.\nfunc (ctx *Context) GetErr() error {\n\t_, err := ctx.GetErrPublic()\n\treturn err\n}\n\n// ErrPrivate if provided then the error saved in context\n// should NOT be visible to the client no matter what.\ntype ErrPrivate interface {\n\terror\n\tIrisPrivateError()\n}\n\n// An internal wrapper for the `SetErrPrivate` method.\ntype privateError struct{ error }\n\nfunc (e privateError) IrisPrivateError() {}\n\n// PrivateError accepts an error and returns a wrapped private one.\nfunc PrivateError(err error) ErrPrivate {\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\terrPrivate, ok := err.(ErrPrivate)\n\tif !ok {\n\t\terrPrivate = privateError{err}\n\t}\n\n\treturn errPrivate\n}\n\nconst errorContextKey = \"iris.context.error\"\n\n// SetErrPrivate sets an error that it's only accessible through `GetErr`\n// and it should never be sent to the client.\n//\n// Same as ctx.SetErr with an error that completes the `ErrPrivate` interface.\n// See `GetErrPublic` too.\nfunc (ctx *Context) SetErrPrivate(err error) {\n\tctx.SetErr(PrivateError(err))\n}\n\n// GetErrPublic reports whether the stored error\n// can be displayed to the client without risking\n// to expose security server implementation to the client.\n//\n// If the error is not nil, it is always the original one.\nfunc (ctx *Context) GetErrPublic() (bool, error) {\n\tif v := ctx.values.Get(errorContextKey); v != nil {\n\t\tswitch err := v.(type) {\n\t\tcase privateError:\n\t\t\t// If it's an error set by SetErrPrivate then unwrap it.\n\t\t\treturn false, err.error\n\t\tcase ErrPrivate:\n\t\t\treturn false, err\n\t\tcase error:\n\t\t\treturn true, err\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\n// ErrPanicRecovery may be returned from `Context` actions of a `Handler`\n// which recovers from a manual panic.\ntype ErrPanicRecovery struct {\n\tErrPrivate\n\tCause              interface{}\n\tCallers            []string // file:line callers.\n\tStack              []byte   // the full debug stack.\n\tRegisteredHandlers []string // file:line of all registered handlers.\n\tCurrentHandler     string   // the handler panic came from.\n}\n\n// Error implements the Go standard error type.\nfunc (e *ErrPanicRecovery) Error() string {\n\tif e.Cause != nil {\n\t\tif err, ok := e.Cause.(error); ok {\n\t\t\treturn err.Error()\n\t\t}\n\t}\n\n\treturn fmt.Sprintf(\"%v\\n%s\", e.Cause, strings.Join(e.Callers, \"\\n\"))\n}\n\n// Is completes the internal errors.Is interface.\nfunc (e *ErrPanicRecovery) Is(err error) bool {\n\t_, ok := IsErrPanicRecovery(err)\n\treturn ok\n}\n\n// IsErrPanicRecovery reports whether the given \"err\" is a type of ErrPanicRecovery.\nfunc IsErrPanicRecovery(err error) (*ErrPanicRecovery, bool) {\n\tif err == nil {\n\t\treturn nil, false\n\t}\n\tv, ok := err.(*ErrPanicRecovery)\n\treturn v, ok\n}\n\n// IsRecovered reports whether this handler has been recovered\n// by the Iris recover middleware.\nfunc (ctx *Context) IsRecovered() (*ErrPanicRecovery, bool) {\n\tif ctx.GetStatusCode() == http.StatusInternalServerError {\n\t\t// Panic error from recovery middleware is private.\n\t\treturn IsErrPanicRecovery(ctx.GetErr())\n\t}\n\n\treturn nil, false\n}\n\nconst (\n\tfuncsContextPrefixKey = \"iris.funcs.\"\n\tfuncLogoutContextKey  = \"auth.logout_func\"\n)\n\n// SetFunc registers a custom function to this Request.\n// It's a helper to pass dynamic functions across handlers of the same chain.\n// For a more complete solution please use Dependency Injection instead.\n// This is just an easy to way to pass a function to the\n// next handler like ctx.Values().Set/Get does.\n// Sometimes is faster and easier to pass the object as a request value\n// and cast it when you want to use one of its methods instead of using\n// these `SetFunc` and `CallFunc` methods.\n// This implementation is suitable for functions that may change inside the\n// handler chain and the object holding the method is not predictable.\n//\n// The \"name\" argument is the custom name of the function,\n// you will use its name to call it later on, e.g. \"auth.myfunc\".\n//\n// The second, \"fn\" argument is the raw function/method you want\n// to pass through the next handler(s) of the chain.\n//\n// The last variadic input argument is optionally, if set\n// then its arguments are passing into the function's input arguments,\n// they should be always be the first ones to be accepted by the \"fn\" inputs,\n// e.g. an object, a receiver or a static service.\n//\n// See its `CallFunc` to call the \"fn\" on the next handler.\n//\n// Example at:\n// https://github.com/kataras/iris/tree/master/_examples/routing/writing-a-middleware/share-funcs\nfunc (ctx *Context) SetFunc(name string, fn interface{}, persistenceArgs ...interface{}) {\n\tf := newFunc(name, fn, persistenceArgs...)\n\tctx.values.Set(funcsContextPrefixKey+name, f)\n}\n\n// GetFunc returns the context function declaration which holds\n// some information about the function registered under the given \"name\" by\n// the `SetFunc` method.\nfunc (ctx *Context) GetFunc(name string) (*Func, bool) {\n\tfn := ctx.values.Get(funcsContextPrefixKey + name)\n\tif fn == nil {\n\t\treturn nil, false\n\t}\n\n\treturn fn.(*Func), true\n}\n\n// CallFunc calls the function registered by the `SetFunc`.\n// The input arguments MUST match the expected ones.\n//\n// If the registered function was just a handler\n// or a handler which returns an error\n// or a simple function\n// or a simple function which returns an error\n// then this operation will perform without any serious cost,\n// otherwise reflection will be used instead, which may slow down the overall performance.\n//\n// Retruns ErrNotFound if the function was not registered.\n//\n// For a more complete solution without limiations navigate through\n// the Iris Dependency Injection feature instead.\nfunc (ctx *Context) CallFunc(name string, args ...interface{}) ([]reflect.Value, error) {\n\tfn, ok := ctx.GetFunc(name)\n\tif !ok || fn == nil {\n\t\treturn nil, ErrNotFound\n\t}\n\n\treturn fn.call(ctx, args...)\n}\n\n// SetLogoutFunc registers a custom logout function that will be\n// available to use inside the next handler(s). The function\n// may be registered multiple times but the last one is the valid.\n// So a logout function may start with basic authentication\n// and other middleware in the chain may change it to a custom sessions logout one.\n// This method uses the `SetFunc` method under the hoods.\n//\n// See `Logout` method too.\nfunc (ctx *Context) SetLogoutFunc(fn interface{}, persistenceArgs ...interface{}) {\n\tctx.SetFunc(funcLogoutContextKey, fn, persistenceArgs...)\n}\n\n// Logout calls the registered logout function.\n// Returns ErrNotFound if a logout function was not specified\n// by a prior call of `SetLogoutFunc`.\nfunc (ctx *Context) Logout(args ...interface{}) error {\n\t_, err := ctx.CallFunc(funcLogoutContextKey, args...)\n\treturn err\n}\n\nconst userContextKey = \"iris.user\"\n\n// SetUser sets a value as a User for this request.\n// It's used by auth middlewares as a common\n// method to provide user information to the\n// next handlers in the chain.\n//\n// The \"i\" input argument can be:\n// - A value which completes the User interface\n// - A map[string]interface{}.\n// - A value which does not complete the whole User interface\n// - A value which does not complete the User interface at all\n//   (only its `User().GetRaw` method is available).\n//\n// Look the `User` method to retrieve it.\nfunc (ctx *Context) SetUser(i interface{}) error {\n\tif i == nil {\n\t\tctx.values.Remove(userContextKey)\n\t\treturn nil\n\t}\n\n\tu, ok := i.(User)\n\tif !ok {\n\t\tif m, ok := i.(Map); ok { // it's a map, convert it to a User.\n\t\t\tu = UserMap(m)\n\t\t} else {\n\t\t\t// It's a structure, wrap it and let\n\t\t\t// runtime decide the features.\n\t\t\tp := newUserPartial(i)\n\t\t\tif p == nil {\n\t\t\t\treturn ErrNotSupported\n\t\t\t}\n\t\t\tu = p\n\t\t}\n\t}\n\n\tctx.values.Set(userContextKey, u)\n\treturn nil\n}\n\n// User returns the registered User of this request.\n// To get the original value (even if a value set by SetUser does not implement the User interface)\n// use its GetRaw method.\n// /\n// See `SetUser` too.\nfunc (ctx *Context) User() User {\n\tif v := ctx.values.Get(userContextKey); v != nil {\n\t\tif u, ok := v.(User); ok {\n\t\t\treturn u\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Ensure Iris Context implements the standard Context package, build-time.\nvar _ stdContext.Context = (*Context)(nil)\n\n// Deadline returns the time when work done on behalf of this context\n// should be canceled. Deadline returns ok==false when no deadline is\n// set. Successive calls to Deadline return the same results.\n//\n// Shortcut of Request().Context().Deadline().\nfunc (ctx *Context) Deadline() (deadline time.Time, ok bool) {\n\treturn ctx.request.Context().Deadline()\n}\n\n// Done returns a channel that's closed when work done on behalf of this\n// context should be canceled. Done may return nil if this context can\n// never be canceled. Successive calls to Done return the same value.\n// The close of the Done channel may happen asynchronously,\n// after the cancel function returns.\n//\n// WithCancel arranges for Done to be closed when cancel is called;\n// WithDeadline arranges for Done to be closed when the deadline\n// expires; WithTimeout arranges for Done to be closed when the timeout\n// elapses.\n//\n// Done is provided for use in select statements:\n//\n//  // Stream generates values with DoSomething and sends them to out\n//  // until DoSomething returns an error or ctx.Done is closed.\n//  func Stream(ctx context.Context, out chan<- Value) error {\n//  \tfor {\n//  \t\tv, err := DoSomething(ctx)\n//  \t\tif err != nil {\n//  \t\t\treturn err\n//  \t\t}\n//  \t\tselect {\n//  \t\tcase <-ctx.Done():\n//  \t\t\treturn ctx.Err()\n//  \t\tcase out <- v:\n//  \t\t}\n//  \t}\n//  }\n//\n// See https://blog.golang.org/pipelines for more examples of how to use\n// a Done channel for cancellation.\n//\n// Shortcut of Request().Context().Done().\nfunc (ctx *Context) Done() <-chan struct{} {\n\treturn ctx.request.Context().Done()\n}\n\n// If Done is not yet closed, Err returns nil.\n// If Done is closed, Err returns a non-nil error explaining why:\n// Canceled if the context was canceled\n// or DeadlineExceeded if the context's deadline passed.\n// After Err returns a non-nil error, successive calls to Err return the same error.\n//\n// Shortcut of Request().Context().Err().\nfunc (ctx *Context) Err() error {\n\treturn ctx.request.Context().Err()\n}\n\n// Value returns the value associated with this context for key, or nil\n// if no value is associated with key. Successive calls to Value with\n// the same key returns the same result.\n//\n// Shortcut of Request().Context().Value(key interface{}) interface{}.\nfunc (ctx *Context) Value(key interface{}) interface{} {\n\tif keyStr, ok := key.(string); ok { // check if the key is a type of string, which can be retrieved by the mem store.\n\t\tif entry, exists := ctx.values.GetEntry(keyStr); exists {\n\t\t\treturn entry.ValueRaw\n\t\t}\n\t}\n\t// otherwise return the chained value.\n\treturn ctx.request.Context().Value(key)\n}\n\nconst idContextKey = \"iris.context.id\"\n\n// SetID sets an ID, any value, to the Request Context.\n// If possible the \"id\" should implement a `String() string` method\n// so it can be rendered on `Context.String` method.\n//\n// See `GetID` and `middleware/requestid` too.\nfunc (ctx *Context) SetID(id interface{}) {\n\tctx.values.Set(idContextKey, id)\n}\n\n// GetID returns the Request Context's ID.\n// It returns nil if not given by a prior `SetID` call.\n// See `middleware/requestid` too.\nfunc (ctx *Context) GetID() interface{} {\n\treturn ctx.values.Get(idContextKey)\n}\n\n// String returns the string representation of this request.\n//\n// It returns the Context's ID given by a `SetID`call,\n// followed by the client's IP and the method:uri.\nfunc (ctx *Context) String() string {\n\tid := ctx.GetID()\n\tif id != nil {\n\t\tif stringer, ok := id.(fmt.Stringer); ok {\n\t\t\tid = stringer.String()\n\t\t}\n\t}\n\n\treturn fmt.Sprintf(\"[%v] %s \u25b6 %s:%s\", id, ctx.RemoteAddr(), ctx.Method(), ctx.Request().RequestURI)\n}\n"], "buggy_code_start_loc": [29, 2035], "buggy_code_end_loc": [29, 2110], "fixing_code_start_loc": [30, 2035], "fixing_code_end_loc": [32, 2100], "type": "CWE-59", "message": "This affects all versions of package github.com/kataras/iris; all versions of package github.com/kataras/iris/v12. The unsafe handling of file names during upload using UploadFormFiles method may enable attackers to write to arbitrary locations outside the designated target folder.", "other": {"cve": {"id": "CVE-2021-23772", "sourceIdentifier": "report@snyk.io", "published": "2021-12-24T12:15:07.697", "lastModified": "2022-01-04T20:11:12.957", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects all versions of package github.com/kataras/iris; all versions of package github.com/kataras/iris/v12. The unsafe handling of file names during upload using UploadFormFiles method may enable attackers to write to arbitrary locations outside the designated target folder."}, {"lang": "es", "value": "Esto afecta a todas las versiones del paquete github.com/kataras/iris; todas las versiones del paquete github.com/kataras/iris/v12. Un manejo no seguro de los nombres de archivo durante la carga usando el m\u00e9todo UploadFormFiles puede permitir a atacantes escribir en ubicaciones arbitrarias fuera de la carpeta de destino designada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:iris-go:iris:*:*:*:*:*:go:*:*", "versionEndIncluding": "12.1.8", "matchCriteriaId": "EA26C17D-DFA8-4AB5-9E4C-6D5E0A375F6E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iris-go:iris:12.2.0:alpha:*:*:*:go:*:*", "matchCriteriaId": "36735110-76CB-42E1-A4DC-E75FF8D35844"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iris-go:iris:12.2.0:alpha2:*:*:*:go:*:*", "matchCriteriaId": "4801442A-7188-4FBB-B699-569B7EAC0FC8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iris-go:iris:12.2.0:alpha3:*:*:*:go:*:*", "matchCriteriaId": "911993F3-EC67-4E85-A0B2-598CA8CB3B14"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iris-go:iris:12.2.0:alpha4:*:*:*:go:*:*", "matchCriteriaId": "4ED1FF1C-46DA-4E7B-BC42-00847843A82A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:iris-go:iris:12.2.0:alpha5:*:*:*:go:*:*", "matchCriteriaId": "CA784B81-3C4F-4253-92C9-0B16431BE486"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:golang:go:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.7.5", "matchCriteriaId": "355C01B5-DC2D-4992-BCD9-B22E68BC7858"}]}]}], "references": [{"url": "https://github.com/kataras/iris/commit/e213dba0d32ff66653e0ef124bc5088817264b08", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-GOLANG-GITHUBCOMKATARASIRIS-2325169", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-GOLANG-GITHUBCOMKATARASIRISV12-2325170", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kataras/iris/commit/e213dba0d32ff66653e0ef124bc5088817264b08"}}