{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/kernels/save_restore_tensor.h\"\n#include <numeric>\n#include <unordered_map>\n#include <utility>\n#include <vector>\n\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/lib/gtl/array_slice.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"tensorflow/core/lib/strings/stringprintf.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/tensor_bundle/tensor_bundle.h\"\n#include \"tensorflow/core/util/tensor_slice_reader.h\"\n#include \"tensorflow/core/util/tensor_slice_reader_cache.h\"\n#include \"tensorflow/core/util/tensor_slice_writer.h\"\n\nnamespace tensorflow {\n\nvoid SaveTensors(\n    OpKernelContext* context,\n    checkpoint::TensorSliceWriter::CreateBuilderFunction builder_func,\n    bool save_slices) {\n  const Tensor& filename_t = context->input(0);\n  {\n    const int64_t size = filename_t.NumElements();\n    OP_REQUIRES(\n        context, size == 1,\n        errors::InvalidArgument(\n            \"Input 0 (filename) must be a string scalar; got a tensor of \",\n            size, \"elements\"));\n  }\n\n  // Path, names, and slices if save_slices is true.\n  const int kFixedInputs = save_slices ? 3 : 2;\n  const Tensor& tensor_names_t = context->input(1);\n  OP_REQUIRES(context,\n              FastBoundsCheck(tensor_names_t.NumElements() + kFixedInputs,\n                              std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Too many inputs to SaveTensors\"));\n  const int N = static_cast<int>(tensor_names_t.NumElements());\n  const tstring* tensor_shapes_and_slices_ptr = nullptr;\n  if (save_slices) {\n    const Tensor& tensor_shapes_and_slices_t = context->input(2);\n    OP_REQUIRES(\n        context,\n        tensor_shapes_and_slices_t.NumElements() == static_cast<int64>(N),\n        errors::InvalidArgument(\"Expected \", N,\n                                \" elements for the tensor \"\n                                \"shapes and slices but got \",\n                                tensor_shapes_and_slices_t.NumElements()));\n    tensor_shapes_and_slices_ptr =\n        tensor_shapes_and_slices_t.flat<tstring>().data();\n  }\n  OP_REQUIRES(context, context->num_inputs() == N + kFixedInputs,\n              errors::InvalidArgument(\"Expected totally \", N + kFixedInputs,\n                                      \" inputs as input #1 (which is a string \"\n                                      \"tensor of saved names) contains \",\n                                      N, \" names, but received \",\n                                      context->num_inputs(), \" inputs\"));\n\n  VLOG(1) << \"About to save tensors to file \" << filename_t.flat<tstring>()(0)\n          << \"...\";\n  checkpoint::TensorSliceWriter writer(filename_t.flat<tstring>()(0),\n                                       std::move(builder_func));\n\n  Status s;\n  auto tensor_names_flat = tensor_names_t.flat<tstring>();\n\n  // Process tensors in sorted name order.  This allows us to avoid seeking\n  // during restoration in the common case where we are restoring a full\n  // checkpoint.\n  std::vector<size_t> sorted_name_idx(tensor_names_flat.size());\n  std::iota(sorted_name_idx.begin(), sorted_name_idx.end(), 0);\n  std::sort(sorted_name_idx.begin(), sorted_name_idx.end(),\n            [&tensor_names_flat](size_t a, size_t b) {\n              return tensor_names_flat(a) < tensor_names_flat(b);\n            });\n\n  for (const size_t i : sorted_name_idx) {\n    const string& name = tensor_names_flat(i);\n    const Tensor& input = context->input(i + kFixedInputs);\n    TensorShape shape(input.shape());\n    TensorSlice slice(input.dims());\n    if (save_slices && !tensor_shapes_and_slices_ptr[i].empty()) {\n      const tstring& shape_spec = tensor_shapes_and_slices_ptr[i];\n      TensorShape slice_shape;\n      OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                  shape_spec, &shape, &slice, &slice_shape));\n      OP_REQUIRES(context, slice_shape.IsSameSize(input.shape()),\n                  errors::InvalidArgument(\n                      \"Slice in shape_and_slice \"\n                      \"specification does not match the \"\n                      \"shape of the tensor to  save: \",\n                      shape_spec, \", tensor: \", input.shape().DebugString()));\n    }\n\n#define WRITER_ADD(T)                                           \\\n  case DataTypeToEnum<T>::value:                                \\\n    s = writer.Add(name, shape, slice, input.flat<T>().data()); \\\n    break;\n\n    switch (input.dtype()) {\n      TF_CALL_SAVE_RESTORE_TYPES(WRITER_ADD)\n      default:\n        context->SetStatus(errors::Unimplemented(\"Saving data type \",\n                                                 DataTypeString(input.dtype()),\n                                                 \" not yet supported\"));\n        return;\n    }\n#undef WRITER_ADD\n    if (!s.ok()) {\n      context->SetStatus(s);\n      return;\n    }\n  }\n\n  s = writer.Finish();\n  if (!s.ok()) {\n    context->SetStatus(s);\n  }\n}\n\nvoid RestoreTensor(OpKernelContext* context,\n                   checkpoint::TensorSliceReader::OpenTableFunction open_func,\n                   int preferred_shard, bool restore_slice, int restore_index) {\n  const Tensor& file_pattern_t = context->input(0);\n  {\n    const int64_t size = file_pattern_t.NumElements();\n    OP_REQUIRES(\n        context, size == 1,\n        errors::InvalidArgument(\n            \"Input 0 (file_pattern) must be a string scalar; got a tensor of \",\n            size, \"elements\"));\n  }\n  const string& file_pattern = file_pattern_t.flat<tstring>()(0);\n\n  const Tensor& tensor_name_t = context->input(1);\n  const string& tensor_name = tensor_name_t.flat<tstring>()(restore_index);\n\n  // If we cannot find a cached reader we will allocate our own.\n  std::unique_ptr<checkpoint::TensorSliceReader> allocated_reader;\n\n  const checkpoint::TensorSliceReader* reader = nullptr;\n\n  if (context->slice_reader_cache()) {\n    reader = context->slice_reader_cache()->GetReader(file_pattern, open_func,\n                                                      preferred_shard);\n  }\n  if (!reader) {\n    allocated_reader.reset(new checkpoint::TensorSliceReader(\n        file_pattern, open_func, preferred_shard));\n    reader = allocated_reader.get();\n  }\n  OP_REQUIRES_OK(context, CHECK_NOTNULL(reader)->status());\n\n  // Get the shape and type from the save file.\n  DataType type;\n  TensorShape saved_shape;\n  OP_REQUIRES(\n      context, reader->HasTensor(tensor_name, &saved_shape, &type),\n      errors::NotFound(\"Tensor name \\\"\", tensor_name,\n                       \"\\\" not found in checkpoint files \", file_pattern));\n  OP_REQUIRES(\n      context, type == context->expected_output_dtype(restore_index),\n      errors::InvalidArgument(\"Expected to restore a tensor of type \",\n                              DataTypeString(context->expected_output_dtype(0)),\n                              \", got a tensor of type \", DataTypeString(type),\n                              \" instead: tensor_name = \", tensor_name));\n\n  // Shape of the output and slice to load.\n  TensorShape output_shape(saved_shape);\n  TensorSlice slice_to_load(saved_shape.dims());\n  if (restore_slice) {\n    const tstring& shape_spec =\n        context->input(2).flat<tstring>()(restore_index);\n    if (!shape_spec.empty()) {\n      TensorShape parsed_shape;\n      OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                  shape_spec, &parsed_shape, &slice_to_load,\n                                  &output_shape));\n      OP_REQUIRES(\n          context, parsed_shape.IsSameSize(saved_shape),\n          errors::InvalidArgument(\n              \"Shape in shape_and_slice spec does not match the shape in the \"\n              \"save file: \",\n              parsed_shape.DebugString(),\n              \", save file shape: \", saved_shape.DebugString()));\n    }\n  }\n\n  Tensor* t = nullptr;\n  OP_REQUIRES_OK(context,\n                 context->allocate_output(restore_index, output_shape, &t));\n\n  if (output_shape.num_elements() == 0) return;\n\n#define READER_COPY(T)                                                \\\n  case DataTypeToEnum<T>::value:                                      \\\n    OP_REQUIRES(context,                                              \\\n                reader->CopySliceData(tensor_name, slice_to_load,     \\\n                                      t->flat<T>().data()),           \\\n                errors::InvalidArgument(\"Error copying slice data\")); \\\n    break;\n\n  switch (type) {\n    TF_CALL_SAVE_RESTORE_TYPES(READER_COPY)\n    default:\n      context->SetStatus(errors::Unimplemented(\n          \"Restoring data type \", DataTypeString(type), \" not yet supported\"));\n  }\n#undef READER_COPY\n}\n\nnamespace {\n\n// Tensors larger than this threshold will be restored from a thread-pool.\nconst int64_t kLargeShapeThreshold = 16 << 20;  // 16M\n\n// A restore operation for a single tensor.  Small tensors may be restored\n// directly from the op thread to improve read locality.  Large tensors can be\n// restored from a thread pool: this requires creating a separate BundleReader\n// for each restore.\nstruct RestoreOp {\n  RestoreOp& operator=(const RestoreOp&) = delete;\n\n  bool should_run_in_pool(BundleReader* reader) const {\n    TensorShape restored_full_shape;\n\n    // Ignore status here; we'll catch the error later.\n    if (!reader->LookupTensorShape(tensor_name, &restored_full_shape).ok()) {\n      return false;\n    }\n\n    return restored_full_shape.num_elements() > kLargeShapeThreshold;\n  }\n\n  // Run this restore operation using a new BundleReader.\n  void run_with_new_reader() {\n    BundleReader reader(Env::Default(), reader_prefix);\n    if (!reader.status().ok()) {\n      status = reader.status();\n      return;\n    }\n\n    status = run(&reader);\n  }\n\n  Status run(BundleReader* reader) {\n    TensorShape restored_full_shape;\n    TF_RETURN_IF_ERROR(\n        reader->LookupTensorShape(tensor_name, &restored_full_shape));\n\n    VLOG(1) << \"Restoring tensor \" << idx << \" : \" << tensor_name << \" : \"\n            << restored_full_shape.num_elements();\n    Tensor* restored_tensor;\n    if (shape_and_slice.empty()) {\n      // Lookup the full tensor.\n      TF_RETURN_IF_ERROR(\n          context->allocate_output(idx, restored_full_shape, &restored_tensor));\n      TF_RETURN_IF_ERROR(reader->Lookup(tensor_name, restored_tensor));\n    } else {\n      // Lookup the slice.\n      TensorShape parsed_full_shape;\n      TensorSlice parsed_slice;\n      TensorShape parsed_slice_shape;\n\n      TF_RETURN_IF_ERROR(\n          checkpoint::ParseShapeAndSlice(shape_and_slice, &parsed_full_shape,\n                                         &parsed_slice, &parsed_slice_shape));\n\n      if (!restored_full_shape.IsSameSize(parsed_full_shape)) {\n        return errors::InvalidArgument(\n            \"tensor_name = \", tensor_name, \"; shape in shape_and_slice spec \",\n            parsed_full_shape.DebugString(),\n            \" does not match the shape stored in checkpoint: \",\n            restored_full_shape.DebugString());\n      }\n      TF_RETURN_IF_ERROR(\n          context->allocate_output(idx, parsed_slice_shape, &restored_tensor));\n      TF_RETURN_IF_ERROR(\n          reader->LookupSlice(tensor_name, parsed_slice, restored_tensor));\n    }\n    if (VLOG_IS_ON(5)) {\n      if (restored_tensor->dtype() == DT_FLOAT) {\n        const float* t_data = restored_tensor->flat<float>().data();\n        float min = std::numeric_limits<float>::infinity();\n        float max = -std::numeric_limits<float>::infinity();\n        double avg = 0.0;\n        for (int i = 0; i < restored_tensor->NumElements(); ++i) {\n          if (t_data[i] < min) min = t_data[i];\n          if (t_data[i] > max) max = t_data[i];\n          avg += t_data[i];\n        }\n        VLOG(5) << \" min \" << min << \" max \" << max << \" avg \"\n                << avg / restored_tensor->NumElements() << \" total elts \"\n                << restored_tensor->NumElements();\n      }\n    }\n    VLOG(1) << \"Done restoring tensor \" << idx << \" : \" << tensor_name << \" : \"\n            << restored_full_shape.num_elements();\n    return Status::OK();\n  }\n\n  OpKernelContext* context;\n  size_t idx;\n  string tensor_name;\n  string shape_and_slice;\n  string reader_prefix;\n\n  ::tensorflow::Status status;\n};\n\n}  // namespace\n\nStatus RestoreTensorsV2(OpKernelContext* context, const Tensor& prefix,\n                        const Tensor& tensor_names,\n                        const Tensor& shape_and_slices,\n                        gtl::ArraySlice<DataType> dtypes) {\n  const string& prefix_string = prefix.scalar<tstring>()();\n\n  const auto& tensor_names_flat = tensor_names.flat<tstring>();\n  const auto& shape_and_slices_flat = shape_and_slices.flat<tstring>();\n\n  // Sort lookup keys to improve locality when reading multiple tensors.\n  std::vector<size_t> sorted_name_idx(tensor_names_flat.size());\n  std::iota(sorted_name_idx.begin(), sorted_name_idx.end(), 0);\n  std::sort(sorted_name_idx.begin(), sorted_name_idx.end(),\n            [&tensor_names_flat](size_t a, size_t b) {\n              return tensor_names_flat(a) < tensor_names_flat(b);\n            });\n\n  std::vector<std::unique_ptr<RestoreOp> > pool_restore_ops;\n  std::vector<std::unique_ptr<RestoreOp> > direct_restore_ops;\n\n  BundleReader default_reader(Env::Default(), prefix_string);\n  TF_RETURN_IF_ERROR(default_reader.status());\n\n  std::vector<string> mismatched_errors;\n  for (const size_t i : sorted_name_idx) {\n    TensorShape restored_full_shape;\n    DataType original_dtype;\n    const string& tensor_name = tensor_names_flat(i);\n    TF_RETURN_IF_ERROR(default_reader.LookupDtypeAndShape(\n        tensor_name, &original_dtype, &restored_full_shape));\n    if (dtypes[i] != original_dtype) {\n      string error_msg = strings::StrCat(\n          \"tensor_name = \", tensor_name, \"; expected dtype \",\n          DataTypeString(dtypes[i]), \" does not equal original dtype \",\n          DataTypeString(original_dtype));\n      mismatched_errors.emplace_back(error_msg);\n    }\n  }\n  if (!mismatched_errors.empty()) {\n    const string error_msg = absl::StrJoin(mismatched_errors, \"\\n\");\n    return errors::InvalidArgument(error_msg);\n  }\n\n  for (auto i : sorted_name_idx) {\n    const string& tensor_name = tensor_names_flat(i);\n    const string& shape_and_slice = shape_and_slices_flat(i);\n    auto op =\n        new RestoreOp{context, i, tensor_name, shape_and_slice, prefix_string};\n    if (op->should_run_in_pool(&default_reader)) {\n      pool_restore_ops.emplace_back(op);\n    } else {\n      direct_restore_ops.emplace_back(op);\n    }\n  }\n\n  {\n    // Schedule any threaded operations first, skipping thread pool creation if\n    // we don't have any expensive operations.\n    std::unique_ptr<thread::ThreadPool> reader_pool;\n    if (!pool_restore_ops.empty()) {\n      reader_pool.reset(\n          new thread::ThreadPool(Env::Default(), \"restore_tensors\", 8));\n      for (auto& op : pool_restore_ops) {\n        reader_pool->Schedule([&op]() { op->run_with_new_reader(); });\n      }\n    }\n\n    // Read small tensors from the op thread\n    for (auto& op : direct_restore_ops) {\n      TF_RETURN_IF_ERROR(op->run(&default_reader));\n    }\n  }\n\n  // Check status of pool ops; this must come after the pool shuts down.\n  for (auto& op : pool_restore_ops) {\n    TF_RETURN_IF_ERROR(op->status);\n  }\n\n  for (auto i : sorted_name_idx) {\n    const string& tensor_name = tensor_names_flat(i);\n    if (dtypes[i] != context->mutable_output(i)->dtype()) {\n      return errors::InvalidArgument(\n          \"tensor_name = \", tensor_name, \"; expected dtype \",\n          DataTypeString(dtypes[i]), \" does not equal restored dtype \",\n          DataTypeString(context->mutable_output(i)->dtype()));\n    }\n  }\n\n  return Status::OK();\n}\n\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/kernels/save_restore_tensor.h\"\n#include <numeric>\n#include <unordered_map>\n#include <utility>\n#include <vector>\n\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/lib/gtl/array_slice.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"tensorflow/core/lib/strings/stringprintf.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/tensor_bundle/tensor_bundle.h\"\n#include \"tensorflow/core/util/tensor_slice_reader.h\"\n#include \"tensorflow/core/util/tensor_slice_reader_cache.h\"\n#include \"tensorflow/core/util/tensor_slice_writer.h\"\n\nnamespace tensorflow {\n\nvoid SaveTensors(\n    OpKernelContext* context,\n    checkpoint::TensorSliceWriter::CreateBuilderFunction builder_func,\n    bool save_slices) {\n  const Tensor& filename_t = context->input(0);\n  {\n    const int64_t size = filename_t.NumElements();\n    OP_REQUIRES(\n        context, size == 1,\n        errors::InvalidArgument(\n            \"Input 0 (filename) must be a string scalar; got a tensor of \",\n            size, \"elements\"));\n  }\n\n  // Path, names, and slices if save_slices is true.\n  const int kFixedInputs = save_slices ? 3 : 2;\n  const Tensor& tensor_names_t = context->input(1);\n  OP_REQUIRES(context,\n              FastBoundsCheck(tensor_names_t.NumElements() + kFixedInputs,\n                              std::numeric_limits<int>::max()),\n              errors::InvalidArgument(\"Too many inputs to SaveTensors\"));\n  const int N = static_cast<int>(tensor_names_t.NumElements());\n  const tstring* tensor_shapes_and_slices_ptr = nullptr;\n  if (save_slices) {\n    const Tensor& tensor_shapes_and_slices_t = context->input(2);\n    OP_REQUIRES(\n        context,\n        tensor_shapes_and_slices_t.NumElements() == static_cast<int64>(N),\n        errors::InvalidArgument(\"Expected \", N,\n                                \" elements for the tensor \"\n                                \"shapes and slices but got \",\n                                tensor_shapes_and_slices_t.NumElements()));\n    tensor_shapes_and_slices_ptr =\n        tensor_shapes_and_slices_t.flat<tstring>().data();\n  }\n  OP_REQUIRES(context, context->num_inputs() == N + kFixedInputs,\n              errors::InvalidArgument(\"Expected totally \", N + kFixedInputs,\n                                      \" inputs as input #1 (which is a string \"\n                                      \"tensor of saved names) contains \",\n                                      N, \" names, but received \",\n                                      context->num_inputs(), \" inputs\"));\n\n  VLOG(1) << \"About to save tensors to file \" << filename_t.flat<tstring>()(0)\n          << \"...\";\n  checkpoint::TensorSliceWriter writer(filename_t.flat<tstring>()(0),\n                                       std::move(builder_func));\n\n  Status s;\n  auto tensor_names_flat = tensor_names_t.flat<tstring>();\n\n  // Process tensors in sorted name order.  This allows us to avoid seeking\n  // during restoration in the common case where we are restoring a full\n  // checkpoint.\n  std::vector<size_t> sorted_name_idx(tensor_names_flat.size());\n  std::iota(sorted_name_idx.begin(), sorted_name_idx.end(), 0);\n  std::sort(sorted_name_idx.begin(), sorted_name_idx.end(),\n            [&tensor_names_flat](size_t a, size_t b) {\n              return tensor_names_flat(a) < tensor_names_flat(b);\n            });\n\n  for (const size_t i : sorted_name_idx) {\n    const string& name = tensor_names_flat(i);\n    const Tensor& input = context->input(i + kFixedInputs);\n    TensorShape shape(input.shape());\n    TensorSlice slice(input.dims());\n    if (save_slices && !tensor_shapes_and_slices_ptr[i].empty()) {\n      const tstring& shape_spec = tensor_shapes_and_slices_ptr[i];\n      TensorShape slice_shape;\n      OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                  shape_spec, &shape, &slice, &slice_shape));\n      OP_REQUIRES(context, slice_shape.IsSameSize(input.shape()),\n                  errors::InvalidArgument(\n                      \"Slice in shape_and_slice \"\n                      \"specification does not match the \"\n                      \"shape of the tensor to  save: \",\n                      shape_spec, \", tensor: \", input.shape().DebugString()));\n    }\n\n#define WRITER_ADD(T)                                           \\\n  case DataTypeToEnum<T>::value:                                \\\n    s = writer.Add(name, shape, slice, input.flat<T>().data()); \\\n    break;\n\n    switch (input.dtype()) {\n      TF_CALL_SAVE_RESTORE_TYPES(WRITER_ADD)\n      default:\n        context->SetStatus(errors::Unimplemented(\"Saving data type \",\n                                                 DataTypeString(input.dtype()),\n                                                 \" not yet supported\"));\n        return;\n    }\n#undef WRITER_ADD\n    if (!s.ok()) {\n      context->SetStatus(s);\n      return;\n    }\n  }\n\n  s = writer.Finish();\n  if (!s.ok()) {\n    context->SetStatus(s);\n  }\n}\n\nvoid RestoreTensor(OpKernelContext* context,\n                   checkpoint::TensorSliceReader::OpenTableFunction open_func,\n                   int preferred_shard, bool restore_slice, int restore_index) {\n  const Tensor& file_pattern_t = context->input(0);\n  {\n    const int64_t size = file_pattern_t.NumElements();\n    OP_REQUIRES(\n        context, size == 1,\n        errors::InvalidArgument(\n            \"Input 0 (file_pattern) must be a string scalar; got a tensor of \",\n            size, \" elements\"));\n  }\n  const string& file_pattern = file_pattern_t.flat<tstring>()(0);\n\n  const Tensor& tensor_name_t = context->input(1);\n  {\n    const int64_t size = tensor_name_t.NumElements();\n    OP_REQUIRES(context, size > restore_index,\n                errors::InvalidArgument(\n                    \"Input 1 (file_pattern) must be a have at least \",\n                    restore_index + 1, \" elements\"));\n  }\n  const string& tensor_name = tensor_name_t.flat<tstring>()(restore_index);\n\n  // If we cannot find a cached reader we will allocate our own.\n  std::unique_ptr<checkpoint::TensorSliceReader> allocated_reader;\n\n  const checkpoint::TensorSliceReader* reader = nullptr;\n\n  if (context->slice_reader_cache()) {\n    reader = context->slice_reader_cache()->GetReader(file_pattern, open_func,\n                                                      preferred_shard);\n  }\n  if (!reader) {\n    allocated_reader.reset(new checkpoint::TensorSliceReader(\n        file_pattern, open_func, preferred_shard));\n    reader = allocated_reader.get();\n  }\n  OP_REQUIRES_OK(context, CHECK_NOTNULL(reader)->status());\n\n  // Get the shape and type from the save file.\n  DataType type;\n  TensorShape saved_shape;\n  OP_REQUIRES(\n      context, reader->HasTensor(tensor_name, &saved_shape, &type),\n      errors::NotFound(\"Tensor name \\\"\", tensor_name,\n                       \"\\\" not found in checkpoint files \", file_pattern));\n  OP_REQUIRES(\n      context, type == context->expected_output_dtype(restore_index),\n      errors::InvalidArgument(\"Expected to restore a tensor of type \",\n                              DataTypeString(context->expected_output_dtype(0)),\n                              \", got a tensor of type \", DataTypeString(type),\n                              \" instead: tensor_name = \", tensor_name));\n\n  // Shape of the output and slice to load.\n  TensorShape output_shape(saved_shape);\n  TensorSlice slice_to_load(saved_shape.dims());\n  if (restore_slice) {\n    const tstring& shape_spec =\n        context->input(2).flat<tstring>()(restore_index);\n    if (!shape_spec.empty()) {\n      TensorShape parsed_shape;\n      OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                  shape_spec, &parsed_shape, &slice_to_load,\n                                  &output_shape));\n      OP_REQUIRES(\n          context, parsed_shape.IsSameSize(saved_shape),\n          errors::InvalidArgument(\n              \"Shape in shape_and_slice spec does not match the shape in the \"\n              \"save file: \",\n              parsed_shape.DebugString(),\n              \", save file shape: \", saved_shape.DebugString()));\n    }\n  }\n\n  Tensor* t = nullptr;\n  OP_REQUIRES_OK(context,\n                 context->allocate_output(restore_index, output_shape, &t));\n\n  if (output_shape.num_elements() == 0) return;\n\n#define READER_COPY(T)                                                \\\n  case DataTypeToEnum<T>::value:                                      \\\n    OP_REQUIRES(context,                                              \\\n                reader->CopySliceData(tensor_name, slice_to_load,     \\\n                                      t->flat<T>().data()),           \\\n                errors::InvalidArgument(\"Error copying slice data\")); \\\n    break;\n\n  switch (type) {\n    TF_CALL_SAVE_RESTORE_TYPES(READER_COPY)\n    default:\n      context->SetStatus(errors::Unimplemented(\n          \"Restoring data type \", DataTypeString(type), \" not yet supported\"));\n  }\n#undef READER_COPY\n}\n\nnamespace {\n\n// Tensors larger than this threshold will be restored from a thread-pool.\nconst int64_t kLargeShapeThreshold = 16 << 20;  // 16M\n\n// A restore operation for a single tensor.  Small tensors may be restored\n// directly from the op thread to improve read locality.  Large tensors can be\n// restored from a thread pool: this requires creating a separate BundleReader\n// for each restore.\nstruct RestoreOp {\n  RestoreOp& operator=(const RestoreOp&) = delete;\n\n  bool should_run_in_pool(BundleReader* reader) const {\n    TensorShape restored_full_shape;\n\n    // Ignore status here; we'll catch the error later.\n    if (!reader->LookupTensorShape(tensor_name, &restored_full_shape).ok()) {\n      return false;\n    }\n\n    return restored_full_shape.num_elements() > kLargeShapeThreshold;\n  }\n\n  // Run this restore operation using a new BundleReader.\n  void run_with_new_reader() {\n    BundleReader reader(Env::Default(), reader_prefix);\n    if (!reader.status().ok()) {\n      status = reader.status();\n      return;\n    }\n\n    status = run(&reader);\n  }\n\n  Status run(BundleReader* reader) {\n    TensorShape restored_full_shape;\n    TF_RETURN_IF_ERROR(\n        reader->LookupTensorShape(tensor_name, &restored_full_shape));\n\n    VLOG(1) << \"Restoring tensor \" << idx << \" : \" << tensor_name << \" : \"\n            << restored_full_shape.num_elements();\n    Tensor* restored_tensor;\n    if (shape_and_slice.empty()) {\n      // Lookup the full tensor.\n      TF_RETURN_IF_ERROR(\n          context->allocate_output(idx, restored_full_shape, &restored_tensor));\n      TF_RETURN_IF_ERROR(reader->Lookup(tensor_name, restored_tensor));\n    } else {\n      // Lookup the slice.\n      TensorShape parsed_full_shape;\n      TensorSlice parsed_slice;\n      TensorShape parsed_slice_shape;\n\n      TF_RETURN_IF_ERROR(\n          checkpoint::ParseShapeAndSlice(shape_and_slice, &parsed_full_shape,\n                                         &parsed_slice, &parsed_slice_shape));\n\n      if (!restored_full_shape.IsSameSize(parsed_full_shape)) {\n        return errors::InvalidArgument(\n            \"tensor_name = \", tensor_name, \"; shape in shape_and_slice spec \",\n            parsed_full_shape.DebugString(),\n            \" does not match the shape stored in checkpoint: \",\n            restored_full_shape.DebugString());\n      }\n      TF_RETURN_IF_ERROR(\n          context->allocate_output(idx, parsed_slice_shape, &restored_tensor));\n      TF_RETURN_IF_ERROR(\n          reader->LookupSlice(tensor_name, parsed_slice, restored_tensor));\n    }\n    if (VLOG_IS_ON(5)) {\n      if (restored_tensor->dtype() == DT_FLOAT) {\n        const float* t_data = restored_tensor->flat<float>().data();\n        float min = std::numeric_limits<float>::infinity();\n        float max = -std::numeric_limits<float>::infinity();\n        double avg = 0.0;\n        for (int i = 0; i < restored_tensor->NumElements(); ++i) {\n          if (t_data[i] < min) min = t_data[i];\n          if (t_data[i] > max) max = t_data[i];\n          avg += t_data[i];\n        }\n        VLOG(5) << \" min \" << min << \" max \" << max << \" avg \"\n                << avg / restored_tensor->NumElements() << \" total elts \"\n                << restored_tensor->NumElements();\n      }\n    }\n    VLOG(1) << \"Done restoring tensor \" << idx << \" : \" << tensor_name << \" : \"\n            << restored_full_shape.num_elements();\n    return Status::OK();\n  }\n\n  OpKernelContext* context;\n  size_t idx;\n  string tensor_name;\n  string shape_and_slice;\n  string reader_prefix;\n\n  ::tensorflow::Status status;\n};\n\n}  // namespace\n\nStatus RestoreTensorsV2(OpKernelContext* context, const Tensor& prefix,\n                        const Tensor& tensor_names,\n                        const Tensor& shape_and_slices,\n                        gtl::ArraySlice<DataType> dtypes) {\n  const string& prefix_string = prefix.scalar<tstring>()();\n\n  const auto& tensor_names_flat = tensor_names.flat<tstring>();\n  const auto& shape_and_slices_flat = shape_and_slices.flat<tstring>();\n\n  // Sort lookup keys to improve locality when reading multiple tensors.\n  std::vector<size_t> sorted_name_idx(tensor_names_flat.size());\n  std::iota(sorted_name_idx.begin(), sorted_name_idx.end(), 0);\n  std::sort(sorted_name_idx.begin(), sorted_name_idx.end(),\n            [&tensor_names_flat](size_t a, size_t b) {\n              return tensor_names_flat(a) < tensor_names_flat(b);\n            });\n\n  std::vector<std::unique_ptr<RestoreOp> > pool_restore_ops;\n  std::vector<std::unique_ptr<RestoreOp> > direct_restore_ops;\n\n  BundleReader default_reader(Env::Default(), prefix_string);\n  TF_RETURN_IF_ERROR(default_reader.status());\n\n  std::vector<string> mismatched_errors;\n  for (const size_t i : sorted_name_idx) {\n    TensorShape restored_full_shape;\n    DataType original_dtype;\n    const string& tensor_name = tensor_names_flat(i);\n    TF_RETURN_IF_ERROR(default_reader.LookupDtypeAndShape(\n        tensor_name, &original_dtype, &restored_full_shape));\n    if (dtypes[i] != original_dtype) {\n      string error_msg = strings::StrCat(\n          \"tensor_name = \", tensor_name, \"; expected dtype \",\n          DataTypeString(dtypes[i]), \" does not equal original dtype \",\n          DataTypeString(original_dtype));\n      mismatched_errors.emplace_back(error_msg);\n    }\n  }\n  if (!mismatched_errors.empty()) {\n    const string error_msg = absl::StrJoin(mismatched_errors, \"\\n\");\n    return errors::InvalidArgument(error_msg);\n  }\n\n  for (auto i : sorted_name_idx) {\n    const string& tensor_name = tensor_names_flat(i);\n    const string& shape_and_slice = shape_and_slices_flat(i);\n    auto op =\n        new RestoreOp{context, i, tensor_name, shape_and_slice, prefix_string};\n    if (op->should_run_in_pool(&default_reader)) {\n      pool_restore_ops.emplace_back(op);\n    } else {\n      direct_restore_ops.emplace_back(op);\n    }\n  }\n\n  {\n    // Schedule any threaded operations first, skipping thread pool creation if\n    // we don't have any expensive operations.\n    std::unique_ptr<thread::ThreadPool> reader_pool;\n    if (!pool_restore_ops.empty()) {\n      reader_pool.reset(\n          new thread::ThreadPool(Env::Default(), \"restore_tensors\", 8));\n      for (auto& op : pool_restore_ops) {\n        reader_pool->Schedule([&op]() { op->run_with_new_reader(); });\n      }\n    }\n\n    // Read small tensors from the op thread\n    for (auto& op : direct_restore_ops) {\n      TF_RETURN_IF_ERROR(op->run(&default_reader));\n    }\n  }\n\n  // Check status of pool ops; this must come after the pool shuts down.\n  for (auto& op : pool_restore_ops) {\n    TF_RETURN_IF_ERROR(op->status);\n  }\n\n  for (auto i : sorted_name_idx) {\n    const string& tensor_name = tensor_names_flat(i);\n    if (dtypes[i] != context->mutable_output(i)->dtype()) {\n      return errors::InvalidArgument(\n          \"tensor_name = \", tensor_name, \"; expected dtype \",\n          DataTypeString(dtypes[i]), \" does not equal restored dtype \",\n          DataTypeString(context->mutable_output(i)->dtype()));\n    }\n  }\n\n  return Status::OK();\n}\n\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/save_restore_tensor.cc"], "buggy_code_start_loc": [154], "buggy_code_end_loc": [158], "fixing_code_start_loc": [154], "fixing_code_end_loc": [166], "type": "CWE-125", "message": "TensorFlow is an end-to-end open source platform for machine learning. When restoring tensors via raw APIs, if the tensor name is not provided, TensorFlow can be tricked into dereferencing a null pointer. Alternatively, attackers can read memory outside the bounds of heap allocated data by providing some tensor names but not enough for a successful restoration. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/save_restore_tensor.cc#L158-L159) retrieves the tensor list corresponding to the `tensor_name` user controlled input and immediately retrieves the tensor at the restoration index (controlled via `preferred_shard` argument). This occurs without validating that the provided list has enough values. If the list is empty this results in dereferencing a null pointer (undefined behavior). If, however, the list has some elements, if the restoration index is outside the bounds this results in heap OOB read. We have patched the issue in GitHub commit 9e82dce6e6bd1f36a57e08fa85af213e2b2f2622. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-37639", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-12T19:15:08.707", "lastModified": "2022-04-25T19:13:28.717", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. When restoring tensors via raw APIs, if the tensor name is not provided, TensorFlow can be tricked into dereferencing a null pointer. Alternatively, attackers can read memory outside the bounds of heap allocated data by providing some tensor names but not enough for a successful restoration. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/save_restore_tensor.cc#L158-L159) retrieves the tensor list corresponding to the `tensor_name` user controlled input and immediately retrieves the tensor at the restoration index (controlled via `preferred_shard` argument). This occurs without validating that the provided list has enough values. If the list is empty this results in dereferencing a null pointer (undefined behavior). If, however, the list has some elements, if the restoration index is outside the bounds this results in heap OOB read. We have patched the issue in GitHub commit 9e82dce6e6bd1f36a57e08fa85af213e2b2f2622. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico. Cuando se restauran tensores por medio de raw APIs, si no se proporciona el nombre del tensor, TensorFlow puede ser enga\u00f1ado para que haga desreferencia a un puntero null. Alternativamente, los atacantes pueden leer memoria fuera de l\u00edmites de los datos asignados a la pila al proporcionar algunos nombres de tensor pero no los suficientes para una restauraci\u00f3n con \u00e9xito. La [implementaci\u00f3n](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/save_restore_tensor.cc#L158-L159) recupera la lista de tensores correspondiente a la entrada controlada por el usuario \"tensor_name\" y recupera inmediatamente el tensor en el \u00edndice de restauraci\u00f3n (controlado por medio del argumento \"preferred_shard\"). Esto ocurre sin comprender que la lista proporcionada presenta suficientes valores. Si la lista est\u00e1 vac\u00eda esto resulta en una desreferenciaci\u00f3n de puntero null (comportamiento indefinido). Sin embargo, si la lista presenta algunos elementos, si el \u00edndice de restauraci\u00f3n est\u00e1 fuera de l\u00edmites esto resulta en una lectura OOB de la pila. Hemos parcheado el problema en el commit de GitHub 9e82dce6e6bd1f36a57e08fa85af213e2b2f2622. La correcci\u00f3n se incluir\u00e1 en TensorFlow versi\u00f3n 2.6.0. Tambi\u00e9n se incluir\u00e1 este commit en TensorFlow versi\u00f3n 2.5.1, TensorFlow versi\u00f3n 2.4.3, y TensorFlow versi\u00f3n 2.3.4, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda en el rango de soporte."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}, {"lang": "en", "value": "CWE-476"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.4", "matchCriteriaId": "0F83C081-51CC-415F-A8C0-0A44C75E2CD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.3", "matchCriteriaId": "BD3F2BF8-EBA9-42BF-8F9B-D918B880B15A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "D03E99A7-4E3D-427D-A156-C0713E9FB02A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "70FA6E48-6C57-40CA-809F-4E3D07CBF348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "42187561-E491-434D-828C-F36701446634"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C66B61C8-450A-4C5E-9174-F970D6DEE778"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/9e82dce6e6bd1f36a57e08fa85af213e2b2f2622", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-gh6x-4whr-2qv4", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/9e82dce6e6bd1f36a57e08fa85af213e2b2f2622"}}