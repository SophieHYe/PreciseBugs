{"buggy_code": ["# -*- coding: utf-8 -*-\n\nEXPERIMENTAL_STUFF = True\nMAXNFILES = 1000\n\nif EXPERIMENTAL_STUFF:\n    if is_mobile:\n        response.view = response.view.replace('default/', 'default.mobile/')\n        response.menu = []\n\nimport re\nfrom gluon.admin import *\nfrom gluon.fileutils import abspath, read_file, write_file\nfrom gluon.utils import web2py_uuid\nfrom gluon.tools import Config\nfrom gluon.compileapp import find_exposed_functions\nfrom glob import glob\nimport shutil\nimport platform\n\ntry:\n    import git\n    if git.__version__ < '0.3.1':\n        raise ImportError(\"Your version of git is %s. Upgrade to 0.3.1 or better.\" % git.__version__)\n    have_git = True\nexcept ImportError, e:\n    have_git = False\n    GIT_MISSING = 'Requires gitpython module, but not installed or incompatible version: %s' % e\n\nfrom gluon.languages import (read_possible_languages, read_dict, write_dict,\n                             read_plural_dict, write_plural_dict)\n\n\nif DEMO_MODE and request.function in ['change_password', 'pack',\n                                      'pack_custom', 'pack_plugin', 'upgrade_web2py', 'uninstall',\n                                      'cleanup', 'compile_app', 'remove_compiled_app', 'delete',\n                                      'delete_plugin', 'create_file', 'upload_file', 'update_languages',\n                                      'reload_routes', 'git_push', 'git_pull', 'install_plugin']:\n    session.flash = T('disabled in demo mode')\n    redirect(URL('site'))\n\nif is_gae and request.function in ('edit', 'edit_language',\n                                   'edit_plurals', 'update_languages', 'create_file', 'install_plugin'):\n    session.flash = T('disabled in GAE mode')\n    redirect(URL('site'))\n\nif not is_manager() and request.function in ['change_password', 'upgrade_web2py']:\n    session.flash = T('disabled in multi user mode')\n    redirect(URL('site'))\n\nif FILTER_APPS and request.args(0) and not request.args(0) in FILTER_APPS:\n    session.flash = T('disabled in demo mode')\n    redirect(URL('site'))\n\n\nif not session.token:\n    session.token = web2py_uuid()\n\n\ndef count_lines(data):\n    return len([line for line in data.split('\\n') if line.strip() and not line.startswith('#')])\n\n\ndef log_progress(app, mode='EDIT', filename=None, progress=0):\n    progress_file = os.path.join(apath(app, r=request), 'progress.log')\n    now = str(request.now)[:19]\n    if not os.path.exists(progress_file):\n        safe_open(progress_file, 'w').write('[%s] START\\n' % now)\n    if filename:\n        safe_open(progress_file, 'a').write(\n            '[%s] %s %s: %s\\n' % (now, mode, filename, progress))\n\n\ndef safe_open(a, b):\n    if (DEMO_MODE or is_gae) and ('w' in b or 'a' in b):\n        class tmp:\n\n            def write(self, data):\n                pass\n\n            def close(self):\n                pass\n        return tmp()\n    return open(a, b)\n\n\ndef safe_read(a, b='r'):\n    safe_file = safe_open(a, b)\n    try:\n        return safe_file.read()\n    finally:\n        safe_file.close()\n\n\ndef safe_write(a, value, b='w'):\n    safe_file = safe_open(a, b)\n    try:\n        safe_file.write(value)\n    finally:\n        safe_file.close()\n\n\ndef get_app(name=None):\n    app = name or request.args(0)\n    if (app and os.path.exists(apath(app, r=request)) and\n        (not MULTI_USER_MODE or is_manager() or\n         db(db.app.name == app)(db.app.owner == auth.user.id).count())):\n        return app\n    session.flash = T('App does not exist or you are not authorized')\n    redirect(URL('site'))\n\n\ndef index():\n    \"\"\" Index handler \"\"\"\n\n    send = request.vars.send\n    if DEMO_MODE:\n        session.authorized = True\n        session.last_time = t0\n    if not send:\n        send = URL('site')\n    if session.authorized:\n        redirect(send)\n    elif request.vars.password:\n        if verify_password(request.vars.password[:1024]):\n            session.authorized = True\n            login_record(True)\n\n            if CHECK_VERSION:\n                session.check_version = True\n            else:\n                session.check_version = False\n\n            session.last_time = t0\n            if isinstance(send, list):  # ## why does this happen?\n                send = str(send[0])\n\n            redirect(send)\n        else:\n            times_denied = login_record(False)\n            if times_denied >= allowed_number_of_attempts:\n                response.flash = \\\n                    T('admin disabled because too many invalid login attempts')\n            elif times_denied == allowed_number_of_attempts - 1:\n                response.flash = \\\n                    T('You have one more login attempt before you are locked out')\n            else:\n                response.flash = T('invalid password.')\n    return dict(send=send)\n\n\ndef check_version():\n    \"\"\" Checks if web2py is up to date \"\"\"\n\n    session.forget()\n    session._unlock(response)\n\n    new_version, version = check_new_version(request.env.web2py_version,\n                                             WEB2PY_VERSION_URL)\n\n    if new_version == -1:\n        return A(T('Unable to check for upgrades'), _href=WEB2PY_URL)\n    elif new_version != True:\n        return A(T('web2py is up to date'), _href=WEB2PY_URL)\n    elif platform.system().lower() in ('windows', 'win32', 'win64') and os.path.exists(\"web2py.exe\"):\n        return SPAN('You should upgrade to %s' % version.split('(')[0])\n    else:\n        return sp_button(URL('upgrade_web2py'), T('upgrade now to %s') % version.split('(')[0])\n\n\ndef logout():\n    \"\"\" Logout handler \"\"\"\n    session.authorized = None\n    if MULTI_USER_MODE:\n        redirect(URL('user/logout'))\n    redirect(URL('index'))\n\n\ndef change_password():\n\n    if session.pam_user:\n        session.flash = T(\n            'PAM authenticated user, cannot change password here')\n        redirect(URL('site'))\n    form = SQLFORM.factory(Field('current_admin_password', 'password'),\n                           Field('new_admin_password',\n                                 'password', requires=IS_STRONG()),\n                           Field('new_admin_password_again', 'password'),\n                           _class=\"span4 well\")\n    if form.accepts(request.vars):\n        if not verify_password(request.vars.current_admin_password):\n            form.errors.current_admin_password = T('invalid password')\n        elif form.vars.new_admin_password != form.vars.new_admin_password_again:\n            form.errors.new_admin_password_again = T('no match')\n        else:\n            path = abspath('parameters_%s.py' % request.env.server_port)\n            safe_write(path, 'password=\"%s\"' % CRYPT()(\n                request.vars.new_admin_password)[0])\n            session.flash = T('password changed')\n            redirect(URL('site'))\n    return dict(form=form)\n\n\ndef site():\n    \"\"\" Site handler \"\"\"\n\n    myversion = request.env.web2py_version\n\n    # Shortcut to make the elif statements more legible\n    file_or_appurl = 'file' in request.vars or 'appurl' in request.vars\n\n    class IS_VALID_APPNAME(object):\n\n        def __call__(self, value):\n            if not re.compile('^\\w+$').match(value):\n                return (value, T('Invalid application name'))\n            if not request.vars.overwrite and \\\n                    os.path.exists(os.path.join(apath(r=request), value)):\n                return (value, T('Application exists already'))\n            return (value, None)\n\n    is_appname = IS_VALID_APPNAME()\n    form_create = SQLFORM.factory(Field('name', requires=is_appname),\n                                  table_name='appcreate')\n    form_update = SQLFORM.factory(Field('name', requires=is_appname),\n                                  Field('file', 'upload', uploadfield=False),\n                                  Field('url'),\n                                  Field('overwrite', 'boolean'),\n                                  table_name='appupdate')\n    form_create.process()\n    form_update.process()\n\n    if DEMO_MODE:\n        pass\n\n    elif form_create.accepted:\n        # create a new application\n        appname = cleanpath(form_create.vars.name)\n        created, error = app_create(appname, request, info=True)\n        if created:\n            if MULTI_USER_MODE:\n                db.app.insert(name=appname, owner=auth.user.id)\n            log_progress(appname)\n            session.flash = T('new application \"%s\" created', appname)\n            redirect(URL('design', args=appname))\n        else:\n            session.flash = \\\n                DIV(T('unable to create application \"%s\"', appname),\n                    PRE(error))\n        redirect(URL(r=request))\n\n    elif form_update.accepted:\n        if (form_update.vars.url or '').endswith('.git'):\n            if not have_git:\n                session.flash = GIT_MISSING\n                redirect(URL(r=request))\n            target = os.path.join(apath(r=request), form_update.vars.name)\n            try:\n                new_repo = git.Repo.clone_from(form_update.vars.url, target)\n                session.flash = T('new application \"%s\" imported',\n                                  form_update.vars.name)\n            except git.GitCommandError, err:\n                session.flash = T('Invalid git repository specified.')\n            redirect(URL(r=request))\n\n        elif form_update.vars.url:\n            # fetch an application via URL or file upload\n            try:\n                f = urllib.urlopen(form_update.vars.url)\n                if f.code == 404:\n                    raise Exception(\"404 file not found\")\n            except Exception, e:\n                session.flash = \\\n                    DIV(T('Unable to download app because:'), PRE(repr(e)))\n                redirect(URL(r=request))\n            fname = form_update.vars.url\n\n        elif form_update.accepted and form_update.vars.file:\n            fname = request.vars.file.filename\n            f = request.vars.file.file\n\n        else:\n            session.flash = 'No file uploaded and no URL specified'\n            redirect(URL(r=request))\n\n        if f:\n            appname = cleanpath(form_update.vars.name)\n            installed = app_install(appname, f,\n                                    request, fname,\n                                    overwrite=form_update.vars.overwrite)\n        if f and installed:\n            msg = 'application %(appname)s installed with md5sum: %(digest)s'\n            if MULTI_USER_MODE:\n                db.app.insert(name=appname, owner=auth.user.id)\n            log_progress(appname)\n            session.flash = T(msg, dict(appname=appname,\n                                        digest=md5_hash(installed)))\n        else:\n            msg = 'unable to install application \"%(appname)s\"'\n            session.flash = T(msg, dict(appname=form_update.vars.name))\n        redirect(URL(r=request))\n\n    regex = re.compile('^\\w+$')\n\n    if is_manager():\n        apps = [f for f in os.listdir(apath(r=request)) if regex.match(f)]\n    else:\n        apps = [f.name for f in db(db.app.owner == auth.user_id).select()]\n\n    if FILTER_APPS:\n        apps = [f for f in apps if f in FILTER_APPS]\n\n    apps = sorted(apps, lambda a, b: cmp(a.upper(), b.upper()))\n    myplatform = platform.python_version()\n    return dict(app=None, apps=apps, myversion=myversion, myplatform=myplatform,\n                form_create=form_create, form_update=form_update)\n\n\ndef report_progress(app):\n    import datetime\n    progress_file = os.path.join(apath(app, r=request), 'progress.log')\n    regex = re.compile('\\[(.*?)\\][^\\:]+\\:\\s+(\\-?\\d+)')\n    if not os.path.exists(progress_file):\n        return []\n    matches = regex.findall(open(progress_file, 'r').read())\n    events, counter = [], 0\n    for m in matches:\n        if not m:\n            continue\n        days = -(request.now - datetime.datetime.strptime(m[0],\n                                                          '%Y-%m-%d %H:%M:%S')).days\n        counter += int(m[1])\n        events.append([days, counter])\n    return events\n\n\ndef pack():\n    app = get_app()\n\n    try:\n        if len(request.args) == 1:\n            fname = 'web2py.app.%s.w2p' % app\n            filename = app_pack(app, request, raise_ex=True)\n        else:\n            fname = 'web2py.app.%s.compiled.w2p' % app\n            filename = app_pack_compiled(app, request, raise_ex=True)\n    except Exception, e:\n        filename = None\n\n    if filename:\n        response.headers['Content-Type'] = 'application/w2p'\n        disposition = 'attachment; filename=%s' % fname\n        response.headers['Content-Disposition'] = disposition\n        return safe_read(filename, 'rb')\n    else:\n        session.flash = T('internal error: %s', e)\n        redirect(URL('site'))\n\n\ndef pack_plugin():\n    app = get_app()\n    if len(request.args) == 2:\n        fname = 'web2py.plugin.%s.w2p' % request.args[1]\n        filename = plugin_pack(app, request.args[1], request)\n    if filename:\n        response.headers['Content-Type'] = 'application/w2p'\n        disposition = 'attachment; filename=%s' % fname\n        response.headers['Content-Disposition'] = disposition\n        return safe_read(filename, 'rb')\n    else:\n        session.flash = T('internal error')\n        redirect(URL('plugin', args=request.args))\n\n\ndef pack_exe(app, base, filenames=None):\n    import urllib\n    import zipfile\n    from cStringIO import StringIO\n    # Download latest web2py_win and open it with zipfile\n    download_url = 'http://www.web2py.com/examples/static/web2py_win.zip'\n    out = StringIO()\n    out.write(urllib.urlopen(download_url).read())\n    web2py_win = zipfile.ZipFile(out, mode='a')\n    # Write routes.py with the application as default\n    routes = u'# -*- coding: utf-8 -*-\\nrouters = dict(BASE=dict(default_application=\"%s\"))' % app\n    web2py_win.writestr('web2py/routes.py', routes.encode('utf-8'))\n    # Copy the application into the zipfile\n    common_root = os.path.dirname(base)\n    for filename in filenames:\n        fname = os.path.join(base, filename)\n        arcname = os.path.join('web2py/applications', app, filename)\n        web2py_win.write(fname, arcname)\n    web2py_win.close()\n    response.headers['Content-Type'] = 'application/zip'\n    response.headers['Content-Disposition'] = 'attachment; filename=web2py.app.%s.zip' % app\n    out.seek(0)\n    return response.stream(out)\n\n\ndef pack_custom():\n    app = get_app()\n    base = apath(app, r=request)\n\n    def ignore(fs):\n        return [f for f in fs if not (\n                f[:1] in '#' or f.endswith('~') or f.endswith('.bak'))]\n    files = {}\n    for (r, d, f) in os.walk(base):\n        files[r] = {'folders': ignore(d), 'files': ignore(f)}\n\n    if request.post_vars.file:\n        valid_set = set(os.path.relpath(os.path.join(r, f), base) for r in files for f in files[r]['files'])\n        files = request.post_vars.file\n        files = [files] if not isinstance(files, list) else files\n        files = [file for file in files if file in valid_set]\n\n        if request.post_vars.doexe is None:\n            fname = 'web2py.app.%s.w2p' % app\n            try:\n                filename = app_pack(app, request, raise_ex=True, filenames=files)\n            except Exception, e:\n                filename = None\n            if filename:\n                response.headers['Content-Type'] = 'application/w2p'\n                disposition = 'attachment; filename=%s' % fname\n                response.headers['Content-Disposition'] = disposition\n                return safe_read(filename, 'rb')\n            else:\n                session.flash = T('internal error: %s', e)\n                redirect(URL(args=request.args))\n        else:\n            return pack_exe(app, base, files)\n\n    return locals()\n\n\ndef upgrade_web2py():\n    dialog = FORM.confirm(T('Upgrade'),\n                          {T('Cancel'): URL('site')})\n    if dialog.accepted:\n        (success, error) = upgrade(request)\n        if success:\n            session.flash = T('web2py upgraded; please restart it')\n        else:\n            session.flash = T('unable to upgrade because \"%s\"', error)\n        redirect(URL('site'))\n    return dict(dialog=dialog)\n\n\ndef uninstall():\n    app = get_app()\n\n    dialog = FORM.confirm(T('Uninstall'),\n                          {T('Cancel'): URL('site')})\n    dialog['_id'] = 'confirm_form'\n    dialog['_class'] = 'well'\n    for component in dialog.components:\n        component['_class'] = 'btn'\n\n    if dialog.accepted:\n        if MULTI_USER_MODE:\n            if is_manager() and db(db.app.name == app).delete():\n                pass\n            elif db(db.app.name == app)(db.app.owner == auth.user.id).delete():\n                pass\n            else:\n                session.flash = T('no permission to uninstall \"%s\"', app)\n                redirect(URL('site'))\n        try:\n            filename = app_pack(app, request, raise_ex=True)\n        except:\n            session.flash = T('unable to uninstall \"%s\"', app)\n        else:\n            if app_uninstall(app, request):\n                session.flash = T('application \"%s\" uninstalled', app)\n            else:\n                session.flash = T('unable to uninstall \"%s\"', app)\n        redirect(URL('site'))\n    return dict(app=app, dialog=dialog)\n\n\ndef cleanup():\n    app = get_app()\n    clean = app_cleanup(app, request)\n    if not clean:\n        session.flash = T(\"some files could not be removed\")\n    else:\n        session.flash = T('cache, errors and sessions cleaned')\n\n    redirect(URL('site'))\n\n\ndef compile_app():\n    app = get_app()\n    c = app_compile(app, request,\n                    skip_failed_views=(request.args(1) == 'skip_failed_views'))\n    if not c:\n        session.flash = T('application compiled')\n    elif isinstance(c, list):\n        session.flash = DIV(*[T('application compiled'), BR(), BR(),\n                              T('WARNING: The following views could not be compiled:'), BR()] +\n                            [CAT(BR(), view) for view in c] +\n                            [BR(), BR(), T('DO NOT use the \"Pack compiled\" feature.')])\n    else:\n        session.flash = DIV(T('Cannot compile: there are errors in your app:'),\n                            CODE(c))\n    redirect(URL('site'))\n\n\ndef remove_compiled_app():\n    \"\"\" Remove the compiled application \"\"\"\n    app = get_app()\n    remove_compiled_application(apath(app, r=request))\n    session.flash = T('compiled application removed')\n    redirect(URL('site'))\n\n\ndef delete():\n    \"\"\" Object delete handler \"\"\"\n    app = get_app()\n    filename = '/'.join(request.args)\n    sender = request.vars.sender\n\n    if isinstance(sender, list):  # ## fix a problem with Vista\n        sender = sender[0]\n\n    dialog = FORM.confirm(T('Delete'),\n                          {T('Cancel'): URL(sender, anchor=request.vars.id)})\n\n    if dialog.accepted:\n        try:\n            full_path = apath(filename, r=request)\n            lineno = count_lines(open(full_path, 'r').read())\n            os.unlink(full_path)\n            log_progress(app, 'DELETE', filename, progress=-lineno)\n            session.flash = T('file \"%(filename)s\" deleted',\n                              dict(filename=filename))\n        except Exception:\n            session.flash = T('unable to delete file \"%(filename)s\"',\n                              dict(filename=filename))\n        redirect(URL(sender, anchor=request.vars.id2))\n    return dict(dialog=dialog, filename=filename)\n\ndef enable():\n    if not URL.verify(request, hmac_key=session.hmac_key): raise HTTP(401)\n    app = get_app()\n    filename = os.path.join(apath(app, r=request), 'DISABLED')\n    if is_gae:\n        return SPAN(T('Not supported'), _style='color:yellow')\n    elif os.path.exists(filename):\n        os.unlink(filename)\n        return SPAN(T('Disable'), _style='color:green')\n    else:\n        safe_open(filename, 'wb').write('disabled: True\\ntime-disabled: %s' % request.now)\n        return SPAN(T('Enable'), _style='color:red')\n\n\ndef peek():\n    \"\"\" Visualize object code \"\"\"\n    app = get_app(request.vars.app)\n    filename = '/'.join(request.args)\n    if request.vars.app:\n        path = abspath(filename)\n    else:\n        path = apath(filename, r=request)\n    try:\n        data = safe_read(path).replace('\\r', '')\n    except IOError:\n        session.flash = T('file does not exist')\n        redirect(URL('site'))\n\n    extension = filename[filename.rfind('.') + 1:].lower()\n\n    return dict(app=app,\n                filename=filename,\n                data=data,\n                extension=extension)\n\n\ndef test():\n    \"\"\" Execute controller tests \"\"\"\n    app = get_app()\n    if len(request.args) > 1:\n        file = request.args[1]\n    else:\n        file = '.*\\.py'\n\n    controllers = listdir(\n        apath('%s/controllers/' % app, r=request), file + '$')\n\n    return dict(app=app, controllers=controllers)\n\n\ndef keepalive():\n    return ''\n\n\ndef search():\n    keywords = request.vars.keywords or ''\n    app = get_app()\n\n    def match(filename, keywords):\n        filename = os.path.join(apath(app, r=request), filename)\n        if keywords in read_file(filename, 'rb'):\n            return True\n        return False\n    path = apath(request.args[0], r=request)\n    files1 = glob(os.path.join(path, '*/*.py'))\n    files2 = glob(os.path.join(path, '*/*.html'))\n    files3 = glob(os.path.join(path, '*/*/*.html'))\n    files = [x[len(path) + 1:].replace(\n        '\\\\', '/') for x in files1 + files2 + files3 if match(x, keywords)]\n    return response.json(dict(files=files, message=T.M('Searching: **%s** %%{file}', len(files))))\n\n\ndef edit():\n    \"\"\" File edit handler \"\"\"\n    # Load json only if it is ajax edited...\n    app = get_app(request.vars.app)\n    app_path = apath(app, r=request)\n    preferences = {'theme': 'web2py', 'editor': 'default', 'closetag': 'true', 'codefolding': 'false', 'tabwidth': '4', 'indentwithtabs': 'false', 'linenumbers': 'true', 'highlightline': 'true'}\n    config = Config(os.path.join(request.folder, 'settings.cfg'),\n                    section='editor', default_values={})\n    preferences.update(config.read())\n\n    if not(request.ajax) and not(is_mobile):\n        # return the scaffolding, the rest will be through ajax requests\n        response.title = T('Editing %s') % app\n        return response.render('default/edit.html', dict(app=app, editor_settings=preferences))\n\n    # show settings tab and save prefernces\n    if 'settings' in request.vars:\n        if request.post_vars:  # save new preferences\n            post_vars = request.post_vars.items()\n            # Since unchecked checkbox are not serialized, we must set them as false by hand to store the correct preference in the settings\n            post_vars += [(opt, 'false') for opt in preferences if opt not in request.post_vars]\n            if config.save(post_vars):\n                response.headers[\"web2py-component-flash\"] = T('Preferences saved correctly')\n            else:\n                response.headers[\"web2py-component-flash\"] = T('Preferences saved on session only')\n            response.headers[\"web2py-component-command\"] = \"update_editor(%s);$('a[href=#editor_settings] button.close').click();\" % response.json(config.read())\n            return\n        else:\n            details = {'realfilename': 'settings', 'filename': 'settings', 'id': 'editor_settings', 'force': False}\n            details['plain_html'] = response.render('default/editor_settings.html', {'editor_settings': preferences})\n            return response.json(details)\n\n    \"\"\" File edit handler \"\"\"\n    # Load json only if it is ajax edited...\n    app = get_app(request.vars.app)\n    filename = '/'.join(request.args)\n    realfilename = request.args[-1]\n    if request.vars.app:\n        path = abspath(filename)\n    else:\n        path = apath(filename, r=request)\n    # Try to discover the file type\n    if filename[-3:] == '.py':\n        filetype = 'python'\n    elif filename[-5:] == '.html':\n        filetype = 'html'\n    elif filename[-5:] == '.load':\n        filetype = 'html'\n    elif filename[-4:] == '.css':\n        filetype = 'css'\n    elif filename[-3:] == '.js':\n        filetype = 'javascript'\n    else:\n        filetype = 'html'\n\n    # ## check if file is not there\n    if ('revert' in request.vars) and os.path.exists(path + '.bak'):\n        try:\n            data = safe_read(path + '.bak')\n            data1 = safe_read(path)\n        except IOError:\n            session.flash = T('Invalid action')\n            if 'from_ajax' in request.vars:\n                return response.json({'error': str(T('Invalid action'))})\n            else:\n                redirect(URL('site'))\n\n        safe_write(path, data)\n        file_hash = md5_hash(data)\n        saved_on = time.ctime(os.stat(path)[stat.ST_MTIME])\n        safe_write(path + '.bak', data1)\n        response.flash = T('file \"%s\" of %s restored', (filename, saved_on))\n    else:\n        try:\n            data = safe_read(path)\n        except IOError:\n            session.flash = T('Invalid action')\n            if 'from_ajax' in request.vars:\n                return response.json({'error': str(T('Invalid action'))})\n            else:\n                redirect(URL('site'))\n\n        lineno_old = count_lines(data)\n        file_hash = md5_hash(data)\n        saved_on = time.ctime(os.stat(path)[stat.ST_MTIME])\n\n        if request.vars.file_hash and request.vars.file_hash != file_hash:\n            session.flash = T('file changed on disk')\n            data = request.vars.data.replace('\\r\\n', '\\n').strip() + '\\n'\n            safe_write(path + '.1', data)\n            if 'from_ajax' in request.vars:\n                return response.json({'error': str(T('file changed on disk')),\n                                      'redirect': URL('resolve',\n                                                      args=request.args)})\n            else:\n                redirect(URL('resolve', args=request.args))\n        elif request.vars.data:\n            safe_write(path + '.bak', data)\n            data = request.vars.data.replace('\\r\\n', '\\n').strip() + '\\n'\n            safe_write(path, data)\n            lineno_new = count_lines(data)\n            log_progress(\n                app, 'EDIT', filename, progress=lineno_new - lineno_old)\n            file_hash = md5_hash(data)\n            saved_on = time.ctime(os.stat(path)[stat.ST_MTIME])\n            response.flash = T('file saved on %s', saved_on)\n\n    data_or_revert = (request.vars.data or request.vars.revert)\n\n    # Check compile errors\n    highlight = None\n    if filetype == 'python' and request.vars.data:\n        import _ast\n        try:\n            code = request.vars.data.rstrip().replace('\\r\\n', '\\n') + '\\n'\n            compile(code, path, \"exec\", _ast.PyCF_ONLY_AST)\n        except Exception, e:\n            # offset calculation is only used for textarea (start/stop)\n            start = sum([len(line) + 1 for l, line\n                         in enumerate(request.vars.data.split(\"\\n\"))\n                         if l < e.lineno - 1])\n            if e.text and e.offset:\n                offset = e.offset - (len(e.text) - len(\n                    e.text.splitlines()[-1]))\n            else:\n                offset = 0\n            highlight = {'start': start, 'end': start +\n                         offset + 1, 'lineno': e.lineno, 'offset': offset}\n            try:\n                ex_name = e.__class__.__name__\n            except:\n                ex_name = 'unknown exception!'\n            response.flash = DIV(T('failed to compile file because:'), BR(),\n                                 B(ex_name), ' ' + T('at line %s', e.lineno),\n                                 offset and ' ' +\n                                 T('at char %s', offset) or '',\n                                 PRE(repr(e)))\n    if data_or_revert and request.args[1] == 'modules':\n        # Lets try to reload the modules\n        try:\n            mopath = '.'.join(request.args[2:])[:-3]\n            exec 'import applications.%s.modules.%s' % (\n                request.args[0], mopath)\n            reload(sys.modules['applications.%s.modules.%s'\n                               % (request.args[0], mopath)])\n        except Exception, e:\n            response.flash = DIV(\n                T('failed to reload module because:'), PRE(repr(e)))\n\n    edit_controller = None\n    editviewlinks = None\n    view_link = None\n    if filetype == 'html' and len(request.args) >= 3:\n        cfilename = os.path.join(request.args[0], 'controllers',\n                                 request.args[2] + '.py')\n        if os.path.exists(apath(cfilename, r=request)):\n            edit_controller = URL('edit', args=[cfilename.replace(os.sep, \"/\")])\n            view = request.args[3].replace('.html', '')\n            view_link = URL(request.args[0], request.args[2], view)\n    elif filetype == 'python' and request.args[1] == 'controllers':\n        # it's a controller file.\n        # Create links to all of the associated view files.\n        app = get_app()\n        viewname = os.path.splitext(request.args[2])[0]\n        viewpath = os.path.join(app, 'views', viewname)\n        aviewpath = apath(viewpath, r=request)\n        viewlist = []\n        if os.path.exists(aviewpath):\n            if os.path.isdir(aviewpath):\n                viewlist = glob(os.path.join(aviewpath, '*.html'))\n        elif os.path.exists(aviewpath + '.html'):\n            viewlist.append(aviewpath + '.html')\n        if len(viewlist):\n            editviewlinks = []\n            for v in sorted(viewlist):\n                vf = os.path.split(v)[-1]\n                vargs = \"/\".join([viewpath.replace(os.sep, \"/\"), vf])\n                editviewlinks.append(A(vf.split(\".\")[0],\n                                       _class=\"editor_filelink\",\n                                       _href=URL('edit', args=[vargs])))\n\n    if len(request.args) > 2 and request.args[1] == 'controllers':\n        controller = (request.args[2])[:-3]\n        functions = find_exposed_functions(data)\n        functions = functions and sorted(functions) or []\n    else:\n        (controller, functions) = (None, None)\n\n    if 'from_ajax' in request.vars:\n        return response.json({'file_hash': file_hash, 'saved_on': saved_on, 'functions': functions, 'controller': controller, 'application': request.args[0], 'highlight': highlight})\n    else:\n        file_details = dict(app=request.args[0],\n                            lineno=request.vars.lineno or 1,\n                            editor_settings=preferences,\n                            filename=filename,\n                            realfilename=realfilename,\n                            filetype=filetype,\n                            data=data,\n                            edit_controller=edit_controller,\n                            file_hash=file_hash,\n                            saved_on=saved_on,\n                            controller=controller,\n                            functions=functions,\n                            view_link=view_link,\n                            editviewlinks=editviewlinks,\n                            id=IS_SLUG()(filename)[0],\n                            force=True if (request.vars.restore or\n                                           request.vars.revert) else False)\n        plain_html = response.render('default/edit_js.html', file_details)\n        file_details['plain_html'] = plain_html\n        if is_mobile:\n            return response.render('default.mobile/edit.html',\n                                   file_details, editor_settings=preferences)\n        else:\n            return response.json(file_details)\n\n\ndef todolist():\n    \"\"\" Returns all TODO of the requested app\n    \"\"\"\n    app = request.vars.app or ''\n    app_path = apath('%(app)s' % {'app': app}, r=request)\n    dirs = ['models', 'controllers', 'modules', 'private']\n\n    def listfiles(app, dir, regexp='.*\\.py$'):\n        files = sorted(listdir(apath('%(app)s/%(dir)s/' % {'app': app, 'dir': dir}, r=request), regexp))\n        files = [x.replace(os.path.sep, '/') for x in files if not x.endswith('.bak')]\n        return files\n\n    pattern = '#\\s*(todo)+\\s+(.*)'\n    regex = re.compile(pattern, re.IGNORECASE)\n\n    output = []\n    for d in dirs:\n        for f in listfiles(app, d):\n            matches = []\n            filename = apath(os.path.join(app, d, f), r=request)\n            with open(filename, 'r') as f_s:\n                src = f_s.read()\n                for m in regex.finditer(src):\n                    start = m.start()\n                    lineno = src.count('\\n', 0, start) + 1\n                    matches.append({'text': m.group(0), 'lineno': lineno})\n            if len(matches) != 0:\n                output.append({'filename': f, 'matches': matches, 'dir': d})\n\n    return {'todo': output, 'app': app}\n\n\ndef editor_sessions():\n    config = Config(os.path.join(request.folder, 'settings.cfg'),\n                    section='editor_sessions', default_values={})\n    preferences = config.read()\n\n    if request.vars.session_name and request.vars.files:\n        session_name = request.vars.session_name\n        files = request.vars.files\n        preferences.update({session_name: ','.join(files)})\n        if config.save(preferences.items()):\n            response.headers[\"web2py-component-flash\"] = T('Session saved correctly')\n        else:\n            response.headers[\"web2py-component-flash\"] = T('Session saved on session only')\n\n    return response.render('default/editor_sessions.html', {'editor_sessions': preferences})\n\n\ndef resolve():\n    \"\"\"\n    \"\"\"\n\n    filename = '/'.join(request.args)\n    # ## check if file is not there\n    path = apath(filename, r=request)\n    a = safe_read(path).split('\\n')\n    try:\n        b = safe_read(path + '.1').split('\\n')\n    except IOError:\n        session.flash = 'Other file, no longer there'\n        redirect(URL('edit', args=request.args))\n\n    d = difflib.ndiff(a, b)\n\n    def leading(line):\n        \"\"\"  \"\"\"\n\n        # TODO: we really need to comment this\n        z = ''\n        for (k, c) in enumerate(line):\n            if c == ' ':\n                z += '&nbsp;'\n            elif c == ' \\t':\n                z += '&nbsp;'\n            elif k == 0 and c == '?':\n                pass\n            else:\n                break\n\n        return XML(z)\n\n    def getclass(item):\n        \"\"\" Determine item class \"\"\"\n        operators = {' ': 'normal', '+': 'plus', '-': 'minus'}\n\n        return operators[item[0]]\n\n    if request.vars:\n        c = '\\n'.join([item[2:].rstrip() for (i, item) in enumerate(d) if item[0]\n                       == ' ' or 'line%i' % i in request.vars])\n        safe_write(path, c)\n        session.flash = 'files merged'\n        redirect(URL('edit', args=request.args))\n    else:\n        # Making the short circuit compatible with <= python2.4\n        gen_data = lambda index, item: not item[:1] in ['+', '-'] and \"\" \\\n            or INPUT(_type='checkbox',\n                     _name='line%i' % index,\n                     value=item[0] == '+')\n\n        diff = TABLE(*[TR(TD(gen_data(i, item)),\n                          TD(item[0]),\n                          TD(leading(item[2:]),\n                             TT(item[2:].rstrip())),\n                          _class=getclass(item))\n                       for (i, item) in enumerate(d) if item[0] != '?'])\n\n    return dict(diff=diff, filename=filename)\n\n\ndef edit_language():\n    \"\"\" Edit language file \"\"\"\n    app = get_app()\n    filename = '/'.join(request.args)\n    response.title = request.args[-1]\n    strings = read_dict(apath(filename, r=request))\n\n    if '__corrupted__' in strings:\n        form = SPAN(strings['__corrupted__'], _class='error')\n        return dict(filename=filename, form=form)\n\n    keys = sorted(strings.keys(), lambda x, y: cmp(\n        unicode(x, 'utf-8').lower(), unicode(y, 'utf-8').lower()))\n    rows = []\n    rows.append(H2(T('Original/Translation')))\n\n    for key in keys:\n        name = md5_hash(key)\n        s = strings[key]\n        (prefix, sep, key) = key.partition('\\x01')\n        if sep:\n            prefix = SPAN(prefix + ': ', _class='tm_ftag')\n            k = key\n        else:\n            (k, prefix) = (prefix, '')\n\n        _class = 'untranslated' if k == s else 'translated'\n\n        if len(s) <= 40:\n            elem = INPUT(_type='text', _name=name, value=s,\n                         _size=70, _class=_class)\n        else:\n            elem = TEXTAREA(_name=name, value=s, _cols=70,\n                            _rows=5, _class=_class)\n\n        # Making the short circuit compatible with <= python2.4\n        k = (s != k) and k or B(k)\n\n        new_row = DIV(LABEL(prefix, k, _style=\"font-weight:normal;\"),\n                      CAT(elem, '\\n', TAG.BUTTON(\n                          T('delete'),\n                          _onclick='return delkey(\"%s\")' % name,\n                          _class='btn')), _id=name, _class='span6 well well-small')\n\n        rows.append(DIV(new_row, _class=\"row-fluid\"))\n    rows.append(DIV(INPUT(_type='submit', _value=T('update'), _class=\"btn btn-primary\"), _class='controls'))\n    form = FORM(*rows)\n    if form.accepts(request.vars, keepvalues=True):\n        strs = dict()\n        for key in keys:\n            name = md5_hash(key)\n            if form.vars[name] == chr(127):\n                continue\n            strs[key] = form.vars[name]\n        write_dict(apath(filename, r=request), strs)\n        session.flash = T('file saved on %(time)s', dict(time=time.ctime()))\n        redirect(URL(r=request, args=request.args))\n    return dict(app=request.args[0], filename=filename, form=form)\n\n\ndef edit_plurals():\n    \"\"\" Edit plurals file \"\"\"\n    app = get_app()\n    filename = '/'.join(request.args)\n    plurals = read_plural_dict(\n        apath(filename, r=request))  # plural forms dictionary\n    nplurals = int(request.vars.nplurals) - 1  # plural forms quantity\n    xnplurals = xrange(nplurals)\n\n    if '__corrupted__' in plurals:\n        # show error message and exit\n        form = SPAN(plurals['__corrupted__'], _class='error')\n        return dict(filename=filename, form=form)\n\n    keys = sorted(plurals.keys(), lambda x, y: cmp(\n        unicode(x, 'utf-8').lower(), unicode(y, 'utf-8').lower()))\n    tab_rows = []\n    for key in keys:\n        name = md5_hash(key)\n        forms = plurals[key]\n\n        if len(forms) < nplurals:\n            forms.extend(None for i in xrange(nplurals - len(forms)))\n        tab_col1 = DIV(CAT(LABEL(T(\"Singular Form\")), B(key,\n                                                        _class='fake-input')))\n        tab_inputs = [SPAN(LABEL(T(\"Plural Form #%s\", n + 1)), INPUT(_type='text', _name=name + '_' + str(n), value=forms[n], _size=20), _class='span6') for n in xnplurals]\n        tab_col2 = DIV(CAT(*tab_inputs))\n        tab_col3 = DIV(CAT(LABEL(XML('&nbsp;')), TAG.BUTTON(T('delete'), _onclick='return delkey(\"%s\")' % name, _class='btn'), _class='span6'))\n        tab_row = DIV(DIV(tab_col1, '\\n', tab_col2, '\\n', tab_col3, _class='well well-small'), _id=name, _class='row-fluid tab_row')\n        tab_rows.append(tab_row)\n\n    tab_rows.append(DIV(TAG['button'](T('update'), _type='submit',\n                                      _class='btn btn-primary'),\n                        _class='controls'))\n    tab_container = DIV(*tab_rows, **dict(_class=\"row-fluid\"))\n\n    form = FORM(tab_container)\n    if form.accepts(request.vars, keepvalues=True):\n        new_plurals = dict()\n        for key in keys:\n            name = md5_hash(key)\n            if form.vars[name + '_0'] == chr(127):\n                continue\n            new_plurals[key] = [form.vars[name + '_' + str(n)]\n                                for n in xnplurals]\n        write_plural_dict(apath(filename, r=request), new_plurals)\n        session.flash = T('file saved on %(time)s', dict(time=time.ctime()))\n        redirect(URL(r=request, args=request.args, vars=dict(\n            nplurals=request.vars.nplurals)))\n    return dict(app=request.args[0], filename=filename, form=form)\n\n\ndef about():\n    \"\"\" Read about info \"\"\"\n    app = get_app()\n    # ## check if file is not there\n    about = safe_read(apath('%s/ABOUT' % app, r=request))\n    license = safe_read(apath('%s/LICENSE' % app, r=request))\n    return dict(app=app, about=MARKMIN(about), license=MARKMIN(license), progress=report_progress(app))\n\n\ndef design():\n    \"\"\" Application design handler \"\"\"\n    app = get_app()\n\n    if not response.flash and app == request.application:\n        msg = T('ATTENTION: you cannot edit the running application!')\n        response.flash = msg\n\n    if request.vars and not request.vars.token == session.token:\n        redirect(URL('logout'))\n\n    if request.vars.pluginfile is not None and not isinstance(request.vars.pluginfile, str):\n        filename = os.path.basename(request.vars.pluginfile.filename)\n        if plugin_install(app, request.vars.pluginfile.file,\n                          request, filename):\n            session.flash = T('new plugin installed')\n            redirect(URL('design', args=app))\n        else:\n            session.flash = \\\n                T('unable to create application \"%s\"', request.vars.filename)\n        redirect(URL(r=request))\n    elif isinstance(request.vars.pluginfile, str):\n        session.flash = T('plugin not specified')\n        redirect(URL(r=request))\n\n    # If we have only pyc files it means that\n    # we cannot design\n    if os.path.exists(apath('%s/compiled' % app, r=request)):\n        session.flash = \\\n            T('application is compiled and cannot be designed')\n        redirect(URL('site'))\n\n    # Get all models\n    models = listdir(apath('%s/models/' % app, r=request), '.*\\.py$')\n    models = [x.replace('\\\\', '/') for x in models]\n    defines = {}\n    for m in models:\n        data = safe_read(apath('%s/models/%s' % (app, m), r=request))\n        defines[m] = regex_tables.findall(data)\n        defines[m].sort()\n\n    # Get all controllers\n    controllers = sorted(\n        listdir(apath('%s/controllers/' % app, r=request), '.*\\.py$'))\n    controllers = [x.replace('\\\\', '/') for x in controllers]\n    functions = {}\n    for c in controllers:\n        data = safe_read(apath('%s/controllers/%s' % (app, c), r=request))\n        items = find_exposed_functions(data)\n        functions[c] = items and sorted(items) or []\n\n    # Get all views\n    views = sorted(\n        listdir(apath('%s/views/' % app, r=request), '[\\w/\\-]+(\\.\\w+)+$'))\n    views = [x.replace('\\\\', '/') for x in views if not x.endswith('.bak')]\n    extend = {}\n    include = {}\n    for c in views:\n        data = safe_read(apath('%s/views/%s' % (app, c), r=request))\n        items = regex_extend.findall(data)\n\n        if items:\n            extend[c] = items[0][1]\n\n        items = regex_include.findall(data)\n        include[c] = [i[1] for i in items]\n\n    # Get all modules\n    modules = listdir(apath('%s/modules/' % app, r=request), '.*\\.py$')\n    modules = modules = [x.replace('\\\\', '/') for x in modules]\n    modules.sort()\n\n    # Get all private files\n    privates = listdir(apath('%s/private/' % app, r=request), '[^\\.#].*')\n    privates = [x.replace('\\\\', '/') for x in privates]\n    privates.sort()\n\n    # Get all static files\n    statics = listdir(apath('%s/static/' % app, r=request), '[^\\.#].*',\n                      maxnum=MAXNFILES)\n    statics = [x.replace(os.path.sep, '/') for x in statics]\n    statics.sort()\n\n    # Get all languages\n    langpath = os.path.join(apath(app, r=request), 'languages')\n    languages = dict([(lang, info) for lang, info\n                      in read_possible_languages(langpath).iteritems()\n                      if info[2] != 0])  # info[2] is langfile_mtime:\n    # get only existed files\n\n    # Get crontab\n    cronfolder = apath('%s/cron' % app, r=request)\n    crontab = apath('%s/cron/crontab' % app, r=request)\n    if not is_gae:\n        if not os.path.exists(cronfolder):\n            os.mkdir(cronfolder)\n        if not os.path.exists(crontab):\n            safe_write(crontab, '#crontab')\n\n    plugins = []\n\n    def filter_plugins(items, plugins):\n        plugins += [item[7:].split('/')[0].split(\n            '.')[0] for item in items if item.startswith('plugin_')]\n        plugins[:] = list(set(plugins))\n        plugins.sort()\n        return [item for item in items if not item.startswith('plugin_')]\n\n    return dict(app=app,\n                models=filter_plugins(models, plugins),\n                defines=defines,\n                controllers=filter_plugins(controllers, plugins),\n                functions=functions,\n                views=filter_plugins(views, plugins),\n                modules=filter_plugins(modules, plugins),\n                extend=extend,\n                include=include,\n                privates=filter_plugins(privates, plugins),\n                statics=filter_plugins(statics, plugins),\n                languages=languages,\n                crontab=crontab,\n                plugins=plugins)\n\n\ndef delete_plugin():\n    \"\"\" Object delete handler \"\"\"\n    app = request.args(0)\n    plugin = request.args(1)\n    plugin_name = 'plugin_' + plugin\n\n    dialog = FORM.confirm(\n        T('Delete'),\n        {T('Cancel'): URL('design', args=app)})\n\n    if dialog.accepted:\n        try:\n            for folder in ['models', 'views', 'controllers', 'static', 'modules', 'private']:\n                path = os.path.join(apath(app, r=request), folder)\n                for item in os.listdir(path):\n                    if item.rsplit('.', 1)[0] == plugin_name:\n                        filename = os.path.join(path, item)\n                        if os.path.isdir(filename):\n                            shutil.rmtree(filename)\n                        else:\n                            os.unlink(filename)\n            session.flash = T('plugin \"%(plugin)s\" deleted',\n                              dict(plugin=plugin))\n        except Exception:\n            session.flash = T('unable to delete file plugin \"%(plugin)s\"',\n                              dict(plugin=plugin))\n        redirect(URL('design', args=request.args(0), anchor=request.vars.id2))\n    return dict(dialog=dialog, plugin=plugin)\n\n\ndef plugin():\n    \"\"\" Application design handler \"\"\"\n    app = get_app()\n    plugin = request.args(1)\n\n    if not response.flash and app == request.application:\n        msg = T('ATTENTION: you cannot edit the running application!')\n        response.flash = msg\n\n    # If we have only pyc files it means that\n    # we cannot design\n    if os.path.exists(apath('%s/compiled' % app, r=request)):\n        session.flash = \\\n            T('application is compiled and cannot be designed')\n        redirect(URL('site'))\n\n    # Get all models\n    models = listdir(apath('%s/models/' % app, r=request), '.*\\.py$')\n    models = [x.replace('\\\\', '/') for x in models]\n    defines = {}\n    for m in models:\n        data = safe_read(apath('%s/models/%s' % (app, m), r=request))\n        defines[m] = regex_tables.findall(data)\n        defines[m].sort()\n\n    # Get all controllers\n    controllers = sorted(\n        listdir(apath('%s/controllers/' % app, r=request), '.*\\.py$'))\n    controllers = [x.replace('\\\\', '/') for x in controllers]\n    functions = {}\n    for c in controllers:\n        data = safe_read(apath('%s/controllers/%s' % (app, c), r=request))\n        items = find_exposed_functions(data)\n        functions[c] = items and sorted(items) or []\n\n    # Get all views\n    views = sorted(\n        listdir(apath('%s/views/' % app, r=request), '[\\w/\\-]+\\.\\w+$'))\n    views = [x.replace('\\\\', '/') for x in views]\n    extend = {}\n    include = {}\n    for c in views:\n        data = safe_read(apath('%s/views/%s' % (app, c), r=request))\n        items = regex_extend.findall(data)\n        if items:\n            extend[c] = items[0][1]\n\n        items = regex_include.findall(data)\n        include[c] = [i[1] for i in items]\n\n    # Get all modules\n    modules = listdir(apath('%s/modules/' % app, r=request), '.*\\.py$')\n    modules = modules = [x.replace('\\\\', '/') for x in modules]\n    modules.sort()\n\n    # Get all private files\n    privates = listdir(apath('%s/private/' % app, r=request), '[^\\.#].*')\n    privates = [x.replace('\\\\', '/') for x in privates]\n    privates.sort()\n\n    # Get all static files\n    statics = listdir(apath('%s/static/' % app, r=request), '[^\\.#].*',\n                      maxnum=MAXNFILES)\n    statics = [x.replace(os.path.sep, '/') for x in statics]\n    statics.sort()\n\n    # Get all languages\n    languages = sorted([lang + '.py' for lang, info in\n                        T.get_possible_languages_info().iteritems()\n                        if info[2] != 0])  # info[2] is langfile_mtime:\n    # get only existed files\n\n    # Get crontab\n    crontab = apath('%s/cron/crontab' % app, r=request)\n    if not os.path.exists(crontab):\n        safe_write(crontab, '#crontab')\n\n    def filter_plugins(items):\n        regex = re.compile('^plugin_' + plugin + '(/.*|\\..*)?$')\n        return [item for item in items if item and regex.match(item)]\n\n    return dict(app=app,\n                models=filter_plugins(models),\n                defines=defines,\n                controllers=filter_plugins(controllers),\n                functions=functions,\n                views=filter_plugins(views),\n                modules=filter_plugins(modules),\n                extend=extend,\n                include=include,\n                privates=filter_plugins(privates),\n                statics=filter_plugins(statics),\n                languages=languages,\n                crontab=crontab)\n\n\ndef create_file():\n    \"\"\" Create files handler \"\"\"\n    if request.vars and not request.vars.token == session.token:\n        redirect(URL('logout'))\n    try:\n        anchor = '#' + request.vars.id if request.vars.id else ''\n        if request.vars.app:\n            app = get_app(request.vars.app)\n            path = abspath(request.vars.location)\n        else:\n            if request.vars.dir:\n                request.vars.location += request.vars.dir + '/'\n            app = get_app(name=request.vars.location.split('/')[0])\n            path = apath(request.vars.location, r=request)\n        filename = re.sub('[^\\w./-]+', '_', request.vars.filename)\n        if path[-7:] == '/rules/':\n            # Handle plural rules files\n            if len(filename) == 0:\n                raise SyntaxError\n            if not filename[-3:] == '.py':\n                filename += '.py'\n            lang = re.match('^plural_rules-(.*)\\.py$', filename).group(1)\n            langinfo = read_possible_languages(apath(app, r=request))[lang]\n            text = dedent(\"\"\"\n                   #!/usr/bin/env python\n                   # -*- coding: utf-8 -*-\n                   # Plural-Forms for %(lang)s (%(langname)s)\n\n                   nplurals=2  # for example, English language has 2 forms:\n                               # 1 singular and 1 plural\n\n                   # Determine plural_id for number *n* as sequence of positive\n                   # integers: 0,1,...\n                   # NOTE! For singular form ALWAYS return plural_id = 0\n                   get_plural_id = lambda n: int(n != 1)\n\n                   # Construct and return plural form of *word* using\n                   # *plural_id* (which ALWAYS>0). This function will be executed\n                   # for words (or phrases) not found in plural_dict dictionary.\n                   # By default this function simply returns word in singular:\n                   construct_plural_form = lambda word, plural_id: word\n                   \"\"\")[1:] % dict(lang=langinfo[0], langname=langinfo[1])\n\n        elif path[-11:] == '/languages/':\n            # Handle language files\n            if len(filename) == 0:\n                raise SyntaxError\n            if not filename[-3:] == '.py':\n                filename += '.py'\n            path = os.path.join(apath(app, r=request), 'languages', filename)\n            if not os.path.exists(path):\n                safe_write(path, '')\n            # create language xx[-yy].py file:\n            findT(apath(app, r=request), filename[:-3])\n            session.flash = T('language file \"%(filename)s\" created/updated',\n                              dict(filename=filename))\n            redirect(request.vars.sender + anchor)\n\n        elif path[-8:] == '/models/':\n            # Handle python models\n            if not filename[-3:] == '.py':\n                filename += '.py'\n\n            if len(filename) == 3:\n                raise SyntaxError\n\n            text = '# -*- coding: utf-8 -*-\\n'\n\n        elif path[-13:] == '/controllers/':\n            # Handle python controllers\n            if not filename[-3:] == '.py':\n                filename += '.py'\n\n            if len(filename) == 3:\n                raise SyntaxError\n\n            text = '# -*- coding: utf-8 -*-\\n# %s\\ndef index(): return dict(message=\"hello from %s\")'\n            text = text % (T('try something like'), filename)\n\n        elif path[-7:] == '/views/':\n            if request.vars.plugin and not filename.startswith('plugin_%s/' % request.vars.plugin):\n                filename = 'plugin_%s/%s' % (request.vars.plugin, filename)\n            # Handle template (html) views\n            if filename.find('.') < 0:\n                filename += '.html'\n            extension = filename.split('.')[-1].lower()\n\n            if len(filename) == 5:\n                raise SyntaxError\n\n            msg = T(\n                'This is the %(filename)s template', dict(filename=filename))\n            if extension == 'html':\n                text = dedent(\"\"\"\n                   {{extend 'layout.html'}}\n                   <h1>%s</h1>\n                   {{=BEAUTIFY(response._vars)}}\"\"\" % msg)[1:]\n            else:\n                generic = os.path.join(path, 'generic.' + extension)\n                if os.path.exists(generic):\n                    text = read_file(generic)\n                else:\n                    text = ''\n\n        elif path[-9:] == '/modules/':\n            if request.vars.plugin and not filename.startswith('plugin_%s/' % request.vars.plugin):\n                filename = 'plugin_%s/%s' % (request.vars.plugin, filename)\n            # Handle python module files\n            if not filename[-3:] == '.py':\n                filename += '.py'\n\n            if len(filename) == 3:\n                raise SyntaxError\n\n            text = dedent(\"\"\"\n                   #!/usr/bin/env python\n                   # -*- coding: utf-8 -*-\n                   from gluon import *\\n\"\"\")[1:]\n\n        elif (path[-8:] == '/static/') or (path[-9:] == '/private/'):\n            if (request.vars.plugin and\n                    not filename.startswith('plugin_%s/' % request.vars.plugin)):\n                filename = 'plugin_%s/%s' % (request.vars.plugin, filename)\n            text = ''\n\n        else:\n            redirect(request.vars.sender + anchor)\n\n        full_filename = os.path.join(path, filename)\n        dirpath = os.path.dirname(full_filename)\n\n        if not os.path.exists(dirpath):\n            os.makedirs(dirpath)\n\n        if os.path.exists(full_filename):\n            raise SyntaxError\n\n        safe_write(full_filename, text)\n        log_progress(app, 'CREATE', filename)\n        if request.vars.dir:\n            result = T('file \"%(filename)s\" created',\n                       dict(filename=full_filename[len(path):]))\n        else:\n            session.flash = T('file \"%(filename)s\" created',\n                              dict(filename=full_filename[len(path):]))\n        vars = {}\n        if request.vars.id:\n            vars['id'] = request.vars.id\n        if request.vars.app:\n            vars['app'] = request.vars.app\n        redirect(URL('edit',\n                     args=[os.path.join(request.vars.location, filename)], vars=vars))\n\n    except Exception, e:\n        if not isinstance(e, HTTP):\n            session.flash = T('cannot create file')\n\n    if request.vars.dir:\n        response.flash = result\n        response.headers['web2py-component-content'] = 'append'\n        response.headers['web2py-component-command'] = \"%s %s %s\" % (\n            \"$.web2py.invalidate('#files_menu');\",\n            \"load_file('%s');\" % URL('edit', args=[app, request.vars.dir, filename]),\n            \"$.web2py.enableElement($('#form form').find($.web2py.formInputClickSelector));\")\n        return ''\n    else:\n        redirect(request.vars.sender + anchor)\n\n\ndef listfiles(app, dir, regexp='.*\\.py$'):\n    files = sorted(\n        listdir(apath('%(app)s/%(dir)s/' % {'app': app, 'dir': dir}, r=request), regexp))\n    files = [x.replace('\\\\', '/') for x in files if not x.endswith('.bak')]\n    return files\n\n\ndef editfile(path, file, vars={}, app=None):\n    args = (path, file) if 'app' in vars else (app, path, file)\n    url = URL('edit', args=args, vars=vars)\n    return A(file, _class='editor_filelink', _href=url, _style='word-wrap: nowrap;')\n\n\ndef files_menu():\n    app = request.vars.app or 'welcome'\n    dirs = [{'name': 'models', 'reg': '.*\\.py$'},\n            {'name': 'controllers', 'reg': '.*\\.py$'},\n            {'name': 'views', 'reg': '[\\w/\\-]+(\\.\\w+)+$'},\n            {'name': 'modules', 'reg': '.*\\.py$'},\n            {'name': 'static', 'reg': '[^\\.#].*'},\n            {'name': 'private', 'reg': '.*\\.py$'}]\n    result_files = []\n    for dir in dirs:\n        result_files.append(TAG[''](LI(dir['name'], _class=\"nav-header component\", _onclick=\"collapse('\" + dir['name'] + \"_files');\"),\n                                    LI(UL(*[LI(editfile(dir['name'], f, dict(id=dir['name'] + f.replace('.', '__')), app), _style=\"overflow:hidden\", _id=dir['name'] + \"__\" + f.replace('.', '__'))\n                                            for f in listfiles(app, dir['name'], regexp=dir['reg'])],\n                                          _class=\"nav nav-list small-font\"),\n                                       _id=dir['name'] + '_files', _style=\"display: none;\")))\n    return dict(result_files=result_files)\n\n\ndef upload_file():\n    \"\"\" File uploading handler \"\"\"\n    if request.vars and not request.vars.token == session.token:\n        redirect(URL('logout'))\n    try:\n        filename = None\n        app = get_app(name=request.vars.location.split('/')[0])\n        path = apath(request.vars.location, r=request)\n\n        if request.vars.filename:\n            filename = re.sub('[^\\w\\./]+', '_', request.vars.filename)\n        else:\n            filename = os.path.split(request.vars.file.filename)[-1]\n\n        if path[-8:] == '/models/' and not filename[-3:] == '.py':\n            filename += '.py'\n\n        if path[-9:] == '/modules/' and not filename[-3:] == '.py':\n            filename += '.py'\n\n        if path[-13:] == '/controllers/' and not filename[-3:] == '.py':\n            filename += '.py'\n\n        if path[-7:] == '/views/' and not filename[-5:] == '.html':\n            filename += '.html'\n\n        if path[-11:] == '/languages/' and not filename[-3:] == '.py':\n            filename += '.py'\n\n        filename = os.path.join(path, filename)\n        dirpath = os.path.dirname(filename)\n\n        if not os.path.exists(dirpath):\n            os.makedirs(dirpath)\n\n        data = request.vars.file.file.read()\n        lineno = count_lines(data)\n        safe_write(filename, data, 'wb')\n        log_progress(app, 'UPLOAD', filename, lineno)\n        session.flash = T('file \"%(filename)s\" uploaded',\n                          dict(filename=filename[len(path):]))\n    except Exception:\n        if filename:\n            d = dict(filename=filename[len(path):])\n        else:\n            d = dict(filename='unknown')\n        session.flash = T('cannot upload file \"%(filename)s\"', d)\n\n    redirect(request.vars.sender)\n\n\ndef errors():\n    \"\"\" Error handler \"\"\"\n    import operator\n    import os\n    import pickle\n    import hashlib\n\n    app = get_app()\n    if is_gae:\n        method = 'dbold' if ('old' in\n                             (request.args(1) or '')) else 'dbnew'\n    else:\n        method = request.args(1) or 'new'\n    db_ready = {}\n    db_ready['status'] = get_ticket_storage(app)\n    db_ready['errmessage'] = T(\n        \"No ticket_storage.txt found under /private folder\")\n    db_ready['errlink'] = \"http://web2py.com/books/default/chapter/29/13#Collecting-tickets\"\n\n    if method == 'new':\n        errors_path = apath('%s/errors' % app, r=request)\n\n        delete_hashes = []\n        for item in request.vars:\n            if item[:7] == 'delete_':\n                delete_hashes.append(item[7:])\n\n        hash2error = dict()\n\n        for fn in listdir(errors_path, '^[a-fA-F0-9.\\-]+$'):\n            fullpath = os.path.join(errors_path, fn)\n            if not os.path.isfile(fullpath):\n                continue\n            try:\n                fullpath_file = open(fullpath, 'r')\n                try:\n                    error = pickle.load(fullpath_file)\n                finally:\n                    fullpath_file.close()\n            except IOError:\n                continue\n            except EOFError:\n                continue\n\n            hash = hashlib.md5(error['traceback']).hexdigest()\n\n            if hash in delete_hashes:\n                os.unlink(fullpath)\n            else:\n                try:\n                    hash2error[hash]['count'] += 1\n                except KeyError:\n                    error_lines = error['traceback'].split(\"\\n\")\n                    last_line = error_lines[-2] if len(error_lines) > 1 else 'unknown'\n                    error_causer = os.path.split(error['layer'])[1]\n                    hash2error[hash] = dict(count=1, pickel=error,\n                                            causer=error_causer,\n                                            last_line=last_line,\n                                            hash=hash, ticket=fn)\n\n        decorated = [(x['count'], x) for x in hash2error.values()]\n        decorated.sort(key=operator.itemgetter(0), reverse=True)\n\n        return dict(errors=[x[1] for x in decorated], app=app, method=method, db_ready=db_ready)\n\n    elif method == 'dbnew':\n        errors_path = apath('%s/errors' % app, r=request)\n        tk_db, tk_table = get_ticket_storage(app)\n\n        delete_hashes = []\n        for item in request.vars:\n            if item[:7] == 'delete_':\n                delete_hashes.append(item[7:])\n\n        hash2error = dict()\n\n        for fn in tk_db(tk_table.id > 0).select():\n            try:\n                error = pickle.loads(fn.ticket_data)\n                hash = hashlib.md5(error['traceback']).hexdigest()\n\n                if hash in delete_hashes:\n                    tk_db(tk_table.id == fn.id).delete()\n                    tk_db.commit()\n                else:\n                    try:\n                        hash2error[hash]['count'] += 1\n                    except KeyError:\n                        error_lines = error['traceback'].split(\"\\n\")\n                        last_line = error_lines[-2]\n                        error_causer = os.path.split(error['layer'])[1]\n                        hash2error[hash] = dict(count=1,\n                                                pickel=error, causer=error_causer,\n                                                last_line=last_line, hash=hash,\n                                                ticket=fn.ticket_id)\n            except AttributeError, e:\n                tk_db(tk_table.id == fn.id).delete()\n                tk_db.commit()\n\n        decorated = [(x['count'], x) for x in hash2error.values()]\n        decorated.sort(key=operator.itemgetter(0), reverse=True)\n        return dict(errors=[x[1] for x in decorated], app=app,\n                    method=method, db_ready=db_ready)\n\n    elif method == 'dbold':\n        tk_db, tk_table = get_ticket_storage(app)\n        for item in request.vars:\n            if item[:7] == 'delete_':\n                tk_db(tk_table.ticket_id == item[7:]).delete()\n                tk_db.commit()\n        tickets_ = tk_db(tk_table.id > 0).select(tk_table.ticket_id,\n                                                 tk_table.created_datetime,\n                                                 orderby=~tk_table.created_datetime)\n        tickets = [row.ticket_id for row in tickets_]\n        times = dict([(row.ticket_id, row.created_datetime) for\n                      row in tickets_])\n        return dict(app=app, tickets=tickets, method=method,\n                    times=times, db_ready=db_ready)\n\n    else:\n        for item in request.vars:\n            # delete_all rows doesn't contain any ticket\n            # Remove anything else as requested\n            if item[:7] == 'delete_' and (not item == \"delete_all}\"):\n                os.unlink(apath('%s/errors/%s' % (app, item[7:]), r=request))\n        func = lambda p: os.stat(apath('%s/errors/%s' %\n                                       (app, p), r=request)).st_mtime\n        tickets = sorted(\n            listdir(apath('%s/errors/' % app, r=request), '^\\w.*'),\n            key=func,\n            reverse=True)\n\n        return dict(app=app, tickets=tickets, method=method, db_ready=db_ready)\n\n\ndef get_ticket_storage(app):\n    private_folder = apath('%s/private' % app, r=request)\n    ticket_file = os.path.join(private_folder, 'ticket_storage.txt')\n    if os.path.exists(ticket_file):\n        db_string = open(ticket_file).read()\n        db_string = db_string.strip().replace('\\r', '').replace('\\n', '')\n    elif is_gae:\n        # use Datastore as fallback if there is no ticket_file\n        db_string = \"google:datastore\"\n    else:\n        return False\n    tickets_table = 'web2py_ticket'\n    tablename = tickets_table + '_' + app\n    db_path = apath('%s/databases' % app, r=request)\n    ticketsdb = DAL(db_string, folder=db_path, auto_import=True)\n    if not ticketsdb.get(tablename):\n        table = ticketsdb.define_table(\n            tablename,\n            Field('ticket_id', length=100),\n            Field('ticket_data', 'text'),\n            Field('created_datetime', 'datetime'),\n        )\n    return ticketsdb, ticketsdb.get(tablename)\n\n\ndef make_link(path):\n    \"\"\" Create a link from a path \"\"\"\n    tryFile = path.replace('\\\\', '/')\n\n    if os.path.isabs(tryFile) and os.path.isfile(tryFile):\n        (folder, filename) = os.path.split(tryFile)\n        (base, ext) = os.path.splitext(filename)\n        app = get_app()\n\n        editable = {'controllers': '.py', 'models': '.py', 'views': '.html'}\n        for key in editable.keys():\n            check_extension = folder.endswith(\"%s/%s\" % (app, key))\n            if ext.lower() == editable[key] and check_extension:\n                return A('\"' + tryFile + '\"',\n                         _href=URL(r=request,\n                                   f='edit/%s/%s/%s' % (app, key, filename))).xml()\n    return ''\n\n\ndef make_links(traceback):\n    \"\"\" Make links using the given traceback \"\"\"\n\n    lwords = traceback.split('\"')\n\n    # Making the short circuit compatible with <= python2.4\n    result = (len(lwords) != 0) and lwords[0] or ''\n\n    i = 1\n\n    while i < len(lwords):\n        link = make_link(lwords[i])\n\n        if link == '':\n            result += '\"' + lwords[i]\n        else:\n            result += link\n\n            if i + 1 < len(lwords):\n                result += lwords[i + 1]\n                i = i + 1\n\n        i = i + 1\n\n    return result\n\n\nclass TRACEBACK(object):\n    \"\"\" Generate the traceback \"\"\"\n\n    def __init__(self, text):\n        \"\"\" TRACEBACK constructor \"\"\"\n\n        self.s = make_links(CODE(text).xml())\n\n    def xml(self):\n        \"\"\" Returns the xml \"\"\"\n\n        return self.s\n\n\ndef ticket():\n    \"\"\" Ticket handler \"\"\"\n\n    if len(request.args) != 2:\n        session.flash = T('invalid ticket')\n        redirect(URL('site'))\n\n    app = get_app()\n    myversion = request.env.web2py_version\n    ticket = request.args[1]\n    e = RestrictedError()\n    e.load(request, app, ticket)\n\n    return dict(app=app,\n                ticket=ticket,\n                output=e.output,\n                traceback=(e.traceback and TRACEBACK(e.traceback)),\n                snapshot=e.snapshot,\n                code=e.code,\n                layer=e.layer,\n                myversion=myversion)\n\n\ndef ticketdb():\n    \"\"\" Ticket handler \"\"\"\n\n    if len(request.args) != 2:\n        session.flash = T('invalid ticket')\n        redirect(URL('site'))\n\n    app = get_app()\n    myversion = request.env.web2py_version\n    ticket = request.args[1]\n    e = RestrictedError()\n    request.tickets_db = get_ticket_storage(app)[0]\n    e.load(request, app, ticket)\n    response.view = 'default/ticket.html'\n    return dict(app=app,\n                ticket=ticket,\n                output=e.output,\n                traceback=(e.traceback and TRACEBACK(e.traceback)),\n                snapshot=e.snapshot,\n                code=e.code,\n                layer=e.layer,\n                myversion=myversion)\n\n\ndef error():\n    \"\"\" Generate a ticket (for testing) \"\"\"\n    raise RuntimeError('admin ticket generator at your service')\n\n\ndef update_languages():\n    \"\"\" Update available languages \"\"\"\n\n    app = get_app()\n    update_all_languages(apath(app, r=request))\n    session.flash = T('Language files (static strings) updated')\n    redirect(URL('design', args=app, anchor='languages'))\n\n\ndef user():\n    if MULTI_USER_MODE:\n        if not db(db.auth_user).count():\n            auth.settings.registration_requires_approval = False\n        return dict(form=auth())\n    else:\n        return dict(form=T(\"Disabled\"))\n\n\ndef reload_routes():\n    \"\"\" Reload routes.py \"\"\"\n    import gluon.rewrite\n    gluon.rewrite.load()\n    redirect(URL('site'))\n\n\ndef manage_students():\n    if not (MULTI_USER_MODE and is_manager()):\n        session.flash = T('Not Authorized')\n        redirect(URL('site'))\n    db.auth_user.registration_key.writable = True\n    grid = SQLFORM.grid(db.auth_user)\n    return locals()\n\n\ndef bulk_register():\n    if not (MULTI_USER_MODE and is_manager()):\n        session.flash = T('Not Authorized')\n        redirect(URL('site'))\n    form = SQLFORM.factory(Field('emails', 'text'))\n    if form.process().accepted:\n        emails = [x.strip() for x in form.vars.emails.split('\\n') if x.strip()]\n        n = 0\n        for email in emails:\n            if not db.auth_user(email=email):\n                n += db.auth_user.insert(email=email) and 1 or 0\n        session.flash = T('%s students registered', n)\n        redirect(URL('site'))\n    return locals()\n\n# Begin experimental stuff need fixes:\n# 1) should run in its own process - cannot os.chdir\n# 2) should not prompt user at console\n# 3) should give option to force commit and not reuqire manual merge\n\n\ndef git_pull():\n    \"\"\" Git Pull handler \"\"\"\n    app = get_app()\n    if not have_git:\n        session.flash = GIT_MISSING\n        redirect(URL('site'))\n    dialog = FORM.confirm(T('Pull'),\n                          {T('Cancel'): URL('site')})\n    if dialog.accepted:\n        try:\n            repo = git.Repo(os.path.join(apath(r=request), app))\n            origin = repo.remotes.origin\n            origin.fetch()\n            origin.pull()\n            session.flash = T(\"Application updated via git pull\")\n            redirect(URL('site'))\n\n        except git.CheckoutError:\n            session.flash = T(\"Pull failed, certain files could not be checked out. Check logs for details.\")\n            redirect(URL('site'))\n        except git.UnmergedEntriesError:\n            session.flash = T(\"Pull is not possible because you have unmerged files. Fix them up in the work tree, and then try again.\")\n            redirect(URL('site'))\n        except git.GitCommandError:\n            session.flash = T(\n                \"Pull failed, git exited abnormally. See logs for details.\")\n            redirect(URL('site'))\n        except AssertionError:\n            session.flash = T(\"Pull is not possible because you have unmerged files. Fix them up in the work tree, and then try again.\")\n            redirect(URL('site'))\n    elif 'cancel' in request.vars:\n        redirect(URL('site'))\n    return dict(app=app, dialog=dialog)\n\n\ndef git_push():\n    \"\"\" Git Push handler \"\"\"\n    app = get_app()\n    if not have_git:\n        session.flash = GIT_MISSING\n        redirect(URL('site'))\n    form = SQLFORM.factory(Field('changelog', requires=IS_NOT_EMPTY()))\n    form.element('input[type=submit]')['_value'] = T('Push')\n    form.add_button(T('Cancel'), URL('site'))\n    form.process()\n    if form.accepted:\n        try:\n            repo = git.Repo(os.path.join(apath(r=request), app))\n            index = repo.index\n            index.add([apath(r=request) + app + '/*'])\n            new_commit = index.commit(form.vars.changelog)\n            origin = repo.remotes.origin\n            origin.push()\n            session.flash = T(\n                \"Git repo updated with latest application changes.\")\n            redirect(URL('site'))\n        except git.UnmergedEntriesError:\n            session.flash = T(\"Push failed, there are unmerged entries in the cache. Resolve merge issues manually and try again.\")\n            redirect(URL('site'))\n    return dict(app=app, form=form)\n\n\ndef plugins():\n    app = request.args(0)\n    from serializers import loads_json\n    if not session.plugins:\n        try:\n            rawlist = urllib.urlopen(\"http://www.web2pyslices.com/\" +\n                                     \"public/api.json/action/list/content/Package?package\" +\n                                     \"_type=plugin&search_index=false\").read()\n            session.plugins = loads_json(rawlist)\n        except:\n            response.flash = T('Unable to download the list of plugins')\n            session.plugins = []\n    return dict(plugins=session.plugins[\"results\"], app=request.args(0))\n\n\ndef install_plugin():\n    app = request.args(0)\n    source = request.vars.source\n    plugin = request.vars.plugin\n    if not (source and app):\n        raise HTTP(500, T(\"Invalid request\"))\n    # make sure no XSS attacks in source\n    if not source.lower().split('://')[0] in ('http','https'):\n        raise HTTP(500, T(\"Invalid request\"))\n    form = SQLFORM.factory()\n    result = None\n    if form.process().accepted:\n        # get w2p plugin\n        if \"web2py.plugin.\" in source:\n            filename = \"web2py.plugin.%s.w2p\" % \\\n                source.split(\"web2py.plugin.\")[-1].split(\".w2p\")[0]\n        else:\n            filename = \"web2py.plugin.%s.w2p\" % cleanpath(plugin)\n        if plugin_install(app, urllib.urlopen(source),\n                          request, filename):\n            session.flash = T('New plugin installed: %s', filename)\n        else:\n            session.flash = \\\n                T('unable to install plugin \"%s\"', filename)\n        redirect(URL(f=\"plugins\", args=[app, ]))\n    return dict(form=form, app=app, plugin=plugin, source=source)\n", "import base64\nimport os\nimport time\nfrom gluon import portalocker\nfrom gluon.admin import apath\nfrom gluon.fileutils import read_file\nfrom gluon.utils import web2py_uuid\n# ###########################################################\n# ## make sure administrator is on localhost or https\n# ###########################################################\n\n\nhttp_host = request.env.http_host.split(':')[0]\n\nif request.env.web2py_runtime_gae:\n    session_db = DAL('gae')\n    session.connect(request, response, db=session_db)\n    hosts = (http_host, )\n    is_gae = True\nelse:\n    is_gae = False\n\nif request.is_https:\n    session.secure()\nelif not request.is_local and not DEMO_MODE:\n    raise HTTP(200, T('Admin is disabled because insecure channel'))\n\ntry:\n    _config = {}\n    port = int(request.env.server_port or 0)\n    restricted(\n        read_file(apath('../parameters_%i.py' % port, request)), _config)\n\n    if not 'password' in _config or not _config['password']:\n        raise HTTP(200, T('admin disabled because no admin password'))\nexcept IOError:\n    import gluon.fileutils\n    if is_gae:\n        if gluon.fileutils.check_credentials(request):\n            session.authorized = True\n            session.last_time = time.time()\n        else:\n            raise HTTP(200,\n                       T('admin disabled because not supported on google app engine'))\n    else:\n        raise HTTP(\n            200, T('admin disabled because unable to access password file'))\n\n\ndef verify_password(password):\n    session.pam_user = None\n    if DEMO_MODE:\n        ret = True\n    elif not _config.get('password'):\n        ret - False\n    elif _config['password'].startswith('pam_user:'):\n        session.pam_user = _config['password'][9:].strip()\n        import gluon.contrib.pam\n        ret = gluon.contrib.pam.authenticate(session.pam_user, password)\n    else:\n        ret = _config['password'] == CRYPT()(password)[0]\n    if ret:\n        session.hmac_key = web2py_uuid()\n    return ret\n\n\n# ###########################################################\n# ## handle brute-force login attacks\n# ###########################################################\n\ndeny_file = os.path.join(request.folder, 'private', 'hosts.deny')\nallowed_number_of_attempts = 5\nexpiration_failed_logins = 3600\n\n\ndef read_hosts_deny():\n    import datetime\n    hosts = {}\n    if os.path.exists(deny_file):\n        hosts = {}\n        f = open(deny_file, 'r')\n        portalocker.lock(f, portalocker.LOCK_SH)\n        for line in f.readlines():\n            if not line.strip() or line.startswith('#'):\n                continue\n            fields = line.strip().split()\n            if len(fields) > 2:\n                hosts[fields[0].strip()] = (  # ip\n                    int(fields[1].strip()),  # n attemps\n                    int(fields[2].strip())   # last attempts\n                    )\n        portalocker.unlock(f)\n        f.close()\n    return hosts\n\n\ndef write_hosts_deny(denied_hosts):\n    f = open(deny_file, 'w')\n    portalocker.lock(f, portalocker.LOCK_EX)\n    for key, val in denied_hosts.items():\n        if time.time() - val[1] < expiration_failed_logins:\n            line = '%s %s %s\\n' % (key, val[0], val[1])\n            f.write(line)\n    portalocker.unlock(f)\n    f.close()\n\n\ndef login_record(success=True):\n    denied_hosts = read_hosts_deny()\n    val = (0, 0)\n    if success and request.client in denied_hosts:\n        del denied_hosts[request.client]\n    elif not success and not request.is_local:\n        val = denied_hosts.get(request.client, (0, 0))\n        if time.time() - val[1] < expiration_failed_logins \\\n            and val[0] >= allowed_number_of_attempts:\n            return val[0]  # locked out\n        time.sleep(2 ** val[0])\n        val = (val[0] + 1, int(time.time()))\n        denied_hosts[request.client] = val\n    write_hosts_deny(denied_hosts)\n    return val[0]\n\n\n# ###########################################################\n# ## session expiration\n# ###########################################################\n\nt0 = time.time()\nif session.authorized:\n\n    if session.last_time and session.last_time < t0 - EXPIRATION:\n        session.flash = T('session expired')\n        session.authorized = False\n    else:\n        session.last_time = t0\n\n\nif request.vars.is_mobile in ('true', 'false', 'auto'):\n    session.is_mobile = request.vars.is_mobile or 'auto'\nif request.controller == 'default' and request.function == 'index':\n    if not request.vars.is_mobile:\n        session.is_mobile = 'auto'\nif not session.is_mobile:\n    session.is_mobile = 'auto'\nif session.is_mobile == 'true':\n    is_mobile = True\nelif session.is_mobile == 'false':\n    is_mobile = False\nelse:\n    is_mobile = request.user_agent().get('is_mobile',False)\n\nif DEMO_MODE:\n    session.authorized = True\n    session.forget()\n\nif request.controller == \"webservices\":\n    basic = request.env.http_authorization\n    if not basic or not basic[:6].lower() == 'basic ':\n        raise HTTP(401, \"Wrong credentials\")\n    (username, password) = base64.b64decode(basic[6:]).split(':')\n    if not verify_password(password) or MULTI_USER_MODE:\n        time.sleep(10)\n        raise HTTP(403, \"Not authorized\")\nelif not session.authorized and not \\\n    (request.controller + '/' + request.function in\n     ('default/index', 'default/user', 'plugin_jqmobile/index', 'plugin_jqmobile/about')):\n\n    if request.env.query_string:\n        query_string = '?' + request.env.query_string\n    else:\n        query_string = ''\n\n    if request.env.web2py_original_uri:\n        url = request.env.web2py_original_uri\n    else:\n        url = request.env.path_info + query_string\n    redirect(URL(request.application, 'default', 'index', vars=dict(send=url)))\nelif session.authorized and \\\n     request.controller == 'default' and \\\n     request.function == 'index':\n    redirect(URL(request.application, 'default', 'site'))\n\nif request.controller == 'appadmin' and DEMO_MODE:\n    session.flash = 'Appadmin disabled in demo mode'\n    redirect(URL('default', 'sites'))\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\nEXPERIMENTAL_STUFF = True\nMAXNFILES = 1000\n\nif EXPERIMENTAL_STUFF:\n    if is_mobile:\n        response.view = response.view.replace('default/', 'default.mobile/')\n        response.menu = []\n\nimport re\nfrom gluon.admin import *\nfrom gluon.fileutils import abspath, read_file, write_file\nfrom gluon.utils import web2py_uuid\nfrom gluon.tools import Config\nfrom gluon.compileapp import find_exposed_functions\nfrom glob import glob\nimport shutil\nimport platform\n\ntry:\n    import git\n    if git.__version__ < '0.3.1':\n        raise ImportError(\"Your version of git is %s. Upgrade to 0.3.1 or better.\" % git.__version__)\n    have_git = True\nexcept ImportError, e:\n    have_git = False\n    GIT_MISSING = 'Requires gitpython module, but not installed or incompatible version: %s' % e\n\nfrom gluon.languages import (read_possible_languages, read_dict, write_dict,\n                             read_plural_dict, write_plural_dict)\n\n\nif DEMO_MODE and request.function in ['change_password', 'pack',\n                                      'pack_custom', 'pack_plugin', 'upgrade_web2py', 'uninstall',\n                                      'cleanup', 'compile_app', 'remove_compiled_app', 'delete',\n                                      'delete_plugin', 'create_file', 'upload_file', 'update_languages',\n                                      'reload_routes', 'git_push', 'git_pull', 'install_plugin']:\n    session.flash = T('disabled in demo mode')\n    redirect(URL('site'))\n\nif is_gae and request.function in ('edit', 'edit_language',\n                                   'edit_plurals', 'update_languages', 'create_file', 'install_plugin'):\n    session.flash = T('disabled in GAE mode')\n    redirect(URL('site'))\n\nif not is_manager() and request.function in ['change_password', 'upgrade_web2py']:\n    session.flash = T('disabled in multi user mode')\n    redirect(URL('site'))\n\nif FILTER_APPS and request.args(0) and not request.args(0) in FILTER_APPS:\n    session.flash = T('disabled in demo mode')\n    redirect(URL('site'))\n\n\nif not session.token:\n    session.token = web2py_uuid()\n\n\ndef count_lines(data):\n    return len([line for line in data.split('\\n') if line.strip() and not line.startswith('#')])\n\n\ndef log_progress(app, mode='EDIT', filename=None, progress=0):\n    progress_file = os.path.join(apath(app, r=request), 'progress.log')\n    now = str(request.now)[:19]\n    if not os.path.exists(progress_file):\n        safe_open(progress_file, 'w').write('[%s] START\\n' % now)\n    if filename:\n        safe_open(progress_file, 'a').write(\n            '[%s] %s %s: %s\\n' % (now, mode, filename, progress))\n\n\ndef safe_open(a, b):\n    if (DEMO_MODE or is_gae) and ('w' in b or 'a' in b):\n        class tmp:\n\n            def write(self, data):\n                pass\n\n            def close(self):\n                pass\n        return tmp()\n    return open(a, b)\n\n\ndef safe_read(a, b='r'):\n    safe_file = safe_open(a, b)\n    try:\n        return safe_file.read()\n    finally:\n        safe_file.close()\n\n\ndef safe_write(a, value, b='w'):\n    safe_file = safe_open(a, b)\n    try:\n        safe_file.write(value)\n    finally:\n        safe_file.close()\n\n\ndef get_app(name=None):\n    app = name or request.args(0)\n    if (app and os.path.exists(apath(app, r=request)) and\n        (not MULTI_USER_MODE or is_manager() or\n         db(db.app.name == app)(db.app.owner == auth.user.id).count())):\n        return app\n    session.flash = T('App does not exist or you are not authorized')\n    redirect(URL('site'))\n\n\ndef index():\n    \"\"\" Index handler \"\"\"\n\n    send = request.vars.send\n    if DEMO_MODE:\n        session.authorized = True\n        session.last_time = t0\n    if not send:\n        send = URL('site')\n    if session.authorized:\n        redirect(send)\n    elif failed_login_count() >= allowed_number_of_attempts:\n        time.sleep(2 ** allowed_number_of_attempts)\n        raise HTTP(403)\n    elif request.vars.password:\n        if verify_password(request.vars.password[:1024]):\n            session.authorized = True\n            login_record(True)\n\n            if CHECK_VERSION:\n                session.check_version = True\n            else:\n                session.check_version = False\n\n            session.last_time = t0\n            if isinstance(send, list):  # ## why does this happen?\n                send = str(send[0])\n\n            redirect(send)\n        else:\n            times_denied = login_record(False)\n            if times_denied >= allowed_number_of_attempts:\n                response.flash = \\\n                    T('admin disabled because too many invalid login attempts')\n            elif times_denied == allowed_number_of_attempts - 1:\n                response.flash = \\\n                    T('You have one more login attempt before you are locked out')\n            else:\n                response.flash = T('invalid password.')\n    return dict(send=send)\n\n\ndef check_version():\n    \"\"\" Checks if web2py is up to date \"\"\"\n\n    session.forget()\n    session._unlock(response)\n\n    new_version, version = check_new_version(request.env.web2py_version,\n                                             WEB2PY_VERSION_URL)\n\n    if new_version == -1:\n        return A(T('Unable to check for upgrades'), _href=WEB2PY_URL)\n    elif new_version != True:\n        return A(T('web2py is up to date'), _href=WEB2PY_URL)\n    elif platform.system().lower() in ('windows', 'win32', 'win64') and os.path.exists(\"web2py.exe\"):\n        return SPAN('You should upgrade to %s' % version.split('(')[0])\n    else:\n        return sp_button(URL('upgrade_web2py'), T('upgrade now to %s') % version.split('(')[0])\n\n\ndef logout():\n    \"\"\" Logout handler \"\"\"\n    session.authorized = None\n    if MULTI_USER_MODE:\n        redirect(URL('user/logout'))\n    redirect(URL('index'))\n\n\ndef change_password():\n\n    if session.pam_user:\n        session.flash = T(\n            'PAM authenticated user, cannot change password here')\n        redirect(URL('site'))\n    form = SQLFORM.factory(Field('current_admin_password', 'password'),\n                           Field('new_admin_password',\n                                 'password', requires=IS_STRONG()),\n                           Field('new_admin_password_again', 'password'),\n                           _class=\"span4 well\")\n    if form.accepts(request.vars):\n        if not verify_password(request.vars.current_admin_password):\n            form.errors.current_admin_password = T('invalid password')\n        elif form.vars.new_admin_password != form.vars.new_admin_password_again:\n            form.errors.new_admin_password_again = T('no match')\n        else:\n            path = abspath('parameters_%s.py' % request.env.server_port)\n            safe_write(path, 'password=\"%s\"' % CRYPT()(\n                request.vars.new_admin_password)[0])\n            session.flash = T('password changed')\n            redirect(URL('site'))\n    return dict(form=form)\n\n\ndef site():\n    \"\"\" Site handler \"\"\"\n\n    myversion = request.env.web2py_version\n\n    # Shortcut to make the elif statements more legible\n    file_or_appurl = 'file' in request.vars or 'appurl' in request.vars\n\n    class IS_VALID_APPNAME(object):\n\n        def __call__(self, value):\n            if not re.compile('^\\w+$').match(value):\n                return (value, T('Invalid application name'))\n            if not request.vars.overwrite and \\\n                    os.path.exists(os.path.join(apath(r=request), value)):\n                return (value, T('Application exists already'))\n            return (value, None)\n\n    is_appname = IS_VALID_APPNAME()\n    form_create = SQLFORM.factory(Field('name', requires=is_appname),\n                                  table_name='appcreate')\n    form_update = SQLFORM.factory(Field('name', requires=is_appname),\n                                  Field('file', 'upload', uploadfield=False),\n                                  Field('url'),\n                                  Field('overwrite', 'boolean'),\n                                  table_name='appupdate')\n    form_create.process()\n    form_update.process()\n\n    if DEMO_MODE:\n        pass\n\n    elif form_create.accepted:\n        # create a new application\n        appname = cleanpath(form_create.vars.name)\n        created, error = app_create(appname, request, info=True)\n        if created:\n            if MULTI_USER_MODE:\n                db.app.insert(name=appname, owner=auth.user.id)\n            log_progress(appname)\n            session.flash = T('new application \"%s\" created', appname)\n            redirect(URL('design', args=appname))\n        else:\n            session.flash = \\\n                DIV(T('unable to create application \"%s\"', appname),\n                    PRE(error))\n        redirect(URL(r=request))\n\n    elif form_update.accepted:\n        if (form_update.vars.url or '').endswith('.git'):\n            if not have_git:\n                session.flash = GIT_MISSING\n                redirect(URL(r=request))\n            target = os.path.join(apath(r=request), form_update.vars.name)\n            try:\n                new_repo = git.Repo.clone_from(form_update.vars.url, target)\n                session.flash = T('new application \"%s\" imported',\n                                  form_update.vars.name)\n            except git.GitCommandError, err:\n                session.flash = T('Invalid git repository specified.')\n            redirect(URL(r=request))\n\n        elif form_update.vars.url:\n            # fetch an application via URL or file upload\n            try:\n                f = urllib.urlopen(form_update.vars.url)\n                if f.code == 404:\n                    raise Exception(\"404 file not found\")\n            except Exception, e:\n                session.flash = \\\n                    DIV(T('Unable to download app because:'), PRE(repr(e)))\n                redirect(URL(r=request))\n            fname = form_update.vars.url\n\n        elif form_update.accepted and form_update.vars.file:\n            fname = request.vars.file.filename\n            f = request.vars.file.file\n\n        else:\n            session.flash = 'No file uploaded and no URL specified'\n            redirect(URL(r=request))\n\n        if f:\n            appname = cleanpath(form_update.vars.name)\n            installed = app_install(appname, f,\n                                    request, fname,\n                                    overwrite=form_update.vars.overwrite)\n        if f and installed:\n            msg = 'application %(appname)s installed with md5sum: %(digest)s'\n            if MULTI_USER_MODE:\n                db.app.insert(name=appname, owner=auth.user.id)\n            log_progress(appname)\n            session.flash = T(msg, dict(appname=appname,\n                                        digest=md5_hash(installed)))\n        else:\n            msg = 'unable to install application \"%(appname)s\"'\n            session.flash = T(msg, dict(appname=form_update.vars.name))\n        redirect(URL(r=request))\n\n    regex = re.compile('^\\w+$')\n\n    if is_manager():\n        apps = [f for f in os.listdir(apath(r=request)) if regex.match(f)]\n    else:\n        apps = [f.name for f in db(db.app.owner == auth.user_id).select()]\n\n    if FILTER_APPS:\n        apps = [f for f in apps if f in FILTER_APPS]\n\n    apps = sorted(apps, lambda a, b: cmp(a.upper(), b.upper()))\n    myplatform = platform.python_version()\n    return dict(app=None, apps=apps, myversion=myversion, myplatform=myplatform,\n                form_create=form_create, form_update=form_update)\n\n\ndef report_progress(app):\n    import datetime\n    progress_file = os.path.join(apath(app, r=request), 'progress.log')\n    regex = re.compile('\\[(.*?)\\][^\\:]+\\:\\s+(\\-?\\d+)')\n    if not os.path.exists(progress_file):\n        return []\n    matches = regex.findall(open(progress_file, 'r').read())\n    events, counter = [], 0\n    for m in matches:\n        if not m:\n            continue\n        days = -(request.now - datetime.datetime.strptime(m[0],\n                                                          '%Y-%m-%d %H:%M:%S')).days\n        counter += int(m[1])\n        events.append([days, counter])\n    return events\n\n\ndef pack():\n    app = get_app()\n\n    try:\n        if len(request.args) == 1:\n            fname = 'web2py.app.%s.w2p' % app\n            filename = app_pack(app, request, raise_ex=True)\n        else:\n            fname = 'web2py.app.%s.compiled.w2p' % app\n            filename = app_pack_compiled(app, request, raise_ex=True)\n    except Exception, e:\n        filename = None\n\n    if filename:\n        response.headers['Content-Type'] = 'application/w2p'\n        disposition = 'attachment; filename=%s' % fname\n        response.headers['Content-Disposition'] = disposition\n        return safe_read(filename, 'rb')\n    else:\n        session.flash = T('internal error: %s', e)\n        redirect(URL('site'))\n\n\ndef pack_plugin():\n    app = get_app()\n    if len(request.args) == 2:\n        fname = 'web2py.plugin.%s.w2p' % request.args[1]\n        filename = plugin_pack(app, request.args[1], request)\n    if filename:\n        response.headers['Content-Type'] = 'application/w2p'\n        disposition = 'attachment; filename=%s' % fname\n        response.headers['Content-Disposition'] = disposition\n        return safe_read(filename, 'rb')\n    else:\n        session.flash = T('internal error')\n        redirect(URL('plugin', args=request.args))\n\n\ndef pack_exe(app, base, filenames=None):\n    import urllib\n    import zipfile\n    from cStringIO import StringIO\n    # Download latest web2py_win and open it with zipfile\n    download_url = 'http://www.web2py.com/examples/static/web2py_win.zip'\n    out = StringIO()\n    out.write(urllib.urlopen(download_url).read())\n    web2py_win = zipfile.ZipFile(out, mode='a')\n    # Write routes.py with the application as default\n    routes = u'# -*- coding: utf-8 -*-\\nrouters = dict(BASE=dict(default_application=\"%s\"))' % app\n    web2py_win.writestr('web2py/routes.py', routes.encode('utf-8'))\n    # Copy the application into the zipfile\n    common_root = os.path.dirname(base)\n    for filename in filenames:\n        fname = os.path.join(base, filename)\n        arcname = os.path.join('web2py/applications', app, filename)\n        web2py_win.write(fname, arcname)\n    web2py_win.close()\n    response.headers['Content-Type'] = 'application/zip'\n    response.headers['Content-Disposition'] = 'attachment; filename=web2py.app.%s.zip' % app\n    out.seek(0)\n    return response.stream(out)\n\n\ndef pack_custom():\n    app = get_app()\n    base = apath(app, r=request)\n\n    def ignore(fs):\n        return [f for f in fs if not (\n                f[:1] in '#' or f.endswith('~') or f.endswith('.bak'))]\n    files = {}\n    for (r, d, f) in os.walk(base):\n        files[r] = {'folders': ignore(d), 'files': ignore(f)}\n\n    if request.post_vars.file:\n        valid_set = set(os.path.relpath(os.path.join(r, f), base) for r in files for f in files[r]['files'])\n        files = request.post_vars.file\n        files = [files] if not isinstance(files, list) else files\n        files = [file for file in files if file in valid_set]\n\n        if request.post_vars.doexe is None:\n            fname = 'web2py.app.%s.w2p' % app\n            try:\n                filename = app_pack(app, request, raise_ex=True, filenames=files)\n            except Exception, e:\n                filename = None\n            if filename:\n                response.headers['Content-Type'] = 'application/w2p'\n                disposition = 'attachment; filename=%s' % fname\n                response.headers['Content-Disposition'] = disposition\n                return safe_read(filename, 'rb')\n            else:\n                session.flash = T('internal error: %s', e)\n                redirect(URL(args=request.args))\n        else:\n            return pack_exe(app, base, files)\n\n    return locals()\n\n\ndef upgrade_web2py():\n    dialog = FORM.confirm(T('Upgrade'),\n                          {T('Cancel'): URL('site')})\n    if dialog.accepted:\n        (success, error) = upgrade(request)\n        if success:\n            session.flash = T('web2py upgraded; please restart it')\n        else:\n            session.flash = T('unable to upgrade because \"%s\"', error)\n        redirect(URL('site'))\n    return dict(dialog=dialog)\n\n\ndef uninstall():\n    app = get_app()\n\n    dialog = FORM.confirm(T('Uninstall'),\n                          {T('Cancel'): URL('site')})\n    dialog['_id'] = 'confirm_form'\n    dialog['_class'] = 'well'\n    for component in dialog.components:\n        component['_class'] = 'btn'\n\n    if dialog.accepted:\n        if MULTI_USER_MODE:\n            if is_manager() and db(db.app.name == app).delete():\n                pass\n            elif db(db.app.name == app)(db.app.owner == auth.user.id).delete():\n                pass\n            else:\n                session.flash = T('no permission to uninstall \"%s\"', app)\n                redirect(URL('site'))\n        try:\n            filename = app_pack(app, request, raise_ex=True)\n        except:\n            session.flash = T('unable to uninstall \"%s\"', app)\n        else:\n            if app_uninstall(app, request):\n                session.flash = T('application \"%s\" uninstalled', app)\n            else:\n                session.flash = T('unable to uninstall \"%s\"', app)\n        redirect(URL('site'))\n    return dict(app=app, dialog=dialog)\n\n\ndef cleanup():\n    app = get_app()\n    clean = app_cleanup(app, request)\n    if not clean:\n        session.flash = T(\"some files could not be removed\")\n    else:\n        session.flash = T('cache, errors and sessions cleaned')\n\n    redirect(URL('site'))\n\n\ndef compile_app():\n    app = get_app()\n    c = app_compile(app, request,\n                    skip_failed_views=(request.args(1) == 'skip_failed_views'))\n    if not c:\n        session.flash = T('application compiled')\n    elif isinstance(c, list):\n        session.flash = DIV(*[T('application compiled'), BR(), BR(),\n                              T('WARNING: The following views could not be compiled:'), BR()] +\n                            [CAT(BR(), view) for view in c] +\n                            [BR(), BR(), T('DO NOT use the \"Pack compiled\" feature.')])\n    else:\n        session.flash = DIV(T('Cannot compile: there are errors in your app:'),\n                            CODE(c))\n    redirect(URL('site'))\n\n\ndef remove_compiled_app():\n    \"\"\" Remove the compiled application \"\"\"\n    app = get_app()\n    remove_compiled_application(apath(app, r=request))\n    session.flash = T('compiled application removed')\n    redirect(URL('site'))\n\n\ndef delete():\n    \"\"\" Object delete handler \"\"\"\n    app = get_app()\n    filename = '/'.join(request.args)\n    sender = request.vars.sender\n\n    if isinstance(sender, list):  # ## fix a problem with Vista\n        sender = sender[0]\n\n    dialog = FORM.confirm(T('Delete'),\n                          {T('Cancel'): URL(sender, anchor=request.vars.id)})\n\n    if dialog.accepted:\n        try:\n            full_path = apath(filename, r=request)\n            lineno = count_lines(open(full_path, 'r').read())\n            os.unlink(full_path)\n            log_progress(app, 'DELETE', filename, progress=-lineno)\n            session.flash = T('file \"%(filename)s\" deleted',\n                              dict(filename=filename))\n        except Exception:\n            session.flash = T('unable to delete file \"%(filename)s\"',\n                              dict(filename=filename))\n        redirect(URL(sender, anchor=request.vars.id2))\n    return dict(dialog=dialog, filename=filename)\n\ndef enable():\n    if not URL.verify(request, hmac_key=session.hmac_key): raise HTTP(401)\n    app = get_app()\n    filename = os.path.join(apath(app, r=request), 'DISABLED')\n    if is_gae:\n        return SPAN(T('Not supported'), _style='color:yellow')\n    elif os.path.exists(filename):\n        os.unlink(filename)\n        return SPAN(T('Disable'), _style='color:green')\n    else:\n        safe_open(filename, 'wb').write('disabled: True\\ntime-disabled: %s' % request.now)\n        return SPAN(T('Enable'), _style='color:red')\n\n\ndef peek():\n    \"\"\" Visualize object code \"\"\"\n    app = get_app(request.vars.app)\n    filename = '/'.join(request.args)\n    if request.vars.app:\n        path = abspath(filename)\n    else:\n        path = apath(filename, r=request)\n    try:\n        data = safe_read(path).replace('\\r', '')\n    except IOError:\n        session.flash = T('file does not exist')\n        redirect(URL('site'))\n\n    extension = filename[filename.rfind('.') + 1:].lower()\n\n    return dict(app=app,\n                filename=filename,\n                data=data,\n                extension=extension)\n\n\ndef test():\n    \"\"\" Execute controller tests \"\"\"\n    app = get_app()\n    if len(request.args) > 1:\n        file = request.args[1]\n    else:\n        file = '.*\\.py'\n\n    controllers = listdir(\n        apath('%s/controllers/' % app, r=request), file + '$')\n\n    return dict(app=app, controllers=controllers)\n\n\ndef keepalive():\n    return ''\n\n\ndef search():\n    keywords = request.vars.keywords or ''\n    app = get_app()\n\n    def match(filename, keywords):\n        filename = os.path.join(apath(app, r=request), filename)\n        if keywords in read_file(filename, 'rb'):\n            return True\n        return False\n    path = apath(request.args[0], r=request)\n    files1 = glob(os.path.join(path, '*/*.py'))\n    files2 = glob(os.path.join(path, '*/*.html'))\n    files3 = glob(os.path.join(path, '*/*/*.html'))\n    files = [x[len(path) + 1:].replace(\n        '\\\\', '/') for x in files1 + files2 + files3 if match(x, keywords)]\n    return response.json(dict(files=files, message=T.M('Searching: **%s** %%{file}', len(files))))\n\n\ndef edit():\n    \"\"\" File edit handler \"\"\"\n    # Load json only if it is ajax edited...\n    app = get_app(request.vars.app)\n    app_path = apath(app, r=request)\n    preferences = {'theme': 'web2py', 'editor': 'default', 'closetag': 'true', 'codefolding': 'false', 'tabwidth': '4', 'indentwithtabs': 'false', 'linenumbers': 'true', 'highlightline': 'true'}\n    config = Config(os.path.join(request.folder, 'settings.cfg'),\n                    section='editor', default_values={})\n    preferences.update(config.read())\n\n    if not(request.ajax) and not(is_mobile):\n        # return the scaffolding, the rest will be through ajax requests\n        response.title = T('Editing %s') % app\n        return response.render('default/edit.html', dict(app=app, editor_settings=preferences))\n\n    # show settings tab and save prefernces\n    if 'settings' in request.vars:\n        if request.post_vars:  # save new preferences\n            post_vars = request.post_vars.items()\n            # Since unchecked checkbox are not serialized, we must set them as false by hand to store the correct preference in the settings\n            post_vars += [(opt, 'false') for opt in preferences if opt not in request.post_vars]\n            if config.save(post_vars):\n                response.headers[\"web2py-component-flash\"] = T('Preferences saved correctly')\n            else:\n                response.headers[\"web2py-component-flash\"] = T('Preferences saved on session only')\n            response.headers[\"web2py-component-command\"] = \"update_editor(%s);$('a[href=#editor_settings] button.close').click();\" % response.json(config.read())\n            return\n        else:\n            details = {'realfilename': 'settings', 'filename': 'settings', 'id': 'editor_settings', 'force': False}\n            details['plain_html'] = response.render('default/editor_settings.html', {'editor_settings': preferences})\n            return response.json(details)\n\n    \"\"\" File edit handler \"\"\"\n    # Load json only if it is ajax edited...\n    app = get_app(request.vars.app)\n    filename = '/'.join(request.args)\n    realfilename = request.args[-1]\n    if request.vars.app:\n        path = abspath(filename)\n    else:\n        path = apath(filename, r=request)\n    # Try to discover the file type\n    if filename[-3:] == '.py':\n        filetype = 'python'\n    elif filename[-5:] == '.html':\n        filetype = 'html'\n    elif filename[-5:] == '.load':\n        filetype = 'html'\n    elif filename[-4:] == '.css':\n        filetype = 'css'\n    elif filename[-3:] == '.js':\n        filetype = 'javascript'\n    else:\n        filetype = 'html'\n\n    # ## check if file is not there\n    if ('revert' in request.vars) and os.path.exists(path + '.bak'):\n        try:\n            data = safe_read(path + '.bak')\n            data1 = safe_read(path)\n        except IOError:\n            session.flash = T('Invalid action')\n            if 'from_ajax' in request.vars:\n                return response.json({'error': str(T('Invalid action'))})\n            else:\n                redirect(URL('site'))\n\n        safe_write(path, data)\n        file_hash = md5_hash(data)\n        saved_on = time.ctime(os.stat(path)[stat.ST_MTIME])\n        safe_write(path + '.bak', data1)\n        response.flash = T('file \"%s\" of %s restored', (filename, saved_on))\n    else:\n        try:\n            data = safe_read(path)\n        except IOError:\n            session.flash = T('Invalid action')\n            if 'from_ajax' in request.vars:\n                return response.json({'error': str(T('Invalid action'))})\n            else:\n                redirect(URL('site'))\n\n        lineno_old = count_lines(data)\n        file_hash = md5_hash(data)\n        saved_on = time.ctime(os.stat(path)[stat.ST_MTIME])\n\n        if request.vars.file_hash and request.vars.file_hash != file_hash:\n            session.flash = T('file changed on disk')\n            data = request.vars.data.replace('\\r\\n', '\\n').strip() + '\\n'\n            safe_write(path + '.1', data)\n            if 'from_ajax' in request.vars:\n                return response.json({'error': str(T('file changed on disk')),\n                                      'redirect': URL('resolve',\n                                                      args=request.args)})\n            else:\n                redirect(URL('resolve', args=request.args))\n        elif request.vars.data:\n            safe_write(path + '.bak', data)\n            data = request.vars.data.replace('\\r\\n', '\\n').strip() + '\\n'\n            safe_write(path, data)\n            lineno_new = count_lines(data)\n            log_progress(\n                app, 'EDIT', filename, progress=lineno_new - lineno_old)\n            file_hash = md5_hash(data)\n            saved_on = time.ctime(os.stat(path)[stat.ST_MTIME])\n            response.flash = T('file saved on %s', saved_on)\n\n    data_or_revert = (request.vars.data or request.vars.revert)\n\n    # Check compile errors\n    highlight = None\n    if filetype == 'python' and request.vars.data:\n        import _ast\n        try:\n            code = request.vars.data.rstrip().replace('\\r\\n', '\\n') + '\\n'\n            compile(code, path, \"exec\", _ast.PyCF_ONLY_AST)\n        except Exception, e:\n            # offset calculation is only used for textarea (start/stop)\n            start = sum([len(line) + 1 for l, line\n                         in enumerate(request.vars.data.split(\"\\n\"))\n                         if l < e.lineno - 1])\n            if e.text and e.offset:\n                offset = e.offset - (len(e.text) - len(\n                    e.text.splitlines()[-1]))\n            else:\n                offset = 0\n            highlight = {'start': start, 'end': start +\n                         offset + 1, 'lineno': e.lineno, 'offset': offset}\n            try:\n                ex_name = e.__class__.__name__\n            except:\n                ex_name = 'unknown exception!'\n            response.flash = DIV(T('failed to compile file because:'), BR(),\n                                 B(ex_name), ' ' + T('at line %s', e.lineno),\n                                 offset and ' ' +\n                                 T('at char %s', offset) or '',\n                                 PRE(repr(e)))\n    if data_or_revert and request.args[1] == 'modules':\n        # Lets try to reload the modules\n        try:\n            mopath = '.'.join(request.args[2:])[:-3]\n            exec 'import applications.%s.modules.%s' % (\n                request.args[0], mopath)\n            reload(sys.modules['applications.%s.modules.%s'\n                               % (request.args[0], mopath)])\n        except Exception, e:\n            response.flash = DIV(\n                T('failed to reload module because:'), PRE(repr(e)))\n\n    edit_controller = None\n    editviewlinks = None\n    view_link = None\n    if filetype == 'html' and len(request.args) >= 3:\n        cfilename = os.path.join(request.args[0], 'controllers',\n                                 request.args[2] + '.py')\n        if os.path.exists(apath(cfilename, r=request)):\n            edit_controller = URL('edit', args=[cfilename.replace(os.sep, \"/\")])\n            view = request.args[3].replace('.html', '')\n            view_link = URL(request.args[0], request.args[2], view)\n    elif filetype == 'python' and request.args[1] == 'controllers':\n        # it's a controller file.\n        # Create links to all of the associated view files.\n        app = get_app()\n        viewname = os.path.splitext(request.args[2])[0]\n        viewpath = os.path.join(app, 'views', viewname)\n        aviewpath = apath(viewpath, r=request)\n        viewlist = []\n        if os.path.exists(aviewpath):\n            if os.path.isdir(aviewpath):\n                viewlist = glob(os.path.join(aviewpath, '*.html'))\n        elif os.path.exists(aviewpath + '.html'):\n            viewlist.append(aviewpath + '.html')\n        if len(viewlist):\n            editviewlinks = []\n            for v in sorted(viewlist):\n                vf = os.path.split(v)[-1]\n                vargs = \"/\".join([viewpath.replace(os.sep, \"/\"), vf])\n                editviewlinks.append(A(vf.split(\".\")[0],\n                                       _class=\"editor_filelink\",\n                                       _href=URL('edit', args=[vargs])))\n\n    if len(request.args) > 2 and request.args[1] == 'controllers':\n        controller = (request.args[2])[:-3]\n        functions = find_exposed_functions(data)\n        functions = functions and sorted(functions) or []\n    else:\n        (controller, functions) = (None, None)\n\n    if 'from_ajax' in request.vars:\n        return response.json({'file_hash': file_hash, 'saved_on': saved_on, 'functions': functions, 'controller': controller, 'application': request.args[0], 'highlight': highlight})\n    else:\n        file_details = dict(app=request.args[0],\n                            lineno=request.vars.lineno or 1,\n                            editor_settings=preferences,\n                            filename=filename,\n                            realfilename=realfilename,\n                            filetype=filetype,\n                            data=data,\n                            edit_controller=edit_controller,\n                            file_hash=file_hash,\n                            saved_on=saved_on,\n                            controller=controller,\n                            functions=functions,\n                            view_link=view_link,\n                            editviewlinks=editviewlinks,\n                            id=IS_SLUG()(filename)[0],\n                            force=True if (request.vars.restore or\n                                           request.vars.revert) else False)\n        plain_html = response.render('default/edit_js.html', file_details)\n        file_details['plain_html'] = plain_html\n        if is_mobile:\n            return response.render('default.mobile/edit.html',\n                                   file_details, editor_settings=preferences)\n        else:\n            return response.json(file_details)\n\n\ndef todolist():\n    \"\"\" Returns all TODO of the requested app\n    \"\"\"\n    app = request.vars.app or ''\n    app_path = apath('%(app)s' % {'app': app}, r=request)\n    dirs = ['models', 'controllers', 'modules', 'private']\n\n    def listfiles(app, dir, regexp='.*\\.py$'):\n        files = sorted(listdir(apath('%(app)s/%(dir)s/' % {'app': app, 'dir': dir}, r=request), regexp))\n        files = [x.replace(os.path.sep, '/') for x in files if not x.endswith('.bak')]\n        return files\n\n    pattern = '#\\s*(todo)+\\s+(.*)'\n    regex = re.compile(pattern, re.IGNORECASE)\n\n    output = []\n    for d in dirs:\n        for f in listfiles(app, d):\n            matches = []\n            filename = apath(os.path.join(app, d, f), r=request)\n            with open(filename, 'r') as f_s:\n                src = f_s.read()\n                for m in regex.finditer(src):\n                    start = m.start()\n                    lineno = src.count('\\n', 0, start) + 1\n                    matches.append({'text': m.group(0), 'lineno': lineno})\n            if len(matches) != 0:\n                output.append({'filename': f, 'matches': matches, 'dir': d})\n\n    return {'todo': output, 'app': app}\n\n\ndef editor_sessions():\n    config = Config(os.path.join(request.folder, 'settings.cfg'),\n                    section='editor_sessions', default_values={})\n    preferences = config.read()\n\n    if request.vars.session_name and request.vars.files:\n        session_name = request.vars.session_name\n        files = request.vars.files\n        preferences.update({session_name: ','.join(files)})\n        if config.save(preferences.items()):\n            response.headers[\"web2py-component-flash\"] = T('Session saved correctly')\n        else:\n            response.headers[\"web2py-component-flash\"] = T('Session saved on session only')\n\n    return response.render('default/editor_sessions.html', {'editor_sessions': preferences})\n\n\ndef resolve():\n    \"\"\"\n    \"\"\"\n\n    filename = '/'.join(request.args)\n    # ## check if file is not there\n    path = apath(filename, r=request)\n    a = safe_read(path).split('\\n')\n    try:\n        b = safe_read(path + '.1').split('\\n')\n    except IOError:\n        session.flash = 'Other file, no longer there'\n        redirect(URL('edit', args=request.args))\n\n    d = difflib.ndiff(a, b)\n\n    def leading(line):\n        \"\"\"  \"\"\"\n\n        # TODO: we really need to comment this\n        z = ''\n        for (k, c) in enumerate(line):\n            if c == ' ':\n                z += '&nbsp;'\n            elif c == ' \\t':\n                z += '&nbsp;'\n            elif k == 0 and c == '?':\n                pass\n            else:\n                break\n\n        return XML(z)\n\n    def getclass(item):\n        \"\"\" Determine item class \"\"\"\n        operators = {' ': 'normal', '+': 'plus', '-': 'minus'}\n\n        return operators[item[0]]\n\n    if request.vars:\n        c = '\\n'.join([item[2:].rstrip() for (i, item) in enumerate(d) if item[0]\n                       == ' ' or 'line%i' % i in request.vars])\n        safe_write(path, c)\n        session.flash = 'files merged'\n        redirect(URL('edit', args=request.args))\n    else:\n        # Making the short circuit compatible with <= python2.4\n        gen_data = lambda index, item: not item[:1] in ['+', '-'] and \"\" \\\n            or INPUT(_type='checkbox',\n                     _name='line%i' % index,\n                     value=item[0] == '+')\n\n        diff = TABLE(*[TR(TD(gen_data(i, item)),\n                          TD(item[0]),\n                          TD(leading(item[2:]),\n                             TT(item[2:].rstrip())),\n                          _class=getclass(item))\n                       for (i, item) in enumerate(d) if item[0] != '?'])\n\n    return dict(diff=diff, filename=filename)\n\n\ndef edit_language():\n    \"\"\" Edit language file \"\"\"\n    app = get_app()\n    filename = '/'.join(request.args)\n    response.title = request.args[-1]\n    strings = read_dict(apath(filename, r=request))\n\n    if '__corrupted__' in strings:\n        form = SPAN(strings['__corrupted__'], _class='error')\n        return dict(filename=filename, form=form)\n\n    keys = sorted(strings.keys(), lambda x, y: cmp(\n        unicode(x, 'utf-8').lower(), unicode(y, 'utf-8').lower()))\n    rows = []\n    rows.append(H2(T('Original/Translation')))\n\n    for key in keys:\n        name = md5_hash(key)\n        s = strings[key]\n        (prefix, sep, key) = key.partition('\\x01')\n        if sep:\n            prefix = SPAN(prefix + ': ', _class='tm_ftag')\n            k = key\n        else:\n            (k, prefix) = (prefix, '')\n\n        _class = 'untranslated' if k == s else 'translated'\n\n        if len(s) <= 40:\n            elem = INPUT(_type='text', _name=name, value=s,\n                         _size=70, _class=_class)\n        else:\n            elem = TEXTAREA(_name=name, value=s, _cols=70,\n                            _rows=5, _class=_class)\n\n        # Making the short circuit compatible with <= python2.4\n        k = (s != k) and k or B(k)\n\n        new_row = DIV(LABEL(prefix, k, _style=\"font-weight:normal;\"),\n                      CAT(elem, '\\n', TAG.BUTTON(\n                          T('delete'),\n                          _onclick='return delkey(\"%s\")' % name,\n                          _class='btn')), _id=name, _class='span6 well well-small')\n\n        rows.append(DIV(new_row, _class=\"row-fluid\"))\n    rows.append(DIV(INPUT(_type='submit', _value=T('update'), _class=\"btn btn-primary\"), _class='controls'))\n    form = FORM(*rows)\n    if form.accepts(request.vars, keepvalues=True):\n        strs = dict()\n        for key in keys:\n            name = md5_hash(key)\n            if form.vars[name] == chr(127):\n                continue\n            strs[key] = form.vars[name]\n        write_dict(apath(filename, r=request), strs)\n        session.flash = T('file saved on %(time)s', dict(time=time.ctime()))\n        redirect(URL(r=request, args=request.args))\n    return dict(app=request.args[0], filename=filename, form=form)\n\n\ndef edit_plurals():\n    \"\"\" Edit plurals file \"\"\"\n    app = get_app()\n    filename = '/'.join(request.args)\n    plurals = read_plural_dict(\n        apath(filename, r=request))  # plural forms dictionary\n    nplurals = int(request.vars.nplurals) - 1  # plural forms quantity\n    xnplurals = xrange(nplurals)\n\n    if '__corrupted__' in plurals:\n        # show error message and exit\n        form = SPAN(plurals['__corrupted__'], _class='error')\n        return dict(filename=filename, form=form)\n\n    keys = sorted(plurals.keys(), lambda x, y: cmp(\n        unicode(x, 'utf-8').lower(), unicode(y, 'utf-8').lower()))\n    tab_rows = []\n    for key in keys:\n        name = md5_hash(key)\n        forms = plurals[key]\n\n        if len(forms) < nplurals:\n            forms.extend(None for i in xrange(nplurals - len(forms)))\n        tab_col1 = DIV(CAT(LABEL(T(\"Singular Form\")), B(key,\n                                                        _class='fake-input')))\n        tab_inputs = [SPAN(LABEL(T(\"Plural Form #%s\", n + 1)), INPUT(_type='text', _name=name + '_' + str(n), value=forms[n], _size=20), _class='span6') for n in xnplurals]\n        tab_col2 = DIV(CAT(*tab_inputs))\n        tab_col3 = DIV(CAT(LABEL(XML('&nbsp;')), TAG.BUTTON(T('delete'), _onclick='return delkey(\"%s\")' % name, _class='btn'), _class='span6'))\n        tab_row = DIV(DIV(tab_col1, '\\n', tab_col2, '\\n', tab_col3, _class='well well-small'), _id=name, _class='row-fluid tab_row')\n        tab_rows.append(tab_row)\n\n    tab_rows.append(DIV(TAG['button'](T('update'), _type='submit',\n                                      _class='btn btn-primary'),\n                        _class='controls'))\n    tab_container = DIV(*tab_rows, **dict(_class=\"row-fluid\"))\n\n    form = FORM(tab_container)\n    if form.accepts(request.vars, keepvalues=True):\n        new_plurals = dict()\n        for key in keys:\n            name = md5_hash(key)\n            if form.vars[name + '_0'] == chr(127):\n                continue\n            new_plurals[key] = [form.vars[name + '_' + str(n)]\n                                for n in xnplurals]\n        write_plural_dict(apath(filename, r=request), new_plurals)\n        session.flash = T('file saved on %(time)s', dict(time=time.ctime()))\n        redirect(URL(r=request, args=request.args, vars=dict(\n            nplurals=request.vars.nplurals)))\n    return dict(app=request.args[0], filename=filename, form=form)\n\n\ndef about():\n    \"\"\" Read about info \"\"\"\n    app = get_app()\n    # ## check if file is not there\n    about = safe_read(apath('%s/ABOUT' % app, r=request))\n    license = safe_read(apath('%s/LICENSE' % app, r=request))\n    return dict(app=app, about=MARKMIN(about), license=MARKMIN(license), progress=report_progress(app))\n\n\ndef design():\n    \"\"\" Application design handler \"\"\"\n    app = get_app()\n\n    if not response.flash and app == request.application:\n        msg = T('ATTENTION: you cannot edit the running application!')\n        response.flash = msg\n\n    if request.vars and not request.vars.token == session.token:\n        redirect(URL('logout'))\n\n    if request.vars.pluginfile is not None and not isinstance(request.vars.pluginfile, str):\n        filename = os.path.basename(request.vars.pluginfile.filename)\n        if plugin_install(app, request.vars.pluginfile.file,\n                          request, filename):\n            session.flash = T('new plugin installed')\n            redirect(URL('design', args=app))\n        else:\n            session.flash = \\\n                T('unable to create application \"%s\"', request.vars.filename)\n        redirect(URL(r=request))\n    elif isinstance(request.vars.pluginfile, str):\n        session.flash = T('plugin not specified')\n        redirect(URL(r=request))\n\n    # If we have only pyc files it means that\n    # we cannot design\n    if os.path.exists(apath('%s/compiled' % app, r=request)):\n        session.flash = \\\n            T('application is compiled and cannot be designed')\n        redirect(URL('site'))\n\n    # Get all models\n    models = listdir(apath('%s/models/' % app, r=request), '.*\\.py$')\n    models = [x.replace('\\\\', '/') for x in models]\n    defines = {}\n    for m in models:\n        data = safe_read(apath('%s/models/%s' % (app, m), r=request))\n        defines[m] = regex_tables.findall(data)\n        defines[m].sort()\n\n    # Get all controllers\n    controllers = sorted(\n        listdir(apath('%s/controllers/' % app, r=request), '.*\\.py$'))\n    controllers = [x.replace('\\\\', '/') for x in controllers]\n    functions = {}\n    for c in controllers:\n        data = safe_read(apath('%s/controllers/%s' % (app, c), r=request))\n        items = find_exposed_functions(data)\n        functions[c] = items and sorted(items) or []\n\n    # Get all views\n    views = sorted(\n        listdir(apath('%s/views/' % app, r=request), '[\\w/\\-]+(\\.\\w+)+$'))\n    views = [x.replace('\\\\', '/') for x in views if not x.endswith('.bak')]\n    extend = {}\n    include = {}\n    for c in views:\n        data = safe_read(apath('%s/views/%s' % (app, c), r=request))\n        items = regex_extend.findall(data)\n\n        if items:\n            extend[c] = items[0][1]\n\n        items = regex_include.findall(data)\n        include[c] = [i[1] for i in items]\n\n    # Get all modules\n    modules = listdir(apath('%s/modules/' % app, r=request), '.*\\.py$')\n    modules = modules = [x.replace('\\\\', '/') for x in modules]\n    modules.sort()\n\n    # Get all private files\n    privates = listdir(apath('%s/private/' % app, r=request), '[^\\.#].*')\n    privates = [x.replace('\\\\', '/') for x in privates]\n    privates.sort()\n\n    # Get all static files\n    statics = listdir(apath('%s/static/' % app, r=request), '[^\\.#].*',\n                      maxnum=MAXNFILES)\n    statics = [x.replace(os.path.sep, '/') for x in statics]\n    statics.sort()\n\n    # Get all languages\n    langpath = os.path.join(apath(app, r=request), 'languages')\n    languages = dict([(lang, info) for lang, info\n                      in read_possible_languages(langpath).iteritems()\n                      if info[2] != 0])  # info[2] is langfile_mtime:\n    # get only existed files\n\n    # Get crontab\n    cronfolder = apath('%s/cron' % app, r=request)\n    crontab = apath('%s/cron/crontab' % app, r=request)\n    if not is_gae:\n        if not os.path.exists(cronfolder):\n            os.mkdir(cronfolder)\n        if not os.path.exists(crontab):\n            safe_write(crontab, '#crontab')\n\n    plugins = []\n\n    def filter_plugins(items, plugins):\n        plugins += [item[7:].split('/')[0].split(\n            '.')[0] for item in items if item.startswith('plugin_')]\n        plugins[:] = list(set(plugins))\n        plugins.sort()\n        return [item for item in items if not item.startswith('plugin_')]\n\n    return dict(app=app,\n                models=filter_plugins(models, plugins),\n                defines=defines,\n                controllers=filter_plugins(controllers, plugins),\n                functions=functions,\n                views=filter_plugins(views, plugins),\n                modules=filter_plugins(modules, plugins),\n                extend=extend,\n                include=include,\n                privates=filter_plugins(privates, plugins),\n                statics=filter_plugins(statics, plugins),\n                languages=languages,\n                crontab=crontab,\n                plugins=plugins)\n\n\ndef delete_plugin():\n    \"\"\" Object delete handler \"\"\"\n    app = request.args(0)\n    plugin = request.args(1)\n    plugin_name = 'plugin_' + plugin\n\n    dialog = FORM.confirm(\n        T('Delete'),\n        {T('Cancel'): URL('design', args=app)})\n\n    if dialog.accepted:\n        try:\n            for folder in ['models', 'views', 'controllers', 'static', 'modules', 'private']:\n                path = os.path.join(apath(app, r=request), folder)\n                for item in os.listdir(path):\n                    if item.rsplit('.', 1)[0] == plugin_name:\n                        filename = os.path.join(path, item)\n                        if os.path.isdir(filename):\n                            shutil.rmtree(filename)\n                        else:\n                            os.unlink(filename)\n            session.flash = T('plugin \"%(plugin)s\" deleted',\n                              dict(plugin=plugin))\n        except Exception:\n            session.flash = T('unable to delete file plugin \"%(plugin)s\"',\n                              dict(plugin=plugin))\n        redirect(URL('design', args=request.args(0), anchor=request.vars.id2))\n    return dict(dialog=dialog, plugin=plugin)\n\n\ndef plugin():\n    \"\"\" Application design handler \"\"\"\n    app = get_app()\n    plugin = request.args(1)\n\n    if not response.flash and app == request.application:\n        msg = T('ATTENTION: you cannot edit the running application!')\n        response.flash = msg\n\n    # If we have only pyc files it means that\n    # we cannot design\n    if os.path.exists(apath('%s/compiled' % app, r=request)):\n        session.flash = \\\n            T('application is compiled and cannot be designed')\n        redirect(URL('site'))\n\n    # Get all models\n    models = listdir(apath('%s/models/' % app, r=request), '.*\\.py$')\n    models = [x.replace('\\\\', '/') for x in models]\n    defines = {}\n    for m in models:\n        data = safe_read(apath('%s/models/%s' % (app, m), r=request))\n        defines[m] = regex_tables.findall(data)\n        defines[m].sort()\n\n    # Get all controllers\n    controllers = sorted(\n        listdir(apath('%s/controllers/' % app, r=request), '.*\\.py$'))\n    controllers = [x.replace('\\\\', '/') for x in controllers]\n    functions = {}\n    for c in controllers:\n        data = safe_read(apath('%s/controllers/%s' % (app, c), r=request))\n        items = find_exposed_functions(data)\n        functions[c] = items and sorted(items) or []\n\n    # Get all views\n    views = sorted(\n        listdir(apath('%s/views/' % app, r=request), '[\\w/\\-]+\\.\\w+$'))\n    views = [x.replace('\\\\', '/') for x in views]\n    extend = {}\n    include = {}\n    for c in views:\n        data = safe_read(apath('%s/views/%s' % (app, c), r=request))\n        items = regex_extend.findall(data)\n        if items:\n            extend[c] = items[0][1]\n\n        items = regex_include.findall(data)\n        include[c] = [i[1] for i in items]\n\n    # Get all modules\n    modules = listdir(apath('%s/modules/' % app, r=request), '.*\\.py$')\n    modules = modules = [x.replace('\\\\', '/') for x in modules]\n    modules.sort()\n\n    # Get all private files\n    privates = listdir(apath('%s/private/' % app, r=request), '[^\\.#].*')\n    privates = [x.replace('\\\\', '/') for x in privates]\n    privates.sort()\n\n    # Get all static files\n    statics = listdir(apath('%s/static/' % app, r=request), '[^\\.#].*',\n                      maxnum=MAXNFILES)\n    statics = [x.replace(os.path.sep, '/') for x in statics]\n    statics.sort()\n\n    # Get all languages\n    languages = sorted([lang + '.py' for lang, info in\n                        T.get_possible_languages_info().iteritems()\n                        if info[2] != 0])  # info[2] is langfile_mtime:\n    # get only existed files\n\n    # Get crontab\n    crontab = apath('%s/cron/crontab' % app, r=request)\n    if not os.path.exists(crontab):\n        safe_write(crontab, '#crontab')\n\n    def filter_plugins(items):\n        regex = re.compile('^plugin_' + plugin + '(/.*|\\..*)?$')\n        return [item for item in items if item and regex.match(item)]\n\n    return dict(app=app,\n                models=filter_plugins(models),\n                defines=defines,\n                controllers=filter_plugins(controllers),\n                functions=functions,\n                views=filter_plugins(views),\n                modules=filter_plugins(modules),\n                extend=extend,\n                include=include,\n                privates=filter_plugins(privates),\n                statics=filter_plugins(statics),\n                languages=languages,\n                crontab=crontab)\n\n\ndef create_file():\n    \"\"\" Create files handler \"\"\"\n    if request.vars and not request.vars.token == session.token:\n        redirect(URL('logout'))\n    try:\n        anchor = '#' + request.vars.id if request.vars.id else ''\n        if request.vars.app:\n            app = get_app(request.vars.app)\n            path = abspath(request.vars.location)\n        else:\n            if request.vars.dir:\n                request.vars.location += request.vars.dir + '/'\n            app = get_app(name=request.vars.location.split('/')[0])\n            path = apath(request.vars.location, r=request)\n        filename = re.sub('[^\\w./-]+', '_', request.vars.filename)\n        if path[-7:] == '/rules/':\n            # Handle plural rules files\n            if len(filename) == 0:\n                raise SyntaxError\n            if not filename[-3:] == '.py':\n                filename += '.py'\n            lang = re.match('^plural_rules-(.*)\\.py$', filename).group(1)\n            langinfo = read_possible_languages(apath(app, r=request))[lang]\n            text = dedent(\"\"\"\n                   #!/usr/bin/env python\n                   # -*- coding: utf-8 -*-\n                   # Plural-Forms for %(lang)s (%(langname)s)\n\n                   nplurals=2  # for example, English language has 2 forms:\n                               # 1 singular and 1 plural\n\n                   # Determine plural_id for number *n* as sequence of positive\n                   # integers: 0,1,...\n                   # NOTE! For singular form ALWAYS return plural_id = 0\n                   get_plural_id = lambda n: int(n != 1)\n\n                   # Construct and return plural form of *word* using\n                   # *plural_id* (which ALWAYS>0). This function will be executed\n                   # for words (or phrases) not found in plural_dict dictionary.\n                   # By default this function simply returns word in singular:\n                   construct_plural_form = lambda word, plural_id: word\n                   \"\"\")[1:] % dict(lang=langinfo[0], langname=langinfo[1])\n\n        elif path[-11:] == '/languages/':\n            # Handle language files\n            if len(filename) == 0:\n                raise SyntaxError\n            if not filename[-3:] == '.py':\n                filename += '.py'\n            path = os.path.join(apath(app, r=request), 'languages', filename)\n            if not os.path.exists(path):\n                safe_write(path, '')\n            # create language xx[-yy].py file:\n            findT(apath(app, r=request), filename[:-3])\n            session.flash = T('language file \"%(filename)s\" created/updated',\n                              dict(filename=filename))\n            redirect(request.vars.sender + anchor)\n\n        elif path[-8:] == '/models/':\n            # Handle python models\n            if not filename[-3:] == '.py':\n                filename += '.py'\n\n            if len(filename) == 3:\n                raise SyntaxError\n\n            text = '# -*- coding: utf-8 -*-\\n'\n\n        elif path[-13:] == '/controllers/':\n            # Handle python controllers\n            if not filename[-3:] == '.py':\n                filename += '.py'\n\n            if len(filename) == 3:\n                raise SyntaxError\n\n            text = '# -*- coding: utf-8 -*-\\n# %s\\ndef index(): return dict(message=\"hello from %s\")'\n            text = text % (T('try something like'), filename)\n\n        elif path[-7:] == '/views/':\n            if request.vars.plugin and not filename.startswith('plugin_%s/' % request.vars.plugin):\n                filename = 'plugin_%s/%s' % (request.vars.plugin, filename)\n            # Handle template (html) views\n            if filename.find('.') < 0:\n                filename += '.html'\n            extension = filename.split('.')[-1].lower()\n\n            if len(filename) == 5:\n                raise SyntaxError\n\n            msg = T(\n                'This is the %(filename)s template', dict(filename=filename))\n            if extension == 'html':\n                text = dedent(\"\"\"\n                   {{extend 'layout.html'}}\n                   <h1>%s</h1>\n                   {{=BEAUTIFY(response._vars)}}\"\"\" % msg)[1:]\n            else:\n                generic = os.path.join(path, 'generic.' + extension)\n                if os.path.exists(generic):\n                    text = read_file(generic)\n                else:\n                    text = ''\n\n        elif path[-9:] == '/modules/':\n            if request.vars.plugin and not filename.startswith('plugin_%s/' % request.vars.plugin):\n                filename = 'plugin_%s/%s' % (request.vars.plugin, filename)\n            # Handle python module files\n            if not filename[-3:] == '.py':\n                filename += '.py'\n\n            if len(filename) == 3:\n                raise SyntaxError\n\n            text = dedent(\"\"\"\n                   #!/usr/bin/env python\n                   # -*- coding: utf-8 -*-\n                   from gluon import *\\n\"\"\")[1:]\n\n        elif (path[-8:] == '/static/') or (path[-9:] == '/private/'):\n            if (request.vars.plugin and\n                    not filename.startswith('plugin_%s/' % request.vars.plugin)):\n                filename = 'plugin_%s/%s' % (request.vars.plugin, filename)\n            text = ''\n\n        else:\n            redirect(request.vars.sender + anchor)\n\n        full_filename = os.path.join(path, filename)\n        dirpath = os.path.dirname(full_filename)\n\n        if not os.path.exists(dirpath):\n            os.makedirs(dirpath)\n\n        if os.path.exists(full_filename):\n            raise SyntaxError\n\n        safe_write(full_filename, text)\n        log_progress(app, 'CREATE', filename)\n        if request.vars.dir:\n            result = T('file \"%(filename)s\" created',\n                       dict(filename=full_filename[len(path):]))\n        else:\n            session.flash = T('file \"%(filename)s\" created',\n                              dict(filename=full_filename[len(path):]))\n        vars = {}\n        if request.vars.id:\n            vars['id'] = request.vars.id\n        if request.vars.app:\n            vars['app'] = request.vars.app\n        redirect(URL('edit',\n                     args=[os.path.join(request.vars.location, filename)], vars=vars))\n\n    except Exception, e:\n        if not isinstance(e, HTTP):\n            session.flash = T('cannot create file')\n\n    if request.vars.dir:\n        response.flash = result\n        response.headers['web2py-component-content'] = 'append'\n        response.headers['web2py-component-command'] = \"%s %s %s\" % (\n            \"$.web2py.invalidate('#files_menu');\",\n            \"load_file('%s');\" % URL('edit', args=[app, request.vars.dir, filename]),\n            \"$.web2py.enableElement($('#form form').find($.web2py.formInputClickSelector));\")\n        return ''\n    else:\n        redirect(request.vars.sender + anchor)\n\n\ndef listfiles(app, dir, regexp='.*\\.py$'):\n    files = sorted(\n        listdir(apath('%(app)s/%(dir)s/' % {'app': app, 'dir': dir}, r=request), regexp))\n    files = [x.replace('\\\\', '/') for x in files if not x.endswith('.bak')]\n    return files\n\n\ndef editfile(path, file, vars={}, app=None):\n    args = (path, file) if 'app' in vars else (app, path, file)\n    url = URL('edit', args=args, vars=vars)\n    return A(file, _class='editor_filelink', _href=url, _style='word-wrap: nowrap;')\n\n\ndef files_menu():\n    app = request.vars.app or 'welcome'\n    dirs = [{'name': 'models', 'reg': '.*\\.py$'},\n            {'name': 'controllers', 'reg': '.*\\.py$'},\n            {'name': 'views', 'reg': '[\\w/\\-]+(\\.\\w+)+$'},\n            {'name': 'modules', 'reg': '.*\\.py$'},\n            {'name': 'static', 'reg': '[^\\.#].*'},\n            {'name': 'private', 'reg': '.*\\.py$'}]\n    result_files = []\n    for dir in dirs:\n        result_files.append(TAG[''](LI(dir['name'], _class=\"nav-header component\", _onclick=\"collapse('\" + dir['name'] + \"_files');\"),\n                                    LI(UL(*[LI(editfile(dir['name'], f, dict(id=dir['name'] + f.replace('.', '__')), app), _style=\"overflow:hidden\", _id=dir['name'] + \"__\" + f.replace('.', '__'))\n                                            for f in listfiles(app, dir['name'], regexp=dir['reg'])],\n                                          _class=\"nav nav-list small-font\"),\n                                       _id=dir['name'] + '_files', _style=\"display: none;\")))\n    return dict(result_files=result_files)\n\n\ndef upload_file():\n    \"\"\" File uploading handler \"\"\"\n    if request.vars and not request.vars.token == session.token:\n        redirect(URL('logout'))\n    try:\n        filename = None\n        app = get_app(name=request.vars.location.split('/')[0])\n        path = apath(request.vars.location, r=request)\n\n        if request.vars.filename:\n            filename = re.sub('[^\\w\\./]+', '_', request.vars.filename)\n        else:\n            filename = os.path.split(request.vars.file.filename)[-1]\n\n        if path[-8:] == '/models/' and not filename[-3:] == '.py':\n            filename += '.py'\n\n        if path[-9:] == '/modules/' and not filename[-3:] == '.py':\n            filename += '.py'\n\n        if path[-13:] == '/controllers/' and not filename[-3:] == '.py':\n            filename += '.py'\n\n        if path[-7:] == '/views/' and not filename[-5:] == '.html':\n            filename += '.html'\n\n        if path[-11:] == '/languages/' and not filename[-3:] == '.py':\n            filename += '.py'\n\n        filename = os.path.join(path, filename)\n        dirpath = os.path.dirname(filename)\n\n        if not os.path.exists(dirpath):\n            os.makedirs(dirpath)\n\n        data = request.vars.file.file.read()\n        lineno = count_lines(data)\n        safe_write(filename, data, 'wb')\n        log_progress(app, 'UPLOAD', filename, lineno)\n        session.flash = T('file \"%(filename)s\" uploaded',\n                          dict(filename=filename[len(path):]))\n    except Exception:\n        if filename:\n            d = dict(filename=filename[len(path):])\n        else:\n            d = dict(filename='unknown')\n        session.flash = T('cannot upload file \"%(filename)s\"', d)\n\n    redirect(request.vars.sender)\n\n\ndef errors():\n    \"\"\" Error handler \"\"\"\n    import operator\n    import os\n    import pickle\n    import hashlib\n\n    app = get_app()\n    if is_gae:\n        method = 'dbold' if ('old' in\n                             (request.args(1) or '')) else 'dbnew'\n    else:\n        method = request.args(1) or 'new'\n    db_ready = {}\n    db_ready['status'] = get_ticket_storage(app)\n    db_ready['errmessage'] = T(\n        \"No ticket_storage.txt found under /private folder\")\n    db_ready['errlink'] = \"http://web2py.com/books/default/chapter/29/13#Collecting-tickets\"\n\n    if method == 'new':\n        errors_path = apath('%s/errors' % app, r=request)\n\n        delete_hashes = []\n        for item in request.vars:\n            if item[:7] == 'delete_':\n                delete_hashes.append(item[7:])\n\n        hash2error = dict()\n\n        for fn in listdir(errors_path, '^[a-fA-F0-9.\\-]+$'):\n            fullpath = os.path.join(errors_path, fn)\n            if not os.path.isfile(fullpath):\n                continue\n            try:\n                fullpath_file = open(fullpath, 'r')\n                try:\n                    error = pickle.load(fullpath_file)\n                finally:\n                    fullpath_file.close()\n            except IOError:\n                continue\n            except EOFError:\n                continue\n\n            hash = hashlib.md5(error['traceback']).hexdigest()\n\n            if hash in delete_hashes:\n                os.unlink(fullpath)\n            else:\n                try:\n                    hash2error[hash]['count'] += 1\n                except KeyError:\n                    error_lines = error['traceback'].split(\"\\n\")\n                    last_line = error_lines[-2] if len(error_lines) > 1 else 'unknown'\n                    error_causer = os.path.split(error['layer'])[1]\n                    hash2error[hash] = dict(count=1, pickel=error,\n                                            causer=error_causer,\n                                            last_line=last_line,\n                                            hash=hash, ticket=fn)\n\n        decorated = [(x['count'], x) for x in hash2error.values()]\n        decorated.sort(key=operator.itemgetter(0), reverse=True)\n\n        return dict(errors=[x[1] for x in decorated], app=app, method=method, db_ready=db_ready)\n\n    elif method == 'dbnew':\n        errors_path = apath('%s/errors' % app, r=request)\n        tk_db, tk_table = get_ticket_storage(app)\n\n        delete_hashes = []\n        for item in request.vars:\n            if item[:7] == 'delete_':\n                delete_hashes.append(item[7:])\n\n        hash2error = dict()\n\n        for fn in tk_db(tk_table.id > 0).select():\n            try:\n                error = pickle.loads(fn.ticket_data)\n                hash = hashlib.md5(error['traceback']).hexdigest()\n\n                if hash in delete_hashes:\n                    tk_db(tk_table.id == fn.id).delete()\n                    tk_db.commit()\n                else:\n                    try:\n                        hash2error[hash]['count'] += 1\n                    except KeyError:\n                        error_lines = error['traceback'].split(\"\\n\")\n                        last_line = error_lines[-2]\n                        error_causer = os.path.split(error['layer'])[1]\n                        hash2error[hash] = dict(count=1,\n                                                pickel=error, causer=error_causer,\n                                                last_line=last_line, hash=hash,\n                                                ticket=fn.ticket_id)\n            except AttributeError, e:\n                tk_db(tk_table.id == fn.id).delete()\n                tk_db.commit()\n\n        decorated = [(x['count'], x) for x in hash2error.values()]\n        decorated.sort(key=operator.itemgetter(0), reverse=True)\n        return dict(errors=[x[1] for x in decorated], app=app,\n                    method=method, db_ready=db_ready)\n\n    elif method == 'dbold':\n        tk_db, tk_table = get_ticket_storage(app)\n        for item in request.vars:\n            if item[:7] == 'delete_':\n                tk_db(tk_table.ticket_id == item[7:]).delete()\n                tk_db.commit()\n        tickets_ = tk_db(tk_table.id > 0).select(tk_table.ticket_id,\n                                                 tk_table.created_datetime,\n                                                 orderby=~tk_table.created_datetime)\n        tickets = [row.ticket_id for row in tickets_]\n        times = dict([(row.ticket_id, row.created_datetime) for\n                      row in tickets_])\n        return dict(app=app, tickets=tickets, method=method,\n                    times=times, db_ready=db_ready)\n\n    else:\n        for item in request.vars:\n            # delete_all rows doesn't contain any ticket\n            # Remove anything else as requested\n            if item[:7] == 'delete_' and (not item == \"delete_all}\"):\n                os.unlink(apath('%s/errors/%s' % (app, item[7:]), r=request))\n        func = lambda p: os.stat(apath('%s/errors/%s' %\n                                       (app, p), r=request)).st_mtime\n        tickets = sorted(\n            listdir(apath('%s/errors/' % app, r=request), '^\\w.*'),\n            key=func,\n            reverse=True)\n\n        return dict(app=app, tickets=tickets, method=method, db_ready=db_ready)\n\n\ndef get_ticket_storage(app):\n    private_folder = apath('%s/private' % app, r=request)\n    ticket_file = os.path.join(private_folder, 'ticket_storage.txt')\n    if os.path.exists(ticket_file):\n        db_string = open(ticket_file).read()\n        db_string = db_string.strip().replace('\\r', '').replace('\\n', '')\n    elif is_gae:\n        # use Datastore as fallback if there is no ticket_file\n        db_string = \"google:datastore\"\n    else:\n        return False\n    tickets_table = 'web2py_ticket'\n    tablename = tickets_table + '_' + app\n    db_path = apath('%s/databases' % app, r=request)\n    ticketsdb = DAL(db_string, folder=db_path, auto_import=True)\n    if not ticketsdb.get(tablename):\n        table = ticketsdb.define_table(\n            tablename,\n            Field('ticket_id', length=100),\n            Field('ticket_data', 'text'),\n            Field('created_datetime', 'datetime'),\n        )\n    return ticketsdb, ticketsdb.get(tablename)\n\n\ndef make_link(path):\n    \"\"\" Create a link from a path \"\"\"\n    tryFile = path.replace('\\\\', '/')\n\n    if os.path.isabs(tryFile) and os.path.isfile(tryFile):\n        (folder, filename) = os.path.split(tryFile)\n        (base, ext) = os.path.splitext(filename)\n        app = get_app()\n\n        editable = {'controllers': '.py', 'models': '.py', 'views': '.html'}\n        for key in editable.keys():\n            check_extension = folder.endswith(\"%s/%s\" % (app, key))\n            if ext.lower() == editable[key] and check_extension:\n                return A('\"' + tryFile + '\"',\n                         _href=URL(r=request,\n                                   f='edit/%s/%s/%s' % (app, key, filename))).xml()\n    return ''\n\n\ndef make_links(traceback):\n    \"\"\" Make links using the given traceback \"\"\"\n\n    lwords = traceback.split('\"')\n\n    # Making the short circuit compatible with <= python2.4\n    result = (len(lwords) != 0) and lwords[0] or ''\n\n    i = 1\n\n    while i < len(lwords):\n        link = make_link(lwords[i])\n\n        if link == '':\n            result += '\"' + lwords[i]\n        else:\n            result += link\n\n            if i + 1 < len(lwords):\n                result += lwords[i + 1]\n                i = i + 1\n\n        i = i + 1\n\n    return result\n\n\nclass TRACEBACK(object):\n    \"\"\" Generate the traceback \"\"\"\n\n    def __init__(self, text):\n        \"\"\" TRACEBACK constructor \"\"\"\n\n        self.s = make_links(CODE(text).xml())\n\n    def xml(self):\n        \"\"\" Returns the xml \"\"\"\n\n        return self.s\n\n\ndef ticket():\n    \"\"\" Ticket handler \"\"\"\n\n    if len(request.args) != 2:\n        session.flash = T('invalid ticket')\n        redirect(URL('site'))\n\n    app = get_app()\n    myversion = request.env.web2py_version\n    ticket = request.args[1]\n    e = RestrictedError()\n    e.load(request, app, ticket)\n\n    return dict(app=app,\n                ticket=ticket,\n                output=e.output,\n                traceback=(e.traceback and TRACEBACK(e.traceback)),\n                snapshot=e.snapshot,\n                code=e.code,\n                layer=e.layer,\n                myversion=myversion)\n\n\ndef ticketdb():\n    \"\"\" Ticket handler \"\"\"\n\n    if len(request.args) != 2:\n        session.flash = T('invalid ticket')\n        redirect(URL('site'))\n\n    app = get_app()\n    myversion = request.env.web2py_version\n    ticket = request.args[1]\n    e = RestrictedError()\n    request.tickets_db = get_ticket_storage(app)[0]\n    e.load(request, app, ticket)\n    response.view = 'default/ticket.html'\n    return dict(app=app,\n                ticket=ticket,\n                output=e.output,\n                traceback=(e.traceback and TRACEBACK(e.traceback)),\n                snapshot=e.snapshot,\n                code=e.code,\n                layer=e.layer,\n                myversion=myversion)\n\n\ndef error():\n    \"\"\" Generate a ticket (for testing) \"\"\"\n    raise RuntimeError('admin ticket generator at your service')\n\n\ndef update_languages():\n    \"\"\" Update available languages \"\"\"\n\n    app = get_app()\n    update_all_languages(apath(app, r=request))\n    session.flash = T('Language files (static strings) updated')\n    redirect(URL('design', args=app, anchor='languages'))\n\n\ndef user():\n    if MULTI_USER_MODE:\n        if not db(db.auth_user).count():\n            auth.settings.registration_requires_approval = False\n        return dict(form=auth())\n    else:\n        return dict(form=T(\"Disabled\"))\n\n\ndef reload_routes():\n    \"\"\" Reload routes.py \"\"\"\n    import gluon.rewrite\n    gluon.rewrite.load()\n    redirect(URL('site'))\n\n\ndef manage_students():\n    if not (MULTI_USER_MODE and is_manager()):\n        session.flash = T('Not Authorized')\n        redirect(URL('site'))\n    db.auth_user.registration_key.writable = True\n    grid = SQLFORM.grid(db.auth_user)\n    return locals()\n\n\ndef bulk_register():\n    if not (MULTI_USER_MODE and is_manager()):\n        session.flash = T('Not Authorized')\n        redirect(URL('site'))\n    form = SQLFORM.factory(Field('emails', 'text'))\n    if form.process().accepted:\n        emails = [x.strip() for x in form.vars.emails.split('\\n') if x.strip()]\n        n = 0\n        for email in emails:\n            if not db.auth_user(email=email):\n                n += db.auth_user.insert(email=email) and 1 or 0\n        session.flash = T('%s students registered', n)\n        redirect(URL('site'))\n    return locals()\n\n# Begin experimental stuff need fixes:\n# 1) should run in its own process - cannot os.chdir\n# 2) should not prompt user at console\n# 3) should give option to force commit and not reuqire manual merge\n\n\ndef git_pull():\n    \"\"\" Git Pull handler \"\"\"\n    app = get_app()\n    if not have_git:\n        session.flash = GIT_MISSING\n        redirect(URL('site'))\n    dialog = FORM.confirm(T('Pull'),\n                          {T('Cancel'): URL('site')})\n    if dialog.accepted:\n        try:\n            repo = git.Repo(os.path.join(apath(r=request), app))\n            origin = repo.remotes.origin\n            origin.fetch()\n            origin.pull()\n            session.flash = T(\"Application updated via git pull\")\n            redirect(URL('site'))\n\n        except git.CheckoutError:\n            session.flash = T(\"Pull failed, certain files could not be checked out. Check logs for details.\")\n            redirect(URL('site'))\n        except git.UnmergedEntriesError:\n            session.flash = T(\"Pull is not possible because you have unmerged files. Fix them up in the work tree, and then try again.\")\n            redirect(URL('site'))\n        except git.GitCommandError:\n            session.flash = T(\n                \"Pull failed, git exited abnormally. See logs for details.\")\n            redirect(URL('site'))\n        except AssertionError:\n            session.flash = T(\"Pull is not possible because you have unmerged files. Fix them up in the work tree, and then try again.\")\n            redirect(URL('site'))\n    elif 'cancel' in request.vars:\n        redirect(URL('site'))\n    return dict(app=app, dialog=dialog)\n\n\ndef git_push():\n    \"\"\" Git Push handler \"\"\"\n    app = get_app()\n    if not have_git:\n        session.flash = GIT_MISSING\n        redirect(URL('site'))\n    form = SQLFORM.factory(Field('changelog', requires=IS_NOT_EMPTY()))\n    form.element('input[type=submit]')['_value'] = T('Push')\n    form.add_button(T('Cancel'), URL('site'))\n    form.process()\n    if form.accepted:\n        try:\n            repo = git.Repo(os.path.join(apath(r=request), app))\n            index = repo.index\n            index.add([apath(r=request) + app + '/*'])\n            new_commit = index.commit(form.vars.changelog)\n            origin = repo.remotes.origin\n            origin.push()\n            session.flash = T(\n                \"Git repo updated with latest application changes.\")\n            redirect(URL('site'))\n        except git.UnmergedEntriesError:\n            session.flash = T(\"Push failed, there are unmerged entries in the cache. Resolve merge issues manually and try again.\")\n            redirect(URL('site'))\n    return dict(app=app, form=form)\n\n\ndef plugins():\n    app = request.args(0)\n    from serializers import loads_json\n    if not session.plugins:\n        try:\n            rawlist = urllib.urlopen(\"http://www.web2pyslices.com/\" +\n                                     \"public/api.json/action/list/content/Package?package\" +\n                                     \"_type=plugin&search_index=false\").read()\n            session.plugins = loads_json(rawlist)\n        except:\n            response.flash = T('Unable to download the list of plugins')\n            session.plugins = []\n    return dict(plugins=session.plugins[\"results\"], app=request.args(0))\n\n\ndef install_plugin():\n    app = request.args(0)\n    source = request.vars.source\n    plugin = request.vars.plugin\n    if not (source and app):\n        raise HTTP(500, T(\"Invalid request\"))\n    # make sure no XSS attacks in source\n    if not source.lower().split('://')[0] in ('http','https'):\n        raise HTTP(500, T(\"Invalid request\"))\n    form = SQLFORM.factory()\n    result = None\n    if form.process().accepted:\n        # get w2p plugin\n        if \"web2py.plugin.\" in source:\n            filename = \"web2py.plugin.%s.w2p\" % \\\n                source.split(\"web2py.plugin.\")[-1].split(\".w2p\")[0]\n        else:\n            filename = \"web2py.plugin.%s.w2p\" % cleanpath(plugin)\n        if plugin_install(app, urllib.urlopen(source),\n                          request, filename):\n            session.flash = T('New plugin installed: %s', filename)\n        else:\n            session.flash = \\\n                T('unable to install plugin \"%s\"', filename)\n        redirect(URL(f=\"plugins\", args=[app, ]))\n    return dict(form=form, app=app, plugin=plugin, source=source)\n", "import base64\nimport os\nimport time\nfrom gluon import portalocker\nfrom gluon.admin import apath\nfrom gluon.fileutils import read_file\nfrom gluon.utils import web2py_uuid\n# ###########################################################\n# ## make sure administrator is on localhost or https\n# ###########################################################\n\n\nhttp_host = request.env.http_host.split(':')[0]\n\nif request.env.web2py_runtime_gae:\n    session_db = DAL('gae')\n    session.connect(request, response, db=session_db)\n    hosts = (http_host, )\n    is_gae = True\nelse:\n    is_gae = False\n\nif request.is_https:\n    session.secure()\nelif not request.is_local and not DEMO_MODE:\n    raise HTTP(200, T('Admin is disabled because insecure channel'))\n\ntry:\n    _config = {}\n    port = int(request.env.server_port or 0)\n    restricted(\n        read_file(apath('../parameters_%i.py' % port, request)), _config)\n\n    if not 'password' in _config or not _config['password']:\n        raise HTTP(200, T('admin disabled because no admin password'))\nexcept IOError:\n    import gluon.fileutils\n    if is_gae:\n        if gluon.fileutils.check_credentials(request):\n            session.authorized = True\n            session.last_time = time.time()\n        else:\n            raise HTTP(200,\n                       T('admin disabled because not supported on google app engine'))\n    else:\n        raise HTTP(\n            200, T('admin disabled because unable to access password file'))\n\n\ndef verify_password(password):\n    session.pam_user = None\n    if DEMO_MODE:\n        ret = True\n    elif not _config.get('password'):\n        ret - False\n    elif _config['password'].startswith('pam_user:'):\n        session.pam_user = _config['password'][9:].strip()\n        import gluon.contrib.pam\n        ret = gluon.contrib.pam.authenticate(session.pam_user, password)\n    else:\n        ret = _config['password'] == CRYPT()(password)[0]\n    if ret:\n        session.hmac_key = web2py_uuid()\n    return ret\n\n\n# ###########################################################\n# ## handle brute-force login attacks\n# ###########################################################\n\ndeny_file = os.path.join(request.folder, 'private', 'hosts.deny')\nallowed_number_of_attempts = 5\nexpiration_failed_logins = 3600\n\n\ndef read_hosts_deny():\n    import datetime\n    hosts = {}\n    if os.path.exists(deny_file):\n        hosts = {}\n        f = open(deny_file, 'r')\n        portalocker.lock(f, portalocker.LOCK_SH)\n        for line in f.readlines():\n            if not line.strip() or line.startswith('#'):\n                continue\n            fields = line.strip().split()\n            if len(fields) > 2:\n                hosts[fields[0].strip()] = (  # ip\n                    int(fields[1].strip()),  # n attemps\n                    int(fields[2].strip())   # last attempts\n                    )\n        portalocker.unlock(f)\n        f.close()\n    return hosts\n\n\ndef write_hosts_deny(denied_hosts):\n    f = open(deny_file, 'w')\n    portalocker.lock(f, portalocker.LOCK_EX)\n    for key, val in denied_hosts.items():\n        if time.time() - val[1] < expiration_failed_logins:\n            line = '%s %s %s\\n' % (key, val[0], val[1])\n            f.write(line)\n    portalocker.unlock(f)\n    f.close()\n\ndef login_record(success=True):\n    denied_hosts = read_hosts_deny()\n    val = (0, 0)\n    if success and request.client in denied_hosts:\n        del denied_hosts[request.client]\n    elif not success:\n        val = denied_hosts.get(request.client, (0, 0))\n        if time.time() - val[1] < expiration_failed_logins \\\n            and val[0] >= allowed_number_of_attempts:\n            return val[0]  # locked out\n        time.sleep(2 ** val[0])\n        val = (val[0] + 1, int(time.time()))\n        denied_hosts[request.client] = val\n    write_hosts_deny(denied_hosts)\n    return val[0]\n\ndef failed_login_count():\n    denied_hosts = read_hosts_deny()\n    val = denied_hosts.get(request.client, (0, 0))\n    return val[0]\n\n\n# ###########################################################\n# ## session expiration\n# ###########################################################\n\nt0 = time.time()\nif session.authorized:\n\n    if session.last_time and session.last_time < t0 - EXPIRATION:\n        session.flash = T('session expired')\n        session.authorized = False\n    else:\n        session.last_time = t0\n\n\nif request.vars.is_mobile in ('true', 'false', 'auto'):\n    session.is_mobile = request.vars.is_mobile or 'auto'\nif request.controller == 'default' and request.function == 'index':\n    if not request.vars.is_mobile:\n        session.is_mobile = 'auto'\nif not session.is_mobile:\n    session.is_mobile = 'auto'\nif session.is_mobile == 'true':\n    is_mobile = True\nelif session.is_mobile == 'false':\n    is_mobile = False\nelse:\n    is_mobile = request.user_agent().get('is_mobile',False)\n\nif DEMO_MODE:\n    session.authorized = True\n    session.forget()\n\nif request.controller == \"webservices\":\n    basic = request.env.http_authorization\n    if not basic or not basic[:6].lower() == 'basic ':\n        raise HTTP(401, \"Wrong credentials\")\n    (username, password) = base64.b64decode(basic[6:]).split(':')\n    if not verify_password(password) or MULTI_USER_MODE:\n        time.sleep(10)\n        raise HTTP(403, \"Not authorized\")\nelif not session.authorized and not \\\n    (request.controller + '/' + request.function in\n     ('default/index', 'default/user', 'plugin_jqmobile/index', 'plugin_jqmobile/about')):\n\n    if request.env.query_string:\n        query_string = '?' + request.env.query_string\n    else:\n        query_string = ''\n\n    if request.env.web2py_original_uri:\n        url = request.env.web2py_original_uri\n    else:\n        url = request.env.path_info + query_string\n    redirect(URL(request.application, 'default', 'index', vars=dict(send=url)))\nelif session.authorized and \\\n     request.controller == 'default' and \\\n     request.function == 'index':\n    redirect(URL(request.application, 'default', 'site'))\n\nif request.controller == 'appadmin' and DEMO_MODE:\n    session.flash = 'Appadmin disabled in demo mode'\n    redirect(URL('default', 'sites'))\n"], "buggy_code_start_loc": [123, 107], "buggy_code_end_loc": [123, 121], "fixing_code_start_loc": [124, 106], "fixing_code_end_loc": [127, 126], "type": "CWE-254", "message": "web2py before 2.14.6 does not properly check if a host is denied before verifying passwords, allowing a remote attacker to perform brute-force attacks.", "other": {"cve": {"id": "CVE-2016-10321", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-10T14:59:00.217", "lastModified": "2019-06-21T22:15:09.730", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "web2py before 2.14.6 does not properly check if a host is denied before verifying passwords, allowing a remote attacker to perform brute-force attacks."}, {"lang": "es", "value": "Web2py en versiones anteriores a 2.14.6 no comprueba correctamente si se deniega un host antes de verificar las contrase\u00f1as, lo que permite a un atacante remoto realizar ataques de fuerza bruta."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-254"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:web2py:web2py:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.14.5", "matchCriteriaId": "2D00591E-37CF-4D32-9EE5-CD961E1F75F0"}]}]}], "references": [{"url": "https://github.com/web2py/web2py/commit/944d8bd8f3c5cf8ae296fc03d149056c65358426", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/web2py/web2py/issues/1585#issuecomment-284317919", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4030-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/web2py/web2py/commit/944d8bd8f3c5cf8ae296fc03d149056c65358426"}}