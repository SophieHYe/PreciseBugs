{"buggy_code": ["from collections import defaultdict\nfrom datetime import datetime\n\nfrom debts import settle\nfrom flask import current_app, g\nfrom flask_sqlalchemy import BaseQuery, SQLAlchemy\nfrom itsdangerous import (\n    BadSignature,\n    SignatureExpired,\n    TimedJSONWebSignatureSerializer,\n    URLSafeSerializer,\n)\nimport sqlalchemy\nfrom sqlalchemy import orm\nfrom sqlalchemy.sql import func\nfrom sqlalchemy_continuum import make_versioned, version_class\nfrom sqlalchemy_continuum.plugins import FlaskPlugin\nfrom werkzeug.security import generate_password_hash\n\nfrom ihatemoney.patch_sqlalchemy_continuum import PatchedBuilder\nfrom ihatemoney.versioning import (\n    ConditionalVersioningManager,\n    LoggingMode,\n    get_ip_if_allowed,\n    version_privacy_predicate,\n)\n\nmake_versioned(\n    user_cls=None,\n    manager=ConditionalVersioningManager(\n        # Conditionally Disable the versioning based on each\n        # project's privacy preferences\n        tracking_predicate=version_privacy_predicate,\n        # Patch in a fix to a SQLAchemy-Continuum Bug.\n        # See patch_sqlalchemy_continuum.py\n        builder=PatchedBuilder(),\n    ),\n    plugins=[\n        FlaskPlugin(\n            # Redirect to our own function, which respects user preferences\n            # on IP address collection\n            remote_addr_factory=get_ip_if_allowed,\n            # Suppress the plugin's attempt to grab a user id,\n            # which imports the flask_login module (causing an error)\n            current_user_id_factory=lambda: None,\n        )\n    ],\n)\n\ndb = SQLAlchemy()\n\n\nclass Project(db.Model):\n    class ProjectQuery(BaseQuery):\n        def get_by_name(self, name):\n            return Project.query.filter(Project.name == name).one()\n\n    # Direct SQLAlchemy-Continuum to track changes to this model\n    __versioned__ = {}\n\n    id = db.Column(db.String(64), primary_key=True)\n\n    name = db.Column(db.UnicodeText)\n    password = db.Column(db.String(128))\n    contact_email = db.Column(db.String(128))\n    logging_preference = db.Column(\n        db.Enum(LoggingMode),\n        default=LoggingMode.default(),\n        nullable=False,\n        server_default=LoggingMode.default().name,\n    )\n    members = db.relationship(\"Person\", backref=\"project\")\n\n    query_class = ProjectQuery\n    default_currency = db.Column(db.String(3))\n\n    @property\n    def _to_serialize(self):\n        obj = {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"contact_email\": self.contact_email,\n            \"logging_preference\": self.logging_preference.value,\n            \"members\": [],\n            \"default_currency\": self.default_currency,\n        }\n\n        balance = self.balance\n        for member in self.members:\n            member_obj = member._to_serialize\n            member_obj[\"balance\"] = balance.get(member.id, 0)\n            obj[\"members\"].append(member_obj)\n\n        return obj\n\n    @property\n    def active_members(self):\n        return [m for m in self.members if m.activated]\n\n    @property\n    def balance(self):\n\n        balances, should_pay, should_receive = (defaultdict(int) for time in (1, 2, 3))\n\n        # for each person\n        for person in self.members:\n            # get the list of bills he has to pay\n            bills = Bill.query.options(orm.subqueryload(Bill.owers)).filter(\n                Bill.owers.contains(person)\n            )\n            for bill in bills.all():\n                if person != bill.payer:\n                    share = bill.pay_each() * person.weight\n                    should_pay[person] += share\n                    should_receive[bill.payer] += share\n\n        for person in self.members:\n            balance = should_receive[person] - should_pay[person]\n            balances[person.id] = balance\n\n        return balances\n\n    @property\n    def members_stats(self):\n        \"\"\"Compute what each member has paid\n\n        :return: one stat dict per member\n        :rtype list:\n        \"\"\"\n        return [\n            {\n                \"member\": member,\n                \"paid\": sum(\n                    [\n                        bill.converted_amount\n                        for bill in self.get_member_bills(member.id).all()\n                    ]\n                ),\n                \"spent\": sum(\n                    [\n                        bill.pay_each() * member.weight\n                        for bill in self.get_bills().all()\n                        if member in bill.owers\n                    ]\n                ),\n                \"balance\": self.balance[member.id],\n            }\n            for member in self.active_members\n        ]\n\n    @property\n    def monthly_stats(self):\n        \"\"\"Compute expenses by month\n\n        :return: a dict of years mapping to a dict of months mapping to the amount\n        :rtype dict:\n        \"\"\"\n        monthly = defaultdict(lambda: defaultdict(float))\n        for bill in self.get_bills().all():\n            monthly[bill.date.year][bill.date.month] += bill.converted_amount\n        return monthly\n\n    @property\n    def uses_weights(self):\n        return len([i for i in self.members if i.weight != 1]) > 0\n\n    def get_transactions_to_settle_bill(self, pretty_output=False):\n        \"\"\"Return a list of transactions that could be made to settle the bill\"\"\"\n\n        def prettify(transactions, pretty_output):\n            \"\"\" Return pretty transactions\n            \"\"\"\n            if not pretty_output:\n                return transactions\n            pretty_transactions = []\n            for transaction in transactions:\n                pretty_transactions.append(\n                    {\n                        \"ower\": transaction[\"ower\"].name,\n                        \"receiver\": transaction[\"receiver\"].name,\n                        \"amount\": round(transaction[\"amount\"], 2),\n                    }\n                )\n            return pretty_transactions\n\n        # cache value for better performance\n        members = {person.id: person for person in self.members}\n        settle_plan = settle(self.balance.items()) or []\n\n        transactions = [\n            {\n                \"ower\": members[ower_id],\n                \"receiver\": members[receiver_id],\n                \"amount\": amount,\n            }\n            for ower_id, amount, receiver_id in settle_plan\n        ]\n\n        return prettify(transactions, pretty_output)\n\n    def exactmatch(self, credit, debts):\n        \"\"\"Recursively try and find subsets of 'debts' whose sum is equal to credit\"\"\"\n        if not debts:\n            return None\n        if debts[0][\"balance\"] > credit:\n            return self.exactmatch(credit, debts[1:])\n        elif debts[0][\"balance\"] == credit:\n            return [debts[0]]\n        else:\n            match = self.exactmatch(credit - debts[0][\"balance\"], debts[1:])\n            if match:\n                match.append(debts[0])\n            else:\n                match = self.exactmatch(credit, debts[1:])\n            return match\n\n    def has_bills(self):\n        \"\"\"return if the project do have bills or not\"\"\"\n        return self.get_bills().count() > 0\n\n    def get_bills(self):\n        \"\"\"Return the list of bills related to this project\"\"\"\n        return (\n            Bill.query.join(Person, Project)\n            .filter(Bill.payer_id == Person.id)\n            .filter(Person.project_id == Project.id)\n            .filter(Project.id == self.id)\n            .order_by(Bill.date.desc())\n            .order_by(Bill.creation_date.desc())\n            .order_by(Bill.id.desc())\n        )\n\n    def get_member_bills(self, member_id):\n        \"\"\"Return the list of bills related to a specific member\"\"\"\n        return (\n            Bill.query.join(Person, Project)\n            .filter(Bill.payer_id == Person.id)\n            .filter(Person.project_id == Project.id)\n            .filter(Person.id == member_id)\n            .filter(Project.id == self.id)\n            .order_by(Bill.date.desc())\n            .order_by(Bill.id.desc())\n        )\n\n    def get_pretty_bills(self, export_format=\"json\"):\n        \"\"\"Return a list of project's bills with pretty formatting\"\"\"\n        bills = self.get_bills()\n        pretty_bills = []\n        for bill in bills:\n            if export_format == \"json\":\n                owers = [ower.name for ower in bill.owers]\n            else:\n                owers = \", \".join([ower.name for ower in bill.owers])\n\n            pretty_bills.append(\n                {\n                    \"what\": bill.what,\n                    \"amount\": round(bill.amount, 2),\n                    \"date\": str(bill.date),\n                    \"payer_name\": Person.query.get(bill.payer_id).name,\n                    \"payer_weight\": Person.query.get(bill.payer_id).weight,\n                    \"owers\": owers,\n                }\n            )\n        return pretty_bills\n\n    def remove_member(self, member_id):\n        \"\"\"Remove a member from the project.\n\n        If the member is not bound to a bill, then he is deleted, otherwise\n        he is only deactivated.\n\n        This method returns the status DELETED or DEACTIVATED regarding the\n        changes made.\n        \"\"\"\n        try:\n            person = Person.query.get(member_id, self)\n        except orm.exc.NoResultFound:\n            return None\n        if not person.has_bills():\n            db.session.delete(person)\n            db.session.commit()\n        else:\n            person.activated = False\n            db.session.commit()\n        return person\n\n    def remove_project(self):\n        db.session.delete(self)\n        db.session.commit()\n\n    def generate_token(self, expiration=0):\n        \"\"\"Generate a timed and serialized JsonWebToken\n\n        :param expiration: Token expiration time (in seconds)\n        \"\"\"\n        if expiration:\n            serializer = TimedJSONWebSignatureSerializer(\n                current_app.config[\"SECRET_KEY\"], expiration\n            )\n            token = serializer.dumps({\"project_id\": self.id}).decode(\"utf-8\")\n        else:\n            serializer = URLSafeSerializer(current_app.config[\"SECRET_KEY\"])\n            token = serializer.dumps({\"project_id\": self.id})\n        return token\n\n    @staticmethod\n    def verify_token(token, token_type=\"timed_token\"):\n        \"\"\"Return the project id associated to the provided token,\n        None if the provided token is expired or not valid.\n\n        :param token: Serialized TimedJsonWebToken\n        \"\"\"\n        if token_type == \"timed_token\":\n            serializer = TimedJSONWebSignatureSerializer(\n                current_app.config[\"SECRET_KEY\"]\n            )\n        else:\n            serializer = URLSafeSerializer(current_app.config[\"SECRET_KEY\"])\n        try:\n            data = serializer.loads(token)\n        except SignatureExpired:\n            return None\n        except BadSignature:\n            return None\n        return data[\"project_id\"]\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return f\"<Project {self.name}>\"\n\n    @staticmethod\n    def create_demo_project():\n        project = Project(\n            id=\"demo\",\n            name=\"demonstration\",\n            password=generate_password_hash(\"demo\"),\n            contact_email=\"demo@notmyidea.org\",\n            default_currency=\"EUR\",\n        )\n        db.session.add(project)\n        db.session.commit()\n\n        members = {}\n        for name in (\"Amina\", \"Georg\", \"Alice\"):\n            person = Person()\n            person.name = name\n            person.project = project\n            person.weight = 1\n            db.session.add(person)\n\n            members[name] = person\n\n        db.session.commit()\n\n        operations = (\n            (\"Georg\", 200, (\"Amina\", \"Georg\", \"Alice\"), \"Food shopping\"),\n            (\"Alice\", 20, (\"Amina\", \"Alice\"), \"Beer !\"),\n            (\"Amina\", 50, (\"Amina\", \"Alice\", \"Georg\"), \"AMAP\"),\n        )\n        for (payer, amount, owers, subject) in operations:\n            bill = Bill()\n            bill.payer_id = members[payer].id\n            bill.what = subject\n            bill.owers = [members[name] for name in owers]\n            bill.amount = amount\n            bill.original_currency = \"EUR\"\n            bill.converted_amount = amount\n\n            db.session.add(bill)\n\n        db.session.commit()\n        return project\n\n\nclass Person(db.Model):\n    class PersonQuery(BaseQuery):\n        def get_by_name(self, name, project):\n            return (\n                Person.query.filter(Person.name == name)\n                .filter(Project.id == project.id)\n                .one()\n            )\n\n        def get(self, id, project=None):\n            if not project:\n                project = g.project\n            return (\n                Person.query.filter(Person.id == id)\n                .filter(Project.id == project.id)\n                .one()\n            )\n\n    query_class = PersonQuery\n\n    # Direct SQLAlchemy-Continuum to track changes to this model\n    __versioned__ = {}\n\n    __table_args__ = {\"sqlite_autoincrement\": True}\n\n    id = db.Column(db.Integer, primary_key=True)\n    project_id = db.Column(db.String(64), db.ForeignKey(\"project.id\"))\n    bills = db.relationship(\"Bill\", backref=\"payer\")\n\n    name = db.Column(db.UnicodeText)\n    weight = db.Column(db.Float, default=1)\n    activated = db.Column(db.Boolean, default=True)\n\n    @property\n    def _to_serialize(self):\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"weight\": self.weight,\n            \"activated\": self.activated,\n        }\n\n    def has_bills(self):\n        \"\"\"return if the user do have bills or not\"\"\"\n        bills_as_ower_number = (\n            db.session.query(billowers)\n            .filter(billowers.columns.get(\"person_id\") == self.id)\n            .count()\n        )\n        return bills_as_ower_number != 0 or len(self.bills) != 0\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return f\"<Person {self.name} for project {self.project.name}>\"\n\n\n# We need to manually define a join table for m2m relations\nbillowers = db.Table(\n    \"billowers\",\n    db.Column(\"bill_id\", db.Integer, db.ForeignKey(\"bill.id\"), primary_key=True),\n    db.Column(\"person_id\", db.Integer, db.ForeignKey(\"person.id\"), primary_key=True),\n    sqlite_autoincrement=True,\n)\n\n\nclass Bill(db.Model):\n    class BillQuery(BaseQuery):\n        def get(self, project, id):\n            try:\n                return (\n                    self.join(Person, Project)\n                    .filter(Bill.payer_id == Person.id)\n                    .filter(Person.project_id == Project.id)\n                    .filter(Project.id == project.id)\n                    .filter(Bill.id == id)\n                    .one()\n                )\n            except orm.exc.NoResultFound:\n                return None\n\n        def delete(self, project, id):\n            bill = self.get(project, id)\n            if bill:\n                db.session.delete(bill)\n            return bill\n\n    query_class = BillQuery\n\n    # Direct SQLAlchemy-Continuum to track changes to this model\n    __versioned__ = {}\n\n    __table_args__ = {\"sqlite_autoincrement\": True}\n\n    id = db.Column(db.Integer, primary_key=True)\n\n    payer_id = db.Column(db.Integer, db.ForeignKey(\"person.id\"))\n    owers = db.relationship(Person, secondary=billowers)\n\n    amount = db.Column(db.Float)\n    date = db.Column(db.Date, default=datetime.now)\n    creation_date = db.Column(db.Date, default=datetime.now)\n    what = db.Column(db.UnicodeText)\n    external_link = db.Column(db.UnicodeText)\n\n    original_currency = db.Column(db.String(3))\n    converted_amount = db.Column(db.Float)\n\n    archive = db.Column(db.Integer, db.ForeignKey(\"archive.id\"))\n\n    @property\n    def _to_serialize(self):\n        return {\n            \"id\": self.id,\n            \"payer_id\": self.payer_id,\n            \"owers\": self.owers,\n            \"amount\": self.amount,\n            \"date\": self.date,\n            \"creation_date\": self.creation_date,\n            \"what\": self.what,\n            \"external_link\": self.external_link,\n            \"original_currency\": self.original_currency,\n            \"converted_amount\": self.converted_amount,\n        }\n\n    def pay_each_default(self, amount):\n        \"\"\"Compute what each share has to pay\"\"\"\n        if self.owers:\n            weights = (\n                db.session.query(func.sum(Person.weight))\n                .join(billowers, Bill)\n                .filter(Bill.id == self.id)\n            ).scalar()\n            return amount / weights\n        else:\n            return 0\n\n    def __str__(self):\n        return self.what\n\n    def pay_each(self):\n        return self.pay_each_default(self.converted_amount)\n\n    def __repr__(self):\n        return (\n            f\"<Bill of {self.amount} from {self.payer} for \"\n            f\"{', '.join([o.name for o in self.owers])}>\"\n        )\n\n\nclass Archive(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    project_id = db.Column(db.String(64), db.ForeignKey(\"project.id\"))\n    name = db.Column(db.UnicodeText)\n\n    @property\n    def start_date(self):\n        pass\n\n    @property\n    def end_date(self):\n        pass\n\n    def __repr__(self):\n        return \"<Archive>\"\n\n\nsqlalchemy.orm.configure_mappers()\n\nPersonVersion = version_class(Person)\nProjectVersion = version_class(Project)\nBillVersion = version_class(Bill)\n"], "fixing_code": ["from collections import defaultdict\nfrom datetime import datetime\n\nfrom debts import settle\nfrom flask import current_app, g\nfrom flask_sqlalchemy import BaseQuery, SQLAlchemy\nfrom itsdangerous import (\n    BadSignature,\n    SignatureExpired,\n    TimedJSONWebSignatureSerializer,\n    URLSafeSerializer,\n)\nimport sqlalchemy\nfrom sqlalchemy import orm\nfrom sqlalchemy.sql import func\nfrom sqlalchemy_continuum import make_versioned, version_class\nfrom sqlalchemy_continuum.plugins import FlaskPlugin\nfrom werkzeug.security import generate_password_hash\n\nfrom ihatemoney.patch_sqlalchemy_continuum import PatchedBuilder\nfrom ihatemoney.versioning import (\n    ConditionalVersioningManager,\n    LoggingMode,\n    get_ip_if_allowed,\n    version_privacy_predicate,\n)\n\nmake_versioned(\n    user_cls=None,\n    manager=ConditionalVersioningManager(\n        # Conditionally Disable the versioning based on each\n        # project's privacy preferences\n        tracking_predicate=version_privacy_predicate,\n        # Patch in a fix to a SQLAchemy-Continuum Bug.\n        # See patch_sqlalchemy_continuum.py\n        builder=PatchedBuilder(),\n    ),\n    plugins=[\n        FlaskPlugin(\n            # Redirect to our own function, which respects user preferences\n            # on IP address collection\n            remote_addr_factory=get_ip_if_allowed,\n            # Suppress the plugin's attempt to grab a user id,\n            # which imports the flask_login module (causing an error)\n            current_user_id_factory=lambda: None,\n        )\n    ],\n)\n\ndb = SQLAlchemy()\n\n\nclass Project(db.Model):\n    class ProjectQuery(BaseQuery):\n        def get_by_name(self, name):\n            return Project.query.filter(Project.name == name).one()\n\n    # Direct SQLAlchemy-Continuum to track changes to this model\n    __versioned__ = {}\n\n    id = db.Column(db.String(64), primary_key=True)\n\n    name = db.Column(db.UnicodeText)\n    password = db.Column(db.String(128))\n    contact_email = db.Column(db.String(128))\n    logging_preference = db.Column(\n        db.Enum(LoggingMode),\n        default=LoggingMode.default(),\n        nullable=False,\n        server_default=LoggingMode.default().name,\n    )\n    members = db.relationship(\"Person\", backref=\"project\")\n\n    query_class = ProjectQuery\n    default_currency = db.Column(db.String(3))\n\n    @property\n    def _to_serialize(self):\n        obj = {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"contact_email\": self.contact_email,\n            \"logging_preference\": self.logging_preference.value,\n            \"members\": [],\n            \"default_currency\": self.default_currency,\n        }\n\n        balance = self.balance\n        for member in self.members:\n            member_obj = member._to_serialize\n            member_obj[\"balance\"] = balance.get(member.id, 0)\n            obj[\"members\"].append(member_obj)\n\n        return obj\n\n    @property\n    def active_members(self):\n        return [m for m in self.members if m.activated]\n\n    @property\n    def balance(self):\n\n        balances, should_pay, should_receive = (defaultdict(int) for time in (1, 2, 3))\n\n        # for each person\n        for person in self.members:\n            # get the list of bills he has to pay\n            bills = Bill.query.options(orm.subqueryload(Bill.owers)).filter(\n                Bill.owers.contains(person)\n            )\n            for bill in bills.all():\n                if person != bill.payer:\n                    share = bill.pay_each() * person.weight\n                    should_pay[person] += share\n                    should_receive[bill.payer] += share\n\n        for person in self.members:\n            balance = should_receive[person] - should_pay[person]\n            balances[person.id] = balance\n\n        return balances\n\n    @property\n    def members_stats(self):\n        \"\"\"Compute what each member has paid\n\n        :return: one stat dict per member\n        :rtype list:\n        \"\"\"\n        return [\n            {\n                \"member\": member,\n                \"paid\": sum(\n                    [\n                        bill.converted_amount\n                        for bill in self.get_member_bills(member.id).all()\n                    ]\n                ),\n                \"spent\": sum(\n                    [\n                        bill.pay_each() * member.weight\n                        for bill in self.get_bills().all()\n                        if member in bill.owers\n                    ]\n                ),\n                \"balance\": self.balance[member.id],\n            }\n            for member in self.active_members\n        ]\n\n    @property\n    def monthly_stats(self):\n        \"\"\"Compute expenses by month\n\n        :return: a dict of years mapping to a dict of months mapping to the amount\n        :rtype dict:\n        \"\"\"\n        monthly = defaultdict(lambda: defaultdict(float))\n        for bill in self.get_bills().all():\n            monthly[bill.date.year][bill.date.month] += bill.converted_amount\n        return monthly\n\n    @property\n    def uses_weights(self):\n        return len([i for i in self.members if i.weight != 1]) > 0\n\n    def get_transactions_to_settle_bill(self, pretty_output=False):\n        \"\"\"Return a list of transactions that could be made to settle the bill\"\"\"\n\n        def prettify(transactions, pretty_output):\n            \"\"\" Return pretty transactions\n            \"\"\"\n            if not pretty_output:\n                return transactions\n            pretty_transactions = []\n            for transaction in transactions:\n                pretty_transactions.append(\n                    {\n                        \"ower\": transaction[\"ower\"].name,\n                        \"receiver\": transaction[\"receiver\"].name,\n                        \"amount\": round(transaction[\"amount\"], 2),\n                    }\n                )\n            return pretty_transactions\n\n        # cache value for better performance\n        members = {person.id: person for person in self.members}\n        settle_plan = settle(self.balance.items()) or []\n\n        transactions = [\n            {\n                \"ower\": members[ower_id],\n                \"receiver\": members[receiver_id],\n                \"amount\": amount,\n            }\n            for ower_id, amount, receiver_id in settle_plan\n        ]\n\n        return prettify(transactions, pretty_output)\n\n    def exactmatch(self, credit, debts):\n        \"\"\"Recursively try and find subsets of 'debts' whose sum is equal to credit\"\"\"\n        if not debts:\n            return None\n        if debts[0][\"balance\"] > credit:\n            return self.exactmatch(credit, debts[1:])\n        elif debts[0][\"balance\"] == credit:\n            return [debts[0]]\n        else:\n            match = self.exactmatch(credit - debts[0][\"balance\"], debts[1:])\n            if match:\n                match.append(debts[0])\n            else:\n                match = self.exactmatch(credit, debts[1:])\n            return match\n\n    def has_bills(self):\n        \"\"\"return if the project do have bills or not\"\"\"\n        return self.get_bills().count() > 0\n\n    def get_bills(self):\n        \"\"\"Return the list of bills related to this project\"\"\"\n        return (\n            Bill.query.join(Person, Project)\n            .filter(Bill.payer_id == Person.id)\n            .filter(Person.project_id == Project.id)\n            .filter(Project.id == self.id)\n            .order_by(Bill.date.desc())\n            .order_by(Bill.creation_date.desc())\n            .order_by(Bill.id.desc())\n        )\n\n    def get_member_bills(self, member_id):\n        \"\"\"Return the list of bills related to a specific member\"\"\"\n        return (\n            Bill.query.join(Person, Project)\n            .filter(Bill.payer_id == Person.id)\n            .filter(Person.project_id == Project.id)\n            .filter(Person.id == member_id)\n            .filter(Project.id == self.id)\n            .order_by(Bill.date.desc())\n            .order_by(Bill.id.desc())\n        )\n\n    def get_pretty_bills(self, export_format=\"json\"):\n        \"\"\"Return a list of project's bills with pretty formatting\"\"\"\n        bills = self.get_bills()\n        pretty_bills = []\n        for bill in bills:\n            if export_format == \"json\":\n                owers = [ower.name for ower in bill.owers]\n            else:\n                owers = \", \".join([ower.name for ower in bill.owers])\n\n            pretty_bills.append(\n                {\n                    \"what\": bill.what,\n                    \"amount\": round(bill.amount, 2),\n                    \"date\": str(bill.date),\n                    \"payer_name\": Person.query.get(bill.payer_id).name,\n                    \"payer_weight\": Person.query.get(bill.payer_id).weight,\n                    \"owers\": owers,\n                }\n            )\n        return pretty_bills\n\n    def remove_member(self, member_id):\n        \"\"\"Remove a member from the project.\n\n        If the member is not bound to a bill, then he is deleted, otherwise\n        he is only deactivated.\n\n        This method returns the status DELETED or DEACTIVATED regarding the\n        changes made.\n        \"\"\"\n        try:\n            person = Person.query.get(member_id, self)\n        except orm.exc.NoResultFound:\n            return None\n        if not person.has_bills():\n            db.session.delete(person)\n            db.session.commit()\n        else:\n            person.activated = False\n            db.session.commit()\n        return person\n\n    def remove_project(self):\n        db.session.delete(self)\n        db.session.commit()\n\n    def generate_token(self, expiration=0):\n        \"\"\"Generate a timed and serialized JsonWebToken\n\n        :param expiration: Token expiration time (in seconds)\n        \"\"\"\n        if expiration:\n            serializer = TimedJSONWebSignatureSerializer(\n                current_app.config[\"SECRET_KEY\"], expiration\n            )\n            token = serializer.dumps({\"project_id\": self.id}).decode(\"utf-8\")\n        else:\n            serializer = URLSafeSerializer(current_app.config[\"SECRET_KEY\"])\n            token = serializer.dumps({\"project_id\": self.id})\n        return token\n\n    @staticmethod\n    def verify_token(token, token_type=\"timed_token\"):\n        \"\"\"Return the project id associated to the provided token,\n        None if the provided token is expired or not valid.\n\n        :param token: Serialized TimedJsonWebToken\n        \"\"\"\n        if token_type == \"timed_token\":\n            serializer = TimedJSONWebSignatureSerializer(\n                current_app.config[\"SECRET_KEY\"]\n            )\n        else:\n            serializer = URLSafeSerializer(current_app.config[\"SECRET_KEY\"])\n        try:\n            data = serializer.loads(token)\n        except SignatureExpired:\n            return None\n        except BadSignature:\n            return None\n        return data[\"project_id\"]\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return f\"<Project {self.name}>\"\n\n    @staticmethod\n    def create_demo_project():\n        project = Project(\n            id=\"demo\",\n            name=\"demonstration\",\n            password=generate_password_hash(\"demo\"),\n            contact_email=\"demo@notmyidea.org\",\n            default_currency=\"EUR\",\n        )\n        db.session.add(project)\n        db.session.commit()\n\n        members = {}\n        for name in (\"Amina\", \"Georg\", \"Alice\"):\n            person = Person()\n            person.name = name\n            person.project = project\n            person.weight = 1\n            db.session.add(person)\n\n            members[name] = person\n\n        db.session.commit()\n\n        operations = (\n            (\"Georg\", 200, (\"Amina\", \"Georg\", \"Alice\"), \"Food shopping\"),\n            (\"Alice\", 20, (\"Amina\", \"Alice\"), \"Beer !\"),\n            (\"Amina\", 50, (\"Amina\", \"Alice\", \"Georg\"), \"AMAP\"),\n        )\n        for (payer, amount, owers, subject) in operations:\n            bill = Bill()\n            bill.payer_id = members[payer].id\n            bill.what = subject\n            bill.owers = [members[name] for name in owers]\n            bill.amount = amount\n            bill.original_currency = \"EUR\"\n            bill.converted_amount = amount\n\n            db.session.add(bill)\n\n        db.session.commit()\n        return project\n\n\nclass Person(db.Model):\n    class PersonQuery(BaseQuery):\n        def get_by_name(self, name, project):\n            return (\n                Person.query.filter(Person.name == name)\n                .filter(Person.project_id == project.id)\n                .one()\n            )\n\n        def get(self, id, project=None):\n            if not project:\n                project = g.project\n            return (\n                Person.query.filter(Person.id == id)\n                .filter(Person.project_id == project.id)\n                .one()\n            )\n\n    query_class = PersonQuery\n\n    # Direct SQLAlchemy-Continuum to track changes to this model\n    __versioned__ = {}\n\n    __table_args__ = {\"sqlite_autoincrement\": True}\n\n    id = db.Column(db.Integer, primary_key=True)\n    project_id = db.Column(db.String(64), db.ForeignKey(\"project.id\"))\n    bills = db.relationship(\"Bill\", backref=\"payer\")\n\n    name = db.Column(db.UnicodeText)\n    weight = db.Column(db.Float, default=1)\n    activated = db.Column(db.Boolean, default=True)\n\n    @property\n    def _to_serialize(self):\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"weight\": self.weight,\n            \"activated\": self.activated,\n        }\n\n    def has_bills(self):\n        \"\"\"return if the user do have bills or not\"\"\"\n        bills_as_ower_number = (\n            db.session.query(billowers)\n            .filter(billowers.columns.get(\"person_id\") == self.id)\n            .count()\n        )\n        return bills_as_ower_number != 0 or len(self.bills) != 0\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return f\"<Person {self.name} for project {self.project.name}>\"\n\n\n# We need to manually define a join table for m2m relations\nbillowers = db.Table(\n    \"billowers\",\n    db.Column(\"bill_id\", db.Integer, db.ForeignKey(\"bill.id\"), primary_key=True),\n    db.Column(\"person_id\", db.Integer, db.ForeignKey(\"person.id\"), primary_key=True),\n    sqlite_autoincrement=True,\n)\n\n\nclass Bill(db.Model):\n    class BillQuery(BaseQuery):\n        def get(self, project, id):\n            try:\n                return (\n                    self.join(Person, Project)\n                    .filter(Bill.payer_id == Person.id)\n                    .filter(Person.project_id == Project.id)\n                    .filter(Project.id == project.id)\n                    .filter(Bill.id == id)\n                    .one()\n                )\n            except orm.exc.NoResultFound:\n                return None\n\n        def delete(self, project, id):\n            bill = self.get(project, id)\n            if bill:\n                db.session.delete(bill)\n            return bill\n\n    query_class = BillQuery\n\n    # Direct SQLAlchemy-Continuum to track changes to this model\n    __versioned__ = {}\n\n    __table_args__ = {\"sqlite_autoincrement\": True}\n\n    id = db.Column(db.Integer, primary_key=True)\n\n    payer_id = db.Column(db.Integer, db.ForeignKey(\"person.id\"))\n    owers = db.relationship(Person, secondary=billowers)\n\n    amount = db.Column(db.Float)\n    date = db.Column(db.Date, default=datetime.now)\n    creation_date = db.Column(db.Date, default=datetime.now)\n    what = db.Column(db.UnicodeText)\n    external_link = db.Column(db.UnicodeText)\n\n    original_currency = db.Column(db.String(3))\n    converted_amount = db.Column(db.Float)\n\n    archive = db.Column(db.Integer, db.ForeignKey(\"archive.id\"))\n\n    @property\n    def _to_serialize(self):\n        return {\n            \"id\": self.id,\n            \"payer_id\": self.payer_id,\n            \"owers\": self.owers,\n            \"amount\": self.amount,\n            \"date\": self.date,\n            \"creation_date\": self.creation_date,\n            \"what\": self.what,\n            \"external_link\": self.external_link,\n            \"original_currency\": self.original_currency,\n            \"converted_amount\": self.converted_amount,\n        }\n\n    def pay_each_default(self, amount):\n        \"\"\"Compute what each share has to pay\"\"\"\n        if self.owers:\n            weights = (\n                db.session.query(func.sum(Person.weight))\n                .join(billowers, Bill)\n                .filter(Bill.id == self.id)\n            ).scalar()\n            return amount / weights\n        else:\n            return 0\n\n    def __str__(self):\n        return self.what\n\n    def pay_each(self):\n        return self.pay_each_default(self.converted_amount)\n\n    def __repr__(self):\n        return (\n            f\"<Bill of {self.amount} from {self.payer} for \"\n            f\"{', '.join([o.name for o in self.owers])}>\"\n        )\n\n\nclass Archive(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    project_id = db.Column(db.String(64), db.ForeignKey(\"project.id\"))\n    name = db.Column(db.UnicodeText)\n\n    @property\n    def start_date(self):\n        pass\n\n    @property\n    def end_date(self):\n        pass\n\n    def __repr__(self):\n        return \"<Archive>\"\n\n\nsqlalchemy.orm.configure_mappers()\n\nPersonVersion = version_class(Person)\nProjectVersion = version_class(Project)\nBillVersion = version_class(Bill)\n"], "buggy_code_start_loc": [383], "buggy_code_end_loc": [393], "fixing_code_start_loc": [383], "fixing_code_end_loc": [393], "type": "CWE-863", "message": "In \"I hate money\" before version 4.1.5, an authenticated member of one project can modify and delete members of another project, without knowledge of this other project's private code. This can be further exploited to access all bills of another project without knowledge of this other project's private code. With the default configuration, anybody is allowed to create a new project. An attacker can create a new project and then use it to become authenticated and exploit this flaw. As such, the exposure is similar to an unauthenticated attack, because it is trivial to become authenticated. This is fixed in version 4.1.5.", "other": {"cve": {"id": "CVE-2020-15120", "sourceIdentifier": "security-advisories@github.com", "published": "2020-07-27T18:15:13.983", "lastModified": "2020-07-29T18:09:36.850", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In \"I hate money\" before version 4.1.5, an authenticated member of one project can modify and delete members of another project, without knowledge of this other project's private code. This can be further exploited to access all bills of another project without knowledge of this other project's private code. With the default configuration, anybody is allowed to create a new project. An attacker can create a new project and then use it to become authenticated and exploit this flaw. As such, the exposure is similar to an unauthenticated attack, because it is trivial to become authenticated. This is fixed in version 4.1.5."}, {"lang": "es", "value": "En \"I hate money\" antes de la versi\u00f3n 4.1.5, un miembro autenticado de un proyecto puede modificar y eliminar miembros de otro proyecto, sin conocer el c\u00f3digo privado de este otro proyecto. Esto puede ser explotado a\u00fan m\u00e1s para acceder a todas las facturas de otro proyecto sin conocer el c\u00f3digo privado de este otro proyecto. Con la configuraci\u00f3n predeterminada, es permitido a cualquiera crear un nuevo proyecto. Un atacante puede crear un nuevo proyecto y luego usarlo para autenticarse y explotar este fallo. Como tal, la exposici\u00f3n es similar a un ataque no autenticado, porque es muy sencillo autenticarse. Esto est\u00e1 corregido en la versi\u00f3n 4.1.5"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ihatemoney:i_hate_money:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.5", "matchCriteriaId": "454CE36C-D558-461D-99E5-6A533CD5C59A"}]}]}], "references": [{"url": "https://github.com/spiral-project/ihatemoney/commit/8d77cf5d5646e1d2d8ded13f0660638f57e98471", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/spiral-project/ihatemoney/security/advisories/GHSA-67j9-c52g-w2q9", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/spiral-project/ihatemoney/commit/8d77cf5d5646e1d2d8ded13f0660638f57e98471"}}