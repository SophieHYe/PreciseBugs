{"buggy_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/sparse_ops.cc.\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n\n// TODO(b/31496047): Fix non-standard include order.\n#include <numeric>  // clang-format off\n\nusing tensorflow::sparse::SparseTensor;\nusing tensorflow::gtl::ArraySlice;\n\nnamespace tensorflow {\n\nstruct ReduceDetails {\n  // The dimensions to call Reorder() with.\n  std::vector<int64> reorder_dims;\n\n  // The dimensions to call group() with after Reorder().\n  std::vector<int64> group_by_dims;\n\n  // The shape after reduction.\n  TensorShape reduced_shape;\n};\n\n// Compute common reduce parameters that'll be used for SparseTensor\n// reductions. Usage:\n// ReduceDetails reduction = SparseTensorReduceHelper(sp, axes, keep_dims);\n// sp.Reorder(reduction.reorder_dims);\n// for (const auto& g : sp.group(reduction.group_by_dims)) {\n//   ...\n// }\n// // Set output shape to reduction.reduced_shape.\nReduceDetails SparseTensorReduceHelper(const SparseTensor &sp,\n                                       gtl::ArraySlice<int32> axes_slice,\n                                       bool keep_dims) {\n  ReduceDetails reduction;\n\n  std::vector<int32> reduction_axes(axes_slice.begin(), axes_slice.end());\n  int ndims = sp.dims();\n  for (int64_t i = 0; i < reduction_axes.size(); ++i) {\n    reduction_axes[i] = (reduction_axes[i] + ndims) % ndims;\n  }\n  std::sort(reduction_axes.begin(), reduction_axes.end());\n\n  // (0) Calculate the grouping dimensions:\n  // group_by_dims == {0, .., NDIMS-1} \\ reduction_axes.\n  std::vector<int64> perm(ndims);\n  std::iota(perm.begin(), perm.end(), 0);\n\n  // Requires perm and reduction_axes_ be sorted; group_by_dims will be\n  // sorted as well.\n  std::set_difference(\n      perm.begin(), perm.end(), reduction_axes.begin(), reduction_axes.end(),\n      std::inserter(reduction.group_by_dims, reduction.group_by_dims.begin()));\n\n  // Now append the rest of the axes (the complement of group_by_dims_);\n  // result is used by Reorder().\n  reduction.reorder_dims = reduction.group_by_dims;\n  std::set_difference(perm.begin(), perm.end(), reduction.group_by_dims.begin(),\n                      reduction.group_by_dims.end(),\n                      std::back_inserter(reduction.reorder_dims));\n\n  // (1) Calculate the shape after reduction.\n  auto sp_shape = sp.shape();\n  std::vector<int64> out_dim_sizes;\n  if (keep_dims) {\n    out_dim_sizes.reserve(ndims);\n    auto beg = reduction.group_by_dims.begin();\n    auto end = reduction.group_by_dims.end();\n    for (int d = 0; d < ndims; ++d) {\n      if (std::find(beg, end, d) == end) {\n        out_dim_sizes.push_back(1);  // A reduced axis.\n      } else {\n        out_dim_sizes.push_back(sp_shape[d]);\n      }\n    }\n  } else {\n    out_dim_sizes = sp.PickDims(reduction.group_by_dims);\n  }\n\n  reduction.reduced_shape = TensorShape(out_dim_sizes);\n  return reduction;\n}\n\nStatus ValidateInputs(const Tensor *shape_t, const Tensor *reduction_axes_t) {\n  // indices and values are validated in SparseTensor ctor.\n  if (!TensorShapeUtils::IsVector(shape_t->shape())) {\n    return errors::InvalidArgument(\n        \"Expected input_shape to be a vector; got shape: \",\n        shape_t->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsScalar(reduction_axes_t->shape()) &&\n      !TensorShapeUtils::IsVector(reduction_axes_t->shape())) {\n    return errors::InvalidArgument(\n        \"Expected reduction_axes to be a scalar or a vector; got shape: \",\n        reduction_axes_t->shape().DebugString());\n  }\n\n  const auto reduction_axes_flat = reduction_axes_t->flat<int32>();\n  for (int64_t i = 0; i < reduction_axes_flat.size(); i++) {\n    int32_t axis = reduction_axes_flat(i);\n    if (axis < -shape_t->NumElements() || axis >= shape_t->NumElements()) {\n      return errors::InvalidArgument(\"Invalid reduction dimension \", axis,\n                                     \", for input with \",\n                                     shape_t->NumElements(), \" dimensions.\");\n    }\n  }\n\n  return Status::OK();\n}\n\nstruct SumOp {\n  template <typename T>\n  static void Run(OpKernelContext *ctx, typename TTypes<T>::Scalar &s, const typename TTypes<T>::UnalignedVec &v) {\n      s.device(ctx->eigen_cpu_device()) = v.sum();\n  }\n  static StringPiece Name() {\n      return \"sum\";\n  }\n};\n\nstruct MaxOp {\n  template <typename T>\n  static void Run(OpKernelContext *ctx, typename TTypes<T>::Scalar &s, const typename TTypes<T>::UnalignedVec &v) {\n      s.device(ctx->eigen_cpu_device()) = v.maximum();\n  }\n  static StringPiece Name() {\n      return \"max\";\n  }\n};\n\ntemplate <typename T, typename Op>\nclass SparseReduceOp : public OpKernel {\n public:\n  explicit SparseReduceOp(OpKernelConstruction *ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"keep_dims\", &keep_dims_));\n  }\n\n  void Compute(OpKernelContext *ctx) override {\n    const Tensor *indices_t, *values_t, *shape_t, *reduction_axes_t;\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_indices\", &indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_values\", &values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_shape\", &shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"reduction_axes\", &reduction_axes_t));\n\n    OP_REQUIRES_OK(ctx, ValidateInputs(shape_t, reduction_axes_t));\n\n    // TODO(zongheng): we will call Reorder() below, which will modify\n    // in-place the underlying indices and values buffers.  To avoid\n    // surprises of this kernel being stateful, we work around the above by\n    // making deep copies here.  Remove this if/when we change Reorder()'s\n    // semantics.\n    const auto shape_vec = shape_t->vec<int64>();\n    SparseTensor sp;\n    OP_REQUIRES_OK(ctx, SparseTensor::Create(\n        tensor::DeepCopy(*indices_t), tensor::DeepCopy(*values_t),\n                    TensorShape(shape_vec), &sp));\n    ReduceDetails reduction = SparseTensorReduceHelper(\n        sp, reduction_axes_t->flat<int32>(), keep_dims_);\n\n    Tensor *out_values;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, reduction.reduced_shape, &out_values));\n    auto out_flat = out_values->flat<T>();\n    out_flat.setZero();\n\n    Tensor tmp_reduced_val;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                           TensorShape({}), &tmp_reduced_val));\n    auto reduced_val = tmp_reduced_val.scalar<T>();\n\n    // Compute strides, and use it to convert coords to flat index.  The\n    // coordinates returned by .group() have the same ndims as group_by_dims.\n    gtl::InlinedVector<int64, 8> output_strides(reduction.group_by_dims.size());\n    if (!output_strides.empty()) {  // Do this iff we don't reduce all.\n      output_strides.back() = 1;\n      for (int d = output_strides.size() - 2; d >= 0; --d) {\n        output_strides[d] =\n            output_strides[d + 1] * shape_vec(reduction.group_by_dims[d + 1]);\n      }\n    }\n\n    auto CoordinatesToFlatIndex = [](ArraySlice<int64> coords,\n                                     ArraySlice<int64> strides) -> int64 {\n      if (strides.empty()) {  // Reduce all.\n        return 0;\n      }\n      CHECK_EQ(coords.size(), strides.size());\n      int64_t idx = 0;\n      for (int i = 0; i < coords.size(); ++i) {\n        idx += coords[i] * strides[i];\n      }\n      return idx;\n    };\n\n    // Each group maps one-on-one onto a value in the reduced tensor.\n    // g.group() provides the coordinates of a particular reduced value.\n    sp.Reorder<T>(reduction.reorder_dims);\n    for (const auto &g : sp.group(reduction.group_by_dims)) {\n      Op::template Run<T>(ctx, reduced_val, g.template values<T>());\n      const int64_t idx = CoordinatesToFlatIndex(g.group(), output_strides);\n      out_flat(idx) = reduced_val();\n      VLOG(2) << \"coords: \" << absl::StrJoin(g.group(), \",\")\n              << \"; idx: \" << idx << \"; group \" << Op::Name() << \": \"\n              << reduced_val();\n    }\n  }\n\n private:\n  // True if the number of dimensions should be maintained.\n  bool keep_dims_;\n};\n\n#define REGISTER_KERNELS(T)                                              \\\n  REGISTER_KERNEL_BUILDER(                                               \\\n      Name(\"SparseReduceSum\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SparseReduceOp<T, SumOp>)\nTF_CALL_NUMBER_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n\n#define REGISTER_KERNELS(T)                                              \\\n  REGISTER_KERNEL_BUILDER(                                               \\\n      Name(\"SparseReduceMax\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SparseReduceOp<T, MaxOp>)\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n\ntemplate <typename T, typename Op>\nclass SparseReduceSparseOp : public OpKernel {\n public:\n  explicit SparseReduceSparseOp(OpKernelConstruction *ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"keep_dims\", &keep_dims_));\n  }\n\n  void Compute(OpKernelContext *ctx) override {\n    const Tensor *indices_t, *values_t, *shape_t, *reduction_axes_t;\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_indices\", &indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_values\", &values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_shape\", &shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"reduction_axes\", &reduction_axes_t));\n\n    OP_REQUIRES_OK(ctx, ValidateInputs(shape_t, reduction_axes_t));\n\n    SparseTensor sp;\n    OP_REQUIRES_OK(ctx, SparseTensor::Create(tensor::DeepCopy(*indices_t),\n                                         tensor::DeepCopy(*values_t),\n                    TensorShape(shape_t->vec<int64>()), &sp));\n    ReduceDetails reduction = SparseTensorReduceHelper(\n        sp, reduction_axes_t->flat<int32>(), keep_dims_);\n\n    sp.Reorder<T>(reduction.reorder_dims);\n    // Count nnzs in the output SparseTensor.\n    int64_t nnz = 0;\n    auto iter = sp.group(reduction.group_by_dims);\n    for (auto it = iter.begin(); it != iter.end(); ++it) {\n      nnz++;\n    }\n\n    Tensor *out_indices_t;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(\n                       0, TensorShape({nnz, reduction.reduced_shape.dims()}),\n                       &out_indices_t));\n    typename TTypes<int64>::Matrix out_indices_mat =\n        out_indices_t->matrix<int64>();\n    // For keep_dims. We don't explicitly set dim fields for reduced dims below.\n    out_indices_mat.setZero();\n\n    Tensor *out_values_t;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(1, TensorShape({nnz}), &out_values_t));\n    auto out_flat = out_values_t->flat<T>();\n\n    Tensor tmp_reduced_val;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                           TensorShape({}), &tmp_reduced_val));\n    auto reduced_val = tmp_reduced_val.scalar<T>();\n    int64_t i = 0;\n    for (const auto &g : sp.group(reduction.group_by_dims)) {\n      Op::template Run<T>(ctx, reduced_val, g.template values<T>());\n      std::vector<int64> group = g.group();\n      for (int64_t j = 0; j < group.size(); j++) {\n        if (keep_dims_) {\n          out_indices_mat(i, reduction.group_by_dims[j]) = group[j];\n        } else {\n          out_indices_mat(i, j) = group[j];\n        }\n      }\n      out_flat(i) = reduced_val();\n      i++;\n      VLOG(2) << \"coords: \" << absl::StrJoin(g.group(), \",\")\n              << \"; group \" << Op::Name() << \": \"\n              << reduced_val();\n    }\n\n    Tensor *out_shape_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\n                            2, TensorShape({reduction.reduced_shape.dims()}),\n                            &out_shape_t));\n    auto out_shape_flat = out_shape_t->flat<int64>();\n    auto out_dim_sizes = reduction.reduced_shape.dim_sizes();\n    if (!out_dim_sizes.empty()) {\n      std::copy(out_dim_sizes.begin(), out_dim_sizes.end(), &out_shape_flat(0));\n    }\n  }\n\n private:\n  // True if the number of dimensions should be maintained.\n  bool keep_dims_;\n};\n\n#define REGISTER_KERNELS(T)                                                    \\\n  REGISTER_KERNEL_BUILDER(                                                     \\\n      Name(\"SparseReduceSumSparse\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SparseReduceSparseOp<T, SumOp>)\nTF_CALL_NUMBER_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n\n#define REGISTER_KERNELS(T)                                                    \\\n  REGISTER_KERNEL_BUILDER(                                                     \\\n      Name(\"SparseReduceMaxSparse\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SparseReduceSparseOp<T, MaxOp>)\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/sparse_ops.cc.\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n\n// TODO(b/31496047): Fix non-standard include order.\n#include <numeric>  // clang-format off\n\nusing tensorflow::sparse::SparseTensor;\nusing tensorflow::gtl::ArraySlice;\n\nnamespace tensorflow {\n\nstruct ReduceDetails {\n  // The dimensions to call Reorder() with.\n  std::vector<int64> reorder_dims;\n\n  // The dimensions to call group() with after Reorder().\n  std::vector<int64> group_by_dims;\n\n  // The shape after reduction.\n  TensorShape reduced_shape;\n};\n\n// Compute common reduce parameters that'll be used for SparseTensor\n// reductions. Usage:\n// ReduceDetails reduction = SparseTensorReduceHelper(sp, axes, keep_dims);\n// sp.Reorder(reduction.reorder_dims);\n// for (const auto& g : sp.group(reduction.group_by_dims)) {\n//   ...\n// }\n// // Set output shape to reduction.reduced_shape.\nReduceDetails SparseTensorReduceHelper(const SparseTensor &sp,\n                                       gtl::ArraySlice<int32> axes_slice,\n                                       bool keep_dims) {\n  ReduceDetails reduction;\n\n  std::vector<int32> reduction_axes(axes_slice.begin(), axes_slice.end());\n  int ndims = sp.dims();\n  for (int64_t i = 0; i < reduction_axes.size(); ++i) {\n    reduction_axes[i] = (reduction_axes[i] + ndims) % ndims;\n  }\n  std::sort(reduction_axes.begin(), reduction_axes.end());\n\n  // (0) Calculate the grouping dimensions:\n  // group_by_dims == {0, .., NDIMS-1} \\ reduction_axes.\n  std::vector<int64> perm(ndims);\n  std::iota(perm.begin(), perm.end(), 0);\n\n  // Requires perm and reduction_axes_ be sorted; group_by_dims will be\n  // sorted as well.\n  std::set_difference(\n      perm.begin(), perm.end(), reduction_axes.begin(), reduction_axes.end(),\n      std::inserter(reduction.group_by_dims, reduction.group_by_dims.begin()));\n\n  // Now append the rest of the axes (the complement of group_by_dims_);\n  // result is used by Reorder().\n  reduction.reorder_dims = reduction.group_by_dims;\n  std::set_difference(perm.begin(), perm.end(), reduction.group_by_dims.begin(),\n                      reduction.group_by_dims.end(),\n                      std::back_inserter(reduction.reorder_dims));\n\n  // (1) Calculate the shape after reduction.\n  auto sp_shape = sp.shape();\n  std::vector<int64> out_dim_sizes;\n  if (keep_dims) {\n    out_dim_sizes.reserve(ndims);\n    auto beg = reduction.group_by_dims.begin();\n    auto end = reduction.group_by_dims.end();\n    for (int d = 0; d < ndims; ++d) {\n      if (std::find(beg, end, d) == end) {\n        out_dim_sizes.push_back(1);  // A reduced axis.\n      } else {\n        out_dim_sizes.push_back(sp_shape[d]);\n      }\n    }\n  } else {\n    out_dim_sizes = sp.PickDims(reduction.group_by_dims);\n  }\n\n  reduction.reduced_shape = TensorShape(out_dim_sizes);\n  return reduction;\n}\n\nStatus ValidateInputs(const Tensor *shape_t, const Tensor *reduction_axes_t) {\n  // indices and values are validated in SparseTensor ctor.\n  if (!TensorShapeUtils::IsVector(shape_t->shape())) {\n    return errors::InvalidArgument(\n        \"Expected input_shape to be a vector; got shape: \",\n        shape_t->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsScalar(reduction_axes_t->shape()) &&\n      !TensorShapeUtils::IsVector(reduction_axes_t->shape())) {\n    return errors::InvalidArgument(\n        \"Expected reduction_axes to be a scalar or a vector; got shape: \",\n        reduction_axes_t->shape().DebugString());\n  }\n\n  const auto reduction_axes_flat = reduction_axes_t->flat<int32>();\n  for (int64_t i = 0; i < reduction_axes_flat.size(); i++) {\n    int32_t axis = reduction_axes_flat(i);\n    if (axis < -shape_t->NumElements() || axis >= shape_t->NumElements()) {\n      return errors::InvalidArgument(\"Invalid reduction dimension \", axis,\n                                     \", for input with \",\n                                     shape_t->NumElements(), \" dimensions.\");\n    }\n  }\n\n  return Status::OK();\n}\n\nstruct SumOp {\n  template <typename T>\n  static void Run(OpKernelContext *ctx, typename TTypes<T>::Scalar &s, const typename TTypes<T>::UnalignedVec &v) {\n      s.device(ctx->eigen_cpu_device()) = v.sum();\n  }\n  static StringPiece Name() {\n      return \"sum\";\n  }\n};\n\nstruct MaxOp {\n  template <typename T>\n  static void Run(OpKernelContext *ctx, typename TTypes<T>::Scalar &s, const typename TTypes<T>::UnalignedVec &v) {\n      s.device(ctx->eigen_cpu_device()) = v.maximum();\n  }\n  static StringPiece Name() {\n      return \"max\";\n  }\n};\n\ntemplate <typename T, typename Op>\nclass SparseReduceOp : public OpKernel {\n public:\n  explicit SparseReduceOp(OpKernelConstruction *ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"keep_dims\", &keep_dims_));\n  }\n\n  void Compute(OpKernelContext *ctx) override {\n    const Tensor *indices_t, *values_t, *shape_t, *reduction_axes_t;\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_indices\", &indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_values\", &values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_shape\", &shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"reduction_axes\", &reduction_axes_t));\n\n    OP_REQUIRES_OK(ctx, ValidateInputs(shape_t, reduction_axes_t));\n\n    // TODO(zongheng): we will call Reorder() below, which will modify\n    // in-place the underlying indices and values buffers.  To avoid\n    // surprises of this kernel being stateful, we work around the above by\n    // making deep copies here.  Remove this if/when we change Reorder()'s\n    // semantics.\n    const auto shape_vec = shape_t->vec<int64>();\n    SparseTensor sp;\n    OP_REQUIRES_OK(ctx, SparseTensor::Create(\n        tensor::DeepCopy(*indices_t), tensor::DeepCopy(*values_t),\n                    TensorShape(shape_vec), &sp));\n    ReduceDetails reduction = SparseTensorReduceHelper(\n        sp, reduction_axes_t->flat<int32>(), keep_dims_);\n\n    Tensor *out_values;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, reduction.reduced_shape, &out_values));\n    auto out_flat = out_values->flat<T>();\n    out_flat.setZero();\n\n    Tensor tmp_reduced_val;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                           TensorShape({}), &tmp_reduced_val));\n    auto reduced_val = tmp_reduced_val.scalar<T>();\n\n    // Compute strides, and use it to convert coords to flat index.  The\n    // coordinates returned by .group() have the same ndims as group_by_dims.\n    gtl::InlinedVector<int64, 8> output_strides(reduction.group_by_dims.size());\n    if (!output_strides.empty()) {  // Do this iff we don't reduce all.\n      output_strides.back() = 1;\n      for (int d = output_strides.size() - 2; d >= 0; --d) {\n        output_strides[d] =\n            output_strides[d + 1] * shape_vec(reduction.group_by_dims[d + 1]);\n      }\n    }\n\n    auto CoordinatesToFlatIndex = [](ArraySlice<int64> coords,\n                                     ArraySlice<int64> strides) -> int64 {\n      if (strides.empty()) {  // Reduce all.\n        return 0;\n      }\n      CHECK_EQ(coords.size(), strides.size());\n      int64_t idx = 0;\n      for (int i = 0; i < coords.size(); ++i) {\n        idx += coords[i] * strides[i];\n      }\n      return idx;\n    };\n\n    // Each group maps one-on-one onto a value in the reduced tensor.\n    // g.group() provides the coordinates of a particular reduced value.\n    sp.Reorder<T>(reduction.reorder_dims);\n    for (const auto &g : sp.group(reduction.group_by_dims)) {\n      Op::template Run<T>(ctx, reduced_val, g.template values<T>());\n      OP_REQUIRES(ctx,\n                  output_strides.empty() ||\n                  (g.group().size() == output_strides.size()),\n                  errors::Internal(\n                      \"Expected group size and output_strides size to match\",\n                      \", but got \", g.group().size(), \" and \",\n                      output_strides.size()));\n      const int64_t idx = CoordinatesToFlatIndex(g.group(), output_strides);\n      OP_REQUIRES(ctx,\n                  idx >= 0 && idx < out_flat.size(),\n                  errors::Internal(\n                      \"Obtained a write index of \", idx,\n                      \" which is outside of bounds of [0, \",\n                      out_flat.size(), \")\"));\n      out_flat(idx) = reduced_val();\n      VLOG(2) << \"coords: \" << absl::StrJoin(g.group(), \",\")\n              << \"; idx: \" << idx << \"; group \" << Op::Name() << \": \"\n              << reduced_val();\n    }\n  }\n\n private:\n  // True if the number of dimensions should be maintained.\n  bool keep_dims_;\n};\n\n#define REGISTER_KERNELS(T)                                              \\\n  REGISTER_KERNEL_BUILDER(                                               \\\n      Name(\"SparseReduceSum\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SparseReduceOp<T, SumOp>)\nTF_CALL_NUMBER_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n\n#define REGISTER_KERNELS(T)                                              \\\n  REGISTER_KERNEL_BUILDER(                                               \\\n      Name(\"SparseReduceMax\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SparseReduceOp<T, MaxOp>)\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n\ntemplate <typename T, typename Op>\nclass SparseReduceSparseOp : public OpKernel {\n public:\n  explicit SparseReduceSparseOp(OpKernelConstruction *ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"keep_dims\", &keep_dims_));\n  }\n\n  void Compute(OpKernelContext *ctx) override {\n    const Tensor *indices_t, *values_t, *shape_t, *reduction_axes_t;\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_indices\", &indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_values\", &values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_shape\", &shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"reduction_axes\", &reduction_axes_t));\n\n    OP_REQUIRES_OK(ctx, ValidateInputs(shape_t, reduction_axes_t));\n\n    SparseTensor sp;\n    OP_REQUIRES_OK(ctx, SparseTensor::Create(tensor::DeepCopy(*indices_t),\n                                         tensor::DeepCopy(*values_t),\n                    TensorShape(shape_t->vec<int64>()), &sp));\n    ReduceDetails reduction = SparseTensorReduceHelper(\n        sp, reduction_axes_t->flat<int32>(), keep_dims_);\n\n    sp.Reorder<T>(reduction.reorder_dims);\n    // Count nnzs in the output SparseTensor.\n    int64_t nnz = 0;\n    auto iter = sp.group(reduction.group_by_dims);\n    for (auto it = iter.begin(); it != iter.end(); ++it) {\n      nnz++;\n    }\n\n    Tensor *out_indices_t;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(\n                       0, TensorShape({nnz, reduction.reduced_shape.dims()}),\n                       &out_indices_t));\n    typename TTypes<int64>::Matrix out_indices_mat =\n        out_indices_t->matrix<int64>();\n    // For keep_dims. We don't explicitly set dim fields for reduced dims below.\n    out_indices_mat.setZero();\n\n    Tensor *out_values_t;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(1, TensorShape({nnz}), &out_values_t));\n    auto out_flat = out_values_t->flat<T>();\n\n    Tensor tmp_reduced_val;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                           TensorShape({}), &tmp_reduced_val));\n    auto reduced_val = tmp_reduced_val.scalar<T>();\n    int64_t i = 0;\n    for (const auto &g : sp.group(reduction.group_by_dims)) {\n      Op::template Run<T>(ctx, reduced_val, g.template values<T>());\n      std::vector<int64> group = g.group();\n      for (int64_t j = 0; j < group.size(); j++) {\n        if (keep_dims_) {\n          out_indices_mat(i, reduction.group_by_dims[j]) = group[j];\n        } else {\n          out_indices_mat(i, j) = group[j];\n        }\n      }\n      out_flat(i) = reduced_val();\n      i++;\n      VLOG(2) << \"coords: \" << absl::StrJoin(g.group(), \",\")\n              << \"; group \" << Op::Name() << \": \"\n              << reduced_val();\n    }\n\n    Tensor *out_shape_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(\n                            2, TensorShape({reduction.reduced_shape.dims()}),\n                            &out_shape_t));\n    auto out_shape_flat = out_shape_t->flat<int64>();\n    auto out_dim_sizes = reduction.reduced_shape.dim_sizes();\n    if (!out_dim_sizes.empty()) {\n      std::copy(out_dim_sizes.begin(), out_dim_sizes.end(), &out_shape_flat(0));\n    }\n  }\n\n private:\n  // True if the number of dimensions should be maintained.\n  bool keep_dims_;\n};\n\n#define REGISTER_KERNELS(T)                                                    \\\n  REGISTER_KERNEL_BUILDER(                                                     \\\n      Name(\"SparseReduceSumSparse\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SparseReduceSparseOp<T, SumOp>)\nTF_CALL_NUMBER_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n\n#define REGISTER_KERNELS(T)                                                    \\\n  REGISTER_KERNEL_BUILDER(                                                     \\\n      Name(\"SparseReduceMaxSparse\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      SparseReduceSparseOp<T, MaxOp>)\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/sparse_reduce_op.cc"], "buggy_code_start_loc": [221], "buggy_code_end_loc": [222], "fixing_code_start_loc": [222], "fixing_code_end_loc": [236], "type": "CWE-125", "message": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of sparse reduction operations in TensorFlow can trigger accesses outside of bounds of heap allocated data. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_reduce_op.cc#L217-L228) fails to validate that each reduction group does not overflow and that each corresponding index does not point to outside the bounds of the input tensor. We have patched the issue in GitHub commit 87158f43f05f2720a374f3e6d22a7aaa3a33f750. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-37635", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-12T21:15:07.577", "lastModified": "2021-08-18T16:37:16.573", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of sparse reduction operations in TensorFlow can trigger accesses outside of bounds of heap allocated data. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_reduce_op.cc#L217-L228) fails to validate that each reduction group does not overflow and that each corresponding index does not point to outside the bounds of the input tensor. We have patched the issue in GitHub commit 87158f43f05f2720a374f3e6d22a7aaa3a33f750. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico. En las versiones afectadas, la implementaci\u00f3n operaciones de reducci\u00f3n dispersa en TensorFlow puede desencadenar accesos fuera de l\u00edmites de los datos asignados a la pila. La [implementaci\u00f3n](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_reduce_op.cc#L217-L228) presenta un fallo en comprobar que cada grupo de reducci\u00f3n no se desborde y que cada \u00edndice correspondiente no apunte fuera de l\u00edmites del tensor de entrada. Hemos parcheado el problema en el commit 87158f43f05f2720a374f3e6d22a7aaa3a33f750 de GitHub. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.6.0. Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.5.1, TensorFlow versi\u00f3n 2.4.3, y TensorFlow versi\u00f3n 2.3.4, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda en el rango de soporte."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.4", "matchCriteriaId": "0F83C081-51CC-415F-A8C0-0A44C75E2CD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.3", "matchCriteriaId": "BD3F2BF8-EBA9-42BF-8F9B-D918B880B15A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "D03E99A7-4E3D-427D-A156-C0713E9FB02A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "70FA6E48-6C57-40CA-809F-4E3D07CBF348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "42187561-E491-434D-828C-F36701446634"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C66B61C8-450A-4C5E-9174-F970D6DEE778"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/87158f43f05f2720a374f3e6d22a7aaa3a33f750", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-cgfm-62j4-v4rf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/87158f43f05f2720a374f3e6d22a7aaa3a33f750"}}