{"buggy_code": ["<?php\n\n/**\n * Pure-PHP implementation of AES.\n *\n * Uses mcrypt, if available/possible, and an internal implementation, otherwise.\n *\n * PHP version 5\n *\n * NOTE: Since AES.php is (for compatibility and phpseclib-historical reasons) virtually\n * just a wrapper to Rijndael.php you may consider using Rijndael.php instead of\n * to save one include_once().\n *\n * If {@link \\phpseclib\\Crypt\\AES::setKeyLength() setKeyLength()} isn't called, it'll be calculated from\n * {@link \\phpseclib\\Crypt\\AES::setKey() setKey()}.  ie. if the key is 128-bits, the key length will be 128-bits.  If it's 136-bits\n * it'll be null-padded to 192-bits and 192 bits will be the key length until {@link \\phpseclib\\Crypt\\AES::setKey() setKey()}\n * is called, again, at which point, it'll be recalculated.\n *\n * Since \\phpseclib\\Crypt\\AES extends \\phpseclib\\Crypt\\Rijndael, some functions are available to be called that, in the context of AES, don't\n * make a whole lot of sense.  {@link \\phpseclib\\Crypt\\AES::setBlockLength() setBlockLength()}, for instance.  Calling that function,\n * however possible, won't do anything (AES has a fixed block length whereas Rijndael has a variable one).\n *\n * Here's a short example of how to use this library:\n * <code>\n * <?php\n *    include 'vendor/autoload.php';\n *\n *    $aes = new \\phpseclib\\Crypt\\AES();\n *\n *    $aes->setKey('abcdefghijklmnop');\n *\n *    $size = 10 * 1024;\n *    $plaintext = '';\n *    for ($i = 0; $i < $size; $i++) {\n *        $plaintext.= 'a';\n *    }\n *\n *    echo $aes->decrypt($aes->encrypt($plaintext));\n * ?>\n * </code>\n *\n * @category  Crypt\n * @package   AES\n * @author    Jim Wigginton <terrafrost@php.net>\n * @copyright 2008 Jim Wigginton\n * @license   http://www.opensource.org/licenses/mit-license.html  MIT License\n * @link      http://phpseclib.sourceforge.net\n */\n\nnamespace phpseclib\\Crypt;\n\nuse phpseclib\\Crypt\\Rijndael;\n\n/**\n * Pure-PHP implementation of AES.\n *\n * @package AES\n * @author  Jim Wigginton <terrafrost@php.net>\n * @access  public\n */\nclass AES extends Rijndael\n{\n    /**\n     * Dummy function\n     *\n     * Since \\phpseclib\\Crypt\\AES extends \\phpseclib\\Crypt\\Rijndael, this function is, technically, available, but it doesn't do anything.\n     *\n     * @see \\phpseclib\\Crypt\\Rijndael::setBlockLength()\n     * @access public\n     * @param Integer $length\n     */\n    function setBlockLength($length)\n    {\n        return;\n    }\n\n    /**\n     * Sets the key length\n     *\n     * Valid key lengths are 128, 192, and 256.  If the length is less than 128, it will be rounded up to\n     * 128.  If the length is greater than 128 and invalid, it will be rounded down to the closest valid amount.\n     *\n     * @see \\phpseclib\\Crypt\\Rijndael:setKeyLength()\n     * @access public\n     * @param Integer $length\n     */\n    function setKeyLength($length)\n    {\n        switch ($length) {\n            case 160:\n                $length = 192;\n                break;\n            case 224:\n                $length = 256;\n        }\n        parent::setKeyLength($length);\n    }\n\n    /**\n     * Sets the key.\n     *\n     * Rijndael supports five different key lengths, AES only supports three.\n     *\n     * @see \\phpseclib\\Crypt\\Rijndael:setKey()\n     * @see setKeyLength()\n     * @access public\n     * @param String $key\n     */\n    function setKey($key)\n    {\n        parent::setKey($key);\n\n        if (!$this->explicit_key_length) {\n            $length = strlen($key);\n            switch (true) {\n                case $length <= 16:\n                    $this->key_size = 16;\n                    break;\n                case $length <= 24:\n                    $this->key_size = 24;\n                    break;\n                default:\n                    $this->key_size = 32;\n            }\n            $this->_setEngine();\n        }\n    }\n}\n", "<?php\n\n/**\n * Base Class for all \\phpseclib\\Crypt\\* cipher classes\n *\n * PHP version 5\n *\n * Internally for phpseclib developers:\n *  If you plan to add a new cipher class, please note following rules:\n *\n *  - The new \\phpseclib\\Crypt\\* cipher class should extend \\phpseclib\\Crypt\\Base\n *\n *  - Following methods are then required to be overridden/overloaded:\n *\n *    - _encryptBlock()\n *\n *    - _decryptBlock()\n *\n *    - _setupKey()\n *\n *  - All other methods are optional to be overridden/overloaded\n *\n *  - Look at the source code of the current ciphers how they extend \\phpseclib\\Crypt\\Base\n *    and take one of them as a start up for the new cipher class.\n *\n *  - Please read all the other comments/notes/hints here also for each class var/method\n *\n * @category  Crypt\n * @package   Base\n * @author    Jim Wigginton <terrafrost@php.net>\n * @author    Hans-Juergen Petrich <petrich@tronic-media.com>\n * @copyright 2007 Jim Wigginton\n * @license   http://www.opensource.org/licenses/mit-license.html  MIT License\n * @link      http://phpseclib.sourceforge.net\n */\n\nnamespace phpseclib\\Crypt;\n\nuse phpseclib\\Crypt\\Hash;\n\n/**\n * Base Class for all \\phpseclib\\Crypt\\* cipher classes\n *\n * @package Base\n * @author  Jim Wigginton <terrafrost@php.net>\n * @author  Hans-Juergen Petrich <petrich@tronic-media.com>\n */\nabstract class Base\n{\n    /**#@+\n     * @access public\n     * @see \\phpseclib\\Crypt\\Base::encrypt()\n     * @see \\phpseclib\\Crypt\\Base::decrypt()\n     */\n    /**\n     * Encrypt / decrypt using the Counter mode.\n     *\n     * Set to -1 since that's what Crypt/Random.php uses to index the CTR mode.\n     *\n     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29\n     */\n    const MODE_CTR = -1;\n    /**\n     * Encrypt / decrypt using the Electronic Code Book mode.\n     *\n     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29\n     */\n    const MODE_ECB = 1;\n    /**\n     * Encrypt / decrypt using the Code Book Chaining mode.\n     *\n     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29\n     */\n    const MODE_CBC = 2;\n    /**\n     * Encrypt / decrypt using the Cipher Feedback mode.\n     *\n     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher_feedback_.28CFB.29\n     */\n    const MODE_CFB = 3;\n    /**\n     * Encrypt / decrypt using the Output Feedback mode.\n     *\n     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Output_feedback_.28OFB.29\n     */\n    const MODE_OFB = 4;\n    /**\n     * Encrypt / decrypt using streaming mode.\n     */\n    const MODE_STREAM = 5;\n    /**#@-*/\n\n    /**\n     * Whirlpool available flag\n     *\n     * @see \\phpseclib\\Crypt\\Base::_hashInlineCryptFunction()\n     * @var Boolean\n     * @access private\n     */\n    static $WHIRLPOOL_AVAILABLE;\n\n    /**#@+\n     * @access private\n     * @see \\phpseclib\\Crypt\\Base::__construct()\n     */\n    /**\n     * Base value for the internal implementation $engine switch\n     */\n    const ENGINE_INTERNAL = 1;\n    /**\n     * Base value for the mcrypt implementation $engine switch\n     */\n    const ENGINE_MCRYPT = 2;\n    /**\n     * Base value for the mcrypt implementation $engine switch\n     */\n    const ENGINE_OPENSSL = 3;\n    /**#@-*/\n\n    /**\n     * The Encryption Mode\n     *\n     * @see \\phpseclib\\Crypt\\Base::__construct()\n     * @var Integer\n     * @access private\n     */\n    var $mode;\n\n    /**\n     * The Block Length of the block cipher\n     *\n     * @var Integer\n     * @access private\n     */\n    var $block_size = 16;\n\n    /**\n     * The Key\n     *\n     * @see \\phpseclib\\Crypt\\Base::setKey()\n     * @var String\n     * @access private\n     */\n    var $key = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n    /**\n     * The Initialization Vector\n     *\n     * @see \\phpseclib\\Crypt\\Base::setIV()\n     * @var String\n     * @access private\n     */\n    var $iv;\n\n    /**\n     * A \"sliding\" Initialization Vector\n     *\n     * @see \\phpseclib\\Crypt\\Base::enableContinuousBuffer()\n     * @see \\phpseclib\\Crypt\\Base::_clearBuffers()\n     * @var String\n     * @access private\n     */\n    var $encryptIV;\n\n    /**\n     * A \"sliding\" Initialization Vector\n     *\n     * @see \\phpseclib\\Crypt\\Base::enableContinuousBuffer()\n     * @see \\phpseclib\\Crypt\\Base::_clearBuffers()\n     * @var String\n     * @access private\n     */\n    var $decryptIV;\n\n    /**\n     * Continuous Buffer status\n     *\n     * @see \\phpseclib\\Crypt\\Base::enableContinuousBuffer()\n     * @var Boolean\n     * @access private\n     */\n    var $continuousBuffer = false;\n\n    /**\n     * Encryption buffer for CTR, OFB and CFB modes\n     *\n     * @see \\phpseclib\\Crypt\\Base::encrypt()\n     * @see \\phpseclib\\Crypt\\Base::_clearBuffers()\n     * @var Array\n     * @access private\n     */\n    var $enbuffer;\n\n    /**\n     * Decryption buffer for CTR, OFB and CFB modes\n     *\n     * @see \\phpseclib\\Crypt\\Base::decrypt()\n     * @see \\phpseclib\\Crypt\\Base::_clearBuffers()\n     * @var Array\n     * @access private\n     */\n    var $debuffer;\n\n    /**\n     * mcrypt resource for encryption\n     *\n     * The mcrypt resource can be recreated every time something needs to be created or it can be created just once.\n     * Since mcrypt operates in continuous mode, by default, it'll need to be recreated when in non-continuous mode.\n     *\n     * @see \\phpseclib\\Crypt\\Base::encrypt()\n     * @var Resource\n     * @access private\n     */\n    var $enmcrypt;\n\n    /**\n     * mcrypt resource for decryption\n     *\n     * The mcrypt resource can be recreated every time something needs to be created or it can be created just once.\n     * Since mcrypt operates in continuous mode, by default, it'll need to be recreated when in non-continuous mode.\n     *\n     * @see \\phpseclib\\Crypt\\Base::decrypt()\n     * @var Resource\n     * @access private\n     */\n    var $demcrypt;\n\n    /**\n     * Does the enmcrypt resource need to be (re)initialized?\n     *\n     * @see \\phpseclib\\Crypt\\Twofish::setKey()\n     * @see \\phpseclib\\Crypt\\Twofish::setIV()\n     * @var Boolean\n     * @access private\n     */\n    var $enchanged = true;\n\n    /**\n     * Does the demcrypt resource need to be (re)initialized?\n     *\n     * @see \\phpseclib\\Crypt\\Twofish::setKey()\n     * @see \\phpseclib\\Crypt\\Twofish::setIV()\n     * @var Boolean\n     * @access private\n     */\n    var $dechanged = true;\n\n    /**\n     * mcrypt resource for CFB mode\n     *\n     * mcrypt's CFB mode, in (and only in) buffered context,\n     * is broken, so phpseclib implements the CFB mode by it self,\n     * even when the mcrypt php extension is available.\n     *\n     * In order to do the CFB-mode work (fast) phpseclib\n     * use a separate ECB-mode mcrypt resource.\n     *\n     * @link http://phpseclib.sourceforge.net/cfb-demo.phps\n     * @see \\phpseclib\\Crypt\\Base::encrypt()\n     * @see \\phpseclib\\Crypt\\Base::decrypt()\n     * @see \\phpseclib\\Crypt\\Base::_setupMcrypt()\n     * @var Resource\n     * @access private\n     */\n    var $ecb;\n\n    /**\n     * Optimizing value while CFB-encrypting\n     *\n     * Only relevant if $continuousBuffer enabled\n     * and $engine == self::ENGINE_MCRYPT\n     *\n     * It's faster to re-init $enmcrypt if\n     * $buffer bytes > $cfb_init_len than\n     * using the $ecb resource furthermore.\n     *\n     * This value depends of the chosen cipher\n     * and the time it would be needed for it's\n     * initialization [by mcrypt_generic_init()]\n     * which, typically, depends on the complexity\n     * on its internaly Key-expanding algorithm.\n     *\n     * @see \\phpseclib\\Crypt\\Base::encrypt()\n     * @var Integer\n     * @access private\n     */\n    var $cfb_init_len = 600;\n\n    /**\n     * Does internal cipher state need to be (re)initialized?\n     *\n     * @see setKey()\n     * @see setIV()\n     * @see disableContinuousBuffer()\n     * @var Boolean\n     * @access private\n     */\n    var $changed = true;\n\n    /**\n     * Padding status\n     *\n     * @see \\phpseclib\\Crypt\\Base::enablePadding()\n     * @var Boolean\n     * @access private\n     */\n    var $padding = true;\n\n    /**\n     * Is the mode one that is paddable?\n     *\n     * @see \\phpseclib\\Crypt\\Base::__construct()\n     * @var Boolean\n     * @access private\n     */\n    var $paddable = false;\n\n    /**\n     * Holds which crypt engine internaly should be use,\n     * which will be determined automatically on __construct()\n     *\n     * Currently available $engines are:\n     * - self::ENGINE_OPENSSL  (very fast, php-extension: openssl, extension_loaded('openssl') required)\n     * - self::ENGINE_MCRYPT   (fast, php-extension: mcrypt, extension_loaded('mcrypt') required)\n     * - self::ENGINE_INTERNAL (slower, pure php-engine, no php-extension required)\n     *\n     * @see \\phpseclib\\Crypt\\Base::_setEngine()\n     * @see \\phpseclib\\Crypt\\Base::encrypt()\n     * @see \\phpseclib\\Crypt\\Base::decrypt()\n     * @var Integer\n     * @access private\n     */\n    var $engine;\n\n    /**\n     * Holds the preferred crypt engine\n     *\n     * @see \\phpseclib\\Crypt\\Base::_setEngine()\n     * @see \\phpseclib\\Crypt\\Base::setPreferredEngine()\n     * @var Integer\n     * @access private\n     */\n    var $preferredEngine;\n\n    /**\n     * The mcrypt specific name of the cipher\n     *\n     * Only used if $engine == self::ENGINE_MCRYPT\n     *\n     * @link http://www.php.net/mcrypt_module_open\n     * @link http://www.php.net/mcrypt_list_algorithms\n     * @see \\phpseclib\\Crypt\\Base::_setupMcrypt()\n     * @var String\n     * @access private\n     */\n    var $cipher_name_mcrypt;\n\n    /**\n     * The openssl specific name of the cipher\n     *\n     * Only used if $engine == CRYPT_ENGINE_OPENSSL\n     *\n     * @link http://www.php.net/openssl-get-cipher-methods\n     * @var String\n     * @access private\n     */\n    var $cipher_name_openssl;\n\n    /**\n     * The openssl specific name of the cipher in ECB mode\n     *\n     * If OpenSSL does not support the mode we're trying to use (CTR)\n     * it can still be emulated with ECB mode.\n     *\n     * @link http://www.php.net/openssl-get-cipher-methods\n     * @var String\n     * @access private\n     */\n    var $cipher_name_openssl_ecb;\n\n    /**\n     * The default password key_size used by setPassword()\n     *\n     * @see \\phpseclib\\Crypt\\Base::setPassword()\n     * @var Integer\n     * @access private\n     */\n    var $password_key_size = 32;\n\n    /**\n     * The default salt used by setPassword()\n     *\n     * @see \\phpseclib\\Crypt\\Base::setPassword()\n     * @var String\n     * @access private\n     */\n    var $password_default_salt = 'phpseclib/salt';\n\n    /**\n     * The name of the performance-optimized callback function\n     *\n     * Used by encrypt() / decrypt()\n     * only if $engine == self::ENGINE_INTERNAL\n     *\n     * @see \\phpseclib\\Crypt\\Base::encrypt()\n     * @see \\phpseclib\\Crypt\\Base::decrypt()\n     * @see \\phpseclib\\Crypt\\Base::_setupInlineCrypt()\n     * @see \\phpseclib\\Crypt\\Base::$use_inline_crypt\n     * @var Callback\n     * @access private\n     */\n    var $inline_crypt;\n\n    /**\n     * Holds whether performance-optimized $inline_crypt() can/should be used.\n     *\n     * @see \\phpseclib\\Crypt\\Base::encrypt()\n     * @see \\phpseclib\\Crypt\\Base::decrypt()\n     * @see \\phpseclib\\Crypt\\Base::inline_crypt\n     * @var mixed\n     * @access private\n     */\n    var $use_inline_crypt;\n\n    /**\n     * If OpenSSL can be used in ECB but not in CTR we can emulate CTR\n     *\n     * @see \\phpseclib\\Crypt\\Base::_openssl_ctr_process()\n     * @var Boolean\n     * @access private\n     */\n    var $openssl_emulate_ctr = false;\n\n    /**\n     * Determines what options are passed to openssl_encrypt/decrypt\n     *\n     * @see \\phpseclib\\Crypt\\Base::isValidEngine()\n     * @var mixed\n     * @access private\n     */\n    var $openssl_options;\n\n    /**\n     * Default Constructor.\n     *\n     * Determines whether or not the mcrypt extension should be used.\n     *\n     * $mode could be:\n     *\n     * - self::MODE_ECB\n     *\n     * - self::MODE_CBC\n     *\n     * - self::MODE_CTR\n     *\n     * - self::MODE_CFB\n     *\n     * - self::MODE_OFB\n     *\n     * (or the alias constants of the chosen cipher, for example for AES: CRYPT_AES_MODE_ECB or CRYPT_AES_MODE_CBC ...)\n     *\n     * If not explicitly set, self::MODE_CBC will be used.\n     *\n     * @param optional Integer $mode\n     * @access public\n     */\n    function __construct($mode = self::MODE_CBC)\n    {\n        // $mode dependent settings\n        switch ($mode) {\n            case self::MODE_ECB:\n                $this->paddable = true;\n                $this->mode = self::MODE_ECB;\n                break;\n            case self::MODE_CTR:\n            case self::MODE_CFB:\n            case self::MODE_OFB:\n            case self::MODE_STREAM:\n                $this->mode = $mode;\n                break;\n            case self::MODE_CBC:\n            default:\n                $this->paddable = true;\n                $this->mode = self::MODE_CBC;\n        }\n\n        $this->_setEngine();\n\n        // Determining whether inline crypting can be used by the cipher\n        if ($this->use_inline_crypt !== false && function_exists('create_function')) {\n            $this->use_inline_crypt = true;\n        }\n    }\n\n    /**\n     * Sets the initialization vector. (optional)\n     *\n     * SetIV is not required when self::MODE_ECB (or ie for AES: \\phpseclib\\Crypt\\AES::MODE_ECB) is being used.  If not explicitly set, it'll be assumed\n     * to be all zero's.\n     *\n     * @access public\n     * @param String $iv\n     * @internal Can be overwritten by a sub class, but does not have to be\n     */\n    function setIV($iv)\n    {\n        if ($this->mode == self::MODE_ECB) {\n            return;\n        }\n\n        $this->iv = $iv;\n        $this->changed = true;\n    }\n\n    /**\n     * Sets the key.\n     *\n     * The min/max length(s) of the key depends on the cipher which is used.\n     * If the key not fits the length(s) of the cipher it will paded with null bytes\n     * up to the closest valid key length.  If the key is more than max length,\n     * we trim the excess bits.\n     *\n     * If the key is not explicitly set, it'll be assumed to be all null bytes.\n     *\n     * @access public\n     * @param String $key\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function setKey($key)\n    {\n        $this->key = $key;\n        $this->changed = true;\n        $this->_setEngine();\n    }\n\n    /**\n     * Sets the password.\n     *\n     * Depending on what $method is set to, setPassword()'s (optional) parameters are as follows:\n     *     {@link http://en.wikipedia.org/wiki/PBKDF2 pbkdf2} or pbkdf1:\n     *         $hash, $salt, $count, $dkLen\n     *\n     *         Where $hash (default = sha1) currently supports the following hashes: see: Crypt/Hash.php\n     *\n     * @see Crypt/Hash.php\n     * @param String $password\n     * @param optional String $method\n     * @return Boolean\n     * @access public\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function setPassword($password, $method = 'pbkdf2')\n    {\n        $key = '';\n\n        switch ($method) {\n            default: // 'pbkdf2' or 'pbkdf1'\n                $func_args = func_get_args();\n\n                // Hash function\n                $hash = isset($func_args[2]) ? $func_args[2] : 'sha1';\n\n                // WPA and WPA2 use the SSID as the salt\n                $salt = isset($func_args[3]) ? $func_args[3] : $this->password_default_salt;\n\n                // RFC2898#section-4.2 uses 1,000 iterations by default\n                // WPA and WPA2 use 4,096.\n                $count = isset($func_args[4]) ? $func_args[4] : 1000;\n\n                // Keylength\n                if (isset($func_args[5])) {\n                    $dkLen = $func_args[5];\n                } else {\n                    $dkLen = $method == 'pbkdf1' ? 2 * $this->password_key_size : $this->password_key_size;\n                }\n\n                switch (true) {\n                    case $method == 'pbkdf1':\n                        $hashObj = new Hash();\n                        $hashObj->setHash($hash);\n                        if ($dkLen > $hashObj->getLength()) {\n                            user_error('Derived key too long');\n                            return false;\n                        }\n                        $t = $password . $salt;\n                        for ($i = 0; $i < $count; ++$i) {\n                            $t = $hashObj->hash($t);\n                        }\n                        $key = substr($t, 0, $dkLen);\n\n                        $this->setKey(substr($key, 0, $dkLen >> 1));\n                        $this->setIV(substr($key, $dkLen >> 1));\n\n                        return true;\n                    // Determining if php[>=5.5.0]'s hash_pbkdf2() function avail- and useable\n                    case !function_exists('hash_pbkdf2'):\n                    case !function_exists('hash_algos'):\n                    case !in_array($hash, hash_algos()):\n                        $i = 1;\n                        while (strlen($key) < $dkLen) {\n                            $hmac = new Hash();\n                            $hmac->setHash($hash);\n                            $hmac->setKey($password);\n                            $f = $u = $hmac->hash($salt . pack('N', $i++));\n                            for ($j = 2; $j <= $count; ++$j) {\n                                $u = $hmac->hash($u);\n                                $f^= $u;\n                            }\n                            $key.= $f;\n                        }\n                        $key = substr($key, 0, $dkLen);\n                        break;\n                    default:\n                        $key = hash_pbkdf2($hash, $password, $salt, $count, $dkLen, true);\n                }\n        }\n\n        $this->setKey($key);\n\n        return true;\n    }\n\n    /**\n     * Encrypts a message.\n     *\n     * $plaintext will be padded with additional bytes such that it's length is a multiple of the block size. Other cipher\n     * implementations may or may not pad in the same manner.  Other common approaches to padding and the reasons why it's\n     * necessary are discussed in the following\n     * URL:\n     *\n     * {@link http://www.di-mgt.com.au/cryptopad.html http://www.di-mgt.com.au/cryptopad.html}\n     *\n     * An alternative to padding is to, separately, send the length of the file.  This is what SSH, in fact, does.\n     * strlen($plaintext) will still need to be a multiple of the block size, however, arbitrary values can be added to make it that\n     * length.\n     *\n     * @see \\phpseclib\\Crypt\\Base::decrypt()\n     * @access public\n     * @param String $plaintext\n     * @return String $ciphertext\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function encrypt($plaintext)\n    {\n        if ($this->paddable) {\n            $plaintext = $this->_pad($plaintext);\n        }\n\n        if ($this->engine === self::ENGINE_OPENSSL) {\n            if ($this->changed) {\n                $this->_clearBuffers();\n                $this->changed = false;\n            }\n            switch ($this->mode) {\n                case self::MODE_STREAM:\n                    return openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options);\n                case self::MODE_ECB:\n                    $result = openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options);\n                    return !defined('OPENSSL_RAW_DATA') ? substr($result, 0, -$this->block_size) : $result;\n                case self::MODE_CBC:\n                    $result = openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $this->encryptIV);\n                    if ($this->continuousBuffer) {\n                        $this->encryptIV = substr($result, -$this->block_size);\n                    }\n                    return !defined('OPENSSL_RAW_DATA') ? substr($result, 0, -$this->block_size) : $result;\n                case self::MODE_CTR:\n                    return $this->_openssl_ctr_process($plaintext, $this->encryptIV, $this->enbuffer);\n                case self::MODE_CFB:\n                    // cfb loosely routines inspired by openssl's:\n                    // {@link http://cvs.openssl.org/fileview?f=openssl/crypto/modes/cfb128.c&v=1.3.2.2.2.1}\n                    $ciphertext = '';\n                    if ($this->continuousBuffer) {\n                        $iv = &$this->encryptIV;\n                        $pos = &$this->enbuffer['pos'];\n                    } else {\n                        $iv = $this->encryptIV;\n                        $pos = 0;\n                    }\n                    $len = strlen($plaintext);\n                    $i = 0;\n                    if ($pos) {\n                        $orig_pos = $pos;\n                        $max = $this->block_size - $pos;\n                        if ($len >= $max) {\n                            $i = $max;\n                            $len-= $max;\n                            $pos = 0;\n                        } else {\n                            $i = $len;\n                            $pos+= $len;\n                            $len = 0;\n                        }\n                        // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize\n                        $ciphertext = substr($iv, $orig_pos) ^ $plaintext;\n                        $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);\n                        $plaintext = substr($plaintext, $i);\n                    }\n\n                    $overflow = $len % $this->block_size;\n\n                    if ($overflow) {\n                        $ciphertext.= openssl_encrypt(substr($plaintext, 0, -$overflow) . str_repeat(\"\\0\", $this->block_size), $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);\n                        $iv = $this->_string_pop($ciphertext, $this->block_size);\n\n                        $size = $len - $overflow;\n                        $block = $iv ^ substr($plaintext, -$overflow);\n                        $iv = substr_replace($iv, $block, 0, $overflow);\n                        $ciphertext.= $block;\n                        $pos = $overflow;\n                    } elseif ($len) {\n                        $ciphertext = openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);\n                        $iv = substr($ciphertext, -$this->block_size);\n                    }\n\n                    return $ciphertext;\n                case self::MODE_OFB:\n                    return $this->_openssl_ofb_process($plaintext, $this->encryptIV, $this->enbuffer);\n            }\n        }\n\n        if ($this->engine === self::ENGINE_MCRYPT) {\n            if ($this->changed) {\n                $this->_setupMcrypt();\n                $this->changed = false;\n            }\n            if ($this->enchanged) {\n                mcrypt_generic_init($this->enmcrypt, $this->key, $this->encryptIV);\n                $this->enchanged = false;\n            }\n\n            // re: {@link http://phpseclib.sourceforge.net/cfb-demo.phps}\n            // using mcrypt's default handing of CFB the above would output two different things.  using phpseclib's\n            // rewritten CFB implementation the above outputs the same thing twice.\n            if ($this->mode == self::MODE_CFB && $this->continuousBuffer) {\n                $block_size = $this->block_size;\n                $iv = &$this->encryptIV;\n                $pos = &$this->enbuffer['pos'];\n                $len = strlen($plaintext);\n                $ciphertext = '';\n                $i = 0;\n                if ($pos) {\n                    $orig_pos = $pos;\n                    $max = $block_size - $pos;\n                    if ($len >= $max) {\n                        $i = $max;\n                        $len-= $max;\n                        $pos = 0;\n                    } else {\n                        $i = $len;\n                        $pos+= $len;\n                        $len = 0;\n                    }\n                    $ciphertext = substr($iv, $orig_pos) ^ $plaintext;\n                    $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);\n                    $this->enbuffer['enmcrypt_init'] = true;\n                }\n                if ($len >= $block_size) {\n                    if ($this->enbuffer['enmcrypt_init'] === false || $len > $this->cfb_init_len) {\n                        if ($this->enbuffer['enmcrypt_init'] === true) {\n                            mcrypt_generic_init($this->enmcrypt, $this->key, $iv);\n                            $this->enbuffer['enmcrypt_init'] = false;\n                        }\n                        $ciphertext.= mcrypt_generic($this->enmcrypt, substr($plaintext, $i, $len - $len % $block_size));\n                        $iv = substr($ciphertext, -$block_size);\n                        $len%= $block_size;\n                    } else {\n                        while ($len >= $block_size) {\n                            $iv = mcrypt_generic($this->ecb, $iv) ^ substr($plaintext, $i, $block_size);\n                            $ciphertext.= $iv;\n                            $len-= $block_size;\n                            $i+= $block_size;\n                        }\n                    }\n                }\n\n                if ($len) {\n                    $iv = mcrypt_generic($this->ecb, $iv);\n                    $block = $iv ^ substr($plaintext, -$len);\n                    $iv = substr_replace($iv, $block, 0, $len);\n                    $ciphertext.= $block;\n                    $pos = $len;\n                }\n\n                return $ciphertext;\n            }\n\n            $ciphertext = mcrypt_generic($this->enmcrypt, $plaintext);\n\n            if (!$this->continuousBuffer) {\n                mcrypt_generic_init($this->enmcrypt, $this->key, $this->encryptIV);\n            }\n\n            return $ciphertext;\n        }\n\n        if ($this->changed) {\n            $this->_setup();\n            $this->changed = false;\n        }\n        if ($this->use_inline_crypt) {\n            $inline = $this->inline_crypt;\n            return $inline('encrypt', $this, $plaintext);\n        }\n\n        $buffer = &$this->enbuffer;\n        $block_size = $this->block_size;\n        $ciphertext = '';\n        switch ($this->mode) {\n            case self::MODE_ECB:\n                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                    $ciphertext.= $this->_encryptBlock(substr($plaintext, $i, $block_size));\n                }\n                break;\n            case self::MODE_CBC:\n                $xor = $this->encryptIV;\n                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                    $block = substr($plaintext, $i, $block_size);\n                    $block = $this->_encryptBlock($block ^ $xor);\n                    $xor = $block;\n                    $ciphertext.= $block;\n                }\n                if ($this->continuousBuffer) {\n                    $this->encryptIV = $xor;\n                }\n                break;\n            case self::MODE_CTR:\n                $xor = $this->encryptIV;\n                if (strlen($buffer['ciphertext'])) {\n                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                        $block = substr($plaintext, $i, $block_size);\n                        if (strlen($block) > strlen($buffer['ciphertext'])) {\n                            $buffer['ciphertext'].= $this->_encryptBlock($xor);\n                        }\n                        $this->_increment_str($xor);\n                        $key = $this->_string_shift($buffer['ciphertext'], $block_size);\n                        $ciphertext.= $block ^ $key;\n                    }\n                } else {\n                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                        $block = substr($plaintext, $i, $block_size);\n                        $key = $this->_encryptBlock($xor);\n                        $this->_increment_str($xor);\n                        $ciphertext.= $block ^ $key;\n                    }\n                }\n                if ($this->continuousBuffer) {\n                    $this->encryptIV = $xor;\n                    if ($start = strlen($plaintext) % $block_size) {\n                        $buffer['ciphertext'] = substr($key, $start) . $buffer['ciphertext'];\n                    }\n                }\n                break;\n            case self::MODE_CFB:\n                // cfb loosely routines inspired by openssl's:\n                // {@link http://cvs.openssl.org/fileview?f=openssl/crypto/modes/cfb128.c&v=1.3.2.2.2.1}\n                if ($this->continuousBuffer) {\n                    $iv = &$this->encryptIV;\n                    $pos = &$buffer['pos'];\n                } else {\n                    $iv = $this->encryptIV;\n                    $pos = 0;\n                }\n                $len = strlen($plaintext);\n                $i = 0;\n                if ($pos) {\n                    $orig_pos = $pos;\n                    $max = $block_size - $pos;\n                    if ($len >= $max) {\n                        $i = $max;\n                        $len-= $max;\n                        $pos = 0;\n                    } else {\n                        $i = $len;\n                        $pos+= $len;\n                        $len = 0;\n                    }\n                    // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize\n                    $ciphertext = substr($iv, $orig_pos) ^ $plaintext;\n                    $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);\n                }\n                while ($len >= $block_size) {\n                    $iv = $this->_encryptBlock($iv) ^ substr($plaintext, $i, $block_size);\n                    $ciphertext.= $iv;\n                    $len-= $block_size;\n                    $i+= $block_size;\n                }\n                if ($len) {\n                    $iv = $this->_encryptBlock($iv);\n                    $block = $iv ^ substr($plaintext, $i);\n                    $iv = substr_replace($iv, $block, 0, $len);\n                    $ciphertext.= $block;\n                    $pos = $len;\n                }\n                break;\n            case self::MODE_OFB:\n                $xor = $this->encryptIV;\n                if (strlen($buffer['xor'])) {\n                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                        $block = substr($plaintext, $i, $block_size);\n                        if (strlen($block) > strlen($buffer['xor'])) {\n                            $xor = $this->_encryptBlock($xor);\n                            $buffer['xor'].= $xor;\n                        }\n                        $key = $this->_string_shift($buffer['xor'], $block_size);\n                        $ciphertext.= $block ^ $key;\n                    }\n                } else {\n                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                        $xor = $this->_encryptBlock($xor);\n                        $ciphertext.= substr($plaintext, $i, $block_size) ^ $xor;\n                    }\n                    $key = $xor;\n                }\n                if ($this->continuousBuffer) {\n                    $this->encryptIV = $xor;\n                    if ($start = strlen($plaintext) % $block_size) {\n                         $buffer['xor'] = substr($key, $start) . $buffer['xor'];\n                    }\n                }\n                break;\n            case self::MODE_STREAM:\n                $ciphertext = $this->_encryptBlock($plaintext);\n                break;\n        }\n\n        return $ciphertext;\n    }\n\n    /**\n     * Decrypts a message.\n     *\n     * If strlen($ciphertext) is not a multiple of the block size, null bytes will be added to the end of the string until\n     * it is.\n     *\n     * @see \\phpseclib\\Crypt\\Base::encrypt()\n     * @access public\n     * @param String $ciphertext\n     * @return String $plaintext\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function decrypt($ciphertext)\n    {\n        if ($this->paddable) {\n            // we pad with chr(0) since that's what mcrypt_generic does.  to quote from {@link http://www.php.net/function.mcrypt-generic}:\n            // \"The data is padded with \"\\0\" to make sure the length of the data is n * blocksize.\"\n            $ciphertext = str_pad($ciphertext, strlen($ciphertext) + ($this->block_size - strlen($ciphertext) % $this->block_size) % $this->block_size, chr(0));\n        }\n\n        if ($this->engine === self::ENGINE_OPENSSL) {\n            if ($this->changed) {\n                $this->_clearBuffers();\n                $this->changed = false;\n            }\n            switch ($this->mode) {\n                case self::MODE_STREAM:\n                    $plaintext = openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options);\n                    break;\n                case self::MODE_ECB:\n                    if (!defined('OPENSSL_RAW_DATA')) {\n                        $ciphertext.= openssl_encrypt('', $this->cipher_name_openssl_ecb, $this->key, true);\n                    }\n                    $plaintext = openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options);\n                    break;\n                case self::MODE_CBC:\n                    if (!defined('OPENSSL_RAW_DATA')) {\n                        $padding = str_repeat(chr($this->block_size), $this->block_size) ^ substr($ciphertext, -$this->block_size);\n                        $ciphertext.= substr(openssl_encrypt($padding, $this->cipher_name_openssl_ecb, $this->key, true), 0, $this->block_size);\n                    }\n                    $plaintext = openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $this->decryptIV);\n                    if ($this->continuousBuffer) {\n                        $this->decryptIV = substr($ciphertext, -$this->block_size);\n                    }\n                    break;\n                case self::MODE_CTR:\n                    $plaintext = $this->_openssl_ctr_process($ciphertext, $this->decryptIV, $this->debuffer);\n                    break;\n                case self::MODE_CFB:\n                    // cfb loosely routines inspired by openssl's:\n                    // {@link http://cvs.openssl.org/fileview?f=openssl/crypto/modes/cfb128.c&v=1.3.2.2.2.1}\n                    $plaintext = '';\n                    if ($this->continuousBuffer) {\n                        $iv = &$this->decryptIV;\n                        $pos = &$this->buffer['pos'];\n                    } else {\n                        $iv = $this->decryptIV;\n                        $pos = 0;\n                    }\n                    $len = strlen($ciphertext);\n                    $i = 0;\n                    if ($pos) {\n                        $orig_pos = $pos;\n                        $max = $this->block_size - $pos;\n                        if ($len >= $max) {\n                            $i = $max;\n                            $len-= $max;\n                            $pos = 0;\n                        } else {\n                            $i = $len;\n                            $pos+= $len;\n                            $len = 0;\n                        }\n                        // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $this->blocksize\n                        $plaintext = substr($iv, $orig_pos) ^ $ciphertext;\n                        $iv = substr_replace($iv, substr($ciphertext, 0, $i), $orig_pos, $i);\n                        $ciphertext = substr($ciphertext, $i);\n                    }\n                    $overflow = $len % $this->block_size;\n                    if ($overflow) {\n                        $plaintext.= openssl_decrypt(substr($ciphertext, 0, -$overflow), $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);\n                        if ($len - $overflow) {\n                            $iv = substr($ciphertext, -$overflow - $this->block_size, -$overflow);\n                        }\n                        $iv = openssl_encrypt(str_repeat(\"\\0\", $this->block_size), $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);\n                        $plaintext.= $iv ^ substr($ciphertext, -$overflow);\n                        $iv = substr_replace($iv, substr($ciphertext, -$overflow), 0, $overflow);\n                        $pos = $overflow;\n                    } elseif ($len) {\n                        $plaintext.= openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);\n                        $iv = substr($ciphertext, -$this->block_size);\n                    }\n                    break;\n                case self::MODE_OFB:\n                    $plaintext = $this->_openssl_ofb_process($ciphertext, $this->decryptIV, $this->debuffer);\n            }\n\n            return $this->paddable ? $this->_unpad($plaintext) : $plaintext;\n        }\n\n        if ($this->engine === self::ENGINE_MCRYPT) {\n            $block_size = $this->block_size;\n            if ($this->changed) {\n                $this->_setupMcrypt();\n                $this->changed = false;\n            }\n            if ($this->dechanged) {\n                mcrypt_generic_init($this->demcrypt, $this->key, $this->decryptIV);\n                $this->dechanged = false;\n            }\n\n            if ($this->mode == self::MODE_CFB && $this->continuousBuffer) {\n                $iv = &$this->decryptIV;\n                $pos = &$this->debuffer['pos'];\n                $len = strlen($ciphertext);\n                $plaintext = '';\n                $i = 0;\n                if ($pos) {\n                    $orig_pos = $pos;\n                    $max = $block_size - $pos;\n                    if ($len >= $max) {\n                        $i = $max;\n                        $len-= $max;\n                        $pos = 0;\n                    } else {\n                        $i = $len;\n                        $pos+= $len;\n                        $len = 0;\n                    }\n                    // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize\n                    $plaintext = substr($iv, $orig_pos) ^ $ciphertext;\n                    $iv = substr_replace($iv, substr($ciphertext, 0, $i), $orig_pos, $i);\n                }\n                if ($len >= $block_size) {\n                    $cb = substr($ciphertext, $i, $len - $len % $block_size);\n                    $plaintext.= mcrypt_generic($this->ecb, $iv . $cb) ^ $cb;\n                    $iv = substr($cb, -$block_size);\n                    $len%= $block_size;\n                }\n                if ($len) {\n                    $iv = mcrypt_generic($this->ecb, $iv);\n                    $plaintext.= $iv ^ substr($ciphertext, -$len);\n                    $iv = substr_replace($iv, substr($ciphertext, -$len), 0, $len);\n                    $pos = $len;\n                }\n\n                return $plaintext;\n            }\n\n            $plaintext = mdecrypt_generic($this->demcrypt, $ciphertext);\n\n            if (!$this->continuousBuffer) {\n                mcrypt_generic_init($this->demcrypt, $this->key, $this->decryptIV);\n            }\n\n            return $this->paddable ? $this->_unpad($plaintext) : $plaintext;\n        }\n\n        if ($this->changed) {\n            $this->_setup();\n            $this->changed = false;\n        }\n        if ($this->use_inline_crypt) {\n            $inline = $this->inline_crypt;\n            return $inline('decrypt', $this, $ciphertext);\n        }\n\n        $block_size = $this->block_size;\n\n        $buffer = &$this->debuffer;\n        $plaintext = '';\n        switch ($this->mode) {\n            case self::MODE_ECB:\n                for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {\n                    $plaintext.= $this->_decryptBlock(substr($ciphertext, $i, $block_size));\n                }\n                break;\n            case self::MODE_CBC:\n                $xor = $this->decryptIV;\n                for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {\n                    $block = substr($ciphertext, $i, $block_size);\n                    $plaintext.= $this->_decryptBlock($block) ^ $xor;\n                    $xor = $block;\n                }\n                if ($this->continuousBuffer) {\n                    $this->decryptIV = $xor;\n                }\n                break;\n            case self::MODE_CTR:\n                $xor = $this->decryptIV;\n                if (strlen($buffer['ciphertext'])) {\n                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {\n                        $block = substr($ciphertext, $i, $block_size);\n                        if (strlen($block) > strlen($buffer['ciphertext'])) {\n                            $buffer['ciphertext'].= $this->_encryptBlock($xor);\n                            $this->_increment_str($xor);\n                        }\n                        $key = $this->_string_shift($buffer['ciphertext'], $block_size);\n                        $plaintext.= $block ^ $key;\n                    }\n                } else {\n                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {\n                        $block = substr($ciphertext, $i, $block_size);\n                        $key = $this->_encryptBlock($xor);\n                        $this->_increment_str($xor);\n                        $plaintext.= $block ^ $key;\n                    }\n                }\n                if ($this->continuousBuffer) {\n                    $this->decryptIV = $xor;\n                    if ($start = strlen($ciphertext) % $block_size) {\n                        $buffer['ciphertext'] = substr($key, $start) . $buffer['ciphertext'];\n                    }\n                }\n                break;\n            case self::MODE_CFB:\n                if ($this->continuousBuffer) {\n                    $iv = &$this->decryptIV;\n                    $pos = &$buffer['pos'];\n                } else {\n                    $iv = $this->decryptIV;\n                    $pos = 0;\n                }\n                $len = strlen($ciphertext);\n                $i = 0;\n                if ($pos) {\n                    $orig_pos = $pos;\n                    $max = $block_size - $pos;\n                    if ($len >= $max) {\n                        $i = $max;\n                        $len-= $max;\n                        $pos = 0;\n                    } else {\n                        $i = $len;\n                        $pos+= $len;\n                        $len = 0;\n                    }\n                    // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize\n                    $plaintext = substr($iv, $orig_pos) ^ $ciphertext;\n                    $iv = substr_replace($iv, substr($ciphertext, 0, $i), $orig_pos, $i);\n                }\n                while ($len >= $block_size) {\n                    $iv = $this->_encryptBlock($iv);\n                    $cb = substr($ciphertext, $i, $block_size);\n                    $plaintext.= $iv ^ $cb;\n                    $iv = $cb;\n                    $len-= $block_size;\n                    $i+= $block_size;\n                }\n                if ($len) {\n                    $iv = $this->_encryptBlock($iv);\n                    $plaintext.= $iv ^ substr($ciphertext, $i);\n                    $iv = substr_replace($iv, substr($ciphertext, $i), 0, $len);\n                    $pos = $len;\n                }\n                break;\n            case self::MODE_OFB:\n                $xor = $this->decryptIV;\n                if (strlen($buffer['xor'])) {\n                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {\n                        $block = substr($ciphertext, $i, $block_size);\n                        if (strlen($block) > strlen($buffer['xor'])) {\n                            $xor = $this->_encryptBlock($xor);\n                            $buffer['xor'].= $xor;\n                        }\n                        $key = $this->_string_shift($buffer['xor'], $block_size);\n                        $plaintext.= $block ^ $key;\n                    }\n                } else {\n                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {\n                        $xor = $this->_encryptBlock($xor);\n                        $plaintext.= substr($ciphertext, $i, $block_size) ^ $xor;\n                    }\n                    $key = $xor;\n                }\n                if ($this->continuousBuffer) {\n                    $this->decryptIV = $xor;\n                    if ($start = strlen($ciphertext) % $block_size) {\n                         $buffer['xor'] = substr($key, $start) . $buffer['xor'];\n                    }\n                }\n                break;\n            case self::MODE_STREAM:\n                $plaintext = $this->_decryptBlock($ciphertext);\n                break;\n        }\n        return $this->paddable ? $this->_unpad($plaintext) : $plaintext;\n    }\n\n    /**\n     * OpenSSL CTR Processor\n     *\n     * PHP's OpenSSL bindings do not operate in continuous mode so we'll wrap around it. Since the keystream\n     * for CTR is the same for both encrypting and decrypting this function is re-used by both Crypt_Base::encrypt()\n     * and Crypt_Base::decrypt(). Also, OpenSSL doesn't implement CTR for all of it's symmetric ciphers so this\n     * function will emulate CTR with ECB when necesary.\n     *\n     * @see Crypt_Base::encrypt()\n     * @see Crypt_Base::decrypt()\n     * @param String $plaintext\n     * @param String $encryptIV\n     * @param Array $buffer\n     * @return String\n     * @access private\n     */\n    function _openssl_ctr_process($plaintext, &$encryptIV, &$buffer)\n    {\n        $ciphertext = '';\n\n        $block_size = $this->block_size;\n        $key = $this->key;\n\n        if ($this->openssl_emulate_ctr) {\n            $xor = $encryptIV;\n            if (strlen($buffer['ciphertext'])) {\n                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                    $block = substr($plaintext, $i, $block_size);\n                    if (strlen($block) > strlen($buffer['ciphertext'])) {\n                        $result = openssl_encrypt($xor, $this->cipher_name_openssl_ecb, $key, $this->openssl_options);\n                        $result = !defined('OPENSSL_RAW_DATA') ? substr($result, 0, -$this->block_size) : $result;\n                        $buffer['ciphertext'].= $result;\n                    }\n                    $this->_increment_str($xor);\n                    $otp = $this->_string_shift($buffer['ciphertext'], $block_size);\n                    $ciphertext.= $block ^ $otp;\n                }\n            } else {\n                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                    $block = substr($plaintext, $i, $block_size);\n                    $otp = openssl_encrypt($xor, $this->cipher_name_openssl_ecb, $key, $this->openssl_options);\n                    $otp = !defined('OPENSSL_RAW_DATA') ? substr($otp, 0, -$this->block_size) : $otp;\n                    $this->_increment_str($xor);\n                    $ciphertext.= $block ^ $otp;\n                }\n            }\n            if ($this->continuousBuffer) {\n                $encryptIV = $xor;\n                if ($start = strlen($plaintext) % $block_size) {\n                    $buffer['ciphertext'] = substr($key, $start) . $buffer['ciphertext'];\n                }\n            }\n\n            return $ciphertext;\n        }\n\n        if (strlen($buffer['ciphertext'])) {\n            $ciphertext = $plaintext ^ $this->_string_shift($buffer['ciphertext'], strlen($plaintext));\n            $plaintext = substr($plaintext, strlen($ciphertext));\n\n            if (!strlen($plaintext)) {\n                return $ciphertext;\n            }\n        }\n\n        $overflow = strlen($plaintext) % $block_size;\n        if ($overflow) {\n            $plaintext2 = $this->_string_pop($plaintext, $overflow); // ie. trim $plaintext to a multiple of $block_size and put rest of $plaintext in $plaintext2\n            $encrypted = openssl_encrypt($plaintext . str_repeat(\"\\0\", $block_size), $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);\n            $temp = $this->_string_pop($encrypted, $block_size);\n            $ciphertext.= $encrypted . ($plaintext2 ^ $temp);\n            if ($this->continuousBuffer) {\n                $buffer['ciphertext'] = substr($temp, $overflow);\n                $encryptIV = $temp;\n            }\n        } elseif (!strlen($buffer['ciphertext'])) {\n            $ciphertext.= openssl_encrypt($plaintext . str_repeat(\"\\0\", $block_size), $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);\n            $temp = $this->_string_pop($ciphertext, $block_size);\n            if ($this->continuousBuffer) {\n                $encryptIV = $temp;\n            }\n        }\n        if ($this->continuousBuffer) {\n            if (!defined('OPENSSL_RAW_DATA')) {\n                $encryptIV.= openssl_encrypt('', $this->cipher_name_openssl_ecb, $key, $this->openssl_options);\n            }\n            $encryptIV = openssl_decrypt($encryptIV, $this->cipher_name_openssl_ecb, $key, $this->openssl_options);\n            if ($overflow) {\n                $this->_increment_str($encryptIV);\n            }\n        }\n\n        return $ciphertext;\n    }\n\n    /**\n     * OpenSSL OFB Processor\n     *\n     * PHP's OpenSSL bindings do not operate in continuous mode so we'll wrap around it. Since the keystream\n     * for OFB is the same for both encrypting and decrypting this function is re-used by both Crypt_Base::encrypt()\n     * and Crypt_Base::decrypt().\n     *\n     * @see Crypt_Base::encrypt()\n     * @see Crypt_Base::decrypt()\n     * @param String $plaintext\n     * @param String $encryptIV\n     * @param Array $buffer\n     * @return String\n     * @access private\n     */\n    function _openssl_ofb_process($plaintext, &$encryptIV, &$buffer)\n    {\n        if (strlen($buffer['xor'])) {\n            $ciphertext = $plaintext ^ $buffer['xor'];\n            $buffer['xor'] = substr($buffer['xor'], strlen($ciphertext));\n            $plaintext = substr($plaintext, strlen($ciphertext));\n        } else {\n            $ciphertext = '';\n        }\n\n        $block_size = $this->block_size;\n\n        $len = strlen($plaintext);\n        $key = $this->key;\n        $overflow = $len % $block_size;\n\n        if (strlen($plaintext)) {\n            if ($overflow) {\n                $ciphertext.= openssl_encrypt(substr($plaintext, 0, -$overflow) . str_repeat(\"\\0\", $block_size), $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);\n                $xor = $this->_string_pop($ciphertext, $block_size);\n                if ($this->continuousBuffer) {\n                    $encryptIV = $xor;\n                }\n                $ciphertext.= $this->_string_shift($xor, $overflow) ^ substr($plaintext, -$overflow);\n                if ($this->continuousBuffer) {\n                    $buffer['xor'] = $xor;\n                }\n            } else {\n                $ciphertext = openssl_encrypt($plaintext, $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);\n                if ($this->continuousBuffer) {\n                    $encryptIV = substr($ciphertext, -$block_size) ^ substr($plaintext, -$block_size);\n                }\n            }\n        }\n\n        return $ciphertext;\n    }\n\n    /**\n     * phpseclib <-> OpenSSL Mode Mapper\n     *\n     * May need to be overwritten by classes extending this one in some cases\n     *\n     * @return Integer\n     * @access private\n     */\n    function _openssl_translate_mode()\n    {\n        switch ($this->mode) {\n            case self::MODE_ECB:\n                return 'ecb';\n            case self::MODE_CBC:\n                return 'cbc';\n            case self::MODE_CTR:\n                return 'ctr';\n            case self::MODE_CFB:\n                return 'cfb';\n            case self::MODE_OFB:\n                return 'ofb';\n        }\n    }\n\n    /**\n     * Pad \"packets\".\n     *\n     * Block ciphers working by encrypting between their specified [$this->]block_size at a time\n     * If you ever need to encrypt or decrypt something that isn't of the proper length, it becomes necessary to\n     * pad the input so that it is of the proper length.\n     *\n     * Padding is enabled by default.  Sometimes, however, it is undesirable to pad strings.  Such is the case in SSH,\n     * where \"packets\" are padded with random bytes before being encrypted.  Unpad these packets and you risk stripping\n     * away characters that shouldn't be stripped away. (SSH knows how many bytes are added because the length is\n     * transmitted separately)\n     *\n     * @see \\phpseclib\\Crypt\\Base::disablePadding()\n     * @access public\n     */\n    function enablePadding()\n    {\n        $this->padding = true;\n    }\n\n    /**\n     * Do not pad packets.\n     *\n     * @see \\phpseclib\\Crypt\\Base::enablePadding()\n     * @access public\n     */\n    function disablePadding()\n    {\n        $this->padding = false;\n    }\n\n    /**\n     * Treat consecutive \"packets\" as if they are a continuous buffer.\n     *\n     * Say you have a 32-byte plaintext $plaintext.  Using the default behavior, the two following code snippets\n     * will yield different outputs:\n     *\n     * <code>\n     *    echo $rijndael->encrypt(substr($plaintext,  0, 16));\n     *    echo $rijndael->encrypt(substr($plaintext, 16, 16));\n     * </code>\n     * <code>\n     *    echo $rijndael->encrypt($plaintext);\n     * </code>\n     *\n     * The solution is to enable the continuous buffer.  Although this will resolve the above discrepancy, it creates\n     * another, as demonstrated with the following:\n     *\n     * <code>\n     *    $rijndael->encrypt(substr($plaintext, 0, 16));\n     *    echo $rijndael->decrypt($rijndael->encrypt(substr($plaintext, 16, 16)));\n     * </code>\n     * <code>\n     *    echo $rijndael->decrypt($rijndael->encrypt(substr($plaintext, 16, 16)));\n     * </code>\n     *\n     * With the continuous buffer disabled, these would yield the same output.  With it enabled, they yield different\n     * outputs.  The reason is due to the fact that the initialization vector's change after every encryption /\n     * decryption round when the continuous buffer is enabled.  When it's disabled, they remain constant.\n     *\n     * Put another way, when the continuous buffer is enabled, the state of the \\phpseclib\\Crypt\\*() object changes after each\n     * encryption / decryption round, whereas otherwise, it'd remain constant.  For this reason, it's recommended that\n     * continuous buffers not be used.  They do offer better security and are, in fact, sometimes required (SSH uses them),\n     * however, they are also less intuitive and more likely to cause you problems.\n     *\n     * @see \\phpseclib\\Crypt\\Base::disableContinuousBuffer()\n     * @access public\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function enableContinuousBuffer()\n    {\n        if ($this->mode == self::MODE_ECB) {\n            return;\n        }\n\n        $this->continuousBuffer = true;\n\n        $this->_setEngine();\n    }\n\n    /**\n     * Treat consecutive packets as if they are a discontinuous buffer.\n     *\n     * The default behavior.\n     *\n     * @see \\phpseclib\\Crypt\\Base::enableContinuousBuffer()\n     * @access public\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function disableContinuousBuffer()\n    {\n        if ($this->mode == self::MODE_ECB) {\n            return;\n        }\n        if (!$this->continuousBuffer) {\n            return;\n        }\n\n        $this->continuousBuffer = false;\n        $this->changed = true;\n\n        $this->_setEngine();\n    }\n\n    /**\n     * Test for engine validity\n     *\n     * @see \\phpseclib\\Crypt\\Base::Crypt_Base()\n     * @param Integer $engine\n     * @access public\n     * @return Boolean\n     */\n    function isValidEngine($engine)\n    {\n        switch ($engine) {\n            case self::ENGINE_OPENSSL:\n                if ($this->mode == self::MODE_STREAM && $this->continuousBuffer) {\n                    return false;\n                }\n                $this->openssl_emulate_ctr = false;\n                $result = $this->cipher_name_openssl &&\n                          extension_loaded('openssl') &&\n                          // PHP 5.3.0 - 5.3.2 did not let you set IV's\n                          version_compare(PHP_VERSION, '5.3.3', '>=');\n                if (!$result) {\n                    return false;\n                }\n\n                // prior to PHP 5.4.0 OPENSSL_RAW_DATA and OPENSSL_ZERO_PADDING were not defined. instead of expecting an integer\n                // $options openssl_encrypt expected a boolean $raw_data.\n                if (!defined('OPENSSL_RAW_DATA')) {\n                    $this->openssl_options = true;\n                } else {\n                    $this->openssl_options = OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING;\n                }\n\n                $methods = openssl_get_cipher_methods();\n                if (in_array($this->cipher_name_openssl, $methods)) {\n                    return true;\n                }\n                // not all of openssl's symmetric cipher's support ctr. for those\n                // that don't we'll emulate it\n                switch ($this->mode) {\n                    case self::MODE_CTR:\n                        if (in_array($this->cipher_name_openssl_ecb, $methods)) {\n                            $this->openssl_emulate_ctr = true;\n                            return true;\n                        }\n                }\n                return false;\n            case self::ENGINE_MCRYPT:\n                return $this->cipher_name_mcrypt &&\n                       extension_loaded('mcrypt') &&\n                       in_array($this->cipher_name_mcrypt, mcrypt_list_algorithms());\n            case self::ENGINE_INTERNAL:\n                return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Sets the preferred crypt engine\n     *\n     * Currently, $engine could be:\n     *\n     * - \\phpseclib\\Crypt\\Base::ENGINE_OPENSSL  [very fast]\n     *\n     * - \\phpseclib\\Crypt\\Base::ENGINE_MCRYPT   [fast]\n     *\n     * - \\phpseclib\\Crypt\\Base::ENGINE_INTERNAL [slow]\n     *\n     * If the preferred crypt engine is not available the fastest available one will be used\n     *\n     * @see \\phpseclib\\Crypt\\Base::Crypt_Base()\n     * @param Integer $engine\n     * @access public\n     */\n    function setPreferredEngine($engine)\n    {\n        switch ($engine) {\n            //case self::ENGINE_OPENSSL;\n            case self::ENGINE_MCRYPT:\n            case self::ENGINE_INTERNAL:\n                $this->preferredEngine = $engine;\n                break;\n            default:\n                $this->preferredEngine = self::ENGINE_OPENSSL;\n        }\n\n        $this->_setEngine();\n    }\n\n    /**\n     * Returns the engine currently being utilized\n     *\n     * @see \\phpseclib\\Crypt\\Base::_setEngine()\n     * @access public\n     */\n    function getEngine()\n    {\n        return $this->engine;\n    }\n\n    /**\n     * Sets the engine as appropriate\n     *\n     * @see \\phpseclib\\Crypt\\Base::Crypt_Base()\n     * @access private\n     */\n    function _setEngine()\n    {\n        $this->engine = null;\n\n        $candidateEngines = array(\n            $this->preferredEngine,\n            self::ENGINE_OPENSSL,\n            self::ENGINE_MCRYPT\n        );\n        foreach ($candidateEngines as $engine) {\n            if ($this->isValidEngine($engine)) {\n                $this->engine = $engine;\n                break;\n            }\n        }\n        if (!$this->engine) {\n            $this->engine = self::ENGINE_INTERNAL;\n        }\n\n        if ($this->engine != self::ENGINE_MCRYPT && $this->enmcrypt) {\n            // Closing the current mcrypt resource(s). _mcryptSetup() will, if needed,\n            // (re)open them with the module named in $this->cipher_name_mcrypt\n            mcrypt_module_close($this->enmcrypt);\n            mcrypt_module_close($this->demcrypt);\n            $this->enmcrypt = null;\n            $this->demcrypt = null;\n\n            if ($this->ecb) {\n                mcrypt_module_close($this->ecb);\n                $this->ecb = null;\n            }\n        }\n\n        $this->changed = true;\n    }\n\n    /**\n     * Encrypts a block\n     *\n     * Note: Must be extended by the child \\phpseclib\\Crypt\\* class\n     *\n     * @access private\n     * @param String $in\n     * @return String\n     */\n    abstract function _encryptBlock($in);\n\n    /**\n     * Decrypts a block\n     *\n     * Note: Must be extended by the child \\phpseclib\\Crypt\\* class\n     *\n     * @access private\n     * @param String $in\n     * @return String\n     */\n    abstract function _decryptBlock($in);\n\n    /**\n     * Setup the key (expansion)\n     *\n     * Only used if $engine == self::ENGINE_INTERNAL\n     *\n     * Note: Must extend by the child \\phpseclib\\Crypt\\* class\n     *\n     * @see \\phpseclib\\Crypt\\Base::_setup()\n     * @access private\n     */\n    abstract function _setupKey();\n\n    /**\n     * Setup the self::ENGINE_INTERNAL $engine\n     *\n     * (re)init, if necessary, the internal cipher $engine and flush all $buffers\n     * Used (only) if $engine == self::ENGINE_INTERNAL\n     *\n     * _setup() will be called each time if $changed === true\n     * typically this happens when using one or more of following public methods:\n     *\n     * - setKey()\n     *\n     * - setIV()\n     *\n     * - disableContinuousBuffer()\n     *\n     * - First run of encrypt() / decrypt() with no init-settings\n     *\n     * @see setKey()\n     * @see setIV()\n     * @see disableContinuousBuffer()\n     * @access private\n     * @internal _setup() is always called before en/decryption.\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function _setup()\n    {\n        $this->_clearBuffers();\n        $this->_setupKey();\n\n        if ($this->use_inline_crypt) {\n            $this->_setupInlineCrypt();\n        }\n    }\n\n    /**\n     * Setup the self::ENGINE_MCRYPT $engine\n     *\n     * (re)init, if necessary, the (ext)mcrypt resources and flush all $buffers\n     * Used (only) if $engine = self::ENGINE_MCRYPT\n     *\n     * _setupMcrypt() will be called each time if $changed === true\n     * typically this happens when using one or more of following public methods:\n     *\n     * - setKey()\n     *\n     * - setIV()\n     *\n     * - disableContinuousBuffer()\n     *\n     * - First run of encrypt() / decrypt()\n     *\n     * @see setKey()\n     * @see setIV()\n     * @see disableContinuousBuffer()\n     * @access private\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function _setupMcrypt()\n    {\n        $this->_clearBuffers();\n        $this->enchanged = $this->dechanged = true;\n\n        if (!isset($this->enmcrypt)) {\n            static $mcrypt_modes = array(\n                self::MODE_CTR    => 'ctr',\n                self::MODE_ECB    => MCRYPT_MODE_ECB,\n                self::MODE_CBC    => MCRYPT_MODE_CBC,\n                self::MODE_CFB    => 'ncfb',\n                self::MODE_OFB    => MCRYPT_MODE_NOFB,\n                self::MODE_STREAM => MCRYPT_MODE_STREAM,\n            );\n\n            $this->demcrypt = mcrypt_module_open($this->cipher_name_mcrypt, '', $mcrypt_modes[$this->mode], '');\n            $this->enmcrypt = mcrypt_module_open($this->cipher_name_mcrypt, '', $mcrypt_modes[$this->mode], '');\n\n            // we need the $ecb mcrypt resource (only) in MODE_CFB with enableContinuousBuffer()\n            // to workaround mcrypt's broken ncfb implementation in buffered mode\n            // see: {@link http://phpseclib.sourceforge.net/cfb-demo.phps}\n            if ($this->mode == self::MODE_CFB) {\n                $this->ecb = mcrypt_module_open($this->cipher_name_mcrypt, '', MCRYPT_MODE_ECB, '');\n            }\n\n        } // else should mcrypt_generic_deinit be called?\n\n        if ($this->mode == self::MODE_CFB) {\n            mcrypt_generic_init($this->ecb, $this->key, str_repeat(\"\\0\", $this->block_size));\n        }\n    }\n\n    /**\n     * Pads a string\n     *\n     * Pads a string using the RSA PKCS padding standards so that its length is a multiple of the blocksize.\n     * $this->block_size - (strlen($text) % $this->block_size) bytes are added, each of which is equal to\n     * chr($this->block_size - (strlen($text) % $this->block_size)\n     *\n     * If padding is disabled and $text is not a multiple of the blocksize, the string will be padded regardless\n     * and padding will, hence forth, be enabled.\n     *\n     * @see \\phpseclib\\Crypt\\Base::_unpad()\n     * @param String $text\n     * @access private\n     * @return String\n     */\n    function _pad($text)\n    {\n        $length = strlen($text);\n\n        if (!$this->padding) {\n            if ($length % $this->block_size == 0) {\n                return $text;\n            } else {\n                user_error(\"The plaintext's length ($length) is not a multiple of the block size ({$this->block_size})\");\n                $this->padding = true;\n            }\n        }\n\n        $pad = $this->block_size - ($length % $this->block_size);\n\n        return str_pad($text, $length + $pad, chr($pad));\n    }\n\n    /**\n     * Unpads a string.\n     *\n     * If padding is enabled and the reported padding length is invalid the encryption key will be assumed to be wrong\n     * and false will be returned.\n     *\n     * @see \\phpseclib\\Crypt\\Base::_pad()\n     * @param String $text\n     * @access private\n     * @return String\n     */\n    function _unpad($text)\n    {\n        if (!$this->padding) {\n            return $text;\n        }\n\n        $length = ord($text[strlen($text) - 1]);\n\n        if (!$length || $length > $this->block_size) {\n            return false;\n        }\n\n        return substr($text, 0, -$length);\n    }\n\n    /**\n     * Clears internal buffers\n     *\n     * Clearing/resetting the internal buffers is done everytime\n     * after disableContinuousBuffer() or on cipher $engine (re)init\n     * ie after setKey() or setIV()\n     *\n     * @access public\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function _clearBuffers()\n    {\n        $this->enbuffer = $this->debuffer = array('ciphertext' => '', 'xor' => '', 'pos' => 0, 'enmcrypt_init' => true);\n\n        // mcrypt's handling of invalid's $iv:\n        // $this->encryptIV = $this->decryptIV = strlen($this->iv) == $this->block_size ? $this->iv : str_repeat(\"\\0\", $this->block_size);\n        $this->encryptIV = $this->decryptIV = str_pad(substr($this->iv, 0, $this->block_size), $this->block_size, \"\\0\");\n    }\n\n    /**\n     * String Shift\n     *\n     * Inspired by array_shift\n     *\n     * @param String $string\n     * @param optional Integer $index\n     * @access private\n     * @return String\n     */\n    function _string_shift(&$string, $index = 1)\n    {\n        $substr = substr($string, 0, $index);\n        $string = substr($string, $index);\n        return $substr;\n    }\n\n    /**\n     * String Pop\n     *\n     * Inspired by array_pop\n     *\n     * @param String $string\n     * @param optional Integer $index\n     * @access private\n     * @return String\n     */\n    function _string_pop(&$string, $index = 1)\n    {\n        $substr = substr($string, -$index);\n        $string = substr($string, 0, -$index);\n        return $substr;\n    }\n\n    /**\n     * Increment the current string\n     *\n     * @see \\phpseclib\\Crypt\\Base::decrypt()\n     * @see \\phpseclib\\Crypt\\Base::encrypt()\n     * @param String $var\n     * @access private\n     */\n    function _increment_str(&$var)\n    {\n        for ($i = 4; $i <= strlen($var); $i+= 4) {\n            $temp = substr($var, -$i, 4);\n            switch ($temp) {\n                case \"\\xFF\\xFF\\xFF\\xFF\":\n                    $var = substr_replace($var, \"\\x00\\x00\\x00\\x00\", -$i, 4);\n                    break;\n                case \"\\x7F\\xFF\\xFF\\xFF\":\n                    $var = substr_replace($var, \"\\x80\\x00\\x00\\x00\", -$i, 4);\n                    return;\n                default:\n                    $temp = unpack('Nnum', $temp);\n                    $var = substr_replace($var, pack('N', $temp['num'] + 1), -$i, 4);\n                    return;\n            }\n        }\n\n        $remainder = strlen($var) % 4;\n\n        if ($remainder == 0) {\n            return;\n        }\n\n        $temp = unpack('Nnum', str_pad(substr($var, 0, $remainder), 4, \"\\0\", STR_PAD_LEFT));\n        $temp = substr(pack('N', $temp['num'] + 1), -$remainder);\n        $var = substr_replace($var, $temp, 0, $remainder);\n    }\n\n    /**\n     * Setup the performance-optimized function for de/encrypt()\n     *\n     * Stores the created (or existing) callback function-name\n     * in $this->inline_crypt\n     *\n     * Internally for phpseclib developers:\n     *\n     *     _setupInlineCrypt() would be called only if:\n     *\n     *     - $engine == self::ENGINE_INTERNAL and\n     *\n     *     - $use_inline_crypt === true\n     *\n     *     - each time on _setup(), after(!) _setupKey()\n     *\n     *\n     *     This ensures that _setupInlineCrypt() has always a\n     *     full ready2go initializated internal cipher $engine state\n     *     where, for example, the keys allready expanded,\n     *     keys/block_size calculated and such.\n     *\n     *     It is, each time if called, the responsibility of _setupInlineCrypt():\n     *\n     *     - to set $this->inline_crypt to a valid and fully working callback function\n     *       as a (faster) replacement for encrypt() / decrypt()\n     *\n     *     - NOT to create unlimited callback functions (for memory reasons!)\n     *       no matter how often _setupInlineCrypt() would be called. At some\n     *       point of amount they must be generic re-useable.\n     *\n     *     - the code of _setupInlineCrypt() it self,\n     *       and the generated callback code,\n     *       must be, in following order:\n     *       - 100% safe\n     *       - 100% compatible to encrypt()/decrypt()\n     *       - using only php5+ features/lang-constructs/php-extensions if\n     *         compatibility (down to php4) or fallback is provided\n     *       - readable/maintainable/understandable/commented and... not-cryptic-styled-code :-)\n     *       - >= 10% faster than encrypt()/decrypt() [which is, by the way,\n     *         the reason for the existence of _setupInlineCrypt() :-)]\n     *       - memory-nice\n     *       - short (as good as possible)\n     *\n     * Note: - _setupInlineCrypt() is using _createInlineCryptFunction() to create the full callback function code.\n     *       - In case of using inline crypting, _setupInlineCrypt() must extend by the child \\phpseclib\\Crypt\\* class.\n     *       - The following variable names are reserved:\n     *         - $_*  (all variable names prefixed with an underscore)\n     *         - $self (object reference to it self. Do not use $this, but $self instead)\n     *         - $in (the content of $in has to en/decrypt by the generated code)\n     *       - The callback function should not use the 'return' statement, but en/decrypt'ing the content of $in only\n     *\n     *\n     * @see \\phpseclib\\Crypt\\Base::_setup()\n     * @see \\phpseclib\\Crypt\\Base::_createInlineCryptFunction()\n     * @see \\phpseclib\\Crypt\\Base::encrypt()\n     * @see \\phpseclib\\Crypt\\Base::decrypt()\n     * @access private\n     * @internal If a Crypt_* class providing inline crypting it must extend _setupInlineCrypt()\n     */\n    function _setupInlineCrypt()\n    {\n        // If, for any reason, an extending \\phpseclib\\Crypt\\Base() \\phpseclib\\Crypt\\* class\n        // not using inline crypting then it must be ensured that: $this->use_inline_crypt = false\n        // ie in the class var declaration of $use_inline_crypt in general for the \\phpseclib\\Crypt\\* class,\n        // in the constructor at object instance-time\n        // or, if it's runtime-specific, at runtime\n\n        $this->use_inline_crypt = false;\n    }\n\n    /**\n     * Creates the performance-optimized function for en/decrypt()\n     *\n     * Internally for phpseclib developers:\n     *\n     *    _createInlineCryptFunction():\n     *\n     *    - merge the $cipher_code [setup'ed by _setupInlineCrypt()]\n     *      with the current [$this->]mode of operation code\n     *\n     *    - create the $inline function, which called by encrypt() / decrypt()\n     *      as its replacement to speed up the en/decryption operations.\n     *\n     *    - return the name of the created $inline callback function\n     *\n     *    - used to speed up en/decryption\n     *\n     *\n     *\n     *    The main reason why can speed up things [up to 50%] this way are:\n     *\n     *    - using variables more effective then regular.\n     *      (ie no use of expensive arrays but integers $k_0, $k_1 ...\n     *      or even, for example, the pure $key[] values hardcoded)\n     *\n     *    - avoiding 1000's of function calls of ie _encryptBlock()\n     *      but inlining the crypt operations.\n     *      in the mode of operation for() loop.\n     *\n     *    - full loop unroll the (sometimes key-dependent) rounds\n     *      avoiding this way ++$i counters and runtime-if's etc...\n     *\n     *    The basic code architectur of the generated $inline en/decrypt()\n     *    lambda function, in pseudo php, is:\n     *\n     *    <code>\n     *    +----------------------------------------------------------------------------------------------+\n     *    | callback $inline = create_function:                                                          |\n     *    | lambda_function_0001_crypt_ECB($action, $text)                                               |\n     *    | {                                                                                            |\n     *    |     INSERT PHP CODE OF:                                                                      |\n     *    |     $cipher_code['init_crypt'];                  // general init code.                       |\n     *    |                                                  // ie: $sbox'es declarations used for       |\n     *    |                                                  //     encrypt and decrypt'ing.             |\n     *    |                                                                                              |\n     *    |     switch ($action) {                                                                       |\n     *    |         case 'encrypt':                                                                      |\n     *    |             INSERT PHP CODE OF:                                                              |\n     *    |             $cipher_code['init_encrypt'];       // encrypt sepcific init code.               |\n     *    |                                                    ie: specified $key or $box                |\n     *    |                                                        declarations for encrypt'ing.         |\n     *    |                                                                                              |\n     *    |             foreach ($ciphertext) {                                                          |\n     *    |                 $in = $block_size of $ciphertext;                                            |\n     *    |                                                                                              |\n     *    |                 INSERT PHP CODE OF:                                                          |\n     *    |                 $cipher_code['encrypt_block'];  // encrypt's (string) $in, which is always:  |\n     *    |                                                 // strlen($in) == $this->block_size          |\n     *    |                                                 // here comes the cipher algorithm in action |\n     *    |                                                 // for encryption.                           |\n     *    |                                                 // $cipher_code['encrypt_block'] has to      |\n     *    |                                                 // encrypt the content of the $in variable   |\n     *    |                                                                                              |\n     *    |                 $plaintext .= $in;                                                           |\n     *    |             }                                                                                |\n     *    |             return $plaintext;                                                               |\n     *    |                                                                                              |\n     *    |         case 'decrypt':                                                                      |\n     *    |             INSERT PHP CODE OF:                                                              |\n     *    |             $cipher_code['init_decrypt'];       // decrypt sepcific init code                |\n     *    |                                                    ie: specified $key or $box                |\n     *    |                                                        declarations for decrypt'ing.         |\n     *    |             foreach ($plaintext) {                                                           |\n     *    |                 $in = $block_size of $plaintext;                                             |\n     *    |                                                                                              |\n     *    |                 INSERT PHP CODE OF:                                                          |\n     *    |                 $cipher_code['decrypt_block'];  // decrypt's (string) $in, which is always   |\n     *    |                                                 // strlen($in) == $this->block_size          |\n     *    |                                                 // here comes the cipher algorithm in action |\n     *    |                                                 // for decryption.                           |\n     *    |                                                 // $cipher_code['decrypt_block'] has to      |\n     *    |                                                 // decrypt the content of the $in variable   |\n     *    |                 $ciphertext .= $in;                                                          |\n     *    |             }                                                                                |\n     *    |             return $ciphertext;                                                              |\n     *    |     }                                                                                        |\n     *    | }                                                                                            |\n     *    +----------------------------------------------------------------------------------------------+\n     *    </code>\n     *\n     *    See also the \\phpseclib\\Crypt\\*::_setupInlineCrypt()'s for\n     *    productive inline $cipher_code's how they works.\n     *\n     *    Structure of:\n     *    <code>\n     *    $cipher_code = array(\n     *        'init_crypt'    => (string) '', // optional\n     *        'init_encrypt'  => (string) '', // optional\n     *        'init_decrypt'  => (string) '', // optional\n     *        'encrypt_block' => (string) '', // required\n     *        'decrypt_block' => (string) ''  // required\n     *    );\n     *    </code>\n     *\n     * @see \\phpseclib\\Crypt\\Base::_setupInlineCrypt()\n     * @see \\phpseclib\\Crypt\\Base::encrypt()\n     * @see \\phpseclib\\Crypt\\Base::decrypt()\n     * @param Array $cipher_code\n     * @access private\n     * @return String (the name of the created callback function)\n     */\n    function _createInlineCryptFunction($cipher_code)\n    {\n        $block_size = $this->block_size;\n\n        // optional\n        $init_crypt    = isset($cipher_code['init_crypt'])    ? $cipher_code['init_crypt']    : '';\n        $init_encrypt  = isset($cipher_code['init_encrypt'])  ? $cipher_code['init_encrypt']  : '';\n        $init_decrypt  = isset($cipher_code['init_decrypt'])  ? $cipher_code['init_decrypt']  : '';\n        // required\n        $encrypt_block = $cipher_code['encrypt_block'];\n        $decrypt_block = $cipher_code['decrypt_block'];\n\n        // Generating mode of operation inline code,\n        // merged with the $cipher_code algorithm\n        // for encrypt- and decryption.\n        switch ($this->mode) {\n            case self::MODE_ECB:\n                $encrypt = $init_encrypt . '\n                    $_ciphertext = \"\";\n                    $_plaintext_len = strlen($_text);\n\n                    for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {\n                        $in = substr($_text, $_i, '.$block_size.');\n                        '.$encrypt_block.'\n                        $_ciphertext.= $in;\n                    }\n\n                    return $_ciphertext;\n                    ';\n\n                $decrypt = $init_decrypt . '\n                    $_plaintext = \"\";\n                    $_text = str_pad($_text, strlen($_text) + ('.$block_size.' - strlen($_text) % '.$block_size.') % '.$block_size.', chr(0));\n                    $_ciphertext_len = strlen($_text);\n\n                    for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {\n                        $in = substr($_text, $_i, '.$block_size.');\n                        '.$decrypt_block.'\n                        $_plaintext.= $in;\n                    }\n\n                    return $self->_unpad($_plaintext);\n                    ';\n                break;\n            case self::MODE_CTR:\n                $encrypt = $init_encrypt . '\n                    $_ciphertext = \"\";\n                    $_plaintext_len = strlen($_text);\n                    $_xor = $self->encryptIV;\n                    $_buffer = &$self->enbuffer;\n                    if (strlen($_buffer[\"ciphertext\"])) {\n                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {\n                            $_block = substr($_text, $_i, '.$block_size.');\n                            if (strlen($_block) > strlen($_buffer[\"ciphertext\"])) {\n                                $in = $_xor;\n                                '.$encrypt_block.'\n                                $self->_increment_str($_xor);\n                                $_buffer[\"ciphertext\"].= $in;\n                            }\n                            $_key = $self->_string_shift($_buffer[\"ciphertext\"], '.$block_size.');\n                            $_ciphertext.= $_block ^ $_key;\n                        }\n                    } else {\n                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {\n                            $_block = substr($_text, $_i, '.$block_size.');\n                            $in = $_xor;\n                            '.$encrypt_block.'\n                            $self->_increment_str($_xor);\n                            $_key = $in;\n                            $_ciphertext.= $_block ^ $_key;\n                        }\n                    }\n                    if ($self->continuousBuffer) {\n                        $self->encryptIV = $_xor;\n                        if ($_start = $_plaintext_len % '.$block_size.') {\n                            $_buffer[\"ciphertext\"] = substr($_key, $_start) . $_buffer[\"ciphertext\"];\n                        }\n                    }\n\n                    return $_ciphertext;\n                ';\n\n                $decrypt = $init_encrypt . '\n                    $_plaintext = \"\";\n                    $_ciphertext_len = strlen($_text);\n                    $_xor = $self->decryptIV;\n                    $_buffer = &$self->debuffer;\n\n                    if (strlen($_buffer[\"ciphertext\"])) {\n                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {\n                            $_block = substr($_text, $_i, '.$block_size.');\n                            if (strlen($_block) > strlen($_buffer[\"ciphertext\"])) {\n                                $in = $_xor;\n                                '.$encrypt_block.'\n                                $self->_increment_str($_xor);\n                                $_buffer[\"ciphertext\"].= $in;\n                            }\n                            $_key = $self->_string_shift($_buffer[\"ciphertext\"], '.$block_size.');\n                            $_plaintext.= $_block ^ $_key;\n                        }\n                    } else {\n                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {\n                            $_block = substr($_text, $_i, '.$block_size.');\n                            $in = $_xor;\n                            '.$encrypt_block.'\n                            $self->_increment_str($_xor);\n                            $_key = $in;\n                            $_plaintext.= $_block ^ $_key;\n                        }\n                    }\n                    if ($self->continuousBuffer) {\n                        $self->decryptIV = $_xor;\n                        if ($_start = $_ciphertext_len % '.$block_size.') {\n                            $_buffer[\"ciphertext\"] = substr($_key, $_start) . $_buffer[\"ciphertext\"];\n                        }\n                    }\n\n                    return $_plaintext;\n                    ';\n                break;\n            case self::MODE_CFB:\n                $encrypt = $init_encrypt . '\n                    $_ciphertext = \"\";\n                    $_buffer = &$self->enbuffer;\n\n                    if ($self->continuousBuffer) {\n                        $_iv = &$self->encryptIV;\n                        $_pos = &$_buffer[\"pos\"];\n                    } else {\n                        $_iv = $self->encryptIV;\n                        $_pos = 0;\n                    }\n                    $_len = strlen($_text);\n                    $_i = 0;\n                    if ($_pos) {\n                        $_orig_pos = $_pos;\n                        $_max = '.$block_size.' - $_pos;\n                        if ($_len >= $_max) {\n                            $_i = $_max;\n                            $_len-= $_max;\n                            $_pos = 0;\n                        } else {\n                            $_i = $_len;\n                            $_pos+= $_len;\n                            $_len = 0;\n                        }\n                        $_ciphertext = substr($_iv, $_orig_pos) ^ $_text;\n                        $_iv = substr_replace($_iv, $_ciphertext, $_orig_pos, $_i);\n                    }\n                    while ($_len >= '.$block_size.') {\n                        $in = $_iv;\n                        '.$encrypt_block.';\n                        $_iv = $in ^ substr($_text, $_i, '.$block_size.');\n                        $_ciphertext.= $_iv;\n                        $_len-= '.$block_size.';\n                        $_i+= '.$block_size.';\n                    }\n                    if ($_len) {\n                        $in = $_iv;\n                        '.$encrypt_block.'\n                        $_iv = $in;\n                        $_block = $_iv ^ substr($_text, $_i);\n                        $_iv = substr_replace($_iv, $_block, 0, $_len);\n                        $_ciphertext.= $_block;\n                        $_pos = $_len;\n                    }\n                    return $_ciphertext;\n                ';\n\n                $decrypt = $init_encrypt . '\n                    $_plaintext = \"\";\n                    $_buffer = &$self->debuffer;\n\n                    if ($self->continuousBuffer) {\n                        $_iv = &$self->decryptIV;\n                        $_pos = &$_buffer[\"pos\"];\n                    } else {\n                        $_iv = $self->decryptIV;\n                        $_pos = 0;\n                    }\n                    $_len = strlen($_text);\n                    $_i = 0;\n                    if ($_pos) {\n                        $_orig_pos = $_pos;\n                        $_max = '.$block_size.' - $_pos;\n                        if ($_len >= $_max) {\n                            $_i = $_max;\n                            $_len-= $_max;\n                            $_pos = 0;\n                        } else {\n                            $_i = $_len;\n                            $_pos+= $_len;\n                            $_len = 0;\n                        }\n                        $_plaintext = substr($_iv, $_orig_pos) ^ $_text;\n                        $_iv = substr_replace($_iv, substr($_text, 0, $_i), $_orig_pos, $_i);\n                    }\n                    while ($_len >= '.$block_size.') {\n                        $in = $_iv;\n                        '.$encrypt_block.'\n                        $_iv = $in;\n                        $cb = substr($_text, $_i, '.$block_size.');\n                        $_plaintext.= $_iv ^ $cb;\n                        $_iv = $cb;\n                        $_len-= '.$block_size.';\n                        $_i+= '.$block_size.';\n                    }\n                    if ($_len) {\n                        $in = $_iv;\n                        '.$encrypt_block.'\n                        $_iv = $in;\n                        $_plaintext.= $_iv ^ substr($_text, $_i);\n                        $_iv = substr_replace($_iv, substr($_text, $_i), 0, $_len);\n                        $_pos = $_len;\n                    }\n\n                    return $_plaintext;\n                    ';\n                break;\n            case self::MODE_OFB:\n                $encrypt = $init_encrypt . '\n                    $_ciphertext = \"\";\n                    $_plaintext_len = strlen($_text);\n                    $_xor = $self->encryptIV;\n                    $_buffer = &$self->enbuffer;\n\n                    if (strlen($_buffer[\"xor\"])) {\n                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {\n                            $_block = substr($_text, $_i, '.$block_size.');\n                            if (strlen($_block) > strlen($_buffer[\"xor\"])) {\n                                $in = $_xor;\n                                '.$encrypt_block.'\n                                $_xor = $in;\n                                $_buffer[\"xor\"].= $_xor;\n                            }\n                            $_key = $self->_string_shift($_buffer[\"xor\"], '.$block_size.');\n                            $_ciphertext.= $_block ^ $_key;\n                        }\n                    } else {\n                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {\n                            $in = $_xor;\n                            '.$encrypt_block.'\n                            $_xor = $in;\n                            $_ciphertext.= substr($_text, $_i, '.$block_size.') ^ $_xor;\n                        }\n                        $_key = $_xor;\n                    }\n                    if ($self->continuousBuffer) {\n                        $self->encryptIV = $_xor;\n                        if ($_start = $_plaintext_len % '.$block_size.') {\n                             $_buffer[\"xor\"] = substr($_key, $_start) . $_buffer[\"xor\"];\n                        }\n                    }\n                    return $_ciphertext;\n                    ';\n\n                $decrypt = $init_encrypt . '\n                    $_plaintext = \"\";\n                    $_ciphertext_len = strlen($_text);\n                    $_xor = $self->decryptIV;\n                    $_buffer = &$self->debuffer;\n\n                    if (strlen($_buffer[\"xor\"])) {\n                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {\n                            $_block = substr($_text, $_i, '.$block_size.');\n                            if (strlen($_block) > strlen($_buffer[\"xor\"])) {\n                                $in = $_xor;\n                                '.$encrypt_block.'\n                                $_xor = $in;\n                                $_buffer[\"xor\"].= $_xor;\n                            }\n                            $_key = $self->_string_shift($_buffer[\"xor\"], '.$block_size.');\n                            $_plaintext.= $_block ^ $_key;\n                        }\n                    } else {\n                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {\n                            $in = $_xor;\n                            '.$encrypt_block.'\n                            $_xor = $in;\n                            $_plaintext.= substr($_text, $_i, '.$block_size.') ^ $_xor;\n                        }\n                        $_key = $_xor;\n                    }\n                    if ($self->continuousBuffer) {\n                        $self->decryptIV = $_xor;\n                        if ($_start = $_ciphertext_len % '.$block_size.') {\n                             $_buffer[\"xor\"] = substr($_key, $_start) . $_buffer[\"xor\"];\n                        }\n                    }\n                    return $_plaintext;\n                    ';\n                break;\n            case self::MODE_STREAM:\n                $encrypt = $init_encrypt . '\n                    $_ciphertext = \"\";\n                    '.$encrypt_block.'\n                    return $_ciphertext;\n                    ';\n                $decrypt = $init_decrypt . '\n                    $_plaintext = \"\";\n                    '.$decrypt_block.'\n                    return $_plaintext;\n                    ';\n                break;\n            // case self::MODE_CBC:\n            default:\n                $encrypt = $init_encrypt . '\n                    $_ciphertext = \"\";\n                    $_plaintext_len = strlen($_text);\n\n                    $in = $self->encryptIV;\n\n                    for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {\n                        $in = substr($_text, $_i, '.$block_size.') ^ $in;\n                        '.$encrypt_block.'\n                        $_ciphertext.= $in;\n                    }\n\n                    if ($self->continuousBuffer) {\n                        $self->encryptIV = $in;\n                    }\n\n                    return $_ciphertext;\n                    ';\n\n                $decrypt = $init_decrypt . '\n                    $_plaintext = \"\";\n                    $_text = str_pad($_text, strlen($_text) + ('.$block_size.' - strlen($_text) % '.$block_size.') % '.$block_size.', chr(0));\n                    $_ciphertext_len = strlen($_text);\n\n                    $_iv = $self->decryptIV;\n\n                    for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {\n                        $in = $_block = substr($_text, $_i, '.$block_size.');\n                        '.$decrypt_block.'\n                        $_plaintext.= $in ^ $_iv;\n                        $_iv = $_block;\n                    }\n\n                    if ($self->continuousBuffer) {\n                        $self->decryptIV = $_iv;\n                    }\n\n                    return $self->_unpad($_plaintext);\n                    ';\n                break;\n        }\n\n        // Create the $inline function and return its name as string. Ready to run!\n        return create_function('$_action, &$self, $_text', $init_crypt . 'if ($_action == \"encrypt\") { ' . $encrypt . ' } else { ' . $decrypt . ' }');\n    }\n\n    /**\n     * Holds the lambda_functions table (classwide)\n     *\n     * Each name of the lambda function, created from\n     * _setupInlineCrypt() && _createInlineCryptFunction()\n     * is stored, classwide (!), here for reusing.\n     *\n     * The string-based index of $function is a classwide\n     * uniqe value representing, at least, the $mode of\n     * operation (or more... depends of the optimizing level)\n     * for which $mode the lambda function was created.\n     *\n     * @access private\n     * @return Array &$functions\n     */\n    function &_getLambdaFunctions()\n    {\n        static $functions = array();\n        return $functions;\n    }\n\n    /**\n     * Generates a digest from $bytes\n     *\n     * @see _setupInlineCrypt()\n     * @access private\n     * @param $bytes\n     * @return String\n     */\n    function _hashInlineCryptFunction($bytes)\n    {\n        if (!isset(self::$WHIRLPOOL_AVAILABLE)) {\n            self::$WHIRLPOOL_AVAILABLE = extension_loaded('hash') && in_array('whirlpool', hash_algos());\n        }\n\n        $result = '';\n        $hash = $bytes;\n\n        switch (true) {\n            case self::$WHIRLPOOL_AVAILABLE:\n                foreach (str_split($bytes, 64) as $t) {\n                    $hash = hash('whirlpool', $hash, true);\n                    $result .= $t ^ $hash;\n                }\n                return $result . hash('whirlpool', $hash, true);\n            default:\n                $len = strlen($bytes);\n                for ($i = 0; $i < $len; $i+=20) {\n                    $t = substr($bytes, $i, 20);\n                    $hash = pack('H*', sha1($hash));\n                    $result .= $t ^ $hash;\n                }\n                return $result . pack('H*', sha1($hash));\n        }\n    }\n}\n", "<?php\n\n/**\n * Random Number Generator\n *\n * PHP version 5\n *\n * Here's a short example of how to use this library:\n * <code>\n * <?php\n *    include 'vendor/autoload.php';\n *\n *    echo bin2hex(\\phpseclib\\Crypt\\Random::string(8));\n * ?>\n * </code>\n *\n * @category  Crypt\n * @package   Random\n * @author    Jim Wigginton <terrafrost@php.net>\n * @copyright 2007 Jim Wigginton\n * @license   http://www.opensource.org/licenses/mit-license.html  MIT License\n * @link      http://phpseclib.sourceforge.net\n */\n\nnamespace phpseclib\\Crypt;\n\nuse phpseclib\\Crypt\\AES;\nuse phpseclib\\Crypt\\Base;\nuse phpseclib\\Crypt\\Blowfish;\nuse phpseclib\\Crypt\\DES;\nuse phpseclib\\Crypt\\RC4;\nuse phpseclib\\Crypt\\TripleDES;\nuse phpseclib\\Crypt\\Twofish;\n\n/**\n * Pure-PHP Random Number Generator\n *\n * @package Random\n * @author  Jim Wigginton <terrafrost@php.net>\n * @access  public\n */\nclass Random\n{\n    /**\n     * Generate a random string.\n     *\n     * Although microoptimizations are generally discouraged as they impair readability this function is ripe with\n     * microoptimizations because this function has the potential of being called a huge number of times.\n     * eg. for RSA key generation.\n     *\n     * @param Integer $length\n     * @return String\n     */\n    public static function string($length)\n    {\n        if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {\n            // method 1. prior to PHP 5.3 this would call rand() on windows hence the function_exists('class_alias') call.\n            // ie. class_alias is a function that was introduced in PHP 5.3\n            if (function_exists('mcrypt_create_iv') && function_exists('class_alias')) {\n                return mcrypt_create_iv($length);\n            }\n            // method 2. openssl_random_pseudo_bytes was introduced in PHP 5.3.0 but prior to PHP 5.3.4 there was,\n            // to quote <http://php.net/ChangeLog-5.php#5.3.4>, \"possible blocking behavior\". as of 5.3.4\n            // openssl_random_pseudo_bytes and mcrypt_create_iv do the exact same thing on Windows. ie. they both\n            // call php_win32_get_random_bytes():\n            //\n            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/ext/openssl/openssl.c#L5008\n            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/ext/mcrypt/mcrypt.c#L1392\n            //\n            // php_win32_get_random_bytes() is defined thusly:\n            //\n            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/win32/winutil.c#L80\n            //\n            // we're calling it, all the same, in the off chance that the mcrypt extension is not available\n            if (function_exists('openssl_random_pseudo_bytes') && version_compare(PHP_VERSION, '5.3.4', '>=')) {\n                return openssl_random_pseudo_bytes($length);\n            }\n        } else {\n            // method 1. the fastest\n            if (function_exists('openssl_random_pseudo_bytes')) {\n                return openssl_random_pseudo_bytes($length);\n            }\n            // method 2\n            static $fp = true;\n            if ($fp === true) {\n                // warning's will be output unles the error suppression operator is used. errors such as\n                // \"open_basedir restriction in effect\", \"Permission denied\", \"No such file or directory\", etc.\n                $fp = @fopen('/dev/urandom', 'rb');\n            }\n            if ($fp !== true && $fp !== false) { // surprisingly faster than !is_bool() or is_resource()\n                return fread($fp, $length);\n            }\n            // method 3. pretty much does the same thing as method 2 per the following url:\n            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/ext/mcrypt/mcrypt.c#L1391\n            // surprisingly slower than method 2. maybe that's because mcrypt_create_iv does a bunch of error checking that we're\n            // not doing. regardless, this'll only be called if this PHP script couldn't open /dev/urandom due to open_basedir\n            // restrictions or some such\n            if (function_exists('mcrypt_create_iv')) {\n                return mcrypt_create_iv($length, MCRYPT_DEV_URANDOM);\n            }\n        }\n        // at this point we have no choice but to use a pure-PHP CSPRNG\n\n        // cascade entropy across multiple PHP instances by fixing the session and collecting all\n        // environmental variables, including the previous session data and the current session\n        // data.\n        //\n        // mt_rand seeds itself by looking at the PID and the time, both of which are (relatively)\n        // easy to guess at. linux uses mouse clicks, keyboard timings, etc, as entropy sources, but\n        // PHP isn't low level to be able to use those as sources and on a web server there's not likely\n        // going to be a ton of keyboard or mouse action. web servers do have one thing that we can use\n        // however, a ton of people visiting the website. obviously you don't want to base your seeding\n        // soley on parameters a potential attacker sends but (1) not everything in $_SERVER is controlled\n        // by the user and (2) this isn't just looking at the data sent by the current user - it's based\n        // on the data sent by all users. one user requests the page and a hash of their info is saved.\n        // another user visits the page and the serialization of their data is utilized along with the\n        // server envirnment stuff and a hash of the previous http request data (which itself utilizes\n        // a hash of the session data before that). certainly an attacker should be assumed to have\n        // full control over his own http requests. he, however, is not going to have control over\n        // everyone's http requests.\n        static $crypto = false, $v;\n        if ($crypto === false) {\n            // save old session data\n            $old_session_id = session_id();\n            $old_use_cookies = ini_get('session.use_cookies');\n            $old_session_cache_limiter = session_cache_limiter();\n            $_OLD_SESSION = isset($_SESSION) ? $_SESSION : false;\n            if ($old_session_id != '') {\n                session_write_close();\n            }\n\n            session_id(1);\n            ini_set('session.use_cookies', 0);\n            session_cache_limiter('');\n            session_start();\n\n            $v = $seed = $_SESSION['seed'] = pack('H*', sha1(\n                serialize($_SERVER) .\n                serialize($_POST) .\n                serialize($_GET) .\n                serialize($_COOKIE) .\n                serialize($GLOBALS) .\n                serialize($_SESSION) .\n                serialize($_OLD_SESSION)\n            ));\n            if (!isset($_SESSION['count'])) {\n                $_SESSION['count'] = 0;\n            }\n            $_SESSION['count']++;\n\n            session_write_close();\n\n            // restore old session data\n            if ($old_session_id != '') {\n                session_id($old_session_id);\n                session_start();\n                ini_set('session.use_cookies', $old_use_cookies);\n                session_cache_limiter($old_session_cache_limiter);\n            } else {\n                if ($_OLD_SESSION !== false) {\n                    $_SESSION = $_OLD_SESSION;\n                    unset($_OLD_SESSION);\n                } else {\n                    unset($_SESSION);\n                }\n            }\n\n            // in SSH2 a shared secret and an exchange hash are generated through the key exchange process.\n            // the IV client to server is the hash of that \"nonce\" with the letter A and for the encryption key it's the letter C.\n            // if the hash doesn't produce enough a key or an IV that's long enough concat successive hashes of the\n            // original hash and the current hash. we'll be emulating that. for more info see the following URL:\n            //\n            // http://tools.ietf.org/html/rfc4253#section-7.2\n            //\n            // see the is_string($crypto) part for an example of how to expand the keys\n            $key = pack('H*', sha1($seed . 'A'));\n            $iv = pack('H*', sha1($seed . 'C'));\n\n            // ciphers are used as per the nist.gov link below. also, see this link:\n            //\n            // http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator#Designs_based_on_cryptographic_primitives\n            switch (true) {\n                case class_exists('\\phpseclib\\Crypt\\AES'):\n                    $crypto = new AES(Base::MODE_CTR);\n                    break;\n                case class_exists('\\phpseclib\\Crypt\\Twofish'):\n                    $crypto = new Twofish(Base::MODE_CTR);\n                    break;\n                case class_exists('\\phpseclib\\Crypt\\Blowfish'):\n                    $crypto = new Blowfish(Base::MODE_CTR);\n                    break;\n                case class_exists('\\phpseclib\\Crypt\\TripleDES'):\n                    $crypto = new TripleDES(Base::MODE_CTR);\n                    break;\n                case class_exists('\\phpseclib\\Crypt\\DES'):\n                    $crypto = new DES(Base::MODE_CTR);\n                    break;\n                case class_exists('\\phpseclib\\Crypt\\RC4'):\n                    $crypto = new RC4();\n                    break;\n                default:\n                    user_error(__CLASS__ . ' requires at least one symmetric cipher be loaded');\n                    return false;\n            }\n\n            $crypto->setKey($key);\n            $crypto->setIV($iv);\n            $crypto->enableContinuousBuffer();\n        }\n\n        //return $crypto->encrypt(str_repeat(\"\\0\", $length));\n\n        // the following is based off of ANSI X9.31:\n        //\n        // http://csrc.nist.gov/groups/STM/cavp/documents/rng/931rngext.pdf\n        //\n        // OpenSSL uses that same standard for it's random numbers:\n        //\n        // http://www.opensource.apple.com/source/OpenSSL/OpenSSL-38/openssl/fips-1.0/rand/fips_rand.c\n        // (do a search for \"ANS X9.31 A.2.4\")\n        $result = '';\n        while (strlen($result) < $length) {\n            $i = $crypto->encrypt(microtime()); // strlen(microtime()) == 21\n            $r = $crypto->encrypt($i ^ $v); // strlen($v) == 20\n            $v = $crypto->encrypt($r ^ $i); // strlen($r) == 20\n            $result.= $r;\n        }\n        return substr($result, 0, $length);\n    }\n}\n", "<?php\n\n/**\n * Pure-PHP implementation of Rijndael.\n *\n * Uses mcrypt, if available/possible, and an internal implementation, otherwise.\n *\n * PHP version 5\n *\n * If {@link \\phpseclib\\Crypt\\Rijndael::setBlockLength() setBlockLength()} isn't called, it'll be assumed to be 128 bits.  If\n * {@link \\phpseclib\\Crypt\\Rijndael::setKeyLength() setKeyLength()} isn't called, it'll be calculated from\n * {@link \\phpseclib\\Crypt\\Rijndael::setKey() setKey()}.  ie. if the key is 128-bits, the key length will be 128-bits.  If it's\n * 136-bits it'll be null-padded to 192-bits and 192 bits will be the key length until\n * {@link \\phpseclib\\Crypt\\Rijndael::setKey() setKey()} is called, again, at which point, it'll be recalculated.\n *\n * Not all Rijndael implementations may support 160-bits or 224-bits as the block length / key length.  mcrypt, for example,\n * does not.  AES, itself, only supports block lengths of 128 and key lengths of 128, 192, and 256.\n * {@link http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=10 Rijndael-ammended.pdf#page=10} defines the\n * algorithm for block lengths of 192 and 256 but not for block lengths / key lengths of 160 and 224.  Indeed, 160 and 224\n * are first defined as valid key / block lengths in\n * {@link http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=44 Rijndael-ammended.pdf#page=44}:\n * Extensions: Other block and Cipher Key lengths.\n * Note: Use of 160/224-bit Keys must be explicitly set by setKeyLength(160) respectively setKeyLength(224).\n *\n * {@internal The variable names are the same as those in\n * {@link http://www.csrc.nist.gov/publications/fips/fips197/fips-197.pdf#page=10 fips-197.pdf#page=10}.}}\n *\n * Here's a short example of how to use this library:\n * <code>\n * <?php\n *    include 'vendor/autoload.php';\n *\n *    $rijndael = new \\phpseclib\\Crypt\\Rijndael();\n *\n *    $rijndael->setKey('abcdefghijklmnop');\n *\n *    $size = 10 * 1024;\n *    $plaintext = '';\n *    for ($i = 0; $i < $size; $i++) {\n *        $plaintext.= 'a';\n *    }\n *\n *    echo $rijndael->decrypt($rijndael->encrypt($plaintext));\n * ?>\n * </code>\n *\n * @category  Crypt\n * @package   Rijndael\n * @author    Jim Wigginton <terrafrost@php.net>\n * @copyright 2008 Jim Wigginton\n * @license   http://www.opensource.org/licenses/mit-license.html  MIT License\n * @link      http://phpseclib.sourceforge.net\n */\n\nnamespace phpseclib\\Crypt;\n\nuse phpseclib\\Crypt\\Base;\n\n/**\n * Pure-PHP implementation of Rijndael.\n *\n * @package Rijndael\n * @author  Jim Wigginton <terrafrost@php.net>\n * @access  public\n */\nclass Rijndael extends Base\n{\n    /**\n     * The default password key_size used by setPassword()\n     *\n     * @see \\phpseclib\\Crypt\\Base::password_key_size\n     * @see \\phpseclib\\Crypt\\Base::setPassword()\n     * @var Integer\n     * @access private\n     */\n    var $password_key_size = 16;\n\n    /**\n     * The mcrypt specific name of the cipher\n     *\n     * Mcrypt is useable for 128/192/256-bit $block_size/$key_size. For 160/224 not.\n     * \\phpseclib\\Crypt\\Rijndael determines automatically whether mcrypt is useable\n     * or not for the current $block_size/$key_size.\n     * In case of, $cipher_name_mcrypt will be set dynamically at run time accordingly.\n     *\n     * @see \\phpseclib\\Crypt\\Base::cipher_name_mcrypt\n     * @see \\phpseclib\\Crypt\\Base::engine\n     * @see isValidEngine()\n     * @var String\n     * @access private\n     */\n    var $cipher_name_mcrypt = 'rijndael-128';\n\n    /**\n     * The default salt used by setPassword()\n     *\n     * @see \\phpseclib\\Crypt\\Base::password_default_salt\n     * @see \\phpseclib\\Crypt\\Base::setPassword()\n     * @var String\n     * @access private\n     */\n    var $password_default_salt = 'phpseclib';\n\n    /**\n     * Has the key length explicitly been set or should it be derived from the key, itself?\n     *\n     * @see setKeyLength()\n     * @var Boolean\n     * @access private\n     */\n    var $explicit_key_length = false;\n\n    /**\n     * The Key Schedule\n     *\n     * @see _setup()\n     * @var Array\n     * @access private\n     */\n    var $w;\n\n    /**\n     * The Inverse Key Schedule\n     *\n     * @see _setup()\n     * @var Array\n     * @access private\n     */\n    var $dw;\n\n    /**\n     * The Block Length divided by 32\n     *\n     * @see setBlockLength()\n     * @var Integer\n     * @access private\n     * @internal The max value is 256 / 32 = 8, the min value is 128 / 32 = 4.  Exists in conjunction with $block_size\n     *    because the encryption / decryption / key schedule creation requires this number and not $block_size.  We could\n     *    derive this from $block_size or vice versa, but that'd mean we'd have to do multiple shift operations, so in lieu\n     *    of that, we'll just precompute it once.\n     */\n    var $Nb = 4;\n\n    /**\n     * The Key Length\n     *\n     * @see setKeyLength()\n     * @var Integer\n     * @access private\n     * @internal The max value is 256 / 8 = 32, the min value is 128 / 8 = 16.  Exists in conjunction with $Nk\n     *    because the encryption / decryption / key schedule creation requires this number and not $key_size.  We could\n     *    derive this from $key_size or vice versa, but that'd mean we'd have to do multiple shift operations, so in lieu\n     *    of that, we'll just precompute it once.\n     */\n    var $key_size = 16;\n\n    /**\n     * The Key Length divided by 32\n     *\n     * @see setKeyLength()\n     * @var Integer\n     * @access private\n     * @internal The max value is 256 / 32 = 8, the min value is 128 / 32 = 4\n     */\n    var $Nk = 4;\n\n    /**\n     * The Number of Rounds\n     *\n     * @var Integer\n     * @access private\n     * @internal The max value is 14, the min value is 10.\n     */\n    var $Nr;\n\n    /**\n     * Shift offsets\n     *\n     * @var Array\n     * @access private\n     */\n    var $c;\n\n    /**\n     * Holds the last used key- and block_size information\n     *\n     * @var Array\n     * @access private\n     */\n    var $kl;\n\n    /**\n     * Default Constructor.\n     *\n     * Determines whether or not the mcrypt extension should be used.\n     *\n     * $mode could be:\n     *\n     * - \\phpseclib\\Crypt\\Base::MODE_ECB\n     *\n     * - \\phpseclib\\Crypt\\Base::MODE_CBC\n     *\n     * - \\phpseclib\\Crypt\\Base::MODE_CTR\n     *\n     * - \\phpseclib\\Crypt\\Base::MODE_CFB\n     *\n     * - \\phpseclib\\Crypt\\Base::MODE_OFB\n     *\n     * If not explictly set, \\phpseclib\\Crypt\\Base::MODE_CBC will be used.\n     *\n     * @see \\phpseclib\\Crypt\\Base::Crypt_Base()\n     * @param optional Integer $mode\n     * @access public\n\n    /**\n     * Sets the key.\n     *\n     * Keys can be of any length.  Rijndael, itself, requires the use of a key that's between 128-bits and 256-bits long and\n     * whose length is a multiple of 32.  If the key is less than 256-bits and the key length isn't set, we round the length\n     * up to the closest valid key length, padding $key with null bytes.  If the key is more than 256-bits, we trim the\n     * excess bits.\n     *\n     * If the key is not explicitly set, it'll be assumed to be all null bytes.\n     *\n     * Note: 160/224-bit keys must explicitly set by setKeyLength(), otherwise they will be round/pad up to 192/256 bits.\n     *\n     * @see \\phpseclib\\Crypt\\Base:setKey()\n     * @see setKeyLength()\n     * @access public\n     * @param String $key\n     */\n    function setKey($key)\n    {\n        if (!$this->explicit_key_length) {\n            $length = strlen($key);\n            switch (true) {\n                case $length <= 16:\n                    $this->key_size = 16;\n                    break;\n                case $length <= 20:\n                    $this->key_size = 20;\n                    break;\n                case $length <= 24:\n                    $this->key_size = 24;\n                    break;\n                case $length <= 28:\n                    $this->key_size = 28;\n                    break;\n                default:\n                    $this->key_size = 32;\n            }\n        }\n        parent::setKey($key);\n    }\n\n    /**\n     * Sets the key length\n     *\n     * Valid key lengths are 128, 160, 192, 224, and 256.  If the length is less than 128, it will be rounded up to\n     * 128.  If the length is greater than 128 and invalid, it will be rounded down to the closest valid amount.\n     *\n     * Note: phpseclib extends Rijndael (and AES) for using 160- and 224-bit keys but they are officially not defined\n     *       and the most (if not all) implementations are not able using 160/224-bit keys but round/pad them up to\n     *       192/256 bits as, for example, mcrypt will do.\n     *\n     *       That said, if you want be compatible with other Rijndael and AES implementations,\n     *       you should not setKeyLength(160) or setKeyLength(224).\n     *\n     * Additional: In case of 160- and 224-bit keys, phpseclib will/can, for that reason, not use\n     *             the mcrypt php extension, even if available.\n     *             This results then in slower encryption.\n     *\n     * @access public\n     * @param Integer $length\n     */\n    function setKeyLength($length)\n    {\n        switch (true) {\n            case $length == 160:\n                $this->key_size = 20;\n                break;\n            case $length == 224:\n                $this->key_size = 28;\n                break;\n            case $length <= 128:\n                $this->key_size = 16;\n                break;\n            case $length <= 192:\n                $this->key_size = 24;\n                break;\n            default:\n                $this->key_size = 32;\n        }\n\n        $this->explicit_key_length = true;\n        $this->changed = true;\n        $this->_setEngine();\n    }\n\n    /**\n     * Sets the block length\n     *\n     * Valid block lengths are 128, 160, 192, 224, and 256.  If the length is less than 128, it will be rounded up to\n     * 128.  If the length is greater than 128 and invalid, it will be rounded down to the closest valid amount.\n     *\n     * @access public\n     * @param Integer $length\n     */\n    function setBlockLength($length)\n    {\n        $length >>= 5;\n        if ($length > 8) {\n            $length = 8;\n        } elseif ($length < 4) {\n            $length = 4;\n        }\n        $this->Nb = $length;\n        $this->block_size = $length << 2;\n        $this->changed = true;\n        $this->_setEngine();\n    }\n\n    /**\n     * Test for engine validity\n     *\n     * This is mainly just a wrapper to set things up for \\phpseclib\\Crypt\\Base::isValidEngine()\n     *\n     * @see \\phpseclib\\Crypt\\Base::Crypt_Base()\n     * @param Integer $engine\n     * @access public\n     * @return Boolean\n     */\n    function isValidEngine($engine)\n    {\n        switch ($engine) {\n            case self::ENGINE_OPENSSL:\n                if ($this->block_size != 16) {\n                    return false;\n                }\n                $this->cipher_name_openssl_ecb = 'aes-' . ($this->key_size << 3) . '-ecb';\n                $this->cipher_name_openssl = 'aes-' . ($this->key_size << 3) . '-' . $this->_openssl_translate_mode();\n                break;\n            case self::ENGINE_MCRYPT:\n                $this->cipher_name_mcrypt = 'rijndael-' . ($this->block_size << 3);\n                if ($this->key_size % 8) { // is it a 160/224-bit key?\n                    // mcrypt is not usable for them, only for 128/192/256-bit keys\n                    return false;\n                }\n        }\n\n        return parent::isValidEngine($engine);\n    }\n\n    /**\n     * Setup the \\phpseclib\\Crypt\\Base::ENGINE_MCRYPT $engine\n     *\n     * @see \\phpseclib\\Crypt\\Base::_setupMcrypt()\n     * @access private\n     */\n    function _setupMcrypt()\n    {\n        $this->key = str_pad(substr($this->key, 0, $this->key_size), $this->key_size, \"\\0\");\n        parent::_setupMcrypt();\n    }\n\n    /**\n     * Encrypts a block\n     *\n     * @access private\n     * @param String $in\n     * @return String\n     */\n    function _encryptBlock($in)\n    {\n        static $tables;\n        if (empty($tables)) {\n            $tables = &$this->_getTables();\n        }\n        $t0   = $tables[0];\n        $t1   = $tables[1];\n        $t2   = $tables[2];\n        $t3   = $tables[3];\n        $sbox = $tables[4];\n\n        $state = array();\n        $words = unpack('N*', $in);\n\n        $c = $this->c;\n        $w = $this->w;\n        $Nb = $this->Nb;\n        $Nr = $this->Nr;\n\n        // addRoundKey\n        $wc = $Nb - 1;\n        foreach ($words as $word) {\n            $state[] = $word ^ $w[++$wc];\n        }\n\n        // fips-197.pdf#page=19, \"Figure 5. Pseudo Code for the Cipher\", states that this loop has four components -\n        // subBytes, shiftRows, mixColumns, and addRoundKey. fips-197.pdf#page=30, \"Implementation Suggestions Regarding\n        // Various Platforms\" suggests that performs enhanced implementations are described in Rijndael-ammended.pdf.\n        // Rijndael-ammended.pdf#page=20, \"Implementation aspects / 32-bit processor\", discusses such an optimization.\n        // Unfortunately, the description given there is not quite correct.  Per aes.spec.v316.pdf#page=19 [1],\n        // equation (7.4.7) is supposed to use addition instead of subtraction, so we'll do that here, as well.\n\n        // [1] http://fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.v316.pdf\n        $temp = array();\n        for ($round = 1; $round < $Nr; ++$round) {\n            $i = 0; // $c[0] == 0\n            $j = $c[1];\n            $k = $c[2];\n            $l = $c[3];\n\n            while ($i < $Nb) {\n                $temp[$i] = $t0[$state[$i] >> 24 & 0x000000FF] ^\n                            $t1[$state[$j] >> 16 & 0x000000FF] ^\n                            $t2[$state[$k] >>  8 & 0x000000FF] ^\n                            $t3[$state[$l]       & 0x000000FF] ^\n                            $w[++$wc];\n                ++$i;\n                $j = ($j + 1) % $Nb;\n                $k = ($k + 1) % $Nb;\n                $l = ($l + 1) % $Nb;\n            }\n            $state = $temp;\n        }\n\n        // subWord\n        for ($i = 0; $i < $Nb; ++$i) {\n            $state[$i] =   $sbox[$state[$i]       & 0x000000FF]        |\n                          ($sbox[$state[$i] >>  8 & 0x000000FF] <<  8) |\n                          ($sbox[$state[$i] >> 16 & 0x000000FF] << 16) |\n                          ($sbox[$state[$i] >> 24 & 0x000000FF] << 24);\n        }\n\n        // shiftRows + addRoundKey\n        $i = 0; // $c[0] == 0\n        $j = $c[1];\n        $k = $c[2];\n        $l = $c[3];\n        while ($i < $Nb) {\n            $temp[$i] = ($state[$i] & 0xFF000000) ^\n                        ($state[$j] & 0x00FF0000) ^\n                        ($state[$k] & 0x0000FF00) ^\n                        ($state[$l] & 0x000000FF) ^\n                         $w[$i];\n            ++$i;\n            $j = ($j + 1) % $Nb;\n            $k = ($k + 1) % $Nb;\n            $l = ($l + 1) % $Nb;\n        }\n\n        switch ($Nb) {\n            case 8:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6], $temp[7]);\n            case 7:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6]);\n            case 6:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5]);\n            case 5:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4]);\n            default:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3]);\n        }\n    }\n\n    /**\n     * Decrypts a block\n     *\n     * @access private\n     * @param String $in\n     * @return String\n     */\n    function _decryptBlock($in)\n    {\n        static $invtables;\n        if (empty($invtables)) {\n            $invtables = &$this->_getInvTables();\n        }\n        $dt0   = $invtables[0];\n        $dt1   = $invtables[1];\n        $dt2   = $invtables[2];\n        $dt3   = $invtables[3];\n        $isbox = $invtables[4];\n\n        $state = array();\n        $words = unpack('N*', $in);\n\n        $c  = $this->c;\n        $dw = $this->dw;\n        $Nb = $this->Nb;\n        $Nr = $this->Nr;\n\n        // addRoundKey\n        $wc = $Nb - 1;\n        foreach ($words as $word) {\n            $state[] = $word ^ $dw[++$wc];\n        }\n\n        $temp = array();\n        for ($round = $Nr - 1; $round > 0; --$round) {\n            $i = 0; // $c[0] == 0\n            $j = $Nb - $c[1];\n            $k = $Nb - $c[2];\n            $l = $Nb - $c[3];\n\n            while ($i < $Nb) {\n                $temp[$i] = $dt0[$state[$i] >> 24 & 0x000000FF] ^\n                            $dt1[$state[$j] >> 16 & 0x000000FF] ^\n                            $dt2[$state[$k] >>  8 & 0x000000FF] ^\n                            $dt3[$state[$l]       & 0x000000FF] ^\n                            $dw[++$wc];\n                ++$i;\n                $j = ($j + 1) % $Nb;\n                $k = ($k + 1) % $Nb;\n                $l = ($l + 1) % $Nb;\n            }\n            $state = $temp;\n        }\n\n        // invShiftRows + invSubWord + addRoundKey\n        $i = 0; // $c[0] == 0\n        $j = $Nb - $c[1];\n        $k = $Nb - $c[2];\n        $l = $Nb - $c[3];\n\n        while ($i < $Nb) {\n            $word = ($state[$i] & 0xFF000000) |\n                    ($state[$j] & 0x00FF0000) |\n                    ($state[$k] & 0x0000FF00) |\n                    ($state[$l] & 0x000000FF);\n\n            $temp[$i] = $dw[$i] ^ ($isbox[$word       & 0x000000FF]        |\n                                  ($isbox[$word >>  8 & 0x000000FF] <<  8) |\n                                  ($isbox[$word >> 16 & 0x000000FF] << 16) |\n                                  ($isbox[$word >> 24 & 0x000000FF] << 24));\n            ++$i;\n            $j = ($j + 1) % $Nb;\n            $k = ($k + 1) % $Nb;\n            $l = ($l + 1) % $Nb;\n        }\n\n        switch ($Nb) {\n            case 8:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6], $temp[7]);\n            case 7:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6]);\n            case 6:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5]);\n            case 5:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4]);\n            default:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3]);\n        }\n    }\n\n    /**\n     * Setup the key (expansion)\n     *\n     * @see \\phpseclib\\Crypt\\Base::_setupKey()\n     * @access private\n     */\n    function _setupKey()\n    {\n        // Each number in $rcon is equal to the previous number multiplied by two in Rijndael's finite field.\n        // See http://en.wikipedia.org/wiki/Finite_field_arithmetic#Multiplicative_inverse\n        static $rcon = array(0,\n            0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,\n            0x20000000, 0x40000000, 0x80000000, 0x1B000000, 0x36000000,\n            0x6C000000, 0xD8000000, 0xAB000000, 0x4D000000, 0x9A000000,\n            0x2F000000, 0x5E000000, 0xBC000000, 0x63000000, 0xC6000000,\n            0x97000000, 0x35000000, 0x6A000000, 0xD4000000, 0xB3000000,\n            0x7D000000, 0xFA000000, 0xEF000000, 0xC5000000, 0x91000000\n        );\n\n        $this->key = str_pad(substr($this->key, 0, $this->key_size), $this->key_size, \"\\0\");\n\n        if (isset($this->kl['key']) && $this->key === $this->kl['key'] && $this->key_size === $this->kl['key_size'] && $this->block_size === $this->kl['block_size']) {\n            // already expanded\n            return;\n        }\n        $this->kl = array('key' => $this->key, 'key_size' => $this->key_size, 'block_size' => $this->block_size);\n\n        $this->Nk = $this->key_size >> 2;\n        // see Rijndael-ammended.pdf#page=44\n        $this->Nr = max($this->Nk, $this->Nb) + 6;\n\n        // shift offsets for Nb = 5, 7 are defined in Rijndael-ammended.pdf#page=44,\n        //     \"Table 8: Shift offsets in Shiftrow for the alternative block lengths\"\n        // shift offsets for Nb = 4, 6, 8 are defined in Rijndael-ammended.pdf#page=14,\n        //     \"Table 2: Shift offsets for different block lengths\"\n        switch ($this->Nb) {\n            case 4:\n            case 5:\n            case 6:\n                $this->c = array(0, 1, 2, 3);\n                break;\n            case 7:\n                $this->c = array(0, 1, 2, 4);\n                break;\n            case 8:\n                $this->c = array(0, 1, 3, 4);\n        }\n\n        $w = array_values(unpack('N*words', $this->key));\n\n        $length = $this->Nb * ($this->Nr + 1);\n        for ($i = $this->Nk; $i < $length; $i++) {\n            $temp = $w[$i - 1];\n            if ($i % $this->Nk == 0) {\n                // according to <http://php.net/language.types.integer>, \"the size of an integer is platform-dependent\".\n                // on a 32-bit machine, it's 32-bits, and on a 64-bit machine, it's 64-bits. on a 32-bit machine,\n                // 0xFFFFFFFF << 8 == 0xFFFFFF00, but on a 64-bit machine, it equals 0xFFFFFFFF00. as such, doing 'and'\n                // with 0xFFFFFFFF (or 0xFFFFFF00) on a 32-bit machine is unnecessary, but on a 64-bit machine, it is.\n                $temp = (($temp << 8) & 0xFFFFFF00) | (($temp >> 24) & 0x000000FF); // rotWord\n                $temp = $this->_subWord($temp) ^ $rcon[$i / $this->Nk];\n            } elseif ($this->Nk > 6 && $i % $this->Nk == 4) {\n                $temp = $this->_subWord($temp);\n            }\n            $w[$i] = $w[$i - $this->Nk] ^ $temp;\n        }\n\n        // convert the key schedule from a vector of $Nb * ($Nr + 1) length to a matrix with $Nr + 1 rows and $Nb columns\n        // and generate the inverse key schedule.  more specifically,\n        // according to <http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=23> (section 5.3.3),\n        // \"The key expansion for the Inverse Cipher is defined as follows:\n        //        1. Apply the Key Expansion.\n        //        2. Apply InvMixColumn to all Round Keys except the first and the last one.\"\n        // also, see fips-197.pdf#page=27, \"5.3.5 Equivalent Inverse Cipher\"\n        list($dt0, $dt1, $dt2, $dt3) = $this->_getInvTables();\n        $temp = $this->w = $this->dw = array();\n        for ($i = $row = $col = 0; $i < $length; $i++, $col++) {\n            if ($col == $this->Nb) {\n                if ($row == 0) {\n                    $this->dw[0] = $this->w[0];\n                } else {\n                    // subWord + invMixColumn + invSubWord = invMixColumn\n                    $j = 0;\n                    while ($j < $this->Nb) {\n                        $dw = $this->_subWord($this->w[$row][$j]);\n                        $temp[$j] = $dt0[$dw >> 24 & 0x000000FF] ^\n                                    $dt1[$dw >> 16 & 0x000000FF] ^\n                                    $dt2[$dw >>  8 & 0x000000FF] ^\n                                    $dt3[$dw       & 0x000000FF];\n                        $j++;\n                    }\n                    $this->dw[$row] = $temp;\n                }\n\n                $col = 0;\n                $row++;\n            }\n            $this->w[$row][$col] = $w[$i];\n        }\n\n        $this->dw[$row] = $this->w[$row];\n\n        // Converting to 1-dim key arrays (both ascending)\n        $this->dw = array_reverse($this->dw);\n        $w  = array_pop($this->w);\n        $dw = array_pop($this->dw);\n        foreach ($this->w as $r => $wr) {\n            foreach ($wr as $c => $wc) {\n                $w[]  = $wc;\n                $dw[] = $this->dw[$r][$c];\n            }\n        }\n        $this->w  = $w;\n        $this->dw = $dw;\n    }\n\n    /**\n     * Performs S-Box substitutions\n     *\n     * @access private\n     * @param Integer $word\n     */\n    function _subWord($word)\n    {\n        static $sbox;\n        if (empty($sbox)) {\n            list(,,,, $sbox) = $this->_getTables();\n        }\n\n        return  $sbox[$word       & 0x000000FF]        |\n               ($sbox[$word >>  8 & 0x000000FF] <<  8) |\n               ($sbox[$word >> 16 & 0x000000FF] << 16) |\n               ($sbox[$word >> 24 & 0x000000FF] << 24);\n    }\n\n    /**\n     * Provides the mixColumns and sboxes tables\n     *\n     * @see Crypt_Rijndael:_encryptBlock()\n     * @see Crypt_Rijndael:_setupInlineCrypt()\n     * @see Crypt_Rijndael:_subWord()\n     * @access private\n     * @return Array &$tables\n     */\n    function &_getTables()\n    {\n        static $tables;\n        if (empty($tables)) {\n            // according to <http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=19> (section 5.2.1),\n            // precomputed tables can be used in the mixColumns phase. in that example, they're assigned t0...t3, so\n            // those are the names we'll use.\n            $t3 = array_map('intval', array(\n                // with array_map('intval', ...) we ensure we have only int's and not\n                // some slower floats converted by php automatically on high values\n                0x6363A5C6, 0x7C7C84F8, 0x777799EE, 0x7B7B8DF6, 0xF2F20DFF, 0x6B6BBDD6, 0x6F6FB1DE, 0xC5C55491,\n                0x30305060, 0x01010302, 0x6767A9CE, 0x2B2B7D56, 0xFEFE19E7, 0xD7D762B5, 0xABABE64D, 0x76769AEC,\n                0xCACA458F, 0x82829D1F, 0xC9C94089, 0x7D7D87FA, 0xFAFA15EF, 0x5959EBB2, 0x4747C98E, 0xF0F00BFB,\n                0xADADEC41, 0xD4D467B3, 0xA2A2FD5F, 0xAFAFEA45, 0x9C9CBF23, 0xA4A4F753, 0x727296E4, 0xC0C05B9B,\n                0xB7B7C275, 0xFDFD1CE1, 0x9393AE3D, 0x26266A4C, 0x36365A6C, 0x3F3F417E, 0xF7F702F5, 0xCCCC4F83,\n                0x34345C68, 0xA5A5F451, 0xE5E534D1, 0xF1F108F9, 0x717193E2, 0xD8D873AB, 0x31315362, 0x15153F2A,\n                0x04040C08, 0xC7C75295, 0x23236546, 0xC3C35E9D, 0x18182830, 0x9696A137, 0x05050F0A, 0x9A9AB52F,\n                0x0707090E, 0x12123624, 0x80809B1B, 0xE2E23DDF, 0xEBEB26CD, 0x2727694E, 0xB2B2CD7F, 0x75759FEA,\n                0x09091B12, 0x83839E1D, 0x2C2C7458, 0x1A1A2E34, 0x1B1B2D36, 0x6E6EB2DC, 0x5A5AEEB4, 0xA0A0FB5B,\n                0x5252F6A4, 0x3B3B4D76, 0xD6D661B7, 0xB3B3CE7D, 0x29297B52, 0xE3E33EDD, 0x2F2F715E, 0x84849713,\n                0x5353F5A6, 0xD1D168B9, 0x00000000, 0xEDED2CC1, 0x20206040, 0xFCFC1FE3, 0xB1B1C879, 0x5B5BEDB6,\n                0x6A6ABED4, 0xCBCB468D, 0xBEBED967, 0x39394B72, 0x4A4ADE94, 0x4C4CD498, 0x5858E8B0, 0xCFCF4A85,\n                0xD0D06BBB, 0xEFEF2AC5, 0xAAAAE54F, 0xFBFB16ED, 0x4343C586, 0x4D4DD79A, 0x33335566, 0x85859411,\n                0x4545CF8A, 0xF9F910E9, 0x02020604, 0x7F7F81FE, 0x5050F0A0, 0x3C3C4478, 0x9F9FBA25, 0xA8A8E34B,\n                0x5151F3A2, 0xA3A3FE5D, 0x4040C080, 0x8F8F8A05, 0x9292AD3F, 0x9D9DBC21, 0x38384870, 0xF5F504F1,\n                0xBCBCDF63, 0xB6B6C177, 0xDADA75AF, 0x21216342, 0x10103020, 0xFFFF1AE5, 0xF3F30EFD, 0xD2D26DBF,\n                0xCDCD4C81, 0x0C0C1418, 0x13133526, 0xECEC2FC3, 0x5F5FE1BE, 0x9797A235, 0x4444CC88, 0x1717392E,\n                0xC4C45793, 0xA7A7F255, 0x7E7E82FC, 0x3D3D477A, 0x6464ACC8, 0x5D5DE7BA, 0x19192B32, 0x737395E6,\n                0x6060A0C0, 0x81819819, 0x4F4FD19E, 0xDCDC7FA3, 0x22226644, 0x2A2A7E54, 0x9090AB3B, 0x8888830B,\n                0x4646CA8C, 0xEEEE29C7, 0xB8B8D36B, 0x14143C28, 0xDEDE79A7, 0x5E5EE2BC, 0x0B0B1D16, 0xDBDB76AD,\n                0xE0E03BDB, 0x32325664, 0x3A3A4E74, 0x0A0A1E14, 0x4949DB92, 0x06060A0C, 0x24246C48, 0x5C5CE4B8,\n                0xC2C25D9F, 0xD3D36EBD, 0xACACEF43, 0x6262A6C4, 0x9191A839, 0x9595A431, 0xE4E437D3, 0x79798BF2,\n                0xE7E732D5, 0xC8C8438B, 0x3737596E, 0x6D6DB7DA, 0x8D8D8C01, 0xD5D564B1, 0x4E4ED29C, 0xA9A9E049,\n                0x6C6CB4D8, 0x5656FAAC, 0xF4F407F3, 0xEAEA25CF, 0x6565AFCA, 0x7A7A8EF4, 0xAEAEE947, 0x08081810,\n                0xBABAD56F, 0x787888F0, 0x25256F4A, 0x2E2E725C, 0x1C1C2438, 0xA6A6F157, 0xB4B4C773, 0xC6C65197,\n                0xE8E823CB, 0xDDDD7CA1, 0x74749CE8, 0x1F1F213E, 0x4B4BDD96, 0xBDBDDC61, 0x8B8B860D, 0x8A8A850F,\n                0x707090E0, 0x3E3E427C, 0xB5B5C471, 0x6666AACC, 0x4848D890, 0x03030506, 0xF6F601F7, 0x0E0E121C,\n                0x6161A3C2, 0x35355F6A, 0x5757F9AE, 0xB9B9D069, 0x86869117, 0xC1C15899, 0x1D1D273A, 0x9E9EB927,\n                0xE1E138D9, 0xF8F813EB, 0x9898B32B, 0x11113322, 0x6969BBD2, 0xD9D970A9, 0x8E8E8907, 0x9494A733,\n                0x9B9BB62D, 0x1E1E223C, 0x87879215, 0xE9E920C9, 0xCECE4987, 0x5555FFAA, 0x28287850, 0xDFDF7AA5,\n                0x8C8C8F03, 0xA1A1F859, 0x89898009, 0x0D0D171A, 0xBFBFDA65, 0xE6E631D7, 0x4242C684, 0x6868B8D0,\n                0x4141C382, 0x9999B029, 0x2D2D775A, 0x0F0F111E, 0xB0B0CB7B, 0x5454FCA8, 0xBBBBD66D, 0x16163A2C\n            ));\n\n            foreach ($t3 as $t3i) {\n                $t0[] = (($t3i << 24) & 0xFF000000) | (($t3i >>  8) & 0x00FFFFFF);\n                $t1[] = (($t3i << 16) & 0xFFFF0000) | (($t3i >> 16) & 0x0000FFFF);\n                $t2[] = (($t3i <<  8) & 0xFFFFFF00) | (($t3i >> 24) & 0x000000FF);\n            }\n\n            $tables = array(\n                // The Precomputed mixColumns tables t0 - t3\n                $t0,\n                $t1,\n                $t2,\n                $t3,\n                // The SubByte S-Box\n                array(\n                    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n                    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n                    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n                    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n                    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n                    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n                    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n                    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n                    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n                    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n                    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n                    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n                    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n                    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n                    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n                    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16\n                )\n            );\n        }\n        return $tables;\n    }\n\n    /**\n     * Provides the inverse mixColumns and inverse sboxes tables\n     *\n     * @see Crypt_Rijndael:_decryptBlock()\n     * @see Crypt_Rijndael:_setupInlineCrypt()\n     * @see Crypt_Rijndael:_setupKey()\n     * @access private\n     * @return Array &$tables\n     */\n    function &_getInvTables()\n    {\n        static $tables;\n        if (empty($tables)) {\n            $dt3 = array_map('intval', array(\n                0xF4A75051, 0x4165537E, 0x17A4C31A, 0x275E963A, 0xAB6BCB3B, 0x9D45F11F, 0xFA58ABAC, 0xE303934B,\n                0x30FA5520, 0x766DF6AD, 0xCC769188, 0x024C25F5, 0xE5D7FC4F, 0x2ACBD7C5, 0x35448026, 0x62A38FB5,\n                0xB15A49DE, 0xBA1B6725, 0xEA0E9845, 0xFEC0E15D, 0x2F7502C3, 0x4CF01281, 0x4697A38D, 0xD3F9C66B,\n                0x8F5FE703, 0x929C9515, 0x6D7AEBBF, 0x5259DA95, 0xBE832DD4, 0x7421D358, 0xE0692949, 0xC9C8448E,\n                0xC2896A75, 0x8E7978F4, 0x583E6B99, 0xB971DD27, 0xE14FB6BE, 0x88AD17F0, 0x20AC66C9, 0xCE3AB47D,\n                0xDF4A1863, 0x1A3182E5, 0x51336097, 0x537F4562, 0x6477E0B1, 0x6BAE84BB, 0x81A01CFE, 0x082B94F9,\n                0x48685870, 0x45FD198F, 0xDE6C8794, 0x7BF8B752, 0x73D323AB, 0x4B02E272, 0x1F8F57E3, 0x55AB2A66,\n                0xEB2807B2, 0xB5C2032F, 0xC57B9A86, 0x3708A5D3, 0x2887F230, 0xBFA5B223, 0x036ABA02, 0x16825CED,\n                0xCF1C2B8A, 0x79B492A7, 0x07F2F0F3, 0x69E2A14E, 0xDAF4CD65, 0x05BED506, 0x34621FD1, 0xA6FE8AC4,\n                0x2E539D34, 0xF355A0A2, 0x8AE13205, 0xF6EB75A4, 0x83EC390B, 0x60EFAA40, 0x719F065E, 0x6E1051BD,\n                0x218AF93E, 0xDD063D96, 0x3E05AEDD, 0xE6BD464D, 0x548DB591, 0xC45D0571, 0x06D46F04, 0x5015FF60,\n                0x98FB2419, 0xBDE997D6, 0x4043CC89, 0xD99E7767, 0xE842BDB0, 0x898B8807, 0x195B38E7, 0xC8EEDB79,\n                0x7C0A47A1, 0x420FE97C, 0x841EC9F8, 0x00000000, 0x80868309, 0x2BED4832, 0x1170AC1E, 0x5A724E6C,\n                0x0EFFFBFD, 0x8538560F, 0xAED51E3D, 0x2D392736, 0x0FD9640A, 0x5CA62168, 0x5B54D19B, 0x362E3A24,\n                0x0A67B10C, 0x57E70F93, 0xEE96D2B4, 0x9B919E1B, 0xC0C54F80, 0xDC20A261, 0x774B695A, 0x121A161C,\n                0x93BA0AE2, 0xA02AE5C0, 0x22E0433C, 0x1B171D12, 0x090D0B0E, 0x8BC7ADF2, 0xB6A8B92D, 0x1EA9C814,\n                0xF1198557, 0x75074CAF, 0x99DDBBEE, 0x7F60FDA3, 0x01269FF7, 0x72F5BC5C, 0x663BC544, 0xFB7E345B,\n                0x4329768B, 0x23C6DCCB, 0xEDFC68B6, 0xE4F163B8, 0x31DCCAD7, 0x63851042, 0x97224013, 0xC6112084,\n                0x4A247D85, 0xBB3DF8D2, 0xF93211AE, 0x29A16DC7, 0x9E2F4B1D, 0xB230F3DC, 0x8652EC0D, 0xC1E3D077,\n                0xB3166C2B, 0x70B999A9, 0x9448FA11, 0xE9642247, 0xFC8CC4A8, 0xF03F1AA0, 0x7D2CD856, 0x3390EF22,\n                0x494EC787, 0x38D1C1D9, 0xCAA2FE8C, 0xD40B3698, 0xF581CFA6, 0x7ADE28A5, 0xB78E26DA, 0xADBFA43F,\n                0x3A9DE42C, 0x78920D50, 0x5FCC9B6A, 0x7E466254, 0x8D13C2F6, 0xD8B8E890, 0x39F75E2E, 0xC3AFF582,\n                0x5D80BE9F, 0xD0937C69, 0xD52DA96F, 0x2512B3CF, 0xAC993BC8, 0x187DA710, 0x9C636EE8, 0x3BBB7BDB,\n                0x267809CD, 0x5918F46E, 0x9AB701EC, 0x4F9AA883, 0x956E65E6, 0xFFE67EAA, 0xBCCF0821, 0x15E8E6EF,\n                0xE79BD9BA, 0x6F36CE4A, 0x9F09D4EA, 0xB07CD629, 0xA4B2AF31, 0x3F23312A, 0xA59430C6, 0xA266C035,\n                0x4EBC3774, 0x82CAA6FC, 0x90D0B0E0, 0xA7D81533, 0x04984AF1, 0xECDAF741, 0xCD500E7F, 0x91F62F17,\n                0x4DD68D76, 0xEFB04D43, 0xAA4D54CC, 0x9604DFE4, 0xD1B5E39E, 0x6A881B4C, 0x2C1FB8C1, 0x65517F46,\n                0x5EEA049D, 0x8C355D01, 0x877473FA, 0x0B412EFB, 0x671D5AB3, 0xDBD25292, 0x105633E9, 0xD647136D,\n                0xD7618C9A, 0xA10C7A37, 0xF8148E59, 0x133C89EB, 0xA927EECE, 0x61C935B7, 0x1CE5EDE1, 0x47B13C7A,\n                0xD2DF599C, 0xF2733F55, 0x14CE7918, 0xC737BF73, 0xF7CDEA53, 0xFDAA5B5F, 0x3D6F14DF, 0x44DB8678,\n                0xAFF381CA, 0x68C43EB9, 0x24342C38, 0xA3405FC2, 0x1DC37216, 0xE2250CBC, 0x3C498B28, 0x0D9541FF,\n                0xA8017139, 0x0CB3DE08, 0xB4E49CD8, 0x56C19064, 0xCB84617B, 0x32B670D5, 0x6C5C7448, 0xB85742D0\n            ));\n\n            foreach ($dt3 as $dt3i) {\n                $dt0[] = (($dt3i << 24) & 0xFF000000) | (($dt3i >>  8) & 0x00FFFFFF);\n                $dt1[] = (($dt3i << 16) & 0xFFFF0000) | (($dt3i >> 16) & 0x0000FFFF);\n                $dt2[] = (($dt3i <<  8) & 0xFFFFFF00) | (($dt3i >> 24) & 0x000000FF);\n            };\n\n            $tables = array(\n                // The Precomputed inverse mixColumns tables dt0 - dt3\n                $dt0,\n                $dt1,\n                $dt2,\n                $dt3,\n                // The inverse SubByte S-Box\n                array(\n                    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n                    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n                    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n                    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n                    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n                    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n                    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n                    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n                    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n                    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n                    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n                    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n                    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n                    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n                    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n                    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D\n                )\n            );\n        }\n        return $tables;\n    }\n\n    /**\n     * Setup the performance-optimized function for de/encrypt()\n     *\n     * @see \\phpseclib\\Crypt\\Base::_setupInlineCrypt()\n     * @access private\n     */\n    function _setupInlineCrypt()\n    {\n        // Note: _setupInlineCrypt() will be called only if $this->changed === true\n        // So here we are'nt under the same heavy timing-stress as we are in _de/encryptBlock() or de/encrypt().\n        // However...the here generated function- $code, stored as php callback in $this->inline_crypt, must work as fast as even possible.\n\n        $lambda_functions =& self::_getLambdaFunctions();\n\n        // We create max. 10 hi-optimized code for memory reason. Means: For each $key one ultra fast inline-crypt function.\n        // (Currently, for Crypt_Rijndael/AES, one generated $lambda_function cost on php5.5@32bit ~80kb unfreeable mem and ~130kb on php5.5@64bit)\n        // After that, we'll still create very fast optimized code but not the hi-ultimative code, for each $mode one.\n        $gen_hi_opt_code = (bool)( count($lambda_functions) < 10 );\n\n        // Generation of a uniqe hash for our generated code\n        $code_hash = \"Crypt_Rijndael, {$this->mode}, {$this->Nr}, {$this->Nb}\";\n        if ($gen_hi_opt_code) {\n            $code_hash = str_pad($code_hash, 32) . $this->_hashInlineCryptFunction($this->key);\n        }\n\n        if (!isset($lambda_functions[$code_hash])) {\n            switch (true) {\n                case $gen_hi_opt_code:\n                    // The hi-optimized $lambda_functions will use the key-words hardcoded for better performance.\n                    $w  = $this->w;\n                    $dw = $this->dw;\n                    $init_encrypt = '';\n                    $init_decrypt = '';\n                    break;\n                default:\n                    for ($i = 0, $cw = count($this->w); $i < $cw; ++$i) {\n                        $w[]  = '$w['  . $i . ']';\n                        $dw[] = '$dw[' . $i . ']';\n                    }\n                    $init_encrypt = '$w  = $self->w;';\n                    $init_decrypt = '$dw = $self->dw;';\n            }\n\n            $Nr = $this->Nr;\n            $Nb = $this->Nb;\n            $c  = $this->c;\n\n            // Generating encrypt code:\n            $init_encrypt.= '\n                static $tables;\n                if (empty($tables)) {\n                    $tables = &$self->_getTables();\n                }\n                $t0   = $tables[0];\n                $t1   = $tables[1];\n                $t2   = $tables[2];\n                $t3   = $tables[3];\n                $sbox = $tables[4];\n            ';\n\n            $s  = 'e';\n            $e  = 's';\n            $wc = $Nb - 1;\n\n            // Preround: addRoundKey\n            $encrypt_block = '$in = unpack(\"N*\", $in);'.\"\\n\";\n            for ($i = 0; $i < $Nb; ++$i) {\n                $encrypt_block .= '$s'.$i.' = $in['.($i + 1).'] ^ '.$w[++$wc].\";\\n\";\n            }\n\n            // Mainrounds: shiftRows + subWord + mixColumns + addRoundKey\n            for ($round = 1; $round < $Nr; ++$round) {\n                list($s, $e) = array($e, $s);\n                for ($i = 0; $i < $Nb; ++$i) {\n                    $encrypt_block.=\n                        '$'.$e.$i.' =\n                        $t0[($'.$s.$i                  .' >> 24) & 0xff] ^\n                        $t1[($'.$s.(($i + $c[1]) % $Nb).' >> 16) & 0xff] ^\n                        $t2[($'.$s.(($i + $c[2]) % $Nb).' >>  8) & 0xff] ^\n                        $t3[ $'.$s.(($i + $c[3]) % $Nb).'        & 0xff] ^\n                        '.$w[++$wc].\";\\n\";\n                }\n            }\n\n            // Finalround: subWord + shiftRows + addRoundKey\n            for ($i = 0; $i < $Nb; ++$i) {\n                $encrypt_block.=\n                    '$'.$e.$i.' =\n                     $sbox[ $'.$e.$i.'        & 0xff]        |\n                    ($sbox[($'.$e.$i.' >>  8) & 0xff] <<  8) |\n                    ($sbox[($'.$e.$i.' >> 16) & 0xff] << 16) |\n                    ($sbox[($'.$e.$i.' >> 24) & 0xff] << 24);'.\"\\n\";\n            }\n            $encrypt_block .= '$in = pack(\"N*\"'.\"\\n\";\n            for ($i = 0; $i < $Nb; ++$i) {\n                $encrypt_block.= ',\n                    ($'.$e.$i                  .' & '.((int)0xFF000000).') ^\n                    ($'.$e.(($i + $c[1]) % $Nb).' &         0x00FF0000   ) ^\n                    ($'.$e.(($i + $c[2]) % $Nb).' &         0x0000FF00   ) ^\n                    ($'.$e.(($i + $c[3]) % $Nb).' &         0x000000FF   ) ^\n                    '.$w[$i].\"\\n\";\n            }\n            $encrypt_block .= ');';\n\n            // Generating decrypt code:\n            $init_decrypt.= '\n                static $invtables;\n                if (empty($invtables)) {\n                    $invtables = &$self->_getInvTables();\n                }\n                $dt0   = $invtables[0];\n                $dt1   = $invtables[1];\n                $dt2   = $invtables[2];\n                $dt3   = $invtables[3];\n                $isbox = $invtables[4];\n            ';\n\n            $s  = 'e';\n            $e  = 's';\n            $wc = $Nb - 1;\n\n            // Preround: addRoundKey\n            $decrypt_block = '$in = unpack(\"N*\", $in);'.\"\\n\";\n            for ($i = 0; $i < $Nb; ++$i) {\n                $decrypt_block .= '$s'.$i.' = $in['.($i + 1).'] ^ '.$dw[++$wc].';'.\"\\n\";\n            }\n\n            // Mainrounds: shiftRows + subWord + mixColumns + addRoundKey\n            for ($round = 1; $round < $Nr; ++$round) {\n                list($s, $e) = array($e, $s);\n                for ($i = 0; $i < $Nb; ++$i) {\n                    $decrypt_block.=\n                        '$'.$e.$i.' =\n                        $dt0[($'.$s.$i                        .' >> 24) & 0xff] ^\n                        $dt1[($'.$s.(($Nb + $i - $c[1]) % $Nb).' >> 16) & 0xff] ^\n                        $dt2[($'.$s.(($Nb + $i - $c[2]) % $Nb).' >>  8) & 0xff] ^\n                        $dt3[ $'.$s.(($Nb + $i - $c[3]) % $Nb).'        & 0xff] ^\n                        '.$dw[++$wc].\";\\n\";\n                }\n            }\n\n            // Finalround: subWord + shiftRows + addRoundKey\n            for ($i = 0; $i < $Nb; ++$i) {\n                $decrypt_block.=\n                    '$'.$e.$i.' =\n                     $isbox[ $'.$e.$i.'        & 0xff]        |\n                    ($isbox[($'.$e.$i.' >>  8) & 0xff] <<  8) |\n                    ($isbox[($'.$e.$i.' >> 16) & 0xff] << 16) |\n                    ($isbox[($'.$e.$i.' >> 24) & 0xff] << 24);'.\"\\n\";\n            }\n            $decrypt_block .= '$in = pack(\"N*\"'.\"\\n\";\n            for ($i = 0; $i < $Nb; ++$i) {\n                $decrypt_block.= ',\n                    ($'.$e.$i.                        ' & '.((int)0xFF000000).') ^\n                    ($'.$e.(($Nb + $i - $c[1]) % $Nb).' &         0x00FF0000   ) ^\n                    ($'.$e.(($Nb + $i - $c[2]) % $Nb).' &         0x0000FF00   ) ^\n                    ($'.$e.(($Nb + $i - $c[3]) % $Nb).' &         0x000000FF   ) ^\n                    '.$dw[$i].\"\\n\";\n            }\n            $decrypt_block .= ');';\n\n            $lambda_functions[$code_hash] = $this->_createInlineCryptFunction(\n                array(\n                   'init_crypt'    => '',\n                   'init_encrypt'  => $init_encrypt,\n                   'init_decrypt'  => $init_decrypt,\n                   'encrypt_block' => $encrypt_block,\n                   'decrypt_block' => $decrypt_block\n                )\n            );\n        }\n        $this->inline_crypt = $lambda_functions[$code_hash];\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Pure-PHP implementation of AES.\n *\n * Uses mcrypt, if available/possible, and an internal implementation, otherwise.\n *\n * PHP version 5\n *\n * NOTE: Since AES.php is (for compatibility and phpseclib-historical reasons) virtually\n * just a wrapper to Rijndael.php you may consider using Rijndael.php instead of\n * to save one include_once().\n *\n * If {@link self::setKeyLength() setKeyLength()} isn't called, it'll be calculated from\n * {@link self::setKey() setKey()}.  ie. if the key is 128-bits, the key length will be 128-bits.  If it's 136-bits\n * it'll be null-padded to 192-bits and 192 bits will be the key length until {@link self::setKey() setKey()}\n * is called, again, at which point, it'll be recalculated.\n *\n * Since \\phpseclib\\Crypt\\AES extends \\phpseclib\\Crypt\\Rijndael, some functions are available to be called that, in the context of AES, don't\n * make a whole lot of sense.  {@link self::setBlockLength() setBlockLength()}, for instance.  Calling that function,\n * however possible, won't do anything (AES has a fixed block length whereas Rijndael has a variable one).\n *\n * Here's a short example of how to use this library:\n * <code>\n * <?php\n *    include 'vendor/autoload.php';\n *\n *    $aes = new \\phpseclib\\Crypt\\AES();\n *\n *    $aes->setKey('abcdefghijklmnop');\n *\n *    $size = 10 * 1024;\n *    $plaintext = '';\n *    for ($i = 0; $i < $size; $i++) {\n *        $plaintext.= 'a';\n *    }\n *\n *    echo $aes->decrypt($aes->encrypt($plaintext));\n * ?>\n * </code>\n *\n * @category  Crypt\n * @package   AES\n * @author    Jim Wigginton <terrafrost@php.net>\n * @copyright 2008 Jim Wigginton\n * @license   http://www.opensource.org/licenses/mit-license.html  MIT License\n * @link      http://phpseclib.sourceforge.net\n */\n\nnamespace phpseclib\\Crypt;\n\nuse phpseclib\\Crypt\\Rijndael;\n\n/**\n * Pure-PHP implementation of AES.\n *\n * @package AES\n * @author  Jim Wigginton <terrafrost@php.net>\n * @access  public\n */\nclass AES extends Rijndael\n{\n    /**\n     * Dummy function\n     *\n     * Since \\phpseclib\\Crypt\\AES extends \\phpseclib\\Crypt\\Rijndael, this function is, technically, available, but it doesn't do anything.\n     *\n     * @see \\phpseclib\\Crypt\\Rijndael::setBlockLength()\n     * @access public\n     * @param int $length\n     */\n    function setBlockLength($length)\n    {\n        return;\n    }\n\n    /**\n     * Sets the key length\n     *\n     * Valid key lengths are 128, 192, and 256.  If the length is less than 128, it will be rounded up to\n     * 128.  If the length is greater than 128 and invalid, it will be rounded down to the closest valid amount.\n     *\n     * @see \\phpseclib\\Crypt\\Rijndael:setKeyLength()\n     * @access public\n     * @param int $length\n     */\n    function setKeyLength($length)\n    {\n        switch ($length) {\n            case 160:\n                $length = 192;\n                break;\n            case 224:\n                $length = 256;\n        }\n        parent::setKeyLength($length);\n    }\n\n    /**\n     * Sets the key.\n     *\n     * Rijndael supports five different key lengths, AES only supports three.\n     *\n     * @see \\phpseclib\\Crypt\\Rijndael:setKey()\n     * @see setKeyLength()\n     * @access public\n     * @param string $key\n     */\n    function setKey($key)\n    {\n        parent::setKey($key);\n\n        if (!$this->explicit_key_length) {\n            $length = strlen($key);\n            switch (true) {\n                case $length <= 16:\n                    $this->key_length = 16;\n                    break;\n                case $length <= 24:\n                    $this->key_length = 24;\n                    break;\n                default:\n                    $this->key_length = 32;\n            }\n            $this->_setEngine();\n        }\n    }\n}\n", "<?php\n\n/**\n * Base Class for all \\phpseclib\\Crypt\\* cipher classes\n *\n * PHP version 5\n *\n * Internally for phpseclib developers:\n *  If you plan to add a new cipher class, please note following rules:\n *\n *  - The new \\phpseclib\\Crypt\\* cipher class should extend \\phpseclib\\Crypt\\Base\n *\n *  - Following methods are then required to be overridden/overloaded:\n *\n *    - _encryptBlock()\n *\n *    - _decryptBlock()\n *\n *    - _setupKey()\n *\n *  - All other methods are optional to be overridden/overloaded\n *\n *  - Look at the source code of the current ciphers how they extend \\phpseclib\\Crypt\\Base\n *    and take one of them as a start up for the new cipher class.\n *\n *  - Please read all the other comments/notes/hints here also for each class var/method\n *\n * @category  Crypt\n * @package   Base\n * @author    Jim Wigginton <terrafrost@php.net>\n * @author    Hans-Juergen Petrich <petrich@tronic-media.com>\n * @copyright 2007 Jim Wigginton\n * @license   http://www.opensource.org/licenses/mit-license.html  MIT License\n * @link      http://phpseclib.sourceforge.net\n */\n\nnamespace phpseclib\\Crypt;\n\nuse phpseclib\\Crypt\\Hash;\n\n/**\n * Base Class for all \\phpseclib\\Crypt\\* cipher classes\n *\n * @package Base\n * @author  Jim Wigginton <terrafrost@php.net>\n * @author  Hans-Juergen Petrich <petrich@tronic-media.com>\n */\nabstract class Base\n{\n    /**#@+\n     * @access public\n     * @see \\phpseclib\\Crypt\\Base::encrypt()\n     * @see \\phpseclib\\Crypt\\Base::decrypt()\n     */\n    /**\n     * Encrypt / decrypt using the Counter mode.\n     *\n     * Set to -1 since that's what Crypt/Random.php uses to index the CTR mode.\n     *\n     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29\n     */\n    const MODE_CTR = -1;\n    /**\n     * Encrypt / decrypt using the Electronic Code Book mode.\n     *\n     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29\n     */\n    const MODE_ECB = 1;\n    /**\n     * Encrypt / decrypt using the Code Book Chaining mode.\n     *\n     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29\n     */\n    const MODE_CBC = 2;\n    /**\n     * Encrypt / decrypt using the Cipher Feedback mode.\n     *\n     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher_feedback_.28CFB.29\n     */\n    const MODE_CFB = 3;\n    /**\n     * Encrypt / decrypt using the Output Feedback mode.\n     *\n     * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Output_feedback_.28OFB.29\n     */\n    const MODE_OFB = 4;\n    /**\n     * Encrypt / decrypt using streaming mode.\n     */\n    const MODE_STREAM = 5;\n    /**#@-*/\n\n    /**\n     * Whirlpool available flag\n     *\n     * @see \\phpseclib\\Crypt\\Base::_hashInlineCryptFunction()\n     * @var bool\n     * @access private\n     */\n    static $WHIRLPOOL_AVAILABLE;\n\n    /**#@+\n     * @access private\n     * @see \\phpseclib\\Crypt\\Base::__construct()\n     */\n    /**\n     * Base value for the internal implementation $engine switch\n     */\n    const ENGINE_INTERNAL = 1;\n    /**\n     * Base value for the mcrypt implementation $engine switch\n     */\n    const ENGINE_MCRYPT = 2;\n    /**\n     * Base value for the mcrypt implementation $engine switch\n     */\n    const ENGINE_OPENSSL = 3;\n    /**#@-*/\n\n    /**\n     * The Encryption Mode\n     *\n     * @see self::__construct()\n     * @var int\n     * @access private\n     */\n    var $mode;\n\n    /**\n     * The Block Length of the block cipher\n     *\n     * @var int\n     * @access private\n     */\n    var $block_size = 16;\n\n    /**\n     * The Key\n     *\n     * @see self::setKey()\n     * @var string\n     * @access private\n     */\n    var $key = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n    /**\n     * The Initialization Vector\n     *\n     * @see self::setIV()\n     * @var string\n     * @access private\n     */\n    var $iv;\n\n    /**\n     * A \"sliding\" Initialization Vector\n     *\n     * @see self::enableContinuousBuffer()\n     * @see self::_clearBuffers()\n     * @var string\n     * @access private\n     */\n    var $encryptIV;\n\n    /**\n     * A \"sliding\" Initialization Vector\n     *\n     * @see self::enableContinuousBuffer()\n     * @see self::_clearBuffers()\n     * @var string\n     * @access private\n     */\n    var $decryptIV;\n\n    /**\n     * Continuous Buffer status\n     *\n     * @see self::enableContinuousBuffer()\n     * @var bool\n     * @access private\n     */\n    var $continuousBuffer = false;\n\n    /**\n     * Encryption buffer for CTR, OFB and CFB modes\n     *\n     * @see self::encrypt()\n     * @see self::_clearBuffers()\n     * @var array\n     * @access private\n     */\n    var $enbuffer;\n\n    /**\n     * Decryption buffer for CTR, OFB and CFB modes\n     *\n     * @see self::decrypt()\n     * @see self::_clearBuffers()\n     * @var array\n     * @access private\n     */\n    var $debuffer;\n\n    /**\n     * mcrypt resource for encryption\n     *\n     * The mcrypt resource can be recreated every time something needs to be created or it can be created just once.\n     * Since mcrypt operates in continuous mode, by default, it'll need to be recreated when in non-continuous mode.\n     *\n     * @see self::encrypt()\n     * @var resource\n     * @access private\n     */\n    var $enmcrypt;\n\n    /**\n     * mcrypt resource for decryption\n     *\n     * The mcrypt resource can be recreated every time something needs to be created or it can be created just once.\n     * Since mcrypt operates in continuous mode, by default, it'll need to be recreated when in non-continuous mode.\n     *\n     * @see self::decrypt()\n     * @var resource\n     * @access private\n     */\n    var $demcrypt;\n\n    /**\n     * Does the enmcrypt resource need to be (re)initialized?\n     *\n     * @see \\phpseclib\\Crypt\\Twofish::setKey()\n     * @see \\phpseclib\\Crypt\\Twofish::setIV()\n     * @var bool\n     * @access private\n     */\n    var $enchanged = true;\n\n    /**\n     * Does the demcrypt resource need to be (re)initialized?\n     *\n     * @see \\phpseclib\\Crypt\\Twofish::setKey()\n     * @see \\phpseclib\\Crypt\\Twofish::setIV()\n     * @var bool\n     * @access private\n     */\n    var $dechanged = true;\n\n    /**\n     * mcrypt resource for CFB mode\n     *\n     * mcrypt's CFB mode, in (and only in) buffered context,\n     * is broken, so phpseclib implements the CFB mode by it self,\n     * even when the mcrypt php extension is available.\n     *\n     * In order to do the CFB-mode work (fast) phpseclib\n     * use a separate ECB-mode mcrypt resource.\n     *\n     * @link http://phpseclib.sourceforge.net/cfb-demo.phps\n     * @see self::encrypt()\n     * @see self::decrypt()\n     * @see self::_setupMcrypt()\n     * @var resource\n     * @access private\n     */\n    var $ecb;\n\n    /**\n     * Optimizing value while CFB-encrypting\n     *\n     * Only relevant if $continuousBuffer enabled\n     * and $engine == self::ENGINE_MCRYPT\n     *\n     * It's faster to re-init $enmcrypt if\n     * $buffer bytes > $cfb_init_len than\n     * using the $ecb resource furthermore.\n     *\n     * This value depends of the chosen cipher\n     * and the time it would be needed for it's\n     * initialization [by mcrypt_generic_init()]\n     * which, typically, depends on the complexity\n     * on its internaly Key-expanding algorithm.\n     *\n     * @see self::encrypt()\n     * @var int\n     * @access private\n     */\n    var $cfb_init_len = 600;\n\n    /**\n     * Does internal cipher state need to be (re)initialized?\n     *\n     * @see self::setKey()\n     * @see self::setIV()\n     * @see self::disableContinuousBuffer()\n     * @var bool\n     * @access private\n     */\n    var $changed = true;\n\n    /**\n     * Padding status\n     *\n     * @see self::enablePadding()\n     * @var bool\n     * @access private\n     */\n    var $padding = true;\n\n    /**\n     * Is the mode one that is paddable?\n     *\n     * @see self::__construct()\n     * @var bool\n     * @access private\n     */\n    var $paddable = false;\n\n    /**\n     * Holds which crypt engine internaly should be use,\n     * which will be determined automatically on __construct()\n     *\n     * Currently available $engines are:\n     * - self::ENGINE_OPENSSL  (very fast, php-extension: openssl, extension_loaded('openssl') required)\n     * - self::ENGINE_MCRYPT   (fast, php-extension: mcrypt, extension_loaded('mcrypt') required)\n     * - self::ENGINE_INTERNAL (slower, pure php-engine, no php-extension required)\n     *\n     * @see self::_setEngine()\n     * @see self::encrypt()\n     * @see self::decrypt()\n     * @var int\n     * @access private\n     */\n    var $engine;\n\n    /**\n     * Holds the preferred crypt engine\n     *\n     * @see self::_setEngine()\n     * @see self::setPreferredEngine()\n     * @var int\n     * @access private\n     */\n    var $preferredEngine;\n\n    /**\n     * The mcrypt specific name of the cipher\n     *\n     * Only used if $engine == self::ENGINE_MCRYPT\n     *\n     * @link http://www.php.net/mcrypt_module_open\n     * @link http://www.php.net/mcrypt_list_algorithms\n     * @see self::_setupMcrypt()\n     * @var string\n     * @access private\n     */\n    var $cipher_name_mcrypt;\n\n    /**\n     * The openssl specific name of the cipher\n     *\n     * Only used if $engine == self::ENGINE_OPENSSL\n     *\n     * @link http://www.php.net/openssl-get-cipher-methods\n     * @var string\n     * @access private\n     */\n    var $cipher_name_openssl;\n\n    /**\n     * The openssl specific name of the cipher in ECB mode\n     *\n     * If OpenSSL does not support the mode we're trying to use (CTR)\n     * it can still be emulated with ECB mode.\n     *\n     * @link http://www.php.net/openssl-get-cipher-methods\n     * @var string\n     * @access private\n     */\n    var $cipher_name_openssl_ecb;\n\n    /**\n     * The default salt used by setPassword()\n     *\n     * @see self::setPassword()\n     * @var string\n     * @access private\n     */\n    var $password_default_salt = 'phpseclib/salt';\n\n    /**\n     * The name of the performance-optimized callback function\n     *\n     * Used by encrypt() / decrypt()\n     * only if $engine == self::ENGINE_INTERNAL\n     *\n     * @see self::encrypt()\n     * @see self::decrypt()\n     * @see self::_setupInlineCrypt()\n     * @see self::$use_inline_crypt\n     * @var Callback\n     * @access private\n     */\n    var $inline_crypt;\n\n    /**\n     * Holds whether performance-optimized $inline_crypt() can/should be used.\n     *\n     * @see self::encrypt()\n     * @see self::decrypt()\n     * @see self::inline_crypt\n     * @var mixed\n     * @access private\n     */\n    var $use_inline_crypt;\n\n    /**\n     * If OpenSSL can be used in ECB but not in CTR we can emulate CTR\n     *\n     * @see self::_openssl_ctr_process()\n     * @var bool\n     * @access private\n     */\n    var $openssl_emulate_ctr = false;\n\n    /**\n     * Determines what options are passed to openssl_encrypt/decrypt\n     *\n     * @see self::isValidEngine()\n     * @var mixed\n     * @access private\n     */\n    var $openssl_options;\n\n    /**\n     * Has the key length explicitly been set or should it be derived from the key, itself?\n     *\n     * @see self::setKeyLength()\n     * @var bool\n     * @access private\n     */\n    var $explicit_key_length = false;\n\n    /**\n     * Don't truncate / null pad key\n     *\n     * @see self::_clearBuffers()\n     * @var bool\n     * @access private\n     */\n    var $skip_key_adjustment = false;\n\n    /**\n     * Default Constructor.\n     *\n     * Determines whether or not the mcrypt extension should be used.\n     *\n     * $mode could be:\n     *\n     * - self::MODE_ECB\n     *\n     * - self::MODE_CBC\n     *\n     * - self::MODE_CTR\n     *\n     * - self::MODE_CFB\n     *\n     * - self::MODE_OFB\n     *\n     * If not explicitly set, self::MODE_CBC will be used.\n     *\n     * @param int $mode\n     * @access public\n     */\n    function __construct($mode = self::MODE_CBC)\n    {\n        // $mode dependent settings\n        switch ($mode) {\n            case self::MODE_ECB:\n                $this->paddable = true;\n                $this->mode = self::MODE_ECB;\n                break;\n            case self::MODE_CTR:\n            case self::MODE_CFB:\n            case self::MODE_OFB:\n            case self::MODE_STREAM:\n                $this->mode = $mode;\n                break;\n            case self::MODE_CBC:\n            default:\n                $this->paddable = true;\n                $this->mode = self::MODE_CBC;\n        }\n\n        $this->_setEngine();\n\n        // Determining whether inline crypting can be used by the cipher\n        if ($this->use_inline_crypt !== false && function_exists('create_function')) {\n            $this->use_inline_crypt = true;\n        }\n    }\n\n    /**\n     * Sets the initialization vector. (optional)\n     *\n     * SetIV is not required when self::MODE_ECB (or ie for AES: \\phpseclib\\Crypt\\AES::MODE_ECB) is being used.  If not explicitly set, it'll be assumed\n     * to be all zero's.\n     *\n     * @access public\n     * @param string $iv\n     * @internal Can be overwritten by a sub class, but does not have to be\n     */\n    function setIV($iv)\n    {\n        if ($this->mode == self::MODE_ECB) {\n            return;\n        }\n\n        $this->iv = $iv;\n        $this->changed = true;\n    }\n\n    /**\n     * Sets the key length.\n     *\n     * Keys with explicitly set lengths need to be treated accordingly\n     *\n     * @access public\n     * @param int $length\n     */\n    function setKeyLength($length)\n    {\n        $this->explicit_key_length = true;\n        $this->changed = true;\n        $this->_setEngine();\n    }\n\n    /**\n     * Returns the current key length in bits\n     *\n     * @access public\n     * @return int\n     */\n    function getKeyLength()\n    {\n        return $this->key_length << 3;\n    }\n\n    /**\n     * Returns the current block length in bits\n     *\n     * @access public\n     * @return int\n     */\n    function getBlockLength()\n    {\n        return $this->block_size << 3;\n    }\n\n    /**\n     * Sets the key.\n     *\n     * The min/max length(s) of the key depends on the cipher which is used.\n     * If the key not fits the length(s) of the cipher it will paded with null bytes\n     * up to the closest valid key length.  If the key is more than max length,\n     * we trim the excess bits.\n     *\n     * If the key is not explicitly set, it'll be assumed to be all null bytes.\n     *\n     * @access public\n     * @param string $key\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function setKey($key)\n    {\n        if (!$this->explicit_key_length) {\n            $this->setKeyLength(strlen($key) << 3);\n            $this->explicit_key_length = false;\n        }\n\n        $this->key = $key;\n        $this->changed = true;\n        $this->_setEngine();\n    }\n\n    /**\n     * Sets the password.\n     *\n     * Depending on what $method is set to, setPassword()'s (optional) parameters are as follows:\n     *     {@link http://en.wikipedia.org/wiki/PBKDF2 pbkdf2} or pbkdf1:\n     *         $hash, $salt, $count, $dkLen\n     *\n     *         Where $hash (default = sha1) currently supports the following hashes: see: Crypt/Hash.php\n     *\n     * @see Crypt/Hash.php\n     * @param string $password\n     * @param string $method\n     * @return bool\n     * @access public\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function setPassword($password, $method = 'pbkdf2')\n    {\n        $key = '';\n\n        switch ($method) {\n            default: // 'pbkdf2' or 'pbkdf1'\n                $func_args = func_get_args();\n\n                // Hash function\n                $hash = isset($func_args[2]) ? $func_args[2] : 'sha1';\n\n                // WPA and WPA2 use the SSID as the salt\n                $salt = isset($func_args[3]) ? $func_args[3] : $this->password_default_salt;\n\n                // RFC2898#section-4.2 uses 1,000 iterations by default\n                // WPA and WPA2 use 4,096.\n                $count = isset($func_args[4]) ? $func_args[4] : 1000;\n\n                // Keylength\n                if (isset($func_args[5])) {\n                    $dkLen = $func_args[5];\n                } else {\n                    $dkLen = $method == 'pbkdf1' ? 2 * $this->key_length : $this->key_length;\n                }\n\n                switch (true) {\n                    case $method == 'pbkdf1':\n                        $hashObj = new Hash();\n                        $hashObj->setHash($hash);\n                        if ($dkLen > $hashObj->getLength()) {\n                            user_error('Derived key too long');\n                            return false;\n                        }\n                        $t = $password . $salt;\n                        for ($i = 0; $i < $count; ++$i) {\n                            $t = $hashObj->hash($t);\n                        }\n                        $key = substr($t, 0, $dkLen);\n\n                        $this->setKey(substr($key, 0, $dkLen >> 1));\n                        $this->setIV(substr($key, $dkLen >> 1));\n\n                        return true;\n                    // Determining if php[>=5.5.0]'s hash_pbkdf2() function avail- and useable\n                    case !function_exists('hash_pbkdf2'):\n                    case !function_exists('hash_algos'):\n                    case !in_array($hash, hash_algos()):\n                        $i = 1;\n                        while (strlen($key) < $dkLen) {\n                            $hmac = new Hash();\n                            $hmac->setHash($hash);\n                            $hmac->setKey($password);\n                            $f = $u = $hmac->hash($salt . pack('N', $i++));\n                            for ($j = 2; $j <= $count; ++$j) {\n                                $u = $hmac->hash($u);\n                                $f^= $u;\n                            }\n                            $key.= $f;\n                        }\n                        $key = substr($key, 0, $dkLen);\n                        break;\n                    default:\n                        $key = hash_pbkdf2($hash, $password, $salt, $count, $dkLen, true);\n                }\n        }\n\n        $this->setKey($key);\n\n        return true;\n    }\n\n    /**\n     * Encrypts a message.\n     *\n     * $plaintext will be padded with additional bytes such that it's length is a multiple of the block size. Other cipher\n     * implementations may or may not pad in the same manner.  Other common approaches to padding and the reasons why it's\n     * necessary are discussed in the following\n     * URL:\n     *\n     * {@link http://www.di-mgt.com.au/cryptopad.html http://www.di-mgt.com.au/cryptopad.html}\n     *\n     * An alternative to padding is to, separately, send the length of the file.  This is what SSH, in fact, does.\n     * strlen($plaintext) will still need to be a multiple of the block size, however, arbitrary values can be added to make it that\n     * length.\n     *\n     * @see self::decrypt()\n     * @access public\n     * @param string $plaintext\n     * @return string $ciphertext\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function encrypt($plaintext)\n    {\n        if ($this->paddable) {\n            $plaintext = $this->_pad($plaintext);\n        }\n\n        if ($this->engine === self::ENGINE_OPENSSL) {\n            if ($this->changed) {\n                $this->_clearBuffers();\n                $this->changed = false;\n            }\n            switch ($this->mode) {\n                case self::MODE_STREAM:\n                    return openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options);\n                case self::MODE_ECB:\n                    $result = openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options);\n                    return !defined('OPENSSL_RAW_DATA') ? substr($result, 0, -$this->block_size) : $result;\n                case self::MODE_CBC:\n                    $result = openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $this->encryptIV);\n                    if ($this->continuousBuffer) {\n                        $this->encryptIV = substr($result, -$this->block_size);\n                    }\n                    return !defined('OPENSSL_RAW_DATA') ? substr($result, 0, -$this->block_size) : $result;\n                case self::MODE_CTR:\n                    return $this->_openssl_ctr_process($plaintext, $this->encryptIV, $this->enbuffer);\n                case self::MODE_CFB:\n                    // cfb loosely routines inspired by openssl's:\n                    // {@link http://cvs.openssl.org/fileview?f=openssl/crypto/modes/cfb128.c&v=1.3.2.2.2.1}\n                    $ciphertext = '';\n                    if ($this->continuousBuffer) {\n                        $iv = &$this->encryptIV;\n                        $pos = &$this->enbuffer['pos'];\n                    } else {\n                        $iv = $this->encryptIV;\n                        $pos = 0;\n                    }\n                    $len = strlen($plaintext);\n                    $i = 0;\n                    if ($pos) {\n                        $orig_pos = $pos;\n                        $max = $this->block_size - $pos;\n                        if ($len >= $max) {\n                            $i = $max;\n                            $len-= $max;\n                            $pos = 0;\n                        } else {\n                            $i = $len;\n                            $pos+= $len;\n                            $len = 0;\n                        }\n                        // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize\n                        $ciphertext = substr($iv, $orig_pos) ^ $plaintext;\n                        $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);\n                        $plaintext = substr($plaintext, $i);\n                    }\n\n                    $overflow = $len % $this->block_size;\n\n                    if ($overflow) {\n                        $ciphertext.= openssl_encrypt(substr($plaintext, 0, -$overflow) . str_repeat(\"\\0\", $this->block_size), $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);\n                        $iv = $this->_string_pop($ciphertext, $this->block_size);\n\n                        $size = $len - $overflow;\n                        $block = $iv ^ substr($plaintext, -$overflow);\n                        $iv = substr_replace($iv, $block, 0, $overflow);\n                        $ciphertext.= $block;\n                        $pos = $overflow;\n                    } elseif ($len) {\n                        $ciphertext = openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);\n                        $iv = substr($ciphertext, -$this->block_size);\n                    }\n\n                    return $ciphertext;\n                case self::MODE_OFB:\n                    return $this->_openssl_ofb_process($plaintext, $this->encryptIV, $this->enbuffer);\n            }\n        }\n\n        if ($this->engine === self::ENGINE_MCRYPT) {\n            if ($this->changed) {\n                $this->_setupMcrypt();\n                $this->changed = false;\n            }\n            if ($this->enchanged) {\n                mcrypt_generic_init($this->enmcrypt, $this->key, $this->encryptIV);\n                $this->enchanged = false;\n            }\n\n            // re: {@link http://phpseclib.sourceforge.net/cfb-demo.phps}\n            // using mcrypt's default handing of CFB the above would output two different things.  using phpseclib's\n            // rewritten CFB implementation the above outputs the same thing twice.\n            if ($this->mode == self::MODE_CFB && $this->continuousBuffer) {\n                $block_size = $this->block_size;\n                $iv = &$this->encryptIV;\n                $pos = &$this->enbuffer['pos'];\n                $len = strlen($plaintext);\n                $ciphertext = '';\n                $i = 0;\n                if ($pos) {\n                    $orig_pos = $pos;\n                    $max = $block_size - $pos;\n                    if ($len >= $max) {\n                        $i = $max;\n                        $len-= $max;\n                        $pos = 0;\n                    } else {\n                        $i = $len;\n                        $pos+= $len;\n                        $len = 0;\n                    }\n                    $ciphertext = substr($iv, $orig_pos) ^ $plaintext;\n                    $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);\n                    $this->enbuffer['enmcrypt_init'] = true;\n                }\n                if ($len >= $block_size) {\n                    if ($this->enbuffer['enmcrypt_init'] === false || $len > $this->cfb_init_len) {\n                        if ($this->enbuffer['enmcrypt_init'] === true) {\n                            mcrypt_generic_init($this->enmcrypt, $this->key, $iv);\n                            $this->enbuffer['enmcrypt_init'] = false;\n                        }\n                        $ciphertext.= mcrypt_generic($this->enmcrypt, substr($plaintext, $i, $len - $len % $block_size));\n                        $iv = substr($ciphertext, -$block_size);\n                        $len%= $block_size;\n                    } else {\n                        while ($len >= $block_size) {\n                            $iv = mcrypt_generic($this->ecb, $iv) ^ substr($plaintext, $i, $block_size);\n                            $ciphertext.= $iv;\n                            $len-= $block_size;\n                            $i+= $block_size;\n                        }\n                    }\n                }\n\n                if ($len) {\n                    $iv = mcrypt_generic($this->ecb, $iv);\n                    $block = $iv ^ substr($plaintext, -$len);\n                    $iv = substr_replace($iv, $block, 0, $len);\n                    $ciphertext.= $block;\n                    $pos = $len;\n                }\n\n                return $ciphertext;\n            }\n\n            $ciphertext = mcrypt_generic($this->enmcrypt, $plaintext);\n\n            if (!$this->continuousBuffer) {\n                mcrypt_generic_init($this->enmcrypt, $this->key, $this->encryptIV);\n            }\n\n            return $ciphertext;\n        }\n\n        if ($this->changed) {\n            $this->_setup();\n            $this->changed = false;\n        }\n        if ($this->use_inline_crypt) {\n            $inline = $this->inline_crypt;\n            return $inline('encrypt', $this, $plaintext);\n        }\n\n        $buffer = &$this->enbuffer;\n        $block_size = $this->block_size;\n        $ciphertext = '';\n        switch ($this->mode) {\n            case self::MODE_ECB:\n                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                    $ciphertext.= $this->_encryptBlock(substr($plaintext, $i, $block_size));\n                }\n                break;\n            case self::MODE_CBC:\n                $xor = $this->encryptIV;\n                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                    $block = substr($plaintext, $i, $block_size);\n                    $block = $this->_encryptBlock($block ^ $xor);\n                    $xor = $block;\n                    $ciphertext.= $block;\n                }\n                if ($this->continuousBuffer) {\n                    $this->encryptIV = $xor;\n                }\n                break;\n            case self::MODE_CTR:\n                $xor = $this->encryptIV;\n                if (strlen($buffer['ciphertext'])) {\n                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                        $block = substr($plaintext, $i, $block_size);\n                        if (strlen($block) > strlen($buffer['ciphertext'])) {\n                            $buffer['ciphertext'].= $this->_encryptBlock($xor);\n                        }\n                        $this->_increment_str($xor);\n                        $key = $this->_string_shift($buffer['ciphertext'], $block_size);\n                        $ciphertext.= $block ^ $key;\n                    }\n                } else {\n                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                        $block = substr($plaintext, $i, $block_size);\n                        $key = $this->_encryptBlock($xor);\n                        $this->_increment_str($xor);\n                        $ciphertext.= $block ^ $key;\n                    }\n                }\n                if ($this->continuousBuffer) {\n                    $this->encryptIV = $xor;\n                    if ($start = strlen($plaintext) % $block_size) {\n                        $buffer['ciphertext'] = substr($key, $start) . $buffer['ciphertext'];\n                    }\n                }\n                break;\n            case self::MODE_CFB:\n                // cfb loosely routines inspired by openssl's:\n                // {@link http://cvs.openssl.org/fileview?f=openssl/crypto/modes/cfb128.c&v=1.3.2.2.2.1}\n                if ($this->continuousBuffer) {\n                    $iv = &$this->encryptIV;\n                    $pos = &$buffer['pos'];\n                } else {\n                    $iv = $this->encryptIV;\n                    $pos = 0;\n                }\n                $len = strlen($plaintext);\n                $i = 0;\n                if ($pos) {\n                    $orig_pos = $pos;\n                    $max = $block_size - $pos;\n                    if ($len >= $max) {\n                        $i = $max;\n                        $len-= $max;\n                        $pos = 0;\n                    } else {\n                        $i = $len;\n                        $pos+= $len;\n                        $len = 0;\n                    }\n                    // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize\n                    $ciphertext = substr($iv, $orig_pos) ^ $plaintext;\n                    $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);\n                }\n                while ($len >= $block_size) {\n                    $iv = $this->_encryptBlock($iv) ^ substr($plaintext, $i, $block_size);\n                    $ciphertext.= $iv;\n                    $len-= $block_size;\n                    $i+= $block_size;\n                }\n                if ($len) {\n                    $iv = $this->_encryptBlock($iv);\n                    $block = $iv ^ substr($plaintext, $i);\n                    $iv = substr_replace($iv, $block, 0, $len);\n                    $ciphertext.= $block;\n                    $pos = $len;\n                }\n                break;\n            case self::MODE_OFB:\n                $xor = $this->encryptIV;\n                if (strlen($buffer['xor'])) {\n                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                        $block = substr($plaintext, $i, $block_size);\n                        if (strlen($block) > strlen($buffer['xor'])) {\n                            $xor = $this->_encryptBlock($xor);\n                            $buffer['xor'].= $xor;\n                        }\n                        $key = $this->_string_shift($buffer['xor'], $block_size);\n                        $ciphertext.= $block ^ $key;\n                    }\n                } else {\n                    for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                        $xor = $this->_encryptBlock($xor);\n                        $ciphertext.= substr($plaintext, $i, $block_size) ^ $xor;\n                    }\n                    $key = $xor;\n                }\n                if ($this->continuousBuffer) {\n                    $this->encryptIV = $xor;\n                    if ($start = strlen($plaintext) % $block_size) {\n                        $buffer['xor'] = substr($key, $start) . $buffer['xor'];\n                    }\n                }\n                break;\n            case self::MODE_STREAM:\n                $ciphertext = $this->_encryptBlock($plaintext);\n                break;\n        }\n\n        return $ciphertext;\n    }\n\n    /**\n     * Decrypts a message.\n     *\n     * If strlen($ciphertext) is not a multiple of the block size, null bytes will be added to the end of the string until\n     * it is.\n     *\n     * @see self::encrypt()\n     * @access public\n     * @param string $ciphertext\n     * @return string $plaintext\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function decrypt($ciphertext)\n    {\n        if ($this->paddable) {\n            // we pad with chr(0) since that's what mcrypt_generic does.  to quote from {@link http://www.php.net/function.mcrypt-generic}:\n            // \"The data is padded with \"\\0\" to make sure the length of the data is n * blocksize.\"\n            $ciphertext = str_pad($ciphertext, strlen($ciphertext) + ($this->block_size - strlen($ciphertext) % $this->block_size) % $this->block_size, chr(0));\n        }\n\n        if ($this->engine === self::ENGINE_OPENSSL) {\n            if ($this->changed) {\n                $this->_clearBuffers();\n                $this->changed = false;\n            }\n            switch ($this->mode) {\n                case self::MODE_STREAM:\n                    $plaintext = openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options);\n                    break;\n                case self::MODE_ECB:\n                    if (!defined('OPENSSL_RAW_DATA')) {\n                        $ciphertext.= openssl_encrypt('', $this->cipher_name_openssl_ecb, $this->key, true);\n                    }\n                    $plaintext = openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options);\n                    break;\n                case self::MODE_CBC:\n                    if (!defined('OPENSSL_RAW_DATA')) {\n                        $padding = str_repeat(chr($this->block_size), $this->block_size) ^ substr($ciphertext, -$this->block_size);\n                        $ciphertext.= substr(openssl_encrypt($padding, $this->cipher_name_openssl_ecb, $this->key, true), 0, $this->block_size);\n                    }\n                    $plaintext = openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $this->decryptIV);\n                    if ($this->continuousBuffer) {\n                        $this->decryptIV = substr($ciphertext, -$this->block_size);\n                    }\n                    break;\n                case self::MODE_CTR:\n                    $plaintext = $this->_openssl_ctr_process($ciphertext, $this->decryptIV, $this->debuffer);\n                    break;\n                case self::MODE_CFB:\n                    // cfb loosely routines inspired by openssl's:\n                    // {@link http://cvs.openssl.org/fileview?f=openssl/crypto/modes/cfb128.c&v=1.3.2.2.2.1}\n                    $plaintext = '';\n                    if ($this->continuousBuffer) {\n                        $iv = &$this->decryptIV;\n                        $pos = &$this->buffer['pos'];\n                    } else {\n                        $iv = $this->decryptIV;\n                        $pos = 0;\n                    }\n                    $len = strlen($ciphertext);\n                    $i = 0;\n                    if ($pos) {\n                        $orig_pos = $pos;\n                        $max = $this->block_size - $pos;\n                        if ($len >= $max) {\n                            $i = $max;\n                            $len-= $max;\n                            $pos = 0;\n                        } else {\n                            $i = $len;\n                            $pos+= $len;\n                            $len = 0;\n                        }\n                        // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $this->blocksize\n                        $plaintext = substr($iv, $orig_pos) ^ $ciphertext;\n                        $iv = substr_replace($iv, substr($ciphertext, 0, $i), $orig_pos, $i);\n                        $ciphertext = substr($ciphertext, $i);\n                    }\n                    $overflow = $len % $this->block_size;\n                    if ($overflow) {\n                        $plaintext.= openssl_decrypt(substr($ciphertext, 0, -$overflow), $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);\n                        if ($len - $overflow) {\n                            $iv = substr($ciphertext, -$overflow - $this->block_size, -$overflow);\n                        }\n                        $iv = openssl_encrypt(str_repeat(\"\\0\", $this->block_size), $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);\n                        $plaintext.= $iv ^ substr($ciphertext, -$overflow);\n                        $iv = substr_replace($iv, substr($ciphertext, -$overflow), 0, $overflow);\n                        $pos = $overflow;\n                    } elseif ($len) {\n                        $plaintext.= openssl_decrypt($ciphertext, $this->cipher_name_openssl, $this->key, $this->openssl_options, $iv);\n                        $iv = substr($ciphertext, -$this->block_size);\n                    }\n                    break;\n                case self::MODE_OFB:\n                    $plaintext = $this->_openssl_ofb_process($ciphertext, $this->decryptIV, $this->debuffer);\n            }\n\n            return $this->paddable ? $this->_unpad($plaintext) : $plaintext;\n        }\n\n        if ($this->engine === self::ENGINE_MCRYPT) {\n            $block_size = $this->block_size;\n            if ($this->changed) {\n                $this->_setupMcrypt();\n                $this->changed = false;\n            }\n            if ($this->dechanged) {\n                mcrypt_generic_init($this->demcrypt, $this->key, $this->decryptIV);\n                $this->dechanged = false;\n            }\n\n            if ($this->mode == self::MODE_CFB && $this->continuousBuffer) {\n                $iv = &$this->decryptIV;\n                $pos = &$this->debuffer['pos'];\n                $len = strlen($ciphertext);\n                $plaintext = '';\n                $i = 0;\n                if ($pos) {\n                    $orig_pos = $pos;\n                    $max = $block_size - $pos;\n                    if ($len >= $max) {\n                        $i = $max;\n                        $len-= $max;\n                        $pos = 0;\n                    } else {\n                        $i = $len;\n                        $pos+= $len;\n                        $len = 0;\n                    }\n                    // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize\n                    $plaintext = substr($iv, $orig_pos) ^ $ciphertext;\n                    $iv = substr_replace($iv, substr($ciphertext, 0, $i), $orig_pos, $i);\n                }\n                if ($len >= $block_size) {\n                    $cb = substr($ciphertext, $i, $len - $len % $block_size);\n                    $plaintext.= mcrypt_generic($this->ecb, $iv . $cb) ^ $cb;\n                    $iv = substr($cb, -$block_size);\n                    $len%= $block_size;\n                }\n                if ($len) {\n                    $iv = mcrypt_generic($this->ecb, $iv);\n                    $plaintext.= $iv ^ substr($ciphertext, -$len);\n                    $iv = substr_replace($iv, substr($ciphertext, -$len), 0, $len);\n                    $pos = $len;\n                }\n\n                return $plaintext;\n            }\n\n            $plaintext = mdecrypt_generic($this->demcrypt, $ciphertext);\n\n            if (!$this->continuousBuffer) {\n                mcrypt_generic_init($this->demcrypt, $this->key, $this->decryptIV);\n            }\n\n            return $this->paddable ? $this->_unpad($plaintext) : $plaintext;\n        }\n\n        if ($this->changed) {\n            $this->_setup();\n            $this->changed = false;\n        }\n        if ($this->use_inline_crypt) {\n            $inline = $this->inline_crypt;\n            return $inline('decrypt', $this, $ciphertext);\n        }\n\n        $block_size = $this->block_size;\n\n        $buffer = &$this->debuffer;\n        $plaintext = '';\n        switch ($this->mode) {\n            case self::MODE_ECB:\n                for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {\n                    $plaintext.= $this->_decryptBlock(substr($ciphertext, $i, $block_size));\n                }\n                break;\n            case self::MODE_CBC:\n                $xor = $this->decryptIV;\n                for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {\n                    $block = substr($ciphertext, $i, $block_size);\n                    $plaintext.= $this->_decryptBlock($block) ^ $xor;\n                    $xor = $block;\n                }\n                if ($this->continuousBuffer) {\n                    $this->decryptIV = $xor;\n                }\n                break;\n            case self::MODE_CTR:\n                $xor = $this->decryptIV;\n                if (strlen($buffer['ciphertext'])) {\n                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {\n                        $block = substr($ciphertext, $i, $block_size);\n                        if (strlen($block) > strlen($buffer['ciphertext'])) {\n                            $buffer['ciphertext'].= $this->_encryptBlock($xor);\n                            $this->_increment_str($xor);\n                        }\n                        $key = $this->_string_shift($buffer['ciphertext'], $block_size);\n                        $plaintext.= $block ^ $key;\n                    }\n                } else {\n                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {\n                        $block = substr($ciphertext, $i, $block_size);\n                        $key = $this->_encryptBlock($xor);\n                        $this->_increment_str($xor);\n                        $plaintext.= $block ^ $key;\n                    }\n                }\n                if ($this->continuousBuffer) {\n                    $this->decryptIV = $xor;\n                    if ($start = strlen($ciphertext) % $block_size) {\n                        $buffer['ciphertext'] = substr($key, $start) . $buffer['ciphertext'];\n                    }\n                }\n                break;\n            case self::MODE_CFB:\n                if ($this->continuousBuffer) {\n                    $iv = &$this->decryptIV;\n                    $pos = &$buffer['pos'];\n                } else {\n                    $iv = $this->decryptIV;\n                    $pos = 0;\n                }\n                $len = strlen($ciphertext);\n                $i = 0;\n                if ($pos) {\n                    $orig_pos = $pos;\n                    $max = $block_size - $pos;\n                    if ($len >= $max) {\n                        $i = $max;\n                        $len-= $max;\n                        $pos = 0;\n                    } else {\n                        $i = $len;\n                        $pos+= $len;\n                        $len = 0;\n                    }\n                    // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize\n                    $plaintext = substr($iv, $orig_pos) ^ $ciphertext;\n                    $iv = substr_replace($iv, substr($ciphertext, 0, $i), $orig_pos, $i);\n                }\n                while ($len >= $block_size) {\n                    $iv = $this->_encryptBlock($iv);\n                    $cb = substr($ciphertext, $i, $block_size);\n                    $plaintext.= $iv ^ $cb;\n                    $iv = $cb;\n                    $len-= $block_size;\n                    $i+= $block_size;\n                }\n                if ($len) {\n                    $iv = $this->_encryptBlock($iv);\n                    $plaintext.= $iv ^ substr($ciphertext, $i);\n                    $iv = substr_replace($iv, substr($ciphertext, $i), 0, $len);\n                    $pos = $len;\n                }\n                break;\n            case self::MODE_OFB:\n                $xor = $this->decryptIV;\n                if (strlen($buffer['xor'])) {\n                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {\n                        $block = substr($ciphertext, $i, $block_size);\n                        if (strlen($block) > strlen($buffer['xor'])) {\n                            $xor = $this->_encryptBlock($xor);\n                            $buffer['xor'].= $xor;\n                        }\n                        $key = $this->_string_shift($buffer['xor'], $block_size);\n                        $plaintext.= $block ^ $key;\n                    }\n                } else {\n                    for ($i = 0; $i < strlen($ciphertext); $i+=$block_size) {\n                        $xor = $this->_encryptBlock($xor);\n                        $plaintext.= substr($ciphertext, $i, $block_size) ^ $xor;\n                    }\n                    $key = $xor;\n                }\n                if ($this->continuousBuffer) {\n                    $this->decryptIV = $xor;\n                    if ($start = strlen($ciphertext) % $block_size) {\n                        $buffer['xor'] = substr($key, $start) . $buffer['xor'];\n                    }\n                }\n                break;\n            case self::MODE_STREAM:\n                $plaintext = $this->_decryptBlock($ciphertext);\n                break;\n        }\n        return $this->paddable ? $this->_unpad($plaintext) : $plaintext;\n    }\n\n    /**\n     * OpenSSL CTR Processor\n     *\n     * PHP's OpenSSL bindings do not operate in continuous mode so we'll wrap around it. Since the keystream\n     * for CTR is the same for both encrypting and decrypting this function is re-used by both Base::encrypt()\n     * and Base::decrypt(). Also, OpenSSL doesn't implement CTR for all of it's symmetric ciphers so this\n     * function will emulate CTR with ECB when necesary.\n     *\n     * @see self::encrypt()\n     * @see self::decrypt()\n     * @param string $plaintext\n     * @param string $encryptIV\n     * @param array $buffer\n     * @return string\n     * @access private\n     */\n    function _openssl_ctr_process($plaintext, &$encryptIV, &$buffer)\n    {\n        $ciphertext = '';\n\n        $block_size = $this->block_size;\n        $key = $this->key;\n\n        if ($this->openssl_emulate_ctr) {\n            $xor = $encryptIV;\n            if (strlen($buffer['ciphertext'])) {\n                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                    $block = substr($plaintext, $i, $block_size);\n                    if (strlen($block) > strlen($buffer['ciphertext'])) {\n                        $result = openssl_encrypt($xor, $this->cipher_name_openssl_ecb, $key, $this->openssl_options);\n                        $result = !defined('OPENSSL_RAW_DATA') ? substr($result, 0, -$this->block_size) : $result;\n                        $buffer['ciphertext'].= $result;\n                    }\n                    $this->_increment_str($xor);\n                    $otp = $this->_string_shift($buffer['ciphertext'], $block_size);\n                    $ciphertext.= $block ^ $otp;\n                }\n            } else {\n                for ($i = 0; $i < strlen($plaintext); $i+=$block_size) {\n                    $block = substr($plaintext, $i, $block_size);\n                    $otp = openssl_encrypt($xor, $this->cipher_name_openssl_ecb, $key, $this->openssl_options);\n                    $otp = !defined('OPENSSL_RAW_DATA') ? substr($otp, 0, -$this->block_size) : $otp;\n                    $this->_increment_str($xor);\n                    $ciphertext.= $block ^ $otp;\n                }\n            }\n            if ($this->continuousBuffer) {\n                $encryptIV = $xor;\n                if ($start = strlen($plaintext) % $block_size) {\n                    $buffer['ciphertext'] = substr($key, $start) . $buffer['ciphertext'];\n                }\n            }\n\n            return $ciphertext;\n        }\n\n        if (strlen($buffer['ciphertext'])) {\n            $ciphertext = $plaintext ^ $this->_string_shift($buffer['ciphertext'], strlen($plaintext));\n            $plaintext = substr($plaintext, strlen($ciphertext));\n\n            if (!strlen($plaintext)) {\n                return $ciphertext;\n            }\n        }\n\n        $overflow = strlen($plaintext) % $block_size;\n        if ($overflow) {\n            $plaintext2 = $this->_string_pop($plaintext, $overflow); // ie. trim $plaintext to a multiple of $block_size and put rest of $plaintext in $plaintext2\n            $encrypted = openssl_encrypt($plaintext . str_repeat(\"\\0\", $block_size), $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);\n            $temp = $this->_string_pop($encrypted, $block_size);\n            $ciphertext.= $encrypted . ($plaintext2 ^ $temp);\n            if ($this->continuousBuffer) {\n                $buffer['ciphertext'] = substr($temp, $overflow);\n                $encryptIV = $temp;\n            }\n        } elseif (!strlen($buffer['ciphertext'])) {\n            $ciphertext.= openssl_encrypt($plaintext . str_repeat(\"\\0\", $block_size), $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);\n            $temp = $this->_string_pop($ciphertext, $block_size);\n            if ($this->continuousBuffer) {\n                $encryptIV = $temp;\n            }\n        }\n        if ($this->continuousBuffer) {\n            if (!defined('OPENSSL_RAW_DATA')) {\n                $encryptIV.= openssl_encrypt('', $this->cipher_name_openssl_ecb, $key, $this->openssl_options);\n            }\n            $encryptIV = openssl_decrypt($encryptIV, $this->cipher_name_openssl_ecb, $key, $this->openssl_options);\n            if ($overflow) {\n                $this->_increment_str($encryptIV);\n            }\n        }\n\n        return $ciphertext;\n    }\n\n    /**\n     * OpenSSL OFB Processor\n     *\n     * PHP's OpenSSL bindings do not operate in continuous mode so we'll wrap around it. Since the keystream\n     * for OFB is the same for both encrypting and decrypting this function is re-used by both Base::encrypt()\n     * and Base::decrypt().\n     *\n     * @see self::encrypt()\n     * @see self::decrypt()\n     * @param string $plaintext\n     * @param string $encryptIV\n     * @param array $buffer\n     * @return string\n     * @access private\n     */\n    function _openssl_ofb_process($plaintext, &$encryptIV, &$buffer)\n    {\n        if (strlen($buffer['xor'])) {\n            $ciphertext = $plaintext ^ $buffer['xor'];\n            $buffer['xor'] = substr($buffer['xor'], strlen($ciphertext));\n            $plaintext = substr($plaintext, strlen($ciphertext));\n        } else {\n            $ciphertext = '';\n        }\n\n        $block_size = $this->block_size;\n\n        $len = strlen($plaintext);\n        $key = $this->key;\n        $overflow = $len % $block_size;\n\n        if (strlen($plaintext)) {\n            if ($overflow) {\n                $ciphertext.= openssl_encrypt(substr($plaintext, 0, -$overflow) . str_repeat(\"\\0\", $block_size), $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);\n                $xor = $this->_string_pop($ciphertext, $block_size);\n                if ($this->continuousBuffer) {\n                    $encryptIV = $xor;\n                }\n                $ciphertext.= $this->_string_shift($xor, $overflow) ^ substr($plaintext, -$overflow);\n                if ($this->continuousBuffer) {\n                    $buffer['xor'] = $xor;\n                }\n            } else {\n                $ciphertext = openssl_encrypt($plaintext, $this->cipher_name_openssl, $key, $this->openssl_options, $encryptIV);\n                if ($this->continuousBuffer) {\n                    $encryptIV = substr($ciphertext, -$block_size) ^ substr($plaintext, -$block_size);\n                }\n            }\n        }\n\n        return $ciphertext;\n    }\n\n    /**\n     * phpseclib <-> OpenSSL Mode Mapper\n     *\n     * May need to be overwritten by classes extending this one in some cases\n     *\n     * @return int\n     * @access private\n     */\n    function _openssl_translate_mode()\n    {\n        switch ($this->mode) {\n            case self::MODE_ECB:\n                return 'ecb';\n            case self::MODE_CBC:\n                return 'cbc';\n            case self::MODE_CTR:\n                return 'ctr';\n            case self::MODE_CFB:\n                return 'cfb';\n            case self::MODE_OFB:\n                return 'ofb';\n        }\n    }\n\n    /**\n     * Pad \"packets\".\n     *\n     * Block ciphers working by encrypting between their specified [$this->]block_size at a time\n     * If you ever need to encrypt or decrypt something that isn't of the proper length, it becomes necessary to\n     * pad the input so that it is of the proper length.\n     *\n     * Padding is enabled by default.  Sometimes, however, it is undesirable to pad strings.  Such is the case in SSH,\n     * where \"packets\" are padded with random bytes before being encrypted.  Unpad these packets and you risk stripping\n     * away characters that shouldn't be stripped away. (SSH knows how many bytes are added because the length is\n     * transmitted separately)\n     *\n     * @see self::disablePadding()\n     * @access public\n     */\n    function enablePadding()\n    {\n        $this->padding = true;\n    }\n\n    /**\n     * Do not pad packets.\n     *\n     * @see self::enablePadding()\n     * @access public\n     */\n    function disablePadding()\n    {\n        $this->padding = false;\n    }\n\n    /**\n     * Treat consecutive \"packets\" as if they are a continuous buffer.\n     *\n     * Say you have a 32-byte plaintext $plaintext.  Using the default behavior, the two following code snippets\n     * will yield different outputs:\n     *\n     * <code>\n     *    echo $rijndael->encrypt(substr($plaintext,  0, 16));\n     *    echo $rijndael->encrypt(substr($plaintext, 16, 16));\n     * </code>\n     * <code>\n     *    echo $rijndael->encrypt($plaintext);\n     * </code>\n     *\n     * The solution is to enable the continuous buffer.  Although this will resolve the above discrepancy, it creates\n     * another, as demonstrated with the following:\n     *\n     * <code>\n     *    $rijndael->encrypt(substr($plaintext, 0, 16));\n     *    echo $rijndael->decrypt($rijndael->encrypt(substr($plaintext, 16, 16)));\n     * </code>\n     * <code>\n     *    echo $rijndael->decrypt($rijndael->encrypt(substr($plaintext, 16, 16)));\n     * </code>\n     *\n     * With the continuous buffer disabled, these would yield the same output.  With it enabled, they yield different\n     * outputs.  The reason is due to the fact that the initialization vector's change after every encryption /\n     * decryption round when the continuous buffer is enabled.  When it's disabled, they remain constant.\n     *\n     * Put another way, when the continuous buffer is enabled, the state of the \\phpseclib\\Crypt\\*() object changes after each\n     * encryption / decryption round, whereas otherwise, it'd remain constant.  For this reason, it's recommended that\n     * continuous buffers not be used.  They do offer better security and are, in fact, sometimes required (SSH uses them),\n     * however, they are also less intuitive and more likely to cause you problems.\n     *\n     * @see self::disableContinuousBuffer()\n     * @access public\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function enableContinuousBuffer()\n    {\n        if ($this->mode == self::MODE_ECB) {\n            return;\n        }\n\n        $this->continuousBuffer = true;\n\n        $this->_setEngine();\n    }\n\n    /**\n     * Treat consecutive packets as if they are a discontinuous buffer.\n     *\n     * The default behavior.\n     *\n     * @see self::enableContinuousBuffer()\n     * @access public\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function disableContinuousBuffer()\n    {\n        if ($this->mode == self::MODE_ECB) {\n            return;\n        }\n        if (!$this->continuousBuffer) {\n            return;\n        }\n\n        $this->continuousBuffer = false;\n        $this->changed = true;\n\n        $this->_setEngine();\n    }\n\n    /**\n     * Test for engine validity\n     *\n     * @see self::__construct()\n     * @param int $engine\n     * @access public\n     * @return bool\n     */\n    function isValidEngine($engine)\n    {\n        switch ($engine) {\n            case self::ENGINE_OPENSSL:\n                if ($this->mode == self::MODE_STREAM && $this->continuousBuffer) {\n                    return false;\n                }\n                $this->openssl_emulate_ctr = false;\n                $result = $this->cipher_name_openssl &&\n                          extension_loaded('openssl') &&\n                          // PHP 5.3.0 - 5.3.2 did not let you set IV's\n                          version_compare(PHP_VERSION, '5.3.3', '>=');\n                if (!$result) {\n                    return false;\n                }\n\n                // prior to PHP 5.4.0 OPENSSL_RAW_DATA and OPENSSL_ZERO_PADDING were not defined. instead of expecting an integer\n                // $options openssl_encrypt expected a boolean $raw_data.\n                if (!defined('OPENSSL_RAW_DATA')) {\n                    $this->openssl_options = true;\n                } else {\n                    $this->openssl_options = OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING;\n                }\n\n                $methods = openssl_get_cipher_methods();\n                if (in_array($this->cipher_name_openssl, $methods)) {\n                    return true;\n                }\n                // not all of openssl's symmetric cipher's support ctr. for those\n                // that don't we'll emulate it\n                switch ($this->mode) {\n                    case self::MODE_CTR:\n                        if (in_array($this->cipher_name_openssl_ecb, $methods)) {\n                            $this->openssl_emulate_ctr = true;\n                            return true;\n                        }\n                }\n                return false;\n            case self::ENGINE_MCRYPT:\n                return $this->cipher_name_mcrypt &&\n                       extension_loaded('mcrypt') &&\n                       in_array($this->cipher_name_mcrypt, mcrypt_list_algorithms());\n            case self::ENGINE_INTERNAL:\n                return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Sets the preferred crypt engine\n     *\n     * Currently, $engine could be:\n     *\n     * - \\phpseclib\\Crypt\\Base::ENGINE_OPENSSL  [very fast]\n     *\n     * - \\phpseclib\\Crypt\\Base::ENGINE_MCRYPT   [fast]\n     *\n     * - \\phpseclib\\Crypt\\Base::ENGINE_INTERNAL [slow]\n     *\n     * If the preferred crypt engine is not available the fastest available one will be used\n     *\n     * @see self::__construct()\n     * @param int $engine\n     * @access public\n     */\n    function setPreferredEngine($engine)\n    {\n        switch ($engine) {\n            //case self::ENGINE_OPENSSL;\n            case self::ENGINE_MCRYPT:\n            case self::ENGINE_INTERNAL:\n                $this->preferredEngine = $engine;\n                break;\n            default:\n                $this->preferredEngine = self::ENGINE_OPENSSL;\n        }\n\n        $this->_setEngine();\n    }\n\n    /**\n     * Returns the engine currently being utilized\n     *\n     * @see self::_setEngine()\n     * @access public\n     */\n    function getEngine()\n    {\n        return $this->engine;\n    }\n\n    /**\n     * Sets the engine as appropriate\n     *\n     * @see self::__construct()\n     * @access private\n     */\n    function _setEngine()\n    {\n        $this->engine = null;\n\n        $candidateEngines = array(\n            $this->preferredEngine,\n            self::ENGINE_OPENSSL,\n            self::ENGINE_MCRYPT\n        );\n        foreach ($candidateEngines as $engine) {\n            if ($this->isValidEngine($engine)) {\n                $this->engine = $engine;\n                break;\n            }\n        }\n        if (!$this->engine) {\n            $this->engine = self::ENGINE_INTERNAL;\n        }\n\n        if ($this->engine != self::ENGINE_MCRYPT && $this->enmcrypt) {\n            // Closing the current mcrypt resource(s). _mcryptSetup() will, if needed,\n            // (re)open them with the module named in $this->cipher_name_mcrypt\n            mcrypt_module_close($this->enmcrypt);\n            mcrypt_module_close($this->demcrypt);\n            $this->enmcrypt = null;\n            $this->demcrypt = null;\n\n            if ($this->ecb) {\n                mcrypt_module_close($this->ecb);\n                $this->ecb = null;\n            }\n        }\n\n        $this->changed = true;\n    }\n\n    /**\n     * Encrypts a block\n     *\n     * Note: Must be extended by the child \\phpseclib\\Crypt\\* class\n     *\n     * @access private\n     * @param string $in\n     * @return string\n     */\n    abstract function _encryptBlock($in);\n\n    /**\n     * Decrypts a block\n     *\n     * Note: Must be extended by the child \\phpseclib\\Crypt\\* class\n     *\n     * @access private\n     * @param string $in\n     * @return string\n     */\n    abstract function _decryptBlock($in);\n\n    /**\n     * Setup the key (expansion)\n     *\n     * Only used if $engine == self::ENGINE_INTERNAL\n     *\n     * Note: Must extend by the child \\phpseclib\\Crypt\\* class\n     *\n     * @see self::_setup()\n     * @access private\n     */\n    abstract function _setupKey();\n\n    /**\n     * Setup the self::ENGINE_INTERNAL $engine\n     *\n     * (re)init, if necessary, the internal cipher $engine and flush all $buffers\n     * Used (only) if $engine == self::ENGINE_INTERNAL\n     *\n     * _setup() will be called each time if $changed === true\n     * typically this happens when using one or more of following public methods:\n     *\n     * - setKey()\n     *\n     * - setIV()\n     *\n     * - disableContinuousBuffer()\n     *\n     * - First run of encrypt() / decrypt() with no init-settings\n     *\n     * @see self::setKey()\n     * @see self::setIV()\n     * @see self::disableContinuousBuffer()\n     * @access private\n     * @internal _setup() is always called before en/decryption.\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function _setup()\n    {\n        $this->_clearBuffers();\n        $this->_setupKey();\n\n        if ($this->use_inline_crypt) {\n            $this->_setupInlineCrypt();\n        }\n    }\n\n    /**\n     * Setup the self::ENGINE_MCRYPT $engine\n     *\n     * (re)init, if necessary, the (ext)mcrypt resources and flush all $buffers\n     * Used (only) if $engine = self::ENGINE_MCRYPT\n     *\n     * _setupMcrypt() will be called each time if $changed === true\n     * typically this happens when using one or more of following public methods:\n     *\n     * - setKey()\n     *\n     * - setIV()\n     *\n     * - disableContinuousBuffer()\n     *\n     * - First run of encrypt() / decrypt()\n     *\n     * @see self::setKey()\n     * @see self::setIV()\n     * @see self::disableContinuousBuffer()\n     * @access private\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function _setupMcrypt()\n    {\n        $this->_clearBuffers();\n        $this->enchanged = $this->dechanged = true;\n\n        if (!isset($this->enmcrypt)) {\n            static $mcrypt_modes = array(\n                self::MODE_CTR    => 'ctr',\n                self::MODE_ECB    => MCRYPT_MODE_ECB,\n                self::MODE_CBC    => MCRYPT_MODE_CBC,\n                self::MODE_CFB    => 'ncfb',\n                self::MODE_OFB    => MCRYPT_MODE_NOFB,\n                self::MODE_STREAM => MCRYPT_MODE_STREAM,\n            );\n\n            $this->demcrypt = mcrypt_module_open($this->cipher_name_mcrypt, '', $mcrypt_modes[$this->mode], '');\n            $this->enmcrypt = mcrypt_module_open($this->cipher_name_mcrypt, '', $mcrypt_modes[$this->mode], '');\n\n            // we need the $ecb mcrypt resource (only) in MODE_CFB with enableContinuousBuffer()\n            // to workaround mcrypt's broken ncfb implementation in buffered mode\n            // see: {@link http://phpseclib.sourceforge.net/cfb-demo.phps}\n            if ($this->mode == self::MODE_CFB) {\n                $this->ecb = mcrypt_module_open($this->cipher_name_mcrypt, '', MCRYPT_MODE_ECB, '');\n            }\n        } // else should mcrypt_generic_deinit be called?\n\n        if ($this->mode == self::MODE_CFB) {\n            mcrypt_generic_init($this->ecb, $this->key, str_repeat(\"\\0\", $this->block_size));\n        }\n    }\n\n    /**\n     * Pads a string\n     *\n     * Pads a string using the RSA PKCS padding standards so that its length is a multiple of the blocksize.\n     * $this->block_size - (strlen($text) % $this->block_size) bytes are added, each of which is equal to\n     * chr($this->block_size - (strlen($text) % $this->block_size)\n     *\n     * If padding is disabled and $text is not a multiple of the blocksize, the string will be padded regardless\n     * and padding will, hence forth, be enabled.\n     *\n     * @see self::_unpad()\n     * @param string $text\n     * @access private\n     * @return string\n     */\n    function _pad($text)\n    {\n        $length = strlen($text);\n\n        if (!$this->padding) {\n            if ($length % $this->block_size == 0) {\n                return $text;\n            } else {\n                user_error(\"The plaintext's length ($length) is not a multiple of the block size ({$this->block_size})\");\n                $this->padding = true;\n            }\n        }\n\n        $pad = $this->block_size - ($length % $this->block_size);\n\n        return str_pad($text, $length + $pad, chr($pad));\n    }\n\n    /**\n     * Unpads a string.\n     *\n     * If padding is enabled and the reported padding length is invalid the encryption key will be assumed to be wrong\n     * and false will be returned.\n     *\n     * @see self::_pad()\n     * @param string $text\n     * @access private\n     * @return string\n     */\n    function _unpad($text)\n    {\n        if (!$this->padding) {\n            return $text;\n        }\n\n        $length = ord($text[strlen($text) - 1]);\n\n        if (!$length || $length > $this->block_size) {\n            return false;\n        }\n\n        return substr($text, 0, -$length);\n    }\n\n    /**\n     * Clears internal buffers\n     *\n     * Clearing/resetting the internal buffers is done everytime\n     * after disableContinuousBuffer() or on cipher $engine (re)init\n     * ie after setKey() or setIV()\n     *\n     * @access public\n     * @internal Could, but not must, extend by the child Crypt_* class\n     */\n    function _clearBuffers()\n    {\n        $this->enbuffer = $this->debuffer = array('ciphertext' => '', 'xor' => '', 'pos' => 0, 'enmcrypt_init' => true);\n\n        // mcrypt's handling of invalid's $iv:\n        // $this->encryptIV = $this->decryptIV = strlen($this->iv) == $this->block_size ? $this->iv : str_repeat(\"\\0\", $this->block_size);\n        $this->encryptIV = $this->decryptIV = str_pad(substr($this->iv, 0, $this->block_size), $this->block_size, \"\\0\");\n\n        if (!$this->skip_key_adjustment) {\n            $this->key = str_pad(substr($this->key, 0, $this->key_length), $this->key_length, \"\\0\");\n        }\n    }\n\n    /**\n     * String Shift\n     *\n     * Inspired by array_shift\n     *\n     * @param string $string\n     * @param int $index\n     * @access private\n     * @return string\n     */\n    function _string_shift(&$string, $index = 1)\n    {\n        $substr = substr($string, 0, $index);\n        $string = substr($string, $index);\n        return $substr;\n    }\n\n    /**\n     * String Pop\n     *\n     * Inspired by array_pop\n     *\n     * @param string $string\n     * @param int $index\n     * @access private\n     * @return string\n     */\n    function _string_pop(&$string, $index = 1)\n    {\n        $substr = substr($string, -$index);\n        $string = substr($string, 0, -$index);\n        return $substr;\n    }\n\n    /**\n     * Increment the current string\n     *\n     * @see self::decrypt()\n     * @see self::encrypt()\n     * @param string $var\n     * @access private\n     */\n    function _increment_str(&$var)\n    {\n        for ($i = 4; $i <= strlen($var); $i+= 4) {\n            $temp = substr($var, -$i, 4);\n            switch ($temp) {\n                case \"\\xFF\\xFF\\xFF\\xFF\":\n                    $var = substr_replace($var, \"\\x00\\x00\\x00\\x00\", -$i, 4);\n                    break;\n                case \"\\x7F\\xFF\\xFF\\xFF\":\n                    $var = substr_replace($var, \"\\x80\\x00\\x00\\x00\", -$i, 4);\n                    return;\n                default:\n                    $temp = unpack('Nnum', $temp);\n                    $var = substr_replace($var, pack('N', $temp['num'] + 1), -$i, 4);\n                    return;\n            }\n        }\n\n        $remainder = strlen($var) % 4;\n\n        if ($remainder == 0) {\n            return;\n        }\n\n        $temp = unpack('Nnum', str_pad(substr($var, 0, $remainder), 4, \"\\0\", STR_PAD_LEFT));\n        $temp = substr(pack('N', $temp['num'] + 1), -$remainder);\n        $var = substr_replace($var, $temp, 0, $remainder);\n    }\n\n    /**\n     * Setup the performance-optimized function for de/encrypt()\n     *\n     * Stores the created (or existing) callback function-name\n     * in $this->inline_crypt\n     *\n     * Internally for phpseclib developers:\n     *\n     *     _setupInlineCrypt() would be called only if:\n     *\n     *     - $engine == self::ENGINE_INTERNAL and\n     *\n     *     - $use_inline_crypt === true\n     *\n     *     - each time on _setup(), after(!) _setupKey()\n     *\n     *\n     *     This ensures that _setupInlineCrypt() has always a\n     *     full ready2go initializated internal cipher $engine state\n     *     where, for example, the keys allready expanded,\n     *     keys/block_size calculated and such.\n     *\n     *     It is, each time if called, the responsibility of _setupInlineCrypt():\n     *\n     *     - to set $this->inline_crypt to a valid and fully working callback function\n     *       as a (faster) replacement for encrypt() / decrypt()\n     *\n     *     - NOT to create unlimited callback functions (for memory reasons!)\n     *       no matter how often _setupInlineCrypt() would be called. At some\n     *       point of amount they must be generic re-useable.\n     *\n     *     - the code of _setupInlineCrypt() it self,\n     *       and the generated callback code,\n     *       must be, in following order:\n     *       - 100% safe\n     *       - 100% compatible to encrypt()/decrypt()\n     *       - using only php5+ features/lang-constructs/php-extensions if\n     *         compatibility (down to php4) or fallback is provided\n     *       - readable/maintainable/understandable/commented and... not-cryptic-styled-code :-)\n     *       - >= 10% faster than encrypt()/decrypt() [which is, by the way,\n     *         the reason for the existence of _setupInlineCrypt() :-)]\n     *       - memory-nice\n     *       - short (as good as possible)\n     *\n     * Note: - _setupInlineCrypt() is using _createInlineCryptFunction() to create the full callback function code.\n     *       - In case of using inline crypting, _setupInlineCrypt() must extend by the child \\phpseclib\\Crypt\\* class.\n     *       - The following variable names are reserved:\n     *         - $_*  (all variable names prefixed with an underscore)\n     *         - $self (object reference to it self. Do not use $this, but $self instead)\n     *         - $in (the content of $in has to en/decrypt by the generated code)\n     *       - The callback function should not use the 'return' statement, but en/decrypt'ing the content of $in only\n     *\n     *\n     * @see self::_setup()\n     * @see self::_createInlineCryptFunction()\n     * @see self::encrypt()\n     * @see self::decrypt()\n     * @access private\n     * @internal If a Crypt_* class providing inline crypting it must extend _setupInlineCrypt()\n     */\n    function _setupInlineCrypt()\n    {\n        // If, for any reason, an extending \\phpseclib\\Crypt\\Base() \\phpseclib\\Crypt\\* class\n        // not using inline crypting then it must be ensured that: $this->use_inline_crypt = false\n        // ie in the class var declaration of $use_inline_crypt in general for the \\phpseclib\\Crypt\\* class,\n        // in the constructor at object instance-time\n        // or, if it's runtime-specific, at runtime\n\n        $this->use_inline_crypt = false;\n    }\n\n    /**\n     * Creates the performance-optimized function for en/decrypt()\n     *\n     * Internally for phpseclib developers:\n     *\n     *    _createInlineCryptFunction():\n     *\n     *    - merge the $cipher_code [setup'ed by _setupInlineCrypt()]\n     *      with the current [$this->]mode of operation code\n     *\n     *    - create the $inline function, which called by encrypt() / decrypt()\n     *      as its replacement to speed up the en/decryption operations.\n     *\n     *    - return the name of the created $inline callback function\n     *\n     *    - used to speed up en/decryption\n     *\n     *\n     *\n     *    The main reason why can speed up things [up to 50%] this way are:\n     *\n     *    - using variables more effective then regular.\n     *      (ie no use of expensive arrays but integers $k_0, $k_1 ...\n     *      or even, for example, the pure $key[] values hardcoded)\n     *\n     *    - avoiding 1000's of function calls of ie _encryptBlock()\n     *      but inlining the crypt operations.\n     *      in the mode of operation for() loop.\n     *\n     *    - full loop unroll the (sometimes key-dependent) rounds\n     *      avoiding this way ++$i counters and runtime-if's etc...\n     *\n     *    The basic code architectur of the generated $inline en/decrypt()\n     *    lambda function, in pseudo php, is:\n     *\n     *    <code>\n     *    +----------------------------------------------------------------------------------------------+\n     *    | callback $inline = create_function:                                                          |\n     *    | lambda_function_0001_crypt_ECB($action, $text)                                               |\n     *    | {                                                                                            |\n     *    |     INSERT PHP CODE OF:                                                                      |\n     *    |     $cipher_code['init_crypt'];                  // general init code.                       |\n     *    |                                                  // ie: $sbox'es declarations used for       |\n     *    |                                                  //     encrypt and decrypt'ing.             |\n     *    |                                                                                              |\n     *    |     switch ($action) {                                                                       |\n     *    |         case 'encrypt':                                                                      |\n     *    |             INSERT PHP CODE OF:                                                              |\n     *    |             $cipher_code['init_encrypt'];       // encrypt sepcific init code.               |\n     *    |                                                    ie: specified $key or $box                |\n     *    |                                                        declarations for encrypt'ing.         |\n     *    |                                                                                              |\n     *    |             foreach ($ciphertext) {                                                          |\n     *    |                 $in = $block_size of $ciphertext;                                            |\n     *    |                                                                                              |\n     *    |                 INSERT PHP CODE OF:                                                          |\n     *    |                 $cipher_code['encrypt_block'];  // encrypt's (string) $in, which is always:  |\n     *    |                                                 // strlen($in) == $this->block_size          |\n     *    |                                                 // here comes the cipher algorithm in action |\n     *    |                                                 // for encryption.                           |\n     *    |                                                 // $cipher_code['encrypt_block'] has to      |\n     *    |                                                 // encrypt the content of the $in variable   |\n     *    |                                                                                              |\n     *    |                 $plaintext .= $in;                                                           |\n     *    |             }                                                                                |\n     *    |             return $plaintext;                                                               |\n     *    |                                                                                              |\n     *    |         case 'decrypt':                                                                      |\n     *    |             INSERT PHP CODE OF:                                                              |\n     *    |             $cipher_code['init_decrypt'];       // decrypt sepcific init code                |\n     *    |                                                    ie: specified $key or $box                |\n     *    |                                                        declarations for decrypt'ing.         |\n     *    |             foreach ($plaintext) {                                                           |\n     *    |                 $in = $block_size of $plaintext;                                             |\n     *    |                                                                                              |\n     *    |                 INSERT PHP CODE OF:                                                          |\n     *    |                 $cipher_code['decrypt_block'];  // decrypt's (string) $in, which is always   |\n     *    |                                                 // strlen($in) == $this->block_size          |\n     *    |                                                 // here comes the cipher algorithm in action |\n     *    |                                                 // for decryption.                           |\n     *    |                                                 // $cipher_code['decrypt_block'] has to      |\n     *    |                                                 // decrypt the content of the $in variable   |\n     *    |                 $ciphertext .= $in;                                                          |\n     *    |             }                                                                                |\n     *    |             return $ciphertext;                                                              |\n     *    |     }                                                                                        |\n     *    | }                                                                                            |\n     *    +----------------------------------------------------------------------------------------------+\n     *    </code>\n     *\n     *    See also the \\phpseclib\\Crypt\\*::_setupInlineCrypt()'s for\n     *    productive inline $cipher_code's how they works.\n     *\n     *    Structure of:\n     *    <code>\n     *    $cipher_code = array(\n     *        'init_crypt'    => (string) '', // optional\n     *        'init_encrypt'  => (string) '', // optional\n     *        'init_decrypt'  => (string) '', // optional\n     *        'encrypt_block' => (string) '', // required\n     *        'decrypt_block' => (string) ''  // required\n     *    );\n     *    </code>\n     *\n     * @see self::_setupInlineCrypt()\n     * @see self::encrypt()\n     * @see self::decrypt()\n     * @param array $cipher_code\n     * @access private\n     * @return string (the name of the created callback function)\n     */\n    function _createInlineCryptFunction($cipher_code)\n    {\n        $block_size = $this->block_size;\n\n        // optional\n        $init_crypt    = isset($cipher_code['init_crypt'])    ? $cipher_code['init_crypt']    : '';\n        $init_encrypt  = isset($cipher_code['init_encrypt'])  ? $cipher_code['init_encrypt']  : '';\n        $init_decrypt  = isset($cipher_code['init_decrypt'])  ? $cipher_code['init_decrypt']  : '';\n        // required\n        $encrypt_block = $cipher_code['encrypt_block'];\n        $decrypt_block = $cipher_code['decrypt_block'];\n\n        // Generating mode of operation inline code,\n        // merged with the $cipher_code algorithm\n        // for encrypt- and decryption.\n        switch ($this->mode) {\n            case self::MODE_ECB:\n                $encrypt = $init_encrypt . '\n                    $_ciphertext = \"\";\n                    $_plaintext_len = strlen($_text);\n\n                    for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {\n                        $in = substr($_text, $_i, '.$block_size.');\n                        '.$encrypt_block.'\n                        $_ciphertext.= $in;\n                    }\n\n                    return $_ciphertext;\n                    ';\n\n                $decrypt = $init_decrypt . '\n                    $_plaintext = \"\";\n                    $_text = str_pad($_text, strlen($_text) + ('.$block_size.' - strlen($_text) % '.$block_size.') % '.$block_size.', chr(0));\n                    $_ciphertext_len = strlen($_text);\n\n                    for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {\n                        $in = substr($_text, $_i, '.$block_size.');\n                        '.$decrypt_block.'\n                        $_plaintext.= $in;\n                    }\n\n                    return $self->_unpad($_plaintext);\n                    ';\n                break;\n            case self::MODE_CTR:\n                $encrypt = $init_encrypt . '\n                    $_ciphertext = \"\";\n                    $_plaintext_len = strlen($_text);\n                    $_xor = $self->encryptIV;\n                    $_buffer = &$self->enbuffer;\n                    if (strlen($_buffer[\"ciphertext\"])) {\n                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {\n                            $_block = substr($_text, $_i, '.$block_size.');\n                            if (strlen($_block) > strlen($_buffer[\"ciphertext\"])) {\n                                $in = $_xor;\n                                '.$encrypt_block.'\n                                $self->_increment_str($_xor);\n                                $_buffer[\"ciphertext\"].= $in;\n                            }\n                            $_key = $self->_string_shift($_buffer[\"ciphertext\"], '.$block_size.');\n                            $_ciphertext.= $_block ^ $_key;\n                        }\n                    } else {\n                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {\n                            $_block = substr($_text, $_i, '.$block_size.');\n                            $in = $_xor;\n                            '.$encrypt_block.'\n                            $self->_increment_str($_xor);\n                            $_key = $in;\n                            $_ciphertext.= $_block ^ $_key;\n                        }\n                    }\n                    if ($self->continuousBuffer) {\n                        $self->encryptIV = $_xor;\n                        if ($_start = $_plaintext_len % '.$block_size.') {\n                            $_buffer[\"ciphertext\"] = substr($_key, $_start) . $_buffer[\"ciphertext\"];\n                        }\n                    }\n\n                    return $_ciphertext;\n                ';\n\n                $decrypt = $init_encrypt . '\n                    $_plaintext = \"\";\n                    $_ciphertext_len = strlen($_text);\n                    $_xor = $self->decryptIV;\n                    $_buffer = &$self->debuffer;\n\n                    if (strlen($_buffer[\"ciphertext\"])) {\n                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {\n                            $_block = substr($_text, $_i, '.$block_size.');\n                            if (strlen($_block) > strlen($_buffer[\"ciphertext\"])) {\n                                $in = $_xor;\n                                '.$encrypt_block.'\n                                $self->_increment_str($_xor);\n                                $_buffer[\"ciphertext\"].= $in;\n                            }\n                            $_key = $self->_string_shift($_buffer[\"ciphertext\"], '.$block_size.');\n                            $_plaintext.= $_block ^ $_key;\n                        }\n                    } else {\n                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {\n                            $_block = substr($_text, $_i, '.$block_size.');\n                            $in = $_xor;\n                            '.$encrypt_block.'\n                            $self->_increment_str($_xor);\n                            $_key = $in;\n                            $_plaintext.= $_block ^ $_key;\n                        }\n                    }\n                    if ($self->continuousBuffer) {\n                        $self->decryptIV = $_xor;\n                        if ($_start = $_ciphertext_len % '.$block_size.') {\n                            $_buffer[\"ciphertext\"] = substr($_key, $_start) . $_buffer[\"ciphertext\"];\n                        }\n                    }\n\n                    return $_plaintext;\n                    ';\n                break;\n            case self::MODE_CFB:\n                $encrypt = $init_encrypt . '\n                    $_ciphertext = \"\";\n                    $_buffer = &$self->enbuffer;\n\n                    if ($self->continuousBuffer) {\n                        $_iv = &$self->encryptIV;\n                        $_pos = &$_buffer[\"pos\"];\n                    } else {\n                        $_iv = $self->encryptIV;\n                        $_pos = 0;\n                    }\n                    $_len = strlen($_text);\n                    $_i = 0;\n                    if ($_pos) {\n                        $_orig_pos = $_pos;\n                        $_max = '.$block_size.' - $_pos;\n                        if ($_len >= $_max) {\n                            $_i = $_max;\n                            $_len-= $_max;\n                            $_pos = 0;\n                        } else {\n                            $_i = $_len;\n                            $_pos+= $_len;\n                            $_len = 0;\n                        }\n                        $_ciphertext = substr($_iv, $_orig_pos) ^ $_text;\n                        $_iv = substr_replace($_iv, $_ciphertext, $_orig_pos, $_i);\n                    }\n                    while ($_len >= '.$block_size.') {\n                        $in = $_iv;\n                        '.$encrypt_block.';\n                        $_iv = $in ^ substr($_text, $_i, '.$block_size.');\n                        $_ciphertext.= $_iv;\n                        $_len-= '.$block_size.';\n                        $_i+= '.$block_size.';\n                    }\n                    if ($_len) {\n                        $in = $_iv;\n                        '.$encrypt_block.'\n                        $_iv = $in;\n                        $_block = $_iv ^ substr($_text, $_i);\n                        $_iv = substr_replace($_iv, $_block, 0, $_len);\n                        $_ciphertext.= $_block;\n                        $_pos = $_len;\n                    }\n                    return $_ciphertext;\n                ';\n\n                $decrypt = $init_encrypt . '\n                    $_plaintext = \"\";\n                    $_buffer = &$self->debuffer;\n\n                    if ($self->continuousBuffer) {\n                        $_iv = &$self->decryptIV;\n                        $_pos = &$_buffer[\"pos\"];\n                    } else {\n                        $_iv = $self->decryptIV;\n                        $_pos = 0;\n                    }\n                    $_len = strlen($_text);\n                    $_i = 0;\n                    if ($_pos) {\n                        $_orig_pos = $_pos;\n                        $_max = '.$block_size.' - $_pos;\n                        if ($_len >= $_max) {\n                            $_i = $_max;\n                            $_len-= $_max;\n                            $_pos = 0;\n                        } else {\n                            $_i = $_len;\n                            $_pos+= $_len;\n                            $_len = 0;\n                        }\n                        $_plaintext = substr($_iv, $_orig_pos) ^ $_text;\n                        $_iv = substr_replace($_iv, substr($_text, 0, $_i), $_orig_pos, $_i);\n                    }\n                    while ($_len >= '.$block_size.') {\n                        $in = $_iv;\n                        '.$encrypt_block.'\n                        $_iv = $in;\n                        $cb = substr($_text, $_i, '.$block_size.');\n                        $_plaintext.= $_iv ^ $cb;\n                        $_iv = $cb;\n                        $_len-= '.$block_size.';\n                        $_i+= '.$block_size.';\n                    }\n                    if ($_len) {\n                        $in = $_iv;\n                        '.$encrypt_block.'\n                        $_iv = $in;\n                        $_plaintext.= $_iv ^ substr($_text, $_i);\n                        $_iv = substr_replace($_iv, substr($_text, $_i), 0, $_len);\n                        $_pos = $_len;\n                    }\n\n                    return $_plaintext;\n                    ';\n                break;\n            case self::MODE_OFB:\n                $encrypt = $init_encrypt . '\n                    $_ciphertext = \"\";\n                    $_plaintext_len = strlen($_text);\n                    $_xor = $self->encryptIV;\n                    $_buffer = &$self->enbuffer;\n\n                    if (strlen($_buffer[\"xor\"])) {\n                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {\n                            $_block = substr($_text, $_i, '.$block_size.');\n                            if (strlen($_block) > strlen($_buffer[\"xor\"])) {\n                                $in = $_xor;\n                                '.$encrypt_block.'\n                                $_xor = $in;\n                                $_buffer[\"xor\"].= $_xor;\n                            }\n                            $_key = $self->_string_shift($_buffer[\"xor\"], '.$block_size.');\n                            $_ciphertext.= $_block ^ $_key;\n                        }\n                    } else {\n                        for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {\n                            $in = $_xor;\n                            '.$encrypt_block.'\n                            $_xor = $in;\n                            $_ciphertext.= substr($_text, $_i, '.$block_size.') ^ $_xor;\n                        }\n                        $_key = $_xor;\n                    }\n                    if ($self->continuousBuffer) {\n                        $self->encryptIV = $_xor;\n                        if ($_start = $_plaintext_len % '.$block_size.') {\n                             $_buffer[\"xor\"] = substr($_key, $_start) . $_buffer[\"xor\"];\n                        }\n                    }\n                    return $_ciphertext;\n                    ';\n\n                $decrypt = $init_encrypt . '\n                    $_plaintext = \"\";\n                    $_ciphertext_len = strlen($_text);\n                    $_xor = $self->decryptIV;\n                    $_buffer = &$self->debuffer;\n\n                    if (strlen($_buffer[\"xor\"])) {\n                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {\n                            $_block = substr($_text, $_i, '.$block_size.');\n                            if (strlen($_block) > strlen($_buffer[\"xor\"])) {\n                                $in = $_xor;\n                                '.$encrypt_block.'\n                                $_xor = $in;\n                                $_buffer[\"xor\"].= $_xor;\n                            }\n                            $_key = $self->_string_shift($_buffer[\"xor\"], '.$block_size.');\n                            $_plaintext.= $_block ^ $_key;\n                        }\n                    } else {\n                        for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {\n                            $in = $_xor;\n                            '.$encrypt_block.'\n                            $_xor = $in;\n                            $_plaintext.= substr($_text, $_i, '.$block_size.') ^ $_xor;\n                        }\n                        $_key = $_xor;\n                    }\n                    if ($self->continuousBuffer) {\n                        $self->decryptIV = $_xor;\n                        if ($_start = $_ciphertext_len % '.$block_size.') {\n                             $_buffer[\"xor\"] = substr($_key, $_start) . $_buffer[\"xor\"];\n                        }\n                    }\n                    return $_plaintext;\n                    ';\n                break;\n            case self::MODE_STREAM:\n                $encrypt = $init_encrypt . '\n                    $_ciphertext = \"\";\n                    '.$encrypt_block.'\n                    return $_ciphertext;\n                    ';\n                $decrypt = $init_decrypt . '\n                    $_plaintext = \"\";\n                    '.$decrypt_block.'\n                    return $_plaintext;\n                    ';\n                break;\n            // case self::MODE_CBC:\n            default:\n                $encrypt = $init_encrypt . '\n                    $_ciphertext = \"\";\n                    $_plaintext_len = strlen($_text);\n\n                    $in = $self->encryptIV;\n\n                    for ($_i = 0; $_i < $_plaintext_len; $_i+= '.$block_size.') {\n                        $in = substr($_text, $_i, '.$block_size.') ^ $in;\n                        '.$encrypt_block.'\n                        $_ciphertext.= $in;\n                    }\n\n                    if ($self->continuousBuffer) {\n                        $self->encryptIV = $in;\n                    }\n\n                    return $_ciphertext;\n                    ';\n\n                $decrypt = $init_decrypt . '\n                    $_plaintext = \"\";\n                    $_text = str_pad($_text, strlen($_text) + ('.$block_size.' - strlen($_text) % '.$block_size.') % '.$block_size.', chr(0));\n                    $_ciphertext_len = strlen($_text);\n\n                    $_iv = $self->decryptIV;\n\n                    for ($_i = 0; $_i < $_ciphertext_len; $_i+= '.$block_size.') {\n                        $in = $_block = substr($_text, $_i, '.$block_size.');\n                        '.$decrypt_block.'\n                        $_plaintext.= $in ^ $_iv;\n                        $_iv = $_block;\n                    }\n\n                    if ($self->continuousBuffer) {\n                        $self->decryptIV = $_iv;\n                    }\n\n                    return $self->_unpad($_plaintext);\n                    ';\n                break;\n        }\n\n        // Create the $inline function and return its name as string. Ready to run!\n        return create_function('$_action, &$self, $_text', $init_crypt . 'if ($_action == \"encrypt\") { ' . $encrypt . ' } else { ' . $decrypt . ' }');\n    }\n\n    /**\n     * Holds the lambda_functions table (classwide)\n     *\n     * Each name of the lambda function, created from\n     * _setupInlineCrypt() && _createInlineCryptFunction()\n     * is stored, classwide (!), here for reusing.\n     *\n     * The string-based index of $function is a classwide\n     * uniqe value representing, at least, the $mode of\n     * operation (or more... depends of the optimizing level)\n     * for which $mode the lambda function was created.\n     *\n     * @access private\n     * @return array &$functions\n     */\n    function &_getLambdaFunctions()\n    {\n        static $functions = array();\n        return $functions;\n    }\n\n    /**\n     * Generates a digest from $bytes\n     *\n     * @see self::_setupInlineCrypt()\n     * @access private\n     * @param $bytes\n     * @return string\n     */\n    function _hashInlineCryptFunction($bytes)\n    {\n        if (!isset(self::$WHIRLPOOL_AVAILABLE)) {\n            self::$WHIRLPOOL_AVAILABLE = extension_loaded('hash') && in_array('whirlpool', hash_algos());\n        }\n\n        $result = '';\n        $hash = $bytes;\n\n        switch (true) {\n            case self::$WHIRLPOOL_AVAILABLE:\n                foreach (str_split($bytes, 64) as $t) {\n                    $hash = hash('whirlpool', $hash, true);\n                    $result .= $t ^ $hash;\n                }\n                return $result . hash('whirlpool', $hash, true);\n            default:\n                $len = strlen($bytes);\n                for ($i = 0; $i < $len; $i+=20) {\n                    $t = substr($bytes, $i, 20);\n                    $hash = pack('H*', sha1($hash));\n                    $result .= $t ^ $hash;\n                }\n                return $result . pack('H*', sha1($hash));\n        }\n    }\n}\n", "<?php\n\n/**\n * Random Number Generator\n *\n * PHP version 5\n *\n * Here's a short example of how to use this library:\n * <code>\n * <?php\n *    include 'vendor/autoload.php';\n *\n *    echo bin2hex(\\phpseclib\\Crypt\\Random::string(8));\n * ?>\n * </code>\n *\n * @category  Crypt\n * @package   Random\n * @author    Jim Wigginton <terrafrost@php.net>\n * @copyright 2007 Jim Wigginton\n * @license   http://www.opensource.org/licenses/mit-license.html  MIT License\n * @link      http://phpseclib.sourceforge.net\n */\n\nnamespace phpseclib\\Crypt;\n\nuse phpseclib\\Crypt\\AES;\nuse phpseclib\\Crypt\\Base;\nuse phpseclib\\Crypt\\Blowfish;\nuse phpseclib\\Crypt\\DES;\nuse phpseclib\\Crypt\\RC4;\nuse phpseclib\\Crypt\\TripleDES;\nuse phpseclib\\Crypt\\Twofish;\n\n/**\n * Pure-PHP Random Number Generator\n *\n * @package Random\n * @author  Jim Wigginton <terrafrost@php.net>\n * @access  public\n */\nclass Random\n{\n    /**\n     * Generate a random string.\n     *\n     * Although microoptimizations are generally discouraged as they impair readability this function is ripe with\n     * microoptimizations because this function has the potential of being called a huge number of times.\n     * eg. for RSA key generation.\n     *\n     * @param int $length\n     * @return string\n     */\n    static function string($length)\n    {\n        if (version_compare(PHP_VERSION, '7.0.0', '>=')) {\n            try {\n                return \\random_bytes($length);\n            } catch (\\Throwable $e) {\n                // If a sufficient source of randomness is unavailable, random_bytes() will throw an\n                // object that implements the Throwable interface (Exception, TypeError, Error).\n                // We don't actually need to do anything here. The string() method should just continue\n                // as normal. Note, however, that if we don't have a sufficient source of randomness for\n                // random_bytes(), most of the other calls here will fail too, so we'll end up using\n                // the PHP implementation.\n            }\n        }\n\n        if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {\n            // method 1. prior to PHP 5.3 this would call rand() on windows hence the function_exists('class_alias') call.\n            // ie. class_alias is a function that was introduced in PHP 5.3\n            if (extension_loaded('mcrypt') && function_exists('class_alias')) {\n                return mcrypt_create_iv($length);\n            }\n            // method 2. openssl_random_pseudo_bytes was introduced in PHP 5.3.0 but prior to PHP 5.3.4 there was,\n            // to quote <http://php.net/ChangeLog-5.php#5.3.4>, \"possible blocking behavior\". as of 5.3.4\n            // openssl_random_pseudo_bytes and mcrypt_create_iv do the exact same thing on Windows. ie. they both\n            // call php_win32_get_random_bytes():\n            //\n            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/ext/openssl/openssl.c#L5008\n            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/ext/mcrypt/mcrypt.c#L1392\n            //\n            // php_win32_get_random_bytes() is defined thusly:\n            //\n            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/win32/winutil.c#L80\n            //\n            // we're calling it, all the same, in the off chance that the mcrypt extension is not available\n            if (extension_loaded('openssl') && version_compare(PHP_VERSION, '5.3.4', '>=')) {\n                return openssl_random_pseudo_bytes($length);\n            }\n        } else {\n            // method 1. the fastest\n            if (extension_loaded('openssl')) {\n                return openssl_random_pseudo_bytes($length);\n            }\n            // method 2\n            static $fp = true;\n            if ($fp === true) {\n                // warning's will be output unles the error suppression operator is used. errors such as\n                // \"open_basedir restriction in effect\", \"Permission denied\", \"No such file or directory\", etc.\n                $fp = @fopen('/dev/urandom', 'rb');\n            }\n            if ($fp !== true && $fp !== false) { // surprisingly faster than !is_bool() or is_resource()\n                return fread($fp, $length);\n            }\n            // method 3. pretty much does the same thing as method 2 per the following url:\n            // https://github.com/php/php-src/blob/7014a0eb6d1611151a286c0ff4f2238f92c120d6/ext/mcrypt/mcrypt.c#L1391\n            // surprisingly slower than method 2. maybe that's because mcrypt_create_iv does a bunch of error checking that we're\n            // not doing. regardless, this'll only be called if this PHP script couldn't open /dev/urandom due to open_basedir\n            // restrictions or some such\n            if (extension_loaded('mcrypt')) {\n                return mcrypt_create_iv($length, MCRYPT_DEV_URANDOM);\n            }\n        }\n        // at this point we have no choice but to use a pure-PHP CSPRNG\n\n        // cascade entropy across multiple PHP instances by fixing the session and collecting all\n        // environmental variables, including the previous session data and the current session\n        // data.\n        //\n        // mt_rand seeds itself by looking at the PID and the time, both of which are (relatively)\n        // easy to guess at. linux uses mouse clicks, keyboard timings, etc, as entropy sources, but\n        // PHP isn't low level to be able to use those as sources and on a web server there's not likely\n        // going to be a ton of keyboard or mouse action. web servers do have one thing that we can use\n        // however, a ton of people visiting the website. obviously you don't want to base your seeding\n        // soley on parameters a potential attacker sends but (1) not everything in $_SERVER is controlled\n        // by the user and (2) this isn't just looking at the data sent by the current user - it's based\n        // on the data sent by all users. one user requests the page and a hash of their info is saved.\n        // another user visits the page and the serialization of their data is utilized along with the\n        // server envirnment stuff and a hash of the previous http request data (which itself utilizes\n        // a hash of the session data before that). certainly an attacker should be assumed to have\n        // full control over his own http requests. he, however, is not going to have control over\n        // everyone's http requests.\n        static $crypto = false, $v;\n        if ($crypto === false) {\n            // save old session data\n            $old_session_id = session_id();\n            $old_use_cookies = ini_get('session.use_cookies');\n            $old_session_cache_limiter = session_cache_limiter();\n            $_OLD_SESSION = isset($_SESSION) ? $_SESSION : false;\n            if ($old_session_id != '') {\n                session_write_close();\n            }\n\n            session_id(1);\n            ini_set('session.use_cookies', 0);\n            session_cache_limiter('');\n            session_start();\n\n            $v = $seed = $_SESSION['seed'] = pack('H*', sha1(\n                serialize($_SERVER) .\n                serialize($_POST) .\n                serialize($_GET) .\n                serialize($_COOKIE) .\n                serialize($GLOBALS) .\n                serialize($_SESSION) .\n                serialize($_OLD_SESSION)\n            ));\n            if (!isset($_SESSION['count'])) {\n                $_SESSION['count'] = 0;\n            }\n            $_SESSION['count']++;\n\n            session_write_close();\n\n            // restore old session data\n            if ($old_session_id != '') {\n                session_id($old_session_id);\n                session_start();\n                ini_set('session.use_cookies', $old_use_cookies);\n                session_cache_limiter($old_session_cache_limiter);\n            } else {\n                if ($_OLD_SESSION !== false) {\n                    $_SESSION = $_OLD_SESSION;\n                    unset($_OLD_SESSION);\n                } else {\n                    unset($_SESSION);\n                }\n            }\n\n            // in SSH2 a shared secret and an exchange hash are generated through the key exchange process.\n            // the IV client to server is the hash of that \"nonce\" with the letter A and for the encryption key it's the letter C.\n            // if the hash doesn't produce enough a key or an IV that's long enough concat successive hashes of the\n            // original hash and the current hash. we'll be emulating that. for more info see the following URL:\n            //\n            // http://tools.ietf.org/html/rfc4253#section-7.2\n            //\n            // see the is_string($crypto) part for an example of how to expand the keys\n            $key = pack('H*', sha1($seed . 'A'));\n            $iv = pack('H*', sha1($seed . 'C'));\n\n            // ciphers are used as per the nist.gov link below. also, see this link:\n            //\n            // http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator#Designs_based_on_cryptographic_primitives\n            switch (true) {\n                case class_exists('\\phpseclib\\Crypt\\AES'):\n                    $crypto = new AES(Base::MODE_CTR);\n                    break;\n                case class_exists('\\phpseclib\\Crypt\\Twofish'):\n                    $crypto = new Twofish(Base::MODE_CTR);\n                    break;\n                case class_exists('\\phpseclib\\Crypt\\Blowfish'):\n                    $crypto = new Blowfish(Base::MODE_CTR);\n                    break;\n                case class_exists('\\phpseclib\\Crypt\\TripleDES'):\n                    $crypto = new TripleDES(Base::MODE_CTR);\n                    break;\n                case class_exists('\\phpseclib\\Crypt\\DES'):\n                    $crypto = new DES(Base::MODE_CTR);\n                    break;\n                case class_exists('\\phpseclib\\Crypt\\RC4'):\n                    $crypto = new RC4();\n                    break;\n                default:\n                    user_error(__CLASS__ . ' requires at least one symmetric cipher be loaded');\n                    return false;\n            }\n\n            $crypto->setKey($key);\n            $crypto->setIV($iv);\n            $crypto->enableContinuousBuffer();\n        }\n\n        //return $crypto->encrypt(str_repeat(\"\\0\", $length));\n\n        // the following is based off of ANSI X9.31:\n        //\n        // http://csrc.nist.gov/groups/STM/cavp/documents/rng/931rngext.pdf\n        //\n        // OpenSSL uses that same standard for it's random numbers:\n        //\n        // http://www.opensource.apple.com/source/OpenSSL/OpenSSL-38/openssl/fips-1.0/rand/fips_rand.c\n        // (do a search for \"ANS X9.31 A.2.4\")\n        $result = '';\n        while (strlen($result) < $length) {\n            $i = $crypto->encrypt(microtime()); // strlen(microtime()) == 21\n            $r = $crypto->encrypt($i ^ $v); // strlen($v) == 20\n            $v = $crypto->encrypt($r ^ $i); // strlen($r) == 20\n            $result.= $r;\n        }\n        return substr($result, 0, $length);\n    }\n}\n", "<?php\n\n/**\n * Pure-PHP implementation of Rijndael.\n *\n * Uses mcrypt, if available/possible, and an internal implementation, otherwise.\n *\n * PHP version 5\n *\n * If {@link self::setBlockLength() setBlockLength()} isn't called, it'll be assumed to be 128 bits.  If\n * {@link self::setKeyLength() setKeyLength()} isn't called, it'll be calculated from\n * {@link self::setKey() setKey()}.  ie. if the key is 128-bits, the key length will be 128-bits.  If it's\n * 136-bits it'll be null-padded to 192-bits and 192 bits will be the key length until\n * {@link self::setKey() setKey()} is called, again, at which point, it'll be recalculated.\n *\n * Not all Rijndael implementations may support 160-bits or 224-bits as the block length / key length.  mcrypt, for example,\n * does not.  AES, itself, only supports block lengths of 128 and key lengths of 128, 192, and 256.\n * {@link http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=10 Rijndael-ammended.pdf#page=10} defines the\n * algorithm for block lengths of 192 and 256 but not for block lengths / key lengths of 160 and 224.  Indeed, 160 and 224\n * are first defined as valid key / block lengths in\n * {@link http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=44 Rijndael-ammended.pdf#page=44}:\n * Extensions: Other block and Cipher Key lengths.\n * Note: Use of 160/224-bit Keys must be explicitly set by setKeyLength(160) respectively setKeyLength(224).\n *\n * {@internal The variable names are the same as those in\n * {@link http://www.csrc.nist.gov/publications/fips/fips197/fips-197.pdf#page=10 fips-197.pdf#page=10}.}}\n *\n * Here's a short example of how to use this library:\n * <code>\n * <?php\n *    include 'vendor/autoload.php';\n *\n *    $rijndael = new \\phpseclib\\Crypt\\Rijndael();\n *\n *    $rijndael->setKey('abcdefghijklmnop');\n *\n *    $size = 10 * 1024;\n *    $plaintext = '';\n *    for ($i = 0; $i < $size; $i++) {\n *        $plaintext.= 'a';\n *    }\n *\n *    echo $rijndael->decrypt($rijndael->encrypt($plaintext));\n * ?>\n * </code>\n *\n * @category  Crypt\n * @package   Rijndael\n * @author    Jim Wigginton <terrafrost@php.net>\n * @copyright 2008 Jim Wigginton\n * @license   http://www.opensource.org/licenses/mit-license.html  MIT License\n * @link      http://phpseclib.sourceforge.net\n */\n\nnamespace phpseclib\\Crypt;\n\nuse phpseclib\\Crypt\\Base;\n\n/**\n * Pure-PHP implementation of Rijndael.\n *\n * @package Rijndael\n * @author  Jim Wigginton <terrafrost@php.net>\n * @access  public\n */\nclass Rijndael extends Base\n{\n    /**\n     * The mcrypt specific name of the cipher\n     *\n     * Mcrypt is useable for 128/192/256-bit $block_size/$key_length. For 160/224 not.\n     * \\phpseclib\\Crypt\\Rijndael determines automatically whether mcrypt is useable\n     * or not for the current $block_size/$key_length.\n     * In case of, $cipher_name_mcrypt will be set dynamically at run time accordingly.\n     *\n     * @see \\phpseclib\\Crypt\\Base::cipher_name_mcrypt\n     * @see \\phpseclib\\Crypt\\Base::engine\n     * @see self::isValidEngine()\n     * @var string\n     * @access private\n     */\n    var $cipher_name_mcrypt = 'rijndael-128';\n\n    /**\n     * The default salt used by setPassword()\n     *\n     * @see \\phpseclib\\Crypt\\Base::password_default_salt\n     * @see \\phpseclib\\Crypt\\Base::setPassword()\n     * @var string\n     * @access private\n     */\n    var $password_default_salt = 'phpseclib';\n\n    /**\n     * The Key Schedule\n     *\n     * @see self::_setup()\n     * @var array\n     * @access private\n     */\n    var $w;\n\n    /**\n     * The Inverse Key Schedule\n     *\n     * @see self::_setup()\n     * @var array\n     * @access private\n     */\n    var $dw;\n\n    /**\n     * The Block Length divided by 32\n     *\n     * @see self::setBlockLength()\n     * @var int\n     * @access private\n     * @internal The max value is 256 / 32 = 8, the min value is 128 / 32 = 4.  Exists in conjunction with $block_size\n     *    because the encryption / decryption / key schedule creation requires this number and not $block_size.  We could\n     *    derive this from $block_size or vice versa, but that'd mean we'd have to do multiple shift operations, so in lieu\n     *    of that, we'll just precompute it once.\n     */\n    var $Nb = 4;\n\n    /**\n     * The Key Length (in bytes)\n     *\n     * @see self::setKeyLength()\n     * @var int\n     * @access private\n     * @internal The max value is 256 / 8 = 32, the min value is 128 / 8 = 16.  Exists in conjunction with $Nk\n     *    because the encryption / decryption / key schedule creation requires this number and not $key_length.  We could\n     *    derive this from $key_length or vice versa, but that'd mean we'd have to do multiple shift operations, so in lieu\n     *    of that, we'll just precompute it once.\n     */\n    var $key_length = 16;\n\n    /**\n     * The Key Length divided by 32\n     *\n     * @see self::setKeyLength()\n     * @var int\n     * @access private\n     * @internal The max value is 256 / 32 = 8, the min value is 128 / 32 = 4\n     */\n    var $Nk = 4;\n\n    /**\n     * The Number of Rounds\n     *\n     * @var int\n     * @access private\n     * @internal The max value is 14, the min value is 10.\n     */\n    var $Nr;\n\n    /**\n     * Shift offsets\n     *\n     * @var array\n     * @access private\n     */\n    var $c;\n\n    /**\n     * Holds the last used key- and block_size information\n     *\n     * @var array\n     * @access private\n     */\n    var $kl;\n\n    /**\n     * Sets the key length.\n     *\n     * Valid key lengths are 128, 160, 192, 224, and 256.  If the length is less than 128, it will be rounded up to\n     * 128.  If the length is greater than 128 and invalid, it will be rounded down to the closest valid amount.\n     *\n     * Note: phpseclib extends Rijndael (and AES) for using 160- and 224-bit keys but they are officially not defined\n     *       and the most (if not all) implementations are not able using 160/224-bit keys but round/pad them up to\n     *       192/256 bits as, for example, mcrypt will do.\n     *\n     *       That said, if you want be compatible with other Rijndael and AES implementations,\n     *       you should not setKeyLength(160) or setKeyLength(224).\n     *\n     * Additional: In case of 160- and 224-bit keys, phpseclib will/can, for that reason, not use\n     *             the mcrypt php extension, even if available.\n     *             This results then in slower encryption.\n     *\n     * @access public\n     * @param int $length\n     */\n    function setKeyLength($length)\n    {\n        switch (true) {\n            case $length <= 128:\n                $this->key_length = 16;\n                break;\n            case $length <= 160:\n                $this->key_length = 20;\n                break;\n            case $length <= 192:\n                $this->key_length = 24;\n                break;\n            case $length <= 224:\n                $this->key_length = 28;\n                break;\n            default:\n                $this->key_length = 32;\n        }\n\n        parent::setKeyLength($length);\n    }\n\n    /**\n     * Sets the block length\n     *\n     * Valid block lengths are 128, 160, 192, 224, and 256.  If the length is less than 128, it will be rounded up to\n     * 128.  If the length is greater than 128 and invalid, it will be rounded down to the closest valid amount.\n     *\n     * @access public\n     * @param int $length\n     */\n    function setBlockLength($length)\n    {\n        $length >>= 5;\n        if ($length > 8) {\n            $length = 8;\n        } elseif ($length < 4) {\n            $length = 4;\n        }\n        $this->Nb = $length;\n        $this->block_size = $length << 2;\n        $this->changed = true;\n        $this->_setEngine();\n    }\n\n    /**\n     * Test for engine validity\n     *\n     * This is mainly just a wrapper to set things up for \\phpseclib\\Crypt\\Base::isValidEngine()\n     *\n     * @see \\phpseclib\\Crypt\\Base::__construct()\n     * @param int $engine\n     * @access public\n     * @return bool\n     */\n    function isValidEngine($engine)\n    {\n        switch ($engine) {\n            case self::ENGINE_OPENSSL:\n                if ($this->block_size != 16) {\n                    return false;\n                }\n                $this->cipher_name_openssl_ecb = 'aes-' . ($this->key_length << 3) . '-ecb';\n                $this->cipher_name_openssl = 'aes-' . ($this->key_length << 3) . '-' . $this->_openssl_translate_mode();\n                break;\n            case self::ENGINE_MCRYPT:\n                $this->cipher_name_mcrypt = 'rijndael-' . ($this->block_size << 3);\n                if ($this->key_length % 8) { // is it a 160/224-bit key?\n                    // mcrypt is not usable for them, only for 128/192/256-bit keys\n                    return false;\n                }\n        }\n\n        return parent::isValidEngine($engine);\n    }\n\n    /**\n     * Encrypts a block\n     *\n     * @access private\n     * @param string $in\n     * @return string\n     */\n    function _encryptBlock($in)\n    {\n        static $tables;\n        if (empty($tables)) {\n            $tables = &$this->_getTables();\n        }\n        $t0   = $tables[0];\n        $t1   = $tables[1];\n        $t2   = $tables[2];\n        $t3   = $tables[3];\n        $sbox = $tables[4];\n\n        $state = array();\n        $words = unpack('N*', $in);\n\n        $c = $this->c;\n        $w = $this->w;\n        $Nb = $this->Nb;\n        $Nr = $this->Nr;\n\n        // addRoundKey\n        $wc = $Nb - 1;\n        foreach ($words as $word) {\n            $state[] = $word ^ $w[++$wc];\n        }\n\n        // fips-197.pdf#page=19, \"Figure 5. Pseudo Code for the Cipher\", states that this loop has four components -\n        // subBytes, shiftRows, mixColumns, and addRoundKey. fips-197.pdf#page=30, \"Implementation Suggestions Regarding\n        // Various Platforms\" suggests that performs enhanced implementations are described in Rijndael-ammended.pdf.\n        // Rijndael-ammended.pdf#page=20, \"Implementation aspects / 32-bit processor\", discusses such an optimization.\n        // Unfortunately, the description given there is not quite correct.  Per aes.spec.v316.pdf#page=19 [1],\n        // equation (7.4.7) is supposed to use addition instead of subtraction, so we'll do that here, as well.\n\n        // [1] http://fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.v316.pdf\n        $temp = array();\n        for ($round = 1; $round < $Nr; ++$round) {\n            $i = 0; // $c[0] == 0\n            $j = $c[1];\n            $k = $c[2];\n            $l = $c[3];\n\n            while ($i < $Nb) {\n                $temp[$i] = $t0[$state[$i] >> 24 & 0x000000FF] ^\n                            $t1[$state[$j] >> 16 & 0x000000FF] ^\n                            $t2[$state[$k] >>  8 & 0x000000FF] ^\n                            $t3[$state[$l]       & 0x000000FF] ^\n                            $w[++$wc];\n                ++$i;\n                $j = ($j + 1) % $Nb;\n                $k = ($k + 1) % $Nb;\n                $l = ($l + 1) % $Nb;\n            }\n            $state = $temp;\n        }\n\n        // subWord\n        for ($i = 0; $i < $Nb; ++$i) {\n            $state[$i] =   $sbox[$state[$i]       & 0x000000FF]        |\n                          ($sbox[$state[$i] >>  8 & 0x000000FF] <<  8) |\n                          ($sbox[$state[$i] >> 16 & 0x000000FF] << 16) |\n                          ($sbox[$state[$i] >> 24 & 0x000000FF] << 24);\n        }\n\n        // shiftRows + addRoundKey\n        $i = 0; // $c[0] == 0\n        $j = $c[1];\n        $k = $c[2];\n        $l = $c[3];\n        while ($i < $Nb) {\n            $temp[$i] = ($state[$i] & 0xFF000000) ^\n                        ($state[$j] & 0x00FF0000) ^\n                        ($state[$k] & 0x0000FF00) ^\n                        ($state[$l] & 0x000000FF) ^\n                         $w[$i];\n            ++$i;\n            $j = ($j + 1) % $Nb;\n            $k = ($k + 1) % $Nb;\n            $l = ($l + 1) % $Nb;\n        }\n\n        switch ($Nb) {\n            case 8:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6], $temp[7]);\n            case 7:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6]);\n            case 6:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5]);\n            case 5:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4]);\n            default:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3]);\n        }\n    }\n\n    /**\n     * Decrypts a block\n     *\n     * @access private\n     * @param string $in\n     * @return string\n     */\n    function _decryptBlock($in)\n    {\n        static $invtables;\n        if (empty($invtables)) {\n            $invtables = &$this->_getInvTables();\n        }\n        $dt0   = $invtables[0];\n        $dt1   = $invtables[1];\n        $dt2   = $invtables[2];\n        $dt3   = $invtables[3];\n        $isbox = $invtables[4];\n\n        $state = array();\n        $words = unpack('N*', $in);\n\n        $c  = $this->c;\n        $dw = $this->dw;\n        $Nb = $this->Nb;\n        $Nr = $this->Nr;\n\n        // addRoundKey\n        $wc = $Nb - 1;\n        foreach ($words as $word) {\n            $state[] = $word ^ $dw[++$wc];\n        }\n\n        $temp = array();\n        for ($round = $Nr - 1; $round > 0; --$round) {\n            $i = 0; // $c[0] == 0\n            $j = $Nb - $c[1];\n            $k = $Nb - $c[2];\n            $l = $Nb - $c[3];\n\n            while ($i < $Nb) {\n                $temp[$i] = $dt0[$state[$i] >> 24 & 0x000000FF] ^\n                            $dt1[$state[$j] >> 16 & 0x000000FF] ^\n                            $dt2[$state[$k] >>  8 & 0x000000FF] ^\n                            $dt3[$state[$l]       & 0x000000FF] ^\n                            $dw[++$wc];\n                ++$i;\n                $j = ($j + 1) % $Nb;\n                $k = ($k + 1) % $Nb;\n                $l = ($l + 1) % $Nb;\n            }\n            $state = $temp;\n        }\n\n        // invShiftRows + invSubWord + addRoundKey\n        $i = 0; // $c[0] == 0\n        $j = $Nb - $c[1];\n        $k = $Nb - $c[2];\n        $l = $Nb - $c[3];\n\n        while ($i < $Nb) {\n            $word = ($state[$i] & 0xFF000000) |\n                    ($state[$j] & 0x00FF0000) |\n                    ($state[$k] & 0x0000FF00) |\n                    ($state[$l] & 0x000000FF);\n\n            $temp[$i] = $dw[$i] ^ ($isbox[$word       & 0x000000FF]        |\n                                  ($isbox[$word >>  8 & 0x000000FF] <<  8) |\n                                  ($isbox[$word >> 16 & 0x000000FF] << 16) |\n                                  ($isbox[$word >> 24 & 0x000000FF] << 24));\n            ++$i;\n            $j = ($j + 1) % $Nb;\n            $k = ($k + 1) % $Nb;\n            $l = ($l + 1) % $Nb;\n        }\n\n        switch ($Nb) {\n            case 8:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6], $temp[7]);\n            case 7:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5], $temp[6]);\n            case 6:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4], $temp[5]);\n            case 5:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3], $temp[4]);\n            default:\n                return pack('N*', $temp[0], $temp[1], $temp[2], $temp[3]);\n        }\n    }\n\n    /**\n     * Setup the key (expansion)\n     *\n     * @see \\phpseclib\\Crypt\\Base::_setupKey()\n     * @access private\n     */\n    function _setupKey()\n    {\n        // Each number in $rcon is equal to the previous number multiplied by two in Rijndael's finite field.\n        // See http://en.wikipedia.org/wiki/Finite_field_arithmetic#Multiplicative_inverse\n        static $rcon = array(0,\n            0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,\n            0x20000000, 0x40000000, 0x80000000, 0x1B000000, 0x36000000,\n            0x6C000000, 0xD8000000, 0xAB000000, 0x4D000000, 0x9A000000,\n            0x2F000000, 0x5E000000, 0xBC000000, 0x63000000, 0xC6000000,\n            0x97000000, 0x35000000, 0x6A000000, 0xD4000000, 0xB3000000,\n            0x7D000000, 0xFA000000, 0xEF000000, 0xC5000000, 0x91000000\n        );\n\n        if (isset($this->kl['key']) && $this->key === $this->kl['key'] && $this->key_length === $this->kl['key_length'] && $this->block_size === $this->kl['block_size']) {\n            // already expanded\n            return;\n        }\n        $this->kl = array('key' => $this->key, 'key_length' => $this->key_length, 'block_size' => $this->block_size);\n\n        $this->Nk = $this->key_length >> 2;\n        // see Rijndael-ammended.pdf#page=44\n        $this->Nr = max($this->Nk, $this->Nb) + 6;\n\n        // shift offsets for Nb = 5, 7 are defined in Rijndael-ammended.pdf#page=44,\n        //     \"Table 8: Shift offsets in Shiftrow for the alternative block lengths\"\n        // shift offsets for Nb = 4, 6, 8 are defined in Rijndael-ammended.pdf#page=14,\n        //     \"Table 2: Shift offsets for different block lengths\"\n        switch ($this->Nb) {\n            case 4:\n            case 5:\n            case 6:\n                $this->c = array(0, 1, 2, 3);\n                break;\n            case 7:\n                $this->c = array(0, 1, 2, 4);\n                break;\n            case 8:\n                $this->c = array(0, 1, 3, 4);\n        }\n\n        $w = array_values(unpack('N*words', $this->key));\n\n        $length = $this->Nb * ($this->Nr + 1);\n        for ($i = $this->Nk; $i < $length; $i++) {\n            $temp = $w[$i - 1];\n            if ($i % $this->Nk == 0) {\n                // according to <http://php.net/language.types.integer>, \"the size of an integer is platform-dependent\".\n                // on a 32-bit machine, it's 32-bits, and on a 64-bit machine, it's 64-bits. on a 32-bit machine,\n                // 0xFFFFFFFF << 8 == 0xFFFFFF00, but on a 64-bit machine, it equals 0xFFFFFFFF00. as such, doing 'and'\n                // with 0xFFFFFFFF (or 0xFFFFFF00) on a 32-bit machine is unnecessary, but on a 64-bit machine, it is.\n                $temp = (($temp << 8) & 0xFFFFFF00) | (($temp >> 24) & 0x000000FF); // rotWord\n                $temp = $this->_subWord($temp) ^ $rcon[$i / $this->Nk];\n            } elseif ($this->Nk > 6 && $i % $this->Nk == 4) {\n                $temp = $this->_subWord($temp);\n            }\n            $w[$i] = $w[$i - $this->Nk] ^ $temp;\n        }\n\n        // convert the key schedule from a vector of $Nb * ($Nr + 1) length to a matrix with $Nr + 1 rows and $Nb columns\n        // and generate the inverse key schedule.  more specifically,\n        // according to <http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=23> (section 5.3.3),\n        // \"The key expansion for the Inverse Cipher is defined as follows:\n        //        1. Apply the Key Expansion.\n        //        2. Apply InvMixColumn to all Round Keys except the first and the last one.\"\n        // also, see fips-197.pdf#page=27, \"5.3.5 Equivalent Inverse Cipher\"\n        list($dt0, $dt1, $dt2, $dt3) = $this->_getInvTables();\n        $temp = $this->w = $this->dw = array();\n        for ($i = $row = $col = 0; $i < $length; $i++, $col++) {\n            if ($col == $this->Nb) {\n                if ($row == 0) {\n                    $this->dw[0] = $this->w[0];\n                } else {\n                    // subWord + invMixColumn + invSubWord = invMixColumn\n                    $j = 0;\n                    while ($j < $this->Nb) {\n                        $dw = $this->_subWord($this->w[$row][$j]);\n                        $temp[$j] = $dt0[$dw >> 24 & 0x000000FF] ^\n                                    $dt1[$dw >> 16 & 0x000000FF] ^\n                                    $dt2[$dw >>  8 & 0x000000FF] ^\n                                    $dt3[$dw       & 0x000000FF];\n                        $j++;\n                    }\n                    $this->dw[$row] = $temp;\n                }\n\n                $col = 0;\n                $row++;\n            }\n            $this->w[$row][$col] = $w[$i];\n        }\n\n        $this->dw[$row] = $this->w[$row];\n\n        // Converting to 1-dim key arrays (both ascending)\n        $this->dw = array_reverse($this->dw);\n        $w  = array_pop($this->w);\n        $dw = array_pop($this->dw);\n        foreach ($this->w as $r => $wr) {\n            foreach ($wr as $c => $wc) {\n                $w[]  = $wc;\n                $dw[] = $this->dw[$r][$c];\n            }\n        }\n        $this->w  = $w;\n        $this->dw = $dw;\n    }\n\n    /**\n     * Performs S-Box substitutions\n     *\n     * @access private\n     * @param int $word\n     */\n    function _subWord($word)\n    {\n        static $sbox;\n        if (empty($sbox)) {\n            list(, , , , $sbox) = $this->_getTables();\n        }\n\n        return  $sbox[$word       & 0x000000FF]        |\n               ($sbox[$word >>  8 & 0x000000FF] <<  8) |\n               ($sbox[$word >> 16 & 0x000000FF] << 16) |\n               ($sbox[$word >> 24 & 0x000000FF] << 24);\n    }\n\n    /**\n     * Provides the mixColumns and sboxes tables\n     *\n     * @see self::_encryptBlock()\n     * @see self::_setupInlineCrypt()\n     * @see self::_subWord()\n     * @access private\n     * @return array &$tables\n     */\n    function &_getTables()\n    {\n        static $tables;\n        if (empty($tables)) {\n            // according to <http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf#page=19> (section 5.2.1),\n            // precomputed tables can be used in the mixColumns phase. in that example, they're assigned t0...t3, so\n            // those are the names we'll use.\n            $t3 = array_map('intval', array(\n                // with array_map('intval', ...) we ensure we have only int's and not\n                // some slower floats converted by php automatically on high values\n                0x6363A5C6, 0x7C7C84F8, 0x777799EE, 0x7B7B8DF6, 0xF2F20DFF, 0x6B6BBDD6, 0x6F6FB1DE, 0xC5C55491,\n                0x30305060, 0x01010302, 0x6767A9CE, 0x2B2B7D56, 0xFEFE19E7, 0xD7D762B5, 0xABABE64D, 0x76769AEC,\n                0xCACA458F, 0x82829D1F, 0xC9C94089, 0x7D7D87FA, 0xFAFA15EF, 0x5959EBB2, 0x4747C98E, 0xF0F00BFB,\n                0xADADEC41, 0xD4D467B3, 0xA2A2FD5F, 0xAFAFEA45, 0x9C9CBF23, 0xA4A4F753, 0x727296E4, 0xC0C05B9B,\n                0xB7B7C275, 0xFDFD1CE1, 0x9393AE3D, 0x26266A4C, 0x36365A6C, 0x3F3F417E, 0xF7F702F5, 0xCCCC4F83,\n                0x34345C68, 0xA5A5F451, 0xE5E534D1, 0xF1F108F9, 0x717193E2, 0xD8D873AB, 0x31315362, 0x15153F2A,\n                0x04040C08, 0xC7C75295, 0x23236546, 0xC3C35E9D, 0x18182830, 0x9696A137, 0x05050F0A, 0x9A9AB52F,\n                0x0707090E, 0x12123624, 0x80809B1B, 0xE2E23DDF, 0xEBEB26CD, 0x2727694E, 0xB2B2CD7F, 0x75759FEA,\n                0x09091B12, 0x83839E1D, 0x2C2C7458, 0x1A1A2E34, 0x1B1B2D36, 0x6E6EB2DC, 0x5A5AEEB4, 0xA0A0FB5B,\n                0x5252F6A4, 0x3B3B4D76, 0xD6D661B7, 0xB3B3CE7D, 0x29297B52, 0xE3E33EDD, 0x2F2F715E, 0x84849713,\n                0x5353F5A6, 0xD1D168B9, 0x00000000, 0xEDED2CC1, 0x20206040, 0xFCFC1FE3, 0xB1B1C879, 0x5B5BEDB6,\n                0x6A6ABED4, 0xCBCB468D, 0xBEBED967, 0x39394B72, 0x4A4ADE94, 0x4C4CD498, 0x5858E8B0, 0xCFCF4A85,\n                0xD0D06BBB, 0xEFEF2AC5, 0xAAAAE54F, 0xFBFB16ED, 0x4343C586, 0x4D4DD79A, 0x33335566, 0x85859411,\n                0x4545CF8A, 0xF9F910E9, 0x02020604, 0x7F7F81FE, 0x5050F0A0, 0x3C3C4478, 0x9F9FBA25, 0xA8A8E34B,\n                0x5151F3A2, 0xA3A3FE5D, 0x4040C080, 0x8F8F8A05, 0x9292AD3F, 0x9D9DBC21, 0x38384870, 0xF5F504F1,\n                0xBCBCDF63, 0xB6B6C177, 0xDADA75AF, 0x21216342, 0x10103020, 0xFFFF1AE5, 0xF3F30EFD, 0xD2D26DBF,\n                0xCDCD4C81, 0x0C0C1418, 0x13133526, 0xECEC2FC3, 0x5F5FE1BE, 0x9797A235, 0x4444CC88, 0x1717392E,\n                0xC4C45793, 0xA7A7F255, 0x7E7E82FC, 0x3D3D477A, 0x6464ACC8, 0x5D5DE7BA, 0x19192B32, 0x737395E6,\n                0x6060A0C0, 0x81819819, 0x4F4FD19E, 0xDCDC7FA3, 0x22226644, 0x2A2A7E54, 0x9090AB3B, 0x8888830B,\n                0x4646CA8C, 0xEEEE29C7, 0xB8B8D36B, 0x14143C28, 0xDEDE79A7, 0x5E5EE2BC, 0x0B0B1D16, 0xDBDB76AD,\n                0xE0E03BDB, 0x32325664, 0x3A3A4E74, 0x0A0A1E14, 0x4949DB92, 0x06060A0C, 0x24246C48, 0x5C5CE4B8,\n                0xC2C25D9F, 0xD3D36EBD, 0xACACEF43, 0x6262A6C4, 0x9191A839, 0x9595A431, 0xE4E437D3, 0x79798BF2,\n                0xE7E732D5, 0xC8C8438B, 0x3737596E, 0x6D6DB7DA, 0x8D8D8C01, 0xD5D564B1, 0x4E4ED29C, 0xA9A9E049,\n                0x6C6CB4D8, 0x5656FAAC, 0xF4F407F3, 0xEAEA25CF, 0x6565AFCA, 0x7A7A8EF4, 0xAEAEE947, 0x08081810,\n                0xBABAD56F, 0x787888F0, 0x25256F4A, 0x2E2E725C, 0x1C1C2438, 0xA6A6F157, 0xB4B4C773, 0xC6C65197,\n                0xE8E823CB, 0xDDDD7CA1, 0x74749CE8, 0x1F1F213E, 0x4B4BDD96, 0xBDBDDC61, 0x8B8B860D, 0x8A8A850F,\n                0x707090E0, 0x3E3E427C, 0xB5B5C471, 0x6666AACC, 0x4848D890, 0x03030506, 0xF6F601F7, 0x0E0E121C,\n                0x6161A3C2, 0x35355F6A, 0x5757F9AE, 0xB9B9D069, 0x86869117, 0xC1C15899, 0x1D1D273A, 0x9E9EB927,\n                0xE1E138D9, 0xF8F813EB, 0x9898B32B, 0x11113322, 0x6969BBD2, 0xD9D970A9, 0x8E8E8907, 0x9494A733,\n                0x9B9BB62D, 0x1E1E223C, 0x87879215, 0xE9E920C9, 0xCECE4987, 0x5555FFAA, 0x28287850, 0xDFDF7AA5,\n                0x8C8C8F03, 0xA1A1F859, 0x89898009, 0x0D0D171A, 0xBFBFDA65, 0xE6E631D7, 0x4242C684, 0x6868B8D0,\n                0x4141C382, 0x9999B029, 0x2D2D775A, 0x0F0F111E, 0xB0B0CB7B, 0x5454FCA8, 0xBBBBD66D, 0x16163A2C\n            ));\n\n            foreach ($t3 as $t3i) {\n                $t0[] = (($t3i << 24) & 0xFF000000) | (($t3i >>  8) & 0x00FFFFFF);\n                $t1[] = (($t3i << 16) & 0xFFFF0000) | (($t3i >> 16) & 0x0000FFFF);\n                $t2[] = (($t3i <<  8) & 0xFFFFFF00) | (($t3i >> 24) & 0x000000FF);\n            }\n\n            $tables = array(\n                // The Precomputed mixColumns tables t0 - t3\n                $t0,\n                $t1,\n                $t2,\n                $t3,\n                // The SubByte S-Box\n                array(\n                    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n                    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n                    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n                    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n                    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n                    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n                    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n                    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n                    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n                    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n                    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n                    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n                    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n                    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n                    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n                    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16\n                )\n            );\n        }\n        return $tables;\n    }\n\n    /**\n     * Provides the inverse mixColumns and inverse sboxes tables\n     *\n     * @see self::_decryptBlock()\n     * @see self::_setupInlineCrypt()\n     * @see self::_setupKey()\n     * @access private\n     * @return array &$tables\n     */\n    function &_getInvTables()\n    {\n        static $tables;\n        if (empty($tables)) {\n            $dt3 = array_map('intval', array(\n                0xF4A75051, 0x4165537E, 0x17A4C31A, 0x275E963A, 0xAB6BCB3B, 0x9D45F11F, 0xFA58ABAC, 0xE303934B,\n                0x30FA5520, 0x766DF6AD, 0xCC769188, 0x024C25F5, 0xE5D7FC4F, 0x2ACBD7C5, 0x35448026, 0x62A38FB5,\n                0xB15A49DE, 0xBA1B6725, 0xEA0E9845, 0xFEC0E15D, 0x2F7502C3, 0x4CF01281, 0x4697A38D, 0xD3F9C66B,\n                0x8F5FE703, 0x929C9515, 0x6D7AEBBF, 0x5259DA95, 0xBE832DD4, 0x7421D358, 0xE0692949, 0xC9C8448E,\n                0xC2896A75, 0x8E7978F4, 0x583E6B99, 0xB971DD27, 0xE14FB6BE, 0x88AD17F0, 0x20AC66C9, 0xCE3AB47D,\n                0xDF4A1863, 0x1A3182E5, 0x51336097, 0x537F4562, 0x6477E0B1, 0x6BAE84BB, 0x81A01CFE, 0x082B94F9,\n                0x48685870, 0x45FD198F, 0xDE6C8794, 0x7BF8B752, 0x73D323AB, 0x4B02E272, 0x1F8F57E3, 0x55AB2A66,\n                0xEB2807B2, 0xB5C2032F, 0xC57B9A86, 0x3708A5D3, 0x2887F230, 0xBFA5B223, 0x036ABA02, 0x16825CED,\n                0xCF1C2B8A, 0x79B492A7, 0x07F2F0F3, 0x69E2A14E, 0xDAF4CD65, 0x05BED506, 0x34621FD1, 0xA6FE8AC4,\n                0x2E539D34, 0xF355A0A2, 0x8AE13205, 0xF6EB75A4, 0x83EC390B, 0x60EFAA40, 0x719F065E, 0x6E1051BD,\n                0x218AF93E, 0xDD063D96, 0x3E05AEDD, 0xE6BD464D, 0x548DB591, 0xC45D0571, 0x06D46F04, 0x5015FF60,\n                0x98FB2419, 0xBDE997D6, 0x4043CC89, 0xD99E7767, 0xE842BDB0, 0x898B8807, 0x195B38E7, 0xC8EEDB79,\n                0x7C0A47A1, 0x420FE97C, 0x841EC9F8, 0x00000000, 0x80868309, 0x2BED4832, 0x1170AC1E, 0x5A724E6C,\n                0x0EFFFBFD, 0x8538560F, 0xAED51E3D, 0x2D392736, 0x0FD9640A, 0x5CA62168, 0x5B54D19B, 0x362E3A24,\n                0x0A67B10C, 0x57E70F93, 0xEE96D2B4, 0x9B919E1B, 0xC0C54F80, 0xDC20A261, 0x774B695A, 0x121A161C,\n                0x93BA0AE2, 0xA02AE5C0, 0x22E0433C, 0x1B171D12, 0x090D0B0E, 0x8BC7ADF2, 0xB6A8B92D, 0x1EA9C814,\n                0xF1198557, 0x75074CAF, 0x99DDBBEE, 0x7F60FDA3, 0x01269FF7, 0x72F5BC5C, 0x663BC544, 0xFB7E345B,\n                0x4329768B, 0x23C6DCCB, 0xEDFC68B6, 0xE4F163B8, 0x31DCCAD7, 0x63851042, 0x97224013, 0xC6112084,\n                0x4A247D85, 0xBB3DF8D2, 0xF93211AE, 0x29A16DC7, 0x9E2F4B1D, 0xB230F3DC, 0x8652EC0D, 0xC1E3D077,\n                0xB3166C2B, 0x70B999A9, 0x9448FA11, 0xE9642247, 0xFC8CC4A8, 0xF03F1AA0, 0x7D2CD856, 0x3390EF22,\n                0x494EC787, 0x38D1C1D9, 0xCAA2FE8C, 0xD40B3698, 0xF581CFA6, 0x7ADE28A5, 0xB78E26DA, 0xADBFA43F,\n                0x3A9DE42C, 0x78920D50, 0x5FCC9B6A, 0x7E466254, 0x8D13C2F6, 0xD8B8E890, 0x39F75E2E, 0xC3AFF582,\n                0x5D80BE9F, 0xD0937C69, 0xD52DA96F, 0x2512B3CF, 0xAC993BC8, 0x187DA710, 0x9C636EE8, 0x3BBB7BDB,\n                0x267809CD, 0x5918F46E, 0x9AB701EC, 0x4F9AA883, 0x956E65E6, 0xFFE67EAA, 0xBCCF0821, 0x15E8E6EF,\n                0xE79BD9BA, 0x6F36CE4A, 0x9F09D4EA, 0xB07CD629, 0xA4B2AF31, 0x3F23312A, 0xA59430C6, 0xA266C035,\n                0x4EBC3774, 0x82CAA6FC, 0x90D0B0E0, 0xA7D81533, 0x04984AF1, 0xECDAF741, 0xCD500E7F, 0x91F62F17,\n                0x4DD68D76, 0xEFB04D43, 0xAA4D54CC, 0x9604DFE4, 0xD1B5E39E, 0x6A881B4C, 0x2C1FB8C1, 0x65517F46,\n                0x5EEA049D, 0x8C355D01, 0x877473FA, 0x0B412EFB, 0x671D5AB3, 0xDBD25292, 0x105633E9, 0xD647136D,\n                0xD7618C9A, 0xA10C7A37, 0xF8148E59, 0x133C89EB, 0xA927EECE, 0x61C935B7, 0x1CE5EDE1, 0x47B13C7A,\n                0xD2DF599C, 0xF2733F55, 0x14CE7918, 0xC737BF73, 0xF7CDEA53, 0xFDAA5B5F, 0x3D6F14DF, 0x44DB8678,\n                0xAFF381CA, 0x68C43EB9, 0x24342C38, 0xA3405FC2, 0x1DC37216, 0xE2250CBC, 0x3C498B28, 0x0D9541FF,\n                0xA8017139, 0x0CB3DE08, 0xB4E49CD8, 0x56C19064, 0xCB84617B, 0x32B670D5, 0x6C5C7448, 0xB85742D0\n            ));\n\n            foreach ($dt3 as $dt3i) {\n                $dt0[] = (($dt3i << 24) & 0xFF000000) | (($dt3i >>  8) & 0x00FFFFFF);\n                $dt1[] = (($dt3i << 16) & 0xFFFF0000) | (($dt3i >> 16) & 0x0000FFFF);\n                $dt2[] = (($dt3i <<  8) & 0xFFFFFF00) | (($dt3i >> 24) & 0x000000FF);\n            };\n\n            $tables = array(\n                // The Precomputed inverse mixColumns tables dt0 - dt3\n                $dt0,\n                $dt1,\n                $dt2,\n                $dt3,\n                // The inverse SubByte S-Box\n                array(\n                    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n                    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n                    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n                    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n                    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n                    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n                    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n                    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n                    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n                    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n                    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n                    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n                    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n                    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n                    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n                    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D\n                )\n            );\n        }\n        return $tables;\n    }\n\n    /**\n     * Setup the performance-optimized function for de/encrypt()\n     *\n     * @see \\phpseclib\\Crypt\\Base::_setupInlineCrypt()\n     * @access private\n     */\n    function _setupInlineCrypt()\n    {\n        // Note: _setupInlineCrypt() will be called only if $this->changed === true\n        // So here we are'nt under the same heavy timing-stress as we are in _de/encryptBlock() or de/encrypt().\n        // However...the here generated function- $code, stored as php callback in $this->inline_crypt, must work as fast as even possible.\n\n        $lambda_functions =& self::_getLambdaFunctions();\n\n        // We create max. 10 hi-optimized code for memory reason. Means: For each $key one ultra fast inline-crypt function.\n        // (Currently, for Crypt_Rijndael/AES, one generated $lambda_function cost on php5.5@32bit ~80kb unfreeable mem and ~130kb on php5.5@64bit)\n        // After that, we'll still create very fast optimized code but not the hi-ultimative code, for each $mode one.\n        $gen_hi_opt_code = (bool)(count($lambda_functions) < 10);\n\n        // Generation of a uniqe hash for our generated code\n        $code_hash = \"Crypt_Rijndael, {$this->mode}, {$this->Nr}, {$this->Nb}\";\n        if ($gen_hi_opt_code) {\n            $code_hash = str_pad($code_hash, 32) . $this->_hashInlineCryptFunction($this->key);\n        }\n\n        if (!isset($lambda_functions[$code_hash])) {\n            switch (true) {\n                case $gen_hi_opt_code:\n                    // The hi-optimized $lambda_functions will use the key-words hardcoded for better performance.\n                    $w  = $this->w;\n                    $dw = $this->dw;\n                    $init_encrypt = '';\n                    $init_decrypt = '';\n                    break;\n                default:\n                    for ($i = 0, $cw = count($this->w); $i < $cw; ++$i) {\n                        $w[]  = '$w['  . $i . ']';\n                        $dw[] = '$dw[' . $i . ']';\n                    }\n                    $init_encrypt = '$w  = $self->w;';\n                    $init_decrypt = '$dw = $self->dw;';\n            }\n\n            $Nr = $this->Nr;\n            $Nb = $this->Nb;\n            $c  = $this->c;\n\n            // Generating encrypt code:\n            $init_encrypt.= '\n                static $tables;\n                if (empty($tables)) {\n                    $tables = &$self->_getTables();\n                }\n                $t0   = $tables[0];\n                $t1   = $tables[1];\n                $t2   = $tables[2];\n                $t3   = $tables[3];\n                $sbox = $tables[4];\n            ';\n\n            $s  = 'e';\n            $e  = 's';\n            $wc = $Nb - 1;\n\n            // Preround: addRoundKey\n            $encrypt_block = '$in = unpack(\"N*\", $in);'.\"\\n\";\n            for ($i = 0; $i < $Nb; ++$i) {\n                $encrypt_block .= '$s'.$i.' = $in['.($i + 1).'] ^ '.$w[++$wc].\";\\n\";\n            }\n\n            // Mainrounds: shiftRows + subWord + mixColumns + addRoundKey\n            for ($round = 1; $round < $Nr; ++$round) {\n                list($s, $e) = array($e, $s);\n                for ($i = 0; $i < $Nb; ++$i) {\n                    $encrypt_block.=\n                        '$'.$e.$i.' =\n                        $t0[($'.$s.$i                  .' >> 24) & 0xff] ^\n                        $t1[($'.$s.(($i + $c[1]) % $Nb).' >> 16) & 0xff] ^\n                        $t2[($'.$s.(($i + $c[2]) % $Nb).' >>  8) & 0xff] ^\n                        $t3[ $'.$s.(($i + $c[3]) % $Nb).'        & 0xff] ^\n                        '.$w[++$wc].\";\\n\";\n                }\n            }\n\n            // Finalround: subWord + shiftRows + addRoundKey\n            for ($i = 0; $i < $Nb; ++$i) {\n                $encrypt_block.=\n                    '$'.$e.$i.' =\n                     $sbox[ $'.$e.$i.'        & 0xff]        |\n                    ($sbox[($'.$e.$i.' >>  8) & 0xff] <<  8) |\n                    ($sbox[($'.$e.$i.' >> 16) & 0xff] << 16) |\n                    ($sbox[($'.$e.$i.' >> 24) & 0xff] << 24);'.\"\\n\";\n            }\n            $encrypt_block .= '$in = pack(\"N*\"'.\"\\n\";\n            for ($i = 0; $i < $Nb; ++$i) {\n                $encrypt_block.= ',\n                    ($'.$e.$i                  .' & '.((int)0xFF000000).') ^\n                    ($'.$e.(($i + $c[1]) % $Nb).' &         0x00FF0000   ) ^\n                    ($'.$e.(($i + $c[2]) % $Nb).' &         0x0000FF00   ) ^\n                    ($'.$e.(($i + $c[3]) % $Nb).' &         0x000000FF   ) ^\n                    '.$w[$i].\"\\n\";\n            }\n            $encrypt_block .= ');';\n\n            // Generating decrypt code:\n            $init_decrypt.= '\n                static $invtables;\n                if (empty($invtables)) {\n                    $invtables = &$self->_getInvTables();\n                }\n                $dt0   = $invtables[0];\n                $dt1   = $invtables[1];\n                $dt2   = $invtables[2];\n                $dt3   = $invtables[3];\n                $isbox = $invtables[4];\n            ';\n\n            $s  = 'e';\n            $e  = 's';\n            $wc = $Nb - 1;\n\n            // Preround: addRoundKey\n            $decrypt_block = '$in = unpack(\"N*\", $in);'.\"\\n\";\n            for ($i = 0; $i < $Nb; ++$i) {\n                $decrypt_block .= '$s'.$i.' = $in['.($i + 1).'] ^ '.$dw[++$wc].';'.\"\\n\";\n            }\n\n            // Mainrounds: shiftRows + subWord + mixColumns + addRoundKey\n            for ($round = 1; $round < $Nr; ++$round) {\n                list($s, $e) = array($e, $s);\n                for ($i = 0; $i < $Nb; ++$i) {\n                    $decrypt_block.=\n                        '$'.$e.$i.' =\n                        $dt0[($'.$s.$i                        .' >> 24) & 0xff] ^\n                        $dt1[($'.$s.(($Nb + $i - $c[1]) % $Nb).' >> 16) & 0xff] ^\n                        $dt2[($'.$s.(($Nb + $i - $c[2]) % $Nb).' >>  8) & 0xff] ^\n                        $dt3[ $'.$s.(($Nb + $i - $c[3]) % $Nb).'        & 0xff] ^\n                        '.$dw[++$wc].\";\\n\";\n                }\n            }\n\n            // Finalround: subWord + shiftRows + addRoundKey\n            for ($i = 0; $i < $Nb; ++$i) {\n                $decrypt_block.=\n                    '$'.$e.$i.' =\n                     $isbox[ $'.$e.$i.'        & 0xff]        |\n                    ($isbox[($'.$e.$i.' >>  8) & 0xff] <<  8) |\n                    ($isbox[($'.$e.$i.' >> 16) & 0xff] << 16) |\n                    ($isbox[($'.$e.$i.' >> 24) & 0xff] << 24);'.\"\\n\";\n            }\n            $decrypt_block .= '$in = pack(\"N*\"'.\"\\n\";\n            for ($i = 0; $i < $Nb; ++$i) {\n                $decrypt_block.= ',\n                    ($'.$e.$i.                        ' & '.((int)0xFF000000).') ^\n                    ($'.$e.(($Nb + $i - $c[1]) % $Nb).' &         0x00FF0000   ) ^\n                    ($'.$e.(($Nb + $i - $c[2]) % $Nb).' &         0x0000FF00   ) ^\n                    ($'.$e.(($Nb + $i - $c[3]) % $Nb).' &         0x000000FF   ) ^\n                    '.$dw[$i].\"\\n\";\n            }\n            $decrypt_block .= ');';\n\n            $lambda_functions[$code_hash] = $this->_createInlineCryptFunction(\n                array(\n                   'init_crypt'    => '',\n                   'init_encrypt'  => $init_encrypt,\n                   'init_decrypt'  => $init_decrypt,\n                   'encrypt_block' => $encrypt_block,\n                   'decrypt_block' => $decrypt_block\n                )\n            );\n        }\n        $this->inline_crypt = $lambda_functions[$code_hash];\n    }\n}\n"], "buggy_code_start_loc": [14, 97, 51, 10], "buggy_code_end_loc": [124, 2470, 99, 882], "fixing_code_start_loc": [14, 97, 51, 10], "fixing_code_end_loc": [124, 2522, 112, 783], "type": "CWE-200", "message": "libraries/session.inc.php in phpMyAdmin 4.0.x before 4.0.10.13, 4.4.x before 4.4.15.3, and 4.5.x before 4.5.4 does not properly generate CSRF token values, which allows remote attackers to bypass intended access restrictions by predicting a value.", "other": {"cve": {"id": "CVE-2016-2039", "sourceIdentifier": "cve@mitre.org", "published": "2016-02-20T01:59:02.140", "lastModified": "2018-10-30T16:27:35.843", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "libraries/session.inc.php in phpMyAdmin 4.0.x before 4.0.10.13, 4.4.x before 4.4.15.3, and 4.5.x before 4.5.4 does not properly generate CSRF token values, which allows remote attackers to bypass intended access restrictions by predicting a value."}, {"lang": "es", "value": "libraries/session.inc.php en phpMyAdmin 4.0.x en versiones anteriores a 4.0.10.13, 4.4.x en versiones anteriores a 4.4.15.3 y 4.5.x en versiones anteriores a 4.5.4 no genera adecuadamente valores de token CSRF, lo que permite a atacantes remotos eludir las restricciones destinadas al acceso mediante la predicci\u00f3n de un valor."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F06DC95-76B1-4E24-A55F-1358A25ED0E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "B406A721-0075-46C8-A920-3C9602AD667B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "C8AE4653-1911-4A58-85DD-51E0578E788E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "2CA76CB4-6167-446A-8D4F-6D5B38046334"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "6325E2AE-BB86-4953-AA9E-0433C00B096E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "3C54B828-8B23-4C62-907E-8EE7E757B721"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "02DD18C8-172B-41CD-87DD-58BDEC0D9418"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "10666E30-D98A-47A9-881A-B281066F0EC8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "3993826B-CA66-4BC2-8E1B-06CF9230B214"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "14928F51-761E-4FCA-B13C-A11530C7FC46"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "DB761644-20F5-4E0D-B301-7809EAECA813"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "896439D0-6C98-44A6-8C9D-0D57D57782D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "978B828C-1FCB-4386-B685-5BEE5A8A500C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "51A3261B-23BE-42D7-8A52-AE2E8C274A3D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "F0B7EA51-27EC-4884-8D60-FB9477D2B91A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "D6C9F2CC-778B-4604-B463-7A1D3FB8B9C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.0.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "4B20C44D-0EF1-48F2-B0AA-C8FF0BD9E252"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "13CD0228-728B-437A-84C1-BD7AFA52FFB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "DFF55485-9892-4E7B-AEE0-017E61EAA7C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "6100FE3E-0A31-4B55-90F2-90AF765A8EB7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "FBAAC8D9-AAA5-487C-B4AA-84BAE5DB109E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "5E06B1D3-29B4-45B7-B81F-C864AF579011"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "6B2E3923-0E2B-411A-B091-088E6FF050D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "1848C748-804D-4FE4-AB9C-B1BF9E58A19C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "12296322-DFAD-4B36-83EC-D01BF5DF7F2A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "EA321C14-C8F4-41FC-B601-2F646064ABBF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "54DBCF86-0CE8-46C4-B2E7-E3224765CCFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "1BF3DBC5-7020-48D0-ADEA-E71776DB2285"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "317F952E-5F12-4ED3-8FA3-FC1106B50F85"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "87B97F98-C0A7-4D9E-8333-7EE9EC456A12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "7A1E753D-5653-4D7A-8E41-6C02511EBFCE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "417230C7-0EC2-49F4-B810-A8AE84A302AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "103FEAB1-194E-4CEF-935A-4DBCCA298205"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.13.1:*:*:*:*:*:*:*", "matchCriteriaId": "C5814003-9FF8-4F8E-9D90-A2BBB80B8451"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.14.1:*:*:*:*:*:*:*", "matchCriteriaId": "16D28B77-9353-4259-9299-30638A78CCD4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "C022292B-6E06-4328-842F-135A872D22AF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15.1:*:*:*:*:*:*:*", "matchCriteriaId": "F15F00FB-BB9B-4D54-B198-0A74D418B8DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15.2:*:*:*:*:*:*:*", "matchCriteriaId": "DC10AF20-7B65-4FAE-A2AD-783867D60A8D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.4.15.3:*:*:*:*:*:*:*", "matchCriteriaId": "4EB7190C-0401-4E2E-B15F-4CFC79D5A4E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "A4D7AAF1-64FF-40C9-90B2-DEC814157372"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "96D529F5-8870-4934-BCD8-E49095D21224"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "296EB2FA-FCAD-4BD5-A015-62765407AFE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DBD0DC7-64D0-42B1-8EEE-73A0214680F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A6A15D1E-83ED-47EC-B17C-E6BCC49DE83D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phpmyadmin:phpmyadmin:4.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "4112ACFF-D40E-45BE-9307-F710E7B41ECD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:24:*:*:*:*:*:*:*", "matchCriteriaId": "C729D5D1-ED95-443A-9F53-5D7C2FD9B80C"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2016-February/176483.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2016-February/176739.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-02/msg00028.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-02/msg00049.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3627", "source": "cve@mitre.org"}, {"url": "http://www.phpmyadmin.net/home_page/security/PMASA-2016-2.php", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/phpmyadmin/phpmyadmin/commit/cb7748ac9cffcd1cd0f3081499cd4aafa9d1065e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/phpmyadmin/phpmyadmin/commit/f20970d32c3dfdf82aef7b6c244da1f769043813", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/phpmyadmin/phpmyadmin/commit/cb7748ac9cffcd1cd0f3081499cd4aafa9d1065e"}}