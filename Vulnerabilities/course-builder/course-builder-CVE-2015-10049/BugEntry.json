{"buggy_code": ["<!-- TODO(psimakov): use local YUI library -->\n<link rel=\"stylesheet\" type=\"text/css\"\n    href=\"/static/yui_3.6.0/yui/build/cssreset-context/cssreset-context-min.css\">\n<script\n    src=\"/static/yui_3.6.0/yui/build/yui/yui.js\"></script>\n<link rel=\"stylesheet\" type=\"text/css\"\n    href=\"/static/inputex-3.1.0/src/inputex/assets/skins/sam/inputex.css\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"/modules/oeditor/resources/butterbar.css\">\n<script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"></script>\n<script src=\"/modules/oeditor/resources/butterbar.js\" type='text/javascript'></script>\n<script\n    src=\"/static/inputex-3.1.0/src/loader.js\" type='text/javascript'></script>\n<script\n    src=\"/static/inputex-3.1.0/lib/jsonPretty.js\" type='text/javascript'></script>\n\n{% if can_highlight_code %}\n  <!-- import CodeMirror -->\n  <script src=\"/static/codemirror/lib/codemirror.js\"></script>\n  <link rel=\"stylesheet\" href=\"/static/codemirror/lib/codemirror.css\">\n  <script src=\"/static/codemirror/mode/htmlmixed/htmlmixed.js\"></script>\n  <script src=\"/static/codemirror/mode/xml/xml.js\"></script>\n  <script src=\"/static/codemirror/mode/javascript/javascript.js\"></script>\n  <script src=\"/static/codemirror/mode/css/css.js\"></script>\n  <script src=\"/static/codemirror/keymap/sublime.js\"></script>\n  <script src=\"/static/codemirror/addon/mode/loadmode.js\"></script>\n  <link rel=\"stylesheet\" href=\"/static/codemirror/addon/fold/foldgutter.css\">\n  <script src=\"/static/codemirror/addon/fold/foldcode.js\"></script>\n  <script src=\"/static/codemirror/addon/fold/foldgutter.js\"></script>\n  <script src=\"/static/codemirror/addon/fold/brace-fold.js\"></script>\n  <script src=\"/static/codemirror/addon/fold/xml-fold.js\"></script>\n  <script src=\"/static/codemirror/addon/fold/markdown-fold.js\"></script>\n  <script src=\"/static/codemirror/addon/fold/comment-fold.js\"></script>\n  <link rel=\"stylesheet\" href=\"/static/codemirror/addon/dialog/dialog.css\">\n  <script src=\"/static/codemirror/addon/dialog/dialog.js\"></script>\n  <script src=\"/static/codemirror/addon/search/searchcursor.js\"></script>\n  <script src=\"/static/codemirror/addon/search/search.js\"></script>\n{% endif %}\n\n<!-- import extension libraries. -->\n{% for url in extra_script_tag_urls %}\n  <script src='{{ url }}'></script>\n{% endfor %}\n\n<link rel=\"stylesheet\" type=\"text/css\"\n    href=\"/modules/oeditor/resources/oeditor.css\"/>\n<style>\n  {% for file in extra_css_files %}\n    {% include file %}\n  {% endfor %}\n</style>\n\n<div id='oeditor-container'>\n  <div class='gcb-butterbar-container'>\n    <div class='gcb-butterbar' id='gcb-butterbar-top' style='top:-45px'>\n      <p id='gcb-butterbar-message'></p>\n      <a id='gcb-butterbar-close'>X</a>\n    </div>\n  </div>\n  <div style='width: 100%;' align='center' class='yui3-skin-sam yui-skin-sam'>\n    <div class='form' id='formContainer'></div>\n  </div>\n</div>\n<div id='modal-editor' class='hidden'>\n  <div class='background'></div>\n</div>\n\n<script type='text/javascript'>\n  (function() {\n    //keep all our global objects here\n    var cb_global = {};\n\n    // various URL's needed by the form\n    cb_global.get_url = '{{ get_url }}';\n    cb_global.save_url = '{{ save_url }}';\n    cb_global.save_args = JSON.parse(\"{{ save_args|js_string }}\");\n    cb_global.exit_button_caption = '{{ exit_button_caption }}';\n    cb_global.exit_url = '{{ exit_url }}';\n    cb_global.save_method = '{{ save_method }}';\n    cb_global.auto_return = {% if auto_return %}true{% else %}false{% endif %};\n    cb_global.bundle_lib_files = {% if bundle_lib_files %}true{% else %}false{% endif %};\n\n    // If this value is '', deletions are not allowed\n    cb_global.delete_url = '{{ delete_url }}';\n    cb_global.delete_method = '{{ delete_method }}';\n\n    // button captions\n    cb_global.delete_button_caption = '{{ delete_button_caption }}'\n    cb_global.save_button_caption = '{{ save_button_caption }}'\n    cb_global.custom_rte_tag_icons = JSON.parse(\"{{ custom_rte_tag_icons|js_string }}\");\n\n    cb_global.required_modules = [{% for module in required_modules %}\n        '{{ module }}'{% if not loop.last %},{% endif %}{% endfor %}];\n    cb_global.schema = JSON.parse(\"{{ schema|js_string }}\");\n    cb_global.delete_message = '{{ delete_message }}';\n    cb_global.can_highlight_code = {% if can_highlight_code %}true{% else %}false{% endif %};\n    cb_global.load_schema_with_annotations = function(schema) {\n      {% for annotation in schema_annotations %}\n        schema.root{% for element in annotation[0] %}['{{element}}']{% endfor %}\n          = JSON.parse(\"{{ annotation[1]|js_string }}\")\n      {% endfor %}\n    }\n    cb_global.onFormLoad = function(Y) {\n      {% for file in extra_js_files %}\n        {% include file %}\n      {% endfor %}\n    };\n\n    {% include 'oeditor.js' %}\n    {% include 'rte.js' %}\n    {% include 'popup.js' %}\n\n    onPageLoad(cb_global);\n  })();\n</script>\n", "# Copyright 2012 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Generic object editor view that uses REST services.\"\"\"\n\n__author__ = 'Pavel Simakov (psimakov@google.com)'\n\nimport os\nimport urllib\n\nimport jinja2\nimport webapp2\n\nimport appengine_config\nfrom common import jinja_utils\nfrom common import schema_fields\nfrom common import tags\nfrom controllers import utils\nfrom models import custom_modules\nfrom models import transforms\nfrom models.config import ConfigProperty\n\n# a set of YUI and inputex modules required by the editor\nCOMMON_REQUIRED_MODULES = [\n    'inputex-group', 'inputex-form', 'inputex-jsonschema']\n\nALL_MODULES = [\n    'querystring-stringify-simple', 'inputex-select', 'inputex-string',\n    'inputex-radio', 'inputex-date', 'inputex-datepicker', 'inputex-checkbox',\n    'inputex-list', 'inputex-color', 'gcb-rte', 'inputex-textarea',\n    'inputex-url', 'inputex-uneditable', 'inputex-integer', 'inputex-hidden',\n    'inputex-file', 'io-upload-iframe']\n\nRESOURCES_PATH = '/modules/oeditor/resources'\n\n# Global code syntax highlighter controls.\nCAN_HIGHLIGHT_CODE = ConfigProperty(\n    'gcb_can_highlight_code', bool, (\n        'Whether or not to highlight code syntax '\n        'in Dashboard editors and displays.'),\n    True)\n\n\nclass ObjectEditor(object):\n    \"\"\"Generic object editor powered by jsonschema.\"\"\"\n\n    # Modules can add extra script tags to the oeditor page by registering a\n    # callback function here. The callback function will receive the app_context\n    # as an argument, and should return an iterable of strings, each of which is\n    # the URL of a script library.\n    EXTRA_SCRIPT_TAG_URLS = []\n\n    @classmethod\n    def get_html_for(\n        cls, handler, schema_json, annotations, object_key,\n        rest_url, exit_url,\n        extra_args=None,\n        save_method='put',\n        delete_url=None, delete_message=None, delete_method='post',\n        auto_return=False, read_only=False,\n        required_modules=None,\n        extra_css_files=None,\n        extra_js_files=None,\n        additional_dirs=None,\n        delete_button_caption='Delete',\n        save_button_caption='Save',\n        exit_button_caption='Close'):\n        \"\"\"Creates an HTML code needed to embed and operate this form.\n\n        This method creates an HTML, JS and CSS  required to embed JSON\n        schema-based object editor into a view.\n\n        Args:\n            handler: a BaseHandler class, which will host this HTML, JS and CSS\n            schema_json: a text of JSON schema for the object being edited\n            annotations: schema annotations dictionary\n            object_key: a key of an object being edited\n            rest_url: a REST endpoint for object GET/PUT operation\n            exit_url: a URL to go to after the editor form is dismissed\n            extra_args: extra request params passed back in GET and POST\n            save_method: how the data should be saved to the server (put|upload)\n            delete_url: optional URL for delete operation\n            delete_message: string. Optional custom delete confirmation message\n            delete_method: optional HTTP method for delete operation\n            auto_return: whether to return to the exit_url on successful save\n            read_only: optional flag; if set, removes Save and Delete operations\n            required_modules: list of inputex modules required for this editor\n            extra_css_files: list of extra CSS files to be included\n            extra_js_files: list of extra JS files to be included\n            additional_dirs: list of extra directories to look for\n                Jinja template files, e.g., JS or CSS files included by modules.\n            delete_button_caption: string. A caption for the 'Delete' button\n            save_button_caption: a caption for the 'Save' button\n            exit_button_caption: a caption for the 'Close' button\n\n        Returns:\n            The HTML, JS and CSS text that will instantiate an object editor.\n        \"\"\"\n        required_modules = required_modules or ALL_MODULES\n\n        if not delete_message:\n            kind = transforms.loads(schema_json).get('description')\n            if not kind:\n                kind = 'Generic Object'\n            delete_message = 'Are you sure you want to delete this %s?' % kind\n\n        # construct parameters\n        get_url = rest_url\n        get_args = {'key': object_key}\n        post_url = rest_url\n        post_args = {'key': object_key}\n\n        if extra_args:\n            get_args.update(extra_args)\n            post_args.update(extra_args)\n\n        if read_only:\n            post_url = ''\n            post_args = ''\n\n        custom_rte_tag_icons = []\n        for tag, tag_class in tags.get_tag_bindings().items():\n            custom_rte_tag_icons.append({\n                'name': tag,\n                'iconUrl': tag_class().get_icon_url()})\n\n        extra_script_tag_urls = []\n        for callback in cls.EXTRA_SCRIPT_TAG_URLS:\n            for url in callback():\n                extra_script_tag_urls.append(url)\n\n        template_values = {\n            'enabled': custom_module.enabled,\n            'schema': schema_json,\n            'get_url': '%s?%s' % (get_url, urllib.urlencode(get_args, True)),\n            'save_url': post_url,\n            'save_args': transforms.dumps(post_args),\n            'exit_button_caption': exit_button_caption,\n            'exit_url': jinja2.Markup(exit_url),  # suppress & -> &amp; in url\n            'required_modules': COMMON_REQUIRED_MODULES + required_modules,\n            'extra_css_files': extra_css_files or [],\n            'extra_js_files': extra_js_files or [],\n            'schema_annotations': [\n                (item[0], transforms.dumps(item[1])) for item in annotations],\n            'save_method': save_method,\n            'auto_return': auto_return,\n            'delete_button_caption': delete_button_caption,\n            'save_button_caption': save_button_caption,\n            'custom_rte_tag_icons': transforms.dumps(custom_rte_tag_icons),\n            'delete_message': delete_message,\n            'can_highlight_code': CAN_HIGHLIGHT_CODE.value,\n            'extra_script_tag_urls': extra_script_tag_urls,\n        }\n\n        if delete_url and not read_only:\n            template_values['delete_url'] = delete_url\n        if delete_method:\n            template_values['delete_method'] = delete_method\n        if appengine_config.BUNDLE_LIB_FILES:\n            template_values['bundle_lib_files'] = True\n\n        return jinja2.utils.Markup(handler.get_template('oeditor.html', (\n            [os.path.dirname(__file__)] + (additional_dirs or [])\n        )).render(template_values))\n\n\nclass PopupHandler(webapp2.RequestHandler, utils.ReflectiveRequestHandler):\n    \"\"\"A handler to serve the content of the popup subeditor.\"\"\"\n\n    default_action = 'custom_tag'\n    get_actions = ['edit_custom_tag', 'add_custom_tag']\n    post_actions = []\n\n    def get_template(self, template_name, dirs):\n        \"\"\"Sets up an environment and Gets jinja template.\"\"\"\n        return jinja_utils.get_template(\n            template_name, dirs + [os.path.dirname(__file__)])\n\n    def _validate_schema(self, tag, schema):\n        if schema.has_subregistries():\n            return tag.unavailable_schema(\n                'This tag has an invalid schema and cannot be edited. '\n                'Only simple field types are allowed.')\n\n        text_field_count = 0\n        index = schema_fields.FieldRegistryIndex(schema)\n        index.rebuild()\n        for name in index.names_in_order:\n            if index.find(name).type == 'text':\n                text_field_count += 1\n        if text_field_count > 1:\n            return tag.unavailable_schema(\n                'This tag has an invalid schema and cannot be edited. '\n                'Only one field of type \"text\" is allowed.')\n\n        return schema\n\n    def get_edit_custom_tag(self):\n        \"\"\"Return the the page used to edit a custom HTML tag in a popup.\"\"\"\n        tag_name = self.request.get('tag_name')\n        tag_bindings = tags.get_tag_bindings()\n        tag_class = tag_bindings[tag_name]\n        tag = tag_class()\n        schema = tag.get_schema(self)\n        schema = self._validate_schema(tag, schema)\n\n        template_values = {}\n        template_values['form_html'] = ObjectEditor.get_html_for(\n            self, schema.get_json_schema(), schema.get_schema_dict(), None,\n            None, None,\n            required_modules=tag_class.required_modules(),\n            extra_js_files=tag_class.extra_js_files(),\n            extra_css_files=tag_class.extra_css_files(),\n            additional_dirs=tag_class.additional_dirs())\n        self.response.out.write(\n            self.get_template('popup.html', []).render(template_values))\n\n    def get_add_custom_tag(self):\n        \"\"\"Return the page for the popup used to add a custom HTML tag.\"\"\"\n        tag_name = self.request.get('tag_name')\n        excluded_tags = self.request.get_all('excluded_tags')\n\n        tag_bindings = tags.get_tag_bindings()\n\n        select_data = []\n        for name in tag_bindings.keys():\n            if name not in excluded_tags:\n                clazz = tag_bindings[name]\n                select_data.append((name, '%s: %s' % (\n                    clazz.vendor(), clazz.name())))\n        select_data = sorted(select_data, key=lambda pair: pair[1])\n\n        if tag_name:\n            tag_class = tag_bindings[tag_name]\n        else:\n            tag_class = tag_bindings[select_data[0][0]]\n        tag = tag_class()\n        tag_schema = tag.get_schema(self)\n        tag_schema = self._validate_schema(tag, tag_schema)\n\n        schema = schema_fields.FieldRegistry('Add a Component')\n        type_select = schema.add_sub_registry('type', 'Component Type')\n        type_select.add_property(schema_fields.SchemaField(\n            'tag', 'Name', 'string', select_data=select_data))\n        schema.add_sub_registry('attributes', registry=tag_schema)\n\n        template_values = {}\n        template_values['form_html'] = ObjectEditor.get_html_for(\n            self, schema.get_json_schema(), schema.get_schema_dict(), None,\n            None, None,\n            required_modules=tag_class.required_modules(),\n            extra_js_files=['add_custom_tag.js'] + tag_class.extra_js_files(),\n            extra_css_files=tag_class.extra_css_files(),\n            additional_dirs=tag_class.additional_dirs())\n        self.response.out.write(\n            self.get_template('popup.html', []).render(template_values))\n\n\ndef create_bool_select_annotation(\n    keys_list, label, true_label, false_label, class_name=None,\n    description=None):\n    \"\"\"Creates inputex annotation to display bool type as a select.\"\"\"\n    properties = {\n        'label': label, 'choices': [\n            {'value': True, 'label': true_label},\n            {'value': False, 'label': false_label}]}\n    if class_name:\n        properties['className'] = class_name\n    if description:\n        properties['description'] = description\n    return (keys_list, {'type': 'select', '_inputex': properties})\n\n\ncustom_module = None\n\n\ndef register_module():\n    \"\"\"Registers this module in the registry.\"\"\"\n\n    from controllers import sites\n\n    yui_handlers = [\n        ('/static/inputex-3.1.0/(.*)', sites.make_zip_handler(\n            os.path.join(\n                appengine_config.BUNDLE_ROOT, 'lib/inputex-3.1.0.zip'))),\n        ('/static/yui_3.6.0/(.*)', sites.make_zip_handler(\n            os.path.join(\n                appengine_config.BUNDLE_ROOT, 'lib/yui_3.6.0.zip'))),\n        ('/static/2in3/(.*)', sites.make_zip_handler(\n            os.path.join(\n                appengine_config.BUNDLE_ROOT, 'lib/yui_2in3-2.9.0.zip')))]\n\n    codemirror_handler = [\n        ('/static/codemirror/(.*)', sites.make_zip_handler(\n            os.path.join(\n                appengine_config.BUNDLE_ROOT, 'lib/codemirror-4.5.0.zip')))]\n\n    if appengine_config.BUNDLE_LIB_FILES:\n        yui_handlers += [\n            ('/static/combo/inputex', sites.make_css_combo_zip_handler(\n                os.path.join(\n                    appengine_config.BUNDLE_ROOT, 'lib/inputex-3.1.0.zip'),\n                '/static/inputex-3.1.0/')),\n            ('/static/combo/yui', sites.make_css_combo_zip_handler(\n                os.path.join(appengine_config.BUNDLE_ROOT, 'lib/yui_3.6.0.zip'),\n                '/yui/')),\n            ('/static/combo/2in3', sites.make_css_combo_zip_handler(\n                os.path.join(\n                    appengine_config.BUNDLE_ROOT, 'lib/yui_2in3-2.9.0.zip'),\n                '/static/2in3/'))]\n\n    oeditor_handlers = [('/oeditorpopup', PopupHandler)]\n    global_routes = yui_handlers + codemirror_handler + [\n        (os.path.join(RESOURCES_PATH, '.*'), tags.ResourcesHandler)]\n\n    global custom_module  # pylint: disable=global-statement\n    custom_module = custom_modules.Module(\n        'Object Editor',\n        'A visual editor for editing various types of objects.',\n        global_routes, oeditor_handlers)\n    return custom_module\n", "# Copyright 2014 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests that walk through Course Builder pages.\"\"\"\n\n__author__ = 'Mike Gainer (mgainer@google.com)'\n\nimport cgi\nimport re\nimport urllib\n\nfrom common import crypto\nfrom common import utils as common_utils\nfrom controllers import sites\nfrom controllers import utils\nfrom models import courses\nfrom models import models\nfrom models import transforms\nfrom modules.dashboard import course_settings\nfrom modules.dashboard import filer\nfrom modules.i18n_dashboard import i18n_dashboard\nfrom tests.functional import actions\nfrom tests.functional.actions import assert_contains\nfrom tests.functional.actions import assert_does_not_contain\n\nCOURSE_NAME = 'admin_settings'\nCOURSE_TITLE = 'Admin Settings'\nADMIN_EMAIL = 'admin@foo.com'\nNAMESPACE = 'ns_%s' % COURSE_NAME\nBASE_URL = '/' + COURSE_NAME\nADMIN_SETTINGS_URL = '/%s%s' % (\n    COURSE_NAME, course_settings.HtmlHookRESTHandler.URI)\nTEXT_ASSET_URL = '/%s%s' % (\n    COURSE_NAME, filer.TextAssetRESTHandler.URI)\nSTUDENT_EMAIL = 'student@foo.com'\nSETTINGS_URL = '/%s/dashboard?action=settings&tab=admin_prefs' % COURSE_NAME\n\n\nclass AdminSettingsTests(actions.TestBase):\n\n    def setUp(self):\n        super(AdminSettingsTests, self).setUp()\n        actions.simple_add_course(COURSE_NAME, ADMIN_EMAIL, COURSE_TITLE)\n        actions.login(ADMIN_EMAIL)\n\n    def test_defaults(self):\n        prefs = models.StudentPreferencesDAO.load_or_create()\n        self.assertEquals(False, prefs.show_hooks)\n\n\nclass WelcomePageTests(actions.TestBase):\n\n    def setUp(self):\n        super(WelcomePageTests, self).setUp()\n        self.auto_deploy = sites.ApplicationContext.AUTO_DEPLOY_DEFAULT_COURSE\n        sites.ApplicationContext.AUTO_DEPLOY_DEFAULT_COURSE = False\n\n    def tearDown(self):\n        sites.ApplicationContext.AUTO_DEPLOY_DEFAULT_COURSE = self.auto_deploy\n        super(WelcomePageTests, self).tearDown()\n\n    def test_welcome_page(self):\n        actions.login(ADMIN_EMAIL, is_admin=True)\n        response = self.get('/')\n        self.assertEqual(response.status_int, 302)\n        self.assertEqual(\n            response.headers['location'],\n            'http://localhost/admin/welcome')\n        response = self.get('/admin/welcome?action=welcome')\n        assert_contains('Welcome to Course Builder', response.body)\n        assert_contains('/admin/welcome?action=add_first_course', response.body)\n        assert_contains('/admin/welcome?action=explore_sample', response.body)\n\n    def test_explore_sample_course(self):\n        actions.login(ADMIN_EMAIL, is_admin=True)\n        response = self.post(\n            '/admin/welcome?action=explore_sample',\n            params={'xsrf_token': crypto.XsrfTokenManager.create_xsrf_token(\n                'explore_sample')})\n        self.assertEqual(response.status_int, 302)\n        self.assertEqual(\n            response.headers['location'],\n            'http://localhost/sample/dashboard')\n        response = self.get('/sample/dashboard')\n        assert_contains('Power Searching with Google', response.body)\n        assert_does_not_contain('explore_sample', response.body)\n\n    def test_create_new_course(self):\n        actions.login(ADMIN_EMAIL, is_admin=True)\n        response = self.post(\n            '/admin/welcome?action=add_first_course',\n            params={'xsrf_token': crypto.XsrfTokenManager.create_xsrf_token(\n                'add_first_course')})\n        self.assertEqual(response.status_int, 302)\n        self.assertEqual(\n            response.headers['location'],\n            'http://localhost/first/dashboard')\n        response = self.get('/first/dashboard')\n        assert_contains('My First Course', response.body)\n        response = self.get('/admin/welcome?action=welcome')\n        assert_does_not_contain('add_first_course', response.body)\n\n    def test_explore_sample_course_idempotent(self):\n        self.test_explore_sample_course()\n        self.test_explore_sample_course()\n\n        self.test_create_new_course()\n        response = self.get('/')\n        self.assertEqual(response.status_int, 302)\n        self.assertEqual(\n            response.headers['location'],\n            'http://localhost/sample/course?use_last_location=true')\n\n    def test_create_new_course_idempotent(self):\n        self.test_create_new_course()\n        self.test_create_new_course()\n\n        self.test_explore_sample_course()\n        response = self.get('/')\n        self.assertEqual(response.status_int, 302)\n        self.assertEqual(\n            response.headers['location'],\n            'http://localhost/first/course?use_last_location=true')\n\n\nclass HtmlHookTest(actions.TestBase):\n\n    def setUp(self):\n        super(HtmlHookTest, self).setUp()\n\n        self.app_context = actions.simple_add_course(COURSE_NAME, ADMIN_EMAIL,\n                                            COURSE_TITLE)\n        self.course = courses.Course(None, self.app_context)\n        actions.login(ADMIN_EMAIL, is_admin=True)\n        self.xsrf_token = crypto.XsrfTokenManager.create_xsrf_token(\n            course_settings.HtmlHookRESTHandler.XSRF_ACTION)\n\n    def tearDown(self):\n        settings = self.course.get_environ(self.app_context)\n        settings.pop('foo', None)\n        settings['html_hooks'].pop('foo', None)\n        self.course.save_settings(settings)\n        super(HtmlHookTest, self).tearDown()\n\n    def test_hook_edit_button_presence(self):\n\n        # Turn preference on; expect to see hook editor button\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.show_hooks = True\n            models.StudentPreferencesDAO.save(prefs)\n        response = self.get(BASE_URL)\n        self.assertIn('gcb-html-hook-edit', response.body)\n\n        # Turn preference off; expect editor button not present.\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.show_hooks = False\n            models.StudentPreferencesDAO.save(prefs)\n\n        response = self.get(BASE_URL)\n        self.assertNotIn('gcb-html-hook-edit', response.body)\n\n    def test_non_admin_permissions_failures(self):\n        actions.login(STUDENT_EMAIL)\n        student_xsrf_token = crypto.XsrfTokenManager.create_xsrf_token(\n            course_settings.HtmlHookRESTHandler.XSRF_ACTION)\n\n        response = self.get(ADMIN_SETTINGS_URL)\n        self.assertEquals(200, response.status_int)\n        payload = transforms.loads(response.body)\n        self.assertEquals(401, payload['status'])\n        self.assertEquals('Access denied.', payload['message'])\n\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'key': 'base:after_body_tag_begins',\n                'xsrf_token': cgi.escape(student_xsrf_token),\n                'payload': '{}'})})\n        payload = transforms.loads(response.body)\n        self.assertEquals(401, payload['status'])\n        self.assertEquals('Access denied.', payload['message'])\n\n        response = self.delete(ADMIN_SETTINGS_URL + '?xsrf_token=' +\n                               cgi.escape(student_xsrf_token))\n        self.assertEquals(200, response.status_int)\n        payload = transforms.loads(response.body)\n        self.assertEquals(401, payload['status'])\n        self.assertEquals('Access denied.', payload['message'])\n\n    def test_malformed_requests(self):\n        response = self.put(ADMIN_SETTINGS_URL, {})\n        payload = transforms.loads(response.body)\n        self.assertEquals(400, payload['status'])\n        self.assertEquals('Missing \"request\" parameter.', payload['message'])\n\n        response = self.put(ADMIN_SETTINGS_URL, {'request': 'asdfasdf'})\n        payload = transforms.loads(response.body)\n        self.assertEquals(400, payload['status'])\n        self.assertEquals('Malformed \"request\" parameter.', payload['message'])\n\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token)})})\n        payload = transforms.loads(response.body)\n        self.assertEquals(400, payload['status'])\n        self.assertEquals('Request missing \"key\" parameter.',\n                          payload['message'])\n\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token),\n                'key': 'base:after_body_tag_begins'})})\n        payload = transforms.loads(response.body)\n        self.assertEquals(400, payload['status'])\n        self.assertEquals('Request missing \"payload\" parameter.',\n                          payload['message'])\n\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token),\n                'key': 'base:after_body_tag_begins',\n                'payload': 'asdfsdfasdf'})})\n        payload = transforms.loads(response.body)\n        self.assertEquals(400, payload['status'])\n        self.assertEquals('Malformed \"payload\" parameter.',\n                          payload['message'])\n\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token),\n                'key': 'base:after_body_tag_begins',\n                'payload': '{}'})})\n        payload = transforms.loads(response.body)\n        self.assertEquals(400, payload['status'])\n        self.assertEquals('Payload missing \"hook_content\" parameter.',\n                          payload['message'])\n\n    def test_get_unknown_hook_content(self):\n        # Should be safe (but unhelpful) to ask for no hook.\n        response = transforms.loads(self.get(ADMIN_SETTINGS_URL).body)\n        payload = transforms.loads(response['payload'])\n        self.assertIsNone(payload['hook_content'])\n\n    def test_get_defaulted_hook_content(self):\n        url = '%s?key=%s' % (\n            ADMIN_SETTINGS_URL, cgi.escape('base.after_body_tag_begins'))\n        response = transforms.loads(self.get(url).body)\n        self.assertEquals(200, response['status'])\n        self.assertEquals('Success.', response['message'])\n        payload = transforms.loads(response['payload'])\n        self.assertEquals('<!-- base.after_body_tag_begins -->',\n                          payload['hook_content'])\n\n    def test_page_has_defaulted_hook_content(self):\n        response = self.get(BASE_URL)\n        self.assertIn('<!-- base.after_body_tag_begins -->', response.body)\n\n    def test_set_hook_content(self):\n        html_text = '<table><tbody><tr><th>;&lt;&gt;</th></tr></tbody></table>'\n\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token),\n                'key': 'base.after_body_tag_begins',\n                'payload': transforms.dumps(\n                    {'hook_content': html_text})})})\n        self.assertEquals(200, response.status_int)\n        response = transforms.loads(response.body)\n        self.assertEquals(200, response['status'])\n        self.assertEquals('Saved.', response['message'])\n\n        # And verify that the changed text appears on course pages.\n        # NOTE that text is as-is; no escaping of special HTML\n        # characters should have been done.\n        response = self.get(BASE_URL)\n        self.assertIn(html_text, response.body)\n\n    def test_delete_default_content_ineffective(self):\n        response = self.get(BASE_URL)\n        self.assertIn('<!-- base.after_body_tag_begins -->', response.body)\n\n        url = '%s?key=%s&xsrf_token=%s' % (\n            ADMIN_SETTINGS_URL, cgi.escape('base.after_body_tag_begins'),\n            cgi.escape(self.xsrf_token))\n        response = transforms.loads(self.delete(url).body)\n        self.assertEquals(200, response['status'])\n        self.assertEquals('Deleted.', response['message'])\n\n        response = self.get(BASE_URL)\n        self.assertIn('<!-- base.after_body_tag_begins -->', response.body)\n\n    def test_manipulate_non_default_item(self):\n        html_text = '<table><tbody><tr><th>;&lt;&gt;</th></tr></tbody></table>'\n        new_hook_name = 'html.some_new_hook'\n\n        # Verify that content prior to setting is blank.\n        url = '%s?key=%s&xsrf_token=%s' % (\n            ADMIN_SETTINGS_URL, cgi.escape(new_hook_name),\n            cgi.escape(self.xsrf_token))\n        response = transforms.loads(self.get(url).body)\n        payload = transforms.loads(response['payload'])\n        self.assertIsNone(payload['hook_content'])\n\n        # Set the content.\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token),\n                'key': new_hook_name,\n                'payload': transforms.dumps(\n                    {'hook_content': html_text})})})\n        self.assertEquals(200, response.status_int)\n        response = transforms.loads(response.body)\n        self.assertEquals(200, response['status'])\n        self.assertEquals('Saved.', response['message'])\n\n        # Verify that content after setting is as expected\n        url = '%s?key=%s&xsrf_token=%s' % (\n            ADMIN_SETTINGS_URL, cgi.escape(new_hook_name),\n            cgi.escape(self.xsrf_token))\n        response = transforms.loads(self.get(url).body)\n        payload = transforms.loads(response['payload'])\n        self.assertEquals(html_text, payload['hook_content'])\n\n        # Delete the content.\n        response = transforms.loads(self.delete(url).body)\n        self.assertEquals(200, response['status'])\n        self.assertEquals('Deleted.', response['message'])\n\n        # Verify that content after setting is None.\n        url = '%s?key=%s&xsrf_token=%s' % (\n            ADMIN_SETTINGS_URL, cgi.escape(new_hook_name),\n            cgi.escape(self.xsrf_token))\n        response = transforms.loads(self.get(url).body)\n        payload = transforms.loads(response['payload'])\n        self.assertIsNone(payload['hook_content'])\n\n    def test_add_new_hook_to_page(self):\n        hook_name = 'html.my_new_hook'\n        html_text = '<table><tbody><tr><th>;&lt;&gt;</th></tr></tbody></table>'\n        key = 'views/base.html'\n        url = '%s?key=%s' % (\n            TEXT_ASSET_URL, cgi.escape(key))\n\n        # Get base page template.\n        response = transforms.loads(self.get(url).body)\n        xsrf_token = response['xsrf_token']\n        payload = transforms.loads(response['payload'])\n        contents = payload['contents']\n\n        # Add hook specification to page content.\n        contents = contents.replace(\n            '<body data-gcb-page-locale=\"{{ page_locale }}\">',\n            '<body data-gcb-page-locale=\"{{ page_locale }}\">\\n' +\n            '{{ html_hooks.insert(\\'%s\\') | safe }}' % hook_name)\n        self.put(TEXT_ASSET_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(xsrf_token),\n                'key': key,\n                'payload': transforms.dumps({'contents': contents})})})\n\n        # Verify that new hook appears on page.\n        response = self.get(BASE_URL)\n        self.assertIn('id=\"%s\"' % re.sub('[^a-zA-Z-]', '-', hook_name),\n                      response.body)\n\n        # Verify that modified hook content appears on page\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token),\n                'key': hook_name,\n                'payload': transforms.dumps(\n                    {'hook_content': html_text})})})\n\n        response = self.get(BASE_URL)\n        self.assertIn(html_text, response.body)\n\n    def test_student_admin_hook_visibility(self):\n        actions.login(STUDENT_EMAIL, is_admin=False)\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.show_hooks = True\n            models.StudentPreferencesDAO.save(prefs)\n\n        response = self.get(BASE_URL)\n        self.assertNotIn('gcb-html-hook-edit', response.body)\n\n        actions.login(ADMIN_EMAIL, is_admin=True)\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.show_hooks = True\n            models.StudentPreferencesDAO.save(prefs)\n        response = self.get(BASE_URL)\n        self.assertIn('gcb-html-hook-edit', response.body)\n\n    def test_hook_i18n(self):\n        actions.update_course_config(\n            COURSE_NAME,\n            {\n                'html_hooks': {'base': {'after_body_tag_begins': 'foozle'}},\n                'extra_locales': [\n                    {'locale': 'de', 'availability': 'available'},\n                ]\n            })\n\n        hook_bundle = {\n            'content': {\n                'type': 'html',\n                'source_value': '',\n                'data': [{\n                    'source_value': 'foozle',\n                    'target_value': 'FUZEL',\n                }],\n            }\n        }\n        hook_key = i18n_dashboard.ResourceBundleKey(\n            utils.ResourceHtmlHook.TYPE, 'base.after_body_tag_begins', 'de')\n        with common_utils.Namespace(NAMESPACE):\n            i18n_dashboard.ResourceBundleDAO.save(\n                i18n_dashboard.ResourceBundleDTO(str(hook_key), hook_bundle))\n\n        # Verify non-translated version.\n        response = self.get(BASE_URL)\n        dom = self.parse_html_string(response.body)\n        html_hook = dom.find('.//div[@id=\"base-after-body-tag-begins\"]')\n        self.assertEquals('foozle', html_hook.text)\n\n        # Set preference to translated language, and check that that's there.\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.locale = 'de'\n            models.StudentPreferencesDAO.save(prefs)\n\n        response = self.get(BASE_URL)\n        dom = self.parse_html_string(response.body)\n        html_hook = dom.find('.//div[@id=\"base-after-body-tag-begins\"]')\n        self.assertEquals('FUZEL', html_hook.text)\n\n        # With no translation present, but preference set to foreign language,\n        # verify that we fall back to the original language.\n\n        # Remove translation bundle, and clear cache.\n        with common_utils.Namespace(NAMESPACE):\n            i18n_dashboard.ResourceBundleDAO.delete(\n                i18n_dashboard.ResourceBundleDTO(str(hook_key), hook_bundle))\n        i18n_dashboard.ProcessScopedResourceBundleCache.instance().clear()\n\n        response = self.get(BASE_URL)\n        dom = self.parse_html_string(response.body)\n        html_hook = dom.find('.//div[@id=\"base-after-body-tag-begins\"]')\n        self.assertEquals('foozle', html_hook.text)\n\n    def test_hook_content_found_in_old_location(self):\n        actions.update_course_config(COURSE_NAME, {'foo': {'bar': 'baz'}})\n        self.assertEquals(\n            'baz', utils.HtmlHooks.get_content(self.course, 'foo.bar'))\n\n    def test_insert_on_page_and_hook_content_found_using_old_separator(self):\n        settings = self.course.get_environ(self.app_context)\n        settings['html_hooks']['foo'] = {'bar': 'baz'}\n        self.course.save_settings(settings)\n        hooks = utils.HtmlHooks(self.course)\n        content = hooks.insert('foo:bar')\n        self.assertEquals('<div class=\"gcb-html-hook\" id=\"foo-bar\">baz</div>',\n                          str(content))\n\n    def test_hook_content_new_location_overrides_old_location(self):\n        actions.update_course_config(COURSE_NAME,\n                                     {'html_hooks': {'foo': {'bar': 'zab'}}})\n        actions.update_course_config(COURSE_NAME,\n                                     {'foo': {'bar': 'baz'}})\n        self.assertEquals(\n            'zab', utils.HtmlHooks.get_content(self.course, 'foo.bar'))\n\n    def test_hook_rest_edit_removes_from_old_location(self):\n        actions.update_course_config(COURSE_NAME,\n                                     {'html_hooks': {'foo': {'bar': 'zab'}}})\n        actions.update_course_config(COURSE_NAME,\n                                     {'foo': {'bar': 'baz'}})\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token),\n                'key': 'foo.bar',\n                'payload': transforms.dumps({'hook_content': 'BAZ'})})})\n        env = self.course.get_environ(self.app_context)\n        self.assertNotIn('bar', env['foo'])\n        self.assertEquals('BAZ', env['html_hooks']['foo']['bar'])\n\n\n    def test_hook_rest_delete_removes_from_old_and_new_location(self):\n        actions.update_course_config(COURSE_NAME,\n                                     {'html_hooks': {'foo': {'bar': 'zab'}}})\n        actions.update_course_config(COURSE_NAME,\n                                     {'foo': {'bar': 'baz'}})\n        url = '%s?key=%s&xsrf_token=%s' % (\n            ADMIN_SETTINGS_URL, cgi.escape('foo.bar'),\n            cgi.escape(self.xsrf_token))\n        self.delete(url)\n\n        env = self.course.get_environ(self.app_context)\n        self.assertNotIn('bar', env['foo'])\n        self.assertNotIn('bar', env['html_hooks']['foo'])\n\n\nclass JinjaContextTest(actions.TestBase):\n\n    def setUp(self):\n        super(JinjaContextTest, self).setUp()\n        actions.simple_add_course(COURSE_NAME, ADMIN_EMAIL, COURSE_TITLE)\n        actions.login(ADMIN_EMAIL, is_admin=True)\n\n    def _get_jinja_context_text(self, response):\n        root = self.parse_html_string(response.text)\n        div = root.find('body/div[last()]')\n        return ''.join(div.itertext())\n\n    def test_show_jina_context_presence(self):\n\n        # Turn preference on; expect to see context dump.\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.show_jinja_context = True\n            models.StudentPreferencesDAO.save(prefs)\n        self.assertIn('is_read_write_course:',\n                      self._get_jinja_context_text(self.get(BASE_URL)))\n\n        # Turn preference off; expect context dump not present.\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.show_jinja_context = False\n            models.StudentPreferencesDAO.save(prefs)\n        self.assertNotIn('is_read_write_course:',\n                         self._get_jinja_context_text(self.get(BASE_URL)))\n\n    def test_student_jinja_context_visibility(self):\n\n        actions.login(STUDENT_EMAIL, is_admin=False)\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.show_jinja_context = True\n            models.StudentPreferencesDAO.save(prefs)\n        self.assertNotIn('is_read_write_course:',\n                         self._get_jinja_context_text(self.get(BASE_URL)))\n\n\nclass ExitUrlTest(actions.TestBase):\n\n    def setUp(self):\n        super(ExitUrlTest, self).setUp()\n        actions.simple_add_course(COURSE_NAME, ADMIN_EMAIL, COURSE_TITLE)\n        actions.login(ADMIN_EMAIL, is_admin=True)\n\n    def test_exit_url(self):\n        base_url = '/%s/dashboard?action=settings&tab=data_pump' % COURSE_NAME\n        url = base_url + '&' + urllib.urlencode({\n            'exit_url': 'dashboard?%s' % urllib.urlencode({\n                'action': 'analytics',\n                'tab': 'data_pump'})})\n        response = self.get(url)\n        self.assertIn(\n            'cb_global.exit_url = \\'dashboard?action=analytics&tab=data_pump\\'',\n            response.body)\n"], "fixing_code": ["<!-- TODO(psimakov): use local YUI library -->\n<link rel=\"stylesheet\" type=\"text/css\"\n    href=\"/static/yui_3.6.0/yui/build/cssreset-context/cssreset-context-min.css\">\n<script\n    src=\"/static/yui_3.6.0/yui/build/yui/yui.js\"></script>\n<link rel=\"stylesheet\" type=\"text/css\"\n    href=\"/static/inputex-3.1.0/src/inputex/assets/skins/sam/inputex.css\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"/modules/oeditor/resources/butterbar.css\">\n<script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"></script>\n<script src=\"/modules/oeditor/resources/butterbar.js\" type='text/javascript'></script>\n<script\n    src=\"/static/inputex-3.1.0/src/loader.js\" type='text/javascript'></script>\n<script\n    src=\"/static/inputex-3.1.0/lib/jsonPretty.js\" type='text/javascript'></script>\n\n{% if can_highlight_code %}\n  <!-- import CodeMirror -->\n  <script src=\"/static/codemirror/lib/codemirror.js\"></script>\n  <link rel=\"stylesheet\" href=\"/static/codemirror/lib/codemirror.css\">\n  <script src=\"/static/codemirror/mode/htmlmixed/htmlmixed.js\"></script>\n  <script src=\"/static/codemirror/mode/xml/xml.js\"></script>\n  <script src=\"/static/codemirror/mode/javascript/javascript.js\"></script>\n  <script src=\"/static/codemirror/mode/css/css.js\"></script>\n  <script src=\"/static/codemirror/keymap/sublime.js\"></script>\n  <script src=\"/static/codemirror/addon/mode/loadmode.js\"></script>\n  <link rel=\"stylesheet\" href=\"/static/codemirror/addon/fold/foldgutter.css\">\n  <script src=\"/static/codemirror/addon/fold/foldcode.js\"></script>\n  <script src=\"/static/codemirror/addon/fold/foldgutter.js\"></script>\n  <script src=\"/static/codemirror/addon/fold/brace-fold.js\"></script>\n  <script src=\"/static/codemirror/addon/fold/xml-fold.js\"></script>\n  <script src=\"/static/codemirror/addon/fold/markdown-fold.js\"></script>\n  <script src=\"/static/codemirror/addon/fold/comment-fold.js\"></script>\n  <link rel=\"stylesheet\" href=\"/static/codemirror/addon/dialog/dialog.css\">\n  <script src=\"/static/codemirror/addon/dialog/dialog.js\"></script>\n  <script src=\"/static/codemirror/addon/search/searchcursor.js\"></script>\n  <script src=\"/static/codemirror/addon/search/search.js\"></script>\n{% endif %}\n\n<!-- import extension libraries. -->\n{% for url in extra_script_tag_urls %}\n  <script src='{{ url }}'></script>\n{% endfor %}\n\n<link rel=\"stylesheet\" type=\"text/css\"\n    href=\"/modules/oeditor/resources/oeditor.css\"/>\n<style>\n  {% for file in extra_css_files %}\n    {% include file %}\n  {% endfor %}\n</style>\n\n<div id='oeditor-container'>\n  <div class='gcb-butterbar-container'>\n    <div class='gcb-butterbar' id='gcb-butterbar-top' style='top:-45px'>\n      <p id='gcb-butterbar-message'></p>\n      <a id='gcb-butterbar-close'>X</a>\n    </div>\n  </div>\n  <div style='width: 100%;' align='center' class='yui3-skin-sam yui-skin-sam'>\n    <div class='form' id='formContainer'></div>\n  </div>\n</div>\n<div id='modal-editor' class='hidden'>\n  <div class='background'></div>\n</div>\n\n<script type='text/javascript'>\n  (function() {\n    //keep all our global objects here\n    var cb_global = {};\n\n    // various URL's needed by the form\n    cb_global.get_url = '{{ get_url|js_string }}';\n    cb_global.save_url = '{{ save_url|js_string }}';\n    cb_global.save_args = JSON.parse(\"{{ save_args|js_string }}\");\n    cb_global.exit_button_caption = '{{ exit_button_caption|js_string }}';\n    cb_global.exit_url = '{{ exit_url|js_string }}';\n    cb_global.save_method = '{{ save_method|js_string }}';\n    cb_global.auto_return = {% if auto_return %}true{% else %}false{% endif %};\n    cb_global.bundle_lib_files = {% if bundle_lib_files %}true{% else %}false{% endif %};\n\n    // If this value is '', deletions are not allowed\n    cb_global.delete_url = '{{ delete_url|js_string }}';\n    cb_global.delete_method = '{{ delete_method|js_string }}';\n\n    // button captions\n    cb_global.delete_button_caption = '{{ delete_button_caption|js_string }}'\n    cb_global.save_button_caption = '{{ save_button_caption|js_string }}'\n    cb_global.custom_rte_tag_icons = JSON.parse(\"{{ custom_rte_tag_icons|js_string }}\");\n\n    cb_global.required_modules = [{% for module in required_modules %}\n        '{{ module|js_string }}'{% if not loop.last %},{% endif %}{% endfor %}];\n    cb_global.schema = JSON.parse(\"{{ schema|js_string }}\");\n    cb_global.delete_message = '{{ delete_message|js_string }}';\n    cb_global.can_highlight_code = {% if can_highlight_code %}true{% else %}false{% endif %};\n    cb_global.load_schema_with_annotations = function(schema) {\n      {% for annotation in schema_annotations %}\n        schema.root{% for element in annotation[0] %}['{{element|js_string}}']{% endfor %}\n          = JSON.parse(\"{{ annotation[1]|js_string }}\")\n      {% endfor %}\n    }\n    cb_global.onFormLoad = function(Y) {\n      {% for file in extra_js_files %}\n        {% include file %}\n      {% endfor %}\n    };\n\n    {% include 'oeditor.js' %}\n    {% include 'rte.js' %}\n    {% include 'popup.js' %}\n\n    onPageLoad(cb_global);\n  })();\n</script>\n", "# Copyright 2012 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Generic object editor view that uses REST services.\"\"\"\n\n__author__ = 'Pavel Simakov (psimakov@google.com)'\n\nimport os\nimport urllib\n\nimport jinja2\nimport webapp2\n\nimport appengine_config\nfrom common import jinja_utils\nfrom common import schema_fields\nfrom common import tags\nfrom controllers import utils\nfrom models import custom_modules\nfrom models import transforms\nfrom models.config import ConfigProperty\n\n# a set of YUI and inputex modules required by the editor\nCOMMON_REQUIRED_MODULES = [\n    'inputex-group', 'inputex-form', 'inputex-jsonschema']\n\nALL_MODULES = [\n    'querystring-stringify-simple', 'inputex-select', 'inputex-string',\n    'inputex-radio', 'inputex-date', 'inputex-datepicker', 'inputex-checkbox',\n    'inputex-list', 'inputex-color', 'gcb-rte', 'inputex-textarea',\n    'inputex-url', 'inputex-uneditable', 'inputex-integer', 'inputex-hidden',\n    'inputex-file', 'io-upload-iframe']\n\nRESOURCES_PATH = '/modules/oeditor/resources'\n\n# Global code syntax highlighter controls.\nCAN_HIGHLIGHT_CODE = ConfigProperty(\n    'gcb_can_highlight_code', bool, (\n        'Whether or not to highlight code syntax '\n        'in Dashboard editors and displays.'),\n    True)\n\n\nclass ObjectEditor(object):\n    \"\"\"Generic object editor powered by jsonschema.\"\"\"\n\n    # Modules can add extra script tags to the oeditor page by registering a\n    # callback function here. The callback function will receive the app_context\n    # as an argument, and should return an iterable of strings, each of which is\n    # the URL of a script library.\n    EXTRA_SCRIPT_TAG_URLS = []\n\n    @classmethod\n    def get_html_for(\n        cls, handler, schema_json, annotations, object_key,\n        rest_url, exit_url,\n        extra_args=None,\n        save_method='put',\n        delete_url=None, delete_message=None, delete_method='post',\n        auto_return=False, read_only=False,\n        required_modules=None,\n        extra_css_files=None,\n        extra_js_files=None,\n        additional_dirs=None,\n        delete_button_caption='Delete',\n        save_button_caption='Save',\n        exit_button_caption='Close'):\n        \"\"\"Creates an HTML code needed to embed and operate this form.\n\n        This method creates an HTML, JS and CSS  required to embed JSON\n        schema-based object editor into a view.\n\n        Args:\n            handler: a BaseHandler class, which will host this HTML, JS and CSS\n            schema_json: a text of JSON schema for the object being edited\n            annotations: schema annotations dictionary\n            object_key: a key of an object being edited\n            rest_url: a REST endpoint for object GET/PUT operation\n            exit_url: a URL to go to after the editor form is dismissed\n            extra_args: extra request params passed back in GET and POST\n            save_method: how the data should be saved to the server (put|upload)\n            delete_url: optional URL for delete operation\n            delete_message: string. Optional custom delete confirmation message\n            delete_method: optional HTTP method for delete operation\n            auto_return: whether to return to the exit_url on successful save\n            read_only: optional flag; if set, removes Save and Delete operations\n            required_modules: list of inputex modules required for this editor\n            extra_css_files: list of extra CSS files to be included\n            extra_js_files: list of extra JS files to be included\n            additional_dirs: list of extra directories to look for\n                Jinja template files, e.g., JS or CSS files included by modules.\n            delete_button_caption: string. A caption for the 'Delete' button\n            save_button_caption: a caption for the 'Save' button\n            exit_button_caption: a caption for the 'Close' button\n\n        Returns:\n            The HTML, JS and CSS text that will instantiate an object editor.\n        \"\"\"\n        required_modules = required_modules or ALL_MODULES\n\n        if not delete_message:\n            kind = transforms.loads(schema_json).get('description')\n            if not kind:\n                kind = 'Generic Object'\n            delete_message = 'Are you sure you want to delete this %s?' % kind\n\n        # construct parameters\n        get_url = rest_url\n        get_args = {'key': object_key}\n        post_url = rest_url\n        post_args = {'key': object_key}\n\n        if extra_args:\n            get_args.update(extra_args)\n            post_args.update(extra_args)\n\n        if read_only:\n            post_url = ''\n            post_args = ''\n\n        custom_rte_tag_icons = []\n        for tag, tag_class in tags.get_tag_bindings().items():\n            custom_rte_tag_icons.append({\n                'name': tag,\n                'iconUrl': tag_class().get_icon_url()})\n\n        extra_script_tag_urls = []\n        for callback in cls.EXTRA_SCRIPT_TAG_URLS:\n            for url in callback():\n                extra_script_tag_urls.append(url)\n\n        template_values = {\n            'enabled': custom_module.enabled,\n            'schema': schema_json,\n            'get_url': '%s?%s' % (get_url, urllib.urlencode(get_args, True)),\n            'save_url': post_url,\n            'save_args': transforms.dumps(post_args),\n            'exit_button_caption': exit_button_caption,\n            'exit_url': exit_url,\n            'required_modules': COMMON_REQUIRED_MODULES + required_modules,\n            'extra_css_files': extra_css_files or [],\n            'extra_js_files': extra_js_files or [],\n            'schema_annotations': [\n                (item[0], transforms.dumps(item[1])) for item in annotations],\n            'save_method': save_method,\n            'auto_return': auto_return,\n            'delete_button_caption': delete_button_caption,\n            'save_button_caption': save_button_caption,\n            'custom_rte_tag_icons': transforms.dumps(custom_rte_tag_icons),\n            'delete_message': delete_message,\n            'can_highlight_code': CAN_HIGHLIGHT_CODE.value,\n            'extra_script_tag_urls': extra_script_tag_urls,\n        }\n\n        if delete_url and not read_only:\n            template_values['delete_url'] = delete_url\n        if delete_method:\n            template_values['delete_method'] = delete_method\n        if appengine_config.BUNDLE_LIB_FILES:\n            template_values['bundle_lib_files'] = True\n\n        return jinja2.utils.Markup(handler.get_template('oeditor.html', (\n            [os.path.dirname(__file__)] + (additional_dirs or [])\n        )).render(template_values))\n\n\nclass PopupHandler(webapp2.RequestHandler, utils.ReflectiveRequestHandler):\n    \"\"\"A handler to serve the content of the popup subeditor.\"\"\"\n\n    default_action = 'custom_tag'\n    get_actions = ['edit_custom_tag', 'add_custom_tag']\n    post_actions = []\n\n    def get_template(self, template_name, dirs):\n        \"\"\"Sets up an environment and Gets jinja template.\"\"\"\n        return jinja_utils.get_template(\n            template_name, dirs + [os.path.dirname(__file__)])\n\n    def _validate_schema(self, tag, schema):\n        if schema.has_subregistries():\n            return tag.unavailable_schema(\n                'This tag has an invalid schema and cannot be edited. '\n                'Only simple field types are allowed.')\n\n        text_field_count = 0\n        index = schema_fields.FieldRegistryIndex(schema)\n        index.rebuild()\n        for name in index.names_in_order:\n            if index.find(name).type == 'text':\n                text_field_count += 1\n        if text_field_count > 1:\n            return tag.unavailable_schema(\n                'This tag has an invalid schema and cannot be edited. '\n                'Only one field of type \"text\" is allowed.')\n\n        return schema\n\n    def get_edit_custom_tag(self):\n        \"\"\"Return the the page used to edit a custom HTML tag in a popup.\"\"\"\n        tag_name = self.request.get('tag_name')\n        tag_bindings = tags.get_tag_bindings()\n        tag_class = tag_bindings[tag_name]\n        tag = tag_class()\n        schema = tag.get_schema(self)\n        schema = self._validate_schema(tag, schema)\n\n        template_values = {}\n        template_values['form_html'] = ObjectEditor.get_html_for(\n            self, schema.get_json_schema(), schema.get_schema_dict(), None,\n            None, None,\n            required_modules=tag_class.required_modules(),\n            extra_js_files=tag_class.extra_js_files(),\n            extra_css_files=tag_class.extra_css_files(),\n            additional_dirs=tag_class.additional_dirs())\n        self.response.out.write(\n            self.get_template('popup.html', []).render(template_values))\n\n    def get_add_custom_tag(self):\n        \"\"\"Return the page for the popup used to add a custom HTML tag.\"\"\"\n        tag_name = self.request.get('tag_name')\n        excluded_tags = self.request.get_all('excluded_tags')\n\n        tag_bindings = tags.get_tag_bindings()\n\n        select_data = []\n        for name in tag_bindings.keys():\n            if name not in excluded_tags:\n                clazz = tag_bindings[name]\n                select_data.append((name, '%s: %s' % (\n                    clazz.vendor(), clazz.name())))\n        select_data = sorted(select_data, key=lambda pair: pair[1])\n\n        if tag_name:\n            tag_class = tag_bindings[tag_name]\n        else:\n            tag_class = tag_bindings[select_data[0][0]]\n        tag = tag_class()\n        tag_schema = tag.get_schema(self)\n        tag_schema = self._validate_schema(tag, tag_schema)\n\n        schema = schema_fields.FieldRegistry('Add a Component')\n        type_select = schema.add_sub_registry('type', 'Component Type')\n        type_select.add_property(schema_fields.SchemaField(\n            'tag', 'Name', 'string', select_data=select_data))\n        schema.add_sub_registry('attributes', registry=tag_schema)\n\n        template_values = {}\n        template_values['form_html'] = ObjectEditor.get_html_for(\n            self, schema.get_json_schema(), schema.get_schema_dict(), None,\n            None, None,\n            required_modules=tag_class.required_modules(),\n            extra_js_files=['add_custom_tag.js'] + tag_class.extra_js_files(),\n            extra_css_files=tag_class.extra_css_files(),\n            additional_dirs=tag_class.additional_dirs())\n        self.response.out.write(\n            self.get_template('popup.html', []).render(template_values))\n\n\ndef create_bool_select_annotation(\n    keys_list, label, true_label, false_label, class_name=None,\n    description=None):\n    \"\"\"Creates inputex annotation to display bool type as a select.\"\"\"\n    properties = {\n        'label': label, 'choices': [\n            {'value': True, 'label': true_label},\n            {'value': False, 'label': false_label}]}\n    if class_name:\n        properties['className'] = class_name\n    if description:\n        properties['description'] = description\n    return (keys_list, {'type': 'select', '_inputex': properties})\n\n\ncustom_module = None\n\n\ndef register_module():\n    \"\"\"Registers this module in the registry.\"\"\"\n\n    from controllers import sites\n\n    yui_handlers = [\n        ('/static/inputex-3.1.0/(.*)', sites.make_zip_handler(\n            os.path.join(\n                appengine_config.BUNDLE_ROOT, 'lib/inputex-3.1.0.zip'))),\n        ('/static/yui_3.6.0/(.*)', sites.make_zip_handler(\n            os.path.join(\n                appengine_config.BUNDLE_ROOT, 'lib/yui_3.6.0.zip'))),\n        ('/static/2in3/(.*)', sites.make_zip_handler(\n            os.path.join(\n                appengine_config.BUNDLE_ROOT, 'lib/yui_2in3-2.9.0.zip')))]\n\n    codemirror_handler = [\n        ('/static/codemirror/(.*)', sites.make_zip_handler(\n            os.path.join(\n                appengine_config.BUNDLE_ROOT, 'lib/codemirror-4.5.0.zip')))]\n\n    if appengine_config.BUNDLE_LIB_FILES:\n        yui_handlers += [\n            ('/static/combo/inputex', sites.make_css_combo_zip_handler(\n                os.path.join(\n                    appengine_config.BUNDLE_ROOT, 'lib/inputex-3.1.0.zip'),\n                '/static/inputex-3.1.0/')),\n            ('/static/combo/yui', sites.make_css_combo_zip_handler(\n                os.path.join(appengine_config.BUNDLE_ROOT, 'lib/yui_3.6.0.zip'),\n                '/yui/')),\n            ('/static/combo/2in3', sites.make_css_combo_zip_handler(\n                os.path.join(\n                    appengine_config.BUNDLE_ROOT, 'lib/yui_2in3-2.9.0.zip'),\n                '/static/2in3/'))]\n\n    oeditor_handlers = [('/oeditorpopup', PopupHandler)]\n    global_routes = yui_handlers + codemirror_handler + [\n        (os.path.join(RESOURCES_PATH, '.*'), tags.ResourcesHandler)]\n\n    global custom_module  # pylint: disable=global-statement\n    custom_module = custom_modules.Module(\n        'Object Editor',\n        'A visual editor for editing various types of objects.',\n        global_routes, oeditor_handlers)\n    return custom_module\n", "# Copyright 2014 Google Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests that walk through Course Builder pages.\"\"\"\n\n__author__ = 'Mike Gainer (mgainer@google.com)'\n\nimport cgi\nimport re\nimport urllib\n\nfrom common import crypto\nfrom common import utils as common_utils\nfrom controllers import sites\nfrom controllers import utils\nfrom models import courses\nfrom models import models\nfrom models import transforms\nfrom modules.dashboard import course_settings\nfrom modules.dashboard import filer\nfrom modules.i18n_dashboard import i18n_dashboard\nfrom tests.functional import actions\nfrom tests.functional.actions import assert_contains\nfrom tests.functional.actions import assert_does_not_contain\n\nCOURSE_NAME = 'admin_settings'\nCOURSE_TITLE = 'Admin Settings'\nADMIN_EMAIL = 'admin@foo.com'\nNAMESPACE = 'ns_%s' % COURSE_NAME\nBASE_URL = '/' + COURSE_NAME\nADMIN_SETTINGS_URL = '/%s%s' % (\n    COURSE_NAME, course_settings.HtmlHookRESTHandler.URI)\nTEXT_ASSET_URL = '/%s%s' % (\n    COURSE_NAME, filer.TextAssetRESTHandler.URI)\nSTUDENT_EMAIL = 'student@foo.com'\nSETTINGS_URL = '/%s/dashboard?action=settings&tab=admin_prefs' % COURSE_NAME\n\n\nclass AdminSettingsTests(actions.TestBase):\n\n    def setUp(self):\n        super(AdminSettingsTests, self).setUp()\n        actions.simple_add_course(COURSE_NAME, ADMIN_EMAIL, COURSE_TITLE)\n        actions.login(ADMIN_EMAIL)\n\n    def test_defaults(self):\n        prefs = models.StudentPreferencesDAO.load_or_create()\n        self.assertEquals(False, prefs.show_hooks)\n\n\nclass WelcomePageTests(actions.TestBase):\n\n    def setUp(self):\n        super(WelcomePageTests, self).setUp()\n        self.auto_deploy = sites.ApplicationContext.AUTO_DEPLOY_DEFAULT_COURSE\n        sites.ApplicationContext.AUTO_DEPLOY_DEFAULT_COURSE = False\n\n    def tearDown(self):\n        sites.ApplicationContext.AUTO_DEPLOY_DEFAULT_COURSE = self.auto_deploy\n        super(WelcomePageTests, self).tearDown()\n\n    def test_welcome_page(self):\n        actions.login(ADMIN_EMAIL, is_admin=True)\n        response = self.get('/')\n        self.assertEqual(response.status_int, 302)\n        self.assertEqual(\n            response.headers['location'],\n            'http://localhost/admin/welcome')\n        response = self.get('/admin/welcome?action=welcome')\n        assert_contains('Welcome to Course Builder', response.body)\n        assert_contains('/admin/welcome?action=add_first_course', response.body)\n        assert_contains('/admin/welcome?action=explore_sample', response.body)\n\n    def test_explore_sample_course(self):\n        actions.login(ADMIN_EMAIL, is_admin=True)\n        response = self.post(\n            '/admin/welcome?action=explore_sample',\n            params={'xsrf_token': crypto.XsrfTokenManager.create_xsrf_token(\n                'explore_sample')})\n        self.assertEqual(response.status_int, 302)\n        self.assertEqual(\n            response.headers['location'],\n            'http://localhost/sample/dashboard')\n        response = self.get('/sample/dashboard')\n        assert_contains('Power Searching with Google', response.body)\n        assert_does_not_contain('explore_sample', response.body)\n\n    def test_create_new_course(self):\n        actions.login(ADMIN_EMAIL, is_admin=True)\n        response = self.post(\n            '/admin/welcome?action=add_first_course',\n            params={'xsrf_token': crypto.XsrfTokenManager.create_xsrf_token(\n                'add_first_course')})\n        self.assertEqual(response.status_int, 302)\n        self.assertEqual(\n            response.headers['location'],\n            'http://localhost/first/dashboard')\n        response = self.get('/first/dashboard')\n        assert_contains('My First Course', response.body)\n        response = self.get('/admin/welcome?action=welcome')\n        assert_does_not_contain('add_first_course', response.body)\n\n    def test_explore_sample_course_idempotent(self):\n        self.test_explore_sample_course()\n        self.test_explore_sample_course()\n\n        self.test_create_new_course()\n        response = self.get('/')\n        self.assertEqual(response.status_int, 302)\n        self.assertEqual(\n            response.headers['location'],\n            'http://localhost/sample/course?use_last_location=true')\n\n    def test_create_new_course_idempotent(self):\n        self.test_create_new_course()\n        self.test_create_new_course()\n\n        self.test_explore_sample_course()\n        response = self.get('/')\n        self.assertEqual(response.status_int, 302)\n        self.assertEqual(\n            response.headers['location'],\n            'http://localhost/first/course?use_last_location=true')\n\n\nclass HtmlHookTest(actions.TestBase):\n\n    def setUp(self):\n        super(HtmlHookTest, self).setUp()\n\n        self.app_context = actions.simple_add_course(COURSE_NAME, ADMIN_EMAIL,\n                                            COURSE_TITLE)\n        self.course = courses.Course(None, self.app_context)\n        actions.login(ADMIN_EMAIL, is_admin=True)\n        self.xsrf_token = crypto.XsrfTokenManager.create_xsrf_token(\n            course_settings.HtmlHookRESTHandler.XSRF_ACTION)\n\n    def tearDown(self):\n        settings = self.course.get_environ(self.app_context)\n        settings.pop('foo', None)\n        settings['html_hooks'].pop('foo', None)\n        self.course.save_settings(settings)\n        super(HtmlHookTest, self).tearDown()\n\n    def test_hook_edit_button_presence(self):\n\n        # Turn preference on; expect to see hook editor button\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.show_hooks = True\n            models.StudentPreferencesDAO.save(prefs)\n        response = self.get(BASE_URL)\n        self.assertIn('gcb-html-hook-edit', response.body)\n\n        # Turn preference off; expect editor button not present.\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.show_hooks = False\n            models.StudentPreferencesDAO.save(prefs)\n\n        response = self.get(BASE_URL)\n        self.assertNotIn('gcb-html-hook-edit', response.body)\n\n    def test_non_admin_permissions_failures(self):\n        actions.login(STUDENT_EMAIL)\n        student_xsrf_token = crypto.XsrfTokenManager.create_xsrf_token(\n            course_settings.HtmlHookRESTHandler.XSRF_ACTION)\n\n        response = self.get(ADMIN_SETTINGS_URL)\n        self.assertEquals(200, response.status_int)\n        payload = transforms.loads(response.body)\n        self.assertEquals(401, payload['status'])\n        self.assertEquals('Access denied.', payload['message'])\n\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'key': 'base:after_body_tag_begins',\n                'xsrf_token': cgi.escape(student_xsrf_token),\n                'payload': '{}'})})\n        payload = transforms.loads(response.body)\n        self.assertEquals(401, payload['status'])\n        self.assertEquals('Access denied.', payload['message'])\n\n        response = self.delete(ADMIN_SETTINGS_URL + '?xsrf_token=' +\n                               cgi.escape(student_xsrf_token))\n        self.assertEquals(200, response.status_int)\n        payload = transforms.loads(response.body)\n        self.assertEquals(401, payload['status'])\n        self.assertEquals('Access denied.', payload['message'])\n\n    def test_malformed_requests(self):\n        response = self.put(ADMIN_SETTINGS_URL, {})\n        payload = transforms.loads(response.body)\n        self.assertEquals(400, payload['status'])\n        self.assertEquals('Missing \"request\" parameter.', payload['message'])\n\n        response = self.put(ADMIN_SETTINGS_URL, {'request': 'asdfasdf'})\n        payload = transforms.loads(response.body)\n        self.assertEquals(400, payload['status'])\n        self.assertEquals('Malformed \"request\" parameter.', payload['message'])\n\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token)})})\n        payload = transforms.loads(response.body)\n        self.assertEquals(400, payload['status'])\n        self.assertEquals('Request missing \"key\" parameter.',\n                          payload['message'])\n\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token),\n                'key': 'base:after_body_tag_begins'})})\n        payload = transforms.loads(response.body)\n        self.assertEquals(400, payload['status'])\n        self.assertEquals('Request missing \"payload\" parameter.',\n                          payload['message'])\n\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token),\n                'key': 'base:after_body_tag_begins',\n                'payload': 'asdfsdfasdf'})})\n        payload = transforms.loads(response.body)\n        self.assertEquals(400, payload['status'])\n        self.assertEquals('Malformed \"payload\" parameter.',\n                          payload['message'])\n\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token),\n                'key': 'base:after_body_tag_begins',\n                'payload': '{}'})})\n        payload = transforms.loads(response.body)\n        self.assertEquals(400, payload['status'])\n        self.assertEquals('Payload missing \"hook_content\" parameter.',\n                          payload['message'])\n\n    def test_get_unknown_hook_content(self):\n        # Should be safe (but unhelpful) to ask for no hook.\n        response = transforms.loads(self.get(ADMIN_SETTINGS_URL).body)\n        payload = transforms.loads(response['payload'])\n        self.assertIsNone(payload['hook_content'])\n\n    def test_get_defaulted_hook_content(self):\n        url = '%s?key=%s' % (\n            ADMIN_SETTINGS_URL, cgi.escape('base.after_body_tag_begins'))\n        response = transforms.loads(self.get(url).body)\n        self.assertEquals(200, response['status'])\n        self.assertEquals('Success.', response['message'])\n        payload = transforms.loads(response['payload'])\n        self.assertEquals('<!-- base.after_body_tag_begins -->',\n                          payload['hook_content'])\n\n    def test_page_has_defaulted_hook_content(self):\n        response = self.get(BASE_URL)\n        self.assertIn('<!-- base.after_body_tag_begins -->', response.body)\n\n    def test_set_hook_content(self):\n        html_text = '<table><tbody><tr><th>;&lt;&gt;</th></tr></tbody></table>'\n\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token),\n                'key': 'base.after_body_tag_begins',\n                'payload': transforms.dumps(\n                    {'hook_content': html_text})})})\n        self.assertEquals(200, response.status_int)\n        response = transforms.loads(response.body)\n        self.assertEquals(200, response['status'])\n        self.assertEquals('Saved.', response['message'])\n\n        # And verify that the changed text appears on course pages.\n        # NOTE that text is as-is; no escaping of special HTML\n        # characters should have been done.\n        response = self.get(BASE_URL)\n        self.assertIn(html_text, response.body)\n\n    def test_delete_default_content_ineffective(self):\n        response = self.get(BASE_URL)\n        self.assertIn('<!-- base.after_body_tag_begins -->', response.body)\n\n        url = '%s?key=%s&xsrf_token=%s' % (\n            ADMIN_SETTINGS_URL, cgi.escape('base.after_body_tag_begins'),\n            cgi.escape(self.xsrf_token))\n        response = transforms.loads(self.delete(url).body)\n        self.assertEquals(200, response['status'])\n        self.assertEquals('Deleted.', response['message'])\n\n        response = self.get(BASE_URL)\n        self.assertIn('<!-- base.after_body_tag_begins -->', response.body)\n\n    def test_manipulate_non_default_item(self):\n        html_text = '<table><tbody><tr><th>;&lt;&gt;</th></tr></tbody></table>'\n        new_hook_name = 'html.some_new_hook'\n\n        # Verify that content prior to setting is blank.\n        url = '%s?key=%s&xsrf_token=%s' % (\n            ADMIN_SETTINGS_URL, cgi.escape(new_hook_name),\n            cgi.escape(self.xsrf_token))\n        response = transforms.loads(self.get(url).body)\n        payload = transforms.loads(response['payload'])\n        self.assertIsNone(payload['hook_content'])\n\n        # Set the content.\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token),\n                'key': new_hook_name,\n                'payload': transforms.dumps(\n                    {'hook_content': html_text})})})\n        self.assertEquals(200, response.status_int)\n        response = transforms.loads(response.body)\n        self.assertEquals(200, response['status'])\n        self.assertEquals('Saved.', response['message'])\n\n        # Verify that content after setting is as expected\n        url = '%s?key=%s&xsrf_token=%s' % (\n            ADMIN_SETTINGS_URL, cgi.escape(new_hook_name),\n            cgi.escape(self.xsrf_token))\n        response = transforms.loads(self.get(url).body)\n        payload = transforms.loads(response['payload'])\n        self.assertEquals(html_text, payload['hook_content'])\n\n        # Delete the content.\n        response = transforms.loads(self.delete(url).body)\n        self.assertEquals(200, response['status'])\n        self.assertEquals('Deleted.', response['message'])\n\n        # Verify that content after setting is None.\n        url = '%s?key=%s&xsrf_token=%s' % (\n            ADMIN_SETTINGS_URL, cgi.escape(new_hook_name),\n            cgi.escape(self.xsrf_token))\n        response = transforms.loads(self.get(url).body)\n        payload = transforms.loads(response['payload'])\n        self.assertIsNone(payload['hook_content'])\n\n    def test_add_new_hook_to_page(self):\n        hook_name = 'html.my_new_hook'\n        html_text = '<table><tbody><tr><th>;&lt;&gt;</th></tr></tbody></table>'\n        key = 'views/base.html'\n        url = '%s?key=%s' % (\n            TEXT_ASSET_URL, cgi.escape(key))\n\n        # Get base page template.\n        response = transforms.loads(self.get(url).body)\n        xsrf_token = response['xsrf_token']\n        payload = transforms.loads(response['payload'])\n        contents = payload['contents']\n\n        # Add hook specification to page content.\n        contents = contents.replace(\n            '<body data-gcb-page-locale=\"{{ page_locale }}\">',\n            '<body data-gcb-page-locale=\"{{ page_locale }}\">\\n' +\n            '{{ html_hooks.insert(\\'%s\\') | safe }}' % hook_name)\n        self.put(TEXT_ASSET_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(xsrf_token),\n                'key': key,\n                'payload': transforms.dumps({'contents': contents})})})\n\n        # Verify that new hook appears on page.\n        response = self.get(BASE_URL)\n        self.assertIn('id=\"%s\"' % re.sub('[^a-zA-Z-]', '-', hook_name),\n                      response.body)\n\n        # Verify that modified hook content appears on page\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token),\n                'key': hook_name,\n                'payload': transforms.dumps(\n                    {'hook_content': html_text})})})\n\n        response = self.get(BASE_URL)\n        self.assertIn(html_text, response.body)\n\n    def test_student_admin_hook_visibility(self):\n        actions.login(STUDENT_EMAIL, is_admin=False)\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.show_hooks = True\n            models.StudentPreferencesDAO.save(prefs)\n\n        response = self.get(BASE_URL)\n        self.assertNotIn('gcb-html-hook-edit', response.body)\n\n        actions.login(ADMIN_EMAIL, is_admin=True)\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.show_hooks = True\n            models.StudentPreferencesDAO.save(prefs)\n        response = self.get(BASE_URL)\n        self.assertIn('gcb-html-hook-edit', response.body)\n\n    def test_hook_i18n(self):\n        actions.update_course_config(\n            COURSE_NAME,\n            {\n                'html_hooks': {'base': {'after_body_tag_begins': 'foozle'}},\n                'extra_locales': [\n                    {'locale': 'de', 'availability': 'available'},\n                ]\n            })\n\n        hook_bundle = {\n            'content': {\n                'type': 'html',\n                'source_value': '',\n                'data': [{\n                    'source_value': 'foozle',\n                    'target_value': 'FUZEL',\n                }],\n            }\n        }\n        hook_key = i18n_dashboard.ResourceBundleKey(\n            utils.ResourceHtmlHook.TYPE, 'base.after_body_tag_begins', 'de')\n        with common_utils.Namespace(NAMESPACE):\n            i18n_dashboard.ResourceBundleDAO.save(\n                i18n_dashboard.ResourceBundleDTO(str(hook_key), hook_bundle))\n\n        # Verify non-translated version.\n        response = self.get(BASE_URL)\n        dom = self.parse_html_string(response.body)\n        html_hook = dom.find('.//div[@id=\"base-after-body-tag-begins\"]')\n        self.assertEquals('foozle', html_hook.text)\n\n        # Set preference to translated language, and check that that's there.\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.locale = 'de'\n            models.StudentPreferencesDAO.save(prefs)\n\n        response = self.get(BASE_URL)\n        dom = self.parse_html_string(response.body)\n        html_hook = dom.find('.//div[@id=\"base-after-body-tag-begins\"]')\n        self.assertEquals('FUZEL', html_hook.text)\n\n        # With no translation present, but preference set to foreign language,\n        # verify that we fall back to the original language.\n\n        # Remove translation bundle, and clear cache.\n        with common_utils.Namespace(NAMESPACE):\n            i18n_dashboard.ResourceBundleDAO.delete(\n                i18n_dashboard.ResourceBundleDTO(str(hook_key), hook_bundle))\n        i18n_dashboard.ProcessScopedResourceBundleCache.instance().clear()\n\n        response = self.get(BASE_URL)\n        dom = self.parse_html_string(response.body)\n        html_hook = dom.find('.//div[@id=\"base-after-body-tag-begins\"]')\n        self.assertEquals('foozle', html_hook.text)\n\n    def test_hook_content_found_in_old_location(self):\n        actions.update_course_config(COURSE_NAME, {'foo': {'bar': 'baz'}})\n        self.assertEquals(\n            'baz', utils.HtmlHooks.get_content(self.course, 'foo.bar'))\n\n    def test_insert_on_page_and_hook_content_found_using_old_separator(self):\n        settings = self.course.get_environ(self.app_context)\n        settings['html_hooks']['foo'] = {'bar': 'baz'}\n        self.course.save_settings(settings)\n        hooks = utils.HtmlHooks(self.course)\n        content = hooks.insert('foo:bar')\n        self.assertEquals('<div class=\"gcb-html-hook\" id=\"foo-bar\">baz</div>',\n                          str(content))\n\n    def test_hook_content_new_location_overrides_old_location(self):\n        actions.update_course_config(COURSE_NAME,\n                                     {'html_hooks': {'foo': {'bar': 'zab'}}})\n        actions.update_course_config(COURSE_NAME,\n                                     {'foo': {'bar': 'baz'}})\n        self.assertEquals(\n            'zab', utils.HtmlHooks.get_content(self.course, 'foo.bar'))\n\n    def test_hook_rest_edit_removes_from_old_location(self):\n        actions.update_course_config(COURSE_NAME,\n                                     {'html_hooks': {'foo': {'bar': 'zab'}}})\n        actions.update_course_config(COURSE_NAME,\n                                     {'foo': {'bar': 'baz'}})\n        response = self.put(ADMIN_SETTINGS_URL, {'request': transforms.dumps({\n                'xsrf_token': cgi.escape(self.xsrf_token),\n                'key': 'foo.bar',\n                'payload': transforms.dumps({'hook_content': 'BAZ'})})})\n        env = self.course.get_environ(self.app_context)\n        self.assertNotIn('bar', env['foo'])\n        self.assertEquals('BAZ', env['html_hooks']['foo']['bar'])\n\n\n    def test_hook_rest_delete_removes_from_old_and_new_location(self):\n        actions.update_course_config(COURSE_NAME,\n                                     {'html_hooks': {'foo': {'bar': 'zab'}}})\n        actions.update_course_config(COURSE_NAME,\n                                     {'foo': {'bar': 'baz'}})\n        url = '%s?key=%s&xsrf_token=%s' % (\n            ADMIN_SETTINGS_URL, cgi.escape('foo.bar'),\n            cgi.escape(self.xsrf_token))\n        self.delete(url)\n\n        env = self.course.get_environ(self.app_context)\n        self.assertNotIn('bar', env['foo'])\n        self.assertNotIn('bar', env['html_hooks']['foo'])\n\n\nclass JinjaContextTest(actions.TestBase):\n\n    def setUp(self):\n        super(JinjaContextTest, self).setUp()\n        actions.simple_add_course(COURSE_NAME, ADMIN_EMAIL, COURSE_TITLE)\n        actions.login(ADMIN_EMAIL, is_admin=True)\n\n    def _get_jinja_context_text(self, response):\n        root = self.parse_html_string(response.text)\n        div = root.find('body/div[last()]')\n        return ''.join(div.itertext())\n\n    def test_show_jina_context_presence(self):\n\n        # Turn preference on; expect to see context dump.\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.show_jinja_context = True\n            models.StudentPreferencesDAO.save(prefs)\n        self.assertIn('is_read_write_course:',\n                      self._get_jinja_context_text(self.get(BASE_URL)))\n\n        # Turn preference off; expect context dump not present.\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.show_jinja_context = False\n            models.StudentPreferencesDAO.save(prefs)\n        self.assertNotIn('is_read_write_course:',\n                         self._get_jinja_context_text(self.get(BASE_URL)))\n\n    def test_student_jinja_context_visibility(self):\n\n        actions.login(STUDENT_EMAIL, is_admin=False)\n        with common_utils.Namespace(NAMESPACE):\n            prefs = models.StudentPreferencesDAO.load_or_create()\n            prefs.show_jinja_context = True\n            models.StudentPreferencesDAO.save(prefs)\n        self.assertNotIn('is_read_write_course:',\n                         self._get_jinja_context_text(self.get(BASE_URL)))\n\n\nclass ExitUrlTest(actions.TestBase):\n\n    def setUp(self):\n        super(ExitUrlTest, self).setUp()\n        actions.simple_add_course(COURSE_NAME, ADMIN_EMAIL, COURSE_TITLE)\n        actions.login(ADMIN_EMAIL, is_admin=True)\n\n    def test_exit_url(self):\n        base_url = '/%s/dashboard?action=settings&tab=data_pump' % COURSE_NAME\n        url = base_url + '&' + urllib.urlencode({\n            'exit_url': 'dashboard?%s' % urllib.urlencode({\n                'action': 'analytics',\n                'tab': 'data_pump'})})\n        response = self.get(url)\n        self.assertIn(\n            'cb_global.exit_url = \\'dashboard?action=analytics'\n            '\\\\u0026tab=data_pump\\'',\n            response.body)\n"], "buggy_code_start_loc": [73, 150, 562], "buggy_code_end_loc": [99, 151, 563], "fixing_code_start_loc": [73, 150, 562], "fixing_code_end_loc": [99, 151, 564], "type": "CWE-79", "message": "A vulnerability was found in Overdrive Eletr\u00f4nica course-builder up to 1.7.x and classified as problematic. Affected by this issue is some unknown functionality of the file coursebuilder/modules/oeditor/oeditor.html. The manipulation leads to cross site scripting. The attack may be launched remotely. Upgrading to version 1.8.0 is able to address this issue. The name of the patch is e39645fd714adb7e549908780235911ae282b21b. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-218372.", "other": {"cve": {"id": "CVE-2015-10049", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-15T18:15:08.937", "lastModified": "2023-01-24T18:28:03.270", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Overdrive Eletr\u00f4nica course-builder up to 1.7.x and classified as problematic. Affected by this issue is some unknown functionality of the file coursebuilder/modules/oeditor/oeditor.html. The manipulation leads to cross site scripting. The attack may be launched remotely. Upgrading to version 1.8.0 is able to address this issue. The name of the patch is e39645fd714adb7e549908780235911ae282b21b. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-218372."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:course-builder_project:course-builder:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.0", "matchCriteriaId": "F1E0F36D-1997-448E-8246-EB57A1135CDD"}]}]}], "references": [{"url": "https://github.com/overdrive-diy/course-builder/commit/e39645fd714adb7e549908780235911ae282b21b", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/overdrive-diy/course-builder/releases/tag/V1.8.0", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218372", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.218372", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/overdrive-diy/course-builder/commit/e39645fd714adb7e549908780235911ae282b21b"}}