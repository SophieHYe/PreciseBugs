{"buggy_code": ["/********************************************************************\n *                                                                  *\n * THIS FILE IS PART OF THE libopusfile SOFTWARE CODEC SOURCE CODE. *\n * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *\n * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *\n * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *\n *                                                                  *\n * THE libopusfile SOURCE CODE IS (C) COPYRIGHT 1994-2020           *\n * by the Xiph.Org Foundation and contributors https://xiph.org/    *\n *                                                                  *\n ********************************************************************\n\n function: stdio-based convenience library for opening/seeking/decoding\n last mod: $Id: vorbisfile.c 17573 2010-10-27 14:53:59Z xiphmont $\n\n ********************************************************************/\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"internal.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <math.h>\n\n#include \"opusfile.h\"\n\n/*This implementation is largely based off of libvorbisfile.\n  All of the Ogg bits work roughly the same, though I have made some\n   \"improvements\" that have not been folded back there, yet.*/\n\n/*A 'chained bitstream' is an Ogg Opus bitstream that contains more than one\n   logical bitstream arranged end to end (the only form of Ogg multiplexing\n   supported by this library.\n  Grouping (parallel multiplexing) is not supported, except to the extent that\n   if there are multiple logical Ogg streams in a single link of the chain, we\n   will ignore all but the first Opus stream we find.*/\n\n/*An Ogg Opus file can be played beginning to end (streamed) without worrying\n   ahead of time about chaining (see opusdec from the opus-tools package).\n  If we have the whole file, however, and want random access\n   (seeking/scrubbing) or desire to know the total length/time of a file, we\n   need to account for the possibility of chaining.*/\n\n/*We can handle things a number of ways.\n  We can determine the entire bitstream structure right off the bat, or find\n   pieces on demand.\n  This library determines and caches structure for the entire bitstream, but\n   builds a virtual decoder on the fly when moving between links in the chain.*/\n\n/*There are also different ways to implement seeking.\n  Enough information exists in an Ogg bitstream to seek to sample-granularity\n   positions in the output.\n  Or, one can seek by picking some portion of the stream roughly in the desired\n   area if we only want coarse navigation through the stream.\n  We implement and expose both strategies.*/\n\n/*The maximum number of bytes in a page (including the page headers).*/\n#define OP_PAGE_SIZE_MAX  (65307)\n/*The default amount to seek backwards per step when trying to find the\n   previous page.\n  This must be at least as large as the maximum size of a page.*/\n#define OP_CHUNK_SIZE     (65536)\n/*The maximum amount to seek backwards per step when trying to find the\n   previous page.*/\n#define OP_CHUNK_SIZE_MAX (1024*(opus_int32)1024)\n/*A smaller read size is needed for low-rate streaming.*/\n#define OP_READ_SIZE      (2048)\n\nint op_test(OpusHead *_head,\n const unsigned char *_initial_data,size_t _initial_bytes){\n  ogg_sync_state  oy;\n  char           *data;\n  int             err;\n  /*The first page of a normal Opus file will be at most 57 bytes (27 Ogg\n     page header bytes + 1 lacing value + 21 Opus header bytes + 8 channel\n     mapping bytes).\n    It will be at least 47 bytes (27 Ogg page header bytes + 1 lacing value +\n     19 Opus header bytes using channel mapping family 0).\n    If we don't have at least that much data, give up now.*/\n  if(_initial_bytes<47)return OP_FALSE;\n  /*Only proceed if we start with the magic OggS string.\n    This is to prevent us spending a lot of time allocating memory and looking\n     for Ogg pages in non-Ogg files.*/\n  if(memcmp(_initial_data,\"OggS\",4)!=0)return OP_ENOTFORMAT;\n  if(OP_UNLIKELY(_initial_bytes>(size_t)LONG_MAX))return OP_EFAULT;\n  ogg_sync_init(&oy);\n  data=ogg_sync_buffer(&oy,(long)_initial_bytes);\n  if(data!=NULL){\n    ogg_stream_state os;\n    ogg_page         og;\n    int              ret;\n    memcpy(data,_initial_data,_initial_bytes);\n    ogg_sync_wrote(&oy,(long)_initial_bytes);\n    ogg_stream_init(&os,-1);\n    err=OP_FALSE;\n    do{\n      ogg_packet op;\n      ret=ogg_sync_pageout(&oy,&og);\n      /*Ignore holes.*/\n      if(ret<0)continue;\n      /*Stop if we run out of data.*/\n      if(!ret)break;\n      ogg_stream_reset_serialno(&os,ogg_page_serialno(&og));\n      ogg_stream_pagein(&os,&og);\n      /*Only process the first packet on this page (if it's a BOS packet,\n         it's required to be the only one).*/\n      if(ogg_stream_packetout(&os,&op)==1){\n        if(op.b_o_s){\n          ret=opus_head_parse(_head,op.packet,op.bytes);\n          /*If this didn't look like Opus, keep going.*/\n          if(ret==OP_ENOTFORMAT)continue;\n          /*Otherwise we're done, one way or another.*/\n          err=ret;\n        }\n        /*We finished parsing the headers.\n          There is no Opus to be found.*/\n        else err=OP_ENOTFORMAT;\n      }\n    }\n    while(err==OP_FALSE);\n    ogg_stream_clear(&os);\n  }\n  else err=OP_EFAULT;\n  ogg_sync_clear(&oy);\n  return err;\n}\n\n/*Many, many internal helpers.\n  The intention is not to be confusing.\n  Rampant duplication and monolithic function implementation (though we do have\n   some large, omnibus functions still) would be harder to understand anyway.\n  The high level functions are last.\n  Begin grokking near the end of the file if you prefer to read things\n   top-down.*/\n\n/*The read/seek functions track absolute position within the stream.*/\n\n/*Read a little more data from the file/pipe into the ogg_sync framer.\n  _nbytes: The maximum number of bytes to read.\n  Return: A positive number of bytes read on success, 0 on end-of-file, or a\n           negative value on failure.*/\nstatic int op_get_data(OggOpusFile *_of,int _nbytes){\n  unsigned char *buffer;\n  int            nbytes;\n  OP_ASSERT(_nbytes>0);\n  buffer=(unsigned char *)ogg_sync_buffer(&_of->oy,_nbytes);\n  nbytes=(int)(*_of->callbacks.read)(_of->stream,buffer,_nbytes);\n  OP_ASSERT(nbytes<=_nbytes);\n  if(OP_LIKELY(nbytes>0))ogg_sync_wrote(&_of->oy,nbytes);\n  return nbytes;\n}\n\n/*Save a tiny smidge of verbosity to make the code more readable.*/\nstatic int op_seek_helper(OggOpusFile *_of,opus_int64 _offset){\n  if(_offset==_of->offset)return 0;\n  if(_of->callbacks.seek==NULL\n   ||(*_of->callbacks.seek)(_of->stream,_offset,SEEK_SET)){\n    return OP_EREAD;\n  }\n  _of->offset=_offset;\n  ogg_sync_reset(&_of->oy);\n  return 0;\n}\n\n/*Get the current position indicator of the underlying stream.\n  This should be the same as the value reported by tell().*/\nstatic opus_int64 op_position(const OggOpusFile *_of){\n  /*The current position indicator is _not_ simply offset.\n    We may also have unprocessed, buffered data in the sync state.*/\n  return _of->offset+_of->oy.fill-_of->oy.returned;\n}\n\n/*From the head of the stream, get the next page.\n  _boundary specifies if the function is allowed to fetch more data from the\n   stream (and how much) or only use internally buffered data.\n  _boundary: -1: Unbounded search.\n              0: Read no additional data.\n                 Use only cached data.\n              n: Search for the start of a new page up to file position n.\n  Return: n>=0:       Found a page at absolute offset n.\n          OP_FALSE:   Hit the _boundary limit.\n          OP_EREAD:   An underlying read operation failed.\n          OP_BADLINK: We hit end-of-file before reaching _boundary.*/\nstatic opus_int64 op_get_next_page(OggOpusFile *_of,ogg_page *_og,\n opus_int64 _boundary){\n  while(_boundary<=0||_of->offset<_boundary){\n    int more;\n    more=ogg_sync_pageseek(&_of->oy,_og);\n    /*Skipped (-more) bytes.*/\n    if(OP_UNLIKELY(more<0))_of->offset-=more;\n    else if(more==0){\n      int read_nbytes;\n      int ret;\n      /*Send more paramedics.*/\n      if(!_boundary)return OP_FALSE;\n      if(_boundary<0)read_nbytes=OP_READ_SIZE;\n      else{\n        opus_int64 position;\n        position=op_position(_of);\n        if(position>=_boundary)return OP_FALSE;\n        read_nbytes=(int)OP_MIN(_boundary-position,OP_READ_SIZE);\n      }\n      ret=op_get_data(_of,read_nbytes);\n      if(OP_UNLIKELY(ret<0))return OP_EREAD;\n      if(OP_UNLIKELY(ret==0)){\n        /*Only fail cleanly on EOF if we didn't have a known boundary.\n          Otherwise, we should have been able to reach that boundary, and this\n           is a fatal error.*/\n        return OP_UNLIKELY(_boundary<0)?OP_FALSE:OP_EBADLINK;\n      }\n    }\n    else{\n      /*Got a page.\n        Return the page start offset and advance the internal offset past the\n         page end.*/\n      opus_int64 page_offset;\n      page_offset=_of->offset;\n      _of->offset+=more;\n      OP_ASSERT(page_offset>=0);\n      return page_offset;\n    }\n  }\n  return OP_FALSE;\n}\n\nstatic int op_add_serialno(const ogg_page *_og,\n ogg_uint32_t **_serialnos,int *_nserialnos,int *_cserialnos){\n  ogg_uint32_t *serialnos;\n  int           nserialnos;\n  int           cserialnos;\n  ogg_uint32_t s;\n  s=ogg_page_serialno(_og);\n  serialnos=*_serialnos;\n  nserialnos=*_nserialnos;\n  cserialnos=*_cserialnos;\n  if(OP_UNLIKELY(nserialnos>=cserialnos)){\n    if(OP_UNLIKELY(cserialnos>INT_MAX/(int)sizeof(*serialnos)-1>>1)){\n      return OP_EFAULT;\n    }\n    cserialnos=2*cserialnos+1;\n    OP_ASSERT(nserialnos<cserialnos);\n    serialnos=(ogg_uint32_t *)_ogg_realloc(serialnos,\n     sizeof(*serialnos)*cserialnos);\n    if(OP_UNLIKELY(serialnos==NULL))return OP_EFAULT;\n  }\n  serialnos[nserialnos++]=s;\n  *_serialnos=serialnos;\n  *_nserialnos=nserialnos;\n  *_cserialnos=cserialnos;\n  return 0;\n}\n\n/*Returns nonzero if found.*/\nstatic int op_lookup_serialno(ogg_uint32_t _s,\n const ogg_uint32_t *_serialnos,int _nserialnos){\n  int i;\n  for(i=0;i<_nserialnos&&_serialnos[i]!=_s;i++);\n  return i<_nserialnos;\n}\n\nstatic int op_lookup_page_serialno(const ogg_page *_og,\n const ogg_uint32_t *_serialnos,int _nserialnos){\n  return op_lookup_serialno(ogg_page_serialno(_og),_serialnos,_nserialnos);\n}\n\ntypedef struct OpusSeekRecord OpusSeekRecord;\n\n/*We use this to remember the pages we found while enumerating the links of a\n   chained stream.\n  We keep track of the starting and ending offsets, as well as the point we\n   started searching from, so we know where to bisect.\n  We also keep the serial number, so we can tell if the page belonged to the\n   current link or not, as well as the granule position, to aid in estimating\n   the start of the link.*/\nstruct OpusSeekRecord{\n  /*The earliest byte we know of such that reading forward from it causes\n     capture to be regained at this page.*/\n  opus_int64   search_start;\n  /*The offset of this page.*/\n  opus_int64   offset;\n  /*The size of this page.*/\n  opus_int32   size;\n  /*The serial number of this page.*/\n  ogg_uint32_t serialno;\n  /*The granule position of this page.*/\n  ogg_int64_t  gp;\n};\n\n/*Find the last page beginning before _offset with a valid granule position.\n  There is no '_boundary' parameter as it will always have to read more data.\n  This is much dirtier than the above, as Ogg doesn't have any backward search\n   linkage.\n  This search prefers pages of the specified serial number.\n  If a page of the specified serial number is spotted during the\n   seek-back-and-read-forward, it will return the info of last page of the\n   matching serial number, instead of the very last page, unless the very last\n   page belongs to a different link than preferred serial number.\n  If no page of the specified serial number is seen, it will return the info of\n   the last page.\n  [out] _sr:   Returns information about the page that was found on success.\n  _offset:     The _offset before which to find a page.\n               Any page returned will consist of data entirely before _offset.\n  _serialno:   The preferred serial number.\n               If a page with this serial number is found, it will be returned\n                even if another page in the same link is found closer to\n                _offset.\n               This is purely opportunistic: there is no guarantee such a page\n                will be found if it exists.\n  _serialnos:  The list of serial numbers in the link that contains the\n                preferred serial number.\n  _nserialnos: The number of serial numbers in the current link.\n  Return: 0 on success, or a negative value on failure.\n          OP_EREAD:    Failed to read more data (error or EOF).\n          OP_EBADLINK: We couldn't find a page even after seeking back to the\n                        start of the stream.*/\nstatic int op_get_prev_page_serial(OggOpusFile *_of,OpusSeekRecord *_sr,\n opus_int64 _offset,ogg_uint32_t _serialno,\n const ogg_uint32_t *_serialnos,int _nserialnos){\n  OpusSeekRecord preferred_sr;\n  ogg_page       og;\n  opus_int64     begin;\n  opus_int64     end;\n  opus_int64     original_end;\n  opus_int32     chunk_size;\n  int            preferred_found;\n  original_end=end=begin=_offset;\n  preferred_found=0;\n  _offset=-1;\n  chunk_size=OP_CHUNK_SIZE;\n  do{\n    opus_int64 search_start;\n    int        ret;\n    OP_ASSERT(chunk_size>=OP_PAGE_SIZE_MAX);\n    begin=OP_MAX(begin-chunk_size,0);\n    ret=op_seek_helper(_of,begin);\n    if(OP_UNLIKELY(ret<0))return ret;\n    search_start=begin;\n    while(_of->offset<end){\n      opus_int64   llret;\n      ogg_uint32_t serialno;\n      llret=op_get_next_page(_of,&og,end);\n      if(OP_UNLIKELY(llret<OP_FALSE))return (int)llret;\n      else if(llret==OP_FALSE)break;\n      serialno=ogg_page_serialno(&og);\n      /*Save the information for this page.\n        We're not interested in the page itself... just the serial number, byte\n         offset, page size, and granule position.*/\n      _sr->search_start=search_start;\n      _sr->offset=_offset=llret;\n      _sr->serialno=serialno;\n      OP_ASSERT(_of->offset-_offset>=0);\n      OP_ASSERT(_of->offset-_offset<=OP_PAGE_SIZE_MAX);\n      _sr->size=(opus_int32)(_of->offset-_offset);\n      _sr->gp=ogg_page_granulepos(&og);\n      /*If this page is from the stream we're looking for, remember it.*/\n      if(serialno==_serialno){\n        preferred_found=1;\n        *&preferred_sr=*_sr;\n      }\n      if(!op_lookup_serialno(serialno,_serialnos,_nserialnos)){\n        /*We fell off the end of the link, which means we seeked back too far\n           and shouldn't have been looking in that link to begin with.\n          If we found the preferred serial number, forget that we saw it.*/\n        preferred_found=0;\n      }\n      search_start=llret+1;\n    }\n    /*We started from the beginning of the stream and found nothing.\n      This should be impossible unless the contents of the stream changed out\n       from under us after we read from it.*/\n    if(OP_UNLIKELY(!begin)&&OP_UNLIKELY(_offset<0))return OP_EBADLINK;\n    /*Bump up the chunk size.\n      This is mildly helpful when seeks are very expensive (http).*/\n    chunk_size=OP_MIN(2*chunk_size,OP_CHUNK_SIZE_MAX);\n    /*Avoid quadratic complexity if we hit an invalid patch of the file.*/\n    end=OP_MIN(begin+OP_PAGE_SIZE_MAX-1,original_end);\n  }\n  while(_offset<0);\n  if(preferred_found)*_sr=*&preferred_sr;\n  return 0;\n}\n\n/*Find the last page beginning before _offset with the given serial number and\n   a valid granule position.\n  Unlike the above search, this continues until it finds such a page, but does\n   not stray outside the current link.\n  We could implement it (inefficiently) by calling op_get_prev_page_serial()\n   repeatedly until it returned a page that had both our preferred serial\n   number and a valid granule position, but doing it with a separate function\n   allows us to avoid repeatedly re-scanning valid pages from other streams as\n   we seek-back-and-read-forward.\n  [out] _gp:   Returns the granule position of the page that was found on\n                success.\n  _offset:     The _offset before which to find a page.\n               Any page returned will consist of data entirely before _offset.\n  _serialno:   The target serial number.\n  _serialnos:  The list of serial numbers in the link that contains the\n                preferred serial number.\n  _nserialnos: The number of serial numbers in the current link.\n  Return: The offset of the page on success, or a negative value on failure.\n          OP_EREAD:    Failed to read more data (error or EOF).\n          OP_EBADLINK: We couldn't find a page even after seeking back past the\n                        beginning of the link.*/\nstatic opus_int64 op_get_last_page(OggOpusFile *_of,ogg_int64_t *_gp,\n opus_int64 _offset,ogg_uint32_t _serialno,\n const ogg_uint32_t *_serialnos,int _nserialnos){\n  ogg_page    og;\n  ogg_int64_t gp;\n  opus_int64  begin;\n  opus_int64  end;\n  opus_int64  original_end;\n  opus_int32  chunk_size;\n  /*The target serial number must belong to the current link.*/\n  OP_ASSERT(op_lookup_serialno(_serialno,_serialnos,_nserialnos));\n  original_end=end=begin=_offset;\n  _offset=-1;\n  /*We shouldn't have to initialize gp, but gcc is too dumb to figure out that\n     ret>=0 implies we entered the if(page_gp!=-1) block at least once.*/\n  gp=-1;\n  chunk_size=OP_CHUNK_SIZE;\n  do{\n    int left_link;\n    int ret;\n    OP_ASSERT(chunk_size>=OP_PAGE_SIZE_MAX);\n    begin=OP_MAX(begin-chunk_size,0);\n    ret=op_seek_helper(_of,begin);\n    if(OP_UNLIKELY(ret<0))return ret;\n    left_link=0;\n    while(_of->offset<end){\n      opus_int64   llret;\n      ogg_uint32_t serialno;\n      llret=op_get_next_page(_of,&og,end);\n      if(OP_UNLIKELY(llret<OP_FALSE))return llret;\n      else if(llret==OP_FALSE)break;\n      serialno=ogg_page_serialno(&og);\n      if(serialno==_serialno){\n        ogg_int64_t page_gp;\n        /*The page is from the right stream...*/\n        page_gp=ogg_page_granulepos(&og);\n        if(page_gp!=-1){\n          /*And has a valid granule position.\n            Let's remember it.*/\n          _offset=llret;\n          gp=page_gp;\n        }\n      }\n      else if(OP_UNLIKELY(!op_lookup_serialno(serialno,\n       _serialnos,_nserialnos))){\n        /*We fell off the start of the link, which means we don't need to keep\n           seeking any farther back.*/\n        left_link=1;\n      }\n    }\n    /*We started from at or before the beginning of the link and found nothing.\n      This should be impossible unless the contents of the stream changed out\n       from under us after we read from it.*/\n    if((OP_UNLIKELY(left_link)||OP_UNLIKELY(!begin))&&OP_UNLIKELY(_offset<0)){\n      return OP_EBADLINK;\n    }\n    /*Bump up the chunk size.\n      This is mildly helpful when seeks are very expensive (http).*/\n    chunk_size=OP_MIN(2*chunk_size,OP_CHUNK_SIZE_MAX);\n    /*Avoid quadratic complexity if we hit an invalid patch of the file.*/\n    end=OP_MIN(begin+OP_PAGE_SIZE_MAX-1,original_end);\n  }\n  while(_offset<0);\n  *_gp=gp;\n  return _offset;\n}\n\n/*Uses the local ogg_stream storage in _of.\n  This is important for non-streaming input sources.*/\nstatic int op_fetch_headers_impl(OggOpusFile *_of,OpusHead *_head,\n OpusTags *_tags,ogg_uint32_t **_serialnos,int *_nserialnos,\n int *_cserialnos,ogg_page *_og){\n  ogg_packet op;\n  int        ret;\n  if(_serialnos!=NULL)*_nserialnos=0;\n  /*Extract the serialnos of all BOS pages plus the first set of Opus headers\n     we see in the link.*/\n  while(ogg_page_bos(_og)){\n    if(_serialnos!=NULL){\n      if(OP_UNLIKELY(op_lookup_page_serialno(_og,*_serialnos,*_nserialnos))){\n        /*A dupe serialnumber in an initial header packet set==invalid stream.*/\n        return OP_EBADHEADER;\n      }\n      ret=op_add_serialno(_og,_serialnos,_nserialnos,_cserialnos);\n      if(OP_UNLIKELY(ret<0))return ret;\n    }\n    if(_of->ready_state<OP_STREAMSET){\n      /*We don't have an Opus stream in this link yet, so begin prospective\n         stream setup.\n        We need a stream to get packets.*/\n      ogg_stream_reset_serialno(&_of->os,ogg_page_serialno(_og));\n      ogg_stream_pagein(&_of->os,_og);\n      if(OP_LIKELY(ogg_stream_packetout(&_of->os,&op)>0)){\n        ret=opus_head_parse(_head,op.packet,op.bytes);\n        /*Found a valid Opus header.\n          Continue setup.*/\n        if(OP_LIKELY(ret>=0))_of->ready_state=OP_STREAMSET;\n        /*If it's just a stream type we don't recognize, ignore it.\n          Everything else is fatal.*/\n        else if(ret!=OP_ENOTFORMAT)return ret;\n      }\n      /*TODO: Should a BOS page with no packets be an error?*/\n    }\n    /*Get the next page.\n      No need to clamp the boundary offset against _of->end, as all errors\n       become OP_ENOTFORMAT or OP_EBADHEADER.*/\n    if(OP_UNLIKELY(op_get_next_page(_of,_og,\n     OP_ADV_OFFSET(_of->offset,OP_CHUNK_SIZE))<0)){\n      return _of->ready_state<OP_STREAMSET?OP_ENOTFORMAT:OP_EBADHEADER;\n    }\n  }\n  if(OP_UNLIKELY(_of->ready_state!=OP_STREAMSET))return OP_ENOTFORMAT;\n  /*If the first non-header page belonged to our Opus stream, submit it.*/\n  if(_of->os.serialno==ogg_page_serialno(_og))ogg_stream_pagein(&_of->os,_og);\n  /*Loop getting packets.*/\n  for(;;){\n    switch(ogg_stream_packetout(&_of->os,&op)){\n      case 0:{\n        /*Loop getting pages.*/\n        for(;;){\n          /*No need to clamp the boundary offset against _of->end, as all\n             errors become OP_EBADHEADER.*/\n          if(OP_UNLIKELY(op_get_next_page(_of,_og,\n           OP_ADV_OFFSET(_of->offset,OP_CHUNK_SIZE))<0)){\n            return OP_EBADHEADER;\n          }\n          /*If this page belongs to the correct stream, go parse it.*/\n          if(_of->os.serialno==ogg_page_serialno(_og)){\n            ogg_stream_pagein(&_of->os,_og);\n            break;\n          }\n          /*If the link ends before we see the Opus comment header, abort.*/\n          if(OP_UNLIKELY(ogg_page_bos(_og)))return OP_EBADHEADER;\n          /*Otherwise, keep looking.*/\n        }\n      }break;\n      /*We shouldn't get a hole in the headers!*/\n      case -1:return OP_EBADHEADER;\n      default:{\n        /*Got a packet.\n          It should be the comment header.*/\n        ret=opus_tags_parse(_tags,op.packet,op.bytes);\n        if(OP_UNLIKELY(ret<0))return ret;\n        /*Make sure the page terminated at the end of the comment header.\n          If there is another packet on the page, or part of a packet, then\n           reject the stream.\n          Otherwise seekable sources won't be able to seek back to the start\n           properly.*/\n        ret=ogg_stream_packetout(&_of->os,&op);\n        if(OP_UNLIKELY(ret!=0)\n         ||OP_UNLIKELY(_og->header[_og->header_len-1]==255)){\n          /*If we fail, the caller assumes our tags are uninitialized.*/\n          opus_tags_clear(_tags);\n          return OP_EBADHEADER;\n        }\n        return 0;\n      }\n    }\n  }\n}\n\nstatic int op_fetch_headers(OggOpusFile *_of,OpusHead *_head,\n OpusTags *_tags,ogg_uint32_t **_serialnos,int *_nserialnos,\n int *_cserialnos,ogg_page *_og){\n  ogg_page og;\n  int      ret;\n  if(!_og){\n    /*No need to clamp the boundary offset against _of->end, as all errors\n       become OP_ENOTFORMAT.*/\n    if(OP_UNLIKELY(op_get_next_page(_of,&og,\n     OP_ADV_OFFSET(_of->offset,OP_CHUNK_SIZE))<0)){\n      return OP_ENOTFORMAT;\n    }\n    _og=&og;\n  }\n  _of->ready_state=OP_OPENED;\n  ret=op_fetch_headers_impl(_of,_head,_tags,_serialnos,_nserialnos,\n   _cserialnos,_og);\n  /*Revert back from OP_STREAMSET to OP_OPENED on failure, to prevent\n     double-free of the tags in an unseekable stream.*/\n  if(OP_UNLIKELY(ret<0))_of->ready_state=OP_OPENED;\n  return ret;\n}\n\n/*Granule position manipulation routines.\n  A granule position is defined to be an unsigned 64-bit integer, with the\n   special value -1 in two's complement indicating an unset or invalid granule\n   position.\n  We are not guaranteed to have an unsigned 64-bit type, so we construct the\n   following routines that\n   a) Properly order negative numbers as larger than positive numbers, and\n   b) Check for underflow or overflow past the special -1 value.\n  This lets us operate on the full, valid range of granule positions in a\n   consistent and safe manner.\n  This full range is organized into distinct regions:\n   [ -1 (invalid) ][ 0 ... OP_INT64_MAX ][ OP_INT64_MIN ... -2 ][-1 (invalid) ]\n\n  No one should actually use granule positions so large that they're negative,\n   even if they are technically valid, as very little software handles them\n   correctly (including most of Xiph.Org's).\n  This library also refuses to support durations so large they won't fit in a\n   signed 64-bit integer (to avoid exposing this mess to the application, and\n   to simplify a good deal of internal arithmetic), so the only way to use them\n   successfully is if pcm_start is very large.\n  This means there isn't anything you can do with negative granule positions\n   that you couldn't have done with purely non-negative ones.\n  The main purpose of these routines is to allow us to think very explicitly\n   about the possible failure cases of all granule position manipulations.*/\n\n/*Safely adds a small signed integer to a valid (not -1) granule position.\n  The result can use the full 64-bit range of values (both positive and\n   negative), but will fail on overflow (wrapping past -1; wrapping past\n   OP_INT64_MAX is explicitly okay).\n  [out] _dst_gp: The resulting granule position.\n                 Only modified on success.\n  _src_gp:       The granule position to add to.\n                 This must not be -1.\n  _delta:        The amount to add.\n                 This is allowed to be up to 32 bits to support the maximum\n                  duration of a single Ogg page (255 packets * 120 ms per\n                  packet == 1,468,800 samples at 48 kHz).\n  Return: 0 on success, or OP_EINVAL if the result would wrap around past -1.*/\nstatic int op_granpos_add(ogg_int64_t *_dst_gp,ogg_int64_t _src_gp,\n opus_int32 _delta){\n  /*The code below handles this case correctly, but there's no reason we\n     should ever be called with these values, so make sure we aren't.*/\n  OP_ASSERT(_src_gp!=-1);\n  if(_delta>0){\n    /*Adding this amount to the granule position would overflow its 64-bit\n       range.*/\n    if(OP_UNLIKELY(_src_gp<0)&&OP_UNLIKELY(_src_gp>=-1-_delta))return OP_EINVAL;\n    if(OP_UNLIKELY(_src_gp>OP_INT64_MAX-_delta)){\n      /*Adding this amount to the granule position would overflow the positive\n         half of its 64-bit range.\n        Since signed overflow is undefined in C, do it in a way the compiler\n         isn't allowed to screw up.*/\n      _delta-=(opus_int32)(OP_INT64_MAX-_src_gp)+1;\n      _src_gp=OP_INT64_MIN;\n    }\n  }\n  else if(_delta<0){\n    /*Subtracting this amount from the granule position would underflow its\n       64-bit range.*/\n    if(_src_gp>=0&&OP_UNLIKELY(_src_gp<-_delta))return OP_EINVAL;\n    if(OP_UNLIKELY(_src_gp<OP_INT64_MIN-_delta)){\n      /*Subtracting this amount from the granule position would underflow the\n         negative half of its 64-bit range.\n        Since signed underflow is undefined in C, do it in a way the compiler\n         isn't allowed to screw up.*/\n      _delta+=(opus_int32)(_src_gp-OP_INT64_MIN)+1;\n      _src_gp=OP_INT64_MAX;\n    }\n  }\n  *_dst_gp=_src_gp+_delta;\n  return 0;\n}\n\n/*Safely computes the difference between two granule positions.\n  The difference must fit in a signed 64-bit integer, or the function fails.\n  It correctly handles the case where the granule position has wrapped around\n   from positive values to negative ones.\n  [out] _delta: The difference between the granule positions.\n                Only modified on success.\n  _gp_a:        The granule position to subtract from.\n                This must not be -1.\n  _gp_b:        The granule position to subtract.\n                This must not be -1.\n  Return: 0 on success, or OP_EINVAL if the result would not fit in a signed\n           64-bit integer.*/\nstatic int op_granpos_diff(ogg_int64_t *_delta,\n ogg_int64_t _gp_a,ogg_int64_t _gp_b){\n  int gp_a_negative;\n  int gp_b_negative;\n  /*The code below handles these cases correctly, but there's no reason we\n     should ever be called with these values, so make sure we aren't.*/\n  OP_ASSERT(_gp_a!=-1);\n  OP_ASSERT(_gp_b!=-1);\n  gp_a_negative=OP_UNLIKELY(_gp_a<0);\n  gp_b_negative=OP_UNLIKELY(_gp_b<0);\n  if(OP_UNLIKELY(gp_a_negative^gp_b_negative)){\n    ogg_int64_t da;\n    ogg_int64_t db;\n    if(gp_a_negative){\n      /*_gp_a has wrapped to a negative value but _gp_b hasn't: the difference\n         should be positive.*/\n      /*Step 1: Handle wrapping.*/\n      /*_gp_a < 0 => da < 0.*/\n      da=(OP_INT64_MIN-_gp_a)-1;\n      /*_gp_b >= 0  => db >= 0.*/\n      db=OP_INT64_MAX-_gp_b;\n      /*Step 2: Check for overflow.*/\n      if(OP_UNLIKELY(OP_INT64_MAX+da<db))return OP_EINVAL;\n      *_delta=db-da;\n    }\n    else{\n      /*_gp_b has wrapped to a negative value but _gp_a hasn't: the difference\n         should be negative.*/\n      /*Step 1: Handle wrapping.*/\n      /*_gp_a >= 0 => da <= 0*/\n      da=_gp_a+OP_INT64_MIN;\n      /*_gp_b < 0 => db <= 0*/\n      db=OP_INT64_MIN-_gp_b;\n      /*Step 2: Check for overflow.*/\n      if(OP_UNLIKELY(da<OP_INT64_MIN-db))return OP_EINVAL;\n      *_delta=da+db;\n    }\n  }\n  else *_delta=_gp_a-_gp_b;\n  return 0;\n}\n\nstatic int op_granpos_cmp(ogg_int64_t _gp_a,ogg_int64_t _gp_b){\n  /*The invalid granule position -1 should behave like NaN: neither greater\n     than nor less than any other granule position, nor equal to any other\n     granule position, including itself.\n    However, that means there isn't anything we could sensibly return from this\n     function for it.*/\n  OP_ASSERT(_gp_a!=-1);\n  OP_ASSERT(_gp_b!=-1);\n  /*Handle the wrapping cases.*/\n  if(OP_UNLIKELY(_gp_a<0)){\n    if(_gp_b>=0)return 1;\n    /*Else fall through.*/\n  }\n  else if(OP_UNLIKELY(_gp_b<0))return -1;\n  /*No wrapping case.*/\n  return (_gp_a>_gp_b)-(_gp_b>_gp_a);\n}\n\n/*Returns the duration of the packet (in samples at 48 kHz), or a negative\n   value on error.*/\nstatic int op_get_packet_duration(const unsigned char *_data,int _len){\n  int nframes;\n  int frame_size;\n  int nsamples;\n  nframes=opus_packet_get_nb_frames(_data,_len);\n  if(OP_UNLIKELY(nframes<0))return OP_EBADPACKET;\n  frame_size=opus_packet_get_samples_per_frame(_data,48000);\n  nsamples=nframes*frame_size;\n  if(OP_UNLIKELY(nsamples>120*48))return OP_EBADPACKET;\n  return nsamples;\n}\n\n/*This function more properly belongs in info.c, but we define it here to allow\n   the static granule position manipulation functions to remain static.*/\nogg_int64_t opus_granule_sample(const OpusHead *_head,ogg_int64_t _gp){\n  opus_int32 pre_skip;\n  pre_skip=_head->pre_skip;\n  if(_gp!=-1&&op_granpos_add(&_gp,_gp,-pre_skip))_gp=-1;\n  return _gp;\n}\n\n/*Grab all the packets currently in the stream state, and compute their\n   durations.\n  _of->op_count is set to the number of packets collected.\n  [out] _durations: Returns the durations of the individual packets.\n  Return: The total duration of all packets, or OP_HOLE if there was a hole.*/\nstatic opus_int32 op_collect_audio_packets(OggOpusFile *_of,\n int _durations[255]){\n  opus_int32 total_duration;\n  int        op_count;\n  /*Count the durations of all packets in the page.*/\n  op_count=0;\n  total_duration=0;\n  for(;;){\n    int ret;\n    /*This takes advantage of undocumented libogg behavior that returned\n       ogg_packet buffers are valid at least until the next page is\n       submitted.\n      Relying on this is not too terrible, as _none_ of the Ogg memory\n       ownership/lifetime rules are well-documented.\n      But I can read its code and know this will work.*/\n    ret=ogg_stream_packetout(&_of->os,_of->op+op_count);\n    if(!ret)break;\n    if(OP_UNLIKELY(ret<0)){\n      /*We shouldn't get holes in the middle of pages.*/\n      OP_ASSERT(op_count==0);\n      /*Set the return value and break out of the loop.\n        We want to make sure op_count gets set to 0, because we've ingested a\n         page, so any previously loaded packets are now invalid.*/\n      total_duration=OP_HOLE;\n      break;\n    }\n    /*Unless libogg is broken, we can't get more than 255 packets from a\n       single page.*/\n    OP_ASSERT(op_count<255);\n    _durations[op_count]=op_get_packet_duration(_of->op[op_count].packet,\n     _of->op[op_count].bytes);\n    if(OP_LIKELY(_durations[op_count]>0)){\n      /*With at most 255 packets on a page, this can't overflow.*/\n      total_duration+=_durations[op_count++];\n    }\n    /*Ignore packets with an invalid TOC sequence.*/\n    else if(op_count>0){\n      /*But save the granule position, if there was one.*/\n      _of->op[op_count-1].granulepos=_of->op[op_count].granulepos;\n    }\n  }\n  _of->op_pos=0;\n  _of->op_count=op_count;\n  return total_duration;\n}\n\n/*Starting from current cursor position, get the initial PCM offset of the next\n   page.\n  This also validates the granule position on the first page with a completed\n   audio data packet, as required by the spec.\n  If this link is completely empty (no pages with completed packets), then this\n   function sets pcm_start=pcm_end=0 and returns the BOS page of the next link\n   (if any).\n  In the seekable case, we initialize pcm_end=-1 before calling this function,\n   so that later we can detect that the link was empty before calling\n   op_find_final_pcm_offset().\n  [inout] _link: The link for which to find pcm_start.\n  [out] _og:     Returns the BOS page of the next link if this link was empty.\n                 In the unseekable case, we can then feed this to\n                  op_fetch_headers() to start the next link.\n                 The caller may pass NULL (e.g., for seekable streams), in\n                  which case this page will be discarded.\n  Return: 0 on success, 1 if there is a buffered BOS page available, or a\n           negative value on unrecoverable error.*/\nstatic int op_find_initial_pcm_offset(OggOpusFile *_of,\n OggOpusLink *_link,ogg_page *_og){\n  ogg_page     og;\n  opus_int64   page_offset;\n  ogg_int64_t  pcm_start;\n  ogg_int64_t  prev_packet_gp;\n  ogg_int64_t  cur_page_gp;\n  ogg_uint32_t serialno;\n  opus_int32   total_duration;\n  int          durations[255];\n  int          cur_page_eos;\n  int          op_count;\n  int          pi;\n  if(_og==NULL)_og=&og;\n  serialno=_of->os.serialno;\n  op_count=0;\n  /*We shouldn't have to initialize total_duration, but gcc is too dumb to\n     figure out that op_count>0 implies we've been through the whole loop at\n     least once.*/\n  total_duration=0;\n  do{\n    page_offset=op_get_next_page(_of,_og,_of->end);\n    /*We should get a page unless the file is truncated or mangled.\n      Otherwise there are no audio data packets in the whole logical stream.*/\n    if(OP_UNLIKELY(page_offset<0)){\n      /*Fail if there was a read error.*/\n      if(page_offset<OP_FALSE)return (int)page_offset;\n      /*Fail if the pre-skip is non-zero, since it's asking us to skip more\n         samples than exist.*/\n      if(_link->head.pre_skip>0)return OP_EBADTIMESTAMP;\n      _link->pcm_file_offset=0;\n      /*Set pcm_end and end_offset so we can skip the call to\n         op_find_final_pcm_offset().*/\n      _link->pcm_start=_link->pcm_end=0;\n      _link->end_offset=_link->data_offset;\n      return 0;\n    }\n    /*Similarly, if we hit the next link in the chain, we've gone too far.*/\n    if(OP_UNLIKELY(ogg_page_bos(_og))){\n      if(_link->head.pre_skip>0)return OP_EBADTIMESTAMP;\n      /*Set pcm_end and end_offset so we can skip the call to\n         op_find_final_pcm_offset().*/\n      _link->pcm_file_offset=0;\n      _link->pcm_start=_link->pcm_end=0;\n      _link->end_offset=_link->data_offset;\n      /*Tell the caller we've got a buffered page for them.*/\n      return 1;\n    }\n    /*Ignore pages from other streams (not strictly necessary, because of the\n       checks in ogg_stream_pagein(), but saves some work).*/\n    if(serialno!=(ogg_uint32_t)ogg_page_serialno(_og))continue;\n    ogg_stream_pagein(&_of->os,_og);\n    /*Bitrate tracking: add the header's bytes here.\n      The body bytes are counted when we consume the packets.*/\n    _of->bytes_tracked+=_og->header_len;\n    /*Count the durations of all packets in the page.*/\n    do total_duration=op_collect_audio_packets(_of,durations);\n    /*Ignore holes.*/\n    while(OP_UNLIKELY(total_duration<0));\n    op_count=_of->op_count;\n  }\n  while(op_count<=0);\n  /*We found the first page with a completed audio data packet: actually look\n     at the granule position.\n    RFC 3533 says, \"A special value of -1 (in two's complement) indicates that\n     no packets finish on this page,\" which does not say that a granule\n     position that is NOT -1 indicates that some packets DO finish on that page\n     (even though this was the intention, libogg itself violated this intention\n     for years before we fixed it).\n    The Ogg Opus specification only imposes its start-time requirements\n     on the granule position of the first page with completed packets,\n     so we ignore any set granule positions until then.*/\n  cur_page_gp=_of->op[op_count-1].granulepos;\n  /*But getting a packet without a valid granule position on the page is not\n     okay.*/\n  if(cur_page_gp==-1)return OP_EBADTIMESTAMP;\n  cur_page_eos=_of->op[op_count-1].e_o_s;\n  if(OP_LIKELY(!cur_page_eos)){\n    /*The EOS flag wasn't set.\n      Work backwards from the provided granule position to get the starting PCM\n       offset.*/\n    if(OP_UNLIKELY(op_granpos_add(&pcm_start,cur_page_gp,-total_duration)<0)){\n      /*The starting granule position MUST not be smaller than the amount of\n         audio on the first page with completed packets.*/\n      return OP_EBADTIMESTAMP;\n    }\n  }\n  else{\n    /*The first page with completed packets was also the last.*/\n    if(OP_LIKELY(op_granpos_add(&pcm_start,cur_page_gp,-total_duration)<0)){\n      /*If there's less audio on the page than indicated by the granule\n         position, then we're doing end-trimming, and the starting PCM offset\n         is zero by spec mandate.*/\n      pcm_start=0;\n      /*However, the end-trimming MUST not ask us to trim more samples than\n         exist after applying the pre-skip.*/\n      if(OP_UNLIKELY(op_granpos_cmp(cur_page_gp,_link->head.pre_skip)<0)){\n        return OP_EBADTIMESTAMP;\n      }\n    }\n  }\n  /*Timestamp the individual packets.*/\n  prev_packet_gp=pcm_start;\n  for(pi=0;pi<op_count;pi++){\n    if(cur_page_eos){\n      ogg_int64_t diff;\n      OP_ALWAYS_TRUE(!op_granpos_diff(&diff,cur_page_gp,prev_packet_gp));\n      diff=durations[pi]-diff;\n      /*If we have samples to trim...*/\n      if(diff>0){\n        /*If we trimmed the entire packet, stop (the spec says encoders\n           shouldn't do this, but we support it anyway).*/\n        if(OP_UNLIKELY(diff>durations[pi]))break;\n        _of->op[pi].granulepos=prev_packet_gp=cur_page_gp;\n        /*Move the EOS flag to this packet, if necessary, so we'll trim the\n           samples.*/\n        _of->op[pi].e_o_s=1;\n        continue;\n      }\n    }\n    /*Update the granule position as normal.*/\n    OP_ALWAYS_TRUE(!op_granpos_add(&_of->op[pi].granulepos,\n     prev_packet_gp,durations[pi]));\n    prev_packet_gp=_of->op[pi].granulepos;\n  }\n  /*Update the packet count after end-trimming.*/\n  _of->op_count=pi;\n  _of->cur_discard_count=_link->head.pre_skip;\n  _link->pcm_file_offset=0;\n  _of->prev_packet_gp=_link->pcm_start=pcm_start;\n  _of->prev_page_offset=page_offset;\n  return 0;\n}\n\n/*Starting from current cursor position, get the final PCM offset of the\n   previous page.\n  This also validates the duration of the link, which, while not strictly\n   required by the spec, we need to ensure duration calculations don't\n   overflow.\n  This is only done for seekable sources.\n  We must validate that op_find_initial_pcm_offset() succeeded for this link\n   before calling this function, otherwise it will scan the entire stream\n   backwards until it reaches the start, and then fail.*/\nstatic int op_find_final_pcm_offset(OggOpusFile *_of,\n const ogg_uint32_t *_serialnos,int _nserialnos,OggOpusLink *_link,\n opus_int64 _offset,ogg_uint32_t _end_serialno,ogg_int64_t _end_gp,\n ogg_int64_t *_total_duration){\n  ogg_int64_t  total_duration;\n  ogg_int64_t  duration;\n  ogg_uint32_t cur_serialno;\n  /*For the time being, fetch end PCM offset the simple way.*/\n  cur_serialno=_link->serialno;\n  if(_end_serialno!=cur_serialno||_end_gp==-1){\n    _offset=op_get_last_page(_of,&_end_gp,_offset,\n     cur_serialno,_serialnos,_nserialnos);\n    if(OP_UNLIKELY(_offset<0))return (int)_offset;\n  }\n  /*At worst we should have found the first page with completed packets.*/\n  if(OP_UNLIKELY(_offset<_link->data_offset))return OP_EBADLINK;\n  /*This implementation requires that the difference between the first and last\n     granule positions in each link be representable in a signed, 64-bit\n     number, and that each link also have at least as many samples as the\n     pre-skip requires.*/\n  if(OP_UNLIKELY(op_granpos_diff(&duration,_end_gp,_link->pcm_start)<0)\n   ||OP_UNLIKELY(duration<_link->head.pre_skip)){\n    return OP_EBADTIMESTAMP;\n  }\n  /*We also require that the total duration be representable in a signed,\n     64-bit number.*/\n  duration-=_link->head.pre_skip;\n  total_duration=*_total_duration;\n  if(OP_UNLIKELY(OP_INT64_MAX-duration<total_duration))return OP_EBADTIMESTAMP;\n  *_total_duration=total_duration+duration;\n  _link->pcm_end=_end_gp;\n  _link->end_offset=_offset;\n  return 0;\n}\n\n/*Rescale the number _x from the range [0,_from] to [0,_to].\n  _from and _to must be positive.*/\nstatic opus_int64 op_rescale64(opus_int64 _x,opus_int64 _from,opus_int64 _to){\n  opus_int64 frac;\n  opus_int64 ret;\n  int        i;\n  if(_x>=_from)return _to;\n  if(_x<=0)return 0;\n  frac=0;\n  for(i=0;i<63;i++){\n    frac<<=1;\n    OP_ASSERT(_x<=_from);\n    if(_x>=_from>>1){\n      _x-=_from-_x;\n      frac|=1;\n    }\n    else _x<<=1;\n  }\n  ret=0;\n  for(i=0;i<63;i++){\n    if(frac&1)ret=(ret&_to&1)+(ret>>1)+(_to>>1);\n    else ret>>=1;\n    frac>>=1;\n  }\n  return ret;\n}\n\n/*The minimum granule position spacing allowed for making predictions.\n  This corresponds to about 1 second of audio at 48 kHz for both Opus and\n   Vorbis, or one keyframe interval in Theora with the default keyframe spacing\n   of 256.*/\n#define OP_GP_SPACING_MIN (48000)\n\n/*Try to estimate the location of the next link using the current seek\n   records, assuming the initial granule position of any streams we've found is\n   0.*/\nstatic opus_int64 op_predict_link_start(const OpusSeekRecord *_sr,int _nsr,\n opus_int64 _searched,opus_int64 _end_searched,opus_int32 _bias){\n  opus_int64 bisect;\n  int        sri;\n  int        srj;\n  /*Require that we be at least OP_CHUNK_SIZE from the end.\n    We don't require that we be at least OP_CHUNK_SIZE from the beginning,\n     because if we are we'll just scan forward without seeking.*/\n  _end_searched-=OP_CHUNK_SIZE;\n  if(_searched>=_end_searched)return -1;\n  bisect=_end_searched;\n  for(sri=0;sri<_nsr;sri++){\n    ogg_int64_t  gp1;\n    ogg_int64_t  gp2_min;\n    ogg_uint32_t serialno1;\n    opus_int64   offset1;\n    /*If the granule position is negative, either it's invalid or we'd cause\n       overflow.\n      If it is larger than OP_INT64_MAX-OP_GP_SPACING_MIN, then no positive\n       granule position would satisfy our minimum spacing requirements below.*/\n    gp1=_sr[sri].gp;\n    if(gp1<0||gp1>OP_INT64_MAX-OP_GP_SPACING_MIN)continue;\n    /*We require some minimum distance between granule positions to make an\n       estimate.\n      We don't actually know what granule position scheme is being used,\n       because we have no idea what kind of stream these came from.\n      Therefore we require a minimum spacing between them, with the\n       expectation that while bitrates and granule position increments might\n       vary locally in quite complex ways, they are globally smooth.*/\n    gp2_min=gp1+OP_GP_SPACING_MIN;\n    offset1=_sr[sri].offset;\n    serialno1=_sr[sri].serialno;\n    for(srj=sri;srj-->0;){\n      ogg_int64_t gp2;\n      opus_int64  offset2;\n      opus_int64  num;\n      ogg_int64_t den;\n      ogg_int64_t ipart;\n      gp2=_sr[srj].gp;\n      if(gp2<gp2_min)continue;\n      /*Oh, and also make sure these came from the same stream.*/\n      if(_sr[srj].serialno!=serialno1)continue;\n      offset2=_sr[srj].offset;\n      /*For once, we can subtract with impunity.*/\n      den=gp2-gp1;\n      ipart=gp2/den;\n      num=offset2-offset1;\n      OP_ASSERT(num>0);\n      if(ipart>0&&(offset2-_searched)/ipart<num)continue;\n      offset2-=ipart*num;\n      gp2-=ipart*den;\n      offset2-=op_rescale64(gp2,den,num)-_bias;\n      if(offset2<_searched)continue;\n      bisect=OP_MIN(bisect,offset2);\n      break;\n    }\n  }\n  return bisect>=_end_searched?-1:bisect;\n}\n\n/*Finds each bitstream link, one at a time, using a bisection search.\n  This has to begin by knowing the offset of the first link's initial page.*/\nstatic int op_bisect_forward_serialno(OggOpusFile *_of,\n opus_int64 _searched,OpusSeekRecord *_sr,int _csr,\n ogg_uint32_t **_serialnos,int *_nserialnos,int *_cserialnos){\n  ogg_page      og;\n  OggOpusLink  *links;\n  int           nlinks;\n  int           clinks;\n  ogg_uint32_t *serialnos;\n  int           nserialnos;\n  ogg_int64_t   total_duration;\n  int           nsr;\n  int           ret;\n  links=_of->links;\n  nlinks=clinks=_of->nlinks;\n  total_duration=0;\n  /*We start with one seek record, for the last page in the file.\n    We build up a list of records for places we seek to during link\n     enumeration.\n    This list is kept sorted in reverse order.\n    We only care about seek locations that were _not_ in the current link,\n     therefore we can add them one at a time to the end of the list as we\n     improve the lower bound on the location where the next link starts.*/\n  nsr=1;\n  for(;;){\n    opus_int64  end_searched;\n    opus_int64  bisect;\n    opus_int64  next;\n    opus_int64  last;\n    ogg_int64_t end_offset;\n    ogg_int64_t end_gp;\n    int         sri;\n    serialnos=*_serialnos;\n    nserialnos=*_nserialnos;\n    if(OP_UNLIKELY(nlinks>=clinks)){\n      if(OP_UNLIKELY(clinks>INT_MAX-1>>1))return OP_EFAULT;\n      clinks=2*clinks+1;\n      OP_ASSERT(nlinks<clinks);\n      links=(OggOpusLink *)_ogg_realloc(links,sizeof(*links)*clinks);\n      if(OP_UNLIKELY(links==NULL))return OP_EFAULT;\n      _of->links=links;\n    }\n    /*Invariants:\n      We have the headers and serial numbers for the link beginning at 'begin'.\n      We have the offset and granule position of the last page in the file\n       (potentially not a page we care about).*/\n    /*Scan the seek records we already have to save us some bisection.*/\n    for(sri=0;sri<nsr;sri++){\n      if(op_lookup_serialno(_sr[sri].serialno,serialnos,nserialnos))break;\n    }\n    /*Is the last page in our current list of serial numbers?*/\n    if(sri<=0)break;\n    /*Last page wasn't found.\n      We have at least one more link.*/\n    last=-1;\n    end_searched=_sr[sri-1].search_start;\n    next=_sr[sri-1].offset;\n    end_gp=-1;\n    if(sri<nsr){\n      _searched=_sr[sri].offset+_sr[sri].size;\n      if(_sr[sri].serialno==links[nlinks-1].serialno){\n        end_gp=_sr[sri].gp;\n        end_offset=_sr[sri].offset;\n      }\n    }\n    nsr=sri;\n    bisect=-1;\n    /*If we've already found the end of at least one link, try to pick the\n       first bisection point at twice the average link size.\n      This is a good choice for files with lots of links that are all about the\n       same size.*/\n    if(nlinks>1){\n      opus_int64 last_offset;\n      opus_int64 avg_link_size;\n      opus_int64 upper_limit;\n      last_offset=links[nlinks-1].offset;\n      avg_link_size=last_offset/(nlinks-1);\n      upper_limit=end_searched-OP_CHUNK_SIZE-avg_link_size;\n      if(OP_LIKELY(last_offset>_searched-avg_link_size)\n       &&OP_LIKELY(last_offset<upper_limit)){\n        bisect=last_offset+avg_link_size;\n        if(OP_LIKELY(bisect<upper_limit))bisect+=avg_link_size;\n      }\n    }\n    /*We guard against garbage separating the last and first pages of two\n       links below.*/\n    while(_searched<end_searched){\n      opus_int32 next_bias;\n      /*If we don't have a better estimate, use simple bisection.*/\n      if(bisect==-1)bisect=_searched+(end_searched-_searched>>1);\n      /*If we're within OP_CHUNK_SIZE of the start, scan forward.*/\n      if(bisect-_searched<OP_CHUNK_SIZE)bisect=_searched;\n      /*Otherwise we're skipping data.\n        Forget the end page, if we saw one, as we might miss a later one.*/\n      else end_gp=-1;\n      ret=op_seek_helper(_of,bisect);\n      if(OP_UNLIKELY(ret<0))return ret;\n      last=op_get_next_page(_of,&og,_sr[nsr-1].offset);\n      if(OP_UNLIKELY(last<OP_FALSE))return (int)last;\n      next_bias=0;\n      if(last==OP_FALSE)end_searched=bisect;\n      else{\n        ogg_uint32_t serialno;\n        ogg_int64_t  gp;\n        serialno=ogg_page_serialno(&og);\n        gp=ogg_page_granulepos(&og);\n        if(!op_lookup_serialno(serialno,serialnos,nserialnos)){\n          end_searched=bisect;\n          next=last;\n          /*In reality we should always have enough room, but be paranoid.*/\n          if(OP_LIKELY(nsr<_csr)){\n            _sr[nsr].search_start=bisect;\n            _sr[nsr].offset=last;\n            OP_ASSERT(_of->offset-last>=0);\n            OP_ASSERT(_of->offset-last<=OP_PAGE_SIZE_MAX);\n            _sr[nsr].size=(opus_int32)(_of->offset-last);\n            _sr[nsr].serialno=serialno;\n            _sr[nsr].gp=gp;\n            nsr++;\n          }\n        }\n        else{\n          _searched=_of->offset;\n          next_bias=OP_CHUNK_SIZE;\n          if(serialno==links[nlinks-1].serialno){\n            /*This page was from the stream we want, remember it.\n              If it's the last such page in the link, we won't have to go back\n               looking for it later.*/\n            end_gp=gp;\n            end_offset=last;\n          }\n        }\n      }\n      bisect=op_predict_link_start(_sr,nsr,_searched,end_searched,next_bias);\n    }\n    /*Bisection point found.\n      Get the final granule position of the previous link, assuming\n       op_find_initial_pcm_offset() didn't already determine the link was\n       empty.*/\n    if(OP_LIKELY(links[nlinks-1].pcm_end==-1)){\n      if(end_gp==-1){\n        /*If we don't know where the end page is, we'll have to seek back and\n           look for it, starting from the end of the link.*/\n        end_offset=next;\n        /*Also forget the last page we read.\n          It won't be available after the seek.*/\n        last=-1;\n      }\n      ret=op_find_final_pcm_offset(_of,serialnos,nserialnos,\n       links+nlinks-1,end_offset,links[nlinks-1].serialno,end_gp,\n       &total_duration);\n      if(OP_UNLIKELY(ret<0))return ret;\n    }\n    if(last!=next){\n      /*The last page we read was not the first page the next link.\n        Move the cursor position to the offset of that first page.\n        This only performs an actual seek if the first page of the next link\n         does not start at the end of the last page from the current Opus\n         stream with a valid granule position.*/\n      ret=op_seek_helper(_of,next);\n      if(OP_UNLIKELY(ret<0))return ret;\n    }\n    ret=op_fetch_headers(_of,&links[nlinks].head,&links[nlinks].tags,\n     _serialnos,_nserialnos,_cserialnos,last!=next?NULL:&og);\n    if(OP_UNLIKELY(ret<0))return ret;\n    /*Mark the current link count so it can be cleaned up on error.*/\n    _of->nlinks=nlinks+1;\n    links[nlinks].offset=next;\n    links[nlinks].data_offset=_of->offset;\n    links[nlinks].serialno=_of->os.serialno;\n    links[nlinks].pcm_end=-1;\n    /*This might consume a page from the next link, however the next bisection\n       always starts with a seek.*/\n    ret=op_find_initial_pcm_offset(_of,links+nlinks,NULL);\n    if(OP_UNLIKELY(ret<0))return ret;\n    links[nlinks].pcm_file_offset=total_duration;\n    _searched=_of->offset;\n    ++nlinks;\n  }\n  /*Last page is in the starting serialno list, so we've reached the last link.\n    Now find the last granule position for it (if we didn't the first time we\n     looked at the end of the stream, and if op_find_initial_pcm_offset()\n     didn't already determine the link was empty).*/\n  if(OP_LIKELY(links[nlinks-1].pcm_end==-1)){\n    ret=op_find_final_pcm_offset(_of,serialnos,nserialnos,\n     links+nlinks-1,_sr[0].offset,_sr[0].serialno,_sr[0].gp,&total_duration);\n    if(OP_UNLIKELY(ret<0))return ret;\n  }\n  /*Trim back the links array if necessary.*/\n  links=(OggOpusLink *)_ogg_realloc(links,sizeof(*links)*nlinks);\n  if(OP_LIKELY(links!=NULL))_of->links=links;\n  /*We also don't need these anymore.*/\n  _ogg_free(*_serialnos);\n  *_serialnos=NULL;\n  *_cserialnos=*_nserialnos=0;\n  return 0;\n}\n\nstatic void op_update_gain(OggOpusFile *_of){\n  OpusHead   *head;\n  opus_int32  gain_q8;\n  int         li;\n  /*If decode isn't ready, then we'll apply the gain when we initialize the\n     decoder.*/\n  if(_of->ready_state<OP_INITSET)return;\n  gain_q8=_of->gain_offset_q8;\n  li=_of->seekable?_of->cur_link:0;\n  head=&_of->links[li].head;\n  /*We don't have to worry about overflow here because the header gain and\n     track gain must lie in the range [-32768,32767], and the user-supplied\n     offset has been pre-clamped to [-98302,98303].*/\n  switch(_of->gain_type){\n    case OP_ALBUM_GAIN:{\n      int album_gain_q8;\n      album_gain_q8=0;\n      opus_tags_get_album_gain(&_of->links[li].tags,&album_gain_q8);\n      gain_q8+=album_gain_q8;\n      gain_q8+=head->output_gain;\n    }break;\n    case OP_TRACK_GAIN:{\n      int track_gain_q8;\n      track_gain_q8=0;\n      opus_tags_get_track_gain(&_of->links[li].tags,&track_gain_q8);\n      gain_q8+=track_gain_q8;\n      gain_q8+=head->output_gain;\n    }break;\n    case OP_HEADER_GAIN:gain_q8+=head->output_gain;break;\n    case OP_ABSOLUTE_GAIN:break;\n    default:OP_ASSERT(0);\n  }\n  gain_q8=OP_CLAMP(-32768,gain_q8,32767);\n  OP_ASSERT(_of->od!=NULL);\n#if defined(OPUS_SET_GAIN)\n  opus_multistream_decoder_ctl(_of->od,OPUS_SET_GAIN(gain_q8));\n#else\n/*A fallback that works with both float and fixed-point is a bunch of work,\n   so just force people to use a sufficiently new version.\n  This is deployed well enough at this point that this shouldn't be a burden.*/\n# error \"libopus 1.0.1 or later required\"\n#endif\n}\n\nstatic int op_make_decode_ready(OggOpusFile *_of){\n  const OpusHead *head;\n  int             li;\n  int             stream_count;\n  int             coupled_count;\n  int             channel_count;\n  if(_of->ready_state>OP_STREAMSET)return 0;\n  if(OP_UNLIKELY(_of->ready_state<OP_STREAMSET))return OP_EFAULT;\n  li=_of->seekable?_of->cur_link:0;\n  head=&_of->links[li].head;\n  stream_count=head->stream_count;\n  coupled_count=head->coupled_count;\n  channel_count=head->channel_count;\n  /*Check to see if the current decoder is compatible with the current link.*/\n  if(_of->od!=NULL&&_of->od_stream_count==stream_count\n   &&_of->od_coupled_count==coupled_count&&_of->od_channel_count==channel_count\n   &&memcmp(_of->od_mapping,head->mapping,\n   sizeof(*head->mapping)*channel_count)==0){\n    opus_multistream_decoder_ctl(_of->od,OPUS_RESET_STATE);\n  }\n  else{\n    int err;\n    opus_multistream_decoder_destroy(_of->od);\n    _of->od=opus_multistream_decoder_create(48000,channel_count,\n     stream_count,coupled_count,head->mapping,&err);\n    if(_of->od==NULL)return OP_EFAULT;\n    _of->od_stream_count=stream_count;\n    _of->od_coupled_count=coupled_count;\n    _of->od_channel_count=channel_count;\n    memcpy(_of->od_mapping,head->mapping,sizeof(*head->mapping)*channel_count);\n  }\n  _of->ready_state=OP_INITSET;\n  _of->bytes_tracked=0;\n  _of->samples_tracked=0;\n#if !defined(OP_FIXED_POINT)\n  _of->state_channel_count=0;\n  /*Use the serial number for the PRNG seed to get repeatable output for\n     straight play-throughs.*/\n  _of->dither_seed=_of->links[li].serialno;\n#endif\n  op_update_gain(_of);\n  return 0;\n}\n\nstatic int op_open_seekable2_impl(OggOpusFile *_of){\n  /*64 seek records should be enough for anybody.\n    Actually, with a bisection search in a 63-bit range down to OP_CHUNK_SIZE\n     granularity, much more than enough.*/\n  OpusSeekRecord sr[64];\n  opus_int64     data_offset;\n  int            ret;\n  /*We can seek, so set out learning all about this file.*/\n  (*_of->callbacks.seek)(_of->stream,0,SEEK_END);\n  _of->offset=_of->end=(*_of->callbacks.tell)(_of->stream);\n  if(OP_UNLIKELY(_of->end<0))return OP_EREAD;\n  data_offset=_of->links[0].data_offset;\n  if(OP_UNLIKELY(_of->end<data_offset))return OP_EBADLINK;\n  /*Get the offset of the last page of the physical bitstream, or, if we're\n     lucky, the last Opus page of the first link, as most Ogg Opus files will\n     contain a single logical bitstream.*/\n  ret=op_get_prev_page_serial(_of,sr,_of->end,\n   _of->links[0].serialno,_of->serialnos,_of->nserialnos);\n  if(OP_UNLIKELY(ret<0))return ret;\n  /*If there's any trailing junk, forget about it.*/\n  _of->end=sr[0].offset+sr[0].size;\n  if(OP_UNLIKELY(_of->end<data_offset))return OP_EBADLINK;\n  /*Now enumerate the bitstream structure.*/\n  return op_bisect_forward_serialno(_of,data_offset,sr,sizeof(sr)/sizeof(*sr),\n   &_of->serialnos,&_of->nserialnos,&_of->cserialnos);\n}\n\nstatic int op_open_seekable2(OggOpusFile *_of){\n  ogg_sync_state    oy_start;\n  ogg_stream_state  os_start;\n  ogg_packet       *op_start;\n  opus_int64        prev_page_offset;\n  opus_int64        start_offset;\n  int               start_op_count;\n  int               ret;\n  /*We're partially open and have a first link header state in storage in _of.\n    Save off that stream state so we can come back to it.\n    It would be simpler to just dump all this state and seek back to\n     links[0].data_offset when we're done.\n    But we do the extra work to allow us to seek back to _exactly_ the same\n     stream position we're at now.\n    This allows, e.g., the HTTP backend to continue reading from the original\n     connection (if it's still available), instead of opening a new one.\n    This means we can open and start playing a normal Opus file with a single\n     link and reasonable packet sizes using only two HTTP requests.*/\n  start_op_count=_of->op_count;\n  /*This is a bit too large to put on the stack unconditionally.*/\n  op_start=(ogg_packet *)_ogg_malloc(sizeof(*op_start)*start_op_count);\n  if(op_start==NULL)return OP_EFAULT;\n  *&oy_start=_of->oy;\n  *&os_start=_of->os;\n  prev_page_offset=_of->prev_page_offset;\n  start_offset=_of->offset;\n  memcpy(op_start,_of->op,sizeof(*op_start)*start_op_count);\n  OP_ASSERT((*_of->callbacks.tell)(_of->stream)==op_position(_of));\n  ogg_sync_init(&_of->oy);\n  ogg_stream_init(&_of->os,-1);\n  ret=op_open_seekable2_impl(_of);\n  /*Restore the old stream state.*/\n  ogg_stream_clear(&_of->os);\n  ogg_sync_clear(&_of->oy);\n  *&_of->oy=*&oy_start;\n  *&_of->os=*&os_start;\n  _of->offset=start_offset;\n  _of->op_count=start_op_count;\n  memcpy(_of->op,op_start,sizeof(*_of->op)*start_op_count);\n  _ogg_free(op_start);\n  _of->prev_packet_gp=_of->links[0].pcm_start;\n  _of->prev_page_offset=prev_page_offset;\n  _of->cur_discard_count=_of->links[0].head.pre_skip;\n  if(OP_UNLIKELY(ret<0))return ret;\n  /*And restore the position indicator.*/\n  ret=(*_of->callbacks.seek)(_of->stream,op_position(_of),SEEK_SET);\n  return OP_UNLIKELY(ret<0)?OP_EREAD:0;\n}\n\n/*Clear out the current logical bitstream decoder.*/\nstatic void op_decode_clear(OggOpusFile *_of){\n  /*We don't actually free the decoder.\n    We might be able to re-use it for the next link.*/\n  _of->op_count=0;\n  _of->od_buffer_size=0;\n  _of->prev_packet_gp=-1;\n  _of->prev_page_offset=-1;\n  if(!_of->seekable){\n    OP_ASSERT(_of->ready_state>=OP_INITSET);\n    opus_tags_clear(&_of->links[0].tags);\n  }\n  _of->ready_state=OP_OPENED;\n}\n\nstatic void op_clear(OggOpusFile *_of){\n  OggOpusLink *links;\n  _ogg_free(_of->od_buffer);\n  if(_of->od!=NULL)opus_multistream_decoder_destroy(_of->od);\n  links=_of->links;\n  if(!_of->seekable){\n    if(_of->ready_state>OP_OPENED||_of->ready_state==OP_PARTOPEN){\n      opus_tags_clear(&links[0].tags);\n    }\n  }\n  else if(OP_LIKELY(links!=NULL)){\n    int nlinks;\n    int link;\n    nlinks=_of->nlinks;\n    for(link=0;link<nlinks;link++)opus_tags_clear(&links[link].tags);\n  }\n  _ogg_free(links);\n  _ogg_free(_of->serialnos);\n  ogg_stream_clear(&_of->os);\n  ogg_sync_clear(&_of->oy);\n  if(_of->callbacks.close!=NULL)(*_of->callbacks.close)(_of->stream);\n}\n\nstatic int op_open1(OggOpusFile *_of,\n void *_stream,const OpusFileCallbacks *_cb,\n const unsigned char *_initial_data,size_t _initial_bytes){\n  ogg_page  og;\n  ogg_page *pog;\n  int       seekable;\n  int       ret;\n  memset(_of,0,sizeof(*_of));\n  if(OP_UNLIKELY(_initial_bytes>(size_t)LONG_MAX))return OP_EFAULT;\n  _of->end=-1;\n  _of->stream=_stream;\n  *&_of->callbacks=*_cb;\n  /*At a minimum, we need to be able to read data.*/\n  if(OP_UNLIKELY(_of->callbacks.read==NULL))return OP_EREAD;\n  /*Initialize the framing state.*/\n  ogg_sync_init(&_of->oy);\n  /*Perhaps some data was previously read into a buffer for testing against\n     other stream types.\n    Allow initialization from this previously read data (especially as we may\n     be reading from a non-seekable stream).\n    This requires copying it into a buffer allocated by ogg_sync_buffer() and\n     doesn't support seeking, so this is not a good mechanism to use for\n     decoding entire files from RAM.*/\n  if(_initial_bytes>0){\n    char *buffer;\n    buffer=ogg_sync_buffer(&_of->oy,(long)_initial_bytes);\n    memcpy(buffer,_initial_data,_initial_bytes*sizeof(*buffer));\n    ogg_sync_wrote(&_of->oy,(long)_initial_bytes);\n  }\n  /*Can we seek?\n    Stevens suggests the seek test is portable.\n    It's actually not for files on win32, but we address that by fixing it in\n     our callback implementation (see stream.c).*/\n  seekable=_cb->seek!=NULL&&(*_cb->seek)(_stream,0,SEEK_CUR)!=-1;\n  /*If seek is implemented, tell must also be implemented.*/\n  if(seekable){\n    opus_int64 pos;\n    if(OP_UNLIKELY(_of->callbacks.tell==NULL))return OP_EINVAL;\n    pos=(*_of->callbacks.tell)(_of->stream);\n    /*If the current position is not equal to the initial bytes consumed,\n       absolute seeking will not work.*/\n    if(OP_UNLIKELY(pos!=(opus_int64)_initial_bytes))return OP_EINVAL;\n  }\n  _of->seekable=seekable;\n  /*Don't seek yet.\n    Set up a 'single' (current) logical bitstream entry for partial open.*/\n  _of->links=(OggOpusLink *)_ogg_malloc(sizeof(*_of->links));\n  /*The serialno gets filled in later by op_fetch_headers().*/\n  ogg_stream_init(&_of->os,-1);\n  pog=NULL;\n  for(;;){\n    /*Fetch all BOS pages, store the Opus header and all seen serial numbers,\n      and load subsequent Opus setup headers.*/\n    ret=op_fetch_headers(_of,&_of->links[0].head,&_of->links[0].tags,\n     &_of->serialnos,&_of->nserialnos,&_of->cserialnos,pog);\n    if(OP_UNLIKELY(ret<0))break;\n    _of->nlinks=1;\n    _of->links[0].offset=0;\n    _of->links[0].data_offset=_of->offset;\n    _of->links[0].pcm_end=-1;\n    _of->links[0].serialno=_of->os.serialno;\n    /*Fetch the initial PCM offset.*/\n    ret=op_find_initial_pcm_offset(_of,_of->links,&og);\n    if(seekable||OP_LIKELY(ret<=0))break;\n    /*This link was empty, but we already have the BOS page for the next one in\n       og.\n      We can't seek, so start processing the next link right now.*/\n    opus_tags_clear(&_of->links[0].tags);\n    _of->nlinks=0;\n    if(!seekable)_of->cur_link++;\n    pog=&og;\n  }\n  if(OP_LIKELY(ret>=0))_of->ready_state=OP_PARTOPEN;\n  return ret;\n}\n\nstatic int op_open2(OggOpusFile *_of){\n  int ret;\n  OP_ASSERT(_of->ready_state==OP_PARTOPEN);\n  if(_of->seekable){\n    _of->ready_state=OP_OPENED;\n    ret=op_open_seekable2(_of);\n  }\n  else ret=0;\n  if(OP_LIKELY(ret>=0)){\n    /*We have buffered packets from op_find_initial_pcm_offset().\n      Move to OP_INITSET so we can use them.*/\n    _of->ready_state=OP_STREAMSET;\n    ret=op_make_decode_ready(_of);\n    if(OP_LIKELY(ret>=0))return 0;\n  }\n  /*Don't auto-close the stream on failure.*/\n  _of->callbacks.close=NULL;\n  op_clear(_of);\n  return ret;\n}\n\nOggOpusFile *op_test_callbacks(void *_stream,const OpusFileCallbacks *_cb,\n const unsigned char *_initial_data,size_t _initial_bytes,int *_error){\n  OggOpusFile *of;\n  int          ret;\n  of=(OggOpusFile *)_ogg_malloc(sizeof(*of));\n  ret=OP_EFAULT;\n  if(OP_LIKELY(of!=NULL)){\n    ret=op_open1(of,_stream,_cb,_initial_data,_initial_bytes);\n    if(OP_LIKELY(ret>=0)){\n      if(_error!=NULL)*_error=0;\n      return of;\n    }\n    /*Don't auto-close the stream on failure.*/\n    of->callbacks.close=NULL;\n    op_clear(of);\n    _ogg_free(of);\n  }\n  if(_error!=NULL)*_error=ret;\n  return NULL;\n}\n\nOggOpusFile *op_open_callbacks(void *_stream,const OpusFileCallbacks *_cb,\n const unsigned char *_initial_data,size_t _initial_bytes,int *_error){\n  OggOpusFile *of;\n  of=op_test_callbacks(_stream,_cb,_initial_data,_initial_bytes,_error);\n  if(OP_LIKELY(of!=NULL)){\n    int ret;\n    ret=op_open2(of);\n    if(OP_LIKELY(ret>=0))return of;\n    if(_error!=NULL)*_error=ret;\n    _ogg_free(of);\n  }\n  return NULL;\n}\n\n/*Convenience routine to clean up from failure for the open functions that\n   create their own streams.*/\nstatic OggOpusFile *op_open_close_on_failure(void *_stream,\n const OpusFileCallbacks *_cb,int *_error){\n  OggOpusFile *of;\n  if(OP_UNLIKELY(_stream==NULL)){\n    if(_error!=NULL)*_error=OP_EFAULT;\n    return NULL;\n  }\n  of=op_open_callbacks(_stream,_cb,NULL,0,_error);\n  if(OP_UNLIKELY(of==NULL))(*_cb->close)(_stream);\n  return of;\n}\n\nOggOpusFile *op_open_file(const char *_path,int *_error){\n  OpusFileCallbacks cb;\n  return op_open_close_on_failure(op_fopen(&cb,_path,\"rb\"),&cb,_error);\n}\n\nOggOpusFile *op_open_memory(const unsigned char *_data,size_t _size,\n int *_error){\n  OpusFileCallbacks cb;\n  return op_open_close_on_failure(op_mem_stream_create(&cb,_data,_size),&cb,\n   _error);\n}\n\n/*Convenience routine to clean up from failure for the open functions that\n   create their own streams.*/\nstatic OggOpusFile *op_test_close_on_failure(void *_stream,\n const OpusFileCallbacks *_cb,int *_error){\n  OggOpusFile *of;\n  if(OP_UNLIKELY(_stream==NULL)){\n    if(_error!=NULL)*_error=OP_EFAULT;\n    return NULL;\n  }\n  of=op_test_callbacks(_stream,_cb,NULL,0,_error);\n  if(OP_UNLIKELY(of==NULL))(*_cb->close)(_stream);\n  return of;\n}\n\nOggOpusFile *op_test_file(const char *_path,int *_error){\n  OpusFileCallbacks cb;\n  return op_test_close_on_failure(op_fopen(&cb,_path,\"rb\"),&cb,_error);\n}\n\nOggOpusFile *op_test_memory(const unsigned char *_data,size_t _size,\n int *_error){\n  OpusFileCallbacks cb;\n  return op_test_close_on_failure(op_mem_stream_create(&cb,_data,_size),&cb,\n   _error);\n}\n\nint op_test_open(OggOpusFile *_of){\n  int ret;\n  if(OP_UNLIKELY(_of->ready_state!=OP_PARTOPEN))return OP_EINVAL;\n  ret=op_open2(_of);\n  /*op_open2() will clear this structure on failure.\n    Reset its contents to prevent double-frees in op_free().*/\n  if(OP_UNLIKELY(ret<0))memset(_of,0,sizeof(*_of));\n  return ret;\n}\n\nvoid op_free(OggOpusFile *_of){\n  if(OP_LIKELY(_of!=NULL)){\n    op_clear(_of);\n    _ogg_free(_of);\n  }\n}\n\nint op_seekable(const OggOpusFile *_of){\n  return _of->seekable;\n}\n\nint op_link_count(const OggOpusFile *_of){\n  return _of->nlinks;\n}\n\nopus_uint32 op_serialno(const OggOpusFile *_of,int _li){\n  if(OP_UNLIKELY(_li>=_of->nlinks))_li=_of->nlinks-1;\n  if(!_of->seekable)_li=0;\n  return _of->links[_li<0?_of->cur_link:_li].serialno;\n}\n\nint op_channel_count(const OggOpusFile *_of,int _li){\n  return op_head(_of,_li)->channel_count;\n}\n\nopus_int64 op_raw_total(const OggOpusFile *_of,int _li){\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED)\n   ||OP_UNLIKELY(!_of->seekable)\n   ||OP_UNLIKELY(_li>=_of->nlinks)){\n    return OP_EINVAL;\n  }\n  if(_li<0)return _of->end;\n  return (_li+1>=_of->nlinks?_of->end:_of->links[_li+1].offset)\n   -(_li>0?_of->links[_li].offset:0);\n}\n\nogg_int64_t op_pcm_total(const OggOpusFile *_of,int _li){\n  OggOpusLink *links;\n  ogg_int64_t  pcm_total;\n  ogg_int64_t  diff;\n  int          nlinks;\n  nlinks=_of->nlinks;\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED)\n   ||OP_UNLIKELY(!_of->seekable)\n   ||OP_UNLIKELY(_li>=nlinks)){\n    return OP_EINVAL;\n  }\n  links=_of->links;\n  /*We verify that the granule position differences are larger than the\n     pre-skip and that the total duration does not overflow during link\n     enumeration, so we don't have to check here.*/\n  pcm_total=0;\n  if(_li<0){\n    pcm_total=links[nlinks-1].pcm_file_offset;\n    _li=nlinks-1;\n  }\n  OP_ALWAYS_TRUE(!op_granpos_diff(&diff,\n   links[_li].pcm_end,links[_li].pcm_start));\n  return pcm_total+(diff-links[_li].head.pre_skip);\n}\n\nconst OpusHead *op_head(const OggOpusFile *_of,int _li){\n  if(OP_UNLIKELY(_li>=_of->nlinks))_li=_of->nlinks-1;\n  if(!_of->seekable)_li=0;\n  return &_of->links[_li<0?_of->cur_link:_li].head;\n}\n\nconst OpusTags *op_tags(const OggOpusFile *_of,int _li){\n  if(OP_UNLIKELY(_li>=_of->nlinks))_li=_of->nlinks-1;\n  if(!_of->seekable){\n    if(_of->ready_state<OP_STREAMSET&&_of->ready_state!=OP_PARTOPEN){\n      return NULL;\n    }\n    _li=0;\n  }\n  else if(_li<0)_li=_of->ready_state>=OP_STREAMSET?_of->cur_link:0;\n  return &_of->links[_li].tags;\n}\n\nint op_current_link(const OggOpusFile *_of){\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;\n  return _of->cur_link;\n}\n\n/*Compute an average bitrate given a byte and sample count.\n  Return: The bitrate in bits per second.*/\nstatic opus_int32 op_calc_bitrate(opus_int64 _bytes,ogg_int64_t _samples){\n  if(OP_UNLIKELY(_samples<=0))return OP_INT32_MAX;\n  /*These rates are absurd, but let's handle them anyway.*/\n  if(OP_UNLIKELY(_bytes>(OP_INT64_MAX-(_samples>>1))/(48000*8))){\n    ogg_int64_t den;\n    if(OP_UNLIKELY(_bytes/(OP_INT32_MAX/(48000*8))>=_samples)){\n      return OP_INT32_MAX;\n    }\n    den=_samples/(48000*8);\n    return (opus_int32)((_bytes+(den>>1))/den);\n  }\n  /*This can't actually overflow in normal operation: even with a pre-skip of\n     545 2.5 ms frames with 8 streams running at 1282*8+1 bytes per packet\n     (1275 byte frames + Opus framing overhead + Ogg lacing values), that all\n     produce a single sample of decoded output, we still don't top 45 Mbps.\n    The only way to get bitrates larger than that is with excessive Opus\n     padding, more encoded streams than output channels, or lots and lots of\n     Ogg pages with no packets on them.*/\n  return (opus_int32)OP_MIN((_bytes*48000*8+(_samples>>1))/_samples,\n   OP_INT32_MAX);\n}\n\nopus_int32 op_bitrate(const OggOpusFile *_of,int _li){\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED)||OP_UNLIKELY(!_of->seekable)\n   ||OP_UNLIKELY(_li>=_of->nlinks)){\n    return OP_EINVAL;\n  }\n  return op_calc_bitrate(op_raw_total(_of,_li),op_pcm_total(_of,_li));\n}\n\nopus_int32 op_bitrate_instant(OggOpusFile *_of){\n  ogg_int64_t samples_tracked;\n  opus_int32  ret;\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;\n  samples_tracked=_of->samples_tracked;\n  if(OP_UNLIKELY(samples_tracked==0))return OP_FALSE;\n  ret=op_calc_bitrate(_of->bytes_tracked,samples_tracked);\n  _of->bytes_tracked=0;\n  _of->samples_tracked=0;\n  return ret;\n}\n\n/*Given a serialno, find a link with a corresponding Opus stream, if it exists.\n  Return: The index of the link to which the page belongs, or a negative number\n           if it was not a desired Opus bitstream section.*/\nstatic int op_get_link_from_serialno(const OggOpusFile *_of,int _cur_link,\n opus_int64 _page_offset,ogg_uint32_t _serialno){\n  const OggOpusLink *links;\n  int                nlinks;\n  int                li_lo;\n  int                li_hi;\n  OP_ASSERT(_of->seekable);\n  links=_of->links;\n  nlinks=_of->nlinks;\n  li_lo=0;\n  /*Start off by guessing we're just a multiplexed page in the current link.*/\n  li_hi=_cur_link+1<nlinks&&_page_offset<links[_cur_link+1].offset?\n   _cur_link+1:nlinks;\n  do{\n    if(_page_offset>=links[_cur_link].offset)li_lo=_cur_link;\n    else li_hi=_cur_link;\n    _cur_link=li_lo+(li_hi-li_lo>>1);\n  }\n  while(li_hi-li_lo>1);\n  /*We've identified the link that should contain this page.\n    Make sure it's a page we care about.*/\n  if(links[_cur_link].serialno!=_serialno)return OP_FALSE;\n  return _cur_link;\n}\n\n/*Fetch and process a page.\n  This handles the case where we're at a bitstream boundary and dumps the\n   decoding machine.\n  If the decoding machine is unloaded, it loads it.\n  It also keeps prev_packet_gp up to date (seek and read both use this).\n  Return: <0) Error, OP_HOLE (lost packet), or OP_EOF.\n           0) Got at least one audio data packet.*/\nstatic int op_fetch_and_process_page(OggOpusFile *_of,\n ogg_page *_og,opus_int64 _page_offset,int _spanp,int _ignore_holes){\n  OggOpusLink  *links;\n  ogg_uint32_t  cur_serialno;\n  int           seekable;\n  int           cur_link;\n  int           ret;\n  /*We shouldn't get here if we have unprocessed packets.*/\n  OP_ASSERT(_of->ready_state<OP_INITSET||_of->op_pos>=_of->op_count);\n  seekable=_of->seekable;\n  links=_of->links;\n  cur_link=seekable?_of->cur_link:0;\n  cur_serialno=links[cur_link].serialno;\n  /*Handle one page.*/\n  for(;;){\n    ogg_page og;\n    OP_ASSERT(_of->ready_state>=OP_OPENED);\n    /*If we were given a page to use, use it.*/\n    if(_og!=NULL){\n      *&og=*_og;\n      _og=NULL;\n    }\n    /*Keep reading until we get a page with the correct serialno.*/\n    else _page_offset=op_get_next_page(_of,&og,_of->end);\n    /*EOF: Leave uninitialized.*/\n    if(_page_offset<0)return _page_offset<OP_FALSE?(int)_page_offset:OP_EOF;\n    if(OP_LIKELY(_of->ready_state>=OP_STREAMSET)\n     &&cur_serialno!=(ogg_uint32_t)ogg_page_serialno(&og)){\n      /*Two possibilities:\n         1) Another stream is multiplexed into this logical section, or*/\n      if(OP_LIKELY(!ogg_page_bos(&og)))continue;\n      /* 2) Our decoding just traversed a bitstream boundary.*/\n      if(!_spanp)return OP_EOF;\n      if(OP_LIKELY(_of->ready_state>=OP_INITSET))op_decode_clear(_of);\n    }\n    /*Bitrate tracking: add the header's bytes here.\n      The body bytes are counted when we consume the packets.*/\n    else _of->bytes_tracked+=og.header_len;\n    /*Do we need to load a new machine before submitting the page?\n      This is different in the seekable and non-seekable cases.\n      In the seekable case, we already have all the header information loaded\n       and cached.\n      We just initialize the machine with it and continue on our merry way.\n      In the non-seekable (streaming) case, we'll only be at a boundary if we\n       just left the previous logical bitstream, and we're now nominally at the\n       header of the next bitstream.*/\n    if(OP_UNLIKELY(_of->ready_state<OP_STREAMSET)){\n      if(seekable){\n        ogg_uint32_t serialno;\n        serialno=ogg_page_serialno(&og);\n        /*Match the serialno to bitstream section.*/\n        OP_ASSERT(cur_link>=0&&cur_link<_of->nlinks);\n        if(links[cur_link].serialno!=serialno){\n          /*It wasn't a page from the current link.\n            Is it from the next one?*/\n          if(OP_LIKELY(cur_link+1<_of->nlinks&&links[cur_link+1].serialno==\n           serialno)){\n            cur_link++;\n          }\n          else{\n            int new_link;\n            new_link=\n             op_get_link_from_serialno(_of,cur_link,_page_offset,serialno);\n            /*Not a desired Opus bitstream section.\n              Keep trying.*/\n            if(new_link<0)continue;\n            cur_link=new_link;\n          }\n        }\n        cur_serialno=serialno;\n        _of->cur_link=cur_link;\n        ogg_stream_reset_serialno(&_of->os,serialno);\n        _of->ready_state=OP_STREAMSET;\n        /*If we're at the start of this link, initialize the granule position\n           and pre-skip tracking.*/\n        if(_page_offset<=links[cur_link].data_offset){\n          _of->prev_packet_gp=links[cur_link].pcm_start;\n          _of->prev_page_offset=-1;\n          _of->cur_discard_count=links[cur_link].head.pre_skip;\n          /*Ignore a hole at the start of a new link (this is common for\n             streams joined in the middle) or after seeking.*/\n          _ignore_holes=1;\n        }\n      }\n      else{\n        do{\n          /*We're streaming.\n            Fetch the two header packets, build the info struct.*/\n          ret=op_fetch_headers(_of,&links[0].head,&links[0].tags,\n           NULL,NULL,NULL,&og);\n          if(OP_UNLIKELY(ret<0))return ret;\n          /*op_find_initial_pcm_offset() will suppress any initial hole for us,\n             so no need to set _ignore_holes.*/\n          ret=op_find_initial_pcm_offset(_of,links,&og);\n          if(OP_UNLIKELY(ret<0))return ret;\n          _of->links[0].serialno=cur_serialno=_of->os.serialno;\n          _of->cur_link++;\n        }\n        /*If the link was empty, keep going, because we already have the\n           BOS page of the next one in og.*/\n        while(OP_UNLIKELY(ret>0));\n        /*If we didn't get any packets out of op_find_initial_pcm_offset(),\n           keep going (this is possible if end-trimming trimmed them all).*/\n        if(_of->op_count<=0)continue;\n        /*Otherwise, we're done.\n          TODO: This resets bytes_tracked, which misses the header bytes\n           already processed by op_find_initial_pcm_offset().*/\n        ret=op_make_decode_ready(_of);\n        if(OP_UNLIKELY(ret<0))return ret;\n        return 0;\n      }\n    }\n    /*The buffered page is the data we want, and we're ready for it.\n      Add it to the stream state.*/\n    if(OP_UNLIKELY(_of->ready_state==OP_STREAMSET)){\n      ret=op_make_decode_ready(_of);\n      if(OP_UNLIKELY(ret<0))return ret;\n    }\n    /*Extract all the packets from the current page.*/\n    ogg_stream_pagein(&_of->os,&og);\n    if(OP_LIKELY(_of->ready_state>=OP_INITSET)){\n      opus_int32 total_duration;\n      int        durations[255];\n      int        op_count;\n      int        report_hole;\n      report_hole=0;\n      total_duration=op_collect_audio_packets(_of,durations);\n      if(OP_UNLIKELY(total_duration<0)){\n        /*libogg reported a hole (a gap in the page sequence numbers).\n          Drain the packets from the page anyway.\n          If we don't, they'll still be there when we fetch the next page.\n          Then, when we go to pull out packets, we might get more than 255,\n           which would overrun our packet buffer.\n          We repeat this call until we get any actual packets, since we might\n           have buffered multiple out-of-sequence pages with no packets on\n           them.*/\n        do total_duration=op_collect_audio_packets(_of,durations);\n        while(total_duration<0);\n        if(!_ignore_holes){\n          /*Report the hole to the caller after we finish timestamping the\n             packets.*/\n          report_hole=1;\n          /*We had lost or damaged pages, so reset our granule position\n             tracking.\n            This makes holes behave the same as a small raw seek.\n            If the next page is the EOS page, we'll discard it (because we\n             can't perform end trimming properly), and we'll always discard at\n             least 80 ms of audio (to allow decoder state to re-converge).\n            We could try to fill in the gap with PLC by looking at timestamps\n             in the non-EOS case, but that's complicated and error prone and we\n             can't rely on the timestamps being valid.*/\n          _of->prev_packet_gp=-1;\n        }\n      }\n      op_count=_of->op_count;\n      /*If we found at least one audio data packet, compute per-packet granule\n         positions for them.*/\n      if(op_count>0){\n        ogg_int64_t diff;\n        ogg_int64_t prev_packet_gp;\n        ogg_int64_t cur_packet_gp;\n        ogg_int64_t cur_page_gp;\n        int         cur_page_eos;\n        int         pi;\n        cur_page_gp=_of->op[op_count-1].granulepos;\n        cur_page_eos=_of->op[op_count-1].e_o_s;\n        prev_packet_gp=_of->prev_packet_gp;\n        if(OP_UNLIKELY(prev_packet_gp==-1)){\n          opus_int32 cur_discard_count;\n          /*This is the first call after a raw seek.\n            Try to reconstruct prev_packet_gp from scratch.*/\n          OP_ASSERT(seekable);\n          if(OP_UNLIKELY(cur_page_eos)){\n            /*If the first page we hit after our seek was the EOS page, and\n               we didn't start from data_offset or before, we don't have\n               enough information to do end-trimming.\n              Proceed to the next link, rather than risk playing back some\n               samples that shouldn't have been played.*/\n            _of->op_count=0;\n            if(report_hole)return OP_HOLE;\n            continue;\n          }\n          /*By default discard 80 ms of data after a seek, unless we seek\n             into the pre-skip region.*/\n          cur_discard_count=80*48;\n          cur_page_gp=_of->op[op_count-1].granulepos;\n          /*Try to initialize prev_packet_gp.\n            If the current page had packets but didn't have a granule\n             position, or the granule position it had was too small (both\n             illegal), just use the starting granule position for the link.*/\n          prev_packet_gp=links[cur_link].pcm_start;\n          if(OP_LIKELY(cur_page_gp!=-1)){\n            op_granpos_add(&prev_packet_gp,cur_page_gp,-total_duration);\n          }\n          if(OP_LIKELY(!op_granpos_diff(&diff,\n           prev_packet_gp,links[cur_link].pcm_start))){\n            opus_int32 pre_skip;\n            /*If we start at the beginning of the pre-skip region, or we're\n               at least 80 ms from the end of the pre-skip region, we discard\n               to the end of the pre-skip region.\n              Otherwise, we still use the 80 ms default, which will discard\n               past the end of the pre-skip region.*/\n            pre_skip=links[cur_link].head.pre_skip;\n            if(diff>=0&&diff<=OP_MAX(0,pre_skip-80*48)){\n              cur_discard_count=pre_skip-(int)diff;\n            }\n          }\n          _of->cur_discard_count=cur_discard_count;\n        }\n        if(OP_UNLIKELY(cur_page_gp==-1)){\n          /*This page had completed packets but didn't have a valid granule\n             position.\n            This is illegal, but we'll try to handle it by continuing to count\n             forwards from the previous page.*/\n          if(op_granpos_add(&cur_page_gp,prev_packet_gp,total_duration)<0){\n            /*The timestamp for this page overflowed.*/\n            cur_page_gp=links[cur_link].pcm_end;\n          }\n        }\n        /*If we hit the last page, handle end-trimming.*/\n        if(OP_UNLIKELY(cur_page_eos)\n         &&OP_LIKELY(!op_granpos_diff(&diff,cur_page_gp,prev_packet_gp))\n         &&OP_LIKELY(diff<total_duration)){\n          cur_packet_gp=prev_packet_gp;\n          for(pi=0;pi<op_count;pi++){\n            /*Check for overflow.*/\n            if(diff<0&&OP_UNLIKELY(OP_INT64_MAX+diff<durations[pi])){\n              diff=durations[pi]+1;\n            }\n            else diff=durations[pi]-diff;\n            /*If we have samples to trim...*/\n            if(diff>0){\n              /*If we trimmed the entire packet, stop (the spec says encoders\n                 shouldn't do this, but we support it anyway).*/\n              if(OP_UNLIKELY(diff>durations[pi]))break;\n              cur_packet_gp=cur_page_gp;\n              /*Move the EOS flag to this packet, if necessary, so we'll trim\n                 the samples during decode.*/\n              _of->op[pi].e_o_s=1;\n            }\n            else{\n              /*Update the granule position as normal.*/\n              OP_ALWAYS_TRUE(!op_granpos_add(&cur_packet_gp,\n               cur_packet_gp,durations[pi]));\n            }\n            _of->op[pi].granulepos=cur_packet_gp;\n            OP_ALWAYS_TRUE(!op_granpos_diff(&diff,cur_page_gp,cur_packet_gp));\n          }\n        }\n        else{\n          /*Propagate timestamps to earlier packets.\n            op_granpos_add(&prev_packet_gp,prev_packet_gp,total_duration)\n             should succeed and give prev_packet_gp==cur_page_gp.\n            But we don't bother to check that, as there isn't much we can do\n             if it's not true, and it actually will not be true on the first\n             page after a seek, if there was a continued packet.\n            The only thing we guarantee is that the start and end granule\n             positions of the packets are valid, and that they are monotonic\n             within a page.\n            They might be completely out of range for this link (we'll check\n             that elsewhere), or non-monotonic between pages.*/\n          if(OP_UNLIKELY(op_granpos_add(&prev_packet_gp,\n           cur_page_gp,-total_duration)<0)){\n            /*The starting timestamp for the first packet on this page\n               underflowed.\n              This is illegal, but we ignore it.*/\n            prev_packet_gp=0;\n          }\n          for(pi=0;pi<op_count;pi++){\n            if(OP_UNLIKELY(op_granpos_add(&cur_packet_gp,\n             cur_page_gp,-total_duration)<0)){\n              /*The start timestamp for this packet underflowed.\n                This is illegal, but we ignore it.*/\n              cur_packet_gp=0;\n            }\n            total_duration-=durations[pi];\n            OP_ASSERT(total_duration>=0);\n            OP_ALWAYS_TRUE(!op_granpos_add(&cur_packet_gp,\n             cur_packet_gp,durations[pi]));\n            _of->op[pi].granulepos=cur_packet_gp;\n          }\n          OP_ASSERT(total_duration==0);\n        }\n        _of->prev_packet_gp=prev_packet_gp;\n        _of->prev_page_offset=_page_offset;\n        _of->op_count=op_count=pi;\n      }\n      if(report_hole)return OP_HOLE;\n      /*If end-trimming didn't trim all the packets, we're done.*/\n      if(op_count>0)return 0;\n    }\n  }\n}\n\nint op_raw_seek(OggOpusFile *_of,opus_int64 _pos){\n  int ret;\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;\n  /*Don't dump the decoder state if we can't seek.*/\n  if(OP_UNLIKELY(!_of->seekable))return OP_ENOSEEK;\n  if(OP_UNLIKELY(_pos<0)||OP_UNLIKELY(_pos>_of->end))return OP_EINVAL;\n  /*Clear out any buffered, decoded data.*/\n  op_decode_clear(_of);\n  _of->bytes_tracked=0;\n  _of->samples_tracked=0;\n  ret=op_seek_helper(_of,_pos);\n  if(OP_UNLIKELY(ret<0))return OP_EREAD;\n  ret=op_fetch_and_process_page(_of,NULL,-1,1,1);\n  /*If we hit EOF, op_fetch_and_process_page() leaves us uninitialized.\n    Instead, jump to the end.*/\n  if(ret==OP_EOF){\n    int cur_link;\n    op_decode_clear(_of);\n    cur_link=_of->nlinks-1;\n    _of->cur_link=cur_link;\n    _of->prev_packet_gp=_of->links[cur_link].pcm_end;\n    _of->cur_discard_count=0;\n    ret=0;\n  }\n  return ret;\n}\n\n/*Convert a PCM offset relative to the start of the whole stream to a granule\n   position in an individual link.*/\nstatic ogg_int64_t op_get_granulepos(const OggOpusFile *_of,\n ogg_int64_t _pcm_offset,int *_li){\n  const OggOpusLink *links;\n  ogg_int64_t        duration;\n  ogg_int64_t        pcm_start;\n  opus_int32         pre_skip;\n  int                nlinks;\n  int                li_lo;\n  int                li_hi;\n  OP_ASSERT(_pcm_offset>=0);\n  nlinks=_of->nlinks;\n  links=_of->links;\n  li_lo=0;\n  li_hi=nlinks;\n  do{\n    int li;\n    li=li_lo+(li_hi-li_lo>>1);\n    if(links[li].pcm_file_offset<=_pcm_offset)li_lo=li;\n    else li_hi=li;\n  }\n  while(li_hi-li_lo>1);\n  _pcm_offset-=links[li_lo].pcm_file_offset;\n  pcm_start=links[li_lo].pcm_start;\n  pre_skip=links[li_lo].head.pre_skip;\n  OP_ALWAYS_TRUE(!op_granpos_diff(&duration,links[li_lo].pcm_end,pcm_start));\n  duration-=pre_skip;\n  if(_pcm_offset>=duration)return -1;\n  _pcm_offset+=pre_skip;\n  if(OP_UNLIKELY(pcm_start>OP_INT64_MAX-_pcm_offset)){\n    /*Adding this amount to the granule position would overflow the positive\n       half of its 64-bit range.\n      Since signed overflow is undefined in C, do it in a way the compiler\n       isn't allowed to screw up.*/\n    _pcm_offset-=OP_INT64_MAX-pcm_start+1;\n    pcm_start=OP_INT64_MIN;\n  }\n  pcm_start+=_pcm_offset;\n  *_li=li_lo;\n  return pcm_start;\n}\n\n/*A small helper to determine if an Ogg page contains data that continues onto\n   a subsequent page.*/\nstatic int op_page_continues(const ogg_page *_og){\n  int nlacing;\n  OP_ASSERT(_og->header_len>=27);\n  nlacing=_og->header[26];\n  OP_ASSERT(_og->header_len>=27+nlacing);\n  /*This also correctly handles the (unlikely) case of nlacing==0, because\n     0!=255.*/\n  return _og->header[27+nlacing-1]==255;\n}\n\n/*A small helper to buffer the continued packet data from a page.*/\nstatic void op_buffer_continued_data(OggOpusFile *_of,ogg_page *_og){\n  ogg_packet op;\n  ogg_stream_pagein(&_of->os,_og);\n  /*Drain any packets that did end on this page (and ignore holes).\n    We only care about the continued packet data.*/\n  while(ogg_stream_packetout(&_of->os,&op));\n}\n\n/*This controls how close the target has to be to use the current stream\n   position to subdivide the initial range.\n  Two minutes seems to be a good default.*/\n#define OP_CUR_TIME_THRESH (120*48*(opus_int32)1000)\n\n/*Note: The OP_SMALL_FOOTPRINT #define doesn't (currently) save much code size,\n   but it's meant to serve as documentation for portions of the seeking\n   algorithm that are purely optional, to aid others learning from/porting this\n   code to other contexts.*/\n/*#define OP_SMALL_FOOTPRINT (1)*/\n\n/*Search within link _li for the page with the highest granule position\n   preceding (or equal to) _target_gp.\n  There is a danger here: missing pages or incorrect frame number information\n   in the bitstream could make our task impossible.\n  Account for that (and report it as an error condition).*/\nstatic int op_pcm_seek_page(OggOpusFile *_of,\n ogg_int64_t _target_gp,int _li){\n  const OggOpusLink *link;\n  ogg_page           og;\n  ogg_int64_t        pcm_pre_skip;\n  ogg_int64_t        pcm_start;\n  ogg_int64_t        pcm_end;\n  ogg_int64_t        best_gp;\n  ogg_int64_t        diff;\n  ogg_uint32_t       serialno;\n  opus_int32         pre_skip;\n  opus_int64         begin;\n  opus_int64         end;\n  opus_int64         boundary;\n  opus_int64         best;\n  opus_int64         best_start;\n  opus_int64         page_offset;\n  opus_int64         d0;\n  opus_int64         d1;\n  opus_int64         d2;\n  int                force_bisect;\n  int                buffering;\n  int                ret;\n  _of->bytes_tracked=0;\n  _of->samples_tracked=0;\n  link=_of->links+_li;\n  best_gp=pcm_start=link->pcm_start;\n  pcm_end=link->pcm_end;\n  serialno=link->serialno;\n  best=best_start=begin=link->data_offset;\n  page_offset=-1;\n  buffering=0;\n  /*We discard the first 80 ms of data after a seek, so seek back that much\n     farther.\n    If we can't, simply seek to the beginning of the link.*/\n  if(OP_UNLIKELY(op_granpos_add(&_target_gp,_target_gp,-80*48)<0)\n   ||OP_UNLIKELY(op_granpos_cmp(_target_gp,pcm_start)<0)){\n    _target_gp=pcm_start;\n  }\n  /*Special case seeking to the start of the link.*/\n  pre_skip=link->head.pre_skip;\n  OP_ALWAYS_TRUE(!op_granpos_add(&pcm_pre_skip,pcm_start,pre_skip));\n  if(op_granpos_cmp(_target_gp,pcm_pre_skip)<0)end=boundary=begin;\n  else{\n    end=boundary=link->end_offset;\n#if !defined(OP_SMALL_FOOTPRINT)\n    /*If we were decoding from this link, we can narrow the range a bit.*/\n    if(_li==_of->cur_link&&_of->ready_state>=OP_INITSET){\n      opus_int64 offset;\n      int        op_count;\n      op_count=_of->op_count;\n      /*The offset can be out of range if we were reading through the stream\n         and encountered a page with the granule position for another link\n         outside of the data range identified during link enumeration when we\n         were opening the file.\n        We will just ignore the current position in that case.\n        The only way the offset can be valid _and_ we can fail the granule\n         position checks below is if someone changed the contents of the last\n         page since we read it.\n        We'd be within our rights to just return OP_EBADLINK, but instead we'll\n         simply ignore the current position in that case, too.*/\n      offset=_of->offset;\n      if(op_count>0&&OP_LIKELY(begin<=offset&&offset<=end)){\n        ogg_int64_t gp;\n        /*Make sure the timestamp is valid.\n          The granule position might be -1 if we collected the packets from a\n           page without a granule position after reporting a hole.*/\n        gp=_of->op[op_count-1].granulepos;\n        if(OP_LIKELY(gp!=-1)&&OP_LIKELY(op_granpos_cmp(pcm_start,gp)<0)\n         &&OP_LIKELY(op_granpos_cmp(pcm_end,gp)>0)){\n          OP_ALWAYS_TRUE(!op_granpos_diff(&diff,gp,_target_gp));\n          /*We only actually use the current time if either\n            a) We can cut off at least half the range, or\n            b) We're seeking sufficiently close to the current position that\n                it's likely to be informative.\n            Otherwise it appears using the whole link range to estimate the\n             first seek location gives better results, on average.*/\n          if(diff<0){\n            if(offset-begin>=end-begin>>1||diff>-OP_CUR_TIME_THRESH){\n              best=begin=offset;\n              best_gp=pcm_start=gp;\n              /*If we have buffered data from a continued packet, remember the\n                 offset of the previous page's start, so that if we do wind up\n                 having to seek back here later, we can prime the stream with\n                 the continued packet data.\n                With no continued packet, we remember the end of the page.*/\n              best_start=_of->os.body_returned<_of->os.body_fill?\n               _of->prev_page_offset:best;\n              /*If there's completed packets and data in the stream state,\n                 prev_page_offset should always be set.*/\n              OP_ASSERT(best_start>=0);\n              /*Buffer any continued packet data starting from here.*/\n              buffering=1;\n            }\n          }\n          else{\n            ogg_int64_t prev_page_gp;\n            /*We might get lucky and already have the packet with the target\n               buffered.\n              Worth checking.\n              For very small files (with all of the data in a single page,\n               generally 1 second or less), we can loop them continuously\n               without seeking at all.*/\n            if(op_granpos_add(&prev_page_gp,_of->op[0].granulepos,\n             -op_get_packet_duration(_of->op[0].packet,_of->op[0].bytes))<0) {\n              /*We validate/sanitize the per-packet timestamps, so the only way\n                 we should fail to calculate a granule position for the\n                 previous page is if the first page with completed packets in\n                 the stream is also the last, and end-trimming causes the\n                 apparent granule position preceding the first sample in the\n                 first packet to underflow.\n                The starting PCM offset is then 0 by spec mandate (see also:\n                 op_find_initial_pcm_offset()).*/\n              OP_ASSERT(_of->op[0].e_o_s);\n              prev_page_gp=0;\n            }\n            if(op_granpos_cmp(prev_page_gp,_target_gp)<=0){\n              /*Don't call op_decode_clear(), because it will dump our\n                 packets.*/\n              _of->op_pos=0;\n              _of->od_buffer_size=0;\n              _of->prev_packet_gp=prev_page_gp;\n              /*_of->prev_page_offset already points to the right place.*/\n              _of->ready_state=OP_STREAMSET;\n              return op_make_decode_ready(_of);\n            }\n            /*No such luck.\n              Check if we can cut off at least half the range, though.*/\n            if(offset-begin<=end-begin>>1||diff<OP_CUR_TIME_THRESH){\n              /*We really want the page start here, but this will do.*/\n              end=boundary=offset;\n              pcm_end=gp;\n            }\n          }\n        }\n      }\n    }\n#endif\n  }\n  /*This code was originally based on the \"new search algorithm by HB (Nicholas\n     Vinen)\" from libvorbisfile.\n    It has been modified substantially since.*/\n  op_decode_clear(_of);\n  if(!buffering)ogg_stream_reset_serialno(&_of->os,serialno);\n  _of->cur_link=_li;\n  _of->ready_state=OP_STREAMSET;\n  /*Initialize the interval size history.*/\n  d2=d1=d0=end-begin;\n  force_bisect=0;\n  while(begin<end){\n    opus_int64 bisect;\n    opus_int64 next_boundary;\n    opus_int32 chunk_size;\n    if(end-begin<OP_CHUNK_SIZE)bisect=begin;\n    else{\n      /*Update the interval size history.*/\n      d0=d1>>1;\n      d1=d2>>1;\n      d2=end-begin>>1;\n      if(force_bisect)bisect=begin+(end-begin>>1);\n      else{\n        ogg_int64_t diff2;\n        OP_ALWAYS_TRUE(!op_granpos_diff(&diff,_target_gp,pcm_start));\n        OP_ALWAYS_TRUE(!op_granpos_diff(&diff2,pcm_end,pcm_start));\n        /*Take a (pretty decent) guess.*/\n        bisect=begin+op_rescale64(diff,diff2,end-begin)-OP_CHUNK_SIZE;\n      }\n      if(bisect-OP_CHUNK_SIZE<begin)bisect=begin;\n      force_bisect=0;\n    }\n    if(bisect!=_of->offset){\n      /*Discard any buffered continued packet data.*/\n      if(buffering)ogg_stream_reset(&_of->os);\n      buffering=0;\n      page_offset=-1;\n      ret=op_seek_helper(_of,bisect);\n      if(OP_UNLIKELY(ret<0))return ret;\n    }\n    chunk_size=OP_CHUNK_SIZE;\n    next_boundary=boundary;\n    /*Now scan forward and figure out where we landed.\n      In the ideal case, we will see a page with a granule position at or\n       before our target, followed by a page with a granule position after our\n       target (or the end of the search interval).\n      Then we can just drop out and will have all of the data we need with no\n       additional seeking.\n      If we landed too far before, or after, we'll break out and do another\n       bisection.*/\n    while(begin<end){\n      page_offset=op_get_next_page(_of,&og,boundary);\n      if(page_offset<0){\n        if(page_offset<OP_FALSE)return (int)page_offset;\n        /*There are no more pages in our interval from our stream with a valid\n           timestamp that start at position bisect or later.*/\n        /*If we scanned the whole interval, we're done.*/\n        if(bisect<=begin+1)end=begin;\n        else{\n          /*Otherwise, back up one chunk.\n            First, discard any data from a continued packet.*/\n          if(buffering)ogg_stream_reset(&_of->os);\n          buffering=0;\n          bisect=OP_MAX(bisect-chunk_size,begin);\n          ret=op_seek_helper(_of,bisect);\n          if(OP_UNLIKELY(ret<0))return ret;\n          /*Bump up the chunk size.*/\n          chunk_size=OP_MIN(2*chunk_size,OP_CHUNK_SIZE_MAX);\n          /*If we did find a page from another stream or without a timestamp,\n             don't read past it.*/\n          boundary=next_boundary;\n        }\n      }\n      else{\n        ogg_int64_t gp;\n        int         has_packets;\n        /*Save the offset of the first page we found after the seek, regardless\n           of the stream it came from or whether or not it has a timestamp.*/\n        next_boundary=OP_MIN(page_offset,next_boundary);\n        if(serialno!=(ogg_uint32_t)ogg_page_serialno(&og))continue;\n        has_packets=ogg_page_packets(&og)>0;\n        /*Force the gp to -1 (as it should be per spec) if no packets end on\n           this page.\n          Otherwise we might get confused when we try to pull out a packet\n           with that timestamp and can't find it.*/\n        gp=has_packets?ogg_page_granulepos(&og):-1;\n        if(gp==-1){\n          if(buffering){\n            if(OP_LIKELY(!has_packets))ogg_stream_pagein(&_of->os,&og);\n            else{\n              /*If packets did end on this page, but we still didn't have a\n                 valid granule position (in violation of the spec!), stop\n                 buffering continued packet data.\n                Otherwise we might continue past the packet we actually\n                 wanted.*/\n              ogg_stream_reset(&_of->os);\n              buffering=0;\n            }\n          }\n          continue;\n        }\n        if(op_granpos_cmp(gp,_target_gp)<0){\n          /*We found a page that ends before our target.\n            Advance to the raw offset of the next page.*/\n          begin=_of->offset;\n          if(OP_UNLIKELY(op_granpos_cmp(pcm_start,gp)>0)\n           ||OP_UNLIKELY(op_granpos_cmp(pcm_end,gp)<0)){\n            /*Don't let pcm_start get out of range!\n              That could happen with an invalid timestamp.*/\n            break;\n          }\n          /*Save the byte offset of the end of the page with this granule\n             position.*/\n          best=best_start=begin;\n          /*Buffer any data from a continued packet, if necessary.\n            This avoids the need to seek back here if the next timestamp we\n             encounter while scanning forward lies after our target.*/\n          if(buffering)ogg_stream_reset(&_of->os);\n          if(op_page_continues(&og)){\n            op_buffer_continued_data(_of,&og);\n            /*If we have a continued packet, remember the offset of this\n               page's start, so that if we do wind up having to seek back here\n               later, we can prime the stream with the continued packet data.\n              With no continued packet, we remember the end of the page.*/\n            best_start=page_offset;\n          }\n          /*Then force buffering on, so that if a packet starts (but does not\n             end) on the next page, we still avoid the extra seek back.*/\n          buffering=1;\n          best_gp=pcm_start=gp;\n          OP_ALWAYS_TRUE(!op_granpos_diff(&diff,_target_gp,pcm_start));\n          /*If we're more than a second away from our target, break out and\n             do another bisection.*/\n          if(diff>48000)break;\n          /*Otherwise, keep scanning forward (do NOT use begin+1).*/\n          bisect=begin;\n        }\n        else{\n          /*We found a page that ends after our target.*/\n          /*If we scanned the whole interval before we found it, we're done.*/\n          if(bisect<=begin+1)end=begin;\n          else{\n            end=bisect;\n            /*In later iterations, don't read past the first page we found.*/\n            boundary=next_boundary;\n            /*If we're not making much progress shrinking the interval size,\n               start forcing straight bisection to limit the worst case.*/\n            force_bisect=end-begin>d0*2;\n            /*Don't let pcm_end get out of range!\n              That could happen with an invalid timestamp.*/\n            if(OP_LIKELY(op_granpos_cmp(pcm_end,gp)>0)\n             &&OP_LIKELY(op_granpos_cmp(pcm_start,gp)<=0)){\n              pcm_end=gp;\n            }\n            break;\n          }\n        }\n      }\n    }\n  }\n  /*Found our page.*/\n  OP_ASSERT(op_granpos_cmp(best_gp,pcm_start)>=0);\n  /*Seek, if necessary.\n    If we were buffering data from a continued packet, we should be able to\n     continue to scan forward to get the rest of the data (even if\n     page_offset==-1).\n    Otherwise, we need to seek back to best_start.*/\n  if(!buffering){\n    if(best_start!=page_offset){\n      page_offset=-1;\n      ret=op_seek_helper(_of,best_start);\n      if(OP_UNLIKELY(ret<0))return ret;\n    }\n    if(best_start<best){\n      /*Retrieve the page at best_start, if we do not already have it.*/\n      if(page_offset<0){\n        page_offset=op_get_next_page(_of,&og,link->end_offset);\n        if(OP_UNLIKELY(page_offset<OP_FALSE))return (int)page_offset;\n        if(OP_UNLIKELY(page_offset!=best_start))return OP_EBADLINK;\n      }\n      op_buffer_continued_data(_of,&og);\n      page_offset=-1;\n    }\n  }\n  /*Update prev_packet_gp to allow per-packet granule position assignment.*/\n  _of->prev_packet_gp=best_gp;\n  _of->prev_page_offset=best_start;\n  ret=op_fetch_and_process_page(_of,page_offset<0?NULL:&og,page_offset,0,1);\n  if(OP_UNLIKELY(ret<0))return OP_EBADLINK;\n  /*Verify result.*/\n  if(OP_UNLIKELY(op_granpos_cmp(_of->prev_packet_gp,_target_gp)>0)){\n    return OP_EBADLINK;\n  }\n  /*Our caller will set cur_discard_count to handle pre-roll.*/\n  return 0;\n}\n\nint op_pcm_seek(OggOpusFile *_of,ogg_int64_t _pcm_offset){\n  const OggOpusLink *link;\n  ogg_int64_t        pcm_start;\n  ogg_int64_t        target_gp;\n  ogg_int64_t        prev_packet_gp;\n  ogg_int64_t        skip;\n  ogg_int64_t        diff;\n  int                op_count;\n  int                op_pos;\n  int                ret;\n  int                li;\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;\n  if(OP_UNLIKELY(!_of->seekable))return OP_ENOSEEK;\n  if(OP_UNLIKELY(_pcm_offset<0))return OP_EINVAL;\n  target_gp=op_get_granulepos(_of,_pcm_offset,&li);\n  if(OP_UNLIKELY(target_gp==-1))return OP_EINVAL;\n  link=_of->links+li;\n  pcm_start=link->pcm_start;\n  OP_ALWAYS_TRUE(!op_granpos_diff(&_pcm_offset,target_gp,pcm_start));\n#if !defined(OP_SMALL_FOOTPRINT)\n  /*For small (90 ms or less) forward seeks within the same link, just decode\n     forward.\n    This also optimizes the case of seeking to the current position.*/\n  if(li==_of->cur_link&&_of->ready_state>=OP_INITSET){\n    ogg_int64_t gp;\n    gp=_of->prev_packet_gp;\n    if(OP_LIKELY(gp!=-1)){\n      ogg_int64_t discard_count;\n      int         nbuffered;\n      nbuffered=OP_MAX(_of->od_buffer_size-_of->od_buffer_pos,0);\n      OP_ALWAYS_TRUE(!op_granpos_add(&gp,gp,-nbuffered));\n      /*We do _not_ add cur_discard_count to gp.\n        Otherwise the total amount to discard could grow without bound, and it\n         would be better just to do a full seek.*/\n      if(OP_LIKELY(!op_granpos_diff(&discard_count,target_gp,gp))){\n        /*We use a threshold of 90 ms instead of 80, since 80 ms is the\n           _minimum_ we would have discarded after a full seek.\n          Assuming 20 ms frames (the default), we'd discard 90 ms on average.*/\n        if(discard_count>=0&&OP_UNLIKELY(discard_count<90*48)){\n          _of->cur_discard_count=(opus_int32)discard_count;\n          return 0;\n        }\n      }\n    }\n  }\n#endif\n  ret=op_pcm_seek_page(_of,target_gp,li);\n  if(OP_UNLIKELY(ret<0))return ret;\n  /*Now skip samples until we actually get to our target.*/\n  /*Figure out where we should skip to.*/\n  if(_pcm_offset<=link->head.pre_skip)skip=0;\n  else skip=OP_MAX(_pcm_offset-80*48,0);\n  OP_ASSERT(_pcm_offset-skip>=0);\n  OP_ASSERT(_pcm_offset-skip<OP_INT32_MAX-120*48);\n  /*Skip packets until we find one with samples past our skip target.*/\n  for(;;){\n    op_count=_of->op_count;\n    prev_packet_gp=_of->prev_packet_gp;\n    for(op_pos=_of->op_pos;op_pos<op_count;op_pos++){\n      ogg_int64_t cur_packet_gp;\n      cur_packet_gp=_of->op[op_pos].granulepos;\n      if(OP_LIKELY(!op_granpos_diff(&diff,cur_packet_gp,pcm_start))\n       &&diff>skip){\n        break;\n      }\n      prev_packet_gp=cur_packet_gp;\n    }\n    _of->prev_packet_gp=prev_packet_gp;\n    _of->op_pos=op_pos;\n    if(op_pos<op_count)break;\n    /*We skipped all the packets on this page.\n      Fetch another.*/\n    ret=op_fetch_and_process_page(_of,NULL,-1,0,1);\n    if(OP_UNLIKELY(ret<0))return OP_EBADLINK;\n  }\n  /*We skipped too far, or couldn't get within 2 billion samples of the target.\n    Either the timestamps were illegal or there was a hole in the data.*/\n  if(op_granpos_diff(&diff,prev_packet_gp,pcm_start)||diff>skip\n   ||_pcm_offset-diff>=OP_INT32_MAX){\n    return OP_EBADLINK;\n  }\n  /*TODO: If there are further holes/illegal timestamps, we still won't decode\n     to the correct sample.\n    However, at least op_pcm_tell() will report the correct value immediately\n     after returning.*/\n  _of->cur_discard_count=(opus_int32)(_pcm_offset-diff);\n  return 0;\n}\n\nopus_int64 op_raw_tell(const OggOpusFile *_of){\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;\n  return _of->offset;\n}\n\n/*Convert a granule position from a given link to a PCM offset relative to the\n   start of the whole stream.\n  For unseekable sources, this gets reset to 0 at the beginning of each link.*/\nstatic ogg_int64_t op_get_pcm_offset(const OggOpusFile *_of,\n ogg_int64_t _gp,int _li){\n  const OggOpusLink *links;\n  ogg_int64_t        pcm_offset;\n  links=_of->links;\n  OP_ASSERT(_li>=0&&_li<_of->nlinks);\n  pcm_offset=links[_li].pcm_file_offset;\n  if(_of->seekable&&OP_UNLIKELY(op_granpos_cmp(_gp,links[_li].pcm_end)>0)){\n    _gp=links[_li].pcm_end;\n  }\n  if(OP_LIKELY(op_granpos_cmp(_gp,links[_li].pcm_start)>0)){\n    ogg_int64_t delta;\n    if(OP_UNLIKELY(op_granpos_diff(&delta,_gp,links[_li].pcm_start)<0)){\n      /*This means an unseekable stream claimed to have a page from more than\n         2 billion days after we joined.*/\n      OP_ASSERT(!_of->seekable);\n      return OP_INT64_MAX;\n    }\n    if(delta<links[_li].head.pre_skip)delta=0;\n    else delta-=links[_li].head.pre_skip;\n    /*In the seekable case, _gp was limited by pcm_end.\n      In the unseekable case, pcm_offset should be 0.*/\n    OP_ASSERT(pcm_offset<=OP_INT64_MAX-delta);\n    pcm_offset+=delta;\n  }\n  return pcm_offset;\n}\n\nogg_int64_t op_pcm_tell(const OggOpusFile *_of){\n  ogg_int64_t gp;\n  int         nbuffered;\n  int         li;\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;\n  gp=_of->prev_packet_gp;\n  if(gp==-1)return 0;\n  nbuffered=OP_MAX(_of->od_buffer_size-_of->od_buffer_pos,0);\n  OP_ALWAYS_TRUE(!op_granpos_add(&gp,gp,-nbuffered));\n  li=_of->seekable?_of->cur_link:0;\n  if(op_granpos_add(&gp,gp,_of->cur_discard_count)<0){\n    gp=_of->links[li].pcm_end;\n  }\n  return op_get_pcm_offset(_of,gp,li);\n}\n\nvoid op_set_decode_callback(OggOpusFile *_of,\n op_decode_cb_func _decode_cb,void *_ctx){\n  _of->decode_cb=_decode_cb;\n  _of->decode_cb_ctx=_ctx;\n}\n\nint op_set_gain_offset(OggOpusFile *_of,\n int _gain_type,opus_int32 _gain_offset_q8){\n  if(_gain_type!=OP_HEADER_GAIN&&_gain_type!=OP_ALBUM_GAIN\n   &&_gain_type!=OP_TRACK_GAIN&&_gain_type!=OP_ABSOLUTE_GAIN){\n    return OP_EINVAL;\n  }\n  _of->gain_type=_gain_type;\n  /*The sum of header gain and track gain lies in the range [-65536,65534].\n    These bounds allow the offset to set the final value to anywhere in the\n     range [-32768,32767], which is what we'll clamp it to before applying.*/\n  _of->gain_offset_q8=OP_CLAMP(-98302,_gain_offset_q8,98303);\n  op_update_gain(_of);\n  return 0;\n}\n\nvoid op_set_dither_enabled(OggOpusFile *_of,int _enabled){\n#if !defined(OP_FIXED_POINT)\n  _of->dither_disabled=!_enabled;\n  if(!_enabled)_of->dither_mute=65;\n#endif\n}\n\n/*Allocate the decoder scratch buffer.\n  This is done lazily, since if the user provides large enough buffers, we'll\n   never need it.*/\nstatic int op_init_buffer(OggOpusFile *_of){\n  int nchannels_max;\n  if(_of->seekable){\n    const OggOpusLink *links;\n    int                nlinks;\n    int                li;\n    links=_of->links;\n    nlinks=_of->nlinks;\n    nchannels_max=1;\n    for(li=0;li<nlinks;li++){\n      nchannels_max=OP_MAX(nchannels_max,links[li].head.channel_count);\n    }\n  }\n  else nchannels_max=OP_NCHANNELS_MAX;\n  _of->od_buffer=(op_sample *)_ogg_malloc(\n   sizeof(*_of->od_buffer)*nchannels_max*120*48);\n  if(_of->od_buffer==NULL)return OP_EFAULT;\n  return 0;\n}\n\n/*Decode a single packet into the target buffer.*/\nstatic int op_decode(OggOpusFile *_of,op_sample *_pcm,\n const ogg_packet *_op,int _nsamples,int _nchannels){\n  int ret;\n  /*First we try using the application-provided decode callback.*/\n  if(_of->decode_cb!=NULL){\n#if defined(OP_FIXED_POINT)\n    ret=(*_of->decode_cb)(_of->decode_cb_ctx,_of->od,_pcm,_op,\n     _nsamples,_nchannels,OP_DEC_FORMAT_SHORT,_of->cur_link);\n#else\n    ret=(*_of->decode_cb)(_of->decode_cb_ctx,_of->od,_pcm,_op,\n     _nsamples,_nchannels,OP_DEC_FORMAT_FLOAT,_of->cur_link);\n#endif\n  }\n  else ret=OP_DEC_USE_DEFAULT;\n  /*If the application didn't want to handle decoding, do it ourselves.*/\n  if(ret==OP_DEC_USE_DEFAULT){\n#if defined(OP_FIXED_POINT)\n    ret=opus_multistream_decode(_of->od,\n     _op->packet,_op->bytes,_pcm,_nsamples,0);\n#else\n    ret=opus_multistream_decode_float(_of->od,\n     _op->packet,_op->bytes,_pcm,_nsamples,0);\n#endif\n    OP_ASSERT(ret<0||ret==_nsamples);\n  }\n  /*If the application returned a positive value other than 0 or\n     OP_DEC_USE_DEFAULT, fail.*/\n  else if(OP_UNLIKELY(ret>0))return OP_EBADPACKET;\n  if(OP_UNLIKELY(ret<0))return OP_EBADPACKET;\n  return ret;\n}\n\n/*Read more samples from the stream, using the same API as op_read() or\n   op_read_float().*/\nstatic int op_read_native(OggOpusFile *_of,\n op_sample *_pcm,int _buf_size,int *_li){\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;\n  for(;;){\n    int ret;\n    if(OP_LIKELY(_of->ready_state>=OP_INITSET)){\n      int nchannels;\n      int od_buffer_pos;\n      int nsamples;\n      int op_pos;\n      nchannels=_of->links[_of->seekable?_of->cur_link:0].head.channel_count;\n      od_buffer_pos=_of->od_buffer_pos;\n      nsamples=_of->od_buffer_size-od_buffer_pos;\n      /*If we have buffered samples, return them.*/\n      if(nsamples>0){\n        if(nsamples*nchannels>_buf_size)nsamples=_buf_size/nchannels;\n        OP_ASSERT(_pcm!=NULL||nsamples<=0);\n        /*Check nsamples again so we don't pass NULL to memcpy() if _buf_size\n           is zero.\n          That would technically be undefined behavior, even if the number of\n           bytes to copy were zero.*/\n        if(nsamples>0){\n          memcpy(_pcm,_of->od_buffer+nchannels*od_buffer_pos,\n           sizeof(*_pcm)*nchannels*nsamples);\n          od_buffer_pos+=nsamples;\n          _of->od_buffer_pos=od_buffer_pos;\n        }\n        if(_li!=NULL)*_li=_of->cur_link;\n        return nsamples;\n      }\n      /*If we have buffered packets, decode one.*/\n      op_pos=_of->op_pos;\n      if(OP_LIKELY(op_pos<_of->op_count)){\n        const ogg_packet *pop;\n        ogg_int64_t       diff;\n        opus_int32        cur_discard_count;\n        int               duration;\n        int               trimmed_duration;\n        pop=_of->op+op_pos++;\n        _of->op_pos=op_pos;\n        cur_discard_count=_of->cur_discard_count;\n        duration=op_get_packet_duration(pop->packet,pop->bytes);\n        /*We don't buffer packets with an invalid TOC sequence.*/\n        OP_ASSERT(duration>0);\n        trimmed_duration=duration;\n        /*Perform end-trimming.*/\n        if(OP_UNLIKELY(pop->e_o_s)){\n          if(OP_UNLIKELY(op_granpos_cmp(pop->granulepos,\n           _of->prev_packet_gp)<=0)){\n            trimmed_duration=0;\n          }\n          else if(OP_LIKELY(!op_granpos_diff(&diff,\n           pop->granulepos,_of->prev_packet_gp))){\n            trimmed_duration=(int)OP_MIN(diff,trimmed_duration);\n          }\n        }\n        _of->prev_packet_gp=pop->granulepos;\n        if(OP_UNLIKELY(duration*nchannels>_buf_size)){\n          op_sample *buf;\n          /*If the user's buffer is too small, decode into a scratch buffer.*/\n          buf=_of->od_buffer;\n          if(OP_UNLIKELY(buf==NULL)){\n            ret=op_init_buffer(_of);\n            if(OP_UNLIKELY(ret<0))return ret;\n            buf=_of->od_buffer;\n          }\n          ret=op_decode(_of,buf,pop,duration,nchannels);\n          if(OP_UNLIKELY(ret<0))return ret;\n          /*Perform pre-skip/pre-roll.*/\n          od_buffer_pos=(int)OP_MIN(trimmed_duration,cur_discard_count);\n          cur_discard_count-=od_buffer_pos;\n          _of->cur_discard_count=cur_discard_count;\n          _of->od_buffer_pos=od_buffer_pos;\n          _of->od_buffer_size=trimmed_duration;\n          /*Update bitrate tracking based on the actual samples we used from\n             what was decoded.*/\n          _of->bytes_tracked+=pop->bytes;\n          _of->samples_tracked+=trimmed_duration-od_buffer_pos;\n        }\n        else{\n          OP_ASSERT(_pcm!=NULL);\n          /*Otherwise decode directly into the user's buffer.*/\n          ret=op_decode(_of,_pcm,pop,duration,nchannels);\n          if(OP_UNLIKELY(ret<0))return ret;\n          if(OP_LIKELY(trimmed_duration>0)){\n            /*Perform pre-skip/pre-roll.*/\n            od_buffer_pos=(int)OP_MIN(trimmed_duration,cur_discard_count);\n            cur_discard_count-=od_buffer_pos;\n            _of->cur_discard_count=cur_discard_count;\n            trimmed_duration-=od_buffer_pos;\n            if(OP_LIKELY(trimmed_duration>0)\n             &&OP_UNLIKELY(od_buffer_pos>0)){\n              memmove(_pcm,_pcm+od_buffer_pos*nchannels,\n               sizeof(*_pcm)*trimmed_duration*nchannels);\n            }\n            /*Update bitrate tracking based on the actual samples we used from\n               what was decoded.*/\n            _of->bytes_tracked+=pop->bytes;\n            _of->samples_tracked+=trimmed_duration;\n            if(OP_LIKELY(trimmed_duration>0)){\n              if(_li!=NULL)*_li=_of->cur_link;\n              return trimmed_duration;\n            }\n          }\n        }\n        /*Don't grab another page yet.\n          This one might have more packets, or might have buffered data now.*/\n        continue;\n      }\n    }\n    /*Suck in another page.*/\n    ret=op_fetch_and_process_page(_of,NULL,-1,1,0);\n    if(OP_UNLIKELY(ret==OP_EOF)){\n      if(_li!=NULL)*_li=_of->cur_link;\n      return 0;\n    }\n    if(OP_UNLIKELY(ret<0))return ret;\n  }\n}\n\n/*A generic filter to apply to the decoded audio data.\n  _src is non-const because we will destructively modify the contents of the\n   source buffer that we consume in some cases.*/\ntypedef int (*op_read_filter_func)(OggOpusFile *_of,void *_dst,int _dst_sz,\n op_sample *_src,int _nsamples,int _nchannels);\n\n/*Decode some samples and then apply a custom filter to them.\n  This is used to convert to different output formats.*/\nstatic int op_filter_read_native(OggOpusFile *_of,void *_dst,int _dst_sz,\n op_read_filter_func _filter,int *_li){\n  int ret;\n  /*Ensure we have some decoded samples in our buffer.*/\n  ret=op_read_native(_of,NULL,0,_li);\n  /*Now apply the filter to them.*/\n  if(OP_LIKELY(ret>=0)&&OP_LIKELY(_of->ready_state>=OP_INITSET)){\n    int od_buffer_pos;\n    od_buffer_pos=_of->od_buffer_pos;\n    ret=_of->od_buffer_size-od_buffer_pos;\n    if(OP_LIKELY(ret>0)){\n      int nchannels;\n      nchannels=_of->links[_of->seekable?_of->cur_link:0].head.channel_count;\n      ret=(*_filter)(_of,_dst,_dst_sz,\n       _of->od_buffer+nchannels*od_buffer_pos,ret,nchannels);\n      OP_ASSERT(ret>=0);\n      OP_ASSERT(ret<=_of->od_buffer_size-od_buffer_pos);\n      od_buffer_pos+=ret;\n      _of->od_buffer_pos=od_buffer_pos;\n    }\n  }\n  return ret;\n}\n\n#if !defined(OP_FIXED_POINT)||!defined(OP_DISABLE_FLOAT_API)\n\n/*Matrices for downmixing from the supported channel counts to stereo.\n  The matrices with 5 or more channels are normalized to a total volume of 2.0,\n   since most mixes sound too quiet if normalized to 1.0 (as there is generally\n   little volume in the side/rear channels).*/\nstatic const float OP_STEREO_DOWNMIX[OP_NCHANNELS_MAX-2][OP_NCHANNELS_MAX][2]={\n  /*3.0*/\n  {\n    {0.5858F,0.0F},{0.4142F,0.4142F},{0.0F,0.5858F}\n  },\n  /*quadrophonic*/\n  {\n    {0.4226F,0.0F},{0.0F,0.4226F},{0.366F,0.2114F},{0.2114F,0.336F}\n  },\n  /*5.0*/\n  {\n    {0.651F,0.0F},{0.46F,0.46F},{0.0F,0.651F},{0.5636F,0.3254F},\n    {0.3254F,0.5636F}\n  },\n  /*5.1*/\n  {\n    {0.529F,0.0F},{0.3741F,0.3741F},{0.0F,0.529F},{0.4582F,0.2645F},\n    {0.2645F,0.4582F},{0.3741F,0.3741F}\n  },\n  /*6.1*/\n  {\n    {0.4553F,0.0F},{0.322F,0.322F},{0.0F,0.4553F},{0.3943F,0.2277F},\n    {0.2277F,0.3943F},{0.2788F,0.2788F},{0.322F,0.322F}\n  },\n  /*7.1*/\n  {\n    {0.3886F,0.0F},{0.2748F,0.2748F},{0.0F,0.3886F},{0.3366F,0.1943F},\n    {0.1943F,0.3366F},{0.3366F,0.1943F},{0.1943F,0.3366F},{0.2748F,0.2748F}\n  }\n};\n\n#endif\n\n#if defined(OP_FIXED_POINT)\n\n/*Matrices for downmixing from the supported channel counts to stereo.\n  The matrices with 5 or more channels are normalized to a total volume of 2.0,\n   since most mixes sound too quiet if normalized to 1.0 (as there is generally\n   little volume in the side/rear channels).\n  Hence we keep the coefficients in Q14, so the downmix values won't overflow a\n   32-bit number.*/\nstatic const opus_int16 OP_STEREO_DOWNMIX_Q14\n [OP_NCHANNELS_MAX-2][OP_NCHANNELS_MAX][2]={\n  /*3.0*/\n  {\n    {9598,0},{6786,6786},{0,9598}\n  },\n  /*quadrophonic*/\n  {\n    {6924,0},{0,6924},{5996,3464},{3464,5996}\n  },\n  /*5.0*/\n  {\n    {10666,0},{7537,7537},{0,10666},{9234,5331},{5331,9234}\n  },\n  /*5.1*/\n  {\n    {8668,0},{6129,6129},{0,8668},{7507,4335},{4335,7507},{6129,6129}\n  },\n  /*6.1*/\n  {\n    {7459,0},{5275,5275},{0,7459},{6460,3731},{3731,6460},{4568,4568},\n    {5275,5275}\n  },\n  /*7.1*/\n  {\n    {6368,0},{4502,4502},{0,6368},{5515,3183},{3183,5515},{5515,3183},\n    {3183,5515},{4502,4502}\n  }\n};\n\nint op_read(OggOpusFile *_of,opus_int16 *_pcm,int _buf_size,int *_li){\n  return op_read_native(_of,_pcm,_buf_size,_li);\n}\n\nstatic int op_stereo_filter(OggOpusFile *_of,void *_dst,int _dst_sz,\n op_sample *_src,int _nsamples,int _nchannels){\n  (void)_of;\n  _nsamples=OP_MIN(_nsamples,_dst_sz>>1);\n  if(_nchannels==2)memcpy(_dst,_src,_nsamples*2*sizeof(*_src));\n  else{\n    opus_int16 *dst;\n    int         i;\n    dst=(opus_int16 *)_dst;\n    if(_nchannels==1){\n      for(i=0;i<_nsamples;i++)dst[2*i+0]=dst[2*i+1]=_src[i];\n    }\n    else{\n      for(i=0;i<_nsamples;i++){\n        opus_int32 l;\n        opus_int32 r;\n        int        ci;\n        l=r=0;\n        for(ci=0;ci<_nchannels;ci++){\n          opus_int32 s;\n          s=_src[_nchannels*i+ci];\n          l+=OP_STEREO_DOWNMIX_Q14[_nchannels-3][ci][0]*s;\n          r+=OP_STEREO_DOWNMIX_Q14[_nchannels-3][ci][1]*s;\n        }\n        /*TODO: For 5 or more channels, we should do soft clipping here.*/\n        dst[2*i+0]=(opus_int16)OP_CLAMP(-32768,l+8192>>14,32767);\n        dst[2*i+1]=(opus_int16)OP_CLAMP(-32768,r+8192>>14,32767);\n      }\n    }\n  }\n  return _nsamples;\n}\n\nint op_read_stereo(OggOpusFile *_of,opus_int16 *_pcm,int _buf_size){\n  return op_filter_read_native(_of,_pcm,_buf_size,op_stereo_filter,NULL);\n}\n\n# if !defined(OP_DISABLE_FLOAT_API)\n\nstatic int op_short2float_filter(OggOpusFile *_of,void *_dst,int _dst_sz,\n op_sample *_src,int _nsamples,int _nchannels){\n  float *dst;\n  int    i;\n  (void)_of;\n  dst=(float *)_dst;\n  if(OP_UNLIKELY(_nsamples*_nchannels>_dst_sz))_nsamples=_dst_sz/_nchannels;\n  _dst_sz=_nsamples*_nchannels;\n  for(i=0;i<_dst_sz;i++)dst[i]=(1.0F/32768)*_src[i];\n  return _nsamples;\n}\n\nint op_read_float(OggOpusFile *_of,float *_pcm,int _buf_size,int *_li){\n  return op_filter_read_native(_of,_pcm,_buf_size,op_short2float_filter,_li);\n}\n\nstatic int op_short2float_stereo_filter(OggOpusFile *_of,\n void *_dst,int _dst_sz,op_sample *_src,int _nsamples,int _nchannels){\n  float *dst;\n  int    i;\n  dst=(float *)_dst;\n  _nsamples=OP_MIN(_nsamples,_dst_sz>>1);\n  if(_nchannels==1){\n    _nsamples=op_short2float_filter(_of,dst,_nsamples,_src,_nsamples,1);\n    for(i=_nsamples;i-->0;)dst[2*i+0]=dst[2*i+1]=dst[i];\n  }\n  else if(_nchannels<5){\n    /*For 3 or 4 channels, we can downmix in fixed point without risk of\n       clipping.*/\n    if(_nchannels>2){\n      _nsamples=op_stereo_filter(_of,_src,_nsamples*2,\n       _src,_nsamples,_nchannels);\n    }\n    return op_short2float_filter(_of,dst,_dst_sz,_src,_nsamples,2);\n  }\n  else{\n    /*For 5 or more channels, we convert to floats and then downmix (so that we\n       don't risk clipping).*/\n    for(i=0;i<_nsamples;i++){\n      float l;\n      float r;\n      int   ci;\n      l=r=0;\n      for(ci=0;ci<_nchannels;ci++){\n        float s;\n        s=(1.0F/32768)*_src[_nchannels*i+ci];\n        l+=OP_STEREO_DOWNMIX[_nchannels-3][ci][0]*s;\n        r+=OP_STEREO_DOWNMIX[_nchannels-3][ci][1]*s;\n      }\n      dst[2*i+0]=l;\n      dst[2*i+1]=r;\n    }\n  }\n  return _nsamples;\n}\n\nint op_read_float_stereo(OggOpusFile *_of,float *_pcm,int _buf_size){\n  return op_filter_read_native(_of,_pcm,_buf_size,\n   op_short2float_stereo_filter,NULL);\n}\n\n# endif\n\n#else\n\n# if defined(OP_HAVE_LRINTF)\n#  include <math.h>\n#  define op_float2int(_x) (lrintf(_x))\n# else\n#  define op_float2int(_x) ((int)((_x)+((_x)<0?-0.5F:0.5F)))\n# endif\n\n/*The dithering code here is adapted from opusdec, part of opus-tools.\n  It was originally written by Greg Maxwell.*/\n\nstatic opus_uint32 op_rand(opus_uint32 _seed){\n  return _seed*96314165+907633515&0xFFFFFFFFU;\n}\n\n/*This implements 16-bit quantization with full triangular dither and IIR noise\n   shaping.\n  The noise shaping filters were designed by Sebastian Gesemann, and are based\n   on the LAME ATH curves with flattening to limit their peak gain to 20 dB.\n  Everyone else's noise shaping filters are mildly crazy.\n  The 48 kHz version of this filter is just a warped version of the 44.1 kHz\n   filter and probably could be improved by shifting the HF shelf up in\n   frequency a little bit, since 48 kHz has a bit more room and being more\n   conservative against bat-ears is probably more important than more noise\n   suppression.\n  This process can increase the peak level of the signal (in theory by the peak\n   error of 1.5 +20 dB, though that is unobservably rare).\n  To avoid clipping, the signal is attenuated by a couple thousandths of a dB.\n  Initially, the approach taken here was to only attenuate by the 99.9th\n   percentile, making clipping rare but not impossible (like SoX), but the\n   limited gain of the filter means that the worst case was only two\n   thousandths of a dB more, so this just uses the worst case.\n  The attenuation is probably also helpful to prevent clipping in the DAC\n   reconstruction filters or downstream resampling, in any case.*/\n\n# define OP_GAIN (32753.0F)\n\n# define OP_PRNG_GAIN (1.0F/(float)0xFFFFFFFF)\n\n/*48 kHz noise shaping filter, sd=2.34.*/\n\nstatic const float OP_FCOEF_B[4]={\n  2.2374F,-0.7339F,-0.1251F,-0.6033F\n};\n\nstatic const float OP_FCOEF_A[4]={\n  0.9030F,0.0116F,-0.5853F,-0.2571F\n};\n\nstatic int op_float2short_filter(OggOpusFile *_of,void *_dst,int _dst_sz,\n float *_src,int _nsamples,int _nchannels){\n  opus_int16 *dst;\n  int         ci;\n  int         i;\n  dst=(opus_int16 *)_dst;\n  if(OP_UNLIKELY(_nsamples*_nchannels>_dst_sz))_nsamples=_dst_sz/_nchannels;\n# if defined(OP_SOFT_CLIP)\n  if(_of->state_channel_count!=_nchannels){\n    for(ci=0;ci<_nchannels;ci++)_of->clip_state[ci]=0;\n  }\n  opus_pcm_soft_clip(_src,_nsamples,_nchannels,_of->clip_state);\n# endif\n  if(_of->dither_disabled){\n    for(i=0;i<_nchannels*_nsamples;i++){\n      dst[i]=op_float2int(OP_CLAMP(-32768,32768.0F*_src[i],32767));\n    }\n  }\n  else{\n    opus_uint32 seed;\n    int         mute;\n    seed=_of->dither_seed;\n    mute=_of->dither_mute;\n    if(_of->state_channel_count!=_nchannels)mute=65;\n    /*In order to avoid replacing digital silence with quiet dither noise, we\n       mute if the output has been silent for a while.*/\n    if(mute>64)memset(_of->dither_a,0,sizeof(*_of->dither_a)*4*_nchannels);\n    for(i=0;i<_nsamples;i++){\n      int silent;\n      silent=1;\n      for(ci=0;ci<_nchannels;ci++){\n        float r;\n        float s;\n        float err;\n        int   si;\n        int   j;\n        s=_src[_nchannels*i+ci];\n        silent&=s==0;\n        s*=OP_GAIN;\n        err=0;\n        for(j=0;j<4;j++){\n          err+=OP_FCOEF_B[j]*_of->dither_b[ci*4+j]\n           -OP_FCOEF_A[j]*_of->dither_a[ci*4+j];\n        }\n        for(j=3;j-->0;)_of->dither_a[ci*4+j+1]=_of->dither_a[ci*4+j];\n        for(j=3;j-->0;)_of->dither_b[ci*4+j+1]=_of->dither_b[ci*4+j];\n        _of->dither_a[ci*4]=err;\n        s-=err;\n        if(mute>16)r=0;\n        else{\n          seed=op_rand(seed);\n          r=seed*OP_PRNG_GAIN;\n          seed=op_rand(seed);\n          r-=seed*OP_PRNG_GAIN;\n        }\n        /*Clamp in float out of paranoia that the input will be > 96 dBFS and\n           wrap if the integer is clamped.*/\n        si=op_float2int(OP_CLAMP(-32768,s+r,32767));\n        dst[_nchannels*i+ci]=(opus_int16)si;\n        /*Including clipping in the noise shaping is generally disastrous: the\n           futile effort to restore the clipped energy results in more clipping.\n          However, small amounts---at the level which could normally be created\n           by dither and rounding---are harmless and can even reduce clipping\n           somewhat due to the clipping sometimes reducing the dither + rounding\n           error.*/\n        _of->dither_b[ci*4]=mute>16?0:OP_CLAMP(-1.5F,si-s,1.5F);\n      }\n      mute++;\n      if(!silent)mute=0;\n    }\n    _of->dither_mute=OP_MIN(mute,65);\n    _of->dither_seed=seed;\n  }\n  _of->state_channel_count=_nchannels;\n  return _nsamples;\n}\n\nint op_read(OggOpusFile *_of,opus_int16 *_pcm,int _buf_size,int *_li){\n  return op_filter_read_native(_of,_pcm,_buf_size,op_float2short_filter,_li);\n}\n\nint op_read_float(OggOpusFile *_of,float *_pcm,int _buf_size,int *_li){\n  _of->state_channel_count=0;\n  return op_read_native(_of,_pcm,_buf_size,_li);\n}\n\nstatic int op_stereo_filter(OggOpusFile *_of,void *_dst,int _dst_sz,\n op_sample *_src,int _nsamples,int _nchannels){\n  (void)_of;\n  _nsamples=OP_MIN(_nsamples,_dst_sz>>1);\n  if(_nchannels==2)memcpy(_dst,_src,_nsamples*2*sizeof(*_src));\n  else{\n    float *dst;\n    int    i;\n    dst=(float *)_dst;\n    if(_nchannels==1){\n      for(i=0;i<_nsamples;i++)dst[2*i+0]=dst[2*i+1]=_src[i];\n    }\n    else{\n      for(i=0;i<_nsamples;i++){\n        float l;\n        float r;\n        int   ci;\n        l=r=0;\n        for(ci=0;ci<_nchannels;ci++){\n          l+=OP_STEREO_DOWNMIX[_nchannels-3][ci][0]*_src[_nchannels*i+ci];\n          r+=OP_STEREO_DOWNMIX[_nchannels-3][ci][1]*_src[_nchannels*i+ci];\n        }\n        dst[2*i+0]=l;\n        dst[2*i+1]=r;\n      }\n    }\n  }\n  return _nsamples;\n}\n\nstatic int op_float2short_stereo_filter(OggOpusFile *_of,\n void *_dst,int _dst_sz,op_sample *_src,int _nsamples,int _nchannels){\n  opus_int16 *dst;\n  dst=(opus_int16 *)_dst;\n  if(_nchannels==1){\n    int i;\n    _nsamples=op_float2short_filter(_of,dst,_dst_sz>>1,_src,_nsamples,1);\n    for(i=_nsamples;i-->0;)dst[2*i+0]=dst[2*i+1]=dst[i];\n  }\n  else{\n    if(_nchannels>2){\n      _nsamples=OP_MIN(_nsamples,_dst_sz>>1);\n      _nsamples=op_stereo_filter(_of,_src,_nsamples*2,\n       _src,_nsamples,_nchannels);\n    }\n    _nsamples=op_float2short_filter(_of,dst,_dst_sz,_src,_nsamples,2);\n  }\n  return _nsamples;\n}\n\nint op_read_stereo(OggOpusFile *_of,opus_int16 *_pcm,int _buf_size){\n  return op_filter_read_native(_of,_pcm,_buf_size,\n   op_float2short_stereo_filter,NULL);\n}\n\nint op_read_float_stereo(OggOpusFile *_of,float *_pcm,int _buf_size){\n  _of->state_channel_count=0;\n  return op_filter_read_native(_of,_pcm,_buf_size,op_stereo_filter,NULL);\n}\n\n#endif\n"], "fixing_code": ["/********************************************************************\n *                                                                  *\n * THIS FILE IS PART OF THE libopusfile SOFTWARE CODEC SOURCE CODE. *\n * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *\n * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *\n * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *\n *                                                                  *\n * THE libopusfile SOURCE CODE IS (C) COPYRIGHT 1994-2020           *\n * by the Xiph.Org Foundation and contributors https://xiph.org/    *\n *                                                                  *\n ********************************************************************\n\n function: stdio-based convenience library for opening/seeking/decoding\n last mod: $Id: vorbisfile.c 17573 2010-10-27 14:53:59Z xiphmont $\n\n ********************************************************************/\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"internal.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <limits.h>\n#include <string.h>\n#include <math.h>\n\n#include \"opusfile.h\"\n\n/*This implementation is largely based off of libvorbisfile.\n  All of the Ogg bits work roughly the same, though I have made some\n   \"improvements\" that have not been folded back there, yet.*/\n\n/*A 'chained bitstream' is an Ogg Opus bitstream that contains more than one\n   logical bitstream arranged end to end (the only form of Ogg multiplexing\n   supported by this library.\n  Grouping (parallel multiplexing) is not supported, except to the extent that\n   if there are multiple logical Ogg streams in a single link of the chain, we\n   will ignore all but the first Opus stream we find.*/\n\n/*An Ogg Opus file can be played beginning to end (streamed) without worrying\n   ahead of time about chaining (see opusdec from the opus-tools package).\n  If we have the whole file, however, and want random access\n   (seeking/scrubbing) or desire to know the total length/time of a file, we\n   need to account for the possibility of chaining.*/\n\n/*We can handle things a number of ways.\n  We can determine the entire bitstream structure right off the bat, or find\n   pieces on demand.\n  This library determines and caches structure for the entire bitstream, but\n   builds a virtual decoder on the fly when moving between links in the chain.*/\n\n/*There are also different ways to implement seeking.\n  Enough information exists in an Ogg bitstream to seek to sample-granularity\n   positions in the output.\n  Or, one can seek by picking some portion of the stream roughly in the desired\n   area if we only want coarse navigation through the stream.\n  We implement and expose both strategies.*/\n\n/*The maximum number of bytes in a page (including the page headers).*/\n#define OP_PAGE_SIZE_MAX  (65307)\n/*The default amount to seek backwards per step when trying to find the\n   previous page.\n  This must be at least as large as the maximum size of a page.*/\n#define OP_CHUNK_SIZE     (65536)\n/*The maximum amount to seek backwards per step when trying to find the\n   previous page.*/\n#define OP_CHUNK_SIZE_MAX (1024*(opus_int32)1024)\n/*A smaller read size is needed for low-rate streaming.*/\n#define OP_READ_SIZE      (2048)\n\nint op_test(OpusHead *_head,\n const unsigned char *_initial_data,size_t _initial_bytes){\n  ogg_sync_state  oy;\n  char           *data;\n  int             err;\n  /*The first page of a normal Opus file will be at most 57 bytes (27 Ogg\n     page header bytes + 1 lacing value + 21 Opus header bytes + 8 channel\n     mapping bytes).\n    It will be at least 47 bytes (27 Ogg page header bytes + 1 lacing value +\n     19 Opus header bytes using channel mapping family 0).\n    If we don't have at least that much data, give up now.*/\n  if(_initial_bytes<47)return OP_FALSE;\n  /*Only proceed if we start with the magic OggS string.\n    This is to prevent us spending a lot of time allocating memory and looking\n     for Ogg pages in non-Ogg files.*/\n  if(memcmp(_initial_data,\"OggS\",4)!=0)return OP_ENOTFORMAT;\n  if(OP_UNLIKELY(_initial_bytes>(size_t)LONG_MAX))return OP_EFAULT;\n  ogg_sync_init(&oy);\n  data=ogg_sync_buffer(&oy,(long)_initial_bytes);\n  if(data!=NULL){\n    ogg_stream_state os;\n    ogg_page         og;\n    int              ret;\n    memcpy(data,_initial_data,_initial_bytes);\n    ogg_sync_wrote(&oy,(long)_initial_bytes);\n    ogg_stream_init(&os,-1);\n    err=OP_FALSE;\n    do{\n      ogg_packet op;\n      ret=ogg_sync_pageout(&oy,&og);\n      /*Ignore holes.*/\n      if(ret<0)continue;\n      /*Stop if we run out of data.*/\n      if(!ret)break;\n      ogg_stream_reset_serialno(&os,ogg_page_serialno(&og));\n      ogg_stream_pagein(&os,&og);\n      /*Only process the first packet on this page (if it's a BOS packet,\n         it's required to be the only one).*/\n      if(ogg_stream_packetout(&os,&op)==1){\n        if(op.b_o_s){\n          ret=opus_head_parse(_head,op.packet,op.bytes);\n          /*If this didn't look like Opus, keep going.*/\n          if(ret==OP_ENOTFORMAT)continue;\n          /*Otherwise we're done, one way or another.*/\n          err=ret;\n        }\n        /*We finished parsing the headers.\n          There is no Opus to be found.*/\n        else err=OP_ENOTFORMAT;\n      }\n    }\n    while(err==OP_FALSE);\n    ogg_stream_clear(&os);\n  }\n  else err=OP_EFAULT;\n  ogg_sync_clear(&oy);\n  return err;\n}\n\n/*Many, many internal helpers.\n  The intention is not to be confusing.\n  Rampant duplication and monolithic function implementation (though we do have\n   some large, omnibus functions still) would be harder to understand anyway.\n  The high level functions are last.\n  Begin grokking near the end of the file if you prefer to read things\n   top-down.*/\n\n/*The read/seek functions track absolute position within the stream.*/\n\n/*Read a little more data from the file/pipe into the ogg_sync framer.\n  _nbytes: The maximum number of bytes to read.\n  Return: A positive number of bytes read on success, 0 on end-of-file, or a\n           negative value on failure.*/\nstatic int op_get_data(OggOpusFile *_of,int _nbytes){\n  unsigned char *buffer;\n  int            nbytes;\n  OP_ASSERT(_nbytes>0);\n  buffer=(unsigned char *)ogg_sync_buffer(&_of->oy,_nbytes);\n  if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT;\n  nbytes=(int)(*_of->callbacks.read)(_of->stream,buffer,_nbytes);\n  OP_ASSERT(nbytes<=_nbytes);\n  if(OP_LIKELY(nbytes>0))ogg_sync_wrote(&_of->oy,nbytes);\n  return nbytes;\n}\n\n/*Save a tiny smidge of verbosity to make the code more readable.*/\nstatic int op_seek_helper(OggOpusFile *_of,opus_int64 _offset){\n  if(_offset==_of->offset)return 0;\n  if(_of->callbacks.seek==NULL\n   ||(*_of->callbacks.seek)(_of->stream,_offset,SEEK_SET)){\n    return OP_EREAD;\n  }\n  _of->offset=_offset;\n  ogg_sync_reset(&_of->oy);\n  return 0;\n}\n\n/*Get the current position indicator of the underlying stream.\n  This should be the same as the value reported by tell().*/\nstatic opus_int64 op_position(const OggOpusFile *_of){\n  /*The current position indicator is _not_ simply offset.\n    We may also have unprocessed, buffered data in the sync state.*/\n  return _of->offset+_of->oy.fill-_of->oy.returned;\n}\n\n/*From the head of the stream, get the next page.\n  _boundary specifies if the function is allowed to fetch more data from the\n   stream (and how much) or only use internally buffered data.\n  _boundary: -1: Unbounded search.\n              0: Read no additional data.\n                 Use only cached data.\n              n: Search for the start of a new page up to file position n.\n  Return: n>=0:       Found a page at absolute offset n.\n          OP_FALSE:   Hit the _boundary limit.\n          OP_EREAD:   An underlying read operation failed.\n          OP_BADLINK: We hit end-of-file before reaching _boundary.*/\nstatic opus_int64 op_get_next_page(OggOpusFile *_of,ogg_page *_og,\n opus_int64 _boundary){\n  while(_boundary<=0||_of->offset<_boundary){\n    int more;\n    more=ogg_sync_pageseek(&_of->oy,_og);\n    /*Skipped (-more) bytes.*/\n    if(OP_UNLIKELY(more<0))_of->offset-=more;\n    else if(more==0){\n      int read_nbytes;\n      int ret;\n      /*Send more paramedics.*/\n      if(!_boundary)return OP_FALSE;\n      if(_boundary<0)read_nbytes=OP_READ_SIZE;\n      else{\n        opus_int64 position;\n        position=op_position(_of);\n        if(position>=_boundary)return OP_FALSE;\n        read_nbytes=(int)OP_MIN(_boundary-position,OP_READ_SIZE);\n      }\n      ret=op_get_data(_of,read_nbytes);\n      if(OP_UNLIKELY(ret<0))return OP_EREAD;\n      if(OP_UNLIKELY(ret==0)){\n        /*Only fail cleanly on EOF if we didn't have a known boundary.\n          Otherwise, we should have been able to reach that boundary, and this\n           is a fatal error.*/\n        return OP_UNLIKELY(_boundary<0)?OP_FALSE:OP_EBADLINK;\n      }\n    }\n    else{\n      /*Got a page.\n        Return the page start offset and advance the internal offset past the\n         page end.*/\n      opus_int64 page_offset;\n      page_offset=_of->offset;\n      _of->offset+=more;\n      OP_ASSERT(page_offset>=0);\n      return page_offset;\n    }\n  }\n  return OP_FALSE;\n}\n\nstatic int op_add_serialno(const ogg_page *_og,\n ogg_uint32_t **_serialnos,int *_nserialnos,int *_cserialnos){\n  ogg_uint32_t *serialnos;\n  int           nserialnos;\n  int           cserialnos;\n  ogg_uint32_t s;\n  s=ogg_page_serialno(_og);\n  serialnos=*_serialnos;\n  nserialnos=*_nserialnos;\n  cserialnos=*_cserialnos;\n  if(OP_UNLIKELY(nserialnos>=cserialnos)){\n    if(OP_UNLIKELY(cserialnos>INT_MAX/(int)sizeof(*serialnos)-1>>1)){\n      return OP_EFAULT;\n    }\n    cserialnos=2*cserialnos+1;\n    OP_ASSERT(nserialnos<cserialnos);\n    serialnos=(ogg_uint32_t *)_ogg_realloc(serialnos,\n     sizeof(*serialnos)*cserialnos);\n    if(OP_UNLIKELY(serialnos==NULL))return OP_EFAULT;\n  }\n  serialnos[nserialnos++]=s;\n  *_serialnos=serialnos;\n  *_nserialnos=nserialnos;\n  *_cserialnos=cserialnos;\n  return 0;\n}\n\n/*Returns nonzero if found.*/\nstatic int op_lookup_serialno(ogg_uint32_t _s,\n const ogg_uint32_t *_serialnos,int _nserialnos){\n  int i;\n  for(i=0;i<_nserialnos&&_serialnos[i]!=_s;i++);\n  return i<_nserialnos;\n}\n\nstatic int op_lookup_page_serialno(const ogg_page *_og,\n const ogg_uint32_t *_serialnos,int _nserialnos){\n  return op_lookup_serialno(ogg_page_serialno(_og),_serialnos,_nserialnos);\n}\n\ntypedef struct OpusSeekRecord OpusSeekRecord;\n\n/*We use this to remember the pages we found while enumerating the links of a\n   chained stream.\n  We keep track of the starting and ending offsets, as well as the point we\n   started searching from, so we know where to bisect.\n  We also keep the serial number, so we can tell if the page belonged to the\n   current link or not, as well as the granule position, to aid in estimating\n   the start of the link.*/\nstruct OpusSeekRecord{\n  /*The earliest byte we know of such that reading forward from it causes\n     capture to be regained at this page.*/\n  opus_int64   search_start;\n  /*The offset of this page.*/\n  opus_int64   offset;\n  /*The size of this page.*/\n  opus_int32   size;\n  /*The serial number of this page.*/\n  ogg_uint32_t serialno;\n  /*The granule position of this page.*/\n  ogg_int64_t  gp;\n};\n\n/*Find the last page beginning before _offset with a valid granule position.\n  There is no '_boundary' parameter as it will always have to read more data.\n  This is much dirtier than the above, as Ogg doesn't have any backward search\n   linkage.\n  This search prefers pages of the specified serial number.\n  If a page of the specified serial number is spotted during the\n   seek-back-and-read-forward, it will return the info of last page of the\n   matching serial number, instead of the very last page, unless the very last\n   page belongs to a different link than preferred serial number.\n  If no page of the specified serial number is seen, it will return the info of\n   the last page.\n  [out] _sr:   Returns information about the page that was found on success.\n  _offset:     The _offset before which to find a page.\n               Any page returned will consist of data entirely before _offset.\n  _serialno:   The preferred serial number.\n               If a page with this serial number is found, it will be returned\n                even if another page in the same link is found closer to\n                _offset.\n               This is purely opportunistic: there is no guarantee such a page\n                will be found if it exists.\n  _serialnos:  The list of serial numbers in the link that contains the\n                preferred serial number.\n  _nserialnos: The number of serial numbers in the current link.\n  Return: 0 on success, or a negative value on failure.\n          OP_EREAD:    Failed to read more data (error or EOF).\n          OP_EBADLINK: We couldn't find a page even after seeking back to the\n                        start of the stream.*/\nstatic int op_get_prev_page_serial(OggOpusFile *_of,OpusSeekRecord *_sr,\n opus_int64 _offset,ogg_uint32_t _serialno,\n const ogg_uint32_t *_serialnos,int _nserialnos){\n  OpusSeekRecord preferred_sr;\n  ogg_page       og;\n  opus_int64     begin;\n  opus_int64     end;\n  opus_int64     original_end;\n  opus_int32     chunk_size;\n  int            preferred_found;\n  original_end=end=begin=_offset;\n  preferred_found=0;\n  _offset=-1;\n  chunk_size=OP_CHUNK_SIZE;\n  do{\n    opus_int64 search_start;\n    int        ret;\n    OP_ASSERT(chunk_size>=OP_PAGE_SIZE_MAX);\n    begin=OP_MAX(begin-chunk_size,0);\n    ret=op_seek_helper(_of,begin);\n    if(OP_UNLIKELY(ret<0))return ret;\n    search_start=begin;\n    while(_of->offset<end){\n      opus_int64   llret;\n      ogg_uint32_t serialno;\n      llret=op_get_next_page(_of,&og,end);\n      if(OP_UNLIKELY(llret<OP_FALSE))return (int)llret;\n      else if(llret==OP_FALSE)break;\n      serialno=ogg_page_serialno(&og);\n      /*Save the information for this page.\n        We're not interested in the page itself... just the serial number, byte\n         offset, page size, and granule position.*/\n      _sr->search_start=search_start;\n      _sr->offset=_offset=llret;\n      _sr->serialno=serialno;\n      OP_ASSERT(_of->offset-_offset>=0);\n      OP_ASSERT(_of->offset-_offset<=OP_PAGE_SIZE_MAX);\n      _sr->size=(opus_int32)(_of->offset-_offset);\n      _sr->gp=ogg_page_granulepos(&og);\n      /*If this page is from the stream we're looking for, remember it.*/\n      if(serialno==_serialno){\n        preferred_found=1;\n        *&preferred_sr=*_sr;\n      }\n      if(!op_lookup_serialno(serialno,_serialnos,_nserialnos)){\n        /*We fell off the end of the link, which means we seeked back too far\n           and shouldn't have been looking in that link to begin with.\n          If we found the preferred serial number, forget that we saw it.*/\n        preferred_found=0;\n      }\n      search_start=llret+1;\n    }\n    /*We started from the beginning of the stream and found nothing.\n      This should be impossible unless the contents of the stream changed out\n       from under us after we read from it.*/\n    if(OP_UNLIKELY(!begin)&&OP_UNLIKELY(_offset<0))return OP_EBADLINK;\n    /*Bump up the chunk size.\n      This is mildly helpful when seeks are very expensive (http).*/\n    chunk_size=OP_MIN(2*chunk_size,OP_CHUNK_SIZE_MAX);\n    /*Avoid quadratic complexity if we hit an invalid patch of the file.*/\n    end=OP_MIN(begin+OP_PAGE_SIZE_MAX-1,original_end);\n  }\n  while(_offset<0);\n  if(preferred_found)*_sr=*&preferred_sr;\n  return 0;\n}\n\n/*Find the last page beginning before _offset with the given serial number and\n   a valid granule position.\n  Unlike the above search, this continues until it finds such a page, but does\n   not stray outside the current link.\n  We could implement it (inefficiently) by calling op_get_prev_page_serial()\n   repeatedly until it returned a page that had both our preferred serial\n   number and a valid granule position, but doing it with a separate function\n   allows us to avoid repeatedly re-scanning valid pages from other streams as\n   we seek-back-and-read-forward.\n  [out] _gp:   Returns the granule position of the page that was found on\n                success.\n  _offset:     The _offset before which to find a page.\n               Any page returned will consist of data entirely before _offset.\n  _serialno:   The target serial number.\n  _serialnos:  The list of serial numbers in the link that contains the\n                preferred serial number.\n  _nserialnos: The number of serial numbers in the current link.\n  Return: The offset of the page on success, or a negative value on failure.\n          OP_EREAD:    Failed to read more data (error or EOF).\n          OP_EBADLINK: We couldn't find a page even after seeking back past the\n                        beginning of the link.*/\nstatic opus_int64 op_get_last_page(OggOpusFile *_of,ogg_int64_t *_gp,\n opus_int64 _offset,ogg_uint32_t _serialno,\n const ogg_uint32_t *_serialnos,int _nserialnos){\n  ogg_page    og;\n  ogg_int64_t gp;\n  opus_int64  begin;\n  opus_int64  end;\n  opus_int64  original_end;\n  opus_int32  chunk_size;\n  /*The target serial number must belong to the current link.*/\n  OP_ASSERT(op_lookup_serialno(_serialno,_serialnos,_nserialnos));\n  original_end=end=begin=_offset;\n  _offset=-1;\n  /*We shouldn't have to initialize gp, but gcc is too dumb to figure out that\n     ret>=0 implies we entered the if(page_gp!=-1) block at least once.*/\n  gp=-1;\n  chunk_size=OP_CHUNK_SIZE;\n  do{\n    int left_link;\n    int ret;\n    OP_ASSERT(chunk_size>=OP_PAGE_SIZE_MAX);\n    begin=OP_MAX(begin-chunk_size,0);\n    ret=op_seek_helper(_of,begin);\n    if(OP_UNLIKELY(ret<0))return ret;\n    left_link=0;\n    while(_of->offset<end){\n      opus_int64   llret;\n      ogg_uint32_t serialno;\n      llret=op_get_next_page(_of,&og,end);\n      if(OP_UNLIKELY(llret<OP_FALSE))return llret;\n      else if(llret==OP_FALSE)break;\n      serialno=ogg_page_serialno(&og);\n      if(serialno==_serialno){\n        ogg_int64_t page_gp;\n        /*The page is from the right stream...*/\n        page_gp=ogg_page_granulepos(&og);\n        if(page_gp!=-1){\n          /*And has a valid granule position.\n            Let's remember it.*/\n          _offset=llret;\n          gp=page_gp;\n        }\n      }\n      else if(OP_UNLIKELY(!op_lookup_serialno(serialno,\n       _serialnos,_nserialnos))){\n        /*We fell off the start of the link, which means we don't need to keep\n           seeking any farther back.*/\n        left_link=1;\n      }\n    }\n    /*We started from at or before the beginning of the link and found nothing.\n      This should be impossible unless the contents of the stream changed out\n       from under us after we read from it.*/\n    if((OP_UNLIKELY(left_link)||OP_UNLIKELY(!begin))&&OP_UNLIKELY(_offset<0)){\n      return OP_EBADLINK;\n    }\n    /*Bump up the chunk size.\n      This is mildly helpful when seeks are very expensive (http).*/\n    chunk_size=OP_MIN(2*chunk_size,OP_CHUNK_SIZE_MAX);\n    /*Avoid quadratic complexity if we hit an invalid patch of the file.*/\n    end=OP_MIN(begin+OP_PAGE_SIZE_MAX-1,original_end);\n  }\n  while(_offset<0);\n  *_gp=gp;\n  return _offset;\n}\n\n/*Uses the local ogg_stream storage in _of.\n  This is important for non-streaming input sources.*/\nstatic int op_fetch_headers_impl(OggOpusFile *_of,OpusHead *_head,\n OpusTags *_tags,ogg_uint32_t **_serialnos,int *_nserialnos,\n int *_cserialnos,ogg_page *_og){\n  ogg_packet op;\n  int        ret;\n  if(_serialnos!=NULL)*_nserialnos=0;\n  /*Extract the serialnos of all BOS pages plus the first set of Opus headers\n     we see in the link.*/\n  while(ogg_page_bos(_og)){\n    if(_serialnos!=NULL){\n      if(OP_UNLIKELY(op_lookup_page_serialno(_og,*_serialnos,*_nserialnos))){\n        /*A dupe serialnumber in an initial header packet set==invalid stream.*/\n        return OP_EBADHEADER;\n      }\n      ret=op_add_serialno(_og,_serialnos,_nserialnos,_cserialnos);\n      if(OP_UNLIKELY(ret<0))return ret;\n    }\n    if(_of->ready_state<OP_STREAMSET){\n      /*We don't have an Opus stream in this link yet, so begin prospective\n         stream setup.\n        We need a stream to get packets.*/\n      ogg_stream_reset_serialno(&_of->os,ogg_page_serialno(_og));\n      ogg_stream_pagein(&_of->os,_og);\n      if(OP_LIKELY(ogg_stream_packetout(&_of->os,&op)>0)){\n        ret=opus_head_parse(_head,op.packet,op.bytes);\n        /*Found a valid Opus header.\n          Continue setup.*/\n        if(OP_LIKELY(ret>=0))_of->ready_state=OP_STREAMSET;\n        /*If it's just a stream type we don't recognize, ignore it.\n          Everything else is fatal.*/\n        else if(ret!=OP_ENOTFORMAT)return ret;\n      }\n      /*TODO: Should a BOS page with no packets be an error?*/\n    }\n    /*Get the next page.\n      No need to clamp the boundary offset against _of->end, as all errors\n       become OP_ENOTFORMAT or OP_EBADHEADER.*/\n    if(OP_UNLIKELY(op_get_next_page(_of,_og,\n     OP_ADV_OFFSET(_of->offset,OP_CHUNK_SIZE))<0)){\n      return _of->ready_state<OP_STREAMSET?OP_ENOTFORMAT:OP_EBADHEADER;\n    }\n  }\n  if(OP_UNLIKELY(_of->ready_state!=OP_STREAMSET))return OP_ENOTFORMAT;\n  /*If the first non-header page belonged to our Opus stream, submit it.*/\n  if(_of->os.serialno==ogg_page_serialno(_og))ogg_stream_pagein(&_of->os,_og);\n  /*Loop getting packets.*/\n  for(;;){\n    switch(ogg_stream_packetout(&_of->os,&op)){\n      case 0:{\n        /*Loop getting pages.*/\n        for(;;){\n          /*No need to clamp the boundary offset against _of->end, as all\n             errors become OP_EBADHEADER.*/\n          if(OP_UNLIKELY(op_get_next_page(_of,_og,\n           OP_ADV_OFFSET(_of->offset,OP_CHUNK_SIZE))<0)){\n            return OP_EBADHEADER;\n          }\n          /*If this page belongs to the correct stream, go parse it.*/\n          if(_of->os.serialno==ogg_page_serialno(_og)){\n            ogg_stream_pagein(&_of->os,_og);\n            break;\n          }\n          /*If the link ends before we see the Opus comment header, abort.*/\n          if(OP_UNLIKELY(ogg_page_bos(_og)))return OP_EBADHEADER;\n          /*Otherwise, keep looking.*/\n        }\n      }break;\n      /*We shouldn't get a hole in the headers!*/\n      case -1:return OP_EBADHEADER;\n      default:{\n        /*Got a packet.\n          It should be the comment header.*/\n        ret=opus_tags_parse(_tags,op.packet,op.bytes);\n        if(OP_UNLIKELY(ret<0))return ret;\n        /*Make sure the page terminated at the end of the comment header.\n          If there is another packet on the page, or part of a packet, then\n           reject the stream.\n          Otherwise seekable sources won't be able to seek back to the start\n           properly.*/\n        ret=ogg_stream_packetout(&_of->os,&op);\n        if(OP_UNLIKELY(ret!=0)\n         ||OP_UNLIKELY(_og->header[_og->header_len-1]==255)){\n          /*If we fail, the caller assumes our tags are uninitialized.*/\n          opus_tags_clear(_tags);\n          return OP_EBADHEADER;\n        }\n        return 0;\n      }\n    }\n  }\n}\n\nstatic int op_fetch_headers(OggOpusFile *_of,OpusHead *_head,\n OpusTags *_tags,ogg_uint32_t **_serialnos,int *_nserialnos,\n int *_cserialnos,ogg_page *_og){\n  ogg_page og;\n  int      ret;\n  if(!_og){\n    /*No need to clamp the boundary offset against _of->end, as all errors\n       become OP_ENOTFORMAT.*/\n    if(OP_UNLIKELY(op_get_next_page(_of,&og,\n     OP_ADV_OFFSET(_of->offset,OP_CHUNK_SIZE))<0)){\n      return OP_ENOTFORMAT;\n    }\n    _og=&og;\n  }\n  _of->ready_state=OP_OPENED;\n  ret=op_fetch_headers_impl(_of,_head,_tags,_serialnos,_nserialnos,\n   _cserialnos,_og);\n  /*Revert back from OP_STREAMSET to OP_OPENED on failure, to prevent\n     double-free of the tags in an unseekable stream.*/\n  if(OP_UNLIKELY(ret<0))_of->ready_state=OP_OPENED;\n  return ret;\n}\n\n/*Granule position manipulation routines.\n  A granule position is defined to be an unsigned 64-bit integer, with the\n   special value -1 in two's complement indicating an unset or invalid granule\n   position.\n  We are not guaranteed to have an unsigned 64-bit type, so we construct the\n   following routines that\n   a) Properly order negative numbers as larger than positive numbers, and\n   b) Check for underflow or overflow past the special -1 value.\n  This lets us operate on the full, valid range of granule positions in a\n   consistent and safe manner.\n  This full range is organized into distinct regions:\n   [ -1 (invalid) ][ 0 ... OP_INT64_MAX ][ OP_INT64_MIN ... -2 ][-1 (invalid) ]\n\n  No one should actually use granule positions so large that they're negative,\n   even if they are technically valid, as very little software handles them\n   correctly (including most of Xiph.Org's).\n  This library also refuses to support durations so large they won't fit in a\n   signed 64-bit integer (to avoid exposing this mess to the application, and\n   to simplify a good deal of internal arithmetic), so the only way to use them\n   successfully is if pcm_start is very large.\n  This means there isn't anything you can do with negative granule positions\n   that you couldn't have done with purely non-negative ones.\n  The main purpose of these routines is to allow us to think very explicitly\n   about the possible failure cases of all granule position manipulations.*/\n\n/*Safely adds a small signed integer to a valid (not -1) granule position.\n  The result can use the full 64-bit range of values (both positive and\n   negative), but will fail on overflow (wrapping past -1; wrapping past\n   OP_INT64_MAX is explicitly okay).\n  [out] _dst_gp: The resulting granule position.\n                 Only modified on success.\n  _src_gp:       The granule position to add to.\n                 This must not be -1.\n  _delta:        The amount to add.\n                 This is allowed to be up to 32 bits to support the maximum\n                  duration of a single Ogg page (255 packets * 120 ms per\n                  packet == 1,468,800 samples at 48 kHz).\n  Return: 0 on success, or OP_EINVAL if the result would wrap around past -1.*/\nstatic int op_granpos_add(ogg_int64_t *_dst_gp,ogg_int64_t _src_gp,\n opus_int32 _delta){\n  /*The code below handles this case correctly, but there's no reason we\n     should ever be called with these values, so make sure we aren't.*/\n  OP_ASSERT(_src_gp!=-1);\n  if(_delta>0){\n    /*Adding this amount to the granule position would overflow its 64-bit\n       range.*/\n    if(OP_UNLIKELY(_src_gp<0)&&OP_UNLIKELY(_src_gp>=-1-_delta))return OP_EINVAL;\n    if(OP_UNLIKELY(_src_gp>OP_INT64_MAX-_delta)){\n      /*Adding this amount to the granule position would overflow the positive\n         half of its 64-bit range.\n        Since signed overflow is undefined in C, do it in a way the compiler\n         isn't allowed to screw up.*/\n      _delta-=(opus_int32)(OP_INT64_MAX-_src_gp)+1;\n      _src_gp=OP_INT64_MIN;\n    }\n  }\n  else if(_delta<0){\n    /*Subtracting this amount from the granule position would underflow its\n       64-bit range.*/\n    if(_src_gp>=0&&OP_UNLIKELY(_src_gp<-_delta))return OP_EINVAL;\n    if(OP_UNLIKELY(_src_gp<OP_INT64_MIN-_delta)){\n      /*Subtracting this amount from the granule position would underflow the\n         negative half of its 64-bit range.\n        Since signed underflow is undefined in C, do it in a way the compiler\n         isn't allowed to screw up.*/\n      _delta+=(opus_int32)(_src_gp-OP_INT64_MIN)+1;\n      _src_gp=OP_INT64_MAX;\n    }\n  }\n  *_dst_gp=_src_gp+_delta;\n  return 0;\n}\n\n/*Safely computes the difference between two granule positions.\n  The difference must fit in a signed 64-bit integer, or the function fails.\n  It correctly handles the case where the granule position has wrapped around\n   from positive values to negative ones.\n  [out] _delta: The difference between the granule positions.\n                Only modified on success.\n  _gp_a:        The granule position to subtract from.\n                This must not be -1.\n  _gp_b:        The granule position to subtract.\n                This must not be -1.\n  Return: 0 on success, or OP_EINVAL if the result would not fit in a signed\n           64-bit integer.*/\nstatic int op_granpos_diff(ogg_int64_t *_delta,\n ogg_int64_t _gp_a,ogg_int64_t _gp_b){\n  int gp_a_negative;\n  int gp_b_negative;\n  /*The code below handles these cases correctly, but there's no reason we\n     should ever be called with these values, so make sure we aren't.*/\n  OP_ASSERT(_gp_a!=-1);\n  OP_ASSERT(_gp_b!=-1);\n  gp_a_negative=OP_UNLIKELY(_gp_a<0);\n  gp_b_negative=OP_UNLIKELY(_gp_b<0);\n  if(OP_UNLIKELY(gp_a_negative^gp_b_negative)){\n    ogg_int64_t da;\n    ogg_int64_t db;\n    if(gp_a_negative){\n      /*_gp_a has wrapped to a negative value but _gp_b hasn't: the difference\n         should be positive.*/\n      /*Step 1: Handle wrapping.*/\n      /*_gp_a < 0 => da < 0.*/\n      da=(OP_INT64_MIN-_gp_a)-1;\n      /*_gp_b >= 0  => db >= 0.*/\n      db=OP_INT64_MAX-_gp_b;\n      /*Step 2: Check for overflow.*/\n      if(OP_UNLIKELY(OP_INT64_MAX+da<db))return OP_EINVAL;\n      *_delta=db-da;\n    }\n    else{\n      /*_gp_b has wrapped to a negative value but _gp_a hasn't: the difference\n         should be negative.*/\n      /*Step 1: Handle wrapping.*/\n      /*_gp_a >= 0 => da <= 0*/\n      da=_gp_a+OP_INT64_MIN;\n      /*_gp_b < 0 => db <= 0*/\n      db=OP_INT64_MIN-_gp_b;\n      /*Step 2: Check for overflow.*/\n      if(OP_UNLIKELY(da<OP_INT64_MIN-db))return OP_EINVAL;\n      *_delta=da+db;\n    }\n  }\n  else *_delta=_gp_a-_gp_b;\n  return 0;\n}\n\nstatic int op_granpos_cmp(ogg_int64_t _gp_a,ogg_int64_t _gp_b){\n  /*The invalid granule position -1 should behave like NaN: neither greater\n     than nor less than any other granule position, nor equal to any other\n     granule position, including itself.\n    However, that means there isn't anything we could sensibly return from this\n     function for it.*/\n  OP_ASSERT(_gp_a!=-1);\n  OP_ASSERT(_gp_b!=-1);\n  /*Handle the wrapping cases.*/\n  if(OP_UNLIKELY(_gp_a<0)){\n    if(_gp_b>=0)return 1;\n    /*Else fall through.*/\n  }\n  else if(OP_UNLIKELY(_gp_b<0))return -1;\n  /*No wrapping case.*/\n  return (_gp_a>_gp_b)-(_gp_b>_gp_a);\n}\n\n/*Returns the duration of the packet (in samples at 48 kHz), or a negative\n   value on error.*/\nstatic int op_get_packet_duration(const unsigned char *_data,int _len){\n  int nframes;\n  int frame_size;\n  int nsamples;\n  nframes=opus_packet_get_nb_frames(_data,_len);\n  if(OP_UNLIKELY(nframes<0))return OP_EBADPACKET;\n  frame_size=opus_packet_get_samples_per_frame(_data,48000);\n  nsamples=nframes*frame_size;\n  if(OP_UNLIKELY(nsamples>120*48))return OP_EBADPACKET;\n  return nsamples;\n}\n\n/*This function more properly belongs in info.c, but we define it here to allow\n   the static granule position manipulation functions to remain static.*/\nogg_int64_t opus_granule_sample(const OpusHead *_head,ogg_int64_t _gp){\n  opus_int32 pre_skip;\n  pre_skip=_head->pre_skip;\n  if(_gp!=-1&&op_granpos_add(&_gp,_gp,-pre_skip))_gp=-1;\n  return _gp;\n}\n\n/*Grab all the packets currently in the stream state, and compute their\n   durations.\n  _of->op_count is set to the number of packets collected.\n  [out] _durations: Returns the durations of the individual packets.\n  Return: The total duration of all packets, or OP_HOLE if there was a hole.*/\nstatic opus_int32 op_collect_audio_packets(OggOpusFile *_of,\n int _durations[255]){\n  opus_int32 total_duration;\n  int        op_count;\n  /*Count the durations of all packets in the page.*/\n  op_count=0;\n  total_duration=0;\n  for(;;){\n    int ret;\n    /*This takes advantage of undocumented libogg behavior that returned\n       ogg_packet buffers are valid at least until the next page is\n       submitted.\n      Relying on this is not too terrible, as _none_ of the Ogg memory\n       ownership/lifetime rules are well-documented.\n      But I can read its code and know this will work.*/\n    ret=ogg_stream_packetout(&_of->os,_of->op+op_count);\n    if(!ret)break;\n    if(OP_UNLIKELY(ret<0)){\n      /*We shouldn't get holes in the middle of pages.*/\n      OP_ASSERT(op_count==0);\n      /*Set the return value and break out of the loop.\n        We want to make sure op_count gets set to 0, because we've ingested a\n         page, so any previously loaded packets are now invalid.*/\n      total_duration=OP_HOLE;\n      break;\n    }\n    /*Unless libogg is broken, we can't get more than 255 packets from a\n       single page.*/\n    OP_ASSERT(op_count<255);\n    _durations[op_count]=op_get_packet_duration(_of->op[op_count].packet,\n     _of->op[op_count].bytes);\n    if(OP_LIKELY(_durations[op_count]>0)){\n      /*With at most 255 packets on a page, this can't overflow.*/\n      total_duration+=_durations[op_count++];\n    }\n    /*Ignore packets with an invalid TOC sequence.*/\n    else if(op_count>0){\n      /*But save the granule position, if there was one.*/\n      _of->op[op_count-1].granulepos=_of->op[op_count].granulepos;\n    }\n  }\n  _of->op_pos=0;\n  _of->op_count=op_count;\n  return total_duration;\n}\n\n/*Starting from current cursor position, get the initial PCM offset of the next\n   page.\n  This also validates the granule position on the first page with a completed\n   audio data packet, as required by the spec.\n  If this link is completely empty (no pages with completed packets), then this\n   function sets pcm_start=pcm_end=0 and returns the BOS page of the next link\n   (if any).\n  In the seekable case, we initialize pcm_end=-1 before calling this function,\n   so that later we can detect that the link was empty before calling\n   op_find_final_pcm_offset().\n  [inout] _link: The link for which to find pcm_start.\n  [out] _og:     Returns the BOS page of the next link if this link was empty.\n                 In the unseekable case, we can then feed this to\n                  op_fetch_headers() to start the next link.\n                 The caller may pass NULL (e.g., for seekable streams), in\n                  which case this page will be discarded.\n  Return: 0 on success, 1 if there is a buffered BOS page available, or a\n           negative value on unrecoverable error.*/\nstatic int op_find_initial_pcm_offset(OggOpusFile *_of,\n OggOpusLink *_link,ogg_page *_og){\n  ogg_page     og;\n  opus_int64   page_offset;\n  ogg_int64_t  pcm_start;\n  ogg_int64_t  prev_packet_gp;\n  ogg_int64_t  cur_page_gp;\n  ogg_uint32_t serialno;\n  opus_int32   total_duration;\n  int          durations[255];\n  int          cur_page_eos;\n  int          op_count;\n  int          pi;\n  if(_og==NULL)_og=&og;\n  serialno=_of->os.serialno;\n  op_count=0;\n  /*We shouldn't have to initialize total_duration, but gcc is too dumb to\n     figure out that op_count>0 implies we've been through the whole loop at\n     least once.*/\n  total_duration=0;\n  do{\n    page_offset=op_get_next_page(_of,_og,_of->end);\n    /*We should get a page unless the file is truncated or mangled.\n      Otherwise there are no audio data packets in the whole logical stream.*/\n    if(OP_UNLIKELY(page_offset<0)){\n      /*Fail if there was a read error.*/\n      if(page_offset<OP_FALSE)return (int)page_offset;\n      /*Fail if the pre-skip is non-zero, since it's asking us to skip more\n         samples than exist.*/\n      if(_link->head.pre_skip>0)return OP_EBADTIMESTAMP;\n      _link->pcm_file_offset=0;\n      /*Set pcm_end and end_offset so we can skip the call to\n         op_find_final_pcm_offset().*/\n      _link->pcm_start=_link->pcm_end=0;\n      _link->end_offset=_link->data_offset;\n      return 0;\n    }\n    /*Similarly, if we hit the next link in the chain, we've gone too far.*/\n    if(OP_UNLIKELY(ogg_page_bos(_og))){\n      if(_link->head.pre_skip>0)return OP_EBADTIMESTAMP;\n      /*Set pcm_end and end_offset so we can skip the call to\n         op_find_final_pcm_offset().*/\n      _link->pcm_file_offset=0;\n      _link->pcm_start=_link->pcm_end=0;\n      _link->end_offset=_link->data_offset;\n      /*Tell the caller we've got a buffered page for them.*/\n      return 1;\n    }\n    /*Ignore pages from other streams (not strictly necessary, because of the\n       checks in ogg_stream_pagein(), but saves some work).*/\n    if(serialno!=(ogg_uint32_t)ogg_page_serialno(_og))continue;\n    ogg_stream_pagein(&_of->os,_og);\n    /*Bitrate tracking: add the header's bytes here.\n      The body bytes are counted when we consume the packets.*/\n    _of->bytes_tracked+=_og->header_len;\n    /*Count the durations of all packets in the page.*/\n    do total_duration=op_collect_audio_packets(_of,durations);\n    /*Ignore holes.*/\n    while(OP_UNLIKELY(total_duration<0));\n    op_count=_of->op_count;\n  }\n  while(op_count<=0);\n  /*We found the first page with a completed audio data packet: actually look\n     at the granule position.\n    RFC 3533 says, \"A special value of -1 (in two's complement) indicates that\n     no packets finish on this page,\" which does not say that a granule\n     position that is NOT -1 indicates that some packets DO finish on that page\n     (even though this was the intention, libogg itself violated this intention\n     for years before we fixed it).\n    The Ogg Opus specification only imposes its start-time requirements\n     on the granule position of the first page with completed packets,\n     so we ignore any set granule positions until then.*/\n  cur_page_gp=_of->op[op_count-1].granulepos;\n  /*But getting a packet without a valid granule position on the page is not\n     okay.*/\n  if(cur_page_gp==-1)return OP_EBADTIMESTAMP;\n  cur_page_eos=_of->op[op_count-1].e_o_s;\n  if(OP_LIKELY(!cur_page_eos)){\n    /*The EOS flag wasn't set.\n      Work backwards from the provided granule position to get the starting PCM\n       offset.*/\n    if(OP_UNLIKELY(op_granpos_add(&pcm_start,cur_page_gp,-total_duration)<0)){\n      /*The starting granule position MUST not be smaller than the amount of\n         audio on the first page with completed packets.*/\n      return OP_EBADTIMESTAMP;\n    }\n  }\n  else{\n    /*The first page with completed packets was also the last.*/\n    if(OP_LIKELY(op_granpos_add(&pcm_start,cur_page_gp,-total_duration)<0)){\n      /*If there's less audio on the page than indicated by the granule\n         position, then we're doing end-trimming, and the starting PCM offset\n         is zero by spec mandate.*/\n      pcm_start=0;\n      /*However, the end-trimming MUST not ask us to trim more samples than\n         exist after applying the pre-skip.*/\n      if(OP_UNLIKELY(op_granpos_cmp(cur_page_gp,_link->head.pre_skip)<0)){\n        return OP_EBADTIMESTAMP;\n      }\n    }\n  }\n  /*Timestamp the individual packets.*/\n  prev_packet_gp=pcm_start;\n  for(pi=0;pi<op_count;pi++){\n    if(cur_page_eos){\n      ogg_int64_t diff;\n      OP_ALWAYS_TRUE(!op_granpos_diff(&diff,cur_page_gp,prev_packet_gp));\n      diff=durations[pi]-diff;\n      /*If we have samples to trim...*/\n      if(diff>0){\n        /*If we trimmed the entire packet, stop (the spec says encoders\n           shouldn't do this, but we support it anyway).*/\n        if(OP_UNLIKELY(diff>durations[pi]))break;\n        _of->op[pi].granulepos=prev_packet_gp=cur_page_gp;\n        /*Move the EOS flag to this packet, if necessary, so we'll trim the\n           samples.*/\n        _of->op[pi].e_o_s=1;\n        continue;\n      }\n    }\n    /*Update the granule position as normal.*/\n    OP_ALWAYS_TRUE(!op_granpos_add(&_of->op[pi].granulepos,\n     prev_packet_gp,durations[pi]));\n    prev_packet_gp=_of->op[pi].granulepos;\n  }\n  /*Update the packet count after end-trimming.*/\n  _of->op_count=pi;\n  _of->cur_discard_count=_link->head.pre_skip;\n  _link->pcm_file_offset=0;\n  _of->prev_packet_gp=_link->pcm_start=pcm_start;\n  _of->prev_page_offset=page_offset;\n  return 0;\n}\n\n/*Starting from current cursor position, get the final PCM offset of the\n   previous page.\n  This also validates the duration of the link, which, while not strictly\n   required by the spec, we need to ensure duration calculations don't\n   overflow.\n  This is only done for seekable sources.\n  We must validate that op_find_initial_pcm_offset() succeeded for this link\n   before calling this function, otherwise it will scan the entire stream\n   backwards until it reaches the start, and then fail.*/\nstatic int op_find_final_pcm_offset(OggOpusFile *_of,\n const ogg_uint32_t *_serialnos,int _nserialnos,OggOpusLink *_link,\n opus_int64 _offset,ogg_uint32_t _end_serialno,ogg_int64_t _end_gp,\n ogg_int64_t *_total_duration){\n  ogg_int64_t  total_duration;\n  ogg_int64_t  duration;\n  ogg_uint32_t cur_serialno;\n  /*For the time being, fetch end PCM offset the simple way.*/\n  cur_serialno=_link->serialno;\n  if(_end_serialno!=cur_serialno||_end_gp==-1){\n    _offset=op_get_last_page(_of,&_end_gp,_offset,\n     cur_serialno,_serialnos,_nserialnos);\n    if(OP_UNLIKELY(_offset<0))return (int)_offset;\n  }\n  /*At worst we should have found the first page with completed packets.*/\n  if(OP_UNLIKELY(_offset<_link->data_offset))return OP_EBADLINK;\n  /*This implementation requires that the difference between the first and last\n     granule positions in each link be representable in a signed, 64-bit\n     number, and that each link also have at least as many samples as the\n     pre-skip requires.*/\n  if(OP_UNLIKELY(op_granpos_diff(&duration,_end_gp,_link->pcm_start)<0)\n   ||OP_UNLIKELY(duration<_link->head.pre_skip)){\n    return OP_EBADTIMESTAMP;\n  }\n  /*We also require that the total duration be representable in a signed,\n     64-bit number.*/\n  duration-=_link->head.pre_skip;\n  total_duration=*_total_duration;\n  if(OP_UNLIKELY(OP_INT64_MAX-duration<total_duration))return OP_EBADTIMESTAMP;\n  *_total_duration=total_duration+duration;\n  _link->pcm_end=_end_gp;\n  _link->end_offset=_offset;\n  return 0;\n}\n\n/*Rescale the number _x from the range [0,_from] to [0,_to].\n  _from and _to must be positive.*/\nstatic opus_int64 op_rescale64(opus_int64 _x,opus_int64 _from,opus_int64 _to){\n  opus_int64 frac;\n  opus_int64 ret;\n  int        i;\n  if(_x>=_from)return _to;\n  if(_x<=0)return 0;\n  frac=0;\n  for(i=0;i<63;i++){\n    frac<<=1;\n    OP_ASSERT(_x<=_from);\n    if(_x>=_from>>1){\n      _x-=_from-_x;\n      frac|=1;\n    }\n    else _x<<=1;\n  }\n  ret=0;\n  for(i=0;i<63;i++){\n    if(frac&1)ret=(ret&_to&1)+(ret>>1)+(_to>>1);\n    else ret>>=1;\n    frac>>=1;\n  }\n  return ret;\n}\n\n/*The minimum granule position spacing allowed for making predictions.\n  This corresponds to about 1 second of audio at 48 kHz for both Opus and\n   Vorbis, or one keyframe interval in Theora with the default keyframe spacing\n   of 256.*/\n#define OP_GP_SPACING_MIN (48000)\n\n/*Try to estimate the location of the next link using the current seek\n   records, assuming the initial granule position of any streams we've found is\n   0.*/\nstatic opus_int64 op_predict_link_start(const OpusSeekRecord *_sr,int _nsr,\n opus_int64 _searched,opus_int64 _end_searched,opus_int32 _bias){\n  opus_int64 bisect;\n  int        sri;\n  int        srj;\n  /*Require that we be at least OP_CHUNK_SIZE from the end.\n    We don't require that we be at least OP_CHUNK_SIZE from the beginning,\n     because if we are we'll just scan forward without seeking.*/\n  _end_searched-=OP_CHUNK_SIZE;\n  if(_searched>=_end_searched)return -1;\n  bisect=_end_searched;\n  for(sri=0;sri<_nsr;sri++){\n    ogg_int64_t  gp1;\n    ogg_int64_t  gp2_min;\n    ogg_uint32_t serialno1;\n    opus_int64   offset1;\n    /*If the granule position is negative, either it's invalid or we'd cause\n       overflow.\n      If it is larger than OP_INT64_MAX-OP_GP_SPACING_MIN, then no positive\n       granule position would satisfy our minimum spacing requirements below.*/\n    gp1=_sr[sri].gp;\n    if(gp1<0||gp1>OP_INT64_MAX-OP_GP_SPACING_MIN)continue;\n    /*We require some minimum distance between granule positions to make an\n       estimate.\n      We don't actually know what granule position scheme is being used,\n       because we have no idea what kind of stream these came from.\n      Therefore we require a minimum spacing between them, with the\n       expectation that while bitrates and granule position increments might\n       vary locally in quite complex ways, they are globally smooth.*/\n    gp2_min=gp1+OP_GP_SPACING_MIN;\n    offset1=_sr[sri].offset;\n    serialno1=_sr[sri].serialno;\n    for(srj=sri;srj-->0;){\n      ogg_int64_t gp2;\n      opus_int64  offset2;\n      opus_int64  num;\n      ogg_int64_t den;\n      ogg_int64_t ipart;\n      gp2=_sr[srj].gp;\n      if(gp2<gp2_min)continue;\n      /*Oh, and also make sure these came from the same stream.*/\n      if(_sr[srj].serialno!=serialno1)continue;\n      offset2=_sr[srj].offset;\n      /*For once, we can subtract with impunity.*/\n      den=gp2-gp1;\n      ipart=gp2/den;\n      num=offset2-offset1;\n      OP_ASSERT(num>0);\n      if(ipart>0&&(offset2-_searched)/ipart<num)continue;\n      offset2-=ipart*num;\n      gp2-=ipart*den;\n      offset2-=op_rescale64(gp2,den,num)-_bias;\n      if(offset2<_searched)continue;\n      bisect=OP_MIN(bisect,offset2);\n      break;\n    }\n  }\n  return bisect>=_end_searched?-1:bisect;\n}\n\n/*Finds each bitstream link, one at a time, using a bisection search.\n  This has to begin by knowing the offset of the first link's initial page.*/\nstatic int op_bisect_forward_serialno(OggOpusFile *_of,\n opus_int64 _searched,OpusSeekRecord *_sr,int _csr,\n ogg_uint32_t **_serialnos,int *_nserialnos,int *_cserialnos){\n  ogg_page      og;\n  OggOpusLink  *links;\n  int           nlinks;\n  int           clinks;\n  ogg_uint32_t *serialnos;\n  int           nserialnos;\n  ogg_int64_t   total_duration;\n  int           nsr;\n  int           ret;\n  links=_of->links;\n  nlinks=clinks=_of->nlinks;\n  total_duration=0;\n  /*We start with one seek record, for the last page in the file.\n    We build up a list of records for places we seek to during link\n     enumeration.\n    This list is kept sorted in reverse order.\n    We only care about seek locations that were _not_ in the current link,\n     therefore we can add them one at a time to the end of the list as we\n     improve the lower bound on the location where the next link starts.*/\n  nsr=1;\n  for(;;){\n    opus_int64  end_searched;\n    opus_int64  bisect;\n    opus_int64  next;\n    opus_int64  last;\n    ogg_int64_t end_offset;\n    ogg_int64_t end_gp;\n    int         sri;\n    serialnos=*_serialnos;\n    nserialnos=*_nserialnos;\n    if(OP_UNLIKELY(nlinks>=clinks)){\n      if(OP_UNLIKELY(clinks>INT_MAX-1>>1))return OP_EFAULT;\n      clinks=2*clinks+1;\n      OP_ASSERT(nlinks<clinks);\n      links=(OggOpusLink *)_ogg_realloc(links,sizeof(*links)*clinks);\n      if(OP_UNLIKELY(links==NULL))return OP_EFAULT;\n      _of->links=links;\n    }\n    /*Invariants:\n      We have the headers and serial numbers for the link beginning at 'begin'.\n      We have the offset and granule position of the last page in the file\n       (potentially not a page we care about).*/\n    /*Scan the seek records we already have to save us some bisection.*/\n    for(sri=0;sri<nsr;sri++){\n      if(op_lookup_serialno(_sr[sri].serialno,serialnos,nserialnos))break;\n    }\n    /*Is the last page in our current list of serial numbers?*/\n    if(sri<=0)break;\n    /*Last page wasn't found.\n      We have at least one more link.*/\n    last=-1;\n    end_searched=_sr[sri-1].search_start;\n    next=_sr[sri-1].offset;\n    end_gp=-1;\n    if(sri<nsr){\n      _searched=_sr[sri].offset+_sr[sri].size;\n      if(_sr[sri].serialno==links[nlinks-1].serialno){\n        end_gp=_sr[sri].gp;\n        end_offset=_sr[sri].offset;\n      }\n    }\n    nsr=sri;\n    bisect=-1;\n    /*If we've already found the end of at least one link, try to pick the\n       first bisection point at twice the average link size.\n      This is a good choice for files with lots of links that are all about the\n       same size.*/\n    if(nlinks>1){\n      opus_int64 last_offset;\n      opus_int64 avg_link_size;\n      opus_int64 upper_limit;\n      last_offset=links[nlinks-1].offset;\n      avg_link_size=last_offset/(nlinks-1);\n      upper_limit=end_searched-OP_CHUNK_SIZE-avg_link_size;\n      if(OP_LIKELY(last_offset>_searched-avg_link_size)\n       &&OP_LIKELY(last_offset<upper_limit)){\n        bisect=last_offset+avg_link_size;\n        if(OP_LIKELY(bisect<upper_limit))bisect+=avg_link_size;\n      }\n    }\n    /*We guard against garbage separating the last and first pages of two\n       links below.*/\n    while(_searched<end_searched){\n      opus_int32 next_bias;\n      /*If we don't have a better estimate, use simple bisection.*/\n      if(bisect==-1)bisect=_searched+(end_searched-_searched>>1);\n      /*If we're within OP_CHUNK_SIZE of the start, scan forward.*/\n      if(bisect-_searched<OP_CHUNK_SIZE)bisect=_searched;\n      /*Otherwise we're skipping data.\n        Forget the end page, if we saw one, as we might miss a later one.*/\n      else end_gp=-1;\n      ret=op_seek_helper(_of,bisect);\n      if(OP_UNLIKELY(ret<0))return ret;\n      last=op_get_next_page(_of,&og,_sr[nsr-1].offset);\n      if(OP_UNLIKELY(last<OP_FALSE))return (int)last;\n      next_bias=0;\n      if(last==OP_FALSE)end_searched=bisect;\n      else{\n        ogg_uint32_t serialno;\n        ogg_int64_t  gp;\n        serialno=ogg_page_serialno(&og);\n        gp=ogg_page_granulepos(&og);\n        if(!op_lookup_serialno(serialno,serialnos,nserialnos)){\n          end_searched=bisect;\n          next=last;\n          /*In reality we should always have enough room, but be paranoid.*/\n          if(OP_LIKELY(nsr<_csr)){\n            _sr[nsr].search_start=bisect;\n            _sr[nsr].offset=last;\n            OP_ASSERT(_of->offset-last>=0);\n            OP_ASSERT(_of->offset-last<=OP_PAGE_SIZE_MAX);\n            _sr[nsr].size=(opus_int32)(_of->offset-last);\n            _sr[nsr].serialno=serialno;\n            _sr[nsr].gp=gp;\n            nsr++;\n          }\n        }\n        else{\n          _searched=_of->offset;\n          next_bias=OP_CHUNK_SIZE;\n          if(serialno==links[nlinks-1].serialno){\n            /*This page was from the stream we want, remember it.\n              If it's the last such page in the link, we won't have to go back\n               looking for it later.*/\n            end_gp=gp;\n            end_offset=last;\n          }\n        }\n      }\n      bisect=op_predict_link_start(_sr,nsr,_searched,end_searched,next_bias);\n    }\n    /*Bisection point found.\n      Get the final granule position of the previous link, assuming\n       op_find_initial_pcm_offset() didn't already determine the link was\n       empty.*/\n    if(OP_LIKELY(links[nlinks-1].pcm_end==-1)){\n      if(end_gp==-1){\n        /*If we don't know where the end page is, we'll have to seek back and\n           look for it, starting from the end of the link.*/\n        end_offset=next;\n        /*Also forget the last page we read.\n          It won't be available after the seek.*/\n        last=-1;\n      }\n      ret=op_find_final_pcm_offset(_of,serialnos,nserialnos,\n       links+nlinks-1,end_offset,links[nlinks-1].serialno,end_gp,\n       &total_duration);\n      if(OP_UNLIKELY(ret<0))return ret;\n    }\n    if(last!=next){\n      /*The last page we read was not the first page the next link.\n        Move the cursor position to the offset of that first page.\n        This only performs an actual seek if the first page of the next link\n         does not start at the end of the last page from the current Opus\n         stream with a valid granule position.*/\n      ret=op_seek_helper(_of,next);\n      if(OP_UNLIKELY(ret<0))return ret;\n    }\n    ret=op_fetch_headers(_of,&links[nlinks].head,&links[nlinks].tags,\n     _serialnos,_nserialnos,_cserialnos,last!=next?NULL:&og);\n    if(OP_UNLIKELY(ret<0))return ret;\n    /*Mark the current link count so it can be cleaned up on error.*/\n    _of->nlinks=nlinks+1;\n    links[nlinks].offset=next;\n    links[nlinks].data_offset=_of->offset;\n    links[nlinks].serialno=_of->os.serialno;\n    links[nlinks].pcm_end=-1;\n    /*This might consume a page from the next link, however the next bisection\n       always starts with a seek.*/\n    ret=op_find_initial_pcm_offset(_of,links+nlinks,NULL);\n    if(OP_UNLIKELY(ret<0))return ret;\n    links[nlinks].pcm_file_offset=total_duration;\n    _searched=_of->offset;\n    ++nlinks;\n  }\n  /*Last page is in the starting serialno list, so we've reached the last link.\n    Now find the last granule position for it (if we didn't the first time we\n     looked at the end of the stream, and if op_find_initial_pcm_offset()\n     didn't already determine the link was empty).*/\n  if(OP_LIKELY(links[nlinks-1].pcm_end==-1)){\n    ret=op_find_final_pcm_offset(_of,serialnos,nserialnos,\n     links+nlinks-1,_sr[0].offset,_sr[0].serialno,_sr[0].gp,&total_duration);\n    if(OP_UNLIKELY(ret<0))return ret;\n  }\n  /*Trim back the links array if necessary.*/\n  links=(OggOpusLink *)_ogg_realloc(links,sizeof(*links)*nlinks);\n  if(OP_LIKELY(links!=NULL))_of->links=links;\n  /*We also don't need these anymore.*/\n  _ogg_free(*_serialnos);\n  *_serialnos=NULL;\n  *_cserialnos=*_nserialnos=0;\n  return 0;\n}\n\nstatic void op_update_gain(OggOpusFile *_of){\n  OpusHead   *head;\n  opus_int32  gain_q8;\n  int         li;\n  /*If decode isn't ready, then we'll apply the gain when we initialize the\n     decoder.*/\n  if(_of->ready_state<OP_INITSET)return;\n  gain_q8=_of->gain_offset_q8;\n  li=_of->seekable?_of->cur_link:0;\n  head=&_of->links[li].head;\n  /*We don't have to worry about overflow here because the header gain and\n     track gain must lie in the range [-32768,32767], and the user-supplied\n     offset has been pre-clamped to [-98302,98303].*/\n  switch(_of->gain_type){\n    case OP_ALBUM_GAIN:{\n      int album_gain_q8;\n      album_gain_q8=0;\n      opus_tags_get_album_gain(&_of->links[li].tags,&album_gain_q8);\n      gain_q8+=album_gain_q8;\n      gain_q8+=head->output_gain;\n    }break;\n    case OP_TRACK_GAIN:{\n      int track_gain_q8;\n      track_gain_q8=0;\n      opus_tags_get_track_gain(&_of->links[li].tags,&track_gain_q8);\n      gain_q8+=track_gain_q8;\n      gain_q8+=head->output_gain;\n    }break;\n    case OP_HEADER_GAIN:gain_q8+=head->output_gain;break;\n    case OP_ABSOLUTE_GAIN:break;\n    default:OP_ASSERT(0);\n  }\n  gain_q8=OP_CLAMP(-32768,gain_q8,32767);\n  OP_ASSERT(_of->od!=NULL);\n#if defined(OPUS_SET_GAIN)\n  opus_multistream_decoder_ctl(_of->od,OPUS_SET_GAIN(gain_q8));\n#else\n/*A fallback that works with both float and fixed-point is a bunch of work,\n   so just force people to use a sufficiently new version.\n  This is deployed well enough at this point that this shouldn't be a burden.*/\n# error \"libopus 1.0.1 or later required\"\n#endif\n}\n\nstatic int op_make_decode_ready(OggOpusFile *_of){\n  const OpusHead *head;\n  int             li;\n  int             stream_count;\n  int             coupled_count;\n  int             channel_count;\n  if(_of->ready_state>OP_STREAMSET)return 0;\n  if(OP_UNLIKELY(_of->ready_state<OP_STREAMSET))return OP_EFAULT;\n  li=_of->seekable?_of->cur_link:0;\n  head=&_of->links[li].head;\n  stream_count=head->stream_count;\n  coupled_count=head->coupled_count;\n  channel_count=head->channel_count;\n  /*Check to see if the current decoder is compatible with the current link.*/\n  if(_of->od!=NULL&&_of->od_stream_count==stream_count\n   &&_of->od_coupled_count==coupled_count&&_of->od_channel_count==channel_count\n   &&memcmp(_of->od_mapping,head->mapping,\n   sizeof(*head->mapping)*channel_count)==0){\n    opus_multistream_decoder_ctl(_of->od,OPUS_RESET_STATE);\n  }\n  else{\n    int err;\n    opus_multistream_decoder_destroy(_of->od);\n    _of->od=opus_multistream_decoder_create(48000,channel_count,\n     stream_count,coupled_count,head->mapping,&err);\n    if(_of->od==NULL)return OP_EFAULT;\n    _of->od_stream_count=stream_count;\n    _of->od_coupled_count=coupled_count;\n    _of->od_channel_count=channel_count;\n    memcpy(_of->od_mapping,head->mapping,sizeof(*head->mapping)*channel_count);\n  }\n  _of->ready_state=OP_INITSET;\n  _of->bytes_tracked=0;\n  _of->samples_tracked=0;\n#if !defined(OP_FIXED_POINT)\n  _of->state_channel_count=0;\n  /*Use the serial number for the PRNG seed to get repeatable output for\n     straight play-throughs.*/\n  _of->dither_seed=_of->links[li].serialno;\n#endif\n  op_update_gain(_of);\n  return 0;\n}\n\nstatic int op_open_seekable2_impl(OggOpusFile *_of){\n  /*64 seek records should be enough for anybody.\n    Actually, with a bisection search in a 63-bit range down to OP_CHUNK_SIZE\n     granularity, much more than enough.*/\n  OpusSeekRecord sr[64];\n  opus_int64     data_offset;\n  int            ret;\n  /*We can seek, so set out learning all about this file.*/\n  (*_of->callbacks.seek)(_of->stream,0,SEEK_END);\n  _of->offset=_of->end=(*_of->callbacks.tell)(_of->stream);\n  if(OP_UNLIKELY(_of->end<0))return OP_EREAD;\n  data_offset=_of->links[0].data_offset;\n  if(OP_UNLIKELY(_of->end<data_offset))return OP_EBADLINK;\n  /*Get the offset of the last page of the physical bitstream, or, if we're\n     lucky, the last Opus page of the first link, as most Ogg Opus files will\n     contain a single logical bitstream.*/\n  ret=op_get_prev_page_serial(_of,sr,_of->end,\n   _of->links[0].serialno,_of->serialnos,_of->nserialnos);\n  if(OP_UNLIKELY(ret<0))return ret;\n  /*If there's any trailing junk, forget about it.*/\n  _of->end=sr[0].offset+sr[0].size;\n  if(OP_UNLIKELY(_of->end<data_offset))return OP_EBADLINK;\n  /*Now enumerate the bitstream structure.*/\n  return op_bisect_forward_serialno(_of,data_offset,sr,sizeof(sr)/sizeof(*sr),\n   &_of->serialnos,&_of->nserialnos,&_of->cserialnos);\n}\n\nstatic int op_open_seekable2(OggOpusFile *_of){\n  ogg_sync_state    oy_start;\n  ogg_stream_state  os_start;\n  ogg_packet       *op_start;\n  opus_int64        prev_page_offset;\n  opus_int64        start_offset;\n  int               start_op_count;\n  int               ret;\n  /*We're partially open and have a first link header state in storage in _of.\n    Save off that stream state so we can come back to it.\n    It would be simpler to just dump all this state and seek back to\n     links[0].data_offset when we're done.\n    But we do the extra work to allow us to seek back to _exactly_ the same\n     stream position we're at now.\n    This allows, e.g., the HTTP backend to continue reading from the original\n     connection (if it's still available), instead of opening a new one.\n    This means we can open and start playing a normal Opus file with a single\n     link and reasonable packet sizes using only two HTTP requests.*/\n  start_op_count=_of->op_count;\n  /*This is a bit too large to put on the stack unconditionally.*/\n  op_start=(ogg_packet *)_ogg_malloc(sizeof(*op_start)*start_op_count);\n  if(op_start==NULL)return OP_EFAULT;\n  *&oy_start=_of->oy;\n  *&os_start=_of->os;\n  prev_page_offset=_of->prev_page_offset;\n  start_offset=_of->offset;\n  memcpy(op_start,_of->op,sizeof(*op_start)*start_op_count);\n  OP_ASSERT((*_of->callbacks.tell)(_of->stream)==op_position(_of));\n  ogg_sync_init(&_of->oy);\n  ogg_stream_init(&_of->os,-1);\n  ret=op_open_seekable2_impl(_of);\n  /*Restore the old stream state.*/\n  ogg_stream_clear(&_of->os);\n  ogg_sync_clear(&_of->oy);\n  *&_of->oy=*&oy_start;\n  *&_of->os=*&os_start;\n  _of->offset=start_offset;\n  _of->op_count=start_op_count;\n  memcpy(_of->op,op_start,sizeof(*_of->op)*start_op_count);\n  _ogg_free(op_start);\n  _of->prev_packet_gp=_of->links[0].pcm_start;\n  _of->prev_page_offset=prev_page_offset;\n  _of->cur_discard_count=_of->links[0].head.pre_skip;\n  if(OP_UNLIKELY(ret<0))return ret;\n  /*And restore the position indicator.*/\n  ret=(*_of->callbacks.seek)(_of->stream,op_position(_of),SEEK_SET);\n  return OP_UNLIKELY(ret<0)?OP_EREAD:0;\n}\n\n/*Clear out the current logical bitstream decoder.*/\nstatic void op_decode_clear(OggOpusFile *_of){\n  /*We don't actually free the decoder.\n    We might be able to re-use it for the next link.*/\n  _of->op_count=0;\n  _of->od_buffer_size=0;\n  _of->prev_packet_gp=-1;\n  _of->prev_page_offset=-1;\n  if(!_of->seekable){\n    OP_ASSERT(_of->ready_state>=OP_INITSET);\n    opus_tags_clear(&_of->links[0].tags);\n  }\n  _of->ready_state=OP_OPENED;\n}\n\nstatic void op_clear(OggOpusFile *_of){\n  OggOpusLink *links;\n  _ogg_free(_of->od_buffer);\n  if(_of->od!=NULL)opus_multistream_decoder_destroy(_of->od);\n  links=_of->links;\n  if(!_of->seekable){\n    if(_of->ready_state>OP_OPENED||_of->ready_state==OP_PARTOPEN){\n      opus_tags_clear(&links[0].tags);\n    }\n  }\n  else if(OP_LIKELY(links!=NULL)){\n    int nlinks;\n    int link;\n    nlinks=_of->nlinks;\n    for(link=0;link<nlinks;link++)opus_tags_clear(&links[link].tags);\n  }\n  _ogg_free(links);\n  _ogg_free(_of->serialnos);\n  ogg_stream_clear(&_of->os);\n  ogg_sync_clear(&_of->oy);\n  if(_of->callbacks.close!=NULL)(*_of->callbacks.close)(_of->stream);\n}\n\nstatic int op_open1(OggOpusFile *_of,\n void *_stream,const OpusFileCallbacks *_cb,\n const unsigned char *_initial_data,size_t _initial_bytes){\n  ogg_page  og;\n  ogg_page *pog;\n  int       seekable;\n  int       ret;\n  memset(_of,0,sizeof(*_of));\n  if(OP_UNLIKELY(_initial_bytes>(size_t)LONG_MAX))return OP_EFAULT;\n  _of->end=-1;\n  _of->stream=_stream;\n  *&_of->callbacks=*_cb;\n  /*At a minimum, we need to be able to read data.*/\n  if(OP_UNLIKELY(_of->callbacks.read==NULL))return OP_EREAD;\n  /*Initialize the framing state.*/\n  ogg_sync_init(&_of->oy);\n  /*Perhaps some data was previously read into a buffer for testing against\n     other stream types.\n    Allow initialization from this previously read data (especially as we may\n     be reading from a non-seekable stream).\n    This requires copying it into a buffer allocated by ogg_sync_buffer() and\n     doesn't support seeking, so this is not a good mechanism to use for\n     decoding entire files from RAM.*/\n  if(_initial_bytes>0){\n    char *buffer;\n    buffer=ogg_sync_buffer(&_of->oy,(long)_initial_bytes);\n    if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT;\n    memcpy(buffer,_initial_data,_initial_bytes*sizeof(*buffer));\n    ogg_sync_wrote(&_of->oy,(long)_initial_bytes);\n  }\n  /*Can we seek?\n    Stevens suggests the seek test is portable.\n    It's actually not for files on win32, but we address that by fixing it in\n     our callback implementation (see stream.c).*/\n  seekable=_cb->seek!=NULL&&(*_cb->seek)(_stream,0,SEEK_CUR)!=-1;\n  /*If seek is implemented, tell must also be implemented.*/\n  if(seekable){\n    opus_int64 pos;\n    if(OP_UNLIKELY(_of->callbacks.tell==NULL))return OP_EINVAL;\n    pos=(*_of->callbacks.tell)(_of->stream);\n    /*If the current position is not equal to the initial bytes consumed,\n       absolute seeking will not work.*/\n    if(OP_UNLIKELY(pos!=(opus_int64)_initial_bytes))return OP_EINVAL;\n  }\n  _of->seekable=seekable;\n  /*Don't seek yet.\n    Set up a 'single' (current) logical bitstream entry for partial open.*/\n  _of->links=(OggOpusLink *)_ogg_malloc(sizeof(*_of->links));\n  /*The serialno gets filled in later by op_fetch_headers().*/\n  ogg_stream_init(&_of->os,-1);\n  pog=NULL;\n  for(;;){\n    /*Fetch all BOS pages, store the Opus header and all seen serial numbers,\n      and load subsequent Opus setup headers.*/\n    ret=op_fetch_headers(_of,&_of->links[0].head,&_of->links[0].tags,\n     &_of->serialnos,&_of->nserialnos,&_of->cserialnos,pog);\n    if(OP_UNLIKELY(ret<0))break;\n    _of->nlinks=1;\n    _of->links[0].offset=0;\n    _of->links[0].data_offset=_of->offset;\n    _of->links[0].pcm_end=-1;\n    _of->links[0].serialno=_of->os.serialno;\n    /*Fetch the initial PCM offset.*/\n    ret=op_find_initial_pcm_offset(_of,_of->links,&og);\n    if(seekable||OP_LIKELY(ret<=0))break;\n    /*This link was empty, but we already have the BOS page for the next one in\n       og.\n      We can't seek, so start processing the next link right now.*/\n    opus_tags_clear(&_of->links[0].tags);\n    _of->nlinks=0;\n    if(!seekable)_of->cur_link++;\n    pog=&og;\n  }\n  if(OP_LIKELY(ret>=0))_of->ready_state=OP_PARTOPEN;\n  return ret;\n}\n\nstatic int op_open2(OggOpusFile *_of){\n  int ret;\n  OP_ASSERT(_of->ready_state==OP_PARTOPEN);\n  if(_of->seekable){\n    _of->ready_state=OP_OPENED;\n    ret=op_open_seekable2(_of);\n  }\n  else ret=0;\n  if(OP_LIKELY(ret>=0)){\n    /*We have buffered packets from op_find_initial_pcm_offset().\n      Move to OP_INITSET so we can use them.*/\n    _of->ready_state=OP_STREAMSET;\n    ret=op_make_decode_ready(_of);\n    if(OP_LIKELY(ret>=0))return 0;\n  }\n  /*Don't auto-close the stream on failure.*/\n  _of->callbacks.close=NULL;\n  op_clear(_of);\n  return ret;\n}\n\nOggOpusFile *op_test_callbacks(void *_stream,const OpusFileCallbacks *_cb,\n const unsigned char *_initial_data,size_t _initial_bytes,int *_error){\n  OggOpusFile *of;\n  int          ret;\n  of=(OggOpusFile *)_ogg_malloc(sizeof(*of));\n  ret=OP_EFAULT;\n  if(OP_LIKELY(of!=NULL)){\n    ret=op_open1(of,_stream,_cb,_initial_data,_initial_bytes);\n    if(OP_LIKELY(ret>=0)){\n      if(_error!=NULL)*_error=0;\n      return of;\n    }\n    /*Don't auto-close the stream on failure.*/\n    of->callbacks.close=NULL;\n    op_clear(of);\n    _ogg_free(of);\n  }\n  if(_error!=NULL)*_error=ret;\n  return NULL;\n}\n\nOggOpusFile *op_open_callbacks(void *_stream,const OpusFileCallbacks *_cb,\n const unsigned char *_initial_data,size_t _initial_bytes,int *_error){\n  OggOpusFile *of;\n  of=op_test_callbacks(_stream,_cb,_initial_data,_initial_bytes,_error);\n  if(OP_LIKELY(of!=NULL)){\n    int ret;\n    ret=op_open2(of);\n    if(OP_LIKELY(ret>=0))return of;\n    if(_error!=NULL)*_error=ret;\n    _ogg_free(of);\n  }\n  return NULL;\n}\n\n/*Convenience routine to clean up from failure for the open functions that\n   create their own streams.*/\nstatic OggOpusFile *op_open_close_on_failure(void *_stream,\n const OpusFileCallbacks *_cb,int *_error){\n  OggOpusFile *of;\n  if(OP_UNLIKELY(_stream==NULL)){\n    if(_error!=NULL)*_error=OP_EFAULT;\n    return NULL;\n  }\n  of=op_open_callbacks(_stream,_cb,NULL,0,_error);\n  if(OP_UNLIKELY(of==NULL))(*_cb->close)(_stream);\n  return of;\n}\n\nOggOpusFile *op_open_file(const char *_path,int *_error){\n  OpusFileCallbacks cb;\n  return op_open_close_on_failure(op_fopen(&cb,_path,\"rb\"),&cb,_error);\n}\n\nOggOpusFile *op_open_memory(const unsigned char *_data,size_t _size,\n int *_error){\n  OpusFileCallbacks cb;\n  return op_open_close_on_failure(op_mem_stream_create(&cb,_data,_size),&cb,\n   _error);\n}\n\n/*Convenience routine to clean up from failure for the open functions that\n   create their own streams.*/\nstatic OggOpusFile *op_test_close_on_failure(void *_stream,\n const OpusFileCallbacks *_cb,int *_error){\n  OggOpusFile *of;\n  if(OP_UNLIKELY(_stream==NULL)){\n    if(_error!=NULL)*_error=OP_EFAULT;\n    return NULL;\n  }\n  of=op_test_callbacks(_stream,_cb,NULL,0,_error);\n  if(OP_UNLIKELY(of==NULL))(*_cb->close)(_stream);\n  return of;\n}\n\nOggOpusFile *op_test_file(const char *_path,int *_error){\n  OpusFileCallbacks cb;\n  return op_test_close_on_failure(op_fopen(&cb,_path,\"rb\"),&cb,_error);\n}\n\nOggOpusFile *op_test_memory(const unsigned char *_data,size_t _size,\n int *_error){\n  OpusFileCallbacks cb;\n  return op_test_close_on_failure(op_mem_stream_create(&cb,_data,_size),&cb,\n   _error);\n}\n\nint op_test_open(OggOpusFile *_of){\n  int ret;\n  if(OP_UNLIKELY(_of->ready_state!=OP_PARTOPEN))return OP_EINVAL;\n  ret=op_open2(_of);\n  /*op_open2() will clear this structure on failure.\n    Reset its contents to prevent double-frees in op_free().*/\n  if(OP_UNLIKELY(ret<0))memset(_of,0,sizeof(*_of));\n  return ret;\n}\n\nvoid op_free(OggOpusFile *_of){\n  if(OP_LIKELY(_of!=NULL)){\n    op_clear(_of);\n    _ogg_free(_of);\n  }\n}\n\nint op_seekable(const OggOpusFile *_of){\n  return _of->seekable;\n}\n\nint op_link_count(const OggOpusFile *_of){\n  return _of->nlinks;\n}\n\nopus_uint32 op_serialno(const OggOpusFile *_of,int _li){\n  if(OP_UNLIKELY(_li>=_of->nlinks))_li=_of->nlinks-1;\n  if(!_of->seekable)_li=0;\n  return _of->links[_li<0?_of->cur_link:_li].serialno;\n}\n\nint op_channel_count(const OggOpusFile *_of,int _li){\n  return op_head(_of,_li)->channel_count;\n}\n\nopus_int64 op_raw_total(const OggOpusFile *_of,int _li){\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED)\n   ||OP_UNLIKELY(!_of->seekable)\n   ||OP_UNLIKELY(_li>=_of->nlinks)){\n    return OP_EINVAL;\n  }\n  if(_li<0)return _of->end;\n  return (_li+1>=_of->nlinks?_of->end:_of->links[_li+1].offset)\n   -(_li>0?_of->links[_li].offset:0);\n}\n\nogg_int64_t op_pcm_total(const OggOpusFile *_of,int _li){\n  OggOpusLink *links;\n  ogg_int64_t  pcm_total;\n  ogg_int64_t  diff;\n  int          nlinks;\n  nlinks=_of->nlinks;\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED)\n   ||OP_UNLIKELY(!_of->seekable)\n   ||OP_UNLIKELY(_li>=nlinks)){\n    return OP_EINVAL;\n  }\n  links=_of->links;\n  /*We verify that the granule position differences are larger than the\n     pre-skip and that the total duration does not overflow during link\n     enumeration, so we don't have to check here.*/\n  pcm_total=0;\n  if(_li<0){\n    pcm_total=links[nlinks-1].pcm_file_offset;\n    _li=nlinks-1;\n  }\n  OP_ALWAYS_TRUE(!op_granpos_diff(&diff,\n   links[_li].pcm_end,links[_li].pcm_start));\n  return pcm_total+(diff-links[_li].head.pre_skip);\n}\n\nconst OpusHead *op_head(const OggOpusFile *_of,int _li){\n  if(OP_UNLIKELY(_li>=_of->nlinks))_li=_of->nlinks-1;\n  if(!_of->seekable)_li=0;\n  return &_of->links[_li<0?_of->cur_link:_li].head;\n}\n\nconst OpusTags *op_tags(const OggOpusFile *_of,int _li){\n  if(OP_UNLIKELY(_li>=_of->nlinks))_li=_of->nlinks-1;\n  if(!_of->seekable){\n    if(_of->ready_state<OP_STREAMSET&&_of->ready_state!=OP_PARTOPEN){\n      return NULL;\n    }\n    _li=0;\n  }\n  else if(_li<0)_li=_of->ready_state>=OP_STREAMSET?_of->cur_link:0;\n  return &_of->links[_li].tags;\n}\n\nint op_current_link(const OggOpusFile *_of){\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;\n  return _of->cur_link;\n}\n\n/*Compute an average bitrate given a byte and sample count.\n  Return: The bitrate in bits per second.*/\nstatic opus_int32 op_calc_bitrate(opus_int64 _bytes,ogg_int64_t _samples){\n  if(OP_UNLIKELY(_samples<=0))return OP_INT32_MAX;\n  /*These rates are absurd, but let's handle them anyway.*/\n  if(OP_UNLIKELY(_bytes>(OP_INT64_MAX-(_samples>>1))/(48000*8))){\n    ogg_int64_t den;\n    if(OP_UNLIKELY(_bytes/(OP_INT32_MAX/(48000*8))>=_samples)){\n      return OP_INT32_MAX;\n    }\n    den=_samples/(48000*8);\n    return (opus_int32)((_bytes+(den>>1))/den);\n  }\n  /*This can't actually overflow in normal operation: even with a pre-skip of\n     545 2.5 ms frames with 8 streams running at 1282*8+1 bytes per packet\n     (1275 byte frames + Opus framing overhead + Ogg lacing values), that all\n     produce a single sample of decoded output, we still don't top 45 Mbps.\n    The only way to get bitrates larger than that is with excessive Opus\n     padding, more encoded streams than output channels, or lots and lots of\n     Ogg pages with no packets on them.*/\n  return (opus_int32)OP_MIN((_bytes*48000*8+(_samples>>1))/_samples,\n   OP_INT32_MAX);\n}\n\nopus_int32 op_bitrate(const OggOpusFile *_of,int _li){\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED)||OP_UNLIKELY(!_of->seekable)\n   ||OP_UNLIKELY(_li>=_of->nlinks)){\n    return OP_EINVAL;\n  }\n  return op_calc_bitrate(op_raw_total(_of,_li),op_pcm_total(_of,_li));\n}\n\nopus_int32 op_bitrate_instant(OggOpusFile *_of){\n  ogg_int64_t samples_tracked;\n  opus_int32  ret;\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;\n  samples_tracked=_of->samples_tracked;\n  if(OP_UNLIKELY(samples_tracked==0))return OP_FALSE;\n  ret=op_calc_bitrate(_of->bytes_tracked,samples_tracked);\n  _of->bytes_tracked=0;\n  _of->samples_tracked=0;\n  return ret;\n}\n\n/*Given a serialno, find a link with a corresponding Opus stream, if it exists.\n  Return: The index of the link to which the page belongs, or a negative number\n           if it was not a desired Opus bitstream section.*/\nstatic int op_get_link_from_serialno(const OggOpusFile *_of,int _cur_link,\n opus_int64 _page_offset,ogg_uint32_t _serialno){\n  const OggOpusLink *links;\n  int                nlinks;\n  int                li_lo;\n  int                li_hi;\n  OP_ASSERT(_of->seekable);\n  links=_of->links;\n  nlinks=_of->nlinks;\n  li_lo=0;\n  /*Start off by guessing we're just a multiplexed page in the current link.*/\n  li_hi=_cur_link+1<nlinks&&_page_offset<links[_cur_link+1].offset?\n   _cur_link+1:nlinks;\n  do{\n    if(_page_offset>=links[_cur_link].offset)li_lo=_cur_link;\n    else li_hi=_cur_link;\n    _cur_link=li_lo+(li_hi-li_lo>>1);\n  }\n  while(li_hi-li_lo>1);\n  /*We've identified the link that should contain this page.\n    Make sure it's a page we care about.*/\n  if(links[_cur_link].serialno!=_serialno)return OP_FALSE;\n  return _cur_link;\n}\n\n/*Fetch and process a page.\n  This handles the case where we're at a bitstream boundary and dumps the\n   decoding machine.\n  If the decoding machine is unloaded, it loads it.\n  It also keeps prev_packet_gp up to date (seek and read both use this).\n  Return: <0) Error, OP_HOLE (lost packet), or OP_EOF.\n           0) Got at least one audio data packet.*/\nstatic int op_fetch_and_process_page(OggOpusFile *_of,\n ogg_page *_og,opus_int64 _page_offset,int _spanp,int _ignore_holes){\n  OggOpusLink  *links;\n  ogg_uint32_t  cur_serialno;\n  int           seekable;\n  int           cur_link;\n  int           ret;\n  /*We shouldn't get here if we have unprocessed packets.*/\n  OP_ASSERT(_of->ready_state<OP_INITSET||_of->op_pos>=_of->op_count);\n  seekable=_of->seekable;\n  links=_of->links;\n  cur_link=seekable?_of->cur_link:0;\n  cur_serialno=links[cur_link].serialno;\n  /*Handle one page.*/\n  for(;;){\n    ogg_page og;\n    OP_ASSERT(_of->ready_state>=OP_OPENED);\n    /*If we were given a page to use, use it.*/\n    if(_og!=NULL){\n      *&og=*_og;\n      _og=NULL;\n    }\n    /*Keep reading until we get a page with the correct serialno.*/\n    else _page_offset=op_get_next_page(_of,&og,_of->end);\n    /*EOF: Leave uninitialized.*/\n    if(_page_offset<0)return _page_offset<OP_FALSE?(int)_page_offset:OP_EOF;\n    if(OP_LIKELY(_of->ready_state>=OP_STREAMSET)\n     &&cur_serialno!=(ogg_uint32_t)ogg_page_serialno(&og)){\n      /*Two possibilities:\n         1) Another stream is multiplexed into this logical section, or*/\n      if(OP_LIKELY(!ogg_page_bos(&og)))continue;\n      /* 2) Our decoding just traversed a bitstream boundary.*/\n      if(!_spanp)return OP_EOF;\n      if(OP_LIKELY(_of->ready_state>=OP_INITSET))op_decode_clear(_of);\n    }\n    /*Bitrate tracking: add the header's bytes here.\n      The body bytes are counted when we consume the packets.*/\n    else _of->bytes_tracked+=og.header_len;\n    /*Do we need to load a new machine before submitting the page?\n      This is different in the seekable and non-seekable cases.\n      In the seekable case, we already have all the header information loaded\n       and cached.\n      We just initialize the machine with it and continue on our merry way.\n      In the non-seekable (streaming) case, we'll only be at a boundary if we\n       just left the previous logical bitstream, and we're now nominally at the\n       header of the next bitstream.*/\n    if(OP_UNLIKELY(_of->ready_state<OP_STREAMSET)){\n      if(seekable){\n        ogg_uint32_t serialno;\n        serialno=ogg_page_serialno(&og);\n        /*Match the serialno to bitstream section.*/\n        OP_ASSERT(cur_link>=0&&cur_link<_of->nlinks);\n        if(links[cur_link].serialno!=serialno){\n          /*It wasn't a page from the current link.\n            Is it from the next one?*/\n          if(OP_LIKELY(cur_link+1<_of->nlinks&&links[cur_link+1].serialno==\n           serialno)){\n            cur_link++;\n          }\n          else{\n            int new_link;\n            new_link=\n             op_get_link_from_serialno(_of,cur_link,_page_offset,serialno);\n            /*Not a desired Opus bitstream section.\n              Keep trying.*/\n            if(new_link<0)continue;\n            cur_link=new_link;\n          }\n        }\n        cur_serialno=serialno;\n        _of->cur_link=cur_link;\n        ogg_stream_reset_serialno(&_of->os,serialno);\n        _of->ready_state=OP_STREAMSET;\n        /*If we're at the start of this link, initialize the granule position\n           and pre-skip tracking.*/\n        if(_page_offset<=links[cur_link].data_offset){\n          _of->prev_packet_gp=links[cur_link].pcm_start;\n          _of->prev_page_offset=-1;\n          _of->cur_discard_count=links[cur_link].head.pre_skip;\n          /*Ignore a hole at the start of a new link (this is common for\n             streams joined in the middle) or after seeking.*/\n          _ignore_holes=1;\n        }\n      }\n      else{\n        do{\n          /*We're streaming.\n            Fetch the two header packets, build the info struct.*/\n          ret=op_fetch_headers(_of,&links[0].head,&links[0].tags,\n           NULL,NULL,NULL,&og);\n          if(OP_UNLIKELY(ret<0))return ret;\n          /*op_find_initial_pcm_offset() will suppress any initial hole for us,\n             so no need to set _ignore_holes.*/\n          ret=op_find_initial_pcm_offset(_of,links,&og);\n          if(OP_UNLIKELY(ret<0))return ret;\n          _of->links[0].serialno=cur_serialno=_of->os.serialno;\n          _of->cur_link++;\n        }\n        /*If the link was empty, keep going, because we already have the\n           BOS page of the next one in og.*/\n        while(OP_UNLIKELY(ret>0));\n        /*If we didn't get any packets out of op_find_initial_pcm_offset(),\n           keep going (this is possible if end-trimming trimmed them all).*/\n        if(_of->op_count<=0)continue;\n        /*Otherwise, we're done.\n          TODO: This resets bytes_tracked, which misses the header bytes\n           already processed by op_find_initial_pcm_offset().*/\n        ret=op_make_decode_ready(_of);\n        if(OP_UNLIKELY(ret<0))return ret;\n        return 0;\n      }\n    }\n    /*The buffered page is the data we want, and we're ready for it.\n      Add it to the stream state.*/\n    if(OP_UNLIKELY(_of->ready_state==OP_STREAMSET)){\n      ret=op_make_decode_ready(_of);\n      if(OP_UNLIKELY(ret<0))return ret;\n    }\n    /*Extract all the packets from the current page.*/\n    ogg_stream_pagein(&_of->os,&og);\n    if(OP_LIKELY(_of->ready_state>=OP_INITSET)){\n      opus_int32 total_duration;\n      int        durations[255];\n      int        op_count;\n      int        report_hole;\n      report_hole=0;\n      total_duration=op_collect_audio_packets(_of,durations);\n      if(OP_UNLIKELY(total_duration<0)){\n        /*libogg reported a hole (a gap in the page sequence numbers).\n          Drain the packets from the page anyway.\n          If we don't, they'll still be there when we fetch the next page.\n          Then, when we go to pull out packets, we might get more than 255,\n           which would overrun our packet buffer.\n          We repeat this call until we get any actual packets, since we might\n           have buffered multiple out-of-sequence pages with no packets on\n           them.*/\n        do total_duration=op_collect_audio_packets(_of,durations);\n        while(total_duration<0);\n        if(!_ignore_holes){\n          /*Report the hole to the caller after we finish timestamping the\n             packets.*/\n          report_hole=1;\n          /*We had lost or damaged pages, so reset our granule position\n             tracking.\n            This makes holes behave the same as a small raw seek.\n            If the next page is the EOS page, we'll discard it (because we\n             can't perform end trimming properly), and we'll always discard at\n             least 80 ms of audio (to allow decoder state to re-converge).\n            We could try to fill in the gap with PLC by looking at timestamps\n             in the non-EOS case, but that's complicated and error prone and we\n             can't rely on the timestamps being valid.*/\n          _of->prev_packet_gp=-1;\n        }\n      }\n      op_count=_of->op_count;\n      /*If we found at least one audio data packet, compute per-packet granule\n         positions for them.*/\n      if(op_count>0){\n        ogg_int64_t diff;\n        ogg_int64_t prev_packet_gp;\n        ogg_int64_t cur_packet_gp;\n        ogg_int64_t cur_page_gp;\n        int         cur_page_eos;\n        int         pi;\n        cur_page_gp=_of->op[op_count-1].granulepos;\n        cur_page_eos=_of->op[op_count-1].e_o_s;\n        prev_packet_gp=_of->prev_packet_gp;\n        if(OP_UNLIKELY(prev_packet_gp==-1)){\n          opus_int32 cur_discard_count;\n          /*This is the first call after a raw seek.\n            Try to reconstruct prev_packet_gp from scratch.*/\n          OP_ASSERT(seekable);\n          if(OP_UNLIKELY(cur_page_eos)){\n            /*If the first page we hit after our seek was the EOS page, and\n               we didn't start from data_offset or before, we don't have\n               enough information to do end-trimming.\n              Proceed to the next link, rather than risk playing back some\n               samples that shouldn't have been played.*/\n            _of->op_count=0;\n            if(report_hole)return OP_HOLE;\n            continue;\n          }\n          /*By default discard 80 ms of data after a seek, unless we seek\n             into the pre-skip region.*/\n          cur_discard_count=80*48;\n          cur_page_gp=_of->op[op_count-1].granulepos;\n          /*Try to initialize prev_packet_gp.\n            If the current page had packets but didn't have a granule\n             position, or the granule position it had was too small (both\n             illegal), just use the starting granule position for the link.*/\n          prev_packet_gp=links[cur_link].pcm_start;\n          if(OP_LIKELY(cur_page_gp!=-1)){\n            op_granpos_add(&prev_packet_gp,cur_page_gp,-total_duration);\n          }\n          if(OP_LIKELY(!op_granpos_diff(&diff,\n           prev_packet_gp,links[cur_link].pcm_start))){\n            opus_int32 pre_skip;\n            /*If we start at the beginning of the pre-skip region, or we're\n               at least 80 ms from the end of the pre-skip region, we discard\n               to the end of the pre-skip region.\n              Otherwise, we still use the 80 ms default, which will discard\n               past the end of the pre-skip region.*/\n            pre_skip=links[cur_link].head.pre_skip;\n            if(diff>=0&&diff<=OP_MAX(0,pre_skip-80*48)){\n              cur_discard_count=pre_skip-(int)diff;\n            }\n          }\n          _of->cur_discard_count=cur_discard_count;\n        }\n        if(OP_UNLIKELY(cur_page_gp==-1)){\n          /*This page had completed packets but didn't have a valid granule\n             position.\n            This is illegal, but we'll try to handle it by continuing to count\n             forwards from the previous page.*/\n          if(op_granpos_add(&cur_page_gp,prev_packet_gp,total_duration)<0){\n            /*The timestamp for this page overflowed.*/\n            cur_page_gp=links[cur_link].pcm_end;\n          }\n        }\n        /*If we hit the last page, handle end-trimming.*/\n        if(OP_UNLIKELY(cur_page_eos)\n         &&OP_LIKELY(!op_granpos_diff(&diff,cur_page_gp,prev_packet_gp))\n         &&OP_LIKELY(diff<total_duration)){\n          cur_packet_gp=prev_packet_gp;\n          for(pi=0;pi<op_count;pi++){\n            /*Check for overflow.*/\n            if(diff<0&&OP_UNLIKELY(OP_INT64_MAX+diff<durations[pi])){\n              diff=durations[pi]+1;\n            }\n            else diff=durations[pi]-diff;\n            /*If we have samples to trim...*/\n            if(diff>0){\n              /*If we trimmed the entire packet, stop (the spec says encoders\n                 shouldn't do this, but we support it anyway).*/\n              if(OP_UNLIKELY(diff>durations[pi]))break;\n              cur_packet_gp=cur_page_gp;\n              /*Move the EOS flag to this packet, if necessary, so we'll trim\n                 the samples during decode.*/\n              _of->op[pi].e_o_s=1;\n            }\n            else{\n              /*Update the granule position as normal.*/\n              OP_ALWAYS_TRUE(!op_granpos_add(&cur_packet_gp,\n               cur_packet_gp,durations[pi]));\n            }\n            _of->op[pi].granulepos=cur_packet_gp;\n            OP_ALWAYS_TRUE(!op_granpos_diff(&diff,cur_page_gp,cur_packet_gp));\n          }\n        }\n        else{\n          /*Propagate timestamps to earlier packets.\n            op_granpos_add(&prev_packet_gp,prev_packet_gp,total_duration)\n             should succeed and give prev_packet_gp==cur_page_gp.\n            But we don't bother to check that, as there isn't much we can do\n             if it's not true, and it actually will not be true on the first\n             page after a seek, if there was a continued packet.\n            The only thing we guarantee is that the start and end granule\n             positions of the packets are valid, and that they are monotonic\n             within a page.\n            They might be completely out of range for this link (we'll check\n             that elsewhere), or non-monotonic between pages.*/\n          if(OP_UNLIKELY(op_granpos_add(&prev_packet_gp,\n           cur_page_gp,-total_duration)<0)){\n            /*The starting timestamp for the first packet on this page\n               underflowed.\n              This is illegal, but we ignore it.*/\n            prev_packet_gp=0;\n          }\n          for(pi=0;pi<op_count;pi++){\n            if(OP_UNLIKELY(op_granpos_add(&cur_packet_gp,\n             cur_page_gp,-total_duration)<0)){\n              /*The start timestamp for this packet underflowed.\n                This is illegal, but we ignore it.*/\n              cur_packet_gp=0;\n            }\n            total_duration-=durations[pi];\n            OP_ASSERT(total_duration>=0);\n            OP_ALWAYS_TRUE(!op_granpos_add(&cur_packet_gp,\n             cur_packet_gp,durations[pi]));\n            _of->op[pi].granulepos=cur_packet_gp;\n          }\n          OP_ASSERT(total_duration==0);\n        }\n        _of->prev_packet_gp=prev_packet_gp;\n        _of->prev_page_offset=_page_offset;\n        _of->op_count=op_count=pi;\n      }\n      if(report_hole)return OP_HOLE;\n      /*If end-trimming didn't trim all the packets, we're done.*/\n      if(op_count>0)return 0;\n    }\n  }\n}\n\nint op_raw_seek(OggOpusFile *_of,opus_int64 _pos){\n  int ret;\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;\n  /*Don't dump the decoder state if we can't seek.*/\n  if(OP_UNLIKELY(!_of->seekable))return OP_ENOSEEK;\n  if(OP_UNLIKELY(_pos<0)||OP_UNLIKELY(_pos>_of->end))return OP_EINVAL;\n  /*Clear out any buffered, decoded data.*/\n  op_decode_clear(_of);\n  _of->bytes_tracked=0;\n  _of->samples_tracked=0;\n  ret=op_seek_helper(_of,_pos);\n  if(OP_UNLIKELY(ret<0))return OP_EREAD;\n  ret=op_fetch_and_process_page(_of,NULL,-1,1,1);\n  /*If we hit EOF, op_fetch_and_process_page() leaves us uninitialized.\n    Instead, jump to the end.*/\n  if(ret==OP_EOF){\n    int cur_link;\n    op_decode_clear(_of);\n    cur_link=_of->nlinks-1;\n    _of->cur_link=cur_link;\n    _of->prev_packet_gp=_of->links[cur_link].pcm_end;\n    _of->cur_discard_count=0;\n    ret=0;\n  }\n  return ret;\n}\n\n/*Convert a PCM offset relative to the start of the whole stream to a granule\n   position in an individual link.*/\nstatic ogg_int64_t op_get_granulepos(const OggOpusFile *_of,\n ogg_int64_t _pcm_offset,int *_li){\n  const OggOpusLink *links;\n  ogg_int64_t        duration;\n  ogg_int64_t        pcm_start;\n  opus_int32         pre_skip;\n  int                nlinks;\n  int                li_lo;\n  int                li_hi;\n  OP_ASSERT(_pcm_offset>=0);\n  nlinks=_of->nlinks;\n  links=_of->links;\n  li_lo=0;\n  li_hi=nlinks;\n  do{\n    int li;\n    li=li_lo+(li_hi-li_lo>>1);\n    if(links[li].pcm_file_offset<=_pcm_offset)li_lo=li;\n    else li_hi=li;\n  }\n  while(li_hi-li_lo>1);\n  _pcm_offset-=links[li_lo].pcm_file_offset;\n  pcm_start=links[li_lo].pcm_start;\n  pre_skip=links[li_lo].head.pre_skip;\n  OP_ALWAYS_TRUE(!op_granpos_diff(&duration,links[li_lo].pcm_end,pcm_start));\n  duration-=pre_skip;\n  if(_pcm_offset>=duration)return -1;\n  _pcm_offset+=pre_skip;\n  if(OP_UNLIKELY(pcm_start>OP_INT64_MAX-_pcm_offset)){\n    /*Adding this amount to the granule position would overflow the positive\n       half of its 64-bit range.\n      Since signed overflow is undefined in C, do it in a way the compiler\n       isn't allowed to screw up.*/\n    _pcm_offset-=OP_INT64_MAX-pcm_start+1;\n    pcm_start=OP_INT64_MIN;\n  }\n  pcm_start+=_pcm_offset;\n  *_li=li_lo;\n  return pcm_start;\n}\n\n/*A small helper to determine if an Ogg page contains data that continues onto\n   a subsequent page.*/\nstatic int op_page_continues(const ogg_page *_og){\n  int nlacing;\n  OP_ASSERT(_og->header_len>=27);\n  nlacing=_og->header[26];\n  OP_ASSERT(_og->header_len>=27+nlacing);\n  /*This also correctly handles the (unlikely) case of nlacing==0, because\n     0!=255.*/\n  return _og->header[27+nlacing-1]==255;\n}\n\n/*A small helper to buffer the continued packet data from a page.*/\nstatic void op_buffer_continued_data(OggOpusFile *_of,ogg_page *_og){\n  ogg_packet op;\n  ogg_stream_pagein(&_of->os,_og);\n  /*Drain any packets that did end on this page (and ignore holes).\n    We only care about the continued packet data.*/\n  while(ogg_stream_packetout(&_of->os,&op));\n}\n\n/*This controls how close the target has to be to use the current stream\n   position to subdivide the initial range.\n  Two minutes seems to be a good default.*/\n#define OP_CUR_TIME_THRESH (120*48*(opus_int32)1000)\n\n/*Note: The OP_SMALL_FOOTPRINT #define doesn't (currently) save much code size,\n   but it's meant to serve as documentation for portions of the seeking\n   algorithm that are purely optional, to aid others learning from/porting this\n   code to other contexts.*/\n/*#define OP_SMALL_FOOTPRINT (1)*/\n\n/*Search within link _li for the page with the highest granule position\n   preceding (or equal to) _target_gp.\n  There is a danger here: missing pages or incorrect frame number information\n   in the bitstream could make our task impossible.\n  Account for that (and report it as an error condition).*/\nstatic int op_pcm_seek_page(OggOpusFile *_of,\n ogg_int64_t _target_gp,int _li){\n  const OggOpusLink *link;\n  ogg_page           og;\n  ogg_int64_t        pcm_pre_skip;\n  ogg_int64_t        pcm_start;\n  ogg_int64_t        pcm_end;\n  ogg_int64_t        best_gp;\n  ogg_int64_t        diff;\n  ogg_uint32_t       serialno;\n  opus_int32         pre_skip;\n  opus_int64         begin;\n  opus_int64         end;\n  opus_int64         boundary;\n  opus_int64         best;\n  opus_int64         best_start;\n  opus_int64         page_offset;\n  opus_int64         d0;\n  opus_int64         d1;\n  opus_int64         d2;\n  int                force_bisect;\n  int                buffering;\n  int                ret;\n  _of->bytes_tracked=0;\n  _of->samples_tracked=0;\n  link=_of->links+_li;\n  best_gp=pcm_start=link->pcm_start;\n  pcm_end=link->pcm_end;\n  serialno=link->serialno;\n  best=best_start=begin=link->data_offset;\n  page_offset=-1;\n  buffering=0;\n  /*We discard the first 80 ms of data after a seek, so seek back that much\n     farther.\n    If we can't, simply seek to the beginning of the link.*/\n  if(OP_UNLIKELY(op_granpos_add(&_target_gp,_target_gp,-80*48)<0)\n   ||OP_UNLIKELY(op_granpos_cmp(_target_gp,pcm_start)<0)){\n    _target_gp=pcm_start;\n  }\n  /*Special case seeking to the start of the link.*/\n  pre_skip=link->head.pre_skip;\n  OP_ALWAYS_TRUE(!op_granpos_add(&pcm_pre_skip,pcm_start,pre_skip));\n  if(op_granpos_cmp(_target_gp,pcm_pre_skip)<0)end=boundary=begin;\n  else{\n    end=boundary=link->end_offset;\n#if !defined(OP_SMALL_FOOTPRINT)\n    /*If we were decoding from this link, we can narrow the range a bit.*/\n    if(_li==_of->cur_link&&_of->ready_state>=OP_INITSET){\n      opus_int64 offset;\n      int        op_count;\n      op_count=_of->op_count;\n      /*The offset can be out of range if we were reading through the stream\n         and encountered a page with the granule position for another link\n         outside of the data range identified during link enumeration when we\n         were opening the file.\n        We will just ignore the current position in that case.\n        The only way the offset can be valid _and_ we can fail the granule\n         position checks below is if someone changed the contents of the last\n         page since we read it.\n        We'd be within our rights to just return OP_EBADLINK, but instead we'll\n         simply ignore the current position in that case, too.*/\n      offset=_of->offset;\n      if(op_count>0&&OP_LIKELY(begin<=offset&&offset<=end)){\n        ogg_int64_t gp;\n        /*Make sure the timestamp is valid.\n          The granule position might be -1 if we collected the packets from a\n           page without a granule position after reporting a hole.*/\n        gp=_of->op[op_count-1].granulepos;\n        if(OP_LIKELY(gp!=-1)&&OP_LIKELY(op_granpos_cmp(pcm_start,gp)<0)\n         &&OP_LIKELY(op_granpos_cmp(pcm_end,gp)>0)){\n          OP_ALWAYS_TRUE(!op_granpos_diff(&diff,gp,_target_gp));\n          /*We only actually use the current time if either\n            a) We can cut off at least half the range, or\n            b) We're seeking sufficiently close to the current position that\n                it's likely to be informative.\n            Otherwise it appears using the whole link range to estimate the\n             first seek location gives better results, on average.*/\n          if(diff<0){\n            if(offset-begin>=end-begin>>1||diff>-OP_CUR_TIME_THRESH){\n              best=begin=offset;\n              best_gp=pcm_start=gp;\n              /*If we have buffered data from a continued packet, remember the\n                 offset of the previous page's start, so that if we do wind up\n                 having to seek back here later, we can prime the stream with\n                 the continued packet data.\n                With no continued packet, we remember the end of the page.*/\n              best_start=_of->os.body_returned<_of->os.body_fill?\n               _of->prev_page_offset:best;\n              /*If there's completed packets and data in the stream state,\n                 prev_page_offset should always be set.*/\n              OP_ASSERT(best_start>=0);\n              /*Buffer any continued packet data starting from here.*/\n              buffering=1;\n            }\n          }\n          else{\n            ogg_int64_t prev_page_gp;\n            /*We might get lucky and already have the packet with the target\n               buffered.\n              Worth checking.\n              For very small files (with all of the data in a single page,\n               generally 1 second or less), we can loop them continuously\n               without seeking at all.*/\n            if(op_granpos_add(&prev_page_gp,_of->op[0].granulepos,\n             -op_get_packet_duration(_of->op[0].packet,_of->op[0].bytes))<0) {\n              /*We validate/sanitize the per-packet timestamps, so the only way\n                 we should fail to calculate a granule position for the\n                 previous page is if the first page with completed packets in\n                 the stream is also the last, and end-trimming causes the\n                 apparent granule position preceding the first sample in the\n                 first packet to underflow.\n                The starting PCM offset is then 0 by spec mandate (see also:\n                 op_find_initial_pcm_offset()).*/\n              OP_ASSERT(_of->op[0].e_o_s);\n              prev_page_gp=0;\n            }\n            if(op_granpos_cmp(prev_page_gp,_target_gp)<=0){\n              /*Don't call op_decode_clear(), because it will dump our\n                 packets.*/\n              _of->op_pos=0;\n              _of->od_buffer_size=0;\n              _of->prev_packet_gp=prev_page_gp;\n              /*_of->prev_page_offset already points to the right place.*/\n              _of->ready_state=OP_STREAMSET;\n              return op_make_decode_ready(_of);\n            }\n            /*No such luck.\n              Check if we can cut off at least half the range, though.*/\n            if(offset-begin<=end-begin>>1||diff<OP_CUR_TIME_THRESH){\n              /*We really want the page start here, but this will do.*/\n              end=boundary=offset;\n              pcm_end=gp;\n            }\n          }\n        }\n      }\n    }\n#endif\n  }\n  /*This code was originally based on the \"new search algorithm by HB (Nicholas\n     Vinen)\" from libvorbisfile.\n    It has been modified substantially since.*/\n  op_decode_clear(_of);\n  if(!buffering)ogg_stream_reset_serialno(&_of->os,serialno);\n  _of->cur_link=_li;\n  _of->ready_state=OP_STREAMSET;\n  /*Initialize the interval size history.*/\n  d2=d1=d0=end-begin;\n  force_bisect=0;\n  while(begin<end){\n    opus_int64 bisect;\n    opus_int64 next_boundary;\n    opus_int32 chunk_size;\n    if(end-begin<OP_CHUNK_SIZE)bisect=begin;\n    else{\n      /*Update the interval size history.*/\n      d0=d1>>1;\n      d1=d2>>1;\n      d2=end-begin>>1;\n      if(force_bisect)bisect=begin+(end-begin>>1);\n      else{\n        ogg_int64_t diff2;\n        OP_ALWAYS_TRUE(!op_granpos_diff(&diff,_target_gp,pcm_start));\n        OP_ALWAYS_TRUE(!op_granpos_diff(&diff2,pcm_end,pcm_start));\n        /*Take a (pretty decent) guess.*/\n        bisect=begin+op_rescale64(diff,diff2,end-begin)-OP_CHUNK_SIZE;\n      }\n      if(bisect-OP_CHUNK_SIZE<begin)bisect=begin;\n      force_bisect=0;\n    }\n    if(bisect!=_of->offset){\n      /*Discard any buffered continued packet data.*/\n      if(buffering)ogg_stream_reset(&_of->os);\n      buffering=0;\n      page_offset=-1;\n      ret=op_seek_helper(_of,bisect);\n      if(OP_UNLIKELY(ret<0))return ret;\n    }\n    chunk_size=OP_CHUNK_SIZE;\n    next_boundary=boundary;\n    /*Now scan forward and figure out where we landed.\n      In the ideal case, we will see a page with a granule position at or\n       before our target, followed by a page with a granule position after our\n       target (or the end of the search interval).\n      Then we can just drop out and will have all of the data we need with no\n       additional seeking.\n      If we landed too far before, or after, we'll break out and do another\n       bisection.*/\n    while(begin<end){\n      page_offset=op_get_next_page(_of,&og,boundary);\n      if(page_offset<0){\n        if(page_offset<OP_FALSE)return (int)page_offset;\n        /*There are no more pages in our interval from our stream with a valid\n           timestamp that start at position bisect or later.*/\n        /*If we scanned the whole interval, we're done.*/\n        if(bisect<=begin+1)end=begin;\n        else{\n          /*Otherwise, back up one chunk.\n            First, discard any data from a continued packet.*/\n          if(buffering)ogg_stream_reset(&_of->os);\n          buffering=0;\n          bisect=OP_MAX(bisect-chunk_size,begin);\n          ret=op_seek_helper(_of,bisect);\n          if(OP_UNLIKELY(ret<0))return ret;\n          /*Bump up the chunk size.*/\n          chunk_size=OP_MIN(2*chunk_size,OP_CHUNK_SIZE_MAX);\n          /*If we did find a page from another stream or without a timestamp,\n             don't read past it.*/\n          boundary=next_boundary;\n        }\n      }\n      else{\n        ogg_int64_t gp;\n        int         has_packets;\n        /*Save the offset of the first page we found after the seek, regardless\n           of the stream it came from or whether or not it has a timestamp.*/\n        next_boundary=OP_MIN(page_offset,next_boundary);\n        if(serialno!=(ogg_uint32_t)ogg_page_serialno(&og))continue;\n        has_packets=ogg_page_packets(&og)>0;\n        /*Force the gp to -1 (as it should be per spec) if no packets end on\n           this page.\n          Otherwise we might get confused when we try to pull out a packet\n           with that timestamp and can't find it.*/\n        gp=has_packets?ogg_page_granulepos(&og):-1;\n        if(gp==-1){\n          if(buffering){\n            if(OP_LIKELY(!has_packets))ogg_stream_pagein(&_of->os,&og);\n            else{\n              /*If packets did end on this page, but we still didn't have a\n                 valid granule position (in violation of the spec!), stop\n                 buffering continued packet data.\n                Otherwise we might continue past the packet we actually\n                 wanted.*/\n              ogg_stream_reset(&_of->os);\n              buffering=0;\n            }\n          }\n          continue;\n        }\n        if(op_granpos_cmp(gp,_target_gp)<0){\n          /*We found a page that ends before our target.\n            Advance to the raw offset of the next page.*/\n          begin=_of->offset;\n          if(OP_UNLIKELY(op_granpos_cmp(pcm_start,gp)>0)\n           ||OP_UNLIKELY(op_granpos_cmp(pcm_end,gp)<0)){\n            /*Don't let pcm_start get out of range!\n              That could happen with an invalid timestamp.*/\n            break;\n          }\n          /*Save the byte offset of the end of the page with this granule\n             position.*/\n          best=best_start=begin;\n          /*Buffer any data from a continued packet, if necessary.\n            This avoids the need to seek back here if the next timestamp we\n             encounter while scanning forward lies after our target.*/\n          if(buffering)ogg_stream_reset(&_of->os);\n          if(op_page_continues(&og)){\n            op_buffer_continued_data(_of,&og);\n            /*If we have a continued packet, remember the offset of this\n               page's start, so that if we do wind up having to seek back here\n               later, we can prime the stream with the continued packet data.\n              With no continued packet, we remember the end of the page.*/\n            best_start=page_offset;\n          }\n          /*Then force buffering on, so that if a packet starts (but does not\n             end) on the next page, we still avoid the extra seek back.*/\n          buffering=1;\n          best_gp=pcm_start=gp;\n          OP_ALWAYS_TRUE(!op_granpos_diff(&diff,_target_gp,pcm_start));\n          /*If we're more than a second away from our target, break out and\n             do another bisection.*/\n          if(diff>48000)break;\n          /*Otherwise, keep scanning forward (do NOT use begin+1).*/\n          bisect=begin;\n        }\n        else{\n          /*We found a page that ends after our target.*/\n          /*If we scanned the whole interval before we found it, we're done.*/\n          if(bisect<=begin+1)end=begin;\n          else{\n            end=bisect;\n            /*In later iterations, don't read past the first page we found.*/\n            boundary=next_boundary;\n            /*If we're not making much progress shrinking the interval size,\n               start forcing straight bisection to limit the worst case.*/\n            force_bisect=end-begin>d0*2;\n            /*Don't let pcm_end get out of range!\n              That could happen with an invalid timestamp.*/\n            if(OP_LIKELY(op_granpos_cmp(pcm_end,gp)>0)\n             &&OP_LIKELY(op_granpos_cmp(pcm_start,gp)<=0)){\n              pcm_end=gp;\n            }\n            break;\n          }\n        }\n      }\n    }\n  }\n  /*Found our page.*/\n  OP_ASSERT(op_granpos_cmp(best_gp,pcm_start)>=0);\n  /*Seek, if necessary.\n    If we were buffering data from a continued packet, we should be able to\n     continue to scan forward to get the rest of the data (even if\n     page_offset==-1).\n    Otherwise, we need to seek back to best_start.*/\n  if(!buffering){\n    if(best_start!=page_offset){\n      page_offset=-1;\n      ret=op_seek_helper(_of,best_start);\n      if(OP_UNLIKELY(ret<0))return ret;\n    }\n    if(best_start<best){\n      /*Retrieve the page at best_start, if we do not already have it.*/\n      if(page_offset<0){\n        page_offset=op_get_next_page(_of,&og,link->end_offset);\n        if(OP_UNLIKELY(page_offset<OP_FALSE))return (int)page_offset;\n        if(OP_UNLIKELY(page_offset!=best_start))return OP_EBADLINK;\n      }\n      op_buffer_continued_data(_of,&og);\n      page_offset=-1;\n    }\n  }\n  /*Update prev_packet_gp to allow per-packet granule position assignment.*/\n  _of->prev_packet_gp=best_gp;\n  _of->prev_page_offset=best_start;\n  ret=op_fetch_and_process_page(_of,page_offset<0?NULL:&og,page_offset,0,1);\n  if(OP_UNLIKELY(ret<0))return OP_EBADLINK;\n  /*Verify result.*/\n  if(OP_UNLIKELY(op_granpos_cmp(_of->prev_packet_gp,_target_gp)>0)){\n    return OP_EBADLINK;\n  }\n  /*Our caller will set cur_discard_count to handle pre-roll.*/\n  return 0;\n}\n\nint op_pcm_seek(OggOpusFile *_of,ogg_int64_t _pcm_offset){\n  const OggOpusLink *link;\n  ogg_int64_t        pcm_start;\n  ogg_int64_t        target_gp;\n  ogg_int64_t        prev_packet_gp;\n  ogg_int64_t        skip;\n  ogg_int64_t        diff;\n  int                op_count;\n  int                op_pos;\n  int                ret;\n  int                li;\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;\n  if(OP_UNLIKELY(!_of->seekable))return OP_ENOSEEK;\n  if(OP_UNLIKELY(_pcm_offset<0))return OP_EINVAL;\n  target_gp=op_get_granulepos(_of,_pcm_offset,&li);\n  if(OP_UNLIKELY(target_gp==-1))return OP_EINVAL;\n  link=_of->links+li;\n  pcm_start=link->pcm_start;\n  OP_ALWAYS_TRUE(!op_granpos_diff(&_pcm_offset,target_gp,pcm_start));\n#if !defined(OP_SMALL_FOOTPRINT)\n  /*For small (90 ms or less) forward seeks within the same link, just decode\n     forward.\n    This also optimizes the case of seeking to the current position.*/\n  if(li==_of->cur_link&&_of->ready_state>=OP_INITSET){\n    ogg_int64_t gp;\n    gp=_of->prev_packet_gp;\n    if(OP_LIKELY(gp!=-1)){\n      ogg_int64_t discard_count;\n      int         nbuffered;\n      nbuffered=OP_MAX(_of->od_buffer_size-_of->od_buffer_pos,0);\n      OP_ALWAYS_TRUE(!op_granpos_add(&gp,gp,-nbuffered));\n      /*We do _not_ add cur_discard_count to gp.\n        Otherwise the total amount to discard could grow without bound, and it\n         would be better just to do a full seek.*/\n      if(OP_LIKELY(!op_granpos_diff(&discard_count,target_gp,gp))){\n        /*We use a threshold of 90 ms instead of 80, since 80 ms is the\n           _minimum_ we would have discarded after a full seek.\n          Assuming 20 ms frames (the default), we'd discard 90 ms on average.*/\n        if(discard_count>=0&&OP_UNLIKELY(discard_count<90*48)){\n          _of->cur_discard_count=(opus_int32)discard_count;\n          return 0;\n        }\n      }\n    }\n  }\n#endif\n  ret=op_pcm_seek_page(_of,target_gp,li);\n  if(OP_UNLIKELY(ret<0))return ret;\n  /*Now skip samples until we actually get to our target.*/\n  /*Figure out where we should skip to.*/\n  if(_pcm_offset<=link->head.pre_skip)skip=0;\n  else skip=OP_MAX(_pcm_offset-80*48,0);\n  OP_ASSERT(_pcm_offset-skip>=0);\n  OP_ASSERT(_pcm_offset-skip<OP_INT32_MAX-120*48);\n  /*Skip packets until we find one with samples past our skip target.*/\n  for(;;){\n    op_count=_of->op_count;\n    prev_packet_gp=_of->prev_packet_gp;\n    for(op_pos=_of->op_pos;op_pos<op_count;op_pos++){\n      ogg_int64_t cur_packet_gp;\n      cur_packet_gp=_of->op[op_pos].granulepos;\n      if(OP_LIKELY(!op_granpos_diff(&diff,cur_packet_gp,pcm_start))\n       &&diff>skip){\n        break;\n      }\n      prev_packet_gp=cur_packet_gp;\n    }\n    _of->prev_packet_gp=prev_packet_gp;\n    _of->op_pos=op_pos;\n    if(op_pos<op_count)break;\n    /*We skipped all the packets on this page.\n      Fetch another.*/\n    ret=op_fetch_and_process_page(_of,NULL,-1,0,1);\n    if(OP_UNLIKELY(ret<0))return OP_EBADLINK;\n  }\n  /*We skipped too far, or couldn't get within 2 billion samples of the target.\n    Either the timestamps were illegal or there was a hole in the data.*/\n  if(op_granpos_diff(&diff,prev_packet_gp,pcm_start)||diff>skip\n   ||_pcm_offset-diff>=OP_INT32_MAX){\n    return OP_EBADLINK;\n  }\n  /*TODO: If there are further holes/illegal timestamps, we still won't decode\n     to the correct sample.\n    However, at least op_pcm_tell() will report the correct value immediately\n     after returning.*/\n  _of->cur_discard_count=(opus_int32)(_pcm_offset-diff);\n  return 0;\n}\n\nopus_int64 op_raw_tell(const OggOpusFile *_of){\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;\n  return _of->offset;\n}\n\n/*Convert a granule position from a given link to a PCM offset relative to the\n   start of the whole stream.\n  For unseekable sources, this gets reset to 0 at the beginning of each link.*/\nstatic ogg_int64_t op_get_pcm_offset(const OggOpusFile *_of,\n ogg_int64_t _gp,int _li){\n  const OggOpusLink *links;\n  ogg_int64_t        pcm_offset;\n  links=_of->links;\n  OP_ASSERT(_li>=0&&_li<_of->nlinks);\n  pcm_offset=links[_li].pcm_file_offset;\n  if(_of->seekable&&OP_UNLIKELY(op_granpos_cmp(_gp,links[_li].pcm_end)>0)){\n    _gp=links[_li].pcm_end;\n  }\n  if(OP_LIKELY(op_granpos_cmp(_gp,links[_li].pcm_start)>0)){\n    ogg_int64_t delta;\n    if(OP_UNLIKELY(op_granpos_diff(&delta,_gp,links[_li].pcm_start)<0)){\n      /*This means an unseekable stream claimed to have a page from more than\n         2 billion days after we joined.*/\n      OP_ASSERT(!_of->seekable);\n      return OP_INT64_MAX;\n    }\n    if(delta<links[_li].head.pre_skip)delta=0;\n    else delta-=links[_li].head.pre_skip;\n    /*In the seekable case, _gp was limited by pcm_end.\n      In the unseekable case, pcm_offset should be 0.*/\n    OP_ASSERT(pcm_offset<=OP_INT64_MAX-delta);\n    pcm_offset+=delta;\n  }\n  return pcm_offset;\n}\n\nogg_int64_t op_pcm_tell(const OggOpusFile *_of){\n  ogg_int64_t gp;\n  int         nbuffered;\n  int         li;\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;\n  gp=_of->prev_packet_gp;\n  if(gp==-1)return 0;\n  nbuffered=OP_MAX(_of->od_buffer_size-_of->od_buffer_pos,0);\n  OP_ALWAYS_TRUE(!op_granpos_add(&gp,gp,-nbuffered));\n  li=_of->seekable?_of->cur_link:0;\n  if(op_granpos_add(&gp,gp,_of->cur_discard_count)<0){\n    gp=_of->links[li].pcm_end;\n  }\n  return op_get_pcm_offset(_of,gp,li);\n}\n\nvoid op_set_decode_callback(OggOpusFile *_of,\n op_decode_cb_func _decode_cb,void *_ctx){\n  _of->decode_cb=_decode_cb;\n  _of->decode_cb_ctx=_ctx;\n}\n\nint op_set_gain_offset(OggOpusFile *_of,\n int _gain_type,opus_int32 _gain_offset_q8){\n  if(_gain_type!=OP_HEADER_GAIN&&_gain_type!=OP_ALBUM_GAIN\n   &&_gain_type!=OP_TRACK_GAIN&&_gain_type!=OP_ABSOLUTE_GAIN){\n    return OP_EINVAL;\n  }\n  _of->gain_type=_gain_type;\n  /*The sum of header gain and track gain lies in the range [-65536,65534].\n    These bounds allow the offset to set the final value to anywhere in the\n     range [-32768,32767], which is what we'll clamp it to before applying.*/\n  _of->gain_offset_q8=OP_CLAMP(-98302,_gain_offset_q8,98303);\n  op_update_gain(_of);\n  return 0;\n}\n\nvoid op_set_dither_enabled(OggOpusFile *_of,int _enabled){\n#if !defined(OP_FIXED_POINT)\n  _of->dither_disabled=!_enabled;\n  if(!_enabled)_of->dither_mute=65;\n#endif\n}\n\n/*Allocate the decoder scratch buffer.\n  This is done lazily, since if the user provides large enough buffers, we'll\n   never need it.*/\nstatic int op_init_buffer(OggOpusFile *_of){\n  int nchannels_max;\n  if(_of->seekable){\n    const OggOpusLink *links;\n    int                nlinks;\n    int                li;\n    links=_of->links;\n    nlinks=_of->nlinks;\n    nchannels_max=1;\n    for(li=0;li<nlinks;li++){\n      nchannels_max=OP_MAX(nchannels_max,links[li].head.channel_count);\n    }\n  }\n  else nchannels_max=OP_NCHANNELS_MAX;\n  _of->od_buffer=(op_sample *)_ogg_malloc(\n   sizeof(*_of->od_buffer)*nchannels_max*120*48);\n  if(_of->od_buffer==NULL)return OP_EFAULT;\n  return 0;\n}\n\n/*Decode a single packet into the target buffer.*/\nstatic int op_decode(OggOpusFile *_of,op_sample *_pcm,\n const ogg_packet *_op,int _nsamples,int _nchannels){\n  int ret;\n  /*First we try using the application-provided decode callback.*/\n  if(_of->decode_cb!=NULL){\n#if defined(OP_FIXED_POINT)\n    ret=(*_of->decode_cb)(_of->decode_cb_ctx,_of->od,_pcm,_op,\n     _nsamples,_nchannels,OP_DEC_FORMAT_SHORT,_of->cur_link);\n#else\n    ret=(*_of->decode_cb)(_of->decode_cb_ctx,_of->od,_pcm,_op,\n     _nsamples,_nchannels,OP_DEC_FORMAT_FLOAT,_of->cur_link);\n#endif\n  }\n  else ret=OP_DEC_USE_DEFAULT;\n  /*If the application didn't want to handle decoding, do it ourselves.*/\n  if(ret==OP_DEC_USE_DEFAULT){\n#if defined(OP_FIXED_POINT)\n    ret=opus_multistream_decode(_of->od,\n     _op->packet,_op->bytes,_pcm,_nsamples,0);\n#else\n    ret=opus_multistream_decode_float(_of->od,\n     _op->packet,_op->bytes,_pcm,_nsamples,0);\n#endif\n    OP_ASSERT(ret<0||ret==_nsamples);\n  }\n  /*If the application returned a positive value other than 0 or\n     OP_DEC_USE_DEFAULT, fail.*/\n  else if(OP_UNLIKELY(ret>0))return OP_EBADPACKET;\n  if(OP_UNLIKELY(ret<0))return OP_EBADPACKET;\n  return ret;\n}\n\n/*Read more samples from the stream, using the same API as op_read() or\n   op_read_float().*/\nstatic int op_read_native(OggOpusFile *_of,\n op_sample *_pcm,int _buf_size,int *_li){\n  if(OP_UNLIKELY(_of->ready_state<OP_OPENED))return OP_EINVAL;\n  for(;;){\n    int ret;\n    if(OP_LIKELY(_of->ready_state>=OP_INITSET)){\n      int nchannels;\n      int od_buffer_pos;\n      int nsamples;\n      int op_pos;\n      nchannels=_of->links[_of->seekable?_of->cur_link:0].head.channel_count;\n      od_buffer_pos=_of->od_buffer_pos;\n      nsamples=_of->od_buffer_size-od_buffer_pos;\n      /*If we have buffered samples, return them.*/\n      if(nsamples>0){\n        if(nsamples*nchannels>_buf_size)nsamples=_buf_size/nchannels;\n        OP_ASSERT(_pcm!=NULL||nsamples<=0);\n        /*Check nsamples again so we don't pass NULL to memcpy() if _buf_size\n           is zero.\n          That would technically be undefined behavior, even if the number of\n           bytes to copy were zero.*/\n        if(nsamples>0){\n          memcpy(_pcm,_of->od_buffer+nchannels*od_buffer_pos,\n           sizeof(*_pcm)*nchannels*nsamples);\n          od_buffer_pos+=nsamples;\n          _of->od_buffer_pos=od_buffer_pos;\n        }\n        if(_li!=NULL)*_li=_of->cur_link;\n        return nsamples;\n      }\n      /*If we have buffered packets, decode one.*/\n      op_pos=_of->op_pos;\n      if(OP_LIKELY(op_pos<_of->op_count)){\n        const ogg_packet *pop;\n        ogg_int64_t       diff;\n        opus_int32        cur_discard_count;\n        int               duration;\n        int               trimmed_duration;\n        pop=_of->op+op_pos++;\n        _of->op_pos=op_pos;\n        cur_discard_count=_of->cur_discard_count;\n        duration=op_get_packet_duration(pop->packet,pop->bytes);\n        /*We don't buffer packets with an invalid TOC sequence.*/\n        OP_ASSERT(duration>0);\n        trimmed_duration=duration;\n        /*Perform end-trimming.*/\n        if(OP_UNLIKELY(pop->e_o_s)){\n          if(OP_UNLIKELY(op_granpos_cmp(pop->granulepos,\n           _of->prev_packet_gp)<=0)){\n            trimmed_duration=0;\n          }\n          else if(OP_LIKELY(!op_granpos_diff(&diff,\n           pop->granulepos,_of->prev_packet_gp))){\n            trimmed_duration=(int)OP_MIN(diff,trimmed_duration);\n          }\n        }\n        _of->prev_packet_gp=pop->granulepos;\n        if(OP_UNLIKELY(duration*nchannels>_buf_size)){\n          op_sample *buf;\n          /*If the user's buffer is too small, decode into a scratch buffer.*/\n          buf=_of->od_buffer;\n          if(OP_UNLIKELY(buf==NULL)){\n            ret=op_init_buffer(_of);\n            if(OP_UNLIKELY(ret<0))return ret;\n            buf=_of->od_buffer;\n          }\n          ret=op_decode(_of,buf,pop,duration,nchannels);\n          if(OP_UNLIKELY(ret<0))return ret;\n          /*Perform pre-skip/pre-roll.*/\n          od_buffer_pos=(int)OP_MIN(trimmed_duration,cur_discard_count);\n          cur_discard_count-=od_buffer_pos;\n          _of->cur_discard_count=cur_discard_count;\n          _of->od_buffer_pos=od_buffer_pos;\n          _of->od_buffer_size=trimmed_duration;\n          /*Update bitrate tracking based on the actual samples we used from\n             what was decoded.*/\n          _of->bytes_tracked+=pop->bytes;\n          _of->samples_tracked+=trimmed_duration-od_buffer_pos;\n        }\n        else{\n          OP_ASSERT(_pcm!=NULL);\n          /*Otherwise decode directly into the user's buffer.*/\n          ret=op_decode(_of,_pcm,pop,duration,nchannels);\n          if(OP_UNLIKELY(ret<0))return ret;\n          if(OP_LIKELY(trimmed_duration>0)){\n            /*Perform pre-skip/pre-roll.*/\n            od_buffer_pos=(int)OP_MIN(trimmed_duration,cur_discard_count);\n            cur_discard_count-=od_buffer_pos;\n            _of->cur_discard_count=cur_discard_count;\n            trimmed_duration-=od_buffer_pos;\n            if(OP_LIKELY(trimmed_duration>0)\n             &&OP_UNLIKELY(od_buffer_pos>0)){\n              memmove(_pcm,_pcm+od_buffer_pos*nchannels,\n               sizeof(*_pcm)*trimmed_duration*nchannels);\n            }\n            /*Update bitrate tracking based on the actual samples we used from\n               what was decoded.*/\n            _of->bytes_tracked+=pop->bytes;\n            _of->samples_tracked+=trimmed_duration;\n            if(OP_LIKELY(trimmed_duration>0)){\n              if(_li!=NULL)*_li=_of->cur_link;\n              return trimmed_duration;\n            }\n          }\n        }\n        /*Don't grab another page yet.\n          This one might have more packets, or might have buffered data now.*/\n        continue;\n      }\n    }\n    /*Suck in another page.*/\n    ret=op_fetch_and_process_page(_of,NULL,-1,1,0);\n    if(OP_UNLIKELY(ret==OP_EOF)){\n      if(_li!=NULL)*_li=_of->cur_link;\n      return 0;\n    }\n    if(OP_UNLIKELY(ret<0))return ret;\n  }\n}\n\n/*A generic filter to apply to the decoded audio data.\n  _src is non-const because we will destructively modify the contents of the\n   source buffer that we consume in some cases.*/\ntypedef int (*op_read_filter_func)(OggOpusFile *_of,void *_dst,int _dst_sz,\n op_sample *_src,int _nsamples,int _nchannels);\n\n/*Decode some samples and then apply a custom filter to them.\n  This is used to convert to different output formats.*/\nstatic int op_filter_read_native(OggOpusFile *_of,void *_dst,int _dst_sz,\n op_read_filter_func _filter,int *_li){\n  int ret;\n  /*Ensure we have some decoded samples in our buffer.*/\n  ret=op_read_native(_of,NULL,0,_li);\n  /*Now apply the filter to them.*/\n  if(OP_LIKELY(ret>=0)&&OP_LIKELY(_of->ready_state>=OP_INITSET)){\n    int od_buffer_pos;\n    od_buffer_pos=_of->od_buffer_pos;\n    ret=_of->od_buffer_size-od_buffer_pos;\n    if(OP_LIKELY(ret>0)){\n      int nchannels;\n      nchannels=_of->links[_of->seekable?_of->cur_link:0].head.channel_count;\n      ret=(*_filter)(_of,_dst,_dst_sz,\n       _of->od_buffer+nchannels*od_buffer_pos,ret,nchannels);\n      OP_ASSERT(ret>=0);\n      OP_ASSERT(ret<=_of->od_buffer_size-od_buffer_pos);\n      od_buffer_pos+=ret;\n      _of->od_buffer_pos=od_buffer_pos;\n    }\n  }\n  return ret;\n}\n\n#if !defined(OP_FIXED_POINT)||!defined(OP_DISABLE_FLOAT_API)\n\n/*Matrices for downmixing from the supported channel counts to stereo.\n  The matrices with 5 or more channels are normalized to a total volume of 2.0,\n   since most mixes sound too quiet if normalized to 1.0 (as there is generally\n   little volume in the side/rear channels).*/\nstatic const float OP_STEREO_DOWNMIX[OP_NCHANNELS_MAX-2][OP_NCHANNELS_MAX][2]={\n  /*3.0*/\n  {\n    {0.5858F,0.0F},{0.4142F,0.4142F},{0.0F,0.5858F}\n  },\n  /*quadrophonic*/\n  {\n    {0.4226F,0.0F},{0.0F,0.4226F},{0.366F,0.2114F},{0.2114F,0.336F}\n  },\n  /*5.0*/\n  {\n    {0.651F,0.0F},{0.46F,0.46F},{0.0F,0.651F},{0.5636F,0.3254F},\n    {0.3254F,0.5636F}\n  },\n  /*5.1*/\n  {\n    {0.529F,0.0F},{0.3741F,0.3741F},{0.0F,0.529F},{0.4582F,0.2645F},\n    {0.2645F,0.4582F},{0.3741F,0.3741F}\n  },\n  /*6.1*/\n  {\n    {0.4553F,0.0F},{0.322F,0.322F},{0.0F,0.4553F},{0.3943F,0.2277F},\n    {0.2277F,0.3943F},{0.2788F,0.2788F},{0.322F,0.322F}\n  },\n  /*7.1*/\n  {\n    {0.3886F,0.0F},{0.2748F,0.2748F},{0.0F,0.3886F},{0.3366F,0.1943F},\n    {0.1943F,0.3366F},{0.3366F,0.1943F},{0.1943F,0.3366F},{0.2748F,0.2748F}\n  }\n};\n\n#endif\n\n#if defined(OP_FIXED_POINT)\n\n/*Matrices for downmixing from the supported channel counts to stereo.\n  The matrices with 5 or more channels are normalized to a total volume of 2.0,\n   since most mixes sound too quiet if normalized to 1.0 (as there is generally\n   little volume in the side/rear channels).\n  Hence we keep the coefficients in Q14, so the downmix values won't overflow a\n   32-bit number.*/\nstatic const opus_int16 OP_STEREO_DOWNMIX_Q14\n [OP_NCHANNELS_MAX-2][OP_NCHANNELS_MAX][2]={\n  /*3.0*/\n  {\n    {9598,0},{6786,6786},{0,9598}\n  },\n  /*quadrophonic*/\n  {\n    {6924,0},{0,6924},{5996,3464},{3464,5996}\n  },\n  /*5.0*/\n  {\n    {10666,0},{7537,7537},{0,10666},{9234,5331},{5331,9234}\n  },\n  /*5.1*/\n  {\n    {8668,0},{6129,6129},{0,8668},{7507,4335},{4335,7507},{6129,6129}\n  },\n  /*6.1*/\n  {\n    {7459,0},{5275,5275},{0,7459},{6460,3731},{3731,6460},{4568,4568},\n    {5275,5275}\n  },\n  /*7.1*/\n  {\n    {6368,0},{4502,4502},{0,6368},{5515,3183},{3183,5515},{5515,3183},\n    {3183,5515},{4502,4502}\n  }\n};\n\nint op_read(OggOpusFile *_of,opus_int16 *_pcm,int _buf_size,int *_li){\n  return op_read_native(_of,_pcm,_buf_size,_li);\n}\n\nstatic int op_stereo_filter(OggOpusFile *_of,void *_dst,int _dst_sz,\n op_sample *_src,int _nsamples,int _nchannels){\n  (void)_of;\n  _nsamples=OP_MIN(_nsamples,_dst_sz>>1);\n  if(_nchannels==2)memcpy(_dst,_src,_nsamples*2*sizeof(*_src));\n  else{\n    opus_int16 *dst;\n    int         i;\n    dst=(opus_int16 *)_dst;\n    if(_nchannels==1){\n      for(i=0;i<_nsamples;i++)dst[2*i+0]=dst[2*i+1]=_src[i];\n    }\n    else{\n      for(i=0;i<_nsamples;i++){\n        opus_int32 l;\n        opus_int32 r;\n        int        ci;\n        l=r=0;\n        for(ci=0;ci<_nchannels;ci++){\n          opus_int32 s;\n          s=_src[_nchannels*i+ci];\n          l+=OP_STEREO_DOWNMIX_Q14[_nchannels-3][ci][0]*s;\n          r+=OP_STEREO_DOWNMIX_Q14[_nchannels-3][ci][1]*s;\n        }\n        /*TODO: For 5 or more channels, we should do soft clipping here.*/\n        dst[2*i+0]=(opus_int16)OP_CLAMP(-32768,l+8192>>14,32767);\n        dst[2*i+1]=(opus_int16)OP_CLAMP(-32768,r+8192>>14,32767);\n      }\n    }\n  }\n  return _nsamples;\n}\n\nint op_read_stereo(OggOpusFile *_of,opus_int16 *_pcm,int _buf_size){\n  return op_filter_read_native(_of,_pcm,_buf_size,op_stereo_filter,NULL);\n}\n\n# if !defined(OP_DISABLE_FLOAT_API)\n\nstatic int op_short2float_filter(OggOpusFile *_of,void *_dst,int _dst_sz,\n op_sample *_src,int _nsamples,int _nchannels){\n  float *dst;\n  int    i;\n  (void)_of;\n  dst=(float *)_dst;\n  if(OP_UNLIKELY(_nsamples*_nchannels>_dst_sz))_nsamples=_dst_sz/_nchannels;\n  _dst_sz=_nsamples*_nchannels;\n  for(i=0;i<_dst_sz;i++)dst[i]=(1.0F/32768)*_src[i];\n  return _nsamples;\n}\n\nint op_read_float(OggOpusFile *_of,float *_pcm,int _buf_size,int *_li){\n  return op_filter_read_native(_of,_pcm,_buf_size,op_short2float_filter,_li);\n}\n\nstatic int op_short2float_stereo_filter(OggOpusFile *_of,\n void *_dst,int _dst_sz,op_sample *_src,int _nsamples,int _nchannels){\n  float *dst;\n  int    i;\n  dst=(float *)_dst;\n  _nsamples=OP_MIN(_nsamples,_dst_sz>>1);\n  if(_nchannels==1){\n    _nsamples=op_short2float_filter(_of,dst,_nsamples,_src,_nsamples,1);\n    for(i=_nsamples;i-->0;)dst[2*i+0]=dst[2*i+1]=dst[i];\n  }\n  else if(_nchannels<5){\n    /*For 3 or 4 channels, we can downmix in fixed point without risk of\n       clipping.*/\n    if(_nchannels>2){\n      _nsamples=op_stereo_filter(_of,_src,_nsamples*2,\n       _src,_nsamples,_nchannels);\n    }\n    return op_short2float_filter(_of,dst,_dst_sz,_src,_nsamples,2);\n  }\n  else{\n    /*For 5 or more channels, we convert to floats and then downmix (so that we\n       don't risk clipping).*/\n    for(i=0;i<_nsamples;i++){\n      float l;\n      float r;\n      int   ci;\n      l=r=0;\n      for(ci=0;ci<_nchannels;ci++){\n        float s;\n        s=(1.0F/32768)*_src[_nchannels*i+ci];\n        l+=OP_STEREO_DOWNMIX[_nchannels-3][ci][0]*s;\n        r+=OP_STEREO_DOWNMIX[_nchannels-3][ci][1]*s;\n      }\n      dst[2*i+0]=l;\n      dst[2*i+1]=r;\n    }\n  }\n  return _nsamples;\n}\n\nint op_read_float_stereo(OggOpusFile *_of,float *_pcm,int _buf_size){\n  return op_filter_read_native(_of,_pcm,_buf_size,\n   op_short2float_stereo_filter,NULL);\n}\n\n# endif\n\n#else\n\n# if defined(OP_HAVE_LRINTF)\n#  include <math.h>\n#  define op_float2int(_x) (lrintf(_x))\n# else\n#  define op_float2int(_x) ((int)((_x)+((_x)<0?-0.5F:0.5F)))\n# endif\n\n/*The dithering code here is adapted from opusdec, part of opus-tools.\n  It was originally written by Greg Maxwell.*/\n\nstatic opus_uint32 op_rand(opus_uint32 _seed){\n  return _seed*96314165+907633515&0xFFFFFFFFU;\n}\n\n/*This implements 16-bit quantization with full triangular dither and IIR noise\n   shaping.\n  The noise shaping filters were designed by Sebastian Gesemann, and are based\n   on the LAME ATH curves with flattening to limit their peak gain to 20 dB.\n  Everyone else's noise shaping filters are mildly crazy.\n  The 48 kHz version of this filter is just a warped version of the 44.1 kHz\n   filter and probably could be improved by shifting the HF shelf up in\n   frequency a little bit, since 48 kHz has a bit more room and being more\n   conservative against bat-ears is probably more important than more noise\n   suppression.\n  This process can increase the peak level of the signal (in theory by the peak\n   error of 1.5 +20 dB, though that is unobservably rare).\n  To avoid clipping, the signal is attenuated by a couple thousandths of a dB.\n  Initially, the approach taken here was to only attenuate by the 99.9th\n   percentile, making clipping rare but not impossible (like SoX), but the\n   limited gain of the filter means that the worst case was only two\n   thousandths of a dB more, so this just uses the worst case.\n  The attenuation is probably also helpful to prevent clipping in the DAC\n   reconstruction filters or downstream resampling, in any case.*/\n\n# define OP_GAIN (32753.0F)\n\n# define OP_PRNG_GAIN (1.0F/(float)0xFFFFFFFF)\n\n/*48 kHz noise shaping filter, sd=2.34.*/\n\nstatic const float OP_FCOEF_B[4]={\n  2.2374F,-0.7339F,-0.1251F,-0.6033F\n};\n\nstatic const float OP_FCOEF_A[4]={\n  0.9030F,0.0116F,-0.5853F,-0.2571F\n};\n\nstatic int op_float2short_filter(OggOpusFile *_of,void *_dst,int _dst_sz,\n float *_src,int _nsamples,int _nchannels){\n  opus_int16 *dst;\n  int         ci;\n  int         i;\n  dst=(opus_int16 *)_dst;\n  if(OP_UNLIKELY(_nsamples*_nchannels>_dst_sz))_nsamples=_dst_sz/_nchannels;\n# if defined(OP_SOFT_CLIP)\n  if(_of->state_channel_count!=_nchannels){\n    for(ci=0;ci<_nchannels;ci++)_of->clip_state[ci]=0;\n  }\n  opus_pcm_soft_clip(_src,_nsamples,_nchannels,_of->clip_state);\n# endif\n  if(_of->dither_disabled){\n    for(i=0;i<_nchannels*_nsamples;i++){\n      dst[i]=op_float2int(OP_CLAMP(-32768,32768.0F*_src[i],32767));\n    }\n  }\n  else{\n    opus_uint32 seed;\n    int         mute;\n    seed=_of->dither_seed;\n    mute=_of->dither_mute;\n    if(_of->state_channel_count!=_nchannels)mute=65;\n    /*In order to avoid replacing digital silence with quiet dither noise, we\n       mute if the output has been silent for a while.*/\n    if(mute>64)memset(_of->dither_a,0,sizeof(*_of->dither_a)*4*_nchannels);\n    for(i=0;i<_nsamples;i++){\n      int silent;\n      silent=1;\n      for(ci=0;ci<_nchannels;ci++){\n        float r;\n        float s;\n        float err;\n        int   si;\n        int   j;\n        s=_src[_nchannels*i+ci];\n        silent&=s==0;\n        s*=OP_GAIN;\n        err=0;\n        for(j=0;j<4;j++){\n          err+=OP_FCOEF_B[j]*_of->dither_b[ci*4+j]\n           -OP_FCOEF_A[j]*_of->dither_a[ci*4+j];\n        }\n        for(j=3;j-->0;)_of->dither_a[ci*4+j+1]=_of->dither_a[ci*4+j];\n        for(j=3;j-->0;)_of->dither_b[ci*4+j+1]=_of->dither_b[ci*4+j];\n        _of->dither_a[ci*4]=err;\n        s-=err;\n        if(mute>16)r=0;\n        else{\n          seed=op_rand(seed);\n          r=seed*OP_PRNG_GAIN;\n          seed=op_rand(seed);\n          r-=seed*OP_PRNG_GAIN;\n        }\n        /*Clamp in float out of paranoia that the input will be > 96 dBFS and\n           wrap if the integer is clamped.*/\n        si=op_float2int(OP_CLAMP(-32768,s+r,32767));\n        dst[_nchannels*i+ci]=(opus_int16)si;\n        /*Including clipping in the noise shaping is generally disastrous: the\n           futile effort to restore the clipped energy results in more clipping.\n          However, small amounts---at the level which could normally be created\n           by dither and rounding---are harmless and can even reduce clipping\n           somewhat due to the clipping sometimes reducing the dither + rounding\n           error.*/\n        _of->dither_b[ci*4]=mute>16?0:OP_CLAMP(-1.5F,si-s,1.5F);\n      }\n      mute++;\n      if(!silent)mute=0;\n    }\n    _of->dither_mute=OP_MIN(mute,65);\n    _of->dither_seed=seed;\n  }\n  _of->state_channel_count=_nchannels;\n  return _nsamples;\n}\n\nint op_read(OggOpusFile *_of,opus_int16 *_pcm,int _buf_size,int *_li){\n  return op_filter_read_native(_of,_pcm,_buf_size,op_float2short_filter,_li);\n}\n\nint op_read_float(OggOpusFile *_of,float *_pcm,int _buf_size,int *_li){\n  _of->state_channel_count=0;\n  return op_read_native(_of,_pcm,_buf_size,_li);\n}\n\nstatic int op_stereo_filter(OggOpusFile *_of,void *_dst,int _dst_sz,\n op_sample *_src,int _nsamples,int _nchannels){\n  (void)_of;\n  _nsamples=OP_MIN(_nsamples,_dst_sz>>1);\n  if(_nchannels==2)memcpy(_dst,_src,_nsamples*2*sizeof(*_src));\n  else{\n    float *dst;\n    int    i;\n    dst=(float *)_dst;\n    if(_nchannels==1){\n      for(i=0;i<_nsamples;i++)dst[2*i+0]=dst[2*i+1]=_src[i];\n    }\n    else{\n      for(i=0;i<_nsamples;i++){\n        float l;\n        float r;\n        int   ci;\n        l=r=0;\n        for(ci=0;ci<_nchannels;ci++){\n          l+=OP_STEREO_DOWNMIX[_nchannels-3][ci][0]*_src[_nchannels*i+ci];\n          r+=OP_STEREO_DOWNMIX[_nchannels-3][ci][1]*_src[_nchannels*i+ci];\n        }\n        dst[2*i+0]=l;\n        dst[2*i+1]=r;\n      }\n    }\n  }\n  return _nsamples;\n}\n\nstatic int op_float2short_stereo_filter(OggOpusFile *_of,\n void *_dst,int _dst_sz,op_sample *_src,int _nsamples,int _nchannels){\n  opus_int16 *dst;\n  dst=(opus_int16 *)_dst;\n  if(_nchannels==1){\n    int i;\n    _nsamples=op_float2short_filter(_of,dst,_dst_sz>>1,_src,_nsamples,1);\n    for(i=_nsamples;i-->0;)dst[2*i+0]=dst[2*i+1]=dst[i];\n  }\n  else{\n    if(_nchannels>2){\n      _nsamples=OP_MIN(_nsamples,_dst_sz>>1);\n      _nsamples=op_stereo_filter(_of,_src,_nsamples*2,\n       _src,_nsamples,_nchannels);\n    }\n    _nsamples=op_float2short_filter(_of,dst,_dst_sz,_src,_nsamples,2);\n  }\n  return _nsamples;\n}\n\nint op_read_stereo(OggOpusFile *_of,opus_int16 *_pcm,int _buf_size){\n  return op_filter_read_native(_of,_pcm,_buf_size,\n   op_float2short_stereo_filter,NULL);\n}\n\nint op_read_float_stereo(OggOpusFile *_of,float *_pcm,int _buf_size){\n  _of->state_channel_count=0;\n  return op_filter_read_native(_of,_pcm,_buf_size,op_stereo_filter,NULL);\n}\n\n#endif\n"], "buggy_code_start_loc": [150], "buggy_code_end_loc": [1529], "fixing_code_start_loc": [151], "fixing_code_end_loc": [1532], "type": "CWE-476", "message": "A null pointer dereference issue was discovered in functions op_get_data and op_open1 in opusfile.c in xiph opusfile 0.9 thru 0.12 allows attackers to cause denial of service or other unspecified impacts.", "other": {"cve": {"id": "CVE-2022-47021", "sourceIdentifier": "cve@mitre.org", "published": "2023-01-20T19:15:17.550", "lastModified": "2023-02-10T03:15:11.697", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A null pointer dereference issue was discovered in functions op_get_data and op_open1 in opusfile.c in xiph opusfile 0.9 thru 0.12 allows attackers to cause denial of service or other unspecified impacts."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xiph:opusfile:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.9", "versionEndIncluding": "0.12", "matchCriteriaId": "246E2C12-AD8B-42AA-9838-8A83E4A3A068"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/xiph/opusfile/commit/0a4cd796df5b030cb866f3f4a5e41a4b92caddf5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xiph/opusfile/issues/36", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2ODIA6QRIRBNF2HRXOE5VCZ2AFP4ZB4R/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4LIKBLOE433RA44YTYUZLED4IOWJG5DV/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ED4CWLBR2WQ2IXXTHZ24UYZBRNCLMJXH/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MYPAQANM2ZNPXRBFOS5NFXNJ7O4Q3OBD/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/xiph/opusfile/commit/0a4cd796df5b030cb866f3f4a5e41a4b92caddf5"}}