{"buggy_code": ["from trac.core import *\nfrom trac.util.datefmt import from_utimestamp, pretty_timedelta\nfrom trac.versioncontrol import RepositoryManager\nfrom trac.util.translation import _\nfrom datetime import datetime\nfrom time import time\nimport math\nimport re\n\nclass PortRepository(object):\n    def __init__(self, env, id):\n        self.env = env\n        self.clear()\n        self.id = id\n\n    def clear(self):\n        self.id = None\n        self.name = None\n        self.type = None\n        self.url = None\n        self.browseurl = None\n        self.username = None\n\n    def delete(self):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n\n        cursor.execute(\"SELECT count(*) FROM buildqueue WHERE repository = %s\", ( self.id, ))\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if row[0] > 0:\n            raise TracError('There are still buildqueue entries that need this repository')\n\n        cursor.execute(\"DELETE FROM portrepositories WHERE id = %s\", ( self.id, ))\n        db.commit()\n\n    def add(self):\n        if self.id:\n            raise TracError('Already existing portrepository object cannot be added again')\n\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"INSERT INTO portrepositories (name, type, url, browseurl, username) VALUES(%s, %s, %s, %s, %s)\", ( self.name, self.type, self.url, self.browseurl, self.username ) )\n        db.commit()\n\n\n\nclass Backend(object):\n    def __init__(self, env, id=None):\n        self.env = env\n        self.clear()\n        self.id = id\n\n    def clear(self):\n        self.id = None\n        self.protocol = None\n        self.host = None\n        self.uri = None\n        self.credentials = None\n        self.maxparallel = None\n        self.type = None\n        self.status = None\n\n    def getURL(self):\n        return self.protocol + '://' + self.host + self.uri\n\n    def setStatus(self, status):\n        self.status = int(status)\n\n        if self.status == 0:\n            self.disabled = True\n            self.statusname = 'fail'\n        elif self.status == 1:\n            self.enabled = True\n            self.statusname = 'success'\n        elif self.status == 2:\n            self.disabled = True\n            self.failed = True\n            self.statusname = 'fail'\n        else:\n            raise TracError('Invalid backend status')\n\n    def updateStatus(self, status):\n        self.setStatus(status)\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"UPDATE backends SET status = %s WHERE id = %s\", ( self.status, self.id ) )\n        db.commit()\n\n    def delete(self):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n\n        cursor.execute(\"SELECT count(*) FROM backendbuilds WHERE backendid = %s\", ( self.id, ))\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if row[0] > 0:\n            raise TracError('There are still backendbuilds for this backend')\n\n        cursor.execute(\"DELETE FROM backends WHERE id = %s\", ( self.id, ))\n        db.commit()\n\n    def add(self):\n        if self.id:\n            raise TracError('Already existing backend object cannot be added again')\n\n        if self.uri[0] != '/':\n            raise TracError('')\n\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"INSERT INTO backends (host, protocol, uri, credentials, maxparallel, status, type) VALUES(%s, %s, %s, %s, %s, %s, %s)\", ( self.host, self.protocol, self.uri, self.credentials, self.maxparallel, self.status, self.type ) )\n        db.commit()\n\n\nclass Backendbuild(object):\n    def __init__(self, env, id=None):\n        self.env = env\n        self.clear()\n        self.id = id\n\n    def clear(self):\n        self.id = None\n        self.buildgroup = None\n        self.backendid = None\n        self.priority = None\n        self.status = None\n        self.buildname = None\n\n    def setStatus(self, status):\n        self.status = int(status)\n\n        if self.status == 0:\n            self.disabled = True\n            self.statusname = 'fail'\n        elif self.status == 1:\n            self.enabled = True\n            self.statusname = 'success'\n        elif self.status == 2:\n            self.disabled = True\n            self.failed = True\n            self.statusname = 'fail'\n        elif self.status == 3:\n            self.disabled = False\n            self.failed = False\n            self.statusname = 'dud'\n        elif self.status == 4:\n            self.disabled = False\n            self.failed = False\n            self.statusname = 'dud'\n        else:\n            raise TracError('Invalid backendbuild status')\n\n    def updateStatus(self, status):\n        self.setStatus(status)\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"UPDATE backendbuilds SET status = %s WHERE id = %s\", ( self.status, self.id ) )\n        db.commit()\n\n    def delete(self):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n\n        cursor.execute(\"SELECT buildgroup, backendid FROM backendbuilds WHERE id = %s\", ( self.id, ))\n        row = cursor.fetchone()\n\n        cursor.execute(\"SELECT count(*) FROM builds WHERE buildgroup = %s AND backendid = %s AND status < 90\", ( row[0], row[1] ))\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if row[0] > 0:\n            raise TracError('There are running builds for this Backendbuild')\n\n        cursor.execute(\"DELETE FROM backendbuilds WHERE id = %s\", ( self.id, ))\n        db.commit()\n\n\n    def add(self):\n        if self.id:\n            raise TracError('Already existing backendbuild object cannot be added again')\n\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"INSERT INTO backendbuilds (buildgroup, backendid, priority, status, buildname) VALUES(%s, %s, %s, %s, %s)\", ( self.buildgroup, self.backendid, self.priority, self.status, self.buildname) )\n        db.commit()\n\n\nclass Build(object):\n    def __init__(self, env, queueid=None):\n        self.env = env\n        self.clear()\n        self.queueid = queueid\n\n    def clear(self):\n        self.queueid = None\n        self.repository = None\n        self.revision = None\n        self.description = None\n        self.runtime = None\n        self.startdate = None\n        self.enddate = None\n        self.owner = None\n        self.priority = None\n        self.ports = list()\n        self.status = None\n\n    def setStatus(self, status):\n        self.status = status\n\n    def addBuild(self, groups, ports, req):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n\n        self.status = 20\n\n        if not self.queueid:\n            self.queueid = datetime.now().strftime('%Y%m%d%H%M%S-%f')[0:20]\n\n        if not self.revision:\n            self.revision = None\n\n        if not self.priority:\n            self.priority = 5\n        self.priority = int(self.priority)\n\n        if not self.description:\n            self.description = 'Web rebuild'\n\n        if not ports:\n            raise TracError('Portname needs to be set')\n\n        if self.priority < 3:\n            cursor.execute(\"SELECT count(*) FROM buildqueue WHERE owner = %s AND priority < 3 AND status < 90\", ( req.authname, ))\n            row = cursor.fetchone()\n            if not row:\n                raise TracError('SQL Error')\n            if row[0] > 0:\n                self.priority = 5\n\n        try:\n            if self.revision:\n                self.revision = int(self.revision)\n        except ValueError:\n            raise TracError('Revision needs to be numeric')\n\n        cursor.execute(\"SELECT id, type, replace(url, '%OWNER%', %s) FROM portrepositories WHERE id = %s AND ( username = %s OR username IS NULL )\", (\n req.authname, self.repository, self.owner ))\n        if cursor.rowcount != 1:\n            raise TracError('SQL Error')\n        row = cursor.fetchone()\n\n        if row[1] == 'svn':\n             reponame, repo, fullrepopath = RepositoryManager(self.env).get_repository_by_path(row[2])\n             if not self.revision:\n                 self.revision = repo.get_youngest_rev()\n             if self.revision < 0 or self.revision > repo.get_youngest_rev():\n                 raise TracError('Invalid Revision number')\n             if not repo.has_node(fullrepopath[len(repo.get_path_url('/', self.revision)):], self.revision):\n                 raise TracError('No permissions to schedule builds for this repository')\n             \n        if isinstance(groups, basestring):\n            grouplist = list()\n            grouplist.append(groups)\n            groups = grouplist\n\n        if isinstance(ports, basestring):\n            ports = ports.split()\n            ports.sort()\n\n            for portname in ports:\n                if not re.match('^([a-zA-Z0-9_+.-]+)/([a-zA-Z0-9_+.-]+)$', portname):\n                    raise TracError(_('Invalid portname %(port)s', port=portname))\n                if len(portname) >= 100:\n                    raise TracError(_('Portname %(port)s too long', port=portname))\n\n        if groups[0] == 'automatic':\n            cursor.execute(\"SELECT buildgroup FROM automaticbuildgroups WHERE username = %s ORDER BY priority\", (self.owner,) )\n            if cursor.rowcount < 1:\n                raise TracError('Cannot schedule automatic builds. You need to join a buildgroup first.')\n            groups = cursor.fetchall()\n        else:\n            for group in groups:\n                cursor.execute(\"SELECT name FROM buildgroups WHERE name = %s\", (group,) )\n                if cursor.rowcount != 1:\n                    raise TracError('Invalid Buildqueue')\n\n        if len(ports) > 2 and self.priority < 3:\n            self.priority = 5\n\n        cursor.execute(\"INSERT INTO buildqueue (id, owner, repository, revision, status, priority, startdate, enddate, description) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)\", ( self.queueid, self.owner, self.repository, self.revision, self.status, self.priority, long(time()*1000000), 0, self.description ))\n\n        for portname in ports:\n            for group in groups:\n                cursor.execute(\"INSERT INTO builds (queueid, backendkey, buildgroup, portname, pkgversion, status, buildstatus, buildreason, buildlog, wrkdir, backendid, startdate, enddate, checkdate) VALUES (%s, SUBSTRING(MD5(RANDOM()::text), 1, 25), %s, %s, null, %s, null, null, null, null, 0, 0, 0, 0)\", ( self.queueid, group, portname, self.status ))\n        db.commit()\n        return True\n\n    def delete(self, req):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n\n        cursor.execute(\"SELECT count(*) FROM buildqueue WHERE buildqueue.id = %s AND buildqueue.owner = %s\", ( self.queueid, req.authname ))\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if row[0] != 1:\n            raise TracError('Invalid QueueID')\n\n        cursor.execute(\"SELECT id FROM builds WHERE queueid = %s FOR UPDATE\", ( self.queueid, ) )\n\n        error = None\n        for id in cursor:\n            try:\n                port = Port(self.env, id)\n                port.delete(req)\n            except TracError as e:\n                error = e\n\n        db.commit()\n        if error:\n            raise error\n\n\nclass Port(object):\n    def __init__(self, env, id=None):\n        self.env = env\n        self.clear()\n        self.id = id\n\n    def clear(self):\n        self.id = None\n        self.group = None\n        self.portname = None\n        self.pkgversion = None\n        self.status = None\n        self.buildstatus = 'unknown'\n        self.statusname = None\n        self.reason = None\n        self.buildlog = None\n        self.wrkdir = None\n        self.runtime = None\n        self.startdate = None\n        self.enddate = None\n        self.deletable = None\n\n    def setStatus(self, status, statusname=None):\n        self.status = status\n\n        if not self.status:\n            self.status = 20\n\n        if math.floor(self.status / 10) == 2:\n            self.statusname = 'waiting'\n            self.deletable = True\n        elif math.floor(self.status / 10) == 3:\n            self.statusname = 'starting'\n        elif math.floor(self.status / 10) == 5:\n            self.statusname = 'building'\n        elif math.floor(self.status / 10) == 7:\n            self.statusname = 'transferring'\n        elif math.floor(self.status / 10) == 8:\n            self.statusname = 'cleaning'\n        elif math.floor(self.status / 10) == 9:\n            self.statusname = 'finished'\n            self.deletable = True\n        else:\n            self.statusname = 'unknown'\n\n        if statusname:\n            self.statusname = statusname.lower()\n\n    def setPriority(self, priority):\n        self.priority = int(priority)\n\n        if self.priority == 1 or self.priority == 2:\n            self.priorityname = 'highest'\n        elif self.priority == 3 or self.priority == 4:\n            self.priorityname = 'high'\n        elif self.priority == 5:\n            self.priorityname = 'standard'\n        elif self.priority == 6 or self.priority == 7:\n            self.priorityname = 'low'\n        elif self.priority == 8 or self.priority == 9:\n            self.priorityname = 'lowest'\n        else:\n            raise TracError('Invalid Priority')\n\n    def buildFinished(self, key):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"UPDATE builds SET status = 51 WHERE backendkey = %s AND status = 50\", ( key, ))\n        db.commit()\n\n    def delete(self, req=None):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n\n        if req:\n            username = req.authname\n        else:\n            username = 'anonymous'\n\n        cursor.execute(\"SELECT count(*) FROM buildqueue, builds WHERE buildqueue.id = builds.queueid AND builds.id = %s AND (buildqueue.owner = %s OR %s = 'anonymous')\", ( self.id, username, username ))\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if row[0] != 1:\n            raise TracError('Invalid ID')\n\n        cursor.execute(\"SELECT buildqueue.id, builds.status FROM buildqueue, builds WHERE buildqueue.id = builds.queueid AND builds.id = %s\", ( self.id, ))\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if cursor.rowcount != 1:\n            raise TracError('Invalid ID')\n\n        queueid = row[0]\n        status = row[1]\n\n        if status >= 30 and status < 90:\n            raise TracError('Cannot delete running build')\n\n        cursor.execute(\"UPDATE builds SET status = 95 WHERE id = %s\", (self.id,) )\n\n        cursor.execute(\"SELECT count(*) FROM builds WHERE queueid = %s AND status <= 90\", (queueid,) )\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if row[0] == 0:\n            cursor.execute(\"UPDATE buildqueue SET status = 95, enddate = %s WHERE id = %s\", (long(time()*1000000), queueid ))\n\n        db.commit()\n\n\ndef GlobalBuildqueueIterator(env, req):\n    cursor = env.get_db_cnx().cursor()\n\n    if req.args.get('group'):\n        group = req.args.get('group')\n    else:\n        group = ''\n\n    cursor.execute(\"SELECT builds.id, builds.buildgroup, builds.portname, builds.pkgversion, builds.status, builds.buildstatus, builds.buildreason, builds.buildlog, builds.wrkdir, builds.startdate, CASE WHEN builds.enddate < builds.startdate THEN extract(epoch from now())*1000000 ELSE builds.enddate END, buildqueue.id, buildqueue.priority, buildqueue.owner FROM builds, buildqueue WHERE buildqueue.id = builds.queueid AND builds.status < 90 AND (builds.buildgroup = %s OR %s = '') ORDER BY builds.status DESC, buildqueue.priority, builds.id DESC LIMIT 50\", (group, group))\n\n    lastport = None\n    for id, group, portname, pkgversion, status, buildstatus, buildreason, buildlog, wrkdir, startdate, enddate, queueid, priority, owner in cursor:\n        port = Port(env)\n        port.id = id\n        port.group = group\n        port.portname = portname\n        port.pkgversion = pkgversion\n        port.buildstatus = buildstatus\n        port.buildlog = buildlog\n        port.wrkdir = wrkdir\n        port.runtime = pretty_timedelta( from_utimestamp(startdate), from_utimestamp(enddate) )\n        port.startdate = startdate\n        port.enddate = enddate\n        port.directory = '/~%s/%s-%s' % ( owner, queueid, id )\n        port.queueid = queueid\n        port.owner = owner\n        port.setPriority(priority)\n\n        if buildstatus:\n            port.buildstatus = buildstatus.lower()\n        if buildstatus and not buildreason:\n            buildreason = buildstatus.lower()\n\n        if owner == req.authname or status != 20:\n            port.highlight = True\n\n        port.setStatus(status, buildreason)\n\n        if lastport != portname:\n            port.head = True\n            lastport = portname\n\n        yield port\n\n\ndef BuildqueueIterator(env, req):\n    cursor = env.get_db_cnx().cursor()\n    cursor2 = env.get_db_cnx().cursor()\n\n    cursor.execute(\"SELECT buildqueue.id, owner, replace(replace(browseurl, '%OWNER%', owner), '%REVISION%', revision::text), revision, status, startdate, enddate, description FROM buildqueue, portrepositories WHERE buildqueue.repository = portrepositories.id AND owner = %s AND buildqueue.status < 95 ORDER BY buildqueue.id DESC\", (req.authname,) )\n\n    for queueid, owner, repository, revision, status, startdate, enddate, description in cursor:\n        build = Build(env)\n        build.queueid = queueid\n        build.owner = owner\n        build.repository = repository\n        build.revision = revision\n        build.setStatus(status)\n        build.runtime = pretty_timedelta( from_utimestamp(startdate), from_utimestamp(enddate) )\n        build.startdate = startdate\n        build.enddate = enddate\n        build.description = description\n\n        cursor2.execute(\"SELECT id, buildgroup, portname, pkgversion, status, buildstatus, buildreason, buildlog, wrkdir, startdate, CASE WHEN enddate < startdate THEN extract(epoch from now())*1000000 ELSE enddate END FROM builds WHERE queueid = %s AND status <= 90 ORDER BY id\", (queueid,) )\n\n        lastport = None\n        for id, group, portname, pkgversion, status, buildstatus, buildreason, buildlog, wrkdir, startdate, enddate in cursor2:\n            port = Port(env)\n            port.id = id\n            port.group = group\n            port.portname = portname\n            port.pkgversion = pkgversion\n            port.buildstatus = buildstatus\n            port.buildlog = buildlog\n            port.wrkdir = wrkdir\n            port.runtime = pretty_timedelta( from_utimestamp(startdate), from_utimestamp(enddate) )\n            port.startdate = startdate\n            port.enddate = enddate\n            port.directory = '/~%s/%s-%s' % ( owner, queueid, id )\n\n            if buildstatus:\n                port.buildstatus = buildstatus.lower()\n            if buildstatus and not buildreason:\n                buildreason = buildstatus.lower()\n\n            port.setStatus(status, buildreason)\n\n            if lastport != portname:\n                port.head = True\n                lastport = portname\n\n            build.ports.append(port)\n\n        yield build\n\n\nclass Buildgroup(object):\n   def __init__(self, env, name):\n        self.env = env\n        self.clear()\n        self.name = name\n\n   def clear(self):\n        self.name = None\n        self.version = None\n        self.arch = None\n        self.type = None\n        self.description = None\n        self.available = None\n        self.status = 'fail'\n        self.priority = None\n        self.priorityname = None\n        self.joined = None\n        self.queued = None\n\n   def setPriority(self, priority):\n        self.priority = 0\n        self.priorityname = 'unknown'\n\n        if int(priority) > 0 and int(priority) < 10:\n            self.priority = int(priority)\n        else:\n            self.priority = 5\n\n        if self.priority == 1:\n            self.priorityname = 'highest'\n        if self.priority == 3:\n            self.priorityname = 'high'\n        if self.priority == 5:\n            self.priorityname = 'normal'\n        if self.priority == 7:\n            self.priorityname = 'low'\n        if self.priority == 9:\n            self.priorityname = 'lowest'\n\n   def leave(self, req):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"DELETE FROM automaticbuildgroups WHERE buildgroup = %s AND username = %s\", ( self.name, req.authname ) )\n        db.commit()\n\n   def join(self, req):\n        self.leave(req)\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"INSERT INTO automaticbuildgroups (username, buildgroup, priority) VALUES(%s, %s, %s)\", ( req.authname, self.name, self.priority ) )\n        db.commit()\n\n   def delete(self):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        \n        cursor.execute(\"SELECT count(*) FROM backendbuilds WHERE buildgroup = %s\", ( self.name, ))\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if row[0] > 0:\n            raise TracError('Backendbuilds for this buildgroup still exist')\n\n        cursor.execute(\"DELETE FROM automaticbuildgroups WHERE buildgroup = %s\", (self.name,) )\n        cursor.execute(\"DELETE FROM buildgroups WHERE name = %s\", (self.name,) )\n        db.commit()\n\n   def add(self):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"INSERT INTO buildgroups (name, version, arch, type, description) VALUES(%s, %s, %s, %s, %s)\", ( self.name, self.version, self.arch, self.type, self.description) )\n        db.commit()\n\n   def deleteAllJobs(self):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        \n        cursor.execute(\"SELECT id FROM builds WHERE status < 30 AND buildgroup = %s\", ( self.name, ))\n        for id in cursor:\n            port = Port(self.env, id)\n            port.delete()\n        db.commit()\n\ndef BuildgroupsIterator(env, req):\n   cursor = env.get_db_cnx().cursor()\n   cursor2 = env.get_db_cnx().cursor()\n   cursor.execute(\"SELECT name, version, arch, type, description, (SELECT count(*) FROM backendbuilds, backends WHERE buildgroup = name AND backendbuilds.status IN(1, 3) AND backendbuilds.backendid = backends.id AND backends.status = 1) FROM buildgroups WHERE 1=1 ORDER BY version DESC, name\")\n\n   for name, version, arch, type, description, available in cursor:\n        buildgroup = Buildgroup(env, name)\n        buildgroup.version = version\n        buildgroup.arch = arch\n        buildgroup.type = type\n        buildgroup.description = description\n        buildgroup.available = available\n\n        if available > 0:\n            buildgroup.status = 'success'\n        if req.authname and req.authname != 'anonymous':\n            cursor2.execute(\"SELECT priority FROM automaticbuildgroups WHERE username = %s AND buildgroup = %s\", ( req.authname, name ) )\n\n            if cursor2.rowcount > 0:\n                buildgroup.joined = 'true'\n                buildgroup.setPriority(cursor2.fetchall()[0][0])\n\n        cursor2.execute(\"SELECT count(*) FROM builds WHERE buildgroup = %s AND status < 90\", (name,) )\n        if cursor2.rowcount > 0:\n            buildgroup.queued = cursor2.fetchall()[0][0]\n        \n        yield buildgroup\n\n\ndef AvailableBuildgroupsIterator(env, req):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT name FROM buildgroups WHERE version != '000' AND name NOT IN (SELECT buildgroup FROM automaticbuildgroups WHERE username = %s) ORDER BY version DESC, name\", (req.authname,) )\n\n    for name in cursor:\n        buildgroup = Buildgroup(env, name)\n\n        yield buildgroup\n\n\ndef UserBuildgroupsIterator(env):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT name, version, arch, type, description FROM buildgroups WHERE version != '000' ORDER BY version DESC, name\")\n\n    for name, version, arch, type, description in cursor:\n        buildgroup = Buildgroup(env, name)\n        buildgroup.version = version\n        buildgroup.arch = arch\n        buildgroup.type = type\n        buildgroup.description = description\n\n        yield buildgroup\n\n\ndef AllBuildgroupsIterator(env):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT name, version, arch, type, description FROM buildgroups ORDER BY version DESC, name\")\n\n    for name, version, arch, type, description in cursor:\n        buildgroup = Buildgroup(env, name)\n        buildgroup.version = version\n        buildgroup.arch = arch\n        buildgroup.type = type\n        buildgroup.description = description\n\n        yield buildgroup\n\n\ndef RepositoryIterator(env, req):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT id, replace(name, '%OWNER%', %s), type, url, replace(browseurl, '%OWNER%', %s), username FROM portrepositories WHERE username IS NULL OR username = %s ORDER BY id\", (req.authname, req.authname, req.authname))\n\n    for id, name, type, url, browseurl, username in cursor:\n        repository = PortRepository(env, id)\n        repository.name = name\n        repository.type = type\n        repository.url = url\n        repository.browseurl = browseurl\n        repository.username = username\n\n        yield repository\n\n\ndef PortRepositoryIterator(env):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT id, name, type, url, browseurl, username FROM portrepositories ORDER BY id\")\n\n    for id, name, type, url, browseurl, username in cursor:\n        repository = PortRepository(env, id)\n        repository.name = name\n        repository.type = type\n        repository.url = url\n        repository.browseurl = browseurl\n        repository.username = username\n\n        yield repository\n\n\ndef BackendsIterator(env):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT id, protocol, host, uri, credentials, maxparallel, status, type FROM backends ORDER BY id\")\n\n    for id, protocol, host, uri, credentials, maxparallel, status, type in cursor:\n        backend = Backend(env, id)\n        backend.protocol = protocol\n        backend.host = host\n        backend.uri = uri\n        backend.credentials = credentials\n        backend.maxparallel = maxparallel\n        backend.type = type\n        backend.url = backend.getURL()\n        backend.setStatus(status)\n\n        yield backend\n\n\ndef BackendbuildsIterator(env):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT backendbuilds.id, backendbuilds.buildgroup, backendbuilds.backendid, backendbuilds.priority, backendbuilds.status, backendbuilds.buildname, backends.protocol || '://' || backends.host || backends.uri FROM backendbuilds, backends WHERE backendbuilds.backendid = backends.id ORDER BY backendbuilds.backendid, backendbuilds.id\")\n\n    lastbackend = None\n    for id, buildgroup, backendid, priority, status, buildname, backend in cursor:\n        backendbuild = Backendbuild(env, id)\n        backendbuild.buildgroup = buildgroup\n        backendbuild.backendid = backendid\n        backendbuild.priority = priority\n        backendbuild.buildname = buildname\n        backendbuild.backend = backend\n        backendbuild.setStatus(status)\n\n        if lastbackend != backendid:\n            backendbuild.head = True\n            lastbackend = backendid\n\n        yield backendbuild\n\n\nclass BuildarchiveIterator(object):\n    def __init__(self, env):\n        self.env = env\n\n    def filter(self, owner=None, queueid=None, revision=None, uniqueports=False):\n        self.owner = owner\n        self.queueid = queueid\n\tself.revision = int(revision)\n        self.uniqueports = uniqueports\n\n    def count(self):\n        cursor = self.env.get_db_cnx().cursor()\n        cursor.execute(\"SELECT count(*) FROM buildqueue WHERE status >= 90\" + self._get_filter())\n        if cursor.rowcount > 0:\n            return cursor.fetchall()[0][0]\n\n        return 0\n\n    def _get_filter(self):\n        filter = ''\n\n        if self.queueid:\n            filter += \"AND buildqueue.id = '%s'\" % (self.queueid)\n\n        if self.owner:\n            filter += \"AND buildqueue.owner = '%s'\" % (self.owner)\n\n\tif self.revision:\n            filter += \"AND buildqueue.revision = '%s'\" % (self.revision)\n\n        return filter\n\n    def get_data(self, limit=100, offset=0):\n        cursor = self.env.get_db_cnx().cursor()\n        cursor2 = self.env.get_db_cnx().cursor()\n\n        cursor.execute(\"SELECT buildqueue.id, owner, replace(replace(browseurl, '%OWNER%', buildqueue.owner), '%REVISION%', revision::text), revision, status, startdate, CASE WHEN enddate < startdate THEN startdate ELSE enddate END, description FROM buildqueue, portrepositories WHERE repository = portrepositories.id AND buildqueue.status >= 10 \" + self._get_filter() + \" ORDER BY buildqueue.id DESC LIMIT %s OFFSET %s\", (limit, offset) )\n\n        for queueid, owner, repository, revision, status, startdate, enddate, description in cursor:\n            build = Build(self.env)\n            build.queueid = queueid\n            build.owner = owner\n            build.repository = repository\n            build.revision = revision\n            build.setStatus(status)\n            build.runtime = pretty_timedelta( from_utimestamp(startdate), from_utimestamp(enddate) )\n            build.startdate = startdate\n            build.enddate = enddate\n            build.description = description\n\n            cursor2.execute(\"SELECT id, buildgroup, portname, pkgversion, status, buildstatus, buildreason, buildlog, wrkdir, startdate, CASE WHEN enddate < startdate THEN extract(epoch from now())*1000000 ELSE enddate END FROM builds WHERE queueid = %s ORDER BY id\", (queueid,) )\n\n            lastport = None\n            for id, group, portname, pkgversion, status, buildstatus, buildreason, buildlog, wrkdir, startdate, enddate in cursor2:\n                port = Port(self.env)\n                port.id = id\n                port.group = group\n                port.portname = portname\n                port.pkgversion = pkgversion\n                port.buildstatus = buildstatus\n                port.buildlog = buildlog\n                port.wrkdir = wrkdir\n                port.runtime = pretty_timedelta( from_utimestamp(startdate), from_utimestamp(enddate) )\n                port.startdate = startdate\n                port.enddate = enddate\n                port.directory = '/~%s/%s-%s' % ( owner, queueid, id )\n\n                if buildstatus:\n                    port.buildstatus = buildstatus.lower()\n                if buildstatus and not buildreason:\n                    buildreason = buildstatus.lower()\n\n                port.setStatus(status, buildreason)\n\n                if self.uniqueports and lastport == portname:\n                    continue\n\n                if lastport != portname:\n                    port.head = True\n                    lastport = portname\n\n                build.ports.append(port)\n\n            yield build\n\ndef BuildstatsAllIterator(env):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT EXTRACT(epoch FROM date)*1000, count FROM (SELECT DATE_TRUNC('day', TO_TIMESTAMP(enddate/1000000))::timestamptz date, COUNT(*) FROM (SELECT enddate FROM builds WHERE enddate > 0) base WHERE 1=1 GROUP BY DATE_TRUNC('day', TO_TIMESTAMP(enddate/1000000)) ORDER BY 1 DESC LIMIT 30) src WHERE EXTRACT(epoch FROM src.date)::int > 0\")\n\n    for date, sum in cursor:\n        yield [date, sum]\n\ndef BuildstatsUserIterator(env, username):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT EXTRACT(epoch FROM date)*1000, count FROM (SELECT DATE_TRUNC('day', TO_TIMESTAMP(enddate/1000000))::timestamptz date, COUNT(*) FROM (SELECT builds.enddate FROM builds, buildqueue WHERE buildqueue.id = builds.queueid AND buildqueue.owner = %s) base WHERE 1=1 GROUP BY DATE_TRUNC('day', TO_TIMESTAMP(enddate/1000000)) ORDER BY 1 DESC LIMIT 30) src WHERE EXTRACT(epoch FROM src.date)::int > 0\", (username, ))\n\n    for date, sum in cursor:\n        yield [date, sum]\n"], "fixing_code": ["from trac.core import *\nfrom trac.util.datefmt import from_utimestamp, pretty_timedelta\nfrom trac.versioncontrol import RepositoryManager\nfrom trac.util.translation import _\nfrom datetime import datetime\nfrom time import time\nimport math\nimport re\n\nclass PortRepository(object):\n    def __init__(self, env, id):\n        self.env = env\n        self.clear()\n        self.id = id\n\n    def clear(self):\n        self.id = None\n        self.name = None\n        self.type = None\n        self.url = None\n        self.browseurl = None\n        self.username = None\n\n    def delete(self):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n\n        cursor.execute(\"SELECT count(*) FROM buildqueue WHERE repository = %s\", ( self.id, ))\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if row[0] > 0:\n            raise TracError('There are still buildqueue entries that need this repository')\n\n        cursor.execute(\"DELETE FROM portrepositories WHERE id = %s\", ( self.id, ))\n        db.commit()\n\n    def add(self):\n        if self.id:\n            raise TracError('Already existing portrepository object cannot be added again')\n\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"INSERT INTO portrepositories (name, type, url, browseurl, username) VALUES(%s, %s, %s, %s, %s)\", ( self.name, self.type, self.url, self.browseurl, self.username ) )\n        db.commit()\n\n\n\nclass Backend(object):\n    def __init__(self, env, id=None):\n        self.env = env\n        self.clear()\n        self.id = id\n\n    def clear(self):\n        self.id = None\n        self.protocol = None\n        self.host = None\n        self.uri = None\n        self.credentials = None\n        self.maxparallel = None\n        self.type = None\n        self.status = None\n\n    def getURL(self):\n        return self.protocol + '://' + self.host + self.uri\n\n    def setStatus(self, status):\n        self.status = int(status)\n\n        if self.status == 0:\n            self.disabled = True\n            self.statusname = 'fail'\n        elif self.status == 1:\n            self.enabled = True\n            self.statusname = 'success'\n        elif self.status == 2:\n            self.disabled = True\n            self.failed = True\n            self.statusname = 'fail'\n        else:\n            raise TracError('Invalid backend status')\n\n    def updateStatus(self, status):\n        self.setStatus(status)\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"UPDATE backends SET status = %s WHERE id = %s\", ( self.status, self.id ) )\n        db.commit()\n\n    def delete(self):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n\n        cursor.execute(\"SELECT count(*) FROM backendbuilds WHERE backendid = %s\", ( self.id, ))\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if row[0] > 0:\n            raise TracError('There are still backendbuilds for this backend')\n\n        cursor.execute(\"DELETE FROM backends WHERE id = %s\", ( self.id, ))\n        db.commit()\n\n    def add(self):\n        if self.id:\n            raise TracError('Already existing backend object cannot be added again')\n\n        if self.uri[0] != '/':\n            raise TracError('')\n\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"INSERT INTO backends (host, protocol, uri, credentials, maxparallel, status, type) VALUES(%s, %s, %s, %s, %s, %s, %s)\", ( self.host, self.protocol, self.uri, self.credentials, self.maxparallel, self.status, self.type ) )\n        db.commit()\n\n\nclass Backendbuild(object):\n    def __init__(self, env, id=None):\n        self.env = env\n        self.clear()\n        self.id = id\n\n    def clear(self):\n        self.id = None\n        self.buildgroup = None\n        self.backendid = None\n        self.priority = None\n        self.status = None\n        self.buildname = None\n\n    def setStatus(self, status):\n        self.status = int(status)\n\n        if self.status == 0:\n            self.disabled = True\n            self.statusname = 'fail'\n        elif self.status == 1:\n            self.enabled = True\n            self.statusname = 'success'\n        elif self.status == 2:\n            self.disabled = True\n            self.failed = True\n            self.statusname = 'fail'\n        elif self.status == 3:\n            self.disabled = False\n            self.failed = False\n            self.statusname = 'dud'\n        elif self.status == 4:\n            self.disabled = False\n            self.failed = False\n            self.statusname = 'dud'\n        else:\n            raise TracError('Invalid backendbuild status')\n\n    def updateStatus(self, status):\n        self.setStatus(status)\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"UPDATE backendbuilds SET status = %s WHERE id = %s\", ( self.status, self.id ) )\n        db.commit()\n\n    def delete(self):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n\n        cursor.execute(\"SELECT buildgroup, backendid FROM backendbuilds WHERE id = %s\", ( self.id, ))\n        row = cursor.fetchone()\n\n        cursor.execute(\"SELECT count(*) FROM builds WHERE buildgroup = %s AND backendid = %s AND status < 90\", ( row[0], row[1] ))\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if row[0] > 0:\n            raise TracError('There are running builds for this Backendbuild')\n\n        cursor.execute(\"DELETE FROM backendbuilds WHERE id = %s\", ( self.id, ))\n        db.commit()\n\n\n    def add(self):\n        if self.id:\n            raise TracError('Already existing backendbuild object cannot be added again')\n\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"INSERT INTO backendbuilds (buildgroup, backendid, priority, status, buildname) VALUES(%s, %s, %s, %s, %s)\", ( self.buildgroup, self.backendid, self.priority, self.status, self.buildname) )\n        db.commit()\n\n\nclass Build(object):\n    def __init__(self, env, queueid=None):\n        self.env = env\n        self.clear()\n        self.queueid = queueid\n\n    def clear(self):\n        self.queueid = None\n        self.repository = None\n        self.revision = None\n        self.description = None\n        self.runtime = None\n        self.startdate = None\n        self.enddate = None\n        self.owner = None\n        self.priority = None\n        self.ports = list()\n        self.status = None\n\n    def setStatus(self, status):\n        self.status = status\n\n    def addBuild(self, groups, ports, req):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n\n        self.status = 20\n\n        if not self.queueid:\n            self.queueid = datetime.now().strftime('%Y%m%d%H%M%S-%f')[0:20]\n\n        if not self.revision:\n            self.revision = None\n\n        if not self.priority:\n            self.priority = 5\n        self.priority = int(self.priority)\n\n        if not self.description:\n            self.description = 'Web rebuild'\n\n        if not ports:\n            raise TracError('Portname needs to be set')\n\n        if self.priority < 3:\n            cursor.execute(\"SELECT count(*) FROM buildqueue WHERE owner = %s AND priority < 3 AND status < 90\", ( req.authname, ))\n            row = cursor.fetchone()\n            if not row:\n                raise TracError('SQL Error')\n            if row[0] > 0:\n                self.priority = 5\n\n        try:\n            if self.revision:\n                self.revision = int(self.revision)\n        except ValueError:\n            raise TracError('Revision needs to be numeric')\n\n        cursor.execute(\"SELECT id, type, replace(url, '%OWNER%', %s) FROM portrepositories WHERE id = %s AND ( username = %s OR username IS NULL )\", (\n req.authname, self.repository, self.owner ))\n        if cursor.rowcount != 1:\n            raise TracError('SQL Error')\n        row = cursor.fetchone()\n\n        if row[1] == 'svn':\n             reponame, repo, fullrepopath = RepositoryManager(self.env).get_repository_by_path(row[2])\n             if not self.revision:\n                 self.revision = repo.get_youngest_rev()\n             if self.revision < 0 or self.revision > repo.get_youngest_rev():\n                 raise TracError('Invalid Revision number')\n             if not repo.has_node(fullrepopath[len(repo.get_path_url('/', self.revision)):], self.revision):\n                 raise TracError('No permissions to schedule builds for this repository')\n             \n        if isinstance(groups, basestring):\n            grouplist = list()\n            grouplist.append(groups)\n            groups = grouplist\n\n        if isinstance(ports, basestring):\n            ports = ports.split()\n            ports.sort()\n\n            for portname in ports:\n                if not re.match('^([a-zA-Z0-9_+.-]+)/([a-zA-Z0-9_+.-]+)$', portname):\n                    raise TracError(_('Invalid portname %(port)s', port=portname))\n                if len(portname) >= 100:\n                    raise TracError(_('Portname %(port)s too long', port=portname))\n\n        if groups[0] == 'automatic':\n            cursor.execute(\"SELECT buildgroup FROM automaticbuildgroups WHERE username = %s ORDER BY priority\", (self.owner,) )\n            if cursor.rowcount < 1:\n                raise TracError('Cannot schedule automatic builds. You need to join a buildgroup first.')\n            groups = cursor.fetchall()\n        else:\n            for group in groups:\n                cursor.execute(\"SELECT name FROM buildgroups WHERE name = %s\", (group,) )\n                if cursor.rowcount != 1:\n                    raise TracError('Invalid Buildqueue')\n\n        if len(ports) > 2 and self.priority < 3:\n            self.priority = 5\n\n        cursor.execute(\"INSERT INTO buildqueue (id, owner, repository, revision, status, priority, startdate, enddate, description) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)\", ( self.queueid, self.owner, self.repository, self.revision, self.status, self.priority, long(time()*1000000), 0, self.description ))\n\n        for portname in ports:\n            for group in groups:\n                cursor.execute(\"INSERT INTO builds (queueid, backendkey, buildgroup, portname, pkgversion, status, buildstatus, buildreason, buildlog, wrkdir, backendid, startdate, enddate, checkdate) VALUES (%s, SUBSTRING(MD5(RANDOM()::text), 1, 25), %s, %s, null, %s, null, null, null, null, 0, 0, 0, 0)\", ( self.queueid, group, portname, self.status ))\n        db.commit()\n        return True\n\n    def delete(self, req):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n\n        cursor.execute(\"SELECT count(*) FROM buildqueue WHERE buildqueue.id = %s AND buildqueue.owner = %s\", ( self.queueid, req.authname ))\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if row[0] != 1:\n            raise TracError('Invalid QueueID')\n\n        cursor.execute(\"SELECT id FROM builds WHERE queueid = %s FOR UPDATE\", ( self.queueid, ) )\n\n        error = None\n        for id in cursor:\n            try:\n                port = Port(self.env, id)\n                port.delete(req)\n            except TracError as e:\n                error = e\n\n        db.commit()\n        if error:\n            raise error\n\n\nclass Port(object):\n    def __init__(self, env, id=None):\n        self.env = env\n        self.clear()\n        self.id = id\n\n    def clear(self):\n        self.id = None\n        self.group = None\n        self.portname = None\n        self.pkgversion = None\n        self.status = None\n        self.buildstatus = 'unknown'\n        self.statusname = None\n        self.reason = None\n        self.buildlog = None\n        self.wrkdir = None\n        self.runtime = None\n        self.startdate = None\n        self.enddate = None\n        self.deletable = None\n\n    def setStatus(self, status, statusname=None):\n        self.status = status\n\n        if not self.status:\n            self.status = 20\n\n        if math.floor(self.status / 10) == 2:\n            self.statusname = 'waiting'\n            self.deletable = True\n        elif math.floor(self.status / 10) == 3:\n            self.statusname = 'starting'\n        elif math.floor(self.status / 10) == 5:\n            self.statusname = 'building'\n        elif math.floor(self.status / 10) == 7:\n            self.statusname = 'transferring'\n        elif math.floor(self.status / 10) == 8:\n            self.statusname = 'cleaning'\n        elif math.floor(self.status / 10) == 9:\n            self.statusname = 'finished'\n            self.deletable = True\n        else:\n            self.statusname = 'unknown'\n\n        if statusname:\n            self.statusname = statusname.lower()\n\n    def setPriority(self, priority):\n        self.priority = int(priority)\n\n        if self.priority == 1 or self.priority == 2:\n            self.priorityname = 'highest'\n        elif self.priority == 3 or self.priority == 4:\n            self.priorityname = 'high'\n        elif self.priority == 5:\n            self.priorityname = 'standard'\n        elif self.priority == 6 or self.priority == 7:\n            self.priorityname = 'low'\n        elif self.priority == 8 or self.priority == 9:\n            self.priorityname = 'lowest'\n        else:\n            raise TracError('Invalid Priority')\n\n    def buildFinished(self, key):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"UPDATE builds SET status = 51 WHERE backendkey = %s AND status = 50\", ( key, ))\n        db.commit()\n\n    def delete(self, req=None):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n\n        if req:\n            username = req.authname\n        else:\n            username = 'anonymous'\n\n        cursor.execute(\"SELECT count(*) FROM buildqueue, builds WHERE buildqueue.id = builds.queueid AND builds.id = %s AND (buildqueue.owner = %s OR %s = 'anonymous')\", ( self.id, username, username ))\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if row[0] != 1:\n            raise TracError('Invalid ID')\n\n        cursor.execute(\"SELECT buildqueue.id, builds.status FROM buildqueue, builds WHERE buildqueue.id = builds.queueid AND builds.id = %s\", ( self.id, ))\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if cursor.rowcount != 1:\n            raise TracError('Invalid ID')\n\n        queueid = row[0]\n        status = row[1]\n\n        if status >= 30 and status < 90:\n            raise TracError('Cannot delete running build')\n\n        cursor.execute(\"UPDATE builds SET status = 95 WHERE id = %s\", (self.id,) )\n\n        cursor.execute(\"SELECT count(*) FROM builds WHERE queueid = %s AND status <= 90\", (queueid,) )\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if row[0] == 0:\n            cursor.execute(\"UPDATE buildqueue SET status = 95, enddate = %s WHERE id = %s\", (long(time()*1000000), queueid ))\n\n        db.commit()\n\n\ndef GlobalBuildqueueIterator(env, req):\n    cursor = env.get_db_cnx().cursor()\n\n    if req.args.get('group'):\n        group = req.args.get('group')\n    else:\n        group = ''\n\n    cursor.execute(\"SELECT builds.id, builds.buildgroup, builds.portname, builds.pkgversion, builds.status, builds.buildstatus, builds.buildreason, builds.buildlog, builds.wrkdir, builds.startdate, CASE WHEN builds.enddate < builds.startdate THEN extract(epoch from now())*1000000 ELSE builds.enddate END, buildqueue.id, buildqueue.priority, buildqueue.owner FROM builds, buildqueue WHERE buildqueue.id = builds.queueid AND builds.status < 90 AND (builds.buildgroup = %s OR %s = '') ORDER BY builds.status DESC, buildqueue.priority, builds.id DESC LIMIT 50\", (group, group))\n\n    lastport = None\n    for id, group, portname, pkgversion, status, buildstatus, buildreason, buildlog, wrkdir, startdate, enddate, queueid, priority, owner in cursor:\n        port = Port(env)\n        port.id = id\n        port.group = group\n        port.portname = portname\n        port.pkgversion = pkgversion\n        port.buildstatus = buildstatus\n        port.buildlog = buildlog\n        port.wrkdir = wrkdir\n        port.runtime = pretty_timedelta( from_utimestamp(startdate), from_utimestamp(enddate) )\n        port.startdate = startdate\n        port.enddate = enddate\n        port.directory = '/~%s/%s-%s' % ( owner, queueid, id )\n        port.queueid = queueid\n        port.owner = owner\n        port.setPriority(priority)\n\n        if buildstatus:\n            port.buildstatus = buildstatus.lower()\n        if buildstatus and not buildreason:\n            buildreason = buildstatus.lower()\n\n        if owner == req.authname or status != 20:\n            port.highlight = True\n\n        port.setStatus(status, buildreason)\n\n        if lastport != portname:\n            port.head = True\n            lastport = portname\n\n        yield port\n\n\ndef BuildqueueIterator(env, req):\n    cursor = env.get_db_cnx().cursor()\n    cursor2 = env.get_db_cnx().cursor()\n\n    cursor.execute(\"SELECT buildqueue.id, owner, replace(replace(browseurl, '%OWNER%', owner), '%REVISION%', revision::text), revision, status, startdate, enddate, description FROM buildqueue, portrepositories WHERE buildqueue.repository = portrepositories.id AND owner = %s AND buildqueue.status < 95 ORDER BY buildqueue.id DESC\", (req.authname,) )\n\n    for queueid, owner, repository, revision, status, startdate, enddate, description in cursor:\n        build = Build(env)\n        build.queueid = queueid\n        build.owner = owner\n        build.repository = repository\n        build.revision = revision\n        build.setStatus(status)\n        build.runtime = pretty_timedelta( from_utimestamp(startdate), from_utimestamp(enddate) )\n        build.startdate = startdate\n        build.enddate = enddate\n        build.description = description\n\n        cursor2.execute(\"SELECT id, buildgroup, portname, pkgversion, status, buildstatus, buildreason, buildlog, wrkdir, startdate, CASE WHEN enddate < startdate THEN extract(epoch from now())*1000000 ELSE enddate END FROM builds WHERE queueid = %s AND status <= 90 ORDER BY id\", (queueid,) )\n\n        lastport = None\n        for id, group, portname, pkgversion, status, buildstatus, buildreason, buildlog, wrkdir, startdate, enddate in cursor2:\n            port = Port(env)\n            port.id = id\n            port.group = group\n            port.portname = portname\n            port.pkgversion = pkgversion\n            port.buildstatus = buildstatus\n            port.buildlog = buildlog\n            port.wrkdir = wrkdir\n            port.runtime = pretty_timedelta( from_utimestamp(startdate), from_utimestamp(enddate) )\n            port.startdate = startdate\n            port.enddate = enddate\n            port.directory = '/~%s/%s-%s' % ( owner, queueid, id )\n\n            if buildstatus:\n                port.buildstatus = buildstatus.lower()\n            if buildstatus and not buildreason:\n                buildreason = buildstatus.lower()\n\n            port.setStatus(status, buildreason)\n\n            if lastport != portname:\n                port.head = True\n                lastport = portname\n\n            build.ports.append(port)\n\n        yield build\n\n\nclass Buildgroup(object):\n   def __init__(self, env, name):\n        self.env = env\n        self.clear()\n        self.name = name\n\n   def clear(self):\n        self.name = None\n        self.version = None\n        self.arch = None\n        self.type = None\n        self.description = None\n        self.available = None\n        self.status = 'fail'\n        self.priority = None\n        self.priorityname = None\n        self.joined = None\n        self.queued = None\n\n   def setPriority(self, priority):\n        self.priority = 0\n        self.priorityname = 'unknown'\n\n        if int(priority) > 0 and int(priority) < 10:\n            self.priority = int(priority)\n        else:\n            self.priority = 5\n\n        if self.priority == 1:\n            self.priorityname = 'highest'\n        if self.priority == 3:\n            self.priorityname = 'high'\n        if self.priority == 5:\n            self.priorityname = 'normal'\n        if self.priority == 7:\n            self.priorityname = 'low'\n        if self.priority == 9:\n            self.priorityname = 'lowest'\n\n   def leave(self, req):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"DELETE FROM automaticbuildgroups WHERE buildgroup = %s AND username = %s\", ( self.name, req.authname ) )\n        db.commit()\n\n   def join(self, req):\n        self.leave(req)\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"INSERT INTO automaticbuildgroups (username, buildgroup, priority) VALUES(%s, %s, %s)\", ( req.authname, self.name, self.priority ) )\n        db.commit()\n\n   def delete(self):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        \n        cursor.execute(\"SELECT count(*) FROM backendbuilds WHERE buildgroup = %s\", ( self.name, ))\n        row = cursor.fetchone()\n        if not row:\n            raise TracError('SQL Error')\n        if row[0] > 0:\n            raise TracError('Backendbuilds for this buildgroup still exist')\n\n        cursor.execute(\"DELETE FROM automaticbuildgroups WHERE buildgroup = %s\", (self.name,) )\n        cursor.execute(\"DELETE FROM buildgroups WHERE name = %s\", (self.name,) )\n        db.commit()\n\n   def add(self):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        cursor.execute(\"INSERT INTO buildgroups (name, version, arch, type, description) VALUES(%s, %s, %s, %s, %s)\", ( self.name, self.version, self.arch, self.type, self.description) )\n        db.commit()\n\n   def deleteAllJobs(self):\n        db = self.env.get_db_cnx()\n        cursor = db.cursor()\n        \n        cursor.execute(\"SELECT id FROM builds WHERE status < 30 AND buildgroup = %s\", ( self.name, ))\n        for id in cursor:\n            port = Port(self.env, id)\n            port.delete()\n        db.commit()\n\ndef BuildgroupsIterator(env, req):\n   cursor = env.get_db_cnx().cursor()\n   cursor2 = env.get_db_cnx().cursor()\n   cursor.execute(\"SELECT name, version, arch, type, description, (SELECT count(*) FROM backendbuilds, backends WHERE buildgroup = name AND backendbuilds.status IN(1, 3) AND backendbuilds.backendid = backends.id AND backends.status = 1) FROM buildgroups WHERE 1=1 ORDER BY version DESC, name\")\n\n   for name, version, arch, type, description, available in cursor:\n        buildgroup = Buildgroup(env, name)\n        buildgroup.version = version\n        buildgroup.arch = arch\n        buildgroup.type = type\n        buildgroup.description = description\n        buildgroup.available = available\n\n        if available > 0:\n            buildgroup.status = 'success'\n        if req.authname and req.authname != 'anonymous':\n            cursor2.execute(\"SELECT priority FROM automaticbuildgroups WHERE username = %s AND buildgroup = %s\", ( req.authname, name ) )\n\n            if cursor2.rowcount > 0:\n                buildgroup.joined = 'true'\n                buildgroup.setPriority(cursor2.fetchall()[0][0])\n\n        cursor2.execute(\"SELECT count(*) FROM builds WHERE buildgroup = %s AND status < 90\", (name,) )\n        if cursor2.rowcount > 0:\n            buildgroup.queued = cursor2.fetchall()[0][0]\n        \n        yield buildgroup\n\n\ndef AvailableBuildgroupsIterator(env, req):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT name FROM buildgroups WHERE version != '000' AND name NOT IN (SELECT buildgroup FROM automaticbuildgroups WHERE username = %s) ORDER BY version DESC, name\", (req.authname,) )\n\n    for name in cursor:\n        buildgroup = Buildgroup(env, name)\n\n        yield buildgroup\n\n\ndef UserBuildgroupsIterator(env):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT name, version, arch, type, description FROM buildgroups WHERE version != '000' ORDER BY version DESC, name\")\n\n    for name, version, arch, type, description in cursor:\n        buildgroup = Buildgroup(env, name)\n        buildgroup.version = version\n        buildgroup.arch = arch\n        buildgroup.type = type\n        buildgroup.description = description\n\n        yield buildgroup\n\n\ndef AllBuildgroupsIterator(env):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT name, version, arch, type, description FROM buildgroups ORDER BY version DESC, name\")\n\n    for name, version, arch, type, description in cursor:\n        buildgroup = Buildgroup(env, name)\n        buildgroup.version = version\n        buildgroup.arch = arch\n        buildgroup.type = type\n        buildgroup.description = description\n\n        yield buildgroup\n\n\ndef RepositoryIterator(env, req):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT id, replace(name, '%OWNER%', %s), type, url, replace(browseurl, '%OWNER%', %s), username FROM portrepositories WHERE username IS NULL OR username = %s ORDER BY id\", (req.authname, req.authname, req.authname))\n\n    for id, name, type, url, browseurl, username in cursor:\n        repository = PortRepository(env, id)\n        repository.name = name\n        repository.type = type\n        repository.url = url\n        repository.browseurl = browseurl\n        repository.username = username\n\n        yield repository\n\n\ndef PortRepositoryIterator(env):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT id, name, type, url, browseurl, username FROM portrepositories ORDER BY id\")\n\n    for id, name, type, url, browseurl, username in cursor:\n        repository = PortRepository(env, id)\n        repository.name = name\n        repository.type = type\n        repository.url = url\n        repository.browseurl = browseurl\n        repository.username = username\n\n        yield repository\n\n\ndef BackendsIterator(env):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT id, protocol, host, uri, credentials, maxparallel, status, type FROM backends ORDER BY id\")\n\n    for id, protocol, host, uri, credentials, maxparallel, status, type in cursor:\n        backend = Backend(env, id)\n        backend.protocol = protocol\n        backend.host = host\n        backend.uri = uri\n        backend.credentials = credentials\n        backend.maxparallel = maxparallel\n        backend.type = type\n        backend.url = backend.getURL()\n        backend.setStatus(status)\n\n        yield backend\n\n\ndef BackendbuildsIterator(env):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT backendbuilds.id, backendbuilds.buildgroup, backendbuilds.backendid, backendbuilds.priority, backendbuilds.status, backendbuilds.buildname, backends.protocol || '://' || backends.host || backends.uri FROM backendbuilds, backends WHERE backendbuilds.backendid = backends.id ORDER BY backendbuilds.backendid, backendbuilds.id\")\n\n    lastbackend = None\n    for id, buildgroup, backendid, priority, status, buildname, backend in cursor:\n        backendbuild = Backendbuild(env, id)\n        backendbuild.buildgroup = buildgroup\n        backendbuild.backendid = backendid\n        backendbuild.priority = priority\n        backendbuild.buildname = buildname\n        backendbuild.backend = backend\n        backendbuild.setStatus(status)\n\n        if lastbackend != backendid:\n            backendbuild.head = True\n            lastbackend = backendid\n\n        yield backendbuild\n\n\nclass BuildarchiveIterator(object):\n    def __init__(self, env):\n        self.env = env\n\n    def filter(self, owner=None, queueid=None, revision=None, uniqueports=False):\n        self.owner = owner\n        self.queueid = queueid\n\tself.revision = revision\n        self.uniqueports = uniqueports\n\n    def count(self):\n        cursor = self.env.get_db_cnx().cursor()\n        cursor.execute(\"SELECT count(*) FROM buildqueue WHERE status >= 90\" + self._get_filter())\n        if cursor.rowcount > 0:\n            return cursor.fetchall()[0][0]\n\n        return 0\n\n    def _get_filter(self):\n        filter = ''\n\n        if self.queueid:\n            filter += \"AND buildqueue.id = '%s'\" % (re.sub(\"[\\\"']\", \"\", self.queueid))\n\n        if self.owner:\n            filter += \"AND buildqueue.owner = '%s'\" % (re.sub(\"[\\\"']\", \"\", self.owner))\n\n\tif self.revision:\n            filter += \"AND buildqueue.revision = %s\" % (int(self.revision))\n\n        return filter\n\n    def get_data(self, limit=100, offset=0):\n        cursor = self.env.get_db_cnx().cursor()\n        cursor2 = self.env.get_db_cnx().cursor()\n\n        cursor.execute(\"SELECT buildqueue.id, owner, replace(replace(browseurl, '%OWNER%', buildqueue.owner), '%REVISION%', revision::text), revision, status, startdate, CASE WHEN enddate < startdate THEN startdate ELSE enddate END, description FROM buildqueue, portrepositories WHERE repository = portrepositories.id AND buildqueue.status >= 10 \" + self._get_filter() + \" ORDER BY buildqueue.id DESC LIMIT %s OFFSET %s\", (limit, offset) )\n\n        for queueid, owner, repository, revision, status, startdate, enddate, description in cursor:\n            build = Build(self.env)\n            build.queueid = queueid\n            build.owner = owner\n            build.repository = repository\n            build.revision = revision\n            build.setStatus(status)\n            build.runtime = pretty_timedelta( from_utimestamp(startdate), from_utimestamp(enddate) )\n            build.startdate = startdate\n            build.enddate = enddate\n            build.description = description\n\n            cursor2.execute(\"SELECT id, buildgroup, portname, pkgversion, status, buildstatus, buildreason, buildlog, wrkdir, startdate, CASE WHEN enddate < startdate THEN extract(epoch from now())*1000000 ELSE enddate END FROM builds WHERE queueid = %s ORDER BY id\", (queueid,) )\n\n            lastport = None\n            for id, group, portname, pkgversion, status, buildstatus, buildreason, buildlog, wrkdir, startdate, enddate in cursor2:\n                port = Port(self.env)\n                port.id = id\n                port.group = group\n                port.portname = portname\n                port.pkgversion = pkgversion\n                port.buildstatus = buildstatus\n                port.buildlog = buildlog\n                port.wrkdir = wrkdir\n                port.runtime = pretty_timedelta( from_utimestamp(startdate), from_utimestamp(enddate) )\n                port.startdate = startdate\n                port.enddate = enddate\n                port.directory = '/~%s/%s-%s' % ( owner, queueid, id )\n\n                if buildstatus:\n                    port.buildstatus = buildstatus.lower()\n                if buildstatus and not buildreason:\n                    buildreason = buildstatus.lower()\n\n                port.setStatus(status, buildreason)\n\n                if self.uniqueports and lastport == portname:\n                    continue\n\n                if lastport != portname:\n                    port.head = True\n                    lastport = portname\n\n                build.ports.append(port)\n\n            yield build\n\ndef BuildstatsAllIterator(env):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT EXTRACT(epoch FROM date)*1000, count FROM (SELECT DATE_TRUNC('day', TO_TIMESTAMP(enddate/1000000))::timestamptz date, COUNT(*) FROM (SELECT enddate FROM builds WHERE enddate > 0) base WHERE 1=1 GROUP BY DATE_TRUNC('day', TO_TIMESTAMP(enddate/1000000)) ORDER BY 1 DESC LIMIT 30) src WHERE EXTRACT(epoch FROM src.date)::int > 0\")\n\n    for date, sum in cursor:\n        yield [date, sum]\n\ndef BuildstatsUserIterator(env, username):\n    cursor = env.get_db_cnx().cursor()\n    cursor.execute(\"SELECT EXTRACT(epoch FROM date)*1000, count FROM (SELECT DATE_TRUNC('day', TO_TIMESTAMP(enddate/1000000))::timestamptz date, COUNT(*) FROM (SELECT builds.enddate FROM builds, buildqueue WHERE buildqueue.id = builds.queueid AND buildqueue.owner = %s) base WHERE 1=1 GROUP BY DATE_TRUNC('day', TO_TIMESTAMP(enddate/1000000)) ORDER BY 1 DESC LIMIT 30) src WHERE EXTRACT(epoch FROM src.date)::int > 0\", (username, ))\n\n    for date, sum in cursor:\n        yield [date, sum]\n"], "buggy_code_start_loc": [760], "buggy_code_end_loc": [782], "fixing_code_start_loc": [760], "fixing_code_end_loc": [782], "type": "CWE-89", "message": "A vulnerability was found in nivit redports. It has been declared as critical. This vulnerability affects unknown code of the file redports-trac/redports/model.py. The manipulation leads to sql injection. The name of the patch is fc2c1ea1b8d795094abb15ac73cab90830534e04. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-218464.", "other": {"cve": {"id": "CVE-2014-125082", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-18T00:15:11.597", "lastModified": "2023-01-24T19:43:55.377", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in nivit redports. It has been declared as critical. This vulnerability affects unknown code of the file redports-trac/redports/model.py. The manipulation leads to sql injection. The name of the patch is fc2c1ea1b8d795094abb15ac73cab90830534e04. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-218464."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redports_project:redports:*:*:*:*:*:*:*:*", "versionEndExcluding": "2014-01-14", "matchCriteriaId": "4B8CFD84-5008-41A6-A58A-91239E6147A3"}]}]}], "references": [{"url": "https://github.com/nivit/redports/commit/fc2c1ea1b8d795094abb15ac73cab90830534e04", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218464", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}, {"url": "https://vuldb.com/?id.218464", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/nivit/redports/commit/fc2c1ea1b8d795094abb15ac73cab90830534e04"}}