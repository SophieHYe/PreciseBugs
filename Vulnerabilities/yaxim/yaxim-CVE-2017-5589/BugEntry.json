{"buggy_code": ["package org.yaxim.androidclient.service;\n\nimport java.io.File;\nimport java.text.Collator;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.X509TrustManager;\n\nimport de.duenndns.ssl.MemorizingTrustManager;\n\nimport org.jivesoftware.smack.AccountManager;\nimport org.jivesoftware.smack.Connection;\nimport org.jivesoftware.smack.ConnectionConfiguration;\nimport org.jivesoftware.smack.ConnectionListener;\nimport org.jivesoftware.smack.PacketListener;\nimport org.jivesoftware.smack.Roster;\nimport org.jivesoftware.smack.RosterEntry;\nimport org.jivesoftware.smack.RosterGroup;\nimport org.jivesoftware.smack.RosterListener;\nimport org.jivesoftware.smack.SmackConfiguration;\nimport org.jivesoftware.smack.XMPPConnection;\nimport org.jivesoftware.smack.XMPPException;\nimport org.jivesoftware.smack.filter.PacketFilter;\nimport org.jivesoftware.smack.filter.PacketTypeFilter;\nimport org.jivesoftware.smack.packet.IQ;\nimport org.jivesoftware.smack.packet.IQ.Type;\nimport org.jivesoftware.smack.packet.Message;\nimport org.jivesoftware.smack.packet.Packet;\nimport org.jivesoftware.smack.packet.Presence;\nimport org.jivesoftware.smack.packet.Presence.Mode;\nimport org.jivesoftware.smack.packet.RosterPacket;\nimport org.jivesoftware.smack.provider.ProviderManager;\nimport org.jivesoftware.smack.util.DNSUtil;\nimport org.jivesoftware.smack.util.StringUtils;\nimport org.jivesoftware.smack.util.dns.DNSJavaResolver;\nimport org.jivesoftware.smackx.entitycaps.EntityCapsManager;\nimport org.jivesoftware.smackx.entitycaps.cache.SimpleDirectoryPersistentCache;\nimport org.jivesoftware.smackx.Form;\nimport org.jivesoftware.smackx.FormField;\nimport org.jivesoftware.smackx.GroupChatInvitation;\nimport org.jivesoftware.smackx.ServiceDiscoveryManager;\nimport org.jivesoftware.smackx.muc.DiscussionHistory;\nimport org.jivesoftware.smackx.muc.InvitationListener;\nimport org.jivesoftware.smackx.muc.MultiUserChat;\nimport org.jivesoftware.smackx.muc.Occupant;\nimport org.jivesoftware.smackx.muc.RoomInfo;\nimport org.jivesoftware.smackx.carbons.Carbon;\nimport org.jivesoftware.smackx.carbons.CarbonManager;\nimport org.jivesoftware.smackx.entitycaps.provider.CapsExtensionProvider;\nimport org.jivesoftware.smackx.forward.Forwarded;\nimport org.jivesoftware.smackx.muc.MultiUserChat;\nimport org.jivesoftware.smackx.provider.DataFormProvider;\nimport org.jivesoftware.smackx.provider.DelayInfoProvider;\nimport org.jivesoftware.smackx.provider.DiscoverInfoProvider;\nimport org.jivesoftware.smackx.provider.DiscoverItemsProvider;\nimport org.jivesoftware.smackx.provider.MUCAdminProvider;\nimport org.jivesoftware.smackx.provider.MUCOwnerProvider;\nimport org.jivesoftware.smackx.provider.MUCUserProvider;\nimport org.jivesoftware.smackx.packet.DelayInformation;\nimport org.jivesoftware.smackx.packet.DelayInfo;\nimport org.jivesoftware.smackx.packet.DiscoverInfo;\nimport org.jivesoftware.smackx.packet.MUCUser;\nimport org.jivesoftware.smackx.packet.Version;\nimport org.jivesoftware.smackx.ping.PingManager;\nimport org.jivesoftware.smackx.ping.packet.*;\nimport org.jivesoftware.smackx.ping.provider.PingProvider;\nimport org.jivesoftware.smackx.receipts.DeliveryReceipt;\nimport org.jivesoftware.smackx.receipts.DeliveryReceiptManager;\nimport org.jivesoftware.smackx.receipts.DeliveryReceiptRequest;\nimport org.jivesoftware.smackx.receipts.ReceiptReceivedListener;\nimport org.yaxim.androidclient.YaximApplication;\nimport org.yaxim.androidclient.data.ChatHelper;\nimport org.yaxim.androidclient.data.ChatProvider;\nimport org.yaxim.androidclient.data.ChatRoomHelper;\nimport org.yaxim.androidclient.data.RosterProvider;\nimport org.yaxim.androidclient.data.YaximConfiguration;\nimport org.yaxim.androidclient.data.ChatProvider.ChatConstants;\nimport org.yaxim.androidclient.data.RosterProvider.RosterConstants;\nimport org.yaxim.androidclient.exceptions.YaximXMPPException;\nimport org.yaxim.androidclient.packet.PreAuth;\nimport org.yaxim.androidclient.packet.Replace;\nimport org.yaxim.androidclient.util.ConnectionState;\nimport org.yaxim.androidclient.util.LogConstants;\nimport org.yaxim.androidclient.util.PreferenceConstants;\nimport org.yaxim.androidclient.util.StatusMode;\nimport org.yaxim.androidclient.R;\n\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.database.Cursor;\n\nimport android.net.Uri;\nimport android.telephony.gsm.SmsMessage.MessageClass;\nimport android.text.TextUtils;\nimport android.util.Log;\n\npublic class SmackableImp implements Smackable {\n\tfinal static private String TAG = \"yaxim.SmackableImp\";\n\n\tfinal static private int PACKET_TIMEOUT = 30000;\n\n\tfinal static private String[] SEND_OFFLINE_PROJECTION = new String[] {\n\t\t\tChatConstants._ID, ChatConstants.JID,\n\t\t\tChatConstants.MESSAGE, ChatConstants.DATE, ChatConstants.PACKET_ID };\n\tfinal static private String SEND_OFFLINE_SELECTION =\n\t\t\tChatConstants.DIRECTION + \" = \" + ChatConstants.OUTGOING + \" AND \" +\n\t\t\tChatConstants.DELIVERY_STATUS + \" = \" + ChatConstants.DS_NEW;\n\n\tstatic final DiscoverInfo.Identity YAXIM_IDENTITY = new DiscoverInfo.Identity(\"client\",\n\t\t\t\t\tYaximApplication.XMPP_IDENTITY_NAME,\n\t\t\t\t\tYaximApplication.XMPP_IDENTITY_TYPE);\n\n\tstatic File capsCacheDir = null; ///< this is used to cache if we already initialized EntityCapsCache\n\n\tstatic {\n\t\tregisterSmackProviders();\n\t\tDNSUtil.setDNSResolver(DNSJavaResolver.getInstance());\n\n\t\t// initialize smack defaults before any connections are created\n\t\tSmackConfiguration.setPacketReplyTimeout(PACKET_TIMEOUT);\n\t\tSmackConfiguration.setDefaultPingInterval(0);\n\t}\n\n\tstatic void registerSmackProviders() {\n\t\tProviderManager pm = ProviderManager.getInstance();\n\t\t// add IQ handling\n\t\tpm.addIQProvider(\"query\",\"http://jabber.org/protocol/disco#info\", new DiscoverInfoProvider());\n\t\tpm.addIQProvider(\"query\",\"http://jabber.org/protocol/disco#items\", new DiscoverItemsProvider());\n\t\t// add delayed delivery notifications\n\t\tpm.addExtensionProvider(\"delay\",\"urn:xmpp:delay\", new DelayInfoProvider());\n\t\tpm.addExtensionProvider(\"x\",\"jabber:x:delay\", new DelayInfoProvider());\n\t\t// add XEP-0092 Software Version\n\t\tpm.addIQProvider(\"query\", Version.NAMESPACE, new Version.Provider());\n\n\t\t// data forms\n\t\tpm.addExtensionProvider(\"x\",\"jabber:x:data\", new DataFormProvider());\n\n\t\t// add carbons and forwarding\n\t\tpm.addExtensionProvider(\"forwarded\", Forwarded.NAMESPACE, new Forwarded.Provider());\n\t\tpm.addExtensionProvider(\"sent\", Carbon.NAMESPACE, new Carbon.Provider());\n\t\tpm.addExtensionProvider(\"received\", Carbon.NAMESPACE, new Carbon.Provider());\n\t\t// add delivery receipts\n\t\tpm.addExtensionProvider(DeliveryReceipt.ELEMENT, DeliveryReceipt.NAMESPACE, new DeliveryReceipt.Provider());\n\t\tpm.addExtensionProvider(DeliveryReceiptRequest.ELEMENT, DeliveryReceipt.NAMESPACE, new DeliveryReceiptRequest.Provider());\n\t\t// add XMPP Ping (XEP-0199)\n\t\tpm.addIQProvider(\"ping\",\"urn:xmpp:ping\", new PingProvider());\n\n\t\tServiceDiscoveryManager.setDefaultIdentity(YAXIM_IDENTITY);\n\t\t\n\t\t// XEP-0115 Entity Capabilities\n\t\tpm.addExtensionProvider(\"c\", \"http://jabber.org/protocol/caps\", new CapsExtensionProvider());\n\n\t\t// XEP-0308 Last Message Correction\n\t\tpm.addExtensionProvider(\"replace\", Replace.NAMESPACE, new Replace.Provider());\n\n\t\t// XEP-XXXX Pre-Authenticated Roster Subscription\n\t\tpm.addExtensionProvider(\"preauth\", PreAuth.NAMESPACE, new PreAuth.Provider());\n\n\t\t//  MUC User\n\t\tpm.addExtensionProvider(\"x\",\"http://jabber.org/protocol/muc#user\", new MUCUserProvider());\n\t\t// MUC direct invitation\n\t\tpm.addExtensionProvider(\"x\",\"jabber:x:conference\", new GroupChatInvitation.Provider());\n\t\t//  MUC Admin\n\t\tpm.addIQProvider(\"query\",\"http://jabber.org/protocol/muc#admin\", new MUCAdminProvider());\n\t\t//  MUC Owner\n\t\tpm.addIQProvider(\"query\",\"http://jabber.org/protocol/muc#owner\", new MUCOwnerProvider());\n\n\t\tXmppStreamHandler.addExtensionProviders();\n\t}\n\n\tprivate final YaximConfiguration mConfig;\n\tprivate ConnectionConfiguration mXMPPConfig;\n\tprivate XmppStreamHandler.ExtXMPPConnection mXMPPConnection;\n\tprivate XmppStreamHandler mStreamHandler;\n\tprivate Thread mConnectingThread;\n\tprivate Object mConnectingThreadMutex = new Object();\n\n\n\tprivate ConnectionState mRequestedState = ConnectionState.OFFLINE;\n\tprivate ConnectionState mState = ConnectionState.OFFLINE;\n\tprivate String mLastError;\n\tprivate long mLastOnline = 0;\t//< timestamp of last successful full login (XEP-0198 does not count)\n\tprivate long mLastOffline = 0;\t//< timestamp of the end of last successful login\n\n\tprivate XMPPServiceCallback mServiceCallBack;\n\tprivate Roster mRoster;\n\tprivate RosterListener mRosterListener;\n\tprivate PacketListener mPacketListener;\n\tprivate PacketListener mPresenceListener;\n\tprivate ConnectionListener mConnectionListener;\n\n\tprivate final ContentResolver mContentResolver;\n\n\tprivate AlarmManager mAlarmManager;\n\tprivate PacketListener mPongListener;\n\tprivate String mPingID;\n\tprivate long mPingTimestamp;\n\n\tprivate PendingIntent mPingAlarmPendIntent;\n\tprivate PendingIntent mPongTimeoutAlarmPendIntent;\n\tprivate static final String PING_ALARM = \"org.yaxim.androidclient.PING_ALARM\";\n\tprivate static final String PONG_TIMEOUT_ALARM = \"org.yaxim.androidclient.PONG_TIMEOUT_ALARM\";\n\tprivate Intent mPingAlarmIntent = new Intent(PING_ALARM);\n\tprivate Intent mPongTimeoutAlarmIntent = new Intent(PONG_TIMEOUT_ALARM);\n\tprivate Service mService;\n\n\tprivate PongTimeoutAlarmReceiver mPongTimeoutAlarmReceiver = new PongTimeoutAlarmReceiver();\n\tprivate BroadcastReceiver mPingAlarmReceiver = new PingAlarmReceiver();\n\t\n\tprivate final HashSet<String> mucJIDs = new HashSet<String>();\t//< all configured MUCs, joined or not\n\tprivate Map<String, MultiUserChat> multiUserChats;\n\tprivate long mucLastPing = 0;\n\tprivate Map<String, Long> mucLastPong = new HashMap<String, Long>();\t//< per-MUC timestamp of last incoming ping result\n\tprivate Map<String, Presence> subscriptionRequests = new HashMap<String, Presence>();\n\n\n\tpublic SmackableImp(YaximConfiguration config,\n\t\t\tContentResolver contentResolver,\n\t\t\tService service) {\n\t\tthis.mConfig = config;\n\t\tthis.mContentResolver = contentResolver;\n\t\tthis.mService = service;\n\t\tthis.mAlarmManager = (AlarmManager)mService.getSystemService(Context.ALARM_SERVICE);\n\n\t\tmLastOnline = mLastOffline = System.currentTimeMillis();\n\t}\n\t\t\n\t// this code runs a DNS resolver, might be blocking\n\tprivate synchronized void initXMPPConnection() {\n\t\t// allow custom server / custom port to override SRV record\n\t\tif (mConfig.customServer.length() > 0)\n\t\t\tmXMPPConfig = new ConnectionConfiguration(mConfig.customServer,\n\t\t\t\t\tmConfig.port, mConfig.server);\n\t\telse\n\t\t\tmXMPPConfig = new ConnectionConfiguration(mConfig.server); // use SRV\n\t\tmXMPPConfig.setReconnectionAllowed(false);\n\t\tmXMPPConfig.setSendPresence(false);\n\t\tmXMPPConfig.setCompressionEnabled(false); // disable for now\n\t\tmXMPPConfig.setDebuggerEnabled(mConfig.smackdebug);\n\t\tif (mConfig.require_ssl)\n\t\t\tthis.mXMPPConfig.setSecurityMode(ConnectionConfiguration.SecurityMode.required);\n\n\t\t// register MemorizingTrustManager for HTTPS\n\t\ttry {\n\t\t\tSSLContext sc = SSLContext.getInstance(\"TLS\");\n\t\t\tMemorizingTrustManager mtm = YaximApplication.getApp(mService).mMTM;\n\t\t\tsc.init(null, new X509TrustManager[] { mtm },\n\t\t\t\t\tnew java.security.SecureRandom());\n\t\t\tthis.mXMPPConfig.setCustomSSLContext(sc);\n\t\t\tthis.mXMPPConfig.setHostnameVerifier(mtm.wrapHostnameVerifier(\n\t\t\t\t\t\tnew org.apache.http.conn.ssl.StrictHostnameVerifier()));\n\t\t} catch (java.security.GeneralSecurityException e) {\n\t\t\tdebugLog(\"initialize MemorizingTrustManager: \" + e);\n\t\t}\n\n\t\tthis.mXMPPConnection = new XmppStreamHandler.ExtXMPPConnection(mXMPPConfig);\n\t\tthis.mStreamHandler = new XmppStreamHandler(mXMPPConnection, mConfig.smackdebug);\n\t\tmStreamHandler.addAckReceivedListener(new XmppStreamHandler.AckReceivedListener() {\n\t\t\tpublic void ackReceived(long handled, long total) {\n\t\t\t\tgotServerPong(\"\" + handled);\n\t\t\t}\n\t\t});\n\t\tmConfig.reconnect_required = false;\n\n\t\tmultiUserChats = new HashMap<String, MultiUserChat>();\n\t\tinitServiceDiscovery();\n\t}\n\n\t// blocking, run from a thread!\n\tpublic boolean doConnect(boolean create_account) throws YaximXMPPException {\n\t\tmRequestedState = ConnectionState.ONLINE;\n\t\tupdateConnectionState(ConnectionState.CONNECTING);\n\t\tif (mXMPPConnection == null || mConfig.reconnect_required)\n\t\t\tinitXMPPConnection();\n\t\ttryToConnect(create_account);\n\t\t// actually, authenticated must be true now, or an exception must have\n\t\t// been thrown.\n\t\tif (isAuthenticated()) {\n\t\t\tupdateConnectionState(ConnectionState.LOADING);\n\t\t\tregisterMessageListener();\n\t\t\tregisterPresenceListener();\n\t\t\tregisterPongListener();\n\t\t\tsyncDbRooms();\n\t\t\tsendOfflineMessages();\n\t\t\tsendUserWatching();\n\t\t\t// we need to \"ping\" the service to let it know we are actually\n\t\t\t// connected, even when no roster entries will come in\n\t\t\tupdateConnectionState(ConnectionState.ONLINE);\n\t\t} else throw new YaximXMPPException(\"SMACK connected, but authentication failed\");\n\t\treturn true;\n\t}\n\n\t// BLOCKING, call on a new Thread!\n\tprivate void updateConnectingThread(Thread new_thread) {\n\t\tsynchronized(mConnectingThreadMutex) {\n\t\t\tif (mConnectingThread == null) {\n\t\t\t\tmConnectingThread = new_thread;\n\t\t\t} else try {\n\t\t\t\tLog.d(TAG, \"updateConnectingThread: old thread is still running, killing it.\");\n\t\t\t\tmConnectingThread.interrupt();\n\t\t\t\tmConnectingThread.join(50);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLog.d(TAG, \"updateConnectingThread: failed to join(): \" + e);\n\t\t\t} finally {\n\t\t\t\tmConnectingThread = new_thread;\n\t\t\t}\n\t\t}\n\t}\n\tprivate void finishConnectingThread() {\n\t\tsynchronized(mConnectingThreadMutex) {\n\t\t\tmConnectingThread = null;\n\t\t}\n\t}\n\n\t/** Non-blocking, synchronized function to connect/disconnect XMPP.\n\t * This code is called from outside and returns immediately. The actual work\n\t * is done on a background thread, and notified via callback.\n\t * @param new_state The state to transition into. Possible values:\n\t * \tOFFLINE to properly close the connection\n\t * \tONLINE to connect\n\t * \tDISCONNECTED when network goes down\n\t * @param create_account When going online, try to register an account.\n\t */\n\t@Override\n\tpublic synchronized void requestConnectionState(ConnectionState new_state, final boolean create_account) {\n\t\tLog.d(TAG, \"requestConnState: \" + mState + \" -> \" + new_state + (create_account ? \" create_account!\" : \"\"));\n\t\tmRequestedState = new_state;\n\t\tif (new_state == mState)\n\t\t\treturn;\n\t\tswitch (new_state) {\n\t\tcase ONLINE:\n\t\t\tswitch (mState) {\n\t\t\tcase RECONNECT_DELAYED:\n\t\t\t\t// TODO: cancel timer\n\t\t\tcase RECONNECT_NETWORK:\n\t\t\tcase DISCONNECTED:\n\t\t\tcase OFFLINE:\n\t\t\t\t// update state before starting thread to prevent race conditions\n\t\t\t\tupdateConnectionState(ConnectionState.CONNECTING);\n\n\t\t\t\t// register ping (connection) timeout handler: 2*PACKET_TIMEOUT(30s) + 3s\n\t\t\t\tregisterPongTimeout(2*PACKET_TIMEOUT + 3000, \"connection\");\n\n\t\t\t\tnew Thread() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tupdateConnectingThread(this);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdoConnect(create_account);\n\t\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t\t// this might happen when DNS resolution in ConnectionConfiguration fails\n\t\t\t\t\t\t\tonDisconnected(e);\n\t\t\t\t\t\t} catch (IllegalStateException e) {//TODO: work around old smack\n\t\t\t\t\t\t\tonDisconnected(e);\n\t\t\t\t\t\t} catch (YaximXMPPException e) {\n\t\t\t\t\t\t\tonDisconnected(e);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tmAlarmManager.cancel(mPongTimeoutAlarmPendIntent);\n\t\t\t\t\t\t\tfinishConnectingThread();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.start();\n\t\t\t\tbreak;\n\t\t\tcase CONNECTING:\n\t\t\tcase LOADING:\n\t\t\tcase DISCONNECTING:\n\t\t\t\t// ignore all other cases\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DISCONNECTED:\n\t\t\t// spawn thread to do disconnect\n\t\t\tif (mState == ConnectionState.ONLINE) {\n\t\t\t\t// update state before starting thread to prevent race conditions\n\t\t\t\tupdateConnectionState(ConnectionState.DISCONNECTING);\n\n\t\t\t\t// register ping (connection) timeout handler: PACKET_TIMEOUT(30s)\n\t\t\t\tregisterPongTimeout(PACKET_TIMEOUT, \"forced disconnect\");\n\n\t\t\t\tnew Thread() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tupdateConnectingThread(this);\n\t\t\t\t\t\tmStreamHandler.quickShutdown();\n\t\t\t\t\t\tonDisconnected(\"forced disconnect completed\");\n\t\t\t\t\t\tfinishConnectingThread();\n\t\t\t\t\t\t//updateConnectionState(ConnectionState.OFFLINE);\n\t\t\t\t\t}\n\t\t\t\t}.start();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OFFLINE:\n\t\t\tswitch (mState) {\n\t\t\tcase CONNECTING:\n\t\t\tcase LOADING:\n\t\t\tcase ONLINE:\n\t\t\t\t// update state before starting thread to prevent race conditions\n\t\t\t\tupdateConnectionState(ConnectionState.DISCONNECTING);\n\n\t\t\t\t// register ping (connection) timeout handler: PACKET_TIMEOUT(30s)\n\t\t\t\tregisterPongTimeout(PACKET_TIMEOUT, \"manual disconnect\");\n\n\t\t\t\t// spawn thread to do disconnect\n\t\t\t\tnew Thread() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tupdateConnectingThread(this);\n\t\t\t\t\t\tmXMPPConnection.shutdown();\n\t\t\t\t\t\tmStreamHandler.close();\n\t\t\t\t\t\tmAlarmManager.cancel(mPongTimeoutAlarmPendIntent);\n\t\t\t\t\t\t// we should reset XMPPConnection the next time\n\t\t\t\t\t\tmConfig.reconnect_required = true;\n\t\t\t\t\t\tfinishConnectingThread();\n\t\t\t\t\t\t// reconnect if it was requested in the meantime\n\t\t\t\t\t\tif (mRequestedState == ConnectionState.ONLINE)\n\t\t\t\t\t\t\trequestConnectionState(ConnectionState.ONLINE);\n\t\t\t\t\t}\n\t\t\t\t}.start();\n\t\t\t\tbreak;\n\t\t\tcase DISCONNECTING:\n\t\t\t\tbreak;\n\t\t\tcase DISCONNECTED:\n\t\t\tcase RECONNECT_DELAYED:\n\t\t\t\t// TODO: clear timer\n\t\t\tcase RECONNECT_NETWORK:\n\t\t\t\tupdateConnectionState(ConnectionState.OFFLINE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RECONNECT_NETWORK:\n\t\tcase RECONNECT_DELAYED:\n\t\t\tswitch (mState) {\n\t\t\tcase DISCONNECTED:\n\t\t\tcase RECONNECT_NETWORK:\n\t\t\tcase RECONNECT_DELAYED:\n\t\t\t\tupdateConnectionState(new_state);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"Can not go from \" + mState + \" to \" + new_state);\n\t\t\t}\n\t\t}\n\t}\n\t@Override\n\tpublic void requestConnectionState(ConnectionState new_state) {\n\t\trequestConnectionState(new_state, false);\n\t}\n\n\t@Override\n\tpublic ConnectionState getConnectionState() {\n\t\treturn mState;\n\t}\n\n\t@Override\n\tpublic long getConnectionStateTimestamp() {\n\t\treturn (mState == ConnectionState.ONLINE) ? mLastOnline : mLastOffline;\n\t}\n\n\t// called at the end of a state transition\n\tprivate synchronized void updateConnectionState(ConnectionState new_state) {\n\t\tif (new_state == ConnectionState.ONLINE || new_state == ConnectionState.LOADING)\n\t\t\tmLastError = null;\n\t\tLog.d(TAG, \"updateConnectionState: \" + mState + \" -> \" + new_state + \" (\" + mLastError + \")\");\n\t\tif (new_state == mState)\n\t\t\treturn;\n\t\tif (mState == ConnectionState.ONLINE)\n\t\t\tmLastOffline = System.currentTimeMillis();\n\t\tmState = new_state;\n\t\tif (mServiceCallBack != null)\n\t\t\tmServiceCallBack.connectionStateChanged();\n\t}\n\tprivate void initServiceDiscovery() {\n\t\t// register connection features\n\t\tServiceDiscoveryManager sdm = ServiceDiscoveryManager.getInstanceFor(mXMPPConnection);\n\n\t\t// init Entity Caps manager with storage in app's cache dir\n\t\ttry {\n\t\t\tif (capsCacheDir == null) {\n\t\t\t\tcapsCacheDir = new File(mService.getCacheDir(), \"entity-caps-cache\");\n\t\t\t\tcapsCacheDir.mkdirs();\n\t\t\t\tEntityCapsManager.setPersistentCache(new SimpleDirectoryPersistentCache(capsCacheDir));\n\t\t\t}\n\t\t} catch (java.io.IOException e) {\n\t\t\tLog.e(TAG, \"Could not init Entity Caps cache: \" + e.getLocalizedMessage());\n\t\t}\n\n\t\t// reference PingManager, set ping flood protection to 10s\n\t\tPingManager.getInstanceFor(mXMPPConnection).disablePingFloodProtection();\n\n\t\t// set Version for replies\n\t\tString app_name = mService.getString(R.string.app_name);\n\t\tString build_revision = mService.getString(R.string.build_revision);\n\t\tVersion.Manager.getInstanceFor(mXMPPConnection).setVersion(\n\t\t\t\tnew Version(app_name, build_revision, \"Android\"));\n\n\t\t// reference DeliveryReceiptManager, add listener\n\t\tDeliveryReceiptManager dm = DeliveryReceiptManager.getInstanceFor(mXMPPConnection);\n\t\tdm.addReceiptReceivedListener(new ReceiptReceivedListener() { // DOES NOT WORK IN CARBONS\n\t\t\tpublic void onReceiptReceived(String fromJid, String toJid, String receiptId) {\n\t\t\t\tLog.d(TAG, \"got delivery receipt for \" + receiptId);\n\t\t\t\tchangeMessageDeliveryStatus(receiptId, ChatConstants.DS_ACKED);\n\t\t\t}});\n\t}\n\n\tpublic void addRosterItem(String user, String alias, String group, String token)\n\t\t\tthrows YaximXMPPException {\n\t\tsubscriptionRequests.remove(user);\n\t\tmConfig.whitelistInvitationJID(user);\n\t\ttryToAddRosterEntry(user, alias, group, token);\n\t}\n\n\tpublic void removeRosterItem(String user) throws YaximXMPPException {\n\t\tdebugLog(\"removeRosterItem(\" + user + \")\");\n\t\tsubscriptionRequests.remove(user);\n\t\ttryToRemoveRosterEntry(user);\n\t}\n\n\tpublic void renameRosterItem(String user, String newName)\n\t\t\tthrows YaximXMPPException {\n\t\tRosterEntry rosterEntry = mRoster.getEntry(user);\n\n\t\tif (!(newName.length() > 0) || (rosterEntry == null)) {\n\t\t\tthrow new YaximXMPPException(\"JabberID to rename is invalid!\");\n\t\t}\n\t\trosterEntry.setName(newName);\n\t}\n\n\tpublic void addRosterGroup(String group) {\n\t\tmRoster.createGroup(group);\n\t}\n\n\tpublic void renameRosterGroup(String group, String newGroup) {\n\t\tRosterGroup groupToRename = mRoster.getGroup(group);\n\t\tgroupToRename.setName(newGroup);\n\t}\n\n\tpublic void moveRosterItemToGroup(String user, String group)\n\t\t\tthrows YaximXMPPException {\n\t\ttryToMoveRosterEntryToGroup(user, group);\n\t}\n\n\tpublic void sendPresenceRequest(String user, String type) {\n\t\t// HACK: remove the fake roster entry added by handleIncomingSubscribe()\n\t\tsubscriptionRequests.remove(user);\n\t\tif (\"unsubscribed\".equals(type))\n\t\t\tdeleteRosterEntryFromDB(user);\n\t\tPresence response = new Presence(Presence.Type.valueOf(type));\n\t\tresponse.setTo(user);\n\t\tmXMPPConnection.sendPacket(response);\n\t}\n\t\n\t@Override\n\tpublic String changePassword(String newPassword) {\n\t\ttry {\n\t\t\tnew AccountManager(mXMPPConnection).changePassword(newPassword);\n\t\t\treturn \"OK\"; //HACK: hard coded string to differentiate from failure modes\n\t\t} catch (XMPPException e) {\n\t\t\tif (e.getXMPPError() != null)\n\t\t\t\treturn e.getXMPPError().toString();\n\t\t\telse\n\t\t\t\treturn e.getLocalizedMessage();\n\t\t}\n\t}\n\n\tprivate void onDisconnected(String reason) {\n\t\tunregisterPongListener();\n\t\tmLastError = reason;\n\t\tupdateConnectionState(ConnectionState.DISCONNECTED);\n\t}\n\tprivate void onDisconnected(Throwable reason) {\n\t\tLog.e(TAG, \"onDisconnected: \" + reason);\n\t\treason.printStackTrace();\n\t\t// iterate through to the deepest exception\n\t\twhile (reason.getCause() != null && !(reason.getCause().getClass().getSimpleName().equals(\"GaiException\")))\n\t\t\treason = reason.getCause();\n\t\tonDisconnected(reason.getLocalizedMessage());\n\t}\n\n\tprivate void tryToConnect(boolean create_account) throws YaximXMPPException {\n\t\ttry {\n\t\t\tif (mXMPPConnection.isConnected()) {\n\t\t\t\ttry {\n\t\t\t\t\tmStreamHandler.quickShutdown(); // blocking shutdown prior to re-connection\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tdebugLog(\"conn.shutdown() failed: \" + e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tregisterRosterListener();\n\t\t\tboolean need_bind = !mStreamHandler.isResumePossible();\n\n\t\t\tif (mConnectionListener != null)\n\t\t\t\tmXMPPConnection.removeConnectionListener(mConnectionListener);\n\t\t\tmConnectionListener = new ConnectionListener() {\n\t\t\t\tpublic void connectionClosedOnError(Exception e) {\n\t\t\t\t\t// XXX: this is the only callback we get from errors, so\n\t\t\t\t\t// we need to check for non-resumability and work around\n\t\t\t\t\t// here:\n\t\t\t\t\tif (!mStreamHandler.isResumePossible()) {\n\t\t\t\t\t\tmultiUserChats.clear();\n\t\t\t\t\t\tmucLastPong.clear();\n\t\t\t\t\t\tmucLastPing = 0;\n\t\t\t\t\t}\n\t\t\t\t\tonDisconnected(e);\n\t\t\t\t}\n\t\t\t\tpublic void connectionClosed() {\n\t\t\t\t\t// TODO: fix reconnect when we got kicked by the server or SM failed!\n\t\t\t\t\t//onDisconnected(null);\n\t\t\t\t\tmultiUserChats.clear();\n\t\t\t\t\tmucLastPong.clear();\n\t\t\t\t\tmucLastPing = 0;\n\t\t\t\t\tupdateConnectionState(ConnectionState.OFFLINE);\n\t\t\t\t}\n\t\t\t\tpublic void reconnectingIn(int seconds) { }\n\t\t\t\tpublic void reconnectionFailed(Exception e) { }\n\t\t\t\tpublic void reconnectionSuccessful() { }\n\t\t\t};\n\t\t\tmXMPPConnection.addConnectionListener(mConnectionListener);\n\n\t\t\tmXMPPConnection.connect(need_bind);\n\t\t\t// SMACK auto-logins if we were authenticated before\n\t\t\tif (!mXMPPConnection.isAuthenticated()) {\n\t\t\t\tif (create_account) {\n\t\t\t\t\tLog.d(TAG, \"creating new server account...\");\n\t\t\t\t\tAccountManager am = new AccountManager(mXMPPConnection);\n\t\t\t\t\tam.createAccount(mConfig.userName, mConfig.password);\n\t\t\t\t}\n\t\t\t\tmXMPPConnection.login(mConfig.userName, mConfig.password,\n\t\t\t\t\t\tmConfig.ressource);\n\t\t\t}\n\t\t\tLog.d(TAG, \"SM: can resume = \" + mStreamHandler.isResumePossible() + \" needbind=\" + need_bind);\n\t\t\tif (need_bind) {\n\t\t\t\tmStreamHandler.notifyInitialLogin();\n\t\t\t\tcleanupMUCs(true);\n\t\t\t\tsetStatusFromConfig();\n\t\t\t\tmLastOnline = System.currentTimeMillis();\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\t// actually we just care for IllegalState or NullPointer or XMPPEx.\n\t\t\tthrow new YaximXMPPException(\"tryToConnect failed\", e);\n\t\t}\n\t}\n\n\tprivate void tryToMoveRosterEntryToGroup(String userName, String groupName)\n\t\t\tthrows YaximXMPPException {\n\n\t\tRosterGroup rosterGroup = getRosterGroup(groupName);\n\t\tRosterEntry rosterEntry = mRoster.getEntry(userName);\n\n\t\tremoveRosterEntryFromGroups(rosterEntry);\n\n\t\tif (groupName.length() == 0)\n\t\t\treturn;\n\t\telse {\n\t\t\ttry {\n\t\t\t\trosterGroup.addEntry(rosterEntry);\n\t\t\t} catch (XMPPException e) {\n\t\t\t\tthrow new YaximXMPPException(\"tryToMoveRosterEntryToGroup\", e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate RosterGroup getRosterGroup(String groupName) {\n\t\tRosterGroup rosterGroup = mRoster.getGroup(groupName);\n\n\t\t// create group if unknown\n\t\tif ((groupName.length() > 0) && rosterGroup == null) {\n\t\t\trosterGroup = mRoster.createGroup(groupName);\n\t\t}\n\t\treturn rosterGroup;\n\n\t}\n\n\tprivate void removeRosterEntryFromGroups(RosterEntry rosterEntry)\n\t\t\tthrows YaximXMPPException {\n\t\tCollection<RosterGroup> oldGroups = rosterEntry.getGroups();\n\n\t\tfor (RosterGroup group : oldGroups) {\n\t\t\ttryToRemoveUserFromGroup(group, rosterEntry);\n\t\t}\n\t}\n\n\tprivate void tryToRemoveUserFromGroup(RosterGroup group,\n\t\t\tRosterEntry rosterEntry) throws YaximXMPPException {\n\t\ttry {\n\t\t\tgroup.removeEntry(rosterEntry);\n\t\t} catch (XMPPException e) {\n\t\t\tthrow new YaximXMPPException(\"tryToRemoveUserFromGroup\", e);\n\t\t}\n\t}\n\n\tprivate void tryToRemoveRosterEntry(String user) throws YaximXMPPException {\n\t\ttry {\n\t\t\tRosterEntry rosterEntry = mRoster.getEntry(user);\n\n\t\t\tif (rosterEntry != null) {\n\t\t\t\t// first, unsubscribe the user\n\t\t\t\tPresence unsub = new Presence(Presence.Type.unsubscribed);\n\t\t\t\tunsub.setTo(rosterEntry.getUser());\n\t\t\t\tmXMPPConnection.sendPacket(unsub);\n\t\t\t\t// then, remove from roster\n\t\t\t\tmRoster.removeEntry(rosterEntry);\n\t\t\t}\n\t\t} catch (XMPPException e) {\n\t\t\tthrow new YaximXMPPException(\"tryToRemoveRosterEntry\", e);\n\t\t}\n\t}\n\n\tprivate void tryToAddRosterEntry(String user, String alias, String group, String token)\n\t\t\tthrows YaximXMPPException {\n\t\ttry {\n\t\t\t// send a presence subscription request with token (must be before roster action!)\n\t\t\tif (token != null && token.length() > 0) {\n\t\t\t\tPresence preauth = new Presence(Presence.Type.subscribe);\n\t\t\t\tpreauth.setTo(user);\n\t\t\t\tpreauth.addExtension(new PreAuth(token));\n\t\t\t\tmXMPPConnection.sendPacket(preauth);\n\t\t\t}\n\t\t\t// add to roster, triggers another sub request by Smack (sigh)\n\t\t\tmRoster.createEntry(user, alias, new String[] { group });\n\t\t\t// send a pre-approval\n\t\t\tPresence pre_approval = new Presence(Presence.Type.subscribed);\n\t\t\tpre_approval.setTo(user);\n\t\t\tmXMPPConnection.sendPacket(pre_approval);\n\t\t\tmConfig.whitelistInvitationJID(user);\n\t\t} catch (XMPPException e) {\n\t\t\tthrow new YaximXMPPException(\"tryToAddRosterEntry\", e);\n\t\t}\n\t}\n\n\tprivate void removeOldRosterEntries() {\n\t\tLog.d(TAG, \"removeOldRosterEntries()\");\n\t\tCollection<RosterEntry> rosterEntries = mRoster.getEntries();\n\t\tStringBuilder exclusion = new StringBuilder(RosterConstants.JID + \" NOT IN (\");\n\t\tboolean first = true;\n\t\t\n\t\tfor (RosterEntry rosterEntry : rosterEntries) {\n\t\t\tif (first)\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\texclusion.append(\",\");\n\t\t\texclusion.append(\"'\").append(rosterEntry.getUser()).append(\"'\");\n\t\t}\n\t\t\n\t\texclusion.append(\") AND \"+RosterConstants.GROUP+\" NOT IN ('\" + RosterProvider.RosterConstants.MUCS + \"');\");\n\t\tint count = mContentResolver.delete(RosterProvider.CONTENT_URI, exclusion.toString(), null);\n\t\tLog.d(TAG, \"deleted \" + count + \" old roster entries\");\n\t}\n\n\t// HACK: add an incoming subscription request as a fake roster entry\n\tprivate void handleIncomingSubscribe(Presence request) {\n\t\t// perform Pre-Authenticated Roster Subscription, fallback to manual\n\t\ttry {\n\t\t\tString jid = request.getFrom();\n\t\t\tPreAuth preauth = (PreAuth)request.getExtension(PreAuth.ELEMENT, PreAuth.NAMESPACE);\n\t\t\tString jid_or_token = jid;\n\t\t\tif (preauth != null) {\n\t\t\t\tjid_or_token = preauth.getToken();\n\t\t\t\tLog.d(TAG, \"PARS: found token \" + jid_or_token);\n\t\t\t}\n\t\t\tif (mConfig.redeemInvitationCode(jid_or_token)) {\n\t\t\t\tLog.d(TAG, \"PARS: approving request from \" + jid);\n\t\t\t\tif (mRoster.getEntry(request.getFrom()) != null) {\n\t\t\t\t\t// already in roster, only send approval\n\t\t\t\t\tPresence response = new Presence(Presence.Type.subscribed);\n\t\t\t\t\tresponse.setTo(jid);\n\t\t\t\t\tmXMPPConnection.sendPacket(response);\n\t\t\t\t} else {\n\t\t\t\t\ttryToAddRosterEntry(jid, null, \"\", null);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (YaximXMPPException e) {\n\t\t\tLog.d(TAG, \"PARS: failed to send response: \" + e);\n\t\t}\n\n\t\tsubscriptionRequests.put(request.getFrom(), request);\n\n\t\tfinal ContentValues values = new ContentValues();\n\n\t\tvalues.put(RosterConstants.JID, request.getFrom());\n\t\tvalues.put(RosterConstants.STATUS_MODE, getStatusInt(request));\n\t\tvalues.put(RosterConstants.STATUS_MESSAGE, request.getStatus());\n\t\tif (!mRoster.contains(request.getFrom())) {\n\t\t\t// reset alias and group for new entries\n\t\t\tvalues.put(RosterConstants.ALIAS, request.getFrom());\n\t\t\tvalues.put(RosterConstants.GROUP, \"\");\n\t\t};\n\t\tupsertRoster(values, request.getFrom());\n\t}\n\n\tpublic void setStatusFromConfig() {\n\t\t// TODO: only call this when carbons changed, not on every presence change\n\t\tCarbonManager.getInstanceFor(mXMPPConnection).sendCarbonsEnabled(mConfig.messageCarbons);\n\n\t\tPresence presence = new Presence(Presence.Type.available);\n\t\tMode mode = Mode.valueOf(mConfig.getPresenceMode().toString());\n\t\tpresence.setMode(mode);\n\t\tpresence.setStatus(mConfig.statusMessage);\n\t\tpresence.setPriority(mConfig.priority);\n\t\tmXMPPConnection.sendPacket(presence);\n\t\tmConfig.presence_required = false;\n\t}\n\n\tpublic void sendOfflineMessages() {\n\t\tCursor cursor = mContentResolver.query(ChatProvider.CONTENT_URI,\n\t\t\t\tSEND_OFFLINE_PROJECTION, SEND_OFFLINE_SELECTION,\n\t\t\t\tnull, null);\n\t\tfinal int      _ID_COL = cursor.getColumnIndexOrThrow(ChatConstants._ID);\n\t\tfinal int      JID_COL = cursor.getColumnIndexOrThrow(ChatConstants.JID);\n\t\tfinal int      MSG_COL = cursor.getColumnIndexOrThrow(ChatConstants.MESSAGE);\n\t\tfinal int       TS_COL = cursor.getColumnIndexOrThrow(ChatConstants.DATE);\n\t\tfinal int PACKETID_COL = cursor.getColumnIndexOrThrow(ChatConstants.PACKET_ID);\n\t\tContentValues mark_sent = new ContentValues();\n\t\tmark_sent.put(ChatConstants.DELIVERY_STATUS, ChatConstants.DS_SENT_OR_READ);\n\t\twhile (cursor.moveToNext()) {\n\t\t\tint _id = cursor.getInt(_ID_COL);\n\t\t\tString toJID = cursor.getString(JID_COL);\n\t\t\tString message = cursor.getString(MSG_COL);\n\t\t\tString packetID = cursor.getString(PACKETID_COL);\n\t\t\tlong ts = cursor.getLong(TS_COL);\n\t\t\tLog.d(TAG, \"sendOfflineMessages: \" + toJID + \" > \" + message);\n\t\t\tfinal Message newMessage = new Message(toJID, Message.Type.chat);\n\t\t\tnewMessage.setBody(message);\n\t\t\tDelayInformation delay = new DelayInformation(new Date(ts));\n\t\t\tnewMessage.addExtension(delay);\n\t\t\tnewMessage.addExtension(new DelayInfo(delay));\n\t\t\tif (mucJIDs.contains(toJID))\n\t\t\t\tnewMessage.setType(Message.Type.groupchat);\n\t\t\telse\n\t\t\t\tnewMessage.addExtension(new DeliveryReceiptRequest());\n\t\t\tif ((packetID != null) && (packetID.length() > 0)) {\n\t\t\t\tnewMessage.setPacketID(packetID);\n\t\t\t} else {\n\t\t\t\tpacketID = newMessage.getPacketID();\n\t\t\t}\n\t\t\tmark_sent.put(ChatConstants.PACKET_ID, packetID);\n\t\t\tUri rowuri = Uri.parse(\"content://\" + ChatProvider.AUTHORITY\n\t\t\t\t+ \"/\" + ChatProvider.TABLE_NAME + \"/\" + _id);\n\t\t\tmContentResolver.update(rowuri, mark_sent,\n\t\t\t\t\t\tnull, null);\n\t\t\tmXMPPConnection.sendPacket(newMessage);\t\t// must be after marking delivered, otherwise it may override the SendFailListener\n\t\t}\n\t\tcursor.close();\n\t}\n\n\tpublic static void sendOfflineMessage(ContentResolver cr, String toJID, String message) {\n\t\tContentValues values = new ContentValues();\n\t\tvalues.put(ChatConstants.DIRECTION, ChatConstants.OUTGOING);\n\t\tvalues.put(ChatConstants.JID, toJID);\n\t\tvalues.put(ChatConstants.MESSAGE, message);\n\t\tvalues.put(ChatConstants.DELIVERY_STATUS, ChatConstants.DS_NEW);\n\t\tvalues.put(ChatConstants.DATE, System.currentTimeMillis());\n\t\tvalues.put(ChatConstants.PACKET_ID, Packet.nextID());\n\n\t\tcr.insert(ChatProvider.CONTENT_URI, values);\n\t}\n\n\tpublic void sendReceiptIfRequested(Packet packet) {\n\t\tDeliveryReceiptRequest drr = (DeliveryReceiptRequest)packet.getExtension(\n\t\t\t\tDeliveryReceiptRequest.ELEMENT, DeliveryReceipt.NAMESPACE);\n\t\tif (drr != null) {\n\t\t\tMessage ack = new Message(packet.getFrom(), Message.Type.normal);\n\t\t\tack.addExtension(new DeliveryReceipt(packet.getPacketID()));\n\t\t\tmXMPPConnection.sendPacket(ack);\n\t\t}\n\t}\n\n\tpublic void sendMessage(String toJID, String message) {\n\t\tfinal Message newMessage = new Message(toJID, Message.Type.chat);\n\t\tnewMessage.setBody(message);\n\t\tnewMessage.addExtension(new DeliveryReceiptRequest());\n\t\tif (isAuthenticated()) {\n\n\t\t\tif(mucJIDs.contains(toJID)) {\n\t\t\t\tsendMucMessage(toJID, message);\n\t\t\t} else {\n\t\t\t\taddChatMessageToDB(ChatConstants.OUTGOING, toJID, message, ChatConstants.DS_SENT_OR_READ,\n\t\t\t\t\t\tSystem.currentTimeMillis(), newMessage.getPacketID());\n\t\t\t\tmXMPPConnection.sendPacket(newMessage);\n\t\t\t}\n\t\t} else {\n\t\t\t// send offline -> store to DB\n\t\t\taddChatMessageToDB(ChatConstants.OUTGOING, toJID, message, ChatConstants.DS_NEW,\n\t\t\t\t\tSystem.currentTimeMillis(), newMessage.getPacketID());\n\t\t}\n\t}\n\n\tpublic boolean isAuthenticated() {\n\t\tif (mXMPPConnection != null) {\n\t\t\treturn (mXMPPConnection.isConnected() && mXMPPConnection\n\t\t\t\t\t.isAuthenticated());\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void registerCallback(XMPPServiceCallback callBack) {\n\t\tthis.mServiceCallBack = callBack;\n\t\tmService.registerReceiver(mPingAlarmReceiver, new IntentFilter(PING_ALARM));\n\t\tmService.registerReceiver(mPongTimeoutAlarmReceiver, new IntentFilter(PONG_TIMEOUT_ALARM));\n\t}\n\n\tpublic void unRegisterCallback() {\n\t\tdebugLog(\"unRegisterCallback()\");\n\t\t// remove callbacks _before_ tossing old connection\n\t\ttry {\n\t\t\tmXMPPConnection.getRoster().removeRosterListener(mRosterListener);\n\t\t\tmXMPPConnection.removePacketListener(mPacketListener);\n\t\t\tmXMPPConnection.removePacketListener(mPresenceListener);\n\n\t\t\tmXMPPConnection.removePacketListener(mPongListener);\n\t\t\tunregisterPongListener();\n\t\t} catch (Exception e) {\n\t\t\t// ignore it!\n\t\t\te.printStackTrace();\n\t\t}\n\t\trequestConnectionState(ConnectionState.OFFLINE);\n\t\tsetStatusOffline();\n\t\tmService.unregisterReceiver(mPingAlarmReceiver);\n\t\tmService.unregisterReceiver(mPongTimeoutAlarmReceiver);\n//\t\tmultiUserChats.clear(); // TODO: right place\n\t\tthis.mServiceCallBack = null;\n\t}\n\t\n\tpublic String getNameForJID(String jid) {\n\t\tif (jid.contains(\"/\")) { // MUC-PM\n\t\t\tString[] jid_parts = jid.split(\"/\", 2);\n\t\t\treturn String.format(\"%s (%s)\", jid_parts[1],\n\t\t\t\t\tChatRoomHelper.getRoomName(mService, jid_parts[0]));\n\t\t}\n\t\tRosterEntry re = mRoster.getEntry(jid);\n\t\tif (null != re && null != re.getName() && re.getName().length() > 0) {\n\t\t\treturn re.getName();\n\t\t} else if (mucJIDs.contains(jid)) {\n\t\t\treturn ChatRoomHelper.getRoomName(mService, jid);\n\t\t} else {\n\t\t\treturn jid;\n\t\t}\t\t\t\n\t}\n\n\tpublic long getRowIdForMessage(String jid, String resource, int direction, String packet_id) {\n\t\t// query the DB for the RowID, return -1 if packet_id does not match\n\t\tCursor c = mContentResolver.query(ChatProvider.CONTENT_URI, new String[] { ChatConstants._ID, ChatConstants.PACKET_ID },\n\t\t\t\t\"jid = ? AND resource = ? AND from_me = ?\",\n\t\t\t\tnew String[] { jid, resource, \"\" + direction }, \"_id DESC\");\n\t\tlong result = -1;\n\t\tif (c.moveToFirst() && c.getString(1).equals(packet_id))\n\t\t\tresult = c.getLong(0);\n\t\tc.close();\n\t\treturn result;\n\t}\n\n\tprivate void setStatusOffline() {\n\t\tContentValues values = new ContentValues();\n\t\tvalues.put(RosterConstants.STATUS_MODE, StatusMode.offline.ordinal());\n\t\tmContentResolver.update(RosterProvider.CONTENT_URI, values, null, null);\n\t}\n\n\tprivate void registerRosterListener() {\n\t\t// flush roster on connecting.\n\t\tmRoster = mXMPPConnection.getRoster();\n\t\tmRoster.setSubscriptionMode(Roster.SubscriptionMode.manual);\n\n\t\tif (mRosterListener != null)\n\t\t\tmRoster.removeRosterListener(mRosterListener);\n\n\t\tmRosterListener = new RosterListener() {\n\t\t\tprivate boolean first_roster = true;\n\n\t\t\tpublic void entriesAdded(Collection<String> entries) {\n\t\t\t\tdebugLog(\"entriesAdded(\" + entries + \")\");\n\n\t\t\t\tContentValues[] cvs = new ContentValues[entries.size()];\n\t\t\t\tint i = 0;\n\t\t\t\tfor (String entry : entries) {\n\t\t\t\t\tRosterEntry rosterEntry = mRoster.getEntry(entry);\n\t\t\t\t\tcvs[i++] = getContentValuesForRosterEntry(rosterEntry);\n\t\t\t\t}\n\t\t\t\tmContentResolver.bulkInsert(RosterProvider.CONTENT_URI, cvs);\n\t\t\t\t// when getting the roster in the beginning, remove remains of old one\n\t\t\t\tif (first_roster) {\n\t\t\t\t\tremoveOldRosterEntries();\n\t\t\t\t\tfirst_roster = false;\n\t\t\t\t}\n\t\t\t\tdebugLog(\"entriesAdded() done\");\n\t\t\t}\n\n\t\t\tpublic void entriesDeleted(Collection<String> entries) {\n\t\t\t\tdebugLog(\"entriesDeleted(\" + entries + \")\");\n\n\t\t\t\tfor (String entry : entries) {\n\t\t\t\t\tdeleteRosterEntryFromDB(entry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void entriesUpdated(Collection<String> entries) {\n\t\t\t\tdebugLog(\"entriesUpdated(\" + entries + \")\");\n\n\t\t\t\tfor (String entry : entries) {\n\t\t\t\t\tRosterEntry rosterEntry = mRoster.getEntry(entry);\n\t\t\t\t\tupdateRosterEntryInDB(rosterEntry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void presenceChanged(Presence presence) {\n\t\t\t\tdebugLog(\"presenceChanged(\" + presence.getFrom() + \"): \" + presence);\n\n\t\t\t\tString jabberID = getBareJID(presence.getFrom());\n\t\t\t\tRosterEntry rosterEntry = mRoster.getEntry(jabberID);\n\t\t\t\tif (rosterEntry != null)\n\t\t\t\t\tupsertRoster(getContentValuesForRosterEntry(rosterEntry, presence),\n\t\t\t\t\t\t\trosterEntry.getUser());\n\t\t\t}\n\t\t};\n\t\tmRoster.addRosterListener(mRosterListener);\n\t}\n\n\tprivate String getBareJID(String from) {\n\t\tString[] res = from.split(\"/\", 2);\n\t\treturn res[0].toLowerCase();\n\t}\n\n\tprivate String[] getJabberID(String from) {\n\t\tif(from.contains(\"/\")) {\n\t\t\tString[] res = from.split(\"/\", 2);\n\t\t\treturn new String[] { res[0], res[1] };\n\t\t} else {\n\t\t\treturn new String[] {from, \"\"};\n\t\t}\n\t}\n\n\tpublic boolean changeMessageDeliveryStatus(String packetID, int new_status) {\n\t\tContentValues cv = new ContentValues();\n\t\tcv.put(ChatConstants.DELIVERY_STATUS, new_status);\n\t\tUri rowuri = Uri.parse(\"content://\" + ChatProvider.AUTHORITY + \"/\"\n\t\t\t\t+ ChatProvider.TABLE_NAME);\n\t\treturn mContentResolver.update(rowuri, cv,\n\t\t\t\tChatConstants.PACKET_ID + \" = ? AND \" +\n\t\t\t\tChatConstants.DELIVERY_STATUS + \" != \" + ChatConstants.DS_ACKED + \" AND \" +\n\t\t\t\tChatConstants.DIRECTION + \" = \" + ChatConstants.OUTGOING,\n\t\t\t\tnew String[] { packetID }) > 0;\n\t}\n\n\tprotected boolean is_user_watching = false;\n\tpublic void setUserWatching(boolean user_watching) {\n\t\tif (is_user_watching == user_watching)\n\t\t\treturn;\n\t\tis_user_watching = user_watching;\n\t\tif (mXMPPConnection != null && mXMPPConnection.isAuthenticated())\n\t\t\tsendUserWatching();\n\t}\n\n\tprotected void sendUserWatching() {\n\t\tIQ toggle_google_queue = new IQ() {\n\t\t\tpublic String getChildElementXML() {\n\t\t\t\t// enable g:q = start queueing packets = do it when the user is gone\n\t\t\t\treturn \"<query xmlns='google:queue'><\" + (is_user_watching ? \"disable\" : \"enable\") + \"/></query>\";\n\t\t\t}\n\t\t};\n\t\ttoggle_google_queue.setType(IQ.Type.SET);\n\t\tmXMPPConnection.sendPacket(toggle_google_queue);\n\t}\n\n\t/** Check the server connection, reconnect if needed.\n\t *\n\t * This function will try to ping the server if we are connected, and try\n\t * to reestablish a connection otherwise.\n\t */\n\tpublic void sendServerPing() {\n\t\tif (mXMPPConnection == null || !mXMPPConnection.isAuthenticated()) {\n\t\t\tdebugLog(\"Ping: requested, but not connected to server.\");\n\t\t\trequestConnectionState(ConnectionState.ONLINE, false);\n\t\t\treturn;\n\t\t}\n\t\tif (mPingID != null) {\n\t\t\tdebugLog(\"Ping: requested, but still waiting for \" + mPingID);\n\t\t\treturn; // a ping is still on its way\n\t\t}\n\n\t\tif (mStreamHandler.isSmEnabled()) {\n\t\t\tdebugLog(\"Ping: sending SM request\");\n\t\t\tmPingID = \"\" + mStreamHandler.requestAck();\n\t\t} else {\n\t\t\tPing ping = new Ping();\n\t\t\tping.setType(Type.GET);\n\t\t\tping.setTo(mConfig.server);\n\t\t\tmPingID = ping.getPacketID();\n\t\t\tdebugLog(\"Ping: sending ping \" + mPingID);\n\t\t\tmXMPPConnection.sendPacket(ping);\n\t\t}\n\n\t\t// register ping timeout handler: PACKET_TIMEOUT(30s) + 3s\n\t\tregisterPongTimeout(PACKET_TIMEOUT + 3000, mPingID);\n\t}\n\n\tprivate void gotServerPong(String pongID) {\n\t\tlong latency = System.currentTimeMillis() - mPingTimestamp;\n\t\tif (pongID != null && pongID.equals(mPingID))\n\t\t\tLog.i(TAG, String.format(\"Ping: server latency %1.3fs\",\n\t\t\t\t\t\tlatency/1000.));\n\t\telse\n\t\t\tLog.i(TAG, String.format(\"Ping: server latency %1.3fs (estimated)\",\n\t\t\t\t\t\tlatency/1000.));\n\t\tmPingID = null;\n\t\tmAlarmManager.cancel(mPongTimeoutAlarmPendIntent);\n\t}\n\n\t/** Register a \"pong\" timeout on the connection. */\n\tprivate void registerPongTimeout(long wait_time, String id) {\n\t\tmPingID = id;\n\t\tmPingTimestamp = System.currentTimeMillis();\n\t\tdebugLog(String.format(\"Ping: registering timeout for %s: %1.3fs\", id, wait_time/1000.));\n\t\tmAlarmManager.set(AlarmManager.RTC_WAKEUP,\n\t\t\t\tSystem.currentTimeMillis() + wait_time,\n\t\t\t\tmPongTimeoutAlarmPendIntent);\n\t}\n\n\t/**\n\t * BroadcastReceiver to trigger reconnect on pong timeout.\n\t */\n\tprivate class PongTimeoutAlarmReceiver extends BroadcastReceiver {\n\t\tpublic void onReceive(Context ctx, Intent i) {\n\t\t\tdebugLog(\"Ping: timeout for \" + mPingID);\n\t\t\tonDisconnected(mService.getString(R.string.conn_ping_timeout));\n\t\t}\n\t}\n\n\t/**\n\t * BroadcastReceiver to trigger sending pings to the server\n\t */\n\tprivate class PingAlarmReceiver extends BroadcastReceiver {\n\t\tpublic void onReceive(Context ctx, Intent i) {\n\t\t\t\tsendServerPing();\n\t\t\t\t// ping all MUCs. if no ping was received since last attempt, /cycle\n\t\t\t\tIterator<MultiUserChat> muc_it = multiUserChats.values().iterator();\n\t\t\t\tlong ts = System.currentTimeMillis();\n\t\t\t\tContentValues cvR = new ContentValues();\n\t\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, mService.getString(R.string.conn_ping_timeout));\n\t\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.offline.ordinal());\n\t\t\t\tcvR.put(RosterProvider.RosterConstants.GROUP, RosterProvider.RosterConstants.MUCS);\n\t\t\t\twhile (muc_it.hasNext()) {\n\t\t\t\t\tMultiUserChat muc = muc_it.next();\n\t\t\t\t\tif (!muc.isJoined())\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tLong lastPong = mucLastPong.get(muc.getRoom());\n\t\t\t\t\tif (mucLastPing > 0 && (lastPong == null || lastPong < mucLastPing)) {\n\t\t\t\t\t\tdebugLog(\"Ping timeout from \" + muc.getRoom());\n\t\t\t\t\t\tmuc.leave();\n\t\t\t\t\t\tupsertRoster(cvR, muc.getRoom());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPing ping = new Ping();\n\t\t\t\t\t\tping.setType(Type.GET);\n\t\t\t\t\t\tString jid = muc.getRoom() + \"/\" + muc.getNickname();\n\t\t\t\t\t\tping.setTo(jid);\n\t\t\t\t\t\tmPingID = ping.getPacketID();\n\t\t\t\t\t\tdebugLog(\"Ping: sending ping to \" + jid);\n\t\t\t\t\t\tmXMPPConnection.sendPacket(ping);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsyncDbRooms();\n\t\t\t\tmucLastPing = ts;\n\n\t\t}\n\t}\n\n\t/**\n\t * Registers a smack packet listener for IQ packets, intended to recognize \"pongs\" with\n\t * a packet id matching the last \"ping\" sent to the server.\n\t *\n\t * Also sets up the AlarmManager Timer plus necessary intents.\n\t */\n\tprivate void registerPongListener() {\n\t\t// reset ping expectation on new connection\n\t\tmPingID = null;\n\n\t\tif (mPongListener != null)\n\t\t\tmXMPPConnection.removePacketListener(mPongListener);\n\n\t\tmPongListener = new PacketListener() {\n\n\t\t\t@Override\n\t\t\tpublic void processPacket(Packet packet) {\n\t\t\t\tif (packet == null) return;\n\n\t\t\t\tif (packet instanceof IQ && packet.getFrom() != null) {\n\t\t\t\t\tIQ ping = (IQ)packet;\n\t\t\t\t\tString from_bare = getBareJID(ping.getFrom());\n\t\t\t\t\t// check for ping error or RESULT\n\t\t\t\t\tif (ping.getType() == Type.RESULT && mucJIDs.contains(from_bare)) {\n\t\t\t\t\t\tLog.d(TAG, \"Ping: got response from MUC \" + from_bare);\n\t\t\t\t\t\tmucLastPong.put(from_bare, System.currentTimeMillis());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mPingID != null && mPingID.equals(packet.getPacketID()))\n\t\t\t\t\tgotServerPong(packet.getPacketID());\n\n\t\t\t}\n\n\t\t};\n\n\t\tmXMPPConnection.addPacketListener(mPongListener, new PacketTypeFilter(IQ.class));\n\t\tmPingAlarmPendIntent = PendingIntent.getBroadcast(mService.getApplicationContext(), 0, mPingAlarmIntent,\n\t\t\t\t\tPendingIntent.FLAG_UPDATE_CURRENT);\n\t\tmPongTimeoutAlarmPendIntent = PendingIntent.getBroadcast(mService.getApplicationContext(), 0, mPongTimeoutAlarmIntent,\n\t\t\t\t\tPendingIntent.FLAG_UPDATE_CURRENT);\n\t\tmAlarmManager.setInexactRepeating(AlarmManager.RTC_WAKEUP, \n\t\t\t\tSystem.currentTimeMillis() + AlarmManager.INTERVAL_FIFTEEN_MINUTES, AlarmManager.INTERVAL_FIFTEEN_MINUTES, mPingAlarmPendIntent);\n\t}\n\tprivate void unregisterPongListener() {\n\t\tmAlarmManager.cancel(mPingAlarmPendIntent);\n\t\tmAlarmManager.cancel(mPongTimeoutAlarmPendIntent);\n\t}\n\n\tprivate void registerMessageListener() {\n\t\t// do not register multiple packet listeners\n\t\tif (mPacketListener != null)\n\t\t\tmXMPPConnection.removePacketListener(mPacketListener);\n\n\t\tPacketTypeFilter filter = new PacketTypeFilter(Message.class);\n\n\t\tmPacketListener = new PacketListener() {\n\t\t\tpublic void processPacket(Packet packet) {\n\t\t\t\ttry {\n\t\t\t\tif (packet instanceof Message) {\n\t\t\t\t\tMessage msg = (Message) packet;\n\n\t\t\t\t\tString[] fromJID = getJabberID(msg.getFrom());\n\t\t\t\t\t\n\t\t\t\t\tint direction = ChatConstants.INCOMING;\n\t\t\t\t\tCarbon cc = CarbonManager.getCarbon(msg);\n\n\t\t\t\t\t// extract timestamp\n\t\t\t\t\tlong ts;\n\t\t\t\t\tDelayInfo timestamp = (DelayInfo)msg.getExtension(\"delay\", \"urn:xmpp:delay\");\n\t\t\t\t\tif (timestamp == null)\n\t\t\t\t\t\ttimestamp = (DelayInfo)msg.getExtension(\"x\", \"jabber:x:delay\");\n\t\t\t\t\tif (cc != null) // Carbon timestamp overrides packet timestamp\n\t\t\t\t\t\ttimestamp = cc.getForwarded().getDelayInfo();\n\t\t\t\t\tif (timestamp != null)\n\t\t\t\t\t\tts = timestamp.getStamp().getTime();\n\t\t\t\t\telse\n\t\t\t\t\t\tts = System.currentTimeMillis();\n\n\t\t\t\t\t// try to extract a carbon\n\t\t\t\t\tif (cc != null) {\n\t\t\t\t\t\tLog.d(TAG, \"carbon: \" + cc.toXML());\n\t\t\t\t\t\tmsg = (Message)cc.getForwarded().getForwardedPacket();\n\n\t\t\t\t\t\t// outgoing carbon: fromJID is actually chat peer's JID\n\t\t\t\t\t\tif (cc.getDirection() == Carbon.Direction.sent) {\n\t\t\t\t\t\t\tfromJID = getJabberID(msg.getTo());\n\t\t\t\t\t\t\tdirection = ChatConstants.OUTGOING;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfromJID = getJabberID(msg.getFrom());\n\n\t\t\t\t\t\t\t// hook off carbonated delivery receipts\n\t\t\t\t\t\t\tDeliveryReceipt dr = (DeliveryReceipt)msg.getExtension(\n\t\t\t\t\t\t\t\t\tDeliveryReceipt.ELEMENT, DeliveryReceipt.NAMESPACE);\n\t\t\t\t\t\t\tif (dr != null) {\n\t\t\t\t\t\t\t\tLog.d(TAG, \"got CC'ed delivery receipt for \" + dr.getId());\n\t\t\t\t\t\t\t\tchangeMessageDeliveryStatus(dr.getId(), ChatConstants.DS_ACKED);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// ignore carbon copies of OTR messages sent by broken clients\n\t\t\t\t\t\tif (msg.getBody() != null && msg.getBody().startsWith(\"?OTR\")) {\n\t\t\t\t\t\t\tLog.i(TAG, \"Ignoring OTR carbon from \" + msg.getFrom() + \" to \" + msg.getTo());\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// check for jabber MUC invitation\n\t\t\t\t\tif(direction == ChatConstants.INCOMING && handleMucInvitation(msg)) {\n\t\t\t\t\t\tsendReceiptIfRequested(packet);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tString chatMessage = msg.getBody();\n\n\t\t\t\t\t// display error inline\n\t\t\t\t\tif (msg.getType() == Message.Type.error) {\n\t\t\t\t\t\tif (changeMessageDeliveryStatus(msg.getPacketID(), ChatConstants.DS_FAILED))\n\t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, msg.getError().toString(), (cc != null), Message.Type.error);\n\t\t\t\t\t\telse if (mucJIDs.contains(msg.getFrom())) {\n\t\t\t\t\t\t\thandleKickedFromMUC(msg.getFrom(), false, null,\n\t\t\t\t\t\t\t\t\tmsg.getError().toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn; // we do not want to add errors as \"incoming messages\"\n\t\t\t\t\t}\n\n\t\t\t\t\t// ignore empty messages\n\t\t\t\t\tif (chatMessage == null) {\n\t\t\t\t\t\tif (msg.getSubject() != null && msg.getType() == Message.Type.groupchat\n\t\t\t\t\t\t\t\t&& mucJIDs.contains(fromJID[0])) {\n\t\t\t\t\t\t\t// this is a MUC subject, update our DB\n\t\t\t\t\t\t\tContentValues cvR = new ContentValues();\n\t\t\t\t\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, msg.getSubject());\n\t\t\t\t\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.available.ordinal());\n\t\t\t\t\t\t\tLog.d(TAG, \"MUC subject for \" + fromJID[0] + \" set to: \" + msg.getSubject());\n\t\t\t\t\t\t\tupsertRoster(cvR, fromJID[0]);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLog.d(TAG, \"empty message.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// obtain Last Message Correction, if present\n\t\t\t\t\tReplace replace = (Replace)msg.getExtension(Replace.NAMESPACE);\n\t\t\t\t\tString replace_id = (replace != null) ? replace.getId() : null;\n\n\t\t\t\t\t// carbons are old. all others are new\n\t\t\t\t\tint is_new = (cc == null) ? ChatConstants.DS_NEW : ChatConstants.DS_SENT_OR_READ;\n\t\t\t\t\tif (msg.getType() == Message.Type.error)\n\t\t\t\t\t\tis_new = ChatConstants.DS_FAILED;\n\n\t\t\t\t\tboolean is_muc = (msg.getType() == Message.Type.groupchat);\n\t\t\t\t\tboolean is_from_me = (direction == ChatConstants.OUTGOING) ||\n\t\t\t\t\t\t(is_muc && fromJID[1].equals(getMyMucNick(fromJID[0])));\n\n\t\t\t\t\t// handle MUC-PMs: messages from a nick from a known MUC or with\n\t\t\t\t\t// an <x> element\n\t\t\t\t\tMUCUser muc_x = (MUCUser)msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n\t\t\t\t\tboolean is_muc_pm = !is_muc  && !TextUtils.isEmpty(fromJID[1]) &&\n\t\t\t\t\t\t\t(muc_x != null || mucJIDs.contains(fromJID[0]));\n\n\t\t\t\t\t// TODO: ignoring 'received' MUC-PM carbons, until XSF sorts out shit:\n\t\t\t\t\t// - if yaxim is in the MUC, it will receive a non-carbonated copy of\n\t\t\t\t\t//   incoming messages, but not of outgoing ones\n\t\t\t\t\t// - if yaxim isn't in the MUC, it can't respond anyway\n\t\t\t\t\tif (is_muc_pm && !is_from_me && cc != null)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tif (is_muc_pm) {\n\t\t\t\t\t\t// store MUC-PMs under the participant's full JID, not bare\n\t\t\t\t\t\t//is_from_me = fromJID[1].equals(getMyMucNick(fromJID[0]));\n\t\t\t\t\t\tfromJID[0] = fromJID[0] + \"/\" + fromJID[1];\n\t\t\t\t\t\tfromJID[1] = null;\n\t\t\t\t\t\tLog.d(TAG, \"MUC-PM: \" + fromJID[0] + \" d=\" + direction + \" fromme=\" + is_from_me);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Carbons and MUC history are 'silent' by default\n\t\t\t\t\tboolean is_silent = (cc != null) || (is_muc && timestamp != null);\n\n\t\t\t\t\tif (!is_muc || checkAddMucMessage(msg, msg.getPacketID(), fromJID, timestamp)) {\n\t\t\t\t\t\taddChatMessageToDB(direction, fromJID, chatMessage, is_new, ts, msg.getPacketID(), replace_id);\n\t\t\t\t\t\t// only notify on private messages or when MUC notification requested\n\t\t\t\t\t\tboolean need_notify = !is_muc || mConfig.needMucNotification(getMyMucNick(fromJID[0]), chatMessage);\n\t\t\t\t\t\t// outgoing carbon -> clear notification by signalling 'null' message\n\t\t\t\t\t\tif (is_from_me) {\n\t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, null, true, msg.getType());\n\t\t\t\t\t\t\t// TODO: MUC PMs\n\t\t\t\t\t\t\tChatHelper.markAsRead(mService, fromJID[0]);\n\t\t\t\t\t\t} else if (direction == ChatConstants.INCOMING && need_notify)\n\t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, chatMessage, is_silent, msg.getType());\n\t\t\t\t\t}\n\t\t\t\t\tsendReceiptIfRequested(packet);\n\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// SMACK silently discards exceptions dropped from processPacket :(\n\t\t\t\t\tLog.e(TAG, \"failed to process packet:\");\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tmXMPPConnection.addPacketListener(mPacketListener, filter);\n\t}\n\n\tprivate boolean checkAddMucMessage(Message msg, String packet_id, String[] fromJid, DelayInfo timestamp) {\n\t\tString muc = fromJid[0];\n\t\tString nick = fromJid[1];\n\n\t\t// HACK: remove last outgoing message instead of upserting\n\t\tif (nick.equals(getMyMucNick(muc)))\n\t\t\tmContentResolver.delete(ChatProvider.CONTENT_URI,\n\t\t\t\t\"jid = ? AND from_me = 1 AND (pid = ? OR message = ?) AND \" +\n\t\t\t\t\"_id >= (SELECT MIN(_id) FROM chats WHERE jid = ? ORDER BY _id DESC LIMIT 50)\",\n\t\t\t\tnew String[] { muc, packet_id, msg.getBody(), muc });\n\n\t\t// messages with no timestamp are always new\n\t\tif (timestamp == null)\n\t\t\treturn true;\n\n\t\tlong ts = timestamp.getStamp().getTime();\n\n\t\tfinal String[] projection = new String[] {\n\t\t\t\tChatConstants._ID, ChatConstants.MESSAGE,\n\t\t\t\tChatConstants.JID, ChatConstants.RESOURCE,\n\t\t\t\tChatConstants.PACKET_ID\n\t\t};\n\n\t\tif (packet_id == null) packet_id = \"\";\n\t\tfinal String selection = \"resource = ? AND (pid = ? OR date = ? OR message = ?) AND _id >= (SELECT MIN(_id) FROM chats WHERE jid = ? ORDER BY _id DESC LIMIT 50)\";\n\t\tfinal String[] selectionArgs = new String[] { nick, packet_id, \"\"+ts, msg.getBody(), muc };\n\t\ttry {\n\t\t\tCursor cursor = mContentResolver.query(ChatProvider.CONTENT_URI, projection, selection, selectionArgs, null);\n\t\t\tLog.d(TAG, \"message from \" + nick + \" matched \" + cursor.getCount() + \" items.\");\n\t\t\tboolean result = (cursor.getCount() == 0);\n\t\t\tcursor.close();\n\t\t\treturn result;\n\t\t} catch (Exception e) { e.printStackTrace(); } // just return true...\n\t\treturn true;\t\n\t}\n\n\tprivate void handleKickedFromMUC(String room, boolean banned, String actor, String reason) {\n\t\tmucLastPong.remove(room);\n\t\tContentValues cvR = new ContentValues();\n\t\tString message;\n\t\tif (actor != null && actor.length() > 0)\n\t\t\tmessage = mService.getString(banned ? R.string.muc_banned_by : R.string.muc_kicked_by,\n\t\t\t\t\tactor, reason);\n\t\telse\n\t\t\tmessage = mService.getString(banned ? R.string.muc_banned : R.string.muc_kicked,\n\t\t\t\t\treason);\n\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, message);\n\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.offline.ordinal());\n\t\tupsertRoster(cvR, room);\n\t}\n\n\t@Override\n\tpublic String getMyMucNick(String jid) {\n\t\tMultiUserChat muc = multiUserChats.get(jid);\n\t\tif (muc != null && muc.getNickname() != null)\n\t\t\treturn muc.getNickname();\n\t\tif (mucJIDs.contains(jid)) {\n\t\t\tChatRoomHelper.RoomInfo ri = ChatRoomHelper.getRoomInfo(mService, jid);\n\t\t\tif (ri != null)\n\t\t\t\treturn ri.nickname;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate void registerPresenceListener() {\n\t\t// do not register multiple packet listeners\n\t\tif (mPresenceListener != null)\n\t\t\tmXMPPConnection.removePacketListener(mPresenceListener);\n\n\t\tmPresenceListener = new PacketListener() {\n\t\t\tpublic void processPacket(Packet packet) {\n\t\t\t\ttry {\n\t\t\t\t\tPresence p = (Presence) packet;\n\t\t\t\t\tswitch (p.getType()) {\n\t\t\t\t\tcase subscribe:\n\t\t\t\t\t\thandleIncomingSubscribe(p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase subscribed:\n\t\t\t\t\tcase unsubscribe:\n\t\t\t\t\tcase unsubscribed:\n\t\t\t\t\t\tsubscriptionRequests.remove(p.getFrom());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// SMACK silently discards exceptions dropped from processPacket :(\n\t\t\t\t\tLog.e(TAG, \"failed to process presence:\");\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tmXMPPConnection.addPacketListener(mPresenceListener, new PacketTypeFilter(Presence.class));\n\t}\n\n\tprivate void addChatMessageToDB(int direction, String[] tJID,\n\t\t\tString message, int delivery_status, long ts, String packetID, String replaceID) {\n\t\tContentValues values = new ContentValues();\n\n\t\tvalues.put(ChatConstants.DIRECTION, direction);\n\t\tvalues.put(ChatConstants.JID, tJID[0]);\n\t\tvalues.put(ChatConstants.RESOURCE, tJID[1]);\n\t\tvalues.put(ChatConstants.MESSAGE, message);\n\t\tvalues.put(ChatConstants.DELIVERY_STATUS, delivery_status);\n\t\tvalues.put(ChatConstants.DATE, ts);\n\t\tvalues.put(ChatConstants.PACKET_ID, packetID);\n\n\t\tif (replaceID != null) {\n\t\t\t// obtain row id for last message with that full JID, or -1\n\t\t\tlong _id = getRowIdForMessage(tJID[0], tJID[1], direction, replaceID);\n\t\t\tLog.d(TAG, \"Replacing last message from \" + tJID[0] + \"/\" + tJID[1] + \": \" + replaceID + \" -> \" + packetID);\n\t\t\tUri row = Uri.withAppendedPath(ChatProvider.CONTENT_URI, \"\" + _id);\n\t\t\tif (_id >= 0 && mContentResolver.update(row, values, null, null) == 1)\n\t\t\t\treturn;\n\t\t}\n\t\tmContentResolver.insert(ChatProvider.CONTENT_URI, values);\n\t}\n\n\tprivate void addChatMessageToDB(int direction, String JID,\n\t\t\tString message, int delivery_status, long ts, String packetID) {\n\t\tString[] tJID = {JID, \"\"};\n\t\taddChatMessageToDB(direction, tJID, message, delivery_status, ts, packetID, null);\n\t}\n\n\tprivate ContentValues getContentValuesForRosterEntry(final RosterEntry entry) {\n\t\tPresence presence = mRoster.getPresence(entry.getUser());\n\t\treturn getContentValuesForRosterEntry(entry, presence);\n\t}\n\n\tprivate ContentValues getContentValuesForRosterEntry(final RosterEntry entry, Presence presence) {\n\t\tfinal ContentValues values = new ContentValues();\n\n\t\tvalues.put(RosterConstants.JID, entry.getUser());\n\t\tvalues.put(RosterConstants.ALIAS, getName(entry));\n\n\t\t// handle subscription requests and errors with higher priority\n\t\tPresence sub = subscriptionRequests.get(entry.getUser());\n\t\tif (presence.getType() == Presence.Type.error) {\n\t\t\tString error = presence.getError().getMessage();\n\t\t\tif (error == null || error.length() == 0)\n\t\t\t\terror = presence.getError().toString();\n\t\t\tvalues.put(RosterConstants.STATUS_MESSAGE, error);\n\t\t} else if (sub != null) {\n\t\t\tpresence = sub;\n\t\t\tvalues.put(RosterConstants.STATUS_MESSAGE, presence.getStatus());\n\t\t} else switch (entry.getType()) {\n\t\tcase to:\n\t\tcase both:\n\t\t\t// override received presence from roster, using highest-prio entry\n\t\t\tpresence = mRoster.getPresence(entry.getUser());\n\t\t\tvalues.put(RosterConstants.STATUS_MESSAGE, presence.getStatus());\n\t\t\tbreak;\n\t\tcase from:\n\t\t\tvalues.put(RosterConstants.STATUS_MESSAGE, mService.getString(R.string.subscription_status_from));\n\t\t\tpresence = null;\n\t\t\tbreak;\n\t\tcase none:\n\t\t\tvalues.put(RosterConstants.STATUS_MESSAGE, \"\");\n\t\t\tpresence = null;\n\t\t}\n\t\tvalues.put(RosterConstants.STATUS_MODE, getStatusInt(presence));\n\t\tvalues.put(RosterConstants.GROUP, getGroup(entry.getGroups()));\n\n\t\treturn values;\n\t}\n\n\tprivate void deleteRosterEntryFromDB(final String jabberID) {\n\t\tint count = mContentResolver.delete(RosterProvider.CONTENT_URI,\n\t\t\t\tRosterConstants.JID + \" = ?\", new String[] { jabberID });\n\t\tdebugLog(\"deleteRosterEntryFromDB: Deleted \" + count + \" entries\");\n\t}\n\n\tprivate void updateRosterEntryInDB(final RosterEntry entry) {\n\t\tupsertRoster(getContentValuesForRosterEntry(entry), entry.getUser());\n\t}\n\n\tprivate void upsertRoster(final ContentValues values, String jid) {\n\t\tif (mContentResolver.update(RosterProvider.CONTENT_URI, values,\n\t\t\t\tRosterConstants.JID + \" = ?\", new String[] { jid }) == 0) {\n\t\t\tmContentResolver.insert(RosterProvider.CONTENT_URI, values);\n\t\t}\n\t}\n\n\tprivate String getGroup(Collection<RosterGroup> groups) {\n\t\tfor (RosterGroup group : groups) {\n\t\t\treturn group.getName();\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tprivate String getName(RosterEntry rosterEntry) {\n\t\tString name = rosterEntry.getName();\n\t\tif (name != null && name.length() > 0) {\n\t\t\treturn name;\n\t\t}\n\t\treturn rosterEntry.getUser();\n\t}\n\n\tprivate StatusMode getStatus(Presence presence) {\n\t\tif (presence == null)\n\t\t\treturn StatusMode.unknown;\n\t\tif (presence.getType() == Presence.Type.subscribe)\n\t\t\treturn StatusMode.subscribe;\n\t\tif (presence.getType() == Presence.Type.available) {\n\t\t\tif (presence.getMode() != null) {\n\t\t\t\treturn StatusMode.valueOf(presence.getMode().name());\n\t\t\t}\n\t\t\treturn StatusMode.available;\n\t\t}\n\t\treturn StatusMode.offline;\n\t}\n\n\tprivate int getStatusInt(final Presence presence) {\n\t\treturn getStatus(presence).ordinal();\n\t}\n\n\tprivate void debugLog(String data) {\n\t\tif (LogConstants.LOG_DEBUG) {\n\t\t\tLog.d(TAG, data);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getLastError() {\n\t\treturn mLastError;\n\t}\n\n\tprivate synchronized void cleanupMUCs(boolean set_offline) {\n\t\t// get a fresh MUC list\n\t\tCursor cursor = mContentResolver.query(RosterProvider.MUCS_URI,\n\t\t\t\tnew String[] { RosterProvider.RosterConstants.JID },\n\t\t\t\tnull, null, null);\n\t\tmucJIDs.clear();\n\t\twhile(cursor.moveToNext()) {\n\t\t\tmucJIDs.add(cursor.getString(0));\n\t\t}\n\t\tcursor.close();\n\n\t\t// delete removed MUCs\n\t\tStringBuilder exclusion = new StringBuilder(RosterProvider.RosterConstants.GROUP + \" = ? AND \"\n\t\t\t\t+ RosterConstants.JID + \" NOT IN ('\");\n\t\texclusion.append(TextUtils.join(\"', '\", mucJIDs));\n\t\texclusion.append(\"');\");\n\t\tmContentResolver.delete(RosterProvider.CONTENT_URI,\n\t\t\t\texclusion.toString(),\n\t\t\t\tnew String[] { RosterProvider.RosterConstants.MUCS });\n\t\tif (set_offline) {\n\t\t\t// update all other MUCs as offline\n\t\t\tContentValues values = new ContentValues();\n\t\t\tvalues.put(RosterConstants.STATUS_MODE, StatusMode.offline.ordinal());\n\t\t\tmContentResolver.update(RosterProvider.CONTENT_URI, values, RosterProvider.RosterConstants.GROUP + \" = ?\",\n\t\t\t\t\tnew String[] { RosterProvider.RosterConstants.MUCS });\n\t\t}\n\t}\n\n\tpublic synchronized void syncDbRooms() {\n\t\tif (!isAuthenticated()) {\n\t\t\tdebugLog(\"syncDbRooms: aborting, not yet authenticated\");\n\t\t}\n\n\t\tjava.util.Set<String> joinedRooms = multiUserChats.keySet();\n\t\tCursor cursor = mContentResolver.query(RosterProvider.MUCS_URI, \n\t\t\t\tnew String[] {RosterProvider.RosterConstants._ID,\n\t\t\t\t\tRosterProvider.RosterConstants.JID, \n\t\t\t\t\tRosterProvider.RosterConstants.PASSWORD, \n\t\t\t\t\tRosterProvider.RosterConstants.NICKNAME}, \n\t\t\t\tnull, null, null);\n\t\tfinal int ID = cursor.getColumnIndexOrThrow(RosterProvider.RosterConstants._ID);\n\t\tfinal int JID_ID = cursor.getColumnIndexOrThrow(RosterProvider.RosterConstants.JID);\n\t\tfinal int PASSWORD_ID = cursor.getColumnIndexOrThrow(RosterProvider.RosterConstants.PASSWORD);\n\t\tfinal int NICKNAME_ID = cursor.getColumnIndexOrThrow(RosterProvider.RosterConstants.NICKNAME);\n\t\t\n\t\tmucJIDs.clear();\n\t\twhile(cursor.moveToNext()) {\n\t\t\tint id = cursor.getInt(ID);\n\t\t\tString jid = cursor.getString(JID_ID);\n\t\t\tString password = cursor.getString(PASSWORD_ID);\n\t\t\tString nickname = cursor.getString(NICKNAME_ID);\n\t\t\tmucJIDs.add(jid);\n\t\t\t//debugLog(\"Found MUC Room: \"+jid+\" with nick \"+nickname+\" and pw \"+password);\n\t\t\tif(!joinedRooms.contains(jid) || !multiUserChats.get(jid).isJoined()) {\n\t\t\t\tdebugLog(\"room \" + jid + \" isn't joined yet, i wanna join...\");\n\t\t\t\tjoinRoomAsync(jid, nickname, password); // TODO: make historyLen configurable\n\t\t\t} else {\n\t\t\t\tMultiUserChat muc = multiUserChats.get(jid);\n\t\t\t\tif (!muc.getNickname().equals(nickname)) {\n\t\t\t\t\tdebugLog(\"room \" + jid + \": changing nickname to \" + nickname);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmuc.changeNickname(nickname);\n\t\t\t\t\t} catch (XMPPException e) {\n\t\t\t\t\t\tLog.e(TAG, \"Changing nickname failed.\");\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//debugLog(\"found data in contentprovider: \"+jid+\" \"+password+\" \"+nickname);\n\t\t}\n\t\tcursor.close();\n\t\t\n\t\tfor(String room : new HashSet<String>(joinedRooms)) {\n\t\t\tif(!mucJIDs.contains(room)) {\n\t\t\t\tquitRoom(room);\n\t\t\t}\n\t\t}\n\t\tcleanupMUCs(false);\n\t}\n\t\n\tprotected boolean handleMucInvitation(Message msg) {\n\t\tString room;\n\t\tString inviter = null;\n\t\tString reason = null;\n\t\tString password = null;\n\t\t\n\t\tMUCUser mucuser = (MUCUser)msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n\t\tGroupChatInvitation direct = (GroupChatInvitation)msg.getExtension(GroupChatInvitation.ELEMENT_NAME, GroupChatInvitation.NAMESPACE);\n\t\tif (mucuser != null && mucuser.getInvite() != null) {\n\t\t\t// first try official XEP-0045 mediated invitation\n\t\t\tMUCUser.Invite invite = mucuser.getInvite();\n\t\t\troom = msg.getFrom();\n\t\t\tinviter = invite.getFrom();\n\t\t\treason = invite.getReason();\n\t\t\tpassword = mucuser.getPassword();\n\t\t} else if (direct != null) {\n\t\t\t// fall back to XEP-0249 direct invitation\n\t\t\troom = direct.getRoomAddress();\n\t\t\tinviter = msg.getFrom();\n\t\t\t// TODO: get reason from direct invitation, not supported in smack3\n\t\t} else return false; // not a MUC invitation\n\n\t\tif (mucJIDs.contains(room)) {\n\t\t\tLog.i(TAG, \"Ignoring invitation to known MUC \" + room);\n\t\t\treturn true;\n\t\t}\n\t\tLog.d(TAG, \"MUC invitation from \" + inviter + \" to \" + room);\n\t\tasyncProcessMucInvitation(room, inviter, reason, password);\n\t\treturn true;\n\t}\n\n\tprotected void asyncProcessMucInvitation(final String room, final String inviter,\n\t\t\tfinal String reason, final String password) {\n\t\tnew Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tprocessMucInvitation(room, inviter, reason, password);\n\t\t\t}\n\t\t}.start();\n\t}\n\tprotected void processMucInvitation(final String room, final String inviter,\n\t\t\tfinal String reason, final String password) {\n\t\tString roomname = room;\n\t\tString inviter_name = null;\n\t\tif (getBareJID(inviter).equalsIgnoreCase(room)) {\n\t\t\t// from == participant JID, display as \"user (MUC)\"\n\t\t\tinviter_name = getNameForJID(inviter);\n\t\t} else {\n\t\t\t// from == user bare or full JID\n\t\t\tinviter_name = getNameForJID(getBareJID(inviter));\n\t\t}\n\t\tString description = null;\n\t\tString inv_from = mService.getString(R.string.muc_invitation_from,\n\t\t\t\tinviter_name);\n\n\t\t// query room for info\n\t\ttry {\n\t\t\tLog.d(TAG, \"Requesting disco#info from \" + room);\n\t\t\tRoomInfo ri = MultiUserChat.getRoomInfo(mXMPPConnection, room);\n\t\t\tString rn = ri.getRoomName();\n\t\t\tif (rn != null && rn.length() > 0)\n\t\t\t\troomname = String.format(\"%s (%s)\", rn, roomname);\n\t\t\tdescription = ri.getSubject();\n\t\t\tif (!TextUtils.isEmpty(description))\n\t\t\t\tdescription = ri.getDescription();\n\t\t\tdescription = mService.getString(R.string.muc_invitation_occupants,\n\t\t\t\t\tdescription, ri.getOccupantsCount());\n\t\t\tLog.d(TAG, \"MUC name after disco: \" + roomname);\n\t\t} catch (XMPPException e) {\n\t\t\t// ignore a failed room info request\n\t\t\tLog.d(TAG, \"MUC room IQ failed: \" + room);\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tmServiceCallBack.mucInvitationReceived(\n\t\t\t\troomname,\n\t\t\t\troom,\n\t\t\t\tpassword,\n\t\t\t\tinv_from,\n\t\t\t\tdescription);\n\t}\n\t\n\tprivate Map<String,Runnable> ongoingMucJoins = new java.util.concurrent.ConcurrentHashMap<String, Runnable>();\n\tprivate synchronized void joinRoomAsync(final String room, final String nickname, final String password) {\n\t\tif (ongoingMucJoins.containsKey(room))\n\t\t\treturn;\n\t\tThread joiner = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tLog.d(TAG, \"async joining \" + room);\n\t\t\t\tboolean result = joinRoom(room, nickname, password);\n\t\t\t\tLog.d(TAG, \"async joining \" + room + \" done: \" + result);\n\t\t\t\tongoingMucJoins.remove(room);\n\t\t\t}\n\t\t};\n\t\tongoingMucJoins.put(room, joiner);\n\t\tjoiner.start();\n\t}\n\n\tprivate boolean joinRoom(final String room, String nickname, String password) {\n\t\t// work around smack3 bug: can't rejoin with \"used\" MultiUserChat instance\n\t\tMultiUserChat muc = new MultiUserChat(mXMPPConnection, room);\n\t\tLog.d(TAG, \"created new MUC instance: \" + room + \" \" + muc);\n\t\tmuc.addUserStatusListener(new org.jivesoftware.smackx.muc.DefaultUserStatusListener() {\n\t\t\t@Override\n\t\t\tpublic void kicked(String actor, String reason) {\n\t\t\t\tdebugLog(\"Kicked from \" + room + \" by \" + actor + \": \" + reason);\n\t\t\t\thandleKickedFromMUC(room, false, actor, reason);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void banned(String actor, String reason) {\n\t\t\t\tdebugLog(\"Banned from \" + room + \" by \" + actor + \": \" + reason);\n\t\t\t\thandleKickedFromMUC(room, true, actor, reason);\n\t\t\t}\n\t\t});\n\t\t\n\t\tDiscussionHistory history = new DiscussionHistory();\n\t\tfinal String[] projection = new String[] {\n\t\t\t\tChatConstants._ID, ChatConstants.DATE\n\t\t};\n\t\tCursor cursor = mContentResolver.query(ChatProvider.CONTENT_URI, projection, \n\t\t\t\tChatConstants.JID + \" = ? AND \" +\n\t\t\t\tChatConstants.DELIVERY_STATUS + \" = \" +\n\t\t\t\tChatConstants.DS_SENT_OR_READ, new String[] { room }, \"_id DESC LIMIT 1\");\n\t\tif(cursor.getCount()>0) {\n\t\t\tcursor.moveToFirst();\n\t\t\tDate lastDate = new Date(cursor.getLong(1));\n\t\t\tLog.d(TAG, \"Getting room history for \" + room + \" starting at \" + lastDate);\n\t\t\thistory.setSince(lastDate);\n\t\t} else Log.d(TAG, \"No last message for \" + room);\n\t\tcursor.close();\n\t\t\n\t\tContentValues cvR = new ContentValues();\n\t\tcvR.put(RosterProvider.RosterConstants.JID, room);\n\t\tcvR.put(RosterProvider.RosterConstants.ALIAS, room);\n\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, mService.getString(R.string.muc_synchronizing));\n\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.dnd.ordinal());\n\t\tcvR.put(RosterProvider.RosterConstants.GROUP, RosterProvider.RosterConstants.MUCS);\n\t\tupsertRoster(cvR, room);\n\t\tcvR.clear();\n\t\ttry {\n\t\t\tPresence force_resync = new Presence(Presence.Type.unavailable);\n\t\t\tforce_resync.setTo(room + \"/\" + nickname);\n\t\t\tmXMPPConnection.sendPacket(force_resync);\n\t\t\tmuc.join(nickname, password, history, 10*PACKET_TIMEOUT);\n\t\t} catch (Exception e) {\n\t\t\tLog.e(TAG, \"Could not join MUC-room \"+room);\n\t\t\te.printStackTrace();\n\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, mService.getString(R.string.conn_error, e.getLocalizedMessage()));\n\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.offline.ordinal());\n\t\t\tupsertRoster(cvR, room);\n\t\t\treturn false;\n\t\t}\n\n\t\tif(muc.isJoined()) {\n\t\t\tsynchronized(this) {\n\t\t\t\tmultiUserChats.put(room, muc);\n\t\t\t}\n\t\t\tString roomname = room.split(\"@\")[0];\n\t\t\ttry {\n\t\t\t\tRoomInfo ri = MultiUserChat.getRoomInfo(mXMPPConnection, room);\n\t\t\t\tString rn = ri.getRoomName();\n\t\t\t\tif (rn != null && rn.length() > 0)\n\t\t\t\t\troomname = rn;\n\t\t\t\tLog.d(TAG, \"MUC name after disco: \" + roomname);\n\t\t\t} catch (XMPPException e) {\n\t\t\t\t// ignore a failed room info request\n\t\t\t\tLog.d(TAG, \"MUC room IQ failed: \" + room);\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t// delay requesting subject until room info IQ returned/failed\n\t\t\tString subject = muc.getSubject();\n\t\t\tcvR.put(RosterProvider.RosterConstants.ALIAS, roomname);\n\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, subject);\n\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.available.ordinal());\n\t\t\tLog.d(TAG, \"upserting MUC as online: \" + roomname);\n\t\t\tupsertRoster(cvR, room);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void sendMucMessage(String room, String message) {\n\t\tMessage newMessage = new Message(room, Message.Type.groupchat);\n\t\tnewMessage.setBody(message);\n\t\taddChatMessageToDB(ChatConstants.OUTGOING, room, message, ChatConstants.DS_NEW,\n\t\t\t\tSystem.currentTimeMillis(), newMessage.getPacketID());\n\t\tmXMPPConnection.sendPacket(newMessage);\n\t}\n\n\tprivate void quitRoom(String room) {\n\t\tLog.d(TAG, \"Leaving MUC \" + room);\n\t\tMultiUserChat muc = multiUserChats.get(room); \n\t\tmuc.leave();\n\t\tmultiUserChats.remove(room);\n\t\tmucLastPong.remove(room);\n\t\tmContentResolver.delete(RosterProvider.CONTENT_URI, \"jid = ?\", new String[] {room});\n\t}\n\n\t@Override\n\tpublic boolean inviteToRoom(String contactJid, String roomJid) {\n\t\tMultiUserChat muc = multiUserChats.get(roomJid);\n\t\tif(contactJid.contains(\"/\")) {\n\t\t\tcontactJid = contactJid.split(\"/\")[0];\n\t\t}\n\t\tLog.d(TAG, \"invitng contact: \"+contactJid+\" to room: \"+muc);\n\t\tmuc.invite(contactJid, \"User \"+contactJid+\" has invited you to a chat!\");\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic List<ParcelablePresence> getUserList(String jid) {\n\t\tMultiUserChat muc = multiUserChats.get(jid);\n\t\tif (muc == null) {\n\t\t\treturn null;\n\t\t}\n\t\tLog.d(TAG, \"MUC instance: \" + jid + \" \" + muc);\n\t\tIterator<String> occIter = muc.getOccupants();\n\t\tArrayList<ParcelablePresence> tmpList = new ArrayList<ParcelablePresence>();\n\t\twhile(occIter.hasNext())\n\t\t\ttmpList.add(new ParcelablePresence(muc.getOccupantPresence(occIter.next())));\n\t\tCollections.sort(tmpList, new Comparator<ParcelablePresence>() {\n\t\t\t@Override\n\t\t\tpublic int compare(ParcelablePresence lhs, ParcelablePresence rhs) {\n\t\t\t\treturn java.text.Collator.getInstance().compare(lhs.resource, rhs.resource);\n\t\t\t}\n\t\t});\n\t\tLog.d(TAG, \"getUserList(\" + jid + \"): \" + tmpList.size());\n\t\treturn tmpList;\n\t}\n}\n"], "fixing_code": ["package org.yaxim.androidclient.service;\n\nimport java.io.File;\nimport java.text.Collator;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.X509TrustManager;\n\nimport de.duenndns.ssl.MemorizingTrustManager;\n\nimport org.jivesoftware.smack.AccountManager;\nimport org.jivesoftware.smack.Connection;\nimport org.jivesoftware.smack.ConnectionConfiguration;\nimport org.jivesoftware.smack.ConnectionListener;\nimport org.jivesoftware.smack.PacketListener;\nimport org.jivesoftware.smack.Roster;\nimport org.jivesoftware.smack.RosterEntry;\nimport org.jivesoftware.smack.RosterGroup;\nimport org.jivesoftware.smack.RosterListener;\nimport org.jivesoftware.smack.SmackConfiguration;\nimport org.jivesoftware.smack.XMPPConnection;\nimport org.jivesoftware.smack.XMPPException;\nimport org.jivesoftware.smack.filter.PacketFilter;\nimport org.jivesoftware.smack.filter.PacketTypeFilter;\nimport org.jivesoftware.smack.packet.IQ;\nimport org.jivesoftware.smack.packet.IQ.Type;\nimport org.jivesoftware.smack.packet.Message;\nimport org.jivesoftware.smack.packet.Packet;\nimport org.jivesoftware.smack.packet.Presence;\nimport org.jivesoftware.smack.packet.Presence.Mode;\nimport org.jivesoftware.smack.packet.RosterPacket;\nimport org.jivesoftware.smack.provider.ProviderManager;\nimport org.jivesoftware.smack.util.DNSUtil;\nimport org.jivesoftware.smack.util.StringUtils;\nimport org.jivesoftware.smack.util.dns.DNSJavaResolver;\nimport org.jivesoftware.smackx.entitycaps.EntityCapsManager;\nimport org.jivesoftware.smackx.entitycaps.cache.SimpleDirectoryPersistentCache;\nimport org.jivesoftware.smackx.Form;\nimport org.jivesoftware.smackx.FormField;\nimport org.jivesoftware.smackx.GroupChatInvitation;\nimport org.jivesoftware.smackx.ServiceDiscoveryManager;\nimport org.jivesoftware.smackx.muc.DiscussionHistory;\nimport org.jivesoftware.smackx.muc.InvitationListener;\nimport org.jivesoftware.smackx.muc.MultiUserChat;\nimport org.jivesoftware.smackx.muc.Occupant;\nimport org.jivesoftware.smackx.muc.RoomInfo;\nimport org.jivesoftware.smackx.carbons.Carbon;\nimport org.jivesoftware.smackx.carbons.CarbonManager;\nimport org.jivesoftware.smackx.entitycaps.provider.CapsExtensionProvider;\nimport org.jivesoftware.smackx.forward.Forwarded;\nimport org.jivesoftware.smackx.muc.MultiUserChat;\nimport org.jivesoftware.smackx.provider.DataFormProvider;\nimport org.jivesoftware.smackx.provider.DelayInfoProvider;\nimport org.jivesoftware.smackx.provider.DiscoverInfoProvider;\nimport org.jivesoftware.smackx.provider.DiscoverItemsProvider;\nimport org.jivesoftware.smackx.provider.MUCAdminProvider;\nimport org.jivesoftware.smackx.provider.MUCOwnerProvider;\nimport org.jivesoftware.smackx.provider.MUCUserProvider;\nimport org.jivesoftware.smackx.packet.DelayInformation;\nimport org.jivesoftware.smackx.packet.DelayInfo;\nimport org.jivesoftware.smackx.packet.DiscoverInfo;\nimport org.jivesoftware.smackx.packet.MUCUser;\nimport org.jivesoftware.smackx.packet.Version;\nimport org.jivesoftware.smackx.ping.PingManager;\nimport org.jivesoftware.smackx.ping.packet.*;\nimport org.jivesoftware.smackx.ping.provider.PingProvider;\nimport org.jivesoftware.smackx.receipts.DeliveryReceipt;\nimport org.jivesoftware.smackx.receipts.DeliveryReceiptManager;\nimport org.jivesoftware.smackx.receipts.DeliveryReceiptRequest;\nimport org.jivesoftware.smackx.receipts.ReceiptReceivedListener;\nimport org.yaxim.androidclient.YaximApplication;\nimport org.yaxim.androidclient.data.ChatHelper;\nimport org.yaxim.androidclient.data.ChatProvider;\nimport org.yaxim.androidclient.data.ChatRoomHelper;\nimport org.yaxim.androidclient.data.RosterProvider;\nimport org.yaxim.androidclient.data.YaximConfiguration;\nimport org.yaxim.androidclient.data.ChatProvider.ChatConstants;\nimport org.yaxim.androidclient.data.RosterProvider.RosterConstants;\nimport org.yaxim.androidclient.exceptions.YaximXMPPException;\nimport org.yaxim.androidclient.packet.PreAuth;\nimport org.yaxim.androidclient.packet.Replace;\nimport org.yaxim.androidclient.util.ConnectionState;\nimport org.yaxim.androidclient.util.LogConstants;\nimport org.yaxim.androidclient.util.PreferenceConstants;\nimport org.yaxim.androidclient.util.StatusMode;\nimport org.yaxim.androidclient.R;\n\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.app.Service;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.database.Cursor;\n\nimport android.net.Uri;\nimport android.telephony.gsm.SmsMessage.MessageClass;\nimport android.text.TextUtils;\nimport android.util.Log;\n\npublic class SmackableImp implements Smackable {\n\tfinal static private String TAG = \"yaxim.SmackableImp\";\n\n\tfinal static private int PACKET_TIMEOUT = 30000;\n\n\tfinal static private String[] SEND_OFFLINE_PROJECTION = new String[] {\n\t\t\tChatConstants._ID, ChatConstants.JID,\n\t\t\tChatConstants.MESSAGE, ChatConstants.DATE, ChatConstants.PACKET_ID };\n\tfinal static private String SEND_OFFLINE_SELECTION =\n\t\t\tChatConstants.DIRECTION + \" = \" + ChatConstants.OUTGOING + \" AND \" +\n\t\t\tChatConstants.DELIVERY_STATUS + \" = \" + ChatConstants.DS_NEW;\n\n\tstatic final DiscoverInfo.Identity YAXIM_IDENTITY = new DiscoverInfo.Identity(\"client\",\n\t\t\t\t\tYaximApplication.XMPP_IDENTITY_NAME,\n\t\t\t\t\tYaximApplication.XMPP_IDENTITY_TYPE);\n\n\tstatic File capsCacheDir = null; ///< this is used to cache if we already initialized EntityCapsCache\n\n\tstatic {\n\t\tregisterSmackProviders();\n\t\tDNSUtil.setDNSResolver(DNSJavaResolver.getInstance());\n\n\t\t// initialize smack defaults before any connections are created\n\t\tSmackConfiguration.setPacketReplyTimeout(PACKET_TIMEOUT);\n\t\tSmackConfiguration.setDefaultPingInterval(0);\n\t}\n\n\tstatic void registerSmackProviders() {\n\t\tProviderManager pm = ProviderManager.getInstance();\n\t\t// add IQ handling\n\t\tpm.addIQProvider(\"query\",\"http://jabber.org/protocol/disco#info\", new DiscoverInfoProvider());\n\t\tpm.addIQProvider(\"query\",\"http://jabber.org/protocol/disco#items\", new DiscoverItemsProvider());\n\t\t// add delayed delivery notifications\n\t\tpm.addExtensionProvider(\"delay\",\"urn:xmpp:delay\", new DelayInfoProvider());\n\t\tpm.addExtensionProvider(\"x\",\"jabber:x:delay\", new DelayInfoProvider());\n\t\t// add XEP-0092 Software Version\n\t\tpm.addIQProvider(\"query\", Version.NAMESPACE, new Version.Provider());\n\n\t\t// data forms\n\t\tpm.addExtensionProvider(\"x\",\"jabber:x:data\", new DataFormProvider());\n\n\t\t// add carbons and forwarding\n\t\tpm.addExtensionProvider(\"forwarded\", Forwarded.NAMESPACE, new Forwarded.Provider());\n\t\tpm.addExtensionProvider(\"sent\", Carbon.NAMESPACE, new Carbon.Provider());\n\t\tpm.addExtensionProvider(\"received\", Carbon.NAMESPACE, new Carbon.Provider());\n\t\t// add delivery receipts\n\t\tpm.addExtensionProvider(DeliveryReceipt.ELEMENT, DeliveryReceipt.NAMESPACE, new DeliveryReceipt.Provider());\n\t\tpm.addExtensionProvider(DeliveryReceiptRequest.ELEMENT, DeliveryReceipt.NAMESPACE, new DeliveryReceiptRequest.Provider());\n\t\t// add XMPP Ping (XEP-0199)\n\t\tpm.addIQProvider(\"ping\",\"urn:xmpp:ping\", new PingProvider());\n\n\t\tServiceDiscoveryManager.setDefaultIdentity(YAXIM_IDENTITY);\n\t\t\n\t\t// XEP-0115 Entity Capabilities\n\t\tpm.addExtensionProvider(\"c\", \"http://jabber.org/protocol/caps\", new CapsExtensionProvider());\n\n\t\t// XEP-0308 Last Message Correction\n\t\tpm.addExtensionProvider(\"replace\", Replace.NAMESPACE, new Replace.Provider());\n\n\t\t// XEP-XXXX Pre-Authenticated Roster Subscription\n\t\tpm.addExtensionProvider(\"preauth\", PreAuth.NAMESPACE, new PreAuth.Provider());\n\n\t\t//  MUC User\n\t\tpm.addExtensionProvider(\"x\",\"http://jabber.org/protocol/muc#user\", new MUCUserProvider());\n\t\t// MUC direct invitation\n\t\tpm.addExtensionProvider(\"x\",\"jabber:x:conference\", new GroupChatInvitation.Provider());\n\t\t//  MUC Admin\n\t\tpm.addIQProvider(\"query\",\"http://jabber.org/protocol/muc#admin\", new MUCAdminProvider());\n\t\t//  MUC Owner\n\t\tpm.addIQProvider(\"query\",\"http://jabber.org/protocol/muc#owner\", new MUCOwnerProvider());\n\n\t\tXmppStreamHandler.addExtensionProviders();\n\t}\n\n\tprivate final YaximConfiguration mConfig;\n\tprivate ConnectionConfiguration mXMPPConfig;\n\tprivate XmppStreamHandler.ExtXMPPConnection mXMPPConnection;\n\tprivate XmppStreamHandler mStreamHandler;\n\tprivate Thread mConnectingThread;\n\tprivate Object mConnectingThreadMutex = new Object();\n\n\n\tprivate ConnectionState mRequestedState = ConnectionState.OFFLINE;\n\tprivate ConnectionState mState = ConnectionState.OFFLINE;\n\tprivate String mLastError;\n\tprivate long mLastOnline = 0;\t//< timestamp of last successful full login (XEP-0198 does not count)\n\tprivate long mLastOffline = 0;\t//< timestamp of the end of last successful login\n\n\tprivate XMPPServiceCallback mServiceCallBack;\n\tprivate Roster mRoster;\n\tprivate RosterListener mRosterListener;\n\tprivate PacketListener mPacketListener;\n\tprivate PacketListener mPresenceListener;\n\tprivate ConnectionListener mConnectionListener;\n\n\tprivate final ContentResolver mContentResolver;\n\n\tprivate AlarmManager mAlarmManager;\n\tprivate PacketListener mPongListener;\n\tprivate String mPingID;\n\tprivate long mPingTimestamp;\n\n\tprivate PendingIntent mPingAlarmPendIntent;\n\tprivate PendingIntent mPongTimeoutAlarmPendIntent;\n\tprivate static final String PING_ALARM = \"org.yaxim.androidclient.PING_ALARM\";\n\tprivate static final String PONG_TIMEOUT_ALARM = \"org.yaxim.androidclient.PONG_TIMEOUT_ALARM\";\n\tprivate Intent mPingAlarmIntent = new Intent(PING_ALARM);\n\tprivate Intent mPongTimeoutAlarmIntent = new Intent(PONG_TIMEOUT_ALARM);\n\tprivate Service mService;\n\n\tprivate PongTimeoutAlarmReceiver mPongTimeoutAlarmReceiver = new PongTimeoutAlarmReceiver();\n\tprivate BroadcastReceiver mPingAlarmReceiver = new PingAlarmReceiver();\n\t\n\tprivate final HashSet<String> mucJIDs = new HashSet<String>();\t//< all configured MUCs, joined or not\n\tprivate Map<String, MultiUserChat> multiUserChats;\n\tprivate long mucLastPing = 0;\n\tprivate Map<String, Long> mucLastPong = new HashMap<String, Long>();\t//< per-MUC timestamp of last incoming ping result\n\tprivate Map<String, Presence> subscriptionRequests = new HashMap<String, Presence>();\n\n\n\tpublic SmackableImp(YaximConfiguration config,\n\t\t\tContentResolver contentResolver,\n\t\t\tService service) {\n\t\tthis.mConfig = config;\n\t\tthis.mContentResolver = contentResolver;\n\t\tthis.mService = service;\n\t\tthis.mAlarmManager = (AlarmManager)mService.getSystemService(Context.ALARM_SERVICE);\n\n\t\tmLastOnline = mLastOffline = System.currentTimeMillis();\n\t}\n\t\t\n\t// this code runs a DNS resolver, might be blocking\n\tprivate synchronized void initXMPPConnection() {\n\t\t// allow custom server / custom port to override SRV record\n\t\tif (mConfig.customServer.length() > 0)\n\t\t\tmXMPPConfig = new ConnectionConfiguration(mConfig.customServer,\n\t\t\t\t\tmConfig.port, mConfig.server);\n\t\telse\n\t\t\tmXMPPConfig = new ConnectionConfiguration(mConfig.server); // use SRV\n\t\tmXMPPConfig.setReconnectionAllowed(false);\n\t\tmXMPPConfig.setSendPresence(false);\n\t\tmXMPPConfig.setCompressionEnabled(false); // disable for now\n\t\tmXMPPConfig.setDebuggerEnabled(mConfig.smackdebug);\n\t\tif (mConfig.require_ssl)\n\t\t\tthis.mXMPPConfig.setSecurityMode(ConnectionConfiguration.SecurityMode.required);\n\n\t\t// register MemorizingTrustManager for HTTPS\n\t\ttry {\n\t\t\tSSLContext sc = SSLContext.getInstance(\"TLS\");\n\t\t\tMemorizingTrustManager mtm = YaximApplication.getApp(mService).mMTM;\n\t\t\tsc.init(null, new X509TrustManager[] { mtm },\n\t\t\t\t\tnew java.security.SecureRandom());\n\t\t\tthis.mXMPPConfig.setCustomSSLContext(sc);\n\t\t\tthis.mXMPPConfig.setHostnameVerifier(mtm.wrapHostnameVerifier(\n\t\t\t\t\t\tnew org.apache.http.conn.ssl.StrictHostnameVerifier()));\n\t\t} catch (java.security.GeneralSecurityException e) {\n\t\t\tdebugLog(\"initialize MemorizingTrustManager: \" + e);\n\t\t}\n\n\t\tthis.mXMPPConnection = new XmppStreamHandler.ExtXMPPConnection(mXMPPConfig);\n\t\tthis.mStreamHandler = new XmppStreamHandler(mXMPPConnection, mConfig.smackdebug);\n\t\tmStreamHandler.addAckReceivedListener(new XmppStreamHandler.AckReceivedListener() {\n\t\t\tpublic void ackReceived(long handled, long total) {\n\t\t\t\tgotServerPong(\"\" + handled);\n\t\t\t}\n\t\t});\n\t\tmConfig.reconnect_required = false;\n\n\t\tmultiUserChats = new HashMap<String, MultiUserChat>();\n\t\tinitServiceDiscovery();\n\t}\n\n\t// blocking, run from a thread!\n\tpublic boolean doConnect(boolean create_account) throws YaximXMPPException {\n\t\tmRequestedState = ConnectionState.ONLINE;\n\t\tupdateConnectionState(ConnectionState.CONNECTING);\n\t\tif (mXMPPConnection == null || mConfig.reconnect_required)\n\t\t\tinitXMPPConnection();\n\t\ttryToConnect(create_account);\n\t\t// actually, authenticated must be true now, or an exception must have\n\t\t// been thrown.\n\t\tif (isAuthenticated()) {\n\t\t\tupdateConnectionState(ConnectionState.LOADING);\n\t\t\tregisterMessageListener();\n\t\t\tregisterPresenceListener();\n\t\t\tregisterPongListener();\n\t\t\tsyncDbRooms();\n\t\t\tsendOfflineMessages();\n\t\t\tsendUserWatching();\n\t\t\t// we need to \"ping\" the service to let it know we are actually\n\t\t\t// connected, even when no roster entries will come in\n\t\t\tupdateConnectionState(ConnectionState.ONLINE);\n\t\t} else throw new YaximXMPPException(\"SMACK connected, but authentication failed\");\n\t\treturn true;\n\t}\n\n\t// BLOCKING, call on a new Thread!\n\tprivate void updateConnectingThread(Thread new_thread) {\n\t\tsynchronized(mConnectingThreadMutex) {\n\t\t\tif (mConnectingThread == null) {\n\t\t\t\tmConnectingThread = new_thread;\n\t\t\t} else try {\n\t\t\t\tLog.d(TAG, \"updateConnectingThread: old thread is still running, killing it.\");\n\t\t\t\tmConnectingThread.interrupt();\n\t\t\t\tmConnectingThread.join(50);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLog.d(TAG, \"updateConnectingThread: failed to join(): \" + e);\n\t\t\t} finally {\n\t\t\t\tmConnectingThread = new_thread;\n\t\t\t}\n\t\t}\n\t}\n\tprivate void finishConnectingThread() {\n\t\tsynchronized(mConnectingThreadMutex) {\n\t\t\tmConnectingThread = null;\n\t\t}\n\t}\n\n\t/** Non-blocking, synchronized function to connect/disconnect XMPP.\n\t * This code is called from outside and returns immediately. The actual work\n\t * is done on a background thread, and notified via callback.\n\t * @param new_state The state to transition into. Possible values:\n\t * \tOFFLINE to properly close the connection\n\t * \tONLINE to connect\n\t * \tDISCONNECTED when network goes down\n\t * @param create_account When going online, try to register an account.\n\t */\n\t@Override\n\tpublic synchronized void requestConnectionState(ConnectionState new_state, final boolean create_account) {\n\t\tLog.d(TAG, \"requestConnState: \" + mState + \" -> \" + new_state + (create_account ? \" create_account!\" : \"\"));\n\t\tmRequestedState = new_state;\n\t\tif (new_state == mState)\n\t\t\treturn;\n\t\tswitch (new_state) {\n\t\tcase ONLINE:\n\t\t\tswitch (mState) {\n\t\t\tcase RECONNECT_DELAYED:\n\t\t\t\t// TODO: cancel timer\n\t\t\tcase RECONNECT_NETWORK:\n\t\t\tcase DISCONNECTED:\n\t\t\tcase OFFLINE:\n\t\t\t\t// update state before starting thread to prevent race conditions\n\t\t\t\tupdateConnectionState(ConnectionState.CONNECTING);\n\n\t\t\t\t// register ping (connection) timeout handler: 2*PACKET_TIMEOUT(30s) + 3s\n\t\t\t\tregisterPongTimeout(2*PACKET_TIMEOUT + 3000, \"connection\");\n\n\t\t\t\tnew Thread() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tupdateConnectingThread(this);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdoConnect(create_account);\n\t\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t\t// this might happen when DNS resolution in ConnectionConfiguration fails\n\t\t\t\t\t\t\tonDisconnected(e);\n\t\t\t\t\t\t} catch (IllegalStateException e) {//TODO: work around old smack\n\t\t\t\t\t\t\tonDisconnected(e);\n\t\t\t\t\t\t} catch (YaximXMPPException e) {\n\t\t\t\t\t\t\tonDisconnected(e);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tmAlarmManager.cancel(mPongTimeoutAlarmPendIntent);\n\t\t\t\t\t\t\tfinishConnectingThread();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.start();\n\t\t\t\tbreak;\n\t\t\tcase CONNECTING:\n\t\t\tcase LOADING:\n\t\t\tcase DISCONNECTING:\n\t\t\t\t// ignore all other cases\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DISCONNECTED:\n\t\t\t// spawn thread to do disconnect\n\t\t\tif (mState == ConnectionState.ONLINE) {\n\t\t\t\t// update state before starting thread to prevent race conditions\n\t\t\t\tupdateConnectionState(ConnectionState.DISCONNECTING);\n\n\t\t\t\t// register ping (connection) timeout handler: PACKET_TIMEOUT(30s)\n\t\t\t\tregisterPongTimeout(PACKET_TIMEOUT, \"forced disconnect\");\n\n\t\t\t\tnew Thread() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tupdateConnectingThread(this);\n\t\t\t\t\t\tmStreamHandler.quickShutdown();\n\t\t\t\t\t\tonDisconnected(\"forced disconnect completed\");\n\t\t\t\t\t\tfinishConnectingThread();\n\t\t\t\t\t\t//updateConnectionState(ConnectionState.OFFLINE);\n\t\t\t\t\t}\n\t\t\t\t}.start();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OFFLINE:\n\t\t\tswitch (mState) {\n\t\t\tcase CONNECTING:\n\t\t\tcase LOADING:\n\t\t\tcase ONLINE:\n\t\t\t\t// update state before starting thread to prevent race conditions\n\t\t\t\tupdateConnectionState(ConnectionState.DISCONNECTING);\n\n\t\t\t\t// register ping (connection) timeout handler: PACKET_TIMEOUT(30s)\n\t\t\t\tregisterPongTimeout(PACKET_TIMEOUT, \"manual disconnect\");\n\n\t\t\t\t// spawn thread to do disconnect\n\t\t\t\tnew Thread() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tupdateConnectingThread(this);\n\t\t\t\t\t\tmXMPPConnection.shutdown();\n\t\t\t\t\t\tmStreamHandler.close();\n\t\t\t\t\t\tmAlarmManager.cancel(mPongTimeoutAlarmPendIntent);\n\t\t\t\t\t\t// we should reset XMPPConnection the next time\n\t\t\t\t\t\tmConfig.reconnect_required = true;\n\t\t\t\t\t\tfinishConnectingThread();\n\t\t\t\t\t\t// reconnect if it was requested in the meantime\n\t\t\t\t\t\tif (mRequestedState == ConnectionState.ONLINE)\n\t\t\t\t\t\t\trequestConnectionState(ConnectionState.ONLINE);\n\t\t\t\t\t}\n\t\t\t\t}.start();\n\t\t\t\tbreak;\n\t\t\tcase DISCONNECTING:\n\t\t\t\tbreak;\n\t\t\tcase DISCONNECTED:\n\t\t\tcase RECONNECT_DELAYED:\n\t\t\t\t// TODO: clear timer\n\t\t\tcase RECONNECT_NETWORK:\n\t\t\t\tupdateConnectionState(ConnectionState.OFFLINE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RECONNECT_NETWORK:\n\t\tcase RECONNECT_DELAYED:\n\t\t\tswitch (mState) {\n\t\t\tcase DISCONNECTED:\n\t\t\tcase RECONNECT_NETWORK:\n\t\t\tcase RECONNECT_DELAYED:\n\t\t\t\tupdateConnectionState(new_state);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"Can not go from \" + mState + \" to \" + new_state);\n\t\t\t}\n\t\t}\n\t}\n\t@Override\n\tpublic void requestConnectionState(ConnectionState new_state) {\n\t\trequestConnectionState(new_state, false);\n\t}\n\n\t@Override\n\tpublic ConnectionState getConnectionState() {\n\t\treturn mState;\n\t}\n\n\t@Override\n\tpublic long getConnectionStateTimestamp() {\n\t\treturn (mState == ConnectionState.ONLINE) ? mLastOnline : mLastOffline;\n\t}\n\n\t// called at the end of a state transition\n\tprivate synchronized void updateConnectionState(ConnectionState new_state) {\n\t\tif (new_state == ConnectionState.ONLINE || new_state == ConnectionState.LOADING)\n\t\t\tmLastError = null;\n\t\tLog.d(TAG, \"updateConnectionState: \" + mState + \" -> \" + new_state + \" (\" + mLastError + \")\");\n\t\tif (new_state == mState)\n\t\t\treturn;\n\t\tif (mState == ConnectionState.ONLINE)\n\t\t\tmLastOffline = System.currentTimeMillis();\n\t\tmState = new_state;\n\t\tif (mServiceCallBack != null)\n\t\t\tmServiceCallBack.connectionStateChanged();\n\t}\n\tprivate void initServiceDiscovery() {\n\t\t// register connection features\n\t\tServiceDiscoveryManager sdm = ServiceDiscoveryManager.getInstanceFor(mXMPPConnection);\n\n\t\t// init Entity Caps manager with storage in app's cache dir\n\t\ttry {\n\t\t\tif (capsCacheDir == null) {\n\t\t\t\tcapsCacheDir = new File(mService.getCacheDir(), \"entity-caps-cache\");\n\t\t\t\tcapsCacheDir.mkdirs();\n\t\t\t\tEntityCapsManager.setPersistentCache(new SimpleDirectoryPersistentCache(capsCacheDir));\n\t\t\t}\n\t\t} catch (java.io.IOException e) {\n\t\t\tLog.e(TAG, \"Could not init Entity Caps cache: \" + e.getLocalizedMessage());\n\t\t}\n\n\t\t// reference PingManager, set ping flood protection to 10s\n\t\tPingManager.getInstanceFor(mXMPPConnection).disablePingFloodProtection();\n\n\t\t// set Version for replies\n\t\tString app_name = mService.getString(R.string.app_name);\n\t\tString build_revision = mService.getString(R.string.build_revision);\n\t\tVersion.Manager.getInstanceFor(mXMPPConnection).setVersion(\n\t\t\t\tnew Version(app_name, build_revision, \"Android\"));\n\n\t\t// reference DeliveryReceiptManager, add listener\n\t\tDeliveryReceiptManager dm = DeliveryReceiptManager.getInstanceFor(mXMPPConnection);\n\t\tdm.addReceiptReceivedListener(new ReceiptReceivedListener() { // DOES NOT WORK IN CARBONS\n\t\t\tpublic void onReceiptReceived(String fromJid, String toJid, String receiptId) {\n\t\t\t\tLog.d(TAG, \"got delivery receipt for \" + receiptId);\n\t\t\t\tchangeMessageDeliveryStatus(receiptId, ChatConstants.DS_ACKED);\n\t\t\t}});\n\t}\n\n\tpublic void addRosterItem(String user, String alias, String group, String token)\n\t\t\tthrows YaximXMPPException {\n\t\tsubscriptionRequests.remove(user);\n\t\tmConfig.whitelistInvitationJID(user);\n\t\ttryToAddRosterEntry(user, alias, group, token);\n\t}\n\n\tpublic void removeRosterItem(String user) throws YaximXMPPException {\n\t\tdebugLog(\"removeRosterItem(\" + user + \")\");\n\t\tsubscriptionRequests.remove(user);\n\t\ttryToRemoveRosterEntry(user);\n\t}\n\n\tpublic void renameRosterItem(String user, String newName)\n\t\t\tthrows YaximXMPPException {\n\t\tRosterEntry rosterEntry = mRoster.getEntry(user);\n\n\t\tif (!(newName.length() > 0) || (rosterEntry == null)) {\n\t\t\tthrow new YaximXMPPException(\"JabberID to rename is invalid!\");\n\t\t}\n\t\trosterEntry.setName(newName);\n\t}\n\n\tpublic void addRosterGroup(String group) {\n\t\tmRoster.createGroup(group);\n\t}\n\n\tpublic void renameRosterGroup(String group, String newGroup) {\n\t\tRosterGroup groupToRename = mRoster.getGroup(group);\n\t\tgroupToRename.setName(newGroup);\n\t}\n\n\tpublic void moveRosterItemToGroup(String user, String group)\n\t\t\tthrows YaximXMPPException {\n\t\ttryToMoveRosterEntryToGroup(user, group);\n\t}\n\n\tpublic void sendPresenceRequest(String user, String type) {\n\t\t// HACK: remove the fake roster entry added by handleIncomingSubscribe()\n\t\tsubscriptionRequests.remove(user);\n\t\tif (\"unsubscribed\".equals(type))\n\t\t\tdeleteRosterEntryFromDB(user);\n\t\tPresence response = new Presence(Presence.Type.valueOf(type));\n\t\tresponse.setTo(user);\n\t\tmXMPPConnection.sendPacket(response);\n\t}\n\t\n\t@Override\n\tpublic String changePassword(String newPassword) {\n\t\ttry {\n\t\t\tnew AccountManager(mXMPPConnection).changePassword(newPassword);\n\t\t\treturn \"OK\"; //HACK: hard coded string to differentiate from failure modes\n\t\t} catch (XMPPException e) {\n\t\t\tif (e.getXMPPError() != null)\n\t\t\t\treturn e.getXMPPError().toString();\n\t\t\telse\n\t\t\t\treturn e.getLocalizedMessage();\n\t\t}\n\t}\n\n\tprivate void onDisconnected(String reason) {\n\t\tunregisterPongListener();\n\t\tmLastError = reason;\n\t\tupdateConnectionState(ConnectionState.DISCONNECTED);\n\t}\n\tprivate void onDisconnected(Throwable reason) {\n\t\tLog.e(TAG, \"onDisconnected: \" + reason);\n\t\treason.printStackTrace();\n\t\t// iterate through to the deepest exception\n\t\twhile (reason.getCause() != null && !(reason.getCause().getClass().getSimpleName().equals(\"GaiException\")))\n\t\t\treason = reason.getCause();\n\t\tonDisconnected(reason.getLocalizedMessage());\n\t}\n\n\tprivate void tryToConnect(boolean create_account) throws YaximXMPPException {\n\t\ttry {\n\t\t\tif (mXMPPConnection.isConnected()) {\n\t\t\t\ttry {\n\t\t\t\t\tmStreamHandler.quickShutdown(); // blocking shutdown prior to re-connection\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tdebugLog(\"conn.shutdown() failed: \" + e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tregisterRosterListener();\n\t\t\tboolean need_bind = !mStreamHandler.isResumePossible();\n\n\t\t\tif (mConnectionListener != null)\n\t\t\t\tmXMPPConnection.removeConnectionListener(mConnectionListener);\n\t\t\tmConnectionListener = new ConnectionListener() {\n\t\t\t\tpublic void connectionClosedOnError(Exception e) {\n\t\t\t\t\t// XXX: this is the only callback we get from errors, so\n\t\t\t\t\t// we need to check for non-resumability and work around\n\t\t\t\t\t// here:\n\t\t\t\t\tif (!mStreamHandler.isResumePossible()) {\n\t\t\t\t\t\tmultiUserChats.clear();\n\t\t\t\t\t\tmucLastPong.clear();\n\t\t\t\t\t\tmucLastPing = 0;\n\t\t\t\t\t}\n\t\t\t\t\tonDisconnected(e);\n\t\t\t\t}\n\t\t\t\tpublic void connectionClosed() {\n\t\t\t\t\t// TODO: fix reconnect when we got kicked by the server or SM failed!\n\t\t\t\t\t//onDisconnected(null);\n\t\t\t\t\tmultiUserChats.clear();\n\t\t\t\t\tmucLastPong.clear();\n\t\t\t\t\tmucLastPing = 0;\n\t\t\t\t\tupdateConnectionState(ConnectionState.OFFLINE);\n\t\t\t\t}\n\t\t\t\tpublic void reconnectingIn(int seconds) { }\n\t\t\t\tpublic void reconnectionFailed(Exception e) { }\n\t\t\t\tpublic void reconnectionSuccessful() { }\n\t\t\t};\n\t\t\tmXMPPConnection.addConnectionListener(mConnectionListener);\n\n\t\t\tmXMPPConnection.connect(need_bind);\n\t\t\t// SMACK auto-logins if we were authenticated before\n\t\t\tif (!mXMPPConnection.isAuthenticated()) {\n\t\t\t\tif (create_account) {\n\t\t\t\t\tLog.d(TAG, \"creating new server account...\");\n\t\t\t\t\tAccountManager am = new AccountManager(mXMPPConnection);\n\t\t\t\t\tam.createAccount(mConfig.userName, mConfig.password);\n\t\t\t\t}\n\t\t\t\tmXMPPConnection.login(mConfig.userName, mConfig.password,\n\t\t\t\t\t\tmConfig.ressource);\n\t\t\t}\n\t\t\tLog.d(TAG, \"SM: can resume = \" + mStreamHandler.isResumePossible() + \" needbind=\" + need_bind);\n\t\t\tif (need_bind) {\n\t\t\t\tmStreamHandler.notifyInitialLogin();\n\t\t\t\tcleanupMUCs(true);\n\t\t\t\tsetStatusFromConfig();\n\t\t\t\tmLastOnline = System.currentTimeMillis();\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\t// actually we just care for IllegalState or NullPointer or XMPPEx.\n\t\t\tthrow new YaximXMPPException(\"tryToConnect failed\", e);\n\t\t}\n\t}\n\n\tprivate void tryToMoveRosterEntryToGroup(String userName, String groupName)\n\t\t\tthrows YaximXMPPException {\n\n\t\tRosterGroup rosterGroup = getRosterGroup(groupName);\n\t\tRosterEntry rosterEntry = mRoster.getEntry(userName);\n\n\t\tremoveRosterEntryFromGroups(rosterEntry);\n\n\t\tif (groupName.length() == 0)\n\t\t\treturn;\n\t\telse {\n\t\t\ttry {\n\t\t\t\trosterGroup.addEntry(rosterEntry);\n\t\t\t} catch (XMPPException e) {\n\t\t\t\tthrow new YaximXMPPException(\"tryToMoveRosterEntryToGroup\", e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate RosterGroup getRosterGroup(String groupName) {\n\t\tRosterGroup rosterGroup = mRoster.getGroup(groupName);\n\n\t\t// create group if unknown\n\t\tif ((groupName.length() > 0) && rosterGroup == null) {\n\t\t\trosterGroup = mRoster.createGroup(groupName);\n\t\t}\n\t\treturn rosterGroup;\n\n\t}\n\n\tprivate void removeRosterEntryFromGroups(RosterEntry rosterEntry)\n\t\t\tthrows YaximXMPPException {\n\t\tCollection<RosterGroup> oldGroups = rosterEntry.getGroups();\n\n\t\tfor (RosterGroup group : oldGroups) {\n\t\t\ttryToRemoveUserFromGroup(group, rosterEntry);\n\t\t}\n\t}\n\n\tprivate void tryToRemoveUserFromGroup(RosterGroup group,\n\t\t\tRosterEntry rosterEntry) throws YaximXMPPException {\n\t\ttry {\n\t\t\tgroup.removeEntry(rosterEntry);\n\t\t} catch (XMPPException e) {\n\t\t\tthrow new YaximXMPPException(\"tryToRemoveUserFromGroup\", e);\n\t\t}\n\t}\n\n\tprivate void tryToRemoveRosterEntry(String user) throws YaximXMPPException {\n\t\ttry {\n\t\t\tRosterEntry rosterEntry = mRoster.getEntry(user);\n\n\t\t\tif (rosterEntry != null) {\n\t\t\t\t// first, unsubscribe the user\n\t\t\t\tPresence unsub = new Presence(Presence.Type.unsubscribed);\n\t\t\t\tunsub.setTo(rosterEntry.getUser());\n\t\t\t\tmXMPPConnection.sendPacket(unsub);\n\t\t\t\t// then, remove from roster\n\t\t\t\tmRoster.removeEntry(rosterEntry);\n\t\t\t}\n\t\t} catch (XMPPException e) {\n\t\t\tthrow new YaximXMPPException(\"tryToRemoveRosterEntry\", e);\n\t\t}\n\t}\n\n\tprivate void tryToAddRosterEntry(String user, String alias, String group, String token)\n\t\t\tthrows YaximXMPPException {\n\t\ttry {\n\t\t\t// send a presence subscription request with token (must be before roster action!)\n\t\t\tif (token != null && token.length() > 0) {\n\t\t\t\tPresence preauth = new Presence(Presence.Type.subscribe);\n\t\t\t\tpreauth.setTo(user);\n\t\t\t\tpreauth.addExtension(new PreAuth(token));\n\t\t\t\tmXMPPConnection.sendPacket(preauth);\n\t\t\t}\n\t\t\t// add to roster, triggers another sub request by Smack (sigh)\n\t\t\tmRoster.createEntry(user, alias, new String[] { group });\n\t\t\t// send a pre-approval\n\t\t\tPresence pre_approval = new Presence(Presence.Type.subscribed);\n\t\t\tpre_approval.setTo(user);\n\t\t\tmXMPPConnection.sendPacket(pre_approval);\n\t\t\tmConfig.whitelistInvitationJID(user);\n\t\t} catch (XMPPException e) {\n\t\t\tthrow new YaximXMPPException(\"tryToAddRosterEntry\", e);\n\t\t}\n\t}\n\n\tprivate void removeOldRosterEntries() {\n\t\tLog.d(TAG, \"removeOldRosterEntries()\");\n\t\tCollection<RosterEntry> rosterEntries = mRoster.getEntries();\n\t\tStringBuilder exclusion = new StringBuilder(RosterConstants.JID + \" NOT IN (\");\n\t\tboolean first = true;\n\t\t\n\t\tfor (RosterEntry rosterEntry : rosterEntries) {\n\t\t\tif (first)\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\texclusion.append(\",\");\n\t\t\texclusion.append(\"'\").append(rosterEntry.getUser()).append(\"'\");\n\t\t}\n\t\t\n\t\texclusion.append(\") AND \"+RosterConstants.GROUP+\" NOT IN ('\" + RosterProvider.RosterConstants.MUCS + \"');\");\n\t\tint count = mContentResolver.delete(RosterProvider.CONTENT_URI, exclusion.toString(), null);\n\t\tLog.d(TAG, \"deleted \" + count + \" old roster entries\");\n\t}\n\n\t// HACK: add an incoming subscription request as a fake roster entry\n\tprivate void handleIncomingSubscribe(Presence request) {\n\t\t// perform Pre-Authenticated Roster Subscription, fallback to manual\n\t\ttry {\n\t\t\tString jid = request.getFrom();\n\t\t\tPreAuth preauth = (PreAuth)request.getExtension(PreAuth.ELEMENT, PreAuth.NAMESPACE);\n\t\t\tString jid_or_token = jid;\n\t\t\tif (preauth != null) {\n\t\t\t\tjid_or_token = preauth.getToken();\n\t\t\t\tLog.d(TAG, \"PARS: found token \" + jid_or_token);\n\t\t\t}\n\t\t\tif (mConfig.redeemInvitationCode(jid_or_token)) {\n\t\t\t\tLog.d(TAG, \"PARS: approving request from \" + jid);\n\t\t\t\tif (mRoster.getEntry(request.getFrom()) != null) {\n\t\t\t\t\t// already in roster, only send approval\n\t\t\t\t\tPresence response = new Presence(Presence.Type.subscribed);\n\t\t\t\t\tresponse.setTo(jid);\n\t\t\t\t\tmXMPPConnection.sendPacket(response);\n\t\t\t\t} else {\n\t\t\t\t\ttryToAddRosterEntry(jid, null, \"\", null);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (YaximXMPPException e) {\n\t\t\tLog.d(TAG, \"PARS: failed to send response: \" + e);\n\t\t}\n\n\t\tsubscriptionRequests.put(request.getFrom(), request);\n\n\t\tfinal ContentValues values = new ContentValues();\n\n\t\tvalues.put(RosterConstants.JID, request.getFrom());\n\t\tvalues.put(RosterConstants.STATUS_MODE, getStatusInt(request));\n\t\tvalues.put(RosterConstants.STATUS_MESSAGE, request.getStatus());\n\t\tif (!mRoster.contains(request.getFrom())) {\n\t\t\t// reset alias and group for new entries\n\t\t\tvalues.put(RosterConstants.ALIAS, request.getFrom());\n\t\t\tvalues.put(RosterConstants.GROUP, \"\");\n\t\t};\n\t\tupsertRoster(values, request.getFrom());\n\t}\n\n\tpublic void setStatusFromConfig() {\n\t\t// TODO: only call this when carbons changed, not on every presence change\n\t\tCarbonManager.getInstanceFor(mXMPPConnection).sendCarbonsEnabled(mConfig.messageCarbons);\n\n\t\tPresence presence = new Presence(Presence.Type.available);\n\t\tMode mode = Mode.valueOf(mConfig.getPresenceMode().toString());\n\t\tpresence.setMode(mode);\n\t\tpresence.setStatus(mConfig.statusMessage);\n\t\tpresence.setPriority(mConfig.priority);\n\t\tmXMPPConnection.sendPacket(presence);\n\t\tmConfig.presence_required = false;\n\t}\n\n\tpublic void sendOfflineMessages() {\n\t\tCursor cursor = mContentResolver.query(ChatProvider.CONTENT_URI,\n\t\t\t\tSEND_OFFLINE_PROJECTION, SEND_OFFLINE_SELECTION,\n\t\t\t\tnull, null);\n\t\tfinal int      _ID_COL = cursor.getColumnIndexOrThrow(ChatConstants._ID);\n\t\tfinal int      JID_COL = cursor.getColumnIndexOrThrow(ChatConstants.JID);\n\t\tfinal int      MSG_COL = cursor.getColumnIndexOrThrow(ChatConstants.MESSAGE);\n\t\tfinal int       TS_COL = cursor.getColumnIndexOrThrow(ChatConstants.DATE);\n\t\tfinal int PACKETID_COL = cursor.getColumnIndexOrThrow(ChatConstants.PACKET_ID);\n\t\tContentValues mark_sent = new ContentValues();\n\t\tmark_sent.put(ChatConstants.DELIVERY_STATUS, ChatConstants.DS_SENT_OR_READ);\n\t\twhile (cursor.moveToNext()) {\n\t\t\tint _id = cursor.getInt(_ID_COL);\n\t\t\tString toJID = cursor.getString(JID_COL);\n\t\t\tString message = cursor.getString(MSG_COL);\n\t\t\tString packetID = cursor.getString(PACKETID_COL);\n\t\t\tlong ts = cursor.getLong(TS_COL);\n\t\t\tLog.d(TAG, \"sendOfflineMessages: \" + toJID + \" > \" + message);\n\t\t\tfinal Message newMessage = new Message(toJID, Message.Type.chat);\n\t\t\tnewMessage.setBody(message);\n\t\t\tDelayInformation delay = new DelayInformation(new Date(ts));\n\t\t\tnewMessage.addExtension(delay);\n\t\t\tnewMessage.addExtension(new DelayInfo(delay));\n\t\t\tif (mucJIDs.contains(toJID))\n\t\t\t\tnewMessage.setType(Message.Type.groupchat);\n\t\t\telse\n\t\t\t\tnewMessage.addExtension(new DeliveryReceiptRequest());\n\t\t\tif ((packetID != null) && (packetID.length() > 0)) {\n\t\t\t\tnewMessage.setPacketID(packetID);\n\t\t\t} else {\n\t\t\t\tpacketID = newMessage.getPacketID();\n\t\t\t}\n\t\t\tmark_sent.put(ChatConstants.PACKET_ID, packetID);\n\t\t\tUri rowuri = Uri.parse(\"content://\" + ChatProvider.AUTHORITY\n\t\t\t\t+ \"/\" + ChatProvider.TABLE_NAME + \"/\" + _id);\n\t\t\tmContentResolver.update(rowuri, mark_sent,\n\t\t\t\t\t\tnull, null);\n\t\t\tmXMPPConnection.sendPacket(newMessage);\t\t// must be after marking delivered, otherwise it may override the SendFailListener\n\t\t}\n\t\tcursor.close();\n\t}\n\n\tpublic static void sendOfflineMessage(ContentResolver cr, String toJID, String message) {\n\t\tContentValues values = new ContentValues();\n\t\tvalues.put(ChatConstants.DIRECTION, ChatConstants.OUTGOING);\n\t\tvalues.put(ChatConstants.JID, toJID);\n\t\tvalues.put(ChatConstants.MESSAGE, message);\n\t\tvalues.put(ChatConstants.DELIVERY_STATUS, ChatConstants.DS_NEW);\n\t\tvalues.put(ChatConstants.DATE, System.currentTimeMillis());\n\t\tvalues.put(ChatConstants.PACKET_ID, Packet.nextID());\n\n\t\tcr.insert(ChatProvider.CONTENT_URI, values);\n\t}\n\n\tpublic void sendReceiptIfRequested(Packet packet) {\n\t\tDeliveryReceiptRequest drr = (DeliveryReceiptRequest)packet.getExtension(\n\t\t\t\tDeliveryReceiptRequest.ELEMENT, DeliveryReceipt.NAMESPACE);\n\t\tif (drr != null) {\n\t\t\tMessage ack = new Message(packet.getFrom(), Message.Type.normal);\n\t\t\tack.addExtension(new DeliveryReceipt(packet.getPacketID()));\n\t\t\tmXMPPConnection.sendPacket(ack);\n\t\t}\n\t}\n\n\tpublic void sendMessage(String toJID, String message) {\n\t\tfinal Message newMessage = new Message(toJID, Message.Type.chat);\n\t\tnewMessage.setBody(message);\n\t\tnewMessage.addExtension(new DeliveryReceiptRequest());\n\t\tif (isAuthenticated()) {\n\n\t\t\tif(mucJIDs.contains(toJID)) {\n\t\t\t\tsendMucMessage(toJID, message);\n\t\t\t} else {\n\t\t\t\taddChatMessageToDB(ChatConstants.OUTGOING, toJID, message, ChatConstants.DS_SENT_OR_READ,\n\t\t\t\t\t\tSystem.currentTimeMillis(), newMessage.getPacketID());\n\t\t\t\tmXMPPConnection.sendPacket(newMessage);\n\t\t\t}\n\t\t} else {\n\t\t\t// send offline -> store to DB\n\t\t\taddChatMessageToDB(ChatConstants.OUTGOING, toJID, message, ChatConstants.DS_NEW,\n\t\t\t\t\tSystem.currentTimeMillis(), newMessage.getPacketID());\n\t\t}\n\t}\n\n\tpublic boolean isAuthenticated() {\n\t\tif (mXMPPConnection != null) {\n\t\t\treturn (mXMPPConnection.isConnected() && mXMPPConnection\n\t\t\t\t\t.isAuthenticated());\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void registerCallback(XMPPServiceCallback callBack) {\n\t\tthis.mServiceCallBack = callBack;\n\t\tmService.registerReceiver(mPingAlarmReceiver, new IntentFilter(PING_ALARM));\n\t\tmService.registerReceiver(mPongTimeoutAlarmReceiver, new IntentFilter(PONG_TIMEOUT_ALARM));\n\t}\n\n\tpublic void unRegisterCallback() {\n\t\tdebugLog(\"unRegisterCallback()\");\n\t\t// remove callbacks _before_ tossing old connection\n\t\ttry {\n\t\t\tmXMPPConnection.getRoster().removeRosterListener(mRosterListener);\n\t\t\tmXMPPConnection.removePacketListener(mPacketListener);\n\t\t\tmXMPPConnection.removePacketListener(mPresenceListener);\n\n\t\t\tmXMPPConnection.removePacketListener(mPongListener);\n\t\t\tunregisterPongListener();\n\t\t} catch (Exception e) {\n\t\t\t// ignore it!\n\t\t\te.printStackTrace();\n\t\t}\n\t\trequestConnectionState(ConnectionState.OFFLINE);\n\t\tsetStatusOffline();\n\t\tmService.unregisterReceiver(mPingAlarmReceiver);\n\t\tmService.unregisterReceiver(mPongTimeoutAlarmReceiver);\n//\t\tmultiUserChats.clear(); // TODO: right place\n\t\tthis.mServiceCallBack = null;\n\t}\n\t\n\tpublic String getNameForJID(String jid) {\n\t\tif (jid.contains(\"/\")) { // MUC-PM\n\t\t\tString[] jid_parts = jid.split(\"/\", 2);\n\t\t\treturn String.format(\"%s (%s)\", jid_parts[1],\n\t\t\t\t\tChatRoomHelper.getRoomName(mService, jid_parts[0]));\n\t\t}\n\t\tRosterEntry re = mRoster.getEntry(jid);\n\t\tif (null != re && null != re.getName() && re.getName().length() > 0) {\n\t\t\treturn re.getName();\n\t\t} else if (mucJIDs.contains(jid)) {\n\t\t\treturn ChatRoomHelper.getRoomName(mService, jid);\n\t\t} else {\n\t\t\treturn jid;\n\t\t}\t\t\t\n\t}\n\n\tpublic long getRowIdForMessage(String jid, String resource, int direction, String packet_id) {\n\t\t// query the DB for the RowID, return -1 if packet_id does not match\n\t\tCursor c = mContentResolver.query(ChatProvider.CONTENT_URI, new String[] { ChatConstants._ID, ChatConstants.PACKET_ID },\n\t\t\t\t\"jid = ? AND resource = ? AND from_me = ?\",\n\t\t\t\tnew String[] { jid, resource, \"\" + direction }, \"_id DESC\");\n\t\tlong result = -1;\n\t\tif (c.moveToFirst() && c.getString(1).equals(packet_id))\n\t\t\tresult = c.getLong(0);\n\t\tc.close();\n\t\treturn result;\n\t}\n\n\tprivate void setStatusOffline() {\n\t\tContentValues values = new ContentValues();\n\t\tvalues.put(RosterConstants.STATUS_MODE, StatusMode.offline.ordinal());\n\t\tmContentResolver.update(RosterProvider.CONTENT_URI, values, null, null);\n\t}\n\n\tprivate void registerRosterListener() {\n\t\t// flush roster on connecting.\n\t\tmRoster = mXMPPConnection.getRoster();\n\t\tmRoster.setSubscriptionMode(Roster.SubscriptionMode.manual);\n\n\t\tif (mRosterListener != null)\n\t\t\tmRoster.removeRosterListener(mRosterListener);\n\n\t\tmRosterListener = new RosterListener() {\n\t\t\tprivate boolean first_roster = true;\n\n\t\t\tpublic void entriesAdded(Collection<String> entries) {\n\t\t\t\tdebugLog(\"entriesAdded(\" + entries + \")\");\n\n\t\t\t\tContentValues[] cvs = new ContentValues[entries.size()];\n\t\t\t\tint i = 0;\n\t\t\t\tfor (String entry : entries) {\n\t\t\t\t\tRosterEntry rosterEntry = mRoster.getEntry(entry);\n\t\t\t\t\tcvs[i++] = getContentValuesForRosterEntry(rosterEntry);\n\t\t\t\t}\n\t\t\t\tmContentResolver.bulkInsert(RosterProvider.CONTENT_URI, cvs);\n\t\t\t\t// when getting the roster in the beginning, remove remains of old one\n\t\t\t\tif (first_roster) {\n\t\t\t\t\tremoveOldRosterEntries();\n\t\t\t\t\tfirst_roster = false;\n\t\t\t\t}\n\t\t\t\tdebugLog(\"entriesAdded() done\");\n\t\t\t}\n\n\t\t\tpublic void entriesDeleted(Collection<String> entries) {\n\t\t\t\tdebugLog(\"entriesDeleted(\" + entries + \")\");\n\n\t\t\t\tfor (String entry : entries) {\n\t\t\t\t\tdeleteRosterEntryFromDB(entry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void entriesUpdated(Collection<String> entries) {\n\t\t\t\tdebugLog(\"entriesUpdated(\" + entries + \")\");\n\n\t\t\t\tfor (String entry : entries) {\n\t\t\t\t\tRosterEntry rosterEntry = mRoster.getEntry(entry);\n\t\t\t\t\tupdateRosterEntryInDB(rosterEntry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void presenceChanged(Presence presence) {\n\t\t\t\tdebugLog(\"presenceChanged(\" + presence.getFrom() + \"): \" + presence);\n\n\t\t\t\tString jabberID = getBareJID(presence.getFrom());\n\t\t\t\tRosterEntry rosterEntry = mRoster.getEntry(jabberID);\n\t\t\t\tif (rosterEntry != null)\n\t\t\t\t\tupsertRoster(getContentValuesForRosterEntry(rosterEntry, presence),\n\t\t\t\t\t\t\trosterEntry.getUser());\n\t\t\t}\n\t\t};\n\t\tmRoster.addRosterListener(mRosterListener);\n\t}\n\n\tprivate String getBareJID(String from) {\n\t\tString[] res = from.split(\"/\", 2);\n\t\treturn res[0].toLowerCase();\n\t}\n\n\tprivate String[] getJabberID(String from) {\n\t\tif(from.contains(\"/\")) {\n\t\t\tString[] res = from.split(\"/\", 2);\n\t\t\treturn new String[] { res[0], res[1] };\n\t\t} else {\n\t\t\treturn new String[] {from, \"\"};\n\t\t}\n\t}\n\n\tpublic boolean changeMessageDeliveryStatus(String packetID, int new_status) {\n\t\tContentValues cv = new ContentValues();\n\t\tcv.put(ChatConstants.DELIVERY_STATUS, new_status);\n\t\tUri rowuri = Uri.parse(\"content://\" + ChatProvider.AUTHORITY + \"/\"\n\t\t\t\t+ ChatProvider.TABLE_NAME);\n\t\treturn mContentResolver.update(rowuri, cv,\n\t\t\t\tChatConstants.PACKET_ID + \" = ? AND \" +\n\t\t\t\tChatConstants.DELIVERY_STATUS + \" != \" + ChatConstants.DS_ACKED + \" AND \" +\n\t\t\t\tChatConstants.DIRECTION + \" = \" + ChatConstants.OUTGOING,\n\t\t\t\tnew String[] { packetID }) > 0;\n\t}\n\n\tprotected boolean is_user_watching = false;\n\tpublic void setUserWatching(boolean user_watching) {\n\t\tif (is_user_watching == user_watching)\n\t\t\treturn;\n\t\tis_user_watching = user_watching;\n\t\tif (mXMPPConnection != null && mXMPPConnection.isAuthenticated())\n\t\t\tsendUserWatching();\n\t}\n\n\tprotected void sendUserWatching() {\n\t\tIQ toggle_google_queue = new IQ() {\n\t\t\tpublic String getChildElementXML() {\n\t\t\t\t// enable g:q = start queueing packets = do it when the user is gone\n\t\t\t\treturn \"<query xmlns='google:queue'><\" + (is_user_watching ? \"disable\" : \"enable\") + \"/></query>\";\n\t\t\t}\n\t\t};\n\t\ttoggle_google_queue.setType(IQ.Type.SET);\n\t\tmXMPPConnection.sendPacket(toggle_google_queue);\n\t}\n\n\t/** Check the server connection, reconnect if needed.\n\t *\n\t * This function will try to ping the server if we are connected, and try\n\t * to reestablish a connection otherwise.\n\t */\n\tpublic void sendServerPing() {\n\t\tif (mXMPPConnection == null || !mXMPPConnection.isAuthenticated()) {\n\t\t\tdebugLog(\"Ping: requested, but not connected to server.\");\n\t\t\trequestConnectionState(ConnectionState.ONLINE, false);\n\t\t\treturn;\n\t\t}\n\t\tif (mPingID != null) {\n\t\t\tdebugLog(\"Ping: requested, but still waiting for \" + mPingID);\n\t\t\treturn; // a ping is still on its way\n\t\t}\n\n\t\tif (mStreamHandler.isSmEnabled()) {\n\t\t\tdebugLog(\"Ping: sending SM request\");\n\t\t\tmPingID = \"\" + mStreamHandler.requestAck();\n\t\t} else {\n\t\t\tPing ping = new Ping();\n\t\t\tping.setType(Type.GET);\n\t\t\tping.setTo(mConfig.server);\n\t\t\tmPingID = ping.getPacketID();\n\t\t\tdebugLog(\"Ping: sending ping \" + mPingID);\n\t\t\tmXMPPConnection.sendPacket(ping);\n\t\t}\n\n\t\t// register ping timeout handler: PACKET_TIMEOUT(30s) + 3s\n\t\tregisterPongTimeout(PACKET_TIMEOUT + 3000, mPingID);\n\t}\n\n\tprivate void gotServerPong(String pongID) {\n\t\tlong latency = System.currentTimeMillis() - mPingTimestamp;\n\t\tif (pongID != null && pongID.equals(mPingID))\n\t\t\tLog.i(TAG, String.format(\"Ping: server latency %1.3fs\",\n\t\t\t\t\t\tlatency/1000.));\n\t\telse\n\t\t\tLog.i(TAG, String.format(\"Ping: server latency %1.3fs (estimated)\",\n\t\t\t\t\t\tlatency/1000.));\n\t\tmPingID = null;\n\t\tmAlarmManager.cancel(mPongTimeoutAlarmPendIntent);\n\t}\n\n\t/** Register a \"pong\" timeout on the connection. */\n\tprivate void registerPongTimeout(long wait_time, String id) {\n\t\tmPingID = id;\n\t\tmPingTimestamp = System.currentTimeMillis();\n\t\tdebugLog(String.format(\"Ping: registering timeout for %s: %1.3fs\", id, wait_time/1000.));\n\t\tmAlarmManager.set(AlarmManager.RTC_WAKEUP,\n\t\t\t\tSystem.currentTimeMillis() + wait_time,\n\t\t\t\tmPongTimeoutAlarmPendIntent);\n\t}\n\n\t/**\n\t * BroadcastReceiver to trigger reconnect on pong timeout.\n\t */\n\tprivate class PongTimeoutAlarmReceiver extends BroadcastReceiver {\n\t\tpublic void onReceive(Context ctx, Intent i) {\n\t\t\tdebugLog(\"Ping: timeout for \" + mPingID);\n\t\t\tonDisconnected(mService.getString(R.string.conn_ping_timeout));\n\t\t}\n\t}\n\n\t/**\n\t * BroadcastReceiver to trigger sending pings to the server\n\t */\n\tprivate class PingAlarmReceiver extends BroadcastReceiver {\n\t\tpublic void onReceive(Context ctx, Intent i) {\n\t\t\t\tsendServerPing();\n\t\t\t\t// ping all MUCs. if no ping was received since last attempt, /cycle\n\t\t\t\tIterator<MultiUserChat> muc_it = multiUserChats.values().iterator();\n\t\t\t\tlong ts = System.currentTimeMillis();\n\t\t\t\tContentValues cvR = new ContentValues();\n\t\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, mService.getString(R.string.conn_ping_timeout));\n\t\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.offline.ordinal());\n\t\t\t\tcvR.put(RosterProvider.RosterConstants.GROUP, RosterProvider.RosterConstants.MUCS);\n\t\t\t\twhile (muc_it.hasNext()) {\n\t\t\t\t\tMultiUserChat muc = muc_it.next();\n\t\t\t\t\tif (!muc.isJoined())\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tLong lastPong = mucLastPong.get(muc.getRoom());\n\t\t\t\t\tif (mucLastPing > 0 && (lastPong == null || lastPong < mucLastPing)) {\n\t\t\t\t\t\tdebugLog(\"Ping timeout from \" + muc.getRoom());\n\t\t\t\t\t\tmuc.leave();\n\t\t\t\t\t\tupsertRoster(cvR, muc.getRoom());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tPing ping = new Ping();\n\t\t\t\t\t\tping.setType(Type.GET);\n\t\t\t\t\t\tString jid = muc.getRoom() + \"/\" + muc.getNickname();\n\t\t\t\t\t\tping.setTo(jid);\n\t\t\t\t\t\tmPingID = ping.getPacketID();\n\t\t\t\t\t\tdebugLog(\"Ping: sending ping to \" + jid);\n\t\t\t\t\t\tmXMPPConnection.sendPacket(ping);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsyncDbRooms();\n\t\t\t\tmucLastPing = ts;\n\n\t\t}\n\t}\n\n\t/**\n\t * Registers a smack packet listener for IQ packets, intended to recognize \"pongs\" with\n\t * a packet id matching the last \"ping\" sent to the server.\n\t *\n\t * Also sets up the AlarmManager Timer plus necessary intents.\n\t */\n\tprivate void registerPongListener() {\n\t\t// reset ping expectation on new connection\n\t\tmPingID = null;\n\n\t\tif (mPongListener != null)\n\t\t\tmXMPPConnection.removePacketListener(mPongListener);\n\n\t\tmPongListener = new PacketListener() {\n\n\t\t\t@Override\n\t\t\tpublic void processPacket(Packet packet) {\n\t\t\t\tif (packet == null) return;\n\n\t\t\t\tif (packet instanceof IQ && packet.getFrom() != null) {\n\t\t\t\t\tIQ ping = (IQ)packet;\n\t\t\t\t\tString from_bare = getBareJID(ping.getFrom());\n\t\t\t\t\t// check for ping error or RESULT\n\t\t\t\t\tif (ping.getType() == Type.RESULT && mucJIDs.contains(from_bare)) {\n\t\t\t\t\t\tLog.d(TAG, \"Ping: got response from MUC \" + from_bare);\n\t\t\t\t\t\tmucLastPong.put(from_bare, System.currentTimeMillis());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mPingID != null && mPingID.equals(packet.getPacketID()))\n\t\t\t\t\tgotServerPong(packet.getPacketID());\n\n\t\t\t}\n\n\t\t};\n\n\t\tmXMPPConnection.addPacketListener(mPongListener, new PacketTypeFilter(IQ.class));\n\t\tmPingAlarmPendIntent = PendingIntent.getBroadcast(mService.getApplicationContext(), 0, mPingAlarmIntent,\n\t\t\t\t\tPendingIntent.FLAG_UPDATE_CURRENT);\n\t\tmPongTimeoutAlarmPendIntent = PendingIntent.getBroadcast(mService.getApplicationContext(), 0, mPongTimeoutAlarmIntent,\n\t\t\t\t\tPendingIntent.FLAG_UPDATE_CURRENT);\n\t\tmAlarmManager.setInexactRepeating(AlarmManager.RTC_WAKEUP, \n\t\t\t\tSystem.currentTimeMillis() + AlarmManager.INTERVAL_FIFTEEN_MINUTES, AlarmManager.INTERVAL_FIFTEEN_MINUTES, mPingAlarmPendIntent);\n\t}\n\tprivate void unregisterPongListener() {\n\t\tmAlarmManager.cancel(mPingAlarmPendIntent);\n\t\tmAlarmManager.cancel(mPongTimeoutAlarmPendIntent);\n\t}\n\n\tprivate void registerMessageListener() {\n\t\t// do not register multiple packet listeners\n\t\tif (mPacketListener != null)\n\t\t\tmXMPPConnection.removePacketListener(mPacketListener);\n\n\t\tPacketTypeFilter filter = new PacketTypeFilter(Message.class);\n\n\t\tmPacketListener = new PacketListener() {\n\t\t\tpublic void processPacket(Packet packet) {\n\t\t\t\ttry {\n\t\t\t\tif (packet instanceof Message) {\n\t\t\t\t\tMessage msg = (Message) packet;\n\n\t\t\t\t\tString[] fromJID = getJabberID(msg.getFrom());\n\t\t\t\t\t\n\t\t\t\t\tint direction = ChatConstants.INCOMING;\n\t\t\t\t\tCarbon cc = CarbonManager.getCarbon(msg);\n\t\t\t\t\tif (cc != null && !msg.getFrom().equalsIgnoreCase(mConfig.jabberID)) {\n\t\t\t\t\t\tLog.w(TAG, \"Received illegal carbon from \" + msg.getFrom() + \": \" + cc.toXML());\n\t\t\t\t\t\tcc = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// extract timestamp\n\t\t\t\t\tlong ts;\n\t\t\t\t\tDelayInfo timestamp = (DelayInfo)msg.getExtension(\"delay\", \"urn:xmpp:delay\");\n\t\t\t\t\tif (timestamp == null)\n\t\t\t\t\t\ttimestamp = (DelayInfo)msg.getExtension(\"x\", \"jabber:x:delay\");\n\t\t\t\t\tif (cc != null) // Carbon timestamp overrides packet timestamp\n\t\t\t\t\t\ttimestamp = cc.getForwarded().getDelayInfo();\n\t\t\t\t\tif (timestamp != null)\n\t\t\t\t\t\tts = timestamp.getStamp().getTime();\n\t\t\t\t\telse\n\t\t\t\t\t\tts = System.currentTimeMillis();\n\n\t\t\t\t\t// try to extract a carbon\n\t\t\t\t\tif (cc != null) {\n\t\t\t\t\t\tLog.d(TAG, \"carbon: \" + cc.toXML());\n\t\t\t\t\t\tmsg = (Message)cc.getForwarded().getForwardedPacket();\n\n\t\t\t\t\t\t// outgoing carbon: fromJID is actually chat peer's JID\n\t\t\t\t\t\tif (cc.getDirection() == Carbon.Direction.sent) {\n\t\t\t\t\t\t\tfromJID = getJabberID(msg.getTo());\n\t\t\t\t\t\t\tdirection = ChatConstants.OUTGOING;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfromJID = getJabberID(msg.getFrom());\n\n\t\t\t\t\t\t\t// hook off carbonated delivery receipts\n\t\t\t\t\t\t\tDeliveryReceipt dr = (DeliveryReceipt)msg.getExtension(\n\t\t\t\t\t\t\t\t\tDeliveryReceipt.ELEMENT, DeliveryReceipt.NAMESPACE);\n\t\t\t\t\t\t\tif (dr != null) {\n\t\t\t\t\t\t\t\tLog.d(TAG, \"got CC'ed delivery receipt for \" + dr.getId());\n\t\t\t\t\t\t\t\tchangeMessageDeliveryStatus(dr.getId(), ChatConstants.DS_ACKED);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// ignore carbon copies of OTR messages sent by broken clients\n\t\t\t\t\t\tif (msg.getBody() != null && msg.getBody().startsWith(\"?OTR\")) {\n\t\t\t\t\t\t\tLog.i(TAG, \"Ignoring OTR carbon from \" + msg.getFrom() + \" to \" + msg.getTo());\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// check for jabber MUC invitation\n\t\t\t\t\tif(direction == ChatConstants.INCOMING && handleMucInvitation(msg)) {\n\t\t\t\t\t\tsendReceiptIfRequested(packet);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tString chatMessage = msg.getBody();\n\n\t\t\t\t\t// display error inline\n\t\t\t\t\tif (msg.getType() == Message.Type.error) {\n\t\t\t\t\t\tif (changeMessageDeliveryStatus(msg.getPacketID(), ChatConstants.DS_FAILED))\n\t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, msg.getError().toString(), (cc != null), Message.Type.error);\n\t\t\t\t\t\telse if (mucJIDs.contains(msg.getFrom())) {\n\t\t\t\t\t\t\thandleKickedFromMUC(msg.getFrom(), false, null,\n\t\t\t\t\t\t\t\t\tmsg.getError().toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn; // we do not want to add errors as \"incoming messages\"\n\t\t\t\t\t}\n\n\t\t\t\t\t// ignore empty messages\n\t\t\t\t\tif (chatMessage == null) {\n\t\t\t\t\t\tif (msg.getSubject() != null && msg.getType() == Message.Type.groupchat\n\t\t\t\t\t\t\t\t&& mucJIDs.contains(fromJID[0])) {\n\t\t\t\t\t\t\t// this is a MUC subject, update our DB\n\t\t\t\t\t\t\tContentValues cvR = new ContentValues();\n\t\t\t\t\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, msg.getSubject());\n\t\t\t\t\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.available.ordinal());\n\t\t\t\t\t\t\tLog.d(TAG, \"MUC subject for \" + fromJID[0] + \" set to: \" + msg.getSubject());\n\t\t\t\t\t\t\tupsertRoster(cvR, fromJID[0]);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLog.d(TAG, \"empty message.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// obtain Last Message Correction, if present\n\t\t\t\t\tReplace replace = (Replace)msg.getExtension(Replace.NAMESPACE);\n\t\t\t\t\tString replace_id = (replace != null) ? replace.getId() : null;\n\n\t\t\t\t\t// carbons are old. all others are new\n\t\t\t\t\tint is_new = (cc == null) ? ChatConstants.DS_NEW : ChatConstants.DS_SENT_OR_READ;\n\t\t\t\t\tif (msg.getType() == Message.Type.error)\n\t\t\t\t\t\tis_new = ChatConstants.DS_FAILED;\n\n\t\t\t\t\tboolean is_muc = (msg.getType() == Message.Type.groupchat);\n\t\t\t\t\tboolean is_from_me = (direction == ChatConstants.OUTGOING) ||\n\t\t\t\t\t\t(is_muc && fromJID[1].equals(getMyMucNick(fromJID[0])));\n\n\t\t\t\t\t// handle MUC-PMs: messages from a nick from a known MUC or with\n\t\t\t\t\t// an <x> element\n\t\t\t\t\tMUCUser muc_x = (MUCUser)msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n\t\t\t\t\tboolean is_muc_pm = !is_muc  && !TextUtils.isEmpty(fromJID[1]) &&\n\t\t\t\t\t\t\t(muc_x != null || mucJIDs.contains(fromJID[0]));\n\n\t\t\t\t\t// TODO: ignoring 'received' MUC-PM carbons, until XSF sorts out shit:\n\t\t\t\t\t// - if yaxim is in the MUC, it will receive a non-carbonated copy of\n\t\t\t\t\t//   incoming messages, but not of outgoing ones\n\t\t\t\t\t// - if yaxim isn't in the MUC, it can't respond anyway\n\t\t\t\t\tif (is_muc_pm && !is_from_me && cc != null)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tif (is_muc_pm) {\n\t\t\t\t\t\t// store MUC-PMs under the participant's full JID, not bare\n\t\t\t\t\t\t//is_from_me = fromJID[1].equals(getMyMucNick(fromJID[0]));\n\t\t\t\t\t\tfromJID[0] = fromJID[0] + \"/\" + fromJID[1];\n\t\t\t\t\t\tfromJID[1] = null;\n\t\t\t\t\t\tLog.d(TAG, \"MUC-PM: \" + fromJID[0] + \" d=\" + direction + \" fromme=\" + is_from_me);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Carbons and MUC history are 'silent' by default\n\t\t\t\t\tboolean is_silent = (cc != null) || (is_muc && timestamp != null);\n\n\t\t\t\t\tif (!is_muc || checkAddMucMessage(msg, msg.getPacketID(), fromJID, timestamp)) {\n\t\t\t\t\t\taddChatMessageToDB(direction, fromJID, chatMessage, is_new, ts, msg.getPacketID(), replace_id);\n\t\t\t\t\t\t// only notify on private messages or when MUC notification requested\n\t\t\t\t\t\tboolean need_notify = !is_muc || mConfig.needMucNotification(getMyMucNick(fromJID[0]), chatMessage);\n\t\t\t\t\t\t// outgoing carbon -> clear notification by signalling 'null' message\n\t\t\t\t\t\tif (is_from_me) {\n\t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, null, true, msg.getType());\n\t\t\t\t\t\t\t// TODO: MUC PMs\n\t\t\t\t\t\t\tChatHelper.markAsRead(mService, fromJID[0]);\n\t\t\t\t\t\t} else if (direction == ChatConstants.INCOMING && need_notify)\n\t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, chatMessage, is_silent, msg.getType());\n\t\t\t\t\t}\n\t\t\t\t\tsendReceiptIfRequested(packet);\n\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// SMACK silently discards exceptions dropped from processPacket :(\n\t\t\t\t\tLog.e(TAG, \"failed to process packet:\");\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tmXMPPConnection.addPacketListener(mPacketListener, filter);\n\t}\n\n\tprivate boolean checkAddMucMessage(Message msg, String packet_id, String[] fromJid, DelayInfo timestamp) {\n\t\tString muc = fromJid[0];\n\t\tString nick = fromJid[1];\n\n\t\t// HACK: remove last outgoing message instead of upserting\n\t\tif (nick.equals(getMyMucNick(muc)))\n\t\t\tmContentResolver.delete(ChatProvider.CONTENT_URI,\n\t\t\t\t\"jid = ? AND from_me = 1 AND (pid = ? OR message = ?) AND \" +\n\t\t\t\t\"_id >= (SELECT MIN(_id) FROM chats WHERE jid = ? ORDER BY _id DESC LIMIT 50)\",\n\t\t\t\tnew String[] { muc, packet_id, msg.getBody(), muc });\n\n\t\t// messages with no timestamp are always new\n\t\tif (timestamp == null)\n\t\t\treturn true;\n\n\t\tlong ts = timestamp.getStamp().getTime();\n\n\t\tfinal String[] projection = new String[] {\n\t\t\t\tChatConstants._ID, ChatConstants.MESSAGE,\n\t\t\t\tChatConstants.JID, ChatConstants.RESOURCE,\n\t\t\t\tChatConstants.PACKET_ID\n\t\t};\n\n\t\tif (packet_id == null) packet_id = \"\";\n\t\tfinal String selection = \"resource = ? AND (pid = ? OR date = ? OR message = ?) AND _id >= (SELECT MIN(_id) FROM chats WHERE jid = ? ORDER BY _id DESC LIMIT 50)\";\n\t\tfinal String[] selectionArgs = new String[] { nick, packet_id, \"\"+ts, msg.getBody(), muc };\n\t\ttry {\n\t\t\tCursor cursor = mContentResolver.query(ChatProvider.CONTENT_URI, projection, selection, selectionArgs, null);\n\t\t\tLog.d(TAG, \"message from \" + nick + \" matched \" + cursor.getCount() + \" items.\");\n\t\t\tboolean result = (cursor.getCount() == 0);\n\t\t\tcursor.close();\n\t\t\treturn result;\n\t\t} catch (Exception e) { e.printStackTrace(); } // just return true...\n\t\treturn true;\t\n\t}\n\n\tprivate void handleKickedFromMUC(String room, boolean banned, String actor, String reason) {\n\t\tmucLastPong.remove(room);\n\t\tContentValues cvR = new ContentValues();\n\t\tString message;\n\t\tif (actor != null && actor.length() > 0)\n\t\t\tmessage = mService.getString(banned ? R.string.muc_banned_by : R.string.muc_kicked_by,\n\t\t\t\t\tactor, reason);\n\t\telse\n\t\t\tmessage = mService.getString(banned ? R.string.muc_banned : R.string.muc_kicked,\n\t\t\t\t\treason);\n\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, message);\n\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.offline.ordinal());\n\t\tupsertRoster(cvR, room);\n\t}\n\n\t@Override\n\tpublic String getMyMucNick(String jid) {\n\t\tMultiUserChat muc = multiUserChats.get(jid);\n\t\tif (muc != null && muc.getNickname() != null)\n\t\t\treturn muc.getNickname();\n\t\tif (mucJIDs.contains(jid)) {\n\t\t\tChatRoomHelper.RoomInfo ri = ChatRoomHelper.getRoomInfo(mService, jid);\n\t\t\tif (ri != null)\n\t\t\t\treturn ri.nickname;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate void registerPresenceListener() {\n\t\t// do not register multiple packet listeners\n\t\tif (mPresenceListener != null)\n\t\t\tmXMPPConnection.removePacketListener(mPresenceListener);\n\n\t\tmPresenceListener = new PacketListener() {\n\t\t\tpublic void processPacket(Packet packet) {\n\t\t\t\ttry {\n\t\t\t\t\tPresence p = (Presence) packet;\n\t\t\t\t\tswitch (p.getType()) {\n\t\t\t\t\tcase subscribe:\n\t\t\t\t\t\thandleIncomingSubscribe(p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase subscribed:\n\t\t\t\t\tcase unsubscribe:\n\t\t\t\t\tcase unsubscribed:\n\t\t\t\t\t\tsubscriptionRequests.remove(p.getFrom());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// SMACK silently discards exceptions dropped from processPacket :(\n\t\t\t\t\tLog.e(TAG, \"failed to process presence:\");\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tmXMPPConnection.addPacketListener(mPresenceListener, new PacketTypeFilter(Presence.class));\n\t}\n\n\tprivate void addChatMessageToDB(int direction, String[] tJID,\n\t\t\tString message, int delivery_status, long ts, String packetID, String replaceID) {\n\t\tContentValues values = new ContentValues();\n\n\t\tvalues.put(ChatConstants.DIRECTION, direction);\n\t\tvalues.put(ChatConstants.JID, tJID[0]);\n\t\tvalues.put(ChatConstants.RESOURCE, tJID[1]);\n\t\tvalues.put(ChatConstants.MESSAGE, message);\n\t\tvalues.put(ChatConstants.DELIVERY_STATUS, delivery_status);\n\t\tvalues.put(ChatConstants.DATE, ts);\n\t\tvalues.put(ChatConstants.PACKET_ID, packetID);\n\n\t\tif (replaceID != null) {\n\t\t\t// obtain row id for last message with that full JID, or -1\n\t\t\tlong _id = getRowIdForMessage(tJID[0], tJID[1], direction, replaceID);\n\t\t\tLog.d(TAG, \"Replacing last message from \" + tJID[0] + \"/\" + tJID[1] + \": \" + replaceID + \" -> \" + packetID);\n\t\t\tUri row = Uri.withAppendedPath(ChatProvider.CONTENT_URI, \"\" + _id);\n\t\t\tif (_id >= 0 && mContentResolver.update(row, values, null, null) == 1)\n\t\t\t\treturn;\n\t\t}\n\t\tmContentResolver.insert(ChatProvider.CONTENT_URI, values);\n\t}\n\n\tprivate void addChatMessageToDB(int direction, String JID,\n\t\t\tString message, int delivery_status, long ts, String packetID) {\n\t\tString[] tJID = {JID, \"\"};\n\t\taddChatMessageToDB(direction, tJID, message, delivery_status, ts, packetID, null);\n\t}\n\n\tprivate ContentValues getContentValuesForRosterEntry(final RosterEntry entry) {\n\t\tPresence presence = mRoster.getPresence(entry.getUser());\n\t\treturn getContentValuesForRosterEntry(entry, presence);\n\t}\n\n\tprivate ContentValues getContentValuesForRosterEntry(final RosterEntry entry, Presence presence) {\n\t\tfinal ContentValues values = new ContentValues();\n\n\t\tvalues.put(RosterConstants.JID, entry.getUser());\n\t\tvalues.put(RosterConstants.ALIAS, getName(entry));\n\n\t\t// handle subscription requests and errors with higher priority\n\t\tPresence sub = subscriptionRequests.get(entry.getUser());\n\t\tif (presence.getType() == Presence.Type.error) {\n\t\t\tString error = presence.getError().getMessage();\n\t\t\tif (error == null || error.length() == 0)\n\t\t\t\terror = presence.getError().toString();\n\t\t\tvalues.put(RosterConstants.STATUS_MESSAGE, error);\n\t\t} else if (sub != null) {\n\t\t\tpresence = sub;\n\t\t\tvalues.put(RosterConstants.STATUS_MESSAGE, presence.getStatus());\n\t\t} else switch (entry.getType()) {\n\t\tcase to:\n\t\tcase both:\n\t\t\t// override received presence from roster, using highest-prio entry\n\t\t\tpresence = mRoster.getPresence(entry.getUser());\n\t\t\tvalues.put(RosterConstants.STATUS_MESSAGE, presence.getStatus());\n\t\t\tbreak;\n\t\tcase from:\n\t\t\tvalues.put(RosterConstants.STATUS_MESSAGE, mService.getString(R.string.subscription_status_from));\n\t\t\tpresence = null;\n\t\t\tbreak;\n\t\tcase none:\n\t\t\tvalues.put(RosterConstants.STATUS_MESSAGE, \"\");\n\t\t\tpresence = null;\n\t\t}\n\t\tvalues.put(RosterConstants.STATUS_MODE, getStatusInt(presence));\n\t\tvalues.put(RosterConstants.GROUP, getGroup(entry.getGroups()));\n\n\t\treturn values;\n\t}\n\n\tprivate void deleteRosterEntryFromDB(final String jabberID) {\n\t\tint count = mContentResolver.delete(RosterProvider.CONTENT_URI,\n\t\t\t\tRosterConstants.JID + \" = ?\", new String[] { jabberID });\n\t\tdebugLog(\"deleteRosterEntryFromDB: Deleted \" + count + \" entries\");\n\t}\n\n\tprivate void updateRosterEntryInDB(final RosterEntry entry) {\n\t\tupsertRoster(getContentValuesForRosterEntry(entry), entry.getUser());\n\t}\n\n\tprivate void upsertRoster(final ContentValues values, String jid) {\n\t\tif (mContentResolver.update(RosterProvider.CONTENT_URI, values,\n\t\t\t\tRosterConstants.JID + \" = ?\", new String[] { jid }) == 0) {\n\t\t\tmContentResolver.insert(RosterProvider.CONTENT_URI, values);\n\t\t}\n\t}\n\n\tprivate String getGroup(Collection<RosterGroup> groups) {\n\t\tfor (RosterGroup group : groups) {\n\t\t\treturn group.getName();\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tprivate String getName(RosterEntry rosterEntry) {\n\t\tString name = rosterEntry.getName();\n\t\tif (name != null && name.length() > 0) {\n\t\t\treturn name;\n\t\t}\n\t\treturn rosterEntry.getUser();\n\t}\n\n\tprivate StatusMode getStatus(Presence presence) {\n\t\tif (presence == null)\n\t\t\treturn StatusMode.unknown;\n\t\tif (presence.getType() == Presence.Type.subscribe)\n\t\t\treturn StatusMode.subscribe;\n\t\tif (presence.getType() == Presence.Type.available) {\n\t\t\tif (presence.getMode() != null) {\n\t\t\t\treturn StatusMode.valueOf(presence.getMode().name());\n\t\t\t}\n\t\t\treturn StatusMode.available;\n\t\t}\n\t\treturn StatusMode.offline;\n\t}\n\n\tprivate int getStatusInt(final Presence presence) {\n\t\treturn getStatus(presence).ordinal();\n\t}\n\n\tprivate void debugLog(String data) {\n\t\tif (LogConstants.LOG_DEBUG) {\n\t\t\tLog.d(TAG, data);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getLastError() {\n\t\treturn mLastError;\n\t}\n\n\tprivate synchronized void cleanupMUCs(boolean set_offline) {\n\t\t// get a fresh MUC list\n\t\tCursor cursor = mContentResolver.query(RosterProvider.MUCS_URI,\n\t\t\t\tnew String[] { RosterProvider.RosterConstants.JID },\n\t\t\t\tnull, null, null);\n\t\tmucJIDs.clear();\n\t\twhile(cursor.moveToNext()) {\n\t\t\tmucJIDs.add(cursor.getString(0));\n\t\t}\n\t\tcursor.close();\n\n\t\t// delete removed MUCs\n\t\tStringBuilder exclusion = new StringBuilder(RosterProvider.RosterConstants.GROUP + \" = ? AND \"\n\t\t\t\t+ RosterConstants.JID + \" NOT IN ('\");\n\t\texclusion.append(TextUtils.join(\"', '\", mucJIDs));\n\t\texclusion.append(\"');\");\n\t\tmContentResolver.delete(RosterProvider.CONTENT_URI,\n\t\t\t\texclusion.toString(),\n\t\t\t\tnew String[] { RosterProvider.RosterConstants.MUCS });\n\t\tif (set_offline) {\n\t\t\t// update all other MUCs as offline\n\t\t\tContentValues values = new ContentValues();\n\t\t\tvalues.put(RosterConstants.STATUS_MODE, StatusMode.offline.ordinal());\n\t\t\tmContentResolver.update(RosterProvider.CONTENT_URI, values, RosterProvider.RosterConstants.GROUP + \" = ?\",\n\t\t\t\t\tnew String[] { RosterProvider.RosterConstants.MUCS });\n\t\t}\n\t}\n\n\tpublic synchronized void syncDbRooms() {\n\t\tif (!isAuthenticated()) {\n\t\t\tdebugLog(\"syncDbRooms: aborting, not yet authenticated\");\n\t\t}\n\n\t\tjava.util.Set<String> joinedRooms = multiUserChats.keySet();\n\t\tCursor cursor = mContentResolver.query(RosterProvider.MUCS_URI, \n\t\t\t\tnew String[] {RosterProvider.RosterConstants._ID,\n\t\t\t\t\tRosterProvider.RosterConstants.JID, \n\t\t\t\t\tRosterProvider.RosterConstants.PASSWORD, \n\t\t\t\t\tRosterProvider.RosterConstants.NICKNAME}, \n\t\t\t\tnull, null, null);\n\t\tfinal int ID = cursor.getColumnIndexOrThrow(RosterProvider.RosterConstants._ID);\n\t\tfinal int JID_ID = cursor.getColumnIndexOrThrow(RosterProvider.RosterConstants.JID);\n\t\tfinal int PASSWORD_ID = cursor.getColumnIndexOrThrow(RosterProvider.RosterConstants.PASSWORD);\n\t\tfinal int NICKNAME_ID = cursor.getColumnIndexOrThrow(RosterProvider.RosterConstants.NICKNAME);\n\t\t\n\t\tmucJIDs.clear();\n\t\twhile(cursor.moveToNext()) {\n\t\t\tint id = cursor.getInt(ID);\n\t\t\tString jid = cursor.getString(JID_ID);\n\t\t\tString password = cursor.getString(PASSWORD_ID);\n\t\t\tString nickname = cursor.getString(NICKNAME_ID);\n\t\t\tmucJIDs.add(jid);\n\t\t\t//debugLog(\"Found MUC Room: \"+jid+\" with nick \"+nickname+\" and pw \"+password);\n\t\t\tif(!joinedRooms.contains(jid) || !multiUserChats.get(jid).isJoined()) {\n\t\t\t\tdebugLog(\"room \" + jid + \" isn't joined yet, i wanna join...\");\n\t\t\t\tjoinRoomAsync(jid, nickname, password); // TODO: make historyLen configurable\n\t\t\t} else {\n\t\t\t\tMultiUserChat muc = multiUserChats.get(jid);\n\t\t\t\tif (!muc.getNickname().equals(nickname)) {\n\t\t\t\t\tdebugLog(\"room \" + jid + \": changing nickname to \" + nickname);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmuc.changeNickname(nickname);\n\t\t\t\t\t} catch (XMPPException e) {\n\t\t\t\t\t\tLog.e(TAG, \"Changing nickname failed.\");\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//debugLog(\"found data in contentprovider: \"+jid+\" \"+password+\" \"+nickname);\n\t\t}\n\t\tcursor.close();\n\t\t\n\t\tfor(String room : new HashSet<String>(joinedRooms)) {\n\t\t\tif(!mucJIDs.contains(room)) {\n\t\t\t\tquitRoom(room);\n\t\t\t}\n\t\t}\n\t\tcleanupMUCs(false);\n\t}\n\t\n\tprotected boolean handleMucInvitation(Message msg) {\n\t\tString room;\n\t\tString inviter = null;\n\t\tString reason = null;\n\t\tString password = null;\n\t\t\n\t\tMUCUser mucuser = (MUCUser)msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n\t\tGroupChatInvitation direct = (GroupChatInvitation)msg.getExtension(GroupChatInvitation.ELEMENT_NAME, GroupChatInvitation.NAMESPACE);\n\t\tif (mucuser != null && mucuser.getInvite() != null) {\n\t\t\t// first try official XEP-0045 mediated invitation\n\t\t\tMUCUser.Invite invite = mucuser.getInvite();\n\t\t\troom = msg.getFrom();\n\t\t\tinviter = invite.getFrom();\n\t\t\treason = invite.getReason();\n\t\t\tpassword = mucuser.getPassword();\n\t\t} else if (direct != null) {\n\t\t\t// fall back to XEP-0249 direct invitation\n\t\t\troom = direct.getRoomAddress();\n\t\t\tinviter = msg.getFrom();\n\t\t\t// TODO: get reason from direct invitation, not supported in smack3\n\t\t} else return false; // not a MUC invitation\n\n\t\tif (mucJIDs.contains(room)) {\n\t\t\tLog.i(TAG, \"Ignoring invitation to known MUC \" + room);\n\t\t\treturn true;\n\t\t}\n\t\tLog.d(TAG, \"MUC invitation from \" + inviter + \" to \" + room);\n\t\tasyncProcessMucInvitation(room, inviter, reason, password);\n\t\treturn true;\n\t}\n\n\tprotected void asyncProcessMucInvitation(final String room, final String inviter,\n\t\t\tfinal String reason, final String password) {\n\t\tnew Thread() {\n\t\t\tpublic void run() {\n\t\t\t\tprocessMucInvitation(room, inviter, reason, password);\n\t\t\t}\n\t\t}.start();\n\t}\n\tprotected void processMucInvitation(final String room, final String inviter,\n\t\t\tfinal String reason, final String password) {\n\t\tString roomname = room;\n\t\tString inviter_name = null;\n\t\tif (getBareJID(inviter).equalsIgnoreCase(room)) {\n\t\t\t// from == participant JID, display as \"user (MUC)\"\n\t\t\tinviter_name = getNameForJID(inviter);\n\t\t} else {\n\t\t\t// from == user bare or full JID\n\t\t\tinviter_name = getNameForJID(getBareJID(inviter));\n\t\t}\n\t\tString description = null;\n\t\tString inv_from = mService.getString(R.string.muc_invitation_from,\n\t\t\t\tinviter_name);\n\n\t\t// query room for info\n\t\ttry {\n\t\t\tLog.d(TAG, \"Requesting disco#info from \" + room);\n\t\t\tRoomInfo ri = MultiUserChat.getRoomInfo(mXMPPConnection, room);\n\t\t\tString rn = ri.getRoomName();\n\t\t\tif (rn != null && rn.length() > 0)\n\t\t\t\troomname = String.format(\"%s (%s)\", rn, roomname);\n\t\t\tdescription = ri.getSubject();\n\t\t\tif (!TextUtils.isEmpty(description))\n\t\t\t\tdescription = ri.getDescription();\n\t\t\tdescription = mService.getString(R.string.muc_invitation_occupants,\n\t\t\t\t\tdescription, ri.getOccupantsCount());\n\t\t\tLog.d(TAG, \"MUC name after disco: \" + roomname);\n\t\t} catch (XMPPException e) {\n\t\t\t// ignore a failed room info request\n\t\t\tLog.d(TAG, \"MUC room IQ failed: \" + room);\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tmServiceCallBack.mucInvitationReceived(\n\t\t\t\troomname,\n\t\t\t\troom,\n\t\t\t\tpassword,\n\t\t\t\tinv_from,\n\t\t\t\tdescription);\n\t}\n\t\n\tprivate Map<String,Runnable> ongoingMucJoins = new java.util.concurrent.ConcurrentHashMap<String, Runnable>();\n\tprivate synchronized void joinRoomAsync(final String room, final String nickname, final String password) {\n\t\tif (ongoingMucJoins.containsKey(room))\n\t\t\treturn;\n\t\tThread joiner = new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tLog.d(TAG, \"async joining \" + room);\n\t\t\t\tboolean result = joinRoom(room, nickname, password);\n\t\t\t\tLog.d(TAG, \"async joining \" + room + \" done: \" + result);\n\t\t\t\tongoingMucJoins.remove(room);\n\t\t\t}\n\t\t};\n\t\tongoingMucJoins.put(room, joiner);\n\t\tjoiner.start();\n\t}\n\n\tprivate boolean joinRoom(final String room, String nickname, String password) {\n\t\t// work around smack3 bug: can't rejoin with \"used\" MultiUserChat instance\n\t\tMultiUserChat muc = new MultiUserChat(mXMPPConnection, room);\n\t\tLog.d(TAG, \"created new MUC instance: \" + room + \" \" + muc);\n\t\tmuc.addUserStatusListener(new org.jivesoftware.smackx.muc.DefaultUserStatusListener() {\n\t\t\t@Override\n\t\t\tpublic void kicked(String actor, String reason) {\n\t\t\t\tdebugLog(\"Kicked from \" + room + \" by \" + actor + \": \" + reason);\n\t\t\t\thandleKickedFromMUC(room, false, actor, reason);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void banned(String actor, String reason) {\n\t\t\t\tdebugLog(\"Banned from \" + room + \" by \" + actor + \": \" + reason);\n\t\t\t\thandleKickedFromMUC(room, true, actor, reason);\n\t\t\t}\n\t\t});\n\t\t\n\t\tDiscussionHistory history = new DiscussionHistory();\n\t\tfinal String[] projection = new String[] {\n\t\t\t\tChatConstants._ID, ChatConstants.DATE\n\t\t};\n\t\tCursor cursor = mContentResolver.query(ChatProvider.CONTENT_URI, projection, \n\t\t\t\tChatConstants.JID + \" = ? AND \" +\n\t\t\t\tChatConstants.DELIVERY_STATUS + \" = \" +\n\t\t\t\tChatConstants.DS_SENT_OR_READ, new String[] { room }, \"_id DESC LIMIT 1\");\n\t\tif(cursor.getCount()>0) {\n\t\t\tcursor.moveToFirst();\n\t\t\tDate lastDate = new Date(cursor.getLong(1));\n\t\t\tLog.d(TAG, \"Getting room history for \" + room + \" starting at \" + lastDate);\n\t\t\thistory.setSince(lastDate);\n\t\t} else Log.d(TAG, \"No last message for \" + room);\n\t\tcursor.close();\n\t\t\n\t\tContentValues cvR = new ContentValues();\n\t\tcvR.put(RosterProvider.RosterConstants.JID, room);\n\t\tcvR.put(RosterProvider.RosterConstants.ALIAS, room);\n\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, mService.getString(R.string.muc_synchronizing));\n\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.dnd.ordinal());\n\t\tcvR.put(RosterProvider.RosterConstants.GROUP, RosterProvider.RosterConstants.MUCS);\n\t\tupsertRoster(cvR, room);\n\t\tcvR.clear();\n\t\ttry {\n\t\t\tPresence force_resync = new Presence(Presence.Type.unavailable);\n\t\t\tforce_resync.setTo(room + \"/\" + nickname);\n\t\t\tmXMPPConnection.sendPacket(force_resync);\n\t\t\tmuc.join(nickname, password, history, 10*PACKET_TIMEOUT);\n\t\t} catch (Exception e) {\n\t\t\tLog.e(TAG, \"Could not join MUC-room \"+room);\n\t\t\te.printStackTrace();\n\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, mService.getString(R.string.conn_error, e.getLocalizedMessage()));\n\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.offline.ordinal());\n\t\t\tupsertRoster(cvR, room);\n\t\t\treturn false;\n\t\t}\n\n\t\tif(muc.isJoined()) {\n\t\t\tsynchronized(this) {\n\t\t\t\tmultiUserChats.put(room, muc);\n\t\t\t}\n\t\t\tString roomname = room.split(\"@\")[0];\n\t\t\ttry {\n\t\t\t\tRoomInfo ri = MultiUserChat.getRoomInfo(mXMPPConnection, room);\n\t\t\t\tString rn = ri.getRoomName();\n\t\t\t\tif (rn != null && rn.length() > 0)\n\t\t\t\t\troomname = rn;\n\t\t\t\tLog.d(TAG, \"MUC name after disco: \" + roomname);\n\t\t\t} catch (XMPPException e) {\n\t\t\t\t// ignore a failed room info request\n\t\t\t\tLog.d(TAG, \"MUC room IQ failed: \" + room);\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t// delay requesting subject until room info IQ returned/failed\n\t\t\tString subject = muc.getSubject();\n\t\t\tcvR.put(RosterProvider.RosterConstants.ALIAS, roomname);\n\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, subject);\n\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.available.ordinal());\n\t\t\tLog.d(TAG, \"upserting MUC as online: \" + roomname);\n\t\t\tupsertRoster(cvR, room);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void sendMucMessage(String room, String message) {\n\t\tMessage newMessage = new Message(room, Message.Type.groupchat);\n\t\tnewMessage.setBody(message);\n\t\taddChatMessageToDB(ChatConstants.OUTGOING, room, message, ChatConstants.DS_NEW,\n\t\t\t\tSystem.currentTimeMillis(), newMessage.getPacketID());\n\t\tmXMPPConnection.sendPacket(newMessage);\n\t}\n\n\tprivate void quitRoom(String room) {\n\t\tLog.d(TAG, \"Leaving MUC \" + room);\n\t\tMultiUserChat muc = multiUserChats.get(room); \n\t\tmuc.leave();\n\t\tmultiUserChats.remove(room);\n\t\tmucLastPong.remove(room);\n\t\tmContentResolver.delete(RosterProvider.CONTENT_URI, \"jid = ?\", new String[] {room});\n\t}\n\n\t@Override\n\tpublic boolean inviteToRoom(String contactJid, String roomJid) {\n\t\tMultiUserChat muc = multiUserChats.get(roomJid);\n\t\tif(contactJid.contains(\"/\")) {\n\t\t\tcontactJid = contactJid.split(\"/\")[0];\n\t\t}\n\t\tLog.d(TAG, \"invitng contact: \"+contactJid+\" to room: \"+muc);\n\t\tmuc.invite(contactJid, \"User \"+contactJid+\" has invited you to a chat!\");\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic List<ParcelablePresence> getUserList(String jid) {\n\t\tMultiUserChat muc = multiUserChats.get(jid);\n\t\tif (muc == null) {\n\t\t\treturn null;\n\t\t}\n\t\tLog.d(TAG, \"MUC instance: \" + jid + \" \" + muc);\n\t\tIterator<String> occIter = muc.getOccupants();\n\t\tArrayList<ParcelablePresence> tmpList = new ArrayList<ParcelablePresence>();\n\t\twhile(occIter.hasNext())\n\t\t\ttmpList.add(new ParcelablePresence(muc.getOccupantPresence(occIter.next())));\n\t\tCollections.sort(tmpList, new Comparator<ParcelablePresence>() {\n\t\t\t@Override\n\t\t\tpublic int compare(ParcelablePresence lhs, ParcelablePresence rhs) {\n\t\t\t\treturn java.text.Collator.getInstance().compare(lhs.resource, rhs.resource);\n\t\t\t}\n\t\t});\n\t\tLog.d(TAG, \"getUserList(\" + jid + \"): \" + tmpList.size());\n\t\treturn tmpList;\n\t}\n}\n"], "buggy_code_start_loc": [1244], "buggy_code_end_loc": [1244], "fixing_code_start_loc": [1245], "fixing_code_end_loc": [1249], "type": "CWE-20", "message": "An incorrect implementation of \"XEP-0280: Message Carbons\" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for yaxim and Bruno (0.8.6 - 0.8.8; Android).", "other": {"cve": {"id": "CVE-2017-5589", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-09T20:59:00.153", "lastModified": "2017-03-01T02:59:05.480", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An incorrect implementation of \"XEP-0280: Message Carbons\" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for yaxim and Bruno (0.8.6 - 0.8.8; Android)."}, {"lang": "es", "value": "Una implementaci\u00f3n incorrecta de \"XEP-0280: Message Carbons\" en m\u00faltiples clientes XMPP permite a un atacante remoto personificar cualquier usuario, incluidos los contactos, en la pantalla de la aplicaci\u00f3n vulnerable. Esto permite varios tipos de ataques de ingenier\u00eda social. Esta CVE es para yaxim y Bruno (0.8.6 - 0.8.8; Android)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-346"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:yaxim:bruno:0.8.6:*:*:*:*:android:*:*", "matchCriteriaId": "DB39C75E-31B6-45D7-B78D-3A6D799A2E5B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:yaxim:bruno:0.8.7:*:*:*:*:android:*:*", "matchCriteriaId": "99906BCE-7B96-4689-AEDC-0C00F39A29EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:yaxim:bruno:0.8.8:*:*:*:*:android:*:*", "matchCriteriaId": "9709487E-C162-4BFE-BA33-9C7C817EB089"}, {"vulnerable": true, "criteria": "cpe:2.3:a:yaxim:yaxim:0.8.6:*:*:*:*:android:*:*", "matchCriteriaId": "F8997AD7-819E-4D87-B655-EDDC74CA9EE8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:yaxim:yaxim:0.8.7:*:*:*:*:android:*:*", "matchCriteriaId": "4057460F-28F9-43DA-BCB6-750CDC7DFE11"}, {"vulnerable": true, "criteria": "cpe:2.3:a:yaxim:yaxim:0.8.8:*:*:*:*:android:*:*", "matchCriteriaId": "468DD54B-9661-4874-8AEB-99960D62EACB"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2017/02/09/29", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96170", "source": "cve@mitre.org"}, {"url": "https://github.com/ge0rg/yaxim/commit/65a38dc77545d9568732189e86089390f0ceaf9f", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://rt-solutions.de/en/2017/02/CVE-2017-5589_xmpp_carbons/", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}, {"url": "https://rt-solutions.de/wp-content/uploads/2017/02/CVE-2017-5589_xmpp_carbons.pdf", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ge0rg/yaxim/commit/65a38dc77545d9568732189e86089390f0ceaf9f"}}