{"buggy_code": ["'use strict';\n\nvar grunt = require('../grunt');\n\n// Nodejs libs.\nvar fs = require('fs');\nvar path = require('path');\n\n// The module to be exported.\nvar file = module.exports = {};\n\n// External libs.\nfile.glob = require('glob');\nfile.minimatch = require('minimatch');\nfile.findup = require('findup-sync');\nvar YAML = require('js-yaml');\nvar rimraf = require('rimraf');\nvar iconv = require('iconv-lite');\nvar mkdirp = require('mkdirp').sync;\n\n// Windows?\nvar win32 = process.platform === 'win32';\n\n// Normalize \\\\ paths to / paths.\nvar unixifyPath = function(filepath) {\n  if (win32) {\n    return filepath.replace(/\\\\/g, '/');\n  } else {\n    return filepath;\n  }\n};\n\n// Change the current base path (ie, CWD) to the specified path.\nfile.setBase = function() {\n  var dirpath = path.join.apply(path, arguments);\n  process.chdir(dirpath);\n};\n\n// Process specified wildcard glob patterns or filenames against a\n// callback, excluding and uniquing files in the result set.\nvar processPatterns = function(patterns, fn) {\n  // Filepaths to return.\n  var result = [];\n  // Iterate over flattened patterns array.\n  grunt.util._.flattenDeep(patterns).forEach(function(pattern) {\n    // If the first character is ! it should be omitted\n    var exclusion = pattern.indexOf('!') === 0;\n    // If the pattern is an exclusion, remove the !\n    if (exclusion) { pattern = pattern.slice(1); }\n    // Find all matching files for this pattern.\n    var matches = fn(pattern);\n    if (exclusion) {\n      // If an exclusion, remove matching files.\n      result = grunt.util._.difference(result, matches);\n    } else {\n      // Otherwise add matching files.\n      result = grunt.util._.union(result, matches);\n    }\n  });\n  return result;\n};\n\n// Match a filepath or filepaths against one or more wildcard patterns. Returns\n// all matching filepaths.\nfile.match = function(options, patterns, filepaths) {\n  if (grunt.util.kindOf(options) !== 'object') {\n    filepaths = patterns;\n    patterns = options;\n    options = {};\n  }\n  // Return empty set if either patterns or filepaths was omitted.\n  if (patterns == null || filepaths == null) { return []; }\n  // Normalize patterns and filepaths to arrays.\n  if (!Array.isArray(patterns)) { patterns = [patterns]; }\n  if (!Array.isArray(filepaths)) { filepaths = [filepaths]; }\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0 || filepaths.length === 0) { return []; }\n  // Return all matching filepaths.\n  return processPatterns(patterns, function(pattern) {\n    return file.minimatch.match(filepaths, pattern, options);\n  });\n};\n\n// Match a filepath or filepaths against one or more wildcard patterns. Returns\n// true if any of the patterns match.\nfile.isMatch = function() {\n  return file.match.apply(file, arguments).length > 0;\n};\n\n// Return an array of all file paths that match the given wildcard patterns.\nfile.expand = function() {\n  var args = grunt.util.toArray(arguments);\n  // If the first argument is an options object, save those options to pass\n  // into the file.glob.sync method.\n  var options = grunt.util.kindOf(args[0]) === 'object' ? args.shift() : {};\n  // Use the first argument if it's an Array, otherwise convert the arguments\n  // object to an array and use that.\n  var patterns = Array.isArray(args[0]) ? args[0] : args;\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0) { return []; }\n  // Return all matching filepaths.\n  var matches = processPatterns(patterns, function(pattern) {\n    // Find all matching files for this pattern.\n    return file.glob.sync(pattern, options);\n  });\n  // Filter result set?\n  if (options.filter) {\n    matches = matches.filter(function(filepath) {\n      filepath = path.join(options.cwd || '', filepath);\n      try {\n        if (typeof options.filter === 'function') {\n          return options.filter(filepath);\n        } else {\n          // If the file is of the right type and exists, this should work.\n          return fs.statSync(filepath)[options.filter]();\n        }\n      } catch (e) {\n        // Otherwise, it's probably not the right type.\n        return false;\n      }\n    });\n  }\n  return matches;\n};\n\nvar pathSeparatorRe = /[\\/\\\\]/g;\n\n// The \"ext\" option refers to either everything after the first dot (default)\n// or everything after the last dot.\nvar extDotRe = {\n  first: /(\\.[^\\/]*)?$/,\n  last: /(\\.[^\\/\\.]*)?$/,\n};\n\n// Build a multi task \"files\" object dynamically.\nfile.expandMapping = function(patterns, destBase, options) {\n  options = grunt.util._.defaults({}, options, {\n    extDot: 'first',\n    rename: function(destBase, destPath) {\n      return path.join(destBase || '', destPath);\n    }\n  });\n  var files = [];\n  var fileByDest = {};\n  // Find all files matching pattern, using passed-in options.\n  file.expand(options, patterns).forEach(function(src) {\n    var destPath = src;\n    // Flatten?\n    if (options.flatten) {\n      destPath = path.basename(destPath);\n    }\n    // Change the extension?\n    if ('ext' in options) {\n      destPath = destPath.replace(extDotRe[options.extDot], options.ext);\n    }\n    // Generate destination filename.\n    var dest = options.rename(destBase, destPath, options);\n    // Prepend cwd to src path if necessary.\n    if (options.cwd) { src = path.join(options.cwd, src); }\n    // Normalize filepaths to be unix-style.\n    dest = dest.replace(pathSeparatorRe, '/');\n    src = src.replace(pathSeparatorRe, '/');\n    // Map correct src path to dest path.\n    if (fileByDest[dest]) {\n      // If dest already exists, push this src onto that dest's src array.\n      fileByDest[dest].src.push(src);\n    } else {\n      // Otherwise create a new src-dest file mapping object.\n      files.push({\n        src: [src],\n        dest: dest,\n      });\n      // And store a reference for later use.\n      fileByDest[dest] = files[files.length - 1];\n    }\n  });\n  return files;\n};\n\n// Like mkdir -p. Create a directory and any intermediary directories.\nfile.mkdir = function(dirpath, mode) {\n  if (grunt.option('no-write')) { return; }\n  try {\n    mkdirp(dirpath, { mode: mode });\n  } catch (e) {\n    throw grunt.util.error('Unable to create directory \"' + dirpath + '\" (Error code: ' + e.code + ').', e);\n  }\n};\n\n// Recurse into a directory, executing callback for each file.\nfile.recurse = function recurse(rootdir, callback, subdir) {\n  var abspath = subdir ? path.join(rootdir, subdir) : rootdir;\n  fs.readdirSync(abspath).forEach(function(filename) {\n    var filepath = path.join(abspath, filename);\n    if (fs.statSync(filepath).isDirectory()) {\n      recurse(rootdir, callback, unixifyPath(path.join(subdir || '', filename || '')));\n    } else {\n      callback(unixifyPath(filepath), rootdir, subdir, filename);\n    }\n  });\n};\n\n// The default file encoding to use.\nfile.defaultEncoding = 'utf8';\n// Whether to preserve the BOM on file.read rather than strip it.\nfile.preserveBOM = false;\n\n// Read a file, return its contents.\nfile.read = function(filepath, options) {\n  if (!options) { options = {}; }\n  var contents;\n  grunt.verbose.write('Reading ' + filepath + '...');\n  try {\n    contents = fs.readFileSync(String(filepath));\n    // If encoding is not explicitly null, convert from encoded buffer to a\n    // string. If no encoding was specified, use the default.\n    if (options.encoding !== null) {\n      contents = iconv.decode(contents, options.encoding || file.defaultEncoding, {stripBOM: !file.preserveBOM});\n    }\n    grunt.verbose.ok();\n    return contents;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to read \"' + filepath + '\" file (Error code: ' + e.code + ').', e);\n  }\n};\n\n// Read a file, parse its contents, return an object.\nfile.readJSON = function(filepath, options) {\n  var src = file.read(filepath, options);\n  var result;\n  grunt.verbose.write('Parsing ' + filepath + '...');\n  try {\n    result = JSON.parse(src);\n    grunt.verbose.ok();\n    return result;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to parse \"' + filepath + '\" file (' + e.message + ').', e);\n  }\n};\n\n// Read a YAML file, parse its contents, return an object.\nfile.readYAML = function(filepath, options, yamlOptions) {\n  if (!options) { options = {}; }\n  if (!yamlOptions) { yamlOptions = {}; }\n\n  var src = file.read(filepath, options);\n  var result;\n  grunt.verbose.write('Parsing ' + filepath + '...');\n  try {\n    // use the recommended way of reading YAML files\n    // https://github.com/nodeca/js-yaml#safeload-string---options-\n    if (yamlOptions.unsafeLoad) {\n      result = YAML.load(src);\n    } else {\n      result = YAML.safeLoad(src);\n    }\n    grunt.verbose.ok();\n    return result;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to parse \"' + filepath + '\" file (' + e.message + ').', e);\n  }\n};\n\n// Write a file.\nfile.write = function(filepath, contents, options) {\n  if (!options) { options = {}; }\n  var nowrite = grunt.option('no-write');\n  grunt.verbose.write((nowrite ? 'Not actually writing ' : 'Writing ') + filepath + '...');\n  // Create path, if necessary.\n  file.mkdir(path.dirname(filepath));\n  try {\n    // If contents is already a Buffer, don't try to encode it. If no encoding\n    // was specified, use the default.\n    if (!Buffer.isBuffer(contents)) {\n      contents = iconv.encode(contents, options.encoding || file.defaultEncoding);\n    }\n    // Actually write file.\n    if (!nowrite) {\n      fs.writeFileSync(filepath, contents, 'mode' in options ? {mode: options.mode} : {});\n    }\n    grunt.verbose.ok();\n    return true;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to write \"' + filepath + '\" file (Error code: ' + e.code + ').', e);\n  }\n};\n\n// Read a file, optionally processing its content, then write the output.\n// Or read a directory, recursively creating directories, reading files,\n// processing content, writing output.\nfile.copy = function copy(srcpath, destpath, options) {\n  if (file.isDir(srcpath)) {\n    // Copy a directory, recursively.\n    // Explicitly create new dest directory.\n    file.mkdir(destpath);\n    // Iterate over all sub-files/dirs, recursing.\n    fs.readdirSync(srcpath).forEach(function(filepath) {\n      copy(path.join(srcpath, filepath), path.join(destpath, filepath), options);\n    });\n  } else {\n    // Copy a single file.\n    file._copy(srcpath, destpath, options);\n  }\n};\n\n// Read a file, optionally processing its content, then write the output.\nfile._copy = function(srcpath, destpath, options) {\n  if (!options) { options = {}; }\n  // If a process function was specified, and noProcess isn't true or doesn't\n  // match the srcpath, process the file's source.\n  var process = options.process && options.noProcess !== true &&\n    !(options.noProcess && file.isMatch(options.noProcess, srcpath));\n  // If the file will be processed, use the encoding as-specified. Otherwise,\n  // use an encoding of null to force the file to be read/written as a Buffer.\n  var readWriteOptions = process ? options : {encoding: null};\n  // Actually read the file.\n  var contents = file.read(srcpath, readWriteOptions);\n  if (process) {\n    grunt.verbose.write('Processing source...');\n    try {\n      contents = options.process(contents, srcpath, destpath);\n      grunt.verbose.ok();\n    } catch (e) {\n      grunt.verbose.error();\n      throw grunt.util.error('Error while processing \"' + srcpath + '\" file.', e);\n    }\n  }\n  // Abort copy if the process function returns false.\n  if (contents === false) {\n    grunt.verbose.writeln('Write aborted.');\n  } else {\n    file.write(destpath, contents, readWriteOptions);\n  }\n};\n\n// Delete folders and files recursively\nfile.delete = function(filepath, options) {\n  filepath = String(filepath);\n\n  var nowrite = grunt.option('no-write');\n  if (!options) {\n    options = {force: grunt.option('force') || false};\n  }\n\n  grunt.verbose.write((nowrite ? 'Not actually deleting ' : 'Deleting ') + filepath + '...');\n\n  if (!file.exists(filepath)) {\n    grunt.verbose.error();\n    grunt.log.warn('Cannot delete nonexistent file.');\n    return false;\n  }\n\n  // Only delete cwd or outside cwd if --force enabled. Be careful, people!\n  if (!options.force) {\n    if (file.isPathCwd(filepath)) {\n      grunt.verbose.error();\n      grunt.fail.warn('Cannot delete the current working directory.');\n      return false;\n    } else if (!file.isPathInCwd(filepath)) {\n      grunt.verbose.error();\n      grunt.fail.warn('Cannot delete files outside the current working directory.');\n      return false;\n    }\n  }\n\n  try {\n    // Actually delete. Or not.\n    if (!nowrite) {\n      rimraf.sync(filepath);\n    }\n    grunt.verbose.ok();\n    return true;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to delete \"' + filepath + '\" file (' + e.message + ').', e);\n  }\n};\n\n// True if the file path exists.\nfile.exists = function() {\n  var filepath = path.join.apply(path, arguments);\n  return fs.existsSync(filepath);\n};\n\n// True if the file is a symbolic link.\nfile.isLink = function() {\n  var filepath = path.join.apply(path, arguments);\n  try {\n    return fs.lstatSync(filepath).isSymbolicLink();\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      // The file doesn't exist, so it's not a symbolic link.\n      return false;\n    }\n    throw grunt.util.error('Unable to read \"' + filepath + '\" file (Error code: ' + e.code + ').', e);\n  }\n};\n\n// True if the path is a directory.\nfile.isDir = function() {\n  var filepath = path.join.apply(path, arguments);\n  return file.exists(filepath) && fs.statSync(filepath).isDirectory();\n};\n\n// True if the path is a file.\nfile.isFile = function() {\n  var filepath = path.join.apply(path, arguments);\n  return file.exists(filepath) && fs.statSync(filepath).isFile();\n};\n\n// Is a given file path absolute?\nfile.isPathAbsolute = function() {\n  var filepath = path.join.apply(path, arguments);\n  return path.isAbsolute(filepath);\n};\n\n// Do all the specified paths refer to the same path?\nfile.arePathsEquivalent = function(first) {\n  first = path.resolve(first);\n  for (var i = 1; i < arguments.length; i++) {\n    if (first !== path.resolve(arguments[i])) { return false; }\n  }\n  return true;\n};\n\n// Are descendant path(s) contained within ancestor path? Note: does not test\n// if paths actually exist.\nfile.doesPathContain = function(ancestor) {\n  ancestor = path.resolve(ancestor);\n  var relative;\n  for (var i = 1; i < arguments.length; i++) {\n    relative = path.relative(path.resolve(arguments[i]), ancestor);\n    if (relative === '' || /\\w+/.test(relative)) { return false; }\n  }\n  return true;\n};\n\n// Test to see if a filepath is the CWD.\nfile.isPathCwd = function() {\n  var filepath = path.join.apply(path, arguments);\n  try {\n    return file.arePathsEquivalent(fs.realpathSync(process.cwd()), fs.realpathSync(filepath));\n  } catch (e) {\n    return false;\n  }\n};\n\n// Test to see if a filepath is contained within the CWD.\nfile.isPathInCwd = function() {\n  var filepath = path.join.apply(path, arguments);\n  try {\n    return file.doesPathContain(fs.realpathSync(process.cwd()), fs.realpathSync(filepath));\n  } catch (e) {\n    return false;\n  }\n};\n", "{\n  \"name\": \"grunt\",\n  \"description\": \"The JavaScript Task Runner\",\n  \"version\": \"1.4.1\",\n  \"author\": \"Grunt Development Team (https://gruntjs.com/development-team)\",\n  \"homepage\": \"https://gruntjs.com/\",\n  \"repository\": \"https://github.com/gruntjs/grunt.git\",\n  \"license\": \"MIT\",\n  \"engines\": {\n    \"node\": \">=8\"\n  },\n  \"scripts\": {\n    \"test\": \"node bin/grunt test\",\n    \"test-tap\": \"node bin/grunt test:tap\"\n  },\n  \"main\": \"lib/grunt\",\n  \"bin\": {\n    \"grunt\": \"bin/grunt\"\n  },\n  \"keywords\": [\n    \"task\",\n    \"async\",\n    \"cli\",\n    \"minify\",\n    \"uglify\",\n    \"build\",\n    \"lodash\",\n    \"unit\",\n    \"test\",\n    \"qunit\",\n    \"nodeunit\",\n    \"server\",\n    \"init\",\n    \"scaffold\",\n    \"make\",\n    \"jake\",\n    \"tool\"\n  ],\n  \"dependencies\": {\n    \"dateformat\": \"~3.0.3\",\n    \"eventemitter2\": \"~0.4.13\",\n    \"exit\": \"~0.1.2\",\n    \"findup-sync\": \"~0.3.0\",\n    \"glob\": \"~7.1.6\",\n    \"grunt-cli\": \"~1.4.2\",\n    \"grunt-known-options\": \"~2.0.0\",\n    \"grunt-legacy-log\": \"~3.0.0\",\n    \"grunt-legacy-util\": \"~2.0.1\",\n    \"iconv-lite\": \"~0.4.13\",\n    \"js-yaml\": \"~3.14.0\",\n    \"minimatch\": \"~3.0.4\",\n    \"mkdirp\": \"~1.0.4\",\n    \"nopt\": \"~3.0.6\",\n    \"rimraf\": \"~3.0.2\"\n  },\n  \"devDependencies\": {\n    \"difflet\": \"~1.0.1\",\n    \"eslint-config-grunt\": \"~1.0.1\",\n    \"grunt-contrib-nodeunit\": \"~3.0.0\",\n    \"grunt-contrib-watch\": \"~1.1.0\",\n    \"grunt-eslint\": \"~18.1.0\",\n    \"temporary\": \"~0.0.4\",\n    \"through2\": \"~4.0.2\"\n  },\n  \"files\": [\n    \"lib\",\n    \"bin\"\n  ]\n}\n", "'use strict';\n\nvar grunt = require('../../lib/grunt');\n\nvar fs = require('fs');\nvar path = require('path');\n\nvar Tempfile = require('temporary/lib/file');\nvar Tempdir = require('temporary/lib/dir');\n\nvar win32 = process.platform === 'win32';\n\nvar tmpdir = new Tempdir();\ntry {\n  fs.symlinkSync(path.resolve('test/fixtures/octocat.png'), path.join(tmpdir.path, 'octocat.png'), 'file');\n  fs.symlinkSync(path.resolve('test/fixtures/expand'), path.join(tmpdir.path, 'expand'), 'dir');\n} catch (err) {\n  console.error('** ERROR: Cannot create symbolic links; link-related tests will fail.');\n  if (win32) {\n    console.error('** Tests must be run with Administrator privileges on Windows.');\n  }\n}\n\nexports['file.match'] = {\n  'empty set': function(test) {\n    test.expect(12);\n    // Should return empty set if a required argument is missing or an empty set.\n    test.deepEqual(grunt.file.match(null, null), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match({}, null, null), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match(null, 'foo.js'), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match('*.js', null), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match({}, null, 'foo.js'), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match({}, '*.js', null), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match({}, [], 'foo.js'), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match({}, '*.js', []), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match(null, ['foo.js']), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match(['*.js'], null), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match({}, null, ['foo.js']), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match({}, ['*.js'], null), [], 'should return empty set.');\n    test.done();\n  },\n  'basic matching': function(test) {\n    test.expect(6);\n    test.deepEqual(grunt.file.match('*.js', 'foo.js'), ['foo.js'], 'should match correctly.');\n    test.deepEqual(grunt.file.match('*.js', ['foo.js']), ['foo.js'], 'should match correctly.');\n    test.deepEqual(grunt.file.match('*.js', ['foo.js', 'bar.css']), ['foo.js'], 'should match correctly.');\n    test.deepEqual(grunt.file.match(['*.js', '*.css'], 'foo.js'), ['foo.js'], 'should match correctly.');\n    test.deepEqual(grunt.file.match(['*.js', '*.css'], ['foo.js']), ['foo.js'], 'should match correctly.');\n    test.deepEqual(grunt.file.match(['*.js', '*.css'], ['foo.js', 'bar.css']), ['foo.js', 'bar.css'], 'should match correctly.');\n    test.done();\n  },\n  'no matches': function(test) {\n    test.expect(2);\n    test.deepEqual(grunt.file.match('*.js', 'foo.css'), [], 'should fail to match.');\n    test.deepEqual(grunt.file.match('*.js', ['foo.css', 'bar.css']), [], 'should fail to match.');\n    test.done();\n  },\n  'unique': function(test) {\n    test.expect(2);\n    test.deepEqual(grunt.file.match('*.js', ['foo.js', 'foo.js']), ['foo.js'], 'should return a uniqued set.');\n    test.deepEqual(grunt.file.match(['*.js', '*.*'], ['foo.js', 'foo.js']), ['foo.js'], 'should return a uniqued set.');\n    test.done();\n  },\n  'flatten': function(test) {\n    test.expect(1);\n    test.deepEqual(grunt.file.match([['*.js', '*.css'], ['*.*', '*.js']], ['foo.js', 'bar.css']), ['foo.js', 'bar.css'], 'should process nested pattern arrays correctly.');\n    test.done();\n  },\n  'exclusion': function(test) {\n    test.expect(5);\n    test.deepEqual(grunt.file.match(['!*.js'], ['foo.js', 'bar.js']), [], 'solitary exclusion should match nothing');\n    test.deepEqual(grunt.file.match(['*.js', '!*.js'], ['foo.js', 'bar.js']), [], 'exclusion should cancel match');\n    test.deepEqual(grunt.file.match(['*.js', '!f*.js'], ['foo.js', 'bar.js', 'baz.js']), ['bar.js', 'baz.js'], 'partial exclusion should partially cancel match');\n    test.deepEqual(grunt.file.match(['*.js', '!*.js', 'b*.js'], ['foo.js', 'bar.js', 'baz.js']), ['bar.js', 'baz.js'], 'inclusion / exclusion order matters');\n    test.deepEqual(grunt.file.match(['*.js', '!f*.js', '*.js'], ['foo.js', 'bar.js', 'baz.js']), ['bar.js', 'baz.js', 'foo.js'], 'inclusion / exclusion order matters');\n    test.done();\n  },\n  'options.matchBase': function(test) {\n    test.expect(2);\n    test.deepEqual(grunt.file.match({matchBase: true}, '*.js', ['foo.js', 'bar', 'baz/xyz.js']), ['foo.js', 'baz/xyz.js'], 'should matchBase (minimatch) when specified.');\n    test.deepEqual(grunt.file.match('*.js', ['foo.js', 'bar', 'baz/xyz.js']), ['foo.js'], 'should not matchBase (minimatch) by default.');\n    test.done();\n  }\n};\n\nexports['file.isMatch'] = {\n  'basic matching': function(test) {\n    test.expect(6);\n    test.ok(grunt.file.isMatch('*.js', 'foo.js'), 'should match correctly.');\n    test.ok(grunt.file.isMatch('*.js', ['foo.js']), 'should match correctly.');\n    test.ok(grunt.file.isMatch('*.js', ['foo.js', 'bar.css']), 'should match correctly.');\n    test.ok(grunt.file.isMatch(['*.js', '*.css'], 'foo.js'), 'should match correctly.');\n    test.ok(grunt.file.isMatch(['*.js', '*.css'], ['foo.js']), 'should match correctly.');\n    test.ok(grunt.file.isMatch(['*.js', '*.css'], ['foo.js', 'bar.css']), 'should match correctly.');\n    test.done();\n  },\n  'no matches': function(test) {\n    test.expect(6);\n    test.equal(grunt.file.isMatch('*.js', 'foo.css'), false, 'should fail to match.');\n    test.equal(grunt.file.isMatch('*.js', ['foo.css', 'bar.css']), false, 'should fail to match.');\n    test.equal(grunt.file.isMatch(null, 'foo.css'), false, 'should fail to match.');\n    test.equal(grunt.file.isMatch('*.js', null), false, 'should fail to match.');\n    test.equal(grunt.file.isMatch([], 'foo.css'), false, 'should fail to match.');\n    test.equal(grunt.file.isMatch('*.js', []), false, 'should fail to match.');\n    test.done();\n  },\n  'options.matchBase': function(test) {\n    test.expect(2);\n    test.ok(grunt.file.isMatch({matchBase: true}, '*.js', ['baz/xyz.js']), 'should matchBase (minimatch) when specified.');\n    test.equal(grunt.file.isMatch('*.js', ['baz/xyz.js']), false, 'should not matchBase (minimatch) by default.');\n    test.done();\n  }\n};\n\nexports['file.expand*'] = {\n  setUp: function(done) {\n    this.cwd = process.cwd();\n    process.chdir('test/fixtures/expand');\n    done();\n  },\n  tearDown: function(done) {\n    process.chdir(this.cwd);\n    done();\n  },\n  'basic matching': function(test) {\n    test.expect(8);\n    test.deepEqual(grunt.file.expand('**/*.js'), ['js/bar.js', 'js/foo.js'], 'should match.');\n    test.deepEqual(grunt.file.expand('**/*.js', '**/*.css'), ['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css'], 'should match.');\n    test.deepEqual(grunt.file.expand(['**/*.js', '**/*.css']), ['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css'], 'should match.');\n    test.deepEqual(grunt.file.expand('**d*/**'), [\n      'deep',\n      'deep/deep.txt',\n      'deep/deeper',\n      'deep/deeper/deeper.txt',\n      'deep/deeper/deepest',\n      'deep/deeper/deepest/deepest.txt'], 'should match files and directories.');\n    test.deepEqual(grunt.file.expand({mark: true}, '**d*/**'), [\n      'deep/',\n      'deep/deep.txt',\n      'deep/deeper/',\n      'deep/deeper/deeper.txt',\n      'deep/deeper/deepest/',\n      'deep/deeper/deepest/deepest.txt'], 'the minimatch \"mark\" option ensures directories end in /.');\n    test.deepEqual(grunt.file.expand('**d*/**/'), [\n      'deep/',\n      'deep/deeper/',\n      'deep/deeper/deepest/'], 'should match directories, arbitrary / at the end appears in matches.');\n    test.deepEqual(grunt.file.expand({mark: true}, '**d*/**/'), [\n      'deep/',\n      'deep/deeper/',\n      'deep/deeper/deepest/'], 'should match directories, arbitrary / at the end appears in matches.');\n    test.deepEqual(grunt.file.expand('*.xyz'), [], 'should fail to match.');\n    test.done();\n  },\n  'filter': function(test) {\n    test.expect(5);\n    test.deepEqual(grunt.file.expand({filter: 'isFile'}, '**d*/**'), [\n      'deep/deep.txt',\n      'deep/deeper/deeper.txt',\n      'deep/deeper/deepest/deepest.txt'\n    ], 'should match files only.');\n    test.deepEqual(grunt.file.expand({filter: 'isDirectory'}, '**d*/**'), [\n      'deep',\n      'deep/deeper',\n      'deep/deeper/deepest'\n    ], 'should match directories only.');\n    test.deepEqual(grunt.file.expand({filter: function(filepath) { return (/deepest/).test(filepath); }}, '**'), [\n      'deep/deeper/deepest',\n      'deep/deeper/deepest/deepest.txt',\n    ], 'should filter arbitrarily.');\n    test.deepEqual(grunt.file.expand({filter: 'isFile'}, 'js', 'css'), [], 'should fail to match.');\n    test.deepEqual(grunt.file.expand({filter: 'isDirectory'}, '**/*.js'), [], 'should fail to match.');\n    test.done();\n  },\n  'unique': function(test) {\n    test.expect(4);\n    test.deepEqual(grunt.file.expand('**/*.js', 'js/*.js'), ['js/bar.js', 'js/foo.js'], 'file list should be uniqed.');\n    test.deepEqual(grunt.file.expand('**/*.js', '**/*.css', 'js/*.js'), ['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css'], 'file list should be uniqed.');\n    test.deepEqual(grunt.file.expand('js', 'js/'), ['js', 'js/'], 'mixed non-ending-/ and ending-/ dirs will not be uniqed by default.');\n    test.deepEqual(grunt.file.expand({mark: true}, 'js', 'js/'), ['js/'], 'mixed non-ending-/ and ending-/ dirs will be uniqed when \"mark\" is specified.');\n    test.done();\n  },\n  'file order': function(test) {\n    test.expect(4);\n    var actual = grunt.file.expand('**/*.{js,css}');\n    var expected = ['css/baz.css', 'css/qux.css', 'js/bar.js', 'js/foo.js'];\n    test.deepEqual(actual, expected, 'should select 4 files in this order, by default.');\n\n    actual = grunt.file.expand('js/foo.js', 'js/bar.js', '**/*.{js,css}');\n    expected = ['js/foo.js', 'js/bar.js', 'css/baz.css', 'css/qux.css'];\n    test.deepEqual(actual, expected, 'specifically-specified-up-front file order should be maintained.');\n\n    actual = grunt.file.expand('js/bar.js', 'js/foo.js', '**/*.{js,css}');\n    expected = ['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css'];\n    test.deepEqual(actual, expected, 'specifically-specified-up-front file order should be maintained.');\n\n    actual = grunt.file.expand('js/foo.js', '**/*.{js,css}', '!js/bar.js', 'js/bar.js');\n    expected = ['js/foo.js', 'css/baz.css', 'css/qux.css', 'js/bar.js'];\n    test.deepEqual(actual, expected, 'if a file is excluded and then re-added, it should be added at the end.');\n    test.done();\n  },\n  'flatten': function(test) {\n    test.expect(1);\n    test.deepEqual(grunt.file.expand([['**/*.js'], ['**/*.css', 'js/*.js']]), ['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css'], 'should match.');\n    test.done();\n  },\n  'exclusion': function(test) {\n    test.expect(8);\n    test.deepEqual(grunt.file.expand(['!js/*.js']), [], 'solitary exclusion should match nothing');\n    test.deepEqual(grunt.file.expand(['js/bar.js', '!js/bar.js']), [], 'exclusion should cancel match');\n    test.deepEqual(grunt.file.expand(['**/*.js', '!js/foo.js']), ['js/bar.js'], 'should omit single file from matched set');\n    test.deepEqual(grunt.file.expand(['!js/foo.js', '**/*.js']), ['js/bar.js', 'js/foo.js'], 'inclusion / exclusion order matters');\n    test.deepEqual(grunt.file.expand(['**/*.js', '**/*.css', '!js/bar.js', '!css/baz.css']), ['js/foo.js', 'css/qux.css'], 'multiple exclusions should be removed from the set');\n    test.deepEqual(grunt.file.expand(['**/*.js', '**/*.css', '!**/*.css']), ['js/bar.js', 'js/foo.js'], 'excluded wildcards should be removed from the matched set');\n    test.deepEqual(grunt.file.expand(['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css', '!**/b*.*']), ['js/foo.js', 'css/qux.css'], 'different pattern for exclusion should still work');\n    test.deepEqual(grunt.file.expand(['js/bar.js', '!**/b*.*', 'js/foo.js', 'css/baz.css', 'css/qux.css']), ['js/foo.js', 'css/baz.css', 'css/qux.css'], 'inclusion / exclusion order matters');\n    test.done();\n  },\n  'options.matchBase': function(test) {\n    test.expect(4);\n    var opts = {matchBase: true};\n    test.deepEqual(grunt.file.expand('*.js'), [], 'should not matchBase (minimatch) by default.');\n    test.deepEqual(grunt.file.expand(opts, '*.js'), ['js/bar.js', 'js/foo.js'], 'options should be passed through to minimatch.');\n    test.deepEqual(grunt.file.expand(opts, '*.js', '*.css'), ['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css'], 'should match.');\n    test.deepEqual(grunt.file.expand(opts, ['*.js', '*.css']), ['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css'], 'should match.');\n    test.done();\n  },\n  'options.cwd': function(test) {\n    test.expect(4);\n    var cwd = path.resolve(process.cwd(), '..');\n    test.deepEqual(grunt.file.expand({cwd: cwd}, ['expand/js', 'expand/js/*']), ['expand/js', 'expand/js/bar.js', 'expand/js/foo.js'], 'should match.');\n    test.deepEqual(grunt.file.expand({cwd: cwd, filter: 'isFile'}, ['expand/js', 'expand/js/*']), ['expand/js/bar.js', 'expand/js/foo.js'], 'should match.');\n    test.deepEqual(grunt.file.expand({cwd: cwd, filter: 'isDirectory'}, ['expand/js', 'expand/js/*']), ['expand/js'], 'should match.');\n    test.deepEqual(grunt.file.expand({cwd: cwd, filter: 'isFile'}, ['expand/js', 'expand/js/*', '!**/b*.js']), ['expand/js/foo.js'], 'should negate properly.');\n    test.done();\n  },\n  'options.nonull': function(test) {\n    test.expect(2);\n    var opts = {nonull: true};\n    test.deepEqual(grunt.file.expand(opts, ['js/a*', 'js/b*', 'js/c*']), ['js/a*', 'js/bar.js', 'js/c*'], 'non-matching patterns should be returned in result set.');\n    test.deepEqual(grunt.file.expand(opts, ['js/foo.js', 'js/bar.js', 'js/baz.js']), ['js/foo.js', 'js/bar.js', 'js/baz.js'], 'non-matching filenames should be returned in result set.');\n    test.done();\n  },\n};\n\nexports['file.expandMapping'] = {\n  setUp: function(done) {\n    this.cwd = process.cwd();\n    process.chdir('test/fixtures');\n    done();\n  },\n  tearDown: function(done) {\n    process.chdir(this.cwd);\n    done();\n  },\n  'basic matching': function(test) {\n    test.expect(2);\n\n    var actual = grunt.file.expandMapping(['expand/**/*.txt'], 'dest');\n    var expected = [\n      {dest: 'dest/expand/deep/deep.txt', src: ['expand/deep/deep.txt']},\n      {dest: 'dest/expand/deep/deeper/deeper.txt', src: ['expand/deep/deeper/deeper.txt']},\n      {dest: 'dest/expand/deep/deeper/deepest/deepest.txt', src: ['expand/deep/deeper/deepest/deepest.txt']},\n    ];\n    test.deepEqual(actual, expected, 'basic src-dest options');\n\n    actual = grunt.file.expandMapping(['expand/**/*.txt'], 'dest/');\n    test.deepEqual(actual, expected, 'destBase should behave the same both with or without trailing slash');\n\n    test.done();\n  },\n  'flatten': function(test) {\n    test.expect(1);\n    var actual = grunt.file.expandMapping(['expand/**/*.txt'], 'dest', {flatten: true});\n    var expected = [\n      {dest: 'dest/deep.txt', src: ['expand/deep/deep.txt']},\n      {dest: 'dest/deeper.txt', src: ['expand/deep/deeper/deeper.txt']},\n      {dest: 'dest/deepest.txt', src: ['expand/deep/deeper/deepest/deepest.txt']},\n    ];\n    test.deepEqual(actual, expected, 'dest paths should be flattened pre-destBase+destPath join');\n    test.done();\n  },\n  'ext': function(test) {\n    test.expect(3);\n    var actual, expected;\n    actual = grunt.file.expandMapping(['expand/**/*.txt'], 'dest', {ext: '.foo'});\n    expected = [\n      {dest: 'dest/expand/deep/deep.foo', src: ['expand/deep/deep.txt']},\n      {dest: 'dest/expand/deep/deeper/deeper.foo', src: ['expand/deep/deeper/deeper.txt']},\n      {dest: 'dest/expand/deep/deeper/deepest/deepest.foo', src: ['expand/deep/deeper/deepest/deepest.txt']},\n    ];\n    test.deepEqual(actual, expected, 'specified extension should be added');\n    actual = grunt.file.expandMapping(['expand-mapping-ext/**/file*'], 'dest', {ext: '.foo'});\n    expected = [\n      {dest: 'dest/expand-mapping-ext/dir.ectory/file-no-extension.foo', src: ['expand-mapping-ext/dir.ectory/file-no-extension']},\n      {dest: 'dest/expand-mapping-ext/dir.ectory/sub.dir.ectory/file.foo', src: ['expand-mapping-ext/dir.ectory/sub.dir.ectory/file.ext.ension']},\n      {dest: 'dest/expand-mapping-ext/file.foo', src: ['expand-mapping-ext/file.ext.ension']},\n    ];\n    test.deepEqual(actual, expected, 'specified extension should be added');\n    actual = grunt.file.expandMapping(['expand/**/*.txt'], 'dest', {ext: ''});\n    expected = [\n      {dest: 'dest/expand/deep/deep', src: ['expand/deep/deep.txt']},\n      {dest: 'dest/expand/deep/deeper/deeper', src: ['expand/deep/deeper/deeper.txt']},\n      {dest: 'dest/expand/deep/deeper/deepest/deepest', src: ['expand/deep/deeper/deepest/deepest.txt']},\n    ];\n    test.deepEqual(actual, expected, 'empty string extension should be added');\n    test.done();\n  },\n  'extDot': function(test) {\n    test.expect(2);\n    var actual, expected;\n\n    actual = grunt.file.expandMapping(['expand-mapping-ext/**/file*'], 'dest', {ext: '.foo', extDot: 'first'});\n    expected = [\n      {dest: 'dest/expand-mapping-ext/dir.ectory/file-no-extension.foo', src: ['expand-mapping-ext/dir.ectory/file-no-extension']},\n      {dest: 'dest/expand-mapping-ext/dir.ectory/sub.dir.ectory/file.foo', src: ['expand-mapping-ext/dir.ectory/sub.dir.ectory/file.ext.ension']},\n      {dest: 'dest/expand-mapping-ext/file.foo', src: ['expand-mapping-ext/file.ext.ension']},\n    ];\n    test.deepEqual(actual, expected, 'extDot of \"first\" should replace everything after the first dot in the filename.');\n\n    actual = grunt.file.expandMapping(['expand-mapping-ext/**/file*'], 'dest', {ext: '.foo', extDot: 'last'});\n    expected = [\n      {dest: 'dest/expand-mapping-ext/dir.ectory/file-no-extension.foo', src: ['expand-mapping-ext/dir.ectory/file-no-extension']},\n      {dest: 'dest/expand-mapping-ext/dir.ectory/sub.dir.ectory/file.ext.foo', src: ['expand-mapping-ext/dir.ectory/sub.dir.ectory/file.ext.ension']},\n      {dest: 'dest/expand-mapping-ext/file.ext.foo', src: ['expand-mapping-ext/file.ext.ension']},\n    ];\n    test.deepEqual(actual, expected, 'extDot of \"last\" should replace everything after the last dot in the filename.');\n\n    test.done();\n  },\n  'cwd': function(test) {\n    test.expect(1);\n    var actual = grunt.file.expandMapping(['**/*.txt'], 'dest', {cwd: 'expand'});\n    var expected = [\n      {dest: 'dest/deep/deep.txt', src: ['expand/deep/deep.txt']},\n      {dest: 'dest/deep/deeper/deeper.txt', src: ['expand/deep/deeper/deeper.txt']},\n      {dest: 'dest/deep/deeper/deepest/deepest.txt', src: ['expand/deep/deeper/deepest/deepest.txt']},\n    ];\n    test.deepEqual(actual, expected, 'cwd should be stripped from front of destPath, pre-destBase+destPath join');\n    test.done();\n  },\n  'rename': function(test) {\n    test.expect(1);\n    var actual = grunt.file.expandMapping(['**/*.txt'], 'dest', {\n      cwd: 'expand',\n      flatten: true,\n      rename: function(destBase, destPath, options) {\n        return path.join(destBase, options.cwd, 'o-m-g', destPath);\n      }\n    });\n    var expected = [\n      {dest: 'dest/expand/o-m-g/deep.txt', src: ['expand/deep/deep.txt']},\n      {dest: 'dest/expand/o-m-g/deeper.txt', src: ['expand/deep/deeper/deeper.txt']},\n      {dest: 'dest/expand/o-m-g/deepest.txt', src: ['expand/deep/deeper/deepest/deepest.txt']},\n    ];\n    test.deepEqual(actual, expected, 'custom rename function should be used to build dest, post-flatten');\n    test.done();\n  },\n  'rename to same dest': function(test) {\n    test.expect(1);\n    var actual = grunt.file.expandMapping(['**/*'], 'dest', {\n      filter: 'isFile',\n      cwd: 'expand',\n      flatten: true,\n      nosort: true,\n      rename: function(destBase, destPath) {\n        return path.join(destBase, 'all' + path.extname(destPath));\n      }\n    });\n    var expected = [\n      {dest: 'dest/all.md', src: ['expand/README.md']},\n      {dest: 'dest/all.css', src: ['expand/css/baz.css', 'expand/css/qux.css']},\n      {dest: 'dest/all.txt', src: ['expand/deep/deep.txt', 'expand/deep/deeper/deeper.txt', 'expand/deep/deeper/deepest/deepest.txt']},\n      {dest: 'dest/all.js', src: ['expand/js/bar.js', 'expand/js/foo.js']},\n    ];\n    test.deepEqual(actual, expected, 'if dest is same for multiple src, create an array of src');\n    test.done();\n  },\n};\n\n// Compare two buffers. Returns true if they are equivalent.\nvar compareBuffers = function(buf1, buf2) {\n  if (!Buffer.isBuffer(buf1) || !Buffer.isBuffer(buf2)) { return false; }\n  if (buf1.length !== buf2.length) { return false; }\n  for (var i = 0; i < buf2.length; i++) {\n    if (buf1[i] !== buf2[i]) { return false; }\n  }\n  return true;\n};\n\n// Compare two files. Returns true if they are equivalent.\nvar compareFiles = function(filepath1, filepath2) {\n  return compareBuffers(fs.readFileSync(filepath1), fs.readFileSync(filepath2));\n};\n\nexports.file = {\n  setUp: function(done) {\n    this.defaultEncoding = grunt.file.defaultEncoding;\n    grunt.file.defaultEncoding = 'utf8';\n    this.string = 'A\u00e7\u00e3o \u00e9 isso a\u00ed\\n';\n    this.object = {foo: 'A\u00e7\u00e3o \u00e9 isso a\u00ed', bar: ['\u00f8mg', 'p\u00f8nies']};\n    this.writeOption = grunt.option('write');\n\n    // Testing that warnings were displayed.\n    this.oldFailWarnFn = grunt.fail.warn;\n    this.oldLogWarnFn = grunt.log.warn;\n    this.resetWarnCount = function() {\n      this.warnCount = 0;\n    }.bind(this);\n    grunt.fail.warn = grunt.log.warn = function() {\n      this.warnCount += 1;\n    }.bind(this);\n\n    done();\n  },\n  tearDown: function(done) {\n    grunt.file.defaultEncoding = this.defaultEncoding;\n    grunt.option('write', this.writeOption);\n\n    grunt.fail.warn = this.oldFailWarnFn;\n    grunt.log.warn = this.oldLogWarnFn;\n\n    done();\n  },\n  'read': function(test) {\n    test.expect(6);\n    test.strictEqual(grunt.file.read('test/fixtures/utf8.txt'), this.string, 'file should be read as utf8 by default.');\n    test.strictEqual(grunt.file.read('test/fixtures/iso-8859-1.txt', {encoding: 'iso-8859-1'}), this.string, 'file should be read using the specified encoding.');\n    test.ok(compareBuffers(grunt.file.read('test/fixtures/octocat.png', {encoding: null}), fs.readFileSync('test/fixtures/octocat.png')), 'file should be read as a buffer if encoding is specified as null.');\n\n    test.strictEqual(grunt.file.read('test/fixtures/BOM.txt'), 'foo', 'file should have BOM stripped.');\n    grunt.file.preserveBOM = true;\n    test.strictEqual(grunt.file.read('test/fixtures/BOM.txt'), '\\ufeff' + 'foo', 'file should have BOM preserved.');\n    grunt.file.preserveBOM = false;\n\n    grunt.file.defaultEncoding = 'iso-8859-1';\n    test.strictEqual(grunt.file.read('test/fixtures/iso-8859-1.txt'), this.string, 'changing the default encoding should work.');\n    test.done();\n  },\n  'readJSON': function(test) {\n    test.expect(3);\n    var obj;\n    obj = grunt.file.readJSON('test/fixtures/utf8.json');\n    test.deepEqual(obj, this.object, 'file should be read as utf8 by default and parsed correctly.');\n\n    obj = grunt.file.readJSON('test/fixtures/iso-8859-1.json', {encoding: 'iso-8859-1'});\n    test.deepEqual(obj, this.object, 'file should be read using the specified encoding.');\n\n    grunt.file.defaultEncoding = 'iso-8859-1';\n    obj = grunt.file.readJSON('test/fixtures/iso-8859-1.json');\n    test.deepEqual(obj, this.object, 'changing the default encoding should work.');\n    test.done();\n  },\n  'readYAML': function(test) {\n    test.expect(5);\n    var obj;\n    obj = grunt.file.readYAML('test/fixtures/utf8.yaml');\n    test.deepEqual(obj, this.object, 'file should be safely read as utf8 by default and parsed correctly.');\n\n    obj = grunt.file.readYAML('test/fixtures/utf8.yaml', null, {unsafeLoad: true});\n    test.deepEqual(obj, this.object, 'file should be unsafely read as utf8 by default and parsed correctly.');\n\n    obj = grunt.file.readYAML('test/fixtures/iso-8859-1.yaml', {encoding: 'iso-8859-1'});\n    test.deepEqual(obj, this.object, 'file should be read using the specified encoding.');\n\n    test.throws(function() {\n      obj = grunt.file.readYAML('test/fixtures/error.yaml');\n    }, function(err) {\n      return err.message.indexOf('undefined') === -1;\n    }, 'error thrown should not contain undefined.');\n\n    grunt.file.defaultEncoding = 'iso-8859-1';\n    obj = grunt.file.readYAML('test/fixtures/iso-8859-1.yaml');\n    test.deepEqual(obj, this.object, 'changing the default encoding should work.');\n    test.done();\n  },\n  'write': function(test) {\n    test.expect(6);\n    var tmpfile;\n    tmpfile = new Tempfile();\n    grunt.file.write(tmpfile.path, this.string);\n    test.strictEqual(fs.readFileSync(tmpfile.path, 'utf8'), this.string, 'file should be written as utf8 by default.');\n    tmpfile.unlinkSync();\n\n    tmpfile = new Tempfile();\n    grunt.file.write(tmpfile.path, this.string, {encoding: 'iso-8859-1'});\n    test.strictEqual(grunt.file.read(tmpfile.path, {encoding: 'iso-8859-1'}), this.string, 'file should be written using the specified encoding.');\n    tmpfile.unlinkSync();\n\n    tmpfile = new Tempfile();\n    tmpfile.unlinkSync();\n    grunt.file.write(tmpfile.path, this.string, {mode: parseInt('0444', 8)});\n    test.strictEqual(fs.statSync(tmpfile.path).mode & parseInt('0222', 8), 0, 'file should be read only.');\n    fs.chmodSync(tmpfile.path, parseInt('0666', 8));\n    tmpfile.unlinkSync();\n\n    grunt.file.defaultEncoding = 'iso-8859-1';\n    tmpfile = new Tempfile();\n    grunt.file.write(tmpfile.path, this.string);\n    grunt.file.defaultEncoding = 'utf8';\n    test.strictEqual(grunt.file.read(tmpfile.path, {encoding: 'iso-8859-1'}), this.string, 'changing the default encoding should work.');\n    tmpfile.unlinkSync();\n\n    tmpfile = new Tempfile();\n    var octocat = fs.readFileSync('test/fixtures/octocat.png');\n    grunt.file.write(tmpfile.path, octocat);\n    test.ok(compareBuffers(fs.readFileSync(tmpfile.path), octocat), 'buffers should always be written as-specified, with no attempt at re-encoding.');\n    tmpfile.unlinkSync();\n\n    grunt.option('write', false);\n    var filepath = path.join(tmpdir.path, 'should-not-exist.txt');\n    grunt.file.write(filepath, 'test');\n    test.equal(grunt.file.exists(filepath), false, 'file should NOT be created if --no-write was specified.');\n    test.done();\n  },\n  'copy': function(test) {\n    test.expect(4);\n    var tmpfile;\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/utf8.txt', tmpfile.path);\n    test.ok(compareFiles(tmpfile.path, 'test/fixtures/utf8.txt'), 'files should just be copied as encoding-agnostic by default.');\n    tmpfile.unlinkSync();\n\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/iso-8859-1.txt', tmpfile.path);\n    test.ok(compareFiles(tmpfile.path, 'test/fixtures/iso-8859-1.txt'), 'files should just be copied as encoding-agnostic by default.');\n    tmpfile.unlinkSync();\n\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/octocat.png', tmpfile.path);\n    test.ok(compareFiles(tmpfile.path, 'test/fixtures/octocat.png'), 'files should just be copied as encoding-agnostic by default.');\n    tmpfile.unlinkSync();\n\n    grunt.option('write', false);\n    var filepath = path.join(tmpdir.path, 'should-not-exist.txt');\n    grunt.file.copy('test/fixtures/utf8.txt', filepath);\n    test.equal(grunt.file.exists(filepath), false, 'file should NOT be created if --no-write was specified.');\n    test.done();\n  },\n  'copy and process': function(test) {\n    test.expect(14);\n    var tmpfile;\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/utf8.txt', tmpfile.path, {\n      process: function(src, srcpath, destpath) {\n        test.equal(srcpath, 'test/fixtures/utf8.txt', 'srcpath should be passed in, as-specified.');\n        test.equal(destpath, tmpfile.path, 'destpath should be passed in, as-specified.');\n        test.equal(Buffer.isBuffer(src), false, 'when no encoding is specified, use default encoding and process src as a string');\n        test.equal(typeof src, 'string', 'when no encoding is specified, use default encoding and process src as a string');\n        return 'f\u00f8\u00f8' + src + 'b\u00e5r';\n      }\n    });\n    test.equal(grunt.file.read(tmpfile.path), 'f\u00f8\u00f8' + this.string + 'b\u00e5r', 'file should be saved as properly encoded processed string.');\n    tmpfile.unlinkSync();\n\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/iso-8859-1.txt', tmpfile.path, {\n      encoding: 'iso-8859-1',\n      process: function(src) {\n        test.equal(Buffer.isBuffer(src), false, 'use specified encoding and process src as a string');\n        test.equal(typeof src, 'string', 'use specified encoding and process src as a string');\n        return 'f\u00f8\u00f8' + src + 'b\u00e5r';\n      }\n    });\n    test.equal(grunt.file.read(tmpfile.path, {encoding: 'iso-8859-1'}), 'f\u00f8\u00f8' + this.string + 'b\u00e5r', 'file should be saved as properly encoded processed string.');\n    tmpfile.unlinkSync();\n\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/utf8.txt', tmpfile.path, {\n      encoding: null,\n      process: function(src) {\n        test.ok(Buffer.isBuffer(src), 'when encoding is specified as null, process src as a buffer');\n        return Buffer.from('f\u00f8\u00f8' + src.toString() + 'b\u00e5r');\n      }\n    });\n    test.equal(grunt.file.read(tmpfile.path), 'f\u00f8\u00f8' + this.string + 'b\u00e5r', 'file should be saved as the buffer returned by process.');\n    tmpfile.unlinkSync();\n\n    grunt.file.defaultEncoding = 'iso-8859-1';\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/iso-8859-1.txt', tmpfile.path, {\n      process: function(src) {\n        test.equal(Buffer.isBuffer(src), false, 'use non-utf8 default encoding and process src as a string');\n        test.equal(typeof src, 'string', 'use non-utf8 default encoding and process src as a string');\n        return 'f\u00f8\u00f8' + src + 'b\u00e5r';\n      }\n    });\n    test.equal(grunt.file.read(tmpfile.path), 'f\u00f8\u00f8' + this.string + 'b\u00e5r', 'file should be saved as properly encoded processed string.');\n    tmpfile.unlinkSync();\n\n    var filepath = path.join(tmpdir.path, 'should-not-exist.txt');\n    grunt.file.copy('test/fixtures/iso-8859-1.txt', filepath, {\n      process: function() {\n        return false;\n      }\n    });\n    test.equal(grunt.file.exists(filepath), false, 'file should NOT be created if process returns false.');\n    test.done();\n  },\n  'copy and process, noprocess': function(test) {\n    test.expect(4);\n    var tmpfile;\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/utf8.txt', tmpfile.path, {\n      noProcess: true,\n      process: function(src) {\n        return 'f\u00f8\u00f8' + src + 'b\u00e5r';\n      }\n    });\n    test.equal(grunt.file.read(tmpfile.path), this.string, 'file should not have been processed.');\n    tmpfile.unlinkSync();\n\n    ['process', 'noprocess', 'othernoprocess'].forEach(function(filename) {\n      var filepath = path.join(tmpdir.path, filename);\n      grunt.file.copy('test/fixtures/utf8.txt', filepath);\n      var tmpfile = new Tempfile();\n      grunt.file.copy(filepath, tmpfile.path, {\n        noProcess: ['**/*no*'],\n        process: function(src) {\n          return 'f\u00f8\u00f8' + src + 'b\u00e5r';\n        }\n      });\n      if (filename === 'process') {\n        test.equal(grunt.file.read(tmpfile.path), 'f\u00f8\u00f8' + this.string + 'b\u00e5r', 'file should have been processed.');\n      } else {\n        test.equal(grunt.file.read(tmpfile.path), this.string, 'file should not have been processed.');\n      }\n      tmpfile.unlinkSync();\n    }, this);\n\n    test.done();\n  },\n  'copy directory recursively': function(test) {\n    test.expect(34);\n    var copyroot1 = path.join(tmpdir.path, 'copy-dir-1');\n    var copyroot2 = path.join(tmpdir.path, 'copy-dir-2');\n    grunt.file.copy('test/fixtures/expand/', copyroot1);\n    grunt.file.recurse('test/fixtures/expand/', function(srcpath, rootdir, subdir, filename) {\n      var destpath = path.join(copyroot1, subdir || '', filename);\n      test.ok(grunt.file.isFile(srcpath), 'file should have been copied.');\n      test.equal(grunt.file.read(srcpath), grunt.file.read(destpath), 'file contents should be the same.');\n    });\n    grunt.file.mkdir(path.join(copyroot1, 'empty'));\n    grunt.file.mkdir(path.join(copyroot1, 'deep/deeper/empty'));\n    grunt.file.copy(copyroot1, copyroot2, {\n      process: function(contents) {\n        return '<' + contents + '>';\n      },\n    });\n    test.ok(grunt.file.isDir(path.join(copyroot2, 'empty')), 'empty directory should have been created.');\n    test.ok(grunt.file.isDir(path.join(copyroot2, 'deep/deeper/empty')), 'empty directory should have been created.');\n    grunt.file.recurse('test/fixtures/expand/', function(srcpath, rootdir, subdir, filename) {\n      var destpath = path.join(copyroot2, subdir || '', filename);\n      test.ok(grunt.file.isFile(srcpath), 'file should have been copied.');\n      test.equal('<' + grunt.file.read(srcpath) + '>', grunt.file.read(destpath), 'file contents should be processed correctly.');\n    });\n    test.done();\n  },\n  'delete': function(test) {\n    test.expect(2);\n    var oldBase = process.cwd();\n    var cwd = path.resolve(tmpdir.path, 'delete', 'folder');\n    grunt.file.mkdir(cwd);\n    grunt.file.setBase(tmpdir.path);\n\n    grunt.file.write(path.join(cwd, 'test.js'), 'var test;');\n    test.ok(grunt.file.delete(cwd), 'should return true after deleting file.');\n    test.equal(grunt.file.exists(cwd), false, 'file should have been deleted.');\n    grunt.file.setBase(oldBase);\n    test.done();\n  },\n  'delete nonexistent file': function(test) {\n    test.expect(2);\n    this.resetWarnCount();\n    test.ok(!grunt.file.delete('nonexistent'), 'should return false if file does not exist.');\n    test.ok(this.warnCount, 'should issue a warning when deleting non-existent file');\n    test.done();\n  },\n  'delete outside working directory': function(test) {\n    test.expect(4);\n    var oldBase = process.cwd();\n    var cwd = path.resolve(tmpdir.path, 'delete', 'folder');\n    var outsidecwd = path.resolve(tmpdir.path, 'delete', 'outsidecwd');\n    grunt.file.mkdir(cwd);\n    grunt.file.mkdir(outsidecwd);\n    grunt.file.setBase(cwd);\n\n    grunt.file.write(path.join(outsidecwd, 'test.js'), 'var test;');\n\n    this.resetWarnCount();\n    test.equal(grunt.file.delete(path.join(outsidecwd, 'test.js')), false, 'should not delete anything outside the cwd.');\n    test.ok(this.warnCount, 'should issue a warning when deleting outside working directory');\n\n    test.ok(grunt.file.delete(path.join(outsidecwd), {force: true}), 'should delete outside cwd when using the --force.');\n    test.equal(grunt.file.exists(outsidecwd), false, 'file outside cwd should have been deleted when using the --force.');\n\n    grunt.file.setBase(oldBase);\n    test.done();\n  },\n  'dont delete current working directory': function(test) {\n    test.expect(3);\n    var oldBase = process.cwd();\n    var cwd = path.resolve(tmpdir.path, 'dontdelete', 'folder');\n    grunt.file.mkdir(cwd);\n    grunt.file.setBase(cwd);\n\n    this.resetWarnCount();\n    test.equal(grunt.file.delete(cwd), false, 'should not delete the cwd.');\n    test.ok(this.warnCount, 'should issue a warning when trying to delete cwd');\n\n    test.ok(grunt.file.exists(cwd), 'the cwd should exist.');\n\n    grunt.file.setBase(oldBase);\n    test.done();\n  },\n  'dont actually delete with no-write option on': function(test) {\n    test.expect(2);\n    grunt.option('write', false);\n\n    var oldBase = process.cwd();\n    var cwd = path.resolve(tmpdir.path, 'dontdelete', 'folder');\n    grunt.file.mkdir(cwd);\n    grunt.file.setBase(tmpdir.path);\n\n    grunt.file.write(path.join(cwd, 'test.js'), 'var test;');\n    test.ok(grunt.file.delete(cwd), 'should return true after not actually deleting file.');\n    test.equal(grunt.file.exists(cwd), true, 'file should NOT be deleted if --no-write was specified.');\n    grunt.file.setBase(oldBase);\n\n    test.done();\n  },\n  'mkdir': function(test) {\n    test.expect(5);\n    test.doesNotThrow(function() {\n      grunt.file.mkdir(tmpdir.path);\n    }, 'Should not explode if the directory already exists.');\n    test.ok(fs.existsSync(tmpdir.path), 'path should still exist.');\n\n    test.doesNotThrow(function() {\n      grunt.file.mkdir(path.join(tmpdir.path, 'aa/bb/cc'));\n    }, 'Should also not explode, otherwise.');\n    test.ok(path.join(tmpdir.path, 'aa/bb/cc'), 'path should have been created.');\n\n    fs.writeFileSync(path.join(tmpdir.path, 'aa/bb/xx'), 'test');\n    test.throws(function() {\n      grunt.file.mkdir(path.join(tmpdir.path, 'aa/bb/xx/yy'));\n    }, 'Should throw if a path cannot be created (ENOTDIR).');\n\n    test.done();\n  },\n  'recurse': function(test) {\n    test.expect(1);\n    var rootdir = 'test/fixtures/expand';\n    var expected = {};\n    expected[rootdir + '/css/baz.css'] = [rootdir, 'css', 'baz.css'];\n    expected[rootdir + '/css/qux.css'] = [rootdir, 'css', 'qux.css'];\n    expected[rootdir + '/deep/deep.txt'] = [rootdir, 'deep', 'deep.txt'];\n    expected[rootdir + '/deep/deeper/deeper.txt'] = [rootdir, 'deep/deeper', 'deeper.txt'];\n    expected[rootdir + '/deep/deeper/deepest/deepest.txt'] = [rootdir, 'deep/deeper/deepest', 'deepest.txt'];\n    expected[rootdir + '/js/bar.js'] = [rootdir, 'js', 'bar.js'];\n    expected[rootdir + '/js/foo.js'] = [rootdir, 'js', 'foo.js'];\n    expected[rootdir + '/README.md'] = [rootdir, undefined, 'README.md'];\n\n    var actual = {};\n    grunt.file.recurse(rootdir, function(abspath, rootdir, subdir, filename) {\n      actual[abspath] = [rootdir, subdir, filename];\n    });\n\n    test.deepEqual(actual, expected, 'paths and arguments should match.');\n    test.done();\n  },\n  'exists': function(test) {\n    test.expect(6);\n    test.ok(grunt.file.exists('test/fixtures/octocat.png'), 'files exist.');\n    test.ok(grunt.file.exists('test', 'fixtures', 'octocat.png'), 'should work for paths in parts.');\n    test.ok(grunt.file.exists('test/fixtures'), 'directories exist.');\n    test.ok(grunt.file.exists(path.join(tmpdir.path, 'octocat.png')), 'file links exist.');\n    test.ok(grunt.file.exists(path.join(tmpdir.path, 'expand')), 'directory links exist.');\n    test.equal(grunt.file.exists('test/fixtures/does/not/exist'), false, 'nonexistent files do not exist.');\n    test.done();\n  },\n  'isLink': function(test) {\n    test.expect(8);\n    test.equals(grunt.file.isLink('test/fixtures/octocat.png'), false, 'files are not links.');\n    test.equals(grunt.file.isLink('test/fixtures'), false, 'directories are not links.');\n    test.ok(grunt.file.isLink(path.join(tmpdir.path, 'octocat.png')), 'file links are links.');\n    test.ok(grunt.file.isLink(path.join(tmpdir.path, 'expand')), 'directory links are links.');\n    grunt.file.mkdir(path.join(tmpdir.path, 'relative-links'));\n    fs.symlinkSync('test/fixtures/octocat.png', path.join(tmpdir.path, 'relative-links/octocat.png'), 'file');\n    fs.symlinkSync('test/fixtures/expand', path.join(tmpdir.path, 'relative-links/expand'), 'file');\n    test.ok(grunt.file.isLink(path.join(tmpdir.path, 'relative-links/octocat.png')), 'relative file links are links.');\n    test.ok(grunt.file.isLink(path.join(tmpdir.path, 'relative-links/expand')), 'relative directory links are links.');\n    test.ok(grunt.file.isLink(tmpdir.path, 'octocat.png'), 'should work for paths in parts.');\n    test.equals(grunt.file.isLink('test/fixtures/does/not/exist'), false, 'nonexistent files are not links.');\n    test.done();\n  },\n  'isDir': function(test) {\n    test.expect(6);\n    test.equals(grunt.file.isDir('test/fixtures/octocat.png'), false, 'files are not directories.');\n    test.ok(grunt.file.isDir('test/fixtures'), 'directories are directories.');\n    test.ok(grunt.file.isDir('test', 'fixtures'), 'should work for paths in parts.');\n    test.equals(grunt.file.isDir(path.join(tmpdir.path, 'octocat.png')), false, 'file links are not directories.');\n    test.ok(grunt.file.isDir(path.join(tmpdir.path, 'expand')), 'directory links are directories.');\n    test.equals(grunt.file.isDir('test/fixtures/does/not/exist'), false, 'nonexistent files are not directories.');\n    test.done();\n  },\n  'isFile': function(test) {\n    test.expect(6);\n    test.ok(grunt.file.isFile('test/fixtures/octocat.png'), 'files are files.');\n    test.ok(grunt.file.isFile('test', 'fixtures', 'octocat.png'), 'should work for paths in parts.');\n    test.equals(grunt.file.isFile('test/fixtures'), false, 'directories are not files.');\n    test.ok(grunt.file.isFile(path.join(tmpdir.path, 'octocat.png')), 'file links are files.');\n    test.equals(grunt.file.isFile(path.join(tmpdir.path, 'expand')), false, 'directory links are not files.');\n    test.equals(grunt.file.isFile('test/fixtures/does/not/exist'), false, 'nonexistent files are not files.');\n    test.done();\n  },\n  'isPathAbsolute': function(test) {\n    test.expect(6);\n    test.ok(grunt.file.isPathAbsolute(path.resolve('/foo')), 'should return true');\n    test.ok(grunt.file.isPathAbsolute(path.resolve('/foo') + path.sep), 'should return true');\n    test.equal(grunt.file.isPathAbsolute('foo'), false, 'should return false');\n    test.ok(grunt.file.isPathAbsolute(path.resolve('test/fixtures/a.js')), 'should return true');\n    test.equal(grunt.file.isPathAbsolute('test/fixtures/a.js'), false, 'should return false');\n    if (win32) {\n      test.equal(grunt.file.isPathAbsolute('C:/Users/'), true, 'should return true');\n    } else {\n      test.equal(grunt.file.isPathAbsolute('/'), true, 'should return true');\n    }\n    test.done();\n  },\n  'arePathsEquivalent': function(test) {\n    test.expect(5);\n    test.ok(grunt.file.arePathsEquivalent('/foo'), 'should return true');\n    test.ok(grunt.file.arePathsEquivalent('/foo', '/foo/', '/foo/../foo/'), 'should return true');\n    test.ok(grunt.file.arePathsEquivalent(process.cwd(), '.', './', 'test/..'), 'should return true');\n    test.equal(grunt.file.arePathsEquivalent(process.cwd(), '..'), false, 'should return false');\n    test.equal(grunt.file.arePathsEquivalent('.', '..'), false, 'should return false');\n    test.done();\n  },\n  'doesPathContain': function(test) {\n    test.expect(6);\n    test.ok(grunt.file.doesPathContain('/foo', '/foo/bar'), 'should return true');\n    test.ok(grunt.file.doesPathContain('/foo/', '/foo/bar/baz', '/foo/bar', '/foo/whatever'), 'should return true');\n    test.equal(grunt.file.doesPathContain('/foo', '/foo'), false, 'should return false');\n    test.equal(grunt.file.doesPathContain('/foo/xyz', '/foo/xyz/123', '/foo/bar/baz'), false, 'should return false');\n    test.equal(grunt.file.doesPathContain('/foo/xyz', '/foo'), false, 'should return false');\n    test.ok(grunt.file.doesPathContain(process.cwd(), 'test', 'test/fixtures', 'lib'), 'should return true');\n    test.done();\n  },\n  'isPathCwd': function(test) {\n    test.expect(8);\n    test.ok(grunt.file.isPathCwd(process.cwd()), 'cwd is cwd');\n    test.ok(grunt.file.isPathCwd('.'), 'cwd is cwd');\n    test.equal(grunt.file.isPathCwd('test'), false, 'subdirectory is not cwd');\n    test.equal(grunt.file.isPathCwd(path.resolve('test')), false, 'subdirectory is not cwd');\n    test.equal(grunt.file.isPathCwd('..'), false, 'parent is not cwd');\n    test.equal(grunt.file.isPathCwd(path.resolve('..')), false, 'parent is not cwd');\n    test.equal(grunt.file.isPathCwd('/'), false, 'root is not cwd (I hope)');\n    test.equal(grunt.file.isPathCwd('nonexistent'), false, 'nonexistent path is not cwd');\n    test.done();\n  },\n  'isPathInCwd': function(test) {\n    test.expect(8);\n    test.equal(grunt.file.isPathInCwd(process.cwd()), false, 'cwd is not IN cwd');\n    test.equal(grunt.file.isPathInCwd('.'), false, 'cwd is not IN cwd');\n    test.ok(grunt.file.isPathInCwd('test'), 'subdirectory is in cwd');\n    test.ok(grunt.file.isPathInCwd(path.resolve('test')), 'subdirectory is in cwd');\n    test.equal(grunt.file.isPathInCwd('..'), false, 'parent is not in cwd');\n    test.equal(grunt.file.isPathInCwd(path.resolve('..')), false, 'parent is not in cwd');\n    test.equal(grunt.file.isPathInCwd('/'), false, 'root is not in cwd (I hope)');\n    test.equal(grunt.file.isPathInCwd('nonexistent'), false, 'nonexistent path is not in cwd');\n    test.done();\n  },\n  'cwdUnderSymlink': {\n    setUp: function(done) {\n      this.cwd = process.cwd();\n      process.chdir(path.join(tmpdir.path, 'expand'));\n      done();\n    },\n    tearDown: function(done) {\n      process.chdir(this.cwd);\n      done();\n    },\n    'isPathCwd': function(test) {\n      test.expect(2);\n      test.ok(grunt.file.isPathCwd(process.cwd()), 'cwd is cwd');\n      test.ok(grunt.file.isPathCwd('.'), 'cwd is cwd');\n      test.done();\n    },\n    'isPathInCwd': function(test) {\n      test.expect(2);\n      test.ok(grunt.file.isPathInCwd('deep'), 'subdirectory is in cwd');\n      test.ok(grunt.file.isPathInCwd(path.resolve('deep')), 'subdirectory is in cwd');\n      test.done();\n    },\n  }\n};\n"], "fixing_code": ["'use strict';\n\nvar grunt = require('../grunt');\n\n// Nodejs libs.\nvar fs = require('fs');\nvar path = require('path');\n\n// The module to be exported.\nvar file = module.exports = {};\n\n// External libs.\nfile.glob = require('glob');\nfile.minimatch = require('minimatch');\nfile.findup = require('findup-sync');\nvar YAML = require('js-yaml');\nvar rimraf = require('rimraf');\nvar iconv = require('iconv-lite');\nvar mkdirp = require('mkdirp').sync;\n\n// Windows?\nvar win32 = process.platform === 'win32';\n\n// Normalize \\\\ paths to / paths.\nvar unixifyPath = function(filepath) {\n  if (win32) {\n    return filepath.replace(/\\\\/g, '/');\n  } else {\n    return filepath;\n  }\n};\n\n// Change the current base path (ie, CWD) to the specified path.\nfile.setBase = function() {\n  var dirpath = path.join.apply(path, arguments);\n  process.chdir(dirpath);\n};\n\n// Process specified wildcard glob patterns or filenames against a\n// callback, excluding and uniquing files in the result set.\nvar processPatterns = function(patterns, fn) {\n  // Filepaths to return.\n  var result = [];\n  // Iterate over flattened patterns array.\n  grunt.util._.flattenDeep(patterns).forEach(function(pattern) {\n    // If the first character is ! it should be omitted\n    var exclusion = pattern.indexOf('!') === 0;\n    // If the pattern is an exclusion, remove the !\n    if (exclusion) { pattern = pattern.slice(1); }\n    // Find all matching files for this pattern.\n    var matches = fn(pattern);\n    if (exclusion) {\n      // If an exclusion, remove matching files.\n      result = grunt.util._.difference(result, matches);\n    } else {\n      // Otherwise add matching files.\n      result = grunt.util._.union(result, matches);\n    }\n  });\n  return result;\n};\n\n// Match a filepath or filepaths against one or more wildcard patterns. Returns\n// all matching filepaths.\nfile.match = function(options, patterns, filepaths) {\n  if (grunt.util.kindOf(options) !== 'object') {\n    filepaths = patterns;\n    patterns = options;\n    options = {};\n  }\n  // Return empty set if either patterns or filepaths was omitted.\n  if (patterns == null || filepaths == null) { return []; }\n  // Normalize patterns and filepaths to arrays.\n  if (!Array.isArray(patterns)) { patterns = [patterns]; }\n  if (!Array.isArray(filepaths)) { filepaths = [filepaths]; }\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0 || filepaths.length === 0) { return []; }\n  // Return all matching filepaths.\n  return processPatterns(patterns, function(pattern) {\n    return file.minimatch.match(filepaths, pattern, options);\n  });\n};\n\n// Match a filepath or filepaths against one or more wildcard patterns. Returns\n// true if any of the patterns match.\nfile.isMatch = function() {\n  return file.match.apply(file, arguments).length > 0;\n};\n\n// Return an array of all file paths that match the given wildcard patterns.\nfile.expand = function() {\n  var args = grunt.util.toArray(arguments);\n  // If the first argument is an options object, save those options to pass\n  // into the file.glob.sync method.\n  var options = grunt.util.kindOf(args[0]) === 'object' ? args.shift() : {};\n  // Use the first argument if it's an Array, otherwise convert the arguments\n  // object to an array and use that.\n  var patterns = Array.isArray(args[0]) ? args[0] : args;\n  // Return empty set if there are no patterns or filepaths.\n  if (patterns.length === 0) { return []; }\n  // Return all matching filepaths.\n  var matches = processPatterns(patterns, function(pattern) {\n    // Find all matching files for this pattern.\n    return file.glob.sync(pattern, options);\n  });\n  // Filter result set?\n  if (options.filter) {\n    matches = matches.filter(function(filepath) {\n      filepath = path.join(options.cwd || '', filepath);\n      try {\n        if (typeof options.filter === 'function') {\n          return options.filter(filepath);\n        } else {\n          // If the file is of the right type and exists, this should work.\n          return fs.statSync(filepath)[options.filter]();\n        }\n      } catch (e) {\n        // Otherwise, it's probably not the right type.\n        return false;\n      }\n    });\n  }\n  return matches;\n};\n\nvar pathSeparatorRe = /[\\/\\\\]/g;\n\n// The \"ext\" option refers to either everything after the first dot (default)\n// or everything after the last dot.\nvar extDotRe = {\n  first: /(\\.[^\\/]*)?$/,\n  last: /(\\.[^\\/\\.]*)?$/,\n};\n\n// Build a multi task \"files\" object dynamically.\nfile.expandMapping = function(patterns, destBase, options) {\n  options = grunt.util._.defaults({}, options, {\n    extDot: 'first',\n    rename: function(destBase, destPath) {\n      return path.join(destBase || '', destPath);\n    }\n  });\n  var files = [];\n  var fileByDest = {};\n  // Find all files matching pattern, using passed-in options.\n  file.expand(options, patterns).forEach(function(src) {\n    var destPath = src;\n    // Flatten?\n    if (options.flatten) {\n      destPath = path.basename(destPath);\n    }\n    // Change the extension?\n    if ('ext' in options) {\n      destPath = destPath.replace(extDotRe[options.extDot], options.ext);\n    }\n    // Generate destination filename.\n    var dest = options.rename(destBase, destPath, options);\n    // Prepend cwd to src path if necessary.\n    if (options.cwd) { src = path.join(options.cwd, src); }\n    // Normalize filepaths to be unix-style.\n    dest = dest.replace(pathSeparatorRe, '/');\n    src = src.replace(pathSeparatorRe, '/');\n    // Map correct src path to dest path.\n    if (fileByDest[dest]) {\n      // If dest already exists, push this src onto that dest's src array.\n      fileByDest[dest].src.push(src);\n    } else {\n      // Otherwise create a new src-dest file mapping object.\n      files.push({\n        src: [src],\n        dest: dest,\n      });\n      // And store a reference for later use.\n      fileByDest[dest] = files[files.length - 1];\n    }\n  });\n  return files;\n};\n\n// Like mkdir -p. Create a directory and any intermediary directories.\nfile.mkdir = function(dirpath, mode) {\n  if (grunt.option('no-write')) { return; }\n  try {\n    mkdirp(dirpath, { mode: mode });\n  } catch (e) {\n    throw grunt.util.error('Unable to create directory \"' + dirpath + '\" (Error code: ' + e.code + ').', e);\n  }\n};\n\n// Recurse into a directory, executing callback for each file.\nfile.recurse = function recurse(rootdir, callback, subdir) {\n  var abspath = subdir ? path.join(rootdir, subdir) : rootdir;\n  fs.readdirSync(abspath).forEach(function(filename) {\n    var filepath = path.join(abspath, filename);\n    if (fs.statSync(filepath).isDirectory()) {\n      recurse(rootdir, callback, unixifyPath(path.join(subdir || '', filename || '')));\n    } else {\n      callback(unixifyPath(filepath), rootdir, subdir, filename);\n    }\n  });\n};\n\n// The default file encoding to use.\nfile.defaultEncoding = 'utf8';\n// Whether to preserve the BOM on file.read rather than strip it.\nfile.preserveBOM = false;\n\n// Read a file, return its contents.\nfile.read = function(filepath, options) {\n  if (!options) { options = {}; }\n  var contents;\n  grunt.verbose.write('Reading ' + filepath + '...');\n  try {\n    contents = fs.readFileSync(String(filepath));\n    // If encoding is not explicitly null, convert from encoded buffer to a\n    // string. If no encoding was specified, use the default.\n    if (options.encoding !== null) {\n      contents = iconv.decode(contents, options.encoding || file.defaultEncoding, {stripBOM: !file.preserveBOM});\n    }\n    grunt.verbose.ok();\n    return contents;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to read \"' + filepath + '\" file (Error code: ' + e.code + ').', e);\n  }\n};\n\n// Read a file, parse its contents, return an object.\nfile.readJSON = function(filepath, options) {\n  var src = file.read(filepath, options);\n  var result;\n  grunt.verbose.write('Parsing ' + filepath + '...');\n  try {\n    result = JSON.parse(src);\n    grunt.verbose.ok();\n    return result;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to parse \"' + filepath + '\" file (' + e.message + ').', e);\n  }\n};\n\n// Read a YAML file, parse its contents, return an object.\nfile.readYAML = function(filepath, options, yamlOptions) {\n  if (!options) { options = {}; }\n  if (!yamlOptions) { yamlOptions = {}; }\n\n  var src = file.read(filepath, options);\n  var result;\n  grunt.verbose.write('Parsing ' + filepath + '...');\n  try {\n    // use the recommended way of reading YAML files\n    // https://github.com/nodeca/js-yaml#safeload-string---options-\n    if (yamlOptions.unsafeLoad) {\n      result = YAML.load(src);\n    } else {\n      result = YAML.safeLoad(src);\n    }\n    grunt.verbose.ok();\n    return result;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to parse \"' + filepath + '\" file (' + e.message + ').', e);\n  }\n};\n\n// Write a file.\nfile.write = function(filepath, contents, options) {\n  if (!options) { options = {}; }\n  var nowrite = grunt.option('no-write');\n  grunt.verbose.write((nowrite ? 'Not actually writing ' : 'Writing ') + filepath + '...');\n  // Create path, if necessary.\n  file.mkdir(path.dirname(filepath));\n  try {\n    // If contents is already a Buffer, don't try to encode it. If no encoding\n    // was specified, use the default.\n    if (!Buffer.isBuffer(contents)) {\n      contents = iconv.encode(contents, options.encoding || file.defaultEncoding);\n    }\n    // Actually write file.\n    if (!nowrite) {\n      fs.writeFileSync(filepath, contents, 'mode' in options ? {mode: options.mode} : {});\n    }\n    grunt.verbose.ok();\n    return true;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to write \"' + filepath + '\" file (Error code: ' + e.code + ').', e);\n  }\n};\n\n// Read a file, optionally processing its content, then write the output.\n// Or read a directory, recursively creating directories, reading files,\n// processing content, writing output.\n// Handles symlinks by coping them as files or directories.\nfile.copy = function copy(srcpath, destpath, options) {\n  if (file._isSymbolicLink(srcpath)) {\n    file._copySymbolicLink(srcpath, destpath);\n  } else if (file.isDir(srcpath)) {\n    // Copy a directory, recursively.\n    // Explicitly create new dest directory.\n    file.mkdir(destpath);\n    // Iterate over all sub-files/dirs, recursing.\n    fs.readdirSync(srcpath).forEach(function(filepath) {\n      copy(path.join(srcpath, filepath), path.join(destpath, filepath), options);\n    });\n  } else {\n    // Copy a single file.\n    file._copy(srcpath, destpath, options);\n  }\n};\n\n// Read a file, optionally processing its content, then write the output.\nfile._copy = function(srcpath, destpath, options) {\n  if (!options) { options = {}; }\n  // If a process function was specified, and noProcess isn't true or doesn't\n  // match the srcpath, process the file's source.\n  var process = options.process && options.noProcess !== true &&\n    !(options.noProcess && file.isMatch(options.noProcess, srcpath));\n  // If the file will be processed, use the encoding as-specified. Otherwise,\n  // use an encoding of null to force the file to be read/written as a Buffer.\n  var readWriteOptions = process ? options : {encoding: null};\n  // Actually read the file.\n  var contents = file.read(srcpath, readWriteOptions);\n  if (process) {\n    grunt.verbose.write('Processing source...');\n    try {\n      contents = options.process(contents, srcpath, destpath);\n      grunt.verbose.ok();\n    } catch (e) {\n      grunt.verbose.error();\n      throw grunt.util.error('Error while processing \"' + srcpath + '\" file.', e);\n    }\n  }\n  // Abort copy if the process function returns false.\n  if (contents === false) {\n    grunt.verbose.writeln('Write aborted.');\n  } else {\n    file.write(destpath, contents, readWriteOptions);\n  }\n};\n\n// Delete folders and files recursively\nfile.delete = function(filepath, options) {\n  filepath = String(filepath);\n\n  var nowrite = grunt.option('no-write');\n  if (!options) {\n    options = {force: grunt.option('force') || false};\n  }\n\n  grunt.verbose.write((nowrite ? 'Not actually deleting ' : 'Deleting ') + filepath + '...');\n\n  if (!file.exists(filepath)) {\n    grunt.verbose.error();\n    grunt.log.warn('Cannot delete nonexistent file.');\n    return false;\n  }\n\n  // Only delete cwd or outside cwd if --force enabled. Be careful, people!\n  if (!options.force) {\n    if (file.isPathCwd(filepath)) {\n      grunt.verbose.error();\n      grunt.fail.warn('Cannot delete the current working directory.');\n      return false;\n    } else if (!file.isPathInCwd(filepath)) {\n      grunt.verbose.error();\n      grunt.fail.warn('Cannot delete files outside the current working directory.');\n      return false;\n    }\n  }\n\n  try {\n    // Actually delete. Or not.\n    if (!nowrite) {\n      rimraf.sync(filepath);\n    }\n    grunt.verbose.ok();\n    return true;\n  } catch (e) {\n    grunt.verbose.error();\n    throw grunt.util.error('Unable to delete \"' + filepath + '\" file (' + e.message + ').', e);\n  }\n};\n\n// True if the file path exists.\nfile.exists = function() {\n  var filepath = path.join.apply(path, arguments);\n  return fs.existsSync(filepath);\n};\n\n// True if the file is a symbolic link.\nfile.isLink = function() {\n  var filepath = path.join.apply(path, arguments);\n  try {\n    return fs.lstatSync(filepath).isSymbolicLink();\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      // The file doesn't exist, so it's not a symbolic link.\n      return false;\n    }\n    throw grunt.util.error('Unable to read \"' + filepath + '\" file (Error code: ' + e.code + ').', e);\n  }\n};\n\n// True if the path is a directory.\nfile.isDir = function() {\n  var filepath = path.join.apply(path, arguments);\n  return file.exists(filepath) && fs.statSync(filepath).isDirectory();\n};\n\n// True if the path is a file.\nfile.isFile = function() {\n  var filepath = path.join.apply(path, arguments);\n  return file.exists(filepath) && fs.statSync(filepath).isFile();\n};\n\n// Is a given file path absolute?\nfile.isPathAbsolute = function() {\n  var filepath = path.join.apply(path, arguments);\n  return path.isAbsolute(filepath);\n};\n\n// Do all the specified paths refer to the same path?\nfile.arePathsEquivalent = function(first) {\n  first = path.resolve(first);\n  for (var i = 1; i < arguments.length; i++) {\n    if (first !== path.resolve(arguments[i])) { return false; }\n  }\n  return true;\n};\n\n// Are descendant path(s) contained within ancestor path? Note: does not test\n// if paths actually exist.\nfile.doesPathContain = function(ancestor) {\n  ancestor = path.resolve(ancestor);\n  var relative;\n  for (var i = 1; i < arguments.length; i++) {\n    relative = path.relative(path.resolve(arguments[i]), ancestor);\n    if (relative === '' || /\\w+/.test(relative)) { return false; }\n  }\n  return true;\n};\n\n// Test to see if a filepath is the CWD.\nfile.isPathCwd = function() {\n  var filepath = path.join.apply(path, arguments);\n  try {\n    return file.arePathsEquivalent(fs.realpathSync(process.cwd()), fs.realpathSync(filepath));\n  } catch (e) {\n    return false;\n  }\n};\n\nfile._isSymbolicLink = function() {\n  var filepath = path.join.apply(path, arguments);\n  return fs.lstatSync(filepath).isSymbolicLink();\n};\n\nfile._copySymbolicLink = function(srcpath, destpath) {\n  var destdir = path.join(destpath, '..');\n  var fileBase = path.basename(srcpath);\n  // Use the correct relative path for the symlink\n  if (!grunt.file.isPathAbsolute(srcpath)) {\n    srcpath = path.relative(destdir, srcpath) || '.';\n  }\n  file.mkdir(destdir);\n  var mode = grunt.file.isDir(srcpath) ? 'dir' : 'file';\n  var destpath = path.join(destpath, fileBase);\n  return fs.symlinkSync(srcpath, destpath, mode);\n};\n\n// Test to see if a filepath is contained within the CWD.\nfile.isPathInCwd = function() {\n  var filepath = path.join.apply(path, arguments);\n  try {\n    return file.doesPathContain(fs.realpathSync(process.cwd()), fs.realpathSync(filepath));\n  } catch (e) {\n    return false;\n  }\n};\n", "{\n  \"name\": \"grunt\",\n  \"description\": \"The JavaScript Task Runner\",\n  \"version\": \"1.4.1\",\n  \"author\": \"Grunt Development Team (https://gruntjs.com/development-team)\",\n  \"homepage\": \"https://gruntjs.com/\",\n  \"repository\": \"https://github.com/gruntjs/grunt.git\",\n  \"license\": \"MIT\",\n  \"engines\": {\n    \"node\": \">=8\"\n  },\n  \"scripts\": {\n    \"test\": \"node bin/grunt test\",\n    \"test-tap\": \"node bin/grunt test:tap\"\n  },\n  \"main\": \"lib/grunt\",\n  \"bin\": {\n    \"grunt\": \"bin/grunt\"\n  },\n  \"keywords\": [\n    \"task\",\n    \"async\",\n    \"cli\",\n    \"minify\",\n    \"uglify\",\n    \"build\",\n    \"lodash\",\n    \"unit\",\n    \"test\",\n    \"qunit\",\n    \"nodeunit\",\n    \"server\",\n    \"init\",\n    \"scaffold\",\n    \"make\",\n    \"jake\",\n    \"tool\"\n  ],\n  \"dependencies\": {\n    \"dateformat\": \"~3.0.3\",\n    \"eventemitter2\": \"~0.4.13\",\n    \"exit\": \"~0.1.2\",\n    \"findup-sync\": \"~0.3.0\",\n    \"glob\": \"~7.1.6\",\n    \"grunt-cli\": \"~1.4.3\",\n    \"grunt-known-options\": \"~2.0.0\",\n    \"grunt-legacy-log\": \"~3.0.0\",\n    \"grunt-legacy-util\": \"~2.0.1\",\n    \"iconv-lite\": \"~0.4.13\",\n    \"js-yaml\": \"~3.14.0\",\n    \"minimatch\": \"~3.0.4\",\n    \"mkdirp\": \"~1.0.4\",\n    \"nopt\": \"~3.0.6\",\n    \"rimraf\": \"~3.0.2\"\n  },\n  \"devDependencies\": {\n    \"difflet\": \"~1.0.1\",\n    \"eslint-config-grunt\": \"~1.0.1\",\n    \"grunt-contrib-nodeunit\": \"~4.0.0\",\n    \"grunt-contrib-watch\": \"~1.1.0\",\n    \"grunt-eslint\": \"~18.1.0\",\n    \"temporary\": \"~0.0.4\",\n    \"through2\": \"~4.0.2\"\n  },\n  \"files\": [\n    \"lib\",\n    \"bin\"\n  ]\n}\n", "'use strict';\n\nvar grunt = require('../../lib/grunt');\n\nvar fs = require('fs');\nvar path = require('path');\n\nvar Tempfile = require('temporary/lib/file');\nvar Tempdir = require('temporary/lib/dir');\n\nvar win32 = process.platform === 'win32';\n\nvar tmpdir = new Tempdir();\ntry {\n  fs.symlinkSync(path.resolve('test/fixtures/octocat.png'), path.join(tmpdir.path, 'octocat.png'), 'file');\n  fs.symlinkSync(path.resolve('test/fixtures/expand'), path.join(tmpdir.path, 'expand'), 'dir');\n} catch (err) {\n  console.error('** ERROR: Cannot create symbolic links; link-related tests will fail.');\n  if (win32) {\n    console.error('** Tests must be run with Administrator privileges on Windows.');\n  }\n}\n\nexports['file.match'] = {\n  'empty set': function(test) {\n    test.expect(12);\n    // Should return empty set if a required argument is missing or an empty set.\n    test.deepEqual(grunt.file.match(null, null), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match({}, null, null), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match(null, 'foo.js'), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match('*.js', null), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match({}, null, 'foo.js'), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match({}, '*.js', null), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match({}, [], 'foo.js'), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match({}, '*.js', []), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match(null, ['foo.js']), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match(['*.js'], null), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match({}, null, ['foo.js']), [], 'should return empty set.');\n    test.deepEqual(grunt.file.match({}, ['*.js'], null), [], 'should return empty set.');\n    test.done();\n  },\n  'basic matching': function(test) {\n    test.expect(6);\n    test.deepEqual(grunt.file.match('*.js', 'foo.js'), ['foo.js'], 'should match correctly.');\n    test.deepEqual(grunt.file.match('*.js', ['foo.js']), ['foo.js'], 'should match correctly.');\n    test.deepEqual(grunt.file.match('*.js', ['foo.js', 'bar.css']), ['foo.js'], 'should match correctly.');\n    test.deepEqual(grunt.file.match(['*.js', '*.css'], 'foo.js'), ['foo.js'], 'should match correctly.');\n    test.deepEqual(grunt.file.match(['*.js', '*.css'], ['foo.js']), ['foo.js'], 'should match correctly.');\n    test.deepEqual(grunt.file.match(['*.js', '*.css'], ['foo.js', 'bar.css']), ['foo.js', 'bar.css'], 'should match correctly.');\n    test.done();\n  },\n  'no matches': function(test) {\n    test.expect(2);\n    test.deepEqual(grunt.file.match('*.js', 'foo.css'), [], 'should fail to match.');\n    test.deepEqual(grunt.file.match('*.js', ['foo.css', 'bar.css']), [], 'should fail to match.');\n    test.done();\n  },\n  'unique': function(test) {\n    test.expect(2);\n    test.deepEqual(grunt.file.match('*.js', ['foo.js', 'foo.js']), ['foo.js'], 'should return a uniqued set.');\n    test.deepEqual(grunt.file.match(['*.js', '*.*'], ['foo.js', 'foo.js']), ['foo.js'], 'should return a uniqued set.');\n    test.done();\n  },\n  'flatten': function(test) {\n    test.expect(1);\n    test.deepEqual(grunt.file.match([['*.js', '*.css'], ['*.*', '*.js']], ['foo.js', 'bar.css']), ['foo.js', 'bar.css'], 'should process nested pattern arrays correctly.');\n    test.done();\n  },\n  'exclusion': function(test) {\n    test.expect(5);\n    test.deepEqual(grunt.file.match(['!*.js'], ['foo.js', 'bar.js']), [], 'solitary exclusion should match nothing');\n    test.deepEqual(grunt.file.match(['*.js', '!*.js'], ['foo.js', 'bar.js']), [], 'exclusion should cancel match');\n    test.deepEqual(grunt.file.match(['*.js', '!f*.js'], ['foo.js', 'bar.js', 'baz.js']), ['bar.js', 'baz.js'], 'partial exclusion should partially cancel match');\n    test.deepEqual(grunt.file.match(['*.js', '!*.js', 'b*.js'], ['foo.js', 'bar.js', 'baz.js']), ['bar.js', 'baz.js'], 'inclusion / exclusion order matters');\n    test.deepEqual(grunt.file.match(['*.js', '!f*.js', '*.js'], ['foo.js', 'bar.js', 'baz.js']), ['bar.js', 'baz.js', 'foo.js'], 'inclusion / exclusion order matters');\n    test.done();\n  },\n  'options.matchBase': function(test) {\n    test.expect(2);\n    test.deepEqual(grunt.file.match({matchBase: true}, '*.js', ['foo.js', 'bar', 'baz/xyz.js']), ['foo.js', 'baz/xyz.js'], 'should matchBase (minimatch) when specified.');\n    test.deepEqual(grunt.file.match('*.js', ['foo.js', 'bar', 'baz/xyz.js']), ['foo.js'], 'should not matchBase (minimatch) by default.');\n    test.done();\n  }\n};\n\nexports['file.isMatch'] = {\n  'basic matching': function(test) {\n    test.expect(6);\n    test.ok(grunt.file.isMatch('*.js', 'foo.js'), 'should match correctly.');\n    test.ok(grunt.file.isMatch('*.js', ['foo.js']), 'should match correctly.');\n    test.ok(grunt.file.isMatch('*.js', ['foo.js', 'bar.css']), 'should match correctly.');\n    test.ok(grunt.file.isMatch(['*.js', '*.css'], 'foo.js'), 'should match correctly.');\n    test.ok(grunt.file.isMatch(['*.js', '*.css'], ['foo.js']), 'should match correctly.');\n    test.ok(grunt.file.isMatch(['*.js', '*.css'], ['foo.js', 'bar.css']), 'should match correctly.');\n    test.done();\n  },\n  'no matches': function(test) {\n    test.expect(6);\n    test.equal(grunt.file.isMatch('*.js', 'foo.css'), false, 'should fail to match.');\n    test.equal(grunt.file.isMatch('*.js', ['foo.css', 'bar.css']), false, 'should fail to match.');\n    test.equal(grunt.file.isMatch(null, 'foo.css'), false, 'should fail to match.');\n    test.equal(grunt.file.isMatch('*.js', null), false, 'should fail to match.');\n    test.equal(grunt.file.isMatch([], 'foo.css'), false, 'should fail to match.');\n    test.equal(grunt.file.isMatch('*.js', []), false, 'should fail to match.');\n    test.done();\n  },\n  'options.matchBase': function(test) {\n    test.expect(2);\n    test.ok(grunt.file.isMatch({matchBase: true}, '*.js', ['baz/xyz.js']), 'should matchBase (minimatch) when specified.');\n    test.equal(grunt.file.isMatch('*.js', ['baz/xyz.js']), false, 'should not matchBase (minimatch) by default.');\n    test.done();\n  }\n};\n\nexports['file.expand*'] = {\n  setUp: function(done) {\n    this.cwd = process.cwd();\n    process.chdir('test/fixtures/expand');\n    done();\n  },\n  tearDown: function(done) {\n    process.chdir(this.cwd);\n    done();\n  },\n  'basic matching': function(test) {\n    test.expect(8);\n    test.deepEqual(grunt.file.expand('**/*.js'), ['js/bar.js', 'js/foo.js'], 'should match.');\n    test.deepEqual(grunt.file.expand('**/*.js', '**/*.css'), ['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css'], 'should match.');\n    test.deepEqual(grunt.file.expand(['**/*.js', '**/*.css']), ['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css'], 'should match.');\n    test.deepEqual(grunt.file.expand('**d*/**'), [\n      'deep',\n      'deep/deep.txt',\n      'deep/deeper',\n      'deep/deeper/deeper.txt',\n      'deep/deeper/deepest',\n      'deep/deeper/deepest/deepest.txt'], 'should match files and directories.');\n    test.deepEqual(grunt.file.expand({mark: true}, '**d*/**'), [\n      'deep/',\n      'deep/deep.txt',\n      'deep/deeper/',\n      'deep/deeper/deeper.txt',\n      'deep/deeper/deepest/',\n      'deep/deeper/deepest/deepest.txt'], 'the minimatch \"mark\" option ensures directories end in /.');\n    test.deepEqual(grunt.file.expand('**d*/**/'), [\n      'deep/',\n      'deep/deeper/',\n      'deep/deeper/deepest/'], 'should match directories, arbitrary / at the end appears in matches.');\n    test.deepEqual(grunt.file.expand({mark: true}, '**d*/**/'), [\n      'deep/',\n      'deep/deeper/',\n      'deep/deeper/deepest/'], 'should match directories, arbitrary / at the end appears in matches.');\n    test.deepEqual(grunt.file.expand('*.xyz'), [], 'should fail to match.');\n    test.done();\n  },\n  'filter': function(test) {\n    test.expect(5);\n    test.deepEqual(grunt.file.expand({filter: 'isFile'}, '**d*/**'), [\n      'deep/deep.txt',\n      'deep/deeper/deeper.txt',\n      'deep/deeper/deepest/deepest.txt'\n    ], 'should match files only.');\n    test.deepEqual(grunt.file.expand({filter: 'isDirectory'}, '**d*/**'), [\n      'deep',\n      'deep/deeper',\n      'deep/deeper/deepest'\n    ], 'should match directories only.');\n    test.deepEqual(grunt.file.expand({filter: function(filepath) { return (/deepest/).test(filepath); }}, '**'), [\n      'deep/deeper/deepest',\n      'deep/deeper/deepest/deepest.txt',\n    ], 'should filter arbitrarily.');\n    test.deepEqual(grunt.file.expand({filter: 'isFile'}, 'js', 'css'), [], 'should fail to match.');\n    test.deepEqual(grunt.file.expand({filter: 'isDirectory'}, '**/*.js'), [], 'should fail to match.');\n    test.done();\n  },\n  'unique': function(test) {\n    test.expect(4);\n    test.deepEqual(grunt.file.expand('**/*.js', 'js/*.js'), ['js/bar.js', 'js/foo.js'], 'file list should be uniqed.');\n    test.deepEqual(grunt.file.expand('**/*.js', '**/*.css', 'js/*.js'), ['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css'], 'file list should be uniqed.');\n    test.deepEqual(grunt.file.expand('js', 'js/'), ['js', 'js/'], 'mixed non-ending-/ and ending-/ dirs will not be uniqed by default.');\n    test.deepEqual(grunt.file.expand({mark: true}, 'js', 'js/'), ['js/'], 'mixed non-ending-/ and ending-/ dirs will be uniqed when \"mark\" is specified.');\n    test.done();\n  },\n  'file order': function(test) {\n    test.expect(4);\n    var actual = grunt.file.expand('**/*.{js,css}');\n    var expected = ['css/baz.css', 'css/qux.css', 'js/bar.js', 'js/foo.js'];\n    test.deepEqual(actual, expected, 'should select 4 files in this order, by default.');\n\n    actual = grunt.file.expand('js/foo.js', 'js/bar.js', '**/*.{js,css}');\n    expected = ['js/foo.js', 'js/bar.js', 'css/baz.css', 'css/qux.css'];\n    test.deepEqual(actual, expected, 'specifically-specified-up-front file order should be maintained.');\n\n    actual = grunt.file.expand('js/bar.js', 'js/foo.js', '**/*.{js,css}');\n    expected = ['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css'];\n    test.deepEqual(actual, expected, 'specifically-specified-up-front file order should be maintained.');\n\n    actual = grunt.file.expand('js/foo.js', '**/*.{js,css}', '!js/bar.js', 'js/bar.js');\n    expected = ['js/foo.js', 'css/baz.css', 'css/qux.css', 'js/bar.js'];\n    test.deepEqual(actual, expected, 'if a file is excluded and then re-added, it should be added at the end.');\n    test.done();\n  },\n  'flatten': function(test) {\n    test.expect(1);\n    test.deepEqual(grunt.file.expand([['**/*.js'], ['**/*.css', 'js/*.js']]), ['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css'], 'should match.');\n    test.done();\n  },\n  'exclusion': function(test) {\n    test.expect(8);\n    test.deepEqual(grunt.file.expand(['!js/*.js']), [], 'solitary exclusion should match nothing');\n    test.deepEqual(grunt.file.expand(['js/bar.js', '!js/bar.js']), [], 'exclusion should cancel match');\n    test.deepEqual(grunt.file.expand(['**/*.js', '!js/foo.js']), ['js/bar.js'], 'should omit single file from matched set');\n    test.deepEqual(grunt.file.expand(['!js/foo.js', '**/*.js']), ['js/bar.js', 'js/foo.js'], 'inclusion / exclusion order matters');\n    test.deepEqual(grunt.file.expand(['**/*.js', '**/*.css', '!js/bar.js', '!css/baz.css']), ['js/foo.js', 'css/qux.css'], 'multiple exclusions should be removed from the set');\n    test.deepEqual(grunt.file.expand(['**/*.js', '**/*.css', '!**/*.css']), ['js/bar.js', 'js/foo.js'], 'excluded wildcards should be removed from the matched set');\n    test.deepEqual(grunt.file.expand(['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css', '!**/b*.*']), ['js/foo.js', 'css/qux.css'], 'different pattern for exclusion should still work');\n    test.deepEqual(grunt.file.expand(['js/bar.js', '!**/b*.*', 'js/foo.js', 'css/baz.css', 'css/qux.css']), ['js/foo.js', 'css/baz.css', 'css/qux.css'], 'inclusion / exclusion order matters');\n    test.done();\n  },\n  'options.matchBase': function(test) {\n    test.expect(4);\n    var opts = {matchBase: true};\n    test.deepEqual(grunt.file.expand('*.js'), [], 'should not matchBase (minimatch) by default.');\n    test.deepEqual(grunt.file.expand(opts, '*.js'), ['js/bar.js', 'js/foo.js'], 'options should be passed through to minimatch.');\n    test.deepEqual(grunt.file.expand(opts, '*.js', '*.css'), ['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css'], 'should match.');\n    test.deepEqual(grunt.file.expand(opts, ['*.js', '*.css']), ['js/bar.js', 'js/foo.js', 'css/baz.css', 'css/qux.css'], 'should match.');\n    test.done();\n  },\n  'options.cwd': function(test) {\n    test.expect(4);\n    var cwd = path.resolve(process.cwd(), '..');\n    test.deepEqual(grunt.file.expand({cwd: cwd}, ['expand/js', 'expand/js/*']), ['expand/js', 'expand/js/bar.js', 'expand/js/foo.js'], 'should match.');\n    test.deepEqual(grunt.file.expand({cwd: cwd, filter: 'isFile'}, ['expand/js', 'expand/js/*']), ['expand/js/bar.js', 'expand/js/foo.js'], 'should match.');\n    test.deepEqual(grunt.file.expand({cwd: cwd, filter: 'isDirectory'}, ['expand/js', 'expand/js/*']), ['expand/js'], 'should match.');\n    test.deepEqual(grunt.file.expand({cwd: cwd, filter: 'isFile'}, ['expand/js', 'expand/js/*', '!**/b*.js']), ['expand/js/foo.js'], 'should negate properly.');\n    test.done();\n  },\n  'options.nonull': function(test) {\n    test.expect(2);\n    var opts = {nonull: true};\n    test.deepEqual(grunt.file.expand(opts, ['js/a*', 'js/b*', 'js/c*']), ['js/a*', 'js/bar.js', 'js/c*'], 'non-matching patterns should be returned in result set.');\n    test.deepEqual(grunt.file.expand(opts, ['js/foo.js', 'js/bar.js', 'js/baz.js']), ['js/foo.js', 'js/bar.js', 'js/baz.js'], 'non-matching filenames should be returned in result set.');\n    test.done();\n  },\n};\n\nexports['file.expandMapping'] = {\n  setUp: function(done) {\n    this.cwd = process.cwd();\n    process.chdir('test/fixtures');\n    done();\n  },\n  tearDown: function(done) {\n    process.chdir(this.cwd);\n    done();\n  },\n  'basic matching': function(test) {\n    test.expect(2);\n\n    var actual = grunt.file.expandMapping(['expand/**/*.txt'], 'dest');\n    var expected = [\n      {dest: 'dest/expand/deep/deep.txt', src: ['expand/deep/deep.txt']},\n      {dest: 'dest/expand/deep/deeper/deeper.txt', src: ['expand/deep/deeper/deeper.txt']},\n      {dest: 'dest/expand/deep/deeper/deepest/deepest.txt', src: ['expand/deep/deeper/deepest/deepest.txt']},\n    ];\n    test.deepEqual(actual, expected, 'basic src-dest options');\n\n    actual = grunt.file.expandMapping(['expand/**/*.txt'], 'dest/');\n    test.deepEqual(actual, expected, 'destBase should behave the same both with or without trailing slash');\n\n    test.done();\n  },\n  'flatten': function(test) {\n    test.expect(1);\n    var actual = grunt.file.expandMapping(['expand/**/*.txt'], 'dest', {flatten: true});\n    var expected = [\n      {dest: 'dest/deep.txt', src: ['expand/deep/deep.txt']},\n      {dest: 'dest/deeper.txt', src: ['expand/deep/deeper/deeper.txt']},\n      {dest: 'dest/deepest.txt', src: ['expand/deep/deeper/deepest/deepest.txt']},\n    ];\n    test.deepEqual(actual, expected, 'dest paths should be flattened pre-destBase+destPath join');\n    test.done();\n  },\n  'ext': function(test) {\n    test.expect(3);\n    var actual, expected;\n    actual = grunt.file.expandMapping(['expand/**/*.txt'], 'dest', {ext: '.foo'});\n    expected = [\n      {dest: 'dest/expand/deep/deep.foo', src: ['expand/deep/deep.txt']},\n      {dest: 'dest/expand/deep/deeper/deeper.foo', src: ['expand/deep/deeper/deeper.txt']},\n      {dest: 'dest/expand/deep/deeper/deepest/deepest.foo', src: ['expand/deep/deeper/deepest/deepest.txt']},\n    ];\n    test.deepEqual(actual, expected, 'specified extension should be added');\n    actual = grunt.file.expandMapping(['expand-mapping-ext/**/file*'], 'dest', {ext: '.foo'});\n    expected = [\n      {dest: 'dest/expand-mapping-ext/dir.ectory/file-no-extension.foo', src: ['expand-mapping-ext/dir.ectory/file-no-extension']},\n      {dest: 'dest/expand-mapping-ext/dir.ectory/sub.dir.ectory/file.foo', src: ['expand-mapping-ext/dir.ectory/sub.dir.ectory/file.ext.ension']},\n      {dest: 'dest/expand-mapping-ext/file.foo', src: ['expand-mapping-ext/file.ext.ension']},\n    ];\n    test.deepEqual(actual, expected, 'specified extension should be added');\n    actual = grunt.file.expandMapping(['expand/**/*.txt'], 'dest', {ext: ''});\n    expected = [\n      {dest: 'dest/expand/deep/deep', src: ['expand/deep/deep.txt']},\n      {dest: 'dest/expand/deep/deeper/deeper', src: ['expand/deep/deeper/deeper.txt']},\n      {dest: 'dest/expand/deep/deeper/deepest/deepest', src: ['expand/deep/deeper/deepest/deepest.txt']},\n    ];\n    test.deepEqual(actual, expected, 'empty string extension should be added');\n    test.done();\n  },\n  'extDot': function(test) {\n    test.expect(2);\n    var actual, expected;\n\n    actual = grunt.file.expandMapping(['expand-mapping-ext/**/file*'], 'dest', {ext: '.foo', extDot: 'first'});\n    expected = [\n      {dest: 'dest/expand-mapping-ext/dir.ectory/file-no-extension.foo', src: ['expand-mapping-ext/dir.ectory/file-no-extension']},\n      {dest: 'dest/expand-mapping-ext/dir.ectory/sub.dir.ectory/file.foo', src: ['expand-mapping-ext/dir.ectory/sub.dir.ectory/file.ext.ension']},\n      {dest: 'dest/expand-mapping-ext/file.foo', src: ['expand-mapping-ext/file.ext.ension']},\n    ];\n    test.deepEqual(actual, expected, 'extDot of \"first\" should replace everything after the first dot in the filename.');\n\n    actual = grunt.file.expandMapping(['expand-mapping-ext/**/file*'], 'dest', {ext: '.foo', extDot: 'last'});\n    expected = [\n      {dest: 'dest/expand-mapping-ext/dir.ectory/file-no-extension.foo', src: ['expand-mapping-ext/dir.ectory/file-no-extension']},\n      {dest: 'dest/expand-mapping-ext/dir.ectory/sub.dir.ectory/file.ext.foo', src: ['expand-mapping-ext/dir.ectory/sub.dir.ectory/file.ext.ension']},\n      {dest: 'dest/expand-mapping-ext/file.ext.foo', src: ['expand-mapping-ext/file.ext.ension']},\n    ];\n    test.deepEqual(actual, expected, 'extDot of \"last\" should replace everything after the last dot in the filename.');\n\n    test.done();\n  },\n  'cwd': function(test) {\n    test.expect(1);\n    var actual = grunt.file.expandMapping(['**/*.txt'], 'dest', {cwd: 'expand'});\n    var expected = [\n      {dest: 'dest/deep/deep.txt', src: ['expand/deep/deep.txt']},\n      {dest: 'dest/deep/deeper/deeper.txt', src: ['expand/deep/deeper/deeper.txt']},\n      {dest: 'dest/deep/deeper/deepest/deepest.txt', src: ['expand/deep/deeper/deepest/deepest.txt']},\n    ];\n    test.deepEqual(actual, expected, 'cwd should be stripped from front of destPath, pre-destBase+destPath join');\n    test.done();\n  },\n  'rename': function(test) {\n    test.expect(1);\n    var actual = grunt.file.expandMapping(['**/*.txt'], 'dest', {\n      cwd: 'expand',\n      flatten: true,\n      rename: function(destBase, destPath, options) {\n        return path.join(destBase, options.cwd, 'o-m-g', destPath);\n      }\n    });\n    var expected = [\n      {dest: 'dest/expand/o-m-g/deep.txt', src: ['expand/deep/deep.txt']},\n      {dest: 'dest/expand/o-m-g/deeper.txt', src: ['expand/deep/deeper/deeper.txt']},\n      {dest: 'dest/expand/o-m-g/deepest.txt', src: ['expand/deep/deeper/deepest/deepest.txt']},\n    ];\n    test.deepEqual(actual, expected, 'custom rename function should be used to build dest, post-flatten');\n    test.done();\n  },\n  'rename to same dest': function(test) {\n    test.expect(1);\n    var actual = grunt.file.expandMapping(['**/*'], 'dest', {\n      filter: 'isFile',\n      cwd: 'expand',\n      flatten: true,\n      nosort: true,\n      rename: function(destBase, destPath) {\n        return path.join(destBase, 'all' + path.extname(destPath));\n      }\n    });\n    var expected = [\n      {dest: 'dest/all.md', src: ['expand/README.md']},\n      {dest: 'dest/all.css', src: ['expand/css/baz.css', 'expand/css/qux.css']},\n      {dest: 'dest/all.txt', src: ['expand/deep/deep.txt', 'expand/deep/deeper/deeper.txt', 'expand/deep/deeper/deepest/deepest.txt']},\n      {dest: 'dest/all.js', src: ['expand/js/bar.js', 'expand/js/foo.js']},\n    ];\n    test.deepEqual(actual, expected, 'if dest is same for multiple src, create an array of src');\n    test.done();\n  },\n};\n\n// Compare two buffers. Returns true if they are equivalent.\nvar compareBuffers = function(buf1, buf2) {\n  if (!Buffer.isBuffer(buf1) || !Buffer.isBuffer(buf2)) { return false; }\n  if (buf1.length !== buf2.length) { return false; }\n  for (var i = 0; i < buf2.length; i++) {\n    if (buf1[i] !== buf2[i]) { return false; }\n  }\n  return true;\n};\n\n// Compare two files. Returns true if they are equivalent.\nvar compareFiles = function(filepath1, filepath2) {\n  return compareBuffers(fs.readFileSync(filepath1), fs.readFileSync(filepath2));\n};\n\nexports.file = {\n  setUp: function(done) {\n    this.defaultEncoding = grunt.file.defaultEncoding;\n    grunt.file.defaultEncoding = 'utf8';\n    this.string = 'A\u00e7\u00e3o \u00e9 isso a\u00ed\\n';\n    this.object = {foo: 'A\u00e7\u00e3o \u00e9 isso a\u00ed', bar: ['\u00f8mg', 'p\u00f8nies']};\n    this.writeOption = grunt.option('write');\n\n    // Testing that warnings were displayed.\n    this.oldFailWarnFn = grunt.fail.warn;\n    this.oldLogWarnFn = grunt.log.warn;\n    this.resetWarnCount = function() {\n      this.warnCount = 0;\n    }.bind(this);\n    grunt.fail.warn = grunt.log.warn = function() {\n      this.warnCount += 1;\n    }.bind(this);\n\n    done();\n  },\n  tearDown: function(done) {\n    grunt.file.defaultEncoding = this.defaultEncoding;\n    grunt.option('write', this.writeOption);\n\n    grunt.fail.warn = this.oldFailWarnFn;\n    grunt.log.warn = this.oldLogWarnFn;\n\n    done();\n  },\n  'read': function(test) {\n    test.expect(6);\n    test.strictEqual(grunt.file.read('test/fixtures/utf8.txt'), this.string, 'file should be read as utf8 by default.');\n    test.strictEqual(grunt.file.read('test/fixtures/iso-8859-1.txt', {encoding: 'iso-8859-1'}), this.string, 'file should be read using the specified encoding.');\n    test.ok(compareBuffers(grunt.file.read('test/fixtures/octocat.png', {encoding: null}), fs.readFileSync('test/fixtures/octocat.png')), 'file should be read as a buffer if encoding is specified as null.');\n\n    test.strictEqual(grunt.file.read('test/fixtures/BOM.txt'), 'foo', 'file should have BOM stripped.');\n    grunt.file.preserveBOM = true;\n    test.strictEqual(grunt.file.read('test/fixtures/BOM.txt'), '\\ufeff' + 'foo', 'file should have BOM preserved.');\n    grunt.file.preserveBOM = false;\n\n    grunt.file.defaultEncoding = 'iso-8859-1';\n    test.strictEqual(grunt.file.read('test/fixtures/iso-8859-1.txt'), this.string, 'changing the default encoding should work.');\n    test.done();\n  },\n  'readJSON': function(test) {\n    test.expect(3);\n    var obj;\n    obj = grunt.file.readJSON('test/fixtures/utf8.json');\n    test.deepEqual(obj, this.object, 'file should be read as utf8 by default and parsed correctly.');\n\n    obj = grunt.file.readJSON('test/fixtures/iso-8859-1.json', {encoding: 'iso-8859-1'});\n    test.deepEqual(obj, this.object, 'file should be read using the specified encoding.');\n\n    grunt.file.defaultEncoding = 'iso-8859-1';\n    obj = grunt.file.readJSON('test/fixtures/iso-8859-1.json');\n    test.deepEqual(obj, this.object, 'changing the default encoding should work.');\n    test.done();\n  },\n  'readYAML': function(test) {\n    test.expect(5);\n    var obj;\n    obj = grunt.file.readYAML('test/fixtures/utf8.yaml');\n    test.deepEqual(obj, this.object, 'file should be safely read as utf8 by default and parsed correctly.');\n\n    obj = grunt.file.readYAML('test/fixtures/utf8.yaml', null, {unsafeLoad: true});\n    test.deepEqual(obj, this.object, 'file should be unsafely read as utf8 by default and parsed correctly.');\n\n    obj = grunt.file.readYAML('test/fixtures/iso-8859-1.yaml', {encoding: 'iso-8859-1'});\n    test.deepEqual(obj, this.object, 'file should be read using the specified encoding.');\n\n    test.throws(function() {\n      obj = grunt.file.readYAML('test/fixtures/error.yaml');\n    }, function(err) {\n      return err.message.indexOf('undefined') === -1;\n    }, 'error thrown should not contain undefined.');\n\n    grunt.file.defaultEncoding = 'iso-8859-1';\n    obj = grunt.file.readYAML('test/fixtures/iso-8859-1.yaml');\n    test.deepEqual(obj, this.object, 'changing the default encoding should work.');\n    test.done();\n  },\n  'write': function(test) {\n    test.expect(6);\n    var tmpfile;\n    tmpfile = new Tempfile();\n    grunt.file.write(tmpfile.path, this.string);\n    test.strictEqual(fs.readFileSync(tmpfile.path, 'utf8'), this.string, 'file should be written as utf8 by default.');\n    tmpfile.unlinkSync();\n\n    tmpfile = new Tempfile();\n    grunt.file.write(tmpfile.path, this.string, {encoding: 'iso-8859-1'});\n    test.strictEqual(grunt.file.read(tmpfile.path, {encoding: 'iso-8859-1'}), this.string, 'file should be written using the specified encoding.');\n    tmpfile.unlinkSync();\n\n    tmpfile = new Tempfile();\n    tmpfile.unlinkSync();\n    grunt.file.write(tmpfile.path, this.string, {mode: parseInt('0444', 8)});\n    test.strictEqual(fs.statSync(tmpfile.path).mode & parseInt('0222', 8), 0, 'file should be read only.');\n    fs.chmodSync(tmpfile.path, parseInt('0666', 8));\n    tmpfile.unlinkSync();\n\n    grunt.file.defaultEncoding = 'iso-8859-1';\n    tmpfile = new Tempfile();\n    grunt.file.write(tmpfile.path, this.string);\n    grunt.file.defaultEncoding = 'utf8';\n    test.strictEqual(grunt.file.read(tmpfile.path, {encoding: 'iso-8859-1'}), this.string, 'changing the default encoding should work.');\n    tmpfile.unlinkSync();\n\n    tmpfile = new Tempfile();\n    var octocat = fs.readFileSync('test/fixtures/octocat.png');\n    grunt.file.write(tmpfile.path, octocat);\n    test.ok(compareBuffers(fs.readFileSync(tmpfile.path), octocat), 'buffers should always be written as-specified, with no attempt at re-encoding.');\n    tmpfile.unlinkSync();\n\n    grunt.option('write', false);\n    var filepath = path.join(tmpdir.path, 'should-not-exist.txt');\n    grunt.file.write(filepath, 'test');\n    test.equal(grunt.file.exists(filepath), false, 'file should NOT be created if --no-write was specified.');\n    test.done();\n  },\n  'copy': function(test) {\n    test.expect(4);\n    var tmpfile;\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/utf8.txt', tmpfile.path);\n    test.ok(compareFiles(tmpfile.path, 'test/fixtures/utf8.txt'), 'files should just be copied as encoding-agnostic by default.');\n    tmpfile.unlinkSync();\n\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/iso-8859-1.txt', tmpfile.path);\n    test.ok(compareFiles(tmpfile.path, 'test/fixtures/iso-8859-1.txt'), 'files should just be copied as encoding-agnostic by default.');\n    tmpfile.unlinkSync();\n\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/octocat.png', tmpfile.path);\n    test.ok(compareFiles(tmpfile.path, 'test/fixtures/octocat.png'), 'files should just be copied as encoding-agnostic by default.');\n    tmpfile.unlinkSync();\n\n    grunt.option('write', false);\n    var filepath = path.join(tmpdir.path, 'should-not-exist.txt');\n    grunt.file.copy('test/fixtures/utf8.txt', filepath);\n    test.equal(grunt.file.exists(filepath), false, 'file should NOT be created if --no-write was specified.');\n    test.done();\n  },\n  'copy and process': function(test) {\n    test.expect(14);\n    var tmpfile;\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/utf8.txt', tmpfile.path, {\n      process: function(src, srcpath, destpath) {\n        test.equal(srcpath, 'test/fixtures/utf8.txt', 'srcpath should be passed in, as-specified.');\n        test.equal(destpath, tmpfile.path, 'destpath should be passed in, as-specified.');\n        test.equal(Buffer.isBuffer(src), false, 'when no encoding is specified, use default encoding and process src as a string');\n        test.equal(typeof src, 'string', 'when no encoding is specified, use default encoding and process src as a string');\n        return 'f\u00f8\u00f8' + src + 'b\u00e5r';\n      }\n    });\n    test.equal(grunt.file.read(tmpfile.path), 'f\u00f8\u00f8' + this.string + 'b\u00e5r', 'file should be saved as properly encoded processed string.');\n    tmpfile.unlinkSync();\n\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/iso-8859-1.txt', tmpfile.path, {\n      encoding: 'iso-8859-1',\n      process: function(src) {\n        test.equal(Buffer.isBuffer(src), false, 'use specified encoding and process src as a string');\n        test.equal(typeof src, 'string', 'use specified encoding and process src as a string');\n        return 'f\u00f8\u00f8' + src + 'b\u00e5r';\n      }\n    });\n    test.equal(grunt.file.read(tmpfile.path, {encoding: 'iso-8859-1'}), 'f\u00f8\u00f8' + this.string + 'b\u00e5r', 'file should be saved as properly encoded processed string.');\n    tmpfile.unlinkSync();\n\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/utf8.txt', tmpfile.path, {\n      encoding: null,\n      process: function(src) {\n        test.ok(Buffer.isBuffer(src), 'when encoding is specified as null, process src as a buffer');\n        return Buffer.from('f\u00f8\u00f8' + src.toString() + 'b\u00e5r');\n      }\n    });\n    test.equal(grunt.file.read(tmpfile.path), 'f\u00f8\u00f8' + this.string + 'b\u00e5r', 'file should be saved as the buffer returned by process.');\n    tmpfile.unlinkSync();\n\n    grunt.file.defaultEncoding = 'iso-8859-1';\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/iso-8859-1.txt', tmpfile.path, {\n      process: function(src) {\n        test.equal(Buffer.isBuffer(src), false, 'use non-utf8 default encoding and process src as a string');\n        test.equal(typeof src, 'string', 'use non-utf8 default encoding and process src as a string');\n        return 'f\u00f8\u00f8' + src + 'b\u00e5r';\n      }\n    });\n    test.equal(grunt.file.read(tmpfile.path), 'f\u00f8\u00f8' + this.string + 'b\u00e5r', 'file should be saved as properly encoded processed string.');\n    tmpfile.unlinkSync();\n\n    var filepath = path.join(tmpdir.path, 'should-not-exist.txt');\n    grunt.file.copy('test/fixtures/iso-8859-1.txt', filepath, {\n      process: function() {\n        return false;\n      }\n    });\n    test.equal(grunt.file.exists(filepath), false, 'file should NOT be created if process returns false.');\n    test.done();\n  },\n  'copy and process, noprocess': function(test) {\n    test.expect(4);\n    var tmpfile;\n    tmpfile = new Tempfile();\n    grunt.file.copy('test/fixtures/utf8.txt', tmpfile.path, {\n      noProcess: true,\n      process: function(src) {\n        return 'f\u00f8\u00f8' + src + 'b\u00e5r';\n      }\n    });\n    test.equal(grunt.file.read(tmpfile.path), this.string, 'file should not have been processed.');\n    tmpfile.unlinkSync();\n\n    ['process', 'noprocess', 'othernoprocess'].forEach(function(filename) {\n      var filepath = path.join(tmpdir.path, filename);\n      grunt.file.copy('test/fixtures/utf8.txt', filepath);\n      var tmpfile = new Tempfile();\n      grunt.file.copy(filepath, tmpfile.path, {\n        noProcess: ['**/*no*'],\n        process: function(src) {\n          return 'f\u00f8\u00f8' + src + 'b\u00e5r';\n        }\n      });\n      if (filename === 'process') {\n        test.equal(grunt.file.read(tmpfile.path), 'f\u00f8\u00f8' + this.string + 'b\u00e5r', 'file should have been processed.');\n      } else {\n        test.equal(grunt.file.read(tmpfile.path), this.string, 'file should not have been processed.');\n      }\n      tmpfile.unlinkSync();\n    }, this);\n\n    test.done();\n  },\n  'copy directory recursively': function(test) {\n    test.expect(34);\n    var copyroot1 = path.join(tmpdir.path, 'copy-dir-1');\n    var copyroot2 = path.join(tmpdir.path, 'copy-dir-2');\n    grunt.file.copy('test/fixtures/expand/', copyroot1);\n    grunt.file.recurse('test/fixtures/expand/', function(srcpath, rootdir, subdir, filename) {\n      var destpath = path.join(copyroot1, subdir || '', filename);\n      test.ok(grunt.file.isFile(srcpath), 'file should have been copied.');\n      test.equal(grunt.file.read(srcpath), grunt.file.read(destpath), 'file contents should be the same.');\n    });\n    grunt.file.mkdir(path.join(copyroot1, 'empty'));\n    grunt.file.mkdir(path.join(copyroot1, 'deep/deeper/empty'));\n    grunt.file.copy(copyroot1, copyroot2, {\n      process: function(contents) {\n        return '<' + contents + '>';\n      },\n    });\n    test.ok(grunt.file.isDir(path.join(copyroot2, 'empty')), 'empty directory should have been created.');\n    test.ok(grunt.file.isDir(path.join(copyroot2, 'deep/deeper/empty')), 'empty directory should have been created.');\n    grunt.file.recurse('test/fixtures/expand/', function(srcpath, rootdir, subdir, filename) {\n      var destpath = path.join(copyroot2, subdir || '', filename);\n      test.ok(grunt.file.isFile(srcpath), 'file should have been copied.');\n      test.equal('<' + grunt.file.read(srcpath) + '>', grunt.file.read(destpath), 'file contents should be processed correctly.');\n    });\n    test.done();\n  },\n  'delete': function(test) {\n    test.expect(2);\n    var oldBase = process.cwd();\n    var cwd = path.resolve(tmpdir.path, 'delete', 'folder');\n    grunt.file.mkdir(cwd);\n    grunt.file.setBase(tmpdir.path);\n\n    grunt.file.write(path.join(cwd, 'test.js'), 'var test;');\n    test.ok(grunt.file.delete(cwd), 'should return true after deleting file.');\n    test.equal(grunt.file.exists(cwd), false, 'file should have been deleted.');\n    grunt.file.setBase(oldBase);\n    test.done();\n  },\n  'delete nonexistent file': function(test) {\n    test.expect(2);\n    this.resetWarnCount();\n    test.ok(!grunt.file.delete('nonexistent'), 'should return false if file does not exist.');\n    test.ok(this.warnCount, 'should issue a warning when deleting non-existent file');\n    test.done();\n  },\n  'delete outside working directory': function(test) {\n    test.expect(4);\n    var oldBase = process.cwd();\n    var cwd = path.resolve(tmpdir.path, 'delete', 'folder');\n    var outsidecwd = path.resolve(tmpdir.path, 'delete', 'outsidecwd');\n    grunt.file.mkdir(cwd);\n    grunt.file.mkdir(outsidecwd);\n    grunt.file.setBase(cwd);\n\n    grunt.file.write(path.join(outsidecwd, 'test.js'), 'var test;');\n\n    this.resetWarnCount();\n    test.equal(grunt.file.delete(path.join(outsidecwd, 'test.js')), false, 'should not delete anything outside the cwd.');\n    test.ok(this.warnCount, 'should issue a warning when deleting outside working directory');\n\n    test.ok(grunt.file.delete(path.join(outsidecwd), {force: true}), 'should delete outside cwd when using the --force.');\n    test.equal(grunt.file.exists(outsidecwd), false, 'file outside cwd should have been deleted when using the --force.');\n\n    grunt.file.setBase(oldBase);\n    test.done();\n  },\n  'dont delete current working directory': function(test) {\n    test.expect(3);\n    var oldBase = process.cwd();\n    var cwd = path.resolve(tmpdir.path, 'dontdelete', 'folder');\n    grunt.file.mkdir(cwd);\n    grunt.file.setBase(cwd);\n\n    this.resetWarnCount();\n    test.equal(grunt.file.delete(cwd), false, 'should not delete the cwd.');\n    test.ok(this.warnCount, 'should issue a warning when trying to delete cwd');\n\n    test.ok(grunt.file.exists(cwd), 'the cwd should exist.');\n\n    grunt.file.setBase(oldBase);\n    test.done();\n  },\n  'dont actually delete with no-write option on': function(test) {\n    test.expect(2);\n    grunt.option('write', false);\n\n    var oldBase = process.cwd();\n    var cwd = path.resolve(tmpdir.path, 'dontdelete', 'folder');\n    grunt.file.mkdir(cwd);\n    grunt.file.setBase(tmpdir.path);\n\n    grunt.file.write(path.join(cwd, 'test.js'), 'var test;');\n    test.ok(grunt.file.delete(cwd), 'should return true after not actually deleting file.');\n    test.equal(grunt.file.exists(cwd), true, 'file should NOT be deleted if --no-write was specified.');\n    grunt.file.setBase(oldBase);\n\n    test.done();\n  },\n  'mkdir': function(test) {\n    test.expect(5);\n    test.doesNotThrow(function() {\n      grunt.file.mkdir(tmpdir.path);\n    }, 'Should not explode if the directory already exists.');\n    test.ok(fs.existsSync(tmpdir.path), 'path should still exist.');\n\n    test.doesNotThrow(function() {\n      grunt.file.mkdir(path.join(tmpdir.path, 'aa/bb/cc'));\n    }, 'Should also not explode, otherwise.');\n    test.ok(path.join(tmpdir.path, 'aa/bb/cc'), 'path should have been created.');\n\n    fs.writeFileSync(path.join(tmpdir.path, 'aa/bb/xx'), 'test');\n    test.throws(function() {\n      grunt.file.mkdir(path.join(tmpdir.path, 'aa/bb/xx/yy'));\n    }, 'Should throw if a path cannot be created (ENOTDIR).');\n\n    test.done();\n  },\n  'recurse': function(test) {\n    test.expect(1);\n    var rootdir = 'test/fixtures/expand';\n    var expected = {};\n    expected[rootdir + '/css/baz.css'] = [rootdir, 'css', 'baz.css'];\n    expected[rootdir + '/css/qux.css'] = [rootdir, 'css', 'qux.css'];\n    expected[rootdir + '/deep/deep.txt'] = [rootdir, 'deep', 'deep.txt'];\n    expected[rootdir + '/deep/deeper/deeper.txt'] = [rootdir, 'deep/deeper', 'deeper.txt'];\n    expected[rootdir + '/deep/deeper/deepest/deepest.txt'] = [rootdir, 'deep/deeper/deepest', 'deepest.txt'];\n    expected[rootdir + '/js/bar.js'] = [rootdir, 'js', 'bar.js'];\n    expected[rootdir + '/js/foo.js'] = [rootdir, 'js', 'foo.js'];\n    expected[rootdir + '/README.md'] = [rootdir, undefined, 'README.md'];\n\n    var actual = {};\n    grunt.file.recurse(rootdir, function(abspath, rootdir, subdir, filename) {\n      actual[abspath] = [rootdir, subdir, filename];\n    });\n\n    test.deepEqual(actual, expected, 'paths and arguments should match.');\n    test.done();\n  },\n  'exists': function(test) {\n    test.expect(6);\n    test.ok(grunt.file.exists('test/fixtures/octocat.png'), 'files exist.');\n    test.ok(grunt.file.exists('test', 'fixtures', 'octocat.png'), 'should work for paths in parts.');\n    test.ok(grunt.file.exists('test/fixtures'), 'directories exist.');\n    test.ok(grunt.file.exists(path.join(tmpdir.path, 'octocat.png')), 'file links exist.');\n    test.ok(grunt.file.exists(path.join(tmpdir.path, 'expand')), 'directory links exist.');\n    test.equal(grunt.file.exists('test/fixtures/does/not/exist'), false, 'nonexistent files do not exist.');\n    test.done();\n  },\n  'isLink': function(test) {\n    test.expect(8);\n    test.equals(grunt.file.isLink('test/fixtures/octocat.png'), false, 'files are not links.');\n    test.equals(grunt.file.isLink('test/fixtures'), false, 'directories are not links.');\n    test.ok(grunt.file.isLink(path.join(tmpdir.path, 'octocat.png')), 'file links are links.');\n    test.ok(grunt.file.isLink(path.join(tmpdir.path, 'expand')), 'directory links are links.');\n    grunt.file.mkdir(path.join(tmpdir.path, 'relative-links'));\n    fs.symlinkSync('test/fixtures/octocat.png', path.join(tmpdir.path, 'relative-links/octocat.png'), 'file');\n    fs.symlinkSync('test/fixtures/expand', path.join(tmpdir.path, 'relative-links/expand'), 'file');\n    test.ok(grunt.file.isLink(path.join(tmpdir.path, 'relative-links/octocat.png')), 'relative file links are links.');\n    test.ok(grunt.file.isLink(path.join(tmpdir.path, 'relative-links/expand')), 'relative directory links are links.');\n    test.ok(grunt.file.isLink(tmpdir.path, 'octocat.png'), 'should work for paths in parts.');\n    test.equals(grunt.file.isLink('test/fixtures/does/not/exist'), false, 'nonexistent files are not links.');\n    test.done();\n  },\n  'isDir': function(test) {\n    test.expect(6);\n    test.equals(grunt.file.isDir('test/fixtures/octocat.png'), false, 'files are not directories.');\n    test.ok(grunt.file.isDir('test/fixtures'), 'directories are directories.');\n    test.ok(grunt.file.isDir('test', 'fixtures'), 'should work for paths in parts.');\n    test.equals(grunt.file.isDir(path.join(tmpdir.path, 'octocat.png')), false, 'file links are not directories.');\n    test.ok(grunt.file.isDir(path.join(tmpdir.path, 'expand')), 'directory links are directories.');\n    test.equals(grunt.file.isDir('test/fixtures/does/not/exist'), false, 'nonexistent files are not directories.');\n    test.done();\n  },\n  'isFile': function(test) {\n    test.expect(6);\n    test.ok(grunt.file.isFile('test/fixtures/octocat.png'), 'files are files.');\n    test.ok(grunt.file.isFile('test', 'fixtures', 'octocat.png'), 'should work for paths in parts.');\n    test.equals(grunt.file.isFile('test/fixtures'), false, 'directories are not files.');\n    test.ok(grunt.file.isFile(path.join(tmpdir.path, 'octocat.png')), 'file links are files.');\n    test.equals(grunt.file.isFile(path.join(tmpdir.path, 'expand')), false, 'directory links are not files.');\n    test.equals(grunt.file.isFile('test/fixtures/does/not/exist'), false, 'nonexistent files are not files.');\n    test.done();\n  },\n  'isPathAbsolute': function(test) {\n    test.expect(6);\n    test.ok(grunt.file.isPathAbsolute(path.resolve('/foo')), 'should return true');\n    test.ok(grunt.file.isPathAbsolute(path.resolve('/foo') + path.sep), 'should return true');\n    test.equal(grunt.file.isPathAbsolute('foo'), false, 'should return false');\n    test.ok(grunt.file.isPathAbsolute(path.resolve('test/fixtures/a.js')), 'should return true');\n    test.equal(grunt.file.isPathAbsolute('test/fixtures/a.js'), false, 'should return false');\n    if (win32) {\n      test.equal(grunt.file.isPathAbsolute('C:/Users/'), true, 'should return true');\n    } else {\n      test.equal(grunt.file.isPathAbsolute('/'), true, 'should return true');\n    }\n    test.done();\n  },\n  'arePathsEquivalent': function(test) {\n    test.expect(5);\n    test.ok(grunt.file.arePathsEquivalent('/foo'), 'should return true');\n    test.ok(grunt.file.arePathsEquivalent('/foo', '/foo/', '/foo/../foo/'), 'should return true');\n    test.ok(grunt.file.arePathsEquivalent(process.cwd(), '.', './', 'test/..'), 'should return true');\n    test.equal(grunt.file.arePathsEquivalent(process.cwd(), '..'), false, 'should return false');\n    test.equal(grunt.file.arePathsEquivalent('.', '..'), false, 'should return false');\n    test.done();\n  },\n  'doesPathContain': function(test) {\n    test.expect(6);\n    test.ok(grunt.file.doesPathContain('/foo', '/foo/bar'), 'should return true');\n    test.ok(grunt.file.doesPathContain('/foo/', '/foo/bar/baz', '/foo/bar', '/foo/whatever'), 'should return true');\n    test.equal(grunt.file.doesPathContain('/foo', '/foo'), false, 'should return false');\n    test.equal(grunt.file.doesPathContain('/foo/xyz', '/foo/xyz/123', '/foo/bar/baz'), false, 'should return false');\n    test.equal(grunt.file.doesPathContain('/foo/xyz', '/foo'), false, 'should return false');\n    test.ok(grunt.file.doesPathContain(process.cwd(), 'test', 'test/fixtures', 'lib'), 'should return true');\n    test.done();\n  },\n  'isPathCwd': function(test) {\n    test.expect(8);\n    test.ok(grunt.file.isPathCwd(process.cwd()), 'cwd is cwd');\n    test.ok(grunt.file.isPathCwd('.'), 'cwd is cwd');\n    test.equal(grunt.file.isPathCwd('test'), false, 'subdirectory is not cwd');\n    test.equal(grunt.file.isPathCwd(path.resolve('test')), false, 'subdirectory is not cwd');\n    test.equal(grunt.file.isPathCwd('..'), false, 'parent is not cwd');\n    test.equal(grunt.file.isPathCwd(path.resolve('..')), false, 'parent is not cwd');\n    test.equal(grunt.file.isPathCwd('/'), false, 'root is not cwd (I hope)');\n    test.equal(grunt.file.isPathCwd('nonexistent'), false, 'nonexistent path is not cwd');\n    test.done();\n  },\n  'isPathInCwd': function(test) {\n    test.expect(8);\n    test.equal(grunt.file.isPathInCwd(process.cwd()), false, 'cwd is not IN cwd');\n    test.equal(grunt.file.isPathInCwd('.'), false, 'cwd is not IN cwd');\n    test.ok(grunt.file.isPathInCwd('test'), 'subdirectory is in cwd');\n    test.ok(grunt.file.isPathInCwd(path.resolve('test')), 'subdirectory is in cwd');\n    test.equal(grunt.file.isPathInCwd('..'), false, 'parent is not in cwd');\n    test.equal(grunt.file.isPathInCwd(path.resolve('..')), false, 'parent is not in cwd');\n    test.equal(grunt.file.isPathInCwd('/'), false, 'root is not in cwd (I hope)');\n    test.equal(grunt.file.isPathInCwd('nonexistent'), false, 'nonexistent path is not in cwd');\n    test.done();\n  },\n  'cwdUnderSymlink': {\n    setUp: function(done) {\n      this.cwd = process.cwd();\n      process.chdir(path.join(tmpdir.path, 'expand'));\n      done();\n    },\n    tearDown: function(done) {\n      process.chdir(this.cwd);\n      done();\n    },\n    'isPathCwd': function(test) {\n      test.expect(2);\n      test.ok(grunt.file.isPathCwd(process.cwd()), 'cwd is cwd');\n      test.ok(grunt.file.isPathCwd('.'), 'cwd is cwd');\n      test.done();\n    },\n    'isPathInCwd': function(test) {\n      test.expect(2);\n      test.ok(grunt.file.isPathInCwd('deep'), 'subdirectory is in cwd');\n      test.ok(grunt.file.isPathInCwd(path.resolve('deep')), 'subdirectory is in cwd');\n      test.done();\n    },\n    'symbolicLinkCopy': function(test) {\n      test.expect(4);\n      var srcfile = new Tempdir();\n      fs.symlinkSync(path.resolve('test/fixtures/octocat.png'), path.join(srcfile.path, 'octocat.png'), 'file');\n      // test symlink copy for files\n      var destdir = new Tempdir();\n      grunt.file.copy(path.join(srcfile.path, 'octocat.png'), destdir.path);\n      test.ok(fs.lstatSync(path.join(srcfile.path, 'octocat.png')).isSymbolicLink());\n      test.ok(fs.lstatSync(path.join(destdir.path, 'octocat.png')).isSymbolicLink());\n\n      // test symlink copy for directories\n      var srcdir = new Tempdir();\n      var destdir = new Tempdir();\n      var fixtures = path.resolve('test/fixtures');\n      var symlinkSource = path.join(srcdir.path, path.basename(fixtures));\n      console.log('symlinkSource', symlinkSource);\n      fs.symlinkSync(fixtures, symlinkSource, 'dir');\n\n      grunt.file.copy(symlinkSource, destdir.path);\n      test.ok(fs.lstatSync(symlinkSource).isSymbolicLink());\n      test.ok(fs.lstatSync(path.join(destdir.path, path.basename(fixtures))).isSymbolicLink());\n      test.done();\n    },\n  }\n};\n"], "buggy_code_start_loc": [294, 45, 895], "buggy_code_end_loc": [451, 60, 895], "fixing_code_start_loc": [295, 45, 896], "fixing_code_end_loc": [473, 60, 919], "type": "CWE-22", "message": "Path Traversal in GitHub repository gruntjs/grunt prior to 1.5.2.", "other": {"cve": {"id": "CVE-2022-0436", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-12T21:15:07.643", "lastModified": "2023-04-06T15:15:08.727", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Path Traversal in GitHub repository gruntjs/grunt prior to 1.5.2."}, {"lang": "es", "value": "Un Salto de Ruta en el repositorio de GitHub gruntjs/grunt versiones anteriores a 1.5.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gruntjs:grunt:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.5.2", "matchCriteriaId": "0A4F35A4-C03E-48B9-8CF8-9B4AA89B6C2B"}]}]}], "references": [{"url": "https://github.com/gruntjs/grunt/commit/aad3d4521c3098fb255fb2db8f2e1d691a033665", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/f55315e9-9f6d-4dbb-8c40-bae50c1ae92b", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/04/msg00008.html", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/gruntjs/grunt/commit/aad3d4521c3098fb255fb2db8f2e1d691a033665"}}