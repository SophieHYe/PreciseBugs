{"buggy_code": ["<?php\n/* Icinga Web 2 | (c) 2018 Icinga Development Team | GPLv2+ */\n\nnamespace Icinga\\Module\\Monitoring\\Backend\\Ido\\Query;\n\n/**\n * Query for host contacts\n */\nclass HostcontactQuery extends IdoQuery\n{\n    protected $allowCustomVars = true;\n\n    protected $groupBase = [\n        'contacts' => ['co.object_id', 'c.contact_id'],\n        'timeperiods' => ['ht.timeperiod_id', 'st.timeperiod_id']\n    ];\n\n    protected $groupOrigin = ['contactgroups', 'hosts', 'services'];\n\n    protected $subQueryTargets = [\n        'hostgroups'    => 'hostgroup',\n        'servicegroups' => 'servicegroup'\n    ];\n\n    protected $columnMap = [\n        'contactgroups' => [\n            'contactgroup'       => 'cgo.name1 COLLATE latin1_general_ci',\n            'contactgroup_name'  => 'cgo.name1',\n            'contactgroup_alias' => 'cg.alias COLLATE latin1_general_ci'\n        ],\n        'contacts' => [\n            'contact_id'                       => 'c.contact_id',\n            'contact'                          => 'co.name1 COLLATE latin1_general_ci',\n            'contact_name'                     => 'co.name1',\n            'contact_alias'                    => 'c.alias COLLATE latin1_general_ci',\n            'contact_email'                    => 'c.email_address COLLATE latin1_general_ci',\n            'contact_pager'                    => 'c.pager_address',\n            'contact_object_id'                => 'c.contact_object_id',\n            'contact_has_host_notfications'    => 'c.host_notifications_enabled',\n            'contact_has_service_notfications' => 'c.service_notifications_enabled',\n            'contact_can_submit_commands'      => 'c.can_submit_commands',\n            'contact_notify_service_recovery'  => 'c.notify_service_recovery',\n            'contact_notify_service_warning'   => 'c.notify_service_warning',\n            'contact_notify_service_critical'  => 'c.notify_service_critical',\n            'contact_notify_service_unknown'   => 'c.notify_service_unknown',\n            'contact_notify_service_flapping'  => 'c.notify_service_flapping',\n            'contact_notify_service_downtime'  => 'c.notify_service_downtime',\n            'contact_notify_host_recovery'     => 'c.notify_host_recovery',\n            'contact_notify_host_down'         => 'c.notify_host_down',\n            'contact_notify_host_unreachable'  => 'c.notify_host_unreachable',\n            'contact_notify_host_flapping'     => 'c.notify_host_flapping',\n            'contact_notify_host_downtime'     => 'c.notify_host_downtime'\n        ],\n        'hostgroups' => [\n            'hostgroup'       => 'hgo.name1 COLLATE latin1_general_ci',\n            'hostgroup_alias' => 'hg.alias COLLATE latin1_general_ci',\n            'hostgroup_name'  => 'hgo.name1'\n        ],\n        'hosts' => [\n            'host'              => 'ho.name1 COLLATE latin1_general_ci',\n            'host_name'         => 'ho.name1',\n            'host_alias'        => 'h.alias',\n            'host_display_name' => 'h.display_name COLLATE latin1_general_ci'\n        ],\n        'instances' => [\n            'instance_name' => 'i.instance_name'\n        ],\n        'servicegroups' => [\n            'servicegroup'       => 'sgo.name1 COLLATE latin1_general_ci',\n            'servicegroup_name'  => 'sgo.name1',\n            'servicegroup_alias' => 'sg.alias COLLATE latin1_general_ci'\n        ],\n        'services' => [\n            'service'              => 'so.name2 COLLATE latin1_general_ci',\n            'service_description'  => 'so.name2',\n            'service_display_name' => 's.display_name COLLATE latin1_general_ci',\n            'service_host_name'    => 'so.name1'\n        ],\n        'timeperiods' => [\n            'contact_notify_host_timeperiod'    => 'ht.alias COLLATE latin1_general_ci',\n            'contact_notify_service_timeperiod' => 'st.alias COLLATE latin1_general_ci'\n        ]\n    ];\n\n    protected function joinBaseTables()\n    {\n        $this->select->from(\n            ['c' => $this->prefix . 'contacts'],\n            []\n        )->join(\n            ['co' => $this->prefix . 'objects'],\n            'co.object_id = c.contact_object_id AND co.is_active = 1',\n            []\n        );\n\n        $this->joinedVirtualTables = array('contacts' => true);\n    }\n\n    /**\n     * Join contact groups\n     */\n    protected function joinContactgroups()\n    {\n        $this->select->joinLeft(\n            ['cgm' => $this->prefix . 'contactgroup_members'],\n            'co.object_id = cgm.contact_object_id',\n            []\n        )->joinLeft(\n            ['cg' => $this->prefix . 'contactgroups'],\n            'cgm.contactgroup_id = cg.contactgroup_id',\n            []\n        )->joinLeft(\n            ['cgo' => $this->prefix . 'objects'],\n            'cg.contactgroup_object_id = cgo.object_id AND cgo.is_active = 1 AND cgo.objecttype_id = 11',\n            []\n        );\n    }\n\n    /**\n     * Join host groups\n     */\n    protected function joinHostgroups()\n    {\n        $this->requireVirtualTable('hosts');\n\n        $this->select->joinLeft(\n            ['hgm' => $this->prefix . 'hostgroup_members'],\n            'hgm.host_object_id = ho.object_id',\n            []\n        )->joinLeft(\n            ['hg' => $this->prefix . 'hostgroups'],\n            'hg.hostgroup_id = hgm.hostgroup_id',\n            []\n        )->joinLeft(\n            ['hgo' => $this->prefix . 'objects'],\n            'hgo.object_id = hg.hostgroup_object_id AND hgo.is_active = 1 AND hgo.objecttype_id = 3',\n            []\n        );\n    }\n\n    /**\n     * Join hosts\n     */\n    protected function joinHosts()\n    {\n        $this->select->joinLeft(\n            ['hc' => $this->prefix . 'host_contacts'],\n            'hc.contact_object_id = c.contact_object_id',\n            []\n        )->joinLeft(\n            ['h' => $this->prefix . 'hosts'],\n            'h.host_id = hc.host_id',\n            []\n        )->joinLeft(\n            ['ho' => $this->prefix . 'objects'],\n            'ho.object_id = h.host_object_id AND ho.is_active = 1',\n            []\n        );\n    }\n\n    /**\n     * Join instances\n     */\n    protected function joinInstances()\n    {\n        $this->select->join(\n            ['i' => $this->prefix . 'instances'],\n            'i.instance_id = c.instance_id',\n            []\n        );\n    }\n\n    /**\n     * Join service groups\n     */\n    protected function joinServicegroups()\n    {\n        $this->requireVirtualTable('services');\n        $this->select->joinLeft(\n            ['sgm' => $this->prefix . 'servicegroup_members'],\n            'sgm.service_object_id = s.service_object_id',\n            []\n        )->joinLeft(\n            ['sg' => $this->prefix . 'servicegroups'],\n            'sg.servicegroup_id = sgm.servicegroup_id',\n            []\n        )->joinLeft(\n            ['sgo' => $this->prefix . 'objects'],\n            'sgo.object_id = sg.servicegroup_object_id AND sgo.is_active = 1 AND sgo.objecttype_id = 4',\n            []\n        );\n    }\n\n    /**\n     * Join services\n     */\n    protected function joinServices()\n    {\n        $this->requireVirtualTable('hosts');\n\n        $this->select->joinLeft(\n            ['s' => $this->prefix . 'services'],\n            's.host_object_id = ho.object_id',\n            []\n        )->joinLeft(\n            ['so' => $this->prefix . 'objects'],\n            'so.object_id = s.service_object_id AND so.is_active = 1 AND so.objecttype_id = 2',\n            []\n        );\n    }\n\n    /**\n     * Join time periods\n     */\n    protected function joinTimeperiods()\n    {\n        $this->select->joinLeft(\n            ['ht' => $this->prefix . 'timeperiods'],\n            'ht.timeperiod_object_id = c.host_timeperiod_object_id',\n            []\n        );\n        $this->select->joinLeft(\n            ['st' => $this->prefix . 'timeperiods'],\n            'st.timeperiod_object_id = c.service_timeperiod_object_id',\n            []\n        );\n    }\n\n    protected function joinSubQuery(IdoQuery $query, $name, $filter, $and, $negate, &$additionalFilter)\n    {\n        if ($name === 'hostgroup') {\n            $this->requireVirtualTable('hosts');\n\n            $query->joinVirtualTable('members');\n\n            return ['hgm.host_object_id', 'ho.object_id'];\n        } elseif ($name === 'servicegroup') {\n            $this->requireVirtualTable('services');\n\n            $query->joinVirtualTable('members');\n\n            return ['sgm.service_object_id', 'so.object_id'];\n        }\n\n        return parent::joinSubQuery($query, $name, $filter, $and, $negate, $additionalFilter);\n    }\n}\n", "<?php\n/* Icinga Web 2 | (c) 2015 Icinga Development Team | GPLv2+ */\n\nnamespace Icinga\\Module\\Monitoring\\Backend\\Ido\\Query;\n\nclass HostserviceproblemsummaryQuery extends IdoQuery\n{\n    /**\n     * {@inheritdoc}\n     */\n    protected $allowCustomVars = true;\n\n    /**\n     * The HoststatusQuery in use\n     *\n     * @var HoststatusQuery\n     */\n    protected $hostStatusQuery;\n\n    /**\n     * {@inheritdoc}\n     */\n    protected $columnMap = array(\n        'instances' => array(\n            'instance_name' => 'i.instance_name'\n        ),\n        'services' => array(\n            'host_name'                 => 'so.name1',\n            'service_description'       => 'so.name2'\n        ),\n        'hostgroups' => array(\n            'hostgroup_name'            => 'hgo.name1'\n        ),\n        'servicegroups' => array(\n            'servicegroup_name'         => 'sgo.name1'\n        ),\n        'problemsummary' => array(\n            'unhandled_service_count'   => 'SUM(\n                CASE\n                    WHEN (ss.problem_has_been_acknowledged + ss.scheduled_downtime_depth + COALESCE(hs.current_state, 0)) > 0\n                    THEN 0\n                    ELSE 1\n                END\n            )'\n        )\n    );\n\n    /**\n     * Set the HoststatusQuery to use\n     *\n     * @param   HoststatusQuery     $query\n     *\n     * @return  $this\n     */\n    public function setHoststatusQuery(HoststatusQuery $query)\n    {\n        $this->hostStatusQuery = clone $query;\n        $this->hostStatusQuery\n            ->clearOrder()\n            ->setIsSubQuery()\n            ->columns(array('object_id'));\n        return $this;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function joinBaseTables()\n    {\n        $this->select->from(\n            array('so' => $this->prefix . 'objects'),\n            array()\n        )->join(\n            array('s' => $this->prefix . 'services'),\n            's.service_object_id = so.object_id AND so.is_active = 1',\n            array()\n        );\n        $this->select->group('so.name1');\n        $this->joinedVirtualTables['services'] = true;\n    }\n\n    /**\n     * Join instances\n     */\n    protected function joinInstances()\n    {\n        $this->select->join(\n            array('i' => $this->prefix . 'instances'),\n            'i.instance_id = so.instance_id',\n            array()\n        );\n    }\n\n    /**\n     * Join host groups\n     */\n    protected function joinHostgroups()\n    {\n        $this->select->joinLeft(\n            array('hgm' => $this->prefix . 'hostgroup_members'),\n            'hgm.host_object_id = s.host_object_id',\n            array()\n        )->joinLeft(\n            array('hg' => $this->prefix . 'hostgroups'),\n            'hg.hostgroup_id = hgm.hostgroup_id',\n            array()\n        )->joinLeft(\n            array('hgo' => $this->prefix . 'objects'),\n            'hgo.object_id = hg.hostgroup_object_id AND hgo.is_active = 1 AND hgo.objecttype_id = 3',\n            array()\n        );\n    }\n\n    /**\n     * Join service groups\n     */\n    protected function joinServicegroups()\n    {\n        $this->select->joinLeft(\n            array('sgm' => $this->prefix . 'servicegroup_members'),\n            'sgm.service_object_id = so.object_id',\n            array()\n        )->joinLeft(\n            array('sg' => $this->prefix . 'servicegroups'),\n            'sgm.servicegroup_id = sg.servicegroup_id',\n            array()\n        )->joinLeft(\n            array('sgo' => $this->prefix . 'objects'),\n            'sgo.object_id = sg.servicegroup_object_id AND sgo.is_active = 1 AND sgo.objecttype_id = 4',\n            array()\n        );\n    }\n\n    /**\n     * Join the statussummary\n     */\n    protected function joinProblemsummary()\n    {\n        $this->select->join(\n            array('ss' => $this->prefix . 'servicestatus'),\n            'ss.service_object_id = so.object_id AND ss.current_state > 0',\n            array()\n        )->join(\n            array('hs' => $this->prefix . 'hoststatus'),\n            'hs.host_object_id = s.host_object_id',\n            array()\n        )->join(\n            array('h' => $this->hostStatusQuery),\n            'h.object_id = s.host_object_id',\n            array()\n        );\n\n        $this->select->having($this->getMappedField('unhandled_service_count') . ' > 0');\n    }\n}\n", "<?php\n/* Icinga Web 2 | (c) 2013 Icinga Development Team | GPLv2+ */\n\nnamespace Icinga\\Module\\Monitoring\\Backend\\Ido\\Query;\n\nuse Icinga\\Data\\Filter\\FilterNot;\nuse Zend_Db_Expr;\nuse Icinga\\Application\\Icinga;\nuse Icinga\\Application\\Hook;\nuse Icinga\\Application\\Logger;\nuse Icinga\\Data\\Db\\DbQuery;\nuse Icinga\\Data\\Filter\\Filter;\nuse Icinga\\Data\\Filter\\FilterExpression;\nuse Icinga\\Exception\\IcingaException;\nuse Icinga\\Exception\\NotImplementedError;\nuse Icinga\\Exception\\ProgrammingError;\nuse Icinga\\Exception\\QueryException;\nuse Icinga\\Web\\Session;\nuse Icinga\\Module\\Monitoring\\Data\\ColumnFilterIterator;\nuse Zend_Db_Select;\n\n/**\n * Base class for Ido Queries\n *\n * This is the base class for all Ido queries and should be extended for new queries\n * The starting point for implementations is the columnMap attribute. This is an asscociative array in the\n * following form:\n *\n * <pre>\n * <code>\n * array(\n *      'virtualTable' => array(\n *          'fieldalias1' => 'queryColumn1',\n *          'fieldalias2' => 'queryColumn2',\n *          ....\n *      ),\n *      'virtualTable2' => array(\n *          'host'       =>  'host_name1'\n *      )\n * )\n * </code>\n * </pre>\n *\n * This allows you to select e.g. fieldalias1, which automatically calls the query code for joining 'virtualTable'. If\n * you afterwards select 'host', 'virtualTable2' will be joined. The joining logic is up to you, in order to make the\n * above example work you need to implement the joinVirtualTable() method which contain your\n * custom (Zend_Db) logic for joining, filtering and querying the data you want.\n *\n */\nabstract class IdoQuery extends DbQuery\n{\n    /**\n     * The prefix to use\n     *\n     * @var string\n     */\n    protected $prefix;\n\n    /**\n     * An array to map aliases to column names\n     *\n     * @var array\n     */\n    protected $idxAliasColumn;\n\n    /**\n     * An array to map aliases to table names\n     *\n     * @var array\n     */\n    protected $idxAliasTable;\n\n    /**\n     * An array to map custom aliases to aliases\n     *\n     * @var array\n     */\n    protected $idxCustomAliases;\n\n    /**\n     * The column map containing all filterable columns\n     *\n     * This must be overwritten by child classes, in the format\n     * array(\n     *      'virtualTable' => array(\n     *          'fieldalias1' => 'queryColumn1',\n     *          'fieldalias2' => 'queryColumn2',\n     *          ....\n     *      )\n     * )\n     *\n     * @var array\n     */\n    protected $columnMap = array();\n\n    /**\n     * Custom vars available for this query\n     *\n     * @var array\n     */\n    protected $customVars = array();\n\n    /**\n     * Printf compatible string to joins custom vars\n     *\n     * - %1$s   Source field, contain the object_id\n     * - %2$s   Alias used for the relation\n     * - %3$s   Name of the CustomVariable\n     *\n     * @var string\n     */\n    private $customVarsJoinTemplate = '%1$s = %2$s.object_id AND %2$s.varname = %3$s';\n\n    /**\n     * An array with all 'virtual' tables that are already joined\n     *\n     * Virtual tables are the keys  of the columnMap array and require a\n     * join%VirtualTableName%() method to be defined in the concrete\n     * query\n     *\n     * @var array\n     */\n    protected $joinedVirtualTables = array();\n\n    /**\n     * A map of virtual table names and corresponding hook instances\n     *\n     * Joins for those tables will be delegated to them\n     *\n     * @var array\n     */\n    protected $hookedVirtualTables = array();\n\n    /**\n     * List of column aliases used for sorting the result\n     *\n     * @var array\n     */\n    protected $orderColumns = array();\n\n    /**\n     * Table to columns map which have to be added to the GROUP BY list if the query is grouped\n     *\n     * @var array\n     */\n    protected $groupBase = array();\n\n    /**\n     * List of table names which initiate grouping if one of them is joined\n     *\n     * @var array\n     */\n    protected $groupOrigin = array();\n\n    /**\n     * Map of table names to query names for which to create subquery filters\n     *\n     * @var array\n     */\n    protected $subQueryTargets = array();\n\n    /**\n     * The primary key column for the instances table\n     *\n     * @var string\n     */\n    protected $instance_id = 'instance_id';\n\n    /**\n     * The primary key column for the objects table\n     *\n     * @var string\n     */\n    protected $object_id       = 'object_id';\n\n    /**\n     * The primary key column for the acknowledgements table\n     *\n     * @var string\n     */\n    protected $acknowledgement_id = 'acknowledgement_id';\n\n    /**\n     * The primary key column for the commenthistory table\n     *\n     * @var string\n     */\n    protected $commenthistory_id = 'commenthistory_id';\n\n    /**\n     * The primary key column for the contactnotifications table\n     *\n     * @var string\n     */\n    protected $contactnotification_id = 'contactnotification_id';\n\n    /**\n     * The primary key column for the downtimehistory table\n     *\n     * @var string\n     */\n    protected $downtimehistory_id = 'downtimehistory_id';\n\n    /**\n     * The primary key column for the flappinghistory table\n     *\n     * @var string\n     */\n    protected $flappinghistory_id = 'flappinghistory_id';\n\n    /**\n     * The primary key column for the notifications table\n     *\n     * @var string\n     */\n    protected $notification_id = 'notification_id';\n\n    /**\n     * The primary key column for the statehistory table\n     *\n     * @var string\n     */\n    protected $statehistory_id = 'statehistory_id';\n\n    /**\n     * The primary key column for the comments table\n     *\n     * @var string\n     */\n    protected $comment_id = 'comment_id';\n\n    /**\n     * The primary key column for the customvariablestatus table\n     *\n     * @var string\n     */\n    protected $customvariablestatus_id = 'customvariablestatus_id';\n\n    /**\n     * The primary key column for the hoststatus table\n     *\n     * @var string\n     */\n    protected $hoststatus_id = 'hoststatus_id';\n\n    /**\n     * The primary key column for the programstatus table\n     *\n     * @var string\n     */\n    protected $programstatus_id = 'programstatus_id';\n\n    /**\n     * The primary key column for the runtimevariables table\n     *\n     * @var string\n     */\n    protected $runtimevariable_id = 'runtimevariable_id';\n\n    /**\n     * The primary key column for the scheduleddowntime table\n     *\n     * @var string\n     */\n    protected $scheduleddowntime_id = 'scheduleddowntime_id';\n\n    /**\n     * The primary key column for the servicestatus table\n     *\n     * @var string\n     */\n    protected $servicestatus_id = 'servicestatus_id';\n\n    /**\n     * The primary key column for the contactstatus table\n     *\n     * @var string\n     */\n    protected $contactstatus_id = 'contactstatus_id';\n\n    /**\n     * The primary key column for the commands table\n     *\n     * @var string\n     */\n    protected $command_id = 'command_id';\n\n    /**\n     * The primary key column for the contactgroup_members table\n     *\n     * @var string\n     */\n    protected $contactgroup_member_id = 'contactgroup_member_id';\n\n    /**\n     * The primary key column for the contactgroups table\n     *\n     * @var string\n     */\n    protected $contactgroup_id = 'contactgroup_id';\n\n    /**\n     * The primary key column for the contacts table\n     *\n     * @var string\n     */\n    protected $contact_id = 'contact_id';\n\n    /**\n     * The primary key column for the customvariables table\n     *\n     * @var string\n     */\n    protected $customvariable_id = 'customvariable_id';\n\n    /**\n     * The primary key column for the host_contactgroups table\n     *\n     * @var string\n     */\n    protected $host_contactgroup_id = 'host_contactgroup_id';\n\n    /**\n     * The primary key column for the host_contacts table\n     *\n     * @var string\n     */\n    protected $host_contact_id = 'host_contact_id';\n\n    /**\n     * The primary key column for the hostgroup_members table\n     *\n     * @var string\n     */\n    protected $hostgroup_member_id = 'hostgroup_member_id';\n\n    /**\n     * The primary key column for the hostgroups table\n     *\n     * @var string\n     */\n    protected $hostgroup_id = 'hostgroup_id';\n\n    /**\n     * The primary key column for the hosts table\n     *\n     * @var string\n     */\n    protected $host_id = 'host_id';\n\n    /**\n     * The primary key column for the service_contactgroup table\n     *\n     * @var string\n     */\n    protected $service_contactgroup_id = 'service_contactgroup_id';\n\n    /**\n     * The primary key column for the service_contact table\n     *\n     * @var string\n     */\n    protected $service_contact_id = 'service_contact_id';\n\n    /**\n     * The primary key column for the servicegroup_members table\n     *\n     * @var string\n     */\n    protected $servicegroup_member_id = 'servicegroup_member_id';\n\n    /**\n     * The primary key column for the servicegroups table\n     *\n     * @var string\n     */\n    protected $servicegroup_id = 'servicegroup_id';\n\n    /**\n     * The primary key column for the services table\n     *\n     * @var string\n     */\n    protected $service_id = 'service_id';\n\n    /**\n     * The primary key column for the timeperiods table\n     *\n     * @var string\n     */\n    protected $timeperiod_id = 'timeperiod_id';\n\n    /**\n     * An array containing Column names that cause an aggregation of the query\n     *\n     * @var array\n     */\n    protected $aggregateColumnIdx = array();\n\n    /**\n     * True to allow customvar filters and queries\n     *\n     * @var bool\n     */\n    protected $allowCustomVars = false;\n\n    /**\n     * Current IDO version. This is bullshit and needs to be moved somewhere\n     * else. As someone decided that we need no Backend-specific connection\n     * class unfortunately there is no better place right now. And as of the\n     * 'check_source' patch we need a quick fix immediately. So here you go.\n     *\n     * TODO: Fix this.\n     *\n     * @var string\n     */\n    protected static $idoVersion;\n\n    /**\n     * List of column aliases mapped to their table where the COLLATE SQL-instruction has been removed\n     *\n     * This list is being populated in case of a PostgreSQL backend only,\n     * to ensure case-insensitive string comparison in WHERE clauses.\n     *\n     * @var array\n     */\n    protected $caseInsensitiveColumns;\n\n    /**\n     * Return true when the column is an aggregate column\n     *\n     * @param  String $column       The column to test\n     * @return bool                 True when the column is an aggregate column\n     */\n    public function isAggregateColumn($column)\n    {\n        return array_key_exists($column, $this->aggregateColumnIdx);\n    }\n\n    /**\n     * Order the result by the given alias\n     *\n     * @param   string  $alias  The column alias to order by\n     * @param   int     $dir    The sort direction or null to use the default direction\n     *\n     * @return  $this\n     */\n    public function order($alias, $dir = null)\n    {\n        $this->requireColumn($alias);\n\n        if ($this->isCustomvar($alias)) {\n            $column = $this->getCustomvarColumnName($alias);\n        } elseif ($this->hasAliasName($alias)) {\n            $column = $this->aliasToColumnName($alias);\n            $table = $this->aliasToTableName($alias);\n            if (isset($this->caseInsensitiveColumns[$table][$alias])) {\n                $column = 'LOWER(' . $column . ')';\n            }\n        } else {\n            Logger::info('Can\\'t order by column ' . $alias);\n            return $this;\n        }\n\n        $this->orderColumns[] = $alias;\n        return parent::order($column, $dir);\n    }\n\n    /**\n     * Return true when the given field can be used for filtering\n     *\n     * @param String $field     The field to test\n     * @return bool             True when the field can be used for querying, otherwise false\n     */\n    public function isValidFilterTarget($field)\n    {\n        return $this->getMappedField($field) !== null;\n    }\n\n    /**\n     * Return the resolved field for an alias\n     *\n     * @param  String $field     The alias to resolve\n     * @return String           The resolved alias or null if unknown\n     */\n    public function getMappedField($field)\n    {\n        foreach ($this->columnMap as $columnSource => $columnSet) {\n            if (isset($columnSet[$field])) {\n                return $columnSet[$field];\n            }\n        }\n        if ($this->isCustomVar($field)) {\n            return $this->getCustomvarColumnName($field);\n        }\n        return null;\n    }\n\n    public function distinct()\n    {\n        $this->select->distinct();\n        return $this;\n    }\n\n    /**\n     * Prepare the given query so that it can be linked to the parent\n     *\n     * @param   IdoQuery            $query\n     * @param   string              $name\n     * @param   FilterExpression    $filter             The filter which initiated the sub query\n     * @param   bool                $and                Whether it's an AND filter\n     * @param   bool                $negate             Whether it's an != filter\n     * @param   FilterExpression    $additionalFilter   Filters which should be applied to the \"parent\" query\n     *\n     * @return  array   The first value is their, the second our key column\n     *\n     * @throws  NotImplementedError In case the given query is unknown\n     */\n    protected function joinSubQuery(IdoQuery $query, $name, $filter, $and, $negate, &$additionalFilter)\n    {\n        throw new NotImplementedError('Query \"%s\" is unknown', $name);\n    }\n\n    /**\n     * Create and return a sub-query filter for the given filter expression\n     *\n     * @param   FilterExpression    $filter\n     * @param   string              $queryName\n     *\n     * @return  Filter\n     *\n     * @throws  QueryException\n     */\n    protected function createSubQueryFilter(FilterExpression $filter, $queryName)\n    {\n        $expr = $filter->getExpression();\n        $op = $filter->getSign();\n\n        if ($op === '=' && ! is_array($expr) && $op !== '!=') {\n            // We're joining a subquery only if the filter is enclosed in parentheses or if it's a != filter,\n            // e.g. hostgroup_name=(linux...), hostgroup_name!=linux, hostgroup_name!=(linux...)\n            throw new NotImplementedError('');\n        }\n\n        $subQuery = $this->createSubQuery($queryName);\n        $subQuery->setIsSubQuery();\n\n        $subQueryFilter = clone $filter;\n\n        if ($op === '!=') {\n            $negate = true;\n            if (! is_array($expr)) {\n                // We assume that expression is an array later on but we'll support subquery joins for != filters\n                // which are not enclosed in parentheses\n                $expr = [$expr];\n            }\n        } else {\n            $negate = false;\n        }\n\n        if (count($expr) === 1 && strpos($expr[0], '&') !== false) {\n            // Our current filter implementation does not specify & as a control character so the count of the\n            // expression array is always one in this case\n            $expr = array_unique(explode('&', $expr[0]));\n            $subQueryFilter->setExpression($expr);\n            $and = true;\n        } else {\n            // Or filters are respected by our filter implementation. No special handling needed here\n            $and = false;\n        }\n\n        $alias = $filter->getColumn();\n        $column = $subQuery->aliasToColumnName($alias);\n        if (isset($this->caseInsensitiveColumns[$subQuery->aliasToTableName($alias)][$alias])) {\n            $column = 'LOWER( ' . $column . ' )';\n            $subQueryFilter->setColumn($column);\n            $subQueryFilter->setExpression(array_map('strtolower', (array) $subQueryFilter->getExpression()));\n        } else {\n            $subQueryFilter->setColumn($column);\n        }\n\n        $additional = null;\n\n        list($theirs, $ours) = $this->joinSubQuery($subQuery, $queryName, $subQueryFilter, $and, $negate, $additional);\n\n        $zendSelect = $subQuery->select();\n        $fromPart = $zendSelect->getPart($zendSelect::FROM);\n        $zendSelect->reset($zendSelect::FROM);\n\n        foreach ($fromPart as $correlationName => $joinOptions) {\n            if (isset($joinOptions['joinCondition'])) {\n                $joinOptions['joinCondition'] = preg_replace(\n                    '/(?<=^|\\s)\\w+(?=\\.)/',\n                    'sub_$0',\n                    $joinOptions['joinCondition']\n                );\n            }\n\n            $name = ['sub_' . $correlationName => $joinOptions['tableName']];\n            switch ($joinOptions['joinType']) {\n                case $zendSelect::FROM:\n                    $zendSelect->from($name);\n                    break;\n                case $zendSelect::INNER_JOIN:\n                    $zendSelect->joinInner($name, $joinOptions['joinCondition'], null);\n                    break;\n                case $zendSelect::LEFT_JOIN:\n                    $zendSelect->joinLeft($name, $joinOptions['joinCondition'], null);\n                    break;\n                default:\n                    // TODO: Add support for other join types if required?\n                    throw new QueryException(\n                        'Unsupported join type %s. Cannot create subquery filter.',\n                        $joinOptions['joinType']\n                    );\n            }\n        }\n\n        if ($and || $negate && ! $and) {\n            // Having is only required for AND and != filters,\n            // e.g. hostgroup_name=(ping&linux), hostgroup_name!=ping, hostgroup_name!=(ping|linux)\n            $groups = $subQuery->getGroup();\n            $group = $groups[0];\n            $group = preg_replace('/(?<=^|\\s)\\w+(?=\\.)/', 'sub_$0', $group);\n\n            $cnt = count($expr);\n\n            $subQuery->select()->having(\"COUNT(DISTINCT $group) >= $cnt\");\n        }\n\n        $subQueryFilter->setColumn(preg_replace(\n            '/(?<=^|\\s)\\w+(?=\\.)/',\n            'sub_$0',\n            $column\n        ));\n\n        if ($negate) {\n            // != will be NOT EXISTS later\n            $subQueryFilter = $subQueryFilter->setSign('=');\n        }\n\n        $subQueryFilter = $subQueryFilter->andFilter(Filter::where(\n            preg_replace('/(?<=^|\\s)\\w+(?=\\.)/', 'sub_$0', $theirs),\n            new Zend_Db_Expr($ours)\n        ));\n\n        $subQuery\n            ->setFilter($subQueryFilter)\n            ->clearGroupingRules()\n            ->select()\n            ->reset('columns')\n            ->columns([new Zend_Db_Expr('1')]);\n\n        // EXISTS is the column name because without any column $this->isCustomVar() fails badly otherwise.\n        // Additionally it bypasses the non-required optimizations made by our filter rendering implementation.\n        $exists = new FilterExpression($negate ? 'NOT EXISTS' : 'EXISTS', '', new Zend_Db_Expr($subQuery));\n\n        if ($additional !== null) {\n            return Filter::matchAll($exists, $additional);\n        }\n\n        return $exists;\n    }\n\n    protected function requireFilterColumns(Filter $filter)\n    {\n        if ($filter instanceof FilterExpression) {\n            $alias = $filter->getColumn();\n\n            $virtualTable = $this->aliasToTableName($alias);\n            if (isset($this->subQueryTargets[$virtualTable])) {\n                try {\n                    return $this->createSubQueryFilter($filter, $this->subQueryTargets[$virtualTable]);\n                } catch (NotImplementedError $e) {\n                    // We don't want to create subquery filters in all cases\n                }\n            }\n\n            $this->requireColumn($alias);\n\n            if ($this->isCustomvar($alias)) {\n                $column = $this->getCustomvarColumnName($alias);\n            } else {\n                $column = $this->aliasToColumnName($alias);\n                if (isset($this->caseInsensitiveColumns[$this->aliasToTableName($alias)][$alias])) {\n                    $column = 'LOWER(' . $column . ')';\n                    $expression = $filter->getExpression();\n                    if (is_array($expression)) {\n                        $filter->setExpression(array_map('strtolower', $expression));\n                    } else {\n                        $filter->setExpression(strtolower($expression));\n                    }\n                }\n            }\n\n            $filter->setColumn($column);\n        } else {\n            if (! $filter instanceof FilterNot) {\n                // Allow subquery filters in a filter chain\n                $columns = $filter->listFilteredColumns();\n                if (count($columns) === 1) {\n                    $column = $columns[0];\n                    $virtualTable = $this->aliasToTableName($column);\n                    if (isset($this->subQueryTargets[$virtualTable])) {\n                        $lastSign = null;\n                        $filters = [];\n                        $expressions = [];\n                        foreach ($filter->filters() as $child) {\n                            switch (true) {\n                                case $child instanceof FilterExpression:\n                                    $expression = $child->getExpression();\n                                    if (! is_array($expression)) {\n                                        break;\n                                    }\n                                    // Move to default\n                                default:\n                                    $filters[] = $child;\n                                    continue 2;\n                            }\n                            if ($lastSign === null) {\n                                $lastSign = $child->getSign();\n                            } else {\n                                $sign = $child->getSign();\n                                if ($sign !== $lastSign) {\n                                    $filters[] = new FilterExpression(\n                                        $column,\n                                        $lastSign,\n                                        $filter->getOperatorSymbol() === '&'\n                                            ? [implode('&', $expressions)]\n                                            : $expressions\n                                    );\n                                    $expressions = [];\n                                    $lastSign = $sign;\n                                }\n                            }\n                            $expressions[] = $expression;\n                        }\n                        if (! empty($expressions)) {\n                            $filters[] = new FilterExpression(\n                                $column,\n                                $lastSign,\n                                $filter->getOperatorSymbol() === '&'\n                                    ? [implode('&', $expressions)]\n                                    : $expressions\n                            );\n                        }\n                        $filter->setFilters($filters);\n                    }\n                }\n            }\n\n            foreach ($filter->filters() as $child) {\n                $replacement = $this->requireFilterColumns($child);\n                if ($replacement !== null) {\n                    // setId($child->getId()) is performed because replaceById() doesn't already do it\n                    $filter->replaceById($child->getId(), $replacement->setId($child->getId()));\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function addFilter(Filter $filter)\n    {\n        $filter = clone $filter;\n        return parent::addFilter($this->requireFilterColumns($filter) ?: $filter);\n    }\n\n    public function where($condition, $value = null)\n    {\n        $this->requireColumn($condition);\n        $col = $this->getMappedField($condition);\n        if ($col === null) {\n            throw new IcingaException(\n                'No such field: %s',\n                $condition\n            );\n        }\n        return parent::where($col, $value);\n    }\n\n    /**\n     * Return true if an field contains an explicit timestamp\n     *\n     * @param   string  $field      The field to test for containing an timestamp\n     *\n     * @return  bool                True when the field represents an timestamp\n     */\n    public function isTimestamp($field)\n    {\n        if ($this->isCustomVar($field)) {\n            return false;\n        }\n\n        return stripos($this->getMappedField($field) ?: $field, 'UNIX_TIMESTAMP') !== false;\n    }\n\n    /**\n     * Return whether the given alias provides case insensitive value comparison\n     *\n     * @param   string  $alias\n     *\n     * @return  bool\n     */\n    public function isCaseInsensitive($alias)\n    {\n        if ($this->isCustomVar($alias)) {\n            return false;\n        }\n\n        $column = $this->getMappedField($alias);\n        if (! $column) {\n            return false;\n        }\n\n        if (empty($this->caseInsensitiveColumns)) {\n            return preg_match('/ COLLATE .+$/', $column) === 1;\n        }\n\n        if (strpos($column, 'LOWER') === 0) {\n            return true;\n        }\n\n        $table = $this->aliasToTableName($alias);\n        if (! $table) {\n            return false;\n        }\n\n        return isset($this->caseInsensitiveColumns[$table][$alias]);\n    }\n\n    /**\n     * Return our column map\n     *\n     * Might be useful for hooks\n     *\n     * @return array\n     */\n    public function getColumnMap()\n    {\n        return $this->columnMap;\n    }\n\n    /**\n     * Apply oracle specific query initialization\n     */\n    private function initializeForOracle()\n    {\n        // Oracle uses the reserved field 'id' for primary keys, so\n        // these must be used instead of the normally defined ids\n        $this->object_id = $this->host_id = $this->service_id\n            = $this->hostgroup_id = $this->servicegroup_id\n            = $this->contact_id = $this->contactgroup_id = 'id';\n        $this->customVarsJoinTemplate =\n            '%1$s = %2$s.object_id AND LOWER(%2$s.varname) = %3$s';\n        foreach ($this->columnMap as &$columns) {\n            foreach ($columns as &$value) {\n                $value = preg_replace('/UNIX_TIMESTAMP/', 'localts2unixts', $value);\n                $value = preg_replace('/ COLLATE .+$/', '', $value);\n            }\n        }\n    }\n\n    /**\n     * Apply PostgreSQL specific query initialization\n     */\n    private function initializeForPostgres()\n    {\n        $this->customVarsJoinTemplate =\n            '%1$s = %2$s.object_id AND LOWER(%2$s.varname) = %3$s';\n        foreach ($this->columnMap as $table => & $columns) {\n            foreach ($columns as $alias => & $column) {\n                // Using a regex here because COLLATE may occur anywhere in the string\n                $column = preg_replace('/ COLLATE .+$/', '', $column, -1, $count);\n                if ($count > 0) {\n                    $this->caseInsensitiveColumns[$table][$alias] = true;\n                }\n\n                $column = preg_replace(\n                    '/inet_aton\\(([[:word:].]+)\\)/i',\n                    '(CASE WHEN $1 ~ \\'(?:[0-9]{1,3}\\\\\\\\.){3}[0-9]{1,3}\\' THEN $1::inet - \\'0.0.0.0\\' ELSE NULL END)',\n                    $column\n                );\n                if (version_compare($this->getIdoVersion(), '1.14.2', '>=')) {\n                    $column = str_replace('NOW()', 'NOW() AT TIME ZONE \\'UTC\\'', $column);\n                } else {\n                    $column = preg_replace(\n                        '/UNIX_TIMESTAMP(\\((?>[^()]|(?-1))*\\))/i',\n                        'CASE WHEN ($1 < \\'1970-01-03 00:00:00+00\\'::timestamp with time zone) THEN 0 ELSE UNIX_TIMESTAMP($1) END',\n                        $column\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Set up this query and join the initial tables\n     *\n     * @see IdoQuery::initializeForPostgres     For postgresql specific setup\n     */\n    protected function init()\n    {\n        parent::init();\n        $this->prefix = $this->ds->getTablePrefix();\n\n        foreach (Hook::all('monitoring/idoQueryExtension') as $hook) {\n            $extensions = $hook->extendColumnMap($this);\n            if (! is_array($extensions)) {\n                continue;\n            }\n\n            foreach ($extensions as $vTable => $cols) {\n                if (! array_key_exists($vTable, $this->columnMap)) {\n                    $this->hookedVirtualTables[$vTable] = $hook;\n                    $this->columMap[$vTable] = array();\n                }\n\n                foreach ($cols as $k => $v) {\n                    $this->columnMap[$vTable][$k] = $v;\n                }\n            }\n        }\n\n        $dbType = $this->ds->getDbType();\n        if ($dbType === 'oracle') {\n            $this->initializeForOracle();\n        } elseif ($dbType === 'pgsql') {\n            $this->initializeForPostgres();\n        } else {\n            $charset = $this->ds->getConfig()->get('charset') ?: 'latin1';\n            $this->customVarsJoinTemplate .= \" COLLATE {$charset}_general_ci\";\n        }\n        $this->joinBaseTables();\n        $this->select->columns($this->columns);\n        $this->prepareAliasIndexes();\n    }\n\n    /**\n     * Join the base tables for this query\n     */\n    protected function joinBaseTables()\n    {\n        reset($this->columnMap);\n        $table = key($this->columnMap);\n\n        $this->select->from(\n            array($table => $this->prefix . $table),\n            array()\n        );\n\n        $this->joinedVirtualTables = array($table => true);\n    }\n\n    /**\n     * Populates the idxAliasTAble and idxAliasColumn properties\n     */\n    protected function prepareAliasIndexes()\n    {\n        foreach ($this->columnMap as $tbl => & $cols) {\n            foreach ($cols as $alias => $col) {\n                $this->idxAliasTable[$alias] = $tbl;\n                $this->idxAliasColumn[$alias] = preg_replace('~\\n\\s*~', ' ', $col);\n            }\n        }\n    }\n\n    /**\n     * Resolve columns aliases to their database field using the columnMap\n     *\n     * @param   array $columns\n     *\n     * @return  array\n     */\n    public function resolveColumns($columns)\n    {\n        $resolvedColumns = array();\n\n        foreach ($columns as $alias => $col) {\n            if ($col instanceof Zend_Db_Expr) {\n                // Support selecting NULL as column for example\n                $resolvedColumns[$alias] = $col;\n                continue;\n            }\n            $this->requireColumn($col);\n            if ($this->isCustomvar($col)) {\n                $name = $this->getCustomvarColumnName($col);\n            } else {\n                $name = $this->aliasToColumnName($col);\n            }\n            if (is_int($alias)) {\n                $alias = $col;\n            } else {\n                $this->idxCustomAliases[$alias] = $col;\n            }\n\n            $resolvedColumns[$alias] = preg_replace('|\\n|', ' ', $name);\n        }\n\n        return $resolvedColumns;\n    }\n\n    /**\n     * Return all columns that will be selected when no columns are given in the constructor or from\n     *\n     * @return array        An array of column aliases\n     */\n    public function getDefaultColumns()\n    {\n        reset($this->columnMap);\n        $table = key($this->columnMap);\n        return array_keys($this->columnMap[$table]);\n    }\n\n    /**\n     * Modify the query to the given alias can be used in the result set or queries\n     *\n     * This calls requireVirtualTable if needed\n     *\n     * @param $alias                                The alias of the column to require\n     *\n     * @return $this                                 Fluent interface\n     * @see    IdoQuery::requireVirtualTable        The method initializing required joins\n     * @throws \\Icinga\\Exception\\ProgrammingError   When an unknown column is requested\n     */\n    public function requireColumn($alias)\n    {\n        if ($this->hasAliasName($alias)) {\n            $this->requireVirtualTable($this->aliasToTableName($alias));\n        } elseif ($this->isCustomVar($alias)) {\n            $this->requireCustomvar($alias);\n        } else {\n            throw new ProgrammingError(\n                '%s : Got invalid column: %s',\n                get_called_class(),\n                $alias\n            );\n        }\n        return $this;\n    }\n\n    /**\n     * Return true if the given alias exists\n     *\n     * @param  String $alias    The alias to test for\n     * @return bool             True when the alias exists, otherwise false\n     */\n    protected function hasAliasName($alias)\n    {\n        return array_key_exists($alias, $this->idxAliasColumn);\n    }\n\n    /**\n     * Require a virtual table for the given table name if not already required\n     *\n     * @param  String $name         The table name to require\n     * @return $this                 Fluent interface\n     */\n    protected function requireVirtualTable($name)\n    {\n        if ($this->hasJoinedVirtualTable($name)) {\n            return $this;\n        }\n\n        if ($this->virtualTableIsHooked($name)) {\n            return $this->joinHookedVirtualTable($name);\n        } else {\n            return $this->joinVirtualTable($name);\n        }\n    }\n\n    /**\n     * Whether a given virtual table name has been provided by a hook\n     *\n     * @param string $name Virtual table name\n     *\n     * @return boolean\n     */\n    protected function virtualTableIsHooked($name)\n    {\n        return array_key_exists($name, $this->hookedVirtualTables);\n    }\n\n    protected function conflictsWithVirtualTable($name)\n    {\n        if ($this->hasJoinedVirtualTable($name)) {\n            throw new ProgrammingError(\n                'IDO query virtual table conflict with \"%s\"',\n                $name\n            );\n        }\n        return $this;\n    }\n\n    /**\n     * Call the method for joining a virtual table\n     *\n     * This requires a join$Table() method to exist\n     *\n     * @param  String $table        The table to join by calling join$Table() in the concrete implementation\n     * @return $this                 Fluent interface\n     *\n     * @throws \\Icinga\\Exception\\ProgrammingError   If the join method for this table does not exist\n     */\n    protected function joinVirtualTable($table)\n    {\n        $func = 'join' . ucfirst($table);\n        if (method_exists($this, $func)) {\n            $this->$func();\n        } else {\n            throw new ProgrammingError(\n                'Cannot join \"%s\", no such table found',\n                $table\n            );\n        }\n        $this->joinedVirtualTables[$table] = true;\n        return $this;\n    }\n\n    /**\n     * Tell a hook to join a virtual table\n     *\n     * @param  String $table\n     * @return $this\n     */\n    protected function joinHookedVirtualTable($table)\n    {\n        $this->hookedVirtualTables[$table]->joinVirtualTable($this, $table);\n        $this->joinedVirtualTables[$table] = true;\n        return $this;\n    }\n\n    /**\n     * Get the table for a specific alias\n     *\n     * @param   String $alias   The alias to request the table for\n     * @return  String          The table for the alias or null if it doesn't exist\n     */\n    protected function aliasToTableName($alias)\n    {\n        return isset($this->idxAliasTable[$alias]) ? $this->idxAliasTable[$alias] : null;\n    }\n\n    /**\n     * Return whether this query allows to join custom variables\n     *\n     * @return  bool\n     */\n    public function allowsCustomVars()\n    {\n        return $this->allowCustomVars;\n    }\n\n    /**\n     * Return true if the given alias denotes a custom variable\n     *\n     * @param  String $alias    The alias to test for being a customvariable\n     * @return bool             True if the alias is a customvariable, otherwise false\n     */\n    protected function isCustomVar($alias)\n    {\n        return $this->allowCustomVars && $alias[0] === '_';\n    }\n\n    protected function requireCustomvar($customvar)\n    {\n        if (! $this->hasCustomvar($customvar)) {\n            $this->joinCustomvar($customvar);\n        }\n        return $this;\n    }\n\n    protected function hasCustomvar($customvar)\n    {\n        return array_key_exists(strtolower($customvar), $this->customVars);\n    }\n\n    protected function joinCustomvar($customvar)\n    {\n        // TODO: This is not generic enough yet\n        list($type, $name) = $this->customvarNameToTypeName($customvar);\n        $alias = ($type === 'host' ? 'hcv_' : 'scv_') . preg_replace('~[^a-zA-Z0-9_]~', '_', $name);\n\n        // We're replacing any problematic char with an underscore, which will lead to duplicates, this avoids them\n        $from = $this->select->getPart(Zend_Db_Select::FROM);\n        for ($i = 2; array_key_exists($alias, $from); $i++) {\n            $alias = $alias . '_' . $i;\n        }\n\n        $this->customVars[strtolower($customvar)] = $alias;\n\n        if ($this->hasJoinedVirtualTable('services')) {\n            $leftcol = 's.' . $type . '_object_id';\n        } elseif ($type === 'service') {\n            $this->requireVirtualTable('services');\n            $leftcol = 's.service_object_id';\n        } else {\n            $this->requireVirtualTable('hosts');\n            $leftcol = 'h.host_object_id';\n        }\n\n        $mapped = $this->getMappedField($leftcol);\n        if ($mapped !== null) {\n            $this->requireColumn($leftcol);\n            $leftcol = $mapped;\n        }\n\n        $joinOn = sprintf(\n            $this->customVarsJoinTemplate,\n            $leftcol,\n            $alias,\n            $this->db->quote($name)\n        );\n\n        $this->select->joinLeft(\n            array($alias => $this->prefix . 'customvariablestatus'),\n            $joinOn,\n            array()\n        );\n\n        return $this;\n    }\n\n    protected function customvarNameToTypeName($customvar)\n    {\n        $customvar = strtolower($customvar);\n        if (! preg_match('~^_(host|service)_(.+)$~', $customvar, $m)) {\n            throw new ProgrammingError(\n                'Got invalid custom var: \"%s\"',\n                $customvar\n            );\n        }\n        return array($m[1], $m[2]);\n    }\n\n    protected function hasJoinedVirtualTable($name)\n    {\n        return array_key_exists($name, $this->joinedVirtualTables);\n    }\n\n    /**\n     * Get the query column of a already joined custom variable\n     *\n     * @param   string $customvar\n     *\n     * @return  string\n     * @throws  QueryException If the custom variable has not been joined\n     */\n    protected function getCustomvarColumnName($customvar)\n    {\n        if (! isset($this->customVars[($customvar = strtolower($customvar))])) {\n            throw new QueryException('Custom variable %s has not been joined', $customvar);\n        }\n        return $this->customVars[$customvar] . '.varvalue';\n    }\n\n    public function aliasToColumnName($alias)\n    {\n        return $this->idxAliasColumn[$alias];\n    }\n\n    /**\n     * Get the alias of a column expression as defined in the {@link $columnMap} property.\n     *\n     * @param   string $alias Potential custom alias\n     *\n     * @return  string\n     */\n    public function customAliasToAlias($alias)\n    {\n        if (isset($this->idxCustomAliases[$alias])) {\n            return $this->idxCustomAliases[$alias];\n        }\n        return $alias;\n    }\n\n    /**\n     * Create a sub query\n     *\n     * @param   string  $queryName\n     * @param   array   $columns\n     *\n     * @return  static\n     */\n    protected function createSubQuery($queryName, $columns = array())\n    {\n        $class = '\\\\'\n            . substr(__CLASS__, 0, strrpos(__CLASS__, '\\\\') + 1)\n            . ucfirst($queryName) . 'Query';\n        $query = new $class($this->ds, $columns);\n        return $query;\n    }\n\n    /**\n     * Set columns to select\n     *\n     * @param   array $columns\n     *\n     * @return  $this\n     */\n    public function columns(array $columns)\n    {\n        $this->idxCustomAliases = array();\n        $this->columns = $this->resolveColumns($columns);\n        // TODO: we need to refresh our select!\n        // $this->select->columns($columns);\n        return $this;\n    }\n\n    public function clearGroupingRules()\n    {\n        $this->groupBase = array();\n        $this->groupOrigin = array();\n        return $this;\n    }\n\n    /**\n     * Register the GROUP BY columns required for the given alias\n     *\n     * @param   string  $alias              The alias to register columns for\n     * @param   string  $table              The table the given alias is associated with\n     * @param   array   $groupedColumns     The grouping columns registered so far\n     * @param   array   $groupedTables      The tables for which columns were registered so far\n     */\n    protected function registerGroupColumns($alias, $table, array &$groupedColumns, array &$groupedTables)\n    {\n        switch ($table) {\n            case 'checktimeperiods':\n                $groupedColumns[] = 'ctp.timeperiod_id';\n                break;\n            case 'contacts':\n                $groupedColumns[] = 'co.object_id';\n                $groupedColumns[] = 'c.contact_id';\n                break;\n            case 'hostobjects':\n                $groupedColumns[] = 'ho.object_id';\n                break;\n            case 'hosts':\n                $groupedColumns[] = 'h.host_id';\n                break;\n            case 'hostgroups':\n                $groupedColumns[] = 'hgo.object_id';\n                $groupedColumns[] = 'hg.hostgroup_id';\n                break;\n            case 'hoststatus':\n                $groupedColumns[] = 'hs.hoststatus_id';\n                break;\n            case 'instances':\n                $groupedColumns[] = 'i.instance_id';\n                break;\n            case 'servicegroups':\n                $groupedColumns[] = 'sgo.object_id';\n                $groupedColumns[] = 'sg.servicegroup_id';\n                break;\n            case 'serviceobjects':\n                $groupedColumns[] = 'so.object_id';\n                break;\n            case 'serviceproblemsummary':\n                $groupedColumns[] = 'sps.unhandled_services_count';\n                break;\n            case 'services':\n                $groupedColumns[] = 'so.object_id';\n                $groupedColumns[] = 's.service_id';\n                break;\n            case 'servicestatus':\n                $groupedColumns[] = 'ss.servicestatus_id';\n                break;\n            default:\n                return;\n        }\n\n        $groupedTables[$table] = true;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getGroup()\n    {\n        $group = parent::getGroup() ?: array();\n        if (! is_array($group)) {\n            $group = array($group);\n        }\n\n        $joinedOrigins = array_filter($this->groupOrigin, array($this, 'hasJoinedVirtualTable'));\n        if (empty($joinedOrigins)) {\n            return $group;\n        }\n\n        $groupedTables = array();\n        foreach ($this->groupBase as $baseTable => $aliasedPks) {\n            if (! $this->hasJoinedVirtualTable($baseTable)) {\n                continue;\n            }\n            $groupedTables[$baseTable] = true;\n            foreach ($aliasedPks as $aliasedPk) {\n                $group[] = $aliasedPk;\n            }\n        }\n\n        foreach (new ColumnFilterIterator($this->columns) as $desiredAlias => $desiredColumn) {\n            $alias = is_string($desiredAlias) ? $this->customAliasToAlias($desiredAlias) : $desiredColumn;\n            if ($this->isCustomVar($alias) && $this->getDatasource()->getDbType() === 'pgsql') {\n                $table = $this->customVars[$alias];\n                if (! isset($groupedTables[$table])) {\n                    $group[] = $this->getCustomvarColumnName($alias);\n                    $groupedTables[$table] = true;\n                }\n                continue;\n            }\n            $table = $this->aliasToTableName($alias);\n            if ($table && !isset($groupedTables[$table]) && (\n                in_array($table, $joinedOrigins, true) || $this->getDatasource()->getDbType() === 'pgsql')\n            ) {\n                $this->registerGroupColumns($alias, $table, $group, $groupedTables);\n            }\n        }\n\n        if (! empty($group) && $this->getDatasource()->getDbType() === 'pgsql') {\n            foreach (new ColumnFilterIterator($this->orderColumns) as $alias) {\n                if ($this->isCustomVar($alias)) {\n                    $table = $this->customVars[$alias];\n                    if (! isset($groupedTables[$table])) {\n                        $group[] = $this->getCustomvarColumnName($alias);\n                        $groupedTables[$table] = true;\n                    }\n                    continue;\n                }\n                $table = $this->aliasToTableName($alias);\n                if ($table && !isset($groupedTables[$table])\n                    && !in_array($this->getMappedField($alias), $this->columns, true)\n                ) {\n                    $this->registerGroupColumns($alias, $table, $group, $groupedTables);\n                }\n            }\n        }\n\n        return array_unique($group);\n    }\n\n    // TODO: Move this away, see note related to $idoVersion var\n    protected function getIdoVersion()\n    {\n        if (self::$idoVersion === null) {\n            $dbconf = $this->db->getConfig();\n            $id = $dbconf['host'] . '/' . $dbconf['dbname'];\n            $session = null;\n            if (Icinga::app()->isWeb()) {\n                // TODO: Once we have version per connection we should choose a\n                //       namespace based on resource name\n                $session = Session::getSession()->getNamespace('monitoring/ido/' . $id);\n                if (isset($session->version)) {\n                    self::$idoVersion = $session->version;\n                    return self::$idoVersion;\n                }\n            }\n            self::$idoVersion = $this->db->fetchOne(\n                $this->db->select()->from($this->prefix . 'dbversion', 'version')\n            );\n            if ($session !== null) {\n                $session->version = self::$idoVersion;\n            }\n        }\n        return self::$idoVersion;\n    }\n\n    /**\n     * Return the name of the primary key column for the given table name\n     *\n     * @param   string  $table\n     *\n     * @return  string\n     *\n     * @throws ProgrammingError     In case $table is unknown\n     */\n    protected function getPrimaryKeyColumn($table)\n    {\n        // TODO: For god's sake, make this being a mapping\n        //       (instead of matching a ton of properties using a ridiculous long switch case)\n        switch ($table) {\n            case 'instances':\n                return $this->instance_id;\n            case 'objects':\n                return $this->object_id;\n            case 'acknowledgements':\n                return $this->acknowledgement_id;\n            case 'commenthistory':\n                return $this->commenthistory_id;\n            case 'contactnotifiations':\n                return $this->contactnotification_id;\n            case 'downtimehistory':\n                return $this->downtimehistory_id;\n            case 'flappinghistory':\n                return $this->flappinghistory_id;\n            case 'notifications':\n                return $this->notification_id;\n            case 'statehistory':\n                return $this->statehistory_id;\n            case 'comments':\n                return $this->comment_id;\n            case 'customvariablestatus':\n                return $this->customvariablestatus_id;\n            case 'hoststatus':\n                return $this->hoststatus_id;\n            case 'programstatus':\n                return $this->programstatus_id;\n            case 'runtimevariables':\n                return $this->runtimevariable_id;\n            case 'scheduleddowntime':\n                return $this->scheduleddowntime_id;\n            case 'servicestatus':\n                return $this->servicestatus_id;\n            case 'contactstatus':\n                return $this->contactstatus_id;\n            case 'commands':\n                return $this->command_id;\n            case 'contactgroup_members':\n                return $this->contactgroup_member_id;\n            case 'contactgroups':\n                return $this->contactgroup_id;\n            case 'contacts':\n                return $this->contact_id;\n            case 'customvariables':\n                return $this->customvariable_id;\n            case 'host_contactgroups':\n                return $this->host_contactgroup_id;\n            case 'host_contacts':\n                return $this->host_contact_id;\n            case 'hostgroup_members':\n                return $this->hostgroup_member_id;\n            case 'hostgroups':\n                return $this->hostgroup_id;\n            case 'hosts':\n                return $this->host_id;\n            case 'service_contactgroups':\n                return $this->service_contactgroup_id;\n            case 'service_contacts':\n                return $this->service_contact_id;\n            case 'servicegroup_members':\n                return $this->servicegroup_member_id;\n            case 'servicegroups':\n                return $this->servicegroup_id;\n            case 'services':\n                return $this->service_id;\n            case 'timeperiods':\n                return $this->timeperiod_id;\n            default:\n                throw new ProgrammingError('Cannot provide a primary key column. Table \"%s\" is unknown', $table);\n        }\n    }\n}\n", "<?php\n/* Icinga Web 2 | (c) 2018 Icinga Development Team | GPLv2+ */\n\nnamespace Icinga\\Module\\Monitoring\\Backend\\Ido\\Query;\n\n/**\n * Query for service contacts\n */\nclass ServicecontactQuery extends IdoQuery\n{\n    protected $allowCustomVars = true;\n\n    protected $groupBase = [\n        'contacts' => ['co.object_id', 'c.contact_id'],\n        'timeperiods' => ['ht.timeperiod_id', 'st.timeperiod_id']\n    ];\n\n    protected $groupOrigin = ['contactgroups', 'hosts', 'services'];\n\n    protected $subQueryTargets = [\n        'hostgroups'    => 'hostgroup',\n        'servicegroups' => 'servicegroup'\n    ];\n\n    protected $columnMap = [\n        'contactgroups' => [\n            'contactgroup'       => 'cgo.name1 COLLATE latin1_general_ci',\n            'contactgroup_name'  => 'cgo.name1',\n            'contactgroup_alias' => 'cg.alias COLLATE latin1_general_ci'\n        ],\n        'contacts' => [\n            'contact_id'                       => 'c.contact_id',\n            'contact'                          => 'co.name1 COLLATE latin1_general_ci',\n            'contact_name'                     => 'co.name1',\n            'contact_alias'                    => 'c.alias COLLATE latin1_general_ci',\n            'contact_email'                    => 'c.email_address COLLATE latin1_general_ci',\n            'contact_pager'                    => 'c.pager_address',\n            'contact_object_id'                => 'c.contact_object_id',\n            'contact_has_host_notfications'    => 'c.host_notifications_enabled',\n            'contact_has_service_notfications' => 'c.service_notifications_enabled',\n            'contact_can_submit_commands'      => 'c.can_submit_commands',\n            'contact_notify_service_recovery'  => 'c.notify_service_recovery',\n            'contact_notify_service_warning'   => 'c.notify_service_warning',\n            'contact_notify_service_critical'  => 'c.notify_service_critical',\n            'contact_notify_service_unknown'   => 'c.notify_service_unknown',\n            'contact_notify_service_flapping'  => 'c.notify_service_flapping',\n            'contact_notify_service_downtime'  => 'c.notify_service_downtime',\n            'contact_notify_host_recovery'     => 'c.notify_host_recovery',\n            'contact_notify_host_down'         => 'c.notify_host_down',\n            'contact_notify_host_unreachable'  => 'c.notify_host_unreachable',\n            'contact_notify_host_flapping'     => 'c.notify_host_flapping',\n            'contact_notify_host_downtime'     => 'c.notify_host_downtime'\n        ],\n        'hostgroups' => [\n            'hostgroup'       => 'hgo.name1 COLLATE latin1_general_ci',\n            'hostgroup_alias' => 'hg.alias COLLATE latin1_general_ci',\n            'hostgroup_name'  => 'hgo.name1'\n        ],\n        'hosts' => [\n            'host'              => 'ho.name1 COLLATE latin1_general_ci',\n            'host_name'         => 'ho.name1',\n            'host_alias'        => 'h.alias',\n            'host_display_name' => 'h.display_name COLLATE latin1_general_ci'\n        ],\n        'instances' => [\n            'instance_name' => 'i.instance_name'\n        ],\n        'servicegroups' => [\n            'servicegroup'       => 'sgo.name1 COLLATE latin1_general_ci',\n            'servicegroup_name'  => 'sgo.name1',\n            'servicegroup_alias' => 'sg.alias COLLATE latin1_general_ci'\n        ],\n        'services' => [\n            'service'              => 'so.name2 COLLATE latin1_general_ci',\n            'service_description'  => 'so.name2',\n            'service_display_name' => 's.display_name COLLATE latin1_general_ci',\n            'service_host_name'    => 'so.name1'\n        ],\n        'timeperiods' => [\n            'contact_notify_host_timeperiod'    => 'ht.alias COLLATE latin1_general_ci',\n            'contact_notify_service_timeperiod' => 'st.alias COLLATE latin1_general_ci'\n        ]\n    ];\n\n    protected function joinBaseTables()\n    {\n        $this->select->from(\n            ['c' => $this->prefix . 'contacts'],\n            []\n        )->join(\n            ['co' => $this->prefix . 'objects'],\n            'co.object_id = c.contact_object_id AND co.is_active = 1',\n            []\n        );\n\n        $this->select->joinLeft(\n            ['sc' => $this->prefix . 'service_contacts'],\n            'sc.contact_object_id = c.contact_object_id',\n            []\n        )->joinLeft(\n            ['s' => $this->prefix . 'services'],\n            's.service_id = sc.service_id',\n            []\n        )->joinLeft(\n            ['so' => $this->prefix . 'objects'],\n            'so.object_id = s.service_object_id AND so.is_active = 1 AND so.objecttype_id = 2',\n            []\n        );\n\n        $this->joinedVirtualTables['contacts'] = true;\n        $this->joinedVirtualTables['services'] = true;\n    }\n\n    /**\n     * Join contact groups\n     */\n    protected function joinContactgroups()\n    {\n        $this->select->joinLeft(\n            ['cgm' => $this->prefix . 'contactgroup_members'],\n            'co.object_id = cgm.contact_object_id',\n            []\n        )->joinLeft(\n            ['cg' => $this->prefix . 'contactgroups'],\n            'cgm.contactgroup_id = cg.contactgroup_id',\n            []\n        )->joinLeft(\n            ['cgo' => $this->prefix . 'objects'],\n            'cg.contactgroup_object_id = cgo.object_id AND cgo.is_active = 1 AND cgo.objecttype_id = 11',\n            []\n        );\n    }\n\n    /**\n     * Join host groups\n     */\n    protected function joinHostgroups()\n    {\n        $this->requireVirtualTable('hosts');\n        $this->select->joinLeft(\n            ['hgm' => $this->prefix . 'hostgroup_members'],\n            'hgm.host_object_id = ho.object_id',\n            []\n        )->joinLeft(\n            ['hg' => $this->prefix . 'hostgroups'],\n            'hg.hostgroup_id = hgm.hostgroup_id',\n            []\n        )->joinLeft(\n            ['hgo' => $this->prefix . 'objects'],\n            'hgo.object_id = hg.hostgroup_object_id AND hgo.is_active = 1 AND hgo.objecttype_id = 3',\n            []\n        );\n    }\n\n    /**\n     * Join hosts\n     */\n    protected function joinHosts()\n    {\n        $this->select->joinLeft(\n            ['h' => $this->prefix . 'hosts'],\n            'h.host_object_id = s.host_object_id',\n            []\n        )->joinLeft(\n            ['ho' => $this->prefix . 'objects'],\n            'ho.object_id = h.host_object_id AND ho.is_active = 1',\n            []\n        );\n    }\n\n    /**\n     * Join instances\n     */\n    protected function joinInstances()\n    {\n        $this->select->join(\n            ['i' => $this->prefix . 'instances'],\n            'i.instance_id = c.instance_id',\n            []\n        );\n    }\n\n    /**\n     * Join service groups\n     */\n    protected function joinServicegroups()\n    {\n        $this->requireVirtualTable('services');\n        $this->select->joinLeft(\n            ['sgm' => $this->prefix . 'servicegroup_members'],\n            'sgm.service_object_id = s.service_object_id',\n            []\n        )->joinLeft(\n            ['sg' => $this->prefix . 'servicegroups'],\n            'sg.servicegroup_id = sgm.servicegroup_id',\n            []\n        )->joinLeft(\n            ['sgo' => $this->prefix . 'objects'],\n            'sgo.object_id = sg.servicegroup_object_id AND sgo.is_active = 1 AND sgo.objecttype_id = 4',\n            []\n        );\n    }\n\n    /**\n     * Join time periods\n     */\n    protected function joinTimeperiods()\n    {\n        $this->select->joinLeft(\n            ['ht' => $this->prefix . 'timeperiods'],\n            'ht.timeperiod_object_id = c.host_timeperiod_object_id',\n            []\n        );\n        $this->select->joinLeft(\n            ['st' => $this->prefix . 'timeperiods'],\n            'st.timeperiod_object_id = c.service_timeperiod_object_id',\n            []\n        );\n    }\n\n    protected function joinSubQuery(IdoQuery $query, $name, $filter, $and, $negate, &$additionalFilter)\n    {\n        if ($name === 'hostgroup') {\n            $query->joinVirtualTable('members');\n\n            return ['hgm.host_object_id', 's.host_object_id'];\n        } elseif ($name === 'servicegroup') {\n            $query->joinVirtualTable('members');\n\n            return ['sgm.service_object_id', 'so.object_id'];\n        }\n\n        return parent::joinSubQuery($query, $name, $filter, $and, $negate, $additionalFilter);\n    }\n}\n"], "fixing_code": ["<?php\n/* Icinga Web 2 | (c) 2018 Icinga Development Team | GPLv2+ */\n\nnamespace Icinga\\Module\\Monitoring\\Backend\\Ido\\Query;\n\n/**\n * Query for host contacts\n */\nclass HostcontactQuery extends IdoQuery\n{\n    protected $allowCustomVars = true;\n\n    protected $groupBase = [\n        'contacts' => ['co.object_id', 'c.contact_id'],\n        'timeperiods' => ['ht.timeperiod_id', 'st.timeperiod_id']\n    ];\n\n    protected $groupOrigin = ['contactgroups', 'hosts', 'services'];\n\n    protected $subQueryTargets = [\n        'hostgroups'    => 'hostgroup',\n        'servicegroups' => 'servicegroup'\n    ];\n\n    protected $columnMap = [\n        'contactgroups' => [\n            'contactgroup'       => 'cgo.name1 COLLATE latin1_general_ci',\n            'contactgroup_name'  => 'cgo.name1',\n            'contactgroup_alias' => 'cg.alias COLLATE latin1_general_ci'\n        ],\n        'contacts' => [\n            'contact_id'                       => 'c.contact_id',\n            'contact'                          => 'co.name1 COLLATE latin1_general_ci',\n            'contact_name'                     => 'co.name1',\n            'contact_alias'                    => 'c.alias COLLATE latin1_general_ci',\n            'contact_email'                    => 'c.email_address COLLATE latin1_general_ci',\n            'contact_pager'                    => 'c.pager_address',\n            'contact_object_id'                => 'c.contact_object_id',\n            'contact_has_host_notfications'    => 'c.host_notifications_enabled',\n            'contact_has_service_notfications' => 'c.service_notifications_enabled',\n            'contact_can_submit_commands'      => 'c.can_submit_commands',\n            'contact_notify_service_recovery'  => 'c.notify_service_recovery',\n            'contact_notify_service_warning'   => 'c.notify_service_warning',\n            'contact_notify_service_critical'  => 'c.notify_service_critical',\n            'contact_notify_service_unknown'   => 'c.notify_service_unknown',\n            'contact_notify_service_flapping'  => 'c.notify_service_flapping',\n            'contact_notify_service_downtime'  => 'c.notify_service_downtime',\n            'contact_notify_host_recovery'     => 'c.notify_host_recovery',\n            'contact_notify_host_down'         => 'c.notify_host_down',\n            'contact_notify_host_unreachable'  => 'c.notify_host_unreachable',\n            'contact_notify_host_flapping'     => 'c.notify_host_flapping',\n            'contact_notify_host_downtime'     => 'c.notify_host_downtime'\n        ],\n        'hostgroups' => [\n            'hostgroup'       => 'hgo.name1 COLLATE latin1_general_ci',\n            'hostgroup_alias' => 'hg.alias COLLATE latin1_general_ci',\n            'hostgroup_name'  => 'hgo.name1'\n        ],\n        'hosts' => [\n            'host'              => 'ho.name1 COLLATE latin1_general_ci',\n            'host_name'         => 'ho.name1',\n            'host_alias'        => 'h.alias',\n            'host_display_name' => 'h.display_name COLLATE latin1_general_ci'\n        ],\n        'instances' => [\n            'instance_name' => 'i.instance_name'\n        ],\n        'servicegroups' => [\n            'servicegroup'       => 'sgo.name1 COLLATE latin1_general_ci',\n            'servicegroup_name'  => 'sgo.name1',\n            'servicegroup_alias' => 'sg.alias COLLATE latin1_general_ci'\n        ],\n        'services' => [\n            'service'              => 'so.name2 COLLATE latin1_general_ci',\n            'service_description'  => 'so.name2',\n            'service_display_name' => 's.display_name COLLATE latin1_general_ci',\n            'service_host_name'    => 'so.name1'\n        ],\n        'timeperiods' => [\n            'contact_notify_host_timeperiod'    => 'ht.alias COLLATE latin1_general_ci',\n            'contact_notify_service_timeperiod' => 'st.alias COLLATE latin1_general_ci'\n        ]\n    ];\n\n    protected function joinBaseTables()\n    {\n        $this->select->from(\n            ['c' => $this->prefix . 'contacts'],\n            []\n        )->join(\n            ['co' => $this->prefix . 'objects'],\n            'co.object_id = c.contact_object_id AND co.is_active = 1 AND co.objecttype_id = 10',\n            []\n        );\n\n        $this->joinedVirtualTables = array('contacts' => true);\n    }\n\n    /**\n     * Join contact groups\n     */\n    protected function joinContactgroups()\n    {\n        $this->select->joinLeft(\n            ['cgm' => $this->prefix . 'contactgroup_members'],\n            'co.object_id = cgm.contact_object_id',\n            []\n        )->joinLeft(\n            ['cg' => $this->prefix . 'contactgroups'],\n            'cgm.contactgroup_id = cg.contactgroup_id',\n            []\n        )->joinLeft(\n            ['cgo' => $this->prefix . 'objects'],\n            'cg.contactgroup_object_id = cgo.object_id AND cgo.is_active = 1 AND cgo.objecttype_id = 11',\n            []\n        );\n    }\n\n    /**\n     * Join host groups\n     */\n    protected function joinHostgroups()\n    {\n        $this->requireVirtualTable('hosts');\n\n        $this->select->joinLeft(\n            ['hgm' => $this->prefix . 'hostgroup_members'],\n            'hgm.host_object_id = ho.object_id',\n            []\n        )->joinLeft(\n            ['hg' => $this->prefix . 'hostgroups'],\n            'hg.hostgroup_id = hgm.hostgroup_id',\n            []\n        )->joinLeft(\n            ['hgo' => $this->prefix . 'objects'],\n            'hgo.object_id = hg.hostgroup_object_id AND hgo.is_active = 1 AND hgo.objecttype_id = 3',\n            []\n        );\n    }\n\n    /**\n     * Join hosts\n     */\n    protected function joinHosts()\n    {\n        $this->select->joinLeft(\n            ['hc' => $this->prefix . 'host_contacts'],\n            'hc.contact_object_id = c.contact_object_id',\n            []\n        )->joinLeft(\n            ['h' => $this->prefix . 'hosts'],\n            'h.host_id = hc.host_id',\n            []\n        )->joinLeft(\n            ['ho' => $this->prefix . 'objects'],\n            'ho.object_id = h.host_object_id AND ho.is_active = 1 AND ho.objecttype_id = 1',\n            []\n        );\n    }\n\n    /**\n     * Join instances\n     */\n    protected function joinInstances()\n    {\n        $this->select->join(\n            ['i' => $this->prefix . 'instances'],\n            'i.instance_id = c.instance_id',\n            []\n        );\n    }\n\n    /**\n     * Join service groups\n     */\n    protected function joinServicegroups()\n    {\n        $this->requireVirtualTable('services');\n        $this->select->joinLeft(\n            ['sgm' => $this->prefix . 'servicegroup_members'],\n            'sgm.service_object_id = s.service_object_id',\n            []\n        )->joinLeft(\n            ['sg' => $this->prefix . 'servicegroups'],\n            'sg.servicegroup_id = sgm.servicegroup_id',\n            []\n        )->joinLeft(\n            ['sgo' => $this->prefix . 'objects'],\n            'sgo.object_id = sg.servicegroup_object_id AND sgo.is_active = 1 AND sgo.objecttype_id = 4',\n            []\n        );\n    }\n\n    /**\n     * Join services\n     */\n    protected function joinServices()\n    {\n        $this->requireVirtualTable('hosts');\n\n        $this->select->joinLeft(\n            ['s' => $this->prefix . 'services'],\n            's.host_object_id = ho.object_id',\n            []\n        )->joinLeft(\n            ['so' => $this->prefix . 'objects'],\n            'so.object_id = s.service_object_id AND so.is_active = 1 AND so.objecttype_id = 2',\n            []\n        );\n    }\n\n    /**\n     * Join time periods\n     */\n    protected function joinTimeperiods()\n    {\n        $this->select->joinLeft(\n            ['ht' => $this->prefix . 'timeperiods'],\n            'ht.timeperiod_object_id = c.host_timeperiod_object_id',\n            []\n        );\n        $this->select->joinLeft(\n            ['st' => $this->prefix . 'timeperiods'],\n            'st.timeperiod_object_id = c.service_timeperiod_object_id',\n            []\n        );\n    }\n\n    protected function joinSubQuery(IdoQuery $query, $name, $filter, $and, $negate, &$additionalFilter)\n    {\n        if ($name === 'hostgroup') {\n            $this->requireVirtualTable('hosts');\n\n            $query->joinVirtualTable('members');\n\n            return ['hgm.host_object_id', 'ho.object_id'];\n        } elseif ($name === 'servicegroup') {\n            $this->requireVirtualTable('services');\n\n            $query->joinVirtualTable('members');\n\n            return ['sgm.service_object_id', 'so.object_id'];\n        }\n\n        return parent::joinSubQuery($query, $name, $filter, $and, $negate, $additionalFilter);\n    }\n}\n", "<?php\n/* Icinga Web 2 | (c) 2015 Icinga Development Team | GPLv2+ */\n\nnamespace Icinga\\Module\\Monitoring\\Backend\\Ido\\Query;\n\nclass HostserviceproblemsummaryQuery extends IdoQuery\n{\n    /**\n     * {@inheritdoc}\n     */\n    protected $allowCustomVars = true;\n\n    /**\n     * The HoststatusQuery in use\n     *\n     * @var HoststatusQuery\n     */\n    protected $hostStatusQuery;\n\n    /**\n     * {@inheritdoc}\n     */\n    protected $columnMap = array(\n        'instances' => array(\n            'instance_name' => 'i.instance_name'\n        ),\n        'services' => array(\n            'host_name'                 => 'so.name1',\n            'service_description'       => 'so.name2'\n        ),\n        'hostgroups' => array(\n            'hostgroup_name'            => 'hgo.name1'\n        ),\n        'servicegroups' => array(\n            'servicegroup_name'         => 'sgo.name1'\n        ),\n        'problemsummary' => array(\n            'unhandled_service_count'   => 'SUM(\n                CASE\n                    WHEN (ss.problem_has_been_acknowledged + ss.scheduled_downtime_depth + COALESCE(hs.current_state, 0)) > 0\n                    THEN 0\n                    ELSE 1\n                END\n            )'\n        )\n    );\n\n    /**\n     * Set the HoststatusQuery to use\n     *\n     * @param   HoststatusQuery     $query\n     *\n     * @return  $this\n     */\n    public function setHoststatusQuery(HoststatusQuery $query)\n    {\n        $this->hostStatusQuery = clone $query;\n        $this->hostStatusQuery\n            ->clearOrder()\n            ->setIsSubQuery()\n            ->columns(array('object_id'));\n        return $this;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function joinBaseTables()\n    {\n        $this->select->from(\n            array('so' => $this->prefix . 'objects'),\n            array()\n        )->join(\n            array('s' => $this->prefix . 'services'),\n            's.service_object_id = so.object_id AND so.is_active = 1 AND so.objecttype_id = 2',\n            array()\n        );\n        $this->select->group('so.name1');\n        $this->joinedVirtualTables['services'] = true;\n    }\n\n    /**\n     * Join instances\n     */\n    protected function joinInstances()\n    {\n        $this->select->join(\n            array('i' => $this->prefix . 'instances'),\n            'i.instance_id = so.instance_id',\n            array()\n        );\n    }\n\n    /**\n     * Join host groups\n     */\n    protected function joinHostgroups()\n    {\n        $this->select->joinLeft(\n            array('hgm' => $this->prefix . 'hostgroup_members'),\n            'hgm.host_object_id = s.host_object_id',\n            array()\n        )->joinLeft(\n            array('hg' => $this->prefix . 'hostgroups'),\n            'hg.hostgroup_id = hgm.hostgroup_id',\n            array()\n        )->joinLeft(\n            array('hgo' => $this->prefix . 'objects'),\n            'hgo.object_id = hg.hostgroup_object_id AND hgo.is_active = 1 AND hgo.objecttype_id = 3',\n            array()\n        );\n    }\n\n    /**\n     * Join service groups\n     */\n    protected function joinServicegroups()\n    {\n        $this->select->joinLeft(\n            array('sgm' => $this->prefix . 'servicegroup_members'),\n            'sgm.service_object_id = so.object_id',\n            array()\n        )->joinLeft(\n            array('sg' => $this->prefix . 'servicegroups'),\n            'sgm.servicegroup_id = sg.servicegroup_id',\n            array()\n        )->joinLeft(\n            array('sgo' => $this->prefix . 'objects'),\n            'sgo.object_id = sg.servicegroup_object_id AND sgo.is_active = 1 AND sgo.objecttype_id = 4',\n            array()\n        );\n    }\n\n    /**\n     * Join the statussummary\n     */\n    protected function joinProblemsummary()\n    {\n        $this->select->join(\n            array('ss' => $this->prefix . 'servicestatus'),\n            'ss.service_object_id = so.object_id AND ss.current_state > 0',\n            array()\n        )->join(\n            array('hs' => $this->prefix . 'hoststatus'),\n            'hs.host_object_id = s.host_object_id',\n            array()\n        )->join(\n            array('h' => $this->hostStatusQuery),\n            'h.object_id = s.host_object_id',\n            array()\n        );\n\n        $this->select->having($this->getMappedField('unhandled_service_count') . ' > 0');\n    }\n}\n", "<?php\n/* Icinga Web 2 | (c) 2013 Icinga Development Team | GPLv2+ */\n\nnamespace Icinga\\Module\\Monitoring\\Backend\\Ido\\Query;\n\nuse Icinga\\Data\\Filter\\FilterNot;\nuse Zend_Db_Expr;\nuse Icinga\\Application\\Icinga;\nuse Icinga\\Application\\Hook;\nuse Icinga\\Application\\Logger;\nuse Icinga\\Data\\Db\\DbQuery;\nuse Icinga\\Data\\Filter\\Filter;\nuse Icinga\\Data\\Filter\\FilterExpression;\nuse Icinga\\Exception\\IcingaException;\nuse Icinga\\Exception\\NotImplementedError;\nuse Icinga\\Exception\\ProgrammingError;\nuse Icinga\\Exception\\QueryException;\nuse Icinga\\Web\\Session;\nuse Icinga\\Module\\Monitoring\\Data\\ColumnFilterIterator;\nuse Zend_Db_Select;\n\n/**\n * Base class for Ido Queries\n *\n * This is the base class for all Ido queries and should be extended for new queries\n * The starting point for implementations is the columnMap attribute. This is an asscociative array in the\n * following form:\n *\n * <pre>\n * <code>\n * array(\n *      'virtualTable' => array(\n *          'fieldalias1' => 'queryColumn1',\n *          'fieldalias2' => 'queryColumn2',\n *          ....\n *      ),\n *      'virtualTable2' => array(\n *          'host'       =>  'host_name1'\n *      )\n * )\n * </code>\n * </pre>\n *\n * This allows you to select e.g. fieldalias1, which automatically calls the query code for joining 'virtualTable'. If\n * you afterwards select 'host', 'virtualTable2' will be joined. The joining logic is up to you, in order to make the\n * above example work you need to implement the joinVirtualTable() method which contain your\n * custom (Zend_Db) logic for joining, filtering and querying the data you want.\n *\n */\nabstract class IdoQuery extends DbQuery\n{\n    /**\n     * The prefix to use\n     *\n     * @var string\n     */\n    protected $prefix;\n\n    /**\n     * An array to map aliases to column names\n     *\n     * @var array\n     */\n    protected $idxAliasColumn;\n\n    /**\n     * An array to map aliases to table names\n     *\n     * @var array\n     */\n    protected $idxAliasTable;\n\n    /**\n     * An array to map custom aliases to aliases\n     *\n     * @var array\n     */\n    protected $idxCustomAliases;\n\n    /**\n     * The column map containing all filterable columns\n     *\n     * This must be overwritten by child classes, in the format\n     * array(\n     *      'virtualTable' => array(\n     *          'fieldalias1' => 'queryColumn1',\n     *          'fieldalias2' => 'queryColumn2',\n     *          ....\n     *      )\n     * )\n     *\n     * @var array\n     */\n    protected $columnMap = array();\n\n    /**\n     * Custom vars available for this query\n     *\n     * @var array\n     */\n    protected $customVars = array();\n\n    /**\n     * Printf compatible string to joins custom vars\n     *\n     * - %1$s   Source field, contain the object_id\n     * - %2$s   Alias used for the relation\n     * - %3$s   Name of the CustomVariable\n     *\n     * @var string\n     */\n    private $customVarsJoinTemplate = '%1$s = %2$s.object_id AND %2$s.varname = %3$s';\n\n    /**\n     * An array with all 'virtual' tables that are already joined\n     *\n     * Virtual tables are the keys  of the columnMap array and require a\n     * join%VirtualTableName%() method to be defined in the concrete\n     * query\n     *\n     * @var array\n     */\n    protected $joinedVirtualTables = array();\n\n    /**\n     * A map of virtual table names and corresponding hook instances\n     *\n     * Joins for those tables will be delegated to them\n     *\n     * @var array\n     */\n    protected $hookedVirtualTables = array();\n\n    /**\n     * List of column aliases used for sorting the result\n     *\n     * @var array\n     */\n    protected $orderColumns = array();\n\n    /**\n     * Table to columns map which have to be added to the GROUP BY list if the query is grouped\n     *\n     * @var array\n     */\n    protected $groupBase = array();\n\n    /**\n     * List of table names which initiate grouping if one of them is joined\n     *\n     * @var array\n     */\n    protected $groupOrigin = array();\n\n    /**\n     * Map of table names to query names for which to create subquery filters\n     *\n     * @var array\n     */\n    protected $subQueryTargets = array();\n\n    /**\n     * The primary key column for the instances table\n     *\n     * @var string\n     */\n    protected $instance_id = 'instance_id';\n\n    /**\n     * The primary key column for the objects table\n     *\n     * @var string\n     */\n    protected $object_id       = 'object_id';\n\n    /**\n     * The primary key column for the acknowledgements table\n     *\n     * @var string\n     */\n    protected $acknowledgement_id = 'acknowledgement_id';\n\n    /**\n     * The primary key column for the commenthistory table\n     *\n     * @var string\n     */\n    protected $commenthistory_id = 'commenthistory_id';\n\n    /**\n     * The primary key column for the contactnotifications table\n     *\n     * @var string\n     */\n    protected $contactnotification_id = 'contactnotification_id';\n\n    /**\n     * The primary key column for the downtimehistory table\n     *\n     * @var string\n     */\n    protected $downtimehistory_id = 'downtimehistory_id';\n\n    /**\n     * The primary key column for the flappinghistory table\n     *\n     * @var string\n     */\n    protected $flappinghistory_id = 'flappinghistory_id';\n\n    /**\n     * The primary key column for the notifications table\n     *\n     * @var string\n     */\n    protected $notification_id = 'notification_id';\n\n    /**\n     * The primary key column for the statehistory table\n     *\n     * @var string\n     */\n    protected $statehistory_id = 'statehistory_id';\n\n    /**\n     * The primary key column for the comments table\n     *\n     * @var string\n     */\n    protected $comment_id = 'comment_id';\n\n    /**\n     * The primary key column for the customvariablestatus table\n     *\n     * @var string\n     */\n    protected $customvariablestatus_id = 'customvariablestatus_id';\n\n    /**\n     * The primary key column for the hoststatus table\n     *\n     * @var string\n     */\n    protected $hoststatus_id = 'hoststatus_id';\n\n    /**\n     * The primary key column for the programstatus table\n     *\n     * @var string\n     */\n    protected $programstatus_id = 'programstatus_id';\n\n    /**\n     * The primary key column for the runtimevariables table\n     *\n     * @var string\n     */\n    protected $runtimevariable_id = 'runtimevariable_id';\n\n    /**\n     * The primary key column for the scheduleddowntime table\n     *\n     * @var string\n     */\n    protected $scheduleddowntime_id = 'scheduleddowntime_id';\n\n    /**\n     * The primary key column for the servicestatus table\n     *\n     * @var string\n     */\n    protected $servicestatus_id = 'servicestatus_id';\n\n    /**\n     * The primary key column for the contactstatus table\n     *\n     * @var string\n     */\n    protected $contactstatus_id = 'contactstatus_id';\n\n    /**\n     * The primary key column for the commands table\n     *\n     * @var string\n     */\n    protected $command_id = 'command_id';\n\n    /**\n     * The primary key column for the contactgroup_members table\n     *\n     * @var string\n     */\n    protected $contactgroup_member_id = 'contactgroup_member_id';\n\n    /**\n     * The primary key column for the contactgroups table\n     *\n     * @var string\n     */\n    protected $contactgroup_id = 'contactgroup_id';\n\n    /**\n     * The primary key column for the contacts table\n     *\n     * @var string\n     */\n    protected $contact_id = 'contact_id';\n\n    /**\n     * The primary key column for the customvariables table\n     *\n     * @var string\n     */\n    protected $customvariable_id = 'customvariable_id';\n\n    /**\n     * The primary key column for the host_contactgroups table\n     *\n     * @var string\n     */\n    protected $host_contactgroup_id = 'host_contactgroup_id';\n\n    /**\n     * The primary key column for the host_contacts table\n     *\n     * @var string\n     */\n    protected $host_contact_id = 'host_contact_id';\n\n    /**\n     * The primary key column for the hostgroup_members table\n     *\n     * @var string\n     */\n    protected $hostgroup_member_id = 'hostgroup_member_id';\n\n    /**\n     * The primary key column for the hostgroups table\n     *\n     * @var string\n     */\n    protected $hostgroup_id = 'hostgroup_id';\n\n    /**\n     * The primary key column for the hosts table\n     *\n     * @var string\n     */\n    protected $host_id = 'host_id';\n\n    /**\n     * The primary key column for the service_contactgroup table\n     *\n     * @var string\n     */\n    protected $service_contactgroup_id = 'service_contactgroup_id';\n\n    /**\n     * The primary key column for the service_contact table\n     *\n     * @var string\n     */\n    protected $service_contact_id = 'service_contact_id';\n\n    /**\n     * The primary key column for the servicegroup_members table\n     *\n     * @var string\n     */\n    protected $servicegroup_member_id = 'servicegroup_member_id';\n\n    /**\n     * The primary key column for the servicegroups table\n     *\n     * @var string\n     */\n    protected $servicegroup_id = 'servicegroup_id';\n\n    /**\n     * The primary key column for the services table\n     *\n     * @var string\n     */\n    protected $service_id = 'service_id';\n\n    /**\n     * The primary key column for the timeperiods table\n     *\n     * @var string\n     */\n    protected $timeperiod_id = 'timeperiod_id';\n\n    /**\n     * An array containing Column names that cause an aggregation of the query\n     *\n     * @var array\n     */\n    protected $aggregateColumnIdx = array();\n\n    /**\n     * True to allow customvar filters and queries\n     *\n     * @var bool\n     */\n    protected $allowCustomVars = false;\n\n    /**\n     * Current IDO version. This is bullshit and needs to be moved somewhere\n     * else. As someone decided that we need no Backend-specific connection\n     * class unfortunately there is no better place right now. And as of the\n     * 'check_source' patch we need a quick fix immediately. So here you go.\n     *\n     * TODO: Fix this.\n     *\n     * @var string\n     */\n    protected static $idoVersion;\n\n    /**\n     * List of column aliases mapped to their table where the COLLATE SQL-instruction has been removed\n     *\n     * This list is being populated in case of a PostgreSQL backend only,\n     * to ensure case-insensitive string comparison in WHERE clauses.\n     *\n     * @var array\n     */\n    protected $caseInsensitiveColumns;\n\n    /**\n     * Return true when the column is an aggregate column\n     *\n     * @param  String $column       The column to test\n     * @return bool                 True when the column is an aggregate column\n     */\n    public function isAggregateColumn($column)\n    {\n        return array_key_exists($column, $this->aggregateColumnIdx);\n    }\n\n    /**\n     * Order the result by the given alias\n     *\n     * @param   string  $alias  The column alias to order by\n     * @param   int     $dir    The sort direction or null to use the default direction\n     *\n     * @return  $this\n     */\n    public function order($alias, $dir = null)\n    {\n        $this->requireColumn($alias);\n\n        if ($this->isCustomvar($alias)) {\n            $column = $this->getCustomvarColumnName($alias);\n        } elseif ($this->hasAliasName($alias)) {\n            $column = $this->aliasToColumnName($alias);\n            $table = $this->aliasToTableName($alias);\n            if (isset($this->caseInsensitiveColumns[$table][$alias])) {\n                $column = 'LOWER(' . $column . ')';\n            }\n        } else {\n            Logger::info('Can\\'t order by column ' . $alias);\n            return $this;\n        }\n\n        $this->orderColumns[] = $alias;\n        return parent::order($column, $dir);\n    }\n\n    /**\n     * Return true when the given field can be used for filtering\n     *\n     * @param String $field     The field to test\n     * @return bool             True when the field can be used for querying, otherwise false\n     */\n    public function isValidFilterTarget($field)\n    {\n        return $this->getMappedField($field) !== null;\n    }\n\n    /**\n     * Return the resolved field for an alias\n     *\n     * @param  String $field     The alias to resolve\n     * @return String           The resolved alias or null if unknown\n     */\n    public function getMappedField($field)\n    {\n        foreach ($this->columnMap as $columnSource => $columnSet) {\n            if (isset($columnSet[$field])) {\n                return $columnSet[$field];\n            }\n        }\n        if ($this->isCustomVar($field)) {\n            return $this->getCustomvarColumnName($field);\n        }\n        return null;\n    }\n\n    public function distinct()\n    {\n        $this->select->distinct();\n        return $this;\n    }\n\n    /**\n     * Prepare the given query so that it can be linked to the parent\n     *\n     * @param   IdoQuery            $query\n     * @param   string              $name\n     * @param   FilterExpression    $filter             The filter which initiated the sub query\n     * @param   bool                $and                Whether it's an AND filter\n     * @param   bool                $negate             Whether it's an != filter\n     * @param   FilterExpression    $additionalFilter   Filters which should be applied to the \"parent\" query\n     *\n     * @return  array   The first value is their, the second our key column\n     *\n     * @throws  NotImplementedError In case the given query is unknown\n     */\n    protected function joinSubQuery(IdoQuery $query, $name, $filter, $and, $negate, &$additionalFilter)\n    {\n        throw new NotImplementedError('Query \"%s\" is unknown', $name);\n    }\n\n    /**\n     * Create and return a sub-query filter for the given filter expression\n     *\n     * @param   FilterExpression    $filter\n     * @param   string              $queryName\n     *\n     * @return  Filter\n     *\n     * @throws  QueryException\n     */\n    protected function createSubQueryFilter(FilterExpression $filter, $queryName)\n    {\n        $expr = $filter->getExpression();\n        $op = $filter->getSign();\n\n        if ($op === '=' && ! is_array($expr) && $op !== '!=') {\n            // We're joining a subquery only if the filter is enclosed in parentheses or if it's a != filter,\n            // e.g. hostgroup_name=(linux...), hostgroup_name!=linux, hostgroup_name!=(linux...)\n            throw new NotImplementedError('');\n        }\n\n        $subQuery = $this->createSubQuery($queryName);\n        $subQuery->setIsSubQuery();\n\n        $subQueryFilter = clone $filter;\n\n        if ($op === '!=') {\n            $negate = true;\n            if (! is_array($expr)) {\n                // We assume that expression is an array later on but we'll support subquery joins for != filters\n                // which are not enclosed in parentheses\n                $expr = [$expr];\n            }\n        } else {\n            $negate = false;\n        }\n\n        if (count($expr) === 1 && strpos($expr[0], '&') !== false) {\n            // Our current filter implementation does not specify & as a control character so the count of the\n            // expression array is always one in this case\n            $expr = array_unique(explode('&', $expr[0]));\n            $subQueryFilter->setExpression($expr);\n            $and = true;\n        } else {\n            // Or filters are respected by our filter implementation. No special handling needed here\n            $and = false;\n        }\n\n        $alias = $filter->getColumn();\n        $column = $subQuery->aliasToColumnName($alias);\n        if (isset($this->caseInsensitiveColumns[$subQuery->aliasToTableName($alias)][$alias])) {\n            $column = 'LOWER( ' . $column . ' )';\n            $subQueryFilter->setColumn($column);\n            $subQueryFilter->setExpression(array_map('strtolower', (array) $subQueryFilter->getExpression()));\n        } else {\n            $subQueryFilter->setColumn($column);\n        }\n\n        $additional = null;\n\n        list($theirs, $ours) = $this->joinSubQuery($subQuery, $queryName, $subQueryFilter, $and, $negate, $additional);\n\n        $zendSelect = $subQuery->select();\n        $fromPart = $zendSelect->getPart($zendSelect::FROM);\n        $zendSelect->reset($zendSelect::FROM);\n\n        foreach ($fromPart as $correlationName => $joinOptions) {\n            if (isset($joinOptions['joinCondition'])) {\n                $joinOptions['joinCondition'] = preg_replace(\n                    '/(?<=^|\\s)\\w+(?=\\.)/',\n                    'sub_$0',\n                    $joinOptions['joinCondition']\n                );\n            }\n\n            $name = ['sub_' . $correlationName => $joinOptions['tableName']];\n            switch ($joinOptions['joinType']) {\n                case $zendSelect::FROM:\n                    $zendSelect->from($name);\n                    break;\n                case $zendSelect::INNER_JOIN:\n                    $zendSelect->joinInner($name, $joinOptions['joinCondition'], null);\n                    break;\n                case $zendSelect::LEFT_JOIN:\n                    $zendSelect->joinLeft($name, $joinOptions['joinCondition'], null);\n                    break;\n                default:\n                    // TODO: Add support for other join types if required?\n                    throw new QueryException(\n                        'Unsupported join type %s. Cannot create subquery filter.',\n                        $joinOptions['joinType']\n                    );\n            }\n        }\n\n        if ($and || $negate && ! $and) {\n            // Having is only required for AND and != filters,\n            // e.g. hostgroup_name=(ping&linux), hostgroup_name!=ping, hostgroup_name!=(ping|linux)\n            $groups = $subQuery->getGroup();\n            $group = $groups[0];\n            $group = preg_replace('/(?<=^|\\s)\\w+(?=\\.)/', 'sub_$0', $group);\n\n            $cnt = count($expr);\n\n            $subQuery->select()->having(\"COUNT(DISTINCT $group) >= $cnt\");\n        }\n\n        $subQueryFilter->setColumn(preg_replace(\n            '/(?<=^|\\s)\\w+(?=\\.)/',\n            'sub_$0',\n            $column\n        ));\n\n        if ($negate) {\n            // != will be NOT EXISTS later\n            $subQueryFilter = $subQueryFilter->setSign('=');\n        }\n\n        $subQueryFilter = $subQueryFilter->andFilter(Filter::where(\n            preg_replace('/(?<=^|\\s)\\w+(?=\\.)/', 'sub_$0', $theirs),\n            new Zend_Db_Expr($ours)\n        ));\n\n        $subQuery\n            ->setFilter($subQueryFilter)\n            ->clearGroupingRules()\n            ->select()\n            ->reset('columns')\n            ->columns([new Zend_Db_Expr('1')]);\n\n        // EXISTS is the column name because without any column $this->isCustomVar() fails badly otherwise.\n        // Additionally it bypasses the non-required optimizations made by our filter rendering implementation.\n        $exists = new FilterExpression($negate ? 'NOT EXISTS' : 'EXISTS', '', new Zend_Db_Expr($subQuery));\n\n        if ($additional !== null) {\n            return Filter::matchAll($exists, $additional);\n        }\n\n        return $exists;\n    }\n\n    protected function requireFilterColumns(Filter $filter)\n    {\n        if ($filter instanceof FilterExpression) {\n            $alias = $filter->getColumn();\n\n            $virtualTable = $this->aliasToTableName($alias);\n            if (isset($this->subQueryTargets[$virtualTable])) {\n                try {\n                    return $this->createSubQueryFilter($filter, $this->subQueryTargets[$virtualTable]);\n                } catch (NotImplementedError $e) {\n                    // We don't want to create subquery filters in all cases\n                }\n            }\n\n            $this->requireColumn($alias);\n\n            if ($this->isCustomvar($alias)) {\n                $column = $this->getCustomvarColumnName($alias);\n            } else {\n                $column = $this->aliasToColumnName($alias);\n                if (isset($this->caseInsensitiveColumns[$this->aliasToTableName($alias)][$alias])) {\n                    $column = 'LOWER(' . $column . ')';\n                    $expression = $filter->getExpression();\n                    if (is_array($expression)) {\n                        $filter->setExpression(array_map('strtolower', $expression));\n                    } else {\n                        $filter->setExpression(strtolower($expression));\n                    }\n                }\n            }\n\n            $filter->setColumn($column);\n        } else {\n            if (! $filter instanceof FilterNot) {\n                // Allow subquery filters in a filter chain\n                $columns = $filter->listFilteredColumns();\n                if (count($columns) === 1) {\n                    $column = $columns[0];\n                    $virtualTable = $this->aliasToTableName($column);\n                    if (isset($this->subQueryTargets[$virtualTable])) {\n                        $lastSign = null;\n                        $filters = [];\n                        $expressions = [];\n                        foreach ($filter->filters() as $child) {\n                            switch (true) {\n                                case $child instanceof FilterExpression:\n                                    $expression = $child->getExpression();\n                                    if (! is_array($expression)) {\n                                        break;\n                                    }\n                                    // Move to default\n                                default:\n                                    $filters[] = $child;\n                                    continue 2;\n                            }\n                            if ($lastSign === null) {\n                                $lastSign = $child->getSign();\n                            } else {\n                                $sign = $child->getSign();\n                                if ($sign !== $lastSign) {\n                                    $filters[] = new FilterExpression(\n                                        $column,\n                                        $lastSign,\n                                        $filter->getOperatorSymbol() === '&'\n                                            ? [implode('&', $expressions)]\n                                            : $expressions\n                                    );\n                                    $expressions = [];\n                                    $lastSign = $sign;\n                                }\n                            }\n                            $expressions[] = $expression;\n                        }\n                        if (! empty($expressions)) {\n                            $filters[] = new FilterExpression(\n                                $column,\n                                $lastSign,\n                                $filter->getOperatorSymbol() === '&'\n                                    ? [implode('&', $expressions)]\n                                    : $expressions\n                            );\n                        }\n                        $filter->setFilters($filters);\n                    }\n                }\n            }\n\n            foreach ($filter->filters() as $child) {\n                $replacement = $this->requireFilterColumns($child);\n                if ($replacement !== null) {\n                    // setId($child->getId()) is performed because replaceById() doesn't already do it\n                    $filter->replaceById($child->getId(), $replacement->setId($child->getId()));\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function addFilter(Filter $filter)\n    {\n        $filter = clone $filter;\n        return parent::addFilter($this->requireFilterColumns($filter) ?: $filter);\n    }\n\n    public function where($condition, $value = null)\n    {\n        $this->requireColumn($condition);\n        $col = $this->getMappedField($condition);\n        if ($col === null) {\n            throw new IcingaException(\n                'No such field: %s',\n                $condition\n            );\n        }\n        return parent::where($col, $value);\n    }\n\n    /**\n     * Return true if an field contains an explicit timestamp\n     *\n     * @param   string  $field      The field to test for containing an timestamp\n     *\n     * @return  bool                True when the field represents an timestamp\n     */\n    public function isTimestamp($field)\n    {\n        if ($this->isCustomVar($field)) {\n            return false;\n        }\n\n        return stripos($this->getMappedField($field) ?: $field, 'UNIX_TIMESTAMP') !== false;\n    }\n\n    /**\n     * Return whether the given alias provides case insensitive value comparison\n     *\n     * @param   string  $alias\n     *\n     * @return  bool\n     */\n    public function isCaseInsensitive($alias)\n    {\n        if ($this->isCustomVar($alias)) {\n            return false;\n        }\n\n        $column = $this->getMappedField($alias);\n        if (! $column) {\n            return false;\n        }\n\n        if (empty($this->caseInsensitiveColumns)) {\n            return preg_match('/ COLLATE .+$/', $column) === 1;\n        }\n\n        if (strpos($column, 'LOWER') === 0) {\n            return true;\n        }\n\n        $table = $this->aliasToTableName($alias);\n        if (! $table) {\n            return false;\n        }\n\n        return isset($this->caseInsensitiveColumns[$table][$alias]);\n    }\n\n    /**\n     * Return our column map\n     *\n     * Might be useful for hooks\n     *\n     * @return array\n     */\n    public function getColumnMap()\n    {\n        return $this->columnMap;\n    }\n\n    /**\n     * Apply oracle specific query initialization\n     */\n    private function initializeForOracle()\n    {\n        // Oracle uses the reserved field 'id' for primary keys, so\n        // these must be used instead of the normally defined ids\n        $this->object_id = $this->host_id = $this->service_id\n            = $this->hostgroup_id = $this->servicegroup_id\n            = $this->contact_id = $this->contactgroup_id = 'id';\n        $this->customVarsJoinTemplate =\n            '%1$s = %2$s.object_id AND LOWER(%2$s.varname) = %3$s';\n        foreach ($this->columnMap as &$columns) {\n            foreach ($columns as &$value) {\n                $value = preg_replace('/UNIX_TIMESTAMP/', 'localts2unixts', $value);\n                $value = preg_replace('/ COLLATE .+$/', '', $value);\n            }\n        }\n    }\n\n    /**\n     * Apply PostgreSQL specific query initialization\n     */\n    private function initializeForPostgres()\n    {\n        $this->customVarsJoinTemplate =\n            '%1$s = %2$s.object_id AND LOWER(%2$s.varname) = %3$s';\n        foreach ($this->columnMap as $table => & $columns) {\n            foreach ($columns as $alias => & $column) {\n                // Using a regex here because COLLATE may occur anywhere in the string\n                $column = preg_replace('/ COLLATE .+$/', '', $column, -1, $count);\n                if ($count > 0) {\n                    $this->caseInsensitiveColumns[$table][$alias] = true;\n                }\n\n                $column = preg_replace(\n                    '/inet_aton\\(([[:word:].]+)\\)/i',\n                    '(CASE WHEN $1 ~ \\'(?:[0-9]{1,3}\\\\\\\\.){3}[0-9]{1,3}\\' THEN $1::inet - \\'0.0.0.0\\' ELSE NULL END)',\n                    $column\n                );\n                if (version_compare($this->getIdoVersion(), '1.14.2', '>=')) {\n                    $column = str_replace('NOW()', 'NOW() AT TIME ZONE \\'UTC\\'', $column);\n                } else {\n                    $column = preg_replace(\n                        '/UNIX_TIMESTAMP(\\((?>[^()]|(?-1))*\\))/i',\n                        'CASE WHEN ($1 < \\'1970-01-03 00:00:00+00\\'::timestamp with time zone) THEN 0 ELSE UNIX_TIMESTAMP($1) END',\n                        $column\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Set up this query and join the initial tables\n     *\n     * @see IdoQuery::initializeForPostgres     For postgresql specific setup\n     */\n    protected function init()\n    {\n        parent::init();\n        $this->prefix = $this->ds->getTablePrefix();\n\n        foreach (Hook::all('monitoring/idoQueryExtension') as $hook) {\n            $extensions = $hook->extendColumnMap($this);\n            if (! is_array($extensions)) {\n                continue;\n            }\n\n            foreach ($extensions as $vTable => $cols) {\n                if (! array_key_exists($vTable, $this->columnMap)) {\n                    $this->hookedVirtualTables[$vTable] = $hook;\n                    $this->columMap[$vTable] = array();\n                }\n\n                foreach ($cols as $k => $v) {\n                    $this->columnMap[$vTable][$k] = $v;\n                }\n            }\n        }\n\n        $dbType = $this->ds->getDbType();\n        if ($dbType === 'oracle') {\n            $this->initializeForOracle();\n        } elseif ($dbType === 'pgsql') {\n            $this->initializeForPostgres();\n        } else {\n            $charset = $this->ds->getConfig()->get('charset') ?: 'latin1';\n            $this->customVarsJoinTemplate .= \" COLLATE {$charset}_general_ci\";\n        }\n        $this->joinBaseTables();\n        $this->select->columns($this->columns);\n        $this->prepareAliasIndexes();\n    }\n\n    /**\n     * Join the base tables for this query\n     */\n    protected function joinBaseTables()\n    {\n        reset($this->columnMap);\n        $table = key($this->columnMap);\n\n        $this->select->from(\n            array($table => $this->prefix . $table),\n            array()\n        );\n\n        $this->joinedVirtualTables = array($table => true);\n    }\n\n    /**\n     * Populates the idxAliasTAble and idxAliasColumn properties\n     */\n    protected function prepareAliasIndexes()\n    {\n        foreach ($this->columnMap as $tbl => & $cols) {\n            foreach ($cols as $alias => $col) {\n                $this->idxAliasTable[$alias] = $tbl;\n                $this->idxAliasColumn[$alias] = preg_replace('~\\n\\s*~', ' ', $col);\n            }\n        }\n    }\n\n    /**\n     * Resolve columns aliases to their database field using the columnMap\n     *\n     * @param   array $columns\n     *\n     * @return  array\n     */\n    public function resolveColumns($columns)\n    {\n        $resolvedColumns = array();\n\n        foreach ($columns as $alias => $col) {\n            if ($col instanceof Zend_Db_Expr) {\n                // Support selecting NULL as column for example\n                $resolvedColumns[$alias] = $col;\n                continue;\n            }\n            $this->requireColumn($col);\n            if ($this->isCustomvar($col)) {\n                $name = $this->getCustomvarColumnName($col);\n            } else {\n                $name = $this->aliasToColumnName($col);\n            }\n            if (is_int($alias)) {\n                $alias = $col;\n            } else {\n                $this->idxCustomAliases[$alias] = $col;\n            }\n\n            $resolvedColumns[$alias] = preg_replace('|\\n|', ' ', $name);\n        }\n\n        return $resolvedColumns;\n    }\n\n    /**\n     * Return all columns that will be selected when no columns are given in the constructor or from\n     *\n     * @return array        An array of column aliases\n     */\n    public function getDefaultColumns()\n    {\n        reset($this->columnMap);\n        $table = key($this->columnMap);\n        return array_keys($this->columnMap[$table]);\n    }\n\n    /**\n     * Modify the query to the given alias can be used in the result set or queries\n     *\n     * This calls requireVirtualTable if needed\n     *\n     * @param $alias                                The alias of the column to require\n     *\n     * @return $this                                 Fluent interface\n     * @see    IdoQuery::requireVirtualTable        The method initializing required joins\n     * @throws \\Icinga\\Exception\\ProgrammingError   When an unknown column is requested\n     */\n    public function requireColumn($alias)\n    {\n        if ($this->hasAliasName($alias)) {\n            $this->requireVirtualTable($this->aliasToTableName($alias));\n        } elseif ($this->isCustomVar($alias)) {\n            $this->requireCustomvar($alias);\n        } else {\n            throw new ProgrammingError(\n                '%s : Got invalid column: %s',\n                get_called_class(),\n                $alias\n            );\n        }\n        return $this;\n    }\n\n    /**\n     * Return true if the given alias exists\n     *\n     * @param  String $alias    The alias to test for\n     * @return bool             True when the alias exists, otherwise false\n     */\n    protected function hasAliasName($alias)\n    {\n        return array_key_exists($alias, $this->idxAliasColumn);\n    }\n\n    /**\n     * Require a virtual table for the given table name if not already required\n     *\n     * @param  String $name         The table name to require\n     * @return $this                 Fluent interface\n     */\n    protected function requireVirtualTable($name)\n    {\n        if ($this->hasJoinedVirtualTable($name)) {\n            return $this;\n        }\n\n        if ($this->virtualTableIsHooked($name)) {\n            return $this->joinHookedVirtualTable($name);\n        } else {\n            return $this->joinVirtualTable($name);\n        }\n    }\n\n    /**\n     * Whether a given virtual table name has been provided by a hook\n     *\n     * @param string $name Virtual table name\n     *\n     * @return boolean\n     */\n    protected function virtualTableIsHooked($name)\n    {\n        return array_key_exists($name, $this->hookedVirtualTables);\n    }\n\n    protected function conflictsWithVirtualTable($name)\n    {\n        if ($this->hasJoinedVirtualTable($name)) {\n            throw new ProgrammingError(\n                'IDO query virtual table conflict with \"%s\"',\n                $name\n            );\n        }\n        return $this;\n    }\n\n    /**\n     * Call the method for joining a virtual table\n     *\n     * This requires a join$Table() method to exist\n     *\n     * @param  String $table        The table to join by calling join$Table() in the concrete implementation\n     * @return $this                 Fluent interface\n     *\n     * @throws \\Icinga\\Exception\\ProgrammingError   If the join method for this table does not exist\n     */\n    protected function joinVirtualTable($table)\n    {\n        $func = 'join' . ucfirst($table);\n        if (method_exists($this, $func)) {\n            $this->$func();\n        } else {\n            throw new ProgrammingError(\n                'Cannot join \"%s\", no such table found',\n                $table\n            );\n        }\n        $this->joinedVirtualTables[$table] = true;\n        return $this;\n    }\n\n    /**\n     * Tell a hook to join a virtual table\n     *\n     * @param  String $table\n     * @return $this\n     */\n    protected function joinHookedVirtualTable($table)\n    {\n        $this->hookedVirtualTables[$table]->joinVirtualTable($this, $table);\n        $this->joinedVirtualTables[$table] = true;\n        return $this;\n    }\n\n    /**\n     * Get the table for a specific alias\n     *\n     * @param   String $alias   The alias to request the table for\n     * @return  String          The table for the alias or null if it doesn't exist\n     */\n    protected function aliasToTableName($alias)\n    {\n        return isset($this->idxAliasTable[$alias]) ? $this->idxAliasTable[$alias] : null;\n    }\n\n    /**\n     * Return whether this query allows to join custom variables\n     *\n     * @return  bool\n     */\n    public function allowsCustomVars()\n    {\n        return $this->allowCustomVars;\n    }\n\n    /**\n     * Return true if the given alias denotes a custom variable\n     *\n     * @param  String $alias    The alias to test for being a customvariable\n     * @return bool             True if the alias is a customvariable, otherwise false\n     */\n    protected function isCustomVar($alias)\n    {\n        return $this->allowCustomVars && $alias[0] === '_';\n    }\n\n    protected function requireCustomvar($customvar)\n    {\n        if (! $this->hasCustomvar($customvar)) {\n            $this->joinCustomvar($customvar);\n        }\n        return $this;\n    }\n\n    protected function hasCustomvar($customvar)\n    {\n        return array_key_exists(strtolower($customvar), $this->customVars);\n    }\n\n    protected function joinCustomvar($customvar)\n    {\n        // TODO: This is not generic enough yet\n        list($type, $name) = $this->customvarNameToTypeName($customvar);\n        $alias = ($type === 'host' ? 'hcv_' : 'scv_') . preg_replace('~[^a-zA-Z0-9_]~', '_', $name);\n\n        // We're replacing any problematic char with an underscore, which will lead to duplicates, this avoids them\n        $from = $this->select->getPart(Zend_Db_Select::FROM);\n        for ($i = 2; array_key_exists($alias, $from); $i++) {\n            $alias = $alias . '_' . $i;\n        }\n\n        $this->customVars[strtolower($customvar)] = $alias;\n\n        if ($type === 'host') {\n            if (\n                $this instanceof HostserviceproblemsummaryQuery\n                || $this instanceof ServicecommentQuery\n                || $this instanceof ServicedowntimeQuery\n                || $this instanceof ServicecommenthistoryQuery\n                || $this instanceof ServicedowntimestarthistoryQuery\n                || $this instanceof ServiceflappingstarthistoryQuery\n                || $this instanceof ServicegroupQuery\n                || $this instanceof ServicenotificationQuery\n                || $this instanceof ServicestatehistoryQuery\n                || $this instanceof ServicestatusQuery\n            ) {\n                $this->requireVirtualTable('services');\n                $leftcol = 's.host_object_id';\n            } else {\n                $leftcol = 'ho.object_id';\n                if (! $this->hasJoinedTable('ho')) {\n                    $this->requireVirtualTable('hosts');\n                }\n            }\n        } else { // $type === 'service'\n            $leftcol = 'so.object_id';\n            if (! $this->hasJoinedTable('so')) {\n                $this->requireVirtualTable('services');\n            }\n        }\n\n        $mapped = $this->getMappedField($leftcol);\n        if ($mapped !== null) {\n            $this->requireColumn($leftcol);\n            $leftcol = $mapped;\n        }\n\n        $joinOn = sprintf(\n            $this->customVarsJoinTemplate,\n            $leftcol,\n            $alias,\n            $this->db->quote($name)\n        );\n\n        $this->select->joinLeft(\n            array($alias => $this->prefix . 'customvariablestatus'),\n            $joinOn,\n            array()\n        );\n\n        return $this;\n    }\n\n    protected function customvarNameToTypeName($customvar)\n    {\n        $customvar = strtolower($customvar);\n        if (! preg_match('~^_(host|service)_(.+)$~', $customvar, $m)) {\n            throw new ProgrammingError(\n                'Got invalid custom var: \"%s\"',\n                $customvar\n            );\n        }\n        return array($m[1], $m[2]);\n    }\n\n    protected function hasJoinedVirtualTable($name)\n    {\n        return array_key_exists($name, $this->joinedVirtualTables);\n    }\n\n    /**\n     * Get the query column of a already joined custom variable\n     *\n     * @param   string $customvar\n     *\n     * @return  string\n     * @throws  QueryException If the custom variable has not been joined\n     */\n    protected function getCustomvarColumnName($customvar)\n    {\n        if (! isset($this->customVars[($customvar = strtolower($customvar))])) {\n            throw new QueryException('Custom variable %s has not been joined', $customvar);\n        }\n        return $this->customVars[$customvar] . '.varvalue';\n    }\n\n    public function aliasToColumnName($alias)\n    {\n        return $this->idxAliasColumn[$alias];\n    }\n\n    /**\n     * Get the alias of a column expression as defined in the {@link $columnMap} property.\n     *\n     * @param   string $alias Potential custom alias\n     *\n     * @return  string\n     */\n    public function customAliasToAlias($alias)\n    {\n        if (isset($this->idxCustomAliases[$alias])) {\n            return $this->idxCustomAliases[$alias];\n        }\n        return $alias;\n    }\n\n    /**\n     * Create a sub query\n     *\n     * @param   string  $queryName\n     * @param   array   $columns\n     *\n     * @return  static\n     */\n    protected function createSubQuery($queryName, $columns = array())\n    {\n        $class = '\\\\'\n            . substr(__CLASS__, 0, strrpos(__CLASS__, '\\\\') + 1)\n            . ucfirst($queryName) . 'Query';\n        $query = new $class($this->ds, $columns);\n        return $query;\n    }\n\n    /**\n     * Set columns to select\n     *\n     * @param   array $columns\n     *\n     * @return  $this\n     */\n    public function columns(array $columns)\n    {\n        $this->idxCustomAliases = array();\n        $this->columns = $this->resolveColumns($columns);\n        // TODO: we need to refresh our select!\n        // $this->select->columns($columns);\n        return $this;\n    }\n\n    public function clearGroupingRules()\n    {\n        $this->groupBase = array();\n        $this->groupOrigin = array();\n        return $this;\n    }\n\n    /**\n     * Register the GROUP BY columns required for the given alias\n     *\n     * @param   string  $alias              The alias to register columns for\n     * @param   string  $table              The table the given alias is associated with\n     * @param   array   $groupedColumns     The grouping columns registered so far\n     * @param   array   $groupedTables      The tables for which columns were registered so far\n     */\n    protected function registerGroupColumns($alias, $table, array &$groupedColumns, array &$groupedTables)\n    {\n        switch ($table) {\n            case 'checktimeperiods':\n                $groupedColumns[] = 'ctp.timeperiod_id';\n                break;\n            case 'contacts':\n                $groupedColumns[] = 'co.object_id';\n                $groupedColumns[] = 'c.contact_id';\n                break;\n            case 'hostobjects':\n                $groupedColumns[] = 'ho.object_id';\n                break;\n            case 'hosts':\n                $groupedColumns[] = 'h.host_id';\n                break;\n            case 'hostgroups':\n                $groupedColumns[] = 'hgo.object_id';\n                $groupedColumns[] = 'hg.hostgroup_id';\n                break;\n            case 'hoststatus':\n                $groupedColumns[] = 'hs.hoststatus_id';\n                break;\n            case 'instances':\n                $groupedColumns[] = 'i.instance_id';\n                break;\n            case 'servicegroups':\n                $groupedColumns[] = 'sgo.object_id';\n                $groupedColumns[] = 'sg.servicegroup_id';\n                break;\n            case 'serviceobjects':\n                $groupedColumns[] = 'so.object_id';\n                break;\n            case 'serviceproblemsummary':\n                $groupedColumns[] = 'sps.unhandled_services_count';\n                break;\n            case 'services':\n                $groupedColumns[] = 'so.object_id';\n                $groupedColumns[] = 's.service_id';\n                break;\n            case 'servicestatus':\n                $groupedColumns[] = 'ss.servicestatus_id';\n                break;\n            default:\n                return;\n        }\n\n        $groupedTables[$table] = true;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getGroup()\n    {\n        $group = parent::getGroup() ?: array();\n        if (! is_array($group)) {\n            $group = array($group);\n        }\n\n        $joinedOrigins = array_filter($this->groupOrigin, array($this, 'hasJoinedVirtualTable'));\n        if (empty($joinedOrigins)) {\n            return $group;\n        }\n\n        $groupedTables = array();\n        foreach ($this->groupBase as $baseTable => $aliasedPks) {\n            if (! $this->hasJoinedVirtualTable($baseTable)) {\n                continue;\n            }\n            $groupedTables[$baseTable] = true;\n            foreach ($aliasedPks as $aliasedPk) {\n                $group[] = $aliasedPk;\n            }\n        }\n\n        foreach (new ColumnFilterIterator($this->columns) as $desiredAlias => $desiredColumn) {\n            $alias = is_string($desiredAlias) ? $this->customAliasToAlias($desiredAlias) : $desiredColumn;\n            if ($this->isCustomVar($alias) && $this->getDatasource()->getDbType() === 'pgsql') {\n                $table = $this->customVars[$alias];\n                if (! isset($groupedTables[$table])) {\n                    $group[] = $this->getCustomvarColumnName($alias);\n                    $groupedTables[$table] = true;\n                }\n                continue;\n            }\n            $table = $this->aliasToTableName($alias);\n            if ($table && !isset($groupedTables[$table]) && (\n                in_array($table, $joinedOrigins, true) || $this->getDatasource()->getDbType() === 'pgsql')\n            ) {\n                $this->registerGroupColumns($alias, $table, $group, $groupedTables);\n            }\n        }\n\n        if (! empty($group) && $this->getDatasource()->getDbType() === 'pgsql') {\n            foreach (new ColumnFilterIterator($this->orderColumns) as $alias) {\n                if ($this->isCustomVar($alias)) {\n                    $table = $this->customVars[$alias];\n                    if (! isset($groupedTables[$table])) {\n                        $group[] = $this->getCustomvarColumnName($alias);\n                        $groupedTables[$table] = true;\n                    }\n                    continue;\n                }\n                $table = $this->aliasToTableName($alias);\n                if ($table && !isset($groupedTables[$table])\n                    && !in_array($this->getMappedField($alias), $this->columns, true)\n                ) {\n                    $this->registerGroupColumns($alias, $table, $group, $groupedTables);\n                }\n            }\n        }\n\n        return array_unique($group);\n    }\n\n    // TODO: Move this away, see note related to $idoVersion var\n    protected function getIdoVersion()\n    {\n        if (self::$idoVersion === null) {\n            $dbconf = $this->db->getConfig();\n            $id = $dbconf['host'] . '/' . $dbconf['dbname'];\n            $session = null;\n            if (Icinga::app()->isWeb()) {\n                // TODO: Once we have version per connection we should choose a\n                //       namespace based on resource name\n                $session = Session::getSession()->getNamespace('monitoring/ido/' . $id);\n                if (isset($session->version)) {\n                    self::$idoVersion = $session->version;\n                    return self::$idoVersion;\n                }\n            }\n            self::$idoVersion = $this->db->fetchOne(\n                $this->db->select()->from($this->prefix . 'dbversion', 'version')\n            );\n            if ($session !== null) {\n                $session->version = self::$idoVersion;\n            }\n        }\n        return self::$idoVersion;\n    }\n\n    /**\n     * Return the name of the primary key column for the given table name\n     *\n     * @param   string  $table\n     *\n     * @return  string\n     *\n     * @throws ProgrammingError     In case $table is unknown\n     */\n    protected function getPrimaryKeyColumn($table)\n    {\n        // TODO: For god's sake, make this being a mapping\n        //       (instead of matching a ton of properties using a ridiculous long switch case)\n        switch ($table) {\n            case 'instances':\n                return $this->instance_id;\n            case 'objects':\n                return $this->object_id;\n            case 'acknowledgements':\n                return $this->acknowledgement_id;\n            case 'commenthistory':\n                return $this->commenthistory_id;\n            case 'contactnotifiations':\n                return $this->contactnotification_id;\n            case 'downtimehistory':\n                return $this->downtimehistory_id;\n            case 'flappinghistory':\n                return $this->flappinghistory_id;\n            case 'notifications':\n                return $this->notification_id;\n            case 'statehistory':\n                return $this->statehistory_id;\n            case 'comments':\n                return $this->comment_id;\n            case 'customvariablestatus':\n                return $this->customvariablestatus_id;\n            case 'hoststatus':\n                return $this->hoststatus_id;\n            case 'programstatus':\n                return $this->programstatus_id;\n            case 'runtimevariables':\n                return $this->runtimevariable_id;\n            case 'scheduleddowntime':\n                return $this->scheduleddowntime_id;\n            case 'servicestatus':\n                return $this->servicestatus_id;\n            case 'contactstatus':\n                return $this->contactstatus_id;\n            case 'commands':\n                return $this->command_id;\n            case 'contactgroup_members':\n                return $this->contactgroup_member_id;\n            case 'contactgroups':\n                return $this->contactgroup_id;\n            case 'contacts':\n                return $this->contact_id;\n            case 'customvariables':\n                return $this->customvariable_id;\n            case 'host_contactgroups':\n                return $this->host_contactgroup_id;\n            case 'host_contacts':\n                return $this->host_contact_id;\n            case 'hostgroup_members':\n                return $this->hostgroup_member_id;\n            case 'hostgroups':\n                return $this->hostgroup_id;\n            case 'hosts':\n                return $this->host_id;\n            case 'service_contactgroups':\n                return $this->service_contactgroup_id;\n            case 'service_contacts':\n                return $this->service_contact_id;\n            case 'servicegroup_members':\n                return $this->servicegroup_member_id;\n            case 'servicegroups':\n                return $this->servicegroup_id;\n            case 'services':\n                return $this->service_id;\n            case 'timeperiods':\n                return $this->timeperiod_id;\n            default:\n                throw new ProgrammingError('Cannot provide a primary key column. Table \"%s\" is unknown', $table);\n        }\n    }\n}\n", "<?php\n/* Icinga Web 2 | (c) 2018 Icinga Development Team | GPLv2+ */\n\nnamespace Icinga\\Module\\Monitoring\\Backend\\Ido\\Query;\n\n/**\n * Query for service contacts\n */\nclass ServicecontactQuery extends IdoQuery\n{\n    protected $allowCustomVars = true;\n\n    protected $groupBase = [\n        'contacts' => ['co.object_id', 'c.contact_id'],\n        'timeperiods' => ['ht.timeperiod_id', 'st.timeperiod_id']\n    ];\n\n    protected $groupOrigin = ['contactgroups', 'hosts', 'services'];\n\n    protected $subQueryTargets = [\n        'hostgroups'    => 'hostgroup',\n        'servicegroups' => 'servicegroup'\n    ];\n\n    protected $columnMap = [\n        'contactgroups' => [\n            'contactgroup'       => 'cgo.name1 COLLATE latin1_general_ci',\n            'contactgroup_name'  => 'cgo.name1',\n            'contactgroup_alias' => 'cg.alias COLLATE latin1_general_ci'\n        ],\n        'contacts' => [\n            'contact_id'                       => 'c.contact_id',\n            'contact'                          => 'co.name1 COLLATE latin1_general_ci',\n            'contact_name'                     => 'co.name1',\n            'contact_alias'                    => 'c.alias COLLATE latin1_general_ci',\n            'contact_email'                    => 'c.email_address COLLATE latin1_general_ci',\n            'contact_pager'                    => 'c.pager_address',\n            'contact_object_id'                => 'c.contact_object_id',\n            'contact_has_host_notfications'    => 'c.host_notifications_enabled',\n            'contact_has_service_notfications' => 'c.service_notifications_enabled',\n            'contact_can_submit_commands'      => 'c.can_submit_commands',\n            'contact_notify_service_recovery'  => 'c.notify_service_recovery',\n            'contact_notify_service_warning'   => 'c.notify_service_warning',\n            'contact_notify_service_critical'  => 'c.notify_service_critical',\n            'contact_notify_service_unknown'   => 'c.notify_service_unknown',\n            'contact_notify_service_flapping'  => 'c.notify_service_flapping',\n            'contact_notify_service_downtime'  => 'c.notify_service_downtime',\n            'contact_notify_host_recovery'     => 'c.notify_host_recovery',\n            'contact_notify_host_down'         => 'c.notify_host_down',\n            'contact_notify_host_unreachable'  => 'c.notify_host_unreachable',\n            'contact_notify_host_flapping'     => 'c.notify_host_flapping',\n            'contact_notify_host_downtime'     => 'c.notify_host_downtime'\n        ],\n        'hostgroups' => [\n            'hostgroup'       => 'hgo.name1 COLLATE latin1_general_ci',\n            'hostgroup_alias' => 'hg.alias COLLATE latin1_general_ci',\n            'hostgroup_name'  => 'hgo.name1'\n        ],\n        'hosts' => [\n            'host'              => 'ho.name1 COLLATE latin1_general_ci',\n            'host_name'         => 'ho.name1',\n            'host_alias'        => 'h.alias',\n            'host_display_name' => 'h.display_name COLLATE latin1_general_ci'\n        ],\n        'instances' => [\n            'instance_name' => 'i.instance_name'\n        ],\n        'servicegroups' => [\n            'servicegroup'       => 'sgo.name1 COLLATE latin1_general_ci',\n            'servicegroup_name'  => 'sgo.name1',\n            'servicegroup_alias' => 'sg.alias COLLATE latin1_general_ci'\n        ],\n        'services' => [\n            'service'              => 'so.name2 COLLATE latin1_general_ci',\n            'service_description'  => 'so.name2',\n            'service_display_name' => 's.display_name COLLATE latin1_general_ci',\n            'service_host_name'    => 'so.name1'\n        ],\n        'timeperiods' => [\n            'contact_notify_host_timeperiod'    => 'ht.alias COLLATE latin1_general_ci',\n            'contact_notify_service_timeperiod' => 'st.alias COLLATE latin1_general_ci'\n        ]\n    ];\n\n    protected function joinBaseTables()\n    {\n        $this->select->from(\n            ['c' => $this->prefix . 'contacts'],\n            []\n        )->join(\n            ['co' => $this->prefix . 'objects'],\n            'co.object_id = c.contact_object_id AND co.is_active = 1 AND co.objecttype_id = 10',\n            []\n        );\n\n        $this->select->joinLeft(\n            ['sc' => $this->prefix . 'service_contacts'],\n            'sc.contact_object_id = c.contact_object_id',\n            []\n        )->joinLeft(\n            ['s' => $this->prefix . 'services'],\n            's.service_id = sc.service_id',\n            []\n        )->joinLeft(\n            ['so' => $this->prefix . 'objects'],\n            'so.object_id = s.service_object_id AND so.is_active = 1 AND so.objecttype_id = 2',\n            []\n        );\n\n        $this->joinedVirtualTables['contacts'] = true;\n        $this->joinedVirtualTables['services'] = true;\n    }\n\n    /**\n     * Join contact groups\n     */\n    protected function joinContactgroups()\n    {\n        $this->select->joinLeft(\n            ['cgm' => $this->prefix . 'contactgroup_members'],\n            'co.object_id = cgm.contact_object_id',\n            []\n        )->joinLeft(\n            ['cg' => $this->prefix . 'contactgroups'],\n            'cgm.contactgroup_id = cg.contactgroup_id',\n            []\n        )->joinLeft(\n            ['cgo' => $this->prefix . 'objects'],\n            'cg.contactgroup_object_id = cgo.object_id AND cgo.is_active = 1 AND cgo.objecttype_id = 11',\n            []\n        );\n    }\n\n    /**\n     * Join host groups\n     */\n    protected function joinHostgroups()\n    {\n        $this->requireVirtualTable('hosts');\n        $this->select->joinLeft(\n            ['hgm' => $this->prefix . 'hostgroup_members'],\n            'hgm.host_object_id = ho.object_id',\n            []\n        )->joinLeft(\n            ['hg' => $this->prefix . 'hostgroups'],\n            'hg.hostgroup_id = hgm.hostgroup_id',\n            []\n        )->joinLeft(\n            ['hgo' => $this->prefix . 'objects'],\n            'hgo.object_id = hg.hostgroup_object_id AND hgo.is_active = 1 AND hgo.objecttype_id = 3',\n            []\n        );\n    }\n\n    /**\n     * Join hosts\n     */\n    protected function joinHosts()\n    {\n        $this->select->joinLeft(\n            ['h' => $this->prefix . 'hosts'],\n            'h.host_object_id = s.host_object_id',\n            []\n        )->joinLeft(\n            ['ho' => $this->prefix . 'objects'],\n            'ho.object_id = h.host_object_id AND ho.is_active = 1 AND ho.objecttype_id = 1',\n            []\n        );\n    }\n\n    /**\n     * Join instances\n     */\n    protected function joinInstances()\n    {\n        $this->select->join(\n            ['i' => $this->prefix . 'instances'],\n            'i.instance_id = c.instance_id',\n            []\n        );\n    }\n\n    /**\n     * Join service groups\n     */\n    protected function joinServicegroups()\n    {\n        $this->requireVirtualTable('services');\n        $this->select->joinLeft(\n            ['sgm' => $this->prefix . 'servicegroup_members'],\n            'sgm.service_object_id = s.service_object_id',\n            []\n        )->joinLeft(\n            ['sg' => $this->prefix . 'servicegroups'],\n            'sg.servicegroup_id = sgm.servicegroup_id',\n            []\n        )->joinLeft(\n            ['sgo' => $this->prefix . 'objects'],\n            'sgo.object_id = sg.servicegroup_object_id AND sgo.is_active = 1 AND sgo.objecttype_id = 4',\n            []\n        );\n    }\n\n    /**\n     * Join time periods\n     */\n    protected function joinTimeperiods()\n    {\n        $this->select->joinLeft(\n            ['ht' => $this->prefix . 'timeperiods'],\n            'ht.timeperiod_object_id = c.host_timeperiod_object_id',\n            []\n        );\n        $this->select->joinLeft(\n            ['st' => $this->prefix . 'timeperiods'],\n            'st.timeperiod_object_id = c.service_timeperiod_object_id',\n            []\n        );\n    }\n\n    protected function joinSubQuery(IdoQuery $query, $name, $filter, $and, $negate, &$additionalFilter)\n    {\n        if ($name === 'hostgroup') {\n            $query->joinVirtualTable('members');\n\n            return ['hgm.host_object_id', 's.host_object_id'];\n        } elseif ($name === 'servicegroup') {\n            $query->joinVirtualTable('members');\n\n            return ['sgm.service_object_id', 'so.object_id'];\n        }\n\n        return parent::joinSubQuery($query, $name, $filter, $and, $negate, $additionalFilter);\n    }\n}\n"], "buggy_code_start_loc": [92, 75, 1194, 92], "buggy_code_end_loc": [157, 76, 1202, 167], "fixing_code_start_loc": [92, 75, 1194, 92], "fixing_code_end_loc": [157, 76, 1220, 167], "type": "CWE-863", "message": "Icinga Web 2 is an open source monitoring web interface, framework and command-line interface. Installations of Icinga 2 with the IDO writer enabled are affected. If you use service custom variables in role restrictions, and you regularly decommission service objects, users with said roles may still have access to a collection of content. Note that this only applies if a role has implicitly permitted access to hosts, due to permitted access to at least one of their services. If access to a host is permitted by other means, no sensible information has been disclosed to unauthorized users. This issue has been resolved in versions 2.8.6, 2.9.6 and 2.10 of Icinga Web 2.", "other": {"cve": {"id": "CVE-2022-24714", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-08T20:15:07.697", "lastModified": "2022-11-09T21:38:19.137", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Icinga Web 2 is an open source monitoring web interface, framework and command-line interface. Installations of Icinga 2 with the IDO writer enabled are affected. If you use service custom variables in role restrictions, and you regularly decommission service objects, users with said roles may still have access to a collection of content. Note that this only applies if a role has implicitly permitted access to hosts, due to permitted access to at least one of their services. If access to a host is permitted by other means, no sensible information has been disclosed to unauthorized users. This issue has been resolved in versions 2.8.6, 2.9.6 and 2.10 of Icinga Web 2."}, {"lang": "es", "value": "Icinga Web 2 es una interfaz web de monitorizaci\u00f3n de c\u00f3digo abierto, un framework y una interfaz de l\u00ednea de comandos. Las instalaciones de Icinga 2 con el escritor IDO activado est\u00e1n afectadas. Si se utilizan variables personalizadas de servicio en las restricciones de rol, y se desmantelan regularmente los objetos de servicio, los usuarios con dichos roles pueden seguir teniendo acceso a una colecci\u00f3n de contenido. Tenga en cuenta que esto s\u00f3lo se aplica si un rol tiene permitido impl\u00edcitamente el acceso a los hosts, debido al acceso permitido a al menos uno de sus servicios. Si se permite el acceso a un host por otros medios, no se ha revelado informaci\u00f3n sensible a usuarios no autorizados. Este problema ha sido resuelto en las versiones 2.8.6, 2.9.6 y 2.10 de Icinga Web 2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:icinga:icinga_web_2:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.6", "matchCriteriaId": "31515B3D-01CA-4B3C-AF94-AD63FDE7F8B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:icinga:icinga_web_2:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.6", "matchCriteriaId": "CE7D185F-C8C8-4401-B8F5-580DF83D5D79"}]}]}], "references": [{"url": "https://github.com/Icinga/icingaweb2/commit/6e989d05a1568a6733a3d912001251acc51d9293", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Icinga/icingaweb2/security/advisories/GHSA-qcmg-vr56-x9wf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-05", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Icinga/icingaweb2/commit/6e989d05a1568a6733a3d912001251acc51d9293"}}