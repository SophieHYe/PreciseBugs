{"buggy_code": ["/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/common_shape_fns.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/shape_inference.h\"\n\nnamespace tensorflow {\n\nusing shape_inference::InferenceContext;\nusing shape_inference::ShapeHandle;\n\nStatus DenseCountSparseOutputShapeFn(InferenceContext *c) {\n  auto values = c->input(0);\n  auto weights = c->input(1);\n  ShapeHandle output;\n  auto num_weights = c->NumElements(weights);\n  if (c->ValueKnown(num_weights) && c->Value(num_weights) == 0) {\n    output = values;\n  } else {\n    TF_RETURN_IF_ERROR(c->Merge(weights, values, &output));\n  }\n  auto rank = c->Rank(output);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  // out.indices\n  c->set_output(1, c->Vector(nvals));        // out.values\n  c->set_output(2, c->Vector(rank));         // out.dense_shape\n  return Status::OK();\n}\n\nStatus SparseCountSparseOutputShapeFn(InferenceContext *c) {\n  auto rank = c->Dim(c->input(0), 1);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  // out.indices\n  c->set_output(1, c->Vector(nvals));        // out.values\n  c->set_output(2, c->Vector(rank));         // out.dense_shape\n  return Status::OK();\n}\n\nStatus RaggedCountSparseOutputShapeFn(InferenceContext *c) {\n  int32_t rank = c->Rank(c->input(1));\n  if (rank != c->kUnknownRank) {\n    ++rank;  // Add the ragged dimension\n  }\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  // out.indices\n  c->set_output(1, c->Vector(nvals));        // out.values\n  c->set_output(2, c->Vector(rank));         // out.dense_shape\n  return Status::OK();\n}\n\nREGISTER_OP(\"DenseCountSparseOutput\")\n    .Input(\"values: T\")\n    .Input(\"weights: output_type\")\n    .Attr(\"T: {int32, int64}\")\n    .Attr(\"minlength: int >= -1 = -1\")\n    .Attr(\"maxlength: int >= -1 = -1\")\n    .Attr(\"binary_output: bool\")\n    .Attr(\"output_type: {int32, int64, float, double}\")\n    .SetShapeFn(DenseCountSparseOutputShapeFn)\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: output_type\")\n    .Output(\"output_dense_shape: int64\");\n\nREGISTER_OP(\"SparseCountSparseOutput\")\n    .Input(\"indices: int64\")\n    .Input(\"values: T\")\n    .Input(\"dense_shape: int64\")\n    .Input(\"weights: output_type\")\n    .Attr(\"T: {int32, int64}\")\n    .Attr(\"minlength: int >= -1 = -1\")\n    .Attr(\"maxlength: int >= -1 = -1\")\n    .Attr(\"binary_output: bool\")\n    .Attr(\"output_type: {int32, int64, float, double}\")\n    .SetShapeFn(SparseCountSparseOutputShapeFn)\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: output_type\")\n    .Output(\"output_dense_shape: int64\");\n\nREGISTER_OP(\"RaggedCountSparseOutput\")\n    .Input(\"splits: int64\")\n    .Input(\"values: T\")\n    .Input(\"weights: output_type\")\n    .Attr(\"T: {int32, int64}\")\n    .Attr(\"minlength: int >= -1 = -1\")\n    .Attr(\"maxlength: int >= -1 = -1\")\n    .Attr(\"binary_output: bool\")\n    .Attr(\"output_type: {int32, int64, float, double}\")\n    .SetShapeFn(RaggedCountSparseOutputShapeFn)\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: output_type\")\n    .Output(\"output_dense_shape: int64\");\n\n}  // namespace tensorflow\n", "# Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# maxlengthations under the License.\n# ==============================================================================\n\"\"\"Tests for bincount ops.\"\"\"\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import bincount_ops\nfrom tensorflow.python.ops import gen_count_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.ops.ragged import ragged_factory_ops\nfrom tensorflow.python.ops.ragged import ragged_tensor\nfrom tensorflow.python.platform import test\n\n\nclass TestSparseCount(test.TestCase, parameterized.TestCase):\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\": \"_no_maxlength\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 6]\n      }, {\n          \"testcase_name\": \"_maxlength\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [1, 1, 1, 1, 2],\n          \"expected_shape\": [2, 7]\n      }, {\n          \"testcase_name\": \"_minlength\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 9]\n      }, {\n          \"testcase_name\": \"_minlength_larger_values\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 8]\n      }, {\n          \"testcase_name\": \"_no_maxlength_binary\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 6],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_maxlength_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 7],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_minlength_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 9],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_minlength_larger_values_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 8],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_no_maxlength_weights\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [2, 1, 0.5, 9, 3],\n          \"expected_shape\": [2, 6],\n          \"weights\": [[0.5, 1, 2], [3, 4, 5]]\n      }, {\n          \"testcase_name\": \"_maxlength_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [2, 1, 0.5, 3, 9],\n          \"expected_shape\": [2, 7],\n          \"weights\": [[0.5, 1, 2, 11], [7, 3, 4, 5]]\n      }, {\n          \"testcase_name\": \"_minlength_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],\n          \"expected_shape\": [2, 9],\n          \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]\n      }, {\n          \"testcase_name\": \"_minlength_larger_values_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],\n          \"expected_shape\": [2, 8],\n          \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]\n      }, {\n          \"testcase_name\": \"_1d\",\n          \"x\": np.array([3, 2, 1, 1], dtype=np.int32),\n          \"expected_indices\": [[1], [2], [3]],\n          \"expected_values\": [2, 1, 1],\n          \"expected_shape\": [4]\n      }, {\n          \"testcase_name\": \"_all_axes\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[1], [2], [3], [4], [5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\": None\n      })\n  def test_dense_input(self,\n                       x,\n                       expected_indices,\n                       expected_values,\n                       expected_shape,\n                       minlength=None,\n                       maxlength=None,\n                       binary_output=False,\n                       weights=None,\n                       axis=-1):\n    y = bincount_ops.sparse_bincount(\n        x,\n        weights=weights,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\":\n              \"_no_maxlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [3, 6],\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n      },\n      {\n          \"testcase_name\":\n              \"_no_maxlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1],\n          \"expected_shape\": [3, 6],\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_no_maxlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 7, 10],\n          \"expected_shape\": [3, 6],\n          \"weights\":\n              np.array([[6, 0, 2, 0], [0, 0, 0, 0], [10, 0, 3.5, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 7, 10],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [0, 0, 14, 0], [10, 0, 3.5, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 14, 6.5, 10],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 14, 6.5, 10],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),\n      },\n      {\n          \"testcase_name\": \"_1d\",\n          \"x\": np.array([3, 0, 1, 1], dtype=np.int32),\n          \"expected_indices\": [[1], [3]],\n          \"expected_values\": [2, 1],\n          \"expected_shape\": [4],\n      },\n      {\n          \"testcase_name\":\n              \"_all_axes\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[1], [3], [4], [5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\":\n              None,\n      },\n  )\n  def test_sparse_input(self,\n                        x,\n                        expected_indices,\n                        expected_values,\n                        expected_shape,\n                        maxlength=None,\n                        minlength=None,\n                        binary_output=False,\n                        weights=None,\n                        axis=-1):\n    x_sparse = sparse_ops.from_dense(x)\n    w_sparse = sparse_ops.from_dense(weights) if weights is not None else None\n    y = bincount_ops.sparse_bincount(\n        x_sparse,\n        weights=w_sparse,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\": \"_no_maxlength\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 6],\n      },\n      {\n          \"testcase_name\": \"_maxlength\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 7],\n      },\n      {\n          \"testcase_name\": \"_minlength\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 9],\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 8],\n      },\n      {\n          \"testcase_name\": \"_no_maxlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 6],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_maxlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 7],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_minlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 9],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"binary_output\": True,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 8],\n      },\n      {\n          \"testcase_name\": \"_no_maxlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],\n          \"expected_shape\": [5, 6],\n          \"weights\": [[], [], [6, 0.5, 2], [], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_maxlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],\n          \"expected_shape\": [5, 7],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_minlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],\n          \"expected_shape\": [5, 9],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],\n          \"expected_shape\": [5, 8],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_1d\",\n          \"x\": [3, 0, 1, 1],\n          \"expected_indices\": [[0], [1], [3]],\n          \"expected_values\": [1, 2, 1],\n          \"expected_shape\": [4],\n      },\n      {\n          \"testcase_name\": \"_all_axes\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[0], [1], [3], [4], [5]],\n          \"expected_values\": [2, 1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\": None,\n      },\n  )\n  def test_ragged_input(self,\n                        x,\n                        expected_indices,\n                        expected_values,\n                        expected_shape,\n                        maxlength=None,\n                        minlength=None,\n                        binary_output=False,\n                        weights=None,\n                        axis=-1):\n    x_ragged = ragged_factory_ops.constant(x)\n    w = ragged_factory_ops.constant(weights) if weights is not None else None\n    y = bincount_ops.sparse_bincount(\n        x_ragged,\n        weights=w,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n\nclass TestDenseBincount(test.TestCase, parameterized.TestCase):\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_count(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 1000\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n\n    np_out = np.bincount(inp_vals, minlength=size)\n    self.assertAllEqual(\n        np_out, self.evaluate(bincount_ops.bincount(sparse_inp, axis=0)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_count_with_weights(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 1000\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n    weight_vals = np.random.random((n_elems,))\n    sparse_weights = sparse_tensor.SparseTensor(inp_indices, weight_vals,\n                                                [num_rows, 1])\n\n    np_out = np.bincount(inp_vals, minlength=size, weights=weight_vals)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(\n            sparse_inp, sparse_weights, axis=0)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_binary(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 10\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n\n    np_out = np.ones((size,))\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(sparse_inp, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_col_reduce_count(self, dtype):\n    num_rows = 128\n    num_cols = 27\n    size = 100\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate(\n            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],\n            axis=0), (num_rows, size))\n    # from_dense will filter out 0s.\n    inp = inp + 1\n    # from_dense will cause OOM in GPU.\n    with ops.device(\"/CPU:0\"):\n      inp_sparse = sparse_ops.from_dense(inp)\n      inp_sparse = sparse_tensor.SparseTensor(inp_sparse.indices,\n                                              inp_sparse.values - 1,\n                                              inp_sparse.dense_shape)\n    self.assertAllEqual(\n        np_out, self.evaluate(bincount_ops.bincount(arr=inp_sparse, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_col_reduce_binary(self, dtype):\n    num_rows = 128\n    num_cols = 27\n    size = 100\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate([\n            np.where(np.bincount(inp[j, :], minlength=size) > 0, 1, 0)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    # from_dense will filter out 0s.\n    inp = inp + 1\n    # from_dense will cause OOM in GPU.\n    with ops.device(\"/CPU:0\"):\n      inp_sparse = sparse_ops.from_dense(inp)\n      inp_sparse = sparse_tensor.SparseTensor(inp_sparse.indices,\n                                              inp_sparse.values - 1,\n                                              inp_sparse.dense_shape)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            bincount_ops.bincount(arr=inp_sparse, axis=-1, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n                                    dtype)\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 1, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 2, 1]]\n    # pyformat: enable\n    self.assertAllEqual(expected_output,\n                        self.evaluate(bincount_ops.bincount(arr=x, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_binary(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 1, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 1, 1]]\n    # pyformat: enable\n    self.assertAllEqual(\n        expected_output,\n        self.evaluate(\n            bincount_ops.bincount(arr=x, axis=-1, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_with_weights(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])\n    weights = ragged_factory_ops.constant([[], [], [.1, .2, .3], [],\n                                           [.2, .5, .6, .3]])\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [.2, .3, 0, .1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [.5, 0, 0, 0, .9, .2]]\n    # pyformat: enable\n    self.assertAllClose(\n        expected_output,\n        self.evaluate(bincount_ops.bincount(arr=x, weights=weights, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_np(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    num_cols = 27\n    size = 1000\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate(\n            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],\n            axis=0), (num_rows, size))\n    x = ragged_tensor.RaggedTensor.from_tensor(inp)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(arr=x, minlength=size, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_np_with_weights(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    num_cols = 27\n    size = 1000\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_weight = np.random.random((num_rows, num_cols))\n    np_out = np.reshape(\n        np.concatenate([\n            np.bincount(inp[j, :], weights=np_weight[j, :], minlength=size)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    x = ragged_tensor.RaggedTensor.from_tensor(inp)\n    weights = ragged_tensor.RaggedTensor.from_tensor(np_weight)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            bincount_ops.bincount(\n                arr=x, weights=weights, minlength=size, axis=-1)))\n\n\nclass TestSparseCountFailureModes(test.TestCase):\n\n  def test_dense_input_sparse_weights_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(ValueError, \"must be a tf.Tensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_dense_input_ragged_weights_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(ValueError, \"must be a tf.Tensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_dense_input_wrong_shape_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = np.array([[3, 2], [5, 4], [4, 3]])\n    # Note: Eager mode and graph mode throw different errors here. Graph mode\n    # will fail with a ValueError from the shape checking logic, while Eager\n    # will fail with an InvalidArgumentError from the kernel itself.\n    if context.executing_eagerly():\n      with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                  \"must have the same shape\"):\n        self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n    else:\n      with self.assertRaisesRegex(ValueError, \"both shapes must be equal\"):\n        self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_dense_weights_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    with self.assertRaisesRegex(ValueError, \"must be a SparseTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_ragged_weights_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(ValueError, \"must be a SparseTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_wrong_indices_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 1, 0, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same indices\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_too_many_indices_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 1, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesIncompatibleShapesError():\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_wrong_shape_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4], [0, 0, 0, 0]],\n                 dtype=np.int32))\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same dense shape\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_dense_weights_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    with self.assertRaisesRegex(ValueError, \"must be a RaggedTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_sparse_weights_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(ValueError, \"must be a RaggedTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_different_shape_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same row splits\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n\n@test_util.run_all_in_graph_and_eager_modes\n@test_util.disable_tfrt\nclass RawOpsTest(test.TestCase, parameterized.TestCase):\n\n  def testSparseCountSparseOutputBadIndicesShape(self):\n    indices = [[[0], [0]], [[0], [1]], [[1], [0]], [[1], [2]]]\n    values = [1, 1, 1, 10]\n    weights = [1, 2, 4, 6]\n    dense_shape = [2, 3]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Input indices must be a 2-dimensional tensor\"):\n      self.evaluate(\n          gen_count_ops.SparseCountSparseOutput(\n              indices=indices,\n              values=values,\n              dense_shape=dense_shape,\n              weights=weights,\n              binary_output=False))\n\n  def testSparseCountSparseOutputBadWeightsShape(self):\n    indices = [[0, 0], [0, 1], [1, 0], [1, 2]]\n    values = [1, 1, 1, 10]\n    weights = [1, 2, 4]\n    dense_shape = [2, 3]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Weights and values must have the same shape\"):\n      self.evaluate(\n          gen_count_ops.SparseCountSparseOutput(\n              indices=indices,\n              values=values,\n              dense_shape=dense_shape,\n              weights=weights,\n              binary_output=False))\n\n  def testSparseCountSparseOutputBadNumberOfValues(self):\n    indices = [[0, 0], [0, 1], [1, 0]]\n    values = [1, 1, 1, 10]\n    weights = [1, 2, 4, 6]\n    dense_shape = [2, 3]\n    with self.assertRaisesRegex(\n        errors.InvalidArgumentError,\n        \"Number of values must match first dimension of indices\"):\n      self.evaluate(\n          gen_count_ops.SparseCountSparseOutput(\n              indices=indices,\n              values=values,\n              dense_shape=dense_shape,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutput(self):\n    splits = [0, 4, 7]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    output_indices, output_values, output_shape = self.evaluate(\n        gen_count_ops.RaggedCountSparseOutput(\n            splits=splits, values=values, weights=weights, binary_output=False))\n    self.assertAllEqual([[0, 1], [0, 2], [1, 2], [1, 5], [1, 10]],\n                        output_indices)\n    self.assertAllEqual([7, 3, 5, 7, 6], output_values)\n    self.assertAllEqual([2, 11], output_shape)\n\n  def testRaggedCountSparseOutputBadWeightsShape(self):\n    splits = [0, 4, 7]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Weights and values must have the same shape\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutputEmptySplits(self):\n    splits = []\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    with self.assertRaisesRegex(\n        errors.InvalidArgumentError,\n        \"Must provide at least 2 elements for the splits argument\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutputBadSplitsStart(self):\n    splits = [1, 7]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Splits must start with 0\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutputBadSplitsEnd(self):\n    splits = [0, 5]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Splits must end with the number of values\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "fixing_code": ["/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/common_shape_fns.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/shape_inference.h\"\n\nnamespace tensorflow {\n\nusing shape_inference::InferenceContext;\nusing shape_inference::ShapeHandle;\n\nStatus DenseCountSparseOutputShapeFn(InferenceContext *c) {\n  auto values = c->input(0);\n  auto weights = c->input(1);\n  ShapeHandle output;\n  auto num_weights = c->NumElements(weights);\n  if (c->ValueKnown(num_weights) && c->Value(num_weights) == 0) {\n    output = values;\n  } else {\n    TF_RETURN_IF_ERROR(c->Merge(weights, values, &output));\n  }\n  auto rank = c->Rank(output);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  // out.indices\n  c->set_output(1, c->Vector(nvals));        // out.values\n  c->set_output(2, c->Vector(rank));         // out.dense_shape\n  return Status::OK();\n}\n\nStatus SparseCountSparseOutputShapeFn(InferenceContext *c) {\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n  auto rank = c->Dim(c->input(0), 1);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  // out.indices\n  c->set_output(1, c->Vector(nvals));        // out.values\n  c->set_output(2, c->Vector(rank));         // out.dense_shape\n  return Status::OK();\n}\n\nStatus RaggedCountSparseOutputShapeFn(InferenceContext *c) {\n  int32_t rank = c->Rank(c->input(1));\n  if (rank != c->kUnknownRank) {\n    ++rank;  // Add the ragged dimension\n  }\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  // out.indices\n  c->set_output(1, c->Vector(nvals));        // out.values\n  c->set_output(2, c->Vector(rank));         // out.dense_shape\n  return Status::OK();\n}\n\nREGISTER_OP(\"DenseCountSparseOutput\")\n    .Input(\"values: T\")\n    .Input(\"weights: output_type\")\n    .Attr(\"T: {int32, int64}\")\n    .Attr(\"minlength: int >= -1 = -1\")\n    .Attr(\"maxlength: int >= -1 = -1\")\n    .Attr(\"binary_output: bool\")\n    .Attr(\"output_type: {int32, int64, float, double}\")\n    .SetShapeFn(DenseCountSparseOutputShapeFn)\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: output_type\")\n    .Output(\"output_dense_shape: int64\");\n\nREGISTER_OP(\"SparseCountSparseOutput\")\n    .Input(\"indices: int64\")\n    .Input(\"values: T\")\n    .Input(\"dense_shape: int64\")\n    .Input(\"weights: output_type\")\n    .Attr(\"T: {int32, int64}\")\n    .Attr(\"minlength: int >= -1 = -1\")\n    .Attr(\"maxlength: int >= -1 = -1\")\n    .Attr(\"binary_output: bool\")\n    .Attr(\"output_type: {int32, int64, float, double}\")\n    .SetShapeFn(SparseCountSparseOutputShapeFn)\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: output_type\")\n    .Output(\"output_dense_shape: int64\");\n\nREGISTER_OP(\"RaggedCountSparseOutput\")\n    .Input(\"splits: int64\")\n    .Input(\"values: T\")\n    .Input(\"weights: output_type\")\n    .Attr(\"T: {int32, int64}\")\n    .Attr(\"minlength: int >= -1 = -1\")\n    .Attr(\"maxlength: int >= -1 = -1\")\n    .Attr(\"binary_output: bool\")\n    .Attr(\"output_type: {int32, int64, float, double}\")\n    .SetShapeFn(RaggedCountSparseOutputShapeFn)\n    .Output(\"output_indices: int64\")\n    .Output(\"output_values: output_type\")\n    .Output(\"output_dense_shape: int64\");\n\n}  // namespace tensorflow\n", "# Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# maxlengthations under the License.\n# ==============================================================================\n\"\"\"Tests for bincount ops.\"\"\"\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import bincount_ops\nfrom tensorflow.python.ops import gen_count_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.ops.ragged import ragged_factory_ops\nfrom tensorflow.python.ops.ragged import ragged_tensor\nfrom tensorflow.python.platform import test\n\n\nclass TestSparseCount(test.TestCase, parameterized.TestCase):\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\": \"_no_maxlength\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 6]\n      }, {\n          \"testcase_name\": \"_maxlength\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [1, 1, 1, 1, 2],\n          \"expected_shape\": [2, 7]\n      }, {\n          \"testcase_name\": \"_minlength\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 9]\n      }, {\n          \"testcase_name\": \"_minlength_larger_values\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 8]\n      }, {\n          \"testcase_name\": \"_no_maxlength_binary\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 6],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_maxlength_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 7],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_minlength_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 9],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_minlength_larger_values_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 8],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_no_maxlength_weights\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [2, 1, 0.5, 9, 3],\n          \"expected_shape\": [2, 6],\n          \"weights\": [[0.5, 1, 2], [3, 4, 5]]\n      }, {\n          \"testcase_name\": \"_maxlength_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [2, 1, 0.5, 3, 9],\n          \"expected_shape\": [2, 7],\n          \"weights\": [[0.5, 1, 2, 11], [7, 3, 4, 5]]\n      }, {\n          \"testcase_name\": \"_minlength_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],\n          \"expected_shape\": [2, 9],\n          \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]\n      }, {\n          \"testcase_name\": \"_minlength_larger_values_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],\n          \"expected_shape\": [2, 8],\n          \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]\n      }, {\n          \"testcase_name\": \"_1d\",\n          \"x\": np.array([3, 2, 1, 1], dtype=np.int32),\n          \"expected_indices\": [[1], [2], [3]],\n          \"expected_values\": [2, 1, 1],\n          \"expected_shape\": [4]\n      }, {\n          \"testcase_name\": \"_all_axes\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[1], [2], [3], [4], [5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\": None\n      })\n  def test_dense_input(self,\n                       x,\n                       expected_indices,\n                       expected_values,\n                       expected_shape,\n                       minlength=None,\n                       maxlength=None,\n                       binary_output=False,\n                       weights=None,\n                       axis=-1):\n    y = bincount_ops.sparse_bincount(\n        x,\n        weights=weights,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\":\n              \"_no_maxlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [3, 6],\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n      },\n      {\n          \"testcase_name\":\n              \"_no_maxlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1],\n          \"expected_shape\": [3, 6],\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_no_maxlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 7, 10],\n          \"expected_shape\": [3, 6],\n          \"weights\":\n              np.array([[6, 0, 2, 0], [0, 0, 0, 0], [10, 0, 3.5, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 7, 10],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [0, 0, 14, 0], [10, 0, 3.5, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 14, 6.5, 10],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 14, 6.5, 10],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),\n      },\n      {\n          \"testcase_name\": \"_1d\",\n          \"x\": np.array([3, 0, 1, 1], dtype=np.int32),\n          \"expected_indices\": [[1], [3]],\n          \"expected_values\": [2, 1],\n          \"expected_shape\": [4],\n      },\n      {\n          \"testcase_name\":\n              \"_all_axes\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[1], [3], [4], [5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\":\n              None,\n      },\n  )\n  def test_sparse_input(self,\n                        x,\n                        expected_indices,\n                        expected_values,\n                        expected_shape,\n                        maxlength=None,\n                        minlength=None,\n                        binary_output=False,\n                        weights=None,\n                        axis=-1):\n    x_sparse = sparse_ops.from_dense(x)\n    w_sparse = sparse_ops.from_dense(weights) if weights is not None else None\n    y = bincount_ops.sparse_bincount(\n        x_sparse,\n        weights=w_sparse,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\": \"_no_maxlength\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 6],\n      },\n      {\n          \"testcase_name\": \"_maxlength\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 7],\n      },\n      {\n          \"testcase_name\": \"_minlength\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 9],\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 8],\n      },\n      {\n          \"testcase_name\": \"_no_maxlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 6],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_maxlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 7],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_minlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 9],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"binary_output\": True,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 8],\n      },\n      {\n          \"testcase_name\": \"_no_maxlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],\n          \"expected_shape\": [5, 6],\n          \"weights\": [[], [], [6, 0.5, 2], [], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_maxlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],\n          \"expected_shape\": [5, 7],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_minlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],\n          \"expected_shape\": [5, 9],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],\n          \"expected_shape\": [5, 8],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_1d\",\n          \"x\": [3, 0, 1, 1],\n          \"expected_indices\": [[0], [1], [3]],\n          \"expected_values\": [1, 2, 1],\n          \"expected_shape\": [4],\n      },\n      {\n          \"testcase_name\": \"_all_axes\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[0], [1], [3], [4], [5]],\n          \"expected_values\": [2, 1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\": None,\n      },\n  )\n  def test_ragged_input(self,\n                        x,\n                        expected_indices,\n                        expected_values,\n                        expected_shape,\n                        maxlength=None,\n                        minlength=None,\n                        binary_output=False,\n                        weights=None,\n                        axis=-1):\n    x_ragged = ragged_factory_ops.constant(x)\n    w = ragged_factory_ops.constant(weights) if weights is not None else None\n    y = bincount_ops.sparse_bincount(\n        x_ragged,\n        weights=w,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n\nclass TestDenseBincount(test.TestCase, parameterized.TestCase):\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_count(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 1000\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n\n    np_out = np.bincount(inp_vals, minlength=size)\n    self.assertAllEqual(\n        np_out, self.evaluate(bincount_ops.bincount(sparse_inp, axis=0)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_count_with_weights(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 1000\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n    weight_vals = np.random.random((n_elems,))\n    sparse_weights = sparse_tensor.SparseTensor(inp_indices, weight_vals,\n                                                [num_rows, 1])\n\n    np_out = np.bincount(inp_vals, minlength=size, weights=weight_vals)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(\n            sparse_inp, sparse_weights, axis=0)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_binary(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 10\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n\n    np_out = np.ones((size,))\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(sparse_inp, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_col_reduce_count(self, dtype):\n    num_rows = 128\n    num_cols = 27\n    size = 100\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate(\n            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],\n            axis=0), (num_rows, size))\n    # from_dense will filter out 0s.\n    inp = inp + 1\n    # from_dense will cause OOM in GPU.\n    with ops.device(\"/CPU:0\"):\n      inp_sparse = sparse_ops.from_dense(inp)\n      inp_sparse = sparse_tensor.SparseTensor(inp_sparse.indices,\n                                              inp_sparse.values - 1,\n                                              inp_sparse.dense_shape)\n    self.assertAllEqual(\n        np_out, self.evaluate(bincount_ops.bincount(arr=inp_sparse, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_col_reduce_binary(self, dtype):\n    num_rows = 128\n    num_cols = 27\n    size = 100\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate([\n            np.where(np.bincount(inp[j, :], minlength=size) > 0, 1, 0)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    # from_dense will filter out 0s.\n    inp = inp + 1\n    # from_dense will cause OOM in GPU.\n    with ops.device(\"/CPU:0\"):\n      inp_sparse = sparse_ops.from_dense(inp)\n      inp_sparse = sparse_tensor.SparseTensor(inp_sparse.indices,\n                                              inp_sparse.values - 1,\n                                              inp_sparse.dense_shape)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            bincount_ops.bincount(arr=inp_sparse, axis=-1, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n                                    dtype)\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 1, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 2, 1]]\n    # pyformat: enable\n    self.assertAllEqual(expected_output,\n                        self.evaluate(bincount_ops.bincount(arr=x, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_binary(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 1, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 1, 1]]\n    # pyformat: enable\n    self.assertAllEqual(\n        expected_output,\n        self.evaluate(\n            bincount_ops.bincount(arr=x, axis=-1, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_with_weights(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])\n    weights = ragged_factory_ops.constant([[], [], [.1, .2, .3], [],\n                                           [.2, .5, .6, .3]])\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [.2, .3, 0, .1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [.5, 0, 0, 0, .9, .2]]\n    # pyformat: enable\n    self.assertAllClose(\n        expected_output,\n        self.evaluate(bincount_ops.bincount(arr=x, weights=weights, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_np(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    num_cols = 27\n    size = 1000\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate(\n            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],\n            axis=0), (num_rows, size))\n    x = ragged_tensor.RaggedTensor.from_tensor(inp)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(arr=x, minlength=size, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_np_with_weights(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    num_cols = 27\n    size = 1000\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_weight = np.random.random((num_rows, num_cols))\n    np_out = np.reshape(\n        np.concatenate([\n            np.bincount(inp[j, :], weights=np_weight[j, :], minlength=size)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    x = ragged_tensor.RaggedTensor.from_tensor(inp)\n    weights = ragged_tensor.RaggedTensor.from_tensor(np_weight)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            bincount_ops.bincount(\n                arr=x, weights=weights, minlength=size, axis=-1)))\n\n\nclass TestSparseCountFailureModes(test.TestCase):\n\n  def test_dense_input_sparse_weights_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(ValueError, \"must be a tf.Tensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_dense_input_ragged_weights_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(ValueError, \"must be a tf.Tensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_dense_input_wrong_shape_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = np.array([[3, 2], [5, 4], [4, 3]])\n    # Note: Eager mode and graph mode throw different errors here. Graph mode\n    # will fail with a ValueError from the shape checking logic, while Eager\n    # will fail with an InvalidArgumentError from the kernel itself.\n    if context.executing_eagerly():\n      with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                  \"must have the same shape\"):\n        self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n    else:\n      with self.assertRaisesRegex(ValueError, \"both shapes must be equal\"):\n        self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_dense_weights_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    with self.assertRaisesRegex(ValueError, \"must be a SparseTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_ragged_weights_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(ValueError, \"must be a SparseTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_wrong_indices_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 1, 0, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same indices\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_too_many_indices_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 1, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesIncompatibleShapesError():\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_wrong_shape_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4], [0, 0, 0, 0]],\n                 dtype=np.int32))\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same dense shape\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_dense_weights_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    with self.assertRaisesRegex(ValueError, \"must be a RaggedTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_sparse_weights_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(ValueError, \"must be a RaggedTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_different_shape_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same row splits\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n\nclass RawOpsHeapOobTest(test.TestCase, parameterized.TestCase):\n\n  @test_util.run_v1_only(\"Test security error\")\n  def testSparseCountSparseOutputBadIndicesShapeTooSmall(self):\n    indices = [1]\n    values = [[1]]\n    weights = []\n    dense_shape = [10]\n    with self.assertRaisesRegex(ValueError,\n                                \"Shape must be rank 2 but is rank 1 for\"):\n      self.evaluate(\n          gen_count_ops.SparseCountSparseOutput(\n              indices=indices,\n              values=values,\n              dense_shape=dense_shape,\n              weights=weights,\n              binary_output=True))\n\n\n@test_util.run_all_in_graph_and_eager_modes\n@test_util.disable_tfrt\nclass RawOpsTest(test.TestCase, parameterized.TestCase):\n\n  def testSparseCountSparseOutputBadIndicesShape(self):\n    indices = [[[0], [0]], [[0], [1]], [[1], [0]], [[1], [2]]]\n    values = [1, 1, 1, 10]\n    weights = [1, 2, 4, 6]\n    dense_shape = [2, 3]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Input indices must be a 2-dimensional tensor\"):\n      self.evaluate(\n          gen_count_ops.SparseCountSparseOutput(\n              indices=indices,\n              values=values,\n              dense_shape=dense_shape,\n              weights=weights,\n              binary_output=False))\n\n  def testSparseCountSparseOutputBadWeightsShape(self):\n    indices = [[0, 0], [0, 1], [1, 0], [1, 2]]\n    values = [1, 1, 1, 10]\n    weights = [1, 2, 4]\n    dense_shape = [2, 3]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Weights and values must have the same shape\"):\n      self.evaluate(\n          gen_count_ops.SparseCountSparseOutput(\n              indices=indices,\n              values=values,\n              dense_shape=dense_shape,\n              weights=weights,\n              binary_output=False))\n\n  def testSparseCountSparseOutputBadNumberOfValues(self):\n    indices = [[0, 0], [0, 1], [1, 0]]\n    values = [1, 1, 1, 10]\n    weights = [1, 2, 4, 6]\n    dense_shape = [2, 3]\n    with self.assertRaisesRegex(\n        errors.InvalidArgumentError,\n        \"Number of values must match first dimension of indices\"):\n      self.evaluate(\n          gen_count_ops.SparseCountSparseOutput(\n              indices=indices,\n              values=values,\n              dense_shape=dense_shape,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutput(self):\n    splits = [0, 4, 7]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    output_indices, output_values, output_shape = self.evaluate(\n        gen_count_ops.RaggedCountSparseOutput(\n            splits=splits, values=values, weights=weights, binary_output=False))\n    self.assertAllEqual([[0, 1], [0, 2], [1, 2], [1, 5], [1, 10]],\n                        output_indices)\n    self.assertAllEqual([7, 3, 5, 7, 6], output_values)\n    self.assertAllEqual([2, 11], output_shape)\n\n  def testRaggedCountSparseOutputBadWeightsShape(self):\n    splits = [0, 4, 7]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Weights and values must have the same shape\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutputEmptySplits(self):\n    splits = []\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    with self.assertRaisesRegex(\n        errors.InvalidArgumentError,\n        \"Must provide at least 2 elements for the splits argument\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutputBadSplitsStart(self):\n    splits = [1, 7]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Splits must start with 0\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutputBadSplitsEnd(self):\n    splits = [0, 5]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Splits must end with the number of values\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "filenames": ["tensorflow/core/ops/count_ops.cc", "tensorflow/python/ops/bincount_ops_test.py"], "buggy_code_start_loc": [43, 833], "buggy_code_end_loc": [43, 833], "fixing_code_start_loc": [44, 834], "fixing_code_end_loc": [46, 853], "type": "CWE-125", "message": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for `SparseCountSparseOutput` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-41210", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-05T20:15:08.160", "lastModified": "2021-11-09T15:58:59.070", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for `SparseCountSparseOutput` can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. En las versiones afectadas, las funciones de inferencia de forma para \"SparseCountSparseOutput\" pueden desencadenar una lectura fuera de l\u00edmites de la matriz asignada a la pila. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.7.0. Tambi\u00e9n ser\u00e1 incluida este commit en TensorFlow versi\u00f3n 2.6.1, TensorFlow versi\u00f3n 2.5.2, y TensorFlow versi\u00f3n 2.4.4, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.4", "matchCriteriaId": "455FB550-4C9C-4BD6-9F76-A627B62AB332"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.5.0", "versionEndExcluding": "2.5.2", "matchCriteriaId": "035CDF63-1548-4FB4-B8A9-B8D328FAF910"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "651EA851-E660-4E53-9F3E-B6B69D91326B"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/701cfaca222a82afbeeb17496bd718baa65a67d2", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-m342-ff57-4jcc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/701cfaca222a82afbeeb17496bd718baa65a67d2"}}