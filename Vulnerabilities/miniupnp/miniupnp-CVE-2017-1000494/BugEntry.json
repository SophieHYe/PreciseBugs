{"buggy_code": ["/* $Id: upnpreplyparse.c,v 1.19 2015/07/15 10:29:11 nanard Exp $ */\n/* MiniUPnP project\n * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n * (c) 2006-2015 Thomas Bernard\n * This software is subject to the conditions detailed\n * in the LICENCE file provided within the distribution */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"upnpreplyparse.h\"\n#include \"minixml.h\"\n\nstatic void\nNameValueParserStartElt(void * d, const char * name, int l)\n{\n\tstruct NameValueParserData * data = (struct NameValueParserData *)d;\n\tdata->topelt = 1;\n    if(l>63)\n        l = 63;\n    memcpy(data->curelt, name, l);\n    data->curelt[l] = '\\0';\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n}\n\nstatic void\nNameValueParserEndElt(void * d, const char * name, int l)\n{\n    struct NameValueParserData * data = (struct NameValueParserData *)d;\n    struct NameValue * nv;\n\t(void)name;\n\t(void)l;\n\tif(!data->topelt)\n\t\treturn;\n\tif(strcmp(data->curelt, \"NewPortListing\") != 0)\n\t{\n\t\tint l;\n\t\t/* standard case. Limited to n chars strings */\n\t\tl = data->cdatalen;\n\t    nv = malloc(sizeof(struct NameValue));\n\t\tif(nv == NULL)\n\t\t{\n\t\t\t/* malloc error */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: error allocating memory\",\n\t\t\t        \"NameValueParserEndElt\");\n#endif /* DEBUG */\n\t\t\treturn;\n\t\t}\n\t    if(l>=(int)sizeof(nv->value))\n\t        l = sizeof(nv->value) - 1;\n\t    strncpy(nv->name, data->curelt, 64);\n\t\tnv->name[63] = '\\0';\n\t\tif(data->cdata != NULL)\n\t\t{\n\t\t\tmemcpy(nv->value, data->cdata, l);\n\t\t\tnv->value[l] = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnv->value[0] = '\\0';\n\t\t}\n\t\tnv->l_next = data->l_head;\t/* insert in list */\n\t\tdata->l_head = nv;\n\t}\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n\tdata->topelt = 0;\n}\n\nstatic void\nNameValueParserGetData(void * d, const char * datas, int l)\n{\n    struct NameValueParserData * data = (struct NameValueParserData *)d;\n\tif(strcmp(data->curelt, \"NewPortListing\") == 0)\n\t{\n\t\t/* specific case for NewPortListing which is a XML Document */\n\t\tdata->portListing = malloc(l + 1);\n\t\tif(!data->portListing)\n\t\t{\n\t\t\t/* malloc error */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: error allocating memory\",\n\t\t\t        \"NameValueParserGetData\");\n#endif /* DEBUG */\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(data->portListing, datas, l);\n\t\tdata->portListing[l] = '\\0';\n\t\tdata->portListingLength = l;\n\t}\n\telse\n\t{\n\t\t/* standard case. */\n\t\tdata->cdata = datas;\n\t\tdata->cdatalen = l;\n\t}\n}\n\nvoid\nParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}\n\nvoid\nClearNameValueList(struct NameValueParserData * pdata)\n{\n    struct NameValue * nv;\n\tif(pdata->portListing)\n\t{\n\t\tfree(pdata->portListing);\n\t\tpdata->portListing = NULL;\n\t\tpdata->portListingLength = 0;\n\t}\n    while((nv = pdata->l_head) != NULL)\n    {\n\t\tpdata->l_head = nv->l_next;\n        free(nv);\n    }\n}\n\nchar *\nGetValueFromNameValueList(struct NameValueParserData * pdata,\n                          const char * Name)\n{\n    struct NameValue * nv;\n    char * p = NULL;\n    for(nv = pdata->l_head;\n        (nv != NULL) && (p == NULL);\n        nv = nv->l_next)\n    {\n        if(strcmp(nv->name, Name) == 0)\n            p = nv->value;\n    }\n    return p;\n}\n\n#if 0\n/* useless now that minixml ignores namespaces by itself */\nchar *\nGetValueFromNameValueListIgnoreNS(struct NameValueParserData * pdata,\n                                  const char * Name)\n{\n\tstruct NameValue * nv;\n\tchar * p = NULL;\n\tchar * pname;\n\tfor(nv = pdata->head.lh_first;\n\t    (nv != NULL) && (p == NULL);\n\t\tnv = nv->entries.le_next)\n\t{\n\t\tpname = strrchr(nv->name, ':');\n\t\tif(pname)\n\t\t\tpname++;\n\t\telse\n\t\t\tpname = nv->name;\n\t\tif(strcmp(pname, Name)==0)\n\t\t\tp = nv->value;\n\t}\n\treturn p;\n}\n#endif\n\n/* debug all-in-one function\n * do parsing then display to stdout */\n#ifdef DEBUG\nvoid\nDisplayNameValueList(char * buffer, int bufsize)\n{\n    struct NameValueParserData pdata;\n    struct NameValue * nv;\n    ParseNameValue(buffer, bufsize, &pdata);\n    for(nv = pdata.l_head;\n        nv != NULL;\n        nv = nv->l_next)\n    {\n        printf(\"%s = %s\\n\", nv->name, nv->value);\n    }\n    ClearNameValueList(&pdata);\n}\n#endif /* DEBUG */\n\n", "/* $Id: upnpreplyparse.c,v 1.19 2015/07/15 10:29:11 nanard Exp $ */\n/* MiniUPnP project\n * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n * (c) 2006-2015 Thomas Bernard\n * This software is subject to the conditions detailed\n * in the LICENCE file provided within the distribution */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"upnpreplyparse.h\"\n#include \"minixml.h\"\n\nstatic void\nNameValueParserStartElt(void * d, const char * name, int l)\n{\n\tstruct NameValueParserData * data = (struct NameValueParserData *)d;\n\tdata->topelt = 1;\n    if(l>63)\n        l = 63;\n    memcpy(data->curelt, name, l);\n    data->curelt[l] = '\\0';\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n}\n\nstatic void\nNameValueParserEndElt(void * d, const char * name, int l)\n{\n    struct NameValueParserData * data = (struct NameValueParserData *)d;\n    struct NameValue * nv;\n\t(void)name;\n\t(void)l;\n\tif(!data->topelt)\n\t\treturn;\n\tif(strcmp(data->curelt, \"NewPortListing\") != 0)\n\t{\n\t\tint l;\n\t\t/* standard case. Limited to n chars strings */\n\t\tl = data->cdatalen;\n\t    nv = malloc(sizeof(struct NameValue));\n\t\tif(nv == NULL)\n\t\t{\n\t\t\t/* malloc error */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: error allocating memory\",\n\t\t\t        \"NameValueParserEndElt\");\n#endif /* DEBUG */\n\t\t\treturn;\n\t\t}\n\t    if(l>=(int)sizeof(nv->value))\n\t        l = sizeof(nv->value) - 1;\n\t    strncpy(nv->name, data->curelt, 64);\n\t\tnv->name[63] = '\\0';\n\t\tif(data->cdata != NULL)\n\t\t{\n\t\t\tmemcpy(nv->value, data->cdata, l);\n\t\t\tnv->value[l] = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnv->value[0] = '\\0';\n\t\t}\n\t\tnv->l_next = data->l_head;\t/* insert in list */\n\t\tdata->l_head = nv;\n\t}\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n\tdata->topelt = 0;\n}\n\nstatic void\nNameValueParserGetData(void * d, const char * datas, int l)\n{\n    struct NameValueParserData * data = (struct NameValueParserData *)d;\n\tif(strcmp(data->curelt, \"NewPortListing\") == 0)\n\t{\n\t\t/* specific case for NewPortListing which is a XML Document */\n\t\tdata->portListing = malloc(l + 1);\n\t\tif(!data->portListing)\n\t\t{\n\t\t\t/* malloc error */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: error allocating memory\",\n\t\t\t        \"NameValueParserGetData\");\n#endif /* DEBUG */\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(data->portListing, datas, l);\n\t\tdata->portListing[l] = '\\0';\n\t\tdata->portListingLength = l;\n\t}\n\telse\n\t{\n\t\t/* standard case. */\n\t\tdata->cdata = datas;\n\t\tdata->cdatalen = l;\n\t}\n}\n\nvoid\nParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}\n\nvoid\nClearNameValueList(struct NameValueParserData * pdata)\n{\n    struct NameValue * nv;\n\tif(pdata->portListing)\n\t{\n\t\tfree(pdata->portListing);\n\t\tpdata->portListing = NULL;\n\t\tpdata->portListingLength = 0;\n\t}\n    while((nv = pdata->l_head) != NULL)\n    {\n\t\tpdata->l_head = nv->l_next;\n        free(nv);\n    }\n}\n\nchar *\nGetValueFromNameValueList(struct NameValueParserData * pdata,\n                          const char * Name)\n{\n    struct NameValue * nv;\n    char * p = NULL;\n    for(nv = pdata->l_head;\n        (nv != NULL) && (p == NULL);\n        nv = nv->l_next)\n    {\n        if(strcmp(nv->name, Name) == 0)\n            p = nv->value;\n    }\n    return p;\n}\n\n#if 0\n/* useless now that minixml ignores namespaces by itself */\nchar *\nGetValueFromNameValueListIgnoreNS(struct NameValueParserData * pdata,\n                                  const char * Name)\n{\n\tstruct NameValue * nv;\n\tchar * p = NULL;\n\tchar * pname;\n\tfor(nv = pdata->head.lh_first;\n\t    (nv != NULL) && (p == NULL);\n\t\tnv = nv->entries.le_next)\n\t{\n\t\tpname = strrchr(nv->name, ':');\n\t\tif(pname)\n\t\t\tpname++;\n\t\telse\n\t\t\tpname = nv->name;\n\t\tif(strcmp(pname, Name)==0)\n\t\t\tp = nv->value;\n\t}\n\treturn p;\n}\n#endif\n\n/* debug all-in-one function\n * do parsing then display to stdout */\n#ifdef DEBUG\nvoid\nDisplayNameValueList(char * buffer, int bufsize)\n{\n    struct NameValueParserData pdata;\n    struct NameValue * nv;\n    ParseNameValue(buffer, bufsize, &pdata);\n    for(nv = pdata.l_head;\n        nv != NULL;\n        nv = nv->l_next)\n    {\n        printf(\"%s = %s\\n\", nv->name, nv->value);\n    }\n    ClearNameValueList(&pdata);\n}\n#endif /* DEBUG */\n\n"], "fixing_code": ["/* $Id: upnpreplyparse.c,v 1.19 2015/07/15 10:29:11 nanard Exp $ */\n/* vim: tabstop=4 shiftwidth=4 noexpandtab\n * MiniUPnP project\n * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n * (c) 2006-2017 Thomas Bernard\n * This software is subject to the conditions detailed\n * in the LICENCE file provided within the distribution */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"upnpreplyparse.h\"\n#include \"minixml.h\"\n\nstatic void\nNameValueParserStartElt(void * d, const char * name, int l)\n{\n\tstruct NameValueParserData * data = (struct NameValueParserData *)d;\n\tdata->topelt = 1;\n    if(l>63)\n        l = 63;\n    memcpy(data->curelt, name, l);\n    data->curelt[l] = '\\0';\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n}\n\nstatic void\nNameValueParserEndElt(void * d, const char * name, int l)\n{\n    struct NameValueParserData * data = (struct NameValueParserData *)d;\n    struct NameValue * nv;\n\t(void)name;\n\t(void)l;\n\tif(!data->topelt)\n\t\treturn;\n\tif(strcmp(data->curelt, \"NewPortListing\") != 0)\n\t{\n\t\tint l;\n\t\t/* standard case. Limited to n chars strings */\n\t\tl = data->cdatalen;\n\t    nv = malloc(sizeof(struct NameValue));\n\t\tif(nv == NULL)\n\t\t{\n\t\t\t/* malloc error */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: error allocating memory\",\n\t\t\t        \"NameValueParserEndElt\");\n#endif /* DEBUG */\n\t\t\treturn;\n\t\t}\n\t    if(l>=(int)sizeof(nv->value))\n\t        l = sizeof(nv->value) - 1;\n\t    strncpy(nv->name, data->curelt, 64);\n\t\tnv->name[63] = '\\0';\n\t\tif(data->cdata != NULL)\n\t\t{\n\t\t\tmemcpy(nv->value, data->cdata, l);\n\t\t\tnv->value[l] = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnv->value[0] = '\\0';\n\t\t}\n\t\tnv->l_next = data->l_head;\t/* insert in list */\n\t\tdata->l_head = nv;\n\t}\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n\tdata->topelt = 0;\n}\n\nstatic void\nNameValueParserGetData(void * d, const char * datas, int l)\n{\n    struct NameValueParserData * data = (struct NameValueParserData *)d;\n\tif(strcmp(data->curelt, \"NewPortListing\") == 0)\n\t{\n\t\t/* specific case for NewPortListing which is a XML Document */\n\t\tdata->portListing = malloc(l + 1);\n\t\tif(!data->portListing)\n\t\t{\n\t\t\t/* malloc error */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: error allocating memory\",\n\t\t\t        \"NameValueParserGetData\");\n#endif /* DEBUG */\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(data->portListing, datas, l);\n\t\tdata->portListing[l] = '\\0';\n\t\tdata->portListingLength = l;\n\t}\n\telse\n\t{\n\t\t/* standard case. */\n\t\tdata->cdata = datas;\n\t\tdata->cdatalen = l;\n\t}\n}\n\nvoid\nParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tmemset(data, 0, sizeof(struct NameValueParserData));\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}\n\nvoid\nClearNameValueList(struct NameValueParserData * pdata)\n{\n    struct NameValue * nv;\n\tif(pdata->portListing)\n\t{\n\t\tfree(pdata->portListing);\n\t\tpdata->portListing = NULL;\n\t\tpdata->portListingLength = 0;\n\t}\n    while((nv = pdata->l_head) != NULL)\n    {\n\t\tpdata->l_head = nv->l_next;\n        free(nv);\n    }\n}\n\nchar *\nGetValueFromNameValueList(struct NameValueParserData * pdata,\n                          const char * Name)\n{\n    struct NameValue * nv;\n    char * p = NULL;\n    for(nv = pdata->l_head;\n        (nv != NULL) && (p == NULL);\n        nv = nv->l_next)\n    {\n        if(strcmp(nv->name, Name) == 0)\n            p = nv->value;\n    }\n    return p;\n}\n\n#if 0\n/* useless now that minixml ignores namespaces by itself */\nchar *\nGetValueFromNameValueListIgnoreNS(struct NameValueParserData * pdata,\n                                  const char * Name)\n{\n\tstruct NameValue * nv;\n\tchar * p = NULL;\n\tchar * pname;\n\tfor(nv = pdata->head.lh_first;\n\t    (nv != NULL) && (p == NULL);\n\t\tnv = nv->entries.le_next)\n\t{\n\t\tpname = strrchr(nv->name, ':');\n\t\tif(pname)\n\t\t\tpname++;\n\t\telse\n\t\t\tpname = nv->name;\n\t\tif(strcmp(pname, Name)==0)\n\t\t\tp = nv->value;\n\t}\n\treturn p;\n}\n#endif\n\n/* debug all-in-one function\n * do parsing then display to stdout */\n#ifdef DEBUG\nvoid\nDisplayNameValueList(char * buffer, int bufsize)\n{\n    struct NameValueParserData pdata;\n    struct NameValue * nv;\n    ParseNameValue(buffer, bufsize, &pdata);\n    for(nv = pdata.l_head;\n        nv != NULL;\n        nv = nv->l_next)\n    {\n        printf(\"%s = %s\\n\", nv->name, nv->value);\n    }\n    ClearNameValueList(&pdata);\n}\n#endif /* DEBUG */\n\n", "/* $Id: upnpreplyparse.c,v 1.19 2015/07/15 10:29:11 nanard Exp $ */\n/* vim: tabstop=4 shiftwidth=4 noexpandtab\n * MiniUPnP project\n * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n * (c) 2006-2017 Thomas Bernard\n * This software is subject to the conditions detailed\n * in the LICENCE file provided within the distribution */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"upnpreplyparse.h\"\n#include \"minixml.h\"\n\nstatic void\nNameValueParserStartElt(void * d, const char * name, int l)\n{\n\tstruct NameValueParserData * data = (struct NameValueParserData *)d;\n\tdata->topelt = 1;\n    if(l>63)\n        l = 63;\n    memcpy(data->curelt, name, l);\n    data->curelt[l] = '\\0';\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n}\n\nstatic void\nNameValueParserEndElt(void * d, const char * name, int l)\n{\n    struct NameValueParserData * data = (struct NameValueParserData *)d;\n    struct NameValue * nv;\n\t(void)name;\n\t(void)l;\n\tif(!data->topelt)\n\t\treturn;\n\tif(strcmp(data->curelt, \"NewPortListing\") != 0)\n\t{\n\t\tint l;\n\t\t/* standard case. Limited to n chars strings */\n\t\tl = data->cdatalen;\n\t    nv = malloc(sizeof(struct NameValue));\n\t\tif(nv == NULL)\n\t\t{\n\t\t\t/* malloc error */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: error allocating memory\",\n\t\t\t        \"NameValueParserEndElt\");\n#endif /* DEBUG */\n\t\t\treturn;\n\t\t}\n\t    if(l>=(int)sizeof(nv->value))\n\t        l = sizeof(nv->value) - 1;\n\t    strncpy(nv->name, data->curelt, 64);\n\t\tnv->name[63] = '\\0';\n\t\tif(data->cdata != NULL)\n\t\t{\n\t\t\tmemcpy(nv->value, data->cdata, l);\n\t\t\tnv->value[l] = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnv->value[0] = '\\0';\n\t\t}\n\t\tnv->l_next = data->l_head;\t/* insert in list */\n\t\tdata->l_head = nv;\n\t}\n\tdata->cdata = NULL;\n\tdata->cdatalen = 0;\n\tdata->topelt = 0;\n}\n\nstatic void\nNameValueParserGetData(void * d, const char * datas, int l)\n{\n    struct NameValueParserData * data = (struct NameValueParserData *)d;\n\tif(strcmp(data->curelt, \"NewPortListing\") == 0)\n\t{\n\t\t/* specific case for NewPortListing which is a XML Document */\n\t\tdata->portListing = malloc(l + 1);\n\t\tif(!data->portListing)\n\t\t{\n\t\t\t/* malloc error */\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: error allocating memory\",\n\t\t\t        \"NameValueParserGetData\");\n#endif /* DEBUG */\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(data->portListing, datas, l);\n\t\tdata->portListing[l] = '\\0';\n\t\tdata->portListingLength = l;\n\t}\n\telse\n\t{\n\t\t/* standard case. */\n\t\tdata->cdata = datas;\n\t\tdata->cdatalen = l;\n\t}\n}\n\nvoid\nParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tmemset(data, 0, sizeof(struct NameValueParserData));\n\t/* init xmlparser object */\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}\n\nvoid\nClearNameValueList(struct NameValueParserData * pdata)\n{\n    struct NameValue * nv;\n\tif(pdata->portListing)\n\t{\n\t\tfree(pdata->portListing);\n\t\tpdata->portListing = NULL;\n\t\tpdata->portListingLength = 0;\n\t}\n    while((nv = pdata->l_head) != NULL)\n    {\n\t\tpdata->l_head = nv->l_next;\n        free(nv);\n    }\n}\n\nchar *\nGetValueFromNameValueList(struct NameValueParserData * pdata,\n                          const char * Name)\n{\n    struct NameValue * nv;\n    char * p = NULL;\n    for(nv = pdata->l_head;\n        (nv != NULL) && (p == NULL);\n        nv = nv->l_next)\n    {\n        if(strcmp(nv->name, Name) == 0)\n            p = nv->value;\n    }\n    return p;\n}\n\n#if 0\n/* useless now that minixml ignores namespaces by itself */\nchar *\nGetValueFromNameValueListIgnoreNS(struct NameValueParserData * pdata,\n                                  const char * Name)\n{\n\tstruct NameValue * nv;\n\tchar * p = NULL;\n\tchar * pname;\n\tfor(nv = pdata->head.lh_first;\n\t    (nv != NULL) && (p == NULL);\n\t\tnv = nv->entries.le_next)\n\t{\n\t\tpname = strrchr(nv->name, ':');\n\t\tif(pname)\n\t\t\tpname++;\n\t\telse\n\t\t\tpname = nv->name;\n\t\tif(strcmp(pname, Name)==0)\n\t\t\tp = nv->value;\n\t}\n\treturn p;\n}\n#endif\n\n/* debug all-in-one function\n * do parsing then display to stdout */\n#ifdef DEBUG\nvoid\nDisplayNameValueList(char * buffer, int bufsize)\n{\n    struct NameValueParserData pdata;\n    struct NameValue * nv;\n    ParseNameValue(buffer, bufsize, &pdata);\n    for(nv = pdata.l_head;\n        nv != NULL;\n        nv = nv->l_next)\n    {\n        printf(\"%s = %s\\n\", nv->name, nv->value);\n    }\n    ClearNameValueList(&pdata);\n}\n#endif /* DEBUG */\n\n"], "buggy_code_start_loc": [2, 2], "buggy_code_end_loc": [110, 110], "fixing_code_start_loc": [2, 2], "fixing_code_end_loc": [109, 109], "type": "CWE-119", "message": "Uninitialized stack variable vulnerability in NameValueParserEndElt (upnpreplyparse.c) in miniupnpd < 2.0 allows an attacker to cause Denial of Service (Segmentation fault and Memory Corruption) or possibly have unspecified other impact", "other": {"cve": {"id": "CVE-2017-1000494", "sourceIdentifier": "cve@mitre.org", "published": "2018-01-03T14:29:00.207", "lastModified": "2019-05-30T20:29:00.553", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Uninitialized stack variable vulnerability in NameValueParserEndElt (upnpreplyparse.c) in miniupnpd < 2.0 allows an attacker to cause Denial of Service (Segmentation fault and Memory Corruption) or possibly have unspecified other impact"}, {"lang": "es", "value": "Vulnerabilidad de variable de pila no inicializada en NameValueParserEndElt (upnpreplyparse.c) en miniupnpd en versiones posteriores a la 2.0 permite que un atacante provoque una denegaci\u00f3n de servicio (fallo de segmentaci\u00f3n y corrupci\u00f3n de memoria) o que, posiblemente, cause otro tipo de impacto sin especificar."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:miniupnp_project:miniupnpd:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0", "matchCriteriaId": "AA580243-5EA5-4BC3-AAF8-75A6E941801E"}]}]}], "references": [{"url": "https://github.com/miniupnp/miniupnp/commit/7aeb624b44f86d335841242ff427433190e7168a", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/miniupnp/miniupnp/issues/268", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/05/msg00045.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3562-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/miniupnp/miniupnp/commit/7aeb624b44f86d335841242ff427433190e7168a"}}