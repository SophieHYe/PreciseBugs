{"buggy_code": ["// Copyright 2016 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage db\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\tgouuid \"github.com/satori/go.uuid\"\n\t\"github.com/unknwon/com\"\n\n\t\"github.com/gogs/git-module\"\n\n\t\"gogs.io/gogs/internal/conf\"\n\t\"gogs.io/gogs/internal/cryptoutil\"\n\t\"gogs.io/gogs/internal/db/errors\"\n\t\"gogs.io/gogs/internal/gitutil\"\n\t\"gogs.io/gogs/internal/osutil\"\n\t\"gogs.io/gogs/internal/process\"\n\t\"gogs.io/gogs/internal/tool\"\n)\n\nconst (\n\tENV_AUTH_USER_ID           = \"GOGS_AUTH_USER_ID\"\n\tENV_AUTH_USER_NAME         = \"GOGS_AUTH_USER_NAME\"\n\tENV_AUTH_USER_EMAIL        = \"GOGS_AUTH_USER_EMAIL\"\n\tENV_REPO_OWNER_NAME        = \"GOGS_REPO_OWNER_NAME\"\n\tENV_REPO_OWNER_SALT_MD5    = \"GOGS_REPO_OWNER_SALT_MD5\"\n\tENV_REPO_ID                = \"GOGS_REPO_ID\"\n\tENV_REPO_NAME              = \"GOGS_REPO_NAME\"\n\tENV_REPO_CUSTOM_HOOKS_PATH = \"GOGS_REPO_CUSTOM_HOOKS_PATH\"\n)\n\ntype ComposeHookEnvsOptions struct {\n\tAuthUser  *User\n\tOwnerName string\n\tOwnerSalt string\n\tRepoID    int64\n\tRepoName  string\n\tRepoPath  string\n}\n\nfunc ComposeHookEnvs(opts ComposeHookEnvsOptions) []string {\n\tenvs := []string{\n\t\t\"SSH_ORIGINAL_COMMAND=1\",\n\t\tENV_AUTH_USER_ID + \"=\" + com.ToStr(opts.AuthUser.ID),\n\t\tENV_AUTH_USER_NAME + \"=\" + opts.AuthUser.Name,\n\t\tENV_AUTH_USER_EMAIL + \"=\" + opts.AuthUser.Email,\n\t\tENV_REPO_OWNER_NAME + \"=\" + opts.OwnerName,\n\t\tENV_REPO_OWNER_SALT_MD5 + \"=\" + cryptoutil.MD5(opts.OwnerSalt),\n\t\tENV_REPO_ID + \"=\" + com.ToStr(opts.RepoID),\n\t\tENV_REPO_NAME + \"=\" + opts.RepoName,\n\t\tENV_REPO_CUSTOM_HOOKS_PATH + \"=\" + filepath.Join(opts.RepoPath, \"custom_hooks\"),\n\t}\n\treturn envs\n}\n\n// ___________    .___.__  __    ___________.__.__\n// \\_   _____/  __| _/|__|/  |_  \\_   _____/|__|  |   ____\n//  |    __)_  / __ | |  \\   __\\  |    __)  |  |  | _/ __ \\\n//  |        \\/ /_/ | |  ||  |    |     \\   |  |  |_\\  ___/\n// /_______  /\\____ | |__||__|    \\___  /   |__|____/\\___  >\n//         \\/      \\/                 \\/                 \\/\n\n// discardLocalRepoBranchChanges discards local commits/changes of\n// given branch to make sure it is even to remote branch.\nfunc discardLocalRepoBranchChanges(localPath, branch string) error {\n\tif !com.IsExist(localPath) {\n\t\treturn nil\n\t}\n\n\t// No need to check if nothing in the repository.\n\tif !git.RepoHasBranch(localPath, branch) {\n\t\treturn nil\n\t}\n\n\trev := \"origin/\" + branch\n\tif err := git.RepoReset(localPath, rev, git.ResetOptions{Hard: true}); err != nil {\n\t\treturn fmt.Errorf(\"reset [revision: %s]: %v\", rev, err)\n\t}\n\treturn nil\n}\n\nfunc (repo *Repository) DiscardLocalRepoBranchChanges(branch string) error {\n\treturn discardLocalRepoBranchChanges(repo.LocalCopyPath(), branch)\n}\n\n// CheckoutNewBranch checks out to a new branch from the a branch name.\nfunc (repo *Repository) CheckoutNewBranch(oldBranch, newBranch string) error {\n\tif err := git.RepoCheckout(repo.LocalCopyPath(), newBranch, git.CheckoutOptions{\n\t\tBaseBranch: oldBranch,\n\t\tTimeout:    time.Duration(conf.Git.Timeout.Pull) * time.Second,\n\t}); err != nil {\n\t\treturn fmt.Errorf(\"checkout [base: %s, new: %s]: %v\", oldBranch, newBranch, err)\n\t}\n\treturn nil\n}\n\ntype UpdateRepoFileOptions struct {\n\tLastCommitID string\n\tOldBranch    string\n\tNewBranch    string\n\tOldTreeName  string\n\tNewTreeName  string\n\tMessage      string\n\tContent      string\n\tIsNewFile    bool\n}\n\n// UpdateRepoFile adds or updates a file in repository.\nfunc (repo *Repository) UpdateRepoFile(doer *User, opts UpdateRepoFileOptions) (err error) {\n\trepoWorkingPool.CheckIn(com.ToStr(repo.ID))\n\tdefer repoWorkingPool.CheckOut(com.ToStr(repo.ID))\n\n\tif err = repo.DiscardLocalRepoBranchChanges(opts.OldBranch); err != nil {\n\t\treturn fmt.Errorf(\"discard local repo branch[%s] changes: %v\", opts.OldBranch, err)\n\t} else if err = repo.UpdateLocalCopyBranch(opts.OldBranch); err != nil {\n\t\treturn fmt.Errorf(\"update local copy branch[%s]: %v\", opts.OldBranch, err)\n\t}\n\n\trepoPath := repo.RepoPath()\n\tlocalPath := repo.LocalCopyPath()\n\n\tif opts.OldBranch != opts.NewBranch {\n\t\t// Directly return error if new branch already exists in the server\n\t\tif git.RepoHasBranch(repoPath, opts.NewBranch) {\n\t\t\treturn errors.BranchAlreadyExists{Name: opts.NewBranch}\n\t\t}\n\n\t\t// Otherwise, delete branch from local copy in case out of sync\n\t\tif git.RepoHasBranch(localPath, opts.NewBranch) {\n\t\t\tif err = git.RepoDeleteBranch(localPath, opts.NewBranch, git.DeleteBranchOptions{\n\t\t\t\tForce: true,\n\t\t\t}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"delete branch %q: %v\", opts.NewBranch, err)\n\t\t\t}\n\t\t}\n\n\t\tif err := repo.CheckoutNewBranch(opts.OldBranch, opts.NewBranch); err != nil {\n\t\t\treturn fmt.Errorf(\"checkout new branch[%s] from old branch[%s]: %v\", opts.NewBranch, opts.OldBranch, err)\n\t\t}\n\t}\n\n\toldFilePath := path.Join(localPath, opts.OldTreeName)\n\tfilePath := path.Join(localPath, opts.NewTreeName)\n\tif err = os.MkdirAll(path.Dir(filePath), os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\n\t// If it's meant to be a new file, make sure it doesn't exist.\n\tif opts.IsNewFile {\n\t\tif com.IsExist(filePath) {\n\t\t\treturn ErrRepoFileAlreadyExist{filePath}\n\t\t}\n\t}\n\n\t// Ignore move step if it's a new file under a directory.\n\t// Otherwise, move the file when name changed.\n\tif osutil.IsFile(oldFilePath) && opts.OldTreeName != opts.NewTreeName {\n\t\tif err = git.RepoMove(localPath, opts.OldTreeName, opts.NewTreeName); err != nil {\n\t\t\treturn fmt.Errorf(\"git mv %q %q: %v\", opts.OldTreeName, opts.NewTreeName, err)\n\t\t}\n\t}\n\n\tif err = ioutil.WriteFile(filePath, []byte(opts.Content), 0666); err != nil {\n\t\treturn fmt.Errorf(\"write file: %v\", err)\n\t}\n\n\tif err = git.RepoAdd(localPath, git.AddOptions{All: true}); err != nil {\n\t\treturn fmt.Errorf(\"git add --all: %v\", err)\n\t} else if err = git.RepoCommit(localPath, doer.NewGitSig(), opts.Message); err != nil {\n\t\treturn fmt.Errorf(\"commit changes on %q: %v\", localPath, err)\n\t}\n\n\tenvs := ComposeHookEnvs(ComposeHookEnvsOptions{\n\t\tAuthUser:  doer,\n\t\tOwnerName: repo.MustOwner().Name,\n\t\tOwnerSalt: repo.MustOwner().Salt,\n\t\tRepoID:    repo.ID,\n\t\tRepoName:  repo.Name,\n\t\tRepoPath:  repo.RepoPath(),\n\t})\n\tif err = git.RepoPush(localPath, \"origin\", opts.NewBranch, git.PushOptions{Envs: envs}); err != nil {\n\t\treturn fmt.Errorf(\"git push origin %s: %v\", opts.NewBranch, err)\n\t}\n\treturn nil\n}\n\n// GetDiffPreview produces and returns diff result of a file which is not yet committed.\nfunc (repo *Repository) GetDiffPreview(branch, treePath, content string) (diff *gitutil.Diff, err error) {\n\trepoWorkingPool.CheckIn(com.ToStr(repo.ID))\n\tdefer repoWorkingPool.CheckOut(com.ToStr(repo.ID))\n\n\tif err = repo.DiscardLocalRepoBranchChanges(branch); err != nil {\n\t\treturn nil, fmt.Errorf(\"discard local repo branch[%s] changes: %v\", branch, err)\n\t} else if err = repo.UpdateLocalCopyBranch(branch); err != nil {\n\t\treturn nil, fmt.Errorf(\"update local copy branch[%s]: %v\", branch, err)\n\t}\n\n\tlocalPath := repo.LocalCopyPath()\n\tfilePath := path.Join(localPath, treePath)\n\tif err = os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {\n\t\treturn nil, err\n\t}\n\tif err = ioutil.WriteFile(filePath, []byte(content), 0666); err != nil {\n\t\treturn nil, fmt.Errorf(\"write file: %v\", err)\n\t}\n\n\tcmd := exec.Command(\"git\", \"diff\", treePath)\n\tcmd.Dir = localPath\n\tcmd.Stderr = os.Stderr\n\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"get stdout pipe: %v\", err)\n\t}\n\n\tif err = cmd.Start(); err != nil {\n\t\treturn nil, fmt.Errorf(\"start: %v\", err)\n\t}\n\n\tpid := process.Add(fmt.Sprintf(\"GetDiffPreview [repo_path: %s]\", repo.RepoPath()), cmd)\n\tdefer process.Remove(pid)\n\n\tdiff, err = gitutil.ParseDiff(stdout, conf.Git.MaxDiffFiles, conf.Git.MaxDiffLines, conf.Git.MaxDiffLineChars)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"parse diff: %v\", err)\n\t}\n\n\tif err = cmd.Wait(); err != nil {\n\t\treturn nil, fmt.Errorf(\"wait: %v\", err)\n\t}\n\n\treturn diff, nil\n}\n\n// ________         .__          __           ___________.__.__\n// \\______ \\   ____ |  |   _____/  |_  ____   \\_   _____/|__|  |   ____\n//  |    |  \\_/ __ \\|  | _/ __ \\   __\\/ __ \\   |    __)  |  |  | _/ __ \\\n//  |    `   \\  ___/|  |_\\  ___/|  | \\  ___/   |     \\   |  |  |_\\  ___/\n// /_______  /\\___  >____/\\___  >__|  \\___  >  \\___  /   |__|____/\\___  >\n//         \\/     \\/          \\/          \\/       \\/                 \\/\n//\n\ntype DeleteRepoFileOptions struct {\n\tLastCommitID string\n\tOldBranch    string\n\tNewBranch    string\n\tTreePath     string\n\tMessage      string\n}\n\nfunc (repo *Repository) DeleteRepoFile(doer *User, opts DeleteRepoFileOptions) (err error) {\n\trepoWorkingPool.CheckIn(com.ToStr(repo.ID))\n\tdefer repoWorkingPool.CheckOut(com.ToStr(repo.ID))\n\n\tif err = repo.DiscardLocalRepoBranchChanges(opts.OldBranch); err != nil {\n\t\treturn fmt.Errorf(\"discard local repo branch[%s] changes: %v\", opts.OldBranch, err)\n\t} else if err = repo.UpdateLocalCopyBranch(opts.OldBranch); err != nil {\n\t\treturn fmt.Errorf(\"update local copy branch[%s]: %v\", opts.OldBranch, err)\n\t}\n\n\tif opts.OldBranch != opts.NewBranch {\n\t\tif err := repo.CheckoutNewBranch(opts.OldBranch, opts.NewBranch); err != nil {\n\t\t\treturn fmt.Errorf(\"checkout new branch[%s] from old branch[%s]: %v\", opts.NewBranch, opts.OldBranch, err)\n\t\t}\n\t}\n\n\tlocalPath := repo.LocalCopyPath()\n\tif err = os.Remove(path.Join(localPath, opts.TreePath)); err != nil {\n\t\treturn fmt.Errorf(\"remove file %q: %v\", opts.TreePath, err)\n\t}\n\n\tif err = git.RepoAdd(localPath, git.AddOptions{All: true}); err != nil {\n\t\treturn fmt.Errorf(\"git add --all: %v\", err)\n\t} else if err = git.RepoCommit(localPath, doer.NewGitSig(), opts.Message); err != nil {\n\t\treturn fmt.Errorf(\"commit changes to %q: %v\", localPath, err)\n\t}\n\n\tenvs := ComposeHookEnvs(ComposeHookEnvsOptions{\n\t\tAuthUser:  doer,\n\t\tOwnerName: repo.MustOwner().Name,\n\t\tOwnerSalt: repo.MustOwner().Salt,\n\t\tRepoID:    repo.ID,\n\t\tRepoName:  repo.Name,\n\t\tRepoPath:  repo.RepoPath(),\n\t})\n\tif err = git.RepoPush(localPath, \"origin\", opts.NewBranch, git.PushOptions{Envs: envs}); err != nil {\n\t\treturn fmt.Errorf(\"git push origin %s: %v\", opts.NewBranch, err)\n\t}\n\treturn nil\n}\n\n//  ____ ___        .__                    .___ ___________.___.__\n// |    |   \\______ |  |   _________     __| _/ \\_   _____/|   |  |   ____   ______\n// |    |   /\\____ \\|  |  /  _ \\__  \\   / __ |   |    __)  |   |  | _/ __ \\ /  ___/\n// |    |  / |  |_> >  |_(  <_> ) __ \\_/ /_/ |   |     \\   |   |  |_\\  ___/ \\___ \\\n// |______/  |   __/|____/\\____(____  /\\____ |   \\___  /   |___|____/\\___  >____  >\n//           |__|                   \\/      \\/       \\/                  \\/     \\/\n//\n\n// Upload represent a uploaded file to a repo to be deleted when moved\ntype Upload struct {\n\tID   int64\n\tUUID string `xorm:\"uuid UNIQUE\"`\n\tName string\n}\n\n// UploadLocalPath returns where uploads is stored in local file system based on given UUID.\nfunc UploadLocalPath(uuid string) string {\n\treturn path.Join(conf.Repository.Upload.TempPath, uuid[0:1], uuid[1:2], uuid)\n}\n\n// LocalPath returns where uploads are temporarily stored in local file system.\nfunc (upload *Upload) LocalPath() string {\n\treturn UploadLocalPath(upload.UUID)\n}\n\n// NewUpload creates a new upload object.\nfunc NewUpload(name string, buf []byte, file multipart.File) (_ *Upload, err error) {\n\tif tool.IsMaliciousPath(name) {\n\t\treturn nil, fmt.Errorf(\"malicious path detected: %s\", name)\n\t}\n\n\tupload := &Upload{\n\t\tUUID: gouuid.NewV4().String(),\n\t\tName: name,\n\t}\n\n\tlocalPath := upload.LocalPath()\n\tif err = os.MkdirAll(path.Dir(localPath), os.ModePerm); err != nil {\n\t\treturn nil, fmt.Errorf(\"mkdir all: %v\", err)\n\t}\n\n\tfw, err := os.Create(localPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create: %v\", err)\n\t}\n\tdefer fw.Close()\n\n\tif _, err = fw.Write(buf); err != nil {\n\t\treturn nil, fmt.Errorf(\"write: %v\", err)\n\t} else if _, err = io.Copy(fw, file); err != nil {\n\t\treturn nil, fmt.Errorf(\"copy: %v\", err)\n\t}\n\n\tif _, err := x.Insert(upload); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn upload, nil\n}\n\nfunc GetUploadByUUID(uuid string) (*Upload, error) {\n\tupload := &Upload{UUID: uuid}\n\thas, err := x.Get(upload)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if !has {\n\t\treturn nil, ErrUploadNotExist{0, uuid}\n\t}\n\treturn upload, nil\n}\n\nfunc GetUploadsByUUIDs(uuids []string) ([]*Upload, error) {\n\tif len(uuids) == 0 {\n\t\treturn []*Upload{}, nil\n\t}\n\n\t// Silently drop invalid uuids.\n\tuploads := make([]*Upload, 0, len(uuids))\n\treturn uploads, x.In(\"uuid\", uuids).Find(&uploads)\n}\n\nfunc DeleteUploads(uploads ...*Upload) (err error) {\n\tif len(uploads) == 0 {\n\t\treturn nil\n\t}\n\n\tsess := x.NewSession()\n\tdefer sess.Close()\n\tif err = sess.Begin(); err != nil {\n\t\treturn err\n\t}\n\n\tids := make([]int64, len(uploads))\n\tfor i := 0; i < len(uploads); i++ {\n\t\tids[i] = uploads[i].ID\n\t}\n\tif _, err = sess.In(\"id\", ids).Delete(new(Upload)); err != nil {\n\t\treturn fmt.Errorf(\"delete uploads: %v\", err)\n\t}\n\n\tfor _, upload := range uploads {\n\t\tlocalPath := upload.LocalPath()\n\t\tif !osutil.IsFile(localPath) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := os.Remove(localPath); err != nil {\n\t\t\treturn fmt.Errorf(\"remove upload: %v\", err)\n\t\t}\n\t}\n\n\treturn sess.Commit()\n}\n\nfunc DeleteUpload(u *Upload) error {\n\treturn DeleteUploads(u)\n}\n\nfunc DeleteUploadByUUID(uuid string) error {\n\tupload, err := GetUploadByUUID(uuid)\n\tif err != nil {\n\t\tif IsErrUploadNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"get upload by UUID[%s]: %v\", uuid, err)\n\t}\n\n\tif err := DeleteUpload(upload); err != nil {\n\t\treturn fmt.Errorf(\"delete upload: %v\", err)\n\t}\n\n\treturn nil\n}\n\ntype UploadRepoFileOptions struct {\n\tLastCommitID string\n\tOldBranch    string\n\tNewBranch    string\n\tTreePath     string\n\tMessage      string\n\tFiles        []string // In UUID format\n}\n\n// isRepositoryGitPath returns true if given path is or resides inside \".git\" path of the repository.\nfunc isRepositoryGitPath(path string) bool {\n\treturn strings.HasSuffix(path, \".git\") || strings.Contains(path, \".git\"+string(os.PathSeparator))\n}\n\nfunc (repo *Repository) UploadRepoFiles(doer *User, opts UploadRepoFileOptions) (err error) {\n\tif len(opts.Files) == 0 {\n\t\treturn nil\n\t}\n\n\tuploads, err := GetUploadsByUUIDs(opts.Files)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"get uploads by UUIDs[%v]: %v\", opts.Files, err)\n\t}\n\n\trepoWorkingPool.CheckIn(com.ToStr(repo.ID))\n\tdefer repoWorkingPool.CheckOut(com.ToStr(repo.ID))\n\n\tif err = repo.DiscardLocalRepoBranchChanges(opts.OldBranch); err != nil {\n\t\treturn fmt.Errorf(\"discard local repo branch[%s] changes: %v\", opts.OldBranch, err)\n\t} else if err = repo.UpdateLocalCopyBranch(opts.OldBranch); err != nil {\n\t\treturn fmt.Errorf(\"update local copy branch[%s]: %v\", opts.OldBranch, err)\n\t}\n\n\tif opts.OldBranch != opts.NewBranch {\n\t\tif err = repo.CheckoutNewBranch(opts.OldBranch, opts.NewBranch); err != nil {\n\t\t\treturn fmt.Errorf(\"checkout new branch[%s] from old branch[%s]: %v\", opts.NewBranch, opts.OldBranch, err)\n\t\t}\n\t}\n\n\tlocalPath := repo.LocalCopyPath()\n\tdirPath := path.Join(localPath, opts.TreePath)\n\tif err = os.MkdirAll(dirPath, os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\n\t// Copy uploaded files into repository\n\tfor _, upload := range uploads {\n\t\ttmpPath := upload.LocalPath()\n\t\tif !osutil.IsFile(tmpPath) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Prevent copying files into .git directory, see https://gogs.io/gogs/issues/5558.\n\t\tif isRepositoryGitPath(upload.Name) {\n\t\t\tcontinue\n\t\t}\n\n\t\ttargetPath := path.Join(dirPath, upload.Name)\n\t\tif err = com.Copy(tmpPath, targetPath); err != nil {\n\t\t\treturn fmt.Errorf(\"copy: %v\", err)\n\t\t}\n\t}\n\n\tif err = git.RepoAdd(localPath, git.AddOptions{All: true}); err != nil {\n\t\treturn fmt.Errorf(\"git add --all: %v\", err)\n\t} else if err = git.RepoCommit(localPath, doer.NewGitSig(), opts.Message); err != nil {\n\t\treturn fmt.Errorf(\"commit changes on %q: %v\", localPath, err)\n\t}\n\n\tenvs := ComposeHookEnvs(ComposeHookEnvsOptions{\n\t\tAuthUser:  doer,\n\t\tOwnerName: repo.MustOwner().Name,\n\t\tOwnerSalt: repo.MustOwner().Salt,\n\t\tRepoID:    repo.ID,\n\t\tRepoName:  repo.Name,\n\t\tRepoPath:  repo.RepoPath(),\n\t})\n\tif err = git.RepoPush(localPath, \"origin\", opts.NewBranch, git.PushOptions{Envs: envs}); err != nil {\n\t\treturn fmt.Errorf(\"git push origin %s: %v\", opts.NewBranch, err)\n\t}\n\n\treturn DeleteUploads(uploads...)\n}\n"], "fixing_code": ["// Copyright 2016 The Gogs Authors. All rights reserved.\n// Use of this source code is governed by a MIT-style\n// license that can be found in the LICENSE file.\n\npackage db\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\tgouuid \"github.com/satori/go.uuid\"\n\t\"github.com/unknwon/com\"\n\n\t\"github.com/gogs/git-module\"\n\n\t\"gogs.io/gogs/internal/conf\"\n\t\"gogs.io/gogs/internal/cryptoutil\"\n\tdberrors \"gogs.io/gogs/internal/db/errors\"\n\t\"gogs.io/gogs/internal/gitutil\"\n\t\"gogs.io/gogs/internal/osutil\"\n\t\"gogs.io/gogs/internal/pathutil\"\n\t\"gogs.io/gogs/internal/process\"\n\t\"gogs.io/gogs/internal/tool\"\n)\n\nconst (\n\tENV_AUTH_USER_ID           = \"GOGS_AUTH_USER_ID\"\n\tENV_AUTH_USER_NAME         = \"GOGS_AUTH_USER_NAME\"\n\tENV_AUTH_USER_EMAIL        = \"GOGS_AUTH_USER_EMAIL\"\n\tENV_REPO_OWNER_NAME        = \"GOGS_REPO_OWNER_NAME\"\n\tENV_REPO_OWNER_SALT_MD5    = \"GOGS_REPO_OWNER_SALT_MD5\"\n\tENV_REPO_ID                = \"GOGS_REPO_ID\"\n\tENV_REPO_NAME              = \"GOGS_REPO_NAME\"\n\tENV_REPO_CUSTOM_HOOKS_PATH = \"GOGS_REPO_CUSTOM_HOOKS_PATH\"\n)\n\ntype ComposeHookEnvsOptions struct {\n\tAuthUser  *User\n\tOwnerName string\n\tOwnerSalt string\n\tRepoID    int64\n\tRepoName  string\n\tRepoPath  string\n}\n\nfunc ComposeHookEnvs(opts ComposeHookEnvsOptions) []string {\n\tenvs := []string{\n\t\t\"SSH_ORIGINAL_COMMAND=1\",\n\t\tENV_AUTH_USER_ID + \"=\" + com.ToStr(opts.AuthUser.ID),\n\t\tENV_AUTH_USER_NAME + \"=\" + opts.AuthUser.Name,\n\t\tENV_AUTH_USER_EMAIL + \"=\" + opts.AuthUser.Email,\n\t\tENV_REPO_OWNER_NAME + \"=\" + opts.OwnerName,\n\t\tENV_REPO_OWNER_SALT_MD5 + \"=\" + cryptoutil.MD5(opts.OwnerSalt),\n\t\tENV_REPO_ID + \"=\" + com.ToStr(opts.RepoID),\n\t\tENV_REPO_NAME + \"=\" + opts.RepoName,\n\t\tENV_REPO_CUSTOM_HOOKS_PATH + \"=\" + filepath.Join(opts.RepoPath, \"custom_hooks\"),\n\t}\n\treturn envs\n}\n\n// ___________    .___.__  __    ___________.__.__\n// \\_   _____/  __| _/|__|/  |_  \\_   _____/|__|  |   ____\n//  |    __)_  / __ | |  \\   __\\  |    __)  |  |  | _/ __ \\\n//  |        \\/ /_/ | |  ||  |    |     \\   |  |  |_\\  ___/\n// /_______  /\\____ | |__||__|    \\___  /   |__|____/\\___  >\n//         \\/      \\/                 \\/                 \\/\n\n// discardLocalRepoBranchChanges discards local commits/changes of\n// given branch to make sure it is even to remote branch.\nfunc discardLocalRepoBranchChanges(localPath, branch string) error {\n\tif !com.IsExist(localPath) {\n\t\treturn nil\n\t}\n\n\t// No need to check if nothing in the repository.\n\tif !git.RepoHasBranch(localPath, branch) {\n\t\treturn nil\n\t}\n\n\trev := \"origin/\" + branch\n\tif err := git.RepoReset(localPath, rev, git.ResetOptions{Hard: true}); err != nil {\n\t\treturn fmt.Errorf(\"reset [revision: %s]: %v\", rev, err)\n\t}\n\treturn nil\n}\n\nfunc (repo *Repository) DiscardLocalRepoBranchChanges(branch string) error {\n\treturn discardLocalRepoBranchChanges(repo.LocalCopyPath(), branch)\n}\n\n// CheckoutNewBranch checks out to a new branch from the a branch name.\nfunc (repo *Repository) CheckoutNewBranch(oldBranch, newBranch string) error {\n\tif err := git.RepoCheckout(repo.LocalCopyPath(), newBranch, git.CheckoutOptions{\n\t\tBaseBranch: oldBranch,\n\t\tTimeout:    time.Duration(conf.Git.Timeout.Pull) * time.Second,\n\t}); err != nil {\n\t\treturn fmt.Errorf(\"checkout [base: %s, new: %s]: %v\", oldBranch, newBranch, err)\n\t}\n\treturn nil\n}\n\ntype UpdateRepoFileOptions struct {\n\tLastCommitID string\n\tOldBranch    string\n\tNewBranch    string\n\tOldTreeName  string\n\tNewTreeName  string\n\tMessage      string\n\tContent      string\n\tIsNewFile    bool\n}\n\n// UpdateRepoFile adds or updates a file in repository.\nfunc (repo *Repository) UpdateRepoFile(doer *User, opts UpdateRepoFileOptions) (err error) {\n\trepoWorkingPool.CheckIn(com.ToStr(repo.ID))\n\tdefer repoWorkingPool.CheckOut(com.ToStr(repo.ID))\n\n\tif err = repo.DiscardLocalRepoBranchChanges(opts.OldBranch); err != nil {\n\t\treturn fmt.Errorf(\"discard local repo branch[%s] changes: %v\", opts.OldBranch, err)\n\t} else if err = repo.UpdateLocalCopyBranch(opts.OldBranch); err != nil {\n\t\treturn fmt.Errorf(\"update local copy branch[%s]: %v\", opts.OldBranch, err)\n\t}\n\n\trepoPath := repo.RepoPath()\n\tlocalPath := repo.LocalCopyPath()\n\n\tif opts.OldBranch != opts.NewBranch {\n\t\t// Directly return error if new branch already exists in the server\n\t\tif git.RepoHasBranch(repoPath, opts.NewBranch) {\n\t\t\treturn dberrors.BranchAlreadyExists{Name: opts.NewBranch}\n\t\t}\n\n\t\t// Otherwise, delete branch from local copy in case out of sync\n\t\tif git.RepoHasBranch(localPath, opts.NewBranch) {\n\t\t\tif err = git.RepoDeleteBranch(localPath, opts.NewBranch, git.DeleteBranchOptions{\n\t\t\t\tForce: true,\n\t\t\t}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"delete branch %q: %v\", opts.NewBranch, err)\n\t\t\t}\n\t\t}\n\n\t\tif err := repo.CheckoutNewBranch(opts.OldBranch, opts.NewBranch); err != nil {\n\t\t\treturn fmt.Errorf(\"checkout new branch[%s] from old branch[%s]: %v\", opts.NewBranch, opts.OldBranch, err)\n\t\t}\n\t}\n\n\toldFilePath := path.Join(localPath, opts.OldTreeName)\n\tfilePath := path.Join(localPath, opts.NewTreeName)\n\tif err = os.MkdirAll(path.Dir(filePath), os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\n\t// If it's meant to be a new file, make sure it doesn't exist.\n\tif opts.IsNewFile {\n\t\tif com.IsExist(filePath) {\n\t\t\treturn ErrRepoFileAlreadyExist{filePath}\n\t\t}\n\t}\n\n\t// Ignore move step if it's a new file under a directory.\n\t// Otherwise, move the file when name changed.\n\tif osutil.IsFile(oldFilePath) && opts.OldTreeName != opts.NewTreeName {\n\t\tif err = git.RepoMove(localPath, opts.OldTreeName, opts.NewTreeName); err != nil {\n\t\t\treturn fmt.Errorf(\"git mv %q %q: %v\", opts.OldTreeName, opts.NewTreeName, err)\n\t\t}\n\t}\n\n\tif err = ioutil.WriteFile(filePath, []byte(opts.Content), 0666); err != nil {\n\t\treturn fmt.Errorf(\"write file: %v\", err)\n\t}\n\n\tif err = git.RepoAdd(localPath, git.AddOptions{All: true}); err != nil {\n\t\treturn fmt.Errorf(\"git add --all: %v\", err)\n\t} else if err = git.RepoCommit(localPath, doer.NewGitSig(), opts.Message); err != nil {\n\t\treturn fmt.Errorf(\"commit changes on %q: %v\", localPath, err)\n\t}\n\n\tenvs := ComposeHookEnvs(ComposeHookEnvsOptions{\n\t\tAuthUser:  doer,\n\t\tOwnerName: repo.MustOwner().Name,\n\t\tOwnerSalt: repo.MustOwner().Salt,\n\t\tRepoID:    repo.ID,\n\t\tRepoName:  repo.Name,\n\t\tRepoPath:  repo.RepoPath(),\n\t})\n\tif err = git.RepoPush(localPath, \"origin\", opts.NewBranch, git.PushOptions{Envs: envs}); err != nil {\n\t\treturn fmt.Errorf(\"git push origin %s: %v\", opts.NewBranch, err)\n\t}\n\treturn nil\n}\n\n// GetDiffPreview produces and returns diff result of a file which is not yet committed.\nfunc (repo *Repository) GetDiffPreview(branch, treePath, content string) (diff *gitutil.Diff, err error) {\n\trepoWorkingPool.CheckIn(com.ToStr(repo.ID))\n\tdefer repoWorkingPool.CheckOut(com.ToStr(repo.ID))\n\n\tif err = repo.DiscardLocalRepoBranchChanges(branch); err != nil {\n\t\treturn nil, fmt.Errorf(\"discard local repo branch[%s] changes: %v\", branch, err)\n\t} else if err = repo.UpdateLocalCopyBranch(branch); err != nil {\n\t\treturn nil, fmt.Errorf(\"update local copy branch[%s]: %v\", branch, err)\n\t}\n\n\tlocalPath := repo.LocalCopyPath()\n\tfilePath := path.Join(localPath, treePath)\n\tif err = os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {\n\t\treturn nil, err\n\t}\n\tif err = ioutil.WriteFile(filePath, []byte(content), 0666); err != nil {\n\t\treturn nil, fmt.Errorf(\"write file: %v\", err)\n\t}\n\n\tcmd := exec.Command(\"git\", \"diff\", treePath)\n\tcmd.Dir = localPath\n\tcmd.Stderr = os.Stderr\n\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"get stdout pipe: %v\", err)\n\t}\n\n\tif err = cmd.Start(); err != nil {\n\t\treturn nil, fmt.Errorf(\"start: %v\", err)\n\t}\n\n\tpid := process.Add(fmt.Sprintf(\"GetDiffPreview [repo_path: %s]\", repo.RepoPath()), cmd)\n\tdefer process.Remove(pid)\n\n\tdiff, err = gitutil.ParseDiff(stdout, conf.Git.MaxDiffFiles, conf.Git.MaxDiffLines, conf.Git.MaxDiffLineChars)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"parse diff: %v\", err)\n\t}\n\n\tif err = cmd.Wait(); err != nil {\n\t\treturn nil, fmt.Errorf(\"wait: %v\", err)\n\t}\n\n\treturn diff, nil\n}\n\n// ________         .__          __           ___________.__.__\n// \\______ \\   ____ |  |   _____/  |_  ____   \\_   _____/|__|  |   ____\n//  |    |  \\_/ __ \\|  | _/ __ \\   __\\/ __ \\   |    __)  |  |  | _/ __ \\\n//  |    `   \\  ___/|  |_\\  ___/|  | \\  ___/   |     \\   |  |  |_\\  ___/\n// /_______  /\\___  >____/\\___  >__|  \\___  >  \\___  /   |__|____/\\___  >\n//         \\/     \\/          \\/          \\/       \\/                 \\/\n//\n\ntype DeleteRepoFileOptions struct {\n\tLastCommitID string\n\tOldBranch    string\n\tNewBranch    string\n\tTreePath     string\n\tMessage      string\n}\n\nfunc (repo *Repository) DeleteRepoFile(doer *User, opts DeleteRepoFileOptions) (err error) {\n\trepoWorkingPool.CheckIn(com.ToStr(repo.ID))\n\tdefer repoWorkingPool.CheckOut(com.ToStr(repo.ID))\n\n\tif err = repo.DiscardLocalRepoBranchChanges(opts.OldBranch); err != nil {\n\t\treturn fmt.Errorf(\"discard local repo branch[%s] changes: %v\", opts.OldBranch, err)\n\t} else if err = repo.UpdateLocalCopyBranch(opts.OldBranch); err != nil {\n\t\treturn fmt.Errorf(\"update local copy branch[%s]: %v\", opts.OldBranch, err)\n\t}\n\n\tif opts.OldBranch != opts.NewBranch {\n\t\tif err := repo.CheckoutNewBranch(opts.OldBranch, opts.NewBranch); err != nil {\n\t\t\treturn fmt.Errorf(\"checkout new branch[%s] from old branch[%s]: %v\", opts.NewBranch, opts.OldBranch, err)\n\t\t}\n\t}\n\n\tlocalPath := repo.LocalCopyPath()\n\tif err = os.Remove(path.Join(localPath, opts.TreePath)); err != nil {\n\t\treturn fmt.Errorf(\"remove file %q: %v\", opts.TreePath, err)\n\t}\n\n\tif err = git.RepoAdd(localPath, git.AddOptions{All: true}); err != nil {\n\t\treturn fmt.Errorf(\"git add --all: %v\", err)\n\t} else if err = git.RepoCommit(localPath, doer.NewGitSig(), opts.Message); err != nil {\n\t\treturn fmt.Errorf(\"commit changes to %q: %v\", localPath, err)\n\t}\n\n\tenvs := ComposeHookEnvs(ComposeHookEnvsOptions{\n\t\tAuthUser:  doer,\n\t\tOwnerName: repo.MustOwner().Name,\n\t\tOwnerSalt: repo.MustOwner().Salt,\n\t\tRepoID:    repo.ID,\n\t\tRepoName:  repo.Name,\n\t\tRepoPath:  repo.RepoPath(),\n\t})\n\tif err = git.RepoPush(localPath, \"origin\", opts.NewBranch, git.PushOptions{Envs: envs}); err != nil {\n\t\treturn fmt.Errorf(\"git push origin %s: %v\", opts.NewBranch, err)\n\t}\n\treturn nil\n}\n\n//  ____ ___        .__                    .___ ___________.___.__\n// |    |   \\______ |  |   _________     __| _/ \\_   _____/|   |  |   ____   ______\n// |    |   /\\____ \\|  |  /  _ \\__  \\   / __ |   |    __)  |   |  | _/ __ \\ /  ___/\n// |    |  / |  |_> >  |_(  <_> ) __ \\_/ /_/ |   |     \\   |   |  |_\\  ___/ \\___ \\\n// |______/  |   __/|____/\\____(____  /\\____ |   \\___  /   |___|____/\\___  >____  >\n//           |__|                   \\/      \\/       \\/                  \\/     \\/\n//\n\n// Upload represent a uploaded file to a repo to be deleted when moved\ntype Upload struct {\n\tID   int64\n\tUUID string `xorm:\"uuid UNIQUE\"`\n\tName string\n}\n\n// UploadLocalPath returns where uploads is stored in local file system based on given UUID.\nfunc UploadLocalPath(uuid string) string {\n\treturn path.Join(conf.Repository.Upload.TempPath, uuid[0:1], uuid[1:2], uuid)\n}\n\n// LocalPath returns where uploads are temporarily stored in local file system.\nfunc (upload *Upload) LocalPath() string {\n\treturn UploadLocalPath(upload.UUID)\n}\n\n// NewUpload creates a new upload object.\nfunc NewUpload(name string, buf []byte, file multipart.File) (_ *Upload, err error) {\n\tif tool.IsMaliciousPath(name) {\n\t\treturn nil, fmt.Errorf(\"malicious path detected: %s\", name)\n\t}\n\n\tupload := &Upload{\n\t\tUUID: gouuid.NewV4().String(),\n\t\tName: name,\n\t}\n\n\tlocalPath := upload.LocalPath()\n\tif err = os.MkdirAll(path.Dir(localPath), os.ModePerm); err != nil {\n\t\treturn nil, fmt.Errorf(\"mkdir all: %v\", err)\n\t}\n\n\tfw, err := os.Create(localPath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"create: %v\", err)\n\t}\n\tdefer fw.Close()\n\n\tif _, err = fw.Write(buf); err != nil {\n\t\treturn nil, fmt.Errorf(\"write: %v\", err)\n\t} else if _, err = io.Copy(fw, file); err != nil {\n\t\treturn nil, fmt.Errorf(\"copy: %v\", err)\n\t}\n\n\tif _, err := x.Insert(upload); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn upload, nil\n}\n\nfunc GetUploadByUUID(uuid string) (*Upload, error) {\n\tupload := &Upload{UUID: uuid}\n\thas, err := x.Get(upload)\n\tif err != nil {\n\t\treturn nil, err\n\t} else if !has {\n\t\treturn nil, ErrUploadNotExist{0, uuid}\n\t}\n\treturn upload, nil\n}\n\nfunc GetUploadsByUUIDs(uuids []string) ([]*Upload, error) {\n\tif len(uuids) == 0 {\n\t\treturn []*Upload{}, nil\n\t}\n\n\t// Silently drop invalid uuids.\n\tuploads := make([]*Upload, 0, len(uuids))\n\treturn uploads, x.In(\"uuid\", uuids).Find(&uploads)\n}\n\nfunc DeleteUploads(uploads ...*Upload) (err error) {\n\tif len(uploads) == 0 {\n\t\treturn nil\n\t}\n\n\tsess := x.NewSession()\n\tdefer sess.Close()\n\tif err = sess.Begin(); err != nil {\n\t\treturn err\n\t}\n\n\tids := make([]int64, len(uploads))\n\tfor i := 0; i < len(uploads); i++ {\n\t\tids[i] = uploads[i].ID\n\t}\n\tif _, err = sess.In(\"id\", ids).Delete(new(Upload)); err != nil {\n\t\treturn fmt.Errorf(\"delete uploads: %v\", err)\n\t}\n\n\tfor _, upload := range uploads {\n\t\tlocalPath := upload.LocalPath()\n\t\tif !osutil.IsFile(localPath) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := os.Remove(localPath); err != nil {\n\t\t\treturn fmt.Errorf(\"remove upload: %v\", err)\n\t\t}\n\t}\n\n\treturn sess.Commit()\n}\n\nfunc DeleteUpload(u *Upload) error {\n\treturn DeleteUploads(u)\n}\n\nfunc DeleteUploadByUUID(uuid string) error {\n\tupload, err := GetUploadByUUID(uuid)\n\tif err != nil {\n\t\tif IsErrUploadNotExist(err) {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"get upload by UUID[%s]: %v\", uuid, err)\n\t}\n\n\tif err := DeleteUpload(upload); err != nil {\n\t\treturn fmt.Errorf(\"delete upload: %v\", err)\n\t}\n\n\treturn nil\n}\n\ntype UploadRepoFileOptions struct {\n\tLastCommitID string\n\tOldBranch    string\n\tNewBranch    string\n\tTreePath     string\n\tMessage      string\n\tFiles        []string // In UUID format\n}\n\n// isRepositoryGitPath returns true if given path is or resides inside \".git\" path of the repository.\nfunc isRepositoryGitPath(path string) bool {\n\treturn strings.HasSuffix(path, \".git\") || strings.Contains(path, \".git\"+string(os.PathSeparator))\n}\n\nfunc (repo *Repository) UploadRepoFiles(doer *User, opts UploadRepoFileOptions) error {\n\tif len(opts.Files) == 0 {\n\t\treturn nil\n\t}\n\n\t// Prevent uploading files into the \".git\" directory\n\tif isRepositoryGitPath(opts.TreePath) {\n\t\treturn errors.Errorf(\"bad tree path %q\", opts.TreePath)\n\t}\n\n\tuploads, err := GetUploadsByUUIDs(opts.Files)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"get uploads by UUIDs[%v]: %v\", opts.Files, err)\n\t}\n\n\trepoWorkingPool.CheckIn(com.ToStr(repo.ID))\n\tdefer repoWorkingPool.CheckOut(com.ToStr(repo.ID))\n\n\tif err = repo.DiscardLocalRepoBranchChanges(opts.OldBranch); err != nil {\n\t\treturn fmt.Errorf(\"discard local repo branch[%s] changes: %v\", opts.OldBranch, err)\n\t} else if err = repo.UpdateLocalCopyBranch(opts.OldBranch); err != nil {\n\t\treturn fmt.Errorf(\"update local copy branch[%s]: %v\", opts.OldBranch, err)\n\t}\n\n\tif opts.OldBranch != opts.NewBranch {\n\t\tif err = repo.CheckoutNewBranch(opts.OldBranch, opts.NewBranch); err != nil {\n\t\t\treturn fmt.Errorf(\"checkout new branch[%s] from old branch[%s]: %v\", opts.NewBranch, opts.OldBranch, err)\n\t\t}\n\t}\n\n\tlocalPath := repo.LocalCopyPath()\n\tdirPath := path.Join(localPath, opts.TreePath)\n\tif err = os.MkdirAll(dirPath, os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\n\t// Copy uploaded files into repository\n\tfor _, upload := range uploads {\n\t\ttmpPath := upload.LocalPath()\n\t\tif !osutil.IsFile(tmpPath) {\n\t\t\tcontinue\n\t\t}\n\n\t\tupload.Name = pathutil.Clean(upload.Name)\n\n\t\t// Prevent uploading files into the \".git\" directory\n\t\tif isRepositoryGitPath(upload.Name) {\n\t\t\tcontinue\n\t\t}\n\n\t\ttargetPath := path.Join(dirPath, upload.Name)\n\t\tif err = com.Copy(tmpPath, targetPath); err != nil {\n\t\t\treturn fmt.Errorf(\"copy: %v\", err)\n\t\t}\n\t}\n\n\tif err = git.RepoAdd(localPath, git.AddOptions{All: true}); err != nil {\n\t\treturn fmt.Errorf(\"git add --all: %v\", err)\n\t} else if err = git.RepoCommit(localPath, doer.NewGitSig(), opts.Message); err != nil {\n\t\treturn fmt.Errorf(\"commit changes on %q: %v\", localPath, err)\n\t}\n\n\tenvs := ComposeHookEnvs(ComposeHookEnvsOptions{\n\t\tAuthUser:  doer,\n\t\tOwnerName: repo.MustOwner().Name,\n\t\tOwnerSalt: repo.MustOwner().Salt,\n\t\tRepoID:    repo.ID,\n\t\tRepoName:  repo.Name,\n\t\tRepoPath:  repo.RepoPath(),\n\t})\n\tif err = git.RepoPush(localPath, \"origin\", opts.NewBranch, git.PushOptions{Envs: envs}); err != nil {\n\t\treturn fmt.Errorf(\"git push origin %s: %v\", opts.NewBranch, err)\n\t}\n\n\treturn DeleteUploads(uploads...)\n}\n"], "buggy_code_start_loc": [18], "buggy_code_end_loc": [491], "fixing_code_start_loc": [19], "fixing_code_end_loc": [500], "type": "CWE-434", "message": "Remote Command Execution in uploading repository file in GitHub repository gogs/gogs prior to 0.12.6.", "other": {"cve": {"id": "CVE-2022-0415", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-21T11:15:10.757", "lastModified": "2022-03-25T18:14:47.773", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Remote Command Execution in uploading repository file in GitHub repository gogs/gogs prior to 0.12.6."}, {"lang": "es", "value": "Una Ejecuci\u00f3n de Comandos Remota en la carga de un archivo de repositorio en el repositorio de GitHub gogs/gogs versiones anteriores a 0.12.6"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gogs:gogs:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.12.6", "matchCriteriaId": "8D0C289A-C304-438C-8AAA-2D84DA7C48B3"}]}]}], "references": [{"url": "https://github.com/gogs/gogs/commit/0fef3c9082269e9a4e817274942a5d7c50617284", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/b4928cfe-4110-462f-a180-6d5673797902", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gogs/gogs/commit/0fef3c9082269e9a4e817274942a5d7c50617284"}}