{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * ZGFX (RDP8) Bulk Data Compression\n *\n * Copyright 2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_CODEC_ZGFX_H\n#define FREERDP_CODEC_ZGFX_H\n\n#include <freerdp/api.h>\n#include <freerdp/types.h>\n\n#include <freerdp/codec/bulk.h>\n\n#define ZGFX_SEGMENTED_SINGLE\t\t\t0xE0\n#define ZGFX_SEGMENTED_MULTIPART\t\t0xE1\n\n#define ZGFX_PACKET_COMPR_TYPE_RDP8\t\t0x04\n\n#define ZGFX_SEGMENTED_MAXSIZE\t\t\t65535\n\nstruct _ZGFX_CONTEXT\n{\n\tBOOL Compressor;\n\n\tconst BYTE* pbInputCurrent;\n\tconst BYTE* pbInputEnd;\n\n\tUINT32 bits;\n\tUINT32 cBitsRemaining;\n\tUINT32 BitsCurrent;\n\tUINT32 cBitsCurrent;\n\n\tBYTE OutputBuffer[65536];\n\tUINT32 OutputCount;\n\n\tBYTE HistoryBuffer[2500000];\n\tUINT32 HistoryIndex;\n\tUINT32 HistoryBufferSize;\n};\ntypedef struct _ZGFX_CONTEXT ZGFX_CONTEXT;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nFREERDP_API int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData, UINT32* pDstSize, UINT32 flags);\nFREERDP_API int zgfx_compress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData, UINT32* pDstSize, UINT32* pFlags);\nFREERDP_API int zgfx_compress_to_stream(ZGFX_CONTEXT* zgfx, wStream* sDst, const BYTE* pUncompressed, UINT32 uncompressedSize, UINT32* pFlags);\n\nFREERDP_API void zgfx_context_reset(ZGFX_CONTEXT* zgfx, BOOL flush);\n\nFREERDP_API ZGFX_CONTEXT* zgfx_context_new(BOOL Compressor);\nFREERDP_API void zgfx_context_free(ZGFX_CONTEXT* zgfx);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* FREERDP_CODEC_ZGFX_H */\n \n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * ZGFX (RDP8) Bulk Data Compression\n *\n * Copyright 2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2017 Armin Novak <armin.novak@thincast.com>\n * Copyright 2017 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/bitstream.h>\n\n#include <freerdp/log.h>\n#include <freerdp/codec/zgfx.h>\n\n#define TAG FREERDP_TAG(\"codec\")\n\n/**\n * RDP8 Compressor Limits:\n *\n * Maximum number of uncompressed bytes in a single segment: 65535\n * Maximum match distance / minimum history size: 2500000 bytes.\n * Maximum number of segments: 65535\n * Maximum expansion of a segment (when compressed size exceeds uncompressed): 1000 bytes\n * Minimum match length: 3 bytes\n */\n\nstruct _ZGFX_TOKEN\n{\n\tint prefixLength;\n\tint prefixCode;\n\tint valueBits;\n\tint tokenType;\n\tUINT32 valueBase;\n};\ntypedef struct _ZGFX_TOKEN ZGFX_TOKEN;\n\nstatic const ZGFX_TOKEN ZGFX_TOKEN_TABLE[] =\n{\n\t// len code vbits type  vbase\n\t{  1,    0,   8,   0,           0 },    // 0\n\t{  5,   17,   5,   1,           0 },    // 10001\n\t{  5,   18,   7,   1,          32 },    // 10010\n\t{  5,   19,   9,   1,         160 },    // 10011\n\t{  5,   20,  10,   1,         672 },    // 10100\n\t{  5,   21,  12,   1,        1696 },    // 10101\n\t{  5,   24,   0,   0,  0x00       },    // 11000\n\t{  5,   25,   0,   0,  0x01       },    // 11001\n\t{  6,   44,  14,   1,        5792 },    // 101100\n\t{  6,   45,  15,   1,       22176 },    // 101101\n\t{  6,   52,   0,   0,  0x02       },    // 110100\n\t{  6,   53,   0,   0,  0x03       },    // 110101\n\t{  6,   54,   0,   0,  0xFF       },    // 110110\n\t{  7,   92,  18,   1,       54944 },    // 1011100\n\t{  7,   93,  20,   1,      317088 },    // 1011101\n\t{  7,  110,   0,   0,  0x04       },    // 1101110\n\t{  7,  111,   0,   0,  0x05       },    // 1101111\n\t{  7,  112,   0,   0,  0x06       },    // 1110000\n\t{  7,  113,   0,   0,  0x07       },    // 1110001\n\t{  7,  114,   0,   0,  0x08       },    // 1110010\n\t{  7,  115,   0,   0,  0x09       },    // 1110011\n\t{  7,  116,   0,   0,  0x0A       },    // 1110100\n\t{  7,  117,   0,   0,  0x0B       },    // 1110101\n\t{  7,  118,   0,   0,  0x3A       },    // 1110110\n\t{  7,  119,   0,   0,  0x3B       },    // 1110111\n\t{  7,  120,   0,   0,  0x3C       },    // 1111000\n\t{  7,  121,   0,   0,  0x3D       },    // 1111001\n\t{  7,  122,   0,   0,  0x3E       },    // 1111010\n\t{  7,  123,   0,   0,  0x3F       },    // 1111011\n\t{  7,  124,   0,   0,  0x40       },    // 1111100\n\t{  7,  125,   0,   0,  0x80       },    // 1111101\n\t{  8,  188,  20,   1,     1365664 },    // 10111100\n\t{  8,  189,  21,   1,     2414240 },    // 10111101\n\t{  8,  252,   0,   0,  0x0C       },    // 11111100\n\t{  8,  253,   0,   0,  0x38       },    // 11111101\n\t{  8,  254,   0,   0,  0x39       },    // 11111110\n\t{  8,  255,   0,   0,  0x66       },    // 11111111\n\t{  9,  380,  22,   1,     4511392 },    // 101111100\n\t{  9,  381,  23,   1,     8705696 },    // 101111101\n\t{  9,  382,  24,   1,    17094304 },    // 101111110\n\t{ 0 }\n};\n\n#define zgfx_GetBits(_zgfx, _nbits) \\\n\twhile (_zgfx->cBitsCurrent < _nbits) { \\\n\t\t_zgfx->BitsCurrent <<= 8; \\\n\t\tif (_zgfx->pbInputCurrent < _zgfx->pbInputEnd) \\\n\t\t\t_zgfx->BitsCurrent += *(_zgfx->pbInputCurrent)++; \\\n\t\t_zgfx->cBitsCurrent += 8; \\\n\t} \\\n\t_zgfx->cBitsRemaining -= _nbits; \\\n\t_zgfx->cBitsCurrent -= _nbits; \\\n\t_zgfx->bits = _zgfx->BitsCurrent >> _zgfx->cBitsCurrent; \\\n\t_zgfx->BitsCurrent &= ((1 << _zgfx->cBitsCurrent) - 1);\n\nstatic void zgfx_history_buffer_ring_write(ZGFX_CONTEXT* zgfx, const BYTE* src, size_t count)\n{\n\tUINT32 front;\n\n\tif (count <= 0)\n\t\treturn;\n\n\tif (count > zgfx->HistoryBufferSize)\n\t{\n\t\tconst size_t residue = count - zgfx->HistoryBufferSize;\n\t\tcount = zgfx->HistoryBufferSize;\n\t\tsrc += residue;\n\t\tzgfx->HistoryIndex = (zgfx->HistoryIndex + residue) % zgfx->HistoryBufferSize;\n\t}\n\n\tif (zgfx->HistoryIndex + count <= zgfx->HistoryBufferSize)\n\t{\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, count);\n\n\t\tif ((zgfx->HistoryIndex += count) == zgfx->HistoryBufferSize)\n\t\t\tzgfx->HistoryIndex = 0;\n\t}\n\telse\n\t{\n\t\tfront = zgfx->HistoryBufferSize - zgfx->HistoryIndex;\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, front);\n\t\tCopyMemory(zgfx->HistoryBuffer, &src[front], count - front);\n\t\tzgfx->HistoryIndex = count - front;\n\t}\n}\n\nstatic void zgfx_history_buffer_ring_read(ZGFX_CONTEXT* zgfx, int offset, BYTE* dst, UINT32 count)\n{\n\tUINT32 front;\n\tUINT32 index;\n\tUINT32 bytes;\n\tUINT32 valid;\n\tUINT32 bytesLeft;\n\tBYTE* dptr = dst;\n\tBYTE* origDst = dst;\n\n\tif (count <= 0)\n\t\treturn;\n\n\tbytesLeft = count;\n\tindex = (zgfx->HistoryIndex + zgfx->HistoryBufferSize - offset) % zgfx->HistoryBufferSize;\n\tbytes = MIN(bytesLeft, offset);\n\n\tif ((index + bytes) <= zgfx->HistoryBufferSize)\n\t{\n\t\tCopyMemory(dptr, &(zgfx->HistoryBuffer[index]), bytes);\n\t}\n\telse\n\t{\n\t\tfront = zgfx->HistoryBufferSize - index;\n\t\tCopyMemory(dptr, &(zgfx->HistoryBuffer[index]), front);\n\t\tCopyMemory(&dptr[front], zgfx->HistoryBuffer, bytes - front);\n\t}\n\n\tif ((bytesLeft -= bytes) == 0)\n\t\treturn;\n\n\tdptr += bytes;\n\tvalid = bytes;\n\n\tdo\n\t{\n\t\tbytes = valid;\n\n\t\tif (bytes > bytesLeft)\n\t\t\tbytes = bytesLeft;\n\n\t\tCopyMemory(dptr, origDst, bytes);\n\t\tdptr += bytes;\n\t\tvalid <<= 1;\n\t}\n\twhile ((bytesLeft -= bytes) > 0);\n}\n\nstatic BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t segmentSize)\n{\n\tBYTE c;\n\tBYTE flags;\n\tint extra;\n\tint opIndex;\n\tint haveBits;\n\tint inPrefix;\n\tUINT32 count;\n\tUINT32 distance;\n\tBYTE* pbSegment;\n\tsize_t cbSegment = segmentSize - 1;\n\n\tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(stream, flags); /* header (1 byte) */\n\tzgfx->OutputCount = 0;\n\tpbSegment = Stream_Pointer(stream);\n\tStream_Seek(stream, cbSegment);\n\n\tif (!(flags & PACKET_COMPRESSED))\n\t{\n\t\tzgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);\n\t\tCopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);\n\t\tzgfx->OutputCount = cbSegment;\n\t\treturn TRUE;\n\t}\n\n\tzgfx->pbInputCurrent = pbSegment;\n\tzgfx->pbInputEnd = &pbSegment[cbSegment - 1];\n\t/* NumberOfBitsToDecode = ((NumberOfBytesToDecode - 1) * 8) - ValueOfLastByte */\n\tzgfx->cBitsRemaining = 8 * (cbSegment - 1) - *zgfx->pbInputEnd;\n\tzgfx->cBitsCurrent = 0;\n\tzgfx->BitsCurrent = 0;\n\n\twhile (zgfx->cBitsRemaining)\n\t{\n\t\thaveBits = 0;\n\t\tinPrefix = 0;\n\n\t\tfor (opIndex = 0; ZGFX_TOKEN_TABLE[opIndex].prefixLength != 0; opIndex++)\n\t\t{\n\t\t\twhile (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength)\n\t\t\t{\n\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\tinPrefix = (inPrefix << 1) + zgfx->bits;\n\t\t\t\thaveBits++;\n\t\t\t}\n\n\t\t\tif (inPrefix == ZGFX_TOKEN_TABLE[opIndex].prefixCode)\n\t\t\t{\n\t\t\t\tif (ZGFX_TOKEN_TABLE[opIndex].tokenType == 0)\n\t\t\t\t{\n\t\t\t\t\t/* Literal */\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tc = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits);\n\t\t\t\t\tzgfx->HistoryBuffer[zgfx->HistoryIndex] = c;\n\n\t\t\t\t\tif (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)\n\t\t\t\t\t\tzgfx->HistoryIndex = 0;\n\n\t\t\t\t\tzgfx->OutputBuffer[zgfx->OutputCount++] = c;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tdistance = ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits;\n\n\t\t\t\t\tif (distance != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Match */\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\n\t\t\t\t\t\tif (zgfx->bits == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount = 4;\n\t\t\t\t\t\t\textra = 2;\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\n\t\t\t\t\t\t\twhile (zgfx->bits == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount *= 2;\n\t\t\t\t\t\t\t\textra++;\n\t\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, extra);\n\t\t\t\t\t\t\tcount += zgfx->bits;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tzgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Unencoded */\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 15);\n\t\t\t\t\t\tcount = zgfx->bits;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= zgfx->cBitsCurrent;\n\t\t\t\t\t\tzgfx->cBitsCurrent = 0;\n\t\t\t\t\t\tzgfx->BitsCurrent = 0;\n\t\t\t\t\t\tCopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx->pbInputCurrent += count;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= (8 * count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nint zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                    UINT32* pDstSize, UINT32 flags)\n{\n\tint status = -1;\n\tBYTE descriptor;\n\n\twStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);\n\tif (!stream)\n\t\treturn -1;\n\n\tif (Stream_GetRemainingLength(stream) < 1)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(stream, descriptor); /* descriptor (1 byte) */\n\n\tif (descriptor == ZGFX_SEGMENTED_SINGLE)\n\t{\n\t\tif (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))\n\t\t\tgoto fail;\n\n\t\t*ppDstData = NULL;\n\t\tif (zgfx->OutputCount > 0)\n\t\t\t*ppDstData = (BYTE*) malloc(zgfx->OutputCount);\n\n\t\tif (!*ppDstData)\n\t\t\tgoto fail;\n\n\t\t*pDstSize = zgfx->OutputCount;\n\t\tCopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);\n\t}\n\telse if (descriptor == ZGFX_SEGMENTED_MULTIPART)\n\t{\n\t\tUINT32 segmentSize;\n\t\tUINT16 segmentNumber;\n\t\tUINT16 segmentCount;\n\t\tUINT32 uncompressedSize;\n\t\tBYTE* pConcatenated;\n\n\t\tif (Stream_GetRemainingLength(stream) < 6)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT16(stream, segmentCount); /* segmentCount (2 bytes) */\n\t\tStream_Read_UINT32(stream, uncompressedSize); /* uncompressedSize (4 bytes) */\n\n\t\tif (Stream_GetRemainingLength(stream) < segmentCount * sizeof(UINT32))\n\t\t\tgoto fail;\n\n\t\tpConcatenated = (BYTE*) malloc(uncompressedSize);\n\n\t\tif (!pConcatenated)\n\t\t\tgoto fail;\n\n\t\t*ppDstData = pConcatenated;\n\t\t*pDstSize = uncompressedSize;\n\n\t\tfor (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(stream) < sizeof(UINT32))\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT32(stream, segmentSize); /* segmentSize (4 bytes) */\n\n\t\t\tif (!zgfx_decompress_segment(zgfx, stream, segmentSize))\n\t\t\t\tgoto fail;\n\n\t\t\tCopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);\n\t\t\tpConcatenated += zgfx->OutputCount;\n\t\t}\n\t}\n\telse\n\t{\n\t\tgoto fail;\n\t}\n\n\tstatus = 1;\nfail:\n\tStream_Free(stream, FALSE);\n\treturn status;\n}\n\nstatic BOOL zgfx_compress_segment(ZGFX_CONTEXT* zgfx, wStream* s, const BYTE* pSrcData,\n                                  UINT32 SrcSize, UINT32* pFlags)\n{\n\t/* FIXME: Currently compression not implemented. Just copy the raw source */\n\tif (!Stream_EnsureRemainingCapacity(s, SrcSize + 1))\n\t{\n\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\treturn FALSE;\n\t}\n\n\t(*pFlags) |= ZGFX_PACKET_COMPR_TYPE_RDP8; /* RDP 8.0 compression format */\n\tStream_Write_UINT8(s, (*pFlags)); /* header (1 byte) */\n\tStream_Write(s, pSrcData, SrcSize);\n\treturn TRUE;\n}\n\nint zgfx_compress_to_stream(ZGFX_CONTEXT* zgfx, wStream* sDst, const BYTE* pUncompressed,\n                            UINT32 uncompressedSize, UINT32* pFlags)\n{\n\tint fragment;\n\tUINT16 maxLength;\n\tUINT32 totalLength;\n\tsize_t posSegmentCount = 0;\n\tconst BYTE* pSrcData;\n\tint status = 0;\n\tmaxLength = ZGFX_SEGMENTED_MAXSIZE;\n\ttotalLength = uncompressedSize;\n\tpSrcData = pUncompressed;\n\n\tfor (fragment = 0; (totalLength > 0) || (fragment == 0); fragment++)\n\t{\n\t\tUINT32 SrcSize;\n\t\tsize_t posDstSize;\n\t\tsize_t posDataStart;\n\t\tUINT32 DstSize;\n\t\tSrcSize = (totalLength > maxLength) ? maxLength : totalLength;\n\t\tposDstSize = 0;\n\t\ttotalLength -= SrcSize;\n\n\t\t/* Ensure we have enough space for headers */\n\t\tif (!Stream_EnsureRemainingCapacity(sDst, 12))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (fragment == 0)\n\t\t{\n\t\t\t/* First fragment */\n\t\t\t/* descriptor (1 byte) */\n\t\t\tStream_Write_UINT8(sDst, (totalLength == 0) ?\n\t\t\t                   ZGFX_SEGMENTED_SINGLE : ZGFX_SEGMENTED_MULTIPART);\n\n\t\t\tif (totalLength > 0)\n\t\t\t{\n\t\t\t\tposSegmentCount = Stream_GetPosition(sDst); /* segmentCount (2 bytes) */\n\t\t\t\tStream_Seek(sDst, 2);\n\t\t\t\tStream_Write_UINT32(sDst, uncompressedSize); /* uncompressedSize (4 bytes) */\n\t\t\t}\n\t\t}\n\n\t\tif (fragment > 0 || totalLength > 0)\n\t\t{\n\t\t\t/* Multipart */\n\t\t\tposDstSize = Stream_GetPosition(sDst); /* size (4 bytes) */\n\t\t\tStream_Seek(sDst, 4);\n\t\t}\n\n\t\tposDataStart = Stream_GetPosition(sDst);\n\n\t\tif (!zgfx_compress_segment(zgfx, sDst, pSrcData, SrcSize, pFlags))\n\t\t\treturn -1;\n\n\t\tif (posDstSize)\n\t\t{\n\t\t\t/* Fill segment data size */\n\t\t\tDstSize = Stream_GetPosition(sDst) - posDataStart;\n\t\t\tStream_SetPosition(sDst, posDstSize);\n\t\t\tStream_Write_UINT32(sDst, DstSize);\n\t\t\tStream_SetPosition(sDst, posDataStart + DstSize);\n\t\t}\n\n\t\tpSrcData += SrcSize;\n\t}\n\n\tStream_SealLength(sDst);\n\n\t/* fill back segmentCount */\n\tif (posSegmentCount)\n\t{\n\t\tStream_SetPosition(sDst, posSegmentCount);\n\t\tStream_Write_UINT16(sDst, fragment);\n\t\tStream_SetPosition(sDst, Stream_Length(sDst));\n\t}\n\n\treturn status;\n}\n\nint zgfx_compress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                  UINT32* pDstSize, UINT32* pFlags)\n{\n\tint status;\n\twStream* s = Stream_New(NULL, SrcSize);\n\tstatus = zgfx_compress_to_stream(zgfx, s, pSrcData, SrcSize, pFlags);\n\t(*ppDstData) = Stream_Buffer(s);\n\t(*pDstSize) = Stream_GetPosition(s);\n\tStream_Free(s, FALSE);\n\treturn status;\n}\n\n\nvoid zgfx_context_reset(ZGFX_CONTEXT* zgfx, BOOL flush)\n{\n\tzgfx->HistoryIndex = 0;\n}\n\nZGFX_CONTEXT* zgfx_context_new(BOOL Compressor)\n{\n\tZGFX_CONTEXT* zgfx;\n\tzgfx = (ZGFX_CONTEXT*) calloc(1, sizeof(ZGFX_CONTEXT));\n\n\tif (zgfx)\n\t{\n\t\tzgfx->Compressor = Compressor;\n\t\tzgfx->HistoryBufferSize = sizeof(zgfx->HistoryBuffer);\n\t\tzgfx_context_reset(zgfx, FALSE);\n\t}\n\n\treturn zgfx;\n}\n\nvoid zgfx_context_free(ZGFX_CONTEXT* zgfx)\n{\n\tfree(zgfx);\n}\n\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * ZGFX (RDP8) Bulk Data Compression\n *\n * Copyright 2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_CODEC_ZGFX_H\n#define FREERDP_CODEC_ZGFX_H\n\n#include <freerdp/api.h>\n#include <freerdp/types.h>\n\n#include <freerdp/codec/bulk.h>\n\n#define ZGFX_SEGMENTED_SINGLE\t\t\t0xE0\n#define ZGFX_SEGMENTED_MULTIPART\t\t0xE1\n\n#define ZGFX_PACKET_COMPR_TYPE_RDP8\t\t0x04\n\n#define ZGFX_SEGMENTED_MAXSIZE\t\t\t65535\n\ntypedef struct _ZGFX_CONTEXT ZGFX_CONTEXT;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nFREERDP_API int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize,\n                                BYTE** ppDstData, UINT32* pDstSize, UINT32 flags);\nFREERDP_API int zgfx_compress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize,\n                              BYTE** ppDstData, UINT32* pDstSize, UINT32* pFlags);\nFREERDP_API int zgfx_compress_to_stream(ZGFX_CONTEXT* zgfx, wStream* sDst,\n                                        const BYTE* pUncompressed, UINT32 uncompressedSize, UINT32* pFlags);\n\nFREERDP_API void zgfx_context_reset(ZGFX_CONTEXT* zgfx, BOOL flush);\n\nFREERDP_API ZGFX_CONTEXT* zgfx_context_new(BOOL Compressor);\nFREERDP_API void zgfx_context_free(ZGFX_CONTEXT* zgfx);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* FREERDP_CODEC_ZGFX_H */\n\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * ZGFX (RDP8) Bulk Data Compression\n *\n * Copyright 2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2017 Armin Novak <armin.novak@thincast.com>\n * Copyright 2017 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/bitstream.h>\n\n#include <freerdp/log.h>\n#include <freerdp/codec/zgfx.h>\n\n#define TAG FREERDP_TAG(\"codec\")\n\n/**\n * RDP8 Compressor Limits:\n *\n * Maximum number of uncompressed bytes in a single segment: 65535\n * Maximum match distance / minimum history size: 2500000 bytes.\n * Maximum number of segments: 65535\n * Maximum expansion of a segment (when compressed size exceeds uncompressed): 1000 bytes\n * Minimum match length: 3 bytes\n */\n\nstruct _ZGFX_TOKEN\n{\n\tUINT32 prefixLength;\n\tUINT32 prefixCode;\n\tUINT32 valueBits;\n\tUINT32 tokenType;\n\tUINT32 valueBase;\n};\ntypedef struct _ZGFX_TOKEN ZGFX_TOKEN;\n\nstruct _ZGFX_CONTEXT\n{\n\tBOOL Compressor;\n\n\tconst BYTE* pbInputCurrent;\n\tconst BYTE* pbInputEnd;\n\n\tUINT32 bits;\n\tUINT32 cBitsRemaining;\n\tUINT32 BitsCurrent;\n\tUINT32 cBitsCurrent;\n\n\tBYTE OutputBuffer[65536];\n\tUINT32 OutputCount;\n\n\tBYTE HistoryBuffer[2500000];\n\tUINT32 HistoryIndex;\n\tUINT32 HistoryBufferSize;\n};\n\nstatic const ZGFX_TOKEN ZGFX_TOKEN_TABLE[] =\n{\n\t// len code vbits type  vbase\n\t{  1,    0,   8,   0,           0 },    // 0\n\t{  5,   17,   5,   1,           0 },    // 10001\n\t{  5,   18,   7,   1,          32 },    // 10010\n\t{  5,   19,   9,   1,         160 },    // 10011\n\t{  5,   20,  10,   1,         672 },    // 10100\n\t{  5,   21,  12,   1,        1696 },    // 10101\n\t{  5,   24,   0,   0,  0x00       },    // 11000\n\t{  5,   25,   0,   0,  0x01       },    // 11001\n\t{  6,   44,  14,   1,        5792 },    // 101100\n\t{  6,   45,  15,   1,       22176 },    // 101101\n\t{  6,   52,   0,   0,  0x02       },    // 110100\n\t{  6,   53,   0,   0,  0x03       },    // 110101\n\t{  6,   54,   0,   0,  0xFF       },    // 110110\n\t{  7,   92,  18,   1,       54944 },    // 1011100\n\t{  7,   93,  20,   1,      317088 },    // 1011101\n\t{  7,  110,   0,   0,  0x04       },    // 1101110\n\t{  7,  111,   0,   0,  0x05       },    // 1101111\n\t{  7,  112,   0,   0,  0x06       },    // 1110000\n\t{  7,  113,   0,   0,  0x07       },    // 1110001\n\t{  7,  114,   0,   0,  0x08       },    // 1110010\n\t{  7,  115,   0,   0,  0x09       },    // 1110011\n\t{  7,  116,   0,   0,  0x0A       },    // 1110100\n\t{  7,  117,   0,   0,  0x0B       },    // 1110101\n\t{  7,  118,   0,   0,  0x3A       },    // 1110110\n\t{  7,  119,   0,   0,  0x3B       },    // 1110111\n\t{  7,  120,   0,   0,  0x3C       },    // 1111000\n\t{  7,  121,   0,   0,  0x3D       },    // 1111001\n\t{  7,  122,   0,   0,  0x3E       },    // 1111010\n\t{  7,  123,   0,   0,  0x3F       },    // 1111011\n\t{  7,  124,   0,   0,  0x40       },    // 1111100\n\t{  7,  125,   0,   0,  0x80       },    // 1111101\n\t{  8,  188,  20,   1,     1365664 },    // 10111100\n\t{  8,  189,  21,   1,     2414240 },    // 10111101\n\t{  8,  252,   0,   0,  0x0C       },    // 11111100\n\t{  8,  253,   0,   0,  0x38       },    // 11111101\n\t{  8,  254,   0,   0,  0x39       },    // 11111110\n\t{  8,  255,   0,   0,  0x66       },    // 11111111\n\t{  9,  380,  22,   1,     4511392 },    // 101111100\n\t{  9,  381,  23,   1,     8705696 },    // 101111101\n\t{  9,  382,  24,   1,    17094304 },    // 101111110\n\t{ 0 }\n};\n\nstatic INLINE BOOL zgfx_GetBits(ZGFX_CONTEXT* _zgfx, UINT32 _nbits)\n{\n\tif (!_zgfx)\n\t\treturn FALSE;\n\n\twhile (_zgfx->cBitsCurrent < _nbits)\n\t{\n\t\t_zgfx->BitsCurrent <<= 8;\n\n\t\tif (_zgfx->pbInputCurrent < _zgfx->pbInputEnd)\n\t\t\t_zgfx->BitsCurrent += *(_zgfx->pbInputCurrent)++;\n\n\t\t_zgfx->cBitsCurrent += 8;\n\t}\n\n\t_zgfx->cBitsRemaining -= _nbits;\n\t_zgfx->cBitsCurrent -= _nbits;\n\t_zgfx->bits = _zgfx->BitsCurrent >> _zgfx->cBitsCurrent;\n\t_zgfx->BitsCurrent &= ((1 << _zgfx->cBitsCurrent) - 1);\n}\n\nstatic void zgfx_history_buffer_ring_write(ZGFX_CONTEXT* zgfx, const BYTE* src, size_t count)\n{\n\tUINT32 front;\n\n\tif (count <= 0)\n\t\treturn;\n\n\tif (count > zgfx->HistoryBufferSize)\n\t{\n\t\tconst size_t residue = count - zgfx->HistoryBufferSize;\n\t\tcount = zgfx->HistoryBufferSize;\n\t\tsrc += residue;\n\t\tzgfx->HistoryIndex = (zgfx->HistoryIndex + residue) % zgfx->HistoryBufferSize;\n\t}\n\n\tif (zgfx->HistoryIndex + count <= zgfx->HistoryBufferSize)\n\t{\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, count);\n\n\t\tif ((zgfx->HistoryIndex += count) == zgfx->HistoryBufferSize)\n\t\t\tzgfx->HistoryIndex = 0;\n\t}\n\telse\n\t{\n\t\tfront = zgfx->HistoryBufferSize - zgfx->HistoryIndex;\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, front);\n\t\tCopyMemory(zgfx->HistoryBuffer, &src[front], count - front);\n\t\tzgfx->HistoryIndex = count - front;\n\t}\n}\n\nstatic void zgfx_history_buffer_ring_read(ZGFX_CONTEXT* zgfx, int offset, BYTE* dst, UINT32 count)\n{\n\tUINT32 front;\n\tUINT32 index;\n\tUINT32 bytes;\n\tUINT32 valid;\n\tUINT32 bytesLeft;\n\tBYTE* dptr = dst;\n\tBYTE* origDst = dst;\n\n\tif (count <= 0)\n\t\treturn;\n\n\tbytesLeft = count;\n\tindex = (zgfx->HistoryIndex + zgfx->HistoryBufferSize - offset) % zgfx->HistoryBufferSize;\n\tbytes = MIN(bytesLeft, offset);\n\n\tif ((index + bytes) <= zgfx->HistoryBufferSize)\n\t{\n\t\tCopyMemory(dptr, &(zgfx->HistoryBuffer[index]), bytes);\n\t}\n\telse\n\t{\n\t\tfront = zgfx->HistoryBufferSize - index;\n\t\tCopyMemory(dptr, &(zgfx->HistoryBuffer[index]), front);\n\t\tCopyMemory(&dptr[front], zgfx->HistoryBuffer, bytes - front);\n\t}\n\n\tif ((bytesLeft -= bytes) == 0)\n\t\treturn;\n\n\tdptr += bytes;\n\tvalid = bytes;\n\n\tdo\n\t{\n\t\tbytes = valid;\n\n\t\tif (bytes > bytesLeft)\n\t\t\tbytes = bytesLeft;\n\n\t\tCopyMemory(dptr, origDst, bytes);\n\t\tdptr += bytes;\n\t\tvalid <<= 1;\n\t}\n\twhile ((bytesLeft -= bytes) > 0);\n}\n\nstatic BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t segmentSize)\n{\n\tBYTE c;\n\tBYTE flags;\n\tUINT32 extra = 0;\n\tint opIndex;\n\tint haveBits;\n\tint inPrefix;\n\tUINT32 count;\n\tUINT32 distance;\n\tBYTE* pbSegment;\n\tsize_t cbSegment = segmentSize - 1;\n\n\tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(stream, flags); /* header (1 byte) */\n\tzgfx->OutputCount = 0;\n\tpbSegment = Stream_Pointer(stream);\n\tStream_Seek(stream, cbSegment);\n\n\tif (!(flags & PACKET_COMPRESSED))\n\t{\n\t\tzgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);\n\t\tCopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);\n\t\tzgfx->OutputCount = cbSegment;\n\t\treturn TRUE;\n\t}\n\n\tzgfx->pbInputCurrent = pbSegment;\n\tzgfx->pbInputEnd = &pbSegment[cbSegment - 1];\n\t/* NumberOfBitsToDecode = ((NumberOfBytesToDecode - 1) * 8) - ValueOfLastByte */\n\tzgfx->cBitsRemaining = 8 * (cbSegment - 1) - *zgfx->pbInputEnd;\n\tzgfx->cBitsCurrent = 0;\n\tzgfx->BitsCurrent = 0;\n\n\twhile (zgfx->cBitsRemaining)\n\t{\n\t\thaveBits = 0;\n\t\tinPrefix = 0;\n\n\t\tfor (opIndex = 0; ZGFX_TOKEN_TABLE[opIndex].prefixLength != 0; opIndex++)\n\t\t{\n\t\t\twhile (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength)\n\t\t\t{\n\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\tinPrefix = (inPrefix << 1) + zgfx->bits;\n\t\t\t\thaveBits++;\n\t\t\t}\n\n\t\t\tif (inPrefix == ZGFX_TOKEN_TABLE[opIndex].prefixCode)\n\t\t\t{\n\t\t\t\tif (ZGFX_TOKEN_TABLE[opIndex].tokenType == 0)\n\t\t\t\t{\n\t\t\t\t\t/* Literal */\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tc = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits);\n\t\t\t\t\tzgfx->HistoryBuffer[zgfx->HistoryIndex] = c;\n\n\t\t\t\t\tif (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)\n\t\t\t\t\t\tzgfx->HistoryIndex = 0;\n\n\t\t\t\t\tzgfx->OutputBuffer[zgfx->OutputCount++] = c;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tdistance = ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits;\n\n\t\t\t\t\tif (distance != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Match */\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\n\t\t\t\t\t\tif (zgfx->bits == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount = 4;\n\t\t\t\t\t\t\textra = 2;\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\n\t\t\t\t\t\t\twhile (zgfx->bits == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount *= 2;\n\t\t\t\t\t\t\t\textra++;\n\t\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, extra);\n\t\t\t\t\t\t\tcount += zgfx->bits;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tzgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Unencoded */\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 15);\n\t\t\t\t\t\tcount = zgfx->bits;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= zgfx->cBitsCurrent;\n\t\t\t\t\t\tzgfx->cBitsCurrent = 0;\n\t\t\t\t\t\tzgfx->BitsCurrent = 0;\n\t\t\t\t\t\tCopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx->pbInputCurrent += count;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= (8 * count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nint zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                    UINT32* pDstSize, UINT32 flags)\n{\n\tint status = -1;\n\tBYTE descriptor;\n\twStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);\n\n\tif (!stream)\n\t\treturn -1;\n\n\tif (Stream_GetRemainingLength(stream) < 1)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(stream, descriptor); /* descriptor (1 byte) */\n\n\tif (descriptor == ZGFX_SEGMENTED_SINGLE)\n\t{\n\t\tif (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))\n\t\t\tgoto fail;\n\n\t\t*ppDstData = NULL;\n\n\t\tif (zgfx->OutputCount > 0)\n\t\t\t*ppDstData = (BYTE*) malloc(zgfx->OutputCount);\n\n\t\tif (!*ppDstData)\n\t\t\tgoto fail;\n\n\t\t*pDstSize = zgfx->OutputCount;\n\t\tCopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);\n\t}\n\telse if (descriptor == ZGFX_SEGMENTED_MULTIPART)\n\t{\n\t\tUINT32 segmentSize;\n\t\tUINT16 segmentNumber;\n\t\tUINT16 segmentCount;\n\t\tUINT32 uncompressedSize;\n\t\tBYTE* pConcatenated;\n\t\tsize_t used = 0;\n\n\t\tif (Stream_GetRemainingLength(stream) < 6)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT16(stream, segmentCount); /* segmentCount (2 bytes) */\n\t\tStream_Read_UINT32(stream, uncompressedSize); /* uncompressedSize (4 bytes) */\n\n\t\tif (Stream_GetRemainingLength(stream) < segmentCount * sizeof(UINT32))\n\t\t\tgoto fail;\n\n\t\tpConcatenated = (BYTE*) malloc(uncompressedSize);\n\n\t\tif (!pConcatenated)\n\t\t\tgoto fail;\n\n\t\t*ppDstData = pConcatenated;\n\t\t*pDstSize = uncompressedSize;\n\n\t\tfor (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(stream) < sizeof(UINT32))\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT32(stream, segmentSize); /* segmentSize (4 bytes) */\n\n\t\t\tif (!zgfx_decompress_segment(zgfx, stream, segmentSize))\n\t\t\t\tgoto fail;\n\n\t\t\tif (zgfx->OutputCount > UINT32_MAX - used)\n\t\t\t\tgoto fail;\n\n\t\t\tif (used + zgfx->OutputCount > uncompressedSize)\n\t\t\t\tgoto fail;\n\n\t\t\tCopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);\n\t\t\tpConcatenated += zgfx->OutputCount;\n\t\t\tused += zgfx->OutputCount;\n\t\t}\n\t}\n\telse\n\t{\n\t\tgoto fail;\n\t}\n\n\tstatus = 1;\nfail:\n\tStream_Free(stream, FALSE);\n\treturn status;\n}\n\nstatic BOOL zgfx_compress_segment(ZGFX_CONTEXT* zgfx, wStream* s, const BYTE* pSrcData,\n                                  UINT32 SrcSize, UINT32* pFlags)\n{\n\t/* FIXME: Currently compression not implemented. Just copy the raw source */\n\tif (!Stream_EnsureRemainingCapacity(s, SrcSize + 1))\n\t{\n\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\treturn FALSE;\n\t}\n\n\t(*pFlags) |= ZGFX_PACKET_COMPR_TYPE_RDP8; /* RDP 8.0 compression format */\n\tStream_Write_UINT8(s, (*pFlags)); /* header (1 byte) */\n\tStream_Write(s, pSrcData, SrcSize);\n\treturn TRUE;\n}\n\nint zgfx_compress_to_stream(ZGFX_CONTEXT* zgfx, wStream* sDst, const BYTE* pUncompressed,\n                            UINT32 uncompressedSize, UINT32* pFlags)\n{\n\tint fragment;\n\tUINT16 maxLength;\n\tUINT32 totalLength;\n\tsize_t posSegmentCount = 0;\n\tconst BYTE* pSrcData;\n\tint status = 0;\n\tmaxLength = ZGFX_SEGMENTED_MAXSIZE;\n\ttotalLength = uncompressedSize;\n\tpSrcData = pUncompressed;\n\n\tfor (fragment = 0; (totalLength > 0) || (fragment == 0); fragment++)\n\t{\n\t\tUINT32 SrcSize;\n\t\tsize_t posDstSize;\n\t\tsize_t posDataStart;\n\t\tUINT32 DstSize;\n\t\tSrcSize = (totalLength > maxLength) ? maxLength : totalLength;\n\t\tposDstSize = 0;\n\t\ttotalLength -= SrcSize;\n\n\t\t/* Ensure we have enough space for headers */\n\t\tif (!Stream_EnsureRemainingCapacity(sDst, 12))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Stream_EnsureRemainingCapacity failed!\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (fragment == 0)\n\t\t{\n\t\t\t/* First fragment */\n\t\t\t/* descriptor (1 byte) */\n\t\t\tStream_Write_UINT8(sDst, (totalLength == 0) ?\n\t\t\t                   ZGFX_SEGMENTED_SINGLE : ZGFX_SEGMENTED_MULTIPART);\n\n\t\t\tif (totalLength > 0)\n\t\t\t{\n\t\t\t\tposSegmentCount = Stream_GetPosition(sDst); /* segmentCount (2 bytes) */\n\t\t\t\tStream_Seek(sDst, 2);\n\t\t\t\tStream_Write_UINT32(sDst, uncompressedSize); /* uncompressedSize (4 bytes) */\n\t\t\t}\n\t\t}\n\n\t\tif (fragment > 0 || totalLength > 0)\n\t\t{\n\t\t\t/* Multipart */\n\t\t\tposDstSize = Stream_GetPosition(sDst); /* size (4 bytes) */\n\t\t\tStream_Seek(sDst, 4);\n\t\t}\n\n\t\tposDataStart = Stream_GetPosition(sDst);\n\n\t\tif (!zgfx_compress_segment(zgfx, sDst, pSrcData, SrcSize, pFlags))\n\t\t\treturn -1;\n\n\t\tif (posDstSize)\n\t\t{\n\t\t\t/* Fill segment data size */\n\t\t\tDstSize = Stream_GetPosition(sDst) - posDataStart;\n\t\t\tStream_SetPosition(sDst, posDstSize);\n\t\t\tStream_Write_UINT32(sDst, DstSize);\n\t\t\tStream_SetPosition(sDst, posDataStart + DstSize);\n\t\t}\n\n\t\tpSrcData += SrcSize;\n\t}\n\n\tStream_SealLength(sDst);\n\n\t/* fill back segmentCount */\n\tif (posSegmentCount)\n\t{\n\t\tStream_SetPosition(sDst, posSegmentCount);\n\t\tStream_Write_UINT16(sDst, fragment);\n\t\tStream_SetPosition(sDst, Stream_Length(sDst));\n\t}\n\n\treturn status;\n}\n\nint zgfx_compress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                  UINT32* pDstSize, UINT32* pFlags)\n{\n\tint status;\n\twStream* s = Stream_New(NULL, SrcSize);\n\tstatus = zgfx_compress_to_stream(zgfx, s, pSrcData, SrcSize, pFlags);\n\t(*ppDstData) = Stream_Buffer(s);\n\t(*pDstSize) = Stream_GetPosition(s);\n\tStream_Free(s, FALSE);\n\treturn status;\n}\n\n\nvoid zgfx_context_reset(ZGFX_CONTEXT* zgfx, BOOL flush)\n{\n\tzgfx->HistoryIndex = 0;\n}\n\nZGFX_CONTEXT* zgfx_context_new(BOOL Compressor)\n{\n\tZGFX_CONTEXT* zgfx;\n\tzgfx = (ZGFX_CONTEXT*) calloc(1, sizeof(ZGFX_CONTEXT));\n\n\tif (zgfx)\n\t{\n\t\tzgfx->Compressor = Compressor;\n\t\tzgfx->HistoryBufferSize = sizeof(zgfx->HistoryBuffer);\n\t\tzgfx_context_reset(zgfx, FALSE);\n\t}\n\n\treturn zgfx;\n}\n\nvoid zgfx_context_free(ZGFX_CONTEXT* zgfx)\n{\n\tfree(zgfx);\n}\n\n"], "buggy_code_start_loc": [35, 47], "buggy_code_end_loc": [75, 381], "fixing_code_start_loc": [34, 47], "fixing_code_end_loc": [59, 420], "type": "CWE-787", "message": "FreeRDP prior to version 2.0.0-rc4 contains a Heap-Based Buffer Overflow in function zgfx_decompress() that results in a memory corruption and probably even a remote code execution.", "other": {"cve": {"id": "CVE-2018-8785", "sourceIdentifier": "cve@checkpoint.com", "published": "2018-11-29T18:29:00.850", "lastModified": "2020-09-29T15:08:37.443", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FreeRDP prior to version 2.0.0-rc4 contains a Heap-Based Buffer Overflow in function zgfx_decompress() that results in a memory corruption and probably even a remote code execution."}, {"lang": "es", "value": "FreeRDP en versiones anteriores a la 2.0.0-rc4 contiene un desbordamiento de b\u00fafer basado en memoria din\u00e1mica (heap) en la funci\u00f3n zgfx_decompress() que resulta en una corrupci\u00f3n de memoria y, probablemente, incluso en la ejecuci\u00f3n remota de c\u00f3digo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "cve@checkpoint.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.0", "matchCriteriaId": "FB13905B-B0E9-443E-B150-9D64E20DC464"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "F226993C-3AB8-4F86-8591-40CAAC8DD73E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "985D90BF-3B2B-4A3C-B698-DBCB0241B95B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "7C4656D2-EEC4-4871-BA0F-76F760526B1B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/106938", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/602f4a2e14b41703b5f431de3154cd46a5750a2d", "source": "cve@checkpoint.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://research.checkpoint.com/reverse-rdp-attack-code-execution-on-rdp-clients/", "source": "cve@checkpoint.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3845-1/", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/602f4a2e14b41703b5f431de3154cd46a5750a2d"}}