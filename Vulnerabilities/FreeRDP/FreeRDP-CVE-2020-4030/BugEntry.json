{"buggy_code": ["/*************************************************************************\n *\n * $Id: trio.c,v 1.131 2010/09/12 11:08:08 breese Exp $\n *\n * Copyright (C) 1998, 2009 Bjorn Reese and Daniel Stenberg.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND\n * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.\n *\n *************************************************************************\n *\n * A note to trio contributors:\n *\n * Avoid heap allocation at all costs to ensure that the trio functions\n * are async-safe. The exceptions are the printf/fprintf functions, which\n * uses fputc, and the asprintf functions and the <alloc> modifier, which\n * by design are required to allocate form the heap.\n *\n ************************************************************************/\n\n/*\n * TODO:\n *  - Scan is probably too permissive about its modifiers.\n *  - C escapes in %#[] ?\n *  - Multibyte characters (done for format parsing, except scan groups)\n *  - Complex numbers? (C99 _Complex)\n *  - Boolean values? (C99 _Bool)\n *  - C99 NaN(n-char-sequence) missing. The n-char-sequence can be used\n *    to print the mantissa, e.g. NaN(0xc000000000000000)\n *  - Should we support the GNU %a alloc modifier? GNU has an ugly hack\n *    for %a, because C99 used %a for other purposes. If specified as\n *    %as or %a[ it is interpreted as the alloc modifier, otherwise as\n *    the C99 hex-float. This means that you cannot scan %as as a hex-float\n *    immediately followed by an 's'.\n *  - Scanning of collating symbols.\n */\n\n/*************************************************************************\n * Trio include files\n */\n#include \"triodef.h\"\n#include \"trio.h\"\n#include \"triop.h\"\n\n#if defined(TRIO_EMBED_NAN)\n#define TRIO_PUBLIC_NAN static\n#if TRIO_FEATURE_FLOAT\n#define TRIO_FUNC_NAN\n#define TRIO_FUNC_NINF\n#define TRIO_FUNC_PINF\n#define TRIO_FUNC_FPCLASSIFY_AND_SIGNBIT\n#define TRIO_FUNC_ISINF\n#endif\n#endif\n#include \"trionan.h\"\n\n#if defined(TRIO_EMBED_STRING)\n#define TRIO_PUBLIC_STRING static\n#define TRIO_FUNC_LENGTH\n#define TRIO_FUNC_LENGTH_MAX\n#define TRIO_FUNC_TO_LONG\n#if TRIO_FEATURE_LOCALE\n#define TRIO_FUNC_COPY_MAX\n#endif\n#if TRIO_FEATURE_DYNAMICSTRING\n#define TRIO_FUNC_XSTRING_DUPLICATE\n#endif\n#if TRIO_EXTENSION && TRIO_FEATURE_SCANF\n#define TRIO_FUNC_EQUAL_LOCALE\n#endif\n#if TRIO_FEATURE_ERRNO\n#define TRIO_FUNC_ERROR\n#endif\n#if TRIO_FEATURE_FLOAT && TRIO_FEATURE_SCANF\n#define TRIO_FUNC_TO_DOUBLE\n#endif\n#if TRIO_FEATURE_DYNAMICSTRING\n#define TRIO_FUNC_STRING_EXTRACT\n#endif\n#if TRIO_FEATURE_DYNAMICSTRING\n#define TRIO_FUNC_STRING_TERMINATE\n#endif\n#if TRIO_FEATURE_USER_DEFINED\n#define TRIO_FUNC_DUPLICATE\n#endif\n#if TRIO_FEATURE_DYNAMICSTRING\n#define TRIO_FUNC_STRING_DESTROY\n#endif\n#if TRIO_FEATURE_USER_DEFINED\n#define TRIO_FUNC_DESTROY\n#endif\n#if TRIO_FEATURE_USER_DEFINED || (TRIO_FEATURE_FLOAT && TRIO_FEATURE_SCANF)\n#define TRIO_FUNC_EQUAL\n#endif\n#if TRIO_FEATURE_USER_DEFINED || TRIO_FEATURE_SCANF\n#define TRIO_FUNC_EQUAL_CASE\n#endif\n#if (TRIO_EXTENSION && TRIO_FEATURE_SCANF)\n#define TRIO_FUNC_EQUAL_MAX\n#endif\n#if TRIO_FEATURE_SCANF\n#define TRIO_FUNC_TO_UPPER\n#endif\n#if TRIO_FEATURE_DYNAMICSTRING\n#define TRIO_FUNC_XSTRING_APPEND_CHAR\n#endif\n#endif\n#include \"triostr.h\"\n\n/**************************************************************************\n *\n * Definitions\n *\n *************************************************************************/\n\n#include <limits.h>\n#if TRIO_FEATURE_FLOAT\n#include <math.h>\n#include <float.h>\n#endif\n\n#if defined(__STDC_ISO_10646__) || defined(MB_LEN_MAX) || defined(USE_MULTIBYTE) || \\\n    TRIO_FEATURE_WIDECHAR\n#if (!defined(TRIO_PLATFORM_WINCE) && !defined(ANDROID))\n#define TRIO_COMPILER_SUPPORTS_MULTIBYTE\n#if !defined(MB_LEN_MAX)\n#define MB_LEN_MAX 6\n#endif\n#endif\n#endif\n\n#if (TRIO_COMPILER_VISUALC - 0 >= 1100) || defined(TRIO_COMPILER_BORLAND)\n#define TRIO_COMPILER_SUPPORTS_VISUALC_INT\n#endif\n\n#if TRIO_FEATURE_FLOAT\n#if defined(PREDEF_STANDARD_C99) || defined(PREDEF_STANDARD_UNIX03)\n#if !defined(HAVE_FLOORL) && !defined(TRIO_NO_FLOORL)\n#define HAVE_FLOORL\n#endif\n#if !defined(HAVE_CEILL) && !defined(TRIO_NO_CEILL)\n#define HAVE_CEILL\n#endif\n#if !defined(HAVE_POWL) && !defined(TRIO_NO_POWL)\n#define HAVE_POWL\n#endif\n#if !defined(HAVE_FMODL) && !defined(TRIO_NO_FMODL)\n#define HAVE_FMODL\n#endif\n#if !defined(HAVE_LOG10L) && !defined(TRIO_NO_LOG10L)\n#define HAVE_LOG10L\n#endif\n#endif\n#if defined(TRIO_COMPILER_VISUALC)\n#if defined(floorl)\n#define HAVE_FLOORL\n#endif\n#if defined(ceill)\n#define HAVE_CEILL\n#endif\n#if defined(powl)\n#define HAVE_POWL\n#endif\n#if defined(fmodl)\n#define HAVE_FMODL\n#endif\n#if defined(log10l)\n#define HAVE_LOG10L\n#endif\n#endif\n#endif\n\n/*************************************************************************\n * Generic definitions\n */\n\n#if !(defined(DEBUG) || defined(NDEBUG))\n#define NDEBUG\n#endif\n\n#include <assert.h>\n#include <ctype.h>\n#if defined(PREDEF_STANDARD_C99) && !defined(isascii)\n#define isascii(x) ((x)&0x7F)\n#endif\n#if defined(TRIO_COMPILER_ANCIENT)\n#include <varargs.h>\n#else\n#include <stdarg.h>\n#endif\n#include <stddef.h>\n#if defined(TRIO_PLATFORM_WINCE)\nextern int errno;\n#else\n#include <errno.h>\n#endif\n\n#ifndef NULL\n#define NULL 0\n#endif\n#define NIL ((char)0)\n#ifndef FALSE\n#define FALSE (1 == 0)\n#define TRUE (!FALSE)\n#endif\n#define BOOLEAN_T int\n\n/* mincore() can be used for debugging purposes */\n#define VALID(x) (NULL != (x))\n\n#if TRIO_FEATURE_ERRORCODE\n/*\n * Encode the error code and the position. This is decoded\n * with TRIO_ERROR_CODE and TRIO_ERROR_POSITION.\n */\n#define TRIO_ERROR_RETURN(x, y) (-((x) + ((y) << 8)))\n#else\n#define TRIO_ERROR_RETURN(x, y) (-1)\n#endif\n\ntypedef unsigned long trio_flags_t;\n\n/*************************************************************************\n * Platform specific definitions\n */\n#if defined(TRIO_PLATFORM_UNIX)\n#include <unistd.h>\n#include <signal.h>\n#include <locale.h>\n#if !defined(TRIO_FEATURE_LOCALE)\n#define USE_LOCALE\n#endif\n#endif /* TRIO_PLATFORM_UNIX */\n#if defined(TRIO_PLATFORM_VMS)\n#include <unistd.h>\n#endif\n#if defined(TRIO_PLATFORM_WIN32)\n#if defined(TRIO_PLATFORM_WINCE)\nint read(int handle, char* buffer, unsigned int length);\nint write(int handle, const char* buffer, unsigned int length);\n#else\n#include <io.h>\n#define read _read\n#define write _write\n#endif\n#endif /* TRIO_PLATFORM_WIN32 */\n\n#if TRIO_FEATURE_WIDECHAR\n#if defined(PREDEF_STANDARD_C94)\n#include <wchar.h>\n#include <wctype.h>\ntypedef wchar_t trio_wchar_t;\ntypedef wint_t trio_wint_t;\n#else\ntypedef char trio_wchar_t;\ntypedef int trio_wint_t;\n#define WCONST(x) L##x\n#define WEOF EOF\n#define iswalnum(x) isalnum(x)\n#define iswalpha(x) isalpha(x)\n#define iswcntrl(x) iscntrl(x)\n#define iswdigit(x) isdigit(x)\n#define iswgraph(x) isgraph(x)\n#define iswlower(x) islower(x)\n#define iswprint(x) isprint(x)\n#define iswpunct(x) ispunct(x)\n#define iswspace(x) isspace(x)\n#define iswupper(x) isupper(x)\n#define iswxdigit(x) isxdigit(x)\n#endif\n#endif\n\n/*************************************************************************\n * Compiler dependent definitions\n */\n\n/* Support for long long */\n#ifndef __cplusplus\n#if !defined(USE_LONGLONG)\n#if defined(TRIO_COMPILER_GCC) && !defined(__STRICT_ANSI__)\n#define USE_LONGLONG\n#else\n#if defined(TRIO_COMPILER_SUNPRO)\n#define USE_LONGLONG\n#else\n#if defined(TRIO_COMPILER_MSVC) && (_MSC_VER >= 1400)\n#define USE_LONGLONG\n#else\n#if defined(_LONG_LONG) || defined(_LONGLONG)\n#define USE_LONGLONG\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n\n/* The extra long numbers */\n#if defined(USE_LONGLONG)\ntypedef signed long long int trio_longlong_t;\ntypedef unsigned long long int trio_ulonglong_t;\n#else\n#if defined(TRIO_COMPILER_SUPPORTS_VISUALC_INT)\ntypedef signed __int64 trio_longlong_t;\ntypedef unsigned __int64 trio_ulonglong_t;\n#else\ntypedef TRIO_SIGNED long int trio_longlong_t;\ntypedef unsigned long int trio_ulonglong_t;\n#endif\n#endif\n\n/* Maximal and fixed integer types */\n#if defined(PREDEF_STANDARD_C99)\n#include <stdint.h>\ntypedef intmax_t trio_intmax_t;\ntypedef uintmax_t trio_uintmax_t;\ntypedef int8_t trio_int8_t;\ntypedef int16_t trio_int16_t;\ntypedef int32_t trio_int32_t;\ntypedef int64_t trio_int64_t;\n#else\n#if defined(PREDEF_STANDARD_UNIX98)\n#include <inttypes.h>\ntypedef intmax_t trio_intmax_t;\ntypedef uintmax_t trio_uintmax_t;\ntypedef int8_t trio_int8_t;\ntypedef int16_t trio_int16_t;\ntypedef int32_t trio_int32_t;\ntypedef int64_t trio_int64_t;\n#else\n#if defined(TRIO_COMPILER_SUPPORTS_VISUALC_INT)\ntypedef trio_longlong_t trio_intmax_t;\ntypedef trio_ulonglong_t trio_uintmax_t;\ntypedef __int8 trio_int8_t;\ntypedef __int16 trio_int16_t;\ntypedef __int32 trio_int32_t;\ntypedef __int64 trio_int64_t;\n#else\ntypedef trio_longlong_t trio_intmax_t;\ntypedef trio_ulonglong_t trio_uintmax_t;\n#if defined(TRIO_INT8_T)\ntypedef TRIO_INT8_T trio_int8_t;\n#else\ntypedef TRIO_SIGNED char trio_int8_t;\n#endif\n#if defined(TRIO_INT16_T)\ntypedef TRIO_INT16_T trio_int16_t;\n#else\ntypedef TRIO_SIGNED short trio_int16_t;\n#endif\n#if defined(TRIO_INT32_T)\ntypedef TRIO_INT32_T trio_int32_t;\n#else\ntypedef TRIO_SIGNED int trio_int32_t;\n#endif\n#if defined(TRIO_INT64_T)\ntypedef TRIO_INT64_T trio_int64_t;\n#else\ntypedef trio_longlong_t trio_int64_t;\n#endif\n#endif\n#endif\n#endif\n\n#if defined(HAVE_FLOORL)\n#define trio_floor(x) floorl((x))\n#else\n#define trio_floor(x) floor((double)(x))\n#endif\n\n#if defined(HAVE_CEILL)\n#define trio_ceil(x) ceill((x))\n#else\n#define trio_ceil(x) ceil((double)(x))\n#endif\n\n#if defined(HAVE_FMODL)\n#define trio_fmod(x, y) fmodl((x), (y))\n#else\n#define trio_fmod(x, y) fmod((double)(x), (double)(y))\n#endif\n\n#if defined(HAVE_POWL)\n#define trio_pow(x, y) powl((x), (y))\n#else\n#define trio_pow(x, y) pow((double)(x), (double)(y))\n#endif\n\n#if defined(HAVE_LOG10L)\n#define trio_log10(x) log10l((x))\n#else\n#define trio_log10(x) log10((double)(x))\n#endif\n\n#if TRIO_FEATURE_FLOAT\n#define TRIO_FABS(x) (((x) < 0.0) ? -(x) : (x))\n#endif\n\n/*************************************************************************\n * Internal Definitions\n */\n\n#ifdef _WIN32\n#pragma warning(push)\n#pragma warning(disable : 4244)\n#endif\n\n#if TRIO_FEATURE_FLOAT\n\n#if !defined(DECIMAL_DIG)\n#define DECIMAL_DIG DBL_DIG\n#endif\n\n/* Long double sizes */\n#ifdef LDBL_DIG\n#define MAX_MANTISSA_DIGITS LDBL_DIG\n#define MAX_EXPONENT_DIGITS 4\n#define MAX_DOUBLE_DIGITS LDBL_MAX_10_EXP\n#else\n#define MAX_MANTISSA_DIGITS DECIMAL_DIG\n#define MAX_EXPONENT_DIGITS 3\n#define MAX_DOUBLE_DIGITS DBL_MAX_10_EXP\n#endif\n\n#if defined(TRIO_COMPILER_ANCIENT) || !defined(LDBL_DIG)\n#undef LDBL_DIG\n#undef LDBL_MANT_DIG\n#undef LDBL_EPSILON\n#define LDBL_DIG DBL_DIG\n#define LDBL_MANT_DIG DBL_MANT_DIG\n#define LDBL_EPSILON DBL_EPSILON\n#endif\n\n#endif /* TRIO_FEATURE_FLOAT */\n\n/* The maximal number of digits is for base 2 */\n#define MAX_CHARS_IN(x) (sizeof(x) * CHAR_BIT)\n/* The width of a pointer. The number of bits in a hex digit is 4 */\n#define POINTER_WIDTH ((sizeof(\"0x\") - 1) + sizeof(trio_pointer_t) * CHAR_BIT / 4)\n\n#if TRIO_FEATURE_FLOAT\n/* Infinite and Not-A-Number for floating-point */\n#define INFINITE_LOWER \"inf\"\n#define INFINITE_UPPER \"INF\"\n#define LONG_INFINITE_LOWER \"infinite\"\n#define LONG_INFINITE_UPPER \"INFINITE\"\n#define NAN_LOWER \"nan\"\n#define NAN_UPPER \"NAN\"\n#endif\n\n/* Various constants */\nenum\n{\n\tTYPE_PRINT = 1,\n#if TRIO_FEATURE_SCANF\n\tTYPE_SCAN = 2,\n#endif\n\n\t/* Flags. FLAGS_LAST must be less than ULONG_MAX */\n\tFLAGS_NEW = 0,\n\tFLAGS_STICKY = 1,\n\tFLAGS_SPACE = 2 * FLAGS_STICKY,\n\tFLAGS_SHOWSIGN = 2 * FLAGS_SPACE,\n\tFLAGS_LEFTADJUST = 2 * FLAGS_SHOWSIGN,\n\tFLAGS_ALTERNATIVE = 2 * FLAGS_LEFTADJUST,\n\tFLAGS_SHORT = 2 * FLAGS_ALTERNATIVE,\n\tFLAGS_SHORTSHORT = 2 * FLAGS_SHORT,\n\tFLAGS_LONG = 2 * FLAGS_SHORTSHORT,\n\tFLAGS_QUAD = 2 * FLAGS_LONG,\n\tFLAGS_LONGDOUBLE = 2 * FLAGS_QUAD,\n\tFLAGS_SIZE_T = 2 * FLAGS_LONGDOUBLE,\n\tFLAGS_PTRDIFF_T = 2 * FLAGS_SIZE_T,\n\tFLAGS_INTMAX_T = 2 * FLAGS_PTRDIFF_T,\n\tFLAGS_NILPADDING = 2 * FLAGS_INTMAX_T,\n\tFLAGS_UNSIGNED = 2 * FLAGS_NILPADDING,\n\tFLAGS_UPPER = 2 * FLAGS_UNSIGNED,\n\tFLAGS_WIDTH = 2 * FLAGS_UPPER,\n\tFLAGS_WIDTH_PARAMETER = 2 * FLAGS_WIDTH,\n\tFLAGS_PRECISION = 2 * FLAGS_WIDTH_PARAMETER,\n\tFLAGS_PRECISION_PARAMETER = 2 * FLAGS_PRECISION,\n\tFLAGS_BASE = 2 * FLAGS_PRECISION_PARAMETER,\n\tFLAGS_BASE_PARAMETER = 2 * FLAGS_BASE,\n\tFLAGS_FLOAT_E = 2 * FLAGS_BASE_PARAMETER,\n\tFLAGS_FLOAT_G = 2 * FLAGS_FLOAT_E,\n\tFLAGS_QUOTE = 2 * FLAGS_FLOAT_G,\n\tFLAGS_WIDECHAR = 2 * FLAGS_QUOTE,\n\tFLAGS_IGNORE = 2 * FLAGS_WIDECHAR,\n\tFLAGS_IGNORE_PARAMETER = 2 * FLAGS_IGNORE,\n\tFLAGS_VARSIZE_PARAMETER = 2 * FLAGS_IGNORE_PARAMETER,\n\tFLAGS_FIXED_SIZE = 2 * FLAGS_VARSIZE_PARAMETER,\n\tFLAGS_LAST = FLAGS_FIXED_SIZE,\n\t/* Reused flags */\n\tFLAGS_EXCLUDE = FLAGS_SHORT,\n\tFLAGS_USER_DEFINED = FLAGS_IGNORE,\n\tFLAGS_USER_DEFINED_PARAMETER = FLAGS_IGNORE_PARAMETER,\n\tFLAGS_ROUNDING = FLAGS_INTMAX_T,\n\t/* Compounded flags */\n\tFLAGS_ALL_VARSIZES = FLAGS_LONG | FLAGS_QUAD | FLAGS_INTMAX_T | FLAGS_PTRDIFF_T | FLAGS_SIZE_T,\n\tFLAGS_ALL_SIZES = FLAGS_ALL_VARSIZES | FLAGS_SHORTSHORT | FLAGS_SHORT,\n\n\tNO_POSITION = -1,\n\tNO_WIDTH = 0,\n\tNO_PRECISION = -1,\n\tNO_SIZE = -1,\n\n\t/* Do not change these */\n\tNO_BASE = -1,\n\tMIN_BASE = 2,\n\tMAX_BASE = 36,\n\tBASE_BINARY = 2,\n\tBASE_OCTAL = 8,\n\tBASE_DECIMAL = 10,\n\tBASE_HEX = 16,\n\n\t/* Maximal number of allowed parameters */\n\tMAX_PARAMETERS = 64,\n\t/* Maximal number of characters in class */\n\tMAX_CHARACTER_CLASS = UCHAR_MAX + 1,\n\n#if TRIO_FEATURE_USER_DEFINED\n\t/* Maximal string lengths for user-defined specifiers */\n\tMAX_USER_NAME = 64,\n\tMAX_USER_DATA = 256,\n#endif\n\n\t/* Maximal length of locale separator strings */\n\tMAX_LOCALE_SEPARATOR_LENGTH = MB_LEN_MAX,\n\t/* Maximal number of integers in grouping */\n\tMAX_LOCALE_GROUPS = 64\n};\n\n#define NO_GROUPING ((int)CHAR_MAX)\n\n/* Fundamental formatting parameter types */\n#define FORMAT_SENTINEL -1 /* marks end of parameters array */\n#define FORMAT_UNKNOWN 0\n#define FORMAT_INT 1\n#define FORMAT_DOUBLE 2\n#define FORMAT_CHAR 3\n#define FORMAT_STRING 4\n#define FORMAT_POINTER 5\n#define FORMAT_COUNT 6\n#define FORMAT_PARAMETER 7\n#define FORMAT_GROUP 8\n#define FORMAT_ERRNO 9\n#define FORMAT_USER_DEFINED 10\n\n/* Character constants */\n#define CHAR_IDENTIFIER '%'\n#define CHAR_ALT_IDENTIFIER '$'\n#define CHAR_BACKSLASH '\\\\'\n#define CHAR_QUOTE '\\\"'\n#define CHAR_ADJUST ' '\n\n#if TRIO_EXTENSION\n/* Character class expressions */\n#define CLASS_ALNUM \"[:alnum:]\"\n#define CLASS_ALPHA \"[:alpha:]\"\n#define CLASS_BLANK \"[:blank:]\"\n#define CLASS_CNTRL \"[:cntrl:]\"\n#define CLASS_DIGIT \"[:digit:]\"\n#define CLASS_GRAPH \"[:graph:]\"\n#define CLASS_LOWER \"[:lower:]\"\n#define CLASS_PRINT \"[:print:]\"\n#define CLASS_PUNCT \"[:punct:]\"\n#define CLASS_SPACE \"[:space:]\"\n#define CLASS_UPPER \"[:upper:]\"\n#define CLASS_XDIGIT \"[:xdigit:]\"\n#endif\n\n/*\n * SPECIFIERS:\n *\n *\n * a  Hex-float\n * A  Hex-float\n * c  Character\n * C  Widechar character (wint_t)\n * d  Decimal\n * e  Float\n * E  Float\n * F  Float\n * F  Float\n * g  Float\n * G  Float\n * i  Integer\n * m  Error message\n * n  Count\n * o  Octal\n * p  Pointer\n * s  String\n * S  Widechar string (wchar_t *)\n * u  Unsigned\n * x  Hex\n * X  Hex\n * [] Group\n * <> User-defined\n *\n * Reserved:\n *\n * D  Binary Coded Decimal %D(length,precision) (OS/390)\n */\n#define SPECIFIER_CHAR 'c'\n#define SPECIFIER_STRING 's'\n#define SPECIFIER_DECIMAL 'd'\n#define SPECIFIER_INTEGER 'i'\n#define SPECIFIER_UNSIGNED 'u'\n#define SPECIFIER_OCTAL 'o'\n#define SPECIFIER_HEX 'x'\n#define SPECIFIER_HEX_UPPER 'X'\n#if TRIO_FEATURE_FLOAT\n#define SPECIFIER_FLOAT_E 'e'\n#define SPECIFIER_FLOAT_E_UPPER 'E'\n#define SPECIFIER_FLOAT_F 'f'\n#define SPECIFIER_FLOAT_F_UPPER 'F'\n#define SPECIFIER_FLOAT_G 'g'\n#define SPECIFIER_FLOAT_G_UPPER 'G'\n#endif\n#define SPECIFIER_POINTER 'p'\n#if TRIO_FEATURE_SCANF\n#define SPECIFIER_GROUP '['\n#define SPECIFIER_UNGROUP ']'\n#endif\n#define SPECIFIER_COUNT 'n'\n#if TRIO_UNIX98\n#define SPECIFIER_CHAR_UPPER 'C'\n#define SPECIFIER_STRING_UPPER 'S'\n#endif\n#define SPECIFIER_HEXFLOAT 'a'\n#define SPECIFIER_HEXFLOAT_UPPER 'A'\n#define SPECIFIER_ERRNO 'm'\n#if TRIO_FEATURE_BINARY\n#define SPECIFIER_BINARY 'b'\n#define SPECIFIER_BINARY_UPPER 'B'\n#endif\n#if TRIO_FEATURE_USER_DEFINED\n#define SPECIFIER_USER_DEFINED_BEGIN '<'\n#define SPECIFIER_USER_DEFINED_END '>'\n#define SPECIFIER_USER_DEFINED_SEPARATOR ':'\n#define SPECIFIER_USER_DEFINED_EXTRA '|'\n#endif\n\n/*\n * QUALIFIERS:\n *\n *\n * Numbers = d,i,o,u,x,X\n * Float = a,A,e,E,f,F,g,G\n * String = s\n * Char = c\n *\n *\n * 9$ Position\n *      Use the 9th parameter. 9 can be any number between 1 and\n *      the maximal argument\n *\n * 9 Width\n *      Set width to 9. 9 can be any number, but must not be postfixed\n *      by '$'\n *\n * h  Short\n *    Numbers:\n *      (unsigned) short int\n *\n * hh Short short\n *    Numbers:\n *      (unsigned) char\n *\n * l  Long\n *    Numbers:\n *      (unsigned) long int\n *    String:\n *      as the S specifier\n *    Char:\n *      as the C specifier\n *\n * ll Long Long\n *    Numbers:\n *      (unsigned) long long int\n *\n * L  Long Double\n *    Float\n *      long double\n *\n * #  Alternative\n *    Float:\n *      Decimal-point is always present\n *    String:\n *      non-printable characters are handled as \\number\n *\n *    Spacing\n *\n * +  Sign\n *\n * -  Alignment\n *\n * .  Precision\n *\n * *  Parameter\n *    print: use parameter\n *    scan: no parameter (ignore)\n *\n * q  Quad\n *\n * Z  size_t\n *\n * w  Widechar\n *\n * '  Thousands/quote\n *    Numbers:\n *      Integer part grouped in thousands\n *    Binary numbers:\n *      Number grouped in nibbles (4 bits)\n *    String:\n *      Quoted string\n *\n * j  intmax_t\n * t  prtdiff_t\n * z  size_t\n *\n * !  Sticky\n * @  Parameter (for both print and scan)\n *\n * I  n-bit Integer\n *    Numbers:\n *      The following options exists\n *        I8  = 8-bit integer\n *        I16 = 16-bit integer\n *        I32 = 32-bit integer\n *        I64 = 64-bit integer\n */\n#define QUALIFIER_POSITION '$'\n#define QUALIFIER_SHORT 'h'\n#define QUALIFIER_LONG 'l'\n#define QUALIFIER_LONG_UPPER 'L'\n#define QUALIFIER_ALTERNATIVE '#'\n#define QUALIFIER_SPACE ' '\n#define QUALIFIER_PLUS '+'\n#define QUALIFIER_MINUS '-'\n#define QUALIFIER_DOT '.'\n#define QUALIFIER_STAR '*'\n#define QUALIFIER_CIRCUMFLEX '^' /* For scanlists */\n#define QUALIFIER_SIZE_T 'z'\n#define QUALIFIER_PTRDIFF_T 't'\n#define QUALIFIER_INTMAX_T 'j'\n#define QUALIFIER_QUAD 'q'\n#define QUALIFIER_SIZE_T_UPPER 'Z'\n#if TRIO_MISC\n#define QUALIFIER_WIDECHAR 'w'\n#endif\n#define QUALIFIER_FIXED_SIZE 'I'\n#define QUALIFIER_QUOTE '\\''\n#define QUALIFIER_STICKY '!'\n#define QUALIFIER_VARSIZE '&' /* This should remain undocumented */\n#define QUALIFIER_ROUNDING_UPPER 'R'\n#if TRIO_EXTENSION\n#define QUALIFIER_PARAM '@' /* Experimental */\n#define QUALIFIER_COLON ':' /* For scanlists */\n#define QUALIFIER_EQUAL '=' /* For scanlists */\n#endif\n\n/*************************************************************************\n *\n * Internal Structures\n *\n *************************************************************************/\n\n/* Parameters */\ntypedef struct\n{\n\t/* An indication of which entry in the data union is used */\n\tint type;\n\t/* The flags */\n\ttrio_flags_t flags;\n\t/* The width qualifier */\n\tint width;\n\t/* The precision qualifier */\n\tint precision;\n\t/* The base qualifier */\n\tint base;\n\t/* Base from specifier */\n\tint baseSpecifier;\n\t/* The size for the variable size qualifier */\n\tint varsize;\n\t/* Offset of the first character of the specifier */\n\tint beginOffset;\n\t/* Offset of the first character after the specifier */\n\tint endOffset;\n\t/* Position in the argument list that this parameter refers to */\n\tint position;\n\t/* The data from the argument list */\n\tunion {\n\t\tchar* string;\n#if TRIO_FEATURE_WIDECHAR\n\t\ttrio_wchar_t* wstring;\n#endif\n\t\ttrio_pointer_t pointer;\n\t\tunion {\n\t\t\ttrio_intmax_t as_signed;\n\t\t\ttrio_uintmax_t as_unsigned;\n\t\t} number;\n#if TRIO_FEATURE_FLOAT\n\t\tdouble doubleNumber;\n\t\tdouble* doublePointer;\n\t\ttrio_long_double_t longdoubleNumber;\n\t\ttrio_long_double_t* longdoublePointer;\n#endif\n\t\tint errorNumber;\n\t} data;\n#if TRIO_FEATURE_USER_DEFINED\n\t/* For the user-defined specifier */\n\tunion {\n\t\tchar namespace[MAX_USER_NAME];\n\t\tint handler; /* if flags & FLAGS_USER_DEFINED_PARAMETER */\n\t} user_defined;\n\tchar user_data[MAX_USER_DATA];\n#endif\n} trio_parameter_t;\n\n/* Container for customized functions */\ntypedef struct\n{\n\tunion {\n\t\ttrio_outstream_t out;\n\t\ttrio_instream_t in;\n\t} stream;\n\ttrio_pointer_t closure;\n} trio_custom_t;\n\n/* General trio \"class\" */\ntypedef struct _trio_class_t\n{\n\t/*\n\t * The function to write characters to a stream.\n\t */\n\tvoid(*OutStream) TRIO_PROTO((struct _trio_class_t*, int));\n\t/*\n\t * The function to read characters from a stream.\n\t */\n\tvoid(*InStream) TRIO_PROTO((struct _trio_class_t*, int*));\n\t/*\n\t * The function to undo read characters from a stream.\n\t */\n\tvoid(*UndoStream) TRIO_PROTO((struct _trio_class_t*));\n\t/*\n\t * The current location in the stream.\n\t */\n\ttrio_pointer_t location;\n\t/*\n\t * The character currently being processed.\n\t */\n\tint current;\n\t/*\n\t * The number of characters that would have been written/read\n\t * if there had been sufficient space.\n\t */\n\tint processed;\n\tunion {\n\t\t/*\n\t\t * The number of characters that are actually written. Processed and\n\t\t * committed will only differ for the *nprintf functions.\n\t\t */\n\t\tint committed;\n\t\t/*\n\t\t * The number of look-ahead characters read.\n\t\t */\n\t\tint cached;\n\t} actually;\n\t/*\n\t * The upper limit of characters that may be written/read.\n\t */\n\tint max;\n\t/*\n\t * The last output error that was detected.\n\t */\n\tint error;\n} trio_class_t;\n\n/* References (for user-defined callbacks) */\ntypedef struct _trio_reference_t\n{\n\ttrio_class_t* data;\n\ttrio_parameter_t* parameter;\n} trio_reference_t;\n\n#if TRIO_FEATURE_USER_DEFINED\n/* Registered entries (for user-defined callbacks) */\ntypedef struct _trio_userdef_t\n{\n\tstruct _trio_userdef_t* next;\n\ttrio_callback_t callback;\n\tchar* name;\n} trio_userdef_t;\n#endif\n\n/*************************************************************************\n *\n * Internal Variables\n *\n *************************************************************************/\n/* Unused but kept for reference */\n/* static TRIO_CONST char rcsid[] = \"@(#)$Id: trio.c,v 1.131 2010/09/12 11:08:08 breese Exp $\"; */\n\n#if TRIO_FEATURE_FLOAT\n/*\n * Need this to workaround a parser bug in HP C/iX compiler that fails\n * to resolves macro definitions that includes type 'long double',\n * e.g: va_arg(arg_ptr, long double)\n */\n#if defined(TRIO_PLATFORM_MPEIX)\nstatic TRIO_CONST trio_long_double_t ___dummy_long_double = 0;\n#endif\n#endif\n\nstatic TRIO_CONST char internalNullString[] = \"(nil)\";\n\n#if defined(USE_LOCALE)\nstatic struct lconv* internalLocaleValues = NULL;\n#endif\n\n/*\n * UNIX98 says \"in a locale where the radix character is not defined,\n * the radix character defaults to a period (.)\"\n */\n#if TRIO_FEATURE_FLOAT || TRIO_FEATURE_LOCALE || defined(USE_LOCALE)\nstatic int internalDecimalPointLength = 1;\nstatic char internalDecimalPoint = '.';\nstatic char internalDecimalPointString[MAX_LOCALE_SEPARATOR_LENGTH + 1] = \".\";\n#endif\n#if TRIO_FEATURE_QUOTE || TRIO_FEATURE_LOCALE || TRIO_EXTENSION\nstatic int internalThousandSeparatorLength = 1;\nstatic char internalThousandSeparator[MAX_LOCALE_SEPARATOR_LENGTH + 1] = \",\";\nstatic char internalGrouping[MAX_LOCALE_GROUPS] = { (char)NO_GROUPING };\n#endif\n\nstatic TRIO_CONST char internalDigitsLower[] = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nstatic TRIO_CONST char internalDigitsUpper[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n#if TRIO_FEATURE_SCANF\nstatic BOOLEAN_T internalDigitsUnconverted = TRUE;\nstatic int internalDigitArray[128];\n#if TRIO_EXTENSION\nstatic BOOLEAN_T internalCollationUnconverted = TRUE;\nstatic char internalCollationArray[MAX_CHARACTER_CLASS][MAX_CHARACTER_CLASS];\n#endif\n#endif\n\n#if TRIO_FEATURE_USER_DEFINED\nstatic TRIO_VOLATILE trio_callback_t internalEnterCriticalRegion = NULL;\nstatic TRIO_VOLATILE trio_callback_t internalLeaveCriticalRegion = NULL;\nstatic trio_userdef_t* internalUserDef = NULL;\n#endif\n\n/*************************************************************************\n *\n * Internal Functions\n *\n ************************************************************************/\n\n#if defined(TRIO_EMBED_NAN)\n#include \"trionan.c\"\n#endif\n\n#if defined(TRIO_EMBED_STRING)\n#include \"triostr.c\"\n#endif\n\n/*************************************************************************\n * TrioInitializeParameter\n *\n * Description:\n *  Initialize a trio_parameter_t struct.\n */\nTRIO_PRIVATE void TrioInitializeParameter TRIO_ARGS1((parameter), trio_parameter_t* parameter)\n{\n\tparameter->type = FORMAT_UNKNOWN;\n\tparameter->flags = 0;\n\tparameter->width = 0;\n\tparameter->precision = 0;\n\tparameter->base = 0;\n\tparameter->baseSpecifier = 0;\n\tparameter->varsize = 0;\n\tparameter->beginOffset = 0;\n\tparameter->endOffset = 0;\n\tparameter->position = 0;\n\tparameter->data.pointer = 0;\n#if TRIO_FEATURE_USER_DEFINED\n\tparameter->user_defined.handler = 0;\n\tparameter->user_data[0] = 0;\n#endif\n}\n\n/*************************************************************************\n * TrioCopyParameter\n *\n * Description:\n *  Copies one trio_parameter_t struct to another.\n */\nTRIO_PRIVATE void TrioCopyParameter TRIO_ARGS2((target, source), trio_parameter_t* target,\n                                               TRIO_CONST trio_parameter_t* source)\n{\n#if TRIO_FEATURE_USER_DEFINED\n\tsize_t i;\n#endif\n\n\ttarget->type = source->type;\n\ttarget->flags = source->flags;\n\ttarget->width = source->width;\n\ttarget->precision = source->precision;\n\ttarget->base = source->base;\n\ttarget->baseSpecifier = source->baseSpecifier;\n\ttarget->varsize = source->varsize;\n\ttarget->beginOffset = source->beginOffset;\n\ttarget->endOffset = source->endOffset;\n\ttarget->position = source->position;\n\ttarget->data = source->data;\n\n#if TRIO_FEATURE_USER_DEFINED\n\ttarget->user_defined = source->user_defined;\n\n\tfor (i = 0U; i < sizeof(target->user_data); ++i)\n\t{\n\t\tif ((target->user_data[i] = source->user_data[i]) == NIL)\n\t\t\tbreak;\n\t}\n#endif\n}\n\n/*************************************************************************\n * TrioIsQualifier\n *\n * Description:\n *  Remember to add all new qualifiers to this function.\n *  QUALIFIER_POSITION must not be added.\n */\nTRIO_PRIVATE BOOLEAN_T TrioIsQualifier TRIO_ARGS1((character), TRIO_CONST char character)\n{\n\t/* QUALIFIER_POSITION is not included */\n\tswitch (character)\n\t{\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\tcase QUALIFIER_PLUS:\n\t\tcase QUALIFIER_MINUS:\n\t\tcase QUALIFIER_SPACE:\n\t\tcase QUALIFIER_DOT:\n\t\tcase QUALIFIER_STAR:\n\t\tcase QUALIFIER_ALTERNATIVE:\n\t\tcase QUALIFIER_SHORT:\n\t\tcase QUALIFIER_LONG:\n\t\tcase QUALIFIER_CIRCUMFLEX:\n\t\tcase QUALIFIER_LONG_UPPER:\n\t\tcase QUALIFIER_SIZE_T:\n\t\tcase QUALIFIER_PTRDIFF_T:\n\t\tcase QUALIFIER_INTMAX_T:\n\t\tcase QUALIFIER_QUAD:\n\t\tcase QUALIFIER_SIZE_T_UPPER:\n#if defined(QUALIFIER_WIDECHAR)\n\t\tcase QUALIFIER_WIDECHAR:\n#endif\n\t\tcase QUALIFIER_QUOTE:\n\t\tcase QUALIFIER_STICKY:\n\t\tcase QUALIFIER_VARSIZE:\n#if defined(QUALIFIER_PARAM)\n\t\tcase QUALIFIER_PARAM:\n#endif\n\t\tcase QUALIFIER_FIXED_SIZE:\n\t\tcase QUALIFIER_ROUNDING_UPPER:\n\t\t\treturn TRUE;\n\t\tdefault:\n\t\t\treturn FALSE;\n\t}\n}\n\n/*************************************************************************\n * TrioSetLocale\n */\n#if defined(USE_LOCALE)\nTRIO_PRIVATE void TrioSetLocale(TRIO_NOARGS)\n{\n\tinternalLocaleValues = (struct lconv*)localeconv();\n\tif (internalLocaleValues)\n\t{\n\t\tif ((internalLocaleValues->decimal_point) &&\n\t\t    (internalLocaleValues->decimal_point[0] != NIL))\n\t\t{\n\t\t\tinternalDecimalPointLength = trio_length(internalLocaleValues->decimal_point);\n\t\t\tif (internalDecimalPointLength == 1)\n\t\t\t{\n\t\t\t\tinternalDecimalPoint = internalLocaleValues->decimal_point[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinternalDecimalPoint = NIL;\n\t\t\t\ttrio_copy_max(internalDecimalPointString, sizeof(internalDecimalPointString),\n\t\t\t\t              internalLocaleValues->decimal_point);\n\t\t\t}\n\t\t}\n#if TRIO_EXTENSION\n\t\tif ((internalLocaleValues->thousands_sep) &&\n\t\t    (internalLocaleValues->thousands_sep[0] != NIL))\n\t\t{\n\t\t\ttrio_copy_max(internalThousandSeparator, sizeof(internalThousandSeparator),\n\t\t\t              internalLocaleValues->thousands_sep);\n\t\t\tinternalThousandSeparatorLength = trio_length(internalThousandSeparator);\n\t\t}\n#endif\n#if TRIO_EXTENSION\n\t\tif ((internalLocaleValues->grouping) && (internalLocaleValues->grouping[0] != NIL))\n\t\t{\n\t\t\ttrio_copy_max(internalGrouping, sizeof(internalGrouping),\n\t\t\t              internalLocaleValues->grouping);\n\t\t}\n#endif\n\t}\n}\n#endif /* defined(USE_LOCALE) */\n\n#if TRIO_FEATURE_FLOAT && TRIO_FEATURE_QUOTE\nTRIO_PRIVATE int TrioCalcThousandSeparatorLength TRIO_ARGS1((digits), int digits)\n{\n\tint count = 0;\n\tint step = NO_GROUPING;\n\tchar* groupingPointer = internalGrouping;\n\n\twhile (digits > 0)\n\t{\n\t\tif (*groupingPointer == CHAR_MAX)\n\t\t{\n\t\t\t/* Disable grouping */\n\t\t\tbreak; /* while */\n\t\t}\n\t\telse if (*groupingPointer == 0)\n\t\t{\n\t\t\t/* Repeat last group */\n\t\t\tif (step == NO_GROUPING)\n\t\t\t{\n\t\t\t\t/* Error in locale */\n\t\t\t\tbreak; /* while */\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstep = *groupingPointer++;\n\t\t}\n\t\tif (digits > step)\n\t\t\tcount += internalThousandSeparatorLength;\n\t\tdigits -= step;\n\t}\n\treturn count;\n}\n#endif /* TRIO_FEATURE_FLOAT && TRIO_FEATURE_QUOTE */\n\n#if TRIO_FEATURE_QUOTE\nTRIO_PRIVATE BOOLEAN_T TrioFollowedBySeparator TRIO_ARGS1((position), int position)\n{\n\tint step = 0;\n\tchar* groupingPointer = internalGrouping;\n\n\tposition--;\n\tif (position == 0)\n\t\treturn FALSE;\n\twhile (position > 0)\n\t{\n\t\tif (*groupingPointer == CHAR_MAX)\n\t\t{\n\t\t\t/* Disable grouping */\n\t\t\tbreak; /* while */\n\t\t}\n\t\telse if (*groupingPointer != 0)\n\t\t{\n\t\t\tstep = *groupingPointer++;\n\t\t}\n\t\tif (step == 0)\n\t\t\tbreak;\n\t\tposition -= step;\n\t}\n\treturn (position == 0);\n}\n#endif /* TRIO_FEATURE_QUOTE */\n\n/*************************************************************************\n * TrioGetPosition\n *\n * Get the %n$ position.\n */\nTRIO_PRIVATE int TrioGetPosition TRIO_ARGS2((format, offsetPointer), TRIO_CONST char* format,\n                                            int* offsetPointer)\n{\n#if TRIO_FEATURE_POSITIONAL\n\tchar* tmpformat;\n\tint number = 0;\n\tint offset = *offsetPointer;\n\n\tnumber = (int)trio_to_long(&format[offset], &tmpformat, BASE_DECIMAL);\n\toffset = (int)(tmpformat - format);\n\tif ((number != 0) && (QUALIFIER_POSITION == format[offset++]))\n\t{\n\t\t*offsetPointer = offset;\n\t\t/*\n\t\t * number is decreased by 1, because n$ starts from 1, whereas\n\t\t * the array it is indexing starts from 0.\n\t\t */\n\t\treturn number - 1;\n\t}\n#endif\n\treturn NO_POSITION;\n}\n\n/*************************************************************************\n * TrioFindNamespace\n *\n * Find registered user-defined specifier.\n * The prev argument is used for optimization only.\n */\n#if TRIO_FEATURE_USER_DEFINED\nTRIO_PRIVATE trio_userdef_t* TrioFindNamespace TRIO_ARGS2((name, prev), TRIO_CONST char* name,\n                                                          trio_userdef_t** prev)\n{\n\ttrio_userdef_t* def;\n\n\tif (internalEnterCriticalRegion)\n\t\t(void)internalEnterCriticalRegion(NULL);\n\n\tfor (def = internalUserDef; def; def = def->next)\n\t{\n\t\t/* Case-sensitive string comparison */\n\t\tif (trio_equal_case(def->name, name))\n\t\t\tbreak;\n\n\t\tif (prev)\n\t\t\t*prev = def;\n\t}\n\n\tif (internalLeaveCriticalRegion)\n\t\t(void)internalLeaveCriticalRegion(NULL);\n\n\treturn def;\n}\n#endif\n\n/*************************************************************************\n * TrioPower\n *\n * Description:\n *  Calculate pow(base, exponent), where number and exponent are integers.\n */\n#if TRIO_FEATURE_FLOAT\nTRIO_PRIVATE trio_long_double_t TrioPower TRIO_ARGS2((number, exponent), int number, int exponent)\n{\n\ttrio_long_double_t result;\n\n\tif (number == 10)\n\t{\n\t\tswitch (exponent)\n\t\t{\n\t\t\t\t/* Speed up calculation of common cases */\n\t\t\tcase 0:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E-1);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+0);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+1);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+2);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+3);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+4);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+5);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+6);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+7);\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+8);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresult = trio_pow((trio_long_double_t)number, (trio_long_double_t)exponent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn trio_pow((trio_long_double_t)number, (trio_long_double_t)exponent);\n\t}\n\treturn result;\n}\n#endif /* TRIO_FEATURE_FLOAT */\n\n/*************************************************************************\n * TrioLogarithm\n */\n#if TRIO_FEATURE_FLOAT\nTRIO_PRIVATE trio_long_double_t TrioLogarithm TRIO_ARGS2((number, base), trio_long_double_t number,\n                                                         int base)\n{\n\ttrio_long_double_t result;\n\n\tif (number <= 0.0)\n\t{\n\t\t/* xlC crashes on log(0) */\n\t\tresult = (number == 0.0) ? trio_ninf() : trio_nan();\n\t}\n\telse\n\t{\n\t\tif (base == 10)\n\t\t{\n\t\t\tresult = trio_log10(number);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = trio_log10(number) / trio_log10((double)base);\n\t\t}\n\t}\n\treturn result;\n}\n#endif /* TRIO_FEATURE_FLOAT */\n\n/*************************************************************************\n * TrioLogarithmBase\n */\n#if TRIO_FEATURE_FLOAT\nTRIO_PRIVATE double TrioLogarithmBase TRIO_ARGS1((base), int base)\n{\n\tswitch (base)\n\t{\n\t\tcase BASE_BINARY:\n\t\t\treturn 1.0;\n\t\tcase BASE_OCTAL:\n\t\t\treturn 3.0;\n\t\tcase BASE_DECIMAL:\n\t\t\treturn 3.321928094887362345;\n\t\tcase BASE_HEX:\n\t\t\treturn 4.0;\n\t\tdefault:\n\t\t\treturn TrioLogarithm((double)base, 2);\n\t}\n}\n#endif /* TRIO_FEATURE_FLOAT */\n\n/*************************************************************************\n * TrioParseQualifiers\n *\n * Description:\n *  Parse the qualifiers of a potential conversion specifier\n */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wimplicit-fallthrough\"\nTRIO_PRIVATE int TrioParseQualifiers TRIO_ARGS4((type, format, offset, parameter), int type,\n                                                TRIO_CONST char* format, int offset,\n                                                trio_parameter_t* parameter)\n{\n\tchar ch;\n\tint dots = 0; /* Count number of dots in modifier part */\n\tchar* tmpformat;\n\n\tparameter->beginOffset = offset - 1;\n\tparameter->flags = FLAGS_NEW;\n\tparameter->position = TrioGetPosition(format, &offset);\n\n\t/* Default values */\n\tparameter->width = NO_WIDTH;\n\tparameter->precision = NO_PRECISION;\n\tparameter->base = NO_BASE;\n\tparameter->varsize = NO_SIZE;\n\n\twhile (TrioIsQualifier(format[offset]))\n\t{\n\t\tch = format[offset++];\n\n\t\tswitch (ch)\n\t\t{\n\t\t\tcase QUALIFIER_SPACE:\n\t\t\t\tparameter->flags |= FLAGS_SPACE;\n\t\t\t\tbreak;\n\n\t\t\tcase QUALIFIER_PLUS:\n\t\t\t\tparameter->flags |= FLAGS_SHOWSIGN;\n\t\t\t\tbreak;\n\n\t\t\tcase QUALIFIER_MINUS:\n\t\t\t\tparameter->flags |= FLAGS_LEFTADJUST;\n\t\t\t\tparameter->flags &= ~FLAGS_NILPADDING;\n\t\t\t\tbreak;\n\n\t\t\tcase QUALIFIER_ALTERNATIVE:\n\t\t\t\tparameter->flags |= FLAGS_ALTERNATIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase QUALIFIER_DOT:\n\t\t\t\tif (dots == 0) /* Precision */\n\t\t\t\t{\n\t\t\t\t\tdots++;\n\n\t\t\t\t\t/* Skip if no precision */\n\t\t\t\t\tif (QUALIFIER_DOT == format[offset])\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t/* After the first dot we have the precision */\n\t\t\t\t\tparameter->flags |= FLAGS_PRECISION;\n\t\t\t\t\tif ((QUALIFIER_STAR == format[offset])\n#if defined(QUALIFIER_PARAM)\n\t\t\t\t\t    || (QUALIFIER_PARAM == format[offset])\n#endif\n\t\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t\tparameter->flags |= FLAGS_PRECISION_PARAMETER;\n\t\t\t\t\t\tparameter->precision = TrioGetPosition(format, &offset);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tparameter->precision =\n\t\t\t\t\t\t    trio_to_long(&format[offset], &tmpformat, BASE_DECIMAL);\n\t\t\t\t\t\toffset = (int)(tmpformat - format);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (dots == 1) /* Base */\n\t\t\t\t{\n\t\t\t\t\tdots++;\n\n\t\t\t\t\t/* After the second dot we have the base */\n\t\t\t\t\tparameter->flags |= FLAGS_BASE;\n\t\t\t\t\tif ((QUALIFIER_STAR == format[offset])\n#if defined(QUALIFIER_PARAM)\n\t\t\t\t\t    || (QUALIFIER_PARAM == format[offset])\n#endif\n\t\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t\tparameter->flags |= FLAGS_BASE_PARAMETER;\n\t\t\t\t\t\tparameter->base = TrioGetPosition(format, &offset);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tparameter->base = trio_to_long(&format[offset], &tmpformat, BASE_DECIMAL);\n\t\t\t\t\t\tif (parameter->base > MAX_BASE)\n\t\t\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t\t\t\t\toffset = (int)(tmpformat - format);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t\t\t}\n\t\t\t\tbreak; /* QUALIFIER_DOT */\n\n#if defined(QUALIFIER_PARAM)\n\t\t\tcase QUALIFIER_PARAM:\n\t\t\t\tparameter->type = TYPE_PRINT;\n\t\t\t\t/* FALLTHROUGH */\n#endif\n\t\t\tcase QUALIFIER_STAR:\n\t\t\t\t/* This has different meanings for print and scan */\n\t\t\t\tif (TYPE_PRINT == type)\n\t\t\t\t{\n\t\t\t\t\t/* Read with from parameter */\n\t\t\t\t\tint width = TrioGetPosition(format, &offset);\n\t\t\t\t\tparameter->flags |= (FLAGS_WIDTH | FLAGS_WIDTH_PARAMETER);\n\t\t\t\t\tif (NO_POSITION != width)\n\t\t\t\t\t\tparameter->width = width;\n\t\t\t\t\t/* else keep parameter->width = NO_WIDTH which != NO_POSITION */\n\t\t\t\t}\n#if TRIO_FEATURE_SCANF\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Scan, but do not store result */\n\t\t\t\t\tparameter->flags |= FLAGS_IGNORE;\n\t\t\t\t}\n#endif\n\t\t\t\tbreak; /* QUALIFIER_STAR */\n\n\t\t\tcase '0':\n\t\t\t\tif (!(parameter->flags & FLAGS_LEFTADJUST))\n\t\t\t\t\tparameter->flags |= FLAGS_NILPADDING;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\t\tparameter->flags |= FLAGS_WIDTH;\n\t\t\t\t/*\n\t\t\t\t * &format[offset - 1] is used to \"rewind\" the read\n\t\t\t\t * character from format\n\t\t\t\t */\n\t\t\t\tparameter->width = trio_to_long(&format[offset - 1], &tmpformat, BASE_DECIMAL);\n\t\t\t\toffset = (int)(tmpformat - format);\n\t\t\t\tbreak;\n\n\t\t\tcase QUALIFIER_SHORT:\n\t\t\t\tif (parameter->flags & FLAGS_SHORTSHORT)\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t\t\telse if (parameter->flags & FLAGS_SHORT)\n\t\t\t\t\tparameter->flags |= FLAGS_SHORTSHORT;\n\t\t\t\telse\n\t\t\t\t\tparameter->flags |= FLAGS_SHORT;\n\t\t\t\tbreak;\n\n\t\t\tcase QUALIFIER_LONG:\n\t\t\t\tif (parameter->flags & FLAGS_QUAD)\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t\t\telse if (parameter->flags & FLAGS_LONG)\n\t\t\t\t\tparameter->flags |= FLAGS_QUAD;\n\t\t\t\telse\n\t\t\t\t\tparameter->flags |= FLAGS_LONG;\n\t\t\t\tbreak;\n\n#if TRIO_FEATURE_LONGDOUBLE\n\t\t\tcase QUALIFIER_LONG_UPPER:\n\t\t\t\tparameter->flags |= FLAGS_LONGDOUBLE;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_SIZE_T\n\t\t\tcase QUALIFIER_SIZE_T:\n\t\t\t\tparameter->flags |= FLAGS_SIZE_T;\n\t\t\t\t/* Modify flags for later truncation of number */\n\t\t\t\tif (sizeof(size_t) == sizeof(trio_ulonglong_t))\n\t\t\t\t\tparameter->flags |= FLAGS_QUAD;\n\t\t\t\telse if (sizeof(size_t) == sizeof(long))\n\t\t\t\t\tparameter->flags |= FLAGS_LONG;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_PTRDIFF_T\n\t\t\tcase QUALIFIER_PTRDIFF_T:\n\t\t\t\tparameter->flags |= FLAGS_PTRDIFF_T;\n\t\t\t\tif (sizeof(ptrdiff_t) == sizeof(trio_ulonglong_t))\n\t\t\t\t\tparameter->flags |= FLAGS_QUAD;\n\t\t\t\telse if (sizeof(ptrdiff_t) == sizeof(long))\n\t\t\t\t\tparameter->flags |= FLAGS_LONG;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_INTMAX_T\n\t\t\tcase QUALIFIER_INTMAX_T:\n\t\t\t\tparameter->flags |= FLAGS_INTMAX_T;\n\t\t\t\tif (sizeof(trio_intmax_t) == sizeof(trio_ulonglong_t))\n\t\t\t\t\tparameter->flags |= FLAGS_QUAD;\n\t\t\t\telse if (sizeof(trio_intmax_t) == sizeof(long))\n\t\t\t\t\tparameter->flags |= FLAGS_LONG;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_QUAD\n\t\t\tcase QUALIFIER_QUAD:\n\t\t\t\tparameter->flags |= FLAGS_QUAD;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_FIXED_SIZE\n\t\t\tcase QUALIFIER_FIXED_SIZE:\n\t\t\t\tif (parameter->flags & FLAGS_FIXED_SIZE)\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\n\t\t\t\tif (parameter->flags &\n\t\t\t\t    (FLAGS_ALL_SIZES | FLAGS_LONGDOUBLE | FLAGS_WIDECHAR | FLAGS_VARSIZE_PARAMETER))\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\n\t\t\t\tif ((format[offset] == '6') && (format[offset + 1] == '4'))\n\t\t\t\t{\n\t\t\t\t\tparameter->varsize = sizeof(trio_int64_t);\n\t\t\t\t\toffset += 2;\n\t\t\t\t}\n\t\t\t\telse if ((format[offset] == '3') && (format[offset + 1] == '2'))\n\t\t\t\t{\n\t\t\t\t\tparameter->varsize = sizeof(trio_int32_t);\n\t\t\t\t\toffset += 2;\n\t\t\t\t}\n\t\t\t\telse if ((format[offset] == '1') && (format[offset + 1] == '6'))\n\t\t\t\t{\n\t\t\t\t\tparameter->varsize = sizeof(trio_int16_t);\n\t\t\t\t\toffset += 2;\n\t\t\t\t}\n\t\t\t\telse if (format[offset] == '8')\n\t\t\t\t{\n\t\t\t\t\tparameter->varsize = sizeof(trio_int8_t);\n\t\t\t\t\toffset++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\n\t\t\t\tparameter->flags |= FLAGS_FIXED_SIZE;\n\t\t\t\tbreak;\n#endif /* TRIO_FEATURE_FIXED_SIZE */\n\n#if defined(QUALIFIER_WIDECHAR)\n\t\t\tcase QUALIFIER_WIDECHAR:\n\t\t\t\tparameter->flags |= FLAGS_WIDECHAR;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_SIZE_T_UPPER\n\t\t\tcase QUALIFIER_SIZE_T_UPPER:\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_QUOTE\n\t\t\tcase QUALIFIER_QUOTE:\n\t\t\t\tparameter->flags |= FLAGS_QUOTE;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_STICKY\n\t\t\tcase QUALIFIER_STICKY:\n\t\t\t\tparameter->flags |= FLAGS_STICKY;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_VARSIZE\n\t\t\tcase QUALIFIER_VARSIZE:\n\t\t\t\tparameter->flags |= FLAGS_VARSIZE_PARAMETER;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_ROUNDING\n\t\t\tcase QUALIFIER_ROUNDING_UPPER:\n\t\t\t\tparameter->flags |= FLAGS_ROUNDING;\n\t\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\t/* Bail out completely to make the error more obvious */\n\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t}\n\n\t} /* while qualifier */\n\n\tparameter->endOffset = offset;\n\n\treturn 0;\n}\n#pragma GCC diagnostic pop\n\n/*************************************************************************\n * TrioParseSpecifier\n *\n * Description:\n *  Parse the specifier part of a potential conversion specifier\n */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wimplicit-fallthrough\"\nTRIO_PRIVATE int TrioParseSpecifier TRIO_ARGS4((type, format, offset, parameter), int type,\n                                               TRIO_CONST char* format, int offset,\n                                               trio_parameter_t* parameter)\n{\n\tparameter->baseSpecifier = NO_BASE;\n\n\tswitch (format[offset++])\n\t{\n#if defined(SPECIFIER_CHAR_UPPER)\n\t\tcase SPECIFIER_CHAR_UPPER:\n\t\t\tparameter->flags |= FLAGS_WIDECHAR;\n\t\t\t/* FALLTHROUGH */\n#endif\n\t\tcase SPECIFIER_CHAR:\n\t\t\tif (parameter->flags & FLAGS_LONG)\n\t\t\t\tparameter->flags |= FLAGS_WIDECHAR;\n\t\t\telse if (parameter->flags & FLAGS_SHORT)\n\t\t\t\tparameter->flags &= ~FLAGS_WIDECHAR;\n\t\t\tparameter->type = FORMAT_CHAR;\n\t\t\tbreak;\n\n#if defined(SPECIFIER_STRING_UPPER)\n\t\tcase SPECIFIER_STRING_UPPER:\n\t\t\tparameter->flags |= FLAGS_WIDECHAR;\n\t\t\t/* FALLTHROUGH */\n#endif\n\t\tcase SPECIFIER_STRING:\n\t\t\tif (parameter->flags & FLAGS_LONG)\n\t\t\t\tparameter->flags |= FLAGS_WIDECHAR;\n\t\t\telse if (parameter->flags & FLAGS_SHORT)\n\t\t\t\tparameter->flags &= ~FLAGS_WIDECHAR;\n\t\t\tparameter->type = FORMAT_STRING;\n\t\t\tbreak;\n\n#if defined(SPECIFIER_GROUP)\n\t\tcase SPECIFIER_GROUP:\n\t\t\tif (TYPE_SCAN == type)\n\t\t\t{\n\t\t\t\tint depth = 1;\n\t\t\t\tparameter->type = FORMAT_GROUP;\n\t\t\t\tif (format[offset] == QUALIFIER_CIRCUMFLEX)\n\t\t\t\t\toffset++;\n\t\t\t\tif (format[offset] == SPECIFIER_UNGROUP)\n\t\t\t\t\toffset++;\n\t\t\t\tif (format[offset] == QUALIFIER_MINUS)\n\t\t\t\t\toffset++;\n\t\t\t\t/* Skip nested brackets */\n\t\t\t\twhile (format[offset] != NIL)\n\t\t\t\t{\n\t\t\t\t\tif (format[offset] == SPECIFIER_GROUP)\n\t\t\t\t\t{\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (format[offset] == SPECIFIER_UNGROUP)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (--depth <= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toffset++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toffset++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif /* defined(SPECIFIER_GROUP) */\n\n\t\tcase SPECIFIER_INTEGER:\n\t\t\tparameter->type = FORMAT_INT;\n\t\t\tbreak;\n\n\t\tcase SPECIFIER_UNSIGNED:\n\t\t\tparameter->flags |= FLAGS_UNSIGNED;\n\t\t\tparameter->type = FORMAT_INT;\n\t\t\tbreak;\n\n\t\tcase SPECIFIER_DECIMAL:\n\t\t\tparameter->baseSpecifier = BASE_DECIMAL;\n\t\t\tparameter->type = FORMAT_INT;\n\t\t\tbreak;\n\n\t\tcase SPECIFIER_OCTAL:\n\t\t\tparameter->flags |= FLAGS_UNSIGNED;\n\t\t\tparameter->baseSpecifier = BASE_OCTAL;\n\t\t\tparameter->type = FORMAT_INT;\n\t\t\tbreak;\n\n#if TRIO_FEATURE_BINARY\n\t\tcase SPECIFIER_BINARY_UPPER:\n\t\t\tparameter->flags |= FLAGS_UPPER;\n\t\t\t/* FALLTHROUGH */\n\t\tcase SPECIFIER_BINARY:\n\t\t\tparameter->flags |= FLAGS_NILPADDING;\n\t\t\tparameter->baseSpecifier = BASE_BINARY;\n\t\t\tparameter->type = FORMAT_INT;\n\t\t\tbreak;\n#endif\n\n\t\tcase SPECIFIER_HEX_UPPER:\n\t\t\tparameter->flags |= FLAGS_UPPER;\n\t\t\t/* FALLTHROUGH */\n\t\tcase SPECIFIER_HEX:\n\t\t\tparameter->flags |= FLAGS_UNSIGNED;\n\t\t\tparameter->baseSpecifier = BASE_HEX;\n\t\t\tparameter->type = FORMAT_INT;\n\t\t\tbreak;\n\n#if defined(SPECIFIER_FLOAT_E)\n#if defined(SPECIFIER_FLOAT_E_UPPER)\n\t\tcase SPECIFIER_FLOAT_E_UPPER:\n\t\t\tparameter->flags |= FLAGS_UPPER;\n\t\t\t/* FALLTHROUGH */\n#endif\n\t\tcase SPECIFIER_FLOAT_E:\n\t\t\tparameter->flags |= FLAGS_FLOAT_E;\n\t\t\tparameter->type = FORMAT_DOUBLE;\n\t\t\tbreak;\n#endif\n\n#if defined(SPECIFIER_FLOAT_G)\n#if defined(SPECIFIER_FLOAT_G_UPPER)\n\t\tcase SPECIFIER_FLOAT_G_UPPER:\n\t\t\tparameter->flags |= FLAGS_UPPER;\n\t\t\t/* FALLTHROUGH */\n#endif\n\t\tcase SPECIFIER_FLOAT_G:\n\t\t\tparameter->flags |= FLAGS_FLOAT_G;\n\t\t\tparameter->type = FORMAT_DOUBLE;\n\t\t\tbreak;\n#endif\n\n#if defined(SPECIFIER_FLOAT_F)\n#if defined(SPECIFIER_FLOAT_F_UPPER)\n\t\tcase SPECIFIER_FLOAT_F_UPPER:\n\t\t\tparameter->flags |= FLAGS_UPPER;\n\t\t\t/* FALLTHROUGH */\n#endif\n\t\tcase SPECIFIER_FLOAT_F:\n\t\t\tparameter->type = FORMAT_DOUBLE;\n\t\t\tbreak;\n#endif\n\n#if defined(TRIO_COMPILER_VISUALC)\n#pragma warning(push)\n#pragma warning(disable : 4127) /* Conditional expression is constant */\n#endif\n\t\tcase SPECIFIER_POINTER:\n\t\t\tif (sizeof(trio_pointer_t) == sizeof(trio_ulonglong_t))\n\t\t\t\tparameter->flags |= FLAGS_QUAD;\n\t\t\telse if (sizeof(trio_pointer_t) == sizeof(long))\n\t\t\t\tparameter->flags |= FLAGS_LONG;\n\t\t\tparameter->type = FORMAT_POINTER;\n\t\t\tbreak;\n#if defined(TRIO_COMPILER_VISUALC)\n#pragma warning(pop)\n#endif\n\n\t\tcase SPECIFIER_COUNT:\n\t\t\tparameter->type = FORMAT_COUNT;\n\t\t\tbreak;\n\n#if TRIO_FEATURE_HEXFLOAT\n\t\tcase SPECIFIER_HEXFLOAT_UPPER:\n\t\t\tparameter->flags |= FLAGS_UPPER;\n\t\t\t/* FALLTHROUGH */\n\t\tcase SPECIFIER_HEXFLOAT:\n\t\t\tparameter->baseSpecifier = BASE_HEX;\n\t\t\tparameter->type = FORMAT_DOUBLE;\n\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_ERRNO\n\t\tcase SPECIFIER_ERRNO:\n\t\t\tparameter->type = FORMAT_ERRNO;\n\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_USER_DEFINED\n\t\tcase SPECIFIER_USER_DEFINED_BEGIN:\n\t\t{\n\t\t\tunsigned int max;\n\t\t\tint without_namespace = TRUE;\n\t\t\tchar* tmpformat = (char*)&format[offset];\n\t\t\tint ch;\n\n\t\t\tparameter->type = FORMAT_USER_DEFINED;\n\t\t\tparameter->user_defined.namespace[0] = NIL;\n\n\t\t\twhile ((ch = format[offset]) != NIL)\n\t\t\t{\n\t\t\t\toffset++;\n\t\t\t\tif ((ch == SPECIFIER_USER_DEFINED_END) || (ch == SPECIFIER_USER_DEFINED_EXTRA))\n\t\t\t\t{\n\t\t\t\t\tif (without_namespace)\n\t\t\t\t\t\t/* No namespace, handler will be passed as an argument */\n\t\t\t\t\t\tparameter->flags |= FLAGS_USER_DEFINED_PARAMETER;\n\n\t\t\t\t\t/* Copy the user data */\n\t\t\t\t\tmax = (unsigned int)(&format[offset] - tmpformat);\n\t\t\t\t\tif (max > MAX_USER_DATA)\n\t\t\t\t\t\tmax = MAX_USER_DATA;\n\t\t\t\t\ttrio_copy_max(parameter->user_data, max, tmpformat);\n\n\t\t\t\t\t/* Skip extra data (which is only there to keep the compiler happy) */\n\t\t\t\t\twhile ((ch != NIL) && (ch != SPECIFIER_USER_DEFINED_END))\n\t\t\t\t\t\tch = format[offset++];\n\n\t\t\t\t\tbreak; /* while */\n\t\t\t\t}\n\n\t\t\t\tif (ch == SPECIFIER_USER_DEFINED_SEPARATOR)\n\t\t\t\t{\n\t\t\t\t\twithout_namespace = FALSE;\n\t\t\t\t\t/* Copy the namespace for later looking-up */\n\t\t\t\t\tmax = (int)(&format[offset] - tmpformat);\n\t\t\t\t\tif (max > MAX_USER_NAME)\n\t\t\t\t\t\tmax = MAX_USER_NAME;\n\t\t\t\t\ttrio_copy_max(parameter->user_defined.namespace, max, tmpformat);\n\t\t\t\t\ttmpformat = (char*)&format[offset];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ch != SPECIFIER_USER_DEFINED_END)\n\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t}\n\t\tbreak;\n#endif /* TRIO_FEATURE_USER_DEFINED */\n\n\t\tdefault:\n\t\t\t/* Bail out completely to make the error more obvious */\n\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t}\n\n\tparameter->endOffset = offset;\n\n\treturn 0;\n}\n#pragma GCC diagnostic pop\n\n/*************************************************************************\n * TrioParse\n *\n * Description:\n *  Parse the format string\n */\nTRIO_PRIVATE int TrioParse TRIO_ARGS6((type, format, parameters, arglist, argfunc, argarray),\n                                      int type, TRIO_CONST char* format,\n                                      trio_parameter_t* parameters, va_list arglist,\n                                      trio_argfunc_t argfunc, trio_pointer_t* argarray)\n{\n\t/* Count the number of times a parameter is referenced */\n\tunsigned short usedEntries[MAX_PARAMETERS];\n\t/* Parameter counters */\n\tint parameterPosition;\n\tint maxParam = -1;\n\t/* Utility variables */\n\tint offset;           /* Offset into formatting string */\n\tBOOLEAN_T positional; /* Does the specifier have a positional? */\n#if TRIO_FEATURE_STICKY\n\tBOOLEAN_T gotSticky = FALSE; /* Are there any sticky modifiers at all? */\n#endif\n\t/*\n\t * indices specifies the order in which the parameters must be\n\t * read from the va_args (this is necessary to handle positionals)\n\t */\n\tint indices[MAX_PARAMETERS];\n\tint pos = 0;\n\t/* Various variables */\n#if defined(TRIO_COMPILER_SUPPORTS_MULTIBYTE)\n\tint charlen;\n#endif\n\tint save_errno;\n\tint i = -1;\n\tint num;\n\ttrio_parameter_t workParameter;\n\tint status;\n\n\t/* Both must be set or none must be set */\n\tassert(((argfunc == NULL) && (argarray == NULL)) || ((argfunc != NULL) && (argarray != NULL)));\n\n\t/*\n\t * The 'parameters' array is not initialized, but we need to\n\t * know which entries we have used.\n\t */\n\tmemset(usedEntries, 0, sizeof(usedEntries));\n\n\tsave_errno = errno;\n\toffset = 0;\n\tparameterPosition = 0;\n#if defined(TRIO_COMPILER_SUPPORTS_MULTIBYTE)\n\t(void)mblen(NULL, 0);\n#endif\n\n\twhile (format[offset])\n\t{\n\t\tTrioInitializeParameter(&workParameter);\n\n#if defined(TRIO_COMPILER_SUPPORTS_MULTIBYTE)\n\t\tif (!isascii(format[offset]))\n\t\t{\n\t\t\t/*\n\t\t\t * Multibyte characters cannot be legal specifiers or\n\t\t\t * modifiers, so we skip over them.\n\t\t\t */\n\t\t\tcharlen = mblen(&format[offset], MB_LEN_MAX);\n\t\t\toffset += (charlen > 0) ? charlen : 1;\n\t\t\tcontinue; /* while */\n\t\t}\n#endif /* TRIO_COMPILER_SUPPORTS_MULTIBYTE */\n\n\t\tswitch (format[offset++])\n\t\t{\n\n\t\t\tcase CHAR_IDENTIFIER:\n\t\t\t{\n\t\t\t\tif (CHAR_IDENTIFIER == format[offset])\n\t\t\t\t{\n\t\t\t\t\t/* skip double \"%\" */\n\t\t\t\t\toffset++;\n\t\t\t\t\tcontinue; /* while */\n\t\t\t\t}\n\n\t\t\t\tstatus = TrioParseQualifiers(type, format, offset, &workParameter);\n\t\t\t\tif (status < 0)\n\t\t\t\t\treturn status; /* Return qualifier syntax error */\n\n\t\t\t\tstatus = TrioParseSpecifier(type, format, workParameter.endOffset, &workParameter);\n\t\t\t\tif (status < 0)\n\t\t\t\t\treturn status; /* Return specifier syntax error */\n\t\t\t}\n\t\t\tbreak;\n\n#if TRIO_EXTENSION\n\t\t\tcase CHAR_ALT_IDENTIFIER:\n\t\t\t{\n\t\t\t\tstatus = TrioParseQualifiers(type, format, offset, &workParameter);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tcontinue; /* False alert, not a user defined specifier */\n\n\t\t\t\tstatus = TrioParseSpecifier(type, format, workParameter.endOffset, &workParameter);\n\t\t\t\tif ((status < 0) || (FORMAT_USER_DEFINED != workParameter.type))\n\t\t\t\t\tcontinue; /* False alert, not a user defined specifier */\n\t\t\t}\n\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\tcontinue; /* while */\n\t\t}\n\n\t\t/* now handle the parsed conversion specification */\n\t\tpositional = (NO_POSITION != workParameter.position);\n\n\t\t/*\n\t\t * Parameters only need the type and value. The value is\n\t\t * read later.\n\t\t */\n\t\tif (workParameter.flags & FLAGS_WIDTH_PARAMETER)\n\t\t{\n\t\t\tif (workParameter.width == NO_WIDTH)\n\t\t\t{\n\t\t\t\tworkParameter.width = parameterPosition++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!positional)\n\t\t\t\t\tworkParameter.position = workParameter.width + 1;\n\t\t\t}\n\n\t\t\tusedEntries[workParameter.width] += 1;\n\t\t\tif (workParameter.width > maxParam)\n\t\t\t\tmaxParam = workParameter.width;\n\t\t\tparameters[pos].type = FORMAT_PARAMETER;\n\t\t\tparameters[pos].flags = 0;\n\t\t\tindices[workParameter.width] = pos;\n\t\t\tworkParameter.width = pos++;\n\t\t}\n\t\tif (workParameter.flags & FLAGS_PRECISION_PARAMETER)\n\t\t{\n\t\t\tif (workParameter.precision == NO_PRECISION)\n\t\t\t{\n\t\t\t\tworkParameter.precision = parameterPosition++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!positional)\n\t\t\t\t\tworkParameter.position = workParameter.precision + 1;\n\t\t\t}\n\n\t\t\tusedEntries[workParameter.precision] += 1;\n\t\t\tif (workParameter.precision > maxParam)\n\t\t\t\tmaxParam = workParameter.precision;\n\t\t\tparameters[pos].type = FORMAT_PARAMETER;\n\t\t\tparameters[pos].flags = 0;\n\t\t\tindices[workParameter.precision] = pos;\n\t\t\tworkParameter.precision = pos++;\n\t\t}\n\t\tif (workParameter.flags & FLAGS_BASE_PARAMETER)\n\t\t{\n\t\t\tif (workParameter.base == NO_BASE)\n\t\t\t{\n\t\t\t\tworkParameter.base = parameterPosition++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!positional)\n\t\t\t\t\tworkParameter.position = workParameter.base + 1;\n\t\t\t}\n\n\t\t\tusedEntries[workParameter.base] += 1;\n\t\t\tif (workParameter.base > maxParam)\n\t\t\t\tmaxParam = workParameter.base;\n\t\t\tparameters[pos].type = FORMAT_PARAMETER;\n\t\t\tparameters[pos].flags = 0;\n\t\t\tindices[workParameter.base] = pos;\n\t\t\tworkParameter.base = pos++;\n\t\t}\n#if TRIO_FEATURE_VARSIZE\n\t\tif (workParameter.flags & FLAGS_VARSIZE_PARAMETER)\n\t\t{\n\t\t\tworkParameter.varsize = parameterPosition++;\n\n\t\t\tusedEntries[workParameter.varsize] += 1;\n\t\t\tif (workParameter.varsize > maxParam)\n\t\t\t\tmaxParam = workParameter.varsize;\n\t\t\tparameters[pos].type = FORMAT_PARAMETER;\n\t\t\tparameters[pos].flags = 0;\n\t\t\tindices[workParameter.varsize] = pos;\n\t\t\tworkParameter.varsize = pos++;\n\t\t}\n#endif\n#if TRIO_FEATURE_USER_DEFINED\n\t\tif (workParameter.flags & FLAGS_USER_DEFINED_PARAMETER)\n\t\t{\n\t\t\tworkParameter.user_defined.handler = parameterPosition++;\n\n\t\t\tusedEntries[workParameter.user_defined.handler] += 1;\n\t\t\tif (workParameter.user_defined.handler > maxParam)\n\t\t\t\tmaxParam = workParameter.user_defined.handler;\n\t\t\tparameters[pos].type = FORMAT_PARAMETER;\n\t\t\tparameters[pos].flags = FLAGS_USER_DEFINED;\n\t\t\tindices[workParameter.user_defined.handler] = pos;\n\t\t\tworkParameter.user_defined.handler = pos++;\n\t\t}\n#endif\n\n\t\tif (NO_POSITION == workParameter.position)\n\t\t{\n\t\t\tworkParameter.position = parameterPosition++;\n\t\t}\n\n\t\tif (workParameter.position > maxParam)\n\t\t\tmaxParam = workParameter.position;\n\n\t\tif (workParameter.position >= MAX_PARAMETERS)\n\t\t{\n\t\t\t/* Bail out completely to make the error more obvious */\n\t\t\treturn TRIO_ERROR_RETURN(TRIO_ETOOMANY, offset);\n\t\t}\n\n\t\tindices[workParameter.position] = pos;\n\n\t\t/*  Count the number of times this entry has been used */\n\t\tusedEntries[workParameter.position] += 1;\n\n\t\t/* Find last sticky parameters */\n#if TRIO_FEATURE_STICKY\n\t\tif (workParameter.flags & FLAGS_STICKY)\n\t\t{\n\t\t\tgotSticky = TRUE;\n\t\t}\n\t\telse if (gotSticky)\n\t\t{\n\t\t\tfor (i = pos - 1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tif (parameters[i].type == FORMAT_PARAMETER)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((parameters[i].flags & FLAGS_STICKY) &&\n\t\t\t\t    (parameters[i].type == workParameter.type))\n\t\t\t\t{\n\t\t\t\t\t/* Do not overwrite current qualifiers */\n\t\t\t\t\tworkParameter.flags |= (parameters[i].flags & (unsigned long)~FLAGS_STICKY);\n\t\t\t\t\tif (workParameter.width == NO_WIDTH)\n\t\t\t\t\t\tworkParameter.width = parameters[i].width;\n\t\t\t\t\tif (workParameter.precision == NO_PRECISION)\n\t\t\t\t\t\tworkParameter.precision = parameters[i].precision;\n\t\t\t\t\tif (workParameter.base == NO_BASE)\n\t\t\t\t\t\tworkParameter.base = parameters[i].base;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\n\t\tif (workParameter.base == NO_BASE)\n\t\t\tworkParameter.base = BASE_DECIMAL;\n\n\t\toffset = workParameter.endOffset;\n\n\t\tTrioCopyParameter(&parameters[pos++], &workParameter);\n\t} /* while format characters left */\n\n\tparameters[pos].type = FORMAT_SENTINEL; /* end parameter array with sentinel */\n\tparameters[pos].beginOffset = offset;\n\n\tfor (num = 0; num <= maxParam; num++)\n\t{\n\t\tif (usedEntries[num] != 1)\n\t\t{\n\t\t\tif (usedEntries[num] == 0) /* gap detected */\n\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EGAP, num);\n\t\t\telse /* double references detected */\n\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EDBLREF, num);\n\t\t}\n\n\t\ti = indices[num];\n\n\t\t/*\n\t\t * FORMAT_PARAMETERS are only present if they must be read,\n\t\t * so it makes no sense to check the ignore flag (besides,\n\t\t * the flags variable is not set for that particular type)\n\t\t */\n\t\tif ((parameters[i].type != FORMAT_PARAMETER) && (parameters[i].flags & FLAGS_IGNORE))\n\t\t\tcontinue; /* for all arguments */\n\n\t\t/*\n\t\t * The stack arguments are read according to ANSI C89\n\t\t * default argument promotions:\n\t\t *\n\t\t *  char           = int\n\t\t *  short          = int\n\t\t *  unsigned char  = unsigned int\n\t\t *  unsigned short = unsigned int\n\t\t *  float          = double\n\t\t *\n\t\t * In addition to the ANSI C89 these types are read (the\n\t\t * default argument promotions of C99 has not been\n\t\t * considered yet)\n\t\t *\n\t\t *  long long\n\t\t *  long double\n\t\t *  size_t\n\t\t *  ptrdiff_t\n\t\t *  intmax_t\n\t\t */\n\t\tswitch (parameters[i].type)\n\t\t{\n\t\t\tcase FORMAT_GROUP:\n\t\t\tcase FORMAT_STRING:\n#if TRIO_FEATURE_WIDECHAR\n\t\t\t\tif (parameters[i].flags & FLAGS_WIDECHAR)\n\t\t\t\t{\n\t\t\t\t\tparameters[i].data.wstring =\n\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t        ? va_arg(arglist, trio_wchar_t*)\n\t\t\t\t\t        : (trio_wchar_t*)(argfunc(argarray, num, TRIO_TYPE_PWCHAR));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tparameters[i].data.string =\n\t\t\t\t\t    (argfunc == NULL) ? va_arg(arglist, char*)\n\t\t\t\t\t                      : (char*)(argfunc(argarray, num, TRIO_TYPE_PCHAR));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n#if TRIO_FEATURE_USER_DEFINED\n\t\t\tcase FORMAT_USER_DEFINED:\n#endif\n\t\t\tcase FORMAT_POINTER:\n\t\t\tcase FORMAT_COUNT:\n\t\t\tcase FORMAT_UNKNOWN:\n\t\t\t\tparameters[i].data.pointer = (argfunc == NULL)\n\t\t\t\t                                 ? va_arg(arglist, trio_pointer_t)\n\t\t\t\t                                 : argfunc(argarray, num, TRIO_TYPE_POINTER);\n\t\t\t\tbreak;\n\n\t\t\tcase FORMAT_CHAR:\n\t\t\tcase FORMAT_INT:\n#if TRIO_FEATURE_SCANF\n\t\t\t\tif (TYPE_SCAN == type)\n\t\t\t\t{\n\t\t\t\t\tif (argfunc == NULL)\n\t\t\t\t\t\tparameters[i].data.pointer =\n\t\t\t\t\t\t    (trio_pointer_t)va_arg(arglist, trio_pointer_t);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (parameters[i].type == FORMAT_CHAR)\n\t\t\t\t\t\t\tparameters[i].data.pointer =\n\t\t\t\t\t\t\t    (trio_pointer_t)((char*)argfunc(argarray, num, TRIO_TYPE_CHAR));\n\t\t\t\t\t\telse if (parameters[i].flags & FLAGS_SHORT)\n\t\t\t\t\t\t\tparameters[i].data.pointer =\n\t\t\t\t\t\t\t    (trio_pointer_t)((short*)argfunc(argarray, num, TRIO_TYPE_SHORT));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tparameters[i].data.pointer =\n\t\t\t\t\t\t\t    (trio_pointer_t)((int*)argfunc(argarray, num, TRIO_TYPE_INT));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n#endif /* TRIO_FEATURE_SCANF */\n\t\t\t\t{\n#if TRIO_FEATURE_VARSIZE || TRIO_FEATURE_FIXED_SIZE\n\t\t\t\t\tif (parameters[i].flags & (FLAGS_VARSIZE_PARAMETER | FLAGS_FIXED_SIZE))\n\t\t\t\t\t{\n\t\t\t\t\t\tint varsize;\n\t\t\t\t\t\tif (parameters[i].flags & FLAGS_VARSIZE_PARAMETER)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Variable sizes are mapped onto the fixed sizes, in\n\t\t\t\t\t\t\t * accordance with integer promotion.\n\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t * Please note that this may not be portable, as we\n\t\t\t\t\t\t\t * only guess the size, not the layout of the numbers.\n\t\t\t\t\t\t\t * For example, if int is little-endian, and long is\n\t\t\t\t\t\t\t * big-endian, then this will fail.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tvarsize =\n\t\t\t\t\t\t\t    (int)parameters[parameters[i].varsize].data.number.as_unsigned;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Used for the I<bits> modifiers */\n\t\t\t\t\t\t\tvarsize = parameters[i].varsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparameters[i].flags &= ~FLAGS_ALL_VARSIZES;\n\n\t\t\t\t\t\tif (varsize <= (int)sizeof(int))\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\telse if (varsize <= (int)sizeof(long))\n\t\t\t\t\t\t\tparameters[i].flags |= FLAGS_LONG;\n#if TRIO_FEATURE_INTMAX_T\n\t\t\t\t\t\telse if (varsize <= (int)sizeof(trio_longlong_t))\n\t\t\t\t\t\t\tparameters[i].flags |= FLAGS_QUAD;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tparameters[i].flags |= FLAGS_INTMAX_T;\n#else\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tparameters[i].flags |= FLAGS_QUAD;\n#endif\n\t\t\t\t\t}\n#endif /* TRIO_FEATURE_VARSIZE */\n#if TRIO_FEATURE_SIZE_T || TRIO_FEATURE_SIZE_T_UPPER\n\t\t\t\t\tif (parameters[i].flags & FLAGS_SIZE_T)\n\t\t\t\t\t\tparameters[i].data.number.as_unsigned =\n\t\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t\t        ? (trio_uintmax_t)va_arg(arglist, size_t)\n\t\t\t\t\t\t        : (trio_uintmax_t)(\n\t\t\t\t\t\t              *((size_t*)argfunc(argarray, num, TRIO_TYPE_SIZE)));\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_PTRDIFF_T\n\t\t\t\t\t    if (parameters[i].flags & FLAGS_PTRDIFF_T)\n\t\t\t\t\t\tparameters[i].data.number.as_unsigned =\n\t\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t\t        ? (trio_uintmax_t)va_arg(arglist, ptrdiff_t)\n\t\t\t\t\t\t        : (trio_uintmax_t)(\n\t\t\t\t\t\t              *((ptrdiff_t*)argfunc(argarray, num, TRIO_TYPE_PTRDIFF)));\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_INTMAX_T\n\t\t\t\t\t    if (parameters[i].flags & FLAGS_INTMAX_T)\n\t\t\t\t\t\tparameters[i].data.number.as_unsigned =\n\t\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t\t        ? (trio_uintmax_t)va_arg(arglist, trio_intmax_t)\n\t\t\t\t\t\t        : (trio_uintmax_t)(\n\t\t\t\t\t\t              *((trio_intmax_t*)argfunc(argarray, num, TRIO_TYPE_UINTMAX)));\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t    if (parameters[i].flags & FLAGS_QUAD)\n\t\t\t\t\t\tparameters[i].data.number.as_unsigned =\n\t\t\t\t\t\t    (argfunc == NULL) ? (trio_uintmax_t)va_arg(arglist, trio_ulonglong_t)\n\t\t\t\t\t\t                      : (trio_uintmax_t)(*((trio_ulonglong_t*)argfunc(\n\t\t\t\t\t\t                            argarray, num, TRIO_TYPE_ULONGLONG)));\n\t\t\t\t\telse if (parameters[i].flags & FLAGS_LONG)\n\t\t\t\t\t\tparameters[i].data.number.as_unsigned =\n\t\t\t\t\t\t    (argfunc == NULL) ? (trio_uintmax_t)va_arg(arglist, long)\n\t\t\t\t\t\t                      : (trio_uintmax_t)(*(\n\t\t\t\t\t\t                            (long*)argfunc(argarray, num, TRIO_TYPE_LONG)));\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (argfunc == NULL)\n\t\t\t\t\t\t\tparameters[i].data.number.as_unsigned =\n\t\t\t\t\t\t\t    (trio_uintmax_t)va_arg(arglist, int);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (parameters[i].type == FORMAT_CHAR)\n\t\t\t\t\t\t\t\tparameters[i].data.number.as_unsigned = (trio_uintmax_t)(\n\t\t\t\t\t\t\t\t    *((char*)argfunc(argarray, num, TRIO_TYPE_CHAR)));\n\t\t\t\t\t\t\telse if (parameters[i].flags & FLAGS_SHORT)\n\t\t\t\t\t\t\t\tparameters[i].data.number.as_unsigned = (trio_uintmax_t)(\n\t\t\t\t\t\t\t\t    *((short*)argfunc(argarray, num, TRIO_TYPE_SHORT)));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tparameters[i].data.number.as_unsigned = (trio_uintmax_t)(\n\t\t\t\t\t\t\t\t    *((int*)argfunc(argarray, num, TRIO_TYPE_INT)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase FORMAT_PARAMETER:\n\t\t\t\t/*\n\t\t\t\t * The parameter for the user-defined specifier is a pointer,\n\t\t\t\t * whereas the rest (width, precision, base) uses an integer.\n\t\t\t\t */\n\t\t\t\tif (parameters[i].flags & FLAGS_USER_DEFINED)\n\t\t\t\t\tparameters[i].data.pointer = (argfunc == NULL)\n\t\t\t\t\t                                 ? va_arg(arglist, trio_pointer_t)\n\t\t\t\t\t                                 : argfunc(argarray, num, TRIO_TYPE_POINTER);\n\t\t\t\telse\n\t\t\t\t\tparameters[i].data.number.as_unsigned =\n\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t        ? (trio_uintmax_t)va_arg(arglist, int)\n\t\t\t\t\t        : (trio_uintmax_t)(*((int*)argfunc(argarray, num, TRIO_TYPE_INT)));\n\t\t\t\tbreak;\n\n#if TRIO_FEATURE_FLOAT\n\t\t\tcase FORMAT_DOUBLE:\n#if TRIO_FEATURE_SCANF\n\t\t\t\tif (TYPE_SCAN == type)\n\t\t\t\t{\n\t\t\t\t\tif (parameters[i].flags & FLAGS_LONGDOUBLE)\n\t\t\t\t\t\tparameters[i].data.longdoublePointer =\n\t\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t\t        ? va_arg(arglist, trio_long_double_t*)\n\t\t\t\t\t\t        : (trio_long_double_t*)argfunc(argarray, num, TRIO_TYPE_LONGDOUBLE);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (parameters[i].flags & FLAGS_LONG)\n\t\t\t\t\t\t\tparameters[i].data.doublePointer =\n\t\t\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t\t\t        ? va_arg(arglist, double*)\n\t\t\t\t\t\t\t        : (double*)argfunc(argarray, num, TRIO_TYPE_DOUBLE);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tparameters[i].data.doublePointer =\n\t\t\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t\t\t        ? (double*)va_arg(arglist, float*)\n\t\t\t\t\t\t\t        : (double*)argfunc(argarray, num, TRIO_TYPE_DOUBLE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n#endif /* TRIO_FEATURE_SCANF */\n\t\t\t\t{\n\t\t\t\t\tif (parameters[i].flags & FLAGS_LONGDOUBLE)\n\t\t\t\t\t\tparameters[i].data.longdoubleNumber =\n\t\t\t\t\t\t    (argfunc == NULL) ? va_arg(arglist, trio_long_double_t)\n\t\t\t\t\t\t                      : (trio_long_double_t)(*((trio_long_double_t*)argfunc(\n\t\t\t\t\t\t                            argarray, num, TRIO_TYPE_LONGDOUBLE)));\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (argfunc == NULL)\n\t\t\t\t\t\t\tparameters[i].data.longdoubleNumber =\n\t\t\t\t\t\t\t    (trio_long_double_t)va_arg(arglist, double);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (parameters[i].flags & FLAGS_SHORT)\n\t\t\t\t\t\t\t\tparameters[i].data.longdoubleNumber = (trio_long_double_t)(\n\t\t\t\t\t\t\t\t    *((float*)argfunc(argarray, num, TRIO_TYPE_FLOAT)));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tparameters[i].data.longdoubleNumber = (trio_long_double_t)(\n\t\t\t\t\t\t\t\t    *((double*)argfunc(argarray, num, TRIO_TYPE_DOUBLE)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif /* TRIO_FEATURE_FLOAT */\n\n#if TRIO_FEATURE_ERRNO\n\t\t\tcase FORMAT_ERRNO:\n\t\t\t\tparameters[i].data.errorNumber = save_errno;\n\t\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t} /* for all specifiers */\n\treturn num;\n}\n\n/*************************************************************************\n *\n * FORMATTING\n *\n ************************************************************************/\n\n/*************************************************************************\n * TrioWriteNumber\n *\n * Description:\n *  Output a number.\n *  The complexity of this function is a result of the complexity\n *  of the dependencies of the flags.\n */\nTRIO_PRIVATE void TrioWriteNumber TRIO_ARGS6((self, number, flags, width, precision, base),\n                                             trio_class_t* self, trio_uintmax_t number,\n                                             trio_flags_t flags, int width, int precision, int base)\n{\n\tBOOLEAN_T isNegative;\n\tBOOLEAN_T isNumberZero;\n\tBOOLEAN_T isPrecisionZero;\n\tBOOLEAN_T ignoreNumber;\n\tchar buffer[MAX_CHARS_IN(trio_uintmax_t) * (1 + MAX_LOCALE_SEPARATOR_LENGTH) + 1];\n\tchar* bufferend;\n\tchar* pointer;\n\tTRIO_CONST char* digits;\n\tint i;\n#if TRIO_FEATURE_QUOTE\n\tint length;\n\tchar* p;\n#endif\n\tint count;\n\tint digitOffset;\n\n\tassert(VALID(self));\n\tassert(VALID(self->OutStream));\n\tassert(((base >= MIN_BASE) && (base <= MAX_BASE)) || (base == NO_BASE));\n\n\tdigits = (flags & FLAGS_UPPER) ? internalDigitsUpper : internalDigitsLower;\n\tif (base == NO_BASE)\n\t\tbase = BASE_DECIMAL;\n\n\tisNumberZero = (number == 0);\n\tisPrecisionZero = (precision == 0);\n\tignoreNumber =\n\t    (isNumberZero && isPrecisionZero && !((flags & FLAGS_ALTERNATIVE) && (base == BASE_OCTAL)));\n\n\tif (flags & FLAGS_UNSIGNED)\n\t{\n\t\tisNegative = FALSE;\n\t\tflags &= ~FLAGS_SHOWSIGN;\n\t}\n\telse\n\t{\n\t\tisNegative = ((trio_intmax_t)number < 0);\n\t\tif (isNegative)\n\t\t\tnumber = -((trio_intmax_t)number);\n\t}\n\n\tif (flags & FLAGS_QUAD)\n\t\tnumber &= (trio_ulonglong_t)-1;\n\telse if (flags & FLAGS_LONG)\n\t\tnumber &= (unsigned long)-1;\n\telse\n\t\tnumber &= (unsigned int)-1;\n\n\t/* Build number */\n\tpointer = bufferend = &buffer[sizeof(buffer) - 1];\n\t*pointer-- = NIL;\n\tfor (i = 1; i < (int)sizeof(buffer); i++)\n\t{\n\t\tdigitOffset = number % base;\n\t\t*pointer-- = digits[digitOffset];\n\t\tnumber /= base;\n\t\tif (number == 0)\n\t\t\tbreak;\n\n#if TRIO_FEATURE_QUOTE\n\t\tif ((flags & FLAGS_QUOTE) && TrioFollowedBySeparator(i + 1))\n\t\t{\n\t\t\t/*\n\t\t\t * We are building the number from the least significant\n\t\t\t * to the most significant digit, so we have to copy the\n\t\t\t * thousand separator backwards\n\t\t\t */\n\t\t\tlength = internalThousandSeparatorLength;\n\t\t\tif (((int)(pointer - buffer) - length) > 0)\n\t\t\t{\n\t\t\t\tp = &internalThousandSeparator[length - 1];\n\t\t\t\twhile (length-- > 0)\n\t\t\t\t\t*pointer-- = *p--;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tif (!ignoreNumber)\n\t{\n\t\t/* Adjust width */\n\t\twidth -= (bufferend - pointer) - 1;\n\t}\n\n\t/* Adjust precision */\n\tif (NO_PRECISION != precision)\n\t{\n\t\tprecision -= (bufferend - pointer) - 1;\n\t\tif (precision < 0)\n\t\t\tprecision = 0;\n\t\tflags |= FLAGS_NILPADDING;\n\t}\n\n\t/* Calculate padding */\n\tcount = (!((flags & FLAGS_LEFTADJUST) || (precision == NO_PRECISION))) ? precision : 0;\n\n\t/* Adjust width further */\n\tif (isNegative || (flags & FLAGS_SHOWSIGN) || (flags & FLAGS_SPACE))\n\t\twidth--;\n\tif ((flags & FLAGS_ALTERNATIVE) && !isNumberZero)\n\t{\n\t\tswitch (base)\n\t\t{\n\t\t\tcase BASE_BINARY:\n\t\t\tcase BASE_HEX:\n\t\t\t\twidth -= 2;\n\t\t\t\tbreak;\n\t\t\tcase BASE_OCTAL:\n\t\t\t\tif (!(flags & FLAGS_NILPADDING) || (count == 0))\n\t\t\t\t\twidth--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Output prefixes spaces if needed */\n\tif (!((flags & FLAGS_LEFTADJUST) ||\n\t      ((flags & FLAGS_NILPADDING) && (precision == NO_PRECISION))))\n\t{\n\t\twhile (width-- > count)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n\n\t/* width has been adjusted for signs and alternatives */\n\tif (isNegative)\n\t\tself->OutStream(self, '-');\n\telse if (flags & FLAGS_SHOWSIGN)\n\t\tself->OutStream(self, '+');\n\telse if (flags & FLAGS_SPACE)\n\t\tself->OutStream(self, ' ');\n\n\t/* Prefix is not written when the value is zero */\n\tif ((flags & FLAGS_ALTERNATIVE) && !isNumberZero)\n\t{\n\t\tswitch (base)\n\t\t{\n\t\t\tcase BASE_BINARY:\n\t\t\t\tself->OutStream(self, '0');\n\t\t\t\tself->OutStream(self, (flags & FLAGS_UPPER) ? 'B' : 'b');\n\t\t\t\tbreak;\n\n\t\t\tcase BASE_OCTAL:\n\t\t\t\tif (!(flags & FLAGS_NILPADDING) || (count == 0))\n\t\t\t\t\tself->OutStream(self, '0');\n\t\t\t\tbreak;\n\n\t\t\tcase BASE_HEX:\n\t\t\t\tself->OutStream(self, '0');\n\t\t\t\tself->OutStream(self, (flags & FLAGS_UPPER) ? 'X' : 'x');\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t} /* switch base */\n\t}\n\n\t/* Output prefixed zero padding if needed */\n\tif (flags & FLAGS_NILPADDING)\n\t{\n\t\tif (precision == NO_PRECISION)\n\t\t\tprecision = width;\n\t\twhile (precision-- > 0)\n\t\t{\n\t\t\tself->OutStream(self, '0');\n\t\t\twidth--;\n\t\t}\n\t}\n\n\tif (!ignoreNumber)\n\t{\n\t\t/* Output the number itself */\n\t\twhile (*(++pointer))\n\t\t{\n\t\t\tself->OutStream(self, *pointer);\n\t\t}\n\t}\n\n\t/* Output trailing spaces if needed */\n\tif (flags & FLAGS_LEFTADJUST)\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n}\n\n/*************************************************************************\n * TrioWriteStringCharacter\n *\n * Description:\n *  Output a single character of a string\n */\nTRIO_PRIVATE void TrioWriteStringCharacter TRIO_ARGS3((self, ch, flags), trio_class_t* self, int ch,\n                                                      trio_flags_t flags)\n{\n\tif (flags & FLAGS_ALTERNATIVE)\n\t{\n\t\tif (!isprint(ch))\n\t\t{\n\t\t\t/*\n\t\t\t * Non-printable characters are converted to C escapes or\n\t\t\t * \\number, if no C escape exists.\n\t\t\t */\n\t\t\tself->OutStream(self, CHAR_BACKSLASH);\n\t\t\tswitch (ch)\n\t\t\t{\n\t\t\t\tcase '\\007':\n\t\t\t\t\tself->OutStream(self, 'a');\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\b':\n\t\t\t\t\tself->OutStream(self, 'b');\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\f':\n\t\t\t\t\tself->OutStream(self, 'f');\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\n':\n\t\t\t\t\tself->OutStream(self, 'n');\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\r':\n\t\t\t\t\tself->OutStream(self, 'r');\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\t':\n\t\t\t\t\tself->OutStream(self, 't');\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\v':\n\t\t\t\t\tself->OutStream(self, 'v');\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tself->OutStream(self, '\\\\');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tself->OutStream(self, 'x');\n\t\t\t\t\tTrioWriteNumber(self, (trio_uintmax_t)ch, FLAGS_UNSIGNED | FLAGS_NILPADDING, 2,\n\t\t\t\t\t                2, BASE_HEX);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (ch == CHAR_BACKSLASH)\n\t\t{\n\t\t\tself->OutStream(self, CHAR_BACKSLASH);\n\t\t\tself->OutStream(self, CHAR_BACKSLASH);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself->OutStream(self, ch);\n\t\t}\n\t}\n\telse\n\t{\n\t\tself->OutStream(self, ch);\n\t}\n}\n\n/*************************************************************************\n * TrioWriteString\n *\n * Description:\n *  Output a string\n */\nTRIO_PRIVATE void TrioWriteString TRIO_ARGS5((self, string, flags, width, precision),\n                                             trio_class_t* self, TRIO_CONST char* string,\n                                             trio_flags_t flags, int width, int precision)\n{\n\tint length;\n\tint ch;\n\n\tassert(VALID(self));\n\tassert(VALID(self->OutStream));\n\n\tif (string == NULL)\n\t{\n\t\tstring = internalNullString;\n\t\tlength = sizeof(internalNullString) - 1;\n#if TRIO_FEATURE_QUOTE\n\t\t/* Disable quoting for the null pointer */\n\t\tflags &= (~FLAGS_QUOTE);\n#endif\n\t\twidth = 0;\n\t}\n\telse\n\t{\n\t\tif (precision == 0)\n\t\t{\n\t\t\tlength = trio_length(string);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlength = trio_length_max(string, precision);\n\t\t}\n\t}\n\tif ((NO_PRECISION != precision) && (precision < length))\n\t{\n\t\tlength = precision;\n\t}\n\twidth -= length;\n\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n\n\tif (!(flags & FLAGS_LEFTADJUST))\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n\n\twhile (length-- > 0)\n\t{\n\t\t/* The ctype parameters must be an unsigned char (or EOF) */\n\t\tch = (int)((unsigned char)(*string++));\n\t\tTrioWriteStringCharacter(self, ch, flags);\n\t}\n\n\tif (flags & FLAGS_LEFTADJUST)\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n}\n\n/*************************************************************************\n * TrioWriteWideStringCharacter\n *\n * Description:\n *  Output a wide string as a multi-byte sequence\n */\n#if TRIO_FEATURE_WIDECHAR\nTRIO_PRIVATE int TrioWriteWideStringCharacter TRIO_ARGS4((self, wch, flags, width),\n                                                         trio_class_t* self, trio_wchar_t wch,\n                                                         trio_flags_t flags, int width)\n{\n\tint size;\n\tint i;\n\tint ch;\n\tchar* string;\n\tchar buffer[MB_LEN_MAX + 1];\n\n\tif (width == NO_WIDTH)\n\t\twidth = sizeof(buffer);\n\n\tsize = wctomb(buffer, wch);\n\tif ((size <= 0) || (size > width) || (buffer[0] == NIL))\n\t\treturn 0;\n\n\tstring = buffer;\n\ti = size;\n\twhile ((width >= i) && (width-- > 0) && (i-- > 0))\n\t{\n\t\t/* The ctype parameters must be an unsigned char (or EOF) */\n\t\tch = (int)((unsigned char)(*string++));\n\t\tTrioWriteStringCharacter(self, ch, flags);\n\t}\n\treturn size;\n}\n#endif /* TRIO_FEATURE_WIDECHAR */\n\n/*************************************************************************\n * TrioWriteWideString\n *\n * Description:\n *  Output a wide character string as a multi-byte string\n */\n#if TRIO_FEATURE_WIDECHAR\nTRIO_PRIVATE void TrioWriteWideString TRIO_ARGS5((self, wstring, flags, width, precision),\n                                                 trio_class_t* self,\n                                                 TRIO_CONST trio_wchar_t* wstring,\n                                                 trio_flags_t flags, int width, int precision)\n{\n\tint length;\n\tint size;\n\n\tassert(VALID(self));\n\tassert(VALID(self->OutStream));\n\n#if defined(TRIO_COMPILER_SUPPORTS_MULTIBYTE)\n\t/* Required by TrioWriteWideStringCharacter */\n\t(void)mblen(NULL, 0);\n#endif\n\n\tif (wstring == NULL)\n\t{\n\t\tTrioWriteString(self, NULL, flags, width, precision);\n\t\treturn;\n\t}\n\n\tif (NO_PRECISION == precision)\n\t{\n\t\tlength = INT_MAX;\n\t}\n\telse\n\t{\n\t\tlength = precision;\n\t\twidth -= length;\n\t}\n\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n\n\tif (!(flags & FLAGS_LEFTADJUST))\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n\n\twhile (length > 0)\n\t{\n\t\tsize = TrioWriteWideStringCharacter(self, *wstring++, flags, length);\n\t\tif (size == 0)\n\t\t\tbreak; /* while */\n\t\tlength -= size;\n\t}\n\n\tif (flags & FLAGS_LEFTADJUST)\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n}\n#endif /* TRIO_FEATURE_WIDECHAR */\n\n/*************************************************************************\n * TrioWriteDouble\n *\n * http://wwwold.dkuug.dk/JTC1/SC22/WG14/www/docs/dr_211.htm\n *\n * \"5.2.4.2.2 paragraph #4\n *\n *  The accuracy [...] is implementation defined, as is the accuracy\n *  of the conversion between floating-point internal representations\n *  and string representations performed by the libray routine in\n *  <stdio.h>\"\n */\n/* FIXME: handle all instances of constant long-double number (L)\n *   and *l() math functions.\n */\n#if TRIO_FEATURE_FLOAT\nTRIO_PRIVATE void TrioWriteDouble TRIO_ARGS6((self, number, flags, width, precision, base),\n                                             trio_class_t* self, trio_long_double_t number,\n                                             trio_flags_t flags, int width, int precision, int base)\n{\n\ttrio_long_double_t integerNumber;\n\ttrio_long_double_t fractionNumber;\n\ttrio_long_double_t workNumber;\n\tint integerDigits;\n\tint fractionDigits;\n\tint exponentDigits;\n\tint workDigits;\n\tint baseDigits;\n\tint integerThreshold;\n\tint fractionThreshold;\n\tint expectedWidth;\n\tint exponent = 0;\n\tunsigned int uExponent = 0;\n\tint exponentBase;\n\ttrio_long_double_t dblBase;\n\ttrio_long_double_t dblFractionBase;\n\ttrio_long_double_t integerAdjust;\n\ttrio_long_double_t fractionAdjust;\n\ttrio_long_double_t workFractionNumber;\n\ttrio_long_double_t workFractionAdjust;\n\tint fractionDigitsInspect;\n\tBOOLEAN_T isNegative;\n\tBOOLEAN_T isExponentNegative = FALSE;\n\tBOOLEAN_T requireTwoDigitExponent;\n\tBOOLEAN_T isHex;\n\tTRIO_CONST char* digits;\n#if TRIO_FEATURE_QUOTE\n\tchar* groupingPointer;\n#endif\n\tint i;\n\tint offset;\n\tBOOLEAN_T hasOnlyZeroes;\n\tint leadingFractionZeroes = -1;\n\tregister int trailingZeroes;\n\tBOOLEAN_T keepTrailingZeroes;\n\tBOOLEAN_T keepDecimalPoint;\n\ttrio_long_double_t epsilon;\n\tBOOLEAN_T adjustNumber = FALSE;\n\n\tassert(VALID(self));\n\tassert(VALID(self->OutStream));\n\tassert(((base >= MIN_BASE) && (base <= MAX_BASE)) || (base == NO_BASE));\n\n\t/* Determine sign and look for special quantities */\n\tswitch (trio_fpclassify_and_signbit(number, &isNegative))\n\t{\n\t\tcase TRIO_FP_NAN:\n\t\t\tTrioWriteString(self, (flags & FLAGS_UPPER) ? NAN_UPPER : NAN_LOWER, flags, width,\n\t\t\t                precision);\n\t\t\treturn;\n\n\t\tcase TRIO_FP_INFINITE:\n\t\t\tif (isNegative)\n\t\t\t{\n\t\t\t\t/* Negative infinity */\n\t\t\t\tTrioWriteString(self,\n\t\t\t\t                (flags & FLAGS_UPPER) ? \"-\" INFINITE_UPPER : \"-\" INFINITE_LOWER,\n\t\t\t\t                flags, width, precision);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Positive infinity */\n\t\t\t\tTrioWriteString(self, (flags & FLAGS_UPPER) ? INFINITE_UPPER : INFINITE_LOWER,\n\t\t\t\t                flags, width, precision);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/* Finitude */\n\t\t\tbreak;\n\t}\n\n\t/* Normal numbers */\n\tif (flags & FLAGS_LONGDOUBLE)\n\t{\n\t\tbaseDigits =\n\t\t    (base == 10) ? LDBL_DIG : (int)trio_floor(LDBL_MANT_DIG / TrioLogarithmBase(base));\n\t\tepsilon = LDBL_EPSILON;\n\t}\n\telse if (flags & FLAGS_SHORT)\n\t{\n\t\tbaseDigits = (base == BASE_DECIMAL)\n\t\t                 ? FLT_DIG\n\t\t                 : (int)trio_floor(FLT_MANT_DIG / TrioLogarithmBase(base));\n\t\tepsilon = FLT_EPSILON;\n\t}\n\telse\n\t{\n\t\tbaseDigits = (base == BASE_DECIMAL)\n\t\t                 ? DBL_DIG\n\t\t                 : (int)trio_floor(DBL_MANT_DIG / TrioLogarithmBase(base));\n\t\tepsilon = DBL_EPSILON;\n\t}\n\n\tdigits = (flags & FLAGS_UPPER) ? internalDigitsUpper : internalDigitsLower;\n\tisHex = (base == BASE_HEX);\n\tif (base == NO_BASE)\n\t\tbase = BASE_DECIMAL;\n\tdblBase = (trio_long_double_t)base;\n\tkeepTrailingZeroes =\n\t    !((flags & FLAGS_ROUNDING) || ((flags & FLAGS_FLOAT_G) && !(flags & FLAGS_ALTERNATIVE)));\n\n#if TRIO_FEATURE_ROUNDING\n\tif (flags & FLAGS_ROUNDING)\n\t{\n\t\tprecision = baseDigits;\n\t}\n#endif\n\n\tif (precision == NO_PRECISION)\n\t{\n\t\tif (isHex)\n\t\t{\n\t\t\tkeepTrailingZeroes = FALSE;\n\t\t\tprecision = FLT_MANT_DIG;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprecision = FLT_DIG;\n\t\t}\n\t}\n\n\tif (isNegative)\n\t{\n\t\tnumber = -number;\n\t}\n\n\tif (isHex)\n\t{\n\t\tflags |= FLAGS_FLOAT_E;\n\t}\n\nreprocess:\n\n\tif (flags & FLAGS_FLOAT_G)\n\t{\n\t\tif (precision == 0)\n\t\t\tprecision = 1;\n\n\t\tif ((number < TRIO_SUFFIX_LONG(1.0E-4)) ||\n\t\t    (number >= TrioPower(base, (trio_long_double_t)precision)))\n\t\t{\n\t\t\t/* Use scientific notation */\n\t\t\tflags |= FLAGS_FLOAT_E;\n\t\t}\n\t\telse if (number < 1.0)\n\t\t{\n\t\t\t/*\n\t\t\t * Use normal notation. If the integer part of the number is\n\t\t\t * zero, then adjust the precision to include leading fractional\n\t\t\t * zeros.\n\t\t\t */\n\t\t\tworkNumber = TrioLogarithm(number, base);\n\t\t\tworkNumber = TRIO_FABS(workNumber);\n\t\t\tif (workNumber - trio_floor(workNumber) < epsilon)\n\t\t\t\tworkNumber--;\n\t\t\tleadingFractionZeroes = (int)trio_floor(workNumber);\n\t\t}\n\t}\n\n\tif (flags & FLAGS_FLOAT_E)\n\t{\n\t\t/* Scale the number */\n\t\tworkNumber = TrioLogarithm(number, base);\n\t\tif (trio_isinf(workNumber) == -1)\n\t\t{\n\t\t\texponent = 0;\n\t\t\t/* Undo setting */\n\t\t\tif (flags & FLAGS_FLOAT_G)\n\t\t\t\tflags &= ~FLAGS_FLOAT_E;\n\t\t}\n\t\telse\n\t\t{\n\t\t\texponent = (int)trio_floor(workNumber);\n\t\t\tworkNumber = number;\n\t\t\t/*\n\t\t\t * The expression A * 10^-B is equivalent to A / 10^B but the former\n\t\t\t * usually gives better accuracy.\n\t\t\t */\n\t\t\tworkNumber *= TrioPower(dblBase, (trio_long_double_t)-exponent);\n\t\t\tif (trio_isinf(workNumber))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scaling is done it two steps to avoid problems with subnormal\n\t\t\t\t * numbers.\n\t\t\t\t */\n\t\t\t\tworkNumber /= TrioPower(dblBase, (trio_long_double_t)(exponent / 2));\n\t\t\t\tworkNumber /= TrioPower(dblBase, (trio_long_double_t)(exponent - (exponent / 2)));\n\t\t\t}\n\t\t\tnumber = workNumber;\n\t\t\tisExponentNegative = (exponent < 0);\n\t\t\tuExponent = (isExponentNegative) ? -exponent : exponent;\n\t\t\tif (isHex)\n\t\t\t\tuExponent *= 4; /* log16(2) */\n#if TRIO_FEATURE_QUOTE\n\t\t\t/* No thousand separators */\n\t\t\tflags &= ~FLAGS_QUOTE;\n#endif\n\t\t}\n\t}\n\n\tintegerNumber = trio_floor(number);\n\tfractionNumber = number - integerNumber;\n\n\t/*\n\t * Truncated number.\n\t *\n\t * Precision is number of significant digits for FLOAT_G and number of\n\t * fractional digits for others.\n\t */\n\tintegerDigits = 1;\n\tif (integerNumber > epsilon)\n\t{\n\t\tintegerDigits += (int)TrioLogarithm(integerNumber, base);\n\t}\n\n\tfractionDigits = precision;\n\tif (flags & FLAGS_FLOAT_G)\n\t{\n\t\tif (leadingFractionZeroes > 0)\n\t\t{\n\t\t\tfractionDigits += leadingFractionZeroes;\n\t\t}\n\t\tif ((integerNumber > epsilon) || (number <= epsilon))\n\t\t{\n\t\t\tfractionDigits -= integerDigits;\n\t\t}\n\t}\n\n\tdblFractionBase = TrioPower(base, fractionDigits);\n\n\tif (integerNumber < 1.0)\n\t{\n\t\tworkNumber = number * dblFractionBase + TRIO_SUFFIX_LONG(0.5);\n\t\tif (trio_floor(number * dblFractionBase) != trio_floor(workNumber))\n\t\t{\n\t\t\tadjustNumber = TRUE;\n\t\t\t/* Remove a leading fraction zero if fraction is rounded up */\n\t\t\tif ((int)TrioLogarithm(number * dblFractionBase, base) !=\n\t\t\t    (int)TrioLogarithm(workNumber, base))\n\t\t\t{\n\t\t\t\t--leadingFractionZeroes;\n\t\t\t}\n\t\t}\n\t\tworkNumber /= dblFractionBase;\n\t}\n\telse\n\t{\n\t\tworkNumber = number + TRIO_SUFFIX_LONG(0.5) / dblFractionBase;\n\t\tadjustNumber = (trio_floor(number) != trio_floor(workNumber));\n\t}\n\tif (adjustNumber)\n\t{\n\t\tif ((flags & FLAGS_FLOAT_G) && !(flags & FLAGS_FLOAT_E))\n\t\t{\n\t\t\t/* The adjustment may require a change to scientific notation */\n\t\t\tif ((workNumber < TRIO_SUFFIX_LONG(1.0E-4)) ||\n\t\t\t    (workNumber >= TrioPower(base, (trio_long_double_t)precision)))\n\t\t\t{\n\t\t\t\t/* Use scientific notation */\n\t\t\t\tflags |= FLAGS_FLOAT_E;\n\t\t\t\tgoto reprocess;\n\t\t\t}\n\t\t}\n\n\t\tif (flags & FLAGS_FLOAT_E)\n\t\t{\n\t\t\tworkDigits = 1 + TrioLogarithm(trio_floor(workNumber), base);\n\t\t\tif (integerDigits == workDigits)\n\t\t\t{\n\t\t\t\t/* Adjust if the same number of digits are used */\n\t\t\t\tnumber += TRIO_SUFFIX_LONG(0.5) / dblFractionBase;\n\t\t\t\tintegerNumber = trio_floor(number);\n\t\t\t\tfractionNumber = number - integerNumber;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Adjust if number was rounded up one digit (ie. 0.99 to 1.00) */\n\t\t\t\texponent++;\n\t\t\t\tisExponentNegative = (exponent < 0);\n\t\t\t\tuExponent = (isExponentNegative) ? -exponent : exponent;\n\t\t\t\tif (isHex)\n\t\t\t\t\tuExponent *= 4; /* log16(2) */\n\t\t\t\tworkNumber = (number + TRIO_SUFFIX_LONG(0.5) / dblFractionBase) / dblBase;\n\t\t\t\tintegerNumber = trio_floor(workNumber);\n\t\t\t\tfractionNumber = workNumber - integerNumber;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (workNumber > 1.0)\n\t\t\t{\n\t\t\t\t/* Adjust if number was rounded up one digit (ie. 99 to 100) */\n\t\t\t\tintegerNumber = trio_floor(workNumber);\n\t\t\t\tfractionNumber = 0.0;\n\t\t\t\tintegerDigits =\n\t\t\t\t    (integerNumber > epsilon) ? 1 + (int)TrioLogarithm(integerNumber, base) : 1;\n\t\t\t\tif (flags & FLAGS_FLOAT_G)\n\t\t\t\t{\n\t\t\t\t\tif (flags & FLAGS_ALTERNATIVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tfractionDigits = precision;\n\t\t\t\t\t\tif ((integerNumber > epsilon) || (number <= epsilon))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfractionDigits -= integerDigits;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfractionDigits = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tintegerNumber = trio_floor(workNumber);\n\t\t\t\tfractionNumber = workNumber - integerNumber;\n\t\t\t\tif (flags & FLAGS_FLOAT_G)\n\t\t\t\t{\n\t\t\t\t\tif (flags & FLAGS_ALTERNATIVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tfractionDigits = precision;\n\t\t\t\t\t\tif (leadingFractionZeroes > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfractionDigits += leadingFractionZeroes;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((integerNumber > epsilon) || (number <= epsilon))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfractionDigits -= integerDigits;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Estimate accuracy */\n\tintegerAdjust = fractionAdjust = TRIO_SUFFIX_LONG(0.5);\n#if TRIO_FEATURE_ROUNDING\n\tif (flags & FLAGS_ROUNDING)\n\t{\n\t\tif (integerDigits > baseDigits)\n\t\t{\n\t\t\tintegerThreshold = baseDigits;\n\t\t\tfractionDigits = 0;\n\t\t\tdblFractionBase = 1.0;\n\t\t\tfractionThreshold = 0;\n\t\t\tprecision = 0; /* Disable decimal-point */\n\t\t\tintegerAdjust = TrioPower(base, integerDigits - integerThreshold - 1);\n\t\t\tfractionAdjust = 0.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tintegerThreshold = integerDigits;\n\t\t\tfractionThreshold = fractionDigits - integerThreshold;\n\t\t\tfractionAdjust = 1.0;\n\t\t}\n\t}\n\telse\n#endif\n\t{\n\t\tintegerThreshold = INT_MAX;\n\t\tfractionThreshold = INT_MAX;\n\t}\n\n\t/*\n\t * Calculate expected width.\n\t *  sign + integer part + thousands separators + decimal point\n\t *  + fraction + exponent\n\t */\n\tfractionAdjust /= dblFractionBase;\n\thasOnlyZeroes = (trio_floor((fractionNumber + fractionAdjust) * dblFractionBase) < epsilon);\n\tkeepDecimalPoint = ((flags & FLAGS_ALTERNATIVE) ||\n\t                    !((precision == 0) || (!keepTrailingZeroes && hasOnlyZeroes)));\n\n\texpectedWidth = integerDigits + fractionDigits;\n\n\tif (!keepTrailingZeroes)\n\t{\n\t\ttrailingZeroes = 0;\n\t\tworkFractionNumber = fractionNumber;\n\t\tworkFractionAdjust = fractionAdjust;\n\t\tfractionDigitsInspect = fractionDigits;\n\n\t\tif (integerDigits > integerThreshold)\n\t\t{\n\t\t\tfractionDigitsInspect = 0;\n\t\t}\n\t\telse if (fractionThreshold <= fractionDigits)\n\t\t{\n\t\t\tfractionDigitsInspect = fractionThreshold + 1;\n\t\t}\n\n\t\ttrailingZeroes = fractionDigits - fractionDigitsInspect;\n\t\tfor (i = 0; i < fractionDigitsInspect; i++)\n\t\t{\n\t\t\tworkFractionNumber *= dblBase;\n\t\t\tworkFractionAdjust *= dblBase;\n\t\t\tworkNumber = trio_floor(workFractionNumber + workFractionAdjust);\n\t\t\tworkFractionNumber -= workNumber;\n\t\t\toffset = (int)trio_fmod(workNumber, dblBase);\n\t\t\tif (offset == 0)\n\t\t\t{\n\t\t\t\ttrailingZeroes++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttrailingZeroes = 0;\n\t\t\t}\n\t\t}\n\t\texpectedWidth -= trailingZeroes;\n\t}\n\n\tif (keepDecimalPoint)\n\t{\n\t\texpectedWidth += internalDecimalPointLength;\n\t}\n\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t{\n\t\texpectedWidth += TrioCalcThousandSeparatorLength(integerDigits);\n\t}\n#endif\n\n\tif (isNegative || (flags & FLAGS_SHOWSIGN) || (flags & FLAGS_SPACE))\n\t{\n\t\texpectedWidth += sizeof(\"-\") - 1;\n\t}\n\n\texponentDigits = 0;\n\tif (flags & FLAGS_FLOAT_E)\n\t{\n\t\texponentDigits =\n\t\t    (uExponent == 0)\n\t\t        ? 1\n\t\t        : (int)trio_ceil(TrioLogarithm((double)(uExponent + 1), (isHex) ? 10 : base));\n\t}\n\trequireTwoDigitExponent = ((base == BASE_DECIMAL) && (exponentDigits == 1));\n\tif (exponentDigits > 0)\n\t{\n\t\texpectedWidth += exponentDigits;\n\t\texpectedWidth += (requireTwoDigitExponent ? sizeof(\"E+0\") - 1 : sizeof(\"E+\") - 1);\n\t}\n\n\tif (isHex)\n\t{\n\t\texpectedWidth += sizeof(\"0X\") - 1;\n\t}\n\n\t/* Output prefixing */\n\tif (flags & FLAGS_NILPADDING)\n\t{\n\t\t/* Leading zeros must be after sign */\n\t\tif (isNegative)\n\t\t\tself->OutStream(self, '-');\n\t\telse if (flags & FLAGS_SHOWSIGN)\n\t\t\tself->OutStream(self, '+');\n\t\telse if (flags & FLAGS_SPACE)\n\t\t\tself->OutStream(self, ' ');\n\t\tif (isHex)\n\t\t{\n\t\t\tself->OutStream(self, '0');\n\t\t\tself->OutStream(self, (flags & FLAGS_UPPER) ? 'X' : 'x');\n\t\t}\n\t\tif (!(flags & FLAGS_LEFTADJUST))\n\t\t{\n\t\t\tfor (i = expectedWidth; i < width; i++)\n\t\t\t{\n\t\t\t\tself->OutStream(self, '0');\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Leading spaces must be before sign */\n\t\tif (!(flags & FLAGS_LEFTADJUST))\n\t\t{\n\t\t\tfor (i = expectedWidth; i < width; i++)\n\t\t\t{\n\t\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t\t\t}\n\t\t}\n\t\tif (isNegative)\n\t\t\tself->OutStream(self, '-');\n\t\telse if (flags & FLAGS_SHOWSIGN)\n\t\t\tself->OutStream(self, '+');\n\t\telse if (flags & FLAGS_SPACE)\n\t\t\tself->OutStream(self, ' ');\n\t\tif (isHex)\n\t\t{\n\t\t\tself->OutStream(self, '0');\n\t\t\tself->OutStream(self, (flags & FLAGS_UPPER) ? 'X' : 'x');\n\t\t}\n\t}\n\n\t/* Output the integer part and thousand separators */\n\tfor (i = 0; i < integerDigits; i++)\n\t{\n\t\tworkNumber =\n\t\t    trio_floor(((integerNumber + integerAdjust) / TrioPower(base, integerDigits - i - 1)));\n\t\tif (i > integerThreshold)\n\t\t{\n\t\t\t/* Beyond accuracy */\n\t\t\tself->OutStream(self, digits[0]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself->OutStream(self, digits[(int)trio_fmod(workNumber, dblBase)]);\n\t\t}\n\n#if TRIO_FEATURE_QUOTE\n\t\tif (((flags & (FLAGS_FLOAT_E | FLAGS_QUOTE)) == FLAGS_QUOTE) &&\n\t\t    TrioFollowedBySeparator(integerDigits - i))\n\t\t{\n\t\t\tfor (groupingPointer = internalThousandSeparator; *groupingPointer != NIL;\n\t\t\t     groupingPointer++)\n\t\t\t{\n\t\t\t\tself->OutStream(self, *groupingPointer);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Insert decimal point and build the fraction part */\n\ttrailingZeroes = 0;\n\n\tif (keepDecimalPoint)\n\t{\n\t\tif (internalDecimalPoint)\n\t\t{\n\t\t\tself->OutStream(self, internalDecimalPoint);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < internalDecimalPointLength; i++)\n\t\t\t{\n\t\t\t\tself->OutStream(self, internalDecimalPointString[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < fractionDigits; i++)\n\t{\n\t\tif ((integerDigits > integerThreshold) || (i > fractionThreshold))\n\t\t{\n\t\t\t/* Beyond accuracy */\n\t\t\ttrailingZeroes++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfractionNumber *= dblBase;\n\t\t\tfractionAdjust *= dblBase;\n\t\t\tworkNumber = trio_floor(fractionNumber + fractionAdjust);\n\t\t\tif (workNumber > fractionNumber)\n\t\t\t{\n\t\t\t\t/* fractionNumber should never become negative */\n\t\t\t\tfractionNumber = 0.0;\n\t\t\t\tfractionAdjust = 0.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfractionNumber -= workNumber;\n\t\t\t}\n\t\t\toffset = (int)trio_fmod(workNumber, dblBase);\n\t\t\tif (offset == 0)\n\t\t\t{\n\t\t\t\ttrailingZeroes++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (trailingZeroes > 0)\n\t\t\t\t{\n\t\t\t\t\t/* Not trailing zeroes after all */\n\t\t\t\t\tself->OutStream(self, digits[0]);\n\t\t\t\t\ttrailingZeroes--;\n\t\t\t\t}\n\t\t\t\tself->OutStream(self, digits[offset]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (keepTrailingZeroes)\n\t{\n\t\twhile (trailingZeroes > 0)\n\t\t{\n\t\t\tself->OutStream(self, digits[0]);\n\t\t\ttrailingZeroes--;\n\t\t}\n\t}\n\n\t/* Output exponent */\n\tif (exponentDigits > 0)\n\t{\n\t\tself->OutStream(self, isHex ? ((flags & FLAGS_UPPER) ? 'P' : 'p')\n\t\t                            : ((flags & FLAGS_UPPER) ? 'E' : 'e'));\n\t\tself->OutStream(self, (isExponentNegative) ? '-' : '+');\n\n\t\t/* The exponent must contain at least two digits */\n\t\tif (requireTwoDigitExponent)\n\t\t\tself->OutStream(self, '0');\n\n\t\tif (isHex)\n\t\t\tbase = 10;\n\t\texponentBase = (int)TrioPower(base, exponentDigits - 1);\n\t\tfor (i = 0; i < exponentDigits; i++)\n\t\t{\n\t\t\tself->OutStream(self, digits[(uExponent / exponentBase) % base]);\n\t\t\texponentBase /= base;\n\t\t}\n\t}\n\t/* Output trailing spaces */\n\tif (flags & FLAGS_LEFTADJUST)\n\t{\n\t\tfor (i = expectedWidth; i < width; i++)\n\t\t{\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t\t}\n\t}\n}\n#endif /* TRIO_FEATURE_FLOAT */\n\n/*************************************************************************\n * TrioFormatProcess\n *\n * Description:\n *  This is the main engine for formatting output\n */\nTRIO_PRIVATE int TrioFormatProcess TRIO_ARGS3((data, format, parameters), trio_class_t* data,\n                                              TRIO_CONST char* format, trio_parameter_t* parameters)\n{\n\tint i;\n#if TRIO_FEATURE_ERRNO\n\tTRIO_CONST char* string;\n#endif\n\ttrio_pointer_t pointer;\n\ttrio_flags_t flags;\n\tint width;\n\tint precision;\n\tint base;\n\tint offset;\n\n\toffset = 0;\n\ti = 0;\n\n\tfor (;;)\n\t{\n\t\t/* Skip the parameter entries */\n\t\twhile (parameters[i].type == FORMAT_PARAMETER)\n\t\t\ti++;\n\n\t\t/* Copy non conversion-specifier part of format string */\n\t\twhile (offset < parameters[i].beginOffset)\n\t\t{\n\t\t\tif (CHAR_IDENTIFIER == format[offset] && CHAR_IDENTIFIER == format[offset + 1])\n\t\t\t{\n\t\t\t\tdata->OutStream(data, CHAR_IDENTIFIER);\n\t\t\t\toffset += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata->OutStream(data, format[offset++]);\n\t\t\t}\n\t\t}\n\n\t\t/* Abort if we reached end of format string */\n\t\tif (parameters[i].type == FORMAT_SENTINEL)\n\t\t\tbreak;\n\n\t\t/* Ouput parameter */\n\t\tflags = parameters[i].flags;\n\n\t\t/* Find width */\n\t\twidth = parameters[i].width;\n\t\tif (flags & FLAGS_WIDTH_PARAMETER)\n\t\t{\n\t\t\t/* Get width from parameter list */\n\t\t\twidth = (int)parameters[width].data.number.as_signed;\n\t\t\tif (width < 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * A negative width is the same as the - flag and\n\t\t\t\t * a positive width.\n\t\t\t\t */\n\t\t\t\tflags |= FLAGS_LEFTADJUST;\n\t\t\t\tflags &= ~FLAGS_NILPADDING;\n\t\t\t\twidth = -width;\n\t\t\t}\n\t\t}\n\n\t\t/* Find precision */\n\t\tif (flags & FLAGS_PRECISION)\n\t\t{\n\t\t\tprecision = parameters[i].precision;\n\t\t\tif (flags & FLAGS_PRECISION_PARAMETER)\n\t\t\t{\n\t\t\t\t/* Get precision from parameter list */\n\t\t\t\tprecision = (int)parameters[precision].data.number.as_signed;\n\t\t\t\tif (precision < 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * A negative precision is the same as no\n\t\t\t\t\t * precision\n\t\t\t\t\t */\n\t\t\t\t\tprecision = NO_PRECISION;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprecision = NO_PRECISION;\n\t\t}\n\n\t\t/* Find base */\n\t\tif (NO_BASE != parameters[i].baseSpecifier)\n\t\t{\n\t\t\t/* Base from specifier has priority */\n\t\t\tbase = parameters[i].baseSpecifier;\n\t\t}\n\t\telse if (flags & FLAGS_BASE_PARAMETER)\n\t\t{\n\t\t\t/* Get base from parameter list */\n\t\t\tbase = parameters[i].base;\n\t\t\tbase = (int)parameters[base].data.number.as_signed;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use base from format string */\n\t\t\tbase = parameters[i].base;\n\t\t}\n\n\t\tswitch (parameters[i].type)\n\t\t{\n\t\t\tcase FORMAT_CHAR:\n#if TRIO_FEATURE_QUOTE\n\t\t\t\tif (flags & FLAGS_QUOTE)\n\t\t\t\t\tdata->OutStream(data, CHAR_QUOTE);\n#endif\n\t\t\t\tif (!(flags & FLAGS_LEFTADJUST))\n\t\t\t\t{\n\t\t\t\t\twhile (--width > 0)\n\t\t\t\t\t\tdata->OutStream(data, CHAR_ADJUST);\n\t\t\t\t}\n#if TRIO_FEATURE_WIDECHAR\n\t\t\t\tif (flags & FLAGS_WIDECHAR)\n\t\t\t\t{\n\t\t\t\t\tTrioWriteWideStringCharacter(\n\t\t\t\t\t    data, (trio_wchar_t)parameters[i].data.number.as_signed, flags, NO_WIDTH);\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tTrioWriteStringCharacter(data, (int)parameters[i].data.number.as_signed, flags);\n\t\t\t\t}\n\n\t\t\t\tif (flags & FLAGS_LEFTADJUST)\n\t\t\t\t{\n\t\t\t\t\twhile (--width > 0)\n\t\t\t\t\t\tdata->OutStream(data, CHAR_ADJUST);\n\t\t\t\t}\n#if TRIO_FEATURE_QUOTE\n\t\t\t\tif (flags & FLAGS_QUOTE)\n\t\t\t\t\tdata->OutStream(data, CHAR_QUOTE);\n#endif\n\n\t\t\t\tbreak; /* FORMAT_CHAR */\n\n\t\t\tcase FORMAT_INT:\n\t\t\t\tTrioWriteNumber(data, parameters[i].data.number.as_unsigned, flags, width,\n\t\t\t\t                precision, base);\n\n\t\t\t\tbreak; /* FORMAT_INT */\n\n#if TRIO_FEATURE_FLOAT\n\t\t\tcase FORMAT_DOUBLE:\n\t\t\t\tTrioWriteDouble(data, parameters[i].data.longdoubleNumber, flags, width, precision,\n\t\t\t\t                base);\n\t\t\t\tbreak; /* FORMAT_DOUBLE */\n#endif\n\n\t\t\tcase FORMAT_STRING:\n#if TRIO_FEATURE_WIDECHAR\n\t\t\t\tif (flags & FLAGS_WIDECHAR)\n\t\t\t\t{\n\t\t\t\t\tTrioWriteWideString(data, parameters[i].data.wstring, flags, width, precision);\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tTrioWriteString(data, parameters[i].data.string, flags, width, precision);\n\t\t\t\t}\n\t\t\t\tbreak; /* FORMAT_STRING */\n\n\t\t\tcase FORMAT_POINTER:\n\t\t\t{\n\t\t\t\ttrio_reference_t reference;\n\n\t\t\t\treference.data = data;\n\t\t\t\treference.parameter = &parameters[i];\n\t\t\t\ttrio_print_pointer(&reference, parameters[i].data.pointer);\n\t\t\t}\n\t\t\tbreak; /* FORMAT_POINTER */\n\n\t\t\tcase FORMAT_COUNT:\n\t\t\t\tpointer = parameters[i].data.pointer;\n\t\t\t\tif (NULL != pointer)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * C99 paragraph 7.19.6.1.8 says \"the number of\n\t\t\t\t\t * characters written to the output stream so far by\n\t\t\t\t\t * this call\", which is data->actually.committed\n\t\t\t\t\t */\n#if TRIO_FEATURE_SIZE_T || TRIO_FEATURE_SIZE_T_UPPER\n\t\t\t\t\tif (flags & FLAGS_SIZE_T)\n\t\t\t\t\t\t*(size_t*)pointer = (size_t)data->actually.committed;\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_PTRDIFF_T\n\t\t\t\t\t    if (flags & FLAGS_PTRDIFF_T)\n\t\t\t\t\t\t*(ptrdiff_t*)pointer = (ptrdiff_t)data->actually.committed;\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_INTMAX_T\n\t\t\t\t\t    if (flags & FLAGS_INTMAX_T)\n\t\t\t\t\t\t*(trio_intmax_t*)pointer = (trio_intmax_t)data->actually.committed;\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t    if (flags & FLAGS_QUAD)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(trio_ulonglong_t*)pointer = (trio_ulonglong_t)data->actually.committed;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flags & FLAGS_LONG)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(long int*)pointer = (long int)data->actually.committed;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flags & FLAGS_SHORT)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(short int*)pointer = (short int)data->actually.committed;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t*(int*)pointer = (int)data->actually.committed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak; /* FORMAT_COUNT */\n\n\t\t\tcase FORMAT_PARAMETER:\n\t\t\t\tbreak; /* FORMAT_PARAMETER */\n\n#if TRIO_FEATURE_ERRNO\n\t\t\tcase FORMAT_ERRNO:\n\t\t\t\tstring = trio_error(parameters[i].data.errorNumber);\n\t\t\t\tif (string)\n\t\t\t\t{\n\t\t\t\t\tTrioWriteString(data, string, flags, width, precision);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdata->OutStream(data, '#');\n\t\t\t\t\tTrioWriteNumber(data, (trio_uintmax_t)parameters[i].data.errorNumber, flags,\n\t\t\t\t\t                width, precision, BASE_DECIMAL);\n\t\t\t\t}\n\t\t\t\tbreak; /* FORMAT_ERRNO */\n#endif                 /* TRIO_FEATURE_ERRNO */\n\n#if TRIO_FEATURE_USER_DEFINED\n\t\t\tcase FORMAT_USER_DEFINED:\n\t\t\t{\n\t\t\t\ttrio_reference_t reference;\n\t\t\t\ttrio_userdef_t* def = NULL;\n\n\t\t\t\tif (parameters[i].flags & FLAGS_USER_DEFINED_PARAMETER)\n\t\t\t\t{\n\t\t\t\t\t/* Use handle */\n\t\t\t\t\tif ((i > 0) || (parameters[i - 1].type == FORMAT_PARAMETER))\n\t\t\t\t\t\tdef = (trio_userdef_t*)parameters[i - 1].data.pointer;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Look up namespace */\n\t\t\t\t\tdef = TrioFindNamespace(parameters[i].user_defined.namespace, NULL);\n\t\t\t\t}\n\t\t\t\tif (def)\n\t\t\t\t{\n\t\t\t\t\treference.data = data;\n\t\t\t\t\treference.parameter = &parameters[i];\n\t\t\t\t\tdef->callback(&reference);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif /* TRIO_FEATURE_USER_DEFINED */\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t} /* switch parameter type */\n\n\t\t/* Prepare for next */\n\t\toffset = parameters[i].endOffset;\n\t\ti++;\n\t}\n\n\treturn data->processed;\n}\n\n/*************************************************************************\n * TrioFormatRef\n */\n#if TRIO_EXTENSION\nTRIO_PRIVATE int TrioFormatRef TRIO_ARGS5((reference, format, arglist, argfunc, argarray),\n                                          trio_reference_t* reference, TRIO_CONST char* format,\n                                          va_list arglist, trio_argfunc_t argfunc,\n                                          trio_pointer_t* argarray)\n{\n\tint status;\n\ttrio_parameter_t parameters[MAX_PARAMETERS];\n\n\tstatus = TrioParse(TYPE_PRINT, format, parameters, arglist, argfunc, argarray);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = TrioFormatProcess(reference->data, format, parameters);\n\tif (reference->data->error != 0)\n\t{\n\t\tstatus = reference->data->error;\n\t}\n\treturn status;\n}\n#endif /* TRIO_EXTENSION */\n\n/*************************************************************************\n * TrioFormat\n */\nTRIO_PRIVATE int TrioFormat TRIO_ARGS7((destination, destinationSize, OutStream, format, arglist,\n                                        argfunc, argarray),\n                                       trio_pointer_t destination, size_t destinationSize,\n                                       void(*OutStream) TRIO_PROTO((trio_class_t*, int)),\n                                       TRIO_CONST char* format, va_list arglist,\n                                       trio_argfunc_t argfunc, trio_pointer_t* argarray)\n{\n\tint status;\n\ttrio_class_t data;\n\ttrio_parameter_t parameters[MAX_PARAMETERS];\n\n\tassert(VALID(OutStream));\n\tassert(VALID(format));\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.OutStream = OutStream;\n\tdata.location = destination;\n\tdata.max = destinationSize;\n\tdata.error = 0;\n\n#if defined(USE_LOCALE)\n\tif (NULL == internalLocaleValues)\n\t{\n\t\tTrioSetLocale();\n\t}\n#endif\n\n\tstatus = TrioParse(TYPE_PRINT, format, parameters, arglist, argfunc, argarray);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = TrioFormatProcess(&data, format, parameters);\n\tif (data.error != 0)\n\t{\n\t\tstatus = data.error;\n\t}\n\treturn status;\n}\n\n/*************************************************************************\n * TrioOutStreamFile\n */\n#if TRIO_FEATURE_FILE || TRIO_FEATURE_STDIO\nTRIO_PRIVATE void TrioOutStreamFile TRIO_ARGS2((self, output), trio_class_t* self, int output)\n{\n\tFILE* file;\n\n\tassert(VALID(self));\n\tassert(VALID(self->location));\n\n\tfile = (FILE*)self->location;\n\tself->processed++;\n\tif (fputc(output, file) == EOF)\n\t{\n\t\tself->error = TRIO_ERROR_RETURN(TRIO_EOF, 0);\n\t}\n\telse\n\t{\n\t\tself->actually.committed++;\n\t}\n}\n#endif /* TRIO_FEATURE_FILE || TRIO_FEATURE_STDIO */\n\n/*************************************************************************\n * TrioOutStreamFileDescriptor\n */\n#if TRIO_FEATURE_FD\nTRIO_PRIVATE void TrioOutStreamFileDescriptor TRIO_ARGS2((self, output), trio_class_t* self,\n                                                         int output)\n{\n\tint fd;\n\tchar ch;\n\n\tassert(VALID(self));\n\n\tfd = *((int*)self->location);\n\tch = (char)output;\n\tself->processed++;\n\tif (write(fd, &ch, sizeof(char)) == -1)\n\t{\n\t\tself->error = TRIO_ERROR_RETURN(TRIO_ERRNO, 0);\n\t}\n\telse\n\t{\n\t\tself->actually.committed++;\n\t}\n}\n#endif /* TRIO_FEATURE_FD */\n\n/*************************************************************************\n * TrioOutStreamCustom\n */\n#if TRIO_FEATURE_CLOSURE\nTRIO_PRIVATE void TrioOutStreamCustom TRIO_ARGS2((self, output), trio_class_t* self, int output)\n{\n\tint status;\n\ttrio_custom_t* data;\n\n\tassert(VALID(self));\n\tassert(VALID(self->location));\n\n\tdata = (trio_custom_t*)self->location;\n\tif (data->stream.out)\n\t{\n\t\tstatus = (data->stream.out)(data->closure, output);\n\t\tif (status >= 0)\n\t\t{\n\t\t\tself->actually.committed++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (self->error == 0)\n\t\t\t{\n\t\t\t\tself->error = TRIO_ERROR_RETURN(TRIO_ECUSTOM, -status);\n\t\t\t}\n\t\t}\n\t}\n\tself->processed++;\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n/*************************************************************************\n * TrioOutStreamString\n */\nTRIO_PRIVATE void TrioOutStreamString TRIO_ARGS2((self, output), trio_class_t* self, int output)\n{\n\tchar** buffer;\n\n\tassert(VALID(self));\n\tassert(VALID(self->location));\n\n\tbuffer = (char**)self->location;\n\t**buffer = (char)output;\n\t(*buffer)++;\n\tself->processed++;\n\tself->actually.committed++;\n}\n\n/*************************************************************************\n * TrioOutStreamStringMax\n */\nTRIO_PRIVATE void TrioOutStreamStringMax TRIO_ARGS2((self, output), trio_class_t* self, int output)\n{\n\tchar** buffer;\n\n\tassert(VALID(self));\n\tassert(VALID(self->location));\n\n\tbuffer = (char**)self->location;\n\n\tif (self->processed < self->max)\n\t{\n\t\t**buffer = (char)output;\n\t\t(*buffer)++;\n\t\tself->actually.committed++;\n\t}\n\tself->processed++;\n}\n\n/*************************************************************************\n * TrioOutStreamStringDynamic\n */\n#if TRIO_FEATURE_DYNAMICSTRING\nTRIO_PRIVATE void TrioOutStreamStringDynamic TRIO_ARGS2((self, output), trio_class_t* self,\n                                                        int output)\n{\n\tassert(VALID(self));\n\tassert(VALID(self->location));\n\n\tif (self->error == 0)\n\t{\n\t\ttrio_xstring_append_char((trio_string_t*)self->location, (char)output);\n\t\tself->actually.committed++;\n\t}\n\t/* The processed variable must always be increased */\n\tself->processed++;\n}\n#endif /* TRIO_FEATURE_DYNAMICSTRING */\n\n/*************************************************************************\n * TrioArrayGetter\n */\nstatic trio_pointer_t TrioArrayGetter(trio_pointer_t context, int index, int type)\n{\n\t/* Utility function for the printfv family */\n\ttrio_pointer_t* argarray = (trio_pointer_t*)context;\n\treturn argarray[index];\n}\n\n/*************************************************************************\n *\n * Formatted printing functions\n *\n ************************************************************************/\n\n/** @addtogroup Printf\n    @{\n*/\n\n/*************************************************************************\n * printf\n */\n\n/**\n   Print to standard output stream.\n\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_STDIO\nTRIO_PUBLIC int trio_printf TRIO_VARGS2((format, va_alist), TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioFormat(stdout, 0, TrioOutStreamFile, format, args, NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_STDIO */\n\n/**\n   Print to standard output stream.\n\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_STDIO\nTRIO_PUBLIC int trio_vprintf TRIO_ARGS2((format, args), TRIO_CONST char* format, va_list args)\n{\n\tassert(VALID(format));\n\n\treturn TrioFormat(stdout, 0, TrioOutStreamFile, format, args, NULL, NULL);\n}\n#endif /* TRIO_FEATURE_STDIO */\n\n/**\n   Print to standard output stream.\n\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_STDIO\nTRIO_PUBLIC int trio_printfv TRIO_ARGS2((format, args), TRIO_CONST char* format,\n                                        trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(format));\n\n\treturn TrioFormat(stdout, 0, TrioOutStreamFile, format, unused, TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_STDIO */\n\n/*************************************************************************\n * fprintf\n */\n\n/**\n   Print to file.\n\n   @param file File pointer.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_FILE\nTRIO_PUBLIC int trio_fprintf TRIO_VARGS3((file, format, va_alist), FILE* file,\n                                         TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(file));\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioFormat(file, 0, TrioOutStreamFile, format, args, NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_FILE */\n\n/**\n   Print to file.\n\n   @param file File pointer.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_FILE\nTRIO_PUBLIC int trio_vfprintf TRIO_ARGS3((file, format, args), FILE* file, TRIO_CONST char* format,\n                                         va_list args)\n{\n\tassert(VALID(file));\n\tassert(VALID(format));\n\n\treturn TrioFormat(file, 0, TrioOutStreamFile, format, args, NULL, NULL);\n}\n#endif /* TRIO_FEATURE_FILE */\n\n/**\n   Print to file.\n\n   @param file File pointer.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_FILE\nTRIO_PUBLIC int trio_fprintfv TRIO_ARGS3((file, format, args), FILE* file, TRIO_CONST char* format,\n                                         trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(file));\n\tassert(VALID(format));\n\n\treturn TrioFormat(file, 0, TrioOutStreamFile, format, unused, TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_FILE */\n\n/*************************************************************************\n * dprintf\n */\n\n/**\n   Print to file descriptor.\n\n   @param fd File descriptor.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_FD\nTRIO_PUBLIC int trio_dprintf TRIO_VARGS3((fd, format, va_alist), int fd, TRIO_CONST char* format,\n                                         TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioFormat(&fd, 0, TrioOutStreamFileDescriptor, format, args, NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_FD */\n\n/**\n   Print to file descriptor.\n\n   @param fd File descriptor.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_FD\nTRIO_PUBLIC int trio_vdprintf TRIO_ARGS3((fd, format, args), int fd, TRIO_CONST char* format,\n                                         va_list args)\n{\n\tassert(VALID(format));\n\n\treturn TrioFormat(&fd, 0, TrioOutStreamFileDescriptor, format, args, NULL, NULL);\n}\n#endif /* TRIO_FEATURE_FD */\n\n/**\n   Print to file descriptor.\n\n   @param fd File descriptor.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_FD\nTRIO_PUBLIC int trio_dprintfv TRIO_ARGS3((fd, format, args), int fd, TRIO_CONST char* format,\n                                         trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(format));\n\n\treturn TrioFormat(&fd, 0, TrioOutStreamFileDescriptor, format, unused, TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_FD */\n\n/*************************************************************************\n * cprintf\n */\n#if TRIO_FEATURE_CLOSURE\nTRIO_PUBLIC int trio_cprintf TRIO_VARGS4((stream, closure, format, va_alist),\n                                         trio_outstream_t stream, trio_pointer_t closure,\n                                         TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tdata.stream.out = stream;\n\tdata.closure = closure;\n\tstatus = TrioFormat(&data, 0, TrioOutStreamCustom, format, args, NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n#if TRIO_FEATURE_CLOSURE\nTRIO_PUBLIC int trio_vcprintf TRIO_ARGS4((stream, closure, format, args), trio_outstream_t stream,\n                                         trio_pointer_t closure, TRIO_CONST char* format,\n                                         va_list args)\n{\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\n\tdata.stream.out = stream;\n\tdata.closure = closure;\n\treturn TrioFormat(&data, 0, TrioOutStreamCustom, format, args, NULL, NULL);\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n#if TRIO_FEATURE_CLOSURE\nTRIO_PUBLIC int trio_cprintfv TRIO_ARGS4((stream, closure, format, args), trio_outstream_t stream,\n                                         trio_pointer_t closure, TRIO_CONST char* format,\n                                         trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\n\tdata.stream.out = stream;\n\tdata.closure = closure;\n\treturn TrioFormat(&data, 0, TrioOutStreamCustom, format, unused, TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n#if TRIO_FEATURE_CLOSURE && TRIO_FEATURE_ARGFUNC\nTRIO_PUBLIC int trio_cprintff TRIO_ARGS5((stream, closure, format, argfunc, context),\n                                         trio_outstream_t stream, trio_pointer_t closure,\n                                         TRIO_CONST char* format, trio_argfunc_t argfunc,\n                                         trio_pointer_t context)\n{\n\tstatic va_list unused;\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\tassert(VALID(argfunc));\n\n\tdata.stream.out = stream;\n\tdata.closure = closure;\n\treturn TrioFormat(&data, 0, TrioOutStreamCustom, format, unused, argfunc,\n\t                  (trio_pointer_t*)context);\n}\n#endif /* TRIO_FEATURE_CLOSURE && TRIO_FEATURE_ARGFUNC */\n\n/*************************************************************************\n * sprintf\n */\n\n/**\n   Print to string.\n\n   @param buffer Output string.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of printed characters.\n */\nTRIO_PUBLIC int trio_sprintf TRIO_VARGS3((buffer, format, va_alist), char* buffer,\n                                         TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioFormat(&buffer, 0, TrioOutStreamString, format, args, NULL, NULL);\n\t*buffer = NIL; /* Terminate with NIL character */\n\tTRIO_VA_END(args);\n\treturn status;\n}\n\n/**\n   Print to string.\n\n   @param buffer Output string.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\nTRIO_PUBLIC int trio_vsprintf TRIO_ARGS3((buffer, format, args), char* buffer,\n                                         TRIO_CONST char* format, va_list args)\n{\n\tint status;\n\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\tstatus = TrioFormat(&buffer, 0, TrioOutStreamString, format, args, NULL, NULL);\n\t*buffer = NIL;\n\treturn status;\n}\n\n/**\n   Print to string.\n\n   @param buffer Output string.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\nTRIO_PUBLIC int trio_sprintfv TRIO_ARGS3((buffer, format, args), char* buffer,\n                                         TRIO_CONST char* format, trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\tint status;\n\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\tstatus = TrioFormat(&buffer, 0, TrioOutStreamString, format, unused, TrioArrayGetter, args);\n\t*buffer = NIL;\n\treturn status;\n}\n\n/*************************************************************************\n * snprintf\n */\n\n/**\n   Print at most @p max characters to string.\n\n   @param buffer Output string.\n   @param max Maximum number of characters to print.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of printed characters.\n */\nTRIO_PUBLIC int trio_snprintf TRIO_VARGS4((buffer, max, format, va_alist), char* buffer, size_t max,\n                                          TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(buffer) || (max == 0));\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioFormat(&buffer, max > 0 ? max - 1 : 0, TrioOutStreamStringMax, format, args, NULL,\n\t                    NULL);\n\tif (max > 0)\n\t\t*buffer = NIL;\n\tTRIO_VA_END(args);\n\treturn status;\n}\n\n/**\n   Print at most @p max characters to string.\n\n   @param buffer Output string.\n   @param max Maximum number of characters to print.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\nTRIO_PUBLIC int trio_vsnprintf TRIO_ARGS4((buffer, max, format, args), char* buffer, size_t max,\n                                          TRIO_CONST char* format, va_list args)\n{\n\tint status;\n\n\tassert(VALID(buffer) || (max == 0));\n\tassert(VALID(format));\n\n\tstatus = TrioFormat(&buffer, max > 0 ? max - 1 : 0, TrioOutStreamStringMax, format, args, NULL,\n\t                    NULL);\n\tif (max > 0)\n\t\t*buffer = NIL;\n\treturn status;\n}\n\n/**\n   Print at most @p max characters to string.\n\n   @param buffer Output string.\n   @param max Maximum number of characters to print.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\nTRIO_PUBLIC int trio_snprintfv TRIO_ARGS4((buffer, max, format, args), char* buffer, size_t max,\n                                          TRIO_CONST char* format, trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\tint status;\n\n\tassert(VALID(buffer) || (max == 0));\n\tassert(VALID(format));\n\n\tstatus = TrioFormat(&buffer, max > 0 ? max - 1 : 0, TrioOutStreamStringMax, format, unused,\n\t                    TrioArrayGetter, args);\n\tif (max > 0)\n\t\t*buffer = NIL;\n\treturn status;\n}\n\n/*************************************************************************\n * snprintfcat\n * Appends the new string to the buffer string overwriting the '\\0'\n * character at the end of buffer.\n */\n#if TRIO_EXTENSION\nTRIO_PUBLIC int trio_snprintfcat TRIO_VARGS4((buffer, max, format, va_alist), char* buffer,\n                                             size_t max, TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\tsize_t buf_len;\n\n\tTRIO_VA_START(args, format);\n\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\tbuf_len = trio_length(buffer);\n\tbuffer = &buffer[buf_len];\n\n\tstatus =\n\t    TrioFormat(&buffer, max - 1 - buf_len, TrioOutStreamStringMax, format, args, NULL, NULL);\n\tTRIO_VA_END(args);\n\t*buffer = NIL;\n\treturn status;\n}\n#endif\n\n#if TRIO_EXTENSION\nTRIO_PUBLIC int trio_vsnprintfcat TRIO_ARGS4((buffer, max, format, args), char* buffer, size_t max,\n                                             TRIO_CONST char* format, va_list args)\n{\n\tint status;\n\tsize_t buf_len;\n\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\tbuf_len = trio_length(buffer);\n\tbuffer = &buffer[buf_len];\n\tstatus =\n\t    TrioFormat(&buffer, max - 1 - buf_len, TrioOutStreamStringMax, format, args, NULL, NULL);\n\t*buffer = NIL;\n\treturn status;\n}\n#endif\n\n/*************************************************************************\n * trio_aprintf\n */\n\n#if TRIO_DEPRECATED && TRIO_FEATURE_DYNAMICSTRING\nTRIO_PUBLIC char* trio_aprintf TRIO_VARGS2((format, va_alist), TRIO_CONST char* format,\n                                           TRIO_VA_DECL)\n{\n\tva_list args;\n\ttrio_string_t* info;\n\tchar* result = NULL;\n\n\tassert(VALID(format));\n\n\tinfo = trio_xstring_duplicate(\"\");\n\tif (info)\n\t{\n\t\tTRIO_VA_START(args, format);\n\t\t(void)TrioFormat(info, 0, TrioOutStreamStringDynamic, format, args, NULL, NULL);\n\t\tTRIO_VA_END(args);\n\n\t\ttrio_string_terminate(info);\n\t\tresult = trio_string_extract(info);\n\t\ttrio_string_destroy(info);\n\t}\n\treturn result;\n}\n#endif /* TRIO_DEPRECATED && TRIO_FEATURE_DYNAMICSTRING */\n\n#if TRIO_DEPRECATED && TRIO_FEATURE_DYNAMICSTRING\nTRIO_PUBLIC char* trio_vaprintf TRIO_ARGS2((format, args), TRIO_CONST char* format, va_list args)\n{\n\ttrio_string_t* info;\n\tchar* result = NULL;\n\n\tassert(VALID(format));\n\n\tinfo = trio_xstring_duplicate(\"\");\n\tif (info)\n\t{\n\t\t(void)TrioFormat(info, 0, TrioOutStreamStringDynamic, format, args, NULL, NULL);\n\t\ttrio_string_terminate(info);\n\t\tresult = trio_string_extract(info);\n\t\ttrio_string_destroy(info);\n\t}\n\treturn result;\n}\n#endif /* TRIO_DEPRECATED && TRIO_FEATURE_DYNAMICSTRING */\n\n/**\n   Allocate and print to string.\n   The memory allocated and returned by @p result must be freed by the\n   calling application.\n\n   @param result Output string.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_DYNAMICSTRING\nTRIO_PUBLIC int trio_asprintf TRIO_VARGS3((result, format, va_alist), char** result,\n                                          TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tva_list args;\n\tint status;\n\ttrio_string_t* info;\n\n\tassert(VALID(format));\n\n\t*result = NULL;\n\n\tinfo = trio_xstring_duplicate(\"\");\n\tif (info == NULL)\n\t{\n\t\tstatus = TRIO_ERROR_RETURN(TRIO_ENOMEM, 0);\n\t}\n\telse\n\t{\n\t\tTRIO_VA_START(args, format);\n\t\tstatus = TrioFormat(info, 0, TrioOutStreamStringDynamic, format, args, NULL, NULL);\n\t\tTRIO_VA_END(args);\n\t\tif (status >= 0)\n\t\t{\n\t\t\ttrio_string_terminate(info);\n\t\t\t*result = trio_string_extract(info);\n\t\t}\n\t\ttrio_string_destroy(info);\n\t}\n\treturn status;\n}\n#endif /* TRIO_FEATURE_DYNAMICSTRING */\n\n/**\n   Allocate and print to string.\n   The memory allocated and returned by @p result must be freed by the\n   calling application.\n\n   @param result Output string.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_DYNAMICSTRING\nTRIO_PUBLIC int trio_vasprintf TRIO_ARGS3((result, format, args), char** result,\n                                          TRIO_CONST char* format, va_list args)\n{\n\tint status;\n\ttrio_string_t* info;\n\n\tassert(VALID(format));\n\n\t*result = NULL;\n\n\tinfo = trio_xstring_duplicate(\"\");\n\tif (info == NULL)\n\t{\n\t\tstatus = TRIO_ERROR_RETURN(TRIO_ENOMEM, 0);\n\t}\n\telse\n\t{\n\t\tstatus = TrioFormat(info, 0, TrioOutStreamStringDynamic, format, args, NULL, NULL);\n\t\tif (status >= 0)\n\t\t{\n\t\t\ttrio_string_terminate(info);\n\t\t\t*result = trio_string_extract(info);\n\t\t}\n\t\ttrio_string_destroy(info);\n\t}\n\treturn status;\n}\n#endif /* TRIO_FEATURE_DYNAMICSTRING */\n\n/**\n   Allocate and print to string.\n   The memory allocated and returned by @p result must be freed by the\n   calling application.\n\n   @param result Output string.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_DYNAMICSTRING\nTRIO_PUBLIC int trio_asprintfv TRIO_ARGS3((result, format, args), char** result,\n                                          TRIO_CONST char* format, trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\tint status;\n\ttrio_string_t* info;\n\n\tassert(VALID(format));\n\n\t*result = NULL;\n\n\tinfo = trio_xstring_duplicate(\"\");\n\tif (info == NULL)\n\t{\n\t\tstatus = TRIO_ERROR_RETURN(TRIO_ENOMEM, 0);\n\t}\n\telse\n\t{\n\t\tstatus =\n\t\t    TrioFormat(info, 0, TrioOutStreamStringDynamic, format, unused, TrioArrayGetter, args);\n\t\tif (status >= 0)\n\t\t{\n\t\t\ttrio_string_terminate(info);\n\t\t\t*result = trio_string_extract(info);\n\t\t}\n\t\ttrio_string_destroy(info);\n\t}\n\treturn status;\n}\n#endif /* TRIO_FEATURE_DYNAMICSTRING */\n\n#if defined(TRIO_DOCUMENTATION)\n#include \"doc/doc_printf.h\"\n#endif\n\n/** @} End of Printf documentation module */\n\n/*************************************************************************\n *\n * CALLBACK\n *\n ************************************************************************/\n\n#if defined(TRIO_DOCUMENTATION)\n#include \"doc/doc_register.h\"\n#endif\n/**\n   @addtogroup UserDefined\n   @{\n*/\n\n#if TRIO_FEATURE_USER_DEFINED\n\n/*************************************************************************\n * trio_register\n */\n\n/**\n   Register new user-defined specifier.\n\n   @param callback\n   @param name\n   @return Handle.\n */\nTRIO_PUBLIC trio_pointer_t trio_register TRIO_ARGS2((callback, name), trio_callback_t callback,\n                                                    TRIO_CONST char* name)\n{\n\ttrio_userdef_t* def;\n\ttrio_userdef_t* prev = NULL;\n\n\tif (callback == NULL)\n\t\treturn NULL;\n\n\tif (name)\n\t{\n\t\t/* Handle built-in namespaces */\n\t\tif (name[0] == ':')\n\t\t{\n\t\t\tif (trio_equal(name, \":enter\"))\n\t\t\t{\n\t\t\t\tinternalEnterCriticalRegion = callback;\n\t\t\t}\n\t\t\telse if (trio_equal(name, \":leave\"))\n\t\t\t{\n\t\t\t\tinternalLeaveCriticalRegion = callback;\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Bail out if namespace is too long */\n\t\tif (trio_length(name) >= MAX_USER_NAME)\n\t\t\treturn NULL;\n\n\t\t/* Bail out if namespace already is registered */\n\t\tdef = TrioFindNamespace(name, &prev);\n\t\tif (def)\n\t\t\treturn NULL;\n\t}\n\n\tdef = (trio_userdef_t*)TRIO_MALLOC(sizeof(trio_userdef_t));\n\tif (def)\n\t{\n\t\tif (internalEnterCriticalRegion)\n\t\t\t(void)internalEnterCriticalRegion(NULL);\n\n\t\tif (name)\n\t\t{\n\t\t\t/* Link into internal list */\n\t\t\tif (prev == NULL)\n\t\t\t\tinternalUserDef = def;\n\t\t\telse\n\t\t\t\tprev->next = def;\n\t\t}\n\t\t/* Initialize */\n\t\tdef->callback = callback;\n\t\tdef->name = (name == NULL) ? NULL : trio_duplicate(name);\n\t\tdef->next = NULL;\n\n\t\tif (internalLeaveCriticalRegion)\n\t\t\t(void)internalLeaveCriticalRegion(NULL);\n\t}\n\treturn (trio_pointer_t)def;\n}\n\n/**\n   Unregister an existing user-defined specifier.\n\n   @param handle\n */\nvoid trio_unregister TRIO_ARGS1((handle), trio_pointer_t handle)\n{\n\ttrio_userdef_t* self = (trio_userdef_t*)handle;\n\ttrio_userdef_t* def;\n\ttrio_userdef_t* prev = NULL;\n\n\tassert(VALID(self));\n\n\tif (self->name)\n\t{\n\t\tdef = TrioFindNamespace(self->name, &prev);\n\t\tif (def)\n\t\t{\n\t\t\tif (internalEnterCriticalRegion)\n\t\t\t\t(void)internalEnterCriticalRegion(NULL);\n\n\t\t\tif (prev == NULL)\n\t\t\t\tinternalUserDef = internalUserDef->next;\n\t\t\telse\n\t\t\t\tprev->next = def->next;\n\n\t\t\tif (internalLeaveCriticalRegion)\n\t\t\t\t(void)internalLeaveCriticalRegion(NULL);\n\t\t}\n\t\ttrio_destroy(self->name);\n\t}\n\tTRIO_FREE(self);\n}\n\n/*************************************************************************\n * trio_get_format [public]\n */\nTRIO_CONST char* trio_get_format TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n#if TRIO_FEATURE_USER_DEFINED\n\tassert(((trio_reference_t*)ref)->parameter->type == FORMAT_USER_DEFINED);\n#endif\n\n\treturn (((trio_reference_t*)ref)->parameter->user_data);\n}\n\n/*************************************************************************\n * trio_get_argument [public]\n */\ntrio_pointer_t trio_get_argument TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n#if TRIO_FEATURE_USER_DEFINED\n\tassert(((trio_reference_t*)ref)->parameter->type == FORMAT_USER_DEFINED);\n#endif\n\n\treturn ((trio_reference_t*)ref)->parameter->data.pointer;\n}\n\n/*************************************************************************\n * trio_get_width / trio_set_width [public]\n */\nint trio_get_width TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn ((trio_reference_t*)ref)->parameter->width;\n}\n\nvoid trio_set_width TRIO_ARGS2((ref, width), trio_pointer_t ref, int width)\n{\n\t((trio_reference_t*)ref)->parameter->width = width;\n}\n\n/*************************************************************************\n * trio_get_precision / trio_set_precision [public]\n */\nint trio_get_precision TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->precision);\n}\n\nvoid trio_set_precision TRIO_ARGS2((ref, precision), trio_pointer_t ref, int precision)\n{\n\t((trio_reference_t*)ref)->parameter->precision = precision;\n}\n\n/*************************************************************************\n * trio_get_base / trio_set_base [public]\n */\nint trio_get_base TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->base);\n}\n\nvoid trio_set_base TRIO_ARGS2((ref, base), trio_pointer_t ref, int base)\n{\n\t((trio_reference_t*)ref)->parameter->base = base;\n}\n\n/*************************************************************************\n * trio_get_long / trio_set_long [public]\n */\nint trio_get_long TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_LONG) ? TRUE : FALSE;\n}\n\nvoid trio_set_long TRIO_ARGS2((ref, is_long), trio_pointer_t ref, int is_long)\n{\n\tif (is_long)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_LONG;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_LONG;\n}\n\n/*************************************************************************\n * trio_get_longlong / trio_set_longlong [public]\n */\nint trio_get_longlong TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_QUAD) ? TRUE : FALSE;\n}\n\nvoid trio_set_longlong TRIO_ARGS2((ref, is_longlong), trio_pointer_t ref, int is_longlong)\n{\n\tif (is_longlong)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_QUAD;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_QUAD;\n}\n\n/*************************************************************************\n * trio_get_longdouble / trio_set_longdouble [public]\n */\n#if TRIO_FEATURE_FLOAT\nint trio_get_longdouble TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_LONGDOUBLE) ? TRUE : FALSE;\n}\n\nvoid trio_set_longdouble TRIO_ARGS2((ref, is_longdouble), trio_pointer_t ref, int is_longdouble)\n{\n\tif (is_longdouble)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_LONGDOUBLE;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_LONGDOUBLE;\n}\n#endif /* TRIO_FEATURE_FLOAT */\n\n/*************************************************************************\n * trio_get_short / trio_set_short [public]\n */\nint trio_get_short TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_SHORT) ? TRUE : FALSE;\n}\n\nvoid trio_set_short TRIO_ARGS2((ref, is_short), trio_pointer_t ref, int is_short)\n{\n\tif (is_short)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_SHORT;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_SHORT;\n}\n\n/*************************************************************************\n * trio_get_shortshort / trio_set_shortshort [public]\n */\nint trio_get_shortshort TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_SHORTSHORT) ? TRUE : FALSE;\n}\n\nvoid trio_set_shortshort TRIO_ARGS2((ref, is_shortshort), trio_pointer_t ref, int is_shortshort)\n{\n\tif (is_shortshort)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_SHORTSHORT;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_SHORTSHORT;\n}\n\n/*************************************************************************\n * trio_get_alternative / trio_set_alternative [public]\n */\nint trio_get_alternative TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_ALTERNATIVE) ? TRUE : FALSE;\n}\n\nvoid trio_set_alternative TRIO_ARGS2((ref, is_alternative), trio_pointer_t ref, int is_alternative)\n{\n\tif (is_alternative)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_ALTERNATIVE;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_ALTERNATIVE;\n}\n\n/*************************************************************************\n * trio_get_alignment / trio_set_alignment [public]\n */\nint trio_get_alignment TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_LEFTADJUST) ? TRUE : FALSE;\n}\n\nvoid trio_set_alignment TRIO_ARGS2((ref, is_leftaligned), trio_pointer_t ref, int is_leftaligned)\n{\n\tif (is_leftaligned)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_LEFTADJUST;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_LEFTADJUST;\n}\n\n/*************************************************************************\n * trio_get_spacing /trio_set_spacing [public]\n */\nint trio_get_spacing TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_SPACE) ? TRUE : FALSE;\n}\n\nvoid trio_set_spacing TRIO_ARGS2((ref, is_space), trio_pointer_t ref, int is_space)\n{\n\tif (is_space)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_SPACE;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_SPACE;\n}\n\n/*************************************************************************\n * trio_get_sign / trio_set_sign [public]\n */\nint trio_get_sign TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_SHOWSIGN) ? TRUE : FALSE;\n}\n\nvoid trio_set_sign TRIO_ARGS2((ref, is_sign), trio_pointer_t ref, int is_sign)\n{\n\tif (is_sign)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_SHOWSIGN;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_SHOWSIGN;\n}\n\n/*************************************************************************\n * trio_get_padding / trio_set_padding [public]\n */\nint trio_get_padding TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_NILPADDING) ? TRUE : FALSE;\n}\n\nvoid trio_set_padding TRIO_ARGS2((ref, is_padding), trio_pointer_t ref, int is_padding)\n{\n\tif (is_padding)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_NILPADDING;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_NILPADDING;\n}\n\n/*************************************************************************\n * trio_get_quote / trio_set_quote [public]\n */\n#if TRIO_FEATURE_QUOTE\nint trio_get_quote TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_QUOTE) ? TRUE : FALSE;\n}\n\nvoid trio_set_quote TRIO_ARGS2((ref, is_quote), trio_pointer_t ref, int is_quote)\n{\n\tif (is_quote)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_QUOTE;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_QUOTE;\n}\n#endif /* TRIO_FEATURE_QUOTE */\n\n/*************************************************************************\n * trio_get_upper / trio_set_upper [public]\n */\nint trio_get_upper TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_UPPER) ? TRUE : FALSE;\n}\n\nvoid trio_set_upper TRIO_ARGS2((ref, is_upper), trio_pointer_t ref, int is_upper)\n{\n\tif (is_upper)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_UPPER;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_UPPER;\n}\n\n/*************************************************************************\n * trio_get_largest / trio_set_largest [public]\n */\n#if TRIO_FEATURE_INTMAX_T\nint trio_get_largest TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_INTMAX_T) ? TRUE : FALSE;\n}\n\nvoid trio_set_largest TRIO_ARGS2((ref, is_largest), trio_pointer_t ref, int is_largest)\n{\n\tif (is_largest)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_INTMAX_T;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_INTMAX_T;\n}\n#endif /* TRIO_FEATURE_INTMAX_T */\n\n/*************************************************************************\n * trio_get_ptrdiff / trio_set_ptrdiff [public]\n */\n#if TRIO_FEATURE_PTRDIFF_T\nint trio_get_ptrdiff TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_PTRDIFF_T) ? TRUE : FALSE;\n}\n\nvoid trio_set_ptrdiff TRIO_ARGS2((ref, is_ptrdiff), trio_pointer_t ref, int is_ptrdiff)\n{\n\tif (is_ptrdiff)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_PTRDIFF_T;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_PTRDIFF_T;\n}\n#endif /* TRIO_FEATURE_PTRDIFF_T */\n\n/*************************************************************************\n * trio_get_size / trio_set_size [public]\n */\n#if TRIO_FEATURE_SIZE_T\nint trio_get_size TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_SIZE_T) ? TRUE : FALSE;\n}\n\nvoid trio_set_size TRIO_ARGS2((ref, is_size), trio_pointer_t ref, int is_size)\n{\n\tif (is_size)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_SIZE_T;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_SIZE_T;\n}\n#endif /* TRIO_FEATURE_SIZE_T */\n\n/*************************************************************************\n * trio_print_int [public]\n */\nvoid trio_print_int TRIO_ARGS2((ref, number), trio_pointer_t ref, int number)\n{\n\ttrio_reference_t* self = (trio_reference_t*)ref;\n\n\tTrioWriteNumber(self->data, (trio_uintmax_t)number, self->parameter->flags,\n\t                self->parameter->width, self->parameter->precision, self->parameter->base);\n}\n\n/*************************************************************************\n * trio_print_uint [public]\n */\nvoid trio_print_uint TRIO_ARGS2((ref, number), trio_pointer_t ref, unsigned int number)\n{\n\ttrio_reference_t* self = (trio_reference_t*)ref;\n\n\tTrioWriteNumber(self->data, (trio_uintmax_t)number, self->parameter->flags | FLAGS_UNSIGNED,\n\t                self->parameter->width, self->parameter->precision, self->parameter->base);\n}\n\n/*************************************************************************\n * trio_print_double [public]\n */\n#if TRIO_FEATURE_FLOAT\nvoid trio_print_double TRIO_ARGS2((ref, number), trio_pointer_t ref, double number)\n{\n\ttrio_reference_t* self = (trio_reference_t*)ref;\n\n\tTrioWriteDouble(self->data, number, self->parameter->flags, self->parameter->width,\n\t                self->parameter->precision, self->parameter->base);\n}\n#endif /* TRIO_FEATURE_FLOAT */\n\n/*************************************************************************\n * trio_print_string [public]\n */\nvoid trio_print_string TRIO_ARGS2((ref, string), trio_pointer_t ref, TRIO_CONST char* string)\n{\n\ttrio_reference_t* self = (trio_reference_t*)ref;\n\n\tTrioWriteString(self->data, string, self->parameter->flags, self->parameter->width,\n\t                self->parameter->precision);\n}\n\n/*************************************************************************\n * trio_print_ref [public]\n */\nint trio_print_ref TRIO_VARGS3((ref, format, va_alist), trio_pointer_t ref, TRIO_CONST char* format,\n                               TRIO_VA_DECL)\n{\n\tint status;\n\tva_list arglist;\n\n\tassert(VALID(format));\n\n\tTRIO_VA_START(arglist, format);\n\tstatus = TrioFormatRef((trio_reference_t*)ref, format, arglist, NULL, NULL);\n\tTRIO_VA_END(arglist);\n\treturn status;\n}\n\n/*************************************************************************\n * trio_vprint_ref [public]\n */\nint trio_vprint_ref TRIO_ARGS3((ref, format, arglist), trio_pointer_t ref, TRIO_CONST char* format,\n                               va_list arglist)\n{\n\tassert(VALID(format));\n\n\treturn TrioFormatRef((trio_reference_t*)ref, format, arglist, NULL, NULL);\n}\n\n/*************************************************************************\n * trio_printv_ref [public]\n */\nint trio_printv_ref TRIO_ARGS3((ref, format, argarray), trio_pointer_t ref, TRIO_CONST char* format,\n                               trio_pointer_t* argarray)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(format));\n\n\treturn TrioFormatRef((trio_reference_t*)ref, format, unused, TrioArrayGetter, argarray);\n}\n\n#endif\n\n/*************************************************************************\n * trio_print_pointer [public]\n */\nvoid trio_print_pointer TRIO_ARGS2((ref, pointer), trio_pointer_t ref, trio_pointer_t pointer)\n{\n\ttrio_reference_t* self = (trio_reference_t*)ref;\n\ttrio_flags_t flags;\n\ttrio_uintmax_t number;\n\n\tif (NULL == pointer)\n\t{\n\t\tTRIO_CONST char* string = internalNullString;\n\t\twhile (*string)\n\t\t\tself->data->OutStream(self->data, *string++);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * The subtraction of the null pointer is a workaround\n\t\t * to avoid a compiler warning. The performance overhead\n\t\t * is negligible (and likely to be removed by an\n\t\t * optimizing compiler). The (char *) casting is done\n\t\t * to please ANSI C++.\n\t\t */\n\t\tnumber = (trio_uintmax_t)((char*)pointer - (char*)0);\n\t\t/* Shrink to size of pointer */\n\t\tnumber &= (trio_uintmax_t)-1;\n\t\tflags = self->parameter->flags;\n\t\tflags |= (FLAGS_UNSIGNED | FLAGS_ALTERNATIVE | FLAGS_NILPADDING);\n\t\tTrioWriteNumber(self->data, number, flags, POINTER_WIDTH, NO_PRECISION, BASE_HEX);\n\t}\n}\n\n/** @} End of UserDefined documentation module */\n\n/*************************************************************************\n *\n * LOCALES\n *\n ************************************************************************/\n\n/*************************************************************************\n * trio_locale_set_decimal_point\n *\n * Decimal point can only be one character. The input argument is a\n * string to enable multibyte characters. At most MB_LEN_MAX characters\n * will be used.\n */\n#if TRIO_FEATURE_LOCALE\nTRIO_PUBLIC void trio_locale_set_decimal_point TRIO_ARGS1((decimalPoint), char* decimalPoint)\n{\n#if defined(USE_LOCALE)\n\tif (NULL == internalLocaleValues)\n\t{\n\t\tTrioSetLocale();\n\t}\n#endif\n\tinternalDecimalPointLength = trio_length(decimalPoint);\n\tif (internalDecimalPointLength == 1)\n\t{\n\t\tinternalDecimalPoint = *decimalPoint;\n\t}\n\telse\n\t{\n\t\tinternalDecimalPoint = NIL;\n\t\ttrio_copy_max(internalDecimalPointString, sizeof(internalDecimalPointString), decimalPoint);\n\t}\n}\n#endif\n\n/*************************************************************************\n * trio_locale_set_thousand_separator\n *\n * See trio_locale_set_decimal_point\n */\n#if TRIO_FEATURE_LOCALE || TRIO_EXTENSION\nTRIO_PUBLIC void trio_locale_set_thousand_separator TRIO_ARGS1((thousandSeparator),\n                                                               char* thousandSeparator)\n{\n#if defined(USE_LOCALE)\n\tif (NULL == internalLocaleValues)\n\t{\n\t\tTrioSetLocale();\n\t}\n#endif\n\ttrio_copy_max(internalThousandSeparator, sizeof(internalThousandSeparator), thousandSeparator);\n\tinternalThousandSeparatorLength = trio_length(internalThousandSeparator);\n}\n#endif\n\n/*************************************************************************\n * trio_locale_set_grouping\n *\n * Array of bytes. Reversed order.\n *\n *  CHAR_MAX : No further grouping\n *  0        : Repeat last group for the remaining digits (not necessary\n *             as C strings are zero-terminated)\n *  n        : Set current group to n\n *\n * Same order as the grouping attribute in LC_NUMERIC.\n */\n#if TRIO_FEATURE_LOCALE || TRIO_EXTENSION\nTRIO_PUBLIC void trio_locale_set_grouping TRIO_ARGS1((grouping), char* grouping)\n{\n#if defined(USE_LOCALE)\n\tif (NULL == internalLocaleValues)\n\t{\n\t\tTrioSetLocale();\n\t}\n#endif\n\ttrio_copy_max(internalGrouping, sizeof(internalGrouping), grouping);\n}\n#endif\n\n/*************************************************************************\n *\n * SCANNING\n *\n ************************************************************************/\n\n#if TRIO_FEATURE_SCANF\n\n/*************************************************************************\n * TrioSkipWhitespaces\n */\nTRIO_PRIVATE int TrioSkipWhitespaces TRIO_ARGS1((self), trio_class_t* self)\n{\n\tint ch;\n\n\tch = self->current;\n\twhile (isspace(ch))\n\t{\n\t\tself->InStream(self, &ch);\n\t}\n\treturn ch;\n}\n\n/*************************************************************************\n * TrioGetCollation\n */\n#if TRIO_EXTENSION\nTRIO_PRIVATE void TrioGetCollation(TRIO_NOARGS)\n{\n\tint i;\n\tint j;\n\tint k;\n\tchar first[2];\n\tchar second[2];\n\n\t/* This is computationally expensive */\n\tfirst[1] = NIL;\n\tsecond[1] = NIL;\n\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t{\n\t\tk = 0;\n\t\tfirst[0] = (char)i;\n\t\tfor (j = 0; j < MAX_CHARACTER_CLASS; j++)\n\t\t{\n\t\t\tsecond[0] = (char)j;\n\t\t\tif (trio_equal_locale(first, second))\n\t\t\t\tinternalCollationArray[i][k++] = (char)j;\n\t\t}\n\t\tinternalCollationArray[i][k] = NIL;\n\t}\n}\n#endif\n\n/*************************************************************************\n * TrioGetCharacterClass\n *\n * FIXME:\n *  multibyte\n */\nTRIO_PRIVATE int TrioGetCharacterClass TRIO_ARGS4((format, offsetPointer, flagsPointer,\n                                                   characterclass),\n                                                  TRIO_CONST char* format, int* offsetPointer,\n                                                  trio_flags_t* flagsPointer, int* characterclass)\n{\n\tint offset = *offsetPointer;\n\tint i;\n\tchar ch;\n\tchar range_begin;\n\tchar range_end;\n\n\t*flagsPointer &= ~FLAGS_EXCLUDE;\n\n\tif (format[offset] == QUALIFIER_CIRCUMFLEX)\n\t{\n\t\t*flagsPointer |= FLAGS_EXCLUDE;\n\t\toffset++;\n\t}\n\t/*\n\t * If the ungroup character is at the beginning of the scanlist,\n\t * it will be part of the class, and a second ungroup character\n\t * must follow to end the group.\n\t */\n\tif (format[offset] == SPECIFIER_UNGROUP)\n\t{\n\t\tcharacterclass[(int)SPECIFIER_UNGROUP]++;\n\t\toffset++;\n\t}\n\t/*\n\t * Minus is used to specify ranges. To include minus in the class,\n\t * it must be at the beginning of the list\n\t */\n\tif (format[offset] == QUALIFIER_MINUS)\n\t{\n\t\tcharacterclass[(int)QUALIFIER_MINUS]++;\n\t\toffset++;\n\t}\n\t/* Collect characters */\n\tfor (ch = format[offset]; (ch != SPECIFIER_UNGROUP) && (ch != NIL); ch = format[++offset])\n\t{\n\t\tswitch (ch)\n\t\t{\n\t\t\tcase QUALIFIER_MINUS: /* Scanlist ranges */\n\n\t\t\t\t/*\n\t\t\t\t * Both C99 and UNIX98 describes ranges as implementation-\n\t\t\t\t * defined.\n\t\t\t\t *\n\t\t\t\t * We support the following behaviour (although this may\n\t\t\t\t * change as we become wiser)\n\t\t\t\t * - only increasing ranges, ie. [a-b] but not [b-a]\n\t\t\t\t * - transitive ranges, ie. [a-b-c] == [a-c]\n\t\t\t\t * - trailing minus, ie. [a-] is interpreted as an 'a'\n\t\t\t\t *   and a '-'\n\t\t\t\t * - duplicates (although we can easily convert these\n\t\t\t\t *   into errors)\n\t\t\t\t */\n\t\t\t\trange_begin = format[offset - 1];\n\t\t\t\trange_end = format[++offset];\n\t\t\t\tif (range_end == SPECIFIER_UNGROUP)\n\t\t\t\t{\n\t\t\t\t\t/* Trailing minus is included */\n\t\t\t\t\tcharacterclass[(int)ch]++;\n\t\t\t\t\tch = range_end;\n\t\t\t\t\tbreak; /* for */\n\t\t\t\t}\n\t\t\t\tif (range_end == NIL)\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t\t\tif (range_begin > range_end)\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_ERANGE, offset);\n\n\t\t\t\tfor (i = (int)range_begin; i <= (int)range_end; i++)\n\t\t\t\t\tcharacterclass[i]++;\n\n\t\t\t\tch = range_end;\n\t\t\t\tbreak;\n\n#if TRIO_EXTENSION\n\n\t\t\tcase SPECIFIER_GROUP:\n\n\t\t\t\tswitch (format[offset + 1])\n\t\t\t\t{\n\t\t\t\t\tcase QUALIFIER_DOT: /* Collating symbol */\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * FIXME: This will be easier to implement when multibyte\n\t\t\t\t\t\t * characters have been implemented. Until now, we ignore\n\t\t\t\t\t\t * this feature.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tfor (i = offset + 2;; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (format[i] == NIL)\n\t\t\t\t\t\t\t\t/* Error in syntax */\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\telse if (format[i] == QUALIFIER_DOT)\n\t\t\t\t\t\t\t\tbreak; /* for */\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (format[++i] != SPECIFIER_UNGROUP)\n\t\t\t\t\t\t\treturn -1;\n\n\t\t\t\t\t\toffset = i;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase QUALIFIER_EQUAL: /* Equivalence class expressions */\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned int j;\n\t\t\t\t\t\tunsigned int k;\n\n\t\t\t\t\t\tif (internalCollationUnconverted)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Lazy evaluation of collation array */\n\t\t\t\t\t\t\tTrioGetCollation();\n\t\t\t\t\t\t\tinternalCollationUnconverted = FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (i = offset + 2;; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (format[i] == NIL)\n\t\t\t\t\t\t\t\t/* Error in syntax */\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\telse if (format[i] == QUALIFIER_EQUAL)\n\t\t\t\t\t\t\t\tbreak; /* for */\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Mark any equivalent character */\n\t\t\t\t\t\t\t\tk = (unsigned int)format[i];\n\t\t\t\t\t\t\t\tfor (j = 0; internalCollationArray[k][j] != NIL; j++)\n\t\t\t\t\t\t\t\t\tcharacterclass[(int)internalCollationArray[k][j]]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (format[++i] != SPECIFIER_UNGROUP)\n\t\t\t\t\t\t\treturn -1;\n\n\t\t\t\t\t\toffset = i;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase QUALIFIER_COLON: /* Character class expressions */\n\n\t\t\t\t\t\tif (trio_equal_max(CLASS_ALNUM, sizeof(CLASS_ALNUM) - 1, &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isalnum(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_ALNUM) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_ALPHA, sizeof(CLASS_ALPHA) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isalpha(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_ALPHA) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_CNTRL, sizeof(CLASS_CNTRL) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (iscntrl(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_CNTRL) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_DIGIT, sizeof(CLASS_DIGIT) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isdigit(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_DIGIT) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_GRAPH, sizeof(CLASS_GRAPH) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isgraph(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_GRAPH) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_LOWER, sizeof(CLASS_LOWER) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (islower(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_LOWER) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_PRINT, sizeof(CLASS_PRINT) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isprint(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_PRINT) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_PUNCT, sizeof(CLASS_PUNCT) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (ispunct(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_PUNCT) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_SPACE, sizeof(CLASS_SPACE) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isspace(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_SPACE) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_UPPER, sizeof(CLASS_UPPER) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isupper(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_UPPER) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_XDIGIT, sizeof(CLASS_XDIGIT) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isxdigit(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_XDIGIT) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcharacterclass[(int)ch]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcharacterclass[(int)ch]++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n#endif /* TRIO_EXTENSION */\n\n\t\t\tdefault:\n\t\t\t\tcharacterclass[(int)ch]++;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*************************************************************************\n * TrioReadNumber\n *\n * We implement our own number conversion in preference of strtol and\n * strtoul, because we must handle 'long long' and thousand separators.\n */\nTRIO_PRIVATE BOOLEAN_T TrioReadNumber TRIO_ARGS5((self, target, flags, width, base),\n                                                 trio_class_t* self, trio_uintmax_t* target,\n                                                 trio_flags_t flags, int width, int base)\n{\n\ttrio_uintmax_t number = 0;\n\tint digit;\n\tint count;\n\tBOOLEAN_T isNegative = FALSE;\n\tBOOLEAN_T gotNumber = FALSE;\n\tint j;\n\n\tassert(VALID(self));\n\tassert(VALID(self->InStream));\n\tassert((base >= MIN_BASE && base <= MAX_BASE) || (base == NO_BASE));\n\n\tif (internalDigitsUnconverted)\n\t{\n\t\t/* Lazy evaluation of digits array */\n\t\tmemset(internalDigitArray, -1, sizeof(internalDigitArray));\n\t\tfor (j = 0; j < (int)sizeof(internalDigitsLower) - 1; j++)\n\t\t{\n\t\t\tinternalDigitArray[(int)internalDigitsLower[j]] = j;\n\t\t\tinternalDigitArray[(int)internalDigitsUpper[j]] = j;\n\t\t}\n\t\tinternalDigitsUnconverted = FALSE;\n\t}\n\n\tTrioSkipWhitespaces(self);\n\n\t/* Leading sign */\n\tif (self->current == '+')\n\t{\n\t\tself->InStream(self, NULL);\n\t}\n\telse if (self->current == '-')\n\t{\n\t\tself->InStream(self, NULL);\n\t\tisNegative = TRUE;\n\t}\n\n\tcount = self->processed;\n\n\tif (flags & FLAGS_ALTERNATIVE)\n\t{\n\t\tswitch (base)\n\t\t{\n\t\t\tcase NO_BASE:\n\t\t\tcase BASE_OCTAL:\n\t\t\tcase BASE_HEX:\n\t\t\tcase BASE_BINARY:\n\t\t\t\tif (self->current == '0')\n\t\t\t\t{\n\t\t\t\t\tself->InStream(self, NULL);\n\t\t\t\t\tif (self->current)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((base == BASE_HEX) && (trio_to_upper(self->current) == 'X'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tself->InStream(self, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((base == BASE_BINARY) && (trio_to_upper(self->current) == 'B'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tself->InStream(self, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn FALSE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (((width == NO_WIDTH) || (self->processed - count < width)) &&\n\t       (!((self->current == EOF) || isspace(self->current))))\n\t{\n\t\tif (isascii(self->current))\n\t\t{\n\t\t\tdigit = internalDigitArray[self->current];\n\t\t\t/* Abort if digit is not allowed in the specified base */\n\t\t\tif ((digit == -1) || (digit >= base))\n\t\t\t\tbreak;\n\t\t}\n#if TRIO_FEATURE_QUOTE\n\t\telse if (flags & FLAGS_QUOTE)\n\t\t{\n\t\t\t/* Compare with thousands separator */\n\t\t\tfor (j = 0; internalThousandSeparator[j] && self->current; j++)\n\t\t\t{\n\t\t\t\tif (internalThousandSeparator[j] != self->current)\n\t\t\t\t\tbreak;\n\n\t\t\t\tself->InStream(self, NULL);\n\t\t\t}\n\t\t\tif (internalThousandSeparator[j])\n\t\t\t\tbreak; /* Mismatch */\n\t\t\telse\n\t\t\t\tcontinue; /* Match */\n\t\t}\n#endif\n\t\telse\n\t\t\tbreak;\n\n\t\tnumber *= base;\n\t\tnumber += digit;\n\t\tgotNumber = TRUE; /* we need at least one digit */\n\n\t\tself->InStream(self, NULL);\n\t}\n\n\t/* Was anything read at all? */\n\tif (!gotNumber)\n\t\treturn FALSE;\n\n\tif (target)\n\t\t*target = (isNegative) ? (trio_uintmax_t)(-((trio_intmax_t)number)) : number;\n\treturn TRUE;\n}\n\n/*************************************************************************\n * TrioReadChar\n */\nTRIO_PRIVATE int TrioReadChar TRIO_ARGS4((self, target, flags, width), trio_class_t* self,\n                                         char* target, trio_flags_t flags, int width)\n{\n\tint i;\n\tchar ch;\n\ttrio_uintmax_t number;\n\n\tassert(VALID(self));\n\tassert(VALID(self->InStream));\n\n\tfor (i = 0; (self->current != EOF) && (i < width); i++)\n\t{\n\t\tch = (char)self->current;\n\t\tself->InStream(self, NULL);\n\t\tif ((flags & FLAGS_ALTERNATIVE) && (ch == CHAR_BACKSLASH))\n\t\t{\n\t\t\tswitch (self->current)\n\t\t\t{\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tch = '\\\\';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'a':\n\t\t\t\t\tch = '\\007';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tch = '\\b';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tch = '\\f';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\tch = '\\n';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\t\tch = '\\r';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\tch = '\\t';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tch = '\\v';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (isdigit(self->current))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Read octal number */\n\t\t\t\t\t\tif (!TrioReadNumber(self, &number, 0, 3, BASE_OCTAL))\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\tch = (char)number;\n\t\t\t\t\t}\n\t\t\t\t\telse if (trio_to_upper(self->current) == 'X')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Read hexadecimal number */\n\t\t\t\t\t\tself->InStream(self, NULL);\n\t\t\t\t\t\tif (!TrioReadNumber(self, &number, 0, 2, BASE_HEX))\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\tch = (char)number;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tch = (char)self->current;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (target)\n\t\t\ttarget[i] = ch;\n\t}\n\treturn i + 1;\n}\n\n/*************************************************************************\n * TrioReadString\n */\nTRIO_PRIVATE BOOLEAN_T TrioReadString TRIO_ARGS4((self, target, flags, width), trio_class_t* self,\n                                                 char* target, trio_flags_t flags, int width)\n{\n\tint i;\n\n\tassert(VALID(self));\n\tassert(VALID(self->InStream));\n\n\tTrioSkipWhitespaces(self);\n\n\t/*\n\t * Continue until end of string is reached, a whitespace is encountered,\n\t * or width is exceeded\n\t */\n\tfor (i = 0; ((width == NO_WIDTH) || (i < width)) &&\n\t            (!((self->current == EOF) || isspace(self->current)));\n\t     i++)\n\t{\n\t\tif (TrioReadChar(self, (target ? &target[i] : 0), flags, 1) == 0)\n\t\t\tbreak; /* for */\n\t}\n\tif (target)\n\t\ttarget[i] = NIL;\n\treturn TRUE;\n}\n\n/*************************************************************************\n * TrioReadWideChar\n */\n#if TRIO_FEATURE_WIDECHAR\nTRIO_PRIVATE int TrioReadWideChar TRIO_ARGS4((self, target, flags, width), trio_class_t* self,\n                                             trio_wchar_t* target, trio_flags_t flags, int width)\n{\n\tint i;\n\tint j;\n\tint size;\n\tint amount = 0;\n\ttrio_wchar_t wch;\n\tchar buffer[MB_LEN_MAX + 1];\n\n\tassert(VALID(self));\n\tassert(VALID(self->InStream));\n\n\tfor (i = 0; (self->current != EOF) && (i < width); i++)\n\t{\n\t\tif (isascii(self->current))\n\t\t{\n\t\t\tif (TrioReadChar(self, buffer, flags, 1) == 0)\n\t\t\t\treturn 0;\n\t\t\tbuffer[1] = NIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Collect a multibyte character, by enlarging buffer until\n\t\t\t * it contains a fully legal multibyte character, or the\n\t\t\t * buffer is full.\n\t\t\t */\n\t\t\tj = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tbuffer[j++] = (char)self->current;\n\t\t\t\tbuffer[j] = NIL;\n\t\t\t\tself->InStream(self, NULL);\n\t\t\t} while ((j < (int)sizeof(buffer)) && (mblen(buffer, (size_t)j) != j));\n\t\t}\n\t\tif (target)\n\t\t{\n\t\t\tsize = mbtowc(&wch, buffer, sizeof(buffer));\n\t\t\tif (size > 0)\n\t\t\t\ttarget[i] = wch;\n\t\t}\n\t\tamount += size;\n\t\tself->InStream(self, NULL);\n\t}\n\treturn amount;\n}\n#endif /* TRIO_FEATURE_WIDECHAR */\n\n/*************************************************************************\n * TrioReadWideString\n */\n#if TRIO_FEATURE_WIDECHAR\nTRIO_PRIVATE BOOLEAN_T TrioReadWideString TRIO_ARGS4((self, target, flags, width),\n                                                     trio_class_t* self, trio_wchar_t* target,\n                                                     trio_flags_t flags, int width)\n{\n\tint i;\n\tint size;\n\n\tassert(VALID(self));\n\tassert(VALID(self->InStream));\n\n\tTrioSkipWhitespaces(self);\n\n#if defined(TRIO_COMPILER_SUPPORTS_MULTIBYTE)\n\t/* Required by TrioReadWideChar */\n\t(void)mblen(NULL, 0);\n#endif\n\n\t/*\n\t * Continue until end of string is reached, a whitespace is encountered,\n\t * or width is exceeded\n\t */\n\tfor (i = 0; ((width == NO_WIDTH) || (i < width)) &&\n\t            (!((self->current == EOF) || isspace(self->current)));)\n\t{\n\t\tsize = TrioReadWideChar(self, &target[i], flags, 1);\n\t\tif (size == 0)\n\t\t\tbreak; /* for */\n\n\t\ti += size;\n\t}\n\tif (target)\n\t\ttarget[i] = WCONST('\\0');\n\treturn TRUE;\n}\n#endif /* TRIO_FEATURE_WIDECHAR */\n\n/*************************************************************************\n * TrioReadGroup\n *\n * Reads non-empty character groups.\n *\n * FIXME: characterclass does not work with multibyte characters\n */\nTRIO_PRIVATE BOOLEAN_T TrioReadGroup TRIO_ARGS5((self, target, characterclass, flags, width),\n                                                trio_class_t* self, char* target,\n                                                int* characterclass, trio_flags_t flags, int width)\n{\n\tint ch;\n\tint i;\n\n\tassert(VALID(self));\n\tassert(VALID(self->InStream));\n\n\tch = self->current;\n\tfor (i = 0; ((width == NO_WIDTH) || (i < width)) &&\n\t            (!((ch == EOF) || (((flags & FLAGS_EXCLUDE) != 0) ^ (characterclass[ch] == 0))));\n\t     i++)\n\t{\n\t\tif (target)\n\t\t\ttarget[i] = (char)ch;\n\t\tself->InStream(self, &ch);\n\t}\n\n\tif (i == 0)\n\t\treturn FALSE;\n\n\t/* Terminate the string if input saved */\n\tif (target)\n\t\ttarget[i] = NIL;\n\treturn TRUE;\n}\n\n/*************************************************************************\n * TrioReadDouble\n *\n * FIXME:\n *  add long double\n *  handle base\n */\n#if TRIO_FEATURE_FLOAT\nTRIO_PRIVATE BOOLEAN_T TrioReadDouble TRIO_ARGS4((self, target, flags, width), trio_class_t* self,\n                                                 trio_pointer_t target, trio_flags_t flags,\n                                                 int width)\n{\n\tint ch;\n\tchar doubleString[512];\n\tint offset = 0;\n\tint start;\n#if TRIO_FEATURE_QUOTE\n\tint j;\n#endif\n\tBOOLEAN_T isHex = FALSE;\n\ttrio_long_double_t infinity;\n\n\tdoubleString[0] = 0;\n\n\tif ((width == NO_WIDTH) || (width > (int)sizeof(doubleString) - 1))\n\t\twidth = sizeof(doubleString) - 1;\n\n\tTrioSkipWhitespaces(self);\n\n\t/*\n\t * Read entire double number from stream. trio_to_double requires\n\t * a string as input, but InStream can be anything, so we have to\n\t * collect all characters.\n\t */\n\tch = self->current;\n\tif ((ch == '+') || (ch == '-'))\n\t{\n\t\tdoubleString[offset++] = (char)ch;\n\t\tself->InStream(self, &ch);\n\t\twidth--;\n\t}\n\n\tstart = offset;\n\tswitch (ch)\n\t{\n\t\tcase 'n':\n\t\tcase 'N':\n\t\t\t/* Not-a-number */\n\t\t\tif (offset != 0)\n\t\t\t\tbreak;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 'i':\n\t\tcase 'I':\n\t\t\t/* Infinity */\n\t\t\twhile (isalpha(ch) && (offset - start < width))\n\t\t\t{\n\t\t\t\tdoubleString[offset++] = (char)ch;\n\t\t\t\tself->InStream(self, &ch);\n\t\t\t}\n\t\t\tdoubleString[offset] = NIL;\n\n\t\t\t/* Case insensitive string comparison */\n\t\t\tif (trio_equal(&doubleString[start], INFINITE_UPPER) ||\n\t\t\t    trio_equal(&doubleString[start], LONG_INFINITE_UPPER))\n\t\t\t{\n\t\t\t\tinfinity = ((start == 1) && (doubleString[0] == '-')) ? trio_ninf() : trio_pinf();\n\t\t\t\tif (!target)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tif (flags & FLAGS_LONGDOUBLE)\n\t\t\t\t{\n\t\t\t\t\t*((trio_long_double_t*)target) = infinity;\n\t\t\t\t}\n\t\t\t\telse if (flags & FLAGS_LONG)\n\t\t\t\t{\n\t\t\t\t\t*((double*)target) = infinity;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*((float*)target) = infinity;\n\t\t\t\t}\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\tif (trio_equal(doubleString, NAN_UPPER))\n\t\t\t{\n\t\t\t\tif (!target)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\t/* NaN must not have a preceeding + nor - */\n\t\t\t\tif (flags & FLAGS_LONGDOUBLE)\n\t\t\t\t{\n\t\t\t\t\t*((trio_long_double_t*)target) = trio_nan();\n\t\t\t\t}\n\t\t\t\telse if (flags & FLAGS_LONG)\n\t\t\t\t{\n\t\t\t\t\t*((double*)target) = trio_nan();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*((float*)target) = trio_nan();\n\t\t\t\t}\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\treturn FALSE;\n\n\t\tcase '0':\n\t\t\tdoubleString[offset++] = (char)ch;\n\t\t\tself->InStream(self, &ch);\n\t\t\tif (trio_to_upper(ch) == 'X')\n\t\t\t{\n\t\t\t\tisHex = TRUE;\n\t\t\t\tdoubleString[offset++] = (char)ch;\n\t\t\t\tself->InStream(self, &ch);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\twhile ((ch != EOF) && (offset - start < width))\n\t{\n\t\t/* Integer part */\n\t\tif (isHex ? isxdigit(ch) : isdigit(ch))\n\t\t{\n\t\t\tdoubleString[offset++] = (char)ch;\n\t\t\tself->InStream(self, &ch);\n\t\t}\n#if TRIO_FEATURE_QUOTE\n\t\telse if (flags & FLAGS_QUOTE)\n\t\t{\n\t\t\t/* Compare with thousands separator */\n\t\t\tfor (j = 0; internalThousandSeparator[j] && self->current; j++)\n\t\t\t{\n\t\t\t\tif (internalThousandSeparator[j] != self->current)\n\t\t\t\t\tbreak;\n\n\t\t\t\tself->InStream(self, &ch);\n\t\t\t}\n\t\t\tif (internalThousandSeparator[j])\n\t\t\t\tbreak; /* Mismatch */\n\t\t\telse\n\t\t\t\tcontinue; /* Match */\n\t\t}\n#endif\n\t\telse\n\t\t\tbreak; /* while */\n\t}\n\tif (ch == '.')\n\t{\n\t\t/* Decimal part */\n\t\tdoubleString[offset++] = (char)ch;\n\t\tself->InStream(self, &ch);\n\t\twhile ((isHex ? isxdigit(ch) : isdigit(ch)) && (offset - start < width))\n\t\t{\n\t\t\tdoubleString[offset++] = (char)ch;\n\t\t\tself->InStream(self, &ch);\n\t\t}\n\t}\n\tif (isHex ? (trio_to_upper(ch) == 'P') : (trio_to_upper(ch) == 'E'))\n\t{\n\t\t/* Exponent */\n\t\tdoubleString[offset++] = (char)ch;\n\t\tself->InStream(self, &ch);\n\t\tif ((ch == '+') || (ch == '-'))\n\t\t{\n\t\t\tdoubleString[offset++] = (char)ch;\n\t\t\tself->InStream(self, &ch);\n\t\t}\n\t\twhile (isdigit(ch) && (offset - start < width))\n\t\t{\n\t\t\tdoubleString[offset++] = (char)ch;\n\t\t\tself->InStream(self, &ch);\n\t\t}\n\t}\n\n\tif ((offset == start) || (*doubleString == NIL))\n\t\treturn FALSE;\n\n\tdoubleString[offset] = 0;\n\n\tif (flags & FLAGS_LONGDOUBLE)\n\t{\n\t\tif (!target)\n\t\t\treturn FALSE;\n\n\t\t*((trio_long_double_t*)target) = trio_to_long_double(doubleString, NULL);\n\t}\n\telse if (flags & FLAGS_LONG)\n\t{\n\t\tif (!target)\n\t\t\treturn FALSE;\n\n\t\t*((double*)target) = trio_to_double(doubleString, NULL);\n\t}\n\telse\n\t{\n\t\tif (!target)\n\t\t\treturn FALSE;\n\n\t\t*((float*)target) = trio_to_float(doubleString, NULL);\n\t}\n\treturn TRUE;\n}\n#endif /* TRIO_FEATURE_FLOAT */\n\n/*************************************************************************\n * TrioReadPointer\n */\nTRIO_PRIVATE BOOLEAN_T TrioReadPointer TRIO_ARGS3((self, target, flags), trio_class_t* self,\n                                                  trio_pointer_t* target, trio_flags_t flags)\n{\n\ttrio_uintmax_t number;\n\tchar buffer[sizeof(internalNullString)];\n\n\tflags |= (FLAGS_UNSIGNED | FLAGS_ALTERNATIVE | FLAGS_NILPADDING);\n\n\tif (TrioReadNumber(self, &number, flags, POINTER_WIDTH, BASE_HEX))\n\t{\n\t\tif (target)\n\t\t{\n#if defined(TRIO_COMPILER_GCC) || defined(TRIO_COMPILER_MIPSPRO)\n\t\t\t/*\n\t\t\t * The strange assignment of number is a workaround for a compiler\n\t\t\t * warning\n\t\t\t */\n\t\t\t*target = &((char*)0)[number];\n#else\n\t\t\t*target = (trio_pointer_t)number;\n#endif\n\t\t}\n\t\treturn TRUE;\n\t}\n\telse if (TrioReadString(self, (flags & FLAGS_IGNORE) ? NULL : buffer, 0,\n\t                        sizeof(internalNullString) - 1))\n\t{\n\t\tif (trio_equal_case(buffer, internalNullString))\n\t\t{\n\t\t\tif (target)\n\t\t\t\t*target = NULL;\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/*************************************************************************\n * TrioScanProcess\n */\nTRIO_PRIVATE int TrioScanProcess TRIO_ARGS3((data, format, parameters), trio_class_t* data,\n                                            TRIO_CONST char* format, trio_parameter_t* parameters)\n{\n\tint status;\n\tint assignment;\n\tint ch;\n\tint offset; /* Offset of format string */\n\tint i;      /* Offset of current parameter */\n\ttrio_flags_t flags;\n\tint width;\n\tint base;\n\ttrio_pointer_t pointer;\n\n\t/* Return on empty format string */\n\tif (format[0] == NIL)\n\t\treturn 0;\n\n\tstatus = 0;\n\tassignment = 0;\n\ti = 0;\n\toffset = 0;\n\tdata->InStream(data, &ch);\n\n\tfor (;;)\n\t{\n\t\t/* Skip the parameter entries */\n\t\twhile (parameters[i].type == FORMAT_PARAMETER)\n\t\t{\n\t\t\tassert(i <= MAX_PARAMETERS);\n\t\t\ti++;\n\t\t}\n\n\t\t/* Compare non conversion-specifier part of format string */\n\t\twhile (offset < parameters[i].beginOffset)\n\t\t{\n\t\t\tif ((CHAR_IDENTIFIER == format[offset]) && (CHAR_IDENTIFIER == format[offset + 1]))\n\t\t\t{\n\t\t\t\t/* Two % in format matches one % in input stream */\n\t\t\t\tif (CHAR_IDENTIFIER == ch)\n\t\t\t\t{\n\t\t\t\t\tdata->InStream(data, &ch);\n\t\t\t\t\toffset += 2;\n\t\t\t\t\tcontinue; /* while format chars left */\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstatus = TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse /* Not an % identifier */\n\t\t\t{\n\t\t\t\tif (isspace((int)format[offset]))\n\t\t\t\t{\n\t\t\t\t\t/* Whitespaces may match any amount of whitespaces */\n\t\t\t\t\tch = TrioSkipWhitespaces(data);\n\t\t\t\t}\n\t\t\t\telse if (ch == format[offset])\n\t\t\t\t{\n\t\t\t\t\tdata->InStream(data, &ch);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstatus = assignment;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\toffset++;\n\t\t\t}\n\t\t}\n\n\t\tif (parameters[i].type == FORMAT_SENTINEL)\n\t\t\tbreak;\n\n\t\tif ((EOF == ch) && (parameters[i].type != FORMAT_COUNT))\n\t\t{\n\t\t\tstatus = (assignment > 0) ? assignment : EOF;\n\t\t\tgoto end;\n\t\t}\n\n\t\tflags = parameters[i].flags;\n\n\t\t/* Find width */\n\t\twidth = parameters[i].width;\n\t\tif (flags & FLAGS_WIDTH_PARAMETER)\n\t\t{\n\t\t\t/* Get width from parameter list */\n\t\t\twidth = (int)parameters[width].data.number.as_signed;\n\t\t}\n\n\t\t/* Find base */\n\t\tif (NO_BASE != parameters[i].baseSpecifier)\n\t\t{\n\t\t\t/* Base from specifier has priority */\n\t\t\tbase = parameters[i].baseSpecifier;\n\t\t}\n\t\telse if (flags & FLAGS_BASE_PARAMETER)\n\t\t{\n\t\t\t/* Get base from parameter list */\n\t\t\tbase = parameters[i].base;\n\t\t\tbase = (int)parameters[base].data.number.as_signed;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use base from format string */\n\t\t\tbase = parameters[i].base;\n\t\t}\n\n\t\tswitch (parameters[i].type)\n\t\t{\n\t\t\tcase FORMAT_INT:\n\t\t\t{\n\t\t\t\ttrio_uintmax_t number;\n\n\t\t\t\tif (0 == base)\n\t\t\t\t\tbase = BASE_DECIMAL;\n\n\t\t\t\tif (!TrioReadNumber(data, &number, flags, width, base))\n\t\t\t\t{\n\t\t\t\t\tstatus = assignment;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\tif (!(flags & FLAGS_IGNORE))\n\t\t\t\t{\n\t\t\t\t\tassignment++;\n\n\t\t\t\t\tpointer = parameters[i].data.pointer;\n#if TRIO_FEATURE_SIZE_T || TRIO_FEATURE_SIZE_T_UPPER\n\t\t\t\t\tif (flags & FLAGS_SIZE_T)\n\t\t\t\t\t\t*(size_t*)pointer = (size_t)number;\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_PTRDIFF_T\n\t\t\t\t\t    if (flags & FLAGS_PTRDIFF_T)\n\t\t\t\t\t\t*(ptrdiff_t*)pointer = (ptrdiff_t)number;\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_INTMAX_T\n\t\t\t\t\t    if (flags & FLAGS_INTMAX_T)\n\t\t\t\t\t\t*(trio_intmax_t*)pointer = (trio_intmax_t)number;\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t    if (flags & FLAGS_QUAD)\n\t\t\t\t\t\t*(trio_ulonglong_t*)pointer = (trio_ulonglong_t)number;\n\t\t\t\t\telse if (flags & FLAGS_LONG)\n\t\t\t\t\t\t*(long int*)pointer = (long int)number;\n\t\t\t\t\telse if (flags & FLAGS_SHORT)\n\t\t\t\t\t\t*(short int*)pointer = (short int)number;\n\t\t\t\t\telse\n\t\t\t\t\t\t*(int*)pointer = (int)number;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak; /* FORMAT_INT */\n\n\t\t\tcase FORMAT_STRING:\n#if TRIO_FEATURE_WIDECHAR\n\t\t\t\tif (flags & FLAGS_WIDECHAR)\n\t\t\t\t{\n\t\t\t\t\tif (!TrioReadWideString(\n\t\t\t\t\t        data, (flags & FLAGS_IGNORE) ? NULL : parameters[i].data.wstring, flags,\n\t\t\t\t\t        width))\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus = assignment;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tif (!TrioReadString(data,\n\t\t\t\t\t                    (flags & FLAGS_IGNORE) ? NULL : parameters[i].data.string,\n\t\t\t\t\t                    flags, width))\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus = assignment;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!(flags & FLAGS_IGNORE))\n\t\t\t\t\tassignment++;\n\t\t\t\tbreak; /* FORMAT_STRING */\n\n#if TRIO_FEATURE_FLOAT\n\t\t\tcase FORMAT_DOUBLE:\n\t\t\t{\n\t\t\t\tif (flags & FLAGS_IGNORE)\n\t\t\t\t{\n\t\t\t\t\tpointer = NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpointer = (flags & FLAGS_LONGDOUBLE)\n\t\t\t\t\t              ? (trio_pointer_t)parameters[i].data.longdoublePointer\n\t\t\t\t\t              : (trio_pointer_t)parameters[i].data.doublePointer;\n\t\t\t\t}\n\t\t\t\tif (!TrioReadDouble(data, pointer, flags, width))\n\t\t\t\t{\n\t\t\t\t\tstatus = assignment;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tif (!(flags & FLAGS_IGNORE))\n\t\t\t\t{\n\t\t\t\t\tassignment++;\n\t\t\t\t}\n\t\t\t\tbreak; /* FORMAT_DOUBLE */\n\t\t\t}\n#endif\n\n\t\t\tcase FORMAT_GROUP:\n\t\t\t{\n\t\t\t\tint characterclass[MAX_CHARACTER_CLASS + 1];\n\n\t\t\t\t/* Skip over modifiers */\n\t\t\t\twhile (format[offset] != SPECIFIER_GROUP)\n\t\t\t\t{\n\t\t\t\t\toffset++;\n\t\t\t\t}\n\t\t\t\t/* Skip over group specifier */\n\t\t\t\toffset++;\n\n\t\t\t\tmemset(characterclass, 0, sizeof(characterclass));\n\t\t\t\tstatus = TrioGetCharacterClass(format, &offset, &flags, characterclass);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tgoto end;\n\n\t\t\t\tif (!TrioReadGroup(data, (flags & FLAGS_IGNORE) ? NULL : parameters[i].data.string,\n\t\t\t\t                   characterclass, flags, parameters[i].width))\n\t\t\t\t{\n\t\t\t\t\tstatus = assignment;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tif (!(flags & FLAGS_IGNORE))\n\t\t\t\t\tassignment++;\n\t\t\t}\n\t\t\tbreak; /* FORMAT_GROUP */\n\n\t\t\tcase FORMAT_COUNT:\n\t\t\t\tpointer = parameters[i].data.pointer;\n\t\t\t\tif (NULL != pointer)\n\t\t\t\t{\n\t\t\t\t\tint count = data->processed;\n\t\t\t\t\tif (ch != EOF)\n\t\t\t\t\t\tcount--; /* a character is read, but is not consumed yet */\n#if TRIO_FEATURE_SIZE_T || TRIO_FEATURE_SIZE_T_UPPER\n\t\t\t\t\tif (flags & FLAGS_SIZE_T)\n\t\t\t\t\t\t*(size_t*)pointer = (size_t)count;\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_PTRDIFF_T\n\t\t\t\t\t    if (flags & FLAGS_PTRDIFF_T)\n\t\t\t\t\t\t*(ptrdiff_t*)pointer = (ptrdiff_t)count;\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_INTMAX_T\n\t\t\t\t\t    if (flags & FLAGS_INTMAX_T)\n\t\t\t\t\t\t*(trio_intmax_t*)pointer = (trio_intmax_t)count;\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t    if (flags & FLAGS_QUAD)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(trio_ulonglong_t*)pointer = (trio_ulonglong_t)count;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flags & FLAGS_LONG)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(long int*)pointer = (long int)count;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flags & FLAGS_SHORT)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(short int*)pointer = (short int)count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t*(int*)pointer = (int)count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak; /* FORMAT_COUNT */\n\n\t\t\tcase FORMAT_CHAR:\n#if TRIO_FEATURE_WIDECHAR\n\t\t\t\tif (flags & FLAGS_WIDECHAR)\n\t\t\t\t{\n\t\t\t\t\tif (TrioReadWideChar(data,\n\t\t\t\t\t                     (flags & FLAGS_IGNORE) ? NULL : parameters[i].data.wstring,\n\t\t\t\t\t                     flags, (width == NO_WIDTH) ? 1 : width) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus = assignment;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tif (TrioReadChar(data,\n\t\t\t\t\t                 (flags & FLAGS_IGNORE) ? NULL : parameters[i].data.string,\n\t\t\t\t\t                 flags, (width == NO_WIDTH) ? 1 : width) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus = assignment;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!(flags & FLAGS_IGNORE))\n\t\t\t\t\tassignment++;\n\t\t\t\tbreak; /* FORMAT_CHAR */\n\n\t\t\tcase FORMAT_POINTER:\n\t\t\t\tif (!TrioReadPointer(\n\t\t\t\t        data,\n\t\t\t\t        (flags & FLAGS_IGNORE) ? NULL : (trio_pointer_t*)parameters[i].data.pointer,\n\t\t\t\t        flags))\n\t\t\t\t{\n\t\t\t\t\tstatus = assignment;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tif (!(flags & FLAGS_IGNORE))\n\t\t\t\t\tassignment++;\n\t\t\t\tbreak; /* FORMAT_POINTER */\n\n\t\t\tcase FORMAT_PARAMETER:\n\t\t\t\tbreak; /* FORMAT_PARAMETER */\n\n\t\t\tdefault:\n\t\t\t\tstatus = TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t\t\tgoto end;\n\t\t}\n\n\t\tch = data->current;\n\t\toffset = parameters[i].endOffset;\n\t\ti++;\n\t}\n\n\tstatus = assignment;\nend:\n\tif (data->UndoStream)\n\t\tdata->UndoStream(data);\n\treturn status;\n}\n\n/*************************************************************************\n * TrioScan\n */\nTRIO_PRIVATE int TrioScan TRIO_ARGS8(\n    (source, sourceSize, InStream, UndoStream, format, arglist, argfunc, argarray),\n    trio_pointer_t source, size_t sourceSize, void(*InStream) TRIO_PROTO((trio_class_t*, int*)),\n    void(*UndoStream) TRIO_PROTO((trio_class_t*)), TRIO_CONST char* format, va_list arglist,\n    trio_argfunc_t argfunc, trio_pointer_t* argarray)\n{\n\tint status;\n\ttrio_parameter_t parameters[MAX_PARAMETERS];\n\ttrio_class_t data;\n\n\tassert(VALID(InStream));\n\tassert(VALID(format));\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.InStream = InStream;\n\tdata.UndoStream = UndoStream;\n\tdata.location = (trio_pointer_t)source;\n\tdata.max = sourceSize;\n\tdata.error = 0;\n\n#if defined(USE_LOCALE)\n\tif (NULL == internalLocaleValues)\n\t{\n\t\tTrioSetLocale();\n\t}\n#endif\n\n\tstatus = TrioParse(TYPE_SCAN, format, parameters, arglist, argfunc, argarray);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = TrioScanProcess(&data, format, parameters);\n\tif (data.error != 0)\n\t{\n\t\tstatus = data.error;\n\t}\n\treturn status;\n}\n\n/*************************************************************************\n * TrioInStreamFile\n */\n#if TRIO_FEATURE_FILE || TRIO_FEATURE_STDIO\nTRIO_PRIVATE void TrioInStreamFile TRIO_ARGS2((self, intPointer), trio_class_t* self,\n                                              int* intPointer)\n{\n\tFILE* file = (FILE*)self->location;\n\n\tassert(VALID(self));\n\tassert(VALID(file));\n\n\tself->actually.cached = 0;\n\n\t/* The initial value of self->current is zero */\n\tif (self->current == EOF)\n\t{\n\t\tself->error =\n\t\t    (ferror(file)) ? TRIO_ERROR_RETURN(TRIO_ERRNO, 0) : TRIO_ERROR_RETURN(TRIO_EOF, 0);\n\t}\n\telse\n\t{\n\t\tself->processed++;\n\t\tself->actually.cached++;\n\t}\n\n\tself->current = fgetc(file);\n\n\tif (VALID(intPointer))\n\t{\n\t\t*intPointer = self->current;\n\t}\n}\n#endif /* TRIO_FEATURE_FILE || TRIO_FEATURE_STDIO */\n\n/*************************************************************************\n * TrioUndoStreamFile\n */\n#if TRIO_FEATURE_FILE || TRIO_FEATURE_STDIO\nTRIO_PRIVATE void TrioUndoStreamFile TRIO_ARGS1((self), trio_class_t* self)\n{\n\tFILE* file = (FILE*)self->location;\n\n\tassert(VALID(self));\n\tassert(VALID(file));\n\n\tif (self->actually.cached > 0)\n\t{\n\t\tassert(self->actually.cached == 1);\n\n\t\tself->current = ungetc(self->current, file);\n\t\tself->actually.cached = 0;\n\t}\n}\n#endif /* TRIO_FEATURE_FILE || TRIO_FEATURE_STDIO */\n\n/*************************************************************************\n * TrioInStreamFileDescriptor\n */\n#if TRIO_FEATURE_FD\nTRIO_PRIVATE void TrioInStreamFileDescriptor TRIO_ARGS2((self, intPointer), trio_class_t* self,\n                                                        int* intPointer)\n{\n\tint fd = *((int*)self->location);\n\tint size;\n\tunsigned char input;\n\n\tassert(VALID(self));\n\n\tself->actually.cached = 0;\n\n\tsize = read(fd, &input, sizeof(char));\n\tif (size == -1)\n\t{\n\t\tself->error = TRIO_ERROR_RETURN(TRIO_ERRNO, 0);\n\t\tself->current = EOF;\n\t}\n\telse\n\t{\n\t\tself->current = (size == 0) ? EOF : input;\n\t}\n\tif (self->current != EOF)\n\t{\n\t\tself->actually.cached++;\n\t\tself->processed++;\n\t}\n\n\tif (VALID(intPointer))\n\t{\n\t\t*intPointer = self->current;\n\t}\n}\n#endif /* TRIO_FEATURE_FD */\n\n/*************************************************************************\n * TrioInStreamCustom\n */\n#if TRIO_FEATURE_CLOSURE\nTRIO_PRIVATE void TrioInStreamCustom TRIO_ARGS2((self, intPointer), trio_class_t* self,\n                                                int* intPointer)\n{\n\ttrio_custom_t* data;\n\n\tassert(VALID(self));\n\tassert(VALID(self->location));\n\n\tself->actually.cached = 0;\n\n\tdata = (trio_custom_t*)self->location;\n\n\tself->current = (data->stream.in == NULL) ? NIL : (data->stream.in)(data->closure);\n\n\tif (self->current == NIL)\n\t{\n\t\tself->current = EOF;\n\t}\n\telse\n\t{\n\t\tself->processed++;\n\t\tself->actually.cached++;\n\t}\n\n\tif (VALID(intPointer))\n\t{\n\t\t*intPointer = self->current;\n\t}\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n/*************************************************************************\n * TrioInStreamString\n */\nTRIO_PRIVATE void TrioInStreamString TRIO_ARGS2((self, intPointer), trio_class_t* self,\n                                                int* intPointer)\n{\n\tunsigned char** buffer;\n\n\tassert(VALID(self));\n\tassert(VALID(self->location));\n\n\tself->actually.cached = 0;\n\n\tbuffer = (unsigned char**)self->location;\n\tself->current = (*buffer)[0];\n\tif (self->current == NIL)\n\t{\n\t\tself->current = EOF;\n\t}\n\telse\n\t{\n\t\t(*buffer)++;\n\t\tself->processed++;\n\t\tself->actually.cached++;\n\t}\n\n\tif (VALID(intPointer))\n\t{\n\t\t*intPointer = self->current;\n\t}\n}\n\n/*************************************************************************\n *\n * Formatted scanning functions\n *\n ************************************************************************/\n\n#if defined(TRIO_DOCUMENTATION)\n#include \"doc/doc_scanf.h\"\n#endif\n/** @addtogroup Scanf\n    @{\n*/\n\n/*************************************************************************\n * scanf\n */\n\n/**\n   Scan characters from standard input stream.\n\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_STDIO\nTRIO_PUBLIC int trio_scanf TRIO_VARGS2((format, va_alist), TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioScan((trio_pointer_t)stdin, 0, TrioInStreamFile, TrioUndoStreamFile, format, args,\n\t                  NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_STDIO */\n\n/**\n   Scan characters from standard input stream.\n\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_STDIO\nTRIO_PUBLIC int trio_vscanf TRIO_ARGS2((format, args), TRIO_CONST char* format, va_list args)\n{\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)stdin, 0, TrioInStreamFile, TrioUndoStreamFile, format, args,\n\t                NULL, NULL);\n}\n#endif /* TRIO_FEATURE_STDIO */\n\n/**\n   Scan characters from standard input stream.\n\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_STDIO\nTRIO_PUBLIC int trio_scanfv TRIO_ARGS2((format, args), TRIO_CONST char* format,\n                                       trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)stdin, 0, TrioInStreamFile, TrioUndoStreamFile, format, unused,\n\t                TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_STDIO */\n\n/*************************************************************************\n * fscanf\n */\n\n/**\n   Scan characters from file.\n\n   @param file File pointer.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_FILE\nTRIO_PUBLIC int trio_fscanf TRIO_VARGS3((file, format, va_alist), FILE* file,\n                                        TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(file));\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioScan((trio_pointer_t)file, 0, TrioInStreamFile, TrioUndoStreamFile, format, args,\n\t                  NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_FILE */\n\n/**\n   Scan characters from file.\n\n   @param file File pointer.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_FILE\nTRIO_PUBLIC int trio_vfscanf TRIO_ARGS3((file, format, args), FILE* file, TRIO_CONST char* format,\n                                        va_list args)\n{\n\tassert(VALID(file));\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)file, 0, TrioInStreamFile, TrioUndoStreamFile, format, args,\n\t                NULL, NULL);\n}\n#endif /* TRIO_FEATURE_FILE */\n\n/**\n   Scan characters from file.\n\n   @param file File pointer.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_FILE\nTRIO_PUBLIC int trio_fscanfv TRIO_ARGS3((file, format, args), FILE* file, TRIO_CONST char* format,\n                                        trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(file));\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)file, 0, TrioInStreamFile, TrioUndoStreamFile, format, unused,\n\t                TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_FILE */\n\n/*************************************************************************\n * dscanf\n */\n\n/**\n   Scan characters from file descriptor.\n\n   @param fd File descriptor.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_FD\nTRIO_PUBLIC int trio_dscanf TRIO_VARGS3((fd, format, va_alist), int fd, TRIO_CONST char* format,\n                                        TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioScan((trio_pointer_t)&fd, 0, TrioInStreamFileDescriptor, NULL, format, args, NULL,\n\t                  NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_FD */\n\n/**\n   Scan characters from file descriptor.\n\n   @param fd File descriptor.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_FD\nTRIO_PUBLIC int trio_vdscanf TRIO_ARGS3((fd, format, args), int fd, TRIO_CONST char* format,\n                                        va_list args)\n{\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)&fd, 0, TrioInStreamFileDescriptor, NULL, format, args, NULL,\n\t                NULL);\n}\n#endif /* TRIO_FEATURE_FD */\n\n/**\n   Scan characters from file descriptor.\n\n   @param fd File descriptor.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_FD\nTRIO_PUBLIC int trio_dscanfv TRIO_ARGS3((fd, format, args), int fd, TRIO_CONST char* format,\n                                        trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)&fd, 0, TrioInStreamFileDescriptor, NULL, format, unused,\n\t                TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_FD */\n\n/*************************************************************************\n * cscanf\n */\n#if TRIO_FEATURE_CLOSURE\nTRIO_PUBLIC int trio_cscanf TRIO_VARGS4((stream, closure, format, va_alist), trio_instream_t stream,\n                                        trio_pointer_t closure, TRIO_CONST char* format,\n                                        TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tdata.stream.in = stream;\n\tdata.closure = closure;\n\tstatus = TrioScan(&data, 0, TrioInStreamCustom, NULL, format, args, NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n#if TRIO_FEATURE_CLOSURE\nTRIO_PUBLIC int trio_vcscanf TRIO_ARGS4((stream, closure, format, args), trio_instream_t stream,\n                                        trio_pointer_t closure, TRIO_CONST char* format,\n                                        va_list args)\n{\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\n\tdata.stream.in = stream;\n\tdata.closure = closure;\n\treturn TrioScan(&data, 0, TrioInStreamCustom, NULL, format, args, NULL, NULL);\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n#if TRIO_FEATURE_CLOSURE\nTRIO_PUBLIC int trio_cscanfv TRIO_ARGS4((stream, closure, format, args), trio_instream_t stream,\n                                        trio_pointer_t closure, TRIO_CONST char* format,\n                                        trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\n\tdata.stream.in = stream;\n\tdata.closure = closure;\n\treturn TrioScan(&data, 0, TrioInStreamCustom, NULL, format, unused, TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n#if TRIO_FEATURE_CLOSURE && TRIO_FEATURE_ARGFUNC\nTRIO_PUBLIC int trio_cscanff TRIO_ARGS5((stream, closure, format, argfunc, context),\n                                        trio_instream_t stream, trio_pointer_t closure,\n                                        TRIO_CONST char* format, trio_argfunc_t argfunc,\n                                        trio_pointer_t context)\n{\n\tstatic va_list unused;\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\tassert(VALID(argfunc));\n\n\tdata.stream.in = stream;\n\tdata.closure = closure;\n\treturn TrioScan(&data, 0, TrioInStreamCustom, NULL, format, unused, argfunc,\n\t                (trio_pointer_t*)context);\n}\n#endif /* TRIO_FEATURE_CLOSURE && TRIO_FEATURE_ARGFUNC */\n\n/*************************************************************************\n * sscanf\n */\n\n/**\n   Scan characters from string.\n\n   @param buffer Input string.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of scanned characters.\n */\nTRIO_PUBLIC int trio_sscanf TRIO_VARGS3((buffer, format, va_alist), TRIO_CONST char* buffer,\n                                        TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus =\n\t    TrioScan((trio_pointer_t)&buffer, 0, TrioInStreamString, NULL, format, args, NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n\n/**\n   Scan characters from string.\n\n   @param buffer Input string.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\nTRIO_PUBLIC int trio_vsscanf TRIO_ARGS3((buffer, format, args), TRIO_CONST char* buffer,\n                                        TRIO_CONST char* format, va_list args)\n{\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)&buffer, 0, TrioInStreamString, NULL, format, args, NULL, NULL);\n}\n\n/**\n   Scan characters from string.\n\n   @param buffer Input string.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\nTRIO_PUBLIC int trio_sscanfv TRIO_ARGS3((buffer, format, args), TRIO_CONST char* buffer,\n                                        TRIO_CONST char* format, trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)&buffer, 0, TrioInStreamString, NULL, format, unused,\n\t                TrioArrayGetter, args);\n}\n\n#endif /* TRIO_FEATURE_SCANF */\n\n/** @} End of Scanf documentation module */\n\n/*************************************************************************\n * trio_strerror\n */\nTRIO_PUBLIC TRIO_CONST char* trio_strerror TRIO_ARGS1((errorcode), int errorcode)\n{\n#if TRIO_FEATURE_STRERR\n\t/* Textual versions of the error codes */\n\tswitch (TRIO_ERROR_CODE(errorcode))\n\t{\n\t\tcase TRIO_EOF:\n\t\t\treturn \"End of file\";\n\t\tcase TRIO_EINVAL:\n\t\t\treturn \"Invalid argument\";\n\t\tcase TRIO_ETOOMANY:\n\t\t\treturn \"Too many arguments\";\n\t\tcase TRIO_EDBLREF:\n\t\t\treturn \"Double reference\";\n\t\tcase TRIO_EGAP:\n\t\t\treturn \"Reference gap\";\n\t\tcase TRIO_ENOMEM:\n\t\t\treturn \"Out of memory\";\n\t\tcase TRIO_ERANGE:\n\t\t\treturn \"Invalid range\";\n\t\tcase TRIO_ECUSTOM:\n\t\t\treturn \"Custom error\";\n\t\tdefault:\n\t\t\treturn \"Unknown\";\n\t}\n#else\n\treturn \"Unknown\";\n#endif\n}\n\n#ifdef _WIN32\n#pragma warning(pop)\n#endif\n", "/*************************************************************************\n *\n * $Id: triostr.c,v 1.36 2010/01/26 13:02:02 breese Exp $\n *\n * Copyright (C) 2001 Bjorn Reese and Daniel Stenberg.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND\n * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.\n *\n ************************************************************************/\n\n/*************************************************************************\n * Include files\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config.h>\n#endif\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"triodef.h\"\n#include \"triostr.h\"\n#if defined(TRIO_FUNC_TO_LONG_DOUBLE)\n#define USE_MATH\n#endif\n#if defined(USE_MATH)\n#include <math.h>\n#endif\n\n/*************************************************************************\n * Definitions\n */\n\n#if !defined(TRIO_PUBLIC_STRING)\n#define TRIO_PUBLIC_STRING TRIO_PUBLIC\n#endif\n#if !defined(TRIO_PRIVATE_STRING)\n#define TRIO_PRIVATE_STRING TRIO_PRIVATE\n#endif\n\n#if !defined(NULL)\n#define NULL 0\n#endif\n#if !defined(NIL)\n#define NIL ((char)0)\n#endif\n#if !defined(FALSE)\n#define FALSE (1 == 0)\n#define TRUE (!FALSE)\n#endif\n#if !defined(BOOLEAN_T)\n#define BOOLEAN_T int\n#endif\n\n#if defined(USE_MATH)\n#if defined(PREDEF_STANDARD_C99)\n#if defined(TRIO_COMPILER_DECC)\n#if (TRIO_COMPILER_DECC - 0 > 80000000)\n/*\n * The OSF/1 runtime that comes with the DECC compiler does not support\n * hexfloats conversion.\n */\n#define USE_STRTOD\n#define USE_STRTOF\n#endif\n#else\n#define USE_STRTOD\n#define USE_STRTOF\n#endif\n#else\n#if defined(TRIO_COMPILER_VISUALC)\n#define USE_STRTOD\n#endif\n#endif\n#endif\n\n#if defined(TRIO_PLATFORM_UNIX)\n#if defined(PREDEF_STANDARD_UNIX95)\n#define USE_STRCASECMP\n#define USE_STRNCASECMP\n#endif\n#if defined(TRIO_PLATFORM_SUNOS)\n#define USE_SYS_ERRLIST\n#else\n#define USE_STRERROR\n#endif\n#if defined(TRIO_PLATFORM_QNX)\n#define strcasecmp(x, y) stricmp(x, y)\n#define strncasecmp(x, y, n) strnicmp(x, y, n)\n#endif\n#endif\n\n#if defined(TRIO_PLATFORM_WIN32)\n#define USE_STRCASECMP\n#if defined(TRIO_PLATFORM_WINCE)\n#define strcasecmp(x, y) _stricmp(x, y)\n#else\n#define strcasecmp(x, y) _stricmp(x, y)\n#endif\n#endif\n\n#if !defined(HAVE_CONFIG_H)\n#if !(defined(TRIO_PLATFORM_SUNOS))\n#define HAVE_TOLOWER\n#define HAVE_TOUPPER\n#endif\n#endif\n\n#if defined(USE_MATH) && !defined(TRIO_NO_POWL)\n#if !defined(HAVE_POWL)\n#if defined(PREDEF_STANDARD_C99) || defined(PREDEF_STANDARD_UNIX03)\n#define HAVE_POWL\n#else\n#if defined(TRIO_COMPILER_VISUALC)\n#if defined(powl)\n#define HAVE_POWL\n#endif\n#endif\n#endif\n#endif\n#endif\n\n#if defined(HAVE_POWL)\n#define trio_powl(x, y) powl((x), (y))\n#else\n#define trio_powl(x, y) pow((double)(x), (double)(y))\n#endif\n\n#if defined(TRIO_FUNC_TO_UPPER) || (defined(TRIO_FUNC_EQUAL) && !defined(USE_STRCASECMP)) ||   \\\n    (defined(TRIO_FUNC_EQUAL_MAX) && !defined(USE_STRNCASECMP)) || defined(TRIO_FUNC_MATCH) || \\\n    defined(TRIO_FUNC_TO_LONG_DOUBLE) || defined(TRIO_FUNC_UPPER)\n#define TRIO_FUNC_INTERNAL_TO_UPPER\n#endif\n\n/*************************************************************************\n * Structures\n */\n\nstruct _trio_string_t\n{\n\tchar* content;\n\tsize_t length;\n\tsize_t allocated;\n};\n\n/*************************************************************************\n * Constants\n */\n\n#if !defined(TRIO_EMBED_STRING)\n/* Unused but kept for reference */\n/* static TRIO_CONST char rcsid[] = \"@(#)$Id: triostr.c,v 1.36 2010/01/26 13:02:02 breese Exp $\"; */\n#endif\n\n/*************************************************************************\n * Static String Functions\n */\n\n#if defined(TRIO_DOCUMENTATION)\n#include \"doc/doc_static.h\"\n#endif\n/** @addtogroup StaticStrings\n    @{\n*/\n\n/*\n * internal_duplicate_max\n */\n#if defined(TRIO_FUNC_DUPLICATE) || defined(TRIO_FUNC_DUPLICATE_MAX) || \\\n    defined(TRIO_FUNC_STRING_DUPLICATE) || defined(TRIO_FUNC_XSTRING_DUPLICATE)\n\nTRIO_PRIVATE_STRING char* internal_duplicate_max TRIO_ARGS2((source, size), TRIO_CONST char* source,\n                                                            size_t size)\n{\n\tchar* target;\n\n\tassert(source);\n\n\t/* Make room for string plus a terminating zero */\n\tsize++;\n\ttarget = trio_create(size);\n\tif (target)\n\t{\n\t\ttrio_copy_max(target, size, source);\n\t}\n\treturn target;\n}\n\n#endif\n\n/*\n * internal_string_alloc\n */\n#if defined(TRIO_FUNC_STRING_CREATE) || defined(TRIO_FUNC_STRING_DUPLICATE) || \\\n    defined(TRIO_FUNC_XSTRING_DUPLICATE)\n\nTRIO_PRIVATE_STRING trio_string_t* internal_string_alloc(TRIO_NOARGS)\n{\n\ttrio_string_t* self;\n\n\tself = (trio_string_t*)TRIO_MALLOC(sizeof(trio_string_t));\n\tif (self)\n\t{\n\t\tself->content = NULL;\n\t\tself->length = 0;\n\t\tself->allocated = 0;\n\t}\n\treturn self;\n}\n\n#endif\n\n/*\n * internal_string_grow\n *\n * The size of the string will be increased by 'delta' characters. If\n * 'delta' is zero, the size will be doubled.\n */\n#if defined(TRIO_FUNC_STRING_CREATE) || defined(TRIO_FUNC_STRING_APPEND) || \\\n    defined(TRIO_FUNC_XSTRING_APPEND) || defined(TRIO_FUNC_XSTRING_APPEND_CHAR)\n\nTRIO_PRIVATE_STRING BOOLEAN_T internal_string_grow TRIO_ARGS2((self, delta), trio_string_t* self,\n                                                              size_t delta)\n{\n\tBOOLEAN_T status = FALSE;\n\tchar* new_content;\n\tsize_t new_size;\n\n\tnew_size =\n\t    (delta == 0) ? ((self->allocated == 0) ? 1 : self->allocated * 2) : self->allocated + delta;\n\n\tnew_content = (char*)TRIO_REALLOC(self->content, new_size);\n\tif (new_content)\n\t{\n\t\tself->content = new_content;\n\t\tself->allocated = new_size;\n\t\tstatus = TRUE;\n\t}\n\treturn status;\n}\n\n#endif\n\n/*\n * internal_string_grow_to\n *\n * The size of the string will be increased to 'length' plus one characters.\n * If 'length' is less than the original size, the original size will be\n * used (that is, the size of the string is never decreased).\n */\n#if defined(TRIO_FUNC_STRING_APPEND) || defined(TRIO_FUNC_XSTRING_APPEND) || \\\n    defined(TRIO_FUNC_XSTRING_APPEND_MAX)\n\nTRIO_PRIVATE_STRING BOOLEAN_T internal_string_grow_to TRIO_ARGS2((self, length),\n                                                                 trio_string_t* self, size_t length)\n{\n\tlength++; /* Room for terminating zero */\n\treturn (self->allocated < length) ? internal_string_grow(self, length - self->allocated) : TRUE;\n}\n\n#endif\n\n#if defined(TRIO_FUNC_INTERNAL_TO_UPPER)\n\nTRIO_PRIVATE_STRING TRIO_INLINE int internal_to_upper TRIO_ARGS1((source), int source)\n{\n#if defined(HAVE_TOUPPER)\n\n\treturn toupper(source);\n\n#else\n\n\t/* Does not handle locales or non-contiguous alphabetic characters */\n\treturn ((source >= (int)'a') && (source <= (int)'z')) ? source - 'a' + 'A' : source;\n\n#endif\n}\n\n#endif\n\n/**\n   Create new string.\n\n   @param size Size of new string.\n   @return Pointer to string, or NULL if allocation failed.\n*/\n#if defined(TRIO_FUNC_CREATE)\n\nTRIO_PUBLIC_STRING char* trio_create TRIO_ARGS1((size), size_t size)\n{\n\treturn (char*)TRIO_MALLOC(size);\n}\n\n#endif\n\n/**\n   Destroy string.\n\n   @param string String to be freed.\n*/\n#if defined(TRIO_FUNC_DESTROY)\n\nTRIO_PUBLIC_STRING void trio_destroy TRIO_ARGS1((string), char* string)\n{\n\tif (string)\n\t{\n\t\tTRIO_FREE(string);\n\t}\n}\n\n#endif\n\n/**\n   Count the number of characters in a string.\n\n   @param string String to measure.\n   @return Number of characters in @p string.\n*/\n#if defined(TRIO_FUNC_LENGTH)\n\nTRIO_PUBLIC_STRING size_t trio_length TRIO_ARGS1((string), TRIO_CONST char* string)\n{\n\treturn strlen(string);\n}\n\n#endif\n\n/**\n   Count at most @p max characters in a string.\n\n   @param string String to measure.\n   @param max Maximum number of characters to count.\n   @return The maximum value of @p max and number of characters in @p string.\n*/\n#if defined(TRIO_FUNC_LENGTH_MAX)\n\nTRIO_PUBLIC_STRING size_t trio_length_max TRIO_ARGS2((string, max), TRIO_CONST char* string,\n                                                     size_t max)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < max; ++i)\n\t{\n\t\tif (string[i] == 0)\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\n#endif\n\n/**\n   Append @p source at the end of @p target.\n\n   @param target Target string.\n   @param source Source string.\n   @return Boolean value indicating success or failure.\n\n   @pre @p target must point to a memory chunk with sufficient room to\n   contain the @p target string and @p source string.\n   @pre No boundary checking is performed, so insufficient memory will\n   result in a buffer overrun.\n   @post @p target will be zero terminated.\n*/\n#if defined(TRIO_FUNC_APPEND)\n\nTRIO_PUBLIC_STRING int trio_append TRIO_ARGS2((target, source), char* target,\n                                              TRIO_CONST char* source)\n{\n\tassert(target);\n\tassert(source);\n\n\treturn (strcat(target, source) != NULL);\n}\n\n#endif\n\n/**\n   Append at most @p max characters from @p source to @p target.\n\n   @param target Target string.\n   @param max Maximum number of characters to append.\n   @param source Source string.\n   @return Boolean value indicating success or failure.\n\n   @pre @p target must point to a memory chuck with sufficient room to\n   contain the @p target string and the @p source string (at most @p max\n   characters).\n   @pre No boundary checking is performed, so insufficient memory will\n   result in a buffer overrun.\n   @post @p target will be zero terminated.\n*/\n#if defined(TRIO_FUNC_APPEND_MAX)\n\nTRIO_PUBLIC_STRING int trio_append_max TRIO_ARGS3((target, max, source), char* target, size_t max,\n                                                  TRIO_CONST char* source)\n{\n\tsize_t length;\n\n\tassert(target);\n\tassert(source);\n\n\tlength = trio_length(target);\n\n\tif (max > length)\n\t{\n\t\tstrncat(target, source, max - length - 1);\n\t}\n\treturn TRUE;\n}\n\n#endif\n\n/**\n   Determine if a string contains a substring.\n\n   @param string String to be searched.\n   @param substring String to be found.\n   @return Boolean value indicating success or failure.\n*/\n#if defined(TRIO_FUNC_CONTAINS)\n\nTRIO_PUBLIC_STRING int trio_contains TRIO_ARGS2((string, substring), TRIO_CONST char* string,\n                                                TRIO_CONST char* substring)\n{\n\tassert(string);\n\tassert(substring);\n\n\treturn (0 != strstr(string, substring));\n}\n\n#endif\n\n/**\n   Copy @p source to @p target.\n\n   @param target Target string.\n   @param source Source string.\n   @return Boolean value indicating success or failure.\n\n   @pre @p target must point to a memory chunk with sufficient room to\n   contain the @p source string.\n   @pre No boundary checking is performed, so insufficient memory will\n   result in a buffer overrun.\n   @post @p target will be zero terminated.\n*/\n#if defined(TRIO_FUNC_COPY)\n\nTRIO_PUBLIC_STRING int trio_copy TRIO_ARGS2((target, source), char* target, TRIO_CONST char* source)\n{\n\tassert(target);\n\tassert(source);\n\n\t(void)strcpy(target, source);\n\treturn TRUE;\n}\n\n#endif\n\n/**\n   Copy at most @p max - 1 characters from @p source to @p target.\n\n   @param target Target string.\n   @param max Maximum number of characters to append (one of which is\n   a NUL terminator).  In other words @p source must point to at least\n   @p max - 1 bytes, but @p target must point to at least @p max\n   bytes.\n   @param source Source string.\n   @return Boolean value indicating success or failure.\n\n   @pre @p target must point to a memory chunk with sufficient room to\n   contain the @p source string and a NUL terminator (at most @p max\n   bytes total).\n   @pre No boundary checking is performed, so insufficient memory will\n   result in a buffer overrun.\n   @post @p target will be zero terminated.\n*/\n#if defined(TRIO_FUNC_COPY_MAX)\n\nTRIO_PUBLIC_STRING int trio_copy_max TRIO_ARGS3((target, max, source), char* target, size_t max,\n                                                TRIO_CONST char* source)\n{\n\tassert(target);\n\tassert(source);\n\tassert(max > 0); /* Includes != 0 */\n\n\t(void)strncpy(target, source, max - 1);\n\ttarget[max - 1] = (char)0;\n\treturn TRUE;\n}\n\n#endif\n\n/**\n   Duplicate @p source.\n\n   @param source Source string.\n   @return A copy of the @p source string.\n\n   @post @p target will be zero terminated.\n*/\n#if defined(TRIO_FUNC_DUPLICATE)\n\nTRIO_PUBLIC_STRING char* trio_duplicate TRIO_ARGS1((source), TRIO_CONST char* source)\n{\n\treturn internal_duplicate_max(source, trio_length(source));\n}\n\n#endif\n\n/**\n   Duplicate at most @p max characters of @p source.\n\n   @param source Source string.\n   @param max Maximum number of characters to duplicate.\n   @return A copy of the @p source string.\n\n   @post @p target will be zero terminated.\n*/\n#if defined(TRIO_FUNC_DUPLICATE_MAX)\n\nTRIO_PUBLIC_STRING char* trio_duplicate_max TRIO_ARGS2((source, max), TRIO_CONST char* source,\n                                                       size_t max)\n{\n\tsize_t length;\n\n\tassert(source);\n\tassert(max > 0);\n\n\tlength = trio_length(source);\n\tif (length > max)\n\t{\n\t\tlength = max;\n\t}\n\treturn internal_duplicate_max(source, length);\n}\n\n#endif\n\n/**\n   Compare if two strings are equal.\n\n   @param first First string.\n   @param second Second string.\n   @return Boolean indicating whether the two strings are equal or not.\n\n   Case-insensitive comparison.\n*/\n#if defined(TRIO_FUNC_EQUAL)\n\nTRIO_PUBLIC_STRING int trio_equal TRIO_ARGS2((first, second), TRIO_CONST char* first,\n                                             TRIO_CONST char* second)\n{\n\tassert(first);\n\tassert(second);\n\n\tif ((first != NULL) && (second != NULL))\n\t{\n#if defined(USE_STRCASECMP)\n\t\treturn (0 == strcasecmp(first, second));\n#else\n\t\twhile ((*first != NIL) && (*second != NIL))\n\t\t{\n\t\t\tif (internal_to_upper(*first) != internal_to_upper(*second))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfirst++;\n\t\t\tsecond++;\n\t\t}\n\t\treturn ((*first == NIL) && (*second == NIL));\n#endif\n\t}\n\treturn FALSE;\n}\n\n#endif\n\n/**\n   Compare if two strings are equal.\n\n   @param first First string.\n   @param second Second string.\n   @return Boolean indicating whether the two strings are equal or not.\n\n   Case-sensitive comparison.\n*/\n#if defined(TRIO_FUNC_EQUAL_CASE)\n\nTRIO_PUBLIC_STRING int trio_equal_case TRIO_ARGS2((first, second), TRIO_CONST char* first,\n                                                  TRIO_CONST char* second)\n{\n\tassert(first);\n\tassert(second);\n\n\tif ((first != NULL) && (second != NULL))\n\t{\n\t\treturn (0 == strcmp(first, second));\n\t}\n\treturn FALSE;\n}\n\n#endif\n\n/**\n   Compare if two strings up until the first @p max characters are equal.\n\n   @param first First string.\n   @param max Maximum number of characters to compare.\n   @param second Second string.\n   @return Boolean indicating whether the two strings are equal or not.\n\n   Case-sensitive comparison.\n*/\n#if defined(TRIO_FUNC_EQUAL_CASE_MAX)\n\nTRIO_PUBLIC_STRING int trio_equal_case_max TRIO_ARGS3((first, max, second), TRIO_CONST char* first,\n                                                      size_t max, TRIO_CONST char* second)\n{\n\tassert(first);\n\tassert(second);\n\n\tif ((first != NULL) && (second != NULL))\n\t{\n\t\treturn (0 == strncmp(first, second, max));\n\t}\n\treturn FALSE;\n}\n\n#endif\n\n/**\n   Compare if two strings are equal.\n\n   @param first First string.\n   @param second Second string.\n   @return Boolean indicating whether the two strings are equal or not.\n\n   Collating characters are considered equal.\n*/\n#if defined(TRIO_FUNC_EQUAL_LOCALE)\n\nTRIO_PUBLIC_STRING int trio_equal_locale TRIO_ARGS2((first, second), TRIO_CONST char* first,\n                                                    TRIO_CONST char* second)\n{\n\tassert(first);\n\tassert(second);\n\n#if defined(LC_COLLATE)\n\treturn (strcoll(first, second) == 0);\n#else\n\treturn trio_equal(first, second);\n#endif\n}\n\n#endif\n\n/**\n   Compare if two strings up until the first @p max characters are equal.\n\n   @param first First string.\n   @param max Maximum number of characters to compare.\n   @param second Second string.\n   @return Boolean indicating whether the two strings are equal or not.\n\n   Case-insensitive comparison.\n*/\n#if defined(TRIO_FUNC_EQUAL_MAX)\n\nTRIO_PUBLIC_STRING int trio_equal_max TRIO_ARGS3((first, max, second), TRIO_CONST char* first,\n                                                 size_t max, TRIO_CONST char* second)\n{\n\tassert(first);\n\tassert(second);\n\n\tif ((first != NULL) && (second != NULL))\n\t{\n#if defined(USE_STRNCASECMP)\n\t\treturn (0 == strncasecmp(first, second, max));\n#else\n\t\t/* Not adequately tested yet */\n\t\tsize_t cnt = 0;\n\t\twhile ((*first != NIL) && (*second != NIL) && (cnt <= max))\n\t\t{\n\t\t\tif (internal_to_upper(*first) != internal_to_upper(*second))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfirst++;\n\t\t\tsecond++;\n\t\t\tcnt++;\n\t\t}\n\t\treturn ((cnt == max) || ((*first == NIL) && (*second == NIL)));\n#endif\n\t}\n\treturn FALSE;\n}\n\n#endif\n\n/**\n   Provide a textual description of an error code (errno).\n\n   @param error_number Error number.\n   @return Textual description of @p error_number.\n*/\n#if defined(TRIO_FUNC_ERROR)\n\nTRIO_PUBLIC_STRING TRIO_CONST char* trio_error TRIO_ARGS1((error_number), int error_number)\n{\n#if defined(USE_STRERROR)\n\n\treturn strerror(error_number);\n\n#else\n#if defined(USE_SYS_ERRLIST)\n\n\textern char* sys_errlist[];\n\textern int sys_nerr;\n\n\treturn ((error_number < 0) || (error_number >= sys_nerr)) ? \"unknown\"\n\t                                                          : sys_errlist[error_number];\n\n#else\n\n\treturn \"unknown\";\n\n#endif\n#endif\n}\n\n#endif\n\n/**\n   Format the date/time according to @p format.\n\n   @param target Target string.\n   @param max Maximum number of characters to format.\n   @param format Formatting string.\n   @param datetime Date/time structure.\n   @return Number of formatted characters.\n\n   The formatting string accepts the same specifiers as the standard C\n   function strftime.\n*/\n#if defined(TRIO_FUNC_FORMAT_DATE_MAX)\n\nTRIO_PUBLIC_STRING size_t trio_format_date_max TRIO_ARGS4((target, max, format, datetime),\n                                                          char* target, size_t max,\n                                                          TRIO_CONST char* format,\n                                                          TRIO_CONST struct tm* datetime)\n{\n\tassert(target);\n\tassert(format);\n\tassert(datetime);\n\tassert(max > 0);\n\n\treturn strftime(target, max, format, datetime);\n}\n\n#endif\n\n/**\n   Calculate a hash value for a string.\n\n   @param string String to be calculated on.\n   @param type Hash function.\n   @return Calculated hash value.\n\n   @p type can be one of the following\n   @li @c TRIO_HASH_PLAIN Plain hash function.\n*/\n#if defined(TRIO_FUNC_HASH)\n\nTRIO_PUBLIC_STRING unsigned long trio_hash TRIO_ARGS2((string, type), TRIO_CONST char* string,\n                                                      int type)\n{\n\tunsigned long value = 0L;\n\tchar ch;\n\n\tassert(string);\n\n\tswitch (type)\n\t{\n\t\tcase TRIO_HASH_PLAIN:\n\t\t\twhile ((ch = *string++) != NIL)\n\t\t\t{\n\t\t\t\tvalue *= 31;\n\t\t\t\tvalue += (unsigned long)ch;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(FALSE);\n\t\t\tbreak;\n\t}\n\treturn value;\n}\n\n#endif\n\n/**\n   Find first occurrence of a character in a string.\n\n   @param string String to be searched.\n   @param character Character to be found.\n   @return A pointer to the found character, or NULL if character was not found.\n */\n#if defined(TRIO_FUNC_INDEX)\n\nTRIO_PUBLIC_STRING char* trio_index TRIO_ARGS2((string, character), TRIO_CONST char* string,\n                                               int character)\n{\n\tassert(string);\n\n\treturn strchr(string, character);\n}\n\n#endif\n\n/**\n   Find last occurrence of a character in a string.\n\n   @param string String to be searched.\n   @param character Character to be found.\n   @return A pointer to the found character, or NULL if character was not found.\n */\n#if defined(TRIO_FUNC_INDEX_LAST)\n\nTRIO_PUBLIC_STRING char* trio_index_last TRIO_ARGS2((string, character), TRIO_CONST char* string,\n                                                    int character)\n{\n\tassert(string);\n\n\treturn strchr(string, character);\n}\n\n#endif\n\n/**\n   Convert the alphabetic letters in the string to lower-case.\n\n   @param target String to be converted.\n   @return Number of processed characters (converted or not).\n*/\n#if defined(TRIO_FUNC_LOWER)\n\nTRIO_PUBLIC_STRING int trio_lower TRIO_ARGS1((target), char* target)\n{\n\tassert(target);\n\n\treturn trio_span_function(target, target, trio_to_lower);\n}\n\n#endif\n\n/**\n   Compare two strings using wildcards.\n\n   @param string String to be searched.\n   @param pattern Pattern, including wildcards, to search for.\n   @return Boolean value indicating success or failure.\n\n   Case-insensitive comparison.\n\n   The following wildcards can be used\n   @li @c * Match any number of characters.\n   @li @c ? Match a single character.\n*/\n#if defined(TRIO_FUNC_MATCH)\n\nTRIO_PUBLIC_STRING int trio_match TRIO_ARGS2((string, pattern), TRIO_CONST char* string,\n                                             TRIO_CONST char* pattern)\n{\n\tassert(string);\n\tassert(pattern);\n\n\tfor (; ('*' != *pattern); ++pattern, ++string)\n\t{\n\t\tif (NIL == *string)\n\t\t{\n\t\t\treturn (NIL == *pattern);\n\t\t}\n\t\tif ((internal_to_upper((int)*string) != internal_to_upper((int)*pattern)) &&\n\t\t    ('?' != *pattern))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\t/* two-line patch to prevent *too* much recursiveness: */\n\twhile ('*' == pattern[1])\n\t\tpattern++;\n\n\tdo\n\t{\n\t\tif (trio_match(string, &pattern[1]))\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\t} while (*string++);\n\n\treturn FALSE;\n}\n\n#endif\n\n/**\n   Compare two strings using wildcards.\n\n   @param string String to be searched.\n   @param pattern Pattern, including wildcards, to search for.\n   @return Boolean value indicating success or failure.\n\n   Case-sensitive comparison.\n\n   The following wildcards can be used\n   @li @c * Match any number of characters.\n   @li @c ? Match a single character.\n*/\n#if defined(TRIO_FUNC_MATCH_CASE)\n\nTRIO_PUBLIC_STRING int trio_match_case TRIO_ARGS2((string, pattern), TRIO_CONST char* string,\n                                                  TRIO_CONST char* pattern)\n{\n\tassert(string);\n\tassert(pattern);\n\n\tfor (; ('*' != *pattern); ++pattern, ++string)\n\t{\n\t\tif (NIL == *string)\n\t\t{\n\t\t\treturn (NIL == *pattern);\n\t\t}\n\t\tif ((*string != *pattern) && ('?' != *pattern))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\t/* two-line patch to prevent *too* much recursiveness: */\n\twhile ('*' == pattern[1])\n\t\tpattern++;\n\n\tdo\n\t{\n\t\tif (trio_match_case(string, &pattern[1]))\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\t} while (*string++);\n\n\treturn FALSE;\n}\n\n#endif\n\n/**\n   Execute a function on each character in string.\n\n   @param target Target string.\n   @param source Source string.\n   @param Function Function to be executed.\n   @return Number of processed characters.\n*/\n#if defined(TRIO_FUNC_SPAN_FUNCTION)\n\nTRIO_PUBLIC_STRING size_t trio_span_function TRIO_ARGS3((target, source, Function), char* target,\n                                                        TRIO_CONST char* source,\n                                                        int(*Function) TRIO_PROTO((int)))\n{\n\tsize_t count = 0;\n\n\tassert(target);\n\tassert(source);\n\tassert(Function);\n\n\twhile (*source != NIL)\n\t{\n\t\t*target++ = Function(*source++);\n\t\tcount++;\n\t}\n\treturn count;\n}\n\n#endif\n\n/**\n   Search for a substring in a string.\n\n   @param string String to be searched.\n   @param substring String to be found.\n   @return Pointer to first occurrence of @p substring in @p string, or NULL\n   if no match was found.\n*/\n#if defined(TRIO_FUNC_SUBSTRING)\n\nTRIO_PUBLIC_STRING char* trio_substring TRIO_ARGS2((string, substring), TRIO_CONST char* string,\n                                                   TRIO_CONST char* substring)\n{\n\tassert(string);\n\tassert(substring);\n\n\treturn strstr(string, substring);\n}\n\n#endif\n\n/**\n   Search for a substring in the first @p max characters of a string.\n\n   @param string String to be searched.\n   @param max Maximum characters to be searched.\n   @param substring String to be found.\n   @return Pointer to first occurrence of @p substring in @p string, or NULL\n   if no match was found.\n*/\n#if defined(TRIO_FUNC_SUBSTRING_MAX)\n\nTRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),\n                                                       TRIO_CONST char* string, size_t max,\n                                                       TRIO_CONST char* substring)\n{\n\tsize_t count;\n\tsize_t size;\n\tchar* result = NULL;\n\n\tassert(string);\n\tassert(substring);\n\n\tsize = trio_length(substring);\n\tif (size <= max)\n\t{\n\t\tfor (count = 0; count <= max - size; count++)\n\t\t{\n\t\t\tif (trio_equal_max(substring, size, &string[count]))\n\t\t\t{\n\t\t\t\tresult = (char*)&string[count];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n#endif\n\n/**\n   Tokenize string.\n\n   @param string String to be tokenized.\n   @param delimiters String containing list of delimiting characters.\n   @return Start of new token.\n\n   @warning @p string will be destroyed.\n*/\n#if defined(TRIO_FUNC_TOKENIZE)\n\nTRIO_PUBLIC_STRING char* trio_tokenize TRIO_ARGS2((string, delimiters), char* string,\n                                                  TRIO_CONST char* delimiters)\n{\n\tassert(delimiters);\n\n\treturn strtok(string, delimiters);\n}\n\n#endif\n\n/**\n   Convert string to floating-point number.\n\n   @param source String to be converted.\n   @param endp Pointer to end of the converted string.\n   @return A floating-point number.\n\n   The following Extended Backus-Naur form is used\n   @verbatim\n   double        ::= [ <sign> ]\n                     ( <number> |\n                       <number> <decimal_point> <number> |\n                       <decimal_point> <number> )\n                     [ <exponential> [ <sign> ] <number> ]\n   number        ::= 1*( <digit> )\n   digit         ::= ( '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' )\n   exponential   ::= ( 'e' | 'E' )\n   sign          ::= ( '-' | '+' )\n   decimal_point ::= '.'\n   @endverbatim\n*/\n#if defined(TRIO_FUNC_TO_LONG_DOUBLE)\n\n/* FIXME: Add EBNF for hex-floats */\nTRIO_PUBLIC_STRING trio_long_double_t trio_to_long_double TRIO_ARGS2((source, endp),\n                                                                     TRIO_CONST char* source,\n                                                                     char** endp)\n{\n#if defined(USE_STRTOLD)\n\treturn strtold(source, endp);\n#else\n\tint isNegative = FALSE;\n\tint isExponentNegative = FALSE;\n\ttrio_long_double_t integer = 0.0;\n\ttrio_long_double_t fraction = 0.0;\n\tunsigned long exponent = 0;\n\ttrio_long_double_t base;\n\ttrio_long_double_t fracdiv = 1.0;\n\ttrio_long_double_t value = 0.0;\n\n\t/* First try hex-floats */\n\tif ((source[0] == '0') && ((source[1] == 'x') || (source[1] == 'X')))\n\t{\n\t\tbase = 16.0;\n\t\tsource += 2;\n\t\twhile (isxdigit((int)*source))\n\t\t{\n\t\t\tinteger *= base;\n\t\t\tinteger += (isdigit((int)*source) ? (*source - '0')\n\t\t\t                                  : 10 + (internal_to_upper((int)*source) - 'A'));\n\t\t\tsource++;\n\t\t}\n\t\tif (*source == '.')\n\t\t{\n\t\t\tsource++;\n\t\t\twhile (isxdigit((int)*source))\n\t\t\t{\n\t\t\t\tfracdiv /= base;\n\t\t\t\tfraction += fracdiv * (isdigit((int)*source)\n\t\t\t\t                           ? (*source - '0')\n\t\t\t\t                           : 10 + (internal_to_upper((int)*source) - 'A'));\n\t\t\t\tsource++;\n\t\t\t}\n\t\t\tif ((*source == 'p') || (*source == 'P'))\n\t\t\t{\n\t\t\t\tsource++;\n\t\t\t\tif ((*source == '+') || (*source == '-'))\n\t\t\t\t{\n\t\t\t\t\tisExponentNegative = (*source == '-');\n\t\t\t\t\tsource++;\n\t\t\t\t}\n\t\t\t\twhile (isdigit((int)*source))\n\t\t\t\t{\n\t\t\t\t\texponent *= 10;\n\t\t\t\t\texponent += (*source - '0');\n\t\t\t\t\tsource++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* For later use with exponent */\n\t\tbase = 2.0;\n\t}\n\telse /* Then try normal decimal floats */\n\t{\n\t\tbase = 10.0;\n\t\tisNegative = (*source == '-');\n\t\t/* Skip sign */\n\t\tif ((*source == '+') || (*source == '-'))\n\t\t\tsource++;\n\n\t\t/* Integer part */\n\t\twhile (isdigit((int)*source))\n\t\t{\n\t\t\tinteger *= base;\n\t\t\tinteger += (*source - '0');\n\t\t\tsource++;\n\t\t}\n\n\t\tif (*source == '.')\n\t\t{\n\t\t\tsource++; /* skip decimal point */\n\t\t\twhile (isdigit((int)*source))\n\t\t\t{\n\t\t\t\tfracdiv /= base;\n\t\t\t\tfraction += (*source - '0') * fracdiv;\n\t\t\t\tsource++;\n\t\t\t}\n\t\t}\n\t\tif ((*source == 'e') || (*source == 'E')\n#if TRIO_MICROSOFT\n\t\t    || (*source == 'd') || (*source == 'D')\n#endif\n\t\t)\n\t\t{\n\t\t\tsource++; /* Skip exponential indicator */\n\t\t\tisExponentNegative = (*source == '-');\n\t\t\tif ((*source == '+') || (*source == '-'))\n\t\t\t\tsource++;\n\t\t\twhile (isdigit((int)*source))\n\t\t\t{\n\t\t\t\texponent *= (int)base;\n\t\t\t\texponent += (*source - '0');\n\t\t\t\tsource++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvalue = integer + fraction;\n\tif (exponent != 0)\n\t{\n\t\tif (isExponentNegative)\n\t\t\tvalue /= trio_powl(base, (trio_long_double_t)exponent);\n\t\telse\n\t\t\tvalue *= trio_powl(base, (trio_long_double_t)exponent);\n\t}\n\tif (isNegative)\n\t\tvalue = -value;\n\n\tif (endp)\n\t\t*endp = (char*)source;\n\treturn value;\n#endif\n}\n\n#endif\n\n/**\n   Convert string to floating-point number.\n\n   @param source String to be converted.\n   @param endp Pointer to end of the converted string.\n   @return A floating-point number.\n\n   See @ref trio_to_long_double.\n*/\n#if defined(TRIO_FUNC_TO_DOUBLE)\n\nTRIO_PUBLIC_STRING double trio_to_double TRIO_ARGS2((source, endp), TRIO_CONST char* source,\n                                                    char** endp)\n{\n#if defined(USE_STRTOD)\n\treturn strtod(source, endp);\n#else\n\treturn (double)trio_to_long_double(source, endp);\n#endif\n}\n\n#endif\n\n/**\n   Convert string to floating-point number.\n\n   @param source String to be converted.\n   @param endp Pointer to end of the converted string.\n   @return A floating-point number.\n\n   See @ref trio_to_long_double.\n*/\n#if defined(TRIO_FUNC_TO_FLOAT)\n\nTRIO_PUBLIC_STRING float trio_to_float TRIO_ARGS2((source, endp), TRIO_CONST char* source,\n                                                  char** endp)\n{\n#if defined(USE_STRTOF)\n\treturn strtof(source, endp);\n#else\n\treturn (float)trio_to_long_double(source, endp);\n#endif\n}\n\n#endif\n\n/**\n   Convert string to signed integer.\n\n   @param string String to be converted.\n   @param endp Pointer to end of converted string.\n   @param base Radix number of number.\n*/\n#if defined(TRIO_FUNC_TO_LONG)\n\nTRIO_PUBLIC_STRING long trio_to_long TRIO_ARGS3((string, endp, base), TRIO_CONST char* string,\n                                                char** endp, int base)\n{\n\tassert(string);\n\tassert((base >= 2) && (base <= 36));\n\n\treturn strtol(string, endp, base);\n}\n\n#endif\n\n/**\n   Convert one alphabetic letter to lower-case.\n\n   @param source The letter to be converted.\n   @return The converted letter.\n*/\n#if defined(TRIO_FUNC_TO_LOWER)\n\nTRIO_PUBLIC_STRING int trio_to_lower TRIO_ARGS1((source), int source)\n{\n#if defined(HAVE_TOLOWER)\n\n\treturn tolower(source);\n\n#else\n\n\t/* Does not handle locales or non-contiguous alphabetic characters */\n\treturn ((source >= (int)'A') && (source <= (int)'Z')) ? source - 'A' + 'a' : source;\n\n#endif\n}\n\n#endif\n\n/**\n   Convert string to unsigned integer.\n\n   @param string String to be converted.\n   @param endp Pointer to end of converted string.\n   @param base Radix number of number.\n*/\n#if defined(TRIO_FUNC_TO_UNSIGNED_LONG)\n\nTRIO_PUBLIC_STRING unsigned long trio_to_unsigned_long TRIO_ARGS3((string, endp, base),\n                                                                  TRIO_CONST char* string,\n                                                                  char** endp, int base)\n{\n\tassert(string);\n\tassert((base >= 2) && (base <= 36));\n\n\treturn strtoul(string, endp, base);\n}\n\n#endif\n\n/**\n   Convert one alphabetic letter to upper-case.\n\n   @param source The letter to be converted.\n   @return The converted letter.\n*/\n#if defined(TRIO_FUNC_TO_UPPER)\n\nTRIO_PUBLIC_STRING int trio_to_upper TRIO_ARGS1((source), int source)\n{\n\treturn internal_to_upper(source);\n}\n\n#endif\n\n/**\n   Convert the alphabetic letters in the string to upper-case.\n\n   @param target The string to be converted.\n   @return The number of processed characters (converted or not).\n*/\n#if defined(TRIO_FUNC_UPPER)\n\nTRIO_PUBLIC_STRING int trio_upper TRIO_ARGS1((target), char* target)\n{\n\tassert(target);\n\n\treturn trio_span_function(target, target, internal_to_upper);\n}\n\n#endif\n\n/** @} End of StaticStrings */\n\n/*************************************************************************\n * Dynamic String Functions\n */\n\n#if defined(TRIO_DOCUMENTATION)\n#include \"doc/doc_dynamic.h\"\n#endif\n/** @addtogroup DynamicStrings\n    @{\n*/\n\n/**\n   Create a new dynamic string.\n\n   @param initial_size Initial size of the buffer.\n   @return Newly allocated dynamic string, or NULL if memory allocation failed.\n*/\n#if defined(TRIO_FUNC_STRING_CREATE)\n\nTRIO_PUBLIC_STRING trio_string_t* trio_string_create TRIO_ARGS1((initial_size), int initial_size)\n{\n\ttrio_string_t* self;\n\n\tself = internal_string_alloc();\n\tif (self)\n\t{\n\t\tif (internal_string_grow(self, (size_t)((initial_size > 0) ? initial_size : 1)))\n\t\t{\n\t\t\tself->content[0] = (char)0;\n\t\t\tself->allocated = initial_size;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttrio_string_destroy(self);\n\t\t\tself = NULL;\n\t\t}\n\t}\n\treturn self;\n}\n\n#endif\n\n/**\n   Deallocate the dynamic string and its contents.\n\n   @param self Dynamic string\n*/\n#if defined(TRIO_FUNC_STRING_DESTROY)\n\nTRIO_PUBLIC_STRING void trio_string_destroy TRIO_ARGS1((self), trio_string_t* self)\n{\n\tassert(self);\n\n\tif (self)\n\t{\n\t\ttrio_destroy(self->content);\n\t\tTRIO_FREE(self);\n\t}\n}\n\n#endif\n\n/**\n   Get a pointer to the content.\n\n   @param self Dynamic string.\n   @param offset Offset into content.\n   @return Pointer to the content.\n\n   @p Offset can be zero, positive, or negative. If @p offset is zero,\n   then the start of the content will be returned. If @p offset is positive,\n   then a pointer to @p offset number of characters from the beginning of the\n   content is returned. If @p offset is negative, then a pointer to @p offset\n   number of characters from the ending of the string, starting at the\n   terminating zero, is returned.\n*/\n#if defined(TRIO_FUNC_STRING_GET)\n\nTRIO_PUBLIC_STRING char* trio_string_get TRIO_ARGS2((self, offset), trio_string_t* self, int offset)\n{\n\tchar* result = NULL;\n\n\tassert(self);\n\n\tif (self->content != NULL)\n\t{\n\t\tif (self->length == 0)\n\t\t{\n\t\t\t(void)trio_string_length(self);\n\t\t}\n\t\tif (offset >= 0)\n\t\t{\n\t\t\tif (offset > (int)self->length)\n\t\t\t{\n\t\t\t\toffset = self->length;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\toffset += self->length + 1;\n\t\t\tif (offset < 0)\n\t\t\t{\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t}\n\t\tresult = &(self->content[offset]);\n\t}\n\treturn result;\n}\n\n#endif\n\n/**\n   Extract the content.\n\n   @param self Dynamic String\n   @return Content of dynamic string.\n\n   The content is removed from the dynamic string. This enables destruction\n   of the dynamic string without deallocation of the content.\n*/\n#if defined(TRIO_FUNC_STRING_EXTRACT)\n\nTRIO_PUBLIC_STRING char* trio_string_extract TRIO_ARGS1((self), trio_string_t* self)\n{\n\tchar* result;\n\n\tassert(self);\n\n\tresult = self->content;\n\t/* FIXME: Allocate new empty buffer? */\n\tself->content = NULL;\n\tself->length = self->allocated = 0;\n\treturn result;\n}\n\n#endif\n\n/**\n   Set the content of the dynamic string.\n\n   @param self Dynamic String\n   @param buffer The new content.\n\n   Sets the content of the dynamic string to a copy @p buffer.\n   An existing content will be deallocated first, if necessary.\n\n   @remark\n   This function will make a copy of @p buffer.\n   You are responsible for deallocating @p buffer yourself.\n*/\n#if defined(TRIO_FUNC_XSTRING_SET)\n\nTRIO_PUBLIC_STRING void trio_xstring_set TRIO_ARGS2((self, buffer), trio_string_t* self,\n                                                    char* buffer)\n{\n\tassert(self);\n\n\ttrio_destroy(self->content);\n\tself->content = trio_duplicate(buffer);\n}\n\n#endif\n\n/*\n * trio_string_size\n */\n#if defined(TRIO_FUNC_STRING_SIZE)\n\nTRIO_PUBLIC_STRING int trio_string_size TRIO_ARGS1((self), trio_string_t* self)\n{\n\tassert(self);\n\n\treturn self->allocated;\n}\n\n#endif\n\n/*\n * trio_string_terminate\n */\n#if defined(TRIO_FUNC_STRING_TERMINATE)\n\nTRIO_PUBLIC_STRING void trio_string_terminate TRIO_ARGS1((self), trio_string_t* self)\n{\n\ttrio_xstring_append_char(self, 0);\n}\n\n#endif\n\n/**\n   Append the second string to the first.\n\n   @param self Dynamic string to be modified.\n   @param other Dynamic string to copy from.\n   @return Boolean value indicating success or failure.\n*/\n#if defined(TRIO_FUNC_STRING_APPEND)\n\nTRIO_PUBLIC_STRING int trio_string_append TRIO_ARGS2((self, other), trio_string_t* self,\n                                                     trio_string_t* other)\n{\n\tsize_t length;\n\n\tassert(self);\n\tassert(other);\n\n\tlength = self->length + other->length;\n\tif (!internal_string_grow_to(self, length))\n\t\tgoto error;\n\ttrio_copy(&self->content[self->length], other->content);\n\tself->length = length;\n\treturn TRUE;\n\nerror:\n\treturn FALSE;\n}\n\n#endif\n\n/*\n * trio_xstring_append\n */\n#if defined(TRIO_FUNC_XSTRING_APPEND)\n\nTRIO_PUBLIC_STRING int trio_xstring_append TRIO_ARGS2((self, other), trio_string_t* self,\n                                                      TRIO_CONST char* other)\n{\n\tsize_t length;\n\n\tassert(self);\n\tassert(other);\n\n\tlength = self->length + trio_length(other);\n\tif (!internal_string_grow_to(self, length))\n\t\tgoto error;\n\ttrio_copy(&self->content[self->length], other);\n\tself->length = length;\n\treturn TRUE;\n\nerror:\n\treturn FALSE;\n}\n\n#endif\n\n/*\n * trio_xstring_append_char\n */\n#if defined(TRIO_FUNC_XSTRING_APPEND_CHAR)\n\nTRIO_PUBLIC_STRING int trio_xstring_append_char TRIO_ARGS2((self, character), trio_string_t* self,\n                                                           char character)\n{\n\tassert(self);\n\n\tif ((int)self->length >= trio_string_size(self))\n\t{\n\t\tif (!internal_string_grow(self, 0))\n\t\t\tgoto error;\n\t}\n\tself->content[self->length] = character;\n\tself->length++;\n\treturn TRUE;\n\nerror:\n\treturn FALSE;\n}\n\n#endif\n\n/*\n * trio_xstring_append_max\n */\n#if defined(TRIO_FUNC_XSTRING_APPEND_MAX)\n\nTRIO_PUBLIC_STRING int trio_xstring_append_max TRIO_ARGS3((self, other, max), trio_string_t* self,\n                                                          TRIO_CONST char* other, size_t max)\n{\n\tsize_t length;\n\n\tassert(self);\n\tassert(other);\n\n\tlength = self->length + trio_length_max(other, max);\n\tif (!internal_string_grow_to(self, length))\n\t\tgoto error;\n\n\t/*\n\t * Pass max + 1 since trio_copy_max copies one character less than\n\t * this from the source to make room for a terminating zero.\n\t */\n\ttrio_copy_max(&self->content[self->length], max + 1, other);\n\tself->length = length;\n\treturn TRUE;\n\nerror:\n\treturn FALSE;\n}\n\n#endif\n\n/**\n   Search for the first occurrence of second parameter in the first.\n\n   @param self Dynamic string to be modified.\n   @param other Dynamic string to copy from.\n   @return Boolean value indicating success or failure.\n*/\n#if defined(TRIO_FUNC_STRING_CONTAINS)\n\nTRIO_PUBLIC_STRING int trio_string_contains TRIO_ARGS2((self, other), trio_string_t* self,\n                                                       trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_contains(self->content, other->content);\n}\n\n#endif\n\n/*\n * trio_xstring_contains\n */\n#if defined(TRIO_FUNC_XSTRING_CONTAINS)\n\nTRIO_PUBLIC_STRING int trio_xstring_contains TRIO_ARGS2((self, other), trio_string_t* self,\n                                                        TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_contains(self->content, other);\n}\n\n#endif\n\n/*\n * trio_string_copy\n */\n#if defined(TRIO_FUNC_STRING_COPY)\n\nTRIO_PUBLIC_STRING int trio_string_copy TRIO_ARGS2((self, other), trio_string_t* self,\n                                                   trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\tself->length = 0;\n\treturn trio_string_append(self, other);\n}\n\n#endif\n\n/*\n * trio_xstring_copy\n */\n#if defined(TRIO_FUNC_XSTRING_COPY)\n\nTRIO_PUBLIC_STRING int trio_xstring_copy TRIO_ARGS2((self, other), trio_string_t* self,\n                                                    TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\tself->length = 0;\n\treturn trio_xstring_append(self, other);\n}\n\n#endif\n\n/*\n * trio_string_duplicate\n */\n#if defined(TRIO_FUNC_STRING_DUPLICATE)\n\nTRIO_PUBLIC_STRING trio_string_t* trio_string_duplicate TRIO_ARGS1((other), trio_string_t* other)\n{\n\ttrio_string_t* self;\n\n\tassert(other);\n\n\tself = internal_string_alloc();\n\tif (self)\n\t{\n\t\tself->content = internal_duplicate_max(other->content, other->length);\n\t\tif (self->content)\n\t\t{\n\t\t\tself->length = other->length;\n\t\t\tself->allocated = self->length + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself->length = self->allocated = 0;\n\t\t}\n\t}\n\treturn self;\n}\n\n#endif\n\n/*\n * trio_xstring_duplicate\n */\n#if defined(TRIO_FUNC_XSTRING_DUPLICATE)\n\nTRIO_PUBLIC_STRING trio_string_t* trio_xstring_duplicate TRIO_ARGS1((other), TRIO_CONST char* other)\n{\n\ttrio_string_t* self;\n\n\tassert(other);\n\n\tself = internal_string_alloc();\n\tif (self)\n\t{\n\t\tself->content = internal_duplicate_max(other, trio_length(other));\n\t\tif (self->content)\n\t\t{\n\t\t\tself->length = trio_length(self->content);\n\t\t\tself->allocated = self->length + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself->length = self->allocated = 0;\n\t\t}\n\t}\n\treturn self;\n}\n\n#endif\n\n/*\n * trio_string_equal\n */\n#if defined(TRIO_FUNC_STRING_EQUAL)\n\nTRIO_PUBLIC_STRING int trio_string_equal TRIO_ARGS2((self, other), trio_string_t* self,\n                                                    trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal(self->content, other->content);\n}\n\n#endif\n\n/*\n * trio_xstring_equal\n */\n#if defined(TRIO_FUNC_XSTRING_EQUAL)\n\nTRIO_PUBLIC_STRING int trio_xstring_equal TRIO_ARGS2((self, other), trio_string_t* self,\n                                                     TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal(self->content, other);\n}\n\n#endif\n\n/*\n * trio_string_equal_max\n */\n#if defined(TRIO_FUNC_STRING_EQUAL_MAX)\n\nTRIO_PUBLIC_STRING int trio_string_equal_max TRIO_ARGS3((self, max, other), trio_string_t* self,\n                                                        size_t max, trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal_max(self->content, max, other->content);\n}\n#endif\n\n/*\n * trio_xstring_equal_max\n */\n#if defined(TRIO_FUNC_XSTRING_EQUAL_MAX)\n\nTRIO_PUBLIC_STRING int trio_xstring_equal_max TRIO_ARGS3((self, max, other), trio_string_t* self,\n                                                         size_t max, TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal_max(self->content, max, other);\n}\n\n#endif\n\n/*\n * trio_string_equal_case\n */\n#if defined(TRIO_FUNC_STRING_EQUAL_CASE)\n\nTRIO_PUBLIC_STRING int trio_string_equal_case TRIO_ARGS2((self, other), trio_string_t* self,\n                                                         trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal_case(self->content, other->content);\n}\n\n#endif\n\n/*\n * trio_xstring_equal_case\n */\n#if defined(TRIO_FUNC_XSTRING_EQUAL_CASE)\n\nTRIO_PUBLIC_STRING int trio_xstring_equal_case TRIO_ARGS2((self, other), trio_string_t* self,\n                                                          TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal_case(self->content, other);\n}\n\n#endif\n\n/*\n * trio_string_equal_case_max\n */\n#if defined(TRIO_FUNC_STRING_EQUAL_CASE_MAX)\n\nTRIO_PUBLIC_STRING int trio_string_equal_case_max TRIO_ARGS3((self, max, other),\n                                                             trio_string_t* self, size_t max,\n                                                             trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal_case_max(self->content, max, other->content);\n}\n\n#endif\n\n/*\n * trio_xstring_equal_case_max\n */\n#if defined(TRIO_FUNC_XSTRING_EQUAL_CASE_MAX)\n\nTRIO_PUBLIC_STRING int trio_xstring_equal_case_max TRIO_ARGS3((self, max, other),\n                                                              trio_string_t* self, size_t max,\n                                                              TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal_case_max(self->content, max, other);\n}\n\n#endif\n\n/*\n * trio_string_format_data_max\n */\n#if defined(TRIO_FUNC_STRING_FORMAT_DATE_MAX)\n\nTRIO_PUBLIC_STRING size_t trio_string_format_date_max TRIO_ARGS4((self, max, format, datetime),\n                                                                 trio_string_t* self, size_t max,\n                                                                 TRIO_CONST char* format,\n                                                                 TRIO_CONST struct tm* datetime)\n{\n\tassert(self);\n\n\treturn trio_format_date_max(self->content, max, format, datetime);\n}\n\n#endif\n\n/*\n * trio_string_index\n */\n#if defined(TRIO_FUNC_STRING_INDEX)\n\nTRIO_PUBLIC_STRING char* trio_string_index TRIO_ARGS2((self, character), trio_string_t* self,\n                                                      int character)\n{\n\tassert(self);\n\n\treturn trio_index(self->content, character);\n}\n\n#endif\n\n/*\n * trio_string_index_last\n */\n#if defined(TRIO_FUNC_STRING_INDEX_LAST)\n\nTRIO_PUBLIC_STRING char* trio_string_index_last TRIO_ARGS2((self, character), trio_string_t* self,\n                                                           int character)\n{\n\tassert(self);\n\n\treturn trio_index_last(self->content, character);\n}\n\n#endif\n\n/*\n * trio_string_length\n */\n#if defined(TRIO_FUNC_STRING_LENGTH)\n\nTRIO_PUBLIC_STRING int trio_string_length TRIO_ARGS1((self), trio_string_t* self)\n{\n\tassert(self);\n\n\tif (self->length == 0)\n\t{\n\t\tself->length = trio_length(self->content);\n\t}\n\treturn self->length;\n}\n\n#endif\n\n/*\n * trio_string_lower\n */\n#if defined(TRIO_FUNC_STRING_LOWER)\n\nTRIO_PUBLIC_STRING int trio_string_lower TRIO_ARGS1((self), trio_string_t* self)\n{\n\tassert(self);\n\n\treturn trio_lower(self->content);\n}\n\n#endif\n\n/*\n * trio_string_match\n */\n#if defined(TRIO_FUNC_STRING_MATCH)\n\nTRIO_PUBLIC_STRING int trio_string_match TRIO_ARGS2((self, other), trio_string_t* self,\n                                                    trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_match(self->content, other->content);\n}\n\n#endif\n\n/*\n * trio_xstring_match\n */\n#if defined(TRIO_FUNC_XSTRING_MATCH)\n\nTRIO_PUBLIC_STRING int trio_xstring_match TRIO_ARGS2((self, other), trio_string_t* self,\n                                                     TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_match(self->content, other);\n}\n\n#endif\n\n/*\n * trio_string_match_case\n */\n#if defined(TRIO_FUNC_STRING_MATCH_CASE)\n\nTRIO_PUBLIC_STRING int trio_string_match_case TRIO_ARGS2((self, other), trio_string_t* self,\n                                                         trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_match_case(self->content, other->content);\n}\n\n#endif\n\n/*\n * trio_xstring_match_case\n */\n#if defined(TRIO_FUNC_XSTRING_MATCH_CASE)\n\nTRIO_PUBLIC_STRING int trio_xstring_match_case TRIO_ARGS2((self, other), trio_string_t* self,\n                                                          TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_match_case(self->content, other);\n}\n\n#endif\n\n/*\n * trio_string_substring\n */\n#if defined(TRIO_FUNC_STRING_SUBSTRING)\n\nTRIO_PUBLIC_STRING char* trio_string_substring TRIO_ARGS2((self, other), trio_string_t* self,\n                                                          trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_substring(self->content, other->content);\n}\n\n#endif\n\n/*\n * trio_xstring_substring\n */\n#if defined(TRIO_FUNC_XSTRING_SUBSTRING)\n\nTRIO_PUBLIC_STRING char* trio_xstring_substring TRIO_ARGS2((self, other), trio_string_t* self,\n                                                           TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_substring(self->content, other);\n}\n\n#endif\n\n/*\n * trio_string_upper\n */\n#if defined(TRIO_FUNC_STRING_UPPER)\n\nTRIO_PUBLIC_STRING int trio_string_upper TRIO_ARGS1((self), trio_string_t* self)\n{\n\tassert(self);\n\n\treturn trio_upper(self->content);\n}\n\n#endif\n\n/** @} End of DynamicStrings */\n"], "fixing_code": ["/*************************************************************************\n *\n * $Id: trio.c,v 1.131 2010/09/12 11:08:08 breese Exp $\n *\n * Copyright (C) 1998, 2009 Bjorn Reese and Daniel Stenberg.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND\n * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.\n *\n *************************************************************************\n *\n * A note to trio contributors:\n *\n * Avoid heap allocation at all costs to ensure that the trio functions\n * are async-safe. The exceptions are the printf/fprintf functions, which\n * uses fputc, and the asprintf functions and the <alloc> modifier, which\n * by design are required to allocate form the heap.\n *\n ************************************************************************/\n\n/*\n * TODO:\n *  - Scan is probably too permissive about its modifiers.\n *  - C escapes in %#[] ?\n *  - Multibyte characters (done for format parsing, except scan groups)\n *  - Complex numbers? (C99 _Complex)\n *  - Boolean values? (C99 _Bool)\n *  - C99 NaN(n-char-sequence) missing. The n-char-sequence can be used\n *    to print the mantissa, e.g. NaN(0xc000000000000000)\n *  - Should we support the GNU %a alloc modifier? GNU has an ugly hack\n *    for %a, because C99 used %a for other purposes. If specified as\n *    %as or %a[ it is interpreted as the alloc modifier, otherwise as\n *    the C99 hex-float. This means that you cannot scan %as as a hex-float\n *    immediately followed by an 's'.\n *  - Scanning of collating symbols.\n */\n\n/*************************************************************************\n * Trio include files\n */\n#include \"triodef.h\"\n#include \"trio.h\"\n#include \"triop.h\"\n\n#if defined(TRIO_EMBED_NAN)\n#define TRIO_PUBLIC_NAN static\n#if TRIO_FEATURE_FLOAT\n#define TRIO_FUNC_NAN\n#define TRIO_FUNC_NINF\n#define TRIO_FUNC_PINF\n#define TRIO_FUNC_FPCLASSIFY_AND_SIGNBIT\n#define TRIO_FUNC_ISINF\n#endif\n#endif\n#include \"trionan.h\"\n\n#if defined(TRIO_EMBED_STRING)\n#define TRIO_PUBLIC_STRING static\n#define TRIO_FUNC_LENGTH\n#define TRIO_FUNC_LENGTH_MAX\n#define TRIO_FUNC_TO_LONG\n#if TRIO_FEATURE_LOCALE\n#define TRIO_FUNC_COPY_MAX\n#endif\n#if TRIO_FEATURE_DYNAMICSTRING\n#define TRIO_FUNC_XSTRING_DUPLICATE\n#endif\n#if TRIO_EXTENSION && TRIO_FEATURE_SCANF\n#define TRIO_FUNC_EQUAL_LOCALE\n#endif\n#if TRIO_FEATURE_ERRNO\n#define TRIO_FUNC_ERROR\n#endif\n#if TRIO_FEATURE_FLOAT && TRIO_FEATURE_SCANF\n#define TRIO_FUNC_TO_DOUBLE\n#endif\n#if TRIO_FEATURE_DYNAMICSTRING\n#define TRIO_FUNC_STRING_EXTRACT\n#endif\n#if TRIO_FEATURE_DYNAMICSTRING\n#define TRIO_FUNC_STRING_TERMINATE\n#endif\n#if TRIO_FEATURE_USER_DEFINED\n#define TRIO_FUNC_DUPLICATE\n#endif\n#if TRIO_FEATURE_DYNAMICSTRING\n#define TRIO_FUNC_STRING_DESTROY\n#endif\n#if TRIO_FEATURE_USER_DEFINED\n#define TRIO_FUNC_DESTROY\n#endif\n#if TRIO_FEATURE_USER_DEFINED || (TRIO_FEATURE_FLOAT && TRIO_FEATURE_SCANF)\n#define TRIO_FUNC_EQUAL\n#endif\n#if TRIO_FEATURE_USER_DEFINED || TRIO_FEATURE_SCANF\n#define TRIO_FUNC_EQUAL_CASE\n#endif\n#if (TRIO_EXTENSION && TRIO_FEATURE_SCANF)\n#define TRIO_FUNC_EQUAL_MAX\n#endif\n#if TRIO_FEATURE_SCANF\n#define TRIO_FUNC_TO_UPPER\n#endif\n#if TRIO_FEATURE_DYNAMICSTRING\n#define TRIO_FUNC_XSTRING_APPEND_CHAR\n#endif\n#endif\n#include \"triostr.h\"\n\n/**************************************************************************\n *\n * Definitions\n *\n *************************************************************************/\n\n#include <limits.h>\n#if TRIO_FEATURE_FLOAT\n#include <math.h>\n#include <float.h>\n#endif\n\n#if defined(__STDC_ISO_10646__) || defined(MB_LEN_MAX) || defined(USE_MULTIBYTE) || \\\n    TRIO_FEATURE_WIDECHAR\n#if (!defined(TRIO_PLATFORM_WINCE) && !defined(ANDROID))\n#define TRIO_COMPILER_SUPPORTS_MULTIBYTE\n#if !defined(MB_LEN_MAX)\n#define MB_LEN_MAX 6\n#endif\n#endif\n#endif\n\n#if (TRIO_COMPILER_VISUALC - 0 >= 1100) || defined(TRIO_COMPILER_BORLAND)\n#define TRIO_COMPILER_SUPPORTS_VISUALC_INT\n#endif\n\n#if TRIO_FEATURE_FLOAT\n#if defined(PREDEF_STANDARD_C99) || defined(PREDEF_STANDARD_UNIX03)\n#if !defined(HAVE_FLOORL) && !defined(TRIO_NO_FLOORL)\n#define HAVE_FLOORL\n#endif\n#if !defined(HAVE_CEILL) && !defined(TRIO_NO_CEILL)\n#define HAVE_CEILL\n#endif\n#if !defined(HAVE_POWL) && !defined(TRIO_NO_POWL)\n#define HAVE_POWL\n#endif\n#if !defined(HAVE_FMODL) && !defined(TRIO_NO_FMODL)\n#define HAVE_FMODL\n#endif\n#if !defined(HAVE_LOG10L) && !defined(TRIO_NO_LOG10L)\n#define HAVE_LOG10L\n#endif\n#endif\n#if defined(TRIO_COMPILER_VISUALC)\n#if defined(floorl)\n#define HAVE_FLOORL\n#endif\n#if defined(ceill)\n#define HAVE_CEILL\n#endif\n#if defined(powl)\n#define HAVE_POWL\n#endif\n#if defined(fmodl)\n#define HAVE_FMODL\n#endif\n#if defined(log10l)\n#define HAVE_LOG10L\n#endif\n#endif\n#endif\n\n/*************************************************************************\n * Generic definitions\n */\n\n#if !(defined(DEBUG) || defined(NDEBUG))\n#define NDEBUG\n#endif\n\n#include <assert.h>\n#include <ctype.h>\n#if defined(PREDEF_STANDARD_C99) && !defined(isascii)\n#define isascii(x) ((x)&0x7F)\n#endif\n#if defined(TRIO_COMPILER_ANCIENT)\n#include <varargs.h>\n#else\n#include <stdarg.h>\n#endif\n#include <stddef.h>\n#if defined(TRIO_PLATFORM_WINCE)\nextern int errno;\n#else\n#include <errno.h>\n#endif\n\n#ifndef NULL\n#define NULL 0\n#endif\n#define NIL ((char)0)\n#ifndef FALSE\n#define FALSE (1 == 0)\n#define TRUE (!FALSE)\n#endif\n#define BOOLEAN_T int\n\n/* mincore() can be used for debugging purposes */\n#define VALID(x) (NULL != (x))\n\n#if TRIO_FEATURE_ERRORCODE\n/*\n * Encode the error code and the position. This is decoded\n * with TRIO_ERROR_CODE and TRIO_ERROR_POSITION.\n */\n#define TRIO_ERROR_RETURN(x, y) (-((x) + ((y) << 8)))\n#else\n#define TRIO_ERROR_RETURN(x, y) (-1)\n#endif\n\ntypedef unsigned long trio_flags_t;\n\n/*************************************************************************\n * Platform specific definitions\n */\n#if defined(TRIO_PLATFORM_UNIX)\n#include <unistd.h>\n#include <signal.h>\n#include <locale.h>\n#if !defined(TRIO_FEATURE_LOCALE)\n#define USE_LOCALE\n#endif\n#endif /* TRIO_PLATFORM_UNIX */\n#if defined(TRIO_PLATFORM_VMS)\n#include <unistd.h>\n#endif\n#if defined(TRIO_PLATFORM_WIN32)\n#if defined(TRIO_PLATFORM_WINCE)\nint read(int handle, char* buffer, unsigned int length);\nint write(int handle, const char* buffer, unsigned int length);\n#else\n#include <io.h>\n#define read _read\n#define write _write\n#endif\n#endif /* TRIO_PLATFORM_WIN32 */\n\n#if TRIO_FEATURE_WIDECHAR\n#if defined(PREDEF_STANDARD_C94)\n#include <wchar.h>\n#include <wctype.h>\ntypedef wchar_t trio_wchar_t;\ntypedef wint_t trio_wint_t;\n#else\ntypedef char trio_wchar_t;\ntypedef int trio_wint_t;\n#define WCONST(x) L##x\n#define WEOF EOF\n#define iswalnum(x) isalnum(x)\n#define iswalpha(x) isalpha(x)\n#define iswcntrl(x) iscntrl(x)\n#define iswdigit(x) isdigit(x)\n#define iswgraph(x) isgraph(x)\n#define iswlower(x) islower(x)\n#define iswprint(x) isprint(x)\n#define iswpunct(x) ispunct(x)\n#define iswspace(x) isspace(x)\n#define iswupper(x) isupper(x)\n#define iswxdigit(x) isxdigit(x)\n#endif\n#endif\n\n/*************************************************************************\n * Compiler dependent definitions\n */\n\n/* Support for long long */\n#ifndef __cplusplus\n#if !defined(USE_LONGLONG)\n#if defined(TRIO_COMPILER_GCC) && !defined(__STRICT_ANSI__)\n#define USE_LONGLONG\n#else\n#if defined(TRIO_COMPILER_SUNPRO)\n#define USE_LONGLONG\n#else\n#if defined(TRIO_COMPILER_MSVC) && (_MSC_VER >= 1400)\n#define USE_LONGLONG\n#else\n#if defined(_LONG_LONG) || defined(_LONGLONG)\n#define USE_LONGLONG\n#endif\n#endif\n#endif\n#endif\n#endif\n#endif\n\n/* The extra long numbers */\n#if defined(USE_LONGLONG)\ntypedef signed long long int trio_longlong_t;\ntypedef unsigned long long int trio_ulonglong_t;\n#else\n#if defined(TRIO_COMPILER_SUPPORTS_VISUALC_INT)\ntypedef signed __int64 trio_longlong_t;\ntypedef unsigned __int64 trio_ulonglong_t;\n#else\ntypedef TRIO_SIGNED long int trio_longlong_t;\ntypedef unsigned long int trio_ulonglong_t;\n#endif\n#endif\n\n/* Maximal and fixed integer types */\n#if defined(PREDEF_STANDARD_C99)\n#include <stdint.h>\ntypedef intmax_t trio_intmax_t;\ntypedef uintmax_t trio_uintmax_t;\ntypedef int8_t trio_int8_t;\ntypedef int16_t trio_int16_t;\ntypedef int32_t trio_int32_t;\ntypedef int64_t trio_int64_t;\n#else\n#if defined(PREDEF_STANDARD_UNIX98)\n#include <inttypes.h>\ntypedef intmax_t trio_intmax_t;\ntypedef uintmax_t trio_uintmax_t;\ntypedef int8_t trio_int8_t;\ntypedef int16_t trio_int16_t;\ntypedef int32_t trio_int32_t;\ntypedef int64_t trio_int64_t;\n#else\n#if defined(TRIO_COMPILER_SUPPORTS_VISUALC_INT)\ntypedef trio_longlong_t trio_intmax_t;\ntypedef trio_ulonglong_t trio_uintmax_t;\ntypedef __int8 trio_int8_t;\ntypedef __int16 trio_int16_t;\ntypedef __int32 trio_int32_t;\ntypedef __int64 trio_int64_t;\n#else\ntypedef trio_longlong_t trio_intmax_t;\ntypedef trio_ulonglong_t trio_uintmax_t;\n#if defined(TRIO_INT8_T)\ntypedef TRIO_INT8_T trio_int8_t;\n#else\ntypedef TRIO_SIGNED char trio_int8_t;\n#endif\n#if defined(TRIO_INT16_T)\ntypedef TRIO_INT16_T trio_int16_t;\n#else\ntypedef TRIO_SIGNED short trio_int16_t;\n#endif\n#if defined(TRIO_INT32_T)\ntypedef TRIO_INT32_T trio_int32_t;\n#else\ntypedef TRIO_SIGNED int trio_int32_t;\n#endif\n#if defined(TRIO_INT64_T)\ntypedef TRIO_INT64_T trio_int64_t;\n#else\ntypedef trio_longlong_t trio_int64_t;\n#endif\n#endif\n#endif\n#endif\n\n#if defined(HAVE_FLOORL)\n#define trio_floor(x) floorl((x))\n#else\n#define trio_floor(x) floor((double)(x))\n#endif\n\n#if defined(HAVE_CEILL)\n#define trio_ceil(x) ceill((x))\n#else\n#define trio_ceil(x) ceil((double)(x))\n#endif\n\n#if defined(HAVE_FMODL)\n#define trio_fmod(x, y) fmodl((x), (y))\n#else\n#define trio_fmod(x, y) fmod((double)(x), (double)(y))\n#endif\n\n#if defined(HAVE_POWL)\n#define trio_pow(x, y) powl((x), (y))\n#else\n#define trio_pow(x, y) pow((double)(x), (double)(y))\n#endif\n\n#if defined(HAVE_LOG10L)\n#define trio_log10(x) log10l((x))\n#else\n#define trio_log10(x) log10((double)(x))\n#endif\n\n#if TRIO_FEATURE_FLOAT\n#define TRIO_FABS(x) (((x) < 0.0) ? -(x) : (x))\n#endif\n\n/*************************************************************************\n * Internal Definitions\n */\n\n#ifdef _WIN32\n#pragma warning(push)\n#pragma warning(disable : 4244)\n#endif\n\n#if TRIO_FEATURE_FLOAT\n\n#if !defined(DECIMAL_DIG)\n#define DECIMAL_DIG DBL_DIG\n#endif\n\n/* Long double sizes */\n#ifdef LDBL_DIG\n#define MAX_MANTISSA_DIGITS LDBL_DIG\n#define MAX_EXPONENT_DIGITS 4\n#define MAX_DOUBLE_DIGITS LDBL_MAX_10_EXP\n#else\n#define MAX_MANTISSA_DIGITS DECIMAL_DIG\n#define MAX_EXPONENT_DIGITS 3\n#define MAX_DOUBLE_DIGITS DBL_MAX_10_EXP\n#endif\n\n#if defined(TRIO_COMPILER_ANCIENT) || !defined(LDBL_DIG)\n#undef LDBL_DIG\n#undef LDBL_MANT_DIG\n#undef LDBL_EPSILON\n#define LDBL_DIG DBL_DIG\n#define LDBL_MANT_DIG DBL_MANT_DIG\n#define LDBL_EPSILON DBL_EPSILON\n#endif\n\n#endif /* TRIO_FEATURE_FLOAT */\n\n/* The maximal number of digits is for base 2 */\n#define MAX_CHARS_IN(x) (sizeof(x) * CHAR_BIT)\n/* The width of a pointer. The number of bits in a hex digit is 4 */\n#define POINTER_WIDTH ((sizeof(\"0x\") - 1) + sizeof(trio_pointer_t) * CHAR_BIT / 4)\n\n#if TRIO_FEATURE_FLOAT\n/* Infinite and Not-A-Number for floating-point */\n#define INFINITE_LOWER \"inf\"\n#define INFINITE_UPPER \"INF\"\n#define LONG_INFINITE_LOWER \"infinite\"\n#define LONG_INFINITE_UPPER \"INFINITE\"\n#define NAN_LOWER \"nan\"\n#define NAN_UPPER \"NAN\"\n#endif\n\n/* Various constants */\nenum\n{\n\tTYPE_PRINT = 1,\n#if TRIO_FEATURE_SCANF\n\tTYPE_SCAN = 2,\n#endif\n\n\t/* Flags. FLAGS_LAST must be less than ULONG_MAX */\n\tFLAGS_NEW = 0,\n\tFLAGS_STICKY = 1,\n\tFLAGS_SPACE = 2 * FLAGS_STICKY,\n\tFLAGS_SHOWSIGN = 2 * FLAGS_SPACE,\n\tFLAGS_LEFTADJUST = 2 * FLAGS_SHOWSIGN,\n\tFLAGS_ALTERNATIVE = 2 * FLAGS_LEFTADJUST,\n\tFLAGS_SHORT = 2 * FLAGS_ALTERNATIVE,\n\tFLAGS_SHORTSHORT = 2 * FLAGS_SHORT,\n\tFLAGS_LONG = 2 * FLAGS_SHORTSHORT,\n\tFLAGS_QUAD = 2 * FLAGS_LONG,\n\tFLAGS_LONGDOUBLE = 2 * FLAGS_QUAD,\n\tFLAGS_SIZE_T = 2 * FLAGS_LONGDOUBLE,\n\tFLAGS_PTRDIFF_T = 2 * FLAGS_SIZE_T,\n\tFLAGS_INTMAX_T = 2 * FLAGS_PTRDIFF_T,\n\tFLAGS_NILPADDING = 2 * FLAGS_INTMAX_T,\n\tFLAGS_UNSIGNED = 2 * FLAGS_NILPADDING,\n\tFLAGS_UPPER = 2 * FLAGS_UNSIGNED,\n\tFLAGS_WIDTH = 2 * FLAGS_UPPER,\n\tFLAGS_WIDTH_PARAMETER = 2 * FLAGS_WIDTH,\n\tFLAGS_PRECISION = 2 * FLAGS_WIDTH_PARAMETER,\n\tFLAGS_PRECISION_PARAMETER = 2 * FLAGS_PRECISION,\n\tFLAGS_BASE = 2 * FLAGS_PRECISION_PARAMETER,\n\tFLAGS_BASE_PARAMETER = 2 * FLAGS_BASE,\n\tFLAGS_FLOAT_E = 2 * FLAGS_BASE_PARAMETER,\n\tFLAGS_FLOAT_G = 2 * FLAGS_FLOAT_E,\n\tFLAGS_QUOTE = 2 * FLAGS_FLOAT_G,\n\tFLAGS_WIDECHAR = 2 * FLAGS_QUOTE,\n\tFLAGS_IGNORE = 2 * FLAGS_WIDECHAR,\n\tFLAGS_IGNORE_PARAMETER = 2 * FLAGS_IGNORE,\n\tFLAGS_VARSIZE_PARAMETER = 2 * FLAGS_IGNORE_PARAMETER,\n\tFLAGS_FIXED_SIZE = 2 * FLAGS_VARSIZE_PARAMETER,\n\tFLAGS_LAST = FLAGS_FIXED_SIZE,\n\t/* Reused flags */\n\tFLAGS_EXCLUDE = FLAGS_SHORT,\n\tFLAGS_USER_DEFINED = FLAGS_IGNORE,\n\tFLAGS_USER_DEFINED_PARAMETER = FLAGS_IGNORE_PARAMETER,\n\tFLAGS_ROUNDING = FLAGS_INTMAX_T,\n\t/* Compounded flags */\n\tFLAGS_ALL_VARSIZES = FLAGS_LONG | FLAGS_QUAD | FLAGS_INTMAX_T | FLAGS_PTRDIFF_T | FLAGS_SIZE_T,\n\tFLAGS_ALL_SIZES = FLAGS_ALL_VARSIZES | FLAGS_SHORTSHORT | FLAGS_SHORT,\n\n\tNO_POSITION = -1,\n\tNO_WIDTH = 0,\n\tNO_PRECISION = -1,\n\tNO_SIZE = -1,\n\n\t/* Do not change these */\n\tNO_BASE = -1,\n\tMIN_BASE = 2,\n\tMAX_BASE = 36,\n\tBASE_BINARY = 2,\n\tBASE_OCTAL = 8,\n\tBASE_DECIMAL = 10,\n\tBASE_HEX = 16,\n\n\t/* Maximal number of allowed parameters */\n\tMAX_PARAMETERS = 64,\n\t/* Maximal number of characters in class */\n\tMAX_CHARACTER_CLASS = UCHAR_MAX + 1,\n\n#if TRIO_FEATURE_USER_DEFINED\n\t/* Maximal string lengths for user-defined specifiers */\n\tMAX_USER_NAME = 64,\n\tMAX_USER_DATA = 256,\n#endif\n\n\t/* Maximal length of locale separator strings */\n\tMAX_LOCALE_SEPARATOR_LENGTH = MB_LEN_MAX,\n\t/* Maximal number of integers in grouping */\n\tMAX_LOCALE_GROUPS = 64\n};\n\n#define NO_GROUPING ((int)CHAR_MAX)\n\n/* Fundamental formatting parameter types */\n#define FORMAT_SENTINEL -1 /* marks end of parameters array */\n#define FORMAT_UNKNOWN 0\n#define FORMAT_INT 1\n#define FORMAT_DOUBLE 2\n#define FORMAT_CHAR 3\n#define FORMAT_STRING 4\n#define FORMAT_POINTER 5\n#define FORMAT_COUNT 6\n#define FORMAT_PARAMETER 7\n#define FORMAT_GROUP 8\n#define FORMAT_ERRNO 9\n#define FORMAT_USER_DEFINED 10\n\n/* Character constants */\n#define CHAR_IDENTIFIER '%'\n#define CHAR_ALT_IDENTIFIER '$'\n#define CHAR_BACKSLASH '\\\\'\n#define CHAR_QUOTE '\\\"'\n#define CHAR_ADJUST ' '\n\n#if TRIO_EXTENSION\n/* Character class expressions */\n#define CLASS_ALNUM \"[:alnum:]\"\n#define CLASS_ALPHA \"[:alpha:]\"\n#define CLASS_BLANK \"[:blank:]\"\n#define CLASS_CNTRL \"[:cntrl:]\"\n#define CLASS_DIGIT \"[:digit:]\"\n#define CLASS_GRAPH \"[:graph:]\"\n#define CLASS_LOWER \"[:lower:]\"\n#define CLASS_PRINT \"[:print:]\"\n#define CLASS_PUNCT \"[:punct:]\"\n#define CLASS_SPACE \"[:space:]\"\n#define CLASS_UPPER \"[:upper:]\"\n#define CLASS_XDIGIT \"[:xdigit:]\"\n#endif\n\n/*\n * SPECIFIERS:\n *\n *\n * a  Hex-float\n * A  Hex-float\n * c  Character\n * C  Widechar character (wint_t)\n * d  Decimal\n * e  Float\n * E  Float\n * F  Float\n * F  Float\n * g  Float\n * G  Float\n * i  Integer\n * m  Error message\n * n  Count\n * o  Octal\n * p  Pointer\n * s  String\n * S  Widechar string (wchar_t *)\n * u  Unsigned\n * x  Hex\n * X  Hex\n * [] Group\n * <> User-defined\n *\n * Reserved:\n *\n * D  Binary Coded Decimal %D(length,precision) (OS/390)\n */\n#define SPECIFIER_CHAR 'c'\n#define SPECIFIER_STRING 's'\n#define SPECIFIER_DECIMAL 'd'\n#define SPECIFIER_INTEGER 'i'\n#define SPECIFIER_UNSIGNED 'u'\n#define SPECIFIER_OCTAL 'o'\n#define SPECIFIER_HEX 'x'\n#define SPECIFIER_HEX_UPPER 'X'\n#if TRIO_FEATURE_FLOAT\n#define SPECIFIER_FLOAT_E 'e'\n#define SPECIFIER_FLOAT_E_UPPER 'E'\n#define SPECIFIER_FLOAT_F 'f'\n#define SPECIFIER_FLOAT_F_UPPER 'F'\n#define SPECIFIER_FLOAT_G 'g'\n#define SPECIFIER_FLOAT_G_UPPER 'G'\n#endif\n#define SPECIFIER_POINTER 'p'\n#if TRIO_FEATURE_SCANF\n#define SPECIFIER_GROUP '['\n#define SPECIFIER_UNGROUP ']'\n#endif\n#define SPECIFIER_COUNT 'n'\n#if TRIO_UNIX98\n#define SPECIFIER_CHAR_UPPER 'C'\n#define SPECIFIER_STRING_UPPER 'S'\n#endif\n#define SPECIFIER_HEXFLOAT 'a'\n#define SPECIFIER_HEXFLOAT_UPPER 'A'\n#define SPECIFIER_ERRNO 'm'\n#if TRIO_FEATURE_BINARY\n#define SPECIFIER_BINARY 'b'\n#define SPECIFIER_BINARY_UPPER 'B'\n#endif\n#if TRIO_FEATURE_USER_DEFINED\n#define SPECIFIER_USER_DEFINED_BEGIN '<'\n#define SPECIFIER_USER_DEFINED_END '>'\n#define SPECIFIER_USER_DEFINED_SEPARATOR ':'\n#define SPECIFIER_USER_DEFINED_EXTRA '|'\n#endif\n\n/*\n * QUALIFIERS:\n *\n *\n * Numbers = d,i,o,u,x,X\n * Float = a,A,e,E,f,F,g,G\n * String = s\n * Char = c\n *\n *\n * 9$ Position\n *      Use the 9th parameter. 9 can be any number between 1 and\n *      the maximal argument\n *\n * 9 Width\n *      Set width to 9. 9 can be any number, but must not be postfixed\n *      by '$'\n *\n * h  Short\n *    Numbers:\n *      (unsigned) short int\n *\n * hh Short short\n *    Numbers:\n *      (unsigned) char\n *\n * l  Long\n *    Numbers:\n *      (unsigned) long int\n *    String:\n *      as the S specifier\n *    Char:\n *      as the C specifier\n *\n * ll Long Long\n *    Numbers:\n *      (unsigned) long long int\n *\n * L  Long Double\n *    Float\n *      long double\n *\n * #  Alternative\n *    Float:\n *      Decimal-point is always present\n *    String:\n *      non-printable characters are handled as \\number\n *\n *    Spacing\n *\n * +  Sign\n *\n * -  Alignment\n *\n * .  Precision\n *\n * *  Parameter\n *    print: use parameter\n *    scan: no parameter (ignore)\n *\n * q  Quad\n *\n * Z  size_t\n *\n * w  Widechar\n *\n * '  Thousands/quote\n *    Numbers:\n *      Integer part grouped in thousands\n *    Binary numbers:\n *      Number grouped in nibbles (4 bits)\n *    String:\n *      Quoted string\n *\n * j  intmax_t\n * t  prtdiff_t\n * z  size_t\n *\n * !  Sticky\n * @  Parameter (for both print and scan)\n *\n * I  n-bit Integer\n *    Numbers:\n *      The following options exists\n *        I8  = 8-bit integer\n *        I16 = 16-bit integer\n *        I32 = 32-bit integer\n *        I64 = 64-bit integer\n */\n#define QUALIFIER_POSITION '$'\n#define QUALIFIER_SHORT 'h'\n#define QUALIFIER_LONG 'l'\n#define QUALIFIER_LONG_UPPER 'L'\n#define QUALIFIER_ALTERNATIVE '#'\n#define QUALIFIER_SPACE ' '\n#define QUALIFIER_PLUS '+'\n#define QUALIFIER_MINUS '-'\n#define QUALIFIER_DOT '.'\n#define QUALIFIER_STAR '*'\n#define QUALIFIER_CIRCUMFLEX '^' /* For scanlists */\n#define QUALIFIER_SIZE_T 'z'\n#define QUALIFIER_PTRDIFF_T 't'\n#define QUALIFIER_INTMAX_T 'j'\n#define QUALIFIER_QUAD 'q'\n#define QUALIFIER_SIZE_T_UPPER 'Z'\n#if TRIO_MISC\n#define QUALIFIER_WIDECHAR 'w'\n#endif\n#define QUALIFIER_FIXED_SIZE 'I'\n#define QUALIFIER_QUOTE '\\''\n#define QUALIFIER_STICKY '!'\n#define QUALIFIER_VARSIZE '&' /* This should remain undocumented */\n#define QUALIFIER_ROUNDING_UPPER 'R'\n#if TRIO_EXTENSION\n#define QUALIFIER_PARAM '@' /* Experimental */\n#define QUALIFIER_COLON ':' /* For scanlists */\n#define QUALIFIER_EQUAL '=' /* For scanlists */\n#endif\n\n/*************************************************************************\n *\n * Internal Structures\n *\n *************************************************************************/\n\n/* Parameters */\ntypedef struct\n{\n\t/* An indication of which entry in the data union is used */\n\tint type;\n\t/* The flags */\n\ttrio_flags_t flags;\n\t/* The width qualifier */\n\tint width;\n\t/* The precision qualifier */\n\tint precision;\n\t/* The base qualifier */\n\tint base;\n\t/* Base from specifier */\n\tint baseSpecifier;\n\t/* The size for the variable size qualifier */\n\tint varsize;\n\t/* Offset of the first character of the specifier */\n\tint beginOffset;\n\t/* Offset of the first character after the specifier */\n\tint endOffset;\n\t/* Position in the argument list that this parameter refers to */\n\tint position;\n\t/* The data from the argument list */\n\tunion {\n\t\tchar* string;\n#if TRIO_FEATURE_WIDECHAR\n\t\ttrio_wchar_t* wstring;\n#endif\n\t\ttrio_pointer_t pointer;\n\t\tunion {\n\t\t\ttrio_intmax_t as_signed;\n\t\t\ttrio_uintmax_t as_unsigned;\n\t\t} number;\n#if TRIO_FEATURE_FLOAT\n\t\tdouble doubleNumber;\n\t\tdouble* doublePointer;\n\t\ttrio_long_double_t longdoubleNumber;\n\t\ttrio_long_double_t* longdoublePointer;\n#endif\n\t\tint errorNumber;\n\t} data;\n#if TRIO_FEATURE_USER_DEFINED\n\t/* For the user-defined specifier */\n\tunion {\n\t\tchar namespace[MAX_USER_NAME];\n\t\tint handler; /* if flags & FLAGS_USER_DEFINED_PARAMETER */\n\t} user_defined;\n\tchar user_data[MAX_USER_DATA];\n#endif\n} trio_parameter_t;\n\n/* Container for customized functions */\ntypedef struct\n{\n\tunion {\n\t\ttrio_outstream_t out;\n\t\ttrio_instream_t in;\n\t} stream;\n\ttrio_pointer_t closure;\n} trio_custom_t;\n\n/* General trio \"class\" */\ntypedef struct _trio_class_t\n{\n\t/*\n\t * The function to write characters to a stream.\n\t */\n\tvoid(*OutStream) TRIO_PROTO((struct _trio_class_t*, int));\n\t/*\n\t * The function to read characters from a stream.\n\t */\n\tvoid(*InStream) TRIO_PROTO((struct _trio_class_t*, int*));\n\t/*\n\t * The function to undo read characters from a stream.\n\t */\n\tvoid(*UndoStream) TRIO_PROTO((struct _trio_class_t*));\n\t/*\n\t * The current location in the stream.\n\t */\n\ttrio_pointer_t location;\n\t/*\n\t * The character currently being processed.\n\t */\n\tint current;\n\t/*\n\t * The number of characters that would have been written/read\n\t * if there had been sufficient space.\n\t */\n\tint processed;\n\tunion {\n\t\t/*\n\t\t * The number of characters that are actually written. Processed and\n\t\t * committed will only differ for the *nprintf functions.\n\t\t */\n\t\tint committed;\n\t\t/*\n\t\t * The number of look-ahead characters read.\n\t\t */\n\t\tint cached;\n\t} actually;\n\t/*\n\t * The upper limit of characters that may be written/read.\n\t */\n\tint max;\n\t/*\n\t * The last output error that was detected.\n\t */\n\tint error;\n} trio_class_t;\n\n/* References (for user-defined callbacks) */\ntypedef struct _trio_reference_t\n{\n\ttrio_class_t* data;\n\ttrio_parameter_t* parameter;\n} trio_reference_t;\n\n#if TRIO_FEATURE_USER_DEFINED\n/* Registered entries (for user-defined callbacks) */\ntypedef struct _trio_userdef_t\n{\n\tstruct _trio_userdef_t* next;\n\ttrio_callback_t callback;\n\tchar* name;\n} trio_userdef_t;\n#endif\n\n/*************************************************************************\n *\n * Internal Variables\n *\n *************************************************************************/\n/* Unused but kept for reference */\n/* static TRIO_CONST char rcsid[] = \"@(#)$Id: trio.c,v 1.131 2010/09/12 11:08:08 breese Exp $\"; */\n\n#if TRIO_FEATURE_FLOAT\n/*\n * Need this to workaround a parser bug in HP C/iX compiler that fails\n * to resolves macro definitions that includes type 'long double',\n * e.g: va_arg(arg_ptr, long double)\n */\n#if defined(TRIO_PLATFORM_MPEIX)\nstatic TRIO_CONST trio_long_double_t ___dummy_long_double = 0;\n#endif\n#endif\n\nstatic TRIO_CONST char internalNullString[] = \"(nil)\";\n\n#if defined(USE_LOCALE)\nstatic struct lconv* internalLocaleValues = NULL;\n#endif\n\n/*\n * UNIX98 says \"in a locale where the radix character is not defined,\n * the radix character defaults to a period (.)\"\n */\n#if TRIO_FEATURE_FLOAT || TRIO_FEATURE_LOCALE || defined(USE_LOCALE)\nstatic int internalDecimalPointLength = 1;\nstatic char internalDecimalPoint = '.';\nstatic char internalDecimalPointString[MAX_LOCALE_SEPARATOR_LENGTH + 1] = \".\";\n#endif\n#if TRIO_FEATURE_QUOTE || TRIO_FEATURE_LOCALE || TRIO_EXTENSION\nstatic int internalThousandSeparatorLength = 1;\nstatic char internalThousandSeparator[MAX_LOCALE_SEPARATOR_LENGTH + 1] = \",\";\nstatic char internalGrouping[MAX_LOCALE_GROUPS] = { (char)NO_GROUPING };\n#endif\n\nstatic TRIO_CONST char internalDigitsLower[] = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nstatic TRIO_CONST char internalDigitsUpper[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n#if TRIO_FEATURE_SCANF\nstatic BOOLEAN_T internalDigitsUnconverted = TRUE;\nstatic int internalDigitArray[128];\n#if TRIO_EXTENSION\nstatic BOOLEAN_T internalCollationUnconverted = TRUE;\nstatic char internalCollationArray[MAX_CHARACTER_CLASS][MAX_CHARACTER_CLASS];\n#endif\n#endif\n\n#if TRIO_FEATURE_USER_DEFINED\nstatic TRIO_VOLATILE trio_callback_t internalEnterCriticalRegion = NULL;\nstatic TRIO_VOLATILE trio_callback_t internalLeaveCriticalRegion = NULL;\nstatic trio_userdef_t* internalUserDef = NULL;\n#endif\n\n/*************************************************************************\n *\n * Internal Functions\n *\n ************************************************************************/\n\n#if defined(TRIO_EMBED_NAN)\n#include \"trionan.c\"\n#endif\n\n#if defined(TRIO_EMBED_STRING)\n#include \"triostr.c\"\n#endif\n\n/*************************************************************************\n * TrioInitializeParameter\n *\n * Description:\n *  Initialize a trio_parameter_t struct.\n */\nTRIO_PRIVATE void TrioInitializeParameter TRIO_ARGS1((parameter), trio_parameter_t* parameter)\n{\n\tparameter->type = FORMAT_UNKNOWN;\n\tparameter->flags = 0;\n\tparameter->width = 0;\n\tparameter->precision = 0;\n\tparameter->base = 0;\n\tparameter->baseSpecifier = 0;\n\tparameter->varsize = 0;\n\tparameter->beginOffset = 0;\n\tparameter->endOffset = 0;\n\tparameter->position = 0;\n\tparameter->data.pointer = 0;\n#if TRIO_FEATURE_USER_DEFINED\n\tparameter->user_defined.handler = 0;\n\tparameter->user_data[0] = 0;\n#endif\n}\n\n/*************************************************************************\n * TrioCopyParameter\n *\n * Description:\n *  Copies one trio_parameter_t struct to another.\n */\nTRIO_PRIVATE void TrioCopyParameter TRIO_ARGS2((target, source), trio_parameter_t* target,\n                                               TRIO_CONST trio_parameter_t* source)\n{\n#if TRIO_FEATURE_USER_DEFINED\n\tsize_t i;\n#endif\n\n\ttarget->type = source->type;\n\ttarget->flags = source->flags;\n\ttarget->width = source->width;\n\ttarget->precision = source->precision;\n\ttarget->base = source->base;\n\ttarget->baseSpecifier = source->baseSpecifier;\n\ttarget->varsize = source->varsize;\n\ttarget->beginOffset = source->beginOffset;\n\ttarget->endOffset = source->endOffset;\n\ttarget->position = source->position;\n\ttarget->data = source->data;\n\n#if TRIO_FEATURE_USER_DEFINED\n\ttarget->user_defined = source->user_defined;\n\n\tfor (i = 0U; i < sizeof(target->user_data); ++i)\n\t{\n\t\tif ((target->user_data[i] = source->user_data[i]) == NIL)\n\t\t\tbreak;\n\t}\n#endif\n}\n\n/*************************************************************************\n * TrioIsQualifier\n *\n * Description:\n *  Remember to add all new qualifiers to this function.\n *  QUALIFIER_POSITION must not be added.\n */\nTRIO_PRIVATE BOOLEAN_T TrioIsQualifier TRIO_ARGS1((character), TRIO_CONST char character)\n{\n\t/* QUALIFIER_POSITION is not included */\n\tswitch (character)\n\t{\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\tcase QUALIFIER_PLUS:\n\t\tcase QUALIFIER_MINUS:\n\t\tcase QUALIFIER_SPACE:\n\t\tcase QUALIFIER_DOT:\n\t\tcase QUALIFIER_STAR:\n\t\tcase QUALIFIER_ALTERNATIVE:\n\t\tcase QUALIFIER_SHORT:\n\t\tcase QUALIFIER_LONG:\n\t\tcase QUALIFIER_CIRCUMFLEX:\n\t\tcase QUALIFIER_LONG_UPPER:\n\t\tcase QUALIFIER_SIZE_T:\n\t\tcase QUALIFIER_PTRDIFF_T:\n\t\tcase QUALIFIER_INTMAX_T:\n\t\tcase QUALIFIER_QUAD:\n\t\tcase QUALIFIER_SIZE_T_UPPER:\n#if defined(QUALIFIER_WIDECHAR)\n\t\tcase QUALIFIER_WIDECHAR:\n#endif\n\t\tcase QUALIFIER_QUOTE:\n\t\tcase QUALIFIER_STICKY:\n\t\tcase QUALIFIER_VARSIZE:\n#if defined(QUALIFIER_PARAM)\n\t\tcase QUALIFIER_PARAM:\n#endif\n\t\tcase QUALIFIER_FIXED_SIZE:\n\t\tcase QUALIFIER_ROUNDING_UPPER:\n\t\t\treturn TRUE;\n\t\tdefault:\n\t\t\treturn FALSE;\n\t}\n}\n\n/*************************************************************************\n * TrioSetLocale\n */\n#if defined(USE_LOCALE)\nTRIO_PRIVATE void TrioSetLocale(TRIO_NOARGS)\n{\n\tinternalLocaleValues = (struct lconv*)localeconv();\n\tif (internalLocaleValues)\n\t{\n\t\tif ((internalLocaleValues->decimal_point) &&\n\t\t    (internalLocaleValues->decimal_point[0] != NIL))\n\t\t{\n\t\t\tinternalDecimalPointLength = trio_length(internalLocaleValues->decimal_point);\n\t\t\tif (internalDecimalPointLength == 1)\n\t\t\t{\n\t\t\t\tinternalDecimalPoint = internalLocaleValues->decimal_point[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinternalDecimalPoint = NIL;\n\t\t\t\ttrio_copy_max(internalDecimalPointString, sizeof(internalDecimalPointString),\n\t\t\t\t              internalLocaleValues->decimal_point);\n\t\t\t}\n\t\t}\n#if TRIO_EXTENSION\n\t\tif ((internalLocaleValues->thousands_sep) &&\n\t\t    (internalLocaleValues->thousands_sep[0] != NIL))\n\t\t{\n\t\t\ttrio_copy_max(internalThousandSeparator, sizeof(internalThousandSeparator),\n\t\t\t              internalLocaleValues->thousands_sep);\n\t\t\tinternalThousandSeparatorLength = trio_length(internalThousandSeparator);\n\t\t}\n#endif\n#if TRIO_EXTENSION\n\t\tif ((internalLocaleValues->grouping) && (internalLocaleValues->grouping[0] != NIL))\n\t\t{\n\t\t\ttrio_copy_max(internalGrouping, sizeof(internalGrouping),\n\t\t\t              internalLocaleValues->grouping);\n\t\t}\n#endif\n\t}\n}\n#endif /* defined(USE_LOCALE) */\n\n#if TRIO_FEATURE_FLOAT && TRIO_FEATURE_QUOTE\nTRIO_PRIVATE int TrioCalcThousandSeparatorLength TRIO_ARGS1((digits), int digits)\n{\n\tint count = 0;\n\tint step = NO_GROUPING;\n\tchar* groupingPointer = internalGrouping;\n\n\twhile (digits > 0)\n\t{\n\t\tif (*groupingPointer == CHAR_MAX)\n\t\t{\n\t\t\t/* Disable grouping */\n\t\t\tbreak; /* while */\n\t\t}\n\t\telse if (*groupingPointer == 0)\n\t\t{\n\t\t\t/* Repeat last group */\n\t\t\tif (step == NO_GROUPING)\n\t\t\t{\n\t\t\t\t/* Error in locale */\n\t\t\t\tbreak; /* while */\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstep = *groupingPointer++;\n\t\t}\n\t\tif (digits > step)\n\t\t\tcount += internalThousandSeparatorLength;\n\t\tdigits -= step;\n\t}\n\treturn count;\n}\n#endif /* TRIO_FEATURE_FLOAT && TRIO_FEATURE_QUOTE */\n\n#if TRIO_FEATURE_QUOTE\nTRIO_PRIVATE BOOLEAN_T TrioFollowedBySeparator TRIO_ARGS1((position), int position)\n{\n\tint step = 0;\n\tchar* groupingPointer = internalGrouping;\n\n\tposition--;\n\tif (position == 0)\n\t\treturn FALSE;\n\twhile (position > 0)\n\t{\n\t\tif (*groupingPointer == CHAR_MAX)\n\t\t{\n\t\t\t/* Disable grouping */\n\t\t\tbreak; /* while */\n\t\t}\n\t\telse if (*groupingPointer != 0)\n\t\t{\n\t\t\tstep = *groupingPointer++;\n\t\t}\n\t\tif (step == 0)\n\t\t\tbreak;\n\t\tposition -= step;\n\t}\n\treturn (position == 0);\n}\n#endif /* TRIO_FEATURE_QUOTE */\n\n/*************************************************************************\n * TrioGetPosition\n *\n * Get the %n$ position.\n */\nTRIO_PRIVATE int TrioGetPosition TRIO_ARGS2((format, offsetPointer), TRIO_CONST char* format,\n                                            int* offsetPointer)\n{\n#if TRIO_FEATURE_POSITIONAL\n\tchar* tmpformat;\n\tint number = 0;\n\tint offset = *offsetPointer;\n\n\tnumber = (int)trio_to_long(&format[offset], &tmpformat, BASE_DECIMAL);\n\toffset = (int)(tmpformat - format);\n\tif ((number != 0) && (QUALIFIER_POSITION == format[offset++]))\n\t{\n\t\t*offsetPointer = offset;\n\t\t/*\n\t\t * number is decreased by 1, because n$ starts from 1, whereas\n\t\t * the array it is indexing starts from 0.\n\t\t */\n\t\treturn number - 1;\n\t}\n#endif\n\treturn NO_POSITION;\n}\n\n/*************************************************************************\n * TrioFindNamespace\n *\n * Find registered user-defined specifier.\n * The prev argument is used for optimization only.\n */\n#if TRIO_FEATURE_USER_DEFINED\nTRIO_PRIVATE trio_userdef_t* TrioFindNamespace TRIO_ARGS2((name, prev), TRIO_CONST char* name,\n                                                          trio_userdef_t** prev)\n{\n\ttrio_userdef_t* def;\n\n\tif (internalEnterCriticalRegion)\n\t\t(void)internalEnterCriticalRegion(NULL);\n\n\tfor (def = internalUserDef; def; def = def->next)\n\t{\n\t\t/* Case-sensitive string comparison */\n\t\tif (trio_equal_case(def->name, name))\n\t\t\tbreak;\n\n\t\tif (prev)\n\t\t\t*prev = def;\n\t}\n\n\tif (internalLeaveCriticalRegion)\n\t\t(void)internalLeaveCriticalRegion(NULL);\n\n\treturn def;\n}\n#endif\n\n/*************************************************************************\n * TrioPower\n *\n * Description:\n *  Calculate pow(base, exponent), where number and exponent are integers.\n */\n#if TRIO_FEATURE_FLOAT\nTRIO_PRIVATE trio_long_double_t TrioPower TRIO_ARGS2((number, exponent), int number, int exponent)\n{\n\ttrio_long_double_t result;\n\n\tif (number == 10)\n\t{\n\t\tswitch (exponent)\n\t\t{\n\t\t\t\t/* Speed up calculation of common cases */\n\t\t\tcase 0:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E-1);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+0);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+1);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+2);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+3);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+4);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+5);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+6);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+7);\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tresult = (trio_long_double_t)number * TRIO_SUFFIX_LONG(1E+8);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresult = trio_pow((trio_long_double_t)number, (trio_long_double_t)exponent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn trio_pow((trio_long_double_t)number, (trio_long_double_t)exponent);\n\t}\n\treturn result;\n}\n#endif /* TRIO_FEATURE_FLOAT */\n\n/*************************************************************************\n * TrioLogarithm\n */\n#if TRIO_FEATURE_FLOAT\nTRIO_PRIVATE trio_long_double_t TrioLogarithm TRIO_ARGS2((number, base), trio_long_double_t number,\n                                                         int base)\n{\n\ttrio_long_double_t result;\n\n\tif (number <= 0.0)\n\t{\n\t\t/* xlC crashes on log(0) */\n\t\tresult = (number == 0.0) ? trio_ninf() : trio_nan();\n\t}\n\telse\n\t{\n\t\tif (base == 10)\n\t\t{\n\t\t\tresult = trio_log10(number);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = trio_log10(number) / trio_log10((double)base);\n\t\t}\n\t}\n\treturn result;\n}\n#endif /* TRIO_FEATURE_FLOAT */\n\n/*************************************************************************\n * TrioLogarithmBase\n */\n#if TRIO_FEATURE_FLOAT\nTRIO_PRIVATE double TrioLogarithmBase TRIO_ARGS1((base), int base)\n{\n\tswitch (base)\n\t{\n\t\tcase BASE_BINARY:\n\t\t\treturn 1.0;\n\t\tcase BASE_OCTAL:\n\t\t\treturn 3.0;\n\t\tcase BASE_DECIMAL:\n\t\t\treturn 3.321928094887362345;\n\t\tcase BASE_HEX:\n\t\t\treturn 4.0;\n\t\tdefault:\n\t\t\treturn TrioLogarithm((double)base, 2);\n\t}\n}\n#endif /* TRIO_FEATURE_FLOAT */\n\n/*************************************************************************\n * TrioParseQualifiers\n *\n * Description:\n *  Parse the qualifiers of a potential conversion specifier\n */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wimplicit-fallthrough\"\nTRIO_PRIVATE int TrioParseQualifiers TRIO_ARGS4((type, format, offset, parameter), int type,\n                                                TRIO_CONST char* format, int offset,\n                                                trio_parameter_t* parameter)\n{\n\tchar ch;\n\tint dots = 0; /* Count number of dots in modifier part */\n\tchar* tmpformat;\n\n\tparameter->beginOffset = offset - 1;\n\tparameter->flags = FLAGS_NEW;\n\tparameter->position = TrioGetPosition(format, &offset);\n\n\t/* Default values */\n\tparameter->width = NO_WIDTH;\n\tparameter->precision = NO_PRECISION;\n\tparameter->base = NO_BASE;\n\tparameter->varsize = NO_SIZE;\n\n\twhile (TrioIsQualifier(format[offset]))\n\t{\n\t\tch = format[offset++];\n\n\t\tswitch (ch)\n\t\t{\n\t\t\tcase QUALIFIER_SPACE:\n\t\t\t\tparameter->flags |= FLAGS_SPACE;\n\t\t\t\tbreak;\n\n\t\t\tcase QUALIFIER_PLUS:\n\t\t\t\tparameter->flags |= FLAGS_SHOWSIGN;\n\t\t\t\tbreak;\n\n\t\t\tcase QUALIFIER_MINUS:\n\t\t\t\tparameter->flags |= FLAGS_LEFTADJUST;\n\t\t\t\tparameter->flags &= ~FLAGS_NILPADDING;\n\t\t\t\tbreak;\n\n\t\t\tcase QUALIFIER_ALTERNATIVE:\n\t\t\t\tparameter->flags |= FLAGS_ALTERNATIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase QUALIFIER_DOT:\n\t\t\t\tif (dots == 0) /* Precision */\n\t\t\t\t{\n\t\t\t\t\tdots++;\n\n\t\t\t\t\t/* Skip if no precision */\n\t\t\t\t\tif (QUALIFIER_DOT == format[offset])\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t/* After the first dot we have the precision */\n\t\t\t\t\tparameter->flags |= FLAGS_PRECISION;\n\t\t\t\t\tif ((QUALIFIER_STAR == format[offset])\n#if defined(QUALIFIER_PARAM)\n\t\t\t\t\t    || (QUALIFIER_PARAM == format[offset])\n#endif\n\t\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t\tparameter->flags |= FLAGS_PRECISION_PARAMETER;\n\t\t\t\t\t\tparameter->precision = TrioGetPosition(format, &offset);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tparameter->precision =\n\t\t\t\t\t\t    trio_to_long(&format[offset], &tmpformat, BASE_DECIMAL);\n\t\t\t\t\t\toffset = (int)(tmpformat - format);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (dots == 1) /* Base */\n\t\t\t\t{\n\t\t\t\t\tdots++;\n\n\t\t\t\t\t/* After the second dot we have the base */\n\t\t\t\t\tparameter->flags |= FLAGS_BASE;\n\t\t\t\t\tif ((QUALIFIER_STAR == format[offset])\n#if defined(QUALIFIER_PARAM)\n\t\t\t\t\t    || (QUALIFIER_PARAM == format[offset])\n#endif\n\t\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t\tparameter->flags |= FLAGS_BASE_PARAMETER;\n\t\t\t\t\t\tparameter->base = TrioGetPosition(format, &offset);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tparameter->base = trio_to_long(&format[offset], &tmpformat, BASE_DECIMAL);\n\t\t\t\t\t\tif (parameter->base > MAX_BASE)\n\t\t\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t\t\t\t\toffset = (int)(tmpformat - format);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t\t\t}\n\t\t\t\tbreak; /* QUALIFIER_DOT */\n\n#if defined(QUALIFIER_PARAM)\n\t\t\tcase QUALIFIER_PARAM:\n\t\t\t\tparameter->type = TYPE_PRINT;\n\t\t\t\t/* FALLTHROUGH */\n#endif\n\t\t\tcase QUALIFIER_STAR:\n\t\t\t\t/* This has different meanings for print and scan */\n\t\t\t\tif (TYPE_PRINT == type)\n\t\t\t\t{\n\t\t\t\t\t/* Read with from parameter */\n\t\t\t\t\tint width = TrioGetPosition(format, &offset);\n\t\t\t\t\tparameter->flags |= (FLAGS_WIDTH | FLAGS_WIDTH_PARAMETER);\n\t\t\t\t\tif (NO_POSITION != width)\n\t\t\t\t\t\tparameter->width = width;\n\t\t\t\t\t/* else keep parameter->width = NO_WIDTH which != NO_POSITION */\n\t\t\t\t}\n#if TRIO_FEATURE_SCANF\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Scan, but do not store result */\n\t\t\t\t\tparameter->flags |= FLAGS_IGNORE;\n\t\t\t\t}\n#endif\n\t\t\t\tbreak; /* QUALIFIER_STAR */\n\n\t\t\tcase '0':\n\t\t\t\tif (!(parameter->flags & FLAGS_LEFTADJUST))\n\t\t\t\t\tparameter->flags |= FLAGS_NILPADDING;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\t\tparameter->flags |= FLAGS_WIDTH;\n\t\t\t\t/*\n\t\t\t\t * &format[offset - 1] is used to \"rewind\" the read\n\t\t\t\t * character from format\n\t\t\t\t */\n\t\t\t\tparameter->width = trio_to_long(&format[offset - 1], &tmpformat, BASE_DECIMAL);\n\t\t\t\toffset = (int)(tmpformat - format);\n\t\t\t\tbreak;\n\n\t\t\tcase QUALIFIER_SHORT:\n\t\t\t\tif (parameter->flags & FLAGS_SHORTSHORT)\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t\t\telse if (parameter->flags & FLAGS_SHORT)\n\t\t\t\t\tparameter->flags |= FLAGS_SHORTSHORT;\n\t\t\t\telse\n\t\t\t\t\tparameter->flags |= FLAGS_SHORT;\n\t\t\t\tbreak;\n\n\t\t\tcase QUALIFIER_LONG:\n\t\t\t\tif (parameter->flags & FLAGS_QUAD)\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t\t\telse if (parameter->flags & FLAGS_LONG)\n\t\t\t\t\tparameter->flags |= FLAGS_QUAD;\n\t\t\t\telse\n\t\t\t\t\tparameter->flags |= FLAGS_LONG;\n\t\t\t\tbreak;\n\n#if TRIO_FEATURE_LONGDOUBLE\n\t\t\tcase QUALIFIER_LONG_UPPER:\n\t\t\t\tparameter->flags |= FLAGS_LONGDOUBLE;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_SIZE_T\n\t\t\tcase QUALIFIER_SIZE_T:\n\t\t\t\tparameter->flags |= FLAGS_SIZE_T;\n\t\t\t\t/* Modify flags for later truncation of number */\n\t\t\t\tif (sizeof(size_t) == sizeof(trio_ulonglong_t))\n\t\t\t\t\tparameter->flags |= FLAGS_QUAD;\n\t\t\t\telse if (sizeof(size_t) == sizeof(long))\n\t\t\t\t\tparameter->flags |= FLAGS_LONG;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_PTRDIFF_T\n\t\t\tcase QUALIFIER_PTRDIFF_T:\n\t\t\t\tparameter->flags |= FLAGS_PTRDIFF_T;\n\t\t\t\tif (sizeof(ptrdiff_t) == sizeof(trio_ulonglong_t))\n\t\t\t\t\tparameter->flags |= FLAGS_QUAD;\n\t\t\t\telse if (sizeof(ptrdiff_t) == sizeof(long))\n\t\t\t\t\tparameter->flags |= FLAGS_LONG;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_INTMAX_T\n\t\t\tcase QUALIFIER_INTMAX_T:\n\t\t\t\tparameter->flags |= FLAGS_INTMAX_T;\n\t\t\t\tif (sizeof(trio_intmax_t) == sizeof(trio_ulonglong_t))\n\t\t\t\t\tparameter->flags |= FLAGS_QUAD;\n\t\t\t\telse if (sizeof(trio_intmax_t) == sizeof(long))\n\t\t\t\t\tparameter->flags |= FLAGS_LONG;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_QUAD\n\t\t\tcase QUALIFIER_QUAD:\n\t\t\t\tparameter->flags |= FLAGS_QUAD;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_FIXED_SIZE\n\t\t\tcase QUALIFIER_FIXED_SIZE:\n\t\t\t\tif (parameter->flags & FLAGS_FIXED_SIZE)\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\n\t\t\t\tif (parameter->flags &\n\t\t\t\t    (FLAGS_ALL_SIZES | FLAGS_LONGDOUBLE | FLAGS_WIDECHAR | FLAGS_VARSIZE_PARAMETER))\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\n\t\t\t\tif ((format[offset] == '6') && (format[offset + 1] == '4'))\n\t\t\t\t{\n\t\t\t\t\tparameter->varsize = sizeof(trio_int64_t);\n\t\t\t\t\toffset += 2;\n\t\t\t\t}\n\t\t\t\telse if ((format[offset] == '3') && (format[offset + 1] == '2'))\n\t\t\t\t{\n\t\t\t\t\tparameter->varsize = sizeof(trio_int32_t);\n\t\t\t\t\toffset += 2;\n\t\t\t\t}\n\t\t\t\telse if ((format[offset] == '1') && (format[offset + 1] == '6'))\n\t\t\t\t{\n\t\t\t\t\tparameter->varsize = sizeof(trio_int16_t);\n\t\t\t\t\toffset += 2;\n\t\t\t\t}\n\t\t\t\telse if (format[offset] == '8')\n\t\t\t\t{\n\t\t\t\t\tparameter->varsize = sizeof(trio_int8_t);\n\t\t\t\t\toffset++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\n\t\t\t\tparameter->flags |= FLAGS_FIXED_SIZE;\n\t\t\t\tbreak;\n#endif /* TRIO_FEATURE_FIXED_SIZE */\n\n#if defined(QUALIFIER_WIDECHAR)\n\t\t\tcase QUALIFIER_WIDECHAR:\n\t\t\t\tparameter->flags |= FLAGS_WIDECHAR;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_SIZE_T_UPPER\n\t\t\tcase QUALIFIER_SIZE_T_UPPER:\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_QUOTE\n\t\t\tcase QUALIFIER_QUOTE:\n\t\t\t\tparameter->flags |= FLAGS_QUOTE;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_STICKY\n\t\t\tcase QUALIFIER_STICKY:\n\t\t\t\tparameter->flags |= FLAGS_STICKY;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_VARSIZE\n\t\t\tcase QUALIFIER_VARSIZE:\n\t\t\t\tparameter->flags |= FLAGS_VARSIZE_PARAMETER;\n\t\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_ROUNDING\n\t\t\tcase QUALIFIER_ROUNDING_UPPER:\n\t\t\t\tparameter->flags |= FLAGS_ROUNDING;\n\t\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\t/* Bail out completely to make the error more obvious */\n\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t}\n\n\t} /* while qualifier */\n\n\tparameter->endOffset = offset;\n\n\treturn 0;\n}\n#pragma GCC diagnostic pop\n\n/*************************************************************************\n * TrioParseSpecifier\n *\n * Description:\n *  Parse the specifier part of a potential conversion specifier\n */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wimplicit-fallthrough\"\nTRIO_PRIVATE int TrioParseSpecifier TRIO_ARGS4((type, format, offset, parameter), int type,\n                                               TRIO_CONST char* format, int offset,\n                                               trio_parameter_t* parameter)\n{\n\tparameter->baseSpecifier = NO_BASE;\n\n\tswitch (format[offset++])\n\t{\n#if defined(SPECIFIER_CHAR_UPPER)\n\t\tcase SPECIFIER_CHAR_UPPER:\n\t\t\tparameter->flags |= FLAGS_WIDECHAR;\n\t\t\t/* FALLTHROUGH */\n#endif\n\t\tcase SPECIFIER_CHAR:\n\t\t\tif (parameter->flags & FLAGS_LONG)\n\t\t\t\tparameter->flags |= FLAGS_WIDECHAR;\n\t\t\telse if (parameter->flags & FLAGS_SHORT)\n\t\t\t\tparameter->flags &= ~FLAGS_WIDECHAR;\n\t\t\tparameter->type = FORMAT_CHAR;\n\t\t\tbreak;\n\n#if defined(SPECIFIER_STRING_UPPER)\n\t\tcase SPECIFIER_STRING_UPPER:\n\t\t\tparameter->flags |= FLAGS_WIDECHAR;\n\t\t\t/* FALLTHROUGH */\n#endif\n\t\tcase SPECIFIER_STRING:\n\t\t\tif (parameter->flags & FLAGS_LONG)\n\t\t\t\tparameter->flags |= FLAGS_WIDECHAR;\n\t\t\telse if (parameter->flags & FLAGS_SHORT)\n\t\t\t\tparameter->flags &= ~FLAGS_WIDECHAR;\n\t\t\tparameter->type = FORMAT_STRING;\n\t\t\tbreak;\n\n#if defined(SPECIFIER_GROUP)\n\t\tcase SPECIFIER_GROUP:\n\t\t\tif (TYPE_SCAN == type)\n\t\t\t{\n\t\t\t\tint depth = 1;\n\t\t\t\tparameter->type = FORMAT_GROUP;\n\t\t\t\tif (format[offset] == QUALIFIER_CIRCUMFLEX)\n\t\t\t\t\toffset++;\n\t\t\t\tif (format[offset] == SPECIFIER_UNGROUP)\n\t\t\t\t\toffset++;\n\t\t\t\tif (format[offset] == QUALIFIER_MINUS)\n\t\t\t\t\toffset++;\n\t\t\t\t/* Skip nested brackets */\n\t\t\t\twhile (format[offset] != NIL)\n\t\t\t\t{\n\t\t\t\t\tif (format[offset] == SPECIFIER_GROUP)\n\t\t\t\t\t{\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (format[offset] == SPECIFIER_UNGROUP)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (--depth <= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toffset++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\toffset++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif /* defined(SPECIFIER_GROUP) */\n\n\t\tcase SPECIFIER_INTEGER:\n\t\t\tparameter->type = FORMAT_INT;\n\t\t\tbreak;\n\n\t\tcase SPECIFIER_UNSIGNED:\n\t\t\tparameter->flags |= FLAGS_UNSIGNED;\n\t\t\tparameter->type = FORMAT_INT;\n\t\t\tbreak;\n\n\t\tcase SPECIFIER_DECIMAL:\n\t\t\tparameter->baseSpecifier = BASE_DECIMAL;\n\t\t\tparameter->type = FORMAT_INT;\n\t\t\tbreak;\n\n\t\tcase SPECIFIER_OCTAL:\n\t\t\tparameter->flags |= FLAGS_UNSIGNED;\n\t\t\tparameter->baseSpecifier = BASE_OCTAL;\n\t\t\tparameter->type = FORMAT_INT;\n\t\t\tbreak;\n\n#if TRIO_FEATURE_BINARY\n\t\tcase SPECIFIER_BINARY_UPPER:\n\t\t\tparameter->flags |= FLAGS_UPPER;\n\t\t\t/* FALLTHROUGH */\n\t\tcase SPECIFIER_BINARY:\n\t\t\tparameter->flags |= FLAGS_NILPADDING;\n\t\t\tparameter->baseSpecifier = BASE_BINARY;\n\t\t\tparameter->type = FORMAT_INT;\n\t\t\tbreak;\n#endif\n\n\t\tcase SPECIFIER_HEX_UPPER:\n\t\t\tparameter->flags |= FLAGS_UPPER;\n\t\t\t/* FALLTHROUGH */\n\t\tcase SPECIFIER_HEX:\n\t\t\tparameter->flags |= FLAGS_UNSIGNED;\n\t\t\tparameter->baseSpecifier = BASE_HEX;\n\t\t\tparameter->type = FORMAT_INT;\n\t\t\tbreak;\n\n#if defined(SPECIFIER_FLOAT_E)\n#if defined(SPECIFIER_FLOAT_E_UPPER)\n\t\tcase SPECIFIER_FLOAT_E_UPPER:\n\t\t\tparameter->flags |= FLAGS_UPPER;\n\t\t\t/* FALLTHROUGH */\n#endif\n\t\tcase SPECIFIER_FLOAT_E:\n\t\t\tparameter->flags |= FLAGS_FLOAT_E;\n\t\t\tparameter->type = FORMAT_DOUBLE;\n\t\t\tbreak;\n#endif\n\n#if defined(SPECIFIER_FLOAT_G)\n#if defined(SPECIFIER_FLOAT_G_UPPER)\n\t\tcase SPECIFIER_FLOAT_G_UPPER:\n\t\t\tparameter->flags |= FLAGS_UPPER;\n\t\t\t/* FALLTHROUGH */\n#endif\n\t\tcase SPECIFIER_FLOAT_G:\n\t\t\tparameter->flags |= FLAGS_FLOAT_G;\n\t\t\tparameter->type = FORMAT_DOUBLE;\n\t\t\tbreak;\n#endif\n\n#if defined(SPECIFIER_FLOAT_F)\n#if defined(SPECIFIER_FLOAT_F_UPPER)\n\t\tcase SPECIFIER_FLOAT_F_UPPER:\n\t\t\tparameter->flags |= FLAGS_UPPER;\n\t\t\t/* FALLTHROUGH */\n#endif\n\t\tcase SPECIFIER_FLOAT_F:\n\t\t\tparameter->type = FORMAT_DOUBLE;\n\t\t\tbreak;\n#endif\n\n#if defined(TRIO_COMPILER_VISUALC)\n#pragma warning(push)\n#pragma warning(disable : 4127) /* Conditional expression is constant */\n#endif\n\t\tcase SPECIFIER_POINTER:\n\t\t\tif (sizeof(trio_pointer_t) == sizeof(trio_ulonglong_t))\n\t\t\t\tparameter->flags |= FLAGS_QUAD;\n\t\t\telse if (sizeof(trio_pointer_t) == sizeof(long))\n\t\t\t\tparameter->flags |= FLAGS_LONG;\n\t\t\tparameter->type = FORMAT_POINTER;\n\t\t\tbreak;\n#if defined(TRIO_COMPILER_VISUALC)\n#pragma warning(pop)\n#endif\n\n\t\tcase SPECIFIER_COUNT:\n\t\t\tparameter->type = FORMAT_COUNT;\n\t\t\tbreak;\n\n#if TRIO_FEATURE_HEXFLOAT\n\t\tcase SPECIFIER_HEXFLOAT_UPPER:\n\t\t\tparameter->flags |= FLAGS_UPPER;\n\t\t\t/* FALLTHROUGH */\n\t\tcase SPECIFIER_HEXFLOAT:\n\t\t\tparameter->baseSpecifier = BASE_HEX;\n\t\t\tparameter->type = FORMAT_DOUBLE;\n\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_ERRNO\n\t\tcase SPECIFIER_ERRNO:\n\t\t\tparameter->type = FORMAT_ERRNO;\n\t\t\tbreak;\n#endif\n\n#if TRIO_FEATURE_USER_DEFINED\n\t\tcase SPECIFIER_USER_DEFINED_BEGIN:\n\t\t{\n\t\t\tunsigned int max;\n\t\t\tint without_namespace = TRUE;\n\t\t\tchar* tmpformat = (char*)&format[offset];\n\t\t\tint ch;\n\n\t\t\tparameter->type = FORMAT_USER_DEFINED;\n\t\t\tparameter->user_defined.namespace[0] = NIL;\n\n\t\t\twhile ((ch = format[offset]) != NIL)\n\t\t\t{\n\t\t\t\toffset++;\n\t\t\t\tif ((ch == SPECIFIER_USER_DEFINED_END) || (ch == SPECIFIER_USER_DEFINED_EXTRA))\n\t\t\t\t{\n\t\t\t\t\tif (without_namespace)\n\t\t\t\t\t\t/* No namespace, handler will be passed as an argument */\n\t\t\t\t\t\tparameter->flags |= FLAGS_USER_DEFINED_PARAMETER;\n\n\t\t\t\t\t/* Copy the user data */\n\t\t\t\t\tmax = (unsigned int)(&format[offset] - tmpformat);\n\t\t\t\t\tif (max > MAX_USER_DATA)\n\t\t\t\t\t\tmax = MAX_USER_DATA;\n\t\t\t\t\ttrio_copy_max(parameter->user_data, max, tmpformat);\n\n\t\t\t\t\t/* Skip extra data (which is only there to keep the compiler happy) */\n\t\t\t\t\twhile ((ch != NIL) && (ch != SPECIFIER_USER_DEFINED_END))\n\t\t\t\t\t\tch = format[offset++];\n\n\t\t\t\t\tbreak; /* while */\n\t\t\t\t}\n\n\t\t\t\tif (ch == SPECIFIER_USER_DEFINED_SEPARATOR)\n\t\t\t\t{\n\t\t\t\t\twithout_namespace = FALSE;\n\t\t\t\t\t/* Copy the namespace for later looking-up */\n\t\t\t\t\tmax = (int)(&format[offset] - tmpformat);\n\t\t\t\t\tif (max > MAX_USER_NAME)\n\t\t\t\t\t\tmax = MAX_USER_NAME;\n\t\t\t\t\ttrio_copy_max(parameter->user_defined.namespace, max, tmpformat);\n\t\t\t\t\ttmpformat = (char*)&format[offset];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ch != SPECIFIER_USER_DEFINED_END)\n\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t}\n\t\tbreak;\n#endif /* TRIO_FEATURE_USER_DEFINED */\n\n\t\tdefault:\n\t\t\t/* Bail out completely to make the error more obvious */\n\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t}\n\n\tparameter->endOffset = offset;\n\n\treturn 0;\n}\n#pragma GCC diagnostic pop\n\n/*************************************************************************\n * TrioParse\n *\n * Description:\n *  Parse the format string\n */\nTRIO_PRIVATE int TrioParse TRIO_ARGS6((type, format, parameters, arglist, argfunc, argarray),\n                                      int type, TRIO_CONST char* format,\n                                      trio_parameter_t* parameters, va_list arglist,\n                                      trio_argfunc_t argfunc, trio_pointer_t* argarray)\n{\n\t/* Count the number of times a parameter is referenced */\n\tunsigned short usedEntries[MAX_PARAMETERS];\n\t/* Parameter counters */\n\tint parameterPosition;\n\tint maxParam = -1;\n\t/* Utility variables */\n\tint offset;           /* Offset into formatting string */\n\tBOOLEAN_T positional; /* Does the specifier have a positional? */\n#if TRIO_FEATURE_STICKY\n\tBOOLEAN_T gotSticky = FALSE; /* Are there any sticky modifiers at all? */\n#endif\n\t/*\n\t * indices specifies the order in which the parameters must be\n\t * read from the va_args (this is necessary to handle positionals)\n\t */\n\tint indices[MAX_PARAMETERS];\n\tint pos = 0;\n\t/* Various variables */\n#if defined(TRIO_COMPILER_SUPPORTS_MULTIBYTE)\n\tint charlen;\n#endif\n\tint save_errno;\n\tint i = -1;\n\tint num;\n\ttrio_parameter_t workParameter;\n\tint status;\n\n\t/* Both must be set or none must be set */\n\tassert(((argfunc == NULL) && (argarray == NULL)) || ((argfunc != NULL) && (argarray != NULL)));\n\n\t/*\n\t * The 'parameters' array is not initialized, but we need to\n\t * know which entries we have used.\n\t */\n\tmemset(usedEntries, 0, sizeof(usedEntries));\n\n\tsave_errno = errno;\n\toffset = 0;\n\tparameterPosition = 0;\n#if defined(TRIO_COMPILER_SUPPORTS_MULTIBYTE)\n\t(void)mblen(NULL, 0);\n#endif\n\n\twhile (format[offset])\n\t{\n\t\tTrioInitializeParameter(&workParameter);\n\n#if defined(TRIO_COMPILER_SUPPORTS_MULTIBYTE)\n\t\tif (!isascii(format[offset]))\n\t\t{\n\t\t\t/*\n\t\t\t * Multibyte characters cannot be legal specifiers or\n\t\t\t * modifiers, so we skip over them.\n\t\t\t */\n\t\t\tcharlen = mblen(&format[offset], MB_LEN_MAX);\n\t\t\toffset += (charlen > 0) ? charlen : 1;\n\t\t\tcontinue; /* while */\n\t\t}\n#endif /* TRIO_COMPILER_SUPPORTS_MULTIBYTE */\n\n\t\tswitch (format[offset++])\n\t\t{\n\n\t\t\tcase CHAR_IDENTIFIER:\n\t\t\t{\n\t\t\t\tif (CHAR_IDENTIFIER == format[offset])\n\t\t\t\t{\n\t\t\t\t\t/* skip double \"%\" */\n\t\t\t\t\toffset++;\n\t\t\t\t\tcontinue; /* while */\n\t\t\t\t}\n\n\t\t\t\tstatus = TrioParseQualifiers(type, format, offset, &workParameter);\n\t\t\t\tif (status < 0)\n\t\t\t\t\treturn status; /* Return qualifier syntax error */\n\n\t\t\t\tstatus = TrioParseSpecifier(type, format, workParameter.endOffset, &workParameter);\n\t\t\t\tif (status < 0)\n\t\t\t\t\treturn status; /* Return specifier syntax error */\n\t\t\t}\n\t\t\tbreak;\n\n#if TRIO_EXTENSION\n\t\t\tcase CHAR_ALT_IDENTIFIER:\n\t\t\t{\n\t\t\t\tstatus = TrioParseQualifiers(type, format, offset, &workParameter);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tcontinue; /* False alert, not a user defined specifier */\n\n\t\t\t\tstatus = TrioParseSpecifier(type, format, workParameter.endOffset, &workParameter);\n\t\t\t\tif ((status < 0) || (FORMAT_USER_DEFINED != workParameter.type))\n\t\t\t\t\tcontinue; /* False alert, not a user defined specifier */\n\t\t\t}\n\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\tcontinue; /* while */\n\t\t}\n\n\t\t/* now handle the parsed conversion specification */\n\t\tpositional = (NO_POSITION != workParameter.position);\n\n\t\t/*\n\t\t * Parameters only need the type and value. The value is\n\t\t * read later.\n\t\t */\n\t\tif (workParameter.flags & FLAGS_WIDTH_PARAMETER)\n\t\t{\n\t\t\tif (workParameter.width == NO_WIDTH)\n\t\t\t{\n\t\t\t\tworkParameter.width = parameterPosition++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!positional)\n\t\t\t\t\tworkParameter.position = workParameter.width + 1;\n\t\t\t}\n\n\t\t\tusedEntries[workParameter.width] += 1;\n\t\t\tif (workParameter.width > maxParam)\n\t\t\t\tmaxParam = workParameter.width;\n\t\t\tparameters[pos].type = FORMAT_PARAMETER;\n\t\t\tparameters[pos].flags = 0;\n\t\t\tindices[workParameter.width] = pos;\n\t\t\tworkParameter.width = pos++;\n\t\t}\n\t\tif (workParameter.flags & FLAGS_PRECISION_PARAMETER)\n\t\t{\n\t\t\tif (workParameter.precision == NO_PRECISION)\n\t\t\t{\n\t\t\t\tworkParameter.precision = parameterPosition++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!positional)\n\t\t\t\t\tworkParameter.position = workParameter.precision + 1;\n\t\t\t}\n\n\t\t\tusedEntries[workParameter.precision] += 1;\n\t\t\tif (workParameter.precision > maxParam)\n\t\t\t\tmaxParam = workParameter.precision;\n\t\t\tparameters[pos].type = FORMAT_PARAMETER;\n\t\t\tparameters[pos].flags = 0;\n\t\t\tindices[workParameter.precision] = pos;\n\t\t\tworkParameter.precision = pos++;\n\t\t}\n\t\tif (workParameter.flags & FLAGS_BASE_PARAMETER)\n\t\t{\n\t\t\tif (workParameter.base == NO_BASE)\n\t\t\t{\n\t\t\t\tworkParameter.base = parameterPosition++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!positional)\n\t\t\t\t\tworkParameter.position = workParameter.base + 1;\n\t\t\t}\n\n\t\t\tusedEntries[workParameter.base] += 1;\n\t\t\tif (workParameter.base > maxParam)\n\t\t\t\tmaxParam = workParameter.base;\n\t\t\tparameters[pos].type = FORMAT_PARAMETER;\n\t\t\tparameters[pos].flags = 0;\n\t\t\tindices[workParameter.base] = pos;\n\t\t\tworkParameter.base = pos++;\n\t\t}\n#if TRIO_FEATURE_VARSIZE\n\t\tif (workParameter.flags & FLAGS_VARSIZE_PARAMETER)\n\t\t{\n\t\t\tworkParameter.varsize = parameterPosition++;\n\n\t\t\tusedEntries[workParameter.varsize] += 1;\n\t\t\tif (workParameter.varsize > maxParam)\n\t\t\t\tmaxParam = workParameter.varsize;\n\t\t\tparameters[pos].type = FORMAT_PARAMETER;\n\t\t\tparameters[pos].flags = 0;\n\t\t\tindices[workParameter.varsize] = pos;\n\t\t\tworkParameter.varsize = pos++;\n\t\t}\n#endif\n#if TRIO_FEATURE_USER_DEFINED\n\t\tif (workParameter.flags & FLAGS_USER_DEFINED_PARAMETER)\n\t\t{\n\t\t\tworkParameter.user_defined.handler = parameterPosition++;\n\n\t\t\tusedEntries[workParameter.user_defined.handler] += 1;\n\t\t\tif (workParameter.user_defined.handler > maxParam)\n\t\t\t\tmaxParam = workParameter.user_defined.handler;\n\t\t\tparameters[pos].type = FORMAT_PARAMETER;\n\t\t\tparameters[pos].flags = FLAGS_USER_DEFINED;\n\t\t\tindices[workParameter.user_defined.handler] = pos;\n\t\t\tworkParameter.user_defined.handler = pos++;\n\t\t}\n#endif\n\n\t\tif (NO_POSITION == workParameter.position)\n\t\t{\n\t\t\tworkParameter.position = parameterPosition++;\n\t\t}\n\n\t\tif (workParameter.position > maxParam)\n\t\t\tmaxParam = workParameter.position;\n\n\t\tif (workParameter.position >= MAX_PARAMETERS)\n\t\t{\n\t\t\t/* Bail out completely to make the error more obvious */\n\t\t\treturn TRIO_ERROR_RETURN(TRIO_ETOOMANY, offset);\n\t\t}\n\n\t\tindices[workParameter.position] = pos;\n\n\t\t/*  Count the number of times this entry has been used */\n\t\tusedEntries[workParameter.position] += 1;\n\n\t\t/* Find last sticky parameters */\n#if TRIO_FEATURE_STICKY\n\t\tif (workParameter.flags & FLAGS_STICKY)\n\t\t{\n\t\t\tgotSticky = TRUE;\n\t\t}\n\t\telse if (gotSticky)\n\t\t{\n\t\t\tfor (i = pos - 1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tif (parameters[i].type == FORMAT_PARAMETER)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((parameters[i].flags & FLAGS_STICKY) &&\n\t\t\t\t    (parameters[i].type == workParameter.type))\n\t\t\t\t{\n\t\t\t\t\t/* Do not overwrite current qualifiers */\n\t\t\t\t\tworkParameter.flags |= (parameters[i].flags & (unsigned long)~FLAGS_STICKY);\n\t\t\t\t\tif (workParameter.width == NO_WIDTH)\n\t\t\t\t\t\tworkParameter.width = parameters[i].width;\n\t\t\t\t\tif (workParameter.precision == NO_PRECISION)\n\t\t\t\t\t\tworkParameter.precision = parameters[i].precision;\n\t\t\t\t\tif (workParameter.base == NO_BASE)\n\t\t\t\t\t\tworkParameter.base = parameters[i].base;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\n\t\tif (workParameter.base == NO_BASE)\n\t\t\tworkParameter.base = BASE_DECIMAL;\n\n\t\toffset = workParameter.endOffset;\n\n\t\tTrioCopyParameter(&parameters[pos++], &workParameter);\n\t} /* while format characters left */\n\n\tparameters[pos].type = FORMAT_SENTINEL; /* end parameter array with sentinel */\n\tparameters[pos].beginOffset = offset;\n\n\tfor (num = 0; num <= maxParam; num++)\n\t{\n\t\tif (usedEntries[num] != 1)\n\t\t{\n\t\t\tif (usedEntries[num] == 0) /* gap detected */\n\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EGAP, num);\n\t\t\telse /* double references detected */\n\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EDBLREF, num);\n\t\t}\n\n\t\ti = indices[num];\n\n\t\t/*\n\t\t * FORMAT_PARAMETERS are only present if they must be read,\n\t\t * so it makes no sense to check the ignore flag (besides,\n\t\t * the flags variable is not set for that particular type)\n\t\t */\n\t\tif ((parameters[i].type != FORMAT_PARAMETER) && (parameters[i].flags & FLAGS_IGNORE))\n\t\t\tcontinue; /* for all arguments */\n\n\t\t/*\n\t\t * The stack arguments are read according to ANSI C89\n\t\t * default argument promotions:\n\t\t *\n\t\t *  char           = int\n\t\t *  short          = int\n\t\t *  unsigned char  = unsigned int\n\t\t *  unsigned short = unsigned int\n\t\t *  float          = double\n\t\t *\n\t\t * In addition to the ANSI C89 these types are read (the\n\t\t * default argument promotions of C99 has not been\n\t\t * considered yet)\n\t\t *\n\t\t *  long long\n\t\t *  long double\n\t\t *  size_t\n\t\t *  ptrdiff_t\n\t\t *  intmax_t\n\t\t */\n\t\tswitch (parameters[i].type)\n\t\t{\n\t\t\tcase FORMAT_GROUP:\n\t\t\tcase FORMAT_STRING:\n#if TRIO_FEATURE_WIDECHAR\n\t\t\t\tif (parameters[i].flags & FLAGS_WIDECHAR)\n\t\t\t\t{\n\t\t\t\t\tparameters[i].data.wstring =\n\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t        ? va_arg(arglist, trio_wchar_t*)\n\t\t\t\t\t        : (trio_wchar_t*)(argfunc(argarray, num, TRIO_TYPE_PWCHAR));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tparameters[i].data.string =\n\t\t\t\t\t    (argfunc == NULL) ? va_arg(arglist, char*)\n\t\t\t\t\t                      : (char*)(argfunc(argarray, num, TRIO_TYPE_PCHAR));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n#if TRIO_FEATURE_USER_DEFINED\n\t\t\tcase FORMAT_USER_DEFINED:\n#endif\n\t\t\tcase FORMAT_POINTER:\n\t\t\tcase FORMAT_COUNT:\n\t\t\tcase FORMAT_UNKNOWN:\n\t\t\t\tparameters[i].data.pointer = (argfunc == NULL)\n\t\t\t\t                                 ? va_arg(arglist, trio_pointer_t)\n\t\t\t\t                                 : argfunc(argarray, num, TRIO_TYPE_POINTER);\n\t\t\t\tbreak;\n\n\t\t\tcase FORMAT_CHAR:\n\t\t\tcase FORMAT_INT:\n#if TRIO_FEATURE_SCANF\n\t\t\t\tif (TYPE_SCAN == type)\n\t\t\t\t{\n\t\t\t\t\tif (argfunc == NULL)\n\t\t\t\t\t\tparameters[i].data.pointer =\n\t\t\t\t\t\t    (trio_pointer_t)va_arg(arglist, trio_pointer_t);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (parameters[i].type == FORMAT_CHAR)\n\t\t\t\t\t\t\tparameters[i].data.pointer =\n\t\t\t\t\t\t\t    (trio_pointer_t)((char*)argfunc(argarray, num, TRIO_TYPE_CHAR));\n\t\t\t\t\t\telse if (parameters[i].flags & FLAGS_SHORT)\n\t\t\t\t\t\t\tparameters[i].data.pointer =\n\t\t\t\t\t\t\t    (trio_pointer_t)((short*)argfunc(argarray, num, TRIO_TYPE_SHORT));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tparameters[i].data.pointer =\n\t\t\t\t\t\t\t    (trio_pointer_t)((int*)argfunc(argarray, num, TRIO_TYPE_INT));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n#endif /* TRIO_FEATURE_SCANF */\n\t\t\t\t{\n#if TRIO_FEATURE_VARSIZE || TRIO_FEATURE_FIXED_SIZE\n\t\t\t\t\tif (parameters[i].flags & (FLAGS_VARSIZE_PARAMETER | FLAGS_FIXED_SIZE))\n\t\t\t\t\t{\n\t\t\t\t\t\tint varsize;\n\t\t\t\t\t\tif (parameters[i].flags & FLAGS_VARSIZE_PARAMETER)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Variable sizes are mapped onto the fixed sizes, in\n\t\t\t\t\t\t\t * accordance with integer promotion.\n\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t * Please note that this may not be portable, as we\n\t\t\t\t\t\t\t * only guess the size, not the layout of the numbers.\n\t\t\t\t\t\t\t * For example, if int is little-endian, and long is\n\t\t\t\t\t\t\t * big-endian, then this will fail.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tvarsize =\n\t\t\t\t\t\t\t    (int)parameters[parameters[i].varsize].data.number.as_unsigned;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Used for the I<bits> modifiers */\n\t\t\t\t\t\t\tvarsize = parameters[i].varsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparameters[i].flags &= ~FLAGS_ALL_VARSIZES;\n\n\t\t\t\t\t\tif (varsize <= (int)sizeof(int))\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\telse if (varsize <= (int)sizeof(long))\n\t\t\t\t\t\t\tparameters[i].flags |= FLAGS_LONG;\n#if TRIO_FEATURE_INTMAX_T\n\t\t\t\t\t\telse if (varsize <= (int)sizeof(trio_longlong_t))\n\t\t\t\t\t\t\tparameters[i].flags |= FLAGS_QUAD;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tparameters[i].flags |= FLAGS_INTMAX_T;\n#else\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tparameters[i].flags |= FLAGS_QUAD;\n#endif\n\t\t\t\t\t}\n#endif /* TRIO_FEATURE_VARSIZE */\n#if TRIO_FEATURE_SIZE_T || TRIO_FEATURE_SIZE_T_UPPER\n\t\t\t\t\tif (parameters[i].flags & FLAGS_SIZE_T)\n\t\t\t\t\t\tparameters[i].data.number.as_unsigned =\n\t\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t\t        ? (trio_uintmax_t)va_arg(arglist, size_t)\n\t\t\t\t\t\t        : (trio_uintmax_t)(\n\t\t\t\t\t\t              *((size_t*)argfunc(argarray, num, TRIO_TYPE_SIZE)));\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_PTRDIFF_T\n\t\t\t\t\t    if (parameters[i].flags & FLAGS_PTRDIFF_T)\n\t\t\t\t\t\tparameters[i].data.number.as_unsigned =\n\t\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t\t        ? (trio_uintmax_t)va_arg(arglist, ptrdiff_t)\n\t\t\t\t\t\t        : (trio_uintmax_t)(\n\t\t\t\t\t\t              *((ptrdiff_t*)argfunc(argarray, num, TRIO_TYPE_PTRDIFF)));\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_INTMAX_T\n\t\t\t\t\t    if (parameters[i].flags & FLAGS_INTMAX_T)\n\t\t\t\t\t\tparameters[i].data.number.as_unsigned =\n\t\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t\t        ? (trio_uintmax_t)va_arg(arglist, trio_intmax_t)\n\t\t\t\t\t\t        : (trio_uintmax_t)(\n\t\t\t\t\t\t              *((trio_intmax_t*)argfunc(argarray, num, TRIO_TYPE_UINTMAX)));\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t    if (parameters[i].flags & FLAGS_QUAD)\n\t\t\t\t\t\tparameters[i].data.number.as_unsigned =\n\t\t\t\t\t\t    (argfunc == NULL) ? (trio_uintmax_t)va_arg(arglist, trio_ulonglong_t)\n\t\t\t\t\t\t                      : (trio_uintmax_t)(*((trio_ulonglong_t*)argfunc(\n\t\t\t\t\t\t                            argarray, num, TRIO_TYPE_ULONGLONG)));\n\t\t\t\t\telse if (parameters[i].flags & FLAGS_LONG)\n\t\t\t\t\t\tparameters[i].data.number.as_unsigned =\n\t\t\t\t\t\t    (argfunc == NULL) ? (trio_uintmax_t)va_arg(arglist, long)\n\t\t\t\t\t\t                      : (trio_uintmax_t)(*(\n\t\t\t\t\t\t                            (long*)argfunc(argarray, num, TRIO_TYPE_LONG)));\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (argfunc == NULL)\n\t\t\t\t\t\t\tparameters[i].data.number.as_unsigned =\n\t\t\t\t\t\t\t    (trio_uintmax_t)va_arg(arglist, int);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (parameters[i].type == FORMAT_CHAR)\n\t\t\t\t\t\t\t\tparameters[i].data.number.as_unsigned = (trio_uintmax_t)(\n\t\t\t\t\t\t\t\t    *((char*)argfunc(argarray, num, TRIO_TYPE_CHAR)));\n\t\t\t\t\t\t\telse if (parameters[i].flags & FLAGS_SHORT)\n\t\t\t\t\t\t\t\tparameters[i].data.number.as_unsigned = (trio_uintmax_t)(\n\t\t\t\t\t\t\t\t    *((short*)argfunc(argarray, num, TRIO_TYPE_SHORT)));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tparameters[i].data.number.as_unsigned = (trio_uintmax_t)(\n\t\t\t\t\t\t\t\t    *((int*)argfunc(argarray, num, TRIO_TYPE_INT)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase FORMAT_PARAMETER:\n\t\t\t\t/*\n\t\t\t\t * The parameter for the user-defined specifier is a pointer,\n\t\t\t\t * whereas the rest (width, precision, base) uses an integer.\n\t\t\t\t */\n\t\t\t\tif (parameters[i].flags & FLAGS_USER_DEFINED)\n\t\t\t\t\tparameters[i].data.pointer = (argfunc == NULL)\n\t\t\t\t\t                                 ? va_arg(arglist, trio_pointer_t)\n\t\t\t\t\t                                 : argfunc(argarray, num, TRIO_TYPE_POINTER);\n\t\t\t\telse\n\t\t\t\t\tparameters[i].data.number.as_unsigned =\n\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t        ? (trio_uintmax_t)va_arg(arglist, int)\n\t\t\t\t\t        : (trio_uintmax_t)(*((int*)argfunc(argarray, num, TRIO_TYPE_INT)));\n\t\t\t\tbreak;\n\n#if TRIO_FEATURE_FLOAT\n\t\t\tcase FORMAT_DOUBLE:\n#if TRIO_FEATURE_SCANF\n\t\t\t\tif (TYPE_SCAN == type)\n\t\t\t\t{\n\t\t\t\t\tif (parameters[i].flags & FLAGS_LONGDOUBLE)\n\t\t\t\t\t\tparameters[i].data.longdoublePointer =\n\t\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t\t        ? va_arg(arglist, trio_long_double_t*)\n\t\t\t\t\t\t        : (trio_long_double_t*)argfunc(argarray, num, TRIO_TYPE_LONGDOUBLE);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (parameters[i].flags & FLAGS_LONG)\n\t\t\t\t\t\t\tparameters[i].data.doublePointer =\n\t\t\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t\t\t        ? va_arg(arglist, double*)\n\t\t\t\t\t\t\t        : (double*)argfunc(argarray, num, TRIO_TYPE_DOUBLE);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tparameters[i].data.doublePointer =\n\t\t\t\t\t\t\t    (argfunc == NULL)\n\t\t\t\t\t\t\t        ? (double*)va_arg(arglist, float*)\n\t\t\t\t\t\t\t        : (double*)argfunc(argarray, num, TRIO_TYPE_DOUBLE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n#endif /* TRIO_FEATURE_SCANF */\n\t\t\t\t{\n\t\t\t\t\tif (parameters[i].flags & FLAGS_LONGDOUBLE)\n\t\t\t\t\t\tparameters[i].data.longdoubleNumber =\n\t\t\t\t\t\t    (argfunc == NULL) ? va_arg(arglist, trio_long_double_t)\n\t\t\t\t\t\t                      : (trio_long_double_t)(*((trio_long_double_t*)argfunc(\n\t\t\t\t\t\t                            argarray, num, TRIO_TYPE_LONGDOUBLE)));\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (argfunc == NULL)\n\t\t\t\t\t\t\tparameters[i].data.longdoubleNumber =\n\t\t\t\t\t\t\t    (trio_long_double_t)va_arg(arglist, double);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (parameters[i].flags & FLAGS_SHORT)\n\t\t\t\t\t\t\t\tparameters[i].data.longdoubleNumber = (trio_long_double_t)(\n\t\t\t\t\t\t\t\t    *((float*)argfunc(argarray, num, TRIO_TYPE_FLOAT)));\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tparameters[i].data.longdoubleNumber = (trio_long_double_t)(\n\t\t\t\t\t\t\t\t    *((double*)argfunc(argarray, num, TRIO_TYPE_DOUBLE)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif /* TRIO_FEATURE_FLOAT */\n\n#if TRIO_FEATURE_ERRNO\n\t\t\tcase FORMAT_ERRNO:\n\t\t\t\tparameters[i].data.errorNumber = save_errno;\n\t\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t} /* for all specifiers */\n\treturn num;\n}\n\n/*************************************************************************\n *\n * FORMATTING\n *\n ************************************************************************/\n\n/*************************************************************************\n * TrioWriteNumber\n *\n * Description:\n *  Output a number.\n *  The complexity of this function is a result of the complexity\n *  of the dependencies of the flags.\n */\nTRIO_PRIVATE void TrioWriteNumber TRIO_ARGS6((self, number, flags, width, precision, base),\n                                             trio_class_t* self, trio_uintmax_t number,\n                                             trio_flags_t flags, int width, int precision, int base)\n{\n\tBOOLEAN_T isNegative;\n\tBOOLEAN_T isNumberZero;\n\tBOOLEAN_T isPrecisionZero;\n\tBOOLEAN_T ignoreNumber;\n\tchar buffer[MAX_CHARS_IN(trio_uintmax_t) * (1 + MAX_LOCALE_SEPARATOR_LENGTH) + 1];\n\tchar* bufferend;\n\tchar* pointer;\n\tTRIO_CONST char* digits;\n\tint i;\n#if TRIO_FEATURE_QUOTE\n\tint length;\n\tchar* p;\n#endif\n\tint count;\n\tint digitOffset;\n\n\tassert(VALID(self));\n\tassert(VALID(self->OutStream));\n\tassert(((base >= MIN_BASE) && (base <= MAX_BASE)) || (base == NO_BASE));\n\n\tdigits = (flags & FLAGS_UPPER) ? internalDigitsUpper : internalDigitsLower;\n\tif (base == NO_BASE)\n\t\tbase = BASE_DECIMAL;\n\n\tisNumberZero = (number == 0);\n\tisPrecisionZero = (precision == 0);\n\tignoreNumber =\n\t    (isNumberZero && isPrecisionZero && !((flags & FLAGS_ALTERNATIVE) && (base == BASE_OCTAL)));\n\n\tif (flags & FLAGS_UNSIGNED)\n\t{\n\t\tisNegative = FALSE;\n\t\tflags &= ~FLAGS_SHOWSIGN;\n\t}\n\telse\n\t{\n\t\tisNegative = ((trio_intmax_t)number < 0);\n\t\tif (isNegative)\n\t\t\tnumber = -((trio_intmax_t)number);\n\t}\n\n\tif (flags & FLAGS_QUAD)\n\t\tnumber &= (trio_ulonglong_t)-1;\n\telse if (flags & FLAGS_LONG)\n\t\tnumber &= (unsigned long)-1;\n\telse\n\t\tnumber &= (unsigned int)-1;\n\n\t/* Build number */\n\tpointer = bufferend = &buffer[sizeof(buffer) - 1];\n\t*pointer-- = NIL;\n\tfor (i = 1; i < (int)sizeof(buffer); i++)\n\t{\n\t\tdigitOffset = number % base;\n\t\t*pointer-- = digits[digitOffset];\n\t\tnumber /= base;\n\t\tif (number == 0)\n\t\t\tbreak;\n\n#if TRIO_FEATURE_QUOTE\n\t\tif ((flags & FLAGS_QUOTE) && TrioFollowedBySeparator(i + 1))\n\t\t{\n\t\t\t/*\n\t\t\t * We are building the number from the least significant\n\t\t\t * to the most significant digit, so we have to copy the\n\t\t\t * thousand separator backwards\n\t\t\t */\n\t\t\tlength = internalThousandSeparatorLength;\n\t\t\tif (((int)(pointer - buffer) - length) > 0)\n\t\t\t{\n\t\t\t\tp = &internalThousandSeparator[length - 1];\n\t\t\t\twhile (length-- > 0)\n\t\t\t\t\t*pointer-- = *p--;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tif (!ignoreNumber)\n\t{\n\t\t/* Adjust width */\n\t\twidth -= (bufferend - pointer) - 1;\n\t}\n\n\t/* Adjust precision */\n\tif (NO_PRECISION != precision)\n\t{\n\t\tprecision -= (bufferend - pointer) - 1;\n\t\tif (precision < 0)\n\t\t\tprecision = 0;\n\t\tflags |= FLAGS_NILPADDING;\n\t}\n\n\t/* Calculate padding */\n\tcount = (!((flags & FLAGS_LEFTADJUST) || (precision == NO_PRECISION))) ? precision : 0;\n\n\t/* Adjust width further */\n\tif (isNegative || (flags & FLAGS_SHOWSIGN) || (flags & FLAGS_SPACE))\n\t\twidth--;\n\tif ((flags & FLAGS_ALTERNATIVE) && !isNumberZero)\n\t{\n\t\tswitch (base)\n\t\t{\n\t\t\tcase BASE_BINARY:\n\t\t\tcase BASE_HEX:\n\t\t\t\twidth -= 2;\n\t\t\t\tbreak;\n\t\t\tcase BASE_OCTAL:\n\t\t\t\tif (!(flags & FLAGS_NILPADDING) || (count == 0))\n\t\t\t\t\twidth--;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Output prefixes spaces if needed */\n\tif (!((flags & FLAGS_LEFTADJUST) ||\n\t      ((flags & FLAGS_NILPADDING) && (precision == NO_PRECISION))))\n\t{\n\t\twhile (width-- > count)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n\n\t/* width has been adjusted for signs and alternatives */\n\tif (isNegative)\n\t\tself->OutStream(self, '-');\n\telse if (flags & FLAGS_SHOWSIGN)\n\t\tself->OutStream(self, '+');\n\telse if (flags & FLAGS_SPACE)\n\t\tself->OutStream(self, ' ');\n\n\t/* Prefix is not written when the value is zero */\n\tif ((flags & FLAGS_ALTERNATIVE) && !isNumberZero)\n\t{\n\t\tswitch (base)\n\t\t{\n\t\t\tcase BASE_BINARY:\n\t\t\t\tself->OutStream(self, '0');\n\t\t\t\tself->OutStream(self, (flags & FLAGS_UPPER) ? 'B' : 'b');\n\t\t\t\tbreak;\n\n\t\t\tcase BASE_OCTAL:\n\t\t\t\tif (!(flags & FLAGS_NILPADDING) || (count == 0))\n\t\t\t\t\tself->OutStream(self, '0');\n\t\t\t\tbreak;\n\n\t\t\tcase BASE_HEX:\n\t\t\t\tself->OutStream(self, '0');\n\t\t\t\tself->OutStream(self, (flags & FLAGS_UPPER) ? 'X' : 'x');\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t} /* switch base */\n\t}\n\n\t/* Output prefixed zero padding if needed */\n\tif (flags & FLAGS_NILPADDING)\n\t{\n\t\tif (precision == NO_PRECISION)\n\t\t\tprecision = width;\n\t\twhile (precision-- > 0)\n\t\t{\n\t\t\tself->OutStream(self, '0');\n\t\t\twidth--;\n\t\t}\n\t}\n\n\tif (!ignoreNumber)\n\t{\n\t\t/* Output the number itself */\n\t\twhile (*(++pointer))\n\t\t{\n\t\t\tself->OutStream(self, *pointer);\n\t\t}\n\t}\n\n\t/* Output trailing spaces if needed */\n\tif (flags & FLAGS_LEFTADJUST)\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n}\n\n/*************************************************************************\n * TrioWriteStringCharacter\n *\n * Description:\n *  Output a single character of a string\n */\nTRIO_PRIVATE void TrioWriteStringCharacter TRIO_ARGS3((self, ch, flags), trio_class_t* self, int ch,\n                                                      trio_flags_t flags)\n{\n\tif (flags & FLAGS_ALTERNATIVE)\n\t{\n\t\tif (!isprint(ch))\n\t\t{\n\t\t\t/*\n\t\t\t * Non-printable characters are converted to C escapes or\n\t\t\t * \\number, if no C escape exists.\n\t\t\t */\n\t\t\tself->OutStream(self, CHAR_BACKSLASH);\n\t\t\tswitch (ch)\n\t\t\t{\n\t\t\t\tcase '\\007':\n\t\t\t\t\tself->OutStream(self, 'a');\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\b':\n\t\t\t\t\tself->OutStream(self, 'b');\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\f':\n\t\t\t\t\tself->OutStream(self, 'f');\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\n':\n\t\t\t\t\tself->OutStream(self, 'n');\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\r':\n\t\t\t\t\tself->OutStream(self, 'r');\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\t':\n\t\t\t\t\tself->OutStream(self, 't');\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\v':\n\t\t\t\t\tself->OutStream(self, 'v');\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tself->OutStream(self, '\\\\');\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tself->OutStream(self, 'x');\n\t\t\t\t\tTrioWriteNumber(self, (trio_uintmax_t)ch, FLAGS_UNSIGNED | FLAGS_NILPADDING, 2,\n\t\t\t\t\t                2, BASE_HEX);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (ch == CHAR_BACKSLASH)\n\t\t{\n\t\t\tself->OutStream(self, CHAR_BACKSLASH);\n\t\t\tself->OutStream(self, CHAR_BACKSLASH);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself->OutStream(self, ch);\n\t\t}\n\t}\n\telse\n\t{\n\t\tself->OutStream(self, ch);\n\t}\n}\n\n/*************************************************************************\n * TrioWriteString\n *\n * Description:\n *  Output a string\n */\nTRIO_PRIVATE void TrioWriteString TRIO_ARGS5((self, string, flags, width, precision),\n                                             trio_class_t* self, TRIO_CONST char* string,\n                                             trio_flags_t flags, int width, int precision)\n{\n\tint length = 0;\n\tint ch;\n\n\tassert(VALID(self));\n\tassert(VALID(self->OutStream));\n\n\tif (string == NULL)\n\t{\n\t\tstring = internalNullString;\n\t\tlength = sizeof(internalNullString) - 1;\n#if TRIO_FEATURE_QUOTE\n\t\t/* Disable quoting for the null pointer */\n\t\tflags &= (~FLAGS_QUOTE);\n#endif\n\t\twidth = 0;\n\t}\n\telse\n\t{\n\t\tif (precision <= 0)\n\t\t{\n\t\t\tlength = trio_length(string);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlength = trio_length_max(string, precision);\n\t\t}\n\t}\n\tif ((NO_PRECISION != precision) && (precision < length))\n\t{\n\t\tlength = precision;\n\t}\n\twidth -= length;\n\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n\n\tif (!(flags & FLAGS_LEFTADJUST))\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n\n\twhile (length-- > 0)\n\t{\n\t\t/* The ctype parameters must be an unsigned char (or EOF) */\n\t\tch = (int)((unsigned char)(*string++));\n\t\tTrioWriteStringCharacter(self, ch, flags);\n\t}\n\n\tif (flags & FLAGS_LEFTADJUST)\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n}\n\n/*************************************************************************\n * TrioWriteWideStringCharacter\n *\n * Description:\n *  Output a wide string as a multi-byte sequence\n */\n#if TRIO_FEATURE_WIDECHAR\nTRIO_PRIVATE int TrioWriteWideStringCharacter TRIO_ARGS4((self, wch, flags, width),\n                                                         trio_class_t* self, trio_wchar_t wch,\n                                                         trio_flags_t flags, int width)\n{\n\tint size;\n\tint i;\n\tint ch;\n\tchar* string;\n\tchar buffer[MB_LEN_MAX + 1];\n\n\tif (width == NO_WIDTH)\n\t\twidth = sizeof(buffer);\n\n\tsize = wctomb(buffer, wch);\n\tif ((size <= 0) || (size > width) || (buffer[0] == NIL))\n\t\treturn 0;\n\n\tstring = buffer;\n\ti = size;\n\twhile ((width >= i) && (width-- > 0) && (i-- > 0))\n\t{\n\t\t/* The ctype parameters must be an unsigned char (or EOF) */\n\t\tch = (int)((unsigned char)(*string++));\n\t\tTrioWriteStringCharacter(self, ch, flags);\n\t}\n\treturn size;\n}\n#endif /* TRIO_FEATURE_WIDECHAR */\n\n/*************************************************************************\n * TrioWriteWideString\n *\n * Description:\n *  Output a wide character string as a multi-byte string\n */\n#if TRIO_FEATURE_WIDECHAR\nTRIO_PRIVATE void TrioWriteWideString TRIO_ARGS5((self, wstring, flags, width, precision),\n                                                 trio_class_t* self,\n                                                 TRIO_CONST trio_wchar_t* wstring,\n                                                 trio_flags_t flags, int width, int precision)\n{\n\tint length;\n\tint size;\n\n\tassert(VALID(self));\n\tassert(VALID(self->OutStream));\n\n#if defined(TRIO_COMPILER_SUPPORTS_MULTIBYTE)\n\t/* Required by TrioWriteWideStringCharacter */\n\t(void)mblen(NULL, 0);\n#endif\n\n\tif (wstring == NULL)\n\t{\n\t\tTrioWriteString(self, NULL, flags, width, precision);\n\t\treturn;\n\t}\n\n\tif (NO_PRECISION == precision)\n\t{\n\t\tlength = INT_MAX;\n\t}\n\telse\n\t{\n\t\tlength = precision;\n\t\twidth -= length;\n\t}\n\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n\n\tif (!(flags & FLAGS_LEFTADJUST))\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n\n\twhile (length > 0)\n\t{\n\t\tsize = TrioWriteWideStringCharacter(self, *wstring++, flags, length);\n\t\tif (size == 0)\n\t\t\tbreak; /* while */\n\t\tlength -= size;\n\t}\n\n\tif (flags & FLAGS_LEFTADJUST)\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n}\n#endif /* TRIO_FEATURE_WIDECHAR */\n\n/*************************************************************************\n * TrioWriteDouble\n *\n * http://wwwold.dkuug.dk/JTC1/SC22/WG14/www/docs/dr_211.htm\n *\n * \"5.2.4.2.2 paragraph #4\n *\n *  The accuracy [...] is implementation defined, as is the accuracy\n *  of the conversion between floating-point internal representations\n *  and string representations performed by the libray routine in\n *  <stdio.h>\"\n */\n/* FIXME: handle all instances of constant long-double number (L)\n *   and *l() math functions.\n */\n#if TRIO_FEATURE_FLOAT\nTRIO_PRIVATE void TrioWriteDouble TRIO_ARGS6((self, number, flags, width, precision, base),\n                                             trio_class_t* self, trio_long_double_t number,\n                                             trio_flags_t flags, int width, int precision, int base)\n{\n\ttrio_long_double_t integerNumber;\n\ttrio_long_double_t fractionNumber;\n\ttrio_long_double_t workNumber;\n\tint integerDigits;\n\tint fractionDigits;\n\tint exponentDigits;\n\tint workDigits;\n\tint baseDigits;\n\tint integerThreshold;\n\tint fractionThreshold;\n\tint expectedWidth;\n\tint exponent = 0;\n\tunsigned int uExponent = 0;\n\tint exponentBase;\n\ttrio_long_double_t dblBase;\n\ttrio_long_double_t dblFractionBase;\n\ttrio_long_double_t integerAdjust;\n\ttrio_long_double_t fractionAdjust;\n\ttrio_long_double_t workFractionNumber;\n\ttrio_long_double_t workFractionAdjust;\n\tint fractionDigitsInspect;\n\tBOOLEAN_T isNegative;\n\tBOOLEAN_T isExponentNegative = FALSE;\n\tBOOLEAN_T requireTwoDigitExponent;\n\tBOOLEAN_T isHex;\n\tTRIO_CONST char* digits;\n#if TRIO_FEATURE_QUOTE\n\tchar* groupingPointer;\n#endif\n\tint i;\n\tint offset;\n\tBOOLEAN_T hasOnlyZeroes;\n\tint leadingFractionZeroes = -1;\n\tregister int trailingZeroes;\n\tBOOLEAN_T keepTrailingZeroes;\n\tBOOLEAN_T keepDecimalPoint;\n\ttrio_long_double_t epsilon;\n\tBOOLEAN_T adjustNumber = FALSE;\n\n\tassert(VALID(self));\n\tassert(VALID(self->OutStream));\n\tassert(((base >= MIN_BASE) && (base <= MAX_BASE)) || (base == NO_BASE));\n\n\t/* Determine sign and look for special quantities */\n\tswitch (trio_fpclassify_and_signbit(number, &isNegative))\n\t{\n\t\tcase TRIO_FP_NAN:\n\t\t\tTrioWriteString(self, (flags & FLAGS_UPPER) ? NAN_UPPER : NAN_LOWER, flags, width,\n\t\t\t                precision);\n\t\t\treturn;\n\n\t\tcase TRIO_FP_INFINITE:\n\t\t\tif (isNegative)\n\t\t\t{\n\t\t\t\t/* Negative infinity */\n\t\t\t\tTrioWriteString(self,\n\t\t\t\t                (flags & FLAGS_UPPER) ? \"-\" INFINITE_UPPER : \"-\" INFINITE_LOWER,\n\t\t\t\t                flags, width, precision);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Positive infinity */\n\t\t\t\tTrioWriteString(self, (flags & FLAGS_UPPER) ? INFINITE_UPPER : INFINITE_LOWER,\n\t\t\t\t                flags, width, precision);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/* Finitude */\n\t\t\tbreak;\n\t}\n\n\t/* Normal numbers */\n\tif (flags & FLAGS_LONGDOUBLE)\n\t{\n\t\tbaseDigits =\n\t\t    (base == 10) ? LDBL_DIG : (int)trio_floor(LDBL_MANT_DIG / TrioLogarithmBase(base));\n\t\tepsilon = LDBL_EPSILON;\n\t}\n\telse if (flags & FLAGS_SHORT)\n\t{\n\t\tbaseDigits = (base == BASE_DECIMAL)\n\t\t                 ? FLT_DIG\n\t\t                 : (int)trio_floor(FLT_MANT_DIG / TrioLogarithmBase(base));\n\t\tepsilon = FLT_EPSILON;\n\t}\n\telse\n\t{\n\t\tbaseDigits = (base == BASE_DECIMAL)\n\t\t                 ? DBL_DIG\n\t\t                 : (int)trio_floor(DBL_MANT_DIG / TrioLogarithmBase(base));\n\t\tepsilon = DBL_EPSILON;\n\t}\n\n\tdigits = (flags & FLAGS_UPPER) ? internalDigitsUpper : internalDigitsLower;\n\tisHex = (base == BASE_HEX);\n\tif (base == NO_BASE)\n\t\tbase = BASE_DECIMAL;\n\tdblBase = (trio_long_double_t)base;\n\tkeepTrailingZeroes =\n\t    !((flags & FLAGS_ROUNDING) || ((flags & FLAGS_FLOAT_G) && !(flags & FLAGS_ALTERNATIVE)));\n\n#if TRIO_FEATURE_ROUNDING\n\tif (flags & FLAGS_ROUNDING)\n\t{\n\t\tprecision = baseDigits;\n\t}\n#endif\n\n\tif (precision == NO_PRECISION)\n\t{\n\t\tif (isHex)\n\t\t{\n\t\t\tkeepTrailingZeroes = FALSE;\n\t\t\tprecision = FLT_MANT_DIG;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprecision = FLT_DIG;\n\t\t}\n\t}\n\n\tif (isNegative)\n\t{\n\t\tnumber = -number;\n\t}\n\n\tif (isHex)\n\t{\n\t\tflags |= FLAGS_FLOAT_E;\n\t}\n\nreprocess:\n\n\tif (flags & FLAGS_FLOAT_G)\n\t{\n\t\tif (precision == 0)\n\t\t\tprecision = 1;\n\n\t\tif ((number < TRIO_SUFFIX_LONG(1.0E-4)) ||\n\t\t    (number >= TrioPower(base, (trio_long_double_t)precision)))\n\t\t{\n\t\t\t/* Use scientific notation */\n\t\t\tflags |= FLAGS_FLOAT_E;\n\t\t}\n\t\telse if (number < 1.0)\n\t\t{\n\t\t\t/*\n\t\t\t * Use normal notation. If the integer part of the number is\n\t\t\t * zero, then adjust the precision to include leading fractional\n\t\t\t * zeros.\n\t\t\t */\n\t\t\tworkNumber = TrioLogarithm(number, base);\n\t\t\tworkNumber = TRIO_FABS(workNumber);\n\t\t\tif (workNumber - trio_floor(workNumber) < epsilon)\n\t\t\t\tworkNumber--;\n\t\t\tleadingFractionZeroes = (int)trio_floor(workNumber);\n\t\t}\n\t}\n\n\tif (flags & FLAGS_FLOAT_E)\n\t{\n\t\t/* Scale the number */\n\t\tworkNumber = TrioLogarithm(number, base);\n\t\tif (trio_isinf(workNumber) == -1)\n\t\t{\n\t\t\texponent = 0;\n\t\t\t/* Undo setting */\n\t\t\tif (flags & FLAGS_FLOAT_G)\n\t\t\t\tflags &= ~FLAGS_FLOAT_E;\n\t\t}\n\t\telse\n\t\t{\n\t\t\texponent = (int)trio_floor(workNumber);\n\t\t\tworkNumber = number;\n\t\t\t/*\n\t\t\t * The expression A * 10^-B is equivalent to A / 10^B but the former\n\t\t\t * usually gives better accuracy.\n\t\t\t */\n\t\t\tworkNumber *= TrioPower(dblBase, (trio_long_double_t)-exponent);\n\t\t\tif (trio_isinf(workNumber))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scaling is done it two steps to avoid problems with subnormal\n\t\t\t\t * numbers.\n\t\t\t\t */\n\t\t\t\tworkNumber /= TrioPower(dblBase, (trio_long_double_t)(exponent / 2));\n\t\t\t\tworkNumber /= TrioPower(dblBase, (trio_long_double_t)(exponent - (exponent / 2)));\n\t\t\t}\n\t\t\tnumber = workNumber;\n\t\t\tisExponentNegative = (exponent < 0);\n\t\t\tuExponent = (isExponentNegative) ? -exponent : exponent;\n\t\t\tif (isHex)\n\t\t\t\tuExponent *= 4; /* log16(2) */\n#if TRIO_FEATURE_QUOTE\n\t\t\t/* No thousand separators */\n\t\t\tflags &= ~FLAGS_QUOTE;\n#endif\n\t\t}\n\t}\n\n\tintegerNumber = trio_floor(number);\n\tfractionNumber = number - integerNumber;\n\n\t/*\n\t * Truncated number.\n\t *\n\t * Precision is number of significant digits for FLOAT_G and number of\n\t * fractional digits for others.\n\t */\n\tintegerDigits = 1;\n\tif (integerNumber > epsilon)\n\t{\n\t\tintegerDigits += (int)TrioLogarithm(integerNumber, base);\n\t}\n\n\tfractionDigits = precision;\n\tif (flags & FLAGS_FLOAT_G)\n\t{\n\t\tif (leadingFractionZeroes > 0)\n\t\t{\n\t\t\tfractionDigits += leadingFractionZeroes;\n\t\t}\n\t\tif ((integerNumber > epsilon) || (number <= epsilon))\n\t\t{\n\t\t\tfractionDigits -= integerDigits;\n\t\t}\n\t}\n\n\tdblFractionBase = TrioPower(base, fractionDigits);\n\n\tif (integerNumber < 1.0)\n\t{\n\t\tworkNumber = number * dblFractionBase + TRIO_SUFFIX_LONG(0.5);\n\t\tif (trio_floor(number * dblFractionBase) != trio_floor(workNumber))\n\t\t{\n\t\t\tadjustNumber = TRUE;\n\t\t\t/* Remove a leading fraction zero if fraction is rounded up */\n\t\t\tif ((int)TrioLogarithm(number * dblFractionBase, base) !=\n\t\t\t    (int)TrioLogarithm(workNumber, base))\n\t\t\t{\n\t\t\t\t--leadingFractionZeroes;\n\t\t\t}\n\t\t}\n\t\tworkNumber /= dblFractionBase;\n\t}\n\telse\n\t{\n\t\tworkNumber = number + TRIO_SUFFIX_LONG(0.5) / dblFractionBase;\n\t\tadjustNumber = (trio_floor(number) != trio_floor(workNumber));\n\t}\n\tif (adjustNumber)\n\t{\n\t\tif ((flags & FLAGS_FLOAT_G) && !(flags & FLAGS_FLOAT_E))\n\t\t{\n\t\t\t/* The adjustment may require a change to scientific notation */\n\t\t\tif ((workNumber < TRIO_SUFFIX_LONG(1.0E-4)) ||\n\t\t\t    (workNumber >= TrioPower(base, (trio_long_double_t)precision)))\n\t\t\t{\n\t\t\t\t/* Use scientific notation */\n\t\t\t\tflags |= FLAGS_FLOAT_E;\n\t\t\t\tgoto reprocess;\n\t\t\t}\n\t\t}\n\n\t\tif (flags & FLAGS_FLOAT_E)\n\t\t{\n\t\t\tworkDigits = 1 + TrioLogarithm(trio_floor(workNumber), base);\n\t\t\tif (integerDigits == workDigits)\n\t\t\t{\n\t\t\t\t/* Adjust if the same number of digits are used */\n\t\t\t\tnumber += TRIO_SUFFIX_LONG(0.5) / dblFractionBase;\n\t\t\t\tintegerNumber = trio_floor(number);\n\t\t\t\tfractionNumber = number - integerNumber;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Adjust if number was rounded up one digit (ie. 0.99 to 1.00) */\n\t\t\t\texponent++;\n\t\t\t\tisExponentNegative = (exponent < 0);\n\t\t\t\tuExponent = (isExponentNegative) ? -exponent : exponent;\n\t\t\t\tif (isHex)\n\t\t\t\t\tuExponent *= 4; /* log16(2) */\n\t\t\t\tworkNumber = (number + TRIO_SUFFIX_LONG(0.5) / dblFractionBase) / dblBase;\n\t\t\t\tintegerNumber = trio_floor(workNumber);\n\t\t\t\tfractionNumber = workNumber - integerNumber;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (workNumber > 1.0)\n\t\t\t{\n\t\t\t\t/* Adjust if number was rounded up one digit (ie. 99 to 100) */\n\t\t\t\tintegerNumber = trio_floor(workNumber);\n\t\t\t\tfractionNumber = 0.0;\n\t\t\t\tintegerDigits =\n\t\t\t\t    (integerNumber > epsilon) ? 1 + (int)TrioLogarithm(integerNumber, base) : 1;\n\t\t\t\tif (flags & FLAGS_FLOAT_G)\n\t\t\t\t{\n\t\t\t\t\tif (flags & FLAGS_ALTERNATIVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tfractionDigits = precision;\n\t\t\t\t\t\tif ((integerNumber > epsilon) || (number <= epsilon))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfractionDigits -= integerDigits;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfractionDigits = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tintegerNumber = trio_floor(workNumber);\n\t\t\t\tfractionNumber = workNumber - integerNumber;\n\t\t\t\tif (flags & FLAGS_FLOAT_G)\n\t\t\t\t{\n\t\t\t\t\tif (flags & FLAGS_ALTERNATIVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tfractionDigits = precision;\n\t\t\t\t\t\tif (leadingFractionZeroes > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfractionDigits += leadingFractionZeroes;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((integerNumber > epsilon) || (number <= epsilon))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfractionDigits -= integerDigits;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Estimate accuracy */\n\tintegerAdjust = fractionAdjust = TRIO_SUFFIX_LONG(0.5);\n#if TRIO_FEATURE_ROUNDING\n\tif (flags & FLAGS_ROUNDING)\n\t{\n\t\tif (integerDigits > baseDigits)\n\t\t{\n\t\t\tintegerThreshold = baseDigits;\n\t\t\tfractionDigits = 0;\n\t\t\tdblFractionBase = 1.0;\n\t\t\tfractionThreshold = 0;\n\t\t\tprecision = 0; /* Disable decimal-point */\n\t\t\tintegerAdjust = TrioPower(base, integerDigits - integerThreshold - 1);\n\t\t\tfractionAdjust = 0.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tintegerThreshold = integerDigits;\n\t\t\tfractionThreshold = fractionDigits - integerThreshold;\n\t\t\tfractionAdjust = 1.0;\n\t\t}\n\t}\n\telse\n#endif\n\t{\n\t\tintegerThreshold = INT_MAX;\n\t\tfractionThreshold = INT_MAX;\n\t}\n\n\t/*\n\t * Calculate expected width.\n\t *  sign + integer part + thousands separators + decimal point\n\t *  + fraction + exponent\n\t */\n\tfractionAdjust /= dblFractionBase;\n\thasOnlyZeroes = (trio_floor((fractionNumber + fractionAdjust) * dblFractionBase) < epsilon);\n\tkeepDecimalPoint = ((flags & FLAGS_ALTERNATIVE) ||\n\t                    !((precision == 0) || (!keepTrailingZeroes && hasOnlyZeroes)));\n\n\texpectedWidth = integerDigits + fractionDigits;\n\n\tif (!keepTrailingZeroes)\n\t{\n\t\ttrailingZeroes = 0;\n\t\tworkFractionNumber = fractionNumber;\n\t\tworkFractionAdjust = fractionAdjust;\n\t\tfractionDigitsInspect = fractionDigits;\n\n\t\tif (integerDigits > integerThreshold)\n\t\t{\n\t\t\tfractionDigitsInspect = 0;\n\t\t}\n\t\telse if (fractionThreshold <= fractionDigits)\n\t\t{\n\t\t\tfractionDigitsInspect = fractionThreshold + 1;\n\t\t}\n\n\t\ttrailingZeroes = fractionDigits - fractionDigitsInspect;\n\t\tfor (i = 0; i < fractionDigitsInspect; i++)\n\t\t{\n\t\t\tworkFractionNumber *= dblBase;\n\t\t\tworkFractionAdjust *= dblBase;\n\t\t\tworkNumber = trio_floor(workFractionNumber + workFractionAdjust);\n\t\t\tworkFractionNumber -= workNumber;\n\t\t\toffset = (int)trio_fmod(workNumber, dblBase);\n\t\t\tif (offset == 0)\n\t\t\t{\n\t\t\t\ttrailingZeroes++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttrailingZeroes = 0;\n\t\t\t}\n\t\t}\n\t\texpectedWidth -= trailingZeroes;\n\t}\n\n\tif (keepDecimalPoint)\n\t{\n\t\texpectedWidth += internalDecimalPointLength;\n\t}\n\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t{\n\t\texpectedWidth += TrioCalcThousandSeparatorLength(integerDigits);\n\t}\n#endif\n\n\tif (isNegative || (flags & FLAGS_SHOWSIGN) || (flags & FLAGS_SPACE))\n\t{\n\t\texpectedWidth += sizeof(\"-\") - 1;\n\t}\n\n\texponentDigits = 0;\n\tif (flags & FLAGS_FLOAT_E)\n\t{\n\t\texponentDigits =\n\t\t    (uExponent == 0)\n\t\t        ? 1\n\t\t        : (int)trio_ceil(TrioLogarithm((double)(uExponent + 1), (isHex) ? 10 : base));\n\t}\n\trequireTwoDigitExponent = ((base == BASE_DECIMAL) && (exponentDigits == 1));\n\tif (exponentDigits > 0)\n\t{\n\t\texpectedWidth += exponentDigits;\n\t\texpectedWidth += (requireTwoDigitExponent ? sizeof(\"E+0\") - 1 : sizeof(\"E+\") - 1);\n\t}\n\n\tif (isHex)\n\t{\n\t\texpectedWidth += sizeof(\"0X\") - 1;\n\t}\n\n\t/* Output prefixing */\n\tif (flags & FLAGS_NILPADDING)\n\t{\n\t\t/* Leading zeros must be after sign */\n\t\tif (isNegative)\n\t\t\tself->OutStream(self, '-');\n\t\telse if (flags & FLAGS_SHOWSIGN)\n\t\t\tself->OutStream(self, '+');\n\t\telse if (flags & FLAGS_SPACE)\n\t\t\tself->OutStream(self, ' ');\n\t\tif (isHex)\n\t\t{\n\t\t\tself->OutStream(self, '0');\n\t\t\tself->OutStream(self, (flags & FLAGS_UPPER) ? 'X' : 'x');\n\t\t}\n\t\tif (!(flags & FLAGS_LEFTADJUST))\n\t\t{\n\t\t\tfor (i = expectedWidth; i < width; i++)\n\t\t\t{\n\t\t\t\tself->OutStream(self, '0');\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Leading spaces must be before sign */\n\t\tif (!(flags & FLAGS_LEFTADJUST))\n\t\t{\n\t\t\tfor (i = expectedWidth; i < width; i++)\n\t\t\t{\n\t\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t\t\t}\n\t\t}\n\t\tif (isNegative)\n\t\t\tself->OutStream(self, '-');\n\t\telse if (flags & FLAGS_SHOWSIGN)\n\t\t\tself->OutStream(self, '+');\n\t\telse if (flags & FLAGS_SPACE)\n\t\t\tself->OutStream(self, ' ');\n\t\tif (isHex)\n\t\t{\n\t\t\tself->OutStream(self, '0');\n\t\t\tself->OutStream(self, (flags & FLAGS_UPPER) ? 'X' : 'x');\n\t\t}\n\t}\n\n\t/* Output the integer part and thousand separators */\n\tfor (i = 0; i < integerDigits; i++)\n\t{\n\t\tworkNumber =\n\t\t    trio_floor(((integerNumber + integerAdjust) / TrioPower(base, integerDigits - i - 1)));\n\t\tif (i > integerThreshold)\n\t\t{\n\t\t\t/* Beyond accuracy */\n\t\t\tself->OutStream(self, digits[0]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself->OutStream(self, digits[(int)trio_fmod(workNumber, dblBase)]);\n\t\t}\n\n#if TRIO_FEATURE_QUOTE\n\t\tif (((flags & (FLAGS_FLOAT_E | FLAGS_QUOTE)) == FLAGS_QUOTE) &&\n\t\t    TrioFollowedBySeparator(integerDigits - i))\n\t\t{\n\t\t\tfor (groupingPointer = internalThousandSeparator; *groupingPointer != NIL;\n\t\t\t     groupingPointer++)\n\t\t\t{\n\t\t\t\tself->OutStream(self, *groupingPointer);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Insert decimal point and build the fraction part */\n\ttrailingZeroes = 0;\n\n\tif (keepDecimalPoint)\n\t{\n\t\tif (internalDecimalPoint)\n\t\t{\n\t\t\tself->OutStream(self, internalDecimalPoint);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < internalDecimalPointLength; i++)\n\t\t\t{\n\t\t\t\tself->OutStream(self, internalDecimalPointString[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < fractionDigits; i++)\n\t{\n\t\tif ((integerDigits > integerThreshold) || (i > fractionThreshold))\n\t\t{\n\t\t\t/* Beyond accuracy */\n\t\t\ttrailingZeroes++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfractionNumber *= dblBase;\n\t\t\tfractionAdjust *= dblBase;\n\t\t\tworkNumber = trio_floor(fractionNumber + fractionAdjust);\n\t\t\tif (workNumber > fractionNumber)\n\t\t\t{\n\t\t\t\t/* fractionNumber should never become negative */\n\t\t\t\tfractionNumber = 0.0;\n\t\t\t\tfractionAdjust = 0.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfractionNumber -= workNumber;\n\t\t\t}\n\t\t\toffset = (int)trio_fmod(workNumber, dblBase);\n\t\t\tif (offset == 0)\n\t\t\t{\n\t\t\t\ttrailingZeroes++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (trailingZeroes > 0)\n\t\t\t\t{\n\t\t\t\t\t/* Not trailing zeroes after all */\n\t\t\t\t\tself->OutStream(self, digits[0]);\n\t\t\t\t\ttrailingZeroes--;\n\t\t\t\t}\n\t\t\t\tself->OutStream(self, digits[offset]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (keepTrailingZeroes)\n\t{\n\t\twhile (trailingZeroes > 0)\n\t\t{\n\t\t\tself->OutStream(self, digits[0]);\n\t\t\ttrailingZeroes--;\n\t\t}\n\t}\n\n\t/* Output exponent */\n\tif (exponentDigits > 0)\n\t{\n\t\tself->OutStream(self, isHex ? ((flags & FLAGS_UPPER) ? 'P' : 'p')\n\t\t                            : ((flags & FLAGS_UPPER) ? 'E' : 'e'));\n\t\tself->OutStream(self, (isExponentNegative) ? '-' : '+');\n\n\t\t/* The exponent must contain at least two digits */\n\t\tif (requireTwoDigitExponent)\n\t\t\tself->OutStream(self, '0');\n\n\t\tif (isHex)\n\t\t\tbase = 10;\n\t\texponentBase = (int)TrioPower(base, exponentDigits - 1);\n\t\tfor (i = 0; i < exponentDigits; i++)\n\t\t{\n\t\t\tself->OutStream(self, digits[(uExponent / exponentBase) % base]);\n\t\t\texponentBase /= base;\n\t\t}\n\t}\n\t/* Output trailing spaces */\n\tif (flags & FLAGS_LEFTADJUST)\n\t{\n\t\tfor (i = expectedWidth; i < width; i++)\n\t\t{\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t\t}\n\t}\n}\n#endif /* TRIO_FEATURE_FLOAT */\n\n/*************************************************************************\n * TrioFormatProcess\n *\n * Description:\n *  This is the main engine for formatting output\n */\nTRIO_PRIVATE int TrioFormatProcess TRIO_ARGS3((data, format, parameters), trio_class_t* data,\n                                              TRIO_CONST char* format, trio_parameter_t* parameters)\n{\n\tint i;\n#if TRIO_FEATURE_ERRNO\n\tTRIO_CONST char* string;\n#endif\n\ttrio_pointer_t pointer;\n\ttrio_flags_t flags;\n\tint width;\n\tint precision;\n\tint base;\n\tint offset;\n\n\toffset = 0;\n\ti = 0;\n\n\tfor (;;)\n\t{\n\t\t/* Skip the parameter entries */\n\t\twhile (parameters[i].type == FORMAT_PARAMETER)\n\t\t\ti++;\n\n\t\t/* Copy non conversion-specifier part of format string */\n\t\twhile (offset < parameters[i].beginOffset)\n\t\t{\n\t\t\tif (CHAR_IDENTIFIER == format[offset] && CHAR_IDENTIFIER == format[offset + 1])\n\t\t\t{\n\t\t\t\tdata->OutStream(data, CHAR_IDENTIFIER);\n\t\t\t\toffset += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata->OutStream(data, format[offset++]);\n\t\t\t}\n\t\t}\n\n\t\t/* Abort if we reached end of format string */\n\t\tif (parameters[i].type == FORMAT_SENTINEL)\n\t\t\tbreak;\n\n\t\t/* Ouput parameter */\n\t\tflags = parameters[i].flags;\n\n\t\t/* Find width */\n\t\twidth = parameters[i].width;\n\t\tif (flags & FLAGS_WIDTH_PARAMETER)\n\t\t{\n\t\t\t/* Get width from parameter list */\n\t\t\twidth = (int)parameters[width].data.number.as_signed;\n\t\t\tif (width < 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * A negative width is the same as the - flag and\n\t\t\t\t * a positive width.\n\t\t\t\t */\n\t\t\t\tflags |= FLAGS_LEFTADJUST;\n\t\t\t\tflags &= ~FLAGS_NILPADDING;\n\t\t\t\twidth = -width;\n\t\t\t}\n\t\t}\n\n\t\t/* Find precision */\n\t\tif (flags & FLAGS_PRECISION)\n\t\t{\n\t\t\tprecision = parameters[i].precision;\n\t\t\tif (flags & FLAGS_PRECISION_PARAMETER)\n\t\t\t{\n\t\t\t\t/* Get precision from parameter list */\n\t\t\t\tprecision = (int)parameters[precision].data.number.as_signed;\n\t\t\t\tif (precision < 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * A negative precision is the same as no\n\t\t\t\t\t * precision\n\t\t\t\t\t */\n\t\t\t\t\tprecision = NO_PRECISION;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprecision = NO_PRECISION;\n\t\t}\n\n\t\t/* Find base */\n\t\tif (NO_BASE != parameters[i].baseSpecifier)\n\t\t{\n\t\t\t/* Base from specifier has priority */\n\t\t\tbase = parameters[i].baseSpecifier;\n\t\t}\n\t\telse if (flags & FLAGS_BASE_PARAMETER)\n\t\t{\n\t\t\t/* Get base from parameter list */\n\t\t\tbase = parameters[i].base;\n\t\t\tbase = (int)parameters[base].data.number.as_signed;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use base from format string */\n\t\t\tbase = parameters[i].base;\n\t\t}\n\n\t\tswitch (parameters[i].type)\n\t\t{\n\t\t\tcase FORMAT_CHAR:\n#if TRIO_FEATURE_QUOTE\n\t\t\t\tif (flags & FLAGS_QUOTE)\n\t\t\t\t\tdata->OutStream(data, CHAR_QUOTE);\n#endif\n\t\t\t\tif (!(flags & FLAGS_LEFTADJUST))\n\t\t\t\t{\n\t\t\t\t\twhile (--width > 0)\n\t\t\t\t\t\tdata->OutStream(data, CHAR_ADJUST);\n\t\t\t\t}\n#if TRIO_FEATURE_WIDECHAR\n\t\t\t\tif (flags & FLAGS_WIDECHAR)\n\t\t\t\t{\n\t\t\t\t\tTrioWriteWideStringCharacter(\n\t\t\t\t\t    data, (trio_wchar_t)parameters[i].data.number.as_signed, flags, NO_WIDTH);\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tTrioWriteStringCharacter(data, (int)parameters[i].data.number.as_signed, flags);\n\t\t\t\t}\n\n\t\t\t\tif (flags & FLAGS_LEFTADJUST)\n\t\t\t\t{\n\t\t\t\t\twhile (--width > 0)\n\t\t\t\t\t\tdata->OutStream(data, CHAR_ADJUST);\n\t\t\t\t}\n#if TRIO_FEATURE_QUOTE\n\t\t\t\tif (flags & FLAGS_QUOTE)\n\t\t\t\t\tdata->OutStream(data, CHAR_QUOTE);\n#endif\n\n\t\t\t\tbreak; /* FORMAT_CHAR */\n\n\t\t\tcase FORMAT_INT:\n\t\t\t\tTrioWriteNumber(data, parameters[i].data.number.as_unsigned, flags, width,\n\t\t\t\t                precision, base);\n\n\t\t\t\tbreak; /* FORMAT_INT */\n\n#if TRIO_FEATURE_FLOAT\n\t\t\tcase FORMAT_DOUBLE:\n\t\t\t\tTrioWriteDouble(data, parameters[i].data.longdoubleNumber, flags, width, precision,\n\t\t\t\t                base);\n\t\t\t\tbreak; /* FORMAT_DOUBLE */\n#endif\n\n\t\t\tcase FORMAT_STRING:\n#if TRIO_FEATURE_WIDECHAR\n\t\t\t\tif (flags & FLAGS_WIDECHAR)\n\t\t\t\t{\n\t\t\t\t\tTrioWriteWideString(data, parameters[i].data.wstring, flags, width, precision);\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tTrioWriteString(data, parameters[i].data.string, flags, width, precision);\n\t\t\t\t}\n\t\t\t\tbreak; /* FORMAT_STRING */\n\n\t\t\tcase FORMAT_POINTER:\n\t\t\t{\n\t\t\t\ttrio_reference_t reference;\n\n\t\t\t\treference.data = data;\n\t\t\t\treference.parameter = &parameters[i];\n\t\t\t\ttrio_print_pointer(&reference, parameters[i].data.pointer);\n\t\t\t}\n\t\t\tbreak; /* FORMAT_POINTER */\n\n\t\t\tcase FORMAT_COUNT:\n\t\t\t\tpointer = parameters[i].data.pointer;\n\t\t\t\tif (NULL != pointer)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * C99 paragraph 7.19.6.1.8 says \"the number of\n\t\t\t\t\t * characters written to the output stream so far by\n\t\t\t\t\t * this call\", which is data->actually.committed\n\t\t\t\t\t */\n#if TRIO_FEATURE_SIZE_T || TRIO_FEATURE_SIZE_T_UPPER\n\t\t\t\t\tif (flags & FLAGS_SIZE_T)\n\t\t\t\t\t\t*(size_t*)pointer = (size_t)data->actually.committed;\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_PTRDIFF_T\n\t\t\t\t\t    if (flags & FLAGS_PTRDIFF_T)\n\t\t\t\t\t\t*(ptrdiff_t*)pointer = (ptrdiff_t)data->actually.committed;\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_INTMAX_T\n\t\t\t\t\t    if (flags & FLAGS_INTMAX_T)\n\t\t\t\t\t\t*(trio_intmax_t*)pointer = (trio_intmax_t)data->actually.committed;\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t    if (flags & FLAGS_QUAD)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(trio_ulonglong_t*)pointer = (trio_ulonglong_t)data->actually.committed;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flags & FLAGS_LONG)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(long int*)pointer = (long int)data->actually.committed;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flags & FLAGS_SHORT)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(short int*)pointer = (short int)data->actually.committed;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t*(int*)pointer = (int)data->actually.committed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak; /* FORMAT_COUNT */\n\n\t\t\tcase FORMAT_PARAMETER:\n\t\t\t\tbreak; /* FORMAT_PARAMETER */\n\n#if TRIO_FEATURE_ERRNO\n\t\t\tcase FORMAT_ERRNO:\n\t\t\t\tstring = trio_error(parameters[i].data.errorNumber);\n\t\t\t\tif (string)\n\t\t\t\t{\n\t\t\t\t\tTrioWriteString(data, string, flags, width, precision);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdata->OutStream(data, '#');\n\t\t\t\t\tTrioWriteNumber(data, (trio_uintmax_t)parameters[i].data.errorNumber, flags,\n\t\t\t\t\t                width, precision, BASE_DECIMAL);\n\t\t\t\t}\n\t\t\t\tbreak; /* FORMAT_ERRNO */\n#endif                 /* TRIO_FEATURE_ERRNO */\n\n#if TRIO_FEATURE_USER_DEFINED\n\t\t\tcase FORMAT_USER_DEFINED:\n\t\t\t{\n\t\t\t\ttrio_reference_t reference;\n\t\t\t\ttrio_userdef_t* def = NULL;\n\n\t\t\t\tif (parameters[i].flags & FLAGS_USER_DEFINED_PARAMETER)\n\t\t\t\t{\n\t\t\t\t\t/* Use handle */\n\t\t\t\t\tif ((i > 0) || (parameters[i - 1].type == FORMAT_PARAMETER))\n\t\t\t\t\t\tdef = (trio_userdef_t*)parameters[i - 1].data.pointer;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* Look up namespace */\n\t\t\t\t\tdef = TrioFindNamespace(parameters[i].user_defined.namespace, NULL);\n\t\t\t\t}\n\t\t\t\tif (def)\n\t\t\t\t{\n\t\t\t\t\treference.data = data;\n\t\t\t\t\treference.parameter = &parameters[i];\n\t\t\t\t\tdef->callback(&reference);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif /* TRIO_FEATURE_USER_DEFINED */\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t} /* switch parameter type */\n\n\t\t/* Prepare for next */\n\t\toffset = parameters[i].endOffset;\n\t\ti++;\n\t}\n\n\treturn data->processed;\n}\n\n/*************************************************************************\n * TrioFormatRef\n */\n#if TRIO_EXTENSION\nTRIO_PRIVATE int TrioFormatRef TRIO_ARGS5((reference, format, arglist, argfunc, argarray),\n                                          trio_reference_t* reference, TRIO_CONST char* format,\n                                          va_list arglist, trio_argfunc_t argfunc,\n                                          trio_pointer_t* argarray)\n{\n\tint status;\n\ttrio_parameter_t parameters[MAX_PARAMETERS];\n\n\tstatus = TrioParse(TYPE_PRINT, format, parameters, arglist, argfunc, argarray);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = TrioFormatProcess(reference->data, format, parameters);\n\tif (reference->data->error != 0)\n\t{\n\t\tstatus = reference->data->error;\n\t}\n\treturn status;\n}\n#endif /* TRIO_EXTENSION */\n\n/*************************************************************************\n * TrioFormat\n */\nTRIO_PRIVATE int TrioFormat TRIO_ARGS7((destination, destinationSize, OutStream, format, arglist,\n                                        argfunc, argarray),\n                                       trio_pointer_t destination, size_t destinationSize,\n                                       void(*OutStream) TRIO_PROTO((trio_class_t*, int)),\n                                       TRIO_CONST char* format, va_list arglist,\n                                       trio_argfunc_t argfunc, trio_pointer_t* argarray)\n{\n\tint status;\n\ttrio_class_t data;\n\ttrio_parameter_t parameters[MAX_PARAMETERS];\n\n\tassert(VALID(OutStream));\n\tassert(VALID(format));\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.OutStream = OutStream;\n\tdata.location = destination;\n\tdata.max = destinationSize;\n\tdata.error = 0;\n\n#if defined(USE_LOCALE)\n\tif (NULL == internalLocaleValues)\n\t{\n\t\tTrioSetLocale();\n\t}\n#endif\n\n\tstatus = TrioParse(TYPE_PRINT, format, parameters, arglist, argfunc, argarray);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = TrioFormatProcess(&data, format, parameters);\n\tif (data.error != 0)\n\t{\n\t\tstatus = data.error;\n\t}\n\treturn status;\n}\n\n/*************************************************************************\n * TrioOutStreamFile\n */\n#if TRIO_FEATURE_FILE || TRIO_FEATURE_STDIO\nTRIO_PRIVATE void TrioOutStreamFile TRIO_ARGS2((self, output), trio_class_t* self, int output)\n{\n\tFILE* file;\n\n\tassert(VALID(self));\n\tassert(VALID(self->location));\n\n\tfile = (FILE*)self->location;\n\tself->processed++;\n\tif (fputc(output, file) == EOF)\n\t{\n\t\tself->error = TRIO_ERROR_RETURN(TRIO_EOF, 0);\n\t}\n\telse\n\t{\n\t\tself->actually.committed++;\n\t}\n}\n#endif /* TRIO_FEATURE_FILE || TRIO_FEATURE_STDIO */\n\n/*************************************************************************\n * TrioOutStreamFileDescriptor\n */\n#if TRIO_FEATURE_FD\nTRIO_PRIVATE void TrioOutStreamFileDescriptor TRIO_ARGS2((self, output), trio_class_t* self,\n                                                         int output)\n{\n\tint fd;\n\tchar ch;\n\n\tassert(VALID(self));\n\n\tfd = *((int*)self->location);\n\tch = (char)output;\n\tself->processed++;\n\tif (write(fd, &ch, sizeof(char)) == -1)\n\t{\n\t\tself->error = TRIO_ERROR_RETURN(TRIO_ERRNO, 0);\n\t}\n\telse\n\t{\n\t\tself->actually.committed++;\n\t}\n}\n#endif /* TRIO_FEATURE_FD */\n\n/*************************************************************************\n * TrioOutStreamCustom\n */\n#if TRIO_FEATURE_CLOSURE\nTRIO_PRIVATE void TrioOutStreamCustom TRIO_ARGS2((self, output), trio_class_t* self, int output)\n{\n\tint status;\n\ttrio_custom_t* data;\n\n\tassert(VALID(self));\n\tassert(VALID(self->location));\n\n\tdata = (trio_custom_t*)self->location;\n\tif (data->stream.out)\n\t{\n\t\tstatus = (data->stream.out)(data->closure, output);\n\t\tif (status >= 0)\n\t\t{\n\t\t\tself->actually.committed++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (self->error == 0)\n\t\t\t{\n\t\t\t\tself->error = TRIO_ERROR_RETURN(TRIO_ECUSTOM, -status);\n\t\t\t}\n\t\t}\n\t}\n\tself->processed++;\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n/*************************************************************************\n * TrioOutStreamString\n */\nTRIO_PRIVATE void TrioOutStreamString TRIO_ARGS2((self, output), trio_class_t* self, int output)\n{\n\tchar** buffer;\n\n\tassert(VALID(self));\n\tassert(VALID(self->location));\n\n\tbuffer = (char**)self->location;\n\t**buffer = (char)output;\n\t(*buffer)++;\n\tself->processed++;\n\tself->actually.committed++;\n}\n\n/*************************************************************************\n * TrioOutStreamStringMax\n */\nTRIO_PRIVATE void TrioOutStreamStringMax TRIO_ARGS2((self, output), trio_class_t* self, int output)\n{\n\tchar** buffer;\n\n\tassert(VALID(self));\n\tassert(VALID(self->location));\n\n\tbuffer = (char**)self->location;\n\n\tif (self->processed < self->max)\n\t{\n\t\t**buffer = (char)output;\n\t\t(*buffer)++;\n\t\tself->actually.committed++;\n\t}\n\tself->processed++;\n}\n\n/*************************************************************************\n * TrioOutStreamStringDynamic\n */\n#if TRIO_FEATURE_DYNAMICSTRING\nTRIO_PRIVATE void TrioOutStreamStringDynamic TRIO_ARGS2((self, output), trio_class_t* self,\n                                                        int output)\n{\n\tassert(VALID(self));\n\tassert(VALID(self->location));\n\n\tif (self->error == 0)\n\t{\n\t\ttrio_xstring_append_char((trio_string_t*)self->location, (char)output);\n\t\tself->actually.committed++;\n\t}\n\t/* The processed variable must always be increased */\n\tself->processed++;\n}\n#endif /* TRIO_FEATURE_DYNAMICSTRING */\n\n/*************************************************************************\n * TrioArrayGetter\n */\nstatic trio_pointer_t TrioArrayGetter(trio_pointer_t context, int index, int type)\n{\n\t/* Utility function for the printfv family */\n\ttrio_pointer_t* argarray = (trio_pointer_t*)context;\n\treturn argarray[index];\n}\n\n/*************************************************************************\n *\n * Formatted printing functions\n *\n ************************************************************************/\n\n/** @addtogroup Printf\n    @{\n*/\n\n/*************************************************************************\n * printf\n */\n\n/**\n   Print to standard output stream.\n\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_STDIO\nTRIO_PUBLIC int trio_printf TRIO_VARGS2((format, va_alist), TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioFormat(stdout, 0, TrioOutStreamFile, format, args, NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_STDIO */\n\n/**\n   Print to standard output stream.\n\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_STDIO\nTRIO_PUBLIC int trio_vprintf TRIO_ARGS2((format, args), TRIO_CONST char* format, va_list args)\n{\n\tassert(VALID(format));\n\n\treturn TrioFormat(stdout, 0, TrioOutStreamFile, format, args, NULL, NULL);\n}\n#endif /* TRIO_FEATURE_STDIO */\n\n/**\n   Print to standard output stream.\n\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_STDIO\nTRIO_PUBLIC int trio_printfv TRIO_ARGS2((format, args), TRIO_CONST char* format,\n                                        trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(format));\n\n\treturn TrioFormat(stdout, 0, TrioOutStreamFile, format, unused, TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_STDIO */\n\n/*************************************************************************\n * fprintf\n */\n\n/**\n   Print to file.\n\n   @param file File pointer.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_FILE\nTRIO_PUBLIC int trio_fprintf TRIO_VARGS3((file, format, va_alist), FILE* file,\n                                         TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(file));\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioFormat(file, 0, TrioOutStreamFile, format, args, NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_FILE */\n\n/**\n   Print to file.\n\n   @param file File pointer.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_FILE\nTRIO_PUBLIC int trio_vfprintf TRIO_ARGS3((file, format, args), FILE* file, TRIO_CONST char* format,\n                                         va_list args)\n{\n\tassert(VALID(file));\n\tassert(VALID(format));\n\n\treturn TrioFormat(file, 0, TrioOutStreamFile, format, args, NULL, NULL);\n}\n#endif /* TRIO_FEATURE_FILE */\n\n/**\n   Print to file.\n\n   @param file File pointer.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_FILE\nTRIO_PUBLIC int trio_fprintfv TRIO_ARGS3((file, format, args), FILE* file, TRIO_CONST char* format,\n                                         trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(file));\n\tassert(VALID(format));\n\n\treturn TrioFormat(file, 0, TrioOutStreamFile, format, unused, TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_FILE */\n\n/*************************************************************************\n * dprintf\n */\n\n/**\n   Print to file descriptor.\n\n   @param fd File descriptor.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_FD\nTRIO_PUBLIC int trio_dprintf TRIO_VARGS3((fd, format, va_alist), int fd, TRIO_CONST char* format,\n                                         TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioFormat(&fd, 0, TrioOutStreamFileDescriptor, format, args, NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_FD */\n\n/**\n   Print to file descriptor.\n\n   @param fd File descriptor.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_FD\nTRIO_PUBLIC int trio_vdprintf TRIO_ARGS3((fd, format, args), int fd, TRIO_CONST char* format,\n                                         va_list args)\n{\n\tassert(VALID(format));\n\n\treturn TrioFormat(&fd, 0, TrioOutStreamFileDescriptor, format, args, NULL, NULL);\n}\n#endif /* TRIO_FEATURE_FD */\n\n/**\n   Print to file descriptor.\n\n   @param fd File descriptor.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_FD\nTRIO_PUBLIC int trio_dprintfv TRIO_ARGS3((fd, format, args), int fd, TRIO_CONST char* format,\n                                         trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(format));\n\n\treturn TrioFormat(&fd, 0, TrioOutStreamFileDescriptor, format, unused, TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_FD */\n\n/*************************************************************************\n * cprintf\n */\n#if TRIO_FEATURE_CLOSURE\nTRIO_PUBLIC int trio_cprintf TRIO_VARGS4((stream, closure, format, va_alist),\n                                         trio_outstream_t stream, trio_pointer_t closure,\n                                         TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tdata.stream.out = stream;\n\tdata.closure = closure;\n\tstatus = TrioFormat(&data, 0, TrioOutStreamCustom, format, args, NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n#if TRIO_FEATURE_CLOSURE\nTRIO_PUBLIC int trio_vcprintf TRIO_ARGS4((stream, closure, format, args), trio_outstream_t stream,\n                                         trio_pointer_t closure, TRIO_CONST char* format,\n                                         va_list args)\n{\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\n\tdata.stream.out = stream;\n\tdata.closure = closure;\n\treturn TrioFormat(&data, 0, TrioOutStreamCustom, format, args, NULL, NULL);\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n#if TRIO_FEATURE_CLOSURE\nTRIO_PUBLIC int trio_cprintfv TRIO_ARGS4((stream, closure, format, args), trio_outstream_t stream,\n                                         trio_pointer_t closure, TRIO_CONST char* format,\n                                         trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\n\tdata.stream.out = stream;\n\tdata.closure = closure;\n\treturn TrioFormat(&data, 0, TrioOutStreamCustom, format, unused, TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n#if TRIO_FEATURE_CLOSURE && TRIO_FEATURE_ARGFUNC\nTRIO_PUBLIC int trio_cprintff TRIO_ARGS5((stream, closure, format, argfunc, context),\n                                         trio_outstream_t stream, trio_pointer_t closure,\n                                         TRIO_CONST char* format, trio_argfunc_t argfunc,\n                                         trio_pointer_t context)\n{\n\tstatic va_list unused;\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\tassert(VALID(argfunc));\n\n\tdata.stream.out = stream;\n\tdata.closure = closure;\n\treturn TrioFormat(&data, 0, TrioOutStreamCustom, format, unused, argfunc,\n\t                  (trio_pointer_t*)context);\n}\n#endif /* TRIO_FEATURE_CLOSURE && TRIO_FEATURE_ARGFUNC */\n\n/*************************************************************************\n * sprintf\n */\n\n/**\n   Print to string.\n\n   @param buffer Output string.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of printed characters.\n */\nTRIO_PUBLIC int trio_sprintf TRIO_VARGS3((buffer, format, va_alist), char* buffer,\n                                         TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioFormat(&buffer, 0, TrioOutStreamString, format, args, NULL, NULL);\n\t*buffer = NIL; /* Terminate with NIL character */\n\tTRIO_VA_END(args);\n\treturn status;\n}\n\n/**\n   Print to string.\n\n   @param buffer Output string.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\nTRIO_PUBLIC int trio_vsprintf TRIO_ARGS3((buffer, format, args), char* buffer,\n                                         TRIO_CONST char* format, va_list args)\n{\n\tint status;\n\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\tstatus = TrioFormat(&buffer, 0, TrioOutStreamString, format, args, NULL, NULL);\n\t*buffer = NIL;\n\treturn status;\n}\n\n/**\n   Print to string.\n\n   @param buffer Output string.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\nTRIO_PUBLIC int trio_sprintfv TRIO_ARGS3((buffer, format, args), char* buffer,\n                                         TRIO_CONST char* format, trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\tint status;\n\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\tstatus = TrioFormat(&buffer, 0, TrioOutStreamString, format, unused, TrioArrayGetter, args);\n\t*buffer = NIL;\n\treturn status;\n}\n\n/*************************************************************************\n * snprintf\n */\n\n/**\n   Print at most @p max characters to string.\n\n   @param buffer Output string.\n   @param max Maximum number of characters to print.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of printed characters.\n */\nTRIO_PUBLIC int trio_snprintf TRIO_VARGS4((buffer, max, format, va_alist), char* buffer, size_t max,\n                                          TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(buffer) || (max == 0));\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioFormat(&buffer, max > 0 ? max - 1 : 0, TrioOutStreamStringMax, format, args, NULL,\n\t                    NULL);\n\tif (max > 0)\n\t\t*buffer = NIL;\n\tTRIO_VA_END(args);\n\treturn status;\n}\n\n/**\n   Print at most @p max characters to string.\n\n   @param buffer Output string.\n   @param max Maximum number of characters to print.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\nTRIO_PUBLIC int trio_vsnprintf TRIO_ARGS4((buffer, max, format, args), char* buffer, size_t max,\n                                          TRIO_CONST char* format, va_list args)\n{\n\tint status;\n\n\tassert(VALID(buffer) || (max == 0));\n\tassert(VALID(format));\n\n\tstatus = TrioFormat(&buffer, max > 0 ? max - 1 : 0, TrioOutStreamStringMax, format, args, NULL,\n\t                    NULL);\n\tif (max > 0)\n\t\t*buffer = NIL;\n\treturn status;\n}\n\n/**\n   Print at most @p max characters to string.\n\n   @param buffer Output string.\n   @param max Maximum number of characters to print.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\nTRIO_PUBLIC int trio_snprintfv TRIO_ARGS4((buffer, max, format, args), char* buffer, size_t max,\n                                          TRIO_CONST char* format, trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\tint status;\n\n\tassert(VALID(buffer) || (max == 0));\n\tassert(VALID(format));\n\n\tstatus = TrioFormat(&buffer, max > 0 ? max - 1 : 0, TrioOutStreamStringMax, format, unused,\n\t                    TrioArrayGetter, args);\n\tif (max > 0)\n\t\t*buffer = NIL;\n\treturn status;\n}\n\n/*************************************************************************\n * snprintfcat\n * Appends the new string to the buffer string overwriting the '\\0'\n * character at the end of buffer.\n */\n#if TRIO_EXTENSION\nTRIO_PUBLIC int trio_snprintfcat TRIO_VARGS4((buffer, max, format, va_alist), char* buffer,\n                                             size_t max, TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\tsize_t buf_len;\n\n\tTRIO_VA_START(args, format);\n\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\tbuf_len = trio_length(buffer);\n\tbuffer = &buffer[buf_len];\n\n\tstatus =\n\t    TrioFormat(&buffer, max - 1 - buf_len, TrioOutStreamStringMax, format, args, NULL, NULL);\n\tTRIO_VA_END(args);\n\t*buffer = NIL;\n\treturn status;\n}\n#endif\n\n#if TRIO_EXTENSION\nTRIO_PUBLIC int trio_vsnprintfcat TRIO_ARGS4((buffer, max, format, args), char* buffer, size_t max,\n                                             TRIO_CONST char* format, va_list args)\n{\n\tint status;\n\tsize_t buf_len;\n\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\tbuf_len = trio_length(buffer);\n\tbuffer = &buffer[buf_len];\n\tstatus =\n\t    TrioFormat(&buffer, max - 1 - buf_len, TrioOutStreamStringMax, format, args, NULL, NULL);\n\t*buffer = NIL;\n\treturn status;\n}\n#endif\n\n/*************************************************************************\n * trio_aprintf\n */\n\n#if TRIO_DEPRECATED && TRIO_FEATURE_DYNAMICSTRING\nTRIO_PUBLIC char* trio_aprintf TRIO_VARGS2((format, va_alist), TRIO_CONST char* format,\n                                           TRIO_VA_DECL)\n{\n\tva_list args;\n\ttrio_string_t* info;\n\tchar* result = NULL;\n\n\tassert(VALID(format));\n\n\tinfo = trio_xstring_duplicate(\"\");\n\tif (info)\n\t{\n\t\tTRIO_VA_START(args, format);\n\t\t(void)TrioFormat(info, 0, TrioOutStreamStringDynamic, format, args, NULL, NULL);\n\t\tTRIO_VA_END(args);\n\n\t\ttrio_string_terminate(info);\n\t\tresult = trio_string_extract(info);\n\t\ttrio_string_destroy(info);\n\t}\n\treturn result;\n}\n#endif /* TRIO_DEPRECATED && TRIO_FEATURE_DYNAMICSTRING */\n\n#if TRIO_DEPRECATED && TRIO_FEATURE_DYNAMICSTRING\nTRIO_PUBLIC char* trio_vaprintf TRIO_ARGS2((format, args), TRIO_CONST char* format, va_list args)\n{\n\ttrio_string_t* info;\n\tchar* result = NULL;\n\n\tassert(VALID(format));\n\n\tinfo = trio_xstring_duplicate(\"\");\n\tif (info)\n\t{\n\t\t(void)TrioFormat(info, 0, TrioOutStreamStringDynamic, format, args, NULL, NULL);\n\t\ttrio_string_terminate(info);\n\t\tresult = trio_string_extract(info);\n\t\ttrio_string_destroy(info);\n\t}\n\treturn result;\n}\n#endif /* TRIO_DEPRECATED && TRIO_FEATURE_DYNAMICSTRING */\n\n/**\n   Allocate and print to string.\n   The memory allocated and returned by @p result must be freed by the\n   calling application.\n\n   @param result Output string.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_DYNAMICSTRING\nTRIO_PUBLIC int trio_asprintf TRIO_VARGS3((result, format, va_alist), char** result,\n                                          TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tva_list args;\n\tint status;\n\ttrio_string_t* info;\n\n\tassert(VALID(format));\n\n\t*result = NULL;\n\n\tinfo = trio_xstring_duplicate(\"\");\n\tif (info == NULL)\n\t{\n\t\tstatus = TRIO_ERROR_RETURN(TRIO_ENOMEM, 0);\n\t}\n\telse\n\t{\n\t\tTRIO_VA_START(args, format);\n\t\tstatus = TrioFormat(info, 0, TrioOutStreamStringDynamic, format, args, NULL, NULL);\n\t\tTRIO_VA_END(args);\n\t\tif (status >= 0)\n\t\t{\n\t\t\ttrio_string_terminate(info);\n\t\t\t*result = trio_string_extract(info);\n\t\t}\n\t\ttrio_string_destroy(info);\n\t}\n\treturn status;\n}\n#endif /* TRIO_FEATURE_DYNAMICSTRING */\n\n/**\n   Allocate and print to string.\n   The memory allocated and returned by @p result must be freed by the\n   calling application.\n\n   @param result Output string.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_DYNAMICSTRING\nTRIO_PUBLIC int trio_vasprintf TRIO_ARGS3((result, format, args), char** result,\n                                          TRIO_CONST char* format, va_list args)\n{\n\tint status;\n\ttrio_string_t* info;\n\n\tassert(VALID(format));\n\n\t*result = NULL;\n\n\tinfo = trio_xstring_duplicate(\"\");\n\tif (info == NULL)\n\t{\n\t\tstatus = TRIO_ERROR_RETURN(TRIO_ENOMEM, 0);\n\t}\n\telse\n\t{\n\t\tstatus = TrioFormat(info, 0, TrioOutStreamStringDynamic, format, args, NULL, NULL);\n\t\tif (status >= 0)\n\t\t{\n\t\t\ttrio_string_terminate(info);\n\t\t\t*result = trio_string_extract(info);\n\t\t}\n\t\ttrio_string_destroy(info);\n\t}\n\treturn status;\n}\n#endif /* TRIO_FEATURE_DYNAMICSTRING */\n\n/**\n   Allocate and print to string.\n   The memory allocated and returned by @p result must be freed by the\n   calling application.\n\n   @param result Output string.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of printed characters.\n */\n#if TRIO_FEATURE_DYNAMICSTRING\nTRIO_PUBLIC int trio_asprintfv TRIO_ARGS3((result, format, args), char** result,\n                                          TRIO_CONST char* format, trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\tint status;\n\ttrio_string_t* info;\n\n\tassert(VALID(format));\n\n\t*result = NULL;\n\n\tinfo = trio_xstring_duplicate(\"\");\n\tif (info == NULL)\n\t{\n\t\tstatus = TRIO_ERROR_RETURN(TRIO_ENOMEM, 0);\n\t}\n\telse\n\t{\n\t\tstatus =\n\t\t    TrioFormat(info, 0, TrioOutStreamStringDynamic, format, unused, TrioArrayGetter, args);\n\t\tif (status >= 0)\n\t\t{\n\t\t\ttrio_string_terminate(info);\n\t\t\t*result = trio_string_extract(info);\n\t\t}\n\t\ttrio_string_destroy(info);\n\t}\n\treturn status;\n}\n#endif /* TRIO_FEATURE_DYNAMICSTRING */\n\n#if defined(TRIO_DOCUMENTATION)\n#include \"doc/doc_printf.h\"\n#endif\n\n/** @} End of Printf documentation module */\n\n/*************************************************************************\n *\n * CALLBACK\n *\n ************************************************************************/\n\n#if defined(TRIO_DOCUMENTATION)\n#include \"doc/doc_register.h\"\n#endif\n/**\n   @addtogroup UserDefined\n   @{\n*/\n\n#if TRIO_FEATURE_USER_DEFINED\n\n/*************************************************************************\n * trio_register\n */\n\n/**\n   Register new user-defined specifier.\n\n   @param callback\n   @param name\n   @return Handle.\n */\nTRIO_PUBLIC trio_pointer_t trio_register TRIO_ARGS2((callback, name), trio_callback_t callback,\n                                                    TRIO_CONST char* name)\n{\n\ttrio_userdef_t* def;\n\ttrio_userdef_t* prev = NULL;\n\n\tif (callback == NULL)\n\t\treturn NULL;\n\n\tif (name)\n\t{\n\t\t/* Handle built-in namespaces */\n\t\tif (name[0] == ':')\n\t\t{\n\t\t\tif (trio_equal(name, \":enter\"))\n\t\t\t{\n\t\t\t\tinternalEnterCriticalRegion = callback;\n\t\t\t}\n\t\t\telse if (trio_equal(name, \":leave\"))\n\t\t\t{\n\t\t\t\tinternalLeaveCriticalRegion = callback;\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Bail out if namespace is too long */\n\t\tif (trio_length_max(name, MAX_USER_NAME) >= MAX_USER_NAME)\n\t\t\treturn NULL;\n\n\t\t/* Bail out if namespace already is registered */\n\t\tdef = TrioFindNamespace(name, &prev);\n\t\tif (def)\n\t\t\treturn NULL;\n\t}\n\n\tdef = (trio_userdef_t*)TRIO_MALLOC(sizeof(trio_userdef_t));\n\tif (def)\n\t{\n\t\tif (internalEnterCriticalRegion)\n\t\t\t(void)internalEnterCriticalRegion(NULL);\n\n\t\tif (name)\n\t\t{\n\t\t\t/* Link into internal list */\n\t\t\tif (prev == NULL)\n\t\t\t\tinternalUserDef = def;\n\t\t\telse\n\t\t\t\tprev->next = def;\n\t\t}\n\t\t/* Initialize */\n\t\tdef->callback = callback;\n\t\tdef->name = (name == NULL) ? NULL : trio_duplicate(name);\n\t\tdef->next = NULL;\n\n\t\tif (internalLeaveCriticalRegion)\n\t\t\t(void)internalLeaveCriticalRegion(NULL);\n\t}\n\treturn (trio_pointer_t)def;\n}\n\n/**\n   Unregister an existing user-defined specifier.\n\n   @param handle\n */\nvoid trio_unregister TRIO_ARGS1((handle), trio_pointer_t handle)\n{\n\ttrio_userdef_t* self = (trio_userdef_t*)handle;\n\ttrio_userdef_t* def;\n\ttrio_userdef_t* prev = NULL;\n\n\tassert(VALID(self));\n\n\tif (self->name)\n\t{\n\t\tdef = TrioFindNamespace(self->name, &prev);\n\t\tif (def)\n\t\t{\n\t\t\tif (internalEnterCriticalRegion)\n\t\t\t\t(void)internalEnterCriticalRegion(NULL);\n\n\t\t\tif (prev == NULL)\n\t\t\t\tinternalUserDef = internalUserDef->next;\n\t\t\telse\n\t\t\t\tprev->next = def->next;\n\n\t\t\tif (internalLeaveCriticalRegion)\n\t\t\t\t(void)internalLeaveCriticalRegion(NULL);\n\t\t}\n\t\ttrio_destroy(self->name);\n\t}\n\tTRIO_FREE(self);\n}\n\n/*************************************************************************\n * trio_get_format [public]\n */\nTRIO_CONST char* trio_get_format TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n#if TRIO_FEATURE_USER_DEFINED\n\tassert(((trio_reference_t*)ref)->parameter->type == FORMAT_USER_DEFINED);\n#endif\n\n\treturn (((trio_reference_t*)ref)->parameter->user_data);\n}\n\n/*************************************************************************\n * trio_get_argument [public]\n */\ntrio_pointer_t trio_get_argument TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n#if TRIO_FEATURE_USER_DEFINED\n\tassert(((trio_reference_t*)ref)->parameter->type == FORMAT_USER_DEFINED);\n#endif\n\n\treturn ((trio_reference_t*)ref)->parameter->data.pointer;\n}\n\n/*************************************************************************\n * trio_get_width / trio_set_width [public]\n */\nint trio_get_width TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn ((trio_reference_t*)ref)->parameter->width;\n}\n\nvoid trio_set_width TRIO_ARGS2((ref, width), trio_pointer_t ref, int width)\n{\n\t((trio_reference_t*)ref)->parameter->width = width;\n}\n\n/*************************************************************************\n * trio_get_precision / trio_set_precision [public]\n */\nint trio_get_precision TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->precision);\n}\n\nvoid trio_set_precision TRIO_ARGS2((ref, precision), trio_pointer_t ref, int precision)\n{\n\t((trio_reference_t*)ref)->parameter->precision = precision;\n}\n\n/*************************************************************************\n * trio_get_base / trio_set_base [public]\n */\nint trio_get_base TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->base);\n}\n\nvoid trio_set_base TRIO_ARGS2((ref, base), trio_pointer_t ref, int base)\n{\n\t((trio_reference_t*)ref)->parameter->base = base;\n}\n\n/*************************************************************************\n * trio_get_long / trio_set_long [public]\n */\nint trio_get_long TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_LONG) ? TRUE : FALSE;\n}\n\nvoid trio_set_long TRIO_ARGS2((ref, is_long), trio_pointer_t ref, int is_long)\n{\n\tif (is_long)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_LONG;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_LONG;\n}\n\n/*************************************************************************\n * trio_get_longlong / trio_set_longlong [public]\n */\nint trio_get_longlong TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_QUAD) ? TRUE : FALSE;\n}\n\nvoid trio_set_longlong TRIO_ARGS2((ref, is_longlong), trio_pointer_t ref, int is_longlong)\n{\n\tif (is_longlong)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_QUAD;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_QUAD;\n}\n\n/*************************************************************************\n * trio_get_longdouble / trio_set_longdouble [public]\n */\n#if TRIO_FEATURE_FLOAT\nint trio_get_longdouble TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_LONGDOUBLE) ? TRUE : FALSE;\n}\n\nvoid trio_set_longdouble TRIO_ARGS2((ref, is_longdouble), trio_pointer_t ref, int is_longdouble)\n{\n\tif (is_longdouble)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_LONGDOUBLE;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_LONGDOUBLE;\n}\n#endif /* TRIO_FEATURE_FLOAT */\n\n/*************************************************************************\n * trio_get_short / trio_set_short [public]\n */\nint trio_get_short TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_SHORT) ? TRUE : FALSE;\n}\n\nvoid trio_set_short TRIO_ARGS2((ref, is_short), trio_pointer_t ref, int is_short)\n{\n\tif (is_short)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_SHORT;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_SHORT;\n}\n\n/*************************************************************************\n * trio_get_shortshort / trio_set_shortshort [public]\n */\nint trio_get_shortshort TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_SHORTSHORT) ? TRUE : FALSE;\n}\n\nvoid trio_set_shortshort TRIO_ARGS2((ref, is_shortshort), trio_pointer_t ref, int is_shortshort)\n{\n\tif (is_shortshort)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_SHORTSHORT;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_SHORTSHORT;\n}\n\n/*************************************************************************\n * trio_get_alternative / trio_set_alternative [public]\n */\nint trio_get_alternative TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_ALTERNATIVE) ? TRUE : FALSE;\n}\n\nvoid trio_set_alternative TRIO_ARGS2((ref, is_alternative), trio_pointer_t ref, int is_alternative)\n{\n\tif (is_alternative)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_ALTERNATIVE;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_ALTERNATIVE;\n}\n\n/*************************************************************************\n * trio_get_alignment / trio_set_alignment [public]\n */\nint trio_get_alignment TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_LEFTADJUST) ? TRUE : FALSE;\n}\n\nvoid trio_set_alignment TRIO_ARGS2((ref, is_leftaligned), trio_pointer_t ref, int is_leftaligned)\n{\n\tif (is_leftaligned)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_LEFTADJUST;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_LEFTADJUST;\n}\n\n/*************************************************************************\n * trio_get_spacing /trio_set_spacing [public]\n */\nint trio_get_spacing TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_SPACE) ? TRUE : FALSE;\n}\n\nvoid trio_set_spacing TRIO_ARGS2((ref, is_space), trio_pointer_t ref, int is_space)\n{\n\tif (is_space)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_SPACE;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_SPACE;\n}\n\n/*************************************************************************\n * trio_get_sign / trio_set_sign [public]\n */\nint trio_get_sign TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_SHOWSIGN) ? TRUE : FALSE;\n}\n\nvoid trio_set_sign TRIO_ARGS2((ref, is_sign), trio_pointer_t ref, int is_sign)\n{\n\tif (is_sign)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_SHOWSIGN;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_SHOWSIGN;\n}\n\n/*************************************************************************\n * trio_get_padding / trio_set_padding [public]\n */\nint trio_get_padding TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_NILPADDING) ? TRUE : FALSE;\n}\n\nvoid trio_set_padding TRIO_ARGS2((ref, is_padding), trio_pointer_t ref, int is_padding)\n{\n\tif (is_padding)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_NILPADDING;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_NILPADDING;\n}\n\n/*************************************************************************\n * trio_get_quote / trio_set_quote [public]\n */\n#if TRIO_FEATURE_QUOTE\nint trio_get_quote TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_QUOTE) ? TRUE : FALSE;\n}\n\nvoid trio_set_quote TRIO_ARGS2((ref, is_quote), trio_pointer_t ref, int is_quote)\n{\n\tif (is_quote)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_QUOTE;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_QUOTE;\n}\n#endif /* TRIO_FEATURE_QUOTE */\n\n/*************************************************************************\n * trio_get_upper / trio_set_upper [public]\n */\nint trio_get_upper TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_UPPER) ? TRUE : FALSE;\n}\n\nvoid trio_set_upper TRIO_ARGS2((ref, is_upper), trio_pointer_t ref, int is_upper)\n{\n\tif (is_upper)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_UPPER;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_UPPER;\n}\n\n/*************************************************************************\n * trio_get_largest / trio_set_largest [public]\n */\n#if TRIO_FEATURE_INTMAX_T\nint trio_get_largest TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_INTMAX_T) ? TRUE : FALSE;\n}\n\nvoid trio_set_largest TRIO_ARGS2((ref, is_largest), trio_pointer_t ref, int is_largest)\n{\n\tif (is_largest)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_INTMAX_T;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_INTMAX_T;\n}\n#endif /* TRIO_FEATURE_INTMAX_T */\n\n/*************************************************************************\n * trio_get_ptrdiff / trio_set_ptrdiff [public]\n */\n#if TRIO_FEATURE_PTRDIFF_T\nint trio_get_ptrdiff TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_PTRDIFF_T) ? TRUE : FALSE;\n}\n\nvoid trio_set_ptrdiff TRIO_ARGS2((ref, is_ptrdiff), trio_pointer_t ref, int is_ptrdiff)\n{\n\tif (is_ptrdiff)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_PTRDIFF_T;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_PTRDIFF_T;\n}\n#endif /* TRIO_FEATURE_PTRDIFF_T */\n\n/*************************************************************************\n * trio_get_size / trio_set_size [public]\n */\n#if TRIO_FEATURE_SIZE_T\nint trio_get_size TRIO_ARGS1((ref), trio_pointer_t ref)\n{\n\treturn (((trio_reference_t*)ref)->parameter->flags & FLAGS_SIZE_T) ? TRUE : FALSE;\n}\n\nvoid trio_set_size TRIO_ARGS2((ref, is_size), trio_pointer_t ref, int is_size)\n{\n\tif (is_size)\n\t\t((trio_reference_t*)ref)->parameter->flags |= FLAGS_SIZE_T;\n\telse\n\t\t((trio_reference_t*)ref)->parameter->flags &= ~FLAGS_SIZE_T;\n}\n#endif /* TRIO_FEATURE_SIZE_T */\n\n/*************************************************************************\n * trio_print_int [public]\n */\nvoid trio_print_int TRIO_ARGS2((ref, number), trio_pointer_t ref, int number)\n{\n\ttrio_reference_t* self = (trio_reference_t*)ref;\n\n\tTrioWriteNumber(self->data, (trio_uintmax_t)number, self->parameter->flags,\n\t                self->parameter->width, self->parameter->precision, self->parameter->base);\n}\n\n/*************************************************************************\n * trio_print_uint [public]\n */\nvoid trio_print_uint TRIO_ARGS2((ref, number), trio_pointer_t ref, unsigned int number)\n{\n\ttrio_reference_t* self = (trio_reference_t*)ref;\n\n\tTrioWriteNumber(self->data, (trio_uintmax_t)number, self->parameter->flags | FLAGS_UNSIGNED,\n\t                self->parameter->width, self->parameter->precision, self->parameter->base);\n}\n\n/*************************************************************************\n * trio_print_double [public]\n */\n#if TRIO_FEATURE_FLOAT\nvoid trio_print_double TRIO_ARGS2((ref, number), trio_pointer_t ref, double number)\n{\n\ttrio_reference_t* self = (trio_reference_t*)ref;\n\n\tTrioWriteDouble(self->data, number, self->parameter->flags, self->parameter->width,\n\t                self->parameter->precision, self->parameter->base);\n}\n#endif /* TRIO_FEATURE_FLOAT */\n\n/*************************************************************************\n * trio_print_string [public]\n */\nvoid trio_print_string TRIO_ARGS2((ref, string), trio_pointer_t ref, TRIO_CONST char* string)\n{\n\ttrio_reference_t* self = (trio_reference_t*)ref;\n\n\tTrioWriteString(self->data, string, self->parameter->flags, self->parameter->width,\n\t                self->parameter->precision);\n}\n\n/*************************************************************************\n * trio_print_ref [public]\n */\nint trio_print_ref TRIO_VARGS3((ref, format, va_alist), trio_pointer_t ref, TRIO_CONST char* format,\n                               TRIO_VA_DECL)\n{\n\tint status;\n\tva_list arglist;\n\n\tassert(VALID(format));\n\n\tTRIO_VA_START(arglist, format);\n\tstatus = TrioFormatRef((trio_reference_t*)ref, format, arglist, NULL, NULL);\n\tTRIO_VA_END(arglist);\n\treturn status;\n}\n\n/*************************************************************************\n * trio_vprint_ref [public]\n */\nint trio_vprint_ref TRIO_ARGS3((ref, format, arglist), trio_pointer_t ref, TRIO_CONST char* format,\n                               va_list arglist)\n{\n\tassert(VALID(format));\n\n\treturn TrioFormatRef((trio_reference_t*)ref, format, arglist, NULL, NULL);\n}\n\n/*************************************************************************\n * trio_printv_ref [public]\n */\nint trio_printv_ref TRIO_ARGS3((ref, format, argarray), trio_pointer_t ref, TRIO_CONST char* format,\n                               trio_pointer_t* argarray)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(format));\n\n\treturn TrioFormatRef((trio_reference_t*)ref, format, unused, TrioArrayGetter, argarray);\n}\n\n#endif\n\n/*************************************************************************\n * trio_print_pointer [public]\n */\nvoid trio_print_pointer TRIO_ARGS2((ref, pointer), trio_pointer_t ref, trio_pointer_t pointer)\n{\n\ttrio_reference_t* self = (trio_reference_t*)ref;\n\ttrio_flags_t flags;\n\ttrio_uintmax_t number;\n\n\tif (NULL == pointer)\n\t{\n\t\tTRIO_CONST char* string = internalNullString;\n\t\twhile (*string)\n\t\t\tself->data->OutStream(self->data, *string++);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * The subtraction of the null pointer is a workaround\n\t\t * to avoid a compiler warning. The performance overhead\n\t\t * is negligible (and likely to be removed by an\n\t\t * optimizing compiler). The (char *) casting is done\n\t\t * to please ANSI C++.\n\t\t */\n\t\tnumber = (trio_uintmax_t)((char*)pointer - (char*)0);\n\t\t/* Shrink to size of pointer */\n\t\tnumber &= (trio_uintmax_t)-1;\n\t\tflags = self->parameter->flags;\n\t\tflags |= (FLAGS_UNSIGNED | FLAGS_ALTERNATIVE | FLAGS_NILPADDING);\n\t\tTrioWriteNumber(self->data, number, flags, POINTER_WIDTH, NO_PRECISION, BASE_HEX);\n\t}\n}\n\n/** @} End of UserDefined documentation module */\n\n/*************************************************************************\n *\n * LOCALES\n *\n ************************************************************************/\n\n/*************************************************************************\n * trio_locale_set_decimal_point\n *\n * Decimal point can only be one character. The input argument is a\n * string to enable multibyte characters. At most MB_LEN_MAX characters\n * will be used.\n */\n#if TRIO_FEATURE_LOCALE\nTRIO_PUBLIC void trio_locale_set_decimal_point TRIO_ARGS1((decimalPoint), char* decimalPoint)\n{\n#if defined(USE_LOCALE)\n\tif (NULL == internalLocaleValues)\n\t{\n\t\tTrioSetLocale();\n\t}\n#endif\n\tinternalDecimalPointLength = trio_length(decimalPoint);\n\tif (internalDecimalPointLength == 1)\n\t{\n\t\tinternalDecimalPoint = *decimalPoint;\n\t}\n\telse\n\t{\n\t\tinternalDecimalPoint = NIL;\n\t\ttrio_copy_max(internalDecimalPointString, sizeof(internalDecimalPointString), decimalPoint);\n\t}\n}\n#endif\n\n/*************************************************************************\n * trio_locale_set_thousand_separator\n *\n * See trio_locale_set_decimal_point\n */\n#if TRIO_FEATURE_LOCALE || TRIO_EXTENSION\nTRIO_PUBLIC void trio_locale_set_thousand_separator TRIO_ARGS1((thousandSeparator),\n                                                               char* thousandSeparator)\n{\n#if defined(USE_LOCALE)\n\tif (NULL == internalLocaleValues)\n\t{\n\t\tTrioSetLocale();\n\t}\n#endif\n\ttrio_copy_max(internalThousandSeparator, sizeof(internalThousandSeparator), thousandSeparator);\n\tinternalThousandSeparatorLength = trio_length(internalThousandSeparator);\n}\n#endif\n\n/*************************************************************************\n * trio_locale_set_grouping\n *\n * Array of bytes. Reversed order.\n *\n *  CHAR_MAX : No further grouping\n *  0        : Repeat last group for the remaining digits (not necessary\n *             as C strings are zero-terminated)\n *  n        : Set current group to n\n *\n * Same order as the grouping attribute in LC_NUMERIC.\n */\n#if TRIO_FEATURE_LOCALE || TRIO_EXTENSION\nTRIO_PUBLIC void trio_locale_set_grouping TRIO_ARGS1((grouping), char* grouping)\n{\n#if defined(USE_LOCALE)\n\tif (NULL == internalLocaleValues)\n\t{\n\t\tTrioSetLocale();\n\t}\n#endif\n\ttrio_copy_max(internalGrouping, sizeof(internalGrouping), grouping);\n}\n#endif\n\n/*************************************************************************\n *\n * SCANNING\n *\n ************************************************************************/\n\n#if TRIO_FEATURE_SCANF\n\n/*************************************************************************\n * TrioSkipWhitespaces\n */\nTRIO_PRIVATE int TrioSkipWhitespaces TRIO_ARGS1((self), trio_class_t* self)\n{\n\tint ch;\n\n\tch = self->current;\n\twhile (isspace(ch))\n\t{\n\t\tself->InStream(self, &ch);\n\t}\n\treturn ch;\n}\n\n/*************************************************************************\n * TrioGetCollation\n */\n#if TRIO_EXTENSION\nTRIO_PRIVATE void TrioGetCollation(TRIO_NOARGS)\n{\n\tint i;\n\tint j;\n\tint k;\n\tchar first[2];\n\tchar second[2];\n\n\t/* This is computationally expensive */\n\tfirst[1] = NIL;\n\tsecond[1] = NIL;\n\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t{\n\t\tk = 0;\n\t\tfirst[0] = (char)i;\n\t\tfor (j = 0; j < MAX_CHARACTER_CLASS; j++)\n\t\t{\n\t\t\tsecond[0] = (char)j;\n\t\t\tif (trio_equal_locale(first, second))\n\t\t\t\tinternalCollationArray[i][k++] = (char)j;\n\t\t}\n\t\tinternalCollationArray[i][k] = NIL;\n\t}\n}\n#endif\n\n/*************************************************************************\n * TrioGetCharacterClass\n *\n * FIXME:\n *  multibyte\n */\nTRIO_PRIVATE int TrioGetCharacterClass TRIO_ARGS4((format, offsetPointer, flagsPointer,\n                                                   characterclass),\n                                                  TRIO_CONST char* format, int* offsetPointer,\n                                                  trio_flags_t* flagsPointer, int* characterclass)\n{\n\tint offset = *offsetPointer;\n\tint i;\n\tchar ch;\n\tchar range_begin;\n\tchar range_end;\n\n\t*flagsPointer &= ~FLAGS_EXCLUDE;\n\n\tif (format[offset] == QUALIFIER_CIRCUMFLEX)\n\t{\n\t\t*flagsPointer |= FLAGS_EXCLUDE;\n\t\toffset++;\n\t}\n\t/*\n\t * If the ungroup character is at the beginning of the scanlist,\n\t * it will be part of the class, and a second ungroup character\n\t * must follow to end the group.\n\t */\n\tif (format[offset] == SPECIFIER_UNGROUP)\n\t{\n\t\tcharacterclass[(int)SPECIFIER_UNGROUP]++;\n\t\toffset++;\n\t}\n\t/*\n\t * Minus is used to specify ranges. To include minus in the class,\n\t * it must be at the beginning of the list\n\t */\n\tif (format[offset] == QUALIFIER_MINUS)\n\t{\n\t\tcharacterclass[(int)QUALIFIER_MINUS]++;\n\t\toffset++;\n\t}\n\t/* Collect characters */\n\tfor (ch = format[offset]; (ch != SPECIFIER_UNGROUP) && (ch != NIL); ch = format[++offset])\n\t{\n\t\tswitch (ch)\n\t\t{\n\t\t\tcase QUALIFIER_MINUS: /* Scanlist ranges */\n\n\t\t\t\t/*\n\t\t\t\t * Both C99 and UNIX98 describes ranges as implementation-\n\t\t\t\t * defined.\n\t\t\t\t *\n\t\t\t\t * We support the following behaviour (although this may\n\t\t\t\t * change as we become wiser)\n\t\t\t\t * - only increasing ranges, ie. [a-b] but not [b-a]\n\t\t\t\t * - transitive ranges, ie. [a-b-c] == [a-c]\n\t\t\t\t * - trailing minus, ie. [a-] is interpreted as an 'a'\n\t\t\t\t *   and a '-'\n\t\t\t\t * - duplicates (although we can easily convert these\n\t\t\t\t *   into errors)\n\t\t\t\t */\n\t\t\t\trange_begin = format[offset - 1];\n\t\t\t\trange_end = format[++offset];\n\t\t\t\tif (range_end == SPECIFIER_UNGROUP)\n\t\t\t\t{\n\t\t\t\t\t/* Trailing minus is included */\n\t\t\t\t\tcharacterclass[(int)ch]++;\n\t\t\t\t\tch = range_end;\n\t\t\t\t\tbreak; /* for */\n\t\t\t\t}\n\t\t\t\tif (range_end == NIL)\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t\t\tif (range_begin > range_end)\n\t\t\t\t\treturn TRIO_ERROR_RETURN(TRIO_ERANGE, offset);\n\n\t\t\t\tfor (i = (int)range_begin; i <= (int)range_end; i++)\n\t\t\t\t\tcharacterclass[i]++;\n\n\t\t\t\tch = range_end;\n\t\t\t\tbreak;\n\n#if TRIO_EXTENSION\n\n\t\t\tcase SPECIFIER_GROUP:\n\n\t\t\t\tswitch (format[offset + 1])\n\t\t\t\t{\n\t\t\t\t\tcase QUALIFIER_DOT: /* Collating symbol */\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * FIXME: This will be easier to implement when multibyte\n\t\t\t\t\t\t * characters have been implemented. Until now, we ignore\n\t\t\t\t\t\t * this feature.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tfor (i = offset + 2;; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (format[i] == NIL)\n\t\t\t\t\t\t\t\t/* Error in syntax */\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\telse if (format[i] == QUALIFIER_DOT)\n\t\t\t\t\t\t\t\tbreak; /* for */\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (format[++i] != SPECIFIER_UNGROUP)\n\t\t\t\t\t\t\treturn -1;\n\n\t\t\t\t\t\toffset = i;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase QUALIFIER_EQUAL: /* Equivalence class expressions */\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned int j;\n\t\t\t\t\t\tunsigned int k;\n\n\t\t\t\t\t\tif (internalCollationUnconverted)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Lazy evaluation of collation array */\n\t\t\t\t\t\t\tTrioGetCollation();\n\t\t\t\t\t\t\tinternalCollationUnconverted = FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (i = offset + 2;; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (format[i] == NIL)\n\t\t\t\t\t\t\t\t/* Error in syntax */\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\telse if (format[i] == QUALIFIER_EQUAL)\n\t\t\t\t\t\t\t\tbreak; /* for */\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Mark any equivalent character */\n\t\t\t\t\t\t\t\tk = (unsigned int)format[i];\n\t\t\t\t\t\t\t\tfor (j = 0; internalCollationArray[k][j] != NIL; j++)\n\t\t\t\t\t\t\t\t\tcharacterclass[(int)internalCollationArray[k][j]]++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (format[++i] != SPECIFIER_UNGROUP)\n\t\t\t\t\t\t\treturn -1;\n\n\t\t\t\t\t\toffset = i;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase QUALIFIER_COLON: /* Character class expressions */\n\n\t\t\t\t\t\tif (trio_equal_max(CLASS_ALNUM, sizeof(CLASS_ALNUM) - 1, &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isalnum(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_ALNUM) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_ALPHA, sizeof(CLASS_ALPHA) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isalpha(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_ALPHA) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_CNTRL, sizeof(CLASS_CNTRL) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (iscntrl(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_CNTRL) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_DIGIT, sizeof(CLASS_DIGIT) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isdigit(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_DIGIT) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_GRAPH, sizeof(CLASS_GRAPH) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isgraph(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_GRAPH) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_LOWER, sizeof(CLASS_LOWER) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (islower(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_LOWER) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_PRINT, sizeof(CLASS_PRINT) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isprint(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_PRINT) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_PUNCT, sizeof(CLASS_PUNCT) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (ispunct(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_PUNCT) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_SPACE, sizeof(CLASS_SPACE) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isspace(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_SPACE) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_UPPER, sizeof(CLASS_UPPER) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isupper(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_UPPER) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (trio_equal_max(CLASS_XDIGIT, sizeof(CLASS_XDIGIT) - 1,\n\t\t\t\t\t\t                        &format[offset]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (i = 0; i < MAX_CHARACTER_CLASS; i++)\n\t\t\t\t\t\t\t\tif (isxdigit(i))\n\t\t\t\t\t\t\t\t\tcharacterclass[i]++;\n\t\t\t\t\t\t\toffset += sizeof(CLASS_XDIGIT) - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcharacterclass[(int)ch]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcharacterclass[(int)ch]++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n#endif /* TRIO_EXTENSION */\n\n\t\t\tdefault:\n\t\t\t\tcharacterclass[(int)ch]++;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*************************************************************************\n * TrioReadNumber\n *\n * We implement our own number conversion in preference of strtol and\n * strtoul, because we must handle 'long long' and thousand separators.\n */\nTRIO_PRIVATE BOOLEAN_T TrioReadNumber TRIO_ARGS5((self, target, flags, width, base),\n                                                 trio_class_t* self, trio_uintmax_t* target,\n                                                 trio_flags_t flags, int width, int base)\n{\n\ttrio_uintmax_t number = 0;\n\tint digit;\n\tint count;\n\tBOOLEAN_T isNegative = FALSE;\n\tBOOLEAN_T gotNumber = FALSE;\n\tint j;\n\n\tassert(VALID(self));\n\tassert(VALID(self->InStream));\n\tassert((base >= MIN_BASE && base <= MAX_BASE) || (base == NO_BASE));\n\n\tif (internalDigitsUnconverted)\n\t{\n\t\t/* Lazy evaluation of digits array */\n\t\tmemset(internalDigitArray, -1, sizeof(internalDigitArray));\n\t\tfor (j = 0; j < (int)sizeof(internalDigitsLower) - 1; j++)\n\t\t{\n\t\t\tinternalDigitArray[(int)internalDigitsLower[j]] = j;\n\t\t\tinternalDigitArray[(int)internalDigitsUpper[j]] = j;\n\t\t}\n\t\tinternalDigitsUnconverted = FALSE;\n\t}\n\n\tTrioSkipWhitespaces(self);\n\n\t/* Leading sign */\n\tif (self->current == '+')\n\t{\n\t\tself->InStream(self, NULL);\n\t}\n\telse if (self->current == '-')\n\t{\n\t\tself->InStream(self, NULL);\n\t\tisNegative = TRUE;\n\t}\n\n\tcount = self->processed;\n\n\tif (flags & FLAGS_ALTERNATIVE)\n\t{\n\t\tswitch (base)\n\t\t{\n\t\t\tcase NO_BASE:\n\t\t\tcase BASE_OCTAL:\n\t\t\tcase BASE_HEX:\n\t\t\tcase BASE_BINARY:\n\t\t\t\tif (self->current == '0')\n\t\t\t\t{\n\t\t\t\t\tself->InStream(self, NULL);\n\t\t\t\t\tif (self->current)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((base == BASE_HEX) && (trio_to_upper(self->current) == 'X'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tself->InStream(self, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((base == BASE_BINARY) && (trio_to_upper(self->current) == 'B'))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tself->InStream(self, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn FALSE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (((width == NO_WIDTH) || (self->processed - count < width)) &&\n\t       (!((self->current == EOF) || isspace(self->current))))\n\t{\n\t\tif (isascii(self->current))\n\t\t{\n\t\t\tdigit = internalDigitArray[self->current];\n\t\t\t/* Abort if digit is not allowed in the specified base */\n\t\t\tif ((digit == -1) || (digit >= base))\n\t\t\t\tbreak;\n\t\t}\n#if TRIO_FEATURE_QUOTE\n\t\telse if (flags & FLAGS_QUOTE)\n\t\t{\n\t\t\t/* Compare with thousands separator */\n\t\t\tfor (j = 0; internalThousandSeparator[j] && self->current; j++)\n\t\t\t{\n\t\t\t\tif (internalThousandSeparator[j] != self->current)\n\t\t\t\t\tbreak;\n\n\t\t\t\tself->InStream(self, NULL);\n\t\t\t}\n\t\t\tif (internalThousandSeparator[j])\n\t\t\t\tbreak; /* Mismatch */\n\t\t\telse\n\t\t\t\tcontinue; /* Match */\n\t\t}\n#endif\n\t\telse\n\t\t\tbreak;\n\n\t\tnumber *= base;\n\t\tnumber += digit;\n\t\tgotNumber = TRUE; /* we need at least one digit */\n\n\t\tself->InStream(self, NULL);\n\t}\n\n\t/* Was anything read at all? */\n\tif (!gotNumber)\n\t\treturn FALSE;\n\n\tif (target)\n\t\t*target = (isNegative) ? (trio_uintmax_t)(-((trio_intmax_t)number)) : number;\n\treturn TRUE;\n}\n\n/*************************************************************************\n * TrioReadChar\n */\nTRIO_PRIVATE int TrioReadChar TRIO_ARGS4((self, target, flags, width), trio_class_t* self,\n                                         char* target, trio_flags_t flags, int width)\n{\n\tint i;\n\tchar ch;\n\ttrio_uintmax_t number;\n\n\tassert(VALID(self));\n\tassert(VALID(self->InStream));\n\n\tfor (i = 0; (self->current != EOF) && (i < width); i++)\n\t{\n\t\tch = (char)self->current;\n\t\tself->InStream(self, NULL);\n\t\tif ((flags & FLAGS_ALTERNATIVE) && (ch == CHAR_BACKSLASH))\n\t\t{\n\t\t\tswitch (self->current)\n\t\t\t{\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tch = '\\\\';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'a':\n\t\t\t\t\tch = '\\007';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tch = '\\b';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tch = '\\f';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\tch = '\\n';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\t\tch = '\\r';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\tch = '\\t';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tch = '\\v';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (isdigit(self->current))\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Read octal number */\n\t\t\t\t\t\tif (!TrioReadNumber(self, &number, 0, 3, BASE_OCTAL))\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\tch = (char)number;\n\t\t\t\t\t}\n\t\t\t\t\telse if (trio_to_upper(self->current) == 'X')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Read hexadecimal number */\n\t\t\t\t\t\tself->InStream(self, NULL);\n\t\t\t\t\t\tif (!TrioReadNumber(self, &number, 0, 2, BASE_HEX))\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\tch = (char)number;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tch = (char)self->current;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (target)\n\t\t\ttarget[i] = ch;\n\t}\n\treturn i + 1;\n}\n\n/*************************************************************************\n * TrioReadString\n */\nTRIO_PRIVATE BOOLEAN_T TrioReadString TRIO_ARGS4((self, target, flags, width), trio_class_t* self,\n                                                 char* target, trio_flags_t flags, int width)\n{\n\tint i;\n\n\tassert(VALID(self));\n\tassert(VALID(self->InStream));\n\n\tTrioSkipWhitespaces(self);\n\n\t/*\n\t * Continue until end of string is reached, a whitespace is encountered,\n\t * or width is exceeded\n\t */\n\tfor (i = 0; ((width == NO_WIDTH) || (i < width)) &&\n\t            (!((self->current == EOF) || isspace(self->current)));\n\t     i++)\n\t{\n\t\tif (TrioReadChar(self, (target ? &target[i] : 0), flags, 1) == 0)\n\t\t\tbreak; /* for */\n\t}\n\tif (target)\n\t\ttarget[i] = NIL;\n\treturn TRUE;\n}\n\n/*************************************************************************\n * TrioReadWideChar\n */\n#if TRIO_FEATURE_WIDECHAR\nTRIO_PRIVATE int TrioReadWideChar TRIO_ARGS4((self, target, flags, width), trio_class_t* self,\n                                             trio_wchar_t* target, trio_flags_t flags, int width)\n{\n\tint i;\n\tint j;\n\tint size;\n\tint amount = 0;\n\ttrio_wchar_t wch;\n\tchar buffer[MB_LEN_MAX + 1];\n\n\tassert(VALID(self));\n\tassert(VALID(self->InStream));\n\n\tfor (i = 0; (self->current != EOF) && (i < width); i++)\n\t{\n\t\tif (isascii(self->current))\n\t\t{\n\t\t\tif (TrioReadChar(self, buffer, flags, 1) == 0)\n\t\t\t\treturn 0;\n\t\t\tbuffer[1] = NIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Collect a multibyte character, by enlarging buffer until\n\t\t\t * it contains a fully legal multibyte character, or the\n\t\t\t * buffer is full.\n\t\t\t */\n\t\t\tj = 0;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tbuffer[j++] = (char)self->current;\n\t\t\t\tbuffer[j] = NIL;\n\t\t\t\tself->InStream(self, NULL);\n\t\t\t} while ((j < (int)sizeof(buffer)) && (mblen(buffer, (size_t)j) != j));\n\t\t}\n\t\tif (target)\n\t\t{\n\t\t\tsize = mbtowc(&wch, buffer, sizeof(buffer));\n\t\t\tif (size > 0)\n\t\t\t\ttarget[i] = wch;\n\t\t}\n\t\tamount += size;\n\t\tself->InStream(self, NULL);\n\t}\n\treturn amount;\n}\n#endif /* TRIO_FEATURE_WIDECHAR */\n\n/*************************************************************************\n * TrioReadWideString\n */\n#if TRIO_FEATURE_WIDECHAR\nTRIO_PRIVATE BOOLEAN_T TrioReadWideString TRIO_ARGS4((self, target, flags, width),\n                                                     trio_class_t* self, trio_wchar_t* target,\n                                                     trio_flags_t flags, int width)\n{\n\tint i;\n\tint size;\n\n\tassert(VALID(self));\n\tassert(VALID(self->InStream));\n\n\tTrioSkipWhitespaces(self);\n\n#if defined(TRIO_COMPILER_SUPPORTS_MULTIBYTE)\n\t/* Required by TrioReadWideChar */\n\t(void)mblen(NULL, 0);\n#endif\n\n\t/*\n\t * Continue until end of string is reached, a whitespace is encountered,\n\t * or width is exceeded\n\t */\n\tfor (i = 0; ((width == NO_WIDTH) || (i < width)) &&\n\t            (!((self->current == EOF) || isspace(self->current)));)\n\t{\n\t\tsize = TrioReadWideChar(self, &target[i], flags, 1);\n\t\tif (size == 0)\n\t\t\tbreak; /* for */\n\n\t\ti += size;\n\t}\n\tif (target)\n\t\ttarget[i] = WCONST('\\0');\n\treturn TRUE;\n}\n#endif /* TRIO_FEATURE_WIDECHAR */\n\n/*************************************************************************\n * TrioReadGroup\n *\n * Reads non-empty character groups.\n *\n * FIXME: characterclass does not work with multibyte characters\n */\nTRIO_PRIVATE BOOLEAN_T TrioReadGroup TRIO_ARGS5((self, target, characterclass, flags, width),\n                                                trio_class_t* self, char* target,\n                                                int* characterclass, trio_flags_t flags, int width)\n{\n\tint ch;\n\tint i;\n\n\tassert(VALID(self));\n\tassert(VALID(self->InStream));\n\n\tch = self->current;\n\tfor (i = 0; ((width == NO_WIDTH) || (i < width)) &&\n\t            (!((ch == EOF) || (((flags & FLAGS_EXCLUDE) != 0) ^ (characterclass[ch] == 0))));\n\t     i++)\n\t{\n\t\tif (target)\n\t\t\ttarget[i] = (char)ch;\n\t\tself->InStream(self, &ch);\n\t}\n\n\tif (i == 0)\n\t\treturn FALSE;\n\n\t/* Terminate the string if input saved */\n\tif (target)\n\t\ttarget[i] = NIL;\n\treturn TRUE;\n}\n\n/*************************************************************************\n * TrioReadDouble\n *\n * FIXME:\n *  add long double\n *  handle base\n */\n#if TRIO_FEATURE_FLOAT\nTRIO_PRIVATE BOOLEAN_T TrioReadDouble TRIO_ARGS4((self, target, flags, width), trio_class_t* self,\n                                                 trio_pointer_t target, trio_flags_t flags,\n                                                 int width)\n{\n\tint ch;\n\tchar doubleString[512];\n\tint offset = 0;\n\tint start;\n#if TRIO_FEATURE_QUOTE\n\tint j;\n#endif\n\tBOOLEAN_T isHex = FALSE;\n\ttrio_long_double_t infinity;\n\n\tdoubleString[0] = 0;\n\n\tif ((width == NO_WIDTH) || (width > (int)sizeof(doubleString) - 1))\n\t\twidth = sizeof(doubleString) - 1;\n\n\tTrioSkipWhitespaces(self);\n\n\t/*\n\t * Read entire double number from stream. trio_to_double requires\n\t * a string as input, but InStream can be anything, so we have to\n\t * collect all characters.\n\t */\n\tch = self->current;\n\tif ((ch == '+') || (ch == '-'))\n\t{\n\t\tdoubleString[offset++] = (char)ch;\n\t\tself->InStream(self, &ch);\n\t\twidth--;\n\t}\n\n\tstart = offset;\n\tswitch (ch)\n\t{\n\t\tcase 'n':\n\t\tcase 'N':\n\t\t\t/* Not-a-number */\n\t\t\tif (offset != 0)\n\t\t\t\tbreak;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 'i':\n\t\tcase 'I':\n\t\t\t/* Infinity */\n\t\t\twhile (isalpha(ch) && (offset - start < width))\n\t\t\t{\n\t\t\t\tdoubleString[offset++] = (char)ch;\n\t\t\t\tself->InStream(self, &ch);\n\t\t\t}\n\t\t\tdoubleString[offset] = NIL;\n\n\t\t\t/* Case insensitive string comparison */\n\t\t\tif (trio_equal(&doubleString[start], INFINITE_UPPER) ||\n\t\t\t    trio_equal(&doubleString[start], LONG_INFINITE_UPPER))\n\t\t\t{\n\t\t\t\tinfinity = ((start == 1) && (doubleString[0] == '-')) ? trio_ninf() : trio_pinf();\n\t\t\t\tif (!target)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tif (flags & FLAGS_LONGDOUBLE)\n\t\t\t\t{\n\t\t\t\t\t*((trio_long_double_t*)target) = infinity;\n\t\t\t\t}\n\t\t\t\telse if (flags & FLAGS_LONG)\n\t\t\t\t{\n\t\t\t\t\t*((double*)target) = infinity;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*((float*)target) = infinity;\n\t\t\t\t}\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\tif (trio_equal(doubleString, NAN_UPPER))\n\t\t\t{\n\t\t\t\tif (!target)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\t/* NaN must not have a preceeding + nor - */\n\t\t\t\tif (flags & FLAGS_LONGDOUBLE)\n\t\t\t\t{\n\t\t\t\t\t*((trio_long_double_t*)target) = trio_nan();\n\t\t\t\t}\n\t\t\t\telse if (flags & FLAGS_LONG)\n\t\t\t\t{\n\t\t\t\t\t*((double*)target) = trio_nan();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*((float*)target) = trio_nan();\n\t\t\t\t}\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\treturn FALSE;\n\n\t\tcase '0':\n\t\t\tdoubleString[offset++] = (char)ch;\n\t\t\tself->InStream(self, &ch);\n\t\t\tif (trio_to_upper(ch) == 'X')\n\t\t\t{\n\t\t\t\tisHex = TRUE;\n\t\t\t\tdoubleString[offset++] = (char)ch;\n\t\t\t\tself->InStream(self, &ch);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\twhile ((ch != EOF) && (offset - start < width))\n\t{\n\t\t/* Integer part */\n\t\tif (isHex ? isxdigit(ch) : isdigit(ch))\n\t\t{\n\t\t\tdoubleString[offset++] = (char)ch;\n\t\t\tself->InStream(self, &ch);\n\t\t}\n#if TRIO_FEATURE_QUOTE\n\t\telse if (flags & FLAGS_QUOTE)\n\t\t{\n\t\t\t/* Compare with thousands separator */\n\t\t\tfor (j = 0; internalThousandSeparator[j] && self->current; j++)\n\t\t\t{\n\t\t\t\tif (internalThousandSeparator[j] != self->current)\n\t\t\t\t\tbreak;\n\n\t\t\t\tself->InStream(self, &ch);\n\t\t\t}\n\t\t\tif (internalThousandSeparator[j])\n\t\t\t\tbreak; /* Mismatch */\n\t\t\telse\n\t\t\t\tcontinue; /* Match */\n\t\t}\n#endif\n\t\telse\n\t\t\tbreak; /* while */\n\t}\n\tif (ch == '.')\n\t{\n\t\t/* Decimal part */\n\t\tdoubleString[offset++] = (char)ch;\n\t\tself->InStream(self, &ch);\n\t\twhile ((isHex ? isxdigit(ch) : isdigit(ch)) && (offset - start < width))\n\t\t{\n\t\t\tdoubleString[offset++] = (char)ch;\n\t\t\tself->InStream(self, &ch);\n\t\t}\n\t}\n\tif (isHex ? (trio_to_upper(ch) == 'P') : (trio_to_upper(ch) == 'E'))\n\t{\n\t\t/* Exponent */\n\t\tdoubleString[offset++] = (char)ch;\n\t\tself->InStream(self, &ch);\n\t\tif ((ch == '+') || (ch == '-'))\n\t\t{\n\t\t\tdoubleString[offset++] = (char)ch;\n\t\t\tself->InStream(self, &ch);\n\t\t}\n\t\twhile (isdigit(ch) && (offset - start < width))\n\t\t{\n\t\t\tdoubleString[offset++] = (char)ch;\n\t\t\tself->InStream(self, &ch);\n\t\t}\n\t}\n\n\tif ((offset == start) || (*doubleString == NIL))\n\t\treturn FALSE;\n\n\tdoubleString[offset] = 0;\n\n\tif (flags & FLAGS_LONGDOUBLE)\n\t{\n\t\tif (!target)\n\t\t\treturn FALSE;\n\n\t\t*((trio_long_double_t*)target) = trio_to_long_double(doubleString, NULL);\n\t}\n\telse if (flags & FLAGS_LONG)\n\t{\n\t\tif (!target)\n\t\t\treturn FALSE;\n\n\t\t*((double*)target) = trio_to_double(doubleString, NULL);\n\t}\n\telse\n\t{\n\t\tif (!target)\n\t\t\treturn FALSE;\n\n\t\t*((float*)target) = trio_to_float(doubleString, NULL);\n\t}\n\treturn TRUE;\n}\n#endif /* TRIO_FEATURE_FLOAT */\n\n/*************************************************************************\n * TrioReadPointer\n */\nTRIO_PRIVATE BOOLEAN_T TrioReadPointer TRIO_ARGS3((self, target, flags), trio_class_t* self,\n                                                  trio_pointer_t* target, trio_flags_t flags)\n{\n\ttrio_uintmax_t number;\n\tchar buffer[sizeof(internalNullString)];\n\n\tflags |= (FLAGS_UNSIGNED | FLAGS_ALTERNATIVE | FLAGS_NILPADDING);\n\n\tif (TrioReadNumber(self, &number, flags, POINTER_WIDTH, BASE_HEX))\n\t{\n\t\tif (target)\n\t\t{\n#if defined(TRIO_COMPILER_GCC) || defined(TRIO_COMPILER_MIPSPRO)\n\t\t\t/*\n\t\t\t * The strange assignment of number is a workaround for a compiler\n\t\t\t * warning\n\t\t\t */\n\t\t\t*target = &((char*)0)[number];\n#else\n\t\t\t*target = (trio_pointer_t)number;\n#endif\n\t\t}\n\t\treturn TRUE;\n\t}\n\telse if (TrioReadString(self, (flags & FLAGS_IGNORE) ? NULL : buffer, 0,\n\t                        sizeof(internalNullString) - 1))\n\t{\n\t\tif (trio_equal_case(buffer, internalNullString))\n\t\t{\n\t\t\tif (target)\n\t\t\t\t*target = NULL;\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/*************************************************************************\n * TrioScanProcess\n */\nTRIO_PRIVATE int TrioScanProcess TRIO_ARGS3((data, format, parameters), trio_class_t* data,\n                                            TRIO_CONST char* format, trio_parameter_t* parameters)\n{\n\tint status;\n\tint assignment;\n\tint ch;\n\tint offset; /* Offset of format string */\n\tint i;      /* Offset of current parameter */\n\ttrio_flags_t flags;\n\tint width;\n\tint base;\n\ttrio_pointer_t pointer;\n\n\t/* Return on empty format string */\n\tif (format[0] == NIL)\n\t\treturn 0;\n\n\tstatus = 0;\n\tassignment = 0;\n\ti = 0;\n\toffset = 0;\n\tdata->InStream(data, &ch);\n\n\tfor (;;)\n\t{\n\t\t/* Skip the parameter entries */\n\t\twhile (parameters[i].type == FORMAT_PARAMETER)\n\t\t{\n\t\t\tassert(i <= MAX_PARAMETERS);\n\t\t\ti++;\n\t\t}\n\n\t\t/* Compare non conversion-specifier part of format string */\n\t\twhile (offset < parameters[i].beginOffset)\n\t\t{\n\t\t\tif ((CHAR_IDENTIFIER == format[offset]) && (CHAR_IDENTIFIER == format[offset + 1]))\n\t\t\t{\n\t\t\t\t/* Two % in format matches one % in input stream */\n\t\t\t\tif (CHAR_IDENTIFIER == ch)\n\t\t\t\t{\n\t\t\t\t\tdata->InStream(data, &ch);\n\t\t\t\t\toffset += 2;\n\t\t\t\t\tcontinue; /* while format chars left */\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstatus = TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse /* Not an % identifier */\n\t\t\t{\n\t\t\t\tif (isspace((int)format[offset]))\n\t\t\t\t{\n\t\t\t\t\t/* Whitespaces may match any amount of whitespaces */\n\t\t\t\t\tch = TrioSkipWhitespaces(data);\n\t\t\t\t}\n\t\t\t\telse if (ch == format[offset])\n\t\t\t\t{\n\t\t\t\t\tdata->InStream(data, &ch);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstatus = assignment;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\toffset++;\n\t\t\t}\n\t\t}\n\n\t\tif (parameters[i].type == FORMAT_SENTINEL)\n\t\t\tbreak;\n\n\t\tif ((EOF == ch) && (parameters[i].type != FORMAT_COUNT))\n\t\t{\n\t\t\tstatus = (assignment > 0) ? assignment : EOF;\n\t\t\tgoto end;\n\t\t}\n\n\t\tflags = parameters[i].flags;\n\n\t\t/* Find width */\n\t\twidth = parameters[i].width;\n\t\tif (flags & FLAGS_WIDTH_PARAMETER)\n\t\t{\n\t\t\t/* Get width from parameter list */\n\t\t\twidth = (int)parameters[width].data.number.as_signed;\n\t\t}\n\n\t\t/* Find base */\n\t\tif (NO_BASE != parameters[i].baseSpecifier)\n\t\t{\n\t\t\t/* Base from specifier has priority */\n\t\t\tbase = parameters[i].baseSpecifier;\n\t\t}\n\t\telse if (flags & FLAGS_BASE_PARAMETER)\n\t\t{\n\t\t\t/* Get base from parameter list */\n\t\t\tbase = parameters[i].base;\n\t\t\tbase = (int)parameters[base].data.number.as_signed;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use base from format string */\n\t\t\tbase = parameters[i].base;\n\t\t}\n\n\t\tswitch (parameters[i].type)\n\t\t{\n\t\t\tcase FORMAT_INT:\n\t\t\t{\n\t\t\t\ttrio_uintmax_t number;\n\n\t\t\t\tif (0 == base)\n\t\t\t\t\tbase = BASE_DECIMAL;\n\n\t\t\t\tif (!TrioReadNumber(data, &number, flags, width, base))\n\t\t\t\t{\n\t\t\t\t\tstatus = assignment;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t\tif (!(flags & FLAGS_IGNORE))\n\t\t\t\t{\n\t\t\t\t\tassignment++;\n\n\t\t\t\t\tpointer = parameters[i].data.pointer;\n#if TRIO_FEATURE_SIZE_T || TRIO_FEATURE_SIZE_T_UPPER\n\t\t\t\t\tif (flags & FLAGS_SIZE_T)\n\t\t\t\t\t\t*(size_t*)pointer = (size_t)number;\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_PTRDIFF_T\n\t\t\t\t\t    if (flags & FLAGS_PTRDIFF_T)\n\t\t\t\t\t\t*(ptrdiff_t*)pointer = (ptrdiff_t)number;\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_INTMAX_T\n\t\t\t\t\t    if (flags & FLAGS_INTMAX_T)\n\t\t\t\t\t\t*(trio_intmax_t*)pointer = (trio_intmax_t)number;\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t    if (flags & FLAGS_QUAD)\n\t\t\t\t\t\t*(trio_ulonglong_t*)pointer = (trio_ulonglong_t)number;\n\t\t\t\t\telse if (flags & FLAGS_LONG)\n\t\t\t\t\t\t*(long int*)pointer = (long int)number;\n\t\t\t\t\telse if (flags & FLAGS_SHORT)\n\t\t\t\t\t\t*(short int*)pointer = (short int)number;\n\t\t\t\t\telse\n\t\t\t\t\t\t*(int*)pointer = (int)number;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak; /* FORMAT_INT */\n\n\t\t\tcase FORMAT_STRING:\n#if TRIO_FEATURE_WIDECHAR\n\t\t\t\tif (flags & FLAGS_WIDECHAR)\n\t\t\t\t{\n\t\t\t\t\tif (!TrioReadWideString(\n\t\t\t\t\t        data, (flags & FLAGS_IGNORE) ? NULL : parameters[i].data.wstring, flags,\n\t\t\t\t\t        width))\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus = assignment;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tif (!TrioReadString(data,\n\t\t\t\t\t                    (flags & FLAGS_IGNORE) ? NULL : parameters[i].data.string,\n\t\t\t\t\t                    flags, width))\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus = assignment;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!(flags & FLAGS_IGNORE))\n\t\t\t\t\tassignment++;\n\t\t\t\tbreak; /* FORMAT_STRING */\n\n#if TRIO_FEATURE_FLOAT\n\t\t\tcase FORMAT_DOUBLE:\n\t\t\t{\n\t\t\t\tif (flags & FLAGS_IGNORE)\n\t\t\t\t{\n\t\t\t\t\tpointer = NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpointer = (flags & FLAGS_LONGDOUBLE)\n\t\t\t\t\t              ? (trio_pointer_t)parameters[i].data.longdoublePointer\n\t\t\t\t\t              : (trio_pointer_t)parameters[i].data.doublePointer;\n\t\t\t\t}\n\t\t\t\tif (!TrioReadDouble(data, pointer, flags, width))\n\t\t\t\t{\n\t\t\t\t\tstatus = assignment;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tif (!(flags & FLAGS_IGNORE))\n\t\t\t\t{\n\t\t\t\t\tassignment++;\n\t\t\t\t}\n\t\t\t\tbreak; /* FORMAT_DOUBLE */\n\t\t\t}\n#endif\n\n\t\t\tcase FORMAT_GROUP:\n\t\t\t{\n\t\t\t\tint characterclass[MAX_CHARACTER_CLASS + 1];\n\n\t\t\t\t/* Skip over modifiers */\n\t\t\t\twhile (format[offset] != SPECIFIER_GROUP)\n\t\t\t\t{\n\t\t\t\t\toffset++;\n\t\t\t\t}\n\t\t\t\t/* Skip over group specifier */\n\t\t\t\toffset++;\n\n\t\t\t\tmemset(characterclass, 0, sizeof(characterclass));\n\t\t\t\tstatus = TrioGetCharacterClass(format, &offset, &flags, characterclass);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tgoto end;\n\n\t\t\t\tif (!TrioReadGroup(data, (flags & FLAGS_IGNORE) ? NULL : parameters[i].data.string,\n\t\t\t\t                   characterclass, flags, parameters[i].width))\n\t\t\t\t{\n\t\t\t\t\tstatus = assignment;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tif (!(flags & FLAGS_IGNORE))\n\t\t\t\t\tassignment++;\n\t\t\t}\n\t\t\tbreak; /* FORMAT_GROUP */\n\n\t\t\tcase FORMAT_COUNT:\n\t\t\t\tpointer = parameters[i].data.pointer;\n\t\t\t\tif (NULL != pointer)\n\t\t\t\t{\n\t\t\t\t\tint count = data->processed;\n\t\t\t\t\tif (ch != EOF)\n\t\t\t\t\t\tcount--; /* a character is read, but is not consumed yet */\n#if TRIO_FEATURE_SIZE_T || TRIO_FEATURE_SIZE_T_UPPER\n\t\t\t\t\tif (flags & FLAGS_SIZE_T)\n\t\t\t\t\t\t*(size_t*)pointer = (size_t)count;\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_PTRDIFF_T\n\t\t\t\t\t    if (flags & FLAGS_PTRDIFF_T)\n\t\t\t\t\t\t*(ptrdiff_t*)pointer = (ptrdiff_t)count;\n\t\t\t\t\telse\n#endif\n#if TRIO_FEATURE_INTMAX_T\n\t\t\t\t\t    if (flags & FLAGS_INTMAX_T)\n\t\t\t\t\t\t*(trio_intmax_t*)pointer = (trio_intmax_t)count;\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t    if (flags & FLAGS_QUAD)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(trio_ulonglong_t*)pointer = (trio_ulonglong_t)count;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flags & FLAGS_LONG)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(long int*)pointer = (long int)count;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flags & FLAGS_SHORT)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(short int*)pointer = (short int)count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t*(int*)pointer = (int)count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak; /* FORMAT_COUNT */\n\n\t\t\tcase FORMAT_CHAR:\n#if TRIO_FEATURE_WIDECHAR\n\t\t\t\tif (flags & FLAGS_WIDECHAR)\n\t\t\t\t{\n\t\t\t\t\tif (TrioReadWideChar(data,\n\t\t\t\t\t                     (flags & FLAGS_IGNORE) ? NULL : parameters[i].data.wstring,\n\t\t\t\t\t                     flags, (width == NO_WIDTH) ? 1 : width) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus = assignment;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tif (TrioReadChar(data,\n\t\t\t\t\t                 (flags & FLAGS_IGNORE) ? NULL : parameters[i].data.string,\n\t\t\t\t\t                 flags, (width == NO_WIDTH) ? 1 : width) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus = assignment;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!(flags & FLAGS_IGNORE))\n\t\t\t\t\tassignment++;\n\t\t\t\tbreak; /* FORMAT_CHAR */\n\n\t\t\tcase FORMAT_POINTER:\n\t\t\t\tif (!TrioReadPointer(\n\t\t\t\t        data,\n\t\t\t\t        (flags & FLAGS_IGNORE) ? NULL : (trio_pointer_t*)parameters[i].data.pointer,\n\t\t\t\t        flags))\n\t\t\t\t{\n\t\t\t\t\tstatus = assignment;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tif (!(flags & FLAGS_IGNORE))\n\t\t\t\t\tassignment++;\n\t\t\t\tbreak; /* FORMAT_POINTER */\n\n\t\t\tcase FORMAT_PARAMETER:\n\t\t\t\tbreak; /* FORMAT_PARAMETER */\n\n\t\t\tdefault:\n\t\t\t\tstatus = TRIO_ERROR_RETURN(TRIO_EINVAL, offset);\n\t\t\t\tgoto end;\n\t\t}\n\n\t\tch = data->current;\n\t\toffset = parameters[i].endOffset;\n\t\ti++;\n\t}\n\n\tstatus = assignment;\nend:\n\tif (data->UndoStream)\n\t\tdata->UndoStream(data);\n\treturn status;\n}\n\n/*************************************************************************\n * TrioScan\n */\nTRIO_PRIVATE int TrioScan TRIO_ARGS8(\n    (source, sourceSize, InStream, UndoStream, format, arglist, argfunc, argarray),\n    trio_pointer_t source, size_t sourceSize, void(*InStream) TRIO_PROTO((trio_class_t*, int*)),\n    void(*UndoStream) TRIO_PROTO((trio_class_t*)), TRIO_CONST char* format, va_list arglist,\n    trio_argfunc_t argfunc, trio_pointer_t* argarray)\n{\n\tint status;\n\ttrio_parameter_t parameters[MAX_PARAMETERS];\n\ttrio_class_t data;\n\n\tassert(VALID(InStream));\n\tassert(VALID(format));\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.InStream = InStream;\n\tdata.UndoStream = UndoStream;\n\tdata.location = (trio_pointer_t)source;\n\tdata.max = sourceSize;\n\tdata.error = 0;\n\n#if defined(USE_LOCALE)\n\tif (NULL == internalLocaleValues)\n\t{\n\t\tTrioSetLocale();\n\t}\n#endif\n\n\tstatus = TrioParse(TYPE_SCAN, format, parameters, arglist, argfunc, argarray);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = TrioScanProcess(&data, format, parameters);\n\tif (data.error != 0)\n\t{\n\t\tstatus = data.error;\n\t}\n\treturn status;\n}\n\n/*************************************************************************\n * TrioInStreamFile\n */\n#if TRIO_FEATURE_FILE || TRIO_FEATURE_STDIO\nTRIO_PRIVATE void TrioInStreamFile TRIO_ARGS2((self, intPointer), trio_class_t* self,\n                                              int* intPointer)\n{\n\tFILE* file = (FILE*)self->location;\n\n\tassert(VALID(self));\n\tassert(VALID(file));\n\n\tself->actually.cached = 0;\n\n\t/* The initial value of self->current is zero */\n\tif (self->current == EOF)\n\t{\n\t\tself->error =\n\t\t    (ferror(file)) ? TRIO_ERROR_RETURN(TRIO_ERRNO, 0) : TRIO_ERROR_RETURN(TRIO_EOF, 0);\n\t}\n\telse\n\t{\n\t\tself->processed++;\n\t\tself->actually.cached++;\n\t}\n\n\tself->current = fgetc(file);\n\n\tif (VALID(intPointer))\n\t{\n\t\t*intPointer = self->current;\n\t}\n}\n#endif /* TRIO_FEATURE_FILE || TRIO_FEATURE_STDIO */\n\n/*************************************************************************\n * TrioUndoStreamFile\n */\n#if TRIO_FEATURE_FILE || TRIO_FEATURE_STDIO\nTRIO_PRIVATE void TrioUndoStreamFile TRIO_ARGS1((self), trio_class_t* self)\n{\n\tFILE* file = (FILE*)self->location;\n\n\tassert(VALID(self));\n\tassert(VALID(file));\n\n\tif (self->actually.cached > 0)\n\t{\n\t\tassert(self->actually.cached == 1);\n\n\t\tself->current = ungetc(self->current, file);\n\t\tself->actually.cached = 0;\n\t}\n}\n#endif /* TRIO_FEATURE_FILE || TRIO_FEATURE_STDIO */\n\n/*************************************************************************\n * TrioInStreamFileDescriptor\n */\n#if TRIO_FEATURE_FD\nTRIO_PRIVATE void TrioInStreamFileDescriptor TRIO_ARGS2((self, intPointer), trio_class_t* self,\n                                                        int* intPointer)\n{\n\tint fd = *((int*)self->location);\n\tint size;\n\tunsigned char input;\n\n\tassert(VALID(self));\n\n\tself->actually.cached = 0;\n\n\tsize = read(fd, &input, sizeof(char));\n\tif (size == -1)\n\t{\n\t\tself->error = TRIO_ERROR_RETURN(TRIO_ERRNO, 0);\n\t\tself->current = EOF;\n\t}\n\telse\n\t{\n\t\tself->current = (size == 0) ? EOF : input;\n\t}\n\tif (self->current != EOF)\n\t{\n\t\tself->actually.cached++;\n\t\tself->processed++;\n\t}\n\n\tif (VALID(intPointer))\n\t{\n\t\t*intPointer = self->current;\n\t}\n}\n#endif /* TRIO_FEATURE_FD */\n\n/*************************************************************************\n * TrioInStreamCustom\n */\n#if TRIO_FEATURE_CLOSURE\nTRIO_PRIVATE void TrioInStreamCustom TRIO_ARGS2((self, intPointer), trio_class_t* self,\n                                                int* intPointer)\n{\n\ttrio_custom_t* data;\n\n\tassert(VALID(self));\n\tassert(VALID(self->location));\n\n\tself->actually.cached = 0;\n\n\tdata = (trio_custom_t*)self->location;\n\n\tself->current = (data->stream.in == NULL) ? NIL : (data->stream.in)(data->closure);\n\n\tif (self->current == NIL)\n\t{\n\t\tself->current = EOF;\n\t}\n\telse\n\t{\n\t\tself->processed++;\n\t\tself->actually.cached++;\n\t}\n\n\tif (VALID(intPointer))\n\t{\n\t\t*intPointer = self->current;\n\t}\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n/*************************************************************************\n * TrioInStreamString\n */\nTRIO_PRIVATE void TrioInStreamString TRIO_ARGS2((self, intPointer), trio_class_t* self,\n                                                int* intPointer)\n{\n\tunsigned char** buffer;\n\n\tassert(VALID(self));\n\tassert(VALID(self->location));\n\n\tself->actually.cached = 0;\n\n\tbuffer = (unsigned char**)self->location;\n\tself->current = (*buffer)[0];\n\tif (self->current == NIL)\n\t{\n\t\tself->current = EOF;\n\t}\n\telse\n\t{\n\t\t(*buffer)++;\n\t\tself->processed++;\n\t\tself->actually.cached++;\n\t}\n\n\tif (VALID(intPointer))\n\t{\n\t\t*intPointer = self->current;\n\t}\n}\n\n/*************************************************************************\n *\n * Formatted scanning functions\n *\n ************************************************************************/\n\n#if defined(TRIO_DOCUMENTATION)\n#include \"doc/doc_scanf.h\"\n#endif\n/** @addtogroup Scanf\n    @{\n*/\n\n/*************************************************************************\n * scanf\n */\n\n/**\n   Scan characters from standard input stream.\n\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_STDIO\nTRIO_PUBLIC int trio_scanf TRIO_VARGS2((format, va_alist), TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioScan((trio_pointer_t)stdin, 0, TrioInStreamFile, TrioUndoStreamFile, format, args,\n\t                  NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_STDIO */\n\n/**\n   Scan characters from standard input stream.\n\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_STDIO\nTRIO_PUBLIC int trio_vscanf TRIO_ARGS2((format, args), TRIO_CONST char* format, va_list args)\n{\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)stdin, 0, TrioInStreamFile, TrioUndoStreamFile, format, args,\n\t                NULL, NULL);\n}\n#endif /* TRIO_FEATURE_STDIO */\n\n/**\n   Scan characters from standard input stream.\n\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_STDIO\nTRIO_PUBLIC int trio_scanfv TRIO_ARGS2((format, args), TRIO_CONST char* format,\n                                       trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)stdin, 0, TrioInStreamFile, TrioUndoStreamFile, format, unused,\n\t                TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_STDIO */\n\n/*************************************************************************\n * fscanf\n */\n\n/**\n   Scan characters from file.\n\n   @param file File pointer.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_FILE\nTRIO_PUBLIC int trio_fscanf TRIO_VARGS3((file, format, va_alist), FILE* file,\n                                        TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(file));\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioScan((trio_pointer_t)file, 0, TrioInStreamFile, TrioUndoStreamFile, format, args,\n\t                  NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_FILE */\n\n/**\n   Scan characters from file.\n\n   @param file File pointer.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_FILE\nTRIO_PUBLIC int trio_vfscanf TRIO_ARGS3((file, format, args), FILE* file, TRIO_CONST char* format,\n                                        va_list args)\n{\n\tassert(VALID(file));\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)file, 0, TrioInStreamFile, TrioUndoStreamFile, format, args,\n\t                NULL, NULL);\n}\n#endif /* TRIO_FEATURE_FILE */\n\n/**\n   Scan characters from file.\n\n   @param file File pointer.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_FILE\nTRIO_PUBLIC int trio_fscanfv TRIO_ARGS3((file, format, args), FILE* file, TRIO_CONST char* format,\n                                        trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(file));\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)file, 0, TrioInStreamFile, TrioUndoStreamFile, format, unused,\n\t                TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_FILE */\n\n/*************************************************************************\n * dscanf\n */\n\n/**\n   Scan characters from file descriptor.\n\n   @param fd File descriptor.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_FD\nTRIO_PUBLIC int trio_dscanf TRIO_VARGS3((fd, format, va_alist), int fd, TRIO_CONST char* format,\n                                        TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus = TrioScan((trio_pointer_t)&fd, 0, TrioInStreamFileDescriptor, NULL, format, args, NULL,\n\t                  NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_FD */\n\n/**\n   Scan characters from file descriptor.\n\n   @param fd File descriptor.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_FD\nTRIO_PUBLIC int trio_vdscanf TRIO_ARGS3((fd, format, args), int fd, TRIO_CONST char* format,\n                                        va_list args)\n{\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)&fd, 0, TrioInStreamFileDescriptor, NULL, format, args, NULL,\n\t                NULL);\n}\n#endif /* TRIO_FEATURE_FD */\n\n/**\n   Scan characters from file descriptor.\n\n   @param fd File descriptor.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\n#if TRIO_FEATURE_FD\nTRIO_PUBLIC int trio_dscanfv TRIO_ARGS3((fd, format, args), int fd, TRIO_CONST char* format,\n                                        trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)&fd, 0, TrioInStreamFileDescriptor, NULL, format, unused,\n\t                TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_FD */\n\n/*************************************************************************\n * cscanf\n */\n#if TRIO_FEATURE_CLOSURE\nTRIO_PUBLIC int trio_cscanf TRIO_VARGS4((stream, closure, format, va_alist), trio_instream_t stream,\n                                        trio_pointer_t closure, TRIO_CONST char* format,\n                                        TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tdata.stream.in = stream;\n\tdata.closure = closure;\n\tstatus = TrioScan(&data, 0, TrioInStreamCustom, NULL, format, args, NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n#if TRIO_FEATURE_CLOSURE\nTRIO_PUBLIC int trio_vcscanf TRIO_ARGS4((stream, closure, format, args), trio_instream_t stream,\n                                        trio_pointer_t closure, TRIO_CONST char* format,\n                                        va_list args)\n{\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\n\tdata.stream.in = stream;\n\tdata.closure = closure;\n\treturn TrioScan(&data, 0, TrioInStreamCustom, NULL, format, args, NULL, NULL);\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n#if TRIO_FEATURE_CLOSURE\nTRIO_PUBLIC int trio_cscanfv TRIO_ARGS4((stream, closure, format, args), trio_instream_t stream,\n                                        trio_pointer_t closure, TRIO_CONST char* format,\n                                        trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\n\tdata.stream.in = stream;\n\tdata.closure = closure;\n\treturn TrioScan(&data, 0, TrioInStreamCustom, NULL, format, unused, TrioArrayGetter, args);\n}\n#endif /* TRIO_FEATURE_CLOSURE */\n\n#if TRIO_FEATURE_CLOSURE && TRIO_FEATURE_ARGFUNC\nTRIO_PUBLIC int trio_cscanff TRIO_ARGS5((stream, closure, format, argfunc, context),\n                                        trio_instream_t stream, trio_pointer_t closure,\n                                        TRIO_CONST char* format, trio_argfunc_t argfunc,\n                                        trio_pointer_t context)\n{\n\tstatic va_list unused;\n\ttrio_custom_t data;\n\n\tassert(VALID(stream));\n\tassert(VALID(format));\n\tassert(VALID(argfunc));\n\n\tdata.stream.in = stream;\n\tdata.closure = closure;\n\treturn TrioScan(&data, 0, TrioInStreamCustom, NULL, format, unused, argfunc,\n\t                (trio_pointer_t*)context);\n}\n#endif /* TRIO_FEATURE_CLOSURE && TRIO_FEATURE_ARGFUNC */\n\n/*************************************************************************\n * sscanf\n */\n\n/**\n   Scan characters from string.\n\n   @param buffer Input string.\n   @param format Formatting string.\n   @param ... Arguments.\n   @return Number of scanned characters.\n */\nTRIO_PUBLIC int trio_sscanf TRIO_VARGS3((buffer, format, va_alist), TRIO_CONST char* buffer,\n                                        TRIO_CONST char* format, TRIO_VA_DECL)\n{\n\tint status;\n\tva_list args;\n\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\tTRIO_VA_START(args, format);\n\tstatus =\n\t    TrioScan((trio_pointer_t)&buffer, 0, TrioInStreamString, NULL, format, args, NULL, NULL);\n\tTRIO_VA_END(args);\n\treturn status;\n}\n\n/**\n   Scan characters from string.\n\n   @param buffer Input string.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\nTRIO_PUBLIC int trio_vsscanf TRIO_ARGS3((buffer, format, args), TRIO_CONST char* buffer,\n                                        TRIO_CONST char* format, va_list args)\n{\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)&buffer, 0, TrioInStreamString, NULL, format, args, NULL, NULL);\n}\n\n/**\n   Scan characters from string.\n\n   @param buffer Input string.\n   @param format Formatting string.\n   @param args Arguments.\n   @return Number of scanned characters.\n */\nTRIO_PUBLIC int trio_sscanfv TRIO_ARGS3((buffer, format, args), TRIO_CONST char* buffer,\n                                        TRIO_CONST char* format, trio_pointer_t* args)\n{\n\tstatic va_list unused;\n\n\tassert(VALID(buffer));\n\tassert(VALID(format));\n\n\treturn TrioScan((trio_pointer_t)&buffer, 0, TrioInStreamString, NULL, format, unused,\n\t                TrioArrayGetter, args);\n}\n\n#endif /* TRIO_FEATURE_SCANF */\n\n/** @} End of Scanf documentation module */\n\n/*************************************************************************\n * trio_strerror\n */\nTRIO_PUBLIC TRIO_CONST char* trio_strerror TRIO_ARGS1((errorcode), int errorcode)\n{\n#if TRIO_FEATURE_STRERR\n\t/* Textual versions of the error codes */\n\tswitch (TRIO_ERROR_CODE(errorcode))\n\t{\n\t\tcase TRIO_EOF:\n\t\t\treturn \"End of file\";\n\t\tcase TRIO_EINVAL:\n\t\t\treturn \"Invalid argument\";\n\t\tcase TRIO_ETOOMANY:\n\t\t\treturn \"Too many arguments\";\n\t\tcase TRIO_EDBLREF:\n\t\t\treturn \"Double reference\";\n\t\tcase TRIO_EGAP:\n\t\t\treturn \"Reference gap\";\n\t\tcase TRIO_ENOMEM:\n\t\t\treturn \"Out of memory\";\n\t\tcase TRIO_ERANGE:\n\t\t\treturn \"Invalid range\";\n\t\tcase TRIO_ECUSTOM:\n\t\t\treturn \"Custom error\";\n\t\tdefault:\n\t\t\treturn \"Unknown\";\n\t}\n#else\n\treturn \"Unknown\";\n#endif\n}\n\n#ifdef _WIN32\n#pragma warning(pop)\n#endif\n", "/*************************************************************************\n *\n * $Id: triostr.c,v 1.36 2010/01/26 13:02:02 breese Exp $\n *\n * Copyright (C) 2001 Bjorn Reese and Daniel Stenberg.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE AUTHORS AND\n * CONTRIBUTORS ACCEPT NO RESPONSIBILITY IN ANY CONCEIVABLE MANNER.\n *\n ************************************************************************/\n\n/*************************************************************************\n * Include files\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config.h>\n#endif\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"triodef.h\"\n#include \"triostr.h\"\n#if defined(TRIO_FUNC_TO_LONG_DOUBLE)\n#define USE_MATH\n#endif\n#if defined(USE_MATH)\n#include <math.h>\n#endif\n\n/*************************************************************************\n * Definitions\n */\n\n#if !defined(TRIO_PUBLIC_STRING)\n#define TRIO_PUBLIC_STRING TRIO_PUBLIC\n#endif\n#if !defined(TRIO_PRIVATE_STRING)\n#define TRIO_PRIVATE_STRING TRIO_PRIVATE\n#endif\n\n#if !defined(NULL)\n#define NULL 0\n#endif\n#if !defined(NIL)\n#define NIL ((char)0)\n#endif\n#if !defined(FALSE)\n#define FALSE (1 == 0)\n#define TRUE (!FALSE)\n#endif\n#if !defined(BOOLEAN_T)\n#define BOOLEAN_T int\n#endif\n\n#if defined(USE_MATH)\n#if defined(PREDEF_STANDARD_C99)\n#if defined(TRIO_COMPILER_DECC)\n#if (TRIO_COMPILER_DECC - 0 > 80000000)\n/*\n * The OSF/1 runtime that comes with the DECC compiler does not support\n * hexfloats conversion.\n */\n#define USE_STRTOD\n#define USE_STRTOF\n#endif\n#else\n#define USE_STRTOD\n#define USE_STRTOF\n#endif\n#else\n#if defined(TRIO_COMPILER_VISUALC)\n#define USE_STRTOD\n#endif\n#endif\n#endif\n\n#if defined(TRIO_PLATFORM_UNIX)\n#if defined(PREDEF_STANDARD_UNIX95)\n#define USE_STRCASECMP\n#define USE_STRNCASECMP\n#endif\n#if defined(TRIO_PLATFORM_SUNOS)\n#define USE_SYS_ERRLIST\n#else\n#define USE_STRERROR\n#endif\n#if defined(TRIO_PLATFORM_QNX)\n#define strcasecmp(x, y) stricmp(x, y)\n#define strncasecmp(x, y, n) strnicmp(x, y, n)\n#endif\n#endif\n\n#if defined(TRIO_PLATFORM_WIN32)\n#define USE_STRCASECMP\n#if defined(TRIO_PLATFORM_WINCE)\n#define strcasecmp(x, y) _stricmp(x, y)\n#else\n#define strcasecmp(x, y) _stricmp(x, y)\n#endif\n#endif\n\n#if !defined(HAVE_CONFIG_H)\n#if !(defined(TRIO_PLATFORM_SUNOS))\n#define HAVE_TOLOWER\n#define HAVE_TOUPPER\n#endif\n#endif\n\n#if defined(USE_MATH) && !defined(TRIO_NO_POWL)\n#if !defined(HAVE_POWL)\n#if defined(PREDEF_STANDARD_C99) || defined(PREDEF_STANDARD_UNIX03)\n#define HAVE_POWL\n#else\n#if defined(TRIO_COMPILER_VISUALC)\n#if defined(powl)\n#define HAVE_POWL\n#endif\n#endif\n#endif\n#endif\n#endif\n\n#if defined(HAVE_POWL)\n#define trio_powl(x, y) powl((x), (y))\n#else\n#define trio_powl(x, y) pow((double)(x), (double)(y))\n#endif\n\n#if defined(TRIO_FUNC_TO_UPPER) || (defined(TRIO_FUNC_EQUAL) && !defined(USE_STRCASECMP)) ||   \\\n    (defined(TRIO_FUNC_EQUAL_MAX) && !defined(USE_STRNCASECMP)) || defined(TRIO_FUNC_MATCH) || \\\n    defined(TRIO_FUNC_TO_LONG_DOUBLE) || defined(TRIO_FUNC_UPPER)\n#define TRIO_FUNC_INTERNAL_TO_UPPER\n#endif\n\n/*************************************************************************\n * Structures\n */\n\nstruct _trio_string_t\n{\n\tchar* content;\n\tsize_t length;\n\tsize_t allocated;\n};\n\n/*************************************************************************\n * Constants\n */\n\n#if !defined(TRIO_EMBED_STRING)\n/* Unused but kept for reference */\n/* static TRIO_CONST char rcsid[] = \"@(#)$Id: triostr.c,v 1.36 2010/01/26 13:02:02 breese Exp $\"; */\n#endif\n\n/*************************************************************************\n * Static String Functions\n */\n\n#if defined(TRIO_DOCUMENTATION)\n#include \"doc/doc_static.h\"\n#endif\n/** @addtogroup StaticStrings\n    @{\n*/\n\n/*\n * internal_duplicate_max\n */\n#if defined(TRIO_FUNC_DUPLICATE) || defined(TRIO_FUNC_DUPLICATE_MAX) || \\\n    defined(TRIO_FUNC_STRING_DUPLICATE) || defined(TRIO_FUNC_XSTRING_DUPLICATE)\n\nTRIO_PRIVATE_STRING char* internal_duplicate_max TRIO_ARGS2((source, size), TRIO_CONST char* source,\n                                                            size_t size)\n{\n\tchar* target;\n\n\tassert(source);\n\n\t/* Make room for string plus a terminating zero */\n\tsize++;\n\ttarget = trio_create(size);\n\tif (target)\n\t{\n\t\ttrio_copy_max(target, size, source);\n\t}\n\treturn target;\n}\n\n#endif\n\n/*\n * internal_string_alloc\n */\n#if defined(TRIO_FUNC_STRING_CREATE) || defined(TRIO_FUNC_STRING_DUPLICATE) || \\\n    defined(TRIO_FUNC_XSTRING_DUPLICATE)\n\nTRIO_PRIVATE_STRING trio_string_t* internal_string_alloc(TRIO_NOARGS)\n{\n\ttrio_string_t* self;\n\n\tself = (trio_string_t*)TRIO_MALLOC(sizeof(trio_string_t));\n\tif (self)\n\t{\n\t\tself->content = NULL;\n\t\tself->length = 0;\n\t\tself->allocated = 0;\n\t}\n\treturn self;\n}\n\n#endif\n\n/*\n * internal_string_grow\n *\n * The size of the string will be increased by 'delta' characters. If\n * 'delta' is zero, the size will be doubled.\n */\n#if defined(TRIO_FUNC_STRING_CREATE) || defined(TRIO_FUNC_STRING_APPEND) || \\\n    defined(TRIO_FUNC_XSTRING_APPEND) || defined(TRIO_FUNC_XSTRING_APPEND_CHAR)\n\nTRIO_PRIVATE_STRING BOOLEAN_T internal_string_grow TRIO_ARGS2((self, delta), trio_string_t* self,\n                                                              size_t delta)\n{\n\tBOOLEAN_T status = FALSE;\n\tchar* new_content;\n\tsize_t new_size;\n\n\tnew_size =\n\t    (delta == 0) ? ((self->allocated == 0) ? 1 : self->allocated * 2) : self->allocated + delta;\n\n\tnew_content = (char*)TRIO_REALLOC(self->content, new_size);\n\tif (new_content)\n\t{\n\t\tself->content = new_content;\n\t\tself->allocated = new_size;\n\t\tstatus = TRUE;\n\t}\n\treturn status;\n}\n\n#endif\n\n/*\n * internal_string_grow_to\n *\n * The size of the string will be increased to 'length' plus one characters.\n * If 'length' is less than the original size, the original size will be\n * used (that is, the size of the string is never decreased).\n */\n#if defined(TRIO_FUNC_STRING_APPEND) || defined(TRIO_FUNC_XSTRING_APPEND) || \\\n    defined(TRIO_FUNC_XSTRING_APPEND_MAX)\n\nTRIO_PRIVATE_STRING BOOLEAN_T internal_string_grow_to TRIO_ARGS2((self, length),\n                                                                 trio_string_t* self, size_t length)\n{\n\tlength++; /* Room for terminating zero */\n\treturn (self->allocated < length) ? internal_string_grow(self, length - self->allocated) : TRUE;\n}\n\n#endif\n\n#if defined(TRIO_FUNC_INTERNAL_TO_UPPER)\n\nTRIO_PRIVATE_STRING TRIO_INLINE int internal_to_upper TRIO_ARGS1((source), int source)\n{\n#if defined(HAVE_TOUPPER)\n\n\treturn toupper(source);\n\n#else\n\n\t/* Does not handle locales or non-contiguous alphabetic characters */\n\treturn ((source >= (int)'a') && (source <= (int)'z')) ? source - 'a' + 'A' : source;\n\n#endif\n}\n\n#endif\n\n/**\n   Create new string.\n\n   @param size Size of new string.\n   @return Pointer to string, or NULL if allocation failed.\n*/\n#if defined(TRIO_FUNC_CREATE)\n\nTRIO_PUBLIC_STRING char* trio_create TRIO_ARGS1((size), size_t size)\n{\n\treturn (char*)TRIO_MALLOC(size);\n}\n\n#endif\n\n/**\n   Destroy string.\n\n   @param string String to be freed.\n*/\n#if defined(TRIO_FUNC_DESTROY)\n\nTRIO_PUBLIC_STRING void trio_destroy TRIO_ARGS1((string), char* string)\n{\n\tif (string)\n\t{\n\t\tTRIO_FREE(string);\n\t}\n}\n\n#endif\n\n/**\n   Count the number of characters in a string.\n\n   @param string String to measure.\n   @return Number of characters in @p string.\n*/\n#if defined(TRIO_FUNC_LENGTH)\n\nTRIO_PUBLIC_STRING size_t trio_length TRIO_ARGS1((string), TRIO_CONST char* string)\n{\n\treturn trio_length_max(string, INT_MAX);\n}\n\n#endif\n\n/**\n   Count at most @p max characters in a string.\n\n   @param string String to measure.\n   @param max Maximum number of characters to count.\n   @return The maximum value of @p max and number of characters in @p string.\n*/\n#if defined(TRIO_FUNC_LENGTH_MAX)\n\nTRIO_PUBLIC_STRING size_t trio_length_max TRIO_ARGS2((string, max), TRIO_CONST char* string,\n                                                     size_t max)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < max; ++i)\n\t{\n\t\tif (string[i] == 0)\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\n#endif\n\n/**\n   Append @p source at the end of @p target.\n\n   @param target Target string.\n   @param source Source string.\n   @return Boolean value indicating success or failure.\n\n   @pre @p target must point to a memory chunk with sufficient room to\n   contain the @p target string and @p source string.\n   @pre No boundary checking is performed, so insufficient memory will\n   result in a buffer overrun.\n   @post @p target will be zero terminated.\n*/\n#if defined(TRIO_FUNC_APPEND)\n\nTRIO_PUBLIC_STRING int trio_append TRIO_ARGS2((target, source), char* target,\n                                              TRIO_CONST char* source)\n{\n\tassert(target);\n\tassert(source);\n\n\treturn (strcat(target, source) != NULL);\n}\n\n#endif\n\n/**\n   Append at most @p max characters from @p source to @p target.\n\n   @param target Target string.\n   @param max Maximum number of characters to append.\n   @param source Source string.\n   @return Boolean value indicating success or failure.\n\n   @pre @p target must point to a memory chuck with sufficient room to\n   contain the @p target string and the @p source string (at most @p max\n   characters).\n   @pre No boundary checking is performed, so insufficient memory will\n   result in a buffer overrun.\n   @post @p target will be zero terminated.\n*/\n#if defined(TRIO_FUNC_APPEND_MAX)\n\nTRIO_PUBLIC_STRING int trio_append_max TRIO_ARGS3((target, max, source), char* target, size_t max,\n                                                  TRIO_CONST char* source)\n{\n\tsize_t length;\n\n\tassert(target);\n\tassert(source);\n\n\tlength = trio_length(target);\n\n\tif (max > length)\n\t{\n\t\tstrncat(target, source, max - length - 1);\n\t}\n\treturn TRUE;\n}\n\n#endif\n\n/**\n   Determine if a string contains a substring.\n\n   @param string String to be searched.\n   @param substring String to be found.\n   @return Boolean value indicating success or failure.\n*/\n#if defined(TRIO_FUNC_CONTAINS)\n\nTRIO_PUBLIC_STRING int trio_contains TRIO_ARGS2((string, substring), TRIO_CONST char* string,\n                                                TRIO_CONST char* substring)\n{\n\tassert(string);\n\tassert(substring);\n\n\treturn (0 != strstr(string, substring));\n}\n\n#endif\n\n/**\n   Copy @p source to @p target.\n\n   @param target Target string.\n   @param source Source string.\n   @return Boolean value indicating success or failure.\n\n   @pre @p target must point to a memory chunk with sufficient room to\n   contain the @p source string.\n   @pre No boundary checking is performed, so insufficient memory will\n   result in a buffer overrun.\n   @post @p target will be zero terminated.\n*/\n#if defined(TRIO_FUNC_COPY)\n\nTRIO_PUBLIC_STRING int trio_copy TRIO_ARGS2((target, source), char* target, TRIO_CONST char* source)\n{\n\tassert(target);\n\tassert(source);\n\n\t(void)strcpy(target, source);\n\treturn TRUE;\n}\n\n#endif\n\n/**\n   Copy at most @p max - 1 characters from @p source to @p target.\n\n   @param target Target string.\n   @param max Maximum number of characters to append (one of which is\n   a NUL terminator).  In other words @p source must point to at least\n   @p max - 1 bytes, but @p target must point to at least @p max\n   bytes.\n   @param source Source string.\n   @return Boolean value indicating success or failure.\n\n   @pre @p target must point to a memory chunk with sufficient room to\n   contain the @p source string and a NUL terminator (at most @p max\n   bytes total).\n   @pre No boundary checking is performed, so insufficient memory will\n   result in a buffer overrun.\n   @post @p target will be zero terminated.\n*/\n#if defined(TRIO_FUNC_COPY_MAX)\n\nTRIO_PUBLIC_STRING int trio_copy_max TRIO_ARGS3((target, max, source), char* target, size_t max,\n                                                TRIO_CONST char* source)\n{\n\tassert(target);\n\tassert(source);\n\tassert(max > 0); /* Includes != 0 */\n\n\t(void)strncpy(target, source, max - 1);\n\ttarget[max - 1] = (char)0;\n\treturn TRUE;\n}\n\n#endif\n\n/**\n   Duplicate @p source.\n\n   @param source Source string.\n   @return A copy of the @p source string.\n\n   @post @p target will be zero terminated.\n*/\n#if defined(TRIO_FUNC_DUPLICATE)\n\nTRIO_PUBLIC_STRING char* trio_duplicate TRIO_ARGS1((source), TRIO_CONST char* source)\n{\n\treturn internal_duplicate_max(source, trio_length(source));\n}\n\n#endif\n\n/**\n   Duplicate at most @p max characters of @p source.\n\n   @param source Source string.\n   @param max Maximum number of characters to duplicate.\n   @return A copy of the @p source string.\n\n   @post @p target will be zero terminated.\n*/\n#if defined(TRIO_FUNC_DUPLICATE_MAX)\n\nTRIO_PUBLIC_STRING char* trio_duplicate_max TRIO_ARGS2((source, max), TRIO_CONST char* source,\n                                                       size_t max)\n{\n\tsize_t length;\n\n\tassert(source);\n\tassert(max > 0);\n\n\tlength = trio_length(source);\n\tif (length > max)\n\t{\n\t\tlength = max;\n\t}\n\treturn internal_duplicate_max(source, length);\n}\n\n#endif\n\n/**\n   Compare if two strings are equal.\n\n   @param first First string.\n   @param second Second string.\n   @return Boolean indicating whether the two strings are equal or not.\n\n   Case-insensitive comparison.\n*/\n#if defined(TRIO_FUNC_EQUAL)\n\nTRIO_PUBLIC_STRING int trio_equal TRIO_ARGS2((first, second), TRIO_CONST char* first,\n                                             TRIO_CONST char* second)\n{\n\tassert(first);\n\tassert(second);\n\n\tif ((first != NULL) && (second != NULL))\n\t{\n#if defined(USE_STRCASECMP)\n\t\treturn (0 == strcasecmp(first, second));\n#else\n\t\twhile ((*first != NIL) && (*second != NIL))\n\t\t{\n\t\t\tif (internal_to_upper(*first) != internal_to_upper(*second))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfirst++;\n\t\t\tsecond++;\n\t\t}\n\t\treturn ((*first == NIL) && (*second == NIL));\n#endif\n\t}\n\treturn FALSE;\n}\n\n#endif\n\n/**\n   Compare if two strings are equal.\n\n   @param first First string.\n   @param second Second string.\n   @return Boolean indicating whether the two strings are equal or not.\n\n   Case-sensitive comparison.\n*/\n#if defined(TRIO_FUNC_EQUAL_CASE)\n\nTRIO_PUBLIC_STRING int trio_equal_case TRIO_ARGS2((first, second), TRIO_CONST char* first,\n                                                  TRIO_CONST char* second)\n{\n\tassert(first);\n\tassert(second);\n\n\tif ((first != NULL) && (second != NULL))\n\t{\n\t\treturn (0 == strcmp(first, second));\n\t}\n\treturn FALSE;\n}\n\n#endif\n\n/**\n   Compare if two strings up until the first @p max characters are equal.\n\n   @param first First string.\n   @param max Maximum number of characters to compare.\n   @param second Second string.\n   @return Boolean indicating whether the two strings are equal or not.\n\n   Case-sensitive comparison.\n*/\n#if defined(TRIO_FUNC_EQUAL_CASE_MAX)\n\nTRIO_PUBLIC_STRING int trio_equal_case_max TRIO_ARGS3((first, max, second), TRIO_CONST char* first,\n                                                      size_t max, TRIO_CONST char* second)\n{\n\tassert(first);\n\tassert(second);\n\n\tif ((first != NULL) && (second != NULL))\n\t{\n\t\treturn (0 == strncmp(first, second, max));\n\t}\n\treturn FALSE;\n}\n\n#endif\n\n/**\n   Compare if two strings are equal.\n\n   @param first First string.\n   @param second Second string.\n   @return Boolean indicating whether the two strings are equal or not.\n\n   Collating characters are considered equal.\n*/\n#if defined(TRIO_FUNC_EQUAL_LOCALE)\n\nTRIO_PUBLIC_STRING int trio_equal_locale TRIO_ARGS2((first, second), TRIO_CONST char* first,\n                                                    TRIO_CONST char* second)\n{\n\tassert(first);\n\tassert(second);\n\n#if defined(LC_COLLATE)\n\treturn (strcoll(first, second) == 0);\n#else\n\treturn trio_equal(first, second);\n#endif\n}\n\n#endif\n\n/**\n   Compare if two strings up until the first @p max characters are equal.\n\n   @param first First string.\n   @param max Maximum number of characters to compare.\n   @param second Second string.\n   @return Boolean indicating whether the two strings are equal or not.\n\n   Case-insensitive comparison.\n*/\n#if defined(TRIO_FUNC_EQUAL_MAX)\n\nTRIO_PUBLIC_STRING int trio_equal_max TRIO_ARGS3((first, max, second), TRIO_CONST char* first,\n                                                 size_t max, TRIO_CONST char* second)\n{\n\tassert(first);\n\tassert(second);\n\n\tif ((first != NULL) && (second != NULL))\n\t{\n#if defined(USE_STRNCASECMP)\n\t\treturn (0 == strncasecmp(first, second, max));\n#else\n\t\t/* Not adequately tested yet */\n\t\tsize_t cnt = 0;\n\t\twhile ((*first != NIL) && (*second != NIL) && (cnt <= max))\n\t\t{\n\t\t\tif (internal_to_upper(*first) != internal_to_upper(*second))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfirst++;\n\t\t\tsecond++;\n\t\t\tcnt++;\n\t\t}\n\t\treturn ((cnt == max) || ((*first == NIL) && (*second == NIL)));\n#endif\n\t}\n\treturn FALSE;\n}\n\n#endif\n\n/**\n   Provide a textual description of an error code (errno).\n\n   @param error_number Error number.\n   @return Textual description of @p error_number.\n*/\n#if defined(TRIO_FUNC_ERROR)\n\nTRIO_PUBLIC_STRING TRIO_CONST char* trio_error TRIO_ARGS1((error_number), int error_number)\n{\n#if defined(USE_STRERROR)\n\n\treturn strerror(error_number);\n\n#else\n#if defined(USE_SYS_ERRLIST)\n\n\textern char* sys_errlist[];\n\textern int sys_nerr;\n\n\treturn ((error_number < 0) || (error_number >= sys_nerr)) ? \"unknown\"\n\t                                                          : sys_errlist[error_number];\n\n#else\n\n\treturn \"unknown\";\n\n#endif\n#endif\n}\n\n#endif\n\n/**\n   Format the date/time according to @p format.\n\n   @param target Target string.\n   @param max Maximum number of characters to format.\n   @param format Formatting string.\n   @param datetime Date/time structure.\n   @return Number of formatted characters.\n\n   The formatting string accepts the same specifiers as the standard C\n   function strftime.\n*/\n#if defined(TRIO_FUNC_FORMAT_DATE_MAX)\n\nTRIO_PUBLIC_STRING size_t trio_format_date_max TRIO_ARGS4((target, max, format, datetime),\n                                                          char* target, size_t max,\n                                                          TRIO_CONST char* format,\n                                                          TRIO_CONST struct tm* datetime)\n{\n\tassert(target);\n\tassert(format);\n\tassert(datetime);\n\tassert(max > 0);\n\n\treturn strftime(target, max, format, datetime);\n}\n\n#endif\n\n/**\n   Calculate a hash value for a string.\n\n   @param string String to be calculated on.\n   @param type Hash function.\n   @return Calculated hash value.\n\n   @p type can be one of the following\n   @li @c TRIO_HASH_PLAIN Plain hash function.\n*/\n#if defined(TRIO_FUNC_HASH)\n\nTRIO_PUBLIC_STRING unsigned long trio_hash TRIO_ARGS2((string, type), TRIO_CONST char* string,\n                                                      int type)\n{\n\tunsigned long value = 0L;\n\tchar ch;\n\n\tassert(string);\n\n\tswitch (type)\n\t{\n\t\tcase TRIO_HASH_PLAIN:\n\t\t\twhile ((ch = *string++) != NIL)\n\t\t\t{\n\t\t\t\tvalue *= 31;\n\t\t\t\tvalue += (unsigned long)ch;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(FALSE);\n\t\t\tbreak;\n\t}\n\treturn value;\n}\n\n#endif\n\n/**\n   Find first occurrence of a character in a string.\n\n   @param string String to be searched.\n   @param character Character to be found.\n   @return A pointer to the found character, or NULL if character was not found.\n */\n#if defined(TRIO_FUNC_INDEX)\n\nTRIO_PUBLIC_STRING char* trio_index TRIO_ARGS2((string, character), TRIO_CONST char* string,\n                                               int character)\n{\n\tassert(string);\n\n\treturn strchr(string, character);\n}\n\n#endif\n\n/**\n   Find last occurrence of a character in a string.\n\n   @param string String to be searched.\n   @param character Character to be found.\n   @return A pointer to the found character, or NULL if character was not found.\n */\n#if defined(TRIO_FUNC_INDEX_LAST)\n\nTRIO_PUBLIC_STRING char* trio_index_last TRIO_ARGS2((string, character), TRIO_CONST char* string,\n                                                    int character)\n{\n\tassert(string);\n\n\treturn strchr(string, character);\n}\n\n#endif\n\n/**\n   Convert the alphabetic letters in the string to lower-case.\n\n   @param target String to be converted.\n   @return Number of processed characters (converted or not).\n*/\n#if defined(TRIO_FUNC_LOWER)\n\nTRIO_PUBLIC_STRING int trio_lower TRIO_ARGS1((target), char* target)\n{\n\tassert(target);\n\n\treturn trio_span_function(target, target, trio_to_lower);\n}\n\n#endif\n\n/**\n   Compare two strings using wildcards.\n\n   @param string String to be searched.\n   @param pattern Pattern, including wildcards, to search for.\n   @return Boolean value indicating success or failure.\n\n   Case-insensitive comparison.\n\n   The following wildcards can be used\n   @li @c * Match any number of characters.\n   @li @c ? Match a single character.\n*/\n#if defined(TRIO_FUNC_MATCH)\n\nTRIO_PUBLIC_STRING int trio_match TRIO_ARGS2((string, pattern), TRIO_CONST char* string,\n                                             TRIO_CONST char* pattern)\n{\n\tassert(string);\n\tassert(pattern);\n\n\tfor (; ('*' != *pattern); ++pattern, ++string)\n\t{\n\t\tif (NIL == *string)\n\t\t{\n\t\t\treturn (NIL == *pattern);\n\t\t}\n\t\tif ((internal_to_upper((int)*string) != internal_to_upper((int)*pattern)) &&\n\t\t    ('?' != *pattern))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\t/* two-line patch to prevent *too* much recursiveness: */\n\twhile ('*' == pattern[1])\n\t\tpattern++;\n\n\tdo\n\t{\n\t\tif (trio_match(string, &pattern[1]))\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\t} while (*string++);\n\n\treturn FALSE;\n}\n\n#endif\n\n/**\n   Compare two strings using wildcards.\n\n   @param string String to be searched.\n   @param pattern Pattern, including wildcards, to search for.\n   @return Boolean value indicating success or failure.\n\n   Case-sensitive comparison.\n\n   The following wildcards can be used\n   @li @c * Match any number of characters.\n   @li @c ? Match a single character.\n*/\n#if defined(TRIO_FUNC_MATCH_CASE)\n\nTRIO_PUBLIC_STRING int trio_match_case TRIO_ARGS2((string, pattern), TRIO_CONST char* string,\n                                                  TRIO_CONST char* pattern)\n{\n\tassert(string);\n\tassert(pattern);\n\n\tfor (; ('*' != *pattern); ++pattern, ++string)\n\t{\n\t\tif (NIL == *string)\n\t\t{\n\t\t\treturn (NIL == *pattern);\n\t\t}\n\t\tif ((*string != *pattern) && ('?' != *pattern))\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\t/* two-line patch to prevent *too* much recursiveness: */\n\twhile ('*' == pattern[1])\n\t\tpattern++;\n\n\tdo\n\t{\n\t\tif (trio_match_case(string, &pattern[1]))\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\t} while (*string++);\n\n\treturn FALSE;\n}\n\n#endif\n\n/**\n   Execute a function on each character in string.\n\n   @param target Target string.\n   @param source Source string.\n   @param Function Function to be executed.\n   @return Number of processed characters.\n*/\n#if defined(TRIO_FUNC_SPAN_FUNCTION)\n\nTRIO_PUBLIC_STRING size_t trio_span_function TRIO_ARGS3((target, source, Function), char* target,\n                                                        TRIO_CONST char* source,\n                                                        int(*Function) TRIO_PROTO((int)))\n{\n\tsize_t count = 0;\n\n\tassert(target);\n\tassert(source);\n\tassert(Function);\n\n\twhile (*source != NIL)\n\t{\n\t\t*target++ = Function(*source++);\n\t\tcount++;\n\t}\n\treturn count;\n}\n\n#endif\n\n/**\n   Search for a substring in a string.\n\n   @param string String to be searched.\n   @param substring String to be found.\n   @return Pointer to first occurrence of @p substring in @p string, or NULL\n   if no match was found.\n*/\n#if defined(TRIO_FUNC_SUBSTRING)\n\nTRIO_PUBLIC_STRING char* trio_substring TRIO_ARGS2((string, substring), TRIO_CONST char* string,\n                                                   TRIO_CONST char* substring)\n{\n\tassert(string);\n\tassert(substring);\n\n\treturn strstr(string, substring);\n}\n\n#endif\n\n/**\n   Search for a substring in the first @p max characters of a string.\n\n   @param string String to be searched.\n   @param max Maximum characters to be searched.\n   @param substring String to be found.\n   @return Pointer to first occurrence of @p substring in @p string, or NULL\n   if no match was found.\n*/\n#if defined(TRIO_FUNC_SUBSTRING_MAX)\n\nTRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),\n                                                       TRIO_CONST char* string, size_t max,\n                                                       TRIO_CONST char* substring)\n{\n\tsize_t count;\n\tsize_t size;\n\tchar* result = NULL;\n\n\tassert(string);\n\tassert(substring);\n\n\tsize = trio_length(substring);\n\tif (size <= max)\n\t{\n\t\tfor (count = 0; count <= max - size; count++)\n\t\t{\n\t\t\tif (trio_equal_max(substring, size, &string[count]))\n\t\t\t{\n\t\t\t\tresult = (char*)&string[count];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n#endif\n\n/**\n   Tokenize string.\n\n   @param string String to be tokenized.\n   @param delimiters String containing list of delimiting characters.\n   @return Start of new token.\n\n   @warning @p string will be destroyed.\n*/\n#if defined(TRIO_FUNC_TOKENIZE)\n\nTRIO_PUBLIC_STRING char* trio_tokenize TRIO_ARGS2((string, delimiters), char* string,\n                                                  TRIO_CONST char* delimiters)\n{\n\tassert(delimiters);\n\n\treturn strtok(string, delimiters);\n}\n\n#endif\n\n/**\n   Convert string to floating-point number.\n\n   @param source String to be converted.\n   @param endp Pointer to end of the converted string.\n   @return A floating-point number.\n\n   The following Extended Backus-Naur form is used\n   @verbatim\n   double        ::= [ <sign> ]\n                     ( <number> |\n                       <number> <decimal_point> <number> |\n                       <decimal_point> <number> )\n                     [ <exponential> [ <sign> ] <number> ]\n   number        ::= 1*( <digit> )\n   digit         ::= ( '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' )\n   exponential   ::= ( 'e' | 'E' )\n   sign          ::= ( '-' | '+' )\n   decimal_point ::= '.'\n   @endverbatim\n*/\n#if defined(TRIO_FUNC_TO_LONG_DOUBLE)\n\n/* FIXME: Add EBNF for hex-floats */\nTRIO_PUBLIC_STRING trio_long_double_t trio_to_long_double TRIO_ARGS2((source, endp),\n                                                                     TRIO_CONST char* source,\n                                                                     char** endp)\n{\n#if defined(USE_STRTOLD)\n\treturn strtold(source, endp);\n#else\n\tint isNegative = FALSE;\n\tint isExponentNegative = FALSE;\n\ttrio_long_double_t integer = 0.0;\n\ttrio_long_double_t fraction = 0.0;\n\tunsigned long exponent = 0;\n\ttrio_long_double_t base;\n\ttrio_long_double_t fracdiv = 1.0;\n\ttrio_long_double_t value = 0.0;\n\n\t/* First try hex-floats */\n\tif ((source[0] == '0') && ((source[1] == 'x') || (source[1] == 'X')))\n\t{\n\t\tbase = 16.0;\n\t\tsource += 2;\n\t\twhile (isxdigit((int)*source))\n\t\t{\n\t\t\tinteger *= base;\n\t\t\tinteger += (isdigit((int)*source) ? (*source - '0')\n\t\t\t                                  : 10 + (internal_to_upper((int)*source) - 'A'));\n\t\t\tsource++;\n\t\t}\n\t\tif (*source == '.')\n\t\t{\n\t\t\tsource++;\n\t\t\twhile (isxdigit((int)*source))\n\t\t\t{\n\t\t\t\tfracdiv /= base;\n\t\t\t\tfraction += fracdiv * (isdigit((int)*source)\n\t\t\t\t                           ? (*source - '0')\n\t\t\t\t                           : 10 + (internal_to_upper((int)*source) - 'A'));\n\t\t\t\tsource++;\n\t\t\t}\n\t\t\tif ((*source == 'p') || (*source == 'P'))\n\t\t\t{\n\t\t\t\tsource++;\n\t\t\t\tif ((*source == '+') || (*source == '-'))\n\t\t\t\t{\n\t\t\t\t\tisExponentNegative = (*source == '-');\n\t\t\t\t\tsource++;\n\t\t\t\t}\n\t\t\t\twhile (isdigit((int)*source))\n\t\t\t\t{\n\t\t\t\t\texponent *= 10;\n\t\t\t\t\texponent += (*source - '0');\n\t\t\t\t\tsource++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* For later use with exponent */\n\t\tbase = 2.0;\n\t}\n\telse /* Then try normal decimal floats */\n\t{\n\t\tbase = 10.0;\n\t\tisNegative = (*source == '-');\n\t\t/* Skip sign */\n\t\tif ((*source == '+') || (*source == '-'))\n\t\t\tsource++;\n\n\t\t/* Integer part */\n\t\twhile (isdigit((int)*source))\n\t\t{\n\t\t\tinteger *= base;\n\t\t\tinteger += (*source - '0');\n\t\t\tsource++;\n\t\t}\n\n\t\tif (*source == '.')\n\t\t{\n\t\t\tsource++; /* skip decimal point */\n\t\t\twhile (isdigit((int)*source))\n\t\t\t{\n\t\t\t\tfracdiv /= base;\n\t\t\t\tfraction += (*source - '0') * fracdiv;\n\t\t\t\tsource++;\n\t\t\t}\n\t\t}\n\t\tif ((*source == 'e') || (*source == 'E')\n#if TRIO_MICROSOFT\n\t\t    || (*source == 'd') || (*source == 'D')\n#endif\n\t\t)\n\t\t{\n\t\t\tsource++; /* Skip exponential indicator */\n\t\t\tisExponentNegative = (*source == '-');\n\t\t\tif ((*source == '+') || (*source == '-'))\n\t\t\t\tsource++;\n\t\t\twhile (isdigit((int)*source))\n\t\t\t{\n\t\t\t\texponent *= (int)base;\n\t\t\t\texponent += (*source - '0');\n\t\t\t\tsource++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvalue = integer + fraction;\n\tif (exponent != 0)\n\t{\n\t\tif (isExponentNegative)\n\t\t\tvalue /= trio_powl(base, (trio_long_double_t)exponent);\n\t\telse\n\t\t\tvalue *= trio_powl(base, (trio_long_double_t)exponent);\n\t}\n\tif (isNegative)\n\t\tvalue = -value;\n\n\tif (endp)\n\t\t*endp = (char*)source;\n\treturn value;\n#endif\n}\n\n#endif\n\n/**\n   Convert string to floating-point number.\n\n   @param source String to be converted.\n   @param endp Pointer to end of the converted string.\n   @return A floating-point number.\n\n   See @ref trio_to_long_double.\n*/\n#if defined(TRIO_FUNC_TO_DOUBLE)\n\nTRIO_PUBLIC_STRING double trio_to_double TRIO_ARGS2((source, endp), TRIO_CONST char* source,\n                                                    char** endp)\n{\n#if defined(USE_STRTOD)\n\treturn strtod(source, endp);\n#else\n\treturn (double)trio_to_long_double(source, endp);\n#endif\n}\n\n#endif\n\n/**\n   Convert string to floating-point number.\n\n   @param source String to be converted.\n   @param endp Pointer to end of the converted string.\n   @return A floating-point number.\n\n   See @ref trio_to_long_double.\n*/\n#if defined(TRIO_FUNC_TO_FLOAT)\n\nTRIO_PUBLIC_STRING float trio_to_float TRIO_ARGS2((source, endp), TRIO_CONST char* source,\n                                                  char** endp)\n{\n#if defined(USE_STRTOF)\n\treturn strtof(source, endp);\n#else\n\treturn (float)trio_to_long_double(source, endp);\n#endif\n}\n\n#endif\n\n/**\n   Convert string to signed integer.\n\n   @param string String to be converted.\n   @param endp Pointer to end of converted string.\n   @param base Radix number of number.\n*/\n#if defined(TRIO_FUNC_TO_LONG)\n\nTRIO_PUBLIC_STRING long trio_to_long TRIO_ARGS3((string, endp, base), TRIO_CONST char* string,\n                                                char** endp, int base)\n{\n\tassert(string);\n\tassert((base >= 2) && (base <= 36));\n\n\treturn strtol(string, endp, base);\n}\n\n#endif\n\n/**\n   Convert one alphabetic letter to lower-case.\n\n   @param source The letter to be converted.\n   @return The converted letter.\n*/\n#if defined(TRIO_FUNC_TO_LOWER)\n\nTRIO_PUBLIC_STRING int trio_to_lower TRIO_ARGS1((source), int source)\n{\n#if defined(HAVE_TOLOWER)\n\n\treturn tolower(source);\n\n#else\n\n\t/* Does not handle locales or non-contiguous alphabetic characters */\n\treturn ((source >= (int)'A') && (source <= (int)'Z')) ? source - 'A' + 'a' : source;\n\n#endif\n}\n\n#endif\n\n/**\n   Convert string to unsigned integer.\n\n   @param string String to be converted.\n   @param endp Pointer to end of converted string.\n   @param base Radix number of number.\n*/\n#if defined(TRIO_FUNC_TO_UNSIGNED_LONG)\n\nTRIO_PUBLIC_STRING unsigned long trio_to_unsigned_long TRIO_ARGS3((string, endp, base),\n                                                                  TRIO_CONST char* string,\n                                                                  char** endp, int base)\n{\n\tassert(string);\n\tassert((base >= 2) && (base <= 36));\n\n\treturn strtoul(string, endp, base);\n}\n\n#endif\n\n/**\n   Convert one alphabetic letter to upper-case.\n\n   @param source The letter to be converted.\n   @return The converted letter.\n*/\n#if defined(TRIO_FUNC_TO_UPPER)\n\nTRIO_PUBLIC_STRING int trio_to_upper TRIO_ARGS1((source), int source)\n{\n\treturn internal_to_upper(source);\n}\n\n#endif\n\n/**\n   Convert the alphabetic letters in the string to upper-case.\n\n   @param target The string to be converted.\n   @return The number of processed characters (converted or not).\n*/\n#if defined(TRIO_FUNC_UPPER)\n\nTRIO_PUBLIC_STRING int trio_upper TRIO_ARGS1((target), char* target)\n{\n\tassert(target);\n\n\treturn trio_span_function(target, target, internal_to_upper);\n}\n\n#endif\n\n/** @} End of StaticStrings */\n\n/*************************************************************************\n * Dynamic String Functions\n */\n\n#if defined(TRIO_DOCUMENTATION)\n#include \"doc/doc_dynamic.h\"\n#endif\n/** @addtogroup DynamicStrings\n    @{\n*/\n\n/**\n   Create a new dynamic string.\n\n   @param initial_size Initial size of the buffer.\n   @return Newly allocated dynamic string, or NULL if memory allocation failed.\n*/\n#if defined(TRIO_FUNC_STRING_CREATE)\n\nTRIO_PUBLIC_STRING trio_string_t* trio_string_create TRIO_ARGS1((initial_size), int initial_size)\n{\n\ttrio_string_t* self;\n\n\tself = internal_string_alloc();\n\tif (self)\n\t{\n\t\tif (internal_string_grow(self, (size_t)((initial_size > 0) ? initial_size : 1)))\n\t\t{\n\t\t\tself->content[0] = (char)0;\n\t\t\tself->allocated = initial_size;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttrio_string_destroy(self);\n\t\t\tself = NULL;\n\t\t}\n\t}\n\treturn self;\n}\n\n#endif\n\n/**\n   Deallocate the dynamic string and its contents.\n\n   @param self Dynamic string\n*/\n#if defined(TRIO_FUNC_STRING_DESTROY)\n\nTRIO_PUBLIC_STRING void trio_string_destroy TRIO_ARGS1((self), trio_string_t* self)\n{\n\tassert(self);\n\n\tif (self)\n\t{\n\t\ttrio_destroy(self->content);\n\t\tTRIO_FREE(self);\n\t}\n}\n\n#endif\n\n/**\n   Get a pointer to the content.\n\n   @param self Dynamic string.\n   @param offset Offset into content.\n   @return Pointer to the content.\n\n   @p Offset can be zero, positive, or negative. If @p offset is zero,\n   then the start of the content will be returned. If @p offset is positive,\n   then a pointer to @p offset number of characters from the beginning of the\n   content is returned. If @p offset is negative, then a pointer to @p offset\n   number of characters from the ending of the string, starting at the\n   terminating zero, is returned.\n*/\n#if defined(TRIO_FUNC_STRING_GET)\n\nTRIO_PUBLIC_STRING char* trio_string_get TRIO_ARGS2((self, offset), trio_string_t* self, int offset)\n{\n\tchar* result = NULL;\n\n\tassert(self);\n\n\tif (self->content != NULL)\n\t{\n\t\tif (self->length == 0)\n\t\t{\n\t\t\t(void)trio_string_length(self);\n\t\t}\n\t\tif (offset >= 0)\n\t\t{\n\t\t\tif (offset > (int)self->length)\n\t\t\t{\n\t\t\t\toffset = self->length;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\toffset += self->length + 1;\n\t\t\tif (offset < 0)\n\t\t\t{\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t}\n\t\tresult = &(self->content[offset]);\n\t}\n\treturn result;\n}\n\n#endif\n\n/**\n   Extract the content.\n\n   @param self Dynamic String\n   @return Content of dynamic string.\n\n   The content is removed from the dynamic string. This enables destruction\n   of the dynamic string without deallocation of the content.\n*/\n#if defined(TRIO_FUNC_STRING_EXTRACT)\n\nTRIO_PUBLIC_STRING char* trio_string_extract TRIO_ARGS1((self), trio_string_t* self)\n{\n\tchar* result;\n\n\tassert(self);\n\n\tresult = self->content;\n\t/* FIXME: Allocate new empty buffer? */\n\tself->content = NULL;\n\tself->length = self->allocated = 0;\n\treturn result;\n}\n\n#endif\n\n/**\n   Set the content of the dynamic string.\n\n   @param self Dynamic String\n   @param buffer The new content.\n\n   Sets the content of the dynamic string to a copy @p buffer.\n   An existing content will be deallocated first, if necessary.\n\n   @remark\n   This function will make a copy of @p buffer.\n   You are responsible for deallocating @p buffer yourself.\n*/\n#if defined(TRIO_FUNC_XSTRING_SET)\n\nTRIO_PUBLIC_STRING void trio_xstring_set TRIO_ARGS2((self, buffer), trio_string_t* self,\n                                                    char* buffer)\n{\n\tassert(self);\n\n\ttrio_destroy(self->content);\n\tself->content = trio_duplicate(buffer);\n}\n\n#endif\n\n/*\n * trio_string_size\n */\n#if defined(TRIO_FUNC_STRING_SIZE)\n\nTRIO_PUBLIC_STRING int trio_string_size TRIO_ARGS1((self), trio_string_t* self)\n{\n\tassert(self);\n\n\treturn self->allocated;\n}\n\n#endif\n\n/*\n * trio_string_terminate\n */\n#if defined(TRIO_FUNC_STRING_TERMINATE)\n\nTRIO_PUBLIC_STRING void trio_string_terminate TRIO_ARGS1((self), trio_string_t* self)\n{\n\ttrio_xstring_append_char(self, 0);\n}\n\n#endif\n\n/**\n   Append the second string to the first.\n\n   @param self Dynamic string to be modified.\n   @param other Dynamic string to copy from.\n   @return Boolean value indicating success or failure.\n*/\n#if defined(TRIO_FUNC_STRING_APPEND)\n\nTRIO_PUBLIC_STRING int trio_string_append TRIO_ARGS2((self, other), trio_string_t* self,\n                                                     trio_string_t* other)\n{\n\tsize_t length;\n\n\tassert(self);\n\tassert(other);\n\n\tlength = self->length + other->length;\n\tif (!internal_string_grow_to(self, length))\n\t\tgoto error;\n\ttrio_copy(&self->content[self->length], other->content);\n\tself->length = length;\n\treturn TRUE;\n\nerror:\n\treturn FALSE;\n}\n\n#endif\n\n/*\n * trio_xstring_append\n */\n#if defined(TRIO_FUNC_XSTRING_APPEND)\n\nTRIO_PUBLIC_STRING int trio_xstring_append TRIO_ARGS2((self, other), trio_string_t* self,\n                                                      TRIO_CONST char* other)\n{\n\tsize_t length;\n\n\tassert(self);\n\tassert(other);\n\n\tlength = self->length + trio_length(other);\n\tif (!internal_string_grow_to(self, length))\n\t\tgoto error;\n\ttrio_copy(&self->content[self->length], other);\n\tself->length = length;\n\treturn TRUE;\n\nerror:\n\treturn FALSE;\n}\n\n#endif\n\n/*\n * trio_xstring_append_char\n */\n#if defined(TRIO_FUNC_XSTRING_APPEND_CHAR)\n\nTRIO_PUBLIC_STRING int trio_xstring_append_char TRIO_ARGS2((self, character), trio_string_t* self,\n                                                           char character)\n{\n\tassert(self);\n\n\tif ((int)self->length >= trio_string_size(self))\n\t{\n\t\tif (!internal_string_grow(self, 0))\n\t\t\tgoto error;\n\t}\n\tself->content[self->length] = character;\n\tself->length++;\n\treturn TRUE;\n\nerror:\n\treturn FALSE;\n}\n\n#endif\n\n/*\n * trio_xstring_append_max\n */\n#if defined(TRIO_FUNC_XSTRING_APPEND_MAX)\n\nTRIO_PUBLIC_STRING int trio_xstring_append_max TRIO_ARGS3((self, other, max), trio_string_t* self,\n                                                          TRIO_CONST char* other, size_t max)\n{\n\tsize_t length;\n\n\tassert(self);\n\tassert(other);\n\n\tlength = self->length + trio_length_max(other, max);\n\tif (!internal_string_grow_to(self, length))\n\t\tgoto error;\n\n\t/*\n\t * Pass max + 1 since trio_copy_max copies one character less than\n\t * this from the source to make room for a terminating zero.\n\t */\n\ttrio_copy_max(&self->content[self->length], max + 1, other);\n\tself->length = length;\n\treturn TRUE;\n\nerror:\n\treturn FALSE;\n}\n\n#endif\n\n/**\n   Search for the first occurrence of second parameter in the first.\n\n   @param self Dynamic string to be modified.\n   @param other Dynamic string to copy from.\n   @return Boolean value indicating success or failure.\n*/\n#if defined(TRIO_FUNC_STRING_CONTAINS)\n\nTRIO_PUBLIC_STRING int trio_string_contains TRIO_ARGS2((self, other), trio_string_t* self,\n                                                       trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_contains(self->content, other->content);\n}\n\n#endif\n\n/*\n * trio_xstring_contains\n */\n#if defined(TRIO_FUNC_XSTRING_CONTAINS)\n\nTRIO_PUBLIC_STRING int trio_xstring_contains TRIO_ARGS2((self, other), trio_string_t* self,\n                                                        TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_contains(self->content, other);\n}\n\n#endif\n\n/*\n * trio_string_copy\n */\n#if defined(TRIO_FUNC_STRING_COPY)\n\nTRIO_PUBLIC_STRING int trio_string_copy TRIO_ARGS2((self, other), trio_string_t* self,\n                                                   trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\tself->length = 0;\n\treturn trio_string_append(self, other);\n}\n\n#endif\n\n/*\n * trio_xstring_copy\n */\n#if defined(TRIO_FUNC_XSTRING_COPY)\n\nTRIO_PUBLIC_STRING int trio_xstring_copy TRIO_ARGS2((self, other), trio_string_t* self,\n                                                    TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\tself->length = 0;\n\treturn trio_xstring_append(self, other);\n}\n\n#endif\n\n/*\n * trio_string_duplicate\n */\n#if defined(TRIO_FUNC_STRING_DUPLICATE)\n\nTRIO_PUBLIC_STRING trio_string_t* trio_string_duplicate TRIO_ARGS1((other), trio_string_t* other)\n{\n\ttrio_string_t* self;\n\n\tassert(other);\n\n\tself = internal_string_alloc();\n\tif (self)\n\t{\n\t\tself->content = internal_duplicate_max(other->content, other->length);\n\t\tif (self->content)\n\t\t{\n\t\t\tself->length = other->length;\n\t\t\tself->allocated = self->length + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself->length = self->allocated = 0;\n\t\t}\n\t}\n\treturn self;\n}\n\n#endif\n\n/*\n * trio_xstring_duplicate\n */\n#if defined(TRIO_FUNC_XSTRING_DUPLICATE)\n\nTRIO_PUBLIC_STRING trio_string_t* trio_xstring_duplicate TRIO_ARGS1((other), TRIO_CONST char* other)\n{\n\ttrio_string_t* self;\n\n\tassert(other);\n\n\tself = internal_string_alloc();\n\tif (self)\n\t{\n\t\tself->content = internal_duplicate_max(other, trio_length(other));\n\t\tif (self->content)\n\t\t{\n\t\t\tself->length = trio_length(self->content);\n\t\t\tself->allocated = self->length + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tself->length = self->allocated = 0;\n\t\t}\n\t}\n\treturn self;\n}\n\n#endif\n\n/*\n * trio_string_equal\n */\n#if defined(TRIO_FUNC_STRING_EQUAL)\n\nTRIO_PUBLIC_STRING int trio_string_equal TRIO_ARGS2((self, other), trio_string_t* self,\n                                                    trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal(self->content, other->content);\n}\n\n#endif\n\n/*\n * trio_xstring_equal\n */\n#if defined(TRIO_FUNC_XSTRING_EQUAL)\n\nTRIO_PUBLIC_STRING int trio_xstring_equal TRIO_ARGS2((self, other), trio_string_t* self,\n                                                     TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal(self->content, other);\n}\n\n#endif\n\n/*\n * trio_string_equal_max\n */\n#if defined(TRIO_FUNC_STRING_EQUAL_MAX)\n\nTRIO_PUBLIC_STRING int trio_string_equal_max TRIO_ARGS3((self, max, other), trio_string_t* self,\n                                                        size_t max, trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal_max(self->content, max, other->content);\n}\n#endif\n\n/*\n * trio_xstring_equal_max\n */\n#if defined(TRIO_FUNC_XSTRING_EQUAL_MAX)\n\nTRIO_PUBLIC_STRING int trio_xstring_equal_max TRIO_ARGS3((self, max, other), trio_string_t* self,\n                                                         size_t max, TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal_max(self->content, max, other);\n}\n\n#endif\n\n/*\n * trio_string_equal_case\n */\n#if defined(TRIO_FUNC_STRING_EQUAL_CASE)\n\nTRIO_PUBLIC_STRING int trio_string_equal_case TRIO_ARGS2((self, other), trio_string_t* self,\n                                                         trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal_case(self->content, other->content);\n}\n\n#endif\n\n/*\n * trio_xstring_equal_case\n */\n#if defined(TRIO_FUNC_XSTRING_EQUAL_CASE)\n\nTRIO_PUBLIC_STRING int trio_xstring_equal_case TRIO_ARGS2((self, other), trio_string_t* self,\n                                                          TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal_case(self->content, other);\n}\n\n#endif\n\n/*\n * trio_string_equal_case_max\n */\n#if defined(TRIO_FUNC_STRING_EQUAL_CASE_MAX)\n\nTRIO_PUBLIC_STRING int trio_string_equal_case_max TRIO_ARGS3((self, max, other),\n                                                             trio_string_t* self, size_t max,\n                                                             trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal_case_max(self->content, max, other->content);\n}\n\n#endif\n\n/*\n * trio_xstring_equal_case_max\n */\n#if defined(TRIO_FUNC_XSTRING_EQUAL_CASE_MAX)\n\nTRIO_PUBLIC_STRING int trio_xstring_equal_case_max TRIO_ARGS3((self, max, other),\n                                                              trio_string_t* self, size_t max,\n                                                              TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_equal_case_max(self->content, max, other);\n}\n\n#endif\n\n/*\n * trio_string_format_data_max\n */\n#if defined(TRIO_FUNC_STRING_FORMAT_DATE_MAX)\n\nTRIO_PUBLIC_STRING size_t trio_string_format_date_max TRIO_ARGS4((self, max, format, datetime),\n                                                                 trio_string_t* self, size_t max,\n                                                                 TRIO_CONST char* format,\n                                                                 TRIO_CONST struct tm* datetime)\n{\n\tassert(self);\n\n\treturn trio_format_date_max(self->content, max, format, datetime);\n}\n\n#endif\n\n/*\n * trio_string_index\n */\n#if defined(TRIO_FUNC_STRING_INDEX)\n\nTRIO_PUBLIC_STRING char* trio_string_index TRIO_ARGS2((self, character), trio_string_t* self,\n                                                      int character)\n{\n\tassert(self);\n\n\treturn trio_index(self->content, character);\n}\n\n#endif\n\n/*\n * trio_string_index_last\n */\n#if defined(TRIO_FUNC_STRING_INDEX_LAST)\n\nTRIO_PUBLIC_STRING char* trio_string_index_last TRIO_ARGS2((self, character), trio_string_t* self,\n                                                           int character)\n{\n\tassert(self);\n\n\treturn trio_index_last(self->content, character);\n}\n\n#endif\n\n/*\n * trio_string_length\n */\n#if defined(TRIO_FUNC_STRING_LENGTH)\n\nTRIO_PUBLIC_STRING int trio_string_length TRIO_ARGS1((self), trio_string_t* self)\n{\n\tassert(self);\n\n\tif (self->length == 0)\n\t{\n\t\tself->length = trio_length(self->content);\n\t}\n\treturn self->length;\n}\n\n#endif\n\n/*\n * trio_string_lower\n */\n#if defined(TRIO_FUNC_STRING_LOWER)\n\nTRIO_PUBLIC_STRING int trio_string_lower TRIO_ARGS1((self), trio_string_t* self)\n{\n\tassert(self);\n\n\treturn trio_lower(self->content);\n}\n\n#endif\n\n/*\n * trio_string_match\n */\n#if defined(TRIO_FUNC_STRING_MATCH)\n\nTRIO_PUBLIC_STRING int trio_string_match TRIO_ARGS2((self, other), trio_string_t* self,\n                                                    trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_match(self->content, other->content);\n}\n\n#endif\n\n/*\n * trio_xstring_match\n */\n#if defined(TRIO_FUNC_XSTRING_MATCH)\n\nTRIO_PUBLIC_STRING int trio_xstring_match TRIO_ARGS2((self, other), trio_string_t* self,\n                                                     TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_match(self->content, other);\n}\n\n#endif\n\n/*\n * trio_string_match_case\n */\n#if defined(TRIO_FUNC_STRING_MATCH_CASE)\n\nTRIO_PUBLIC_STRING int trio_string_match_case TRIO_ARGS2((self, other), trio_string_t* self,\n                                                         trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_match_case(self->content, other->content);\n}\n\n#endif\n\n/*\n * trio_xstring_match_case\n */\n#if defined(TRIO_FUNC_XSTRING_MATCH_CASE)\n\nTRIO_PUBLIC_STRING int trio_xstring_match_case TRIO_ARGS2((self, other), trio_string_t* self,\n                                                          TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_match_case(self->content, other);\n}\n\n#endif\n\n/*\n * trio_string_substring\n */\n#if defined(TRIO_FUNC_STRING_SUBSTRING)\n\nTRIO_PUBLIC_STRING char* trio_string_substring TRIO_ARGS2((self, other), trio_string_t* self,\n                                                          trio_string_t* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_substring(self->content, other->content);\n}\n\n#endif\n\n/*\n * trio_xstring_substring\n */\n#if defined(TRIO_FUNC_XSTRING_SUBSTRING)\n\nTRIO_PUBLIC_STRING char* trio_xstring_substring TRIO_ARGS2((self, other), trio_string_t* self,\n                                                           TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_substring(self->content, other);\n}\n\n#endif\n\n/*\n * trio_string_upper\n */\n#if defined(TRIO_FUNC_STRING_UPPER)\n\nTRIO_PUBLIC_STRING int trio_string_upper TRIO_ARGS1((self), trio_string_t* self)\n{\n\tassert(self);\n\n\treturn trio_upper(self->content);\n}\n\n#endif\n\n/** @} End of DynamicStrings */\n"], "buggy_code_start_loc": [2732, 27], "buggy_code_end_loc": [4758, 332], "fixing_code_start_loc": [2732, 28], "fixing_code_end_loc": [4758, 333], "type": "CWE-190", "message": "In FreeRDP before version 2.1.2, there is an out of bounds read in TrioParse. Logging might bypass string length checks due to an integer overflow. This is fixed in version 2.1.2.", "other": {"cve": {"id": "CVE-2020-4030", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-22T22:15:13.087", "lastModified": "2021-10-07T17:22:48.070", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP before version 2.1.2, there is an out of bounds read in TrioParse. Logging might bypass string length checks due to an integer overflow. This is fixed in version 2.1.2."}, {"lang": "es", "value": "En FreeRDP versiones anteriores a 2.1.2, se presenta una lectura fuera de l\u00edmites en TrioParse. El registro puede omitir las comprobaciones de longitud de cadena debido a un desbordamiento de enteros. Esto es corregido en la versi\u00f3n 2.1.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.2", "matchCriteriaId": "DDAC8E89-8F23-4799-AA42-AD419455D1F6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00080.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.freerdp.com/2020/06/22/2_1_2-released", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/05cd9ea2290d23931f615c1b004d4b2e69074e27", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-fjr5-97f5-qq98", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6Y35HBHG2INICLSGCIKNAR7GCXEHQACQ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XOZLH35OJWIQLM7FYDXAP2EAUBDXE76V/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4481-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/05cd9ea2290d23931f615c1b004d4b2e69074e27"}}