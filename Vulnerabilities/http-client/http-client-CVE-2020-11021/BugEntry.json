{"buggy_code": ["import * as httpm from '../_out'\nimport * as ifm from '../_out/interfaces'\nimport * as path from 'path'\nimport * as fs from 'fs'\n\nlet sampleFilePath: string = path.join(__dirname, 'testoutput.txt')\n\ninterface HttpBinData {\n  url: string\n  data: any\n  json: any\n  headers: any\n  args?: any\n}\n\ndescribe('basics', () => {\n  let _http: httpm.HttpClient\n\n  beforeEach(() => {\n    _http = new httpm.HttpClient('http-client-tests')\n  })\n\n  afterEach(() => {})\n\n  it('constructs', () => {\n    let http: httpm.HttpClient = new httpm.HttpClient('thttp-client-tests')\n    expect(http).toBeDefined()\n  })\n\n  // responses from httpbin return something like:\n  // {\n  //     \"args\": {},\n  //     \"headers\": {\n  //       \"Connection\": \"close\",\n  //       \"Host\": \"httpbin.org\",\n  //       \"User-Agent\": \"typed-test-client-tests\"\n  //     },\n  //     \"origin\": \"173.95.152.44\",\n  //     \"url\": \"https://httpbin.org/get\"\n  //  }\n\n  it('does basic http get request', async done => {\n    let res: httpm.HttpClientResponse = await _http.get(\n      'http://httpbin.org/get'\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.url).toBe('http://httpbin.org/get')\n    expect(obj.headers['User-Agent']).toBeTruthy()\n    done()\n  })\n\n  it('does basic http get request with no user agent', async done => {\n    let http: httpm.HttpClient = new httpm.HttpClient()\n    let res: httpm.HttpClientResponse = await http.get('http://httpbin.org/get')\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.url).toBe('http://httpbin.org/get')\n    expect(obj.headers['User-Agent']).toBeFalsy()\n    done()\n  })\n\n  it('does basic https get request', async done => {\n    let res: httpm.HttpClientResponse = await _http.get(\n      'https://httpbin.org/get'\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.url).toBe('https://httpbin.org/get')\n    done()\n  })\n\n  it('does basic http get request with default headers', async done => {\n    let http: httpm.HttpClient = new httpm.HttpClient('http-client-tests', [], {\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n      }\n    })\n    let res: httpm.HttpClientResponse = await http.get('http://httpbin.org/get')\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.headers.Accept).toBe('application/json')\n    expect(obj.headers['Content-Type']).toBe('application/json')\n    expect(obj.url).toBe('http://httpbin.org/get')\n    done()\n  })\n\n  it('does basic http get request with merged headers', async done => {\n    let http: httpm.HttpClient = new httpm.HttpClient('http-client-tests', [], {\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n      }\n    })\n    let res: httpm.HttpClientResponse = await http.get(\n      'http://httpbin.org/get',\n      {\n        'content-type': 'application/x-www-form-urlencoded'\n      }\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.headers.Accept).toBe('application/json')\n    expect(obj.headers['Content-Type']).toBe(\n      'application/x-www-form-urlencoded'\n    )\n    expect(obj.url).toBe('http://httpbin.org/get')\n    done()\n  })\n\n  it('pipes a get request', () => {\n    return new Promise<string>(async (resolve, reject) => {\n      let file: NodeJS.WritableStream = fs.createWriteStream(sampleFilePath)\n      ;(await _http.get('https://httpbin.org/get')).message\n        .pipe(file)\n        .on('close', () => {\n          let body: string = fs.readFileSync(sampleFilePath).toString()\n          let obj: any = JSON.parse(body)\n          expect(obj.url).toBe('https://httpbin.org/get')\n          resolve()\n        })\n    })\n  })\n\n  it('does basic get request with redirects', async done => {\n    let res: httpm.HttpClientResponse = await _http.get(\n      'https://httpbin.org/redirect-to?url=' +\n        encodeURIComponent('https://httpbin.org/get')\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.url).toBe('https://httpbin.org/get')\n    done()\n  })\n\n  it('does basic get request with redirects (303)', async done => {\n    let res: httpm.HttpClientResponse = await _http.get(\n      'https://httpbin.org/redirect-to?url=' +\n        encodeURIComponent('https://httpbin.org/get') +\n        '&status_code=303'\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.url).toBe('https://httpbin.org/get')\n    done()\n  })\n\n  it('returns 404 for not found get request on redirect', async done => {\n    let res: httpm.HttpClientResponse = await _http.get(\n      'https://httpbin.org/redirect-to?url=' +\n        encodeURIComponent('https://httpbin.org/status/404') +\n        '&status_code=303'\n    )\n    expect(res.message.statusCode).toBe(404)\n    let body: string = await res.readBody()\n    done()\n  })\n\n  it('does not follow redirects if disabled', async done => {\n    let http: httpm.HttpClient = new httpm.HttpClient(\n      'typed-test-client-tests',\n      null,\n      {allowRedirects: false}\n    )\n    let res: httpm.HttpClientResponse = await http.get(\n      'https://httpbin.org/redirect-to?url=' +\n        encodeURIComponent('https://httpbin.org/get')\n    )\n    expect(res.message.statusCode).toBe(302)\n    let body: string = await res.readBody()\n    done()\n  })\n\n  it('does basic head request', async done => {\n    let res: httpm.HttpClientResponse = await _http.head(\n      'http://httpbin.org/get'\n    )\n    expect(res.message.statusCode).toBe(200)\n    done()\n  })\n\n  it('does basic http delete request', async done => {\n    let res: httpm.HttpClientResponse = await _http.del(\n      'http://httpbin.org/delete'\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    done()\n  })\n\n  it('does basic http post request', async done => {\n    let b: string = 'Hello World!'\n    let res: httpm.HttpClientResponse = await _http.post(\n      'http://httpbin.org/post',\n      b\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.data).toBe(b)\n    expect(obj.url).toBe('http://httpbin.org/post')\n    done()\n  })\n\n  it('does basic http patch request', async done => {\n    let b: string = 'Hello World!'\n    let res: httpm.HttpClientResponse = await _http.patch(\n      'http://httpbin.org/patch',\n      b\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.data).toBe(b)\n    expect(obj.url).toBe('http://httpbin.org/patch')\n    done()\n  })\n\n  it('does basic http options request', async done => {\n    let res: httpm.HttpClientResponse = await _http.options(\n      'http://httpbin.org'\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    done()\n  })\n\n  it('returns 404 for not found get request', async done => {\n    let res: httpm.HttpClientResponse = await _http.get(\n      'http://httpbin.org/status/404'\n    )\n    expect(res.message.statusCode).toBe(404)\n    let body: string = await res.readBody()\n    done()\n  })\n\n  it('gets a json object', async () => {\n    let jsonObj: ifm.ITypedResponse<HttpBinData> = await _http.getJson<\n      HttpBinData\n    >('https://httpbin.org/get')\n    expect(jsonObj.statusCode).toBe(200)\n    expect(jsonObj.result).toBeDefined()\n    expect(jsonObj.result.url).toBe('https://httpbin.org/get')\n    expect(jsonObj.result.headers['Accept']).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n    expect(jsonObj.headers[httpm.Headers.ContentType]).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n  })\n\n  it('getting a non existent json object returns null', async () => {\n    let jsonObj: ifm.ITypedResponse<HttpBinData> = await _http.getJson<\n      HttpBinData\n    >('https://httpbin.org/status/404')\n    expect(jsonObj.statusCode).toBe(404)\n    expect(jsonObj.result).toBeNull()\n  })\n\n  it('posts a json object', async () => {\n    let res: any = {name: 'foo'}\n    let restRes: ifm.ITypedResponse<HttpBinData> = await _http.postJson<\n      HttpBinData\n    >('https://httpbin.org/post', res)\n    expect(restRes.statusCode).toBe(200)\n    expect(restRes.result).toBeDefined()\n    expect(restRes.result.url).toBe('https://httpbin.org/post')\n    expect(restRes.result.json.name).toBe('foo')\n    expect(restRes.result.headers['Accept']).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n    expect(restRes.result.headers['Content-Type']).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n    expect(restRes.headers[httpm.Headers.ContentType]).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n  })\n\n  it('puts a json object', async () => {\n    let res: any = {name: 'foo'}\n    let restRes: ifm.ITypedResponse<HttpBinData> = await _http.putJson<\n      HttpBinData\n    >('https://httpbin.org/put', res)\n    expect(restRes.statusCode).toBe(200)\n    expect(restRes.result).toBeDefined()\n    expect(restRes.result.url).toBe('https://httpbin.org/put')\n    expect(restRes.result.json.name).toBe('foo')\n\n    expect(restRes.result.headers['Accept']).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n    expect(restRes.result.headers['Content-Type']).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n    expect(restRes.headers[httpm.Headers.ContentType]).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n  })\n\n  it('patch a json object', async () => {\n    let res: any = {name: 'foo'}\n    let restRes: ifm.ITypedResponse<HttpBinData> = await _http.patchJson<\n      HttpBinData\n    >('https://httpbin.org/patch', res)\n    expect(restRes.statusCode).toBe(200)\n    expect(restRes.result).toBeDefined()\n    expect(restRes.result.url).toBe('https://httpbin.org/patch')\n    expect(restRes.result.json.name).toBe('foo')\n    expect(restRes.result.headers['Accept']).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n    expect(restRes.result.headers['Content-Type']).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n    expect(restRes.headers[httpm.Headers.ContentType]).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n  })\n})\n", "import url = require('url')\nimport http = require('http')\nimport https = require('https')\nimport ifm = require('./interfaces')\nimport pm = require('./proxy')\n\nlet tunnel: any\n\nexport enum HttpCodes {\n  OK = 200,\n  MultipleChoices = 300,\n  MovedPermanently = 301,\n  ResourceMoved = 302,\n  SeeOther = 303,\n  NotModified = 304,\n  UseProxy = 305,\n  SwitchProxy = 306,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n  BadRequest = 400,\n  Unauthorized = 401,\n  PaymentRequired = 402,\n  Forbidden = 403,\n  NotFound = 404,\n  MethodNotAllowed = 405,\n  NotAcceptable = 406,\n  ProxyAuthenticationRequired = 407,\n  RequestTimeout = 408,\n  Conflict = 409,\n  Gone = 410,\n  TooManyRequests = 429,\n  InternalServerError = 500,\n  NotImplemented = 501,\n  BadGateway = 502,\n  ServiceUnavailable = 503,\n  GatewayTimeout = 504\n}\n\nexport enum Headers {\n  Accept = 'accept',\n  ContentType = 'content-type'\n}\n\nexport enum MediaTypes {\n  ApplicationJson = 'application/json'\n}\n\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nexport function getProxyUrl(serverUrl: string): string {\n  let proxyUrl = pm.getProxyUrl(url.parse(serverUrl))\n  return proxyUrl ? proxyUrl.href : ''\n}\n\nconst HttpRedirectCodes: number[] = [\n  HttpCodes.MovedPermanently,\n  HttpCodes.ResourceMoved,\n  HttpCodes.SeeOther,\n  HttpCodes.TemporaryRedirect,\n  HttpCodes.PermanentRedirect\n]\nconst HttpResponseRetryCodes: number[] = [\n  HttpCodes.BadGateway,\n  HttpCodes.ServiceUnavailable,\n  HttpCodes.GatewayTimeout\n]\nconst RetryableHttpVerbs: string[] = ['OPTIONS', 'GET', 'DELETE', 'HEAD']\nconst ExponentialBackoffCeiling = 10\nconst ExponentialBackoffTimeSlice = 5\n\nexport class HttpClientResponse implements ifm.IHttpClientResponse {\n  constructor(message: http.IncomingMessage) {\n    this.message = message\n  }\n\n  public message: http.IncomingMessage\n  readBody(): Promise<string> {\n    return new Promise<string>(async (resolve, reject) => {\n      let output = Buffer.alloc(0)\n\n      this.message.on('data', (chunk: Buffer) => {\n        output = Buffer.concat([output, chunk])\n      })\n\n      this.message.on('end', () => {\n        resolve(output.toString())\n      })\n    })\n  }\n}\n\nexport function isHttps(requestUrl: string) {\n  let parsedUrl: url.Url = url.parse(requestUrl)\n  return parsedUrl.protocol === 'https:'\n}\n\nexport class HttpClient {\n  userAgent: string | undefined\n  handlers: ifm.IRequestHandler[]\n  requestOptions: ifm.IRequestOptions\n\n  private _ignoreSslError: boolean = false\n  private _socketTimeout: number\n  private _allowRedirects: boolean = true\n  private _allowRedirectDowngrade: boolean = false\n  private _maxRedirects: number = 50\n  private _allowRetries: boolean = false\n  private _maxRetries: number = 1\n  private _agent\n  private _proxyAgent\n  private _keepAlive: boolean = false\n  private _disposed: boolean = false\n\n  constructor(\n    userAgent?: string,\n    handlers?: ifm.IRequestHandler[],\n    requestOptions?: ifm.IRequestOptions\n  ) {\n    this.userAgent = userAgent\n    this.handlers = handlers || []\n    this.requestOptions = requestOptions\n    if (requestOptions) {\n      if (requestOptions.ignoreSslError != null) {\n        this._ignoreSslError = requestOptions.ignoreSslError\n      }\n\n      this._socketTimeout = requestOptions.socketTimeout\n\n      if (requestOptions.allowRedirects != null) {\n        this._allowRedirects = requestOptions.allowRedirects\n      }\n\n      if (requestOptions.allowRedirectDowngrade != null) {\n        this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade\n      }\n\n      if (requestOptions.maxRedirects != null) {\n        this._maxRedirects = Math.max(requestOptions.maxRedirects, 0)\n      }\n\n      if (requestOptions.keepAlive != null) {\n        this._keepAlive = requestOptions.keepAlive\n      }\n\n      if (requestOptions.allowRetries != null) {\n        this._allowRetries = requestOptions.allowRetries\n      }\n\n      if (requestOptions.maxRetries != null) {\n        this._maxRetries = requestOptions.maxRetries\n      }\n    }\n  }\n\n  public options(\n    requestUrl: string,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request('OPTIONS', requestUrl, null, additionalHeaders || {})\n  }\n\n  public get(\n    requestUrl: string,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request('GET', requestUrl, null, additionalHeaders || {})\n  }\n\n  public del(\n    requestUrl: string,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request('DELETE', requestUrl, null, additionalHeaders || {})\n  }\n\n  public post(\n    requestUrl: string,\n    data: string,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request('POST', requestUrl, data, additionalHeaders || {})\n  }\n\n  public patch(\n    requestUrl: string,\n    data: string,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request('PATCH', requestUrl, data, additionalHeaders || {})\n  }\n\n  public put(\n    requestUrl: string,\n    data: string,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request('PUT', requestUrl, data, additionalHeaders || {})\n  }\n\n  public head(\n    requestUrl: string,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request('HEAD', requestUrl, null, additionalHeaders || {})\n  }\n\n  public sendStream(\n    verb: string,\n    requestUrl: string,\n    stream: NodeJS.ReadableStream,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request(verb, requestUrl, stream, additionalHeaders)\n  }\n\n  /**\n   * Gets a typed object from an endpoint\n   * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n   */\n  public async getJson<T>(\n    requestUrl: string,\n    additionalHeaders: ifm.IHeaders = {}\n  ): Promise<ifm.ITypedResponse<T>> {\n    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(\n      additionalHeaders,\n      Headers.Accept,\n      MediaTypes.ApplicationJson\n    )\n    let res: ifm.IHttpClientResponse = await this.get(\n      requestUrl,\n      additionalHeaders\n    )\n    return this._processResponse<T>(res, this.requestOptions)\n  }\n\n  public async postJson<T>(\n    requestUrl: string,\n    obj: any,\n    additionalHeaders: ifm.IHeaders = {}\n  ): Promise<ifm.ITypedResponse<T>> {\n    let data: string = JSON.stringify(obj, null, 2)\n    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(\n      additionalHeaders,\n      Headers.Accept,\n      MediaTypes.ApplicationJson\n    )\n    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(\n      additionalHeaders,\n      Headers.ContentType,\n      MediaTypes.ApplicationJson\n    )\n    let res: ifm.IHttpClientResponse = await this.post(\n      requestUrl,\n      data,\n      additionalHeaders\n    )\n    return this._processResponse<T>(res, this.requestOptions)\n  }\n\n  public async putJson<T>(\n    requestUrl: string,\n    obj: any,\n    additionalHeaders: ifm.IHeaders = {}\n  ): Promise<ifm.ITypedResponse<T>> {\n    let data: string = JSON.stringify(obj, null, 2)\n    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(\n      additionalHeaders,\n      Headers.Accept,\n      MediaTypes.ApplicationJson\n    )\n    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(\n      additionalHeaders,\n      Headers.ContentType,\n      MediaTypes.ApplicationJson\n    )\n    let res: ifm.IHttpClientResponse = await this.put(\n      requestUrl,\n      data,\n      additionalHeaders\n    )\n    return this._processResponse<T>(res, this.requestOptions)\n  }\n\n  public async patchJson<T>(\n    requestUrl: string,\n    obj: any,\n    additionalHeaders: ifm.IHeaders = {}\n  ): Promise<ifm.ITypedResponse<T>> {\n    let data: string = JSON.stringify(obj, null, 2)\n    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(\n      additionalHeaders,\n      Headers.Accept,\n      MediaTypes.ApplicationJson\n    )\n    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(\n      additionalHeaders,\n      Headers.ContentType,\n      MediaTypes.ApplicationJson\n    )\n    let res: ifm.IHttpClientResponse = await this.patch(\n      requestUrl,\n      data,\n      additionalHeaders\n    )\n    return this._processResponse<T>(res, this.requestOptions)\n  }\n\n  /**\n   * Makes a raw http request.\n   * All other methods such as get, post, patch, and request ultimately call this.\n   * Prefer get, del, post and patch\n   */\n  public async request(\n    verb: string,\n    requestUrl: string,\n    data: string | NodeJS.ReadableStream,\n    headers: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    if (this._disposed) {\n      throw new Error('Client has already been disposed.')\n    }\n\n    let parsedUrl = url.parse(requestUrl)\n    let info: ifm.IRequestInfo = this._prepareRequest(verb, parsedUrl, headers)\n\n    // Only perform retries on reads since writes may not be idempotent.\n    let maxTries: number =\n      this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1\n        ? this._maxRetries + 1\n        : 1\n    let numTries: number = 0\n\n    let response: HttpClientResponse\n    while (numTries < maxTries) {\n      response = await this.requestRaw(info, data)\n\n      // Check if it's an authentication challenge\n      if (\n        response &&\n        response.message &&\n        response.message.statusCode === HttpCodes.Unauthorized\n      ) {\n        let authenticationHandler: ifm.IRequestHandler\n\n        for (let i = 0; i < this.handlers.length; i++) {\n          if (this.handlers[i].canHandleAuthentication(response)) {\n            authenticationHandler = this.handlers[i]\n            break\n          }\n        }\n\n        if (authenticationHandler) {\n          return authenticationHandler.handleAuthentication(this, info, data)\n        } else {\n          // We have received an unauthorized response but have no handlers to handle it.\n          // Let the response return to the caller.\n          return response\n        }\n      }\n\n      let redirectsRemaining: number = this._maxRedirects\n      while (\n        HttpRedirectCodes.indexOf(response.message.statusCode) != -1 &&\n        this._allowRedirects &&\n        redirectsRemaining > 0\n      ) {\n        const redirectUrl: string | null = response.message.headers['location']\n        if (!redirectUrl) {\n          // if there's no location to redirect to, we won't\n          break\n        }\n        let parsedRedirectUrl = url.parse(redirectUrl)\n        if (\n          parsedUrl.protocol == 'https:' &&\n          parsedUrl.protocol != parsedRedirectUrl.protocol &&\n          !this._allowRedirectDowngrade\n        ) {\n          throw new Error(\n            'Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.'\n          )\n        }\n\n        // we need to finish reading the response before reassigning response\n        // which will leak the open socket.\n        await response.readBody()\n\n        // let's make the request with the new redirectUrl\n        info = this._prepareRequest(verb, parsedRedirectUrl, headers)\n        response = await this.requestRaw(info, data)\n        redirectsRemaining--\n      }\n\n      if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {\n        // If not a retry code, return immediately instead of retrying\n        return response\n      }\n\n      numTries += 1\n\n      if (numTries < maxTries) {\n        await response.readBody()\n        await this._performExponentialBackoff(numTries)\n      }\n    }\n\n    return response\n  }\n\n  /**\n   * Needs to be called if keepAlive is set to true in request options.\n   */\n  public dispose() {\n    if (this._agent) {\n      this._agent.destroy()\n    }\n\n    this._disposed = true\n  }\n\n  /**\n   * Raw request.\n   * @param info\n   * @param data\n   */\n  public requestRaw(\n    info: ifm.IRequestInfo,\n    data: string | NodeJS.ReadableStream\n  ): Promise<ifm.IHttpClientResponse> {\n    return new Promise<ifm.IHttpClientResponse>((resolve, reject) => {\n      let callbackForResult = function (\n        err: any,\n        res: ifm.IHttpClientResponse\n      ) {\n        if (err) {\n          reject(err)\n        }\n\n        resolve(res)\n      }\n\n      this.requestRawWithCallback(info, data, callbackForResult)\n    })\n  }\n\n  /**\n   * Raw request with callback.\n   * @param info\n   * @param data\n   * @param onResult\n   */\n  public requestRawWithCallback(\n    info: ifm.IRequestInfo,\n    data: string | NodeJS.ReadableStream,\n    onResult: (err: any, res: ifm.IHttpClientResponse) => void\n  ): void {\n    let socket\n\n    if (typeof data === 'string') {\n      info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8')\n    }\n\n    let callbackCalled: boolean = false\n    let handleResult = (err: any, res: HttpClientResponse) => {\n      if (!callbackCalled) {\n        callbackCalled = true\n        onResult(err, res)\n      }\n    }\n\n    let req: http.ClientRequest = info.httpModule.request(\n      info.options,\n      (msg: http.IncomingMessage) => {\n        let res: HttpClientResponse = new HttpClientResponse(msg)\n        handleResult(null, res)\n      }\n    )\n\n    req.on('socket', sock => {\n      socket = sock\n    })\n\n    // If we ever get disconnected, we want the socket to timeout eventually\n    req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n      if (socket) {\n        socket.end()\n      }\n      handleResult(new Error('Request timeout: ' + info.options.path), null)\n    })\n\n    req.on('error', function (err) {\n      // err has statusCode property\n      // res should have headers\n      handleResult(err, null)\n    })\n\n    if (data && typeof data === 'string') {\n      req.write(data, 'utf8')\n    }\n\n    if (data && typeof data !== 'string') {\n      data.on('close', function () {\n        req.end()\n      })\n\n      data.pipe(req)\n    } else {\n      req.end()\n    }\n  }\n\n  /**\n   * Gets an http agent. This function is useful when you need an http agent that handles\n   * routing through a proxy server - depending upon the url and proxy environment variables.\n   * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n   */\n  public getAgent(serverUrl: string): http.Agent {\n    let parsedUrl = url.parse(serverUrl)\n    return this._getAgent(parsedUrl)\n  }\n\n  private _prepareRequest(\n    method: string,\n    requestUrl: url.Url,\n    headers: ifm.IHeaders\n  ): ifm.IRequestInfo {\n    const info: ifm.IRequestInfo = <ifm.IRequestInfo>{}\n\n    info.parsedUrl = requestUrl\n    const usingSsl: boolean = info.parsedUrl.protocol === 'https:'\n    info.httpModule = usingSsl ? https : http\n    const defaultPort: number = usingSsl ? 443 : 80\n\n    info.options = <http.RequestOptions>{}\n    info.options.host = info.parsedUrl.hostname\n    info.options.port = info.parsedUrl.port\n      ? parseInt(info.parsedUrl.port)\n      : defaultPort\n    info.options.path =\n      (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '')\n    info.options.method = method\n    info.options.headers = this._mergeHeaders(headers)\n    if (this.userAgent != null) {\n      info.options.headers['user-agent'] = this.userAgent\n    }\n\n    info.options.agent = this._getAgent(info.parsedUrl)\n\n    // gives handlers an opportunity to participate\n    if (this.handlers) {\n      this.handlers.forEach(handler => {\n        handler.prepareRequest(info.options)\n      })\n    }\n\n    return info\n  }\n\n  private _mergeHeaders(headers: ifm.IHeaders): ifm.IHeaders {\n    const lowercaseKeys = obj =>\n      Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {})\n\n    if (this.requestOptions && this.requestOptions.headers) {\n      return Object.assign(\n        {},\n        lowercaseKeys(this.requestOptions.headers),\n        lowercaseKeys(headers)\n      )\n    }\n\n    return lowercaseKeys(headers || {})\n  }\n\n  private _getExistingOrDefaultHeader(\n    additionalHeaders: ifm.IHeaders,\n    header: string,\n    _default: string\n  ) {\n    const lowercaseKeys = obj =>\n      Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {})\n\n    let clientHeader: string\n    if (this.requestOptions && this.requestOptions.headers) {\n      clientHeader = lowercaseKeys(this.requestOptions.headers)[header]\n    }\n    return additionalHeaders[header] || clientHeader || _default\n  }\n\n  private _getAgent(parsedUrl: url.Url): http.Agent {\n    let agent\n    let proxyUrl: url.Url = pm.getProxyUrl(parsedUrl)\n    let useProxy = proxyUrl && proxyUrl.hostname\n\n    if (this._keepAlive && useProxy) {\n      agent = this._proxyAgent\n    }\n\n    if (this._keepAlive && !useProxy) {\n      agent = this._agent\n    }\n\n    // if agent is already assigned use that agent.\n    if (!!agent) {\n      return agent\n    }\n\n    const usingSsl = parsedUrl.protocol === 'https:'\n    let maxSockets = 100\n    if (!!this.requestOptions) {\n      maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets\n    }\n\n    if (useProxy) {\n      // If using proxy, need tunnel\n      if (!tunnel) {\n        tunnel = require('tunnel')\n      }\n\n      const agentOptions = {\n        maxSockets: maxSockets,\n        keepAlive: this._keepAlive,\n        proxy: {\n          proxyAuth: proxyUrl.auth,\n          host: proxyUrl.hostname,\n          port: proxyUrl.port\n        }\n      }\n\n      let tunnelAgent: Function\n      const overHttps = proxyUrl.protocol === 'https:'\n      if (usingSsl) {\n        tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp\n      } else {\n        tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp\n      }\n\n      agent = tunnelAgent(agentOptions)\n      this._proxyAgent = agent\n    }\n\n    // if reusing agent across request and tunneling agent isn't assigned create a new agent\n    if (this._keepAlive && !agent) {\n      const options = {keepAlive: this._keepAlive, maxSockets: maxSockets}\n      agent = usingSsl ? new https.Agent(options) : new http.Agent(options)\n      this._agent = agent\n    }\n\n    // if not using private agent and tunnel agent isn't setup then use global agent\n    if (!agent) {\n      agent = usingSsl ? https.globalAgent : http.globalAgent\n    }\n\n    if (usingSsl && this._ignoreSslError) {\n      // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n      // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n      // we have to cast it to any and change it directly\n      agent.options = Object.assign(agent.options || {}, {\n        rejectUnauthorized: false\n      })\n    }\n\n    return agent\n  }\n\n  private _performExponentialBackoff(retryNumber: number): Promise<void> {\n    retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber)\n    const ms: number = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber)\n    return new Promise(resolve => setTimeout(() => resolve(), ms))\n  }\n\n  private static dateTimeDeserializer(key: any, value: any): any {\n    if (typeof value === 'string') {\n      let a = new Date(value)\n      if (!isNaN(a.valueOf())) {\n        return a\n      }\n    }\n\n    return value\n  }\n\n  private async _processResponse<T>(\n    res: ifm.IHttpClientResponse,\n    options: ifm.IRequestOptions\n  ): Promise<ifm.ITypedResponse<T>> {\n    return new Promise<ifm.ITypedResponse<T>>(async (resolve, reject) => {\n      const statusCode: number = res.message.statusCode\n\n      const response: ifm.ITypedResponse<T> = {\n        statusCode: statusCode,\n        result: null,\n        headers: {}\n      }\n\n      // not found leads to null obj returned\n      if (statusCode == HttpCodes.NotFound) {\n        resolve(response)\n      }\n\n      let obj: any\n      let contents: string\n\n      // get the result from the body\n      try {\n        contents = await res.readBody()\n        if (contents && contents.length > 0) {\n          if (options && options.deserializeDates) {\n            obj = JSON.parse(contents, HttpClient.dateTimeDeserializer)\n          } else {\n            obj = JSON.parse(contents)\n          }\n\n          response.result = obj\n        }\n\n        response.headers = res.message.headers\n      } catch (err) {\n        // Invalid resource (contents not json);  leaving result obj null\n      }\n\n      // note that 3xx redirects are handled by the http layer.\n      if (statusCode > 299) {\n        let msg: string\n\n        // if exception/error in body, attempt to get better error\n        if (obj && obj.message) {\n          msg = obj.message\n        } else if (contents && contents.length > 0) {\n          // it may be the case that the exception is in the body message as string\n          msg = contents\n        } else {\n          msg = 'Failed request: (' + statusCode + ')'\n        }\n\n        let err: Error = new Error(msg)\n\n        // attach statusCode and body obj (if available) to the error object\n        err['statusCode'] = statusCode\n        if (response.result) {\n          err['result'] = response.result\n        }\n\n        reject(err)\n      } else {\n        resolve(response)\n      }\n    })\n  }\n}\n", "{\n  \"name\": \"@actions/http-client\",\n  \"version\": \"1.0.7\",\n  \"description\": \"Actions Http Client\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"build\": \"rm -Rf ./_out && tsc && cp package*.json ./_out && cp *.md ./_out && cp LICENSE ./_out && cp actions.png ./_out\",\n    \"test\": \"jest\",\n    \"format\": \"prettier --write *.ts && prettier --write **/*.ts\",\n    \"format-check\": \"prettier --check *.ts && prettier --check **/*.ts\",\n    \"audit-check\": \"npm audit --audit-level=moderate\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/actions/http-client.git\"\n  },\n  \"keywords\": [\n    \"Actions\",\n    \"Http\"\n  ],\n  \"author\": \"GitHub, Inc.\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/actions/http-client/issues\"\n  },\n  \"homepage\": \"https://github.com/actions/http-client#readme\",\n  \"devDependencies\": {\n    \"@types/jest\": \"^25.1.4\",\n    \"@types/node\": \"^12.12.31\",\n    \"jest\": \"^25.1.0\",\n    \"prettier\": \"^2.0.4\",\n    \"proxy\": \"^1.0.1\",\n    \"ts-jest\": \"^25.2.1\",\n    \"typescript\": \"^3.8.3\"\n  },\n  \"dependencies\": {\n    \"tunnel\": \"0.0.6\"\n  }\n}\n"], "fixing_code": ["import * as httpm from '../_out'\nimport * as ifm from '../_out/interfaces'\nimport * as path from 'path'\nimport * as fs from 'fs'\n\nlet sampleFilePath: string = path.join(__dirname, 'testoutput.txt')\n\ninterface HttpBinData {\n  url: string\n  data: any\n  json: any\n  headers: any\n  args?: any\n}\n\ndescribe('basics', () => {\n  let _http: httpm.HttpClient\n\n  beforeEach(() => {\n    _http = new httpm.HttpClient('http-client-tests')\n  })\n\n  afterEach(() => {})\n\n  it('constructs', () => {\n    let http: httpm.HttpClient = new httpm.HttpClient('thttp-client-tests')\n    expect(http).toBeDefined()\n  })\n\n  // responses from httpbin return something like:\n  // {\n  //     \"args\": {},\n  //     \"headers\": {\n  //       \"Connection\": \"close\",\n  //       \"Host\": \"httpbin.org\",\n  //       \"User-Agent\": \"typed-test-client-tests\"\n  //     },\n  //     \"origin\": \"173.95.152.44\",\n  //     \"url\": \"https://httpbin.org/get\"\n  //  }\n\n  it('does basic http get request', async done => {\n    let res: httpm.HttpClientResponse = await _http.get(\n      'http://httpbin.org/get'\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.url).toBe('http://httpbin.org/get')\n    expect(obj.headers['User-Agent']).toBeTruthy()\n    done()\n  })\n\n  it('does basic http get request with no user agent', async done => {\n    let http: httpm.HttpClient = new httpm.HttpClient()\n    let res: httpm.HttpClientResponse = await http.get('http://httpbin.org/get')\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.url).toBe('http://httpbin.org/get')\n    expect(obj.headers['User-Agent']).toBeFalsy()\n    done()\n  })\n\n  it('does basic https get request', async done => {\n    let res: httpm.HttpClientResponse = await _http.get(\n      'https://httpbin.org/get'\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.url).toBe('https://httpbin.org/get')\n    done()\n  })\n\n  it('does basic http get request with default headers', async done => {\n    let http: httpm.HttpClient = new httpm.HttpClient('http-client-tests', [], {\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n      }\n    })\n    let res: httpm.HttpClientResponse = await http.get('http://httpbin.org/get')\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.headers.Accept).toBe('application/json')\n    expect(obj.headers['Content-Type']).toBe('application/json')\n    expect(obj.url).toBe('http://httpbin.org/get')\n    done()\n  })\n\n  it('does basic http get request with merged headers', async done => {\n    let http: httpm.HttpClient = new httpm.HttpClient('http-client-tests', [], {\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n      }\n    })\n    let res: httpm.HttpClientResponse = await http.get(\n      'http://httpbin.org/get',\n      {\n        'content-type': 'application/x-www-form-urlencoded'\n      }\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.headers.Accept).toBe('application/json')\n    expect(obj.headers['Content-Type']).toBe(\n      'application/x-www-form-urlencoded'\n    )\n    expect(obj.url).toBe('http://httpbin.org/get')\n    done()\n  })\n\n  it('pipes a get request', () => {\n    return new Promise<string>(async (resolve, reject) => {\n      let file: NodeJS.WritableStream = fs.createWriteStream(sampleFilePath)\n      ;(await _http.get('https://httpbin.org/get')).message\n        .pipe(file)\n        .on('close', () => {\n          let body: string = fs.readFileSync(sampleFilePath).toString()\n          let obj: any = JSON.parse(body)\n          expect(obj.url).toBe('https://httpbin.org/get')\n          resolve()\n        })\n    })\n  })\n\n  it('does basic get request with redirects', async done => {\n    let res: httpm.HttpClientResponse = await _http.get(\n      'https://httpbin.org/redirect-to?url=' +\n        encodeURIComponent('https://httpbin.org/get')\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.url).toBe('https://httpbin.org/get')\n    done()\n  })\n\n  it('does basic get request with redirects (303)', async done => {\n    let res: httpm.HttpClientResponse = await _http.get(\n      'https://httpbin.org/redirect-to?url=' +\n        encodeURIComponent('https://httpbin.org/get') +\n        '&status_code=303'\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.url).toBe('https://httpbin.org/get')\n    done()\n  })\n\n  it('returns 404 for not found get request on redirect', async done => {\n    let res: httpm.HttpClientResponse = await _http.get(\n      'https://httpbin.org/redirect-to?url=' +\n        encodeURIComponent('https://httpbin.org/status/404') +\n        '&status_code=303'\n    )\n    expect(res.message.statusCode).toBe(404)\n    let body: string = await res.readBody()\n    done()\n  })\n\n  it('does not follow redirects if disabled', async done => {\n    let http: httpm.HttpClient = new httpm.HttpClient(\n      'typed-test-client-tests',\n      null,\n      {allowRedirects: false}\n    )\n    let res: httpm.HttpClientResponse = await http.get(\n      'https://httpbin.org/redirect-to?url=' +\n        encodeURIComponent('https://httpbin.org/get')\n    )\n    expect(res.message.statusCode).toBe(302)\n    let body: string = await res.readBody()\n    done()\n  })\n\n  it('does not pass auth with diff hostname redirects', async done => {\n    let headers = {\n      accept: 'application/json',\n      authorization: 'shhh'\n    }\n    let res: httpm.HttpClientResponse = await _http.get(\n      'https://httpbin.org/redirect-to?url=' +\n        encodeURIComponent('https://www.httpbin.org/get'),\n      headers\n    )\n\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    // httpbin \"fixes\" the casing\n    expect(obj.headers['Accept']).toBe('application/json')\n    expect(obj.headers['Authorization']).toBeUndefined()\n    expect(obj.headers['authorization']).toBeUndefined()\n    expect(obj.url).toBe('https://www.httpbin.org/get')\n\n    done()\n  })\n\n  it('does not pass Auth with diff hostname redirects', async done => {\n    let headers = {\n      Accept: 'application/json',\n      Authorization: 'shhh'\n    }\n    let res: httpm.HttpClientResponse = await _http.get(\n      'https://httpbin.org/redirect-to?url=' +\n        encodeURIComponent('https://www.httpbin.org/get'),\n      headers\n    )\n\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    // httpbin \"fixes\" the casing\n    expect(obj.headers['Accept']).toBe('application/json')\n    expect(obj.headers['Authorization']).toBeUndefined()\n    expect(obj.headers['authorization']).toBeUndefined()\n    expect(obj.url).toBe('https://www.httpbin.org/get')\n\n    done()\n  })\n\n  it('does basic head request', async done => {\n    let res: httpm.HttpClientResponse = await _http.head(\n      'http://httpbin.org/get'\n    )\n    expect(res.message.statusCode).toBe(200)\n    done()\n  })\n\n  it('does basic http delete request', async done => {\n    let res: httpm.HttpClientResponse = await _http.del(\n      'http://httpbin.org/delete'\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    done()\n  })\n\n  it('does basic http post request', async done => {\n    let b: string = 'Hello World!'\n    let res: httpm.HttpClientResponse = await _http.post(\n      'http://httpbin.org/post',\n      b\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.data).toBe(b)\n    expect(obj.url).toBe('http://httpbin.org/post')\n    done()\n  })\n\n  it('does basic http patch request', async done => {\n    let b: string = 'Hello World!'\n    let res: httpm.HttpClientResponse = await _http.patch(\n      'http://httpbin.org/patch',\n      b\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    let obj: any = JSON.parse(body)\n    expect(obj.data).toBe(b)\n    expect(obj.url).toBe('http://httpbin.org/patch')\n    done()\n  })\n\n  it('does basic http options request', async done => {\n    let res: httpm.HttpClientResponse = await _http.options(\n      'http://httpbin.org'\n    )\n    expect(res.message.statusCode).toBe(200)\n    let body: string = await res.readBody()\n    done()\n  })\n\n  it('returns 404 for not found get request', async done => {\n    let res: httpm.HttpClientResponse = await _http.get(\n      'http://httpbin.org/status/404'\n    )\n    expect(res.message.statusCode).toBe(404)\n    let body: string = await res.readBody()\n    done()\n  })\n\n  it('gets a json object', async () => {\n    let jsonObj: ifm.ITypedResponse<HttpBinData> = await _http.getJson<\n      HttpBinData\n    >('https://httpbin.org/get')\n    expect(jsonObj.statusCode).toBe(200)\n    expect(jsonObj.result).toBeDefined()\n    expect(jsonObj.result.url).toBe('https://httpbin.org/get')\n    expect(jsonObj.result.headers['Accept']).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n    expect(jsonObj.headers[httpm.Headers.ContentType]).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n  })\n\n  it('getting a non existent json object returns null', async () => {\n    let jsonObj: ifm.ITypedResponse<HttpBinData> = await _http.getJson<\n      HttpBinData\n    >('https://httpbin.org/status/404')\n    expect(jsonObj.statusCode).toBe(404)\n    expect(jsonObj.result).toBeNull()\n  })\n\n  it('posts a json object', async () => {\n    let res: any = {name: 'foo'}\n    let restRes: ifm.ITypedResponse<HttpBinData> = await _http.postJson<\n      HttpBinData\n    >('https://httpbin.org/post', res)\n    expect(restRes.statusCode).toBe(200)\n    expect(restRes.result).toBeDefined()\n    expect(restRes.result.url).toBe('https://httpbin.org/post')\n    expect(restRes.result.json.name).toBe('foo')\n    expect(restRes.result.headers['Accept']).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n    expect(restRes.result.headers['Content-Type']).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n    expect(restRes.headers[httpm.Headers.ContentType]).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n  })\n\n  it('puts a json object', async () => {\n    let res: any = {name: 'foo'}\n    let restRes: ifm.ITypedResponse<HttpBinData> = await _http.putJson<\n      HttpBinData\n    >('https://httpbin.org/put', res)\n    expect(restRes.statusCode).toBe(200)\n    expect(restRes.result).toBeDefined()\n    expect(restRes.result.url).toBe('https://httpbin.org/put')\n    expect(restRes.result.json.name).toBe('foo')\n\n    expect(restRes.result.headers['Accept']).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n    expect(restRes.result.headers['Content-Type']).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n    expect(restRes.headers[httpm.Headers.ContentType]).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n  })\n\n  it('patch a json object', async () => {\n    let res: any = {name: 'foo'}\n    let restRes: ifm.ITypedResponse<HttpBinData> = await _http.patchJson<\n      HttpBinData\n    >('https://httpbin.org/patch', res)\n    expect(restRes.statusCode).toBe(200)\n    expect(restRes.result).toBeDefined()\n    expect(restRes.result.url).toBe('https://httpbin.org/patch')\n    expect(restRes.result.json.name).toBe('foo')\n    expect(restRes.result.headers['Accept']).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n    expect(restRes.result.headers['Content-Type']).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n    expect(restRes.headers[httpm.Headers.ContentType]).toBe(\n      httpm.MediaTypes.ApplicationJson\n    )\n  })\n})\n", "import url = require('url')\nimport http = require('http')\nimport https = require('https')\nimport ifm = require('./interfaces')\nimport pm = require('./proxy')\n\nlet tunnel: any\n\nexport enum HttpCodes {\n  OK = 200,\n  MultipleChoices = 300,\n  MovedPermanently = 301,\n  ResourceMoved = 302,\n  SeeOther = 303,\n  NotModified = 304,\n  UseProxy = 305,\n  SwitchProxy = 306,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n  BadRequest = 400,\n  Unauthorized = 401,\n  PaymentRequired = 402,\n  Forbidden = 403,\n  NotFound = 404,\n  MethodNotAllowed = 405,\n  NotAcceptable = 406,\n  ProxyAuthenticationRequired = 407,\n  RequestTimeout = 408,\n  Conflict = 409,\n  Gone = 410,\n  TooManyRequests = 429,\n  InternalServerError = 500,\n  NotImplemented = 501,\n  BadGateway = 502,\n  ServiceUnavailable = 503,\n  GatewayTimeout = 504\n}\n\nexport enum Headers {\n  Accept = 'accept',\n  ContentType = 'content-type'\n}\n\nexport enum MediaTypes {\n  ApplicationJson = 'application/json'\n}\n\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nexport function getProxyUrl(serverUrl: string): string {\n  let proxyUrl = pm.getProxyUrl(url.parse(serverUrl))\n  return proxyUrl ? proxyUrl.href : ''\n}\n\nconst HttpRedirectCodes: number[] = [\n  HttpCodes.MovedPermanently,\n  HttpCodes.ResourceMoved,\n  HttpCodes.SeeOther,\n  HttpCodes.TemporaryRedirect,\n  HttpCodes.PermanentRedirect\n]\nconst HttpResponseRetryCodes: number[] = [\n  HttpCodes.BadGateway,\n  HttpCodes.ServiceUnavailable,\n  HttpCodes.GatewayTimeout\n]\nconst RetryableHttpVerbs: string[] = ['OPTIONS', 'GET', 'DELETE', 'HEAD']\nconst ExponentialBackoffCeiling = 10\nconst ExponentialBackoffTimeSlice = 5\n\nexport class HttpClientResponse implements ifm.IHttpClientResponse {\n  constructor(message: http.IncomingMessage) {\n    this.message = message\n  }\n\n  public message: http.IncomingMessage\n  readBody(): Promise<string> {\n    return new Promise<string>(async (resolve, reject) => {\n      let output = Buffer.alloc(0)\n\n      this.message.on('data', (chunk: Buffer) => {\n        output = Buffer.concat([output, chunk])\n      })\n\n      this.message.on('end', () => {\n        resolve(output.toString())\n      })\n    })\n  }\n}\n\nexport function isHttps(requestUrl: string) {\n  let parsedUrl: url.Url = url.parse(requestUrl)\n  return parsedUrl.protocol === 'https:'\n}\n\nexport class HttpClient {\n  userAgent: string | undefined\n  handlers: ifm.IRequestHandler[]\n  requestOptions: ifm.IRequestOptions\n\n  private _ignoreSslError: boolean = false\n  private _socketTimeout: number\n  private _allowRedirects: boolean = true\n  private _allowRedirectDowngrade: boolean = false\n  private _maxRedirects: number = 50\n  private _allowRetries: boolean = false\n  private _maxRetries: number = 1\n  private _agent\n  private _proxyAgent\n  private _keepAlive: boolean = false\n  private _disposed: boolean = false\n\n  constructor(\n    userAgent?: string,\n    handlers?: ifm.IRequestHandler[],\n    requestOptions?: ifm.IRequestOptions\n  ) {\n    this.userAgent = userAgent\n    this.handlers = handlers || []\n    this.requestOptions = requestOptions\n    if (requestOptions) {\n      if (requestOptions.ignoreSslError != null) {\n        this._ignoreSslError = requestOptions.ignoreSslError\n      }\n\n      this._socketTimeout = requestOptions.socketTimeout\n\n      if (requestOptions.allowRedirects != null) {\n        this._allowRedirects = requestOptions.allowRedirects\n      }\n\n      if (requestOptions.allowRedirectDowngrade != null) {\n        this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade\n      }\n\n      if (requestOptions.maxRedirects != null) {\n        this._maxRedirects = Math.max(requestOptions.maxRedirects, 0)\n      }\n\n      if (requestOptions.keepAlive != null) {\n        this._keepAlive = requestOptions.keepAlive\n      }\n\n      if (requestOptions.allowRetries != null) {\n        this._allowRetries = requestOptions.allowRetries\n      }\n\n      if (requestOptions.maxRetries != null) {\n        this._maxRetries = requestOptions.maxRetries\n      }\n    }\n  }\n\n  public options(\n    requestUrl: string,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request('OPTIONS', requestUrl, null, additionalHeaders || {})\n  }\n\n  public get(\n    requestUrl: string,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request('GET', requestUrl, null, additionalHeaders || {})\n  }\n\n  public del(\n    requestUrl: string,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request('DELETE', requestUrl, null, additionalHeaders || {})\n  }\n\n  public post(\n    requestUrl: string,\n    data: string,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request('POST', requestUrl, data, additionalHeaders || {})\n  }\n\n  public patch(\n    requestUrl: string,\n    data: string,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request('PATCH', requestUrl, data, additionalHeaders || {})\n  }\n\n  public put(\n    requestUrl: string,\n    data: string,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request('PUT', requestUrl, data, additionalHeaders || {})\n  }\n\n  public head(\n    requestUrl: string,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request('HEAD', requestUrl, null, additionalHeaders || {})\n  }\n\n  public sendStream(\n    verb: string,\n    requestUrl: string,\n    stream: NodeJS.ReadableStream,\n    additionalHeaders?: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    return this.request(verb, requestUrl, stream, additionalHeaders)\n  }\n\n  /**\n   * Gets a typed object from an endpoint\n   * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n   */\n  public async getJson<T>(\n    requestUrl: string,\n    additionalHeaders: ifm.IHeaders = {}\n  ): Promise<ifm.ITypedResponse<T>> {\n    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(\n      additionalHeaders,\n      Headers.Accept,\n      MediaTypes.ApplicationJson\n    )\n    let res: ifm.IHttpClientResponse = await this.get(\n      requestUrl,\n      additionalHeaders\n    )\n    return this._processResponse<T>(res, this.requestOptions)\n  }\n\n  public async postJson<T>(\n    requestUrl: string,\n    obj: any,\n    additionalHeaders: ifm.IHeaders = {}\n  ): Promise<ifm.ITypedResponse<T>> {\n    let data: string = JSON.stringify(obj, null, 2)\n    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(\n      additionalHeaders,\n      Headers.Accept,\n      MediaTypes.ApplicationJson\n    )\n    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(\n      additionalHeaders,\n      Headers.ContentType,\n      MediaTypes.ApplicationJson\n    )\n    let res: ifm.IHttpClientResponse = await this.post(\n      requestUrl,\n      data,\n      additionalHeaders\n    )\n    return this._processResponse<T>(res, this.requestOptions)\n  }\n\n  public async putJson<T>(\n    requestUrl: string,\n    obj: any,\n    additionalHeaders: ifm.IHeaders = {}\n  ): Promise<ifm.ITypedResponse<T>> {\n    let data: string = JSON.stringify(obj, null, 2)\n    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(\n      additionalHeaders,\n      Headers.Accept,\n      MediaTypes.ApplicationJson\n    )\n    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(\n      additionalHeaders,\n      Headers.ContentType,\n      MediaTypes.ApplicationJson\n    )\n    let res: ifm.IHttpClientResponse = await this.put(\n      requestUrl,\n      data,\n      additionalHeaders\n    )\n    return this._processResponse<T>(res, this.requestOptions)\n  }\n\n  public async patchJson<T>(\n    requestUrl: string,\n    obj: any,\n    additionalHeaders: ifm.IHeaders = {}\n  ): Promise<ifm.ITypedResponse<T>> {\n    let data: string = JSON.stringify(obj, null, 2)\n    additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(\n      additionalHeaders,\n      Headers.Accept,\n      MediaTypes.ApplicationJson\n    )\n    additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(\n      additionalHeaders,\n      Headers.ContentType,\n      MediaTypes.ApplicationJson\n    )\n    let res: ifm.IHttpClientResponse = await this.patch(\n      requestUrl,\n      data,\n      additionalHeaders\n    )\n    return this._processResponse<T>(res, this.requestOptions)\n  }\n\n  /**\n   * Makes a raw http request.\n   * All other methods such as get, post, patch, and request ultimately call this.\n   * Prefer get, del, post and patch\n   */\n  public async request(\n    verb: string,\n    requestUrl: string,\n    data: string | NodeJS.ReadableStream,\n    headers: ifm.IHeaders\n  ): Promise<ifm.IHttpClientResponse> {\n    if (this._disposed) {\n      throw new Error('Client has already been disposed.')\n    }\n\n    let parsedUrl = url.parse(requestUrl)\n    let info: ifm.IRequestInfo = this._prepareRequest(verb, parsedUrl, headers)\n\n    // Only perform retries on reads since writes may not be idempotent.\n    let maxTries: number =\n      this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1\n        ? this._maxRetries + 1\n        : 1\n    let numTries: number = 0\n\n    let response: HttpClientResponse\n    while (numTries < maxTries) {\n      response = await this.requestRaw(info, data)\n\n      // Check if it's an authentication challenge\n      if (\n        response &&\n        response.message &&\n        response.message.statusCode === HttpCodes.Unauthorized\n      ) {\n        let authenticationHandler: ifm.IRequestHandler\n\n        for (let i = 0; i < this.handlers.length; i++) {\n          if (this.handlers[i].canHandleAuthentication(response)) {\n            authenticationHandler = this.handlers[i]\n            break\n          }\n        }\n\n        if (authenticationHandler) {\n          return authenticationHandler.handleAuthentication(this, info, data)\n        } else {\n          // We have received an unauthorized response but have no handlers to handle it.\n          // Let the response return to the caller.\n          return response\n        }\n      }\n\n      let redirectsRemaining: number = this._maxRedirects\n      while (\n        HttpRedirectCodes.indexOf(response.message.statusCode) != -1 &&\n        this._allowRedirects &&\n        redirectsRemaining > 0\n      ) {\n        const redirectUrl: string | null = response.message.headers['location']\n        if (!redirectUrl) {\n          // if there's no location to redirect to, we won't\n          break\n        }\n        let parsedRedirectUrl = url.parse(redirectUrl)\n        if (\n          parsedUrl.protocol == 'https:' &&\n          parsedUrl.protocol != parsedRedirectUrl.protocol &&\n          !this._allowRedirectDowngrade\n        ) {\n          throw new Error(\n            'Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.'\n          )\n        }\n\n        // we need to finish reading the response before reassigning response\n        // which will leak the open socket.\n        await response.readBody()\n\n        // strip authorization header if redirected to a different hostname\n        if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n          for (let header in headers) {\n            // header names are case insensitive\n            if (header.toLowerCase() === 'authorization') {\n              delete headers[header]\n            }\n          }\n        }\n\n        // let's make the request with the new redirectUrl\n        info = this._prepareRequest(verb, parsedRedirectUrl, headers)\n        response = await this.requestRaw(info, data)\n        redirectsRemaining--\n      }\n\n      if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {\n        // If not a retry code, return immediately instead of retrying\n        return response\n      }\n\n      numTries += 1\n\n      if (numTries < maxTries) {\n        await response.readBody()\n        await this._performExponentialBackoff(numTries)\n      }\n    }\n\n    return response\n  }\n\n  /**\n   * Needs to be called if keepAlive is set to true in request options.\n   */\n  public dispose() {\n    if (this._agent) {\n      this._agent.destroy()\n    }\n\n    this._disposed = true\n  }\n\n  /**\n   * Raw request.\n   * @param info\n   * @param data\n   */\n  public requestRaw(\n    info: ifm.IRequestInfo,\n    data: string | NodeJS.ReadableStream\n  ): Promise<ifm.IHttpClientResponse> {\n    return new Promise<ifm.IHttpClientResponse>((resolve, reject) => {\n      let callbackForResult = function (\n        err: any,\n        res: ifm.IHttpClientResponse\n      ) {\n        if (err) {\n          reject(err)\n        }\n\n        resolve(res)\n      }\n\n      this.requestRawWithCallback(info, data, callbackForResult)\n    })\n  }\n\n  /**\n   * Raw request with callback.\n   * @param info\n   * @param data\n   * @param onResult\n   */\n  public requestRawWithCallback(\n    info: ifm.IRequestInfo,\n    data: string | NodeJS.ReadableStream,\n    onResult: (err: any, res: ifm.IHttpClientResponse) => void\n  ): void {\n    let socket\n\n    if (typeof data === 'string') {\n      info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8')\n    }\n\n    let callbackCalled: boolean = false\n    let handleResult = (err: any, res: HttpClientResponse) => {\n      if (!callbackCalled) {\n        callbackCalled = true\n        onResult(err, res)\n      }\n    }\n\n    let req: http.ClientRequest = info.httpModule.request(\n      info.options,\n      (msg: http.IncomingMessage) => {\n        let res: HttpClientResponse = new HttpClientResponse(msg)\n        handleResult(null, res)\n      }\n    )\n\n    req.on('socket', sock => {\n      socket = sock\n    })\n\n    // If we ever get disconnected, we want the socket to timeout eventually\n    req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n      if (socket) {\n        socket.end()\n      }\n      handleResult(new Error('Request timeout: ' + info.options.path), null)\n    })\n\n    req.on('error', function (err) {\n      // err has statusCode property\n      // res should have headers\n      handleResult(err, null)\n    })\n\n    if (data && typeof data === 'string') {\n      req.write(data, 'utf8')\n    }\n\n    if (data && typeof data !== 'string') {\n      data.on('close', function () {\n        req.end()\n      })\n\n      data.pipe(req)\n    } else {\n      req.end()\n    }\n  }\n\n  /**\n   * Gets an http agent. This function is useful when you need an http agent that handles\n   * routing through a proxy server - depending upon the url and proxy environment variables.\n   * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n   */\n  public getAgent(serverUrl: string): http.Agent {\n    let parsedUrl = url.parse(serverUrl)\n    return this._getAgent(parsedUrl)\n  }\n\n  private _prepareRequest(\n    method: string,\n    requestUrl: url.Url,\n    headers: ifm.IHeaders\n  ): ifm.IRequestInfo {\n    const info: ifm.IRequestInfo = <ifm.IRequestInfo>{}\n\n    info.parsedUrl = requestUrl\n    const usingSsl: boolean = info.parsedUrl.protocol === 'https:'\n    info.httpModule = usingSsl ? https : http\n    const defaultPort: number = usingSsl ? 443 : 80\n\n    info.options = <http.RequestOptions>{}\n    info.options.host = info.parsedUrl.hostname\n    info.options.port = info.parsedUrl.port\n      ? parseInt(info.parsedUrl.port)\n      : defaultPort\n    info.options.path =\n      (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '')\n    info.options.method = method\n    info.options.headers = this._mergeHeaders(headers)\n    if (this.userAgent != null) {\n      info.options.headers['user-agent'] = this.userAgent\n    }\n\n    info.options.agent = this._getAgent(info.parsedUrl)\n\n    // gives handlers an opportunity to participate\n    if (this.handlers) {\n      this.handlers.forEach(handler => {\n        handler.prepareRequest(info.options)\n      })\n    }\n\n    return info\n  }\n\n  private _mergeHeaders(headers: ifm.IHeaders): ifm.IHeaders {\n    const lowercaseKeys = obj =>\n      Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {})\n\n    if (this.requestOptions && this.requestOptions.headers) {\n      return Object.assign(\n        {},\n        lowercaseKeys(this.requestOptions.headers),\n        lowercaseKeys(headers)\n      )\n    }\n\n    return lowercaseKeys(headers || {})\n  }\n\n  private _getExistingOrDefaultHeader(\n    additionalHeaders: ifm.IHeaders,\n    header: string,\n    _default: string\n  ) {\n    const lowercaseKeys = obj =>\n      Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {})\n\n    let clientHeader: string\n    if (this.requestOptions && this.requestOptions.headers) {\n      clientHeader = lowercaseKeys(this.requestOptions.headers)[header]\n    }\n    return additionalHeaders[header] || clientHeader || _default\n  }\n\n  private _getAgent(parsedUrl: url.Url): http.Agent {\n    let agent\n    let proxyUrl: url.Url = pm.getProxyUrl(parsedUrl)\n    let useProxy = proxyUrl && proxyUrl.hostname\n\n    if (this._keepAlive && useProxy) {\n      agent = this._proxyAgent\n    }\n\n    if (this._keepAlive && !useProxy) {\n      agent = this._agent\n    }\n\n    // if agent is already assigned use that agent.\n    if (!!agent) {\n      return agent\n    }\n\n    const usingSsl = parsedUrl.protocol === 'https:'\n    let maxSockets = 100\n    if (!!this.requestOptions) {\n      maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets\n    }\n\n    if (useProxy) {\n      // If using proxy, need tunnel\n      if (!tunnel) {\n        tunnel = require('tunnel')\n      }\n\n      const agentOptions = {\n        maxSockets: maxSockets,\n        keepAlive: this._keepAlive,\n        proxy: {\n          proxyAuth: proxyUrl.auth,\n          host: proxyUrl.hostname,\n          port: proxyUrl.port\n        }\n      }\n\n      let tunnelAgent: Function\n      const overHttps = proxyUrl.protocol === 'https:'\n      if (usingSsl) {\n        tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp\n      } else {\n        tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp\n      }\n\n      agent = tunnelAgent(agentOptions)\n      this._proxyAgent = agent\n    }\n\n    // if reusing agent across request and tunneling agent isn't assigned create a new agent\n    if (this._keepAlive && !agent) {\n      const options = {keepAlive: this._keepAlive, maxSockets: maxSockets}\n      agent = usingSsl ? new https.Agent(options) : new http.Agent(options)\n      this._agent = agent\n    }\n\n    // if not using private agent and tunnel agent isn't setup then use global agent\n    if (!agent) {\n      agent = usingSsl ? https.globalAgent : http.globalAgent\n    }\n\n    if (usingSsl && this._ignoreSslError) {\n      // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n      // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n      // we have to cast it to any and change it directly\n      agent.options = Object.assign(agent.options || {}, {\n        rejectUnauthorized: false\n      })\n    }\n\n    return agent\n  }\n\n  private _performExponentialBackoff(retryNumber: number): Promise<void> {\n    retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber)\n    const ms: number = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber)\n    return new Promise(resolve => setTimeout(() => resolve(), ms))\n  }\n\n  private static dateTimeDeserializer(key: any, value: any): any {\n    if (typeof value === 'string') {\n      let a = new Date(value)\n      if (!isNaN(a.valueOf())) {\n        return a\n      }\n    }\n\n    return value\n  }\n\n  private async _processResponse<T>(\n    res: ifm.IHttpClientResponse,\n    options: ifm.IRequestOptions\n  ): Promise<ifm.ITypedResponse<T>> {\n    return new Promise<ifm.ITypedResponse<T>>(async (resolve, reject) => {\n      const statusCode: number = res.message.statusCode\n\n      const response: ifm.ITypedResponse<T> = {\n        statusCode: statusCode,\n        result: null,\n        headers: {}\n      }\n\n      // not found leads to null obj returned\n      if (statusCode == HttpCodes.NotFound) {\n        resolve(response)\n      }\n\n      let obj: any\n      let contents: string\n\n      // get the result from the body\n      try {\n        contents = await res.readBody()\n        if (contents && contents.length > 0) {\n          if (options && options.deserializeDates) {\n            obj = JSON.parse(contents, HttpClient.dateTimeDeserializer)\n          } else {\n            obj = JSON.parse(contents)\n          }\n\n          response.result = obj\n        }\n\n        response.headers = res.message.headers\n      } catch (err) {\n        // Invalid resource (contents not json);  leaving result obj null\n      }\n\n      // note that 3xx redirects are handled by the http layer.\n      if (statusCode > 299) {\n        let msg: string\n\n        // if exception/error in body, attempt to get better error\n        if (obj && obj.message) {\n          msg = obj.message\n        } else if (contents && contents.length > 0) {\n          // it may be the case that the exception is in the body message as string\n          msg = contents\n        } else {\n          msg = 'Failed request: (' + statusCode + ')'\n        }\n\n        let err: Error = new Error(msg)\n\n        // attach statusCode and body obj (if available) to the error object\n        err['statusCode'] = statusCode\n        if (response.result) {\n          err['result'] = response.result\n        }\n\n        reject(err)\n      } else {\n        resolve(response)\n      }\n    })\n  }\n}\n", "{\n  \"name\": \"@actions/http-client\",\n  \"version\": \"1.0.8\",\n  \"description\": \"Actions Http Client\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"build\": \"rm -Rf ./_out && tsc && cp package*.json ./_out && cp *.md ./_out && cp LICENSE ./_out && cp actions.png ./_out\",\n    \"test\": \"jest\",\n    \"format\": \"prettier --write *.ts && prettier --write **/*.ts\",\n    \"format-check\": \"prettier --check *.ts && prettier --check **/*.ts\",\n    \"audit-check\": \"npm audit --audit-level=moderate\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/actions/http-client.git\"\n  },\n  \"keywords\": [\n    \"Actions\",\n    \"Http\"\n  ],\n  \"author\": \"GitHub, Inc.\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/actions/http-client/issues\"\n  },\n  \"homepage\": \"https://github.com/actions/http-client#readme\",\n  \"devDependencies\": {\n    \"@types/jest\": \"^25.1.4\",\n    \"@types/node\": \"^12.12.31\",\n    \"jest\": \"^25.1.0\",\n    \"prettier\": \"^2.0.4\",\n    \"proxy\": \"^1.0.1\",\n    \"ts-jest\": \"^25.2.1\",\n    \"typescript\": \"^3.8.3\"\n  },\n  \"dependencies\": {\n    \"tunnel\": \"0.0.6\"\n  }\n}\n"], "buggy_code_start_loc": [181, 388, 3], "buggy_code_end_loc": [181, 388, 4], "fixing_code_start_loc": [182, 389, 3], "fixing_code_end_loc": [228, 399, 4], "type": "NVD-CWE-noinfo", "message": "Actions Http-Client (NPM @actions/http-client) before version 1.0.8 can disclose Authorization headers to incorrect domain in certain redirect scenarios. The conditions in which this happens are if consumers of the http-client: 1. make an http request with an authorization header 2. that request leads to a redirect (302) and 3. the redirect url redirects to another domain or hostname Then the authorization header will get passed to the other domain. The problem is fixed in version 1.0.8.", "other": {"cve": {"id": "CVE-2020-11021", "sourceIdentifier": "security-advisories@github.com", "published": "2020-04-29T18:15:13.423", "lastModified": "2021-09-14T14:02:07.937", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Actions Http-Client (NPM @actions/http-client) before version 1.0.8 can disclose Authorization headers to incorrect domain in certain redirect scenarios. The conditions in which this happens are if consumers of the http-client: 1. make an http request with an authorization header 2. that request leads to a redirect (302) and 3. the redirect url redirects to another domain or hostname Then the authorization header will get passed to the other domain. The problem is fixed in version 1.0.8."}, {"lang": "es", "value": "Actions Http-Client (NPM @actions/http-client) versiones anteriores a 1.0.8, puede revelar los encabezados de Autorizaci\u00f3n en dominios incorrectos en determinados escenarios de redireccionamiento. Las condiciones en las que esto ocurre son si los consumidores del http-client: 1. hacen una petici\u00f3n http con un encabezado de autorizaci\u00f3n 2. esa petici\u00f3n conduce a un redireccionamiento (302) y 3. la URL de redireccionamiento redirecciona a otro dominio o nombre de host. Entonces el encabezado de autorizaci\u00f3n se pasar\u00e1 al otro dominio. El problema se corrigi\u00f3 en la versi\u00f3n 1.0.8."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:http-client_project:http-client:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.0.8", "matchCriteriaId": "D06CAAAD-54B3-490E-8931-FA3ACB500A11"}]}]}], "references": [{"url": "https://github.com/actions/http-client/commit/f6aae3dda4f4c9dc0b49737b36007330f78fd53a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/actions/http-client/pull/27", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/actions/http-client/security/advisories/GHSA-9w6v-m7wp-jwg4", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/actions/http-client/commit/f6aae3dda4f4c9dc0b49737b36007330f78fd53a"}}