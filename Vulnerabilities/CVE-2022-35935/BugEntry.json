{"buggy_code": ["/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Based on \"Notes on generating Sobol sequences. August 2008\" by Joe and Kuo.\n// [1] https://web.maths.unsw.edu.au/~fkuo/sobol/joe-kuo-notes.pdf\n#include <algorithm>\n#include <cmath>\n#include <cstdint>\n#include <limits>\n\n#include \"third_party/eigen3/Eigen/Core\"\n#include \"sobol_data.h\"  // from @sobol_data\n#include \"tensorflow/core/framework/device_base.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/platform/platform_strings.h\"\n\nnamespace tensorflow {\n\n// Embed the platform strings in this binary.\nTF_PLATFORM_STRINGS()\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\n\nnamespace {\n\n// Each thread will calculate at least kMinBlockSize points in the sequence.\nconstexpr int kMinBlockSize = 512;\n\n// Returns number of digits in binary representation of n.\n// Example: n=13. Binary representation is 1101. NumBinaryDigits(13) -> 4.\nint NumBinaryDigits(int n) {\n  return static_cast<int>(std::log2(n) + 1);\n}\n\n// Returns position of rightmost zero digit in binary representation of n.\n// Example: n=13. Binary representation is 1101. RightmostZeroBit(13) -> 1.\nint RightmostZeroBit(int n) {\n  int k = 0;\n  while (n & 1) {\n    n >>= 1;\n    ++k;\n  }\n  return k;\n}\n\n// Returns an integer representation of point `i` in the Sobol sequence of\n// dimension `dim` using the given direction numbers.\nEigen::VectorXi GetFirstPoint(int i, int dim,\n                              const Eigen::MatrixXi& direction_numbers) {\n  // Index variables used in this function, consistent with notation in [1].\n  // i - point in the Sobol sequence\n  // j - dimension\n  // k - binary digit\n  Eigen::VectorXi integer_sequence = Eigen::VectorXi::Zero(dim);\n  // go/wiki/Sobol_sequence#A_fast_algorithm_for_the_construction_of_Sobol_sequences\n  int gray_code = i ^ (i >> 1);\n  int num_digits = NumBinaryDigits(i);\n  for (int j = 0; j < dim; ++j) {\n    for (int k = 0; k < num_digits; ++k) {\n      if ((gray_code >> k) & 1) integer_sequence(j) ^= direction_numbers(j, k);\n    }\n  }\n  return integer_sequence;\n}\n\n// Calculates `num_results` Sobol points of dimension `dim` starting at the\n// point `start_point + skip` and writes them into `output` starting at point\n// `start_point`.\ntemplate <typename T>\nvoid CalculateSobolSample(int32_t dim, int32_t num_results, int32_t skip,\n                          int32_t start_point,\n                          typename TTypes<T>::Flat output) {\n  // Index variables used in this function, consistent with notation in [1].\n  // i - point in the Sobol sequence\n  // j - dimension\n  // k - binary digit\n  const int num_digits =\n      NumBinaryDigits(skip + start_point + num_results + 1);\n  Eigen::MatrixXi direction_numbers(dim, num_digits);\n\n  // Shift things so we can use integers everywhere. Before we write to output,\n  // divide by constant to convert back to floats.\n  const T normalizing_constant = 1./(1 << num_digits);\n  for (int j = 0; j < dim; ++j) {\n    for (int k = 0; k < num_digits; ++k) {\n      direction_numbers(j, k) = sobol_data::kDirectionNumbers[j][k]\n                                << (num_digits - k - 1);\n    }\n  }\n\n  // If needed, skip ahead to the appropriate point in the sequence. Otherwise\n  // we start with the first column of direction numbers.\n  Eigen::VectorXi integer_sequence =\n      (skip + start_point > 0)\n          ? GetFirstPoint(skip + start_point + 1, dim, direction_numbers)\n          : direction_numbers.col(0);\n\n  for (int j = 0; j < dim; ++j) {\n    output(start_point * dim + j) = integer_sequence(j) * normalizing_constant;\n  }\n  // go/wiki/Sobol_sequence#A_fast_algorithm_for_the_construction_of_Sobol_sequences\n  for (int i = start_point + 1; i < num_results + start_point; ++i) {\n    // The Gray code for the current point differs from the preceding one by\n    // just a single bit -- the rightmost bit.\n    int k = RightmostZeroBit(i + skip);\n    // Update the current point from the preceding one with a single XOR\n    // operation per dimension.\n    for (int j = 0; j < dim; ++j) {\n      integer_sequence(j) ^= direction_numbers(j, k);\n      output(i * dim + j) = integer_sequence(j) * normalizing_constant;\n    }\n  }\n}\n\n}  // namespace\n\ntemplate <typename Device, typename T>\nclass SobolSampleOp : public OpKernel {\n public:\n  explicit SobolSampleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    int32_t dim = context->input(0).scalar<int32_t>()();\n    int32_t num_results = context->input(1).scalar<int32_t>()();\n    int32_t skip = context->input(2).scalar<int32_t>()();\n\n    OP_REQUIRES(context, dim >= 1,\n                errors::InvalidArgument(\"dim must be at least one\"));\n    OP_REQUIRES(context, dim <= sobol_data::kMaxSobolDim,\n                errors::InvalidArgument(\"dim must be at most \",\n                                        sobol_data::kMaxSobolDim));\n    OP_REQUIRES(context, num_results >= 1,\n                errors::InvalidArgument(\"num_results must be at least one\"));\n    OP_REQUIRES(context, skip >= 0,\n                errors::InvalidArgument(\"skip must be non-negative\"));\n    OP_REQUIRES(context,\n                num_results < std::numeric_limits<int32_t>::max() - skip,\n                errors::InvalidArgument(\"num_results+skip must be less than \",\n                                        std::numeric_limits<int32_t>::max()));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({num_results, dim}), &output));\n    auto output_flat = output->flat<T>();\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    int num_threads = worker_threads.num_threads;\n    int block_size = std::max(\n        kMinBlockSize, static_cast<int>(std::ceil(\n                           static_cast<float>(num_results) / num_threads)));\n    worker_threads.workers->TransformRangeConcurrently(\n        block_size, num_results /* total */,\n        [&dim, &skip, &output_flat](const int start, const int end) {\n          CalculateSobolSample<T>(dim, end - start /* num_results */, skip,\n                                  start, output_flat);\n        });\n  }\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"SobolSample\").Device(DEVICE_CPU).TypeConstraint<double>(\"dtype\"),\n    SobolSampleOp<CPUDevice, double>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"SobolSample\").Device(DEVICE_CPU).TypeConstraint<float>(\"dtype\"),\n    SobolSampleOp<CPUDevice, float>);\n\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Based on \"Notes on generating Sobol sequences. August 2008\" by Joe and Kuo.\n// [1] https://web.maths.unsw.edu.au/~fkuo/sobol/joe-kuo-notes.pdf\n#include <algorithm>\n#include <cmath>\n#include <cstdint>\n#include <limits>\n\n#include \"third_party/eigen3/Eigen/Core\"\n#include \"sobol_data.h\"  // from @sobol_data\n#include \"tensorflow/core/framework/device_base.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/platform/platform_strings.h\"\n\nnamespace tensorflow {\n\n// Embed the platform strings in this binary.\nTF_PLATFORM_STRINGS()\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\n\nnamespace {\n\n// Each thread will calculate at least kMinBlockSize points in the sequence.\nconstexpr int kMinBlockSize = 512;\n\n// Returns number of digits in binary representation of n.\n// Example: n=13. Binary representation is 1101. NumBinaryDigits(13) -> 4.\nint NumBinaryDigits(int n) {\n  return static_cast<int>(std::log2(n) + 1);\n}\n\n// Returns position of rightmost zero digit in binary representation of n.\n// Example: n=13. Binary representation is 1101. RightmostZeroBit(13) -> 1.\nint RightmostZeroBit(int n) {\n  int k = 0;\n  while (n & 1) {\n    n >>= 1;\n    ++k;\n  }\n  return k;\n}\n\n// Returns an integer representation of point `i` in the Sobol sequence of\n// dimension `dim` using the given direction numbers.\nEigen::VectorXi GetFirstPoint(int i, int dim,\n                              const Eigen::MatrixXi& direction_numbers) {\n  // Index variables used in this function, consistent with notation in [1].\n  // i - point in the Sobol sequence\n  // j - dimension\n  // k - binary digit\n  Eigen::VectorXi integer_sequence = Eigen::VectorXi::Zero(dim);\n  // go/wiki/Sobol_sequence#A_fast_algorithm_for_the_construction_of_Sobol_sequences\n  int gray_code = i ^ (i >> 1);\n  int num_digits = NumBinaryDigits(i);\n  for (int j = 0; j < dim; ++j) {\n    for (int k = 0; k < num_digits; ++k) {\n      if ((gray_code >> k) & 1) integer_sequence(j) ^= direction_numbers(j, k);\n    }\n  }\n  return integer_sequence;\n}\n\n// Calculates `num_results` Sobol points of dimension `dim` starting at the\n// point `start_point + skip` and writes them into `output` starting at point\n// `start_point`.\ntemplate <typename T>\nvoid CalculateSobolSample(int32_t dim, int32_t num_results, int32_t skip,\n                          int32_t start_point,\n                          typename TTypes<T>::Flat output) {\n  // Index variables used in this function, consistent with notation in [1].\n  // i - point in the Sobol sequence\n  // j - dimension\n  // k - binary digit\n  const int num_digits =\n      NumBinaryDigits(skip + start_point + num_results + 1);\n  Eigen::MatrixXi direction_numbers(dim, num_digits);\n\n  // Shift things so we can use integers everywhere. Before we write to output,\n  // divide by constant to convert back to floats.\n  const T normalizing_constant = 1./(1 << num_digits);\n  for (int j = 0; j < dim; ++j) {\n    for (int k = 0; k < num_digits; ++k) {\n      direction_numbers(j, k) = sobol_data::kDirectionNumbers[j][k]\n                                << (num_digits - k - 1);\n    }\n  }\n\n  // If needed, skip ahead to the appropriate point in the sequence. Otherwise\n  // we start with the first column of direction numbers.\n  Eigen::VectorXi integer_sequence =\n      (skip + start_point > 0)\n          ? GetFirstPoint(skip + start_point + 1, dim, direction_numbers)\n          : direction_numbers.col(0);\n\n  for (int j = 0; j < dim; ++j) {\n    output(start_point * dim + j) = integer_sequence(j) * normalizing_constant;\n  }\n  // go/wiki/Sobol_sequence#A_fast_algorithm_for_the_construction_of_Sobol_sequences\n  for (int i = start_point + 1; i < num_results + start_point; ++i) {\n    // The Gray code for the current point differs from the preceding one by\n    // just a single bit -- the rightmost bit.\n    int k = RightmostZeroBit(i + skip);\n    // Update the current point from the preceding one with a single XOR\n    // operation per dimension.\n    for (int j = 0; j < dim; ++j) {\n      integer_sequence(j) ^= direction_numbers(j, k);\n      output(i * dim + j) = integer_sequence(j) * normalizing_constant;\n    }\n  }\n}\n\n}  // namespace\n\ntemplate <typename Device, typename T>\nclass SobolSampleOp : public OpKernel {\n public:\n  explicit SobolSampleOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(0).shape()),\n                errors::InvalidArgument(\"dim must be a scalar\"));\n    int32_t dim = context->input(0).scalar<int32_t>()();\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(0).shape()),\n                errors::InvalidArgument(\"num_results must be a scalar\"));\n    int32_t num_results = context->input(1).scalar<int32_t>()();\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(0).shape()),\n                errors::InvalidArgument(\"skip must be a scalar\"));\n    int32_t skip = context->input(2).scalar<int32_t>()();\n\n    OP_REQUIRES(context, dim >= 1,\n                errors::InvalidArgument(\"dim must be at least one\"));\n    OP_REQUIRES(context, dim <= sobol_data::kMaxSobolDim,\n                errors::InvalidArgument(\"dim must be at most \",\n                                        sobol_data::kMaxSobolDim));\n    OP_REQUIRES(context, num_results >= 1,\n                errors::InvalidArgument(\"num_results must be at least one\"));\n    OP_REQUIRES(context, skip >= 0,\n                errors::InvalidArgument(\"skip must be non-negative\"));\n    OP_REQUIRES(context,\n                num_results < std::numeric_limits<int32_t>::max() - skip,\n                errors::InvalidArgument(\"num_results+skip must be less than \",\n                                        std::numeric_limits<int32_t>::max()));\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({num_results, dim}), &output));\n    auto output_flat = output->flat<T>();\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    int num_threads = worker_threads.num_threads;\n    int block_size = std::max(\n        kMinBlockSize, static_cast<int>(std::ceil(\n                           static_cast<float>(num_results) / num_threads)));\n    worker_threads.workers->TransformRangeConcurrently(\n        block_size, num_results /* total */,\n        [&dim, &skip, &output_flat](const int start, const int end) {\n          CalculateSobolSample<T>(dim, end - start /* num_results */, skip,\n                                  start, output_flat);\n        });\n  }\n};\n\nREGISTER_KERNEL_BUILDER(\n    Name(\"SobolSample\").Device(DEVICE_CPU).TypeConstraint<double>(\"dtype\"),\n    SobolSampleOp<CPUDevice, double>);\nREGISTER_KERNEL_BUILDER(\n    Name(\"SobolSample\").Device(DEVICE_CPU).TypeConstraint<float>(\"dtype\"),\n    SobolSampleOp<CPUDevice, float>);\n\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/sobol_op.cc"], "buggy_code_start_loc": [26], "buggy_code_end_loc": [138], "fixing_code_start_loc": [27], "fixing_code_end_loc": [146], "type": "CWE-617", "message": "TensorFlow is an open source platform for machine learning. The implementation of SobolSampleOp is vulnerable to a denial of service via CHECK-failure (assertion failure) caused by assuming `input(0)`, `input(1)`, and `input(2)` to be scalar. This issue has been patched in GitHub commit c65c67f88ad770662e8f191269a907bf2b94b1bf. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-35935", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-16T20:15:10.047", "lastModified": "2022-09-20T16:40:35.673", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. The implementation of SobolSampleOp is vulnerable to a denial of service via CHECK-failure (assertion failure) caused by assuming `input(0)`, `input(1)`, and `input(2)` to be scalar. This issue has been patched in GitHub commit c65c67f88ad770662e8f191269a907bf2b94b1bf. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. La implementaci\u00f3n de SobolSampleOp es vulnerable a una denegaci\u00f3n de servicio por medio de CHECK-failure (fallo de aserci\u00f3n) causado por asumir que \"input(0)\", \"input(1)\" y \"input(2)\" son escalares. Este problema ha sido corregido en el commit de GitHub c65c67f88ad770662e8f191269a907bf2b94b1bf. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.10.0. Tambi\u00e9n seleccionaremos este compromiso en TensorFlow versi\u00f3n 2.9.1, TensorFlow versi\u00f3n 2.8.1, y TensorFlow versi\u00f3n 2.7.2, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndExcluding": "2.7.2", "matchCriteriaId": "C4DFBF2D-5283-42F6-8800-D653BFA5CE82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.1", "matchCriteriaId": "0F9D273D-02DC-441E-AA91-EAC8DEAA4B44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.1", "matchCriteriaId": "FE4F8A81-6CC2-4F7F-9602-C170FDD926E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc0:*:*:*:*:*:*", "matchCriteriaId": "1DBFBCE2-0A01-4575-BE45-6775ABFB8B28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "89806CF9-E423-4CA6-A01A-8175C260CB24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc2:*:*:*:*:*:*", "matchCriteriaId": "F2B80690-A257-4E16-BD27-9AE045BC56ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc3:*:*:*:*:*:*", "matchCriteriaId": "F335F9A4-5AB8-4E53-BC18-E01F7C653E5E"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/c65c67f88ad770662e8f191269a907bf2b94b1bf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-97p7-w86h-vcf9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/c65c67f88ad770662e8f191269a907bf2b94b1bf"}}