{"buggy_code": ["<?php\ndefine('ADMINSERV_TIMER', false);\ndefine('ADMINSERV_VERSION', '2.1.1');\n\n/**\n* Classe pour le fonctionnement d'AdminServ\n*/\nclass AdminServ {\n\t\n\t/**\n\t* Inclue les classes PHP\n\t*/\n\tpublic static function getClass(){\n\t\t$pathClass = AdminServConfig::$PATH_RESOURCES.'class/';\n\t\trequire_once $pathClass.'GbxRemote.inc.php';\n\t\trequire_once $pathClass.'gbxdatafetcher.inc.php';\n\t\trequire_once $pathClass.'utils.class.php';\n\t\trequire_once $pathClass.'tmnick.class.php';\n\t\trequire_once $pathClass.'timedate.class.php';\n\t\trequire_once $pathClass.'file.class.php';\n\t\trequire_once $pathClass.'folder.class.php';\n\t\trequire_once $pathClass.'str.class.php';\n\t\trequire_once $pathClass.'upload.class.php';\n\t\trequire_once $pathClass.'zip.class.php';\n\t\t\n\t\t$pathCore = AdminServConfig::$PATH_RESOURCES.'core/';\n\t\trequire_once $pathCore.'adminlevel.php';\n\t\trequire_once $pathCore.'cache.php';\n\t\trequire_once $pathCore.'event.php';\n\t\trequire_once $pathCore.'logs.php';\n\t\trequire_once $pathCore.'plugin.php';\n\t\trequire_once $pathCore.'server.php';\n\t\trequire_once $pathCore.'sort.php';\n\t\trequire_once $pathCore.'ui.php';\n\t}\n\t\n\t\n\t/**\n\t* M\u00e9thodes de debug\n\t*/\n\tpublic static function dsm($val){\n\t\techo '<pre>';\n\t\tprint_r($val);\n\t\techo '</pre>';\n\t}\n\tpublic static function debug($globalValue = null){\n\t\t$const = get_defined_constants(true);\n\t\t\n\t\treturn self::dsm(\n\t\t\tarray(\n\t\t\t\t'GLOBALS' => ($globalValue) ? $GLOBALS[$globalValue] : $GLOBALS,\n\t\t\t\t'ADMINSERV' => $const['user']\n\t\t\t)\n\t\t);\n\t}\n\t\n\t/**\n\t* Erreurs et infos\n\t*/\n\tpublic static function error($text = null){\n\t\tglobal $client;\n\t\t// Tente de r\u00e9cup\u00e9rer le message d'erreur du d\u00e9di\u00e9\n\t\tif($text === null){\n\t\t\t$text = '['.$client->getErrorCode().'] '.Utils::t( $client->getErrorMessage() );\n\t\t}\n\t\t\n\t\tAdminServLogs::add('error', $text);\n\t\tunset($_SESSION['info']);\n\t\t$_SESSION['error'] = $text;\n\t}\n\tpublic static function info($text){\n\t\t$_SESSION['info'] = $text;\n\t}\n\t\n\t\n\t/**\n\t* Temps de chargement de page\n\t*/\n\tpublic static function startTimer(){\n\t\tglobal $timeStart;\n\t\t$timeStart = microtime(true);\n\t}\n\tpublic static function endTimer(){\n\t\tglobal $timeStart;\n\t\t$timeEnd = microtime(true);\n\t\t$time = $timeEnd - $timeStart;\n\t\treturn number_format($time, 3);\n\t}\n\t\n\t\n\t/**\n\t* V\u00e9rifie la version de PHP\n\t*/\n\tpublic static function checkPHPVersion($version){\n\t\tif( !version_compare(PHP_VERSION, $version, '>=') ){\n\t\t\techo '<b>This PHP version is not compatible with AdminServ.</b><br />Your PHP version: '. PHP_VERSION .'<br />PHP version required: '.$version;\n\t\t\texit;\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t* V\u00e9rifie les droits pour l'\u00e9criture/lecture des fichiers\n\t*\n\t* @param array $list -> Liste des fichiers \u00e0 tester : array('path' => 777)\n\t* @return array\n\t*/\n\tpublic static function checkRights($list){\n\t\tif( count($list) > 0 ){\n\t\t\tforeach($list as $path => $minChmod){\n\t\t\t\t$result = Folder::checkRights($path, $minChmod);\n\t\t\t\tforeach($result as $grpName => $grpValues){\n\t\t\t\t\tforeach($grpValues['result'] as $bool){\n\t\t\t\t\t\tif(!$bool){\n\t\t\t\t\t\t\tself::error( Utils::t('This path was not required rights:').' '.$path.' (\"'.$grpName.'\" '.Utils::t('needs').' \"'.$minChmod.'\")');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t* Intialise le client du serveur courant\n\t*\n\t* @param bool $fullInit -> Intialisation compl\u00e8te ? oui par d\u00e9faut.\n\t* Si non, \u00e7a ne recup\u00e8re aucune info de base, seulement la connexion\n\t* au serveur d\u00e9di\u00e9 et son authentication.\n\t* @return bool\n\t*/\n\tpublic static function initialize($fullInit = true){\n\t\tglobal $client;\n\t\t$out = false;\n\t\t\n\t\tif( isset($_SESSION['adminserv']['sid']) ){\n\t\t\t// CONSTANTS\n\t\t\tdefine('USER_ADMINLEVEL', $_SESSION['adminserv']['adminlevel']);\n\t\t\tdefine('SERVER_ID', $_SESSION['adminserv']['sid']);\n\t\t\tdefine('SERVER_NAME', $_SESSION['adminserv']['name']);\n\t\t\tdefine('SERVER_ADDR', ServerConfig::$SERVERS[SERVER_NAME]['address']);\n\t\t\tdefine('SERVER_XMLRPC_PORT', ServerConfig::$SERVERS[SERVER_NAME]['port']);\n\t\t\tdefine('SERVER_MATCHSET', ServerConfig::$SERVERS[SERVER_NAME]['matchsettings']);\n\t\t\tdefine('SERVER_MAPS_BASEPATH', (isset(ServerConfig::$SERVERS[SERVER_NAME]['mapsbasepath'])) ? ServerConfig::$SERVERS[SERVER_NAME]['mapsbasepath'] : '');\n\t\t\tdefine('SERVER_ADMINLEVEL', serialize( ServerConfig::$SERVERS[SERVER_NAME]['adminlevel']) );\n\t\t\t\n\t\t\t// CONNEXION\n\t\t\t$client = new IXR_ClientMulticall_Gbx;\n\t\t\tif( !$client->InitWithIp(SERVER_ADDR, SERVER_XMLRPC_PORT, AdminServConfig::SERVER_CONNECTION_TIMEOUT) ){\n\t\t\t\tUtils::redirection(false, '?error='.urlencode( Utils::t('The server is not accessible.') ) );\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif( !AdminServAdminLevel::userAllowed(USER_ADMINLEVEL) ){\n\t\t\t\t\tUtils::redirection(false, '?error='.urlencode( Utils::t('You are not allowed at this admin level') ) );\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif( !$client->query('Authenticate', AdminServAdminLevel::getType(), $_SESSION['adminserv']['password']) ){\n\t\t\t\t\t\tUtils::redirection(false, '?error='.urlencode( Utils::t('The password doesn\\'t match to the server.') ) );\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif($fullInit){\n\t\t\t\t\t\t\t$client->addCall('SetApiVersion', array(date('Y-m-d')) );\n\t\t\t\t\t\t\t$client->addCall('GetVersion');\n\t\t\t\t\t\t\t$client->addCall('GetSystemInfo');\n\t\t\t\t\t\t\t$client->addCall('IsRelayServer');\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif( !$client->multiquery() ){\n\t\t\t\t\t\t\t\tself::error();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t$queriesData = $client->getMultiqueryResponse();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Version\n\t\t\t\t\t\t\t\t$getVersion = $queriesData['GetVersion'];\n\t\t\t\t\t\t\t\tdefine('SERVER_VERSION_NAME', $getVersion['Name']);\n\t\t\t\t\t\t\t\tdefine('SERVER_VERSION', $getVersion['Version']);\n\t\t\t\t\t\t\t\tdefine('SERVER_BUILD', $getVersion['Build']);\n\t\t\t\t\t\t\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t\t\t\t\t\t\tdefine('API_VERSION', $getVersion['ApiVersion']);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// SystemInfo\n\t\t\t\t\t\t\t\t$getSystemInfo = $queriesData['GetSystemInfo'];\n\t\t\t\t\t\t\t\tdefine('SERVER_LOGIN', $getSystemInfo['ServerLogin']);\n\t\t\t\t\t\t\t\tdefine('SERVER_PUBLISHED_IP', $getSystemInfo['PublishedIp']);\n\t\t\t\t\t\t\t\tdefine('SERVER_PORT', $getSystemInfo['Port']);\n\t\t\t\t\t\t\t\tdefine('SERVER_P2P_PORT', $getSystemInfo['P2PPort']);\n\t\t\t\t\t\t\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t\t\t\t\t\t\tdefine('SERVER_TITLE', $getSystemInfo['TitleId']);\n\t\t\t\t\t\t\t\t\tdefine('IS_SERVER', $getSystemInfo['IsServer']);\n\t\t\t\t\t\t\t\t\tdefine('IS_DEDICATED', $getSystemInfo['IsDedicated']);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Relay\n\t\t\t\t\t\t\t\tdefine('IS_RELAY', $queriesData['IsRelayServer']);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Protocole : tmtp ou maniaplanet\n\t\t\t\t\t\t\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t\t\t\t\t\t\tTmNick::$linkProtocol = 'maniaplanet';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdefine('LINK_PROTOCOL', TmNick::$linkProtocol);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Mode d'affichage : detail ou simple\n\t\t\t\t\t\t\t\tif( isset($_SESSION['adminserv']['mode']['general']) ){\n\t\t\t\t\t\t\t\t\tdefine('USER_MODE_GENERAL', $_SESSION['adminserv']['mode']['general']);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tdefine('USER_MODE_GENERAL', 'simple');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( isset($_SESSION['adminserv']['mode']['maps']) ){\n\t\t\t\t\t\t\t\t\tdefine('USER_MODE_MAPS', $_SESSION['adminserv']['mode']['maps']);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tdefine('USER_MODE_MAPS', 'simple');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// TmForever\n\t\t\t\t\t\t\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t\t\t\t\t\t\tarray_shift(ExtensionConfig::$GAMEMODES);\n\t\t\t\t\t\t\t\t\t$stuntsGameMode = array_pop(ExtensionConfig::$GAMEMODES);\n\t\t\t\t\t\t\t\t\t$CupGameMode = array_pop(ExtensionConfig::$GAMEMODES);\n\t\t\t\t\t\t\t\t\tExtensionConfig::$GAMEMODES[4] = $stuntsGameMode;\n\t\t\t\t\t\t\t\t\tExtensionConfig::$GAMEMODES[5] = $CupGameMode;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t$out = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t$out = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Retourne un lien protocol TM ou ManiaPlanet\n\t*\n\t* @param string $link -> Lien : #join=server_login ou /:manialink_name\n\t* @return string\n\t*/\n\tpublic static function getProtocolLink($link) {\n\t\t$out = null;\n\t\t$protocolName = 'maniaplanet';\n\t\tif (defined('LINK_PROTOCOL')) {\n\t\t\t$protocolName = LINK_PROTOCOL;\n\t\t}\n\t\t$protocolSeparator = '://';\n\t\t\n\t\tif (defined('SERVER_VERSION_NAME') && SERVER_VERSION_NAME == 'ManiaPlanet' && defined('SERVER_TITLE')) {\n\t\t\t$out = $protocolName.$protocolSeparator.$link.'@'.SERVER_TITLE;\n\t\t}\n\t\telse {\n\t\t\t$out = $protocolName.$protocolSeparator.$link;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re le nom du game mode\n\t*\n\t* @param int  $gameMode  -> La r\u00e9ponse de GetGameMode()\n\t* @param bool $getManual -> Forcer la r\u00e9cup\u00e9ration manuelle du nom \u00e0 partir du num\u00e9ro dans la config\n\t* @return string\n\t*/\n\tpublic static function getGameModeName($gameMode, $getManual = false){\n\t\t$out = Utils::t('No game mode available');\n\t\t\n\t\tif( class_exists('ExtensionConfig') && isset(ExtensionConfig::$GAMEMODES) && count(ExtensionConfig::$GAMEMODES) > 0 ){\n\t\t\tif($getManual && SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t\t$gameMode--;\n\t\t\t\tif( isset(ExtensionConfig::$GAMEMODES[$gameMode]) ){\n\t\t\t\t\t$out = ExtensionConfig::$GAMEMODES[$gameMode];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out = ExtensionConfig::$GAMEMODES[$gameMode];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* D\u00e9termine si le nom du mode de jeu fourni en param\u00e8tre correspond au mode de jeu actuel\n\t*\n\t* @param string $gameModeName    -> Nom du mode de jeu \u00e0 tester\n\t* @param int    $currentGameMode -> ID du mode de jeu courant. Si null, le mode de jeu courant est r\u00e9cup\u00e9r\u00e9 par le serveur\n\t* @return bool\n\t*/\n\tpublic static function isGameMode($gameModeName, $currentGameMode = null){\n\t\tglobal $client;\n\t\t$out = false;\n\t\tif($currentGameMode === null){\n\t\t\t$client->query('GetGameMode');\n\t\t\t$currentGameMode = $client->getResponse();\n\t\t}\n\t\t\n\t\tif($gameModeName == self::getGameModeName($currentGameMode) ){\n\t\t\t$out = true;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* V\u00e9rifie si la configuration du serveur est compatible avec le mode \u00e9quipe\n\t*\n\t* @params int    $gameMode   -> ID du mode de jeu\n\t* @params string $scriptName -> Nom du script si le mode de jeu est 0\n\t* @return bool\n\t*/\n\tpublic static function checkDisplayTeamMode($gameMode, $scriptName = null){\n\t\t$out = false;\n\t\t\n\t\tif($gameMode == 0 && SERVER_VERSION_NAME == 'ManiaPlanet' && class_exists('ExtensionConfig') && isset(ExtensionConfig::$TEAMSCRIPTS) && count(ExtensionConfig::$TEAMSCRIPTS) > 0 ){\n\t\t\tforeach(ExtensionConfig::$TEAMSCRIPTS as $teamScript){\n\t\t\t\tif( stristr($scriptName, $teamScript) ){\n\t\t\t\t\t$out = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif( self::isGameMode('Team', $gameMode) ){\n\t\t\t\t$out = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Formate le nom d'un script\n\t*\n\t* @param string $scriptName -> Le nom du script retourn\u00e9 par le serveur\n\t* @return string\n\t*/\n\tpublic static function formatScriptName($scriptName){\n\t\t$out = str_ireplace('.script.txt', '', $scriptName);\n\t\t$scriptNameEx = explode('\\\\', $out);\n\t\t$out = $scriptNameEx[count($scriptNameEx)-1];\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re les informations du serveur actuel (map, serveur, stats, joueurs)\n\t*\n\t* @param string $sortBy -> Le tri \u00e0 faire sur la liste\n\t* @return array\n\t*/\n\tpublic static function getCurrentServerInfo($sortBy = null){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t\n\t\t// JEU\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$queryName = array(\n\t\t\t\t'getMapInfo' => 'GetCurrentChallengeInfo'\n\t\t\t);\n\t\t}\n\t\telse{\n\t\t\t$queryName = array(\n\t\t\t\t'getMapInfo' => 'GetCurrentMapInfo'\n\t\t\t);\n\t\t}\n\t\t\n\t\t// REQU\u00caTES\n\t\t$client->addCall($queryName['getMapInfo']);\n\t\tif( AdminServAdminLevel::isType('Admin') ){\n\t\t\t$client->addCall('GetMapsDirectory');\n\t\t}\n\t\t$client->addCall('GetGameMode');\n\t\t$client->addCall('GetServerName');\n\t\t$client->addCall('GetStatus');\n\t\t$client->addCall('GetCurrentCallVote');\n\t\tif( AdminServAdminLevel::isType('SuperAdmin') ){\n\t\t\t$client->addCall('GetNetworkStats');\n\t\t}\n\t\t$client->addCall('GetPlayerList', array(AdminServConfig::LIMIT_PLAYERS_LIST, 0, 1) );\n\t\t\n\t\tif( !$client->multiquery() ){\n\t\t\t$out['error'] = Utils::t('Client not initialized');\n\t\t}\n\t\telse{\n\t\t\t// DONN\u00c9ES DES REQU\u00caTES\n\t\t\t$queriesData = $client->getMultiqueryResponse();\n\t\t\t\n\t\t\t// GameMode\n\t\t\t$out['srv']['gameModeId'] = $queriesData['GetGameMode'];\n\t\t\t$out['srv']['gameModeName'] = self::getGameModeName($out['srv']['gameModeId']);\n\t\t\t$out['srv']['gameModeScriptName'] = null;\n\t\t\tif( self::isGameMode('Script', $out['srv']['gameModeId']) ){\n\t\t\t\t$client->query('GetModeScriptInfo');\n\t\t\t\t$getModeScriptInfo = $client->getResponse();\n\t\t\t\tif( isset($getModeScriptInfo['Name']) ){\n\t\t\t\t\t$out['srv']['gameModeScriptName'] = self::formatScriptName($getModeScriptInfo['Name']);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$displayTeamMode = self::checkDisplayTeamMode($out['srv']['gameModeId'], $out['srv']['gameModeScriptName']);\n\t\t\t\n\t\t\t// CurrentMapInfo\n\t\t\t$currentMapInfo = $queriesData[$queryName['getMapInfo']];\n\t\t\t$out['map']['name'] = TmNick::toHtml($currentMapInfo['Name'], 10, true, false, '#999');\n\t\t\t$out['map']['uid'] = $currentMapInfo['UId'];\n\t\t\t$out['map']['author'] = $currentMapInfo['Author'];\n\t\t\t$out['map']['enviro'] = $currentMapInfo['Environnement'];\n\t\t\t\n\t\t\t// MapThumbnail\n\t\t\t$out['map']['thumb'] = null;\n\t\t\tif( isset($queriesData['GetMapsDirectory']) && $currentMapInfo['FileName'] != null){\n\t\t\t\t$mapFileName = $queriesData['GetMapsDirectory'].$currentMapInfo['FileName'];\n\t\t\t\tif( file_exists($mapFileName) ){\n\t\t\t\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t\t\t\t$Gbx = new GBXChallengeFetcher($queriesData['GetMapsDirectory'].$currentMapInfo['FileName'], false, true);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t$Gbx = new GBXChallMapFetcher(false, true);\n\t\t\t\t\t\t$Gbx->processFile($queriesData['GetMapsDirectory'].$currentMapInfo['FileName']);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$out['map']['thumb'] = base64_encode($Gbx->thumbnail);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// CurrentCallVote\n\t\t\t$out['map']['callvote']['login'] = $queriesData['GetCurrentCallVote']['CallerLogin'];\n\t\t\t$out['map']['callvote']['cmdname'] = $queriesData['GetCurrentCallVote']['CmdName'];\n\t\t\t$out['map']['callvote']['cmdparam'] = $queriesData['GetCurrentCallVote']['CmdParam'];\n\t\t\t\n\t\t\t// TeamScores (mode team)\n\t\t\tif( self::isGameMode('Team', $out['srv']['gameModeId']) ){\n\t\t\t\t$client->query('GetCurrentRanking', 2, 0);\n\t\t\t\t$currentRanking = $client->getResponse();\n\t\t\t\t$out['map']['scores']['blue'] = $currentRanking[0]['Score'];\n\t\t\t\t$out['map']['scores']['red'] = $currentRanking[1]['Score'];\n\t\t\t}\n\t\t\t\n\t\t\t// ServerName\n\t\t\t$out['srv']['name'] = TmNick::toHtml($queriesData['GetServerName'], 10, true, false, '#999');\n\t\t\t\n\t\t\t// Status\n\t\t\t$out['srv']['status'] = $queriesData['GetStatus']['Name'];\n\t\t\t\n\t\t\t// NetworkStats\n\t\t\tif( isset($queriesData['GetNetworkStats']) && count($queriesData['GetNetworkStats']) > 0 ){\n\t\t\t\t$networkStats = $queriesData['GetNetworkStats'];\n\t\t\t\t$out['net']['uptime'] = TimeDate::secToStringTime($networkStats['Uptime'], false);\n\t\t\t\t$out['net']['nbrconnection'] = $networkStats['NbrConnection'];\n\t\t\t\t$out['net']['meanconnectiontime'] = TimeDate::secToStringTime($networkStats['MeanConnectionTime'], false);\n\t\t\t\t$out['net']['meannbrplayer'] = $networkStats['MeanNbrPlayer'];\n\t\t\t\t$out['net']['recvnetrate'] = $networkStats['RecvNetRate'];\n\t\t\t\t$out['net']['sendnetrate'] = $networkStats['SendNetRate'];\n\t\t\t\t$out['net']['totalreceivingsize'] = $networkStats['TotalReceivingSize'];\n\t\t\t\t$out['net']['totalsendingsize'] = $networkStats['TotalSendingSize'];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out['net'] = null;\n\t\t\t}\n\t\t\t\n\t\t\t// PlayerList\n\t\t\t$playerList = $queriesData['GetPlayerList'];\n\t\t\t$countPlayerList = count($playerList);\n\t\t\t\n\t\t\tif( $countPlayerList > 0 ){\n\t\t\t\t$client->query('GetCurrentRanking', AdminServConfig::LIMIT_PLAYERS_LIST, 0);\n\t\t\t\t$rankingList = $client->GetResponse();\n\t\t\t\t$rankingKeyList = array(\n\t\t\t\t\t'Rank',\n\t\t\t\t\t'BestTime',\n\t\t\t\t\t'BestCheckpoints',\n\t\t\t\t\t'Score',\n\t\t\t\t\t'NbrLapsFinished',\n\t\t\t\t\t'LadderScore'\n\t\t\t\t);\n\t\t\t\t$i = 0;\n\t\t\t\tforeach($playerList as $player){\n\t\t\t\t\t// Nickname et Playerlogin\n\t\t\t\t\t$out['ply'][$i]['NickName'] = TmNick::toHtml(htmlspecialchars($player['NickName'], ENT_QUOTES, 'UTF-8'), 10, true);\n\t\t\t\t\t$out['ply'][$i]['Login'] = $player['Login'];\n\t\t\t\t\t\n\t\t\t\t\t// PlayerStatus\n\t\t\t\t\tif($player['SpectatorStatus'] != 0){ $playerStatus = Utils::t('Spectator'); }else{ $playerStatus = Utils::t('Player'); }\n\t\t\t\t\t$out['ply'][$i]['PlayerStatus'] = $playerStatus;\n\t\t\t\t\t\n\t\t\t\t\t// Others\n\t\t\t\t\t$out['ply'][$i]['PlayerId'] = $player['PlayerId'];\n\t\t\t\t\t$out['ply'][$i]['TeamId'] = $player['TeamId'];\n\t\t\t\t\tif($player['TeamId'] == 0){ $teamName = Utils::t('Blue'); }else if($player['TeamId'] == 1){ $teamName = Utils::t('Red'); }else{ $teamName = Utils::t('Spectator'); }\n\t\t\t\t\t$out['ply'][$i]['TeamName'] = $teamName;\n\t\t\t\t\t$out['ply'][$i]['SpectatorStatus'] = $player['SpectatorStatus'];\n\t\t\t\t\t\n\t\t\t\t\t// Rankings\n\t\t\t\t\tforeach($rankingKeyList as $rankName){\n\t\t\t\t\t\tif( isset($rankingList[$i][$rankName]) ){\n\t\t\t\t\t\t\t$out['ply'][$i][$rankName] = $rankingList[$i][$rankName];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif($player['LadderRanking'] == -1){\n\t\t\t\t\t\t$player['LadderRanking'] = Utils::t('Not rated');\n\t\t\t\t\t}\n\t\t\t\t\t$out['ply'][$i]['LadderRanking'] = $player['LadderRanking'];\n\t\t\t\t\t$i++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out['ply'] = Utils::t('No player');\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// Nombre de joueurs\n\t\t\tif($countPlayerList > 1){\n\t\t\t\t$out['nbp'] = $countPlayerList.' '.Utils::t('players');\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out['nbp'] = $countPlayerList.' '.Utils::t('player');\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// TRI\n\t\t\tif( is_array($out['ply']) && count($out['ply']) > 0 ){\n\t\t\t\t// Si on est en mode \u00e9quipe, on tri par \u00e9quipe\n\t\t\t\tif($displayTeamMode){\n\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByRank');\n\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByTeam');\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tswitch($sortBy){\n\t\t\t\t\t\tcase 'nickname':\n\t\t\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByNickName');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'ladder':\n\t\t\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByLadderRanking');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'login':\n\t\t\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByLogin');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'status':\n\t\t\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByStatus');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByRank');\n\t\t\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByStatus');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* @deprecated\n\t* R\u00e9cup\u00e8re le login du serveur principal \u00e0 partir d'un serveur Relai\n\t*\n\t* @return string\n\t*/\n\tpublic static function getMainServerLoginFromRelay(){\n\t\tglobal $client;\n\t\t$out = null;\n\t\t\n\t\tif( AdminServAdminLevel::isType('Admin') ){\n\t\t\tif( !$client->query('GameDataDirectory') ){\n\t\t\t\tself::error();\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// R\u00e9cup\u00e9ration du login\n\t\t\t\t$out = null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re le nombre de joueurs pr\u00e9sent sur le serveur\n\t*\n\t* @param bool $spectator -> Inclus les spectateurs dans le calcul\n\t* @return int\n\t*/\n\tpublic static function getNbPlayers($spectator = true){\n\t\tglobal $client;\n\t\t$out = 0;\n\t\t\n\t\tif( !$client->query('GetPlayerList', AdminServConfig::LIMIT_PLAYERS_LIST, 0, 1) ){\n\t\t\tself::error();\n\t\t}\n\t\telse{\n\t\t\t$playerList = $client->getResponse();\n\t\t\t$countPlayerList = count($playerList);\n\t\t\t\n\t\t\tif($spectator){\n\t\t\t\t$out = $countPlayerList;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif($countPlayerList > 0){\n\t\t\t\t\tforeach($playerList as $player){\n\t\t\t\t\t\tif($player['SpectatorStatus'] == 0){\n\t\t\t\t\t\t\t$out++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Administration rapide\n\t*\n\t* @param  string $cmd -> Le nom de la commande (PrevMap, RestartMap, NextMap ou ForceEndRound)\n\t* @return true si r\u00e9ussi, sinon un message d'erreur\n\t*/\n\tpublic static function speedAdmin($cmd){\n\t\tglobal $client;\n\t\t$out = true;\n\t\t\n\t\t// M\u00e9thode en fonction du jeu\n\t\tif($cmd != 'ForceEndRound'){\n\t\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t\t$queries = array(\n\t\t\t\t\t'restartMap' => 'RestartChallenge',\n\t\t\t\t\t'nextMap' => 'NextChallenge',\n\t\t\t\t\t'getCurrentMapIndex' => 'GetCurrentChallengeIndex',\n\t\t\t\t\t'setNextMapIndex' => 'SetNextChallengeIndex'\n\t\t\t\t);\n\t\t\t}else{\n\t\t\t\t$queries = array(\n\t\t\t\t\t'restartMap' => 'RestartMap',\n\t\t\t\t\t'nextMap' => 'NextMap',\n\t\t\t\t\t'getCurrentMapIndex' => 'GetCurrentMapIndex',\n\t\t\t\t\t'setNextMapIndex' => 'SetNextMapIndex'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Si c'est le mode Cup\n\t\t$isCupMode = false;\n\t\tif( self::isGameMode('Cup') ){\n\t\t\t$isCupMode = true;\n\t\t}\n\t\t\n\t\t// Suivant la commande demand\u00e9e\n\t\tswitch($cmd){\n\t\t\tcase 'PrevMap':\n\t\t\t\tif( !$client->query($queries['getCurrentMapIndex']) ){\n\t\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t$currentMapIndex = $client->getResponse();\n\t\t\t\t\tif($currentMapIndex === 0){\n\t\t\t\t\t\t$nbMaps = self::getNbMaps( self::getMapList() );\n\t\t\t\t\t\t$prevMapIndex =  $nbMaps['nbm']['count'] - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t$prevMapIndex = $currentMapIndex - 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif( !$client->query($queries['setNextMapIndex'], $prevMapIndex) ){\n\t\t\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tself::speedAdmin('NextMap');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'RestartMap':\n\t\t\t\tif( !$client->query($queries['restartMap'], $isCupMode) ){\n\t\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'NextMap':\n\t\t\t\tif( !$client->query($queries['nextMap'], $isCupMode) ){\n\t\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'ForceEndRound':\n\t\t\t\tif($isCupMode){\n\t\t\t\t\tif( !$client->query($queries['nextMap']) ){\n\t\t\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif( !$client->query('ForceEndRound') ){\n\t\t\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$out = Utils::t('Unknown command');\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re les options du serveur\n\t*\n\t* @global resource $client -> Le client doit \u00eatre initialis\u00e9\n\t* @return array\n\t*/\n\tpublic static function getServerOptions(){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$client->addCall('GetServerOptions', array(1) );\n\t\t}\n\t\telse{\n\t\t\t$client->addCall('GetServerOptions');\n\t\t}\n\t\t$client->addCall('GetBuddyNotification', array('') );\n\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t$client->addCall('AreHornsDisabled');\n\t\t}\n\t\t\n\t\tif( !$client->multiquery() ){\n\t\t\tself::error();\n\t\t}\n\t\telse{\n\t\t\t$queriesData = $client->getMultiqueryResponse();\n\t\t\t$out = $queriesData['GetServerOptions'];\n\t\t\t$out['Name'] = stripslashes($out['Name']);\n\t\t\tif($out['Name'] == null){\n\t\t\t\t$out['Name'] = SERVER_NAME;\n\t\t\t}\n\t\t\t$out['NameHtml'] = TmNick::toHtml($out['Name'], 10, false, false, '#666');\n\t\t\t$out['Comment'] = stripslashes($out['Comment']);\n\t\t\t$out['CommentHtml'] = TmNick::toHtml('$i'.nl2br($out['Comment']), 10, false, false, '#666');\n\t\t\tif($out['CurrentLadderMode'] !== 0){\n\t\t\t\t$out['CurrentLadderModeName'] = Utils::t('Forced'); \n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out['CurrentLadderModeName'] = Utils::t('Inactive');\n\t\t\t}\n\t\t\tif($out['CurrentVehicleNetQuality'] !== 0){\n\t\t\t\t$out['CurrentVehicleNetQualityName'] = Utils::t('High');\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out['CurrentVehicleNetQualityName'] = Utils::t('Fast');\n\t\t\t}\n\t\t\t$out['BuddyNotification'] = $queriesData['GetBuddyNotification'];\n\t\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t\t$out['DisableHorns'] = $queriesData['AreHornsDisabled'];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out['DisableHorns'] = null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Retourne la structure pour l'enregistrement des options du serveur\n\t*\n\t* @return array\n\t*/\n\tpublic static function getServerOptionsStruct(){\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$keys = array(\n\t\t\t\t'allowMapDownload' => 'AllowChallengeDownload'\n\t\t\t);\n\t\t}\n\t\telse{\n\t\t\t$keys = array(\n\t\t\t\t'allowMapDownload' => 'AllowMapDownload'\n\t\t\t);\n\t\t}\n\t\t\n\t\t$out = array(\n\t\t\t'Name' => stripslashes($_POST['Name']),\n\t\t\t'Comment' => stripslashes($_POST['Comment']),\n\t\t\t'Password' => trim($_POST['Password']),\n\t\t\t'PasswordForSpectator' => trim($_POST['PasswordForSpectator']),\n\t\t\t'NextMaxPlayers' => intval($_POST['NextMaxPlayers']),\n\t\t\t'NextMaxSpectators' => intval($_POST['NextMaxSpectators']),\n\t\t\t'IsP2PUpload' => array_key_exists('IsP2PUpload', $_POST),\n\t\t\t'IsP2PDownload' => array_key_exists('IsP2PDownload', $_POST),\n\t\t\t'NextLadderMode' => intval($_POST['NextLadderMode']),\n\t\t\t'NextVehicleNetQuality' => intval($_POST['NextVehicleNetQuality']),\n\t\t\t'NextCallVoteTimeOut' => TimeDate::secToMillisec( intval($_POST['NextCallVoteTimeOut']) ),\n\t\t\t'CallVoteRatio' => (double)$_POST['CallVoteRatio'],\n\t\t\t$keys['allowMapDownload'] => array_key_exists('AllowMapDownload', $_POST),\n\t\t\t'AutoSaveReplays' => array_key_exists('AutoSaveReplays', $_POST),\n\t\t\t'HideServer' => (int)array_key_exists('HideServer', $_POST),\n\t\t\t'BuddyNotification' => array_key_exists('BuddyNotification', $_POST),\n\t\t\t\n\t\t);\n\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t$out['ClientInputsMaxLatency'] = ($_POST['ClientInputsMaxLatency'] == 'more') ? $_POST['ClientInputsMaxLatencyValue'] : $_POST['ClientInputsMaxLatency'];\n\t\t\t$out['DisableHorns'] = array_key_exists('DisableHorns', $_POST);\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Enregistre les options du serveur\n\t*\n\t* @param array $struct -> Structure contenant les champs demand\u00e9s par la m\u00e9thode SetServerOptions()\n\t*/\n\tpublic static function setServerOptions($struct){\n\t\tglobal $client;\n\t\t$out = false;\n\t\t\n\t\tif( !$client->query('SetServerOptions', $struct) ){\n\t\t\tself::error();\n\t\t}\n\t\telse{\n\t\t\t$client->addCall('SetHideServer', array($struct['HideServer']) );\n\t\t\t$client->addCall('SetBuddyNotification', array('', $struct['BuddyNotification']) );\n\t\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t\t$client->addCall('SetClientInputsMaxLatency', array($struct['ClientInputsMaxLatency']) );\n\t\t\t\t$client->addCall('DisableHorns', array($struct['DisableHorns']) );\n\t\t\t}\n\t\t\t\n\t\t\tif( !$client->multiquery() ){\n\t\t\t\tself::error();\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Exporte les options du serveur dans un fichier\n\t*\n\t* @param  string $file -> Chemin du fichier \u00e0 \u00e9crire\n\t* @param  array  $data -> Structure des options du serveur \u00e0 \u00e9crire\n\t* @return bool\n\t*/\n\tpublic static function exportServerOptions($file, $data){\n\t\t$out = false;\n\t\t\n\t\t$xml = new DOMDocument('1.0', 'utf-8');\n\t\t$xml->formatOutput = true;\n\t\t$srvopts = $xml->createElement('ServerOptions');\n\t\t$srvopts = $xml->appendChild($srvopts);\n\t\tforeach($data as $dataField => $dataValue){\n\t\t\t$srvoptsElement = $xml->createElement($dataField, $dataValue);\n\t\t\t$srvoptsElementAttribute = $xml->createAttribute('type');\n\t\t\t$srvoptsElementAttribute->value = Str::getValueType($dataValue);\n\t\t\t$srvoptsElement->appendChild($srvoptsElementAttribute);\n\t\t\t$srvoptsElement = $srvopts->appendChild($srvoptsElement);\n\t\t}\n\t\t\n\t\tif( $result = $xml->save($file) > 0 ){\n\t\t\t$out = true;\n\t\t\tself::info( Utils::t('Server options are exported in').' '.$file);\n\t\t}\n\t\telse{\n\t\t\tself::error( Utils::t('Unable to export server options') );\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Importe les options du serveur depuis un fichier\n\t*\n\t* @param  string $file -> Chemin du fichier \u00e0 lire\n\t* @return array\n\t*/\n\tpublic static function importServerOptions($file){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t\n\t\tif( file_exists($file) ){\n\t\t\t$dom = new DOMDocument();\n\t\t\t$dom->load($file);\n\t\t\t$srvopts = $dom->childNodes->item(0);\n\t\t\t\n\t\t\tfor($i = 0; $i < $srvopts->childNodes->length; $i++){\n\t\t\t\t$srvoptsElement = $srvopts->childNodes->item($i);\n\t\t\t\tif($srvoptsElement->nodeName != '#text'){\n\t\t\t\t\t$out[$srvoptsElement->nodeName] = Str::setValueType($srvoptsElement->nodeValue, $srvoptsElement->getAttribute('type') );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tself::error( Utils::t('No such file or file is not readable').' : '.$file);\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re les informations de jeux\n\t*\n\t* @global resource $client -> Le client doit \u00eatre initialis\u00e9\n\t* @return array\n\t*/\n\tpublic static function getGameInfos(){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t\n\t\t// Jeu\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$queries = array(\n\t\t\t\t'CupRoundsPerMap' => 'GetCupRoundsPerChallenge',\n\t\t\t);\n\t\t}\n\t\telse{\n\t\t\t$queries = array(\n\t\t\t\t'CupRoundsPerMap' => 'GetCupRoundsPerMap',\n\t\t\t);\n\t\t}\n\t\t\n\t\t// Requ\u00eates\n\t\t$client->addCall('GetGameInfos');\n\t\t$client->addCall('GetAllWarmUpDuration');\n\t\t$client->addCall('GetDisableRespawn');\n\t\t$client->addCall('GetForceShowAllOpponents');\n\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t$client->addCall('GetScriptName');\n\t\t}\n\t\t$client->addCall('GetCupPointsLimit');\n\t\t$client->addCall($queries['CupRoundsPerMap']);\n\t\t$client->addCall('GetCupNbWinners');\n\t\t$client->addCall('GetCupWarmUpDuration');\n\t\t$client->addCall('GetRoundCustomPoints');\n\t\t\n\t\tif( !$client->multiquery() ){\n\t\t\tself::error();\n\t\t}\n\t\telse{\n\t\t\t$queriesData = $client->getMultiqueryResponse();\n\t\t\t\n\t\t\t// Game infos\n\t\t\t$currGamInf = $queriesData['GetGameInfos']['CurrentGameInfos'];\n\t\t\t$nextGamInf = $queriesData['GetGameInfos']['NextGameInfos'];\n\t\t\t\n\t\t\t// Nb de WarmUp\n\t\t\t$currGamInf['AllWarmUpDuration'] = $queriesData['GetAllWarmUpDuration']['CurrentValue'];\n\t\t\t$nextGamInf['AllWarmUpDuration'] = $queriesData['GetAllWarmUpDuration']['NextValue'];\n\t\t\t\n\t\t\t// Respawn\n\t\t\t$currGamInf['DisableRespawn'] = $queriesData['GetDisableRespawn']['CurrentValue'];\n\t\t\t$nextGamInf['DisableRespawn'] = $queriesData['GetDisableRespawn']['NextValue'];\n\t\t\t\n\t\t\t// ForceShowAllOpponents\n\t\t\t$currGamInf['ForceShowAllOpponents'] = $queriesData['GetForceShowAllOpponents']['CurrentValue'];\n\t\t\t$nextGamInf['ForceShowAllOpponents'] = $queriesData['GetForceShowAllOpponents']['NextValue'];\n\t\t\t\n\t\t\t// ScriptName\n\t\t\t$currGamInf['ScriptName'] = null;\n\t\t\t$nextGamInf['ScriptName'] = null;\n\t\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t\t$currGamInf['ScriptName'] = $queriesData['GetScriptName']['CurrentValue'];\n\t\t\t\t$nextGamInf['ScriptName'] = $queriesData['GetScriptName']['NextValue'];\n\t\t\t}\n\t\t\t\n\t\t\t// Mode Cup\n\t\t\t$currGamInf['CupPointsLimit'] = $queriesData['GetCupPointsLimit']['CurrentValue'];\n\t\t\t$nextGamInf['CupPointsLimit'] = $queriesData['GetCupPointsLimit']['NextValue'];\n\t\t\t$currGamInf['CupRoundsPerMap'] = $queriesData[$queries['CupRoundsPerMap']]['CurrentValue'];\n\t\t\t$nextGamInf['CupRoundsPerMap'] = $queriesData[$queries['CupRoundsPerMap']]['NextValue'];\n\t\t\t$currGamInf['CupNbWinners'] = $queriesData['GetCupNbWinners']['CurrentValue'];\n\t\t\t$nextGamInf['CupNbWinners'] = $queriesData['GetCupNbWinners']['NextValue'];\n\t\t\t$currGamInf['CupWarmUpDuration'] = $queriesData['GetCupWarmUpDuration']['CurrentValue'];\n\t\t\t$nextGamInf['CupWarmUpDuration'] = $queriesData['GetCupWarmUpDuration']['NextValue'];\n\t\t\t\n\t\t\t// RoundCustomPoints\n\t\t\t$RoundCustomPoints = implode(',', $queriesData['GetRoundCustomPoints']);\n\t\t\t$currGamInf['RoundCustomPoints'] = $RoundCustomPoints;\n\t\t\t$nextGamInf['RoundCustomPoints'] = $RoundCustomPoints;\n\t\t\t\n\t\t\t// Retour\n\t\t\t$out['curr'] = $currGamInf;\n\t\t\t$out['next'] = $nextGamInf;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Retourne la structure pour l'enregistrement des informations de jeu\n\t*\n\t* @return array\n\t*/\n\tpublic static function getGameInfosStructFromPOST(){\n\t\tif($_POST['NextFinishTimeoutValue'] < 2){\n\t\t\tif($_POST['NextFinishTimeout'] == 0){ $FinishTimeout = 0; }\n\t\t\telse if($_POST['NextFinishTimeout'] == 1){ $FinishTimeout = 1; }\n\t\t}\n\t\telse{ $FinishTimeout = TimeDate::secToMillisec( intval($_POST['NextFinishTimeoutValue']) ); }\n\t\tif( array_key_exists('NextDisableRespawn', $_POST) === true ){ $DisableRespawn = false; }\n\t\telse{ $DisableRespawn = true; }\n\t\tif($_POST['NextForceShowAllOpponentsValue'] < 2){\n\t\t\tif($_POST['NextForceShowAllOpponents'] == 0){ $NextForceShowAllOpponents = 0; }\n\t\t\telse if($_POST['NextForceShowAllOpponents'] == 1){ $NextForceShowAllOpponents = 1; }\n\t\t}\n\t\telse{ $NextForceShowAllOpponents = intval($_POST['NextForceShowAllOpponentsValue']); }\n\t\t\n\t\t$out = array(\n\t\t\t'GameMode' => intval($_POST['NextGameMode']),\n\t\t\t'ChatTime' => TimeDate::secToMillisec( intval($_POST['NextChatTime'] - 8) ),\n\t\t\t'RoundsPointsLimit' => intval($_POST['NextRoundsPointsLimit']),\n\t\t\t'RoundCustomPoints' => intval($_POST['NextRoundCustomPoints']),\n\t\t\t'RoundsUseNewRules' => array_key_exists('NextRoundsUseNewRules', $_POST),\n\t\t\t'RoundsForcedLaps' => intval($_POST['NextRoundsForcedLaps']),\n\t\t\t'RoundsPointsLimitNewRules' => intval($_POST['NextRoundsPointsLimit']),\n\t\t\t'TimeAttackLimit' => TimeDate::secToMillisec( intval($_POST['NextTimeAttackLimit']) ),\n\t\t\t'TimeAttackSynchStartPeriod' => TimeDate::secToMillisec( intval($_POST['NextTimeAttackSynchStartPeriod']) ),\n\t\t\t'TeamPointsLimit' => intval($_POST['NextTeamPointsLimit']),\n\t\t\t'TeamMaxPoints' => intval($_POST['NextTeamMaxPoints']),\n\t\t\t'TeamUseNewRules' => array_key_exists('NextTeamUseNewRules', $_POST),\n\t\t\t'TeamPointsLimitNewRules' => intval($_POST['NextTeamPointsLimit']),\n\t\t\t'LapsNbLaps' => intval($_POST['NextLapsNbLaps']),\n\t\t\t'LapsTimeLimit' => TimeDate::secToMillisec( intval($_POST['NextLapsTimeLimit']) ),\n\t\t\t'FinishTimeout' => $FinishTimeout,\n\t\t\t'AllWarmUpDuration' => intval($_POST['NextAllWarmUpDuration']),\n\t\t\t'DisableRespawn' => $DisableRespawn,\n\t\t\t'ForceShowAllOpponents' => $NextForceShowAllOpponents,\n\t\t\t'CupPointsLimit' => intval($_POST['NextCupPointsLimit']),\n\t\t\t'CupRoundsPerMap' => intval($_POST['NextCupRoundsPerMap']),\n\t\t\t'CupNbWinners' => intval($_POST['NextCupNbWinners']),\n\t\t\t'CupWarmUpDuration' => intval($_POST['NextCupWarmUpDuration'])\n\t\t);\n\t\tif(SERVER_VERSION_NAME != 'TmForever'){\n\t\t\t$out += array('ScriptName' => $_POST['NextScriptName']);\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Enregistre les infos sur les \u00e9quipes\n\t* @param array $team1 -> (assoc) array(name, color (0 to 1), country)\n\t* @param array $team2\n\t* @return bool\n\t*/\n\tpublic static function setTeamInfo($team1, $team2){\n\t\tglobal $client;\n\t\t$out = false;\n\t\t\n\t\tif( !$client->query('SetTeamInfo', 'Unused', 0., 'World', $team1['name'], (double)$team1['color'], $team1['country'], $team2['name'], (double)$team2['color'], $team2['country']) ){\n\t\t\tAdminServ::error();\n\t\t}\n\t\telse{\n\t\t\t$_SESSION['adminserv']['teaminfo'] = array(\n\t\t\t\t'team1' => $team1,\n\t\t\t\t'team2' => $team2\n\t\t\t);\n\t\t\t$out = true;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Add chat line on server\n\t*\n\t* @param string $message       -> Text message\n\t* @param string $nickname      -> Nickname\n\t* @param string $color         -> Text color\n\t* @param string $destination   -> Message destination: server or player login\n\t* @param string $showAdminText -> Display \"Admin\" before the message\n\t* @return bool or text error\n\t*/\n\tpublic static function addChatServerLine($message, $nickname = null, $color = '$ff0', $destination = 'server', $showAdminText = false){\n\t\tglobal $client;\n\t\t$out = false;\n\t\t$admin = null;\n\t\tUtils::addCookieData('adminserv_user', array(AdminServUI::theme(), AdminServUI::lang(), $nickname, $color), AdminServConfig::COOKIE_EXPIRE);\n\t\t\n\t\tif($showAdminText){\n\t\t\t$admin = '$fffAdmin:';\n\t\t}\n\t\t\n\t\tif($nickname){\n\t\t\t$nickname = '$g$ff0'.TmNick::stripNadeoCode($nickname, array('$s') );\n\t\t}\n\t\t\n\t\t$nickname = '$s$ff0['.$admin.$nickname.'$z$s$ff0]$z';\n\t\t$message = $nickname.' '.$color.$message;\n\t\t$_SESSION['adminserv']['chat_dst'] = $destination;\n\t\t\n\t\tif($destination === 'server'){\n\t\t\tif( !$client->query('ChatSendServerMessage', $message) ){\n\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif( !$client->query('ChatSendServerMessageToLogin', $message, $destination) ){\n\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re les lignes du chat serveur\n\t*\n\t* @param bool $hideServerLines -> Masquer les lignes provenant d'un gestionnaire de serveur\n\t* @return string\n\t*/\n\tpublic static function getChatServerLines($hideServerLines = false){\n\t\tglobal $client;\n\t\t$out = null;\n\t\t\n\t\tif( !$client->query('GetChatLines') ){\n\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t}\n\t\telse{\n\t\t\t$langCode = AdminServUI::lang();\n\t\t\t$chatLines = $client->getResponse();\n\t\t\t\n\t\t\tforeach($chatLines as $line){\n\t\t\t\tif( self::isServerLine($line) ){\n\t\t\t\t\tif($hideServerLines){\n\t\t\t\t\t\tunset($line);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t$tradLines = array(\n\t\t\t\t\t\t\t'$99FThis round is a draw.',\n\t\t\t\t\t\t\t'$99FThe $<$00FBlue team$> wins this round.',\n\t\t\t\t\t\t\t'$99FThe $<$F00Red team$> wins this round.'\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif( in_array($line, $tradLines) ){\n\t\t\t\t\t\t\tforeach($tradLines as $tradLine){\n\t\t\t\t\t\t\t\tif($line == $tradLine){\n\t\t\t\t\t\t\t\t\tif($langCode == 'en'){\n\t\t\t\t\t\t\t\t\t\t$line = '$999'.TmNick::toText( TmNick::stripNadeoCode($tradLine, array('$<', '$>')) );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t$line = '$999'.TmNick::toText( Utils::t($tradLine) );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif( strstr($line, '$fffAdmin:') ){\n\t\t\t\t\t\t\t\t$pattern = '$ff0]$z';\n\t\t\t\t\t\t\t\t$lineEx = explode($pattern, $line);\n\t\t\t\t\t\t\t\t$nickname = $lineEx[0].$pattern;\n\t\t\t\t\t\t\t\t$message = TmNick::toText( trim($lineEx[1]) );\n\t\t\t\t\t\t\t\t$line = $nickname.' $666'.$message;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t$line = '$999'.TmNick::toText($line);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t$lineEx = explode('$>', $line);\n\t\t\t\t\t$nickname = TmNick::stripNadeoCode($lineEx[0], array('$s', '[$<') );\n\t\t\t\t\t$message = TmNick::toText( substr($lineEx[1], 2) );\n\t\t\t\t\t\n\t\t\t\t\t$line = '$s$ff0['.$nickname.'$g$ff0]$z $666'.$message;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( isset($line) ){\n\t\t\t\t\t$out .= TmNick::toHtml($line, 10);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Retourne true si la ligne est g\u00e9n\u00e9r\u00e9e par le serveur\n\t*\n\t* @param string $line -> La ligne de la r\u00e9ponse GetChatLines\n\t* @return bool\n\t*/\n\tpublic static function isServerLine($line){\n\t\t$out = false;\n\t\t$char = substr(utf8_decode($line), 0, 1);\n\t\t\n\t\tif($char == '<' || $char == '/' || substr($line, 0, 4) == '$99F' || substr($line, 0, 12) == 'Invalid time' || $char == '?'){\n\t\t\t$out = true;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re le chemin du dossier \"Maps\"\n\t*\n\t* @global resource $client -> Le client doit \u00eatre initialis\u00e9\n\t* @return string\n\t*/\n\tpublic static function getMapsDirectoryPath(){\n\t\tglobal $client;\n\t\t$out = null;\n\t\t\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$queryName = 'GetTracksDirectory';\n\t\t}\n\t\telse{\n\t\t\t$queryName = 'GetMapsDirectory';\n\t\t}\n\t\t\n\t\tif( !$client->query($queryName) ){\n\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t}\n\t\telse{\n\t\t\t$out = Str::toSlash( $client->getResponse() );\n\t\t\tif( substr($out, -1, 1) != '/'){ $out .= '/'; }\n\t\t\tif(SERVER_MAPS_BASEPATH){\n\t\t\t\t$out .= Str::toSlash(SERVER_MAPS_BASEPATH);\n\t\t\t\tif( substr($out, -1, 1) != '/'){ $out .= '/'; }\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Retourne un tableau avec le nombre de maps et l'intitul\u00e9\n\t*\n\t* @param array $array -> La tableau contenant la liste des maps\n\t* @return array\n\t*/\n\tpublic static function getNbMaps($array){\n\t\t$out = array();\n\t\t\n\t\tif( isset($array['lst']) && is_array($array['lst']) ){\n\t\t\t$countMapsList = count($array['lst']);\n\t\t}\n\t\telse{\n\t\t\t$countMapsList = 0;\n\t\t}\n\t\t\n\t\t$out['nbm']['count'] = $countMapsList;\n\t\tif($countMapsList > 1){\n\t\t\t$out['nbm']['title'] = Utils::t('maps');\n\t\t}\n\t\telse{\n\t\t\t$out['nbm']['title'] = Utils::t('map');\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re la liste des maps sur le serveur\n\t*\n\t* @global resource $client -> Le client doit \u00eatre initialis\u00e9\n\t* @param  string   $sortBy -> Le tri \u00e0 faire sur la liste\n\t* @return array\n\t*/\n\tpublic static function getMapList($sortBy = null){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t\n\t\t// M\u00e9thodes\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$queryName = array(\n\t\t\t\t'mapList' => 'GetChallengeList',\n\t\t\t\t'mapIndex' => 'GetCurrentChallengeIndex'\n\t\t\t);\n\t\t}\n\t\telse{\n\t\t\t$queryName = array(\n\t\t\t\t'mapList' => 'GetMapList',\n\t\t\t\t'mapIndex' => 'GetCurrentMapIndex'\n\t\t\t);\n\t\t}\n\t\t\n\t\t// MAPSLIST\n\t\tif( !$client->query($queryName['mapList'], AdminServConfig::LIMIT_MAPS_LIST, 0) ){\n\t\t\t$out['error'] = Utils::t('Client not initialized');\n\t\t}\n\t\telse{\n\t\t\t$mapList = $client->getResponse();\n\t\t\t$countMapList = count($mapList);\n\t\t\t$client->query($queryName['mapIndex']);\n\t\t\t$out['cid'] = $client->getResponse();\n\t\t\t\n\t\t\tif( $countMapList > 0 ){\n\t\t\t\t$i = 0;\n\t\t\t\tforeach($mapList as $map){\n\t\t\t\t\t// Name\n\t\t\t\t\t$name = htmlspecialchars($map['Name'], ENT_QUOTES, 'UTF-8');\n\t\t\t\t\t$out['lst'][$i]['Name'] = TmNick::toHtml($name, 10, true);\n\t\t\t\t\t\n\t\t\t\t\t// Environnement\n\t\t\t\t\t$env = $map['Environnement'];\n\t\t\t\t\tif($env == 'Speed'){ $env = 'Desert'; }else if($env == 'Alpine'){ $env = 'Snow'; }\n\t\t\t\t\t$out['lst'][$i]['Environment'] = $env;\n\t\t\t\t\t\n\t\t\t\t\t// Autres\n\t\t\t\t\t$out['lst'][$i]['UId'] = $map['UId'];\n\t\t\t\t\t$out['lst'][$i]['FileName'] = $map['FileName'];\n\t\t\t\t\t$out['lst'][$i]['Author'] = $map['Author'];\n\t\t\t\t\t$out['lst'][$i]['GoldTime'] = TimeDate::format($map['GoldTime']);\n\t\t\t\t\t$out['lst'][$i]['CopperPrice'] = $map['CopperPrice'];\n\t\t\t\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t\t\t\t$out['lst'][$i]['Type']['Name'] = self::formatScriptName($map['MapType']);\n\t\t\t\t\t\t$out['lst'][$i]['Type']['FullName'] = $map['MapType'];\n\t\t\t\t\t\t$out['lst'][$i]['Style']['Name'] = self::formatScriptName($map['MapStyle']);\n\t\t\t\t\t\t$out['lst'][$i]['Style']['FullName'] = $map['MapStyle'];\n\t\t\t\t\t}\n\t\t\t\t\t$i++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Nombre de maps\n\t\t\t$out += self::getNbMaps($out);\n\t\t\tif($out['nbm']['count'] == 0){\n\t\t\t\t$out['lst'] = Utils::t('No map');\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// TRI\n\t\t\tif($sortBy != null){\n\t\t\t\tif( is_array($out['lst']) && count($out['lst']) > 0 ){\n\t\t\t\t\tswitch($sortBy){\n\t\t\t\t\t\tcase 'name':\n\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByName');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'env':\n\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByEnviro');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'author':\n\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByAuthor');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'goldtime':\n\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByGoldTime');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'cost':\n\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByPrice');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$out['lst'] = array_values($out['lst']);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re la liste des maps sur le serveur et retourne un champ en particulier\n\t*\n\t* @global resource $client -> Le client doit \u00eatre initialis\u00e9\n\t* @return array\n\t*/\n\tpublic static function getMapListField($field){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t\n\t\t// M\u00e9thodes\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$queryName = array(\n\t\t\t\t'mapList' => 'GetChallengeList',\n\t\t\t);\n\t\t}\n\t\telse{\n\t\t\t$queryName = array(\n\t\t\t\t'mapList' => 'GetMapList',\n\t\t\t);\n\t\t}\n\t\t\n\t\t// Mapslist\n\t\tif( !$client->query($queryName['mapList'], AdminServConfig::LIMIT_MAPS_LIST, 0) ){\n\t\t\t$out['error'] = Utils::t('Client not initialized');\n\t\t}\n\t\telse{\n\t\t\t$mapList = $client->getResponse();\n\t\t\t$countMapList = count($mapList);\n\t\t\tif( $countMapList > 0 ){\n\t\t\t\t$i = 0;\n\t\t\t\tforeach($mapList as $map){\n\t\t\t\t\tswitch($field){\n\t\t\t\t\t\tcase 'Name':\n\t\t\t\t\t\t\t$name = htmlspecialchars($map['Name'], ENT_QUOTES, 'UTF-8');\n\t\t\t\t\t\t\t$out[] = TmNick::toHtml($name, 10, true);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Environment':\n\t\t\t\t\t\t\t$env = $map['Environnement'];\n\t\t\t\t\t\t\tif($env == 'Speed'){ $env = 'Desert'; }else if($env == 'Alpine'){ $env = 'Snow'; }\n\t\t\t\t\t\t\t$out[] = $env;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'UId':\n\t\t\t\t\t\t\t$out[] = $map['UId'];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'FileName':\n\t\t\t\t\t\t\t$out[] = $map['FileName'];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Author':\n\t\t\t\t\t\t\t$out[] = $map['Author'];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'GoldTime':\n\t\t\t\t\t\t\t$out[] = TimeDate::format($map['GoldTime']);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'CopperPrice':\n\t\t\t\t\t\t\t$out[] = $map['CopperPrice'];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'MapType':\n\t\t\t\t\t\t\t$out[] = $map['MapType'];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'MapStyle':\n\t\t\t\t\t\t\t$out[] = $map['MapStyle'];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t$i++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re la liste des maps en local \u00e0 partir d'un chemin\n\t*\n\t* @param string $path   -> Le chemin du dossier \u00e0 lister\n\t* @param string $sortBy -> Le tri \u00e0 faire sur la liste\n\t* @return array\n\t*/\n\tpublic static function getLocalMapList($directory, $currentPath, $sortBy = null){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t\n\t\tif( is_array($directory) ){\n\t\t\tif( !empty($directory['files']) ){\n\t\t\t\t// R\u00e9cup\u00e9ration du cache existant\n\t\t\t\t$mapsDirectoryPath = self::getMapsDirectoryPath();\n\t\t\t\t$cache = new AdminServCache();\n\t\t\t\t$cacheKey = 'mapslist-'.Str::replaceChars($mapsDirectoryPath.$currentPath);\n\t\t\t\t$cacheMaps = $cache->get($cacheKey);\n\t\t\t\t\n\t\t\t\t// Fichiers\n\t\t\t\t$files = array();\n\t\t\t\tforeach($directory['files'] as $fileName => $fileValues){\n\t\t\t\t\t$dbExt = File::getDoubleExtension($fileName);\n\t\t\t\t\tif( in_array($dbExt, AdminServConfig::$MAP_EXTENSION) ){\n\t\t\t\t\t\t$files[$fileName] = $fileValues;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Suppression du cache en trop\n\t\t\t\t$cacheOverFiles = array_diff_key($cacheMaps, $files);\n\t\t\t\tif( !empty($cacheOverFiles) ){\n\t\t\t\t\tforeach($cacheOverFiles as $fileName => $fileValues){\n\t\t\t\t\t\tif( isset($cacheMaps[$fileName]) ){\n\t\t\t\t\t\t\tunset($cacheMaps[$fileName]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$cache->set($cacheKey, $cacheMaps);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Ajout des fichiers manquant dans le cache\n\t\t\t\t$cacheMissingFiles = array_diff_key($files, $cacheMaps);\n\t\t\t\tif( !empty($cacheMissingFiles) ){\n\t\t\t\t\t// Path\n\t\t\t\t\t$path = $mapsDirectoryPath.$currentPath;\n\t\t\t\t\t\n\t\t\t\t\t// Cr\u00e9ation du cache\n\t\t\t\t\tforeach($cacheMissingFiles as $file => $values){\n\t\t\t\t\t\t// Donn\u00e9es\n\t\t\t\t\t\t$processFile = utf8_decode($file);\n\t\t\t\t\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t\t\t\t\t$Gbx = new GBXChallengeFetcher($path.$processFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t$Gbx = new GBXChallMapFetcher();\n\t\t\t\t\t\t\t$Gbx->processFile($path.$processFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Name\n\t\t\t\t\t\t$filename = $Gbx->name;\n\t\t\t\t\t\tif($filename == 'read error'){\n\t\t\t\t\t\t\t$filename = str_ireplace('.'.$dbExt, '', $file);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$name = htmlspecialchars($filename, ENT_QUOTES, 'UTF-8');\n\t\t\t\t\t\t$out['lst'][$file]['Name'] = TmNick::toHtml($name, 10, true);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Environnement\n\t\t\t\t\t\t$env = $Gbx->envir;\n\t\t\t\t\t\tif($env == 'read error'){ $env = null; }\n\t\t\t\t\t\tif($env == 'Speed'){ $env = 'Desert'; }else if($env == 'Alpine'){ $env = 'Snow'; }\n\t\t\t\t\t\t$out['lst'][$file]['Environment'] = $env;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Autres\n\t\t\t\t\t\t$out['lst'][$file]['FileName'] = $currentPath.$file;\n\t\t\t\t\t\t$uid = $Gbx->uid;\n\t\t\t\t\t\tif($uid == 'read error'){ $uid = null; }\n\t\t\t\t\t\t$out['lst'][$file]['UId'] = $uid;\n\t\t\t\t\t\t$author = $Gbx->author;\n\t\t\t\t\t\tif($author == 'read error'){ $author = null; }\n\t\t\t\t\t\t$out['lst'][$file]['Author'] = $author;\n\t\t\t\t\t\t$out['lst'][$file]['Recent'] = $values['recent'];\n\t\t\t\t\t\t\n\t\t\t\t\t\t// MapType\n\t\t\t\t\t\t$mapType = $Gbx->mapType;\n\t\t\t\t\t\tif($mapType == null && $Gbx->typeName != null){\n\t\t\t\t\t\t\t$mapType = $Gbx->typeName;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$out['lst'][$file]['Type']['Name'] = self::formatScriptName($mapType);\n\t\t\t\t\t\t$out['lst'][$file]['Type']['FullName'] = $mapType;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Mise \u00e0 jour du cache\n\t\t\t\t\tif( !empty($cacheMaps) ){\n\t\t\t\t\t\t$out['lst'] = array_merge($cacheMaps, $out['lst']);\n\t\t\t\t\t}\n\t\t\t\t\t$cache->set($cacheKey, $out['lst']);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t$out['lst'] = $cacheMaps;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Maps on server?\n\t\t\t\t$currentMapsListUId = null;\n\t\t\t\tif(AdminServConfig::LOCAL_GET_MAPS_ON_SERVER){\n\t\t\t\t\t$currentMapsListUId = self::getMapListField('UId');\n\t\t\t\t}\n\t\t\t\tforeach($out['lst'] as &$file){\n\t\t\t\t\t$file['OnServer'] = false;\n\t\t\t\t\tif($currentMapsListUId){\n\t\t\t\t\t\tif( in_array($file['UId'], $currentMapsListUId) ){\n\t\t\t\t\t\t\t$file['OnServer'] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Nombre de maps\n\t\t\t\t$out += self::getNbMaps($out);\n\t\t\t\tif($out['nbm']['count'] == 0){\n\t\t\t\t\t$out['lst'] = Utils::t('No map');\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// TRIS\n\t\t\t\t\tif($sortBy != null){\n\t\t\t\t\t\tswitch($sortBy){\n\t\t\t\t\t\t\tcase 'filename':\n\t\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByFileName');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'name':\n\t\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByName');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'env':\n\t\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByEnviro');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'type':\n\t\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByType');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'author':\n\t\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByAuthor');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out += self::getNbMaps($out);\n\t\t\t\t$out['lst'] = Utils::t('No map');\n\t\t\t}\n\t\t}\n\t\t// Retour des erreurs de la m\u00e9thode read\n\t\telse{\n\t\t\t$out = $directory;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re la liste des matchsettings en local \u00e0 partir d'un chemin\n\t*\n\t* @param string $path -> Le chemin du dossier \u00e0 lister\n\t* @return array\n\t*/\n\tpublic static function getLocalMatchSettingList($directory, $currentPath){\n\t\t$out = array();\n\t\t\n\t\tif( is_array($directory) ){\n\t\t\tif( !empty($directory['files']) ){\n\t\t\t\t$mapsDirectoryPath = self::getMapsDirectoryPath();\n\t\t\t\t\n\t\t\t\tforeach($directory['files'] as $file => $values){\n\t\t\t\t\tif( in_array(File::getExtension($file), AdminServConfig::$MATCHSET_EXTENSION) ){\n\t\t\t\t\t\t$matchsetData = self::getMatchSettingsData($mapsDirectoryPath.$currentPath.$file, array('maps'));\n\t\t\t\t\t\t$matchsetNbmCount = 0;\n\t\t\t\t\t\tif( isset($matchsetData['maps']) ){\n\t\t\t\t\t\t\t$matchsetNbmCount = count($matchsetData['maps']);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$matchsetNbmTitle = ($matchsetNbmCount > 1) ? Utils::t('maps') : Utils::t('map');\n\t\t\t\t\t\t\n\t\t\t\t\t\t$out['lst'][$file]['Name'] = substr($file, 0, -4);\n\t\t\t\t\t\t$out['lst'][$file]['FileName'] = $currentPath.$file;\n\t\t\t\t\t\t$out['lst'][$file]['Nbm'] = $matchsetNbmCount.' '.$matchsetNbmTitle;\n\t\t\t\t\t\t$out['lst'][$file]['Mtime'] = $values['mtime'];\n\t\t\t\t\t\t$out['lst'][$file]['Recent'] = $values['recent'];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Nombre de matchsettings\n\t\t\tif( isset($out['lst']) && is_array($out['lst']) ){\n\t\t\t\t$out['nbm']['count'] = count($out['lst']);\n\t\t\t\t$out['nbm']['title'] = ($out['nbm']['count'] > 1) ? Utils::t('matchsettings') : Utils::t('matchsetting');\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out['nbm']['count'] = 0;\n\t\t\t\t$out['nbm']['title'] = Utils::t('matchsetting');\n\t\t\t}\n\t\t\tif($out['nbm']['count'] == 0){\n\t\t\t\t$out['lst'] = Utils::t('No matchsetting');\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\t// Retour des erreurs de la m\u00e9thode read\n\t\t\t$out = $directory;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Enregistre la s\u00e9lection du MatchSettings en session\n\t*\n\t* @param array $maps -> Le tableau de maps \u00e0 ajouter \u00e0 la s\u00e9lection\n\t*/\n\tpublic static function saveMatchSettingSelection($maps = array() ){\n\t\t// Liste des maps\n\t\t$out = array();\n\t\tif( isset($_SESSION['adminserv']['matchset_maps_selected']) ){\n\t\t\t$mapsSelected = $_SESSION['adminserv']['matchset_maps_selected'];\n\t\t\tif( isset($mapsSelected['lst']) && is_array($mapsSelected['lst']) && count($mapsSelected['lst']) > 0 ){\n\t\t\t\tforeach($mapsSelected['lst'] as $id => $values){\n\t\t\t\t\t$out['lst'][] = $values;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( isset($maps['lst']) && is_array($maps['lst']) && count($maps['lst']) > 0 ){\n\t\t\tforeach($maps['lst'] as $id => $values){\n\t\t\t\t$out['lst'][] = $values;\n\t\t\t}\n\t\t}\n\t\tif( isset($out['lst']) && count($out['lst']) > 0 ){\n\t\t\t$out['lst'] = array_unique($out['lst'], SORT_REGULAR);\n\t\t}\n\t\t\n\t\t// Nombre de maps\n\t\t$out += self::getNbMaps($out);\n\t\tif($out['nbm']['count'] == 0){\n\t\t\t$out['lst'] = Utils::t('No map');\n\t\t}\n\t\t\n\t\t// Mise \u00e0 jour de la session\n\t\t$_SESSION['adminserv']['matchset_maps_selected'] = $out;\n\t}\n\t\n\t\n\t/**\n\t* Enregistre un MatchSettings\n\t*\n\t* @param string $filename -> L'url du dossier dans lequel le MatchSettings sera cr\u00e9e\n\t* @param array  $struct   -> La structure du MatchSettings avec ses donn\u00e9es\n\t* $struct = Array\n\t* (\n\t*  [gameinfos] => Array\n\t*   (\n\t*    [game_mode] => 0\n\t*    etc...\n\t*   )\n\t*  [hotseat] => Array()\n\t*  [filter] => Array()\n\t*  [startindex] => 1\n\t*  [map] => Array\n\t*   (\n\t*    [8bDoQMwzUllV0D9eu7hSth3rQs6] => name.Map.Gbx\n\t*    etc...\n\t*   )\n\t* )\n\t* @return true si r\u00e9ussi, sinon une erreur\n\t*/\n\tpublic static function saveMatchSettings($filename, $struct){\n\t\t$out = false;\n\t\t\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$mapField = 'challenge';\n\t\t}\n\t\telse{\n\t\t\t$mapField = 'map';\n\t\t}\n\t\t\n\t\t$xml = new DOMDocument('1.0', 'utf-8');\n\t\t$xml->formatOutput = true;\n\t\t$playlist = $xml->createElement('playlist');\n\t\t$playlist = $xml->appendChild($playlist);\n\t\t\n\t\t// GameInfos, Hotseat, Filter\n\t\t$structFields = array(\n\t\t\t'gameinfos',\n\t\t\t'hotseat',\n\t\t\t'filter'\n\t\t);\n\t\tforeach($structFields as $strucField){\n\t\t\tif( isset($struct[$strucField]) && !empty($struct[$strucField]) ){\n\t\t\t\t$node = $xml->createElement($strucField);\n\t\t\t\t$node = $playlist->appendChild($node);\n\t\t\t\tforeach($struct[$strucField] as $field => $value){\n\t\t\t\t\t$childNode = $xml->createElement($field, $value);\n\t\t\t\t\t$childNode = $node->appendChild($childNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Script settings\n\t\tif( isset($struct['scriptsettings']) && !empty($struct['scriptsettings']) ){\n\t\t\t$scriptsettings = $xml->createElement('mode_script_settings');\n\t\t\t$scriptsettings = $playlist->appendChild($scriptsettings);\n\t\t\tforeach($struct['scriptsettings'] as $settingParams){\n\t\t\t\t$setting = $xml->createElement('setting');\n\t\t\t\t$setting = $scriptsettings->appendChild($setting);\n\t\t\t\tif( !empty($settingParams) ){\n\t\t\t\t\tforeach($settingParams as $paramKey => $paramValue){\n\t\t\t\t\t\t$param = $xml->createAttribute($paramKey);\n\t\t\t\t\t\t$param->value = $paramValue;\n\t\t\t\t\t\t$setting->appendChild($param);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Maps\n\t\t$startindex = $xml->createElement('startindex', $struct['startindex']);\n\t\t$startindex = $playlist->appendChild($startindex);\n\t\tif( isset($struct[$mapField]) && !empty($struct[$mapField]) ){\n\t\t\tforeach($struct[$mapField] as $dataIdent => $dataFile){\n\t\t\t\t$map = $xml->createElement($mapField);\n\t\t\t\t$map = $playlist->appendChild($map);\n\t\t\t\t$file = $xml->createElement('file', $dataFile);\n\t\t\t\t$file = $map->appendChild($file);\n\t\t\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t\t\t$ident = $xml->createElement('ident', $dataIdent);\n\t\t\t\t\t$ident = $map->appendChild($ident);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( !$xml->save($filename) ){\n\t\t\t$out = Utils::t('Saving XML file error');\n\t\t}\n\t\telse{\n\t\t\t$out = true;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Extrait les donn\u00e9es d'un MatchSettings et renvoi un tableau\n\t*\n\t* @param string $filename -> L'url du MatchSettings\n\t* @param array  $list     -> Liste des champs \u00e0 retourner\n\t* @return array\n\t*/\n\tpublic static function getMatchSettingsData($filename, $list = array('gameinfos', 'hotseat', 'filter', 'scriptsettings', 'maps') ){\n\t\t$out = array();\n\t\t$xml = null;\n\t\t\n\t\tif( file_exists($filename) ){\n\t\t\t$xml = new DOMDocument('1.0', 'utf-8');\n\t\t\t$xml->load($filename);\n\t\t}\n\t\t\n\t\tif($xml){\n\t\t\t// Gameinfos\n\t\t\tif( in_array('gameinfos', $list) ){\n\t\t\t\t$fields = array(\n\t\t\t\t\t'game_mode' => 'GameMode',\n\t\t\t\t\t'chat_time' => 'ChatTime',\n\t\t\t\t\t'finishtimeout' => 'FinishTimeout',\n\t\t\t\t\t'allwarmupduration' => 'AllWarmUpDuration',\n\t\t\t\t\t'disablerespawn' => 'DisableRespawn',\n\t\t\t\t\t'forceshowallopponents' => 'ForceShowAllOpponents',\n\t\t\t\t\t'rounds_pointslimit' => 'RoundsPointsLimit',\n\t\t\t\t\t'rounds_custom_points' => 'RoundCustomPoints',\n\t\t\t\t\t'rounds_usenewrules' => 'RoundsUseNewRules',\n\t\t\t\t\t'rounds_forcedlaps' => 'RoundsForcedLaps',\n\t\t\t\t\t'rounds_pointslimitnewrules' => 'RoundsPointsLimitNewRules',\n\t\t\t\t\t'team_pointslimit' => 'TeamPointsLimit',\n\t\t\t\t\t'team_maxpoints' => 'TeamMaxPoints',\n\t\t\t\t\t'team_usenewrules' => 'TeamUseNewRules',\n\t\t\t\t\t'team_pointslimitnewrules' => 'TeamPointsLimitNewRules',\n\t\t\t\t\t'timeattack_limit' => 'TimeAttackLimit',\n\t\t\t\t\t'timeattack_synchstartperiod' => 'TimeAttackSynchStartPeriod',\n\t\t\t\t\t'laps_nblaps' => 'LapsNbLaps',\n\t\t\t\t\t'laps_timelimit' => 'LapsTimeLimit',\n\t\t\t\t\t'cup_pointslimit' => 'CupPointsLimit',\n\t\t\t\t\t'cup_roundsperchallenge' => 'CupRoundsPerMap',\n\t\t\t\t\t'cup_nbwinners' => 'CupNbWinners',\n\t\t\t\t\t'cup_warmupduration' => 'CupWarmUpDuration',\n\t\t\t\t);\n\t\t\t\tif(SERVER_VERSION_NAME != 'TmForever'){\n\t\t\t\t\t$fields['script_name'] = 'ScriptName';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tforeach($fields as $fieldXML => $fieldName){\n\t\t\t\t\t$fieldList = $xml->getElementsByTagName($fieldXML);\n\t\t\t\t\tif($fieldList->length > 0){\n\t\t\t\t\t\t$out['gameinfos'][$fieldName] = $fieldList->item(0)->nodeValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Hotseat\n\t\t\tif( in_array('hotseat', $list) ){\n\t\t\t\t$fields = array(\n\t\t\t\t\t'game_mode' => 'GameMode',\n\t\t\t\t\t'time_limit' => 'TimeLimit',\n\t\t\t\t\t'rounds_count' => 'RoundsCount',\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\tforeach($fields as $fieldXML => $fieldName){\n\t\t\t\t\t$fieldList = $xml->getElementsByTagName($fieldXML);\n\t\t\t\t\tif($fieldList->length > 0){\n\t\t\t\t\t\t$out['hotseat'][$fieldName] = $fieldList->item(0)->nodeValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Filter\n\t\t\tif( in_array('filter', $list) ){\n\t\t\t\t$fields = array(\n\t\t\t\t\t'is_lan' => 'IsLan',\n\t\t\t\t\t'is_internet' => 'IsInternet',\n\t\t\t\t\t'is_solo' => 'IsSolo',\n\t\t\t\t\t'is_hotseat' => 'IsHotseat',\n\t\t\t\t\t'sort_index' => 'SortIndex',\n\t\t\t\t\t'random_map_order' => 'RandomMapOrder',\n\t\t\t\t\t'force_default_gamemode' => 'ForceDefaultGameMode',\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\tforeach($fields as $fieldXML => $fieldName){\n\t\t\t\t\t$fieldList = $xml->getElementsByTagName($fieldXML);\n\t\t\t\t\tif($fieldList->length > 0){\n\t\t\t\t\t\t$out['filter'][$fieldName] = $fieldList->item(0)->nodeValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Script Settings\n\t\t\tif( in_array('scriptsettings', $list) ){\n\t\t\t\t$scriptsettings = $xml->getElementsByTagName('setting');\n\t\t\t\tif($scriptsettings->length > 0){\n\t\t\t\t\t$i = 0;\n\t\t\t\t\tforeach($scriptsettings as $setting){\n\t\t\t\t\t\tif( $setting->hasAttributes() ){\n\t\t\t\t\t\t\tforeach($setting->attributes as $attName => $attrNode) {\n\t\t\t\t\t\t\t\t$out['scriptsettings'][$i][$attName] = $attrNode->value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$i++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Maps\n\t\t\tif( in_array('maps', $list) ){\n\t\t\t\t$fieldStartIndex = $xml->getElementsByTagName('startindex');\n\t\t\t\tif($fieldStartIndex->length > 0){\n\t\t\t\t\t$out['StartIndex'] = $fieldStartIndex->item(0)->nodeValue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$mapsField = (SERVER_VERSION_NAME == 'TmForever') ? 'challenge' : 'map';\n\t\t\t\t$fieldMaps = $xml->getElementsByTagName($mapsField);\n\t\t\t\t\n\t\t\t\tforeach($fieldMaps as $map){\n\t\t\t\t\t$ident = null;\n\t\t\t\t\t$fieldIdent = $map->getElementsByTagName('ident');\n\t\t\t\t\tif($fieldIdent->length > 0){\n\t\t\t\t\t\t$ident = $fieldIdent->item(0)->nodeValue;\n\t\t\t\t\t}\n\t\t\t\t\t$file = null;\n\t\t\t\t\t$fieldFile = $map->getElementsByTagName('file');\n\t\t\t\t\tif($fieldFile->length > 0){\n\t\t\t\t\t\t$file = $fieldFile->item(0)->nodeValue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif($ident){\n\t\t\t\t\t\t$out['maps'][$ident] = $file;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t$out['maps'][] = $file;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Met en forme les donn\u00e9es des maps \u00e0 partir d'un MatchSettings\n\t*\n\t* @global resource $client -> Le client doit \u00eatre initialis\u00e9\n\t* @param  array    $maps   -> Le tableau extrait du matchsettings : assoc array(ident => filename)\n\t* @return array\n\t*/\n\tpublic static function getMapListFromMatchSetting($maps){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t$path = self::getMapsDirectoryPath();\n\t\t$countMapList = count($maps);\n\t\t\n\t\tif($countMapList > 0){\n\t\t\t$i = 0;\n\t\t\tforeach($maps as $mapUId => $mapFileName){\n\t\t\t\tif( in_array(File::getDoubleExtension($mapFileName), AdminServConfig::$MAP_EXTENSION) ){\n\t\t\t\t\t// Donn\u00e9es\n\t\t\t\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t\t\t\t$Gbx = new GBXChallengeFetcher($path.Str::toSlash($mapFileName));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t$Gbx = new GBXChallMapFetcher();\n\t\t\t\t\t\t$Gbx->processFile($path.Str::toSlash($mapFileName));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Name\n\t\t\t\t\t$name = htmlspecialchars($Gbx->name, ENT_QUOTES, 'UTF-8');\n\t\t\t\t\t$out['lst'][$i]['Name'] = TmNick::toHtml($name, 10, true);\n\t\t\t\t\t\n\t\t\t\t\t// Environnement\n\t\t\t\t\t$env = $Gbx->envir;\n\t\t\t\t\tif($env == 'Speed'){ $env = 'Desert'; }else if($env == 'Alpine'){ $env = 'Snow'; }\n\t\t\t\t\t$out['lst'][$i]['Environment'] = $env;\n\t\t\t\t\t\n\t\t\t\t\t// Autres\n\t\t\t\t\t$out['lst'][$i]['FileName'] = $mapFileName;\n\t\t\t\t\t$out['lst'][$i]['UId'] = $Gbx->uid;\n\t\t\t\t\t$out['lst'][$i]['Author'] = $Gbx->author;\n\t\t\t\t\t$i++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Nombre de maps\n\t\t$out += self::getNbMaps($out);\n\t\tif($out['nbm']['count'] == 0){\n\t\t\t$out['lst'] = Utils::t('No map');\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Extrait les donn\u00e9es d'une playlist (blacklist ou guestlist)\n\t*\n\t* @param string $filename -> L'url de la playlist\n\t* @return array\n\t*/\n\tpublic static function getPlaylistData($filename){\n\t\t$out = array();\n\t\t\n\t\t$xml = null;\n\t\tif( file_exists($filename) ){\n\t\t\t$xml = new DOMDocument('1.0', 'utf-8');\n\t\t\t$xml->load($filename);\n\t\t}\n\t\t\n\t\tif($xml){\n\t\t\t$root = $xml->documentElement;\n\t\t\t$out['type'] = $root->nodeName;\n\t\t\t$players = $xml->getElementsByTagName($root->nodeName);\n\t\t\tforeach($players as $player){\n\t\t\t\t$login = $player->getElementsByTagName('login');\n\t\t\t\tif($login->length > 0){\n\t\t\t\t\t$out['logins'][] = $login->item(0)->nodeValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n}\n?>"], "fixing_code": ["<?php\ndefine('ADMINSERV_TIMER', false);\ndefine('ADMINSERV_VERSION', '2.1.1');\n\n/**\n* Classe pour le fonctionnement d'AdminServ\n*/\nclass AdminServ {\n\t\n\t/**\n\t* Inclue les classes PHP\n\t*/\n\tpublic static function getClass(){\n\t\t$pathClass = AdminServConfig::$PATH_RESOURCES.'class/';\n\t\trequire_once $pathClass.'GbxRemote.inc.php';\n\t\trequire_once $pathClass.'gbxdatafetcher.inc.php';\n\t\trequire_once $pathClass.'utils.class.php';\n\t\trequire_once $pathClass.'tmnick.class.php';\n\t\trequire_once $pathClass.'timedate.class.php';\n\t\trequire_once $pathClass.'file.class.php';\n\t\trequire_once $pathClass.'folder.class.php';\n\t\trequire_once $pathClass.'str.class.php';\n\t\trequire_once $pathClass.'upload.class.php';\n\t\trequire_once $pathClass.'zip.class.php';\n\t\t\n\t\t$pathCore = AdminServConfig::$PATH_RESOURCES.'core/';\n\t\trequire_once $pathCore.'adminlevel.php';\n\t\trequire_once $pathCore.'cache.php';\n\t\trequire_once $pathCore.'event.php';\n\t\trequire_once $pathCore.'logs.php';\n\t\trequire_once $pathCore.'plugin.php';\n\t\trequire_once $pathCore.'server.php';\n\t\trequire_once $pathCore.'sort.php';\n\t\trequire_once $pathCore.'ui.php';\n\t}\n\t\n\t\n\t/**\n\t* M\u00e9thodes de debug\n\t*/\n\tpublic static function dsm($val){\n\t\techo '<pre>';\n\t\tprint_r($val);\n\t\techo '</pre>';\n\t}\n\tpublic static function debug($globalValue = null){\n\t\t$const = get_defined_constants(true);\n\t\t\n\t\treturn self::dsm(\n\t\t\tarray(\n\t\t\t\t'GLOBALS' => ($globalValue) ? $GLOBALS[$globalValue] : $GLOBALS,\n\t\t\t\t'ADMINSERV' => $const['user']\n\t\t\t)\n\t\t);\n\t}\n\t\n\t/**\n\t* Erreurs et infos\n\t*/\n\tpublic static function error($text = null){\n\t\tglobal $client;\n\t\t// Tente de r\u00e9cup\u00e9rer le message d'erreur du d\u00e9di\u00e9\n\t\tif($text === null){\n\t\t\t$text = '['.$client->getErrorCode().'] '.Utils::t( $client->getErrorMessage() );\n\t\t}\n\t\telse {\n\t\t\t$text = htmlspecialchars($text, ENT_QUOTES, 'UTF-8');\n\t\t}\n\t\t\n\t\tAdminServLogs::add('error', $text);\n\t\tunset($_SESSION['info']);\n\t\t$_SESSION['error'] = $text;\n\t}\n\tpublic static function info($text){\n\t\t$_SESSION['info'] = $text;\n\t}\n\t\n\t\n\t/**\n\t* Temps de chargement de page\n\t*/\n\tpublic static function startTimer(){\n\t\tglobal $timeStart;\n\t\t$timeStart = microtime(true);\n\t}\n\tpublic static function endTimer(){\n\t\tglobal $timeStart;\n\t\t$timeEnd = microtime(true);\n\t\t$time = $timeEnd - $timeStart;\n\t\treturn number_format($time, 3);\n\t}\n\t\n\t\n\t/**\n\t* V\u00e9rifie la version de PHP\n\t*/\n\tpublic static function checkPHPVersion($version){\n\t\tif( !version_compare(PHP_VERSION, $version, '>=') ){\n\t\t\techo '<b>This PHP version is not compatible with AdminServ.</b><br />Your PHP version: '. PHP_VERSION .'<br />PHP version required: '.$version;\n\t\t\texit;\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t* V\u00e9rifie les droits pour l'\u00e9criture/lecture des fichiers\n\t*\n\t* @param array $list -> Liste des fichiers \u00e0 tester : array('path' => 777)\n\t* @return array\n\t*/\n\tpublic static function checkRights($list){\n\t\tif( count($list) > 0 ){\n\t\t\tforeach($list as $path => $minChmod){\n\t\t\t\t$result = Folder::checkRights($path, $minChmod);\n\t\t\t\tforeach($result as $grpName => $grpValues){\n\t\t\t\t\tforeach($grpValues['result'] as $bool){\n\t\t\t\t\t\tif(!$bool){\n\t\t\t\t\t\t\tself::error( Utils::t('This path was not required rights:').' '.$path.' (\"'.$grpName.'\" '.Utils::t('needs').' \"'.$minChmod.'\")');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t* Intialise le client du serveur courant\n\t*\n\t* @param bool $fullInit -> Intialisation compl\u00e8te ? oui par d\u00e9faut.\n\t* Si non, \u00e7a ne recup\u00e8re aucune info de base, seulement la connexion\n\t* au serveur d\u00e9di\u00e9 et son authentication.\n\t* @return bool\n\t*/\n\tpublic static function initialize($fullInit = true){\n\t\tglobal $client;\n\t\t$out = false;\n\t\t\n\t\tif( isset($_SESSION['adminserv']['sid']) ){\n\t\t\t// CONSTANTS\n\t\t\tdefine('USER_ADMINLEVEL', $_SESSION['adminserv']['adminlevel']);\n\t\t\tdefine('SERVER_ID', $_SESSION['adminserv']['sid']);\n\t\t\tdefine('SERVER_NAME', $_SESSION['adminserv']['name']);\n\t\t\tdefine('SERVER_ADDR', ServerConfig::$SERVERS[SERVER_NAME]['address']);\n\t\t\tdefine('SERVER_XMLRPC_PORT', ServerConfig::$SERVERS[SERVER_NAME]['port']);\n\t\t\tdefine('SERVER_MATCHSET', ServerConfig::$SERVERS[SERVER_NAME]['matchsettings']);\n\t\t\tdefine('SERVER_MAPS_BASEPATH', (isset(ServerConfig::$SERVERS[SERVER_NAME]['mapsbasepath'])) ? ServerConfig::$SERVERS[SERVER_NAME]['mapsbasepath'] : '');\n\t\t\tdefine('SERVER_ADMINLEVEL', serialize( ServerConfig::$SERVERS[SERVER_NAME]['adminlevel']) );\n\t\t\t\n\t\t\t// CONNEXION\n\t\t\t$client = new IXR_ClientMulticall_Gbx;\n\t\t\tif( !$client->InitWithIp(SERVER_ADDR, SERVER_XMLRPC_PORT, AdminServConfig::SERVER_CONNECTION_TIMEOUT) ){\n\t\t\t\tUtils::redirection(false, '?error='.urlencode( Utils::t('The server is not accessible.') ) );\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif( !AdminServAdminLevel::userAllowed(USER_ADMINLEVEL) ){\n\t\t\t\t\tUtils::redirection(false, '?error='.urlencode( Utils::t('You are not allowed at this admin level') ) );\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif( !$client->query('Authenticate', AdminServAdminLevel::getType(), $_SESSION['adminserv']['password']) ){\n\t\t\t\t\t\tUtils::redirection(false, '?error='.urlencode( Utils::t('The password doesn\\'t match to the server.') ) );\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif($fullInit){\n\t\t\t\t\t\t\t$client->addCall('SetApiVersion', array(date('Y-m-d')) );\n\t\t\t\t\t\t\t$client->addCall('GetVersion');\n\t\t\t\t\t\t\t$client->addCall('GetSystemInfo');\n\t\t\t\t\t\t\t$client->addCall('IsRelayServer');\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif( !$client->multiquery() ){\n\t\t\t\t\t\t\t\tself::error();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t$queriesData = $client->getMultiqueryResponse();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Version\n\t\t\t\t\t\t\t\t$getVersion = $queriesData['GetVersion'];\n\t\t\t\t\t\t\t\tdefine('SERVER_VERSION_NAME', $getVersion['Name']);\n\t\t\t\t\t\t\t\tdefine('SERVER_VERSION', $getVersion['Version']);\n\t\t\t\t\t\t\t\tdefine('SERVER_BUILD', $getVersion['Build']);\n\t\t\t\t\t\t\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t\t\t\t\t\t\tdefine('API_VERSION', $getVersion['ApiVersion']);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// SystemInfo\n\t\t\t\t\t\t\t\t$getSystemInfo = $queriesData['GetSystemInfo'];\n\t\t\t\t\t\t\t\tdefine('SERVER_LOGIN', $getSystemInfo['ServerLogin']);\n\t\t\t\t\t\t\t\tdefine('SERVER_PUBLISHED_IP', $getSystemInfo['PublishedIp']);\n\t\t\t\t\t\t\t\tdefine('SERVER_PORT', $getSystemInfo['Port']);\n\t\t\t\t\t\t\t\tdefine('SERVER_P2P_PORT', $getSystemInfo['P2PPort']);\n\t\t\t\t\t\t\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t\t\t\t\t\t\tdefine('SERVER_TITLE', $getSystemInfo['TitleId']);\n\t\t\t\t\t\t\t\t\tdefine('IS_SERVER', $getSystemInfo['IsServer']);\n\t\t\t\t\t\t\t\t\tdefine('IS_DEDICATED', $getSystemInfo['IsDedicated']);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Relay\n\t\t\t\t\t\t\t\tdefine('IS_RELAY', $queriesData['IsRelayServer']);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Protocole : tmtp ou maniaplanet\n\t\t\t\t\t\t\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t\t\t\t\t\t\tTmNick::$linkProtocol = 'maniaplanet';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdefine('LINK_PROTOCOL', TmNick::$linkProtocol);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Mode d'affichage : detail ou simple\n\t\t\t\t\t\t\t\tif( isset($_SESSION['adminserv']['mode']['general']) ){\n\t\t\t\t\t\t\t\t\tdefine('USER_MODE_GENERAL', $_SESSION['adminserv']['mode']['general']);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tdefine('USER_MODE_GENERAL', 'simple');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( isset($_SESSION['adminserv']['mode']['maps']) ){\n\t\t\t\t\t\t\t\t\tdefine('USER_MODE_MAPS', $_SESSION['adminserv']['mode']['maps']);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tdefine('USER_MODE_MAPS', 'simple');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// TmForever\n\t\t\t\t\t\t\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t\t\t\t\t\t\tarray_shift(ExtensionConfig::$GAMEMODES);\n\t\t\t\t\t\t\t\t\t$stuntsGameMode = array_pop(ExtensionConfig::$GAMEMODES);\n\t\t\t\t\t\t\t\t\t$CupGameMode = array_pop(ExtensionConfig::$GAMEMODES);\n\t\t\t\t\t\t\t\t\tExtensionConfig::$GAMEMODES[4] = $stuntsGameMode;\n\t\t\t\t\t\t\t\t\tExtensionConfig::$GAMEMODES[5] = $CupGameMode;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t$out = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t$out = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Retourne un lien protocol TM ou ManiaPlanet\n\t*\n\t* @param string $link -> Lien : #join=server_login ou /:manialink_name\n\t* @return string\n\t*/\n\tpublic static function getProtocolLink($link) {\n\t\t$out = null;\n\t\t$protocolName = 'maniaplanet';\n\t\tif (defined('LINK_PROTOCOL')) {\n\t\t\t$protocolName = LINK_PROTOCOL;\n\t\t}\n\t\t$protocolSeparator = '://';\n\t\t\n\t\tif (defined('SERVER_VERSION_NAME') && SERVER_VERSION_NAME == 'ManiaPlanet' && defined('SERVER_TITLE')) {\n\t\t\t$out = $protocolName.$protocolSeparator.$link.'@'.SERVER_TITLE;\n\t\t}\n\t\telse {\n\t\t\t$out = $protocolName.$protocolSeparator.$link;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re le nom du game mode\n\t*\n\t* @param int  $gameMode  -> La r\u00e9ponse de GetGameMode()\n\t* @param bool $getManual -> Forcer la r\u00e9cup\u00e9ration manuelle du nom \u00e0 partir du num\u00e9ro dans la config\n\t* @return string\n\t*/\n\tpublic static function getGameModeName($gameMode, $getManual = false){\n\t\t$out = Utils::t('No game mode available');\n\t\t\n\t\tif( class_exists('ExtensionConfig') && isset(ExtensionConfig::$GAMEMODES) && count(ExtensionConfig::$GAMEMODES) > 0 ){\n\t\t\tif($getManual && SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t\t$gameMode--;\n\t\t\t\tif( isset(ExtensionConfig::$GAMEMODES[$gameMode]) ){\n\t\t\t\t\t$out = ExtensionConfig::$GAMEMODES[$gameMode];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out = ExtensionConfig::$GAMEMODES[$gameMode];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* D\u00e9termine si le nom du mode de jeu fourni en param\u00e8tre correspond au mode de jeu actuel\n\t*\n\t* @param string $gameModeName    -> Nom du mode de jeu \u00e0 tester\n\t* @param int    $currentGameMode -> ID du mode de jeu courant. Si null, le mode de jeu courant est r\u00e9cup\u00e9r\u00e9 par le serveur\n\t* @return bool\n\t*/\n\tpublic static function isGameMode($gameModeName, $currentGameMode = null){\n\t\tglobal $client;\n\t\t$out = false;\n\t\tif($currentGameMode === null){\n\t\t\t$client->query('GetGameMode');\n\t\t\t$currentGameMode = $client->getResponse();\n\t\t}\n\t\t\n\t\tif($gameModeName == self::getGameModeName($currentGameMode) ){\n\t\t\t$out = true;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* V\u00e9rifie si la configuration du serveur est compatible avec le mode \u00e9quipe\n\t*\n\t* @params int    $gameMode   -> ID du mode de jeu\n\t* @params string $scriptName -> Nom du script si le mode de jeu est 0\n\t* @return bool\n\t*/\n\tpublic static function checkDisplayTeamMode($gameMode, $scriptName = null){\n\t\t$out = false;\n\t\t\n\t\tif($gameMode == 0 && SERVER_VERSION_NAME == 'ManiaPlanet' && class_exists('ExtensionConfig') && isset(ExtensionConfig::$TEAMSCRIPTS) && count(ExtensionConfig::$TEAMSCRIPTS) > 0 ){\n\t\t\tforeach(ExtensionConfig::$TEAMSCRIPTS as $teamScript){\n\t\t\t\tif( stristr($scriptName, $teamScript) ){\n\t\t\t\t\t$out = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif( self::isGameMode('Team', $gameMode) ){\n\t\t\t\t$out = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Formate le nom d'un script\n\t*\n\t* @param string $scriptName -> Le nom du script retourn\u00e9 par le serveur\n\t* @return string\n\t*/\n\tpublic static function formatScriptName($scriptName){\n\t\t$out = str_ireplace('.script.txt', '', $scriptName);\n\t\t$scriptNameEx = explode('\\\\', $out);\n\t\t$out = $scriptNameEx[count($scriptNameEx)-1];\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re les informations du serveur actuel (map, serveur, stats, joueurs)\n\t*\n\t* @param string $sortBy -> Le tri \u00e0 faire sur la liste\n\t* @return array\n\t*/\n\tpublic static function getCurrentServerInfo($sortBy = null){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t\n\t\t// JEU\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$queryName = array(\n\t\t\t\t'getMapInfo' => 'GetCurrentChallengeInfo'\n\t\t\t);\n\t\t}\n\t\telse{\n\t\t\t$queryName = array(\n\t\t\t\t'getMapInfo' => 'GetCurrentMapInfo'\n\t\t\t);\n\t\t}\n\t\t\n\t\t// REQU\u00caTES\n\t\t$client->addCall($queryName['getMapInfo']);\n\t\tif( AdminServAdminLevel::isType('Admin') ){\n\t\t\t$client->addCall('GetMapsDirectory');\n\t\t}\n\t\t$client->addCall('GetGameMode');\n\t\t$client->addCall('GetServerName');\n\t\t$client->addCall('GetStatus');\n\t\t$client->addCall('GetCurrentCallVote');\n\t\tif( AdminServAdminLevel::isType('SuperAdmin') ){\n\t\t\t$client->addCall('GetNetworkStats');\n\t\t}\n\t\t$client->addCall('GetPlayerList', array(AdminServConfig::LIMIT_PLAYERS_LIST, 0, 1) );\n\t\t\n\t\tif( !$client->multiquery() ){\n\t\t\t$out['error'] = Utils::t('Client not initialized');\n\t\t}\n\t\telse{\n\t\t\t// DONN\u00c9ES DES REQU\u00caTES\n\t\t\t$queriesData = $client->getMultiqueryResponse();\n\t\t\t\n\t\t\t// GameMode\n\t\t\t$out['srv']['gameModeId'] = $queriesData['GetGameMode'];\n\t\t\t$out['srv']['gameModeName'] = self::getGameModeName($out['srv']['gameModeId']);\n\t\t\t$out['srv']['gameModeScriptName'] = null;\n\t\t\tif( self::isGameMode('Script', $out['srv']['gameModeId']) ){\n\t\t\t\t$client->query('GetModeScriptInfo');\n\t\t\t\t$getModeScriptInfo = $client->getResponse();\n\t\t\t\tif( isset($getModeScriptInfo['Name']) ){\n\t\t\t\t\t$out['srv']['gameModeScriptName'] = self::formatScriptName($getModeScriptInfo['Name']);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$displayTeamMode = self::checkDisplayTeamMode($out['srv']['gameModeId'], $out['srv']['gameModeScriptName']);\n\t\t\t\n\t\t\t// CurrentMapInfo\n\t\t\t$currentMapInfo = $queriesData[$queryName['getMapInfo']];\n\t\t\t$out['map']['name'] = TmNick::toHtml($currentMapInfo['Name'], 10, true, false, '#999');\n\t\t\t$out['map']['uid'] = $currentMapInfo['UId'];\n\t\t\t$out['map']['author'] = $currentMapInfo['Author'];\n\t\t\t$out['map']['enviro'] = $currentMapInfo['Environnement'];\n\t\t\t\n\t\t\t// MapThumbnail\n\t\t\t$out['map']['thumb'] = null;\n\t\t\tif( isset($queriesData['GetMapsDirectory']) && $currentMapInfo['FileName'] != null){\n\t\t\t\t$mapFileName = $queriesData['GetMapsDirectory'].$currentMapInfo['FileName'];\n\t\t\t\tif( file_exists($mapFileName) ){\n\t\t\t\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t\t\t\t$Gbx = new GBXChallengeFetcher($queriesData['GetMapsDirectory'].$currentMapInfo['FileName'], false, true);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t$Gbx = new GBXChallMapFetcher(false, true);\n\t\t\t\t\t\t$Gbx->processFile($queriesData['GetMapsDirectory'].$currentMapInfo['FileName']);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t$out['map']['thumb'] = base64_encode($Gbx->thumbnail);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// CurrentCallVote\n\t\t\t$out['map']['callvote']['login'] = $queriesData['GetCurrentCallVote']['CallerLogin'];\n\t\t\t$out['map']['callvote']['cmdname'] = $queriesData['GetCurrentCallVote']['CmdName'];\n\t\t\t$out['map']['callvote']['cmdparam'] = $queriesData['GetCurrentCallVote']['CmdParam'];\n\t\t\t\n\t\t\t// TeamScores (mode team)\n\t\t\tif( self::isGameMode('Team', $out['srv']['gameModeId']) ){\n\t\t\t\t$client->query('GetCurrentRanking', 2, 0);\n\t\t\t\t$currentRanking = $client->getResponse();\n\t\t\t\t$out['map']['scores']['blue'] = $currentRanking[0]['Score'];\n\t\t\t\t$out['map']['scores']['red'] = $currentRanking[1]['Score'];\n\t\t\t}\n\t\t\t\n\t\t\t// ServerName\n\t\t\t$out['srv']['name'] = TmNick::toHtml($queriesData['GetServerName'], 10, true, false, '#999');\n\t\t\t\n\t\t\t// Status\n\t\t\t$out['srv']['status'] = $queriesData['GetStatus']['Name'];\n\t\t\t\n\t\t\t// NetworkStats\n\t\t\tif( isset($queriesData['GetNetworkStats']) && count($queriesData['GetNetworkStats']) > 0 ){\n\t\t\t\t$networkStats = $queriesData['GetNetworkStats'];\n\t\t\t\t$out['net']['uptime'] = TimeDate::secToStringTime($networkStats['Uptime'], false);\n\t\t\t\t$out['net']['nbrconnection'] = $networkStats['NbrConnection'];\n\t\t\t\t$out['net']['meanconnectiontime'] = TimeDate::secToStringTime($networkStats['MeanConnectionTime'], false);\n\t\t\t\t$out['net']['meannbrplayer'] = $networkStats['MeanNbrPlayer'];\n\t\t\t\t$out['net']['recvnetrate'] = $networkStats['RecvNetRate'];\n\t\t\t\t$out['net']['sendnetrate'] = $networkStats['SendNetRate'];\n\t\t\t\t$out['net']['totalreceivingsize'] = $networkStats['TotalReceivingSize'];\n\t\t\t\t$out['net']['totalsendingsize'] = $networkStats['TotalSendingSize'];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out['net'] = null;\n\t\t\t}\n\t\t\t\n\t\t\t// PlayerList\n\t\t\t$playerList = $queriesData['GetPlayerList'];\n\t\t\t$countPlayerList = count($playerList);\n\t\t\t\n\t\t\tif( $countPlayerList > 0 ){\n\t\t\t\t$client->query('GetCurrentRanking', AdminServConfig::LIMIT_PLAYERS_LIST, 0);\n\t\t\t\t$rankingList = $client->GetResponse();\n\t\t\t\t$rankingKeyList = array(\n\t\t\t\t\t'Rank',\n\t\t\t\t\t'BestTime',\n\t\t\t\t\t'BestCheckpoints',\n\t\t\t\t\t'Score',\n\t\t\t\t\t'NbrLapsFinished',\n\t\t\t\t\t'LadderScore'\n\t\t\t\t);\n\t\t\t\t$i = 0;\n\t\t\t\tforeach($playerList as $player){\n\t\t\t\t\t// Nickname et Playerlogin\n\t\t\t\t\t$out['ply'][$i]['NickName'] = TmNick::toHtml(htmlspecialchars($player['NickName'], ENT_QUOTES, 'UTF-8'), 10, true);\n\t\t\t\t\t$out['ply'][$i]['Login'] = $player['Login'];\n\t\t\t\t\t\n\t\t\t\t\t// PlayerStatus\n\t\t\t\t\tif($player['SpectatorStatus'] != 0){ $playerStatus = Utils::t('Spectator'); }else{ $playerStatus = Utils::t('Player'); }\n\t\t\t\t\t$out['ply'][$i]['PlayerStatus'] = $playerStatus;\n\t\t\t\t\t\n\t\t\t\t\t// Others\n\t\t\t\t\t$out['ply'][$i]['PlayerId'] = $player['PlayerId'];\n\t\t\t\t\t$out['ply'][$i]['TeamId'] = $player['TeamId'];\n\t\t\t\t\tif($player['TeamId'] == 0){ $teamName = Utils::t('Blue'); }else if($player['TeamId'] == 1){ $teamName = Utils::t('Red'); }else{ $teamName = Utils::t('Spectator'); }\n\t\t\t\t\t$out['ply'][$i]['TeamName'] = $teamName;\n\t\t\t\t\t$out['ply'][$i]['SpectatorStatus'] = $player['SpectatorStatus'];\n\t\t\t\t\t\n\t\t\t\t\t// Rankings\n\t\t\t\t\tforeach($rankingKeyList as $rankName){\n\t\t\t\t\t\tif( isset($rankingList[$i][$rankName]) ){\n\t\t\t\t\t\t\t$out['ply'][$i][$rankName] = $rankingList[$i][$rankName];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif($player['LadderRanking'] == -1){\n\t\t\t\t\t\t$player['LadderRanking'] = Utils::t('Not rated');\n\t\t\t\t\t}\n\t\t\t\t\t$out['ply'][$i]['LadderRanking'] = $player['LadderRanking'];\n\t\t\t\t\t$i++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out['ply'] = Utils::t('No player');\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// Nombre de joueurs\n\t\t\tif($countPlayerList > 1){\n\t\t\t\t$out['nbp'] = $countPlayerList.' '.Utils::t('players');\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out['nbp'] = $countPlayerList.' '.Utils::t('player');\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// TRI\n\t\t\tif( is_array($out['ply']) && count($out['ply']) > 0 ){\n\t\t\t\t// Si on est en mode \u00e9quipe, on tri par \u00e9quipe\n\t\t\t\tif($displayTeamMode){\n\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByRank');\n\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByTeam');\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tswitch($sortBy){\n\t\t\t\t\t\tcase 'nickname':\n\t\t\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByNickName');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'ladder':\n\t\t\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByLadderRanking');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'login':\n\t\t\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByLogin');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'status':\n\t\t\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByStatus');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByRank');\n\t\t\t\t\t\t\tuasort($out['ply'], 'AdminServSort::sortByStatus');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* @deprecated\n\t* R\u00e9cup\u00e8re le login du serveur principal \u00e0 partir d'un serveur Relai\n\t*\n\t* @return string\n\t*/\n\tpublic static function getMainServerLoginFromRelay(){\n\t\tglobal $client;\n\t\t$out = null;\n\t\t\n\t\tif( AdminServAdminLevel::isType('Admin') ){\n\t\t\tif( !$client->query('GameDataDirectory') ){\n\t\t\t\tself::error();\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// R\u00e9cup\u00e9ration du login\n\t\t\t\t$out = null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re le nombre de joueurs pr\u00e9sent sur le serveur\n\t*\n\t* @param bool $spectator -> Inclus les spectateurs dans le calcul\n\t* @return int\n\t*/\n\tpublic static function getNbPlayers($spectator = true){\n\t\tglobal $client;\n\t\t$out = 0;\n\t\t\n\t\tif( !$client->query('GetPlayerList', AdminServConfig::LIMIT_PLAYERS_LIST, 0, 1) ){\n\t\t\tself::error();\n\t\t}\n\t\telse{\n\t\t\t$playerList = $client->getResponse();\n\t\t\t$countPlayerList = count($playerList);\n\t\t\t\n\t\t\tif($spectator){\n\t\t\t\t$out = $countPlayerList;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif($countPlayerList > 0){\n\t\t\t\t\tforeach($playerList as $player){\n\t\t\t\t\t\tif($player['SpectatorStatus'] == 0){\n\t\t\t\t\t\t\t$out++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Administration rapide\n\t*\n\t* @param  string $cmd -> Le nom de la commande (PrevMap, RestartMap, NextMap ou ForceEndRound)\n\t* @return true si r\u00e9ussi, sinon un message d'erreur\n\t*/\n\tpublic static function speedAdmin($cmd){\n\t\tglobal $client;\n\t\t$out = true;\n\t\t\n\t\t// M\u00e9thode en fonction du jeu\n\t\tif($cmd != 'ForceEndRound'){\n\t\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t\t$queries = array(\n\t\t\t\t\t'restartMap' => 'RestartChallenge',\n\t\t\t\t\t'nextMap' => 'NextChallenge',\n\t\t\t\t\t'getCurrentMapIndex' => 'GetCurrentChallengeIndex',\n\t\t\t\t\t'setNextMapIndex' => 'SetNextChallengeIndex'\n\t\t\t\t);\n\t\t\t}else{\n\t\t\t\t$queries = array(\n\t\t\t\t\t'restartMap' => 'RestartMap',\n\t\t\t\t\t'nextMap' => 'NextMap',\n\t\t\t\t\t'getCurrentMapIndex' => 'GetCurrentMapIndex',\n\t\t\t\t\t'setNextMapIndex' => 'SetNextMapIndex'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Si c'est le mode Cup\n\t\t$isCupMode = false;\n\t\tif( self::isGameMode('Cup') ){\n\t\t\t$isCupMode = true;\n\t\t}\n\t\t\n\t\t// Suivant la commande demand\u00e9e\n\t\tswitch($cmd){\n\t\t\tcase 'PrevMap':\n\t\t\t\tif( !$client->query($queries['getCurrentMapIndex']) ){\n\t\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t$currentMapIndex = $client->getResponse();\n\t\t\t\t\tif($currentMapIndex === 0){\n\t\t\t\t\t\t$nbMaps = self::getNbMaps( self::getMapList() );\n\t\t\t\t\t\t$prevMapIndex =  $nbMaps['nbm']['count'] - 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t$prevMapIndex = $currentMapIndex - 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif( !$client->query($queries['setNextMapIndex'], $prevMapIndex) ){\n\t\t\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tself::speedAdmin('NextMap');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'RestartMap':\n\t\t\t\tif( !$client->query($queries['restartMap'], $isCupMode) ){\n\t\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'NextMap':\n\t\t\t\tif( !$client->query($queries['nextMap'], $isCupMode) ){\n\t\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'ForceEndRound':\n\t\t\t\tif($isCupMode){\n\t\t\t\t\tif( !$client->query($queries['nextMap']) ){\n\t\t\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif( !$client->query('ForceEndRound') ){\n\t\t\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$out = Utils::t('Unknown command');\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re les options du serveur\n\t*\n\t* @global resource $client -> Le client doit \u00eatre initialis\u00e9\n\t* @return array\n\t*/\n\tpublic static function getServerOptions(){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$client->addCall('GetServerOptions', array(1) );\n\t\t}\n\t\telse{\n\t\t\t$client->addCall('GetServerOptions');\n\t\t}\n\t\t$client->addCall('GetBuddyNotification', array('') );\n\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t$client->addCall('AreHornsDisabled');\n\t\t}\n\t\t\n\t\tif( !$client->multiquery() ){\n\t\t\tself::error();\n\t\t}\n\t\telse{\n\t\t\t$queriesData = $client->getMultiqueryResponse();\n\t\t\t$out = $queriesData['GetServerOptions'];\n\t\t\t$out['Name'] = stripslashes($out['Name']);\n\t\t\tif($out['Name'] == null){\n\t\t\t\t$out['Name'] = SERVER_NAME;\n\t\t\t}\n\t\t\t$out['NameHtml'] = TmNick::toHtml($out['Name'], 10, false, false, '#666');\n\t\t\t$out['Comment'] = stripslashes($out['Comment']);\n\t\t\t$out['CommentHtml'] = TmNick::toHtml('$i'.nl2br($out['Comment']), 10, false, false, '#666');\n\t\t\tif($out['CurrentLadderMode'] !== 0){\n\t\t\t\t$out['CurrentLadderModeName'] = Utils::t('Forced'); \n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out['CurrentLadderModeName'] = Utils::t('Inactive');\n\t\t\t}\n\t\t\tif($out['CurrentVehicleNetQuality'] !== 0){\n\t\t\t\t$out['CurrentVehicleNetQualityName'] = Utils::t('High');\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out['CurrentVehicleNetQualityName'] = Utils::t('Fast');\n\t\t\t}\n\t\t\t$out['BuddyNotification'] = $queriesData['GetBuddyNotification'];\n\t\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t\t$out['DisableHorns'] = $queriesData['AreHornsDisabled'];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out['DisableHorns'] = null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Retourne la structure pour l'enregistrement des options du serveur\n\t*\n\t* @return array\n\t*/\n\tpublic static function getServerOptionsStruct(){\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$keys = array(\n\t\t\t\t'allowMapDownload' => 'AllowChallengeDownload'\n\t\t\t);\n\t\t}\n\t\telse{\n\t\t\t$keys = array(\n\t\t\t\t'allowMapDownload' => 'AllowMapDownload'\n\t\t\t);\n\t\t}\n\t\t\n\t\t$out = array(\n\t\t\t'Name' => stripslashes($_POST['Name']),\n\t\t\t'Comment' => stripslashes($_POST['Comment']),\n\t\t\t'Password' => trim($_POST['Password']),\n\t\t\t'PasswordForSpectator' => trim($_POST['PasswordForSpectator']),\n\t\t\t'NextMaxPlayers' => intval($_POST['NextMaxPlayers']),\n\t\t\t'NextMaxSpectators' => intval($_POST['NextMaxSpectators']),\n\t\t\t'IsP2PUpload' => array_key_exists('IsP2PUpload', $_POST),\n\t\t\t'IsP2PDownload' => array_key_exists('IsP2PDownload', $_POST),\n\t\t\t'NextLadderMode' => intval($_POST['NextLadderMode']),\n\t\t\t'NextVehicleNetQuality' => intval($_POST['NextVehicleNetQuality']),\n\t\t\t'NextCallVoteTimeOut' => TimeDate::secToMillisec( intval($_POST['NextCallVoteTimeOut']) ),\n\t\t\t'CallVoteRatio' => (double)$_POST['CallVoteRatio'],\n\t\t\t$keys['allowMapDownload'] => array_key_exists('AllowMapDownload', $_POST),\n\t\t\t'AutoSaveReplays' => array_key_exists('AutoSaveReplays', $_POST),\n\t\t\t'HideServer' => (int)array_key_exists('HideServer', $_POST),\n\t\t\t'BuddyNotification' => array_key_exists('BuddyNotification', $_POST),\n\t\t\t\n\t\t);\n\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t$out['ClientInputsMaxLatency'] = ($_POST['ClientInputsMaxLatency'] == 'more') ? $_POST['ClientInputsMaxLatencyValue'] : $_POST['ClientInputsMaxLatency'];\n\t\t\t$out['DisableHorns'] = array_key_exists('DisableHorns', $_POST);\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Enregistre les options du serveur\n\t*\n\t* @param array $struct -> Structure contenant les champs demand\u00e9s par la m\u00e9thode SetServerOptions()\n\t*/\n\tpublic static function setServerOptions($struct){\n\t\tglobal $client;\n\t\t$out = false;\n\t\t\n\t\tif( !$client->query('SetServerOptions', $struct) ){\n\t\t\tself::error();\n\t\t}\n\t\telse{\n\t\t\t$client->addCall('SetHideServer', array($struct['HideServer']) );\n\t\t\t$client->addCall('SetBuddyNotification', array('', $struct['BuddyNotification']) );\n\t\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t\t$client->addCall('SetClientInputsMaxLatency', array($struct['ClientInputsMaxLatency']) );\n\t\t\t\t$client->addCall('DisableHorns', array($struct['DisableHorns']) );\n\t\t\t}\n\t\t\t\n\t\t\tif( !$client->multiquery() ){\n\t\t\t\tself::error();\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Exporte les options du serveur dans un fichier\n\t*\n\t* @param  string $file -> Chemin du fichier \u00e0 \u00e9crire\n\t* @param  array  $data -> Structure des options du serveur \u00e0 \u00e9crire\n\t* @return bool\n\t*/\n\tpublic static function exportServerOptions($file, $data){\n\t\t$out = false;\n\t\t\n\t\t$xml = new DOMDocument('1.0', 'utf-8');\n\t\t$xml->formatOutput = true;\n\t\t$srvopts = $xml->createElement('ServerOptions');\n\t\t$srvopts = $xml->appendChild($srvopts);\n\t\tforeach($data as $dataField => $dataValue){\n\t\t\t$srvoptsElement = $xml->createElement($dataField, $dataValue);\n\t\t\t$srvoptsElementAttribute = $xml->createAttribute('type');\n\t\t\t$srvoptsElementAttribute->value = Str::getValueType($dataValue);\n\t\t\t$srvoptsElement->appendChild($srvoptsElementAttribute);\n\t\t\t$srvoptsElement = $srvopts->appendChild($srvoptsElement);\n\t\t}\n\t\t\n\t\tif( $result = $xml->save($file) > 0 ){\n\t\t\t$out = true;\n\t\t\tself::info( Utils::t('Server options are exported in').' '.$file);\n\t\t}\n\t\telse{\n\t\t\tself::error( Utils::t('Unable to export server options') );\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Importe les options du serveur depuis un fichier\n\t*\n\t* @param  string $file -> Chemin du fichier \u00e0 lire\n\t* @return array\n\t*/\n\tpublic static function importServerOptions($file){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t\n\t\tif( file_exists($file) ){\n\t\t\t$dom = new DOMDocument();\n\t\t\t$dom->load($file);\n\t\t\t$srvopts = $dom->childNodes->item(0);\n\t\t\t\n\t\t\tfor($i = 0; $i < $srvopts->childNodes->length; $i++){\n\t\t\t\t$srvoptsElement = $srvopts->childNodes->item($i);\n\t\t\t\tif($srvoptsElement->nodeName != '#text'){\n\t\t\t\t\t$out[$srvoptsElement->nodeName] = Str::setValueType($srvoptsElement->nodeValue, $srvoptsElement->getAttribute('type') );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tself::error( Utils::t('No such file or file is not readable').' : '.$file);\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re les informations de jeux\n\t*\n\t* @global resource $client -> Le client doit \u00eatre initialis\u00e9\n\t* @return array\n\t*/\n\tpublic static function getGameInfos(){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t\n\t\t// Jeu\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$queries = array(\n\t\t\t\t'CupRoundsPerMap' => 'GetCupRoundsPerChallenge',\n\t\t\t);\n\t\t}\n\t\telse{\n\t\t\t$queries = array(\n\t\t\t\t'CupRoundsPerMap' => 'GetCupRoundsPerMap',\n\t\t\t);\n\t\t}\n\t\t\n\t\t// Requ\u00eates\n\t\t$client->addCall('GetGameInfos');\n\t\t$client->addCall('GetAllWarmUpDuration');\n\t\t$client->addCall('GetDisableRespawn');\n\t\t$client->addCall('GetForceShowAllOpponents');\n\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t$client->addCall('GetScriptName');\n\t\t}\n\t\t$client->addCall('GetCupPointsLimit');\n\t\t$client->addCall($queries['CupRoundsPerMap']);\n\t\t$client->addCall('GetCupNbWinners');\n\t\t$client->addCall('GetCupWarmUpDuration');\n\t\t$client->addCall('GetRoundCustomPoints');\n\t\t\n\t\tif( !$client->multiquery() ){\n\t\t\tself::error();\n\t\t}\n\t\telse{\n\t\t\t$queriesData = $client->getMultiqueryResponse();\n\t\t\t\n\t\t\t// Game infos\n\t\t\t$currGamInf = $queriesData['GetGameInfos']['CurrentGameInfos'];\n\t\t\t$nextGamInf = $queriesData['GetGameInfos']['NextGameInfos'];\n\t\t\t\n\t\t\t// Nb de WarmUp\n\t\t\t$currGamInf['AllWarmUpDuration'] = $queriesData['GetAllWarmUpDuration']['CurrentValue'];\n\t\t\t$nextGamInf['AllWarmUpDuration'] = $queriesData['GetAllWarmUpDuration']['NextValue'];\n\t\t\t\n\t\t\t// Respawn\n\t\t\t$currGamInf['DisableRespawn'] = $queriesData['GetDisableRespawn']['CurrentValue'];\n\t\t\t$nextGamInf['DisableRespawn'] = $queriesData['GetDisableRespawn']['NextValue'];\n\t\t\t\n\t\t\t// ForceShowAllOpponents\n\t\t\t$currGamInf['ForceShowAllOpponents'] = $queriesData['GetForceShowAllOpponents']['CurrentValue'];\n\t\t\t$nextGamInf['ForceShowAllOpponents'] = $queriesData['GetForceShowAllOpponents']['NextValue'];\n\t\t\t\n\t\t\t// ScriptName\n\t\t\t$currGamInf['ScriptName'] = null;\n\t\t\t$nextGamInf['ScriptName'] = null;\n\t\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t\t$currGamInf['ScriptName'] = $queriesData['GetScriptName']['CurrentValue'];\n\t\t\t\t$nextGamInf['ScriptName'] = $queriesData['GetScriptName']['NextValue'];\n\t\t\t}\n\t\t\t\n\t\t\t// Mode Cup\n\t\t\t$currGamInf['CupPointsLimit'] = $queriesData['GetCupPointsLimit']['CurrentValue'];\n\t\t\t$nextGamInf['CupPointsLimit'] = $queriesData['GetCupPointsLimit']['NextValue'];\n\t\t\t$currGamInf['CupRoundsPerMap'] = $queriesData[$queries['CupRoundsPerMap']]['CurrentValue'];\n\t\t\t$nextGamInf['CupRoundsPerMap'] = $queriesData[$queries['CupRoundsPerMap']]['NextValue'];\n\t\t\t$currGamInf['CupNbWinners'] = $queriesData['GetCupNbWinners']['CurrentValue'];\n\t\t\t$nextGamInf['CupNbWinners'] = $queriesData['GetCupNbWinners']['NextValue'];\n\t\t\t$currGamInf['CupWarmUpDuration'] = $queriesData['GetCupWarmUpDuration']['CurrentValue'];\n\t\t\t$nextGamInf['CupWarmUpDuration'] = $queriesData['GetCupWarmUpDuration']['NextValue'];\n\t\t\t\n\t\t\t// RoundCustomPoints\n\t\t\t$RoundCustomPoints = implode(',', $queriesData['GetRoundCustomPoints']);\n\t\t\t$currGamInf['RoundCustomPoints'] = $RoundCustomPoints;\n\t\t\t$nextGamInf['RoundCustomPoints'] = $RoundCustomPoints;\n\t\t\t\n\t\t\t// Retour\n\t\t\t$out['curr'] = $currGamInf;\n\t\t\t$out['next'] = $nextGamInf;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Retourne la structure pour l'enregistrement des informations de jeu\n\t*\n\t* @return array\n\t*/\n\tpublic static function getGameInfosStructFromPOST(){\n\t\tif($_POST['NextFinishTimeoutValue'] < 2){\n\t\t\tif($_POST['NextFinishTimeout'] == 0){ $FinishTimeout = 0; }\n\t\t\telse if($_POST['NextFinishTimeout'] == 1){ $FinishTimeout = 1; }\n\t\t}\n\t\telse{ $FinishTimeout = TimeDate::secToMillisec( intval($_POST['NextFinishTimeoutValue']) ); }\n\t\tif( array_key_exists('NextDisableRespawn', $_POST) === true ){ $DisableRespawn = false; }\n\t\telse{ $DisableRespawn = true; }\n\t\tif($_POST['NextForceShowAllOpponentsValue'] < 2){\n\t\t\tif($_POST['NextForceShowAllOpponents'] == 0){ $NextForceShowAllOpponents = 0; }\n\t\t\telse if($_POST['NextForceShowAllOpponents'] == 1){ $NextForceShowAllOpponents = 1; }\n\t\t}\n\t\telse{ $NextForceShowAllOpponents = intval($_POST['NextForceShowAllOpponentsValue']); }\n\t\t\n\t\t$out = array(\n\t\t\t'GameMode' => intval($_POST['NextGameMode']),\n\t\t\t'ChatTime' => TimeDate::secToMillisec( intval($_POST['NextChatTime'] - 8) ),\n\t\t\t'RoundsPointsLimit' => intval($_POST['NextRoundsPointsLimit']),\n\t\t\t'RoundCustomPoints' => intval($_POST['NextRoundCustomPoints']),\n\t\t\t'RoundsUseNewRules' => array_key_exists('NextRoundsUseNewRules', $_POST),\n\t\t\t'RoundsForcedLaps' => intval($_POST['NextRoundsForcedLaps']),\n\t\t\t'RoundsPointsLimitNewRules' => intval($_POST['NextRoundsPointsLimit']),\n\t\t\t'TimeAttackLimit' => TimeDate::secToMillisec( intval($_POST['NextTimeAttackLimit']) ),\n\t\t\t'TimeAttackSynchStartPeriod' => TimeDate::secToMillisec( intval($_POST['NextTimeAttackSynchStartPeriod']) ),\n\t\t\t'TeamPointsLimit' => intval($_POST['NextTeamPointsLimit']),\n\t\t\t'TeamMaxPoints' => intval($_POST['NextTeamMaxPoints']),\n\t\t\t'TeamUseNewRules' => array_key_exists('NextTeamUseNewRules', $_POST),\n\t\t\t'TeamPointsLimitNewRules' => intval($_POST['NextTeamPointsLimit']),\n\t\t\t'LapsNbLaps' => intval($_POST['NextLapsNbLaps']),\n\t\t\t'LapsTimeLimit' => TimeDate::secToMillisec( intval($_POST['NextLapsTimeLimit']) ),\n\t\t\t'FinishTimeout' => $FinishTimeout,\n\t\t\t'AllWarmUpDuration' => intval($_POST['NextAllWarmUpDuration']),\n\t\t\t'DisableRespawn' => $DisableRespawn,\n\t\t\t'ForceShowAllOpponents' => $NextForceShowAllOpponents,\n\t\t\t'CupPointsLimit' => intval($_POST['NextCupPointsLimit']),\n\t\t\t'CupRoundsPerMap' => intval($_POST['NextCupRoundsPerMap']),\n\t\t\t'CupNbWinners' => intval($_POST['NextCupNbWinners']),\n\t\t\t'CupWarmUpDuration' => intval($_POST['NextCupWarmUpDuration'])\n\t\t);\n\t\tif(SERVER_VERSION_NAME != 'TmForever'){\n\t\t\t$out += array('ScriptName' => $_POST['NextScriptName']);\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Enregistre les infos sur les \u00e9quipes\n\t* @param array $team1 -> (assoc) array(name, color (0 to 1), country)\n\t* @param array $team2\n\t* @return bool\n\t*/\n\tpublic static function setTeamInfo($team1, $team2){\n\t\tglobal $client;\n\t\t$out = false;\n\t\t\n\t\tif( !$client->query('SetTeamInfo', 'Unused', 0., 'World', $team1['name'], (double)$team1['color'], $team1['country'], $team2['name'], (double)$team2['color'], $team2['country']) ){\n\t\t\tAdminServ::error();\n\t\t}\n\t\telse{\n\t\t\t$_SESSION['adminserv']['teaminfo'] = array(\n\t\t\t\t'team1' => $team1,\n\t\t\t\t'team2' => $team2\n\t\t\t);\n\t\t\t$out = true;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Add chat line on server\n\t*\n\t* @param string $message       -> Text message\n\t* @param string $nickname      -> Nickname\n\t* @param string $color         -> Text color\n\t* @param string $destination   -> Message destination: server or player login\n\t* @param string $showAdminText -> Display \"Admin\" before the message\n\t* @return bool or text error\n\t*/\n\tpublic static function addChatServerLine($message, $nickname = null, $color = '$ff0', $destination = 'server', $showAdminText = false){\n\t\tglobal $client;\n\t\t$out = false;\n\t\t$admin = null;\n\t\tUtils::addCookieData('adminserv_user', array(AdminServUI::theme(), AdminServUI::lang(), $nickname, $color), AdminServConfig::COOKIE_EXPIRE);\n\t\t\n\t\tif($showAdminText){\n\t\t\t$admin = '$fffAdmin:';\n\t\t}\n\t\t\n\t\tif($nickname){\n\t\t\t$nickname = '$g$ff0'.TmNick::stripNadeoCode($nickname, array('$s') );\n\t\t}\n\t\t\n\t\t$nickname = '$s$ff0['.$admin.$nickname.'$z$s$ff0]$z';\n\t\t$message = $nickname.' '.$color.$message;\n\t\t$_SESSION['adminserv']['chat_dst'] = $destination;\n\t\t\n\t\tif($destination === 'server'){\n\t\t\tif( !$client->query('ChatSendServerMessage', $message) ){\n\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out = true;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif( !$client->query('ChatSendServerMessageToLogin', $message, $destination) ){\n\t\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re les lignes du chat serveur\n\t*\n\t* @param bool $hideServerLines -> Masquer les lignes provenant d'un gestionnaire de serveur\n\t* @return string\n\t*/\n\tpublic static function getChatServerLines($hideServerLines = false){\n\t\tglobal $client;\n\t\t$out = null;\n\t\t\n\t\tif( !$client->query('GetChatLines') ){\n\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t}\n\t\telse{\n\t\t\t$langCode = AdminServUI::lang();\n\t\t\t$chatLines = $client->getResponse();\n\t\t\t\n\t\t\tforeach($chatLines as $line){\n\t\t\t\tif( self::isServerLine($line) ){\n\t\t\t\t\tif($hideServerLines){\n\t\t\t\t\t\tunset($line);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t$tradLines = array(\n\t\t\t\t\t\t\t'$99FThis round is a draw.',\n\t\t\t\t\t\t\t'$99FThe $<$00FBlue team$> wins this round.',\n\t\t\t\t\t\t\t'$99FThe $<$F00Red team$> wins this round.'\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif( in_array($line, $tradLines) ){\n\t\t\t\t\t\t\tforeach($tradLines as $tradLine){\n\t\t\t\t\t\t\t\tif($line == $tradLine){\n\t\t\t\t\t\t\t\t\tif($langCode == 'en'){\n\t\t\t\t\t\t\t\t\t\t$line = '$999'.TmNick::toText( TmNick::stripNadeoCode($tradLine, array('$<', '$>')) );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\t$line = '$999'.TmNick::toText( Utils::t($tradLine) );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif( strstr($line, '$fffAdmin:') ){\n\t\t\t\t\t\t\t\t$pattern = '$ff0]$z';\n\t\t\t\t\t\t\t\t$lineEx = explode($pattern, $line);\n\t\t\t\t\t\t\t\t$nickname = $lineEx[0].$pattern;\n\t\t\t\t\t\t\t\t$message = TmNick::toText( trim($lineEx[1]) );\n\t\t\t\t\t\t\t\t$line = $nickname.' $666'.$message;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t$line = '$999'.TmNick::toText($line);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t$lineEx = explode('$>', $line);\n\t\t\t\t\t$nickname = TmNick::stripNadeoCode($lineEx[0], array('$s', '[$<') );\n\t\t\t\t\t$message = TmNick::toText( substr($lineEx[1], 2) );\n\t\t\t\t\t\n\t\t\t\t\t$line = '$s$ff0['.$nickname.'$g$ff0]$z $666'.$message;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( isset($line) ){\n\t\t\t\t\t$out .= TmNick::toHtml($line, 10);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Retourne true si la ligne est g\u00e9n\u00e9r\u00e9e par le serveur\n\t*\n\t* @param string $line -> La ligne de la r\u00e9ponse GetChatLines\n\t* @return bool\n\t*/\n\tpublic static function isServerLine($line){\n\t\t$out = false;\n\t\t$char = substr(utf8_decode($line), 0, 1);\n\t\t\n\t\tif($char == '<' || $char == '/' || substr($line, 0, 4) == '$99F' || substr($line, 0, 12) == 'Invalid time' || $char == '?'){\n\t\t\t$out = true;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re le chemin du dossier \"Maps\"\n\t*\n\t* @global resource $client -> Le client doit \u00eatre initialis\u00e9\n\t* @return string\n\t*/\n\tpublic static function getMapsDirectoryPath(){\n\t\tglobal $client;\n\t\t$out = null;\n\t\t\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$queryName = 'GetTracksDirectory';\n\t\t}\n\t\telse{\n\t\t\t$queryName = 'GetMapsDirectory';\n\t\t}\n\t\t\n\t\tif( !$client->query($queryName) ){\n\t\t\t$out = '['.$client->getErrorCode().'] '.$client->getErrorMessage();\n\t\t}\n\t\telse{\n\t\t\t$out = Str::toSlash( $client->getResponse() );\n\t\t\tif( substr($out, -1, 1) != '/'){ $out .= '/'; }\n\t\t\tif(SERVER_MAPS_BASEPATH){\n\t\t\t\t$out .= Str::toSlash(SERVER_MAPS_BASEPATH);\n\t\t\t\tif( substr($out, -1, 1) != '/'){ $out .= '/'; }\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Retourne un tableau avec le nombre de maps et l'intitul\u00e9\n\t*\n\t* @param array $array -> La tableau contenant la liste des maps\n\t* @return array\n\t*/\n\tpublic static function getNbMaps($array){\n\t\t$out = array();\n\t\t\n\t\tif( isset($array['lst']) && is_array($array['lst']) ){\n\t\t\t$countMapsList = count($array['lst']);\n\t\t}\n\t\telse{\n\t\t\t$countMapsList = 0;\n\t\t}\n\t\t\n\t\t$out['nbm']['count'] = $countMapsList;\n\t\tif($countMapsList > 1){\n\t\t\t$out['nbm']['title'] = Utils::t('maps');\n\t\t}\n\t\telse{\n\t\t\t$out['nbm']['title'] = Utils::t('map');\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re la liste des maps sur le serveur\n\t*\n\t* @global resource $client -> Le client doit \u00eatre initialis\u00e9\n\t* @param  string   $sortBy -> Le tri \u00e0 faire sur la liste\n\t* @return array\n\t*/\n\tpublic static function getMapList($sortBy = null){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t\n\t\t// M\u00e9thodes\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$queryName = array(\n\t\t\t\t'mapList' => 'GetChallengeList',\n\t\t\t\t'mapIndex' => 'GetCurrentChallengeIndex'\n\t\t\t);\n\t\t}\n\t\telse{\n\t\t\t$queryName = array(\n\t\t\t\t'mapList' => 'GetMapList',\n\t\t\t\t'mapIndex' => 'GetCurrentMapIndex'\n\t\t\t);\n\t\t}\n\t\t\n\t\t// MAPSLIST\n\t\tif( !$client->query($queryName['mapList'], AdminServConfig::LIMIT_MAPS_LIST, 0) ){\n\t\t\t$out['error'] = Utils::t('Client not initialized');\n\t\t}\n\t\telse{\n\t\t\t$mapList = $client->getResponse();\n\t\t\t$countMapList = count($mapList);\n\t\t\t$client->query($queryName['mapIndex']);\n\t\t\t$out['cid'] = $client->getResponse();\n\t\t\t\n\t\t\tif( $countMapList > 0 ){\n\t\t\t\t$i = 0;\n\t\t\t\tforeach($mapList as $map){\n\t\t\t\t\t// Name\n\t\t\t\t\t$name = htmlspecialchars($map['Name'], ENT_QUOTES, 'UTF-8');\n\t\t\t\t\t$out['lst'][$i]['Name'] = TmNick::toHtml($name, 10, true);\n\t\t\t\t\t\n\t\t\t\t\t// Environnement\n\t\t\t\t\t$env = $map['Environnement'];\n\t\t\t\t\tif($env == 'Speed'){ $env = 'Desert'; }else if($env == 'Alpine'){ $env = 'Snow'; }\n\t\t\t\t\t$out['lst'][$i]['Environment'] = $env;\n\t\t\t\t\t\n\t\t\t\t\t// Autres\n\t\t\t\t\t$out['lst'][$i]['UId'] = $map['UId'];\n\t\t\t\t\t$out['lst'][$i]['FileName'] = $map['FileName'];\n\t\t\t\t\t$out['lst'][$i]['Author'] = $map['Author'];\n\t\t\t\t\t$out['lst'][$i]['GoldTime'] = TimeDate::format($map['GoldTime']);\n\t\t\t\t\t$out['lst'][$i]['CopperPrice'] = $map['CopperPrice'];\n\t\t\t\t\tif(SERVER_VERSION_NAME == 'ManiaPlanet'){\n\t\t\t\t\t\t$out['lst'][$i]['Type']['Name'] = self::formatScriptName($map['MapType']);\n\t\t\t\t\t\t$out['lst'][$i]['Type']['FullName'] = $map['MapType'];\n\t\t\t\t\t\t$out['lst'][$i]['Style']['Name'] = self::formatScriptName($map['MapStyle']);\n\t\t\t\t\t\t$out['lst'][$i]['Style']['FullName'] = $map['MapStyle'];\n\t\t\t\t\t}\n\t\t\t\t\t$i++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Nombre de maps\n\t\t\t$out += self::getNbMaps($out);\n\t\t\tif($out['nbm']['count'] == 0){\n\t\t\t\t$out['lst'] = Utils::t('No map');\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// TRI\n\t\t\tif($sortBy != null){\n\t\t\t\tif( is_array($out['lst']) && count($out['lst']) > 0 ){\n\t\t\t\t\tswitch($sortBy){\n\t\t\t\t\t\tcase 'name':\n\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByName');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'env':\n\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByEnviro');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'author':\n\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByAuthor');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'goldtime':\n\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByGoldTime');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'cost':\n\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByPrice');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$out['lst'] = array_values($out['lst']);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re la liste des maps sur le serveur et retourne un champ en particulier\n\t*\n\t* @global resource $client -> Le client doit \u00eatre initialis\u00e9\n\t* @return array\n\t*/\n\tpublic static function getMapListField($field){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t\n\t\t// M\u00e9thodes\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$queryName = array(\n\t\t\t\t'mapList' => 'GetChallengeList',\n\t\t\t);\n\t\t}\n\t\telse{\n\t\t\t$queryName = array(\n\t\t\t\t'mapList' => 'GetMapList',\n\t\t\t);\n\t\t}\n\t\t\n\t\t// Mapslist\n\t\tif( !$client->query($queryName['mapList'], AdminServConfig::LIMIT_MAPS_LIST, 0) ){\n\t\t\t$out['error'] = Utils::t('Client not initialized');\n\t\t}\n\t\telse{\n\t\t\t$mapList = $client->getResponse();\n\t\t\t$countMapList = count($mapList);\n\t\t\tif( $countMapList > 0 ){\n\t\t\t\t$i = 0;\n\t\t\t\tforeach($mapList as $map){\n\t\t\t\t\tswitch($field){\n\t\t\t\t\t\tcase 'Name':\n\t\t\t\t\t\t\t$name = htmlspecialchars($map['Name'], ENT_QUOTES, 'UTF-8');\n\t\t\t\t\t\t\t$out[] = TmNick::toHtml($name, 10, true);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Environment':\n\t\t\t\t\t\t\t$env = $map['Environnement'];\n\t\t\t\t\t\t\tif($env == 'Speed'){ $env = 'Desert'; }else if($env == 'Alpine'){ $env = 'Snow'; }\n\t\t\t\t\t\t\t$out[] = $env;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'UId':\n\t\t\t\t\t\t\t$out[] = $map['UId'];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'FileName':\n\t\t\t\t\t\t\t$out[] = $map['FileName'];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Author':\n\t\t\t\t\t\t\t$out[] = $map['Author'];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'GoldTime':\n\t\t\t\t\t\t\t$out[] = TimeDate::format($map['GoldTime']);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'CopperPrice':\n\t\t\t\t\t\t\t$out[] = $map['CopperPrice'];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'MapType':\n\t\t\t\t\t\t\t$out[] = $map['MapType'];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'MapStyle':\n\t\t\t\t\t\t\t$out[] = $map['MapStyle'];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t$i++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re la liste des maps en local \u00e0 partir d'un chemin\n\t*\n\t* @param string $path   -> Le chemin du dossier \u00e0 lister\n\t* @param string $sortBy -> Le tri \u00e0 faire sur la liste\n\t* @return array\n\t*/\n\tpublic static function getLocalMapList($directory, $currentPath, $sortBy = null){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t\n\t\tif( is_array($directory) ){\n\t\t\tif( !empty($directory['files']) ){\n\t\t\t\t// R\u00e9cup\u00e9ration du cache existant\n\t\t\t\t$mapsDirectoryPath = self::getMapsDirectoryPath();\n\t\t\t\t$cache = new AdminServCache();\n\t\t\t\t$cacheKey = 'mapslist-'.Str::replaceChars($mapsDirectoryPath.$currentPath);\n\t\t\t\t$cacheMaps = $cache->get($cacheKey);\n\t\t\t\t\n\t\t\t\t// Fichiers\n\t\t\t\t$files = array();\n\t\t\t\tforeach($directory['files'] as $fileName => $fileValues){\n\t\t\t\t\t$dbExt = File::getDoubleExtension($fileName);\n\t\t\t\t\tif( in_array($dbExt, AdminServConfig::$MAP_EXTENSION) ){\n\t\t\t\t\t\t$files[$fileName] = $fileValues;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Suppression du cache en trop\n\t\t\t\t$cacheOverFiles = array_diff_key($cacheMaps, $files);\n\t\t\t\tif( !empty($cacheOverFiles) ){\n\t\t\t\t\tforeach($cacheOverFiles as $fileName => $fileValues){\n\t\t\t\t\t\tif( isset($cacheMaps[$fileName]) ){\n\t\t\t\t\t\t\tunset($cacheMaps[$fileName]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$cache->set($cacheKey, $cacheMaps);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Ajout des fichiers manquant dans le cache\n\t\t\t\t$cacheMissingFiles = array_diff_key($files, $cacheMaps);\n\t\t\t\tif( !empty($cacheMissingFiles) ){\n\t\t\t\t\t// Path\n\t\t\t\t\t$path = $mapsDirectoryPath.$currentPath;\n\t\t\t\t\t\n\t\t\t\t\t// Cr\u00e9ation du cache\n\t\t\t\t\tforeach($cacheMissingFiles as $file => $values){\n\t\t\t\t\t\t// Donn\u00e9es\n\t\t\t\t\t\t$processFile = utf8_decode($file);\n\t\t\t\t\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t\t\t\t\t$Gbx = new GBXChallengeFetcher($path.$processFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t$Gbx = new GBXChallMapFetcher();\n\t\t\t\t\t\t\t$Gbx->processFile($path.$processFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Name\n\t\t\t\t\t\t$filename = $Gbx->name;\n\t\t\t\t\t\tif($filename == 'read error'){\n\t\t\t\t\t\t\t$filename = str_ireplace('.'.$dbExt, '', $file);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$name = htmlspecialchars($filename, ENT_QUOTES, 'UTF-8');\n\t\t\t\t\t\t$out['lst'][$file]['Name'] = TmNick::toHtml($name, 10, true);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Environnement\n\t\t\t\t\t\t$env = $Gbx->envir;\n\t\t\t\t\t\tif($env == 'read error'){ $env = null; }\n\t\t\t\t\t\tif($env == 'Speed'){ $env = 'Desert'; }else if($env == 'Alpine'){ $env = 'Snow'; }\n\t\t\t\t\t\t$out['lst'][$file]['Environment'] = $env;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Autres\n\t\t\t\t\t\t$out['lst'][$file]['FileName'] = $currentPath.$file;\n\t\t\t\t\t\t$uid = $Gbx->uid;\n\t\t\t\t\t\tif($uid == 'read error'){ $uid = null; }\n\t\t\t\t\t\t$out['lst'][$file]['UId'] = $uid;\n\t\t\t\t\t\t$author = $Gbx->author;\n\t\t\t\t\t\tif($author == 'read error'){ $author = null; }\n\t\t\t\t\t\t$out['lst'][$file]['Author'] = $author;\n\t\t\t\t\t\t$out['lst'][$file]['Recent'] = $values['recent'];\n\t\t\t\t\t\t\n\t\t\t\t\t\t// MapType\n\t\t\t\t\t\t$mapType = $Gbx->mapType;\n\t\t\t\t\t\tif($mapType == null && $Gbx->typeName != null){\n\t\t\t\t\t\t\t$mapType = $Gbx->typeName;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$out['lst'][$file]['Type']['Name'] = self::formatScriptName($mapType);\n\t\t\t\t\t\t$out['lst'][$file]['Type']['FullName'] = $mapType;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Mise \u00e0 jour du cache\n\t\t\t\t\tif( !empty($cacheMaps) ){\n\t\t\t\t\t\t$out['lst'] = array_merge($cacheMaps, $out['lst']);\n\t\t\t\t\t}\n\t\t\t\t\t$cache->set($cacheKey, $out['lst']);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t$out['lst'] = $cacheMaps;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Maps on server?\n\t\t\t\t$currentMapsListUId = null;\n\t\t\t\tif(AdminServConfig::LOCAL_GET_MAPS_ON_SERVER){\n\t\t\t\t\t$currentMapsListUId = self::getMapListField('UId');\n\t\t\t\t}\n\t\t\t\tforeach($out['lst'] as &$file){\n\t\t\t\t\t$file['OnServer'] = false;\n\t\t\t\t\tif($currentMapsListUId){\n\t\t\t\t\t\tif( in_array($file['UId'], $currentMapsListUId) ){\n\t\t\t\t\t\t\t$file['OnServer'] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Nombre de maps\n\t\t\t\t$out += self::getNbMaps($out);\n\t\t\t\tif($out['nbm']['count'] == 0){\n\t\t\t\t\t$out['lst'] = Utils::t('No map');\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// TRIS\n\t\t\t\t\tif($sortBy != null){\n\t\t\t\t\t\tswitch($sortBy){\n\t\t\t\t\t\t\tcase 'filename':\n\t\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByFileName');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'name':\n\t\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByName');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'env':\n\t\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByEnviro');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'type':\n\t\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByType');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'author':\n\t\t\t\t\t\t\t\tuasort($out['lst'], 'AdminServSort::sortByAuthor');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out += self::getNbMaps($out);\n\t\t\t\t$out['lst'] = Utils::t('No map');\n\t\t\t}\n\t\t}\n\t\t// Retour des erreurs de la m\u00e9thode read\n\t\telse{\n\t\t\t$out = $directory;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* R\u00e9cup\u00e8re la liste des matchsettings en local \u00e0 partir d'un chemin\n\t*\n\t* @param string $path -> Le chemin du dossier \u00e0 lister\n\t* @return array\n\t*/\n\tpublic static function getLocalMatchSettingList($directory, $currentPath){\n\t\t$out = array();\n\t\t\n\t\tif( is_array($directory) ){\n\t\t\tif( !empty($directory['files']) ){\n\t\t\t\t$mapsDirectoryPath = self::getMapsDirectoryPath();\n\t\t\t\t\n\t\t\t\tforeach($directory['files'] as $file => $values){\n\t\t\t\t\tif( in_array(File::getExtension($file), AdminServConfig::$MATCHSET_EXTENSION) ){\n\t\t\t\t\t\t$matchsetData = self::getMatchSettingsData($mapsDirectoryPath.$currentPath.$file, array('maps'));\n\t\t\t\t\t\t$matchsetNbmCount = 0;\n\t\t\t\t\t\tif( isset($matchsetData['maps']) ){\n\t\t\t\t\t\t\t$matchsetNbmCount = count($matchsetData['maps']);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$matchsetNbmTitle = ($matchsetNbmCount > 1) ? Utils::t('maps') : Utils::t('map');\n\t\t\t\t\t\t\n\t\t\t\t\t\t$out['lst'][$file]['Name'] = substr($file, 0, -4);\n\t\t\t\t\t\t$out['lst'][$file]['FileName'] = $currentPath.$file;\n\t\t\t\t\t\t$out['lst'][$file]['Nbm'] = $matchsetNbmCount.' '.$matchsetNbmTitle;\n\t\t\t\t\t\t$out['lst'][$file]['Mtime'] = $values['mtime'];\n\t\t\t\t\t\t$out['lst'][$file]['Recent'] = $values['recent'];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Nombre de matchsettings\n\t\t\tif( isset($out['lst']) && is_array($out['lst']) ){\n\t\t\t\t$out['nbm']['count'] = count($out['lst']);\n\t\t\t\t$out['nbm']['title'] = ($out['nbm']['count'] > 1) ? Utils::t('matchsettings') : Utils::t('matchsetting');\n\t\t\t}\n\t\t\telse{\n\t\t\t\t$out['nbm']['count'] = 0;\n\t\t\t\t$out['nbm']['title'] = Utils::t('matchsetting');\n\t\t\t}\n\t\t\tif($out['nbm']['count'] == 0){\n\t\t\t\t$out['lst'] = Utils::t('No matchsetting');\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\t// Retour des erreurs de la m\u00e9thode read\n\t\t\t$out = $directory;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Enregistre la s\u00e9lection du MatchSettings en session\n\t*\n\t* @param array $maps -> Le tableau de maps \u00e0 ajouter \u00e0 la s\u00e9lection\n\t*/\n\tpublic static function saveMatchSettingSelection($maps = array() ){\n\t\t// Liste des maps\n\t\t$out = array();\n\t\tif( isset($_SESSION['adminserv']['matchset_maps_selected']) ){\n\t\t\t$mapsSelected = $_SESSION['adminserv']['matchset_maps_selected'];\n\t\t\tif( isset($mapsSelected['lst']) && is_array($mapsSelected['lst']) && count($mapsSelected['lst']) > 0 ){\n\t\t\t\tforeach($mapsSelected['lst'] as $id => $values){\n\t\t\t\t\t$out['lst'][] = $values;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( isset($maps['lst']) && is_array($maps['lst']) && count($maps['lst']) > 0 ){\n\t\t\tforeach($maps['lst'] as $id => $values){\n\t\t\t\t$out['lst'][] = $values;\n\t\t\t}\n\t\t}\n\t\tif( isset($out['lst']) && count($out['lst']) > 0 ){\n\t\t\t$out['lst'] = array_unique($out['lst'], SORT_REGULAR);\n\t\t}\n\t\t\n\t\t// Nombre de maps\n\t\t$out += self::getNbMaps($out);\n\t\tif($out['nbm']['count'] == 0){\n\t\t\t$out['lst'] = Utils::t('No map');\n\t\t}\n\t\t\n\t\t// Mise \u00e0 jour de la session\n\t\t$_SESSION['adminserv']['matchset_maps_selected'] = $out;\n\t}\n\t\n\t\n\t/**\n\t* Enregistre un MatchSettings\n\t*\n\t* @param string $filename -> L'url du dossier dans lequel le MatchSettings sera cr\u00e9e\n\t* @param array  $struct   -> La structure du MatchSettings avec ses donn\u00e9es\n\t* $struct = Array\n\t* (\n\t*  [gameinfos] => Array\n\t*   (\n\t*    [game_mode] => 0\n\t*    etc...\n\t*   )\n\t*  [hotseat] => Array()\n\t*  [filter] => Array()\n\t*  [startindex] => 1\n\t*  [map] => Array\n\t*   (\n\t*    [8bDoQMwzUllV0D9eu7hSth3rQs6] => name.Map.Gbx\n\t*    etc...\n\t*   )\n\t* )\n\t* @return true si r\u00e9ussi, sinon une erreur\n\t*/\n\tpublic static function saveMatchSettings($filename, $struct){\n\t\t$out = false;\n\t\t\n\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t$mapField = 'challenge';\n\t\t}\n\t\telse{\n\t\t\t$mapField = 'map';\n\t\t}\n\t\t\n\t\t$xml = new DOMDocument('1.0', 'utf-8');\n\t\t$xml->formatOutput = true;\n\t\t$playlist = $xml->createElement('playlist');\n\t\t$playlist = $xml->appendChild($playlist);\n\t\t\n\t\t// GameInfos, Hotseat, Filter\n\t\t$structFields = array(\n\t\t\t'gameinfos',\n\t\t\t'hotseat',\n\t\t\t'filter'\n\t\t);\n\t\tforeach($structFields as $strucField){\n\t\t\tif( isset($struct[$strucField]) && !empty($struct[$strucField]) ){\n\t\t\t\t$node = $xml->createElement($strucField);\n\t\t\t\t$node = $playlist->appendChild($node);\n\t\t\t\tforeach($struct[$strucField] as $field => $value){\n\t\t\t\t\t$childNode = $xml->createElement($field, $value);\n\t\t\t\t\t$childNode = $node->appendChild($childNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Script settings\n\t\tif( isset($struct['scriptsettings']) && !empty($struct['scriptsettings']) ){\n\t\t\t$scriptsettings = $xml->createElement('mode_script_settings');\n\t\t\t$scriptsettings = $playlist->appendChild($scriptsettings);\n\t\t\tforeach($struct['scriptsettings'] as $settingParams){\n\t\t\t\t$setting = $xml->createElement('setting');\n\t\t\t\t$setting = $scriptsettings->appendChild($setting);\n\t\t\t\tif( !empty($settingParams) ){\n\t\t\t\t\tforeach($settingParams as $paramKey => $paramValue){\n\t\t\t\t\t\t$param = $xml->createAttribute($paramKey);\n\t\t\t\t\t\t$param->value = $paramValue;\n\t\t\t\t\t\t$setting->appendChild($param);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Maps\n\t\t$startindex = $xml->createElement('startindex', $struct['startindex']);\n\t\t$startindex = $playlist->appendChild($startindex);\n\t\tif( isset($struct[$mapField]) && !empty($struct[$mapField]) ){\n\t\t\tforeach($struct[$mapField] as $dataIdent => $dataFile){\n\t\t\t\t$map = $xml->createElement($mapField);\n\t\t\t\t$map = $playlist->appendChild($map);\n\t\t\t\t$file = $xml->createElement('file', $dataFile);\n\t\t\t\t$file = $map->appendChild($file);\n\t\t\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t\t\t$ident = $xml->createElement('ident', $dataIdent);\n\t\t\t\t\t$ident = $map->appendChild($ident);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( !$xml->save($filename) ){\n\t\t\t$out = Utils::t('Saving XML file error');\n\t\t}\n\t\telse{\n\t\t\t$out = true;\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Extrait les donn\u00e9es d'un MatchSettings et renvoi un tableau\n\t*\n\t* @param string $filename -> L'url du MatchSettings\n\t* @param array  $list     -> Liste des champs \u00e0 retourner\n\t* @return array\n\t*/\n\tpublic static function getMatchSettingsData($filename, $list = array('gameinfos', 'hotseat', 'filter', 'scriptsettings', 'maps') ){\n\t\t$out = array();\n\t\t$xml = null;\n\t\t\n\t\tif( file_exists($filename) ){\n\t\t\t$xml = new DOMDocument('1.0', 'utf-8');\n\t\t\t$xml->load($filename);\n\t\t}\n\t\t\n\t\tif($xml){\n\t\t\t// Gameinfos\n\t\t\tif( in_array('gameinfos', $list) ){\n\t\t\t\t$fields = array(\n\t\t\t\t\t'game_mode' => 'GameMode',\n\t\t\t\t\t'chat_time' => 'ChatTime',\n\t\t\t\t\t'finishtimeout' => 'FinishTimeout',\n\t\t\t\t\t'allwarmupduration' => 'AllWarmUpDuration',\n\t\t\t\t\t'disablerespawn' => 'DisableRespawn',\n\t\t\t\t\t'forceshowallopponents' => 'ForceShowAllOpponents',\n\t\t\t\t\t'rounds_pointslimit' => 'RoundsPointsLimit',\n\t\t\t\t\t'rounds_custom_points' => 'RoundCustomPoints',\n\t\t\t\t\t'rounds_usenewrules' => 'RoundsUseNewRules',\n\t\t\t\t\t'rounds_forcedlaps' => 'RoundsForcedLaps',\n\t\t\t\t\t'rounds_pointslimitnewrules' => 'RoundsPointsLimitNewRules',\n\t\t\t\t\t'team_pointslimit' => 'TeamPointsLimit',\n\t\t\t\t\t'team_maxpoints' => 'TeamMaxPoints',\n\t\t\t\t\t'team_usenewrules' => 'TeamUseNewRules',\n\t\t\t\t\t'team_pointslimitnewrules' => 'TeamPointsLimitNewRules',\n\t\t\t\t\t'timeattack_limit' => 'TimeAttackLimit',\n\t\t\t\t\t'timeattack_synchstartperiod' => 'TimeAttackSynchStartPeriod',\n\t\t\t\t\t'laps_nblaps' => 'LapsNbLaps',\n\t\t\t\t\t'laps_timelimit' => 'LapsTimeLimit',\n\t\t\t\t\t'cup_pointslimit' => 'CupPointsLimit',\n\t\t\t\t\t'cup_roundsperchallenge' => 'CupRoundsPerMap',\n\t\t\t\t\t'cup_nbwinners' => 'CupNbWinners',\n\t\t\t\t\t'cup_warmupduration' => 'CupWarmUpDuration',\n\t\t\t\t);\n\t\t\t\tif(SERVER_VERSION_NAME != 'TmForever'){\n\t\t\t\t\t$fields['script_name'] = 'ScriptName';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tforeach($fields as $fieldXML => $fieldName){\n\t\t\t\t\t$fieldList = $xml->getElementsByTagName($fieldXML);\n\t\t\t\t\tif($fieldList->length > 0){\n\t\t\t\t\t\t$out['gameinfos'][$fieldName] = $fieldList->item(0)->nodeValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Hotseat\n\t\t\tif( in_array('hotseat', $list) ){\n\t\t\t\t$fields = array(\n\t\t\t\t\t'game_mode' => 'GameMode',\n\t\t\t\t\t'time_limit' => 'TimeLimit',\n\t\t\t\t\t'rounds_count' => 'RoundsCount',\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\tforeach($fields as $fieldXML => $fieldName){\n\t\t\t\t\t$fieldList = $xml->getElementsByTagName($fieldXML);\n\t\t\t\t\tif($fieldList->length > 0){\n\t\t\t\t\t\t$out['hotseat'][$fieldName] = $fieldList->item(0)->nodeValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Filter\n\t\t\tif( in_array('filter', $list) ){\n\t\t\t\t$fields = array(\n\t\t\t\t\t'is_lan' => 'IsLan',\n\t\t\t\t\t'is_internet' => 'IsInternet',\n\t\t\t\t\t'is_solo' => 'IsSolo',\n\t\t\t\t\t'is_hotseat' => 'IsHotseat',\n\t\t\t\t\t'sort_index' => 'SortIndex',\n\t\t\t\t\t'random_map_order' => 'RandomMapOrder',\n\t\t\t\t\t'force_default_gamemode' => 'ForceDefaultGameMode',\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\tforeach($fields as $fieldXML => $fieldName){\n\t\t\t\t\t$fieldList = $xml->getElementsByTagName($fieldXML);\n\t\t\t\t\tif($fieldList->length > 0){\n\t\t\t\t\t\t$out['filter'][$fieldName] = $fieldList->item(0)->nodeValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Script Settings\n\t\t\tif( in_array('scriptsettings', $list) ){\n\t\t\t\t$scriptsettings = $xml->getElementsByTagName('setting');\n\t\t\t\tif($scriptsettings->length > 0){\n\t\t\t\t\t$i = 0;\n\t\t\t\t\tforeach($scriptsettings as $setting){\n\t\t\t\t\t\tif( $setting->hasAttributes() ){\n\t\t\t\t\t\t\tforeach($setting->attributes as $attName => $attrNode) {\n\t\t\t\t\t\t\t\t$out['scriptsettings'][$i][$attName] = $attrNode->value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$i++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Maps\n\t\t\tif( in_array('maps', $list) ){\n\t\t\t\t$fieldStartIndex = $xml->getElementsByTagName('startindex');\n\t\t\t\tif($fieldStartIndex->length > 0){\n\t\t\t\t\t$out['StartIndex'] = $fieldStartIndex->item(0)->nodeValue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$mapsField = (SERVER_VERSION_NAME == 'TmForever') ? 'challenge' : 'map';\n\t\t\t\t$fieldMaps = $xml->getElementsByTagName($mapsField);\n\t\t\t\t\n\t\t\t\tforeach($fieldMaps as $map){\n\t\t\t\t\t$ident = null;\n\t\t\t\t\t$fieldIdent = $map->getElementsByTagName('ident');\n\t\t\t\t\tif($fieldIdent->length > 0){\n\t\t\t\t\t\t$ident = $fieldIdent->item(0)->nodeValue;\n\t\t\t\t\t}\n\t\t\t\t\t$file = null;\n\t\t\t\t\t$fieldFile = $map->getElementsByTagName('file');\n\t\t\t\t\tif($fieldFile->length > 0){\n\t\t\t\t\t\t$file = $fieldFile->item(0)->nodeValue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif($ident){\n\t\t\t\t\t\t$out['maps'][$ident] = $file;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t$out['maps'][] = $file;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Met en forme les donn\u00e9es des maps \u00e0 partir d'un MatchSettings\n\t*\n\t* @global resource $client -> Le client doit \u00eatre initialis\u00e9\n\t* @param  array    $maps   -> Le tableau extrait du matchsettings : assoc array(ident => filename)\n\t* @return array\n\t*/\n\tpublic static function getMapListFromMatchSetting($maps){\n\t\tglobal $client;\n\t\t$out = array();\n\t\t$path = self::getMapsDirectoryPath();\n\t\t$countMapList = count($maps);\n\t\t\n\t\tif($countMapList > 0){\n\t\t\t$i = 0;\n\t\t\tforeach($maps as $mapUId => $mapFileName){\n\t\t\t\tif( in_array(File::getDoubleExtension($mapFileName), AdminServConfig::$MAP_EXTENSION) ){\n\t\t\t\t\t// Donn\u00e9es\n\t\t\t\t\tif(SERVER_VERSION_NAME == 'TmForever'){\n\t\t\t\t\t\t$Gbx = new GBXChallengeFetcher($path.Str::toSlash($mapFileName));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t$Gbx = new GBXChallMapFetcher();\n\t\t\t\t\t\t$Gbx->processFile($path.Str::toSlash($mapFileName));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Name\n\t\t\t\t\t$name = htmlspecialchars($Gbx->name, ENT_QUOTES, 'UTF-8');\n\t\t\t\t\t$out['lst'][$i]['Name'] = TmNick::toHtml($name, 10, true);\n\t\t\t\t\t\n\t\t\t\t\t// Environnement\n\t\t\t\t\t$env = $Gbx->envir;\n\t\t\t\t\tif($env == 'Speed'){ $env = 'Desert'; }else if($env == 'Alpine'){ $env = 'Snow'; }\n\t\t\t\t\t$out['lst'][$i]['Environment'] = $env;\n\t\t\t\t\t\n\t\t\t\t\t// Autres\n\t\t\t\t\t$out['lst'][$i]['FileName'] = $mapFileName;\n\t\t\t\t\t$out['lst'][$i]['UId'] = $Gbx->uid;\n\t\t\t\t\t$out['lst'][$i]['Author'] = $Gbx->author;\n\t\t\t\t\t$i++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Nombre de maps\n\t\t$out += self::getNbMaps($out);\n\t\tif($out['nbm']['count'] == 0){\n\t\t\t$out['lst'] = Utils::t('No map');\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n\t\n\t\n\t/**\n\t* Extrait les donn\u00e9es d'une playlist (blacklist ou guestlist)\n\t*\n\t* @param string $filename -> L'url de la playlist\n\t* @return array\n\t*/\n\tpublic static function getPlaylistData($filename){\n\t\t$out = array();\n\t\t\n\t\t$xml = null;\n\t\tif( file_exists($filename) ){\n\t\t\t$xml = new DOMDocument('1.0', 'utf-8');\n\t\t\t$xml->load($filename);\n\t\t}\n\t\t\n\t\tif($xml){\n\t\t\t$root = $xml->documentElement;\n\t\t\t$out['type'] = $root->nodeName;\n\t\t\t$players = $xml->getElementsByTagName($root->nodeName);\n\t\t\tforeach($players as $player){\n\t\t\t\t$login = $player->getElementsByTagName('login');\n\t\t\t\tif($login->length > 0){\n\t\t\t\t\t$out['logins'][] = $login->item(0)->nodeValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $out;\n\t}\n}\n?>\n"], "buggy_code_start_loc": [64], "buggy_code_end_loc": [2027], "fixing_code_start_loc": [65], "fixing_code_end_loc": [2030], "type": "CWE-79", "message": "** UNSUPPPORTED WHEN ASSIGNED **** UNSUPPORTED WHEN ASSIGNED ** A vulnerability was found in Chris92de AdminServ. It has been rated as problematic. This issue affects some unknown processing of the file resources/core/adminserv.php. The manipulation of the argument error leads to cross site scripting. The attack may be initiated remotely. The name of the patch is 9a45087814295de6fb3a3fe38f96293665234da1. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-217043. NOTE: This vulnerability only affects products that are no longer supported by the maintainer.", "other": {"cve": {"id": "CVE-2020-36638", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-30T12:15:09.300", "lastModified": "2023-01-06T20:38:31.473", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** UNSUPPPORTED WHEN ASSIGNED **** UNSUPPORTED WHEN ASSIGNED ** A vulnerability was found in Chris92de AdminServ. It has been rated as problematic. This issue affects some unknown processing of the file resources/core/adminserv.php. The manipulation of the argument error leads to cross site scripting. The attack may be initiated remotely. The name of the patch is 9a45087814295de6fb3a3fe38f96293665234da1. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-217043. NOTE: This vulnerability only affects products that are no longer supported by the maintainer."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:adminserv_project:adminserv:-:*:*:*:*:*:*:*", "matchCriteriaId": "4B516930-7C8D-4EB6-A0F6-AD43DC60550D"}]}]}], "references": [{"url": "https://github.com/Chris92de/AdminServ/commit/9a45087814295de6fb3a3fe38f96293665234da1", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Chris92de/AdminServ/pull/6", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217043", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217043", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Chris92de/AdminServ/commit/9a45087814295de6fb3a3fe38f96293665234da1"}}