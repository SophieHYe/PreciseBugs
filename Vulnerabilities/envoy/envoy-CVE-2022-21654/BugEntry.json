{"buggy_code": ["#pragma once\n\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"envoy/api/api.h\"\n#include \"envoy/common/pure.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/cert.pb.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/common.pb.h\"\n#include \"envoy/type/matcher/v3/string.pb.h\"\n\n#include \"absl/types/optional.h\"\n\nnamespace Envoy {\nnamespace Ssl {\n\nclass CertificateValidationContextConfig {\npublic:\n  virtual ~CertificateValidationContextConfig() = default;\n\n  /**\n   * @return The CA certificate to use for peer validation.\n   */\n  virtual const std::string& caCert() const PURE;\n\n  /**\n   * @return Path of the CA certificate to use for peer validation or \"<inline>\"\n   * if the CA certificate was inlined.\n   */\n  virtual const std::string& caCertPath() const PURE;\n\n  /**\n   * @return The CRL to check if a cert is revoked.\n   */\n  virtual const std::string& certificateRevocationList() const PURE;\n\n  /**\n   * @return Path of the certificate revocation list, or \"<inline>\" if the CRL\n   * was inlined.\n   */\n  virtual const std::string& certificateRevocationListPath() const PURE;\n\n  /**\n   * @return The subject alt name matchers to be verified, if enabled.\n   */\n  virtual const std::vector<envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher>&\n  subjectAltNameMatchers() const PURE;\n\n  /**\n   * @return A list of a hex-encoded SHA-256 certificate hashes to be verified.\n   */\n  virtual const std::vector<std::string>& verifyCertificateHashList() const PURE;\n\n  /**\n   * @return A list of a hex-encoded SHA-256 SPKI hashes to be verified.\n   */\n  virtual const std::vector<std::string>& verifyCertificateSpkiList() const PURE;\n\n  /**\n   * @return whether to ignore expired certificates (both too new and too old).\n   */\n  virtual bool allowExpiredCertificate() const PURE;\n\n  /**\n   * @return client certificate validation configuration.\n   */\n  virtual envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext::\n      TrustChainVerification\n      trustChainVerification() const PURE;\n\n  /**\n   * @return the configuration for the custom certificate validator if configured.\n   */\n  virtual const absl::optional<envoy::config::core::v3::TypedExtensionConfig>&\n  customValidatorConfig() const PURE;\n\n  /**\n   * @return a reference to the api object.\n   */\n  virtual Api::Api& api() const PURE;\n\n  /**\n   * @return whether to validate certificate chain with all CRL or not.\n   */\n  virtual bool onlyVerifyLeafCertificateCrl() const PURE;\n};\n\nusing CertificateValidationContextConfigPtr = std::unique_ptr<CertificateValidationContextConfig>;\n\n} // namespace Ssl\n} // namespace Envoy\n", "#pragma once\n\n#include <array>\n#include <deque>\n#include <functional>\n#include <string>\n#include <vector>\n\n#include \"envoy/common/pure.h\"\n#include \"envoy/network/transport_socket.h\"\n#include \"envoy/ssl/context.h\"\n#include \"envoy/ssl/context_config.h\"\n#include \"envoy/ssl/private_key/private_key.h\"\n#include \"envoy/ssl/ssl_socket_extended_info.h\"\n\n#include \"source/common/common/matchers.h\"\n#include \"source/common/stats/symbol_table.h\"\n#include \"source/extensions/transport_sockets/tls/stats.h\"\n\n#include \"openssl/ssl.h\"\n#include \"openssl/x509v3.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace TransportSockets {\nnamespace Tls {\n\nclass CertValidator {\npublic:\n  virtual ~CertValidator() = default;\n\n  /**\n   * Called to add the client validation context information to a given ssl context\n   *\n   * @param context the store context\n   * @param require_client_cert whether or not client cert is required\n   */\n  virtual void addClientValidationContext(SSL_CTX* context, bool require_client_cert) PURE;\n\n  /**\n   * Called by verifyCallback to do the actual cert chain verification.\n   *\n   * @param store_ctx the store context\n   * @param ssl_extended_info the info for storing the validation status\n   * @param leaf_cert the peer certificate to verify\n   * @return 1 to indicate verification success and 0 to indicate verification failure.\n   */\n  virtual int\n  doVerifyCertChain(X509_STORE_CTX* store_ctx, Ssl::SslExtendedSocketInfo* ssl_extended_info,\n                    X509& leaf_cert,\n                    const Network::TransportSocketOptions* transport_socket_options) PURE;\n\n  /**\n   * Called to initialize all ssl contexts\n   *\n   * @param contexts the store context\n   * @param handshaker_provides_certificates whether or not a handshaker implementation provides\n   * certificates itself.\n   * @return the ssl verification mode flag\n   */\n  virtual int initializeSslContexts(std::vector<SSL_CTX*> contexts,\n                                    bool handshaker_provides_certificates) PURE;\n\n  /**\n   * Called when calculation hash for session context ids\n   *\n   * @param md the store context\n   * @param hash_buffer the buffer used for digest calculation\n   * @param hash_length the expected length of hash\n   */\n  virtual void updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                        uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                        unsigned hash_length) PURE;\n\n  virtual size_t daysUntilFirstCertExpires() const PURE;\n  virtual std::string getCaFileName() const PURE;\n  virtual Envoy::Ssl::CertificateDetailsPtr getCaCertInformation() const PURE;\n};\n\nusing CertValidatorPtr = std::unique_ptr<CertValidator>;\n\n} // namespace Tls\n} // namespace TransportSockets\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/extensions/transport_sockets/tls/cert_validator/default_validator.h\"\n\n#include <array>\n#include <deque>\n#include <functional>\n#include <string>\n#include <vector>\n\n#include \"envoy/network/transport_socket.h\"\n#include \"envoy/ssl/context.h\"\n#include \"envoy/ssl/context_config.h\"\n#include \"envoy/ssl/private_key/private_key.h\"\n#include \"envoy/ssl/ssl_socket_extended_info.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/base64.h\"\n#include \"source/common/common/fmt.h\"\n#include \"source/common/common/hex.h\"\n#include \"source/common/common/matchers.h\"\n#include \"source/common/common/utility.h\"\n#include \"source/common/config/utility.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/protobuf/utility.h\"\n#include \"source/common/runtime/runtime_features.h\"\n#include \"source/common/stats/symbol_table.h\"\n#include \"source/common/stats/utility.h\"\n#include \"source/extensions/transport_sockets/tls/cert_validator/cert_validator.h\"\n#include \"source/extensions/transport_sockets/tls/cert_validator/factory.h\"\n#include \"source/extensions/transport_sockets/tls/cert_validator/utility.h\"\n#include \"source/extensions/transport_sockets/tls/stats.h\"\n#include \"source/extensions/transport_sockets/tls/utility.h\"\n\n#include \"absl/synchronization/mutex.h\"\n#include \"openssl/ssl.h\"\n#include \"openssl/x509v3.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace TransportSockets {\nnamespace Tls {\n\nDefaultCertValidator::DefaultCertValidator(\n    const Envoy::Ssl::CertificateValidationContextConfig* config, SslStats& stats,\n    TimeSource& time_source)\n    : config_(config), stats_(stats), time_source_(time_source) {\n  if (config_ != nullptr) {\n    allow_untrusted_certificate_ = config_->trustChainVerification() ==\n                                   envoy::extensions::transport_sockets::tls::v3::\n                                       CertificateValidationContext::ACCEPT_UNTRUSTED;\n  }\n};\n\nint DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> contexts,\n                                                bool provides_certificates) {\n\n  int verify_mode = SSL_VERIFY_NONE;\n  int verify_mode_validation_context = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n\n  if (config_ != nullptr) {\n    envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext::\n        TrustChainVerification verification = config_->trustChainVerification();\n    if (verification == envoy::extensions::transport_sockets::tls::v3::\n                            CertificateValidationContext::ACCEPT_UNTRUSTED) {\n      verify_mode = SSL_VERIFY_PEER; // Ensure client-certs will be requested even if we have\n                                     // nothing to verify against\n      verify_mode_validation_context = SSL_VERIFY_PEER;\n    }\n  }\n\n  if (config_ != nullptr && !config_->caCert().empty() && !provides_certificates) {\n    ca_file_path_ = config_->caCertPath();\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->caCert().data()), config_->caCert().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      bool has_crl = false;\n      for (const X509_INFO* item : list.get()) {\n        if (item->x509) {\n          X509_STORE_add_cert(store, item->x509);\n          if (ca_cert_ == nullptr) {\n            X509_up_ref(item->x509);\n            ca_cert_.reset(item->x509);\n          }\n        }\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n          has_crl = true;\n        }\n      }\n      if (ca_cert_ == nullptr) {\n        throw EnvoyException(\n            absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n      }\n      if (has_crl) {\n        X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                        ? X509_V_FLAG_CRL_CHECK\n                                        : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n      }\n      verify_mode = SSL_VERIFY_PEER;\n      verify_trusted_ca_ = true;\n\n      // NOTE: We're using SSL_CTX_set_cert_verify_callback() instead of X509_verify_cert()\n      // directly. However, our new callback is still calling X509_verify_cert() under\n      // the hood. Therefore, to ignore cert expiration, we need to set the callback\n      // for X509_verify_cert to ignore that error.\n      if (config_->allowExpiredCertificate()) {\n        X509_STORE_set_verify_cb(store, CertValidatorUtil::ignoreCertificateExpirationCallback);\n      }\n    }\n  }\n\n  if (config_ != nullptr && !config_->certificateRevocationList().empty()) {\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->certificateRevocationList().data()),\n                        config_->certificateRevocationList().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load CRL from \", config_->certificateRevocationListPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      for (const X509_INFO* item : list.get()) {\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n        }\n      }\n      X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                      ? X509_V_FLAG_CRL_CHECK\n                                      : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n    }\n  }\n\n  const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_;\n  if (cert_validation_config != nullptr) {\n    if (!cert_validation_config->subjectAltNameMatchers().empty()) {\n      for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& matcher :\n           cert_validation_config->subjectAltNameMatchers()) {\n        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateHashList().empty()) {\n      for (auto hash : cert_validation_config->verifyCertificateHashList()) {\n        // Remove colons from the 95 chars long colon-separated \"fingerprint\"\n        // in order to get the hex-encoded string.\n        if (hash.size() == 95) {\n          hash.erase(std::remove(hash.begin(), hash.end(), ':'), hash.end());\n        }\n        const auto& decoded = Hex::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid hex-encoded SHA-256 \", hash));\n        }\n        verify_certificate_hash_list_.push_back(decoded);\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateSpkiList().empty()) {\n      for (const auto& hash : cert_validation_config->verifyCertificateSpkiList()) {\n        const auto decoded = Base64::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid base64-encoded SHA-256 \", hash));\n        }\n        verify_certificate_spki_list_.emplace_back(decoded.begin(), decoded.end());\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n  }\n\n  return verify_mode;\n}\n\nint DefaultCertValidator::doVerifyCertChain(\n    X509_STORE_CTX* store_ctx, Ssl::SslExtendedSocketInfo* ssl_extended_info, X509& leaf_cert,\n    const Network::TransportSocketOptions* transport_socket_options) {\n  if (verify_trusted_ca_) {\n    int ret = X509_verify_cert(store_ctx);\n    if (ssl_extended_info) {\n      ssl_extended_info->setCertificateValidationStatus(\n          ret == 1 ? Envoy::Ssl::ClientValidationStatus::Validated\n                   : Envoy::Ssl::ClientValidationStatus::Failed);\n    }\n\n    if (ret <= 0) {\n      stats_.fail_verify_error_.inc();\n      ENVOY_LOG(debug, \"{}\", Utility::getX509VerificationErrorInfo(store_ctx));\n      return allow_untrusted_certificate_ ? 1 : ret;\n    }\n  }\n\n  Envoy::Ssl::ClientValidationStatus validated =\n      verifyCertificate(&leaf_cert,\n                        transport_socket_options != nullptr\n                            ? transport_socket_options->verifySubjectAltNameListOverride()\n                            : std::vector<std::string>{},\n                        subject_alt_name_matchers_);\n\n  if (ssl_extended_info) {\n    if (ssl_extended_info->certificateValidationStatus() ==\n        Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    } else if (validated != Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    }\n  }\n\n  // If `trusted_ca` exists, it is already verified in the code above. Thus, we just need to make\n  // sure the verification for other validation context configurations doesn't fail (i.e. either\n  // `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure\n  // other configurations are verified and the verification succeed.\n  int validation_status = verify_trusted_ca_\n                              ? validated != Envoy::Ssl::ClientValidationStatus::Failed\n                              : validated == Envoy::Ssl::ClientValidationStatus::Validated;\n\n  return allow_untrusted_certificate_ ? 1 : validation_status;\n}\n\nEnvoy::Ssl::ClientValidationStatus DefaultCertValidator::verifyCertificate(\n    X509* cert, const std::vector<std::string>& verify_san_list,\n    const std::vector<SanMatcherPtr>& subject_alt_name_matchers) {\n  Envoy::Ssl::ClientValidationStatus validated = Envoy::Ssl::ClientValidationStatus::NotValidated;\n\n  if (!verify_san_list.empty()) {\n    if (!verifySubjectAltName(cert, verify_san_list)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n\n  if (!subject_alt_name_matchers.empty()) {\n    if (!matchSubjectAltName(cert, subject_alt_name_matchers)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n\n  if (!verify_certificate_hash_list_.empty() || !verify_certificate_spki_list_.empty()) {\n    const bool valid_certificate_hash =\n        !verify_certificate_hash_list_.empty() &&\n        verifyCertificateHashList(cert, verify_certificate_hash_list_);\n    const bool valid_certificate_spki =\n        !verify_certificate_spki_list_.empty() &&\n        verifyCertificateSpkiList(cert, verify_certificate_spki_list_);\n\n    if (!valid_certificate_hash && !valid_certificate_spki) {\n      stats_.fail_verify_cert_hash_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n\n  return validated;\n}\n\nbool DefaultCertValidator::verifySubjectAltName(X509* cert,\n                                                const std::vector<std::string>& subject_alt_names) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return false;\n  }\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    const std::string san = Utility::generalNameAsString(general_name);\n    for (auto& config_san : subject_alt_names) {\n      if (general_name->type == GEN_DNS ? Utility::dnsNameMatch(config_san, san.c_str())\n                                        : config_san == san) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nbool DefaultCertValidator::matchSubjectAltName(\n    X509* cert, const std::vector<SanMatcherPtr>& subject_alt_name_matchers) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return false;\n  }\n  for (const auto& config_san_matcher : subject_alt_name_matchers) {\n    for (const GENERAL_NAME* general_name : san_names.get()) {\n      if (config_san_matcher->match(general_name)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nbool DefaultCertValidator::verifyCertificateSpkiList(\n    X509* cert, const std::vector<std::vector<uint8_t>>& expected_hashes) {\n  X509_PUBKEY* pubkey = X509_get_X509_PUBKEY(cert);\n  if (pubkey == nullptr) {\n    return false;\n  }\n  uint8_t* spki = nullptr;\n  const int len = i2d_X509_PUBKEY(pubkey, &spki);\n  if (len < 0) {\n    return false;\n  }\n  bssl::UniquePtr<uint8_t> free_spki(spki);\n\n  std::vector<uint8_t> computed_hash(SHA256_DIGEST_LENGTH);\n  SHA256(spki, len, computed_hash.data());\n\n  for (const auto& expected_hash : expected_hashes) {\n    if (computed_hash == expected_hash) {\n      return true;\n    }\n  }\n  return false;\n}\n\nbool DefaultCertValidator::verifyCertificateHashList(\n    X509* cert, const std::vector<std::vector<uint8_t>>& expected_hashes) {\n  std::vector<uint8_t> computed_hash(SHA256_DIGEST_LENGTH);\n  unsigned int n;\n  X509_digest(cert, EVP_sha256(), computed_hash.data(), &n);\n  RELEASE_ASSERT(n == computed_hash.size(), \"\");\n\n  for (const auto& expected_hash : expected_hashes) {\n    if (computed_hash == expected_hash) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                                    uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                                    unsigned hash_length) {\n  int rc;\n\n  // Hash all the settings that affect whether the server will allow/accept\n  // the client connection. This ensures that the client is always validated against\n  // the correct settings, even if session resumption across different listeners\n  // is enabled.\n  if (ca_cert_ != nullptr) {\n    rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,\n                   fmt::format(\"invalid SHA256 hash length {}\", hash_length));\n\n    rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_hash_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_spki_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n}\n\nvoid DefaultCertValidator::addClientValidationContext(SSL_CTX* ctx, bool require_client_cert) {\n  if (config_ == nullptr || config_->caCert().empty()) {\n    return;\n  }\n\n  bssl::UniquePtr<BIO> bio(\n      BIO_new_mem_buf(const_cast<char*>(config_->caCert().data()), config_->caCert().size()));\n  RELEASE_ASSERT(bio != nullptr, \"\");\n  // Based on BoringSSL's SSL_add_file_cert_subjects_to_stack().\n  bssl::UniquePtr<STACK_OF(X509_NAME)> list(sk_X509_NAME_new(\n      [](const X509_NAME** a, const X509_NAME** b) -> int { return X509_NAME_cmp(*a, *b); }));\n  RELEASE_ASSERT(list != nullptr, \"\");\n  for (;;) {\n    bssl::UniquePtr<X509> cert(PEM_read_bio_X509(bio.get(), nullptr, nullptr, nullptr));\n    if (cert == nullptr) {\n      break;\n    }\n    X509_NAME* name = X509_get_subject_name(cert.get());\n    if (name == nullptr) {\n      throw EnvoyException(absl::StrCat(\"Failed to load trusted client CA certificates from \",\n                                        config_->caCertPath()));\n    }\n    // Check for duplicates.\n    if (sk_X509_NAME_find(list.get(), nullptr, name)) {\n      continue;\n    }\n    bssl::UniquePtr<X509_NAME> name_dup(X509_NAME_dup(name));\n    if (name_dup == nullptr || !sk_X509_NAME_push(list.get(), name_dup.release())) {\n      throw EnvoyException(absl::StrCat(\"Failed to load trusted client CA certificates from \",\n                                        config_->caCertPath()));\n    }\n  }\n\n  // Check for EOF.\n  const uint32_t err = ERR_peek_last_error();\n  if (ERR_GET_LIB(err) == ERR_LIB_PEM && ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {\n    ERR_clear_error();\n  } else {\n    throw EnvoyException(\n        absl::StrCat(\"Failed to load trusted client CA certificates from \", config_->caCertPath()));\n  }\n  SSL_CTX_set_client_CA_list(ctx, list.release());\n\n  if (require_client_cert) {\n    SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);\n  }\n}\n\nEnvoy::Ssl::CertificateDetailsPtr DefaultCertValidator::getCaCertInformation() const {\n  if (ca_cert_ == nullptr) {\n    return nullptr;\n  }\n  return Utility::certificateDetails(ca_cert_.get(), getCaFileName(), time_source_);\n}\n\nsize_t DefaultCertValidator::daysUntilFirstCertExpires() const {\n  return Utility::getDaysUntilExpiration(ca_cert_.get(), time_source_);\n}\n\nclass DefaultCertValidatorFactory : public CertValidatorFactory {\npublic:\n  CertValidatorPtr createCertValidator(const Envoy::Ssl::CertificateValidationContextConfig* config,\n                                       SslStats& stats, TimeSource& time_source) override {\n    return std::make_unique<DefaultCertValidator>(config, stats, time_source);\n  }\n\n  absl::string_view name() override { return \"envoy.tls.cert_validator.default\"; }\n};\n\nREGISTER_FACTORY(DefaultCertValidatorFactory, CertValidatorFactory);\n\n} // namespace Tls\n} // namespace TransportSockets\n} // namespace Extensions\n} // namespace Envoy\n", "#include <cstdint>\n#include <memory>\n#include <string>\n\n#include \"envoy/config/listener/v3/listener.pb.h\"\n#include \"envoy/config/listener/v3/listener_components.pb.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/cert.pb.h\"\n#include \"envoy/network/transport_socket.h\"\n\n#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/event/dispatcher_impl.h\"\n#include \"source/common/json/json_loader.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/network/listen_socket_impl.h\"\n#include \"source/common/network/transport_socket_options_impl.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/common/stream_info/stream_info_impl.h\"\n#include \"source/extensions/transport_sockets/tls/context_config_impl.h\"\n#include \"source/extensions/transport_sockets/tls/context_impl.h\"\n#include \"source/extensions/transport_sockets/tls/private_key/private_key_manager_impl.h\"\n#include \"source/extensions/transport_sockets/tls/ssl_socket.h\"\n\n#include \"test/extensions/transport_sockets/tls/ssl_certs_test.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/ca_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/extensions_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/no_san_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/password_protected_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/san_dns2_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/san_dns3_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/san_dns4_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/san_dns_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/san_uri_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_private_key_method_provider.h\"\n#include \"test/mocks/buffer/mocks.h\"\n#include \"test/mocks/init/mocks.h\"\n#include \"test/mocks/local_info/mocks.h\"\n#include \"test/mocks/network/io_handle.h\"\n#include \"test/mocks/network/mocks.h\"\n#include \"test/mocks/runtime/mocks.h\"\n#include \"test/mocks/secret/mocks.h\"\n#include \"test/mocks/server/transport_socket_factory_context.h\"\n#include \"test/mocks/ssl/mocks.h\"\n#include \"test/mocks/stats/mocks.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/registry.h\"\n#include \"test/test_common/test_runtime.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"absl/strings/str_replace.h\"\n#include \"absl/types/optional.h\"\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n#include \"openssl/ssl.h\"\n\nusing testing::_;\nusing testing::ContainsRegex;\nusing testing::DoAll;\nusing testing::InSequence;\nusing testing::Invoke;\nusing testing::NiceMock;\nusing testing::Return;\nusing testing::ReturnRef;\nusing testing::StrictMock;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace TransportSockets {\nnamespace Tls {\nnamespace {\n\n/**\n * A base class to hold the options for testUtil() and testUtilV2().\n */\nclass TestUtilOptionsBase {\npublic:\n  const std::vector<std::string>& expectedClientCertUri() const {\n    return expected_client_cert_uri_;\n  }\n  const std::string& expectedServerStats() const { return expected_server_stats_; }\n  bool expectSuccess() const { return expect_success_; }\n  Network::Address::IpVersion version() const { return version_; }\n\nprotected:\n  TestUtilOptionsBase(bool expect_success, Network::Address::IpVersion version)\n      : expect_success_(expect_success), version_(version) {}\n\n  void setExpectedClientCertUri(const std::string& expected_client_cert_uri) {\n    expected_client_cert_uri_ = {expected_client_cert_uri};\n  }\n\n  void setExpectedServerStats(const std::string& expected_server_stats) {\n    expected_server_stats_ = expected_server_stats;\n  }\n\nprivate:\n  const bool expect_success_;\n  const Network::Address::IpVersion version_;\n\n  std::string expected_server_stats_;\n  std::vector<std::string> expected_client_cert_uri_;\n};\n\n/**\n * A class to hold the options for testUtil().\n */\nclass TestUtilOptions : public TestUtilOptionsBase {\npublic:\n  TestUtilOptions(const std::string& client_ctx_yaml, const std::string& server_ctx_yaml,\n                  bool expect_success, Network::Address::IpVersion version)\n      : TestUtilOptionsBase(expect_success, version), client_ctx_yaml_(client_ctx_yaml),\n        server_ctx_yaml_(server_ctx_yaml), expect_no_cert_(false), expect_no_cert_chain_(false),\n        expect_private_key_method_(false),\n        expected_server_close_event_(Network::ConnectionEvent::RemoteClose) {\n    if (expect_success) {\n      setExpectedServerStats(\"ssl.handshake\");\n    } else {\n      setExpectedServerStats(\"ssl.fail_verify_error\");\n    }\n  }\n\n  const std::string& clientCtxYaml() const { return client_ctx_yaml_; }\n  const std::string& serverCtxYaml() const { return server_ctx_yaml_; }\n\n  TestUtilOptions& setExpectedServerStats(const std::string& expected_server_stats) {\n    TestUtilOptionsBase::setExpectedServerStats(expected_server_stats);\n    return *this;\n  }\n\n  bool expectNoCert() const { return expect_no_cert_; }\n\n  TestUtilOptions& setExpectNoCert() {\n    expect_no_cert_ = true;\n    return *this;\n  }\n\n  bool expectNoCertChain() const { return expect_no_cert_chain_; }\n\n  TestUtilOptions& setExpectNoCertChain() {\n    expect_no_cert_chain_ = true;\n    return *this;\n  }\n\n  TestUtilOptions& setExpectedClientCertUri(const std::string& expected_client_cert_uri) {\n    TestUtilOptionsBase::setExpectedClientCertUri(expected_client_cert_uri);\n    return *this;\n  }\n\n  TestUtilOptions& setExpectedSha256Digest(const std::string& expected_sha256_digest) {\n    expected_sha256_digest_ = expected_sha256_digest;\n    return *this;\n  }\n\n  const std::string& expectedSha256Digest() const { return expected_sha256_digest_; }\n\n  TestUtilOptions& setExpectedSha1Digest(const std::string& expected_sha1_digest) {\n    expected_sha1_digest_ = expected_sha1_digest;\n    return *this;\n  }\n\n  const std::string& expectedSha1Digest() const { return expected_sha1_digest_; }\n\n  TestUtilOptions& setExpectedLocalUri(const std::string& expected_local_uri) {\n    expected_local_uri_ = {expected_local_uri};\n    return *this;\n  }\n\n  const std::vector<std::string>& expectedLocalUri() const { return expected_local_uri_; }\n\n  TestUtilOptions& setExpectedSerialNumber(const std::string& expected_serial_number) {\n    expected_serial_number_ = expected_serial_number;\n    return *this;\n  }\n\n  const std::string& expectedSerialNumber() const { return expected_serial_number_; }\n\n  TestUtilOptions& setExpectedPeerIssuer(const std::string& expected_peer_issuer) {\n    expected_peer_issuer_ = expected_peer_issuer;\n    return *this;\n  }\n\n  const std::string& expectedPeerIssuer() const { return expected_peer_issuer_; }\n\n  TestUtilOptions& setExpectedPeerSubject(const std::string& expected_peer_subject) {\n    expected_peer_subject_ = expected_peer_subject;\n    return *this;\n  }\n\n  const std::string& expectedPeerSubject() const { return expected_peer_subject_; }\n\n  TestUtilOptions& setExpectedLocalSubject(const std::string& expected_local_subject) {\n    expected_local_subject_ = expected_local_subject;\n    return *this;\n  }\n\n  const std::string& expectedLocalSubject() const { return expected_local_subject_; }\n\n  TestUtilOptions& setExpectedPeerCert(const std::string& expected_peer_cert) {\n    expected_peer_cert_ = expected_peer_cert;\n    return *this;\n  }\n\n  const std::string& expectedPeerCert() const { return expected_peer_cert_; }\n\n  TestUtilOptions& setExpectedPeerCertChain(const std::string& expected_peer_cert_chain) {\n    expected_peer_cert_chain_ = expected_peer_cert_chain;\n    return *this;\n  }\n\n  const std::string& expectedPeerCertChain() const { return expected_peer_cert_chain_; }\n\n  TestUtilOptions& setExpectedValidFromTimePeerCert(const std::string& expected_valid_from) {\n    expected_valid_from_peer_cert_ = expected_valid_from;\n    return *this;\n  }\n\n  const std::string& expectedValidFromTimePeerCert() const {\n    return expected_valid_from_peer_cert_;\n  }\n\n  TestUtilOptions& setExpectedExpirationTimePeerCert(const std::string& expected_expiration) {\n    expected_expiration_peer_cert_ = expected_expiration;\n    return *this;\n  }\n\n  const std::string& expectedExpirationTimePeerCert() const {\n    return expected_expiration_peer_cert_;\n  }\n\n  TestUtilOptions& setPrivateKeyMethodExpected(bool expected_method) {\n    expect_private_key_method_ = expected_method;\n    return *this;\n  }\n\n  bool expectedPrivateKeyMethod() const { return expect_private_key_method_; }\n\n  TestUtilOptions& setExpectedServerCloseEvent(Network::ConnectionEvent expected_event) {\n    expected_server_close_event_ = expected_event;\n    return *this;\n  }\n\n  Network::ConnectionEvent expectedServerCloseEvent() const { return expected_server_close_event_; }\n\n  TestUtilOptions& setExpectedOcspResponse(const std::string& expected_ocsp_response) {\n    expected_ocsp_response_ = expected_ocsp_response;\n    return *this;\n  }\n\n  const std::string& expectedOcspResponse() const { return expected_ocsp_response_; }\n\n  TestUtilOptions& enableOcspStapling() {\n    ocsp_stapling_enabled_ = true;\n    return *this;\n  }\n\n  bool ocspStaplingEnabled() const { return ocsp_stapling_enabled_; }\n\n  TestUtilOptions& setExpectedTransportFailureReasonContains(\n      const std::string& expected_transport_failure_reason_contains) {\n    expected_transport_failure_reason_contains_ = expected_transport_failure_reason_contains;\n    return *this;\n  }\n\n  const std::string& expectedTransportFailureReasonContains() const {\n    return expected_transport_failure_reason_contains_;\n  }\n\n  TestUtilOptions& setNotExpectedClientStats(const std::string& stat) {\n    not_expected_client_stats_ = stat;\n    return *this;\n  }\n  const std::string& notExpectedClientStats() const { return not_expected_client_stats_; }\n\n  TestUtilOptions& setExpectedVerifyErrorCode(int code) {\n    expected_verify_error_code_ = code;\n    return *this;\n  }\n\n  int expectedVerifyErrorCode() const { return expected_verify_error_code_; }\n\nprivate:\n  const std::string client_ctx_yaml_;\n  const std::string server_ctx_yaml_;\n\n  bool expect_no_cert_;\n  bool expect_no_cert_chain_;\n  bool expect_private_key_method_;\n  NiceMock<Runtime::MockLoader> runtime_;\n  Network::ConnectionEvent expected_server_close_event_;\n  std::string expected_sha256_digest_;\n  std::string expected_sha1_digest_;\n  std::vector<std::string> expected_local_uri_;\n  std::string expected_serial_number_;\n  std::string expected_peer_issuer_;\n  std::string expected_peer_subject_;\n  std::string expected_local_subject_;\n  std::string expected_peer_cert_;\n  std::string expected_peer_cert_chain_;\n  std::string expected_valid_from_peer_cert_;\n  std::string expected_expiration_peer_cert_;\n  std::string expected_ocsp_response_;\n  bool ocsp_stapling_enabled_{false};\n  std::string expected_transport_failure_reason_contains_;\n  std::string not_expected_client_stats_;\n  int expected_verify_error_code_{-1};\n};\n\nvoid testUtil(const TestUtilOptions& options) {\n  Event::SimulatedTimeSystem time_system;\n\n  Stats::TestUtil::TestStore server_stats_store;\n  Api::ApiPtr server_api = Api::createApiForTest(server_stats_store, time_system);\n  NiceMock<Runtime::MockLoader> runtime;\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      server_factory_context;\n  ON_CALL(server_factory_context, api()).WillByDefault(ReturnRef(*server_api));\n\n  // For private key method testing.\n  NiceMock<Ssl::MockContextManager> context_manager;\n  Extensions::PrivateKeyMethodProvider::TestPrivateKeyMethodFactory test_factory;\n  Registry::InjectFactory<Ssl::PrivateKeyMethodProviderInstanceFactory>\n      test_private_key_method_factory(test_factory);\n  PrivateKeyMethodManagerImpl private_key_method_manager;\n  if (options.expectedPrivateKeyMethod()) {\n    EXPECT_CALL(server_factory_context, sslContextManager())\n        .WillOnce(ReturnRef(context_manager))\n        .WillRepeatedly(ReturnRef(context_manager));\n    EXPECT_CALL(context_manager, privateKeyMethodManager())\n        .WillOnce(ReturnRef(private_key_method_manager))\n        .WillRepeatedly(ReturnRef(private_key_method_manager));\n  }\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(options.serverCtxYaml()),\n                            server_tls_context);\n  auto server_cfg =\n      std::make_unique<ServerContextConfigImpl>(server_tls_context, server_factory_context);\n  ContextManagerImpl manager(*time_system);\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  Event::DispatcherPtr dispatcher = server_api->allocateDispatcher(\"test_thread\");\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(options.version()));\n  Network::MockTcpListenerCallbacks callbacks;\n  Network::ListenerPtr listener =\n      dispatcher->createListener(socket, callbacks, runtime, true, false);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(options.clientCtxYaml()),\n                            client_tls_context);\n\n  Stats::TestUtil::TestStore client_stats_store;\n  Api::ApiPtr client_api = Api::createApiForTest(client_stats_store, time_system);\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      client_factory_context;\n  ON_CALL(client_factory_context, api()).WillByDefault(ReturnRef(*client_api));\n\n  auto client_cfg =\n      std::make_unique<ClientContextConfigImpl>(client_tls_context, client_factory_context);\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager,\n                                                   client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      client_ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  NiceMock<StreamInfo::MockStreamInfo> stream_info;\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        auto ssl_socket = server_ssl_socket_factory.createTransportSocket(nullptr);\n        // configureInitialCongestionWindow is an unimplemented empty function, this is just to\n        // increase code coverage.\n        ssl_socket->configureInitialCongestionWindow(100, std::chrono::microseconds(123));\n        server_connection = dispatcher->createServerConnection(std::move(socket),\n                                                               std::move(ssl_socket), stream_info);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  if (options.ocspStaplingEnabled()) {\n    const SslHandshakerImpl* ssl_socket =\n        dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n    SSL_enable_ocsp_stapling(ssl_socket->ssl());\n  }\n\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  size_t connect_count = 0;\n  auto connect_second_time = [&]() {\n    if (++connect_count == 2) {\n      if (!options.expectedSha256Digest().empty()) {\n        // Assert twice to ensure a cached value is returned and still valid.\n        EXPECT_EQ(options.expectedSha256Digest(),\n                  server_connection->ssl()->sha256PeerCertificateDigest());\n        EXPECT_EQ(options.expectedSha256Digest(),\n                  server_connection->ssl()->sha256PeerCertificateDigest());\n      }\n      if (!options.expectedSha1Digest().empty()) {\n        // Assert twice to ensure a cached value is returned and still valid.\n        EXPECT_EQ(options.expectedSha1Digest(),\n                  server_connection->ssl()->sha1PeerCertificateDigest());\n        EXPECT_EQ(options.expectedSha1Digest(),\n                  server_connection->ssl()->sha1PeerCertificateDigest());\n      }\n      // Assert twice to ensure a cached value is returned and still valid.\n      EXPECT_EQ(options.expectedClientCertUri(), server_connection->ssl()->uriSanPeerCertificate());\n      EXPECT_EQ(options.expectedClientCertUri(), server_connection->ssl()->uriSanPeerCertificate());\n\n      if (!options.expectedLocalUri().empty()) {\n        // Assert twice to ensure a cached value is returned and still valid.\n        EXPECT_EQ(options.expectedLocalUri(), server_connection->ssl()->uriSanLocalCertificate());\n        EXPECT_EQ(options.expectedLocalUri(), server_connection->ssl()->uriSanLocalCertificate());\n      }\n      EXPECT_EQ(options.expectedSerialNumber(),\n                server_connection->ssl()->serialNumberPeerCertificate());\n      if (!options.expectedPeerIssuer().empty()) {\n        EXPECT_EQ(options.expectedPeerIssuer(), server_connection->ssl()->issuerPeerCertificate());\n      }\n      if (!options.expectedPeerSubject().empty()) {\n        EXPECT_EQ(options.expectedPeerSubject(),\n                  server_connection->ssl()->subjectPeerCertificate());\n      }\n      if (!options.expectedLocalSubject().empty()) {\n        EXPECT_EQ(options.expectedLocalSubject(),\n                  server_connection->ssl()->subjectLocalCertificate());\n      }\n      if (!options.expectedPeerCert().empty()) {\n        std::string urlencoded = absl::StrReplaceAll(\n            options.expectedPeerCert(),\n            {{\"\\r\", \"\"}, {\"\\n\", \"%0A\"}, {\" \", \"%20\"}, {\"+\", \"%2B\"}, {\"/\", \"%2F\"}, {\"=\", \"%3D\"}});\n        // Assert twice to ensure a cached value is returned and still valid.\n        EXPECT_EQ(urlencoded, server_connection->ssl()->urlEncodedPemEncodedPeerCertificate());\n        EXPECT_EQ(urlencoded, server_connection->ssl()->urlEncodedPemEncodedPeerCertificate());\n      }\n      if (!options.expectedPeerCertChain().empty()) {\n        std::string cert_chain = absl::StrReplaceAll(\n            options.expectedPeerCertChain(),\n            {{\"\\r\", \"\"}, {\"\\n\", \"%0A\"}, {\" \", \"%20\"}, {\"+\", \"%2B\"}, {\"/\", \"%2F\"}, {\"=\", \"%3D\"}});\n        // Assert twice to ensure a cached value is returned and still valid.\n        EXPECT_EQ(cert_chain, server_connection->ssl()->urlEncodedPemEncodedPeerCertificateChain());\n        EXPECT_EQ(cert_chain, server_connection->ssl()->urlEncodedPemEncodedPeerCertificateChain());\n      }\n      if (!options.expectedValidFromTimePeerCert().empty()) {\n        const std::string formatted = TestUtility::formatTime(\n            server_connection->ssl()->validFromPeerCertificate().value(), \"%b %e %H:%M:%S %Y GMT\");\n        EXPECT_EQ(options.expectedValidFromTimePeerCert(), formatted);\n      }\n      if (!options.expectedExpirationTimePeerCert().empty()) {\n        const std::string formatted = TestUtility::formatTime(\n            server_connection->ssl()->expirationPeerCertificate().value(), \"%b %e %H:%M:%S %Y GMT\");\n        EXPECT_EQ(options.expectedExpirationTimePeerCert(), formatted);\n      }\n      if (options.expectNoCert()) {\n        EXPECT_FALSE(server_connection->ssl()->peerCertificatePresented());\n        EXPECT_FALSE(server_connection->ssl()->validFromPeerCertificate().has_value());\n        EXPECT_FALSE(server_connection->ssl()->expirationPeerCertificate().has_value());\n        EXPECT_EQ(EMPTY_STRING, server_connection->ssl()->sha256PeerCertificateDigest());\n        EXPECT_EQ(EMPTY_STRING, server_connection->ssl()->sha1PeerCertificateDigest());\n        EXPECT_EQ(EMPTY_STRING, server_connection->ssl()->urlEncodedPemEncodedPeerCertificate());\n        EXPECT_EQ(EMPTY_STRING, server_connection->ssl()->subjectPeerCertificate());\n        EXPECT_EQ(std::vector<std::string>{}, server_connection->ssl()->dnsSansPeerCertificate());\n      }\n      if (options.expectNoCertChain()) {\n        EXPECT_EQ(EMPTY_STRING,\n                  server_connection->ssl()->urlEncodedPemEncodedPeerCertificateChain());\n      }\n\n      const SslHandshakerImpl* ssl_socket =\n          dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n      SSL* client_ssl_socket = ssl_socket->ssl();\n      const uint8_t* response_head;\n      size_t response_len;\n      SSL_get0_ocsp_response(client_ssl_socket, &response_head, &response_len);\n      std::string ocsp_response{reinterpret_cast<const char*>(response_head), response_len};\n      EXPECT_EQ(options.expectedOcspResponse(), ocsp_response);\n\n      // By default, the session is not created with session resumption. The\n      // client should see a session ID but the server should not.\n      EXPECT_EQ(EMPTY_STRING, server_connection->ssl()->sessionId());\n      EXPECT_NE(EMPTY_STRING, client_connection->ssl()->sessionId());\n\n      server_connection->close(Network::ConnectionCloseType::NoFlush);\n      client_connection->close(Network::ConnectionCloseType::NoFlush);\n      dispatcher->exit();\n    }\n  };\n\n  size_t close_count = 0;\n  auto close_second_time = [&close_count, &dispatcher]() {\n    if (++close_count == 2) {\n      dispatcher->exit();\n    }\n  };\n\n  if (options.expectSuccess()) {\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  } else {\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n    EXPECT_CALL(server_connection_callbacks, onEvent(options.expectedServerCloseEvent()))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n  }\n\n  if (options.expectedVerifyErrorCode() != -1) {\n    EXPECT_LOG_CONTAINS(\"debug\", X509_verify_cert_error_string(options.expectedVerifyErrorCode()),\n                        dispatcher->run(Event::Dispatcher::RunType::Block));\n  } else {\n    dispatcher->run(Event::Dispatcher::RunType::Block);\n  }\n\n  if (!options.expectedServerStats().empty()) {\n    EXPECT_EQ(1UL, server_stats_store.counter(options.expectedServerStats()).value());\n  }\n\n  if (!options.notExpectedClientStats().empty()) {\n    EXPECT_EQ(0, client_stats_store.counter(options.notExpectedClientStats()).value());\n  }\n\n  if (options.expectSuccess()) {\n    EXPECT_EQ(\"\", client_connection->transportFailureReason());\n    EXPECT_EQ(\"\", server_connection->transportFailureReason());\n  } else {\n    EXPECT_THAT(std::string(client_connection->transportFailureReason()),\n                ContainsRegex(options.expectedTransportFailureReasonContains()));\n    EXPECT_NE(\"\", server_connection->transportFailureReason());\n  }\n}\n\n/**\n * A class to hold the options for testUtilV2().\n */\nclass TestUtilOptionsV2 : public TestUtilOptionsBase {\npublic:\n  TestUtilOptionsV2(\n      const envoy::config::listener::v3::Listener& listener,\n      const envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext& client_ctx_proto,\n      bool expect_success, Network::Address::IpVersion version)\n      : TestUtilOptionsBase(expect_success, version), listener_(listener),\n        client_ctx_proto_(client_ctx_proto), transport_socket_options_(nullptr) {\n    if (expect_success) {\n      setExpectedServerStats(\"ssl.handshake\").setExpectedClientStats(\"ssl.handshake\");\n    } else {\n      setExpectedServerStats(\"ssl.fail_verify_error\")\n          .setExpectedClientStats(\"ssl.connection_error\");\n    }\n  }\n\n  const envoy::config::listener::v3::Listener& listener() const { return listener_; }\n  const envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext& clientCtxProto() const {\n    return client_ctx_proto_;\n  }\n  const std::string& expectedClientStats() const { return expected_client_stats_; }\n\n  TestUtilOptionsV2& setExpectedServerStats(const std::string& expected_server_stats) {\n    TestUtilOptionsBase::setExpectedServerStats(expected_server_stats);\n    return *this;\n  }\n\n  TestUtilOptionsV2& setExpectedClientCertUri(const std::string& expected_client_cert_uri) {\n    TestUtilOptionsBase::setExpectedClientCertUri(expected_client_cert_uri);\n    return *this;\n  }\n\n  TestUtilOptionsV2& setExpectedClientStats(const std::string& expected_client_stats) {\n    expected_client_stats_ = expected_client_stats;\n    return *this;\n  }\n\n  TestUtilOptionsV2& setClientSession(const std::string& client_session) {\n    client_session_ = client_session;\n    return *this;\n  }\n\n  const std::string& clientSession() const { return client_session_; }\n\n  TestUtilOptionsV2& setExpectedProtocolVersion(const std::string& expected_protocol_version) {\n    expected_protocol_version_ = expected_protocol_version;\n    return *this;\n  }\n\n  const std::string& expectedProtocolVersion() const { return expected_protocol_version_; }\n\n  TestUtilOptionsV2& setExpectedCiphersuite(const std::string& expected_cipher_suite) {\n    expected_cipher_suite_ = expected_cipher_suite;\n    return *this;\n  }\n\n  const std::string& expectedCiphersuite() const { return expected_cipher_suite_; }\n\n  TestUtilOptionsV2& setExpectedServerCertDigest(const std::string& expected_server_cert_digest) {\n    expected_server_cert_digest_ = expected_server_cert_digest;\n    return *this;\n  }\n\n  const std::string& expectedServerCertDigest() const { return expected_server_cert_digest_; }\n\n  TestUtilOptionsV2&\n  setExpectedRequestedServerName(const std::string& expected_requested_server_name) {\n    expected_requested_server_name_ = expected_requested_server_name;\n    return *this;\n  }\n\n  const std::string& expectedRequestedServerName() const { return expected_requested_server_name_; }\n\n  TestUtilOptionsV2& setExpectedALPNProtocol(const std::string& expected_alpn_protocol) {\n    expected_alpn_protocol_ = expected_alpn_protocol;\n    return *this;\n  }\n\n  const std::string& expectedALPNProtocol() const { return expected_alpn_protocol_; }\n\n  TestUtilOptionsV2& setTransportSocketOptions(\n      Network::TransportSocketOptionsConstSharedPtr transport_socket_options) {\n    transport_socket_options_ = transport_socket_options;\n    return *this;\n  }\n\n  Network::TransportSocketOptionsConstSharedPtr transportSocketOptions() const {\n    return transport_socket_options_;\n  }\n\n  TestUtilOptionsV2& setExpectedTransportFailureReasonContains(\n      const std::string& expected_transport_failure_reason_contains) {\n    expected_transport_failure_reason_contains_ = expected_transport_failure_reason_contains;\n    return *this;\n  }\n\n  const std::string& expectedTransportFailureReasonContains() const {\n    return expected_transport_failure_reason_contains_;\n  }\n\nprivate:\n  const envoy::config::listener::v3::Listener& listener_;\n  const envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext& client_ctx_proto_;\n  std::string expected_client_stats_;\n\n  std::string client_session_;\n  std::string expected_cipher_suite_;\n  std::string expected_protocol_version_;\n  std::string expected_server_cert_digest_;\n  std::string expected_requested_server_name_;\n  std::string expected_alpn_protocol_;\n  Network::TransportSocketOptionsConstSharedPtr transport_socket_options_;\n  std::string expected_transport_failure_reason_contains_;\n};\n\nvoid testUtilV2(const TestUtilOptionsV2& options) {\n  Event::SimulatedTimeSystem time_system;\n  ContextManagerImpl manager(*time_system);\n\n  // SNI-based selection logic isn't happening in SslSocket anymore.\n  ASSERT(options.listener().filter_chains().size() == 1);\n  const auto& filter_chain = options.listener().filter_chains(0);\n  std::vector<std::string> server_names(filter_chain.filter_chain_match().server_names().begin(),\n                                        filter_chain.filter_chain_match().server_names().end());\n  Stats::TestUtil::TestStore server_stats_store;\n  Api::ApiPtr server_api = Api::createApiForTest(server_stats_store, time_system);\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      server_factory_context;\n  NiceMock<Runtime::MockLoader> runtime;\n  ON_CALL(server_factory_context, api()).WillByDefault(ReturnRef(*server_api));\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  const envoy::config::core::v3::TransportSocket& transport_socket =\n      filter_chain.transport_socket();\n  ASSERT(transport_socket.has_typed_config());\n  transport_socket.typed_config().UnpackTo(&tls_context);\n\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(tls_context, server_factory_context);\n\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, server_names);\n  EXPECT_FALSE(server_ssl_socket_factory.usesProxyProtocolOptions());\n\n  Event::DispatcherPtr dispatcher(server_api->allocateDispatcher(\"test_thread\"));\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(options.version()));\n  NiceMock<Network::MockTcpListenerCallbacks> callbacks;\n  Network::ListenerPtr listener =\n      dispatcher->createListener(socket, callbacks, runtime, true, false);\n\n  Stats::TestUtil::TestStore client_stats_store;\n  Api::ApiPtr client_api = Api::createApiForTest(client_stats_store, time_system);\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      client_factory_context;\n  ON_CALL(client_factory_context, api()).WillByDefault(ReturnRef(*client_api));\n\n  auto client_cfg =\n      std::make_unique<ClientContextConfigImpl>(options.clientCtxProto(), client_factory_context);\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager,\n                                                   client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      client_ssl_socket_factory.createTransportSocket(options.transportSocketOptions()), nullptr);\n\n  if (!options.clientSession().empty()) {\n    const SslHandshakerImpl* ssl_socket =\n        dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n    SSL* client_ssl_socket = ssl_socket->ssl();\n    SSL_CTX* client_ssl_context = SSL_get_SSL_CTX(client_ssl_socket);\n    SSL_SESSION* client_ssl_session =\n        SSL_SESSION_from_bytes(reinterpret_cast<const uint8_t*>(options.clientSession().data()),\n                               options.clientSession().size(), client_ssl_context);\n    int rc = SSL_set_session(client_ssl_socket, client_ssl_session);\n    ASSERT(rc == 1);\n    SSL_SESSION_free(client_ssl_session);\n  }\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  NiceMock<StreamInfo::MockStreamInfo> stream_info;\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        std::string sni = options.transportSocketOptions() != nullptr &&\n                                  options.transportSocketOptions()->serverNameOverride().has_value()\n                              ? options.transportSocketOptions()->serverNameOverride().value()\n                              : options.clientCtxProto().sni();\n        socket->setRequestedServerName(sni);\n        Network::TransportSocketPtr transport_socket =\n            server_ssl_socket_factory.createTransportSocket(nullptr);\n        EXPECT_FALSE(transport_socket->startSecureTransport());\n        server_connection = dispatcher->createServerConnection(\n            std::move(socket), std::move(transport_socket), stream_info);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  size_t connect_count = 0;\n  auto connect_second_time = [&]() {\n    if (++connect_count == 2) {\n      if (!options.expectedServerCertDigest().empty()) {\n        EXPECT_EQ(options.expectedServerCertDigest(),\n                  client_connection->ssl()->sha256PeerCertificateDigest());\n      }\n      if (!options.expectedALPNProtocol().empty()) {\n        EXPECT_EQ(options.expectedALPNProtocol(), client_connection->nextProtocol());\n      }\n      EXPECT_EQ(options.expectedClientCertUri(), server_connection->ssl()->uriSanPeerCertificate());\n      const SslHandshakerImpl* ssl_socket =\n          dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n      SSL* client_ssl_socket = ssl_socket->ssl();\n      if (!options.expectedProtocolVersion().empty()) {\n        // Assert twice to ensure a cached value is returned and still valid.\n        EXPECT_EQ(options.expectedProtocolVersion(), client_connection->ssl()->tlsVersion());\n        EXPECT_EQ(options.expectedProtocolVersion(), client_connection->ssl()->tlsVersion());\n      }\n      if (!options.expectedCiphersuite().empty()) {\n        EXPECT_EQ(options.expectedCiphersuite(), client_connection->ssl()->ciphersuiteString());\n        const SSL_CIPHER* cipher =\n            SSL_get_cipher_by_value(client_connection->ssl()->ciphersuiteId());\n        EXPECT_NE(nullptr, cipher);\n        EXPECT_EQ(options.expectedCiphersuite(), SSL_CIPHER_get_name(cipher));\n      }\n\n      absl::optional<std::string> server_ssl_requested_server_name;\n      const SslHandshakerImpl* server_ssl_socket =\n          dynamic_cast<const SslHandshakerImpl*>(server_connection->ssl().get());\n      SSL* server_ssl = server_ssl_socket->ssl();\n      auto requested_server_name = SSL_get_servername(server_ssl, TLSEXT_NAMETYPE_host_name);\n      if (requested_server_name != nullptr) {\n        server_ssl_requested_server_name = std::string(requested_server_name);\n      }\n\n      if (!options.expectedRequestedServerName().empty()) {\n        EXPECT_TRUE(server_ssl_requested_server_name.has_value());\n        EXPECT_EQ(options.expectedRequestedServerName(), server_ssl_requested_server_name.value());\n      } else {\n        EXPECT_FALSE(server_ssl_requested_server_name.has_value());\n      }\n\n      const uint16_t tls_version = SSL_version(client_ssl_socket);\n      if (SSL3_VERSION <= tls_version && tls_version <= TLS1_2_VERSION) {\n        // Prior to TLS 1.3, one should be able to resume the session. With TLS\n        // 1.3, tickets come after the handshake and the SSL_SESSION on the\n        // client is a dummy object.\n        SSL_SESSION* client_ssl_session = SSL_get_session(client_ssl_socket);\n        EXPECT_TRUE(SSL_SESSION_is_resumable(client_ssl_session));\n      }\n      server_connection->close(Network::ConnectionCloseType::NoFlush);\n      client_connection->close(Network::ConnectionCloseType::NoFlush);\n      dispatcher->exit();\n    }\n  };\n\n  size_t close_count = 0;\n  auto close_second_time = [&close_count, &dispatcher]() {\n    if (++close_count == 2) {\n      dispatcher->exit();\n    }\n  };\n\n  if (options.expectSuccess()) {\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n          EXPECT_EQ(options.expectedRequestedServerName(),\n                    server_connection->requestedServerName());\n          connect_second_time();\n        }));\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  } else {\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n  }\n\n  dispatcher->run(Event::Dispatcher::RunType::Block);\n\n  if (!options.expectedServerStats().empty()) {\n    EXPECT_EQ(1UL, server_stats_store.counter(options.expectedServerStats()).value())\n        << options.expectedServerStats();\n  }\n\n  if (!options.expectedClientStats().empty()) {\n    EXPECT_EQ(1UL, client_stats_store.counter(options.expectedClientStats()).value());\n  }\n\n  if (options.expectSuccess()) {\n    EXPECT_EQ(\"\", client_connection->transportFailureReason());\n    EXPECT_EQ(\"\", server_connection->transportFailureReason());\n  } else {\n    EXPECT_THAT(std::string(client_connection->transportFailureReason()),\n                ContainsRegex(options.expectedTransportFailureReasonContains()));\n    EXPECT_NE(\"\", server_connection->transportFailureReason());\n  }\n}\n\nvoid updateFilterChain(\n    const envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext& tls_context,\n    envoy::config::listener::v3::FilterChain& filter_chain) {\n  filter_chain.mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_context);\n}\n\nstruct OptionalServerConfig {\n  absl::optional<std::string> cert_hash{};\n  absl::optional<std::string> trusted_ca{};\n  absl::optional<bool> allow_expired_cert{};\n};\n\nvoid configureServerAndExpiredClientCertificate(\n    envoy::config::listener::v3::Listener& listener,\n    envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext& client,\n    const OptionalServerConfig& server_config) {\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"));\n\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  if (server_config.trusted_ca.has_value()) {\n    server_validation_ctx->mutable_trusted_ca()->set_filename(\n        TestEnvironment::substitute(server_config.trusted_ca.value()));\n  } else {\n    server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n        \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  }\n  if (server_config.allow_expired_cert.has_value()) {\n    server_validation_ctx->set_allow_expired_certificate(server_config.allow_expired_cert.value());\n  }\n  if (server_config.cert_hash.has_value()) {\n    server_validation_ctx->add_verify_certificate_hash(server_config.cert_hash.value());\n  }\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/expired_san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/expired_san_uri_key.pem\"));\n}\n\nTestUtilOptionsV2 createProtocolTestOptions(\n    const envoy::config::listener::v3::Listener& listener,\n    const envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext& client_ctx,\n    Network::Address::IpVersion version, std::string protocol) {\n  std::string stats = \"ssl.versions.\" + protocol;\n  TestUtilOptionsV2 options(listener, client_ctx, true, version);\n  options.setExpectedServerStats(stats).setExpectedClientStats(stats);\n  return options.setExpectedProtocolVersion(protocol);\n}\n\n} // namespace\n\nclass SslSocketTest : public SslCertsTest,\n                      public testing::WithParamInterface<Network::Address::IpVersion> {\nprotected:\n  SslSocketTest()\n      : dispatcher_(api_->allocateDispatcher(\"test_thread\")),\n        stream_info_(api_->timeSource(), nullptr) {}\n\n  void testClientSessionResumption(const std::string& server_ctx_yaml,\n                                   const std::string& client_ctx_yaml, bool expect_reuse,\n                                   const Network::Address::IpVersion version);\n\n  NiceMock<Runtime::MockLoader> runtime_;\n  Event::DispatcherPtr dispatcher_;\n  StreamInfo::StreamInfoImpl stream_info_;\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, SslSocketTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(SslSocketTest, GetCertDigest) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedSha256Digest(TEST_NO_SAN_CERT_256_HASH)\n               .setExpectedSha1Digest(TEST_NO_SAN_CERT_1_HASH)\n               .setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, GetCertDigestInvalidFiles) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(\n      test_options.setExpectedSha256Digest(\"\").setExpectedSha1Digest(\"\").setExpectedSerialNumber(\n          \"\"));\n}\n\nTEST_P(SslSocketTest, GetCertDigestInline) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n\n  // From test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem.\n  server_cert->mutable_certificate_chain()->set_inline_bytes(\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\")));\n\n  // From test/extensions/transport_sockets/tls/test_data/san_dns_key.pem.\n  server_cert->mutable_private_key()->set_inline_bytes(\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\")));\n\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  // From test/extensions/transport_sockets/tls/test_data/ca_certificates.pem.\n  server_validation_ctx->mutable_trusted_ca()->set_inline_bytes(\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir \"\n          \"}}/test/extensions/transport_sockets/tls/test_data/ca_certificates.pem\")));\n\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client_ctx;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client_ctx.mutable_common_tls_context()->add_tls_certificates();\n\n  // From test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem.\n  client_cert->mutable_certificate_chain()->set_inline_bytes(\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\")));\n\n  // From test/extensions/transport_sockets/tls/test_data/san_uri_key.pem.\n  client_cert->mutable_private_key()->set_inline_bytes(\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\")));\n\n  TestUtilOptionsV2 test_options(listener, client_ctx, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_SAN_DNS_CERT_256_HASH));\n}\n\nTEST_P(SslSocketTest, GetCertDigestServerCertWithIntermediateCA) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_chain.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedSha256Digest(TEST_NO_SAN_CERT_256_HASH)\n               .setExpectedSha1Digest(TEST_NO_SAN_CERT_1_HASH)\n               .setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, GetCertDigestServerCertWithoutCommonName) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_only_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_only_dns_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedSha256Digest(TEST_NO_SAN_CERT_256_HASH)\n               .setExpectedSha1Digest(TEST_NO_SAN_CERT_1_HASH)\n               .setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, GetUriWithUriSan) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      match_typed_subject_alt_names:\n      - san_type: URI\n        matcher:\n          exact: \"spiffe://lyft.com/test-team\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n               .setExpectedSerialNumber(TEST_SAN_URI_CERT_SERIAL));\n}\n\n// Verify that IP SANs work with an IPv4 address specified in the validation context.\nTEST_P(SslSocketTest, Ipv4San) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamcacert.pem\"\n      match_typed_subject_alt_names:\n      - san_type: IP_ADDRESS\n        matcher:\n          exact: \"127.0.0.1\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamlocalhostcert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamlocalhostkey.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options);\n}\n\n// Verify that IP SANs work with an IPv6 address specified in the validation context.\nTEST_P(SslSocketTest, Ipv6San) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamcacert.pem\"\n      match_typed_subject_alt_names:\n      - san_type: IP_ADDRESS\n        matcher:\n          exact: \"::1\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamlocalhostcert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamlocalhostkey.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options);\n}\n\nTEST_P(SslSocketTest, GetNoUriWithDnsSan) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  // The SAN field only has DNS, expect \"\" for uriSanPeerCertificate().\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedSerialNumber(TEST_SAN_DNS_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, NoCert) {\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.no_certificate\")\n               .setExpectNoCert()\n               .setExpectNoCertChain());\n}\n\n// Prefer ECDSA certificate when multiple RSA certificates are present and the\n// client is RSA/ECDSA capable. We validate TLSv1.2 only here, since we validate\n// the e2e behavior on TLSv1.2/1.3 in ssl_integration_test.\nTEST_P(SslSocketTest, MultiCertPreferEcdsa) {\n  const std::string client_ctx_yaml = absl::StrCat(R\"EOF(\n    common_tls_context:\n      tls_params:\n        tls_minimum_protocol_version: TLSv1_2\n        tls_maximum_protocol_version: TLSv1_2\n        cipher_suites:\n        - ECDHE-ECDSA-AES128-GCM-SHA256\n        - ECDHE-RSA-AES128-GCM-SHA256\n      validation_context:\n        verify_certificate_hash: )EOF\",\n                                                   TEST_SELFSIGNED_ECDSA_P256_CERT_256_HASH);\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_key.pem\"\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options);\n}\n\nTEST_P(SslSocketTest, GetUriWithLocalUriSan) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedLocalUri(\"spiffe://lyft.com/test-team\")\n               .setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, GetSubjectsWithBothCerts) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  require_client_certificate: true\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL)\n               .setExpectedPeerIssuer(\n                   \"CN=Test CA,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedPeerSubject(\n                   \"CN=Test Server,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedLocalSubject(\n                   \"CN=Test Server,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\"));\n}\n\nTEST_P(SslSocketTest, GetPeerCert) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  require_client_certificate: true\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  std::string expected_peer_cert =\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"));\n  testUtil(test_options.setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL)\n               .setExpectedPeerIssuer(\n                   \"CN=Test CA,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedPeerSubject(\n                   \"CN=Test Server,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedLocalSubject(\n                   \"CN=Test Server,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedPeerCert(expected_peer_cert));\n}\n\nTEST_P(SslSocketTest, GetPeerCertAcceptUntrusted) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"\n      trust_chain_verification: ACCEPT_UNTRUSTED\n  require_client_certificate: true\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  std::string expected_peer_cert =\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"));\n  testUtil(test_options.setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL)\n               .setExpectedPeerIssuer(\n                   \"CN=Test CA,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedPeerSubject(\n                   \"CN=Test Server,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedLocalSubject(\n                   \"CN=Test Server,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedPeerCert(expected_peer_cert));\n}\n\nTEST_P(SslSocketTest, NoCertUntrustedNotPermitted) {\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"\n      trust_chain_verification: VERIFY_TRUST_CHAIN\n      verify_certificate_hash: \"0000000000000000000000000000000000000000000000000000000000000000\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\"));\n}\n\nTEST_P(SslSocketTest, NoCertUntrustedPermitted) {\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"\n      trust_chain_verification: ACCEPT_UNTRUSTED\n      verify_certificate_hash: \"0000000000000000000000000000000000000000000000000000000000000000\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.no_certificate\")\n               .setExpectNoCert()\n               .setExpectNoCertChain());\n}\n\nTEST_P(SslSocketTest, GetPeerCertChain) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_chain.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  require_client_certificate: true\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  std::string expected_peer_cert_chain =\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir \"\n          \"}}/test/extensions/transport_sockets/tls/test_data/no_san_chain.pem\"));\n  testUtil(test_options.setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL)\n               .setExpectedPeerCertChain(expected_peer_cert_chain));\n}\n\nTEST_P(SslSocketTest, GetIssueExpireTimesPeerCert) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  require_client_certificate: true\n)EOF\";\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL)\n               .setExpectedValidFromTimePeerCert(TEST_NO_SAN_CERT_NOT_BEFORE)\n               .setExpectedExpirationTimePeerCert(TEST_NO_SAN_CERT_NOT_AFTER));\n}\n\nTEST_P(SslSocketTest, FailedClientAuthCaVerificationNoClientCert) {\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  require_client_certificate: true\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\"));\n}\n\nTEST_P(SslSocketTest, FailedClientAuthCaVerification) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY));\n}\n\nTEST_P(SslSocketTest, FailedClientAuthSanVerificationNoClientCert) {\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      match_typed_subject_alt_names:\n      - san_type: DNS\n        matcher:\n          exact: \"example.com\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\"));\n}\n\nTEST_P(SslSocketTest, FailedClientAuthSanVerification) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      match_typed_subject_alt_names:\n      - san_type: DNS\n        matcher:\n          exact: \"example.com\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_san\"));\n}\n\nTEST_P(SslSocketTest, X509ExtensionsCertificateSerialNumber) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/extensions_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/extensions_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/extensions_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/extensions_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  require_client_certificate: true\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedSerialNumber(TEST_EXTENSIONS_CERT_SERIAL));\n}\n\n// By default, expired certificates are not permitted.\nTEST_P(SslSocketTest, FailedClientCertificateDefaultExpirationVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  configureServerAndExpiredClientCertificate(listener, client, /*server_config=*/{});\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_EXPIRED\"));\n}\n\n// Expired certificates will not be accepted when explicitly disallowed via\n// allow_expired_certificate.\nTEST_P(SslSocketTest, FailedClientCertificateExpirationVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  OptionalServerConfig server_config;\n  server_config.allow_expired_cert = false;\n  configureServerAndExpiredClientCertificate(listener, client, server_config);\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_EXPIRED\"));\n}\n\n// Expired certificates will be accepted when explicitly allowed via allow_expired_certificate.\nTEST_P(SslSocketTest, ClientCertificateExpirationAllowedVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  OptionalServerConfig server_config;\n  server_config.allow_expired_cert = true;\n  configureServerAndExpiredClientCertificate(listener, client, server_config);\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_EXPIRED\"));\n}\n\n// Allow expired certificates, but add a certificate hash requirement so it still fails.\nTEST_P(SslSocketTest, FailedClientCertAllowExpiredBadHashVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  OptionalServerConfig server_config;\n  server_config.allow_expired_cert = true;\n  server_config.cert_hash = \"0000000000000000000000000000000000000000000000000000000000000000\";\n  configureServerAndExpiredClientCertificate(listener, client, server_config);\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_cert_hash\")\n                 .setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_EXPIRED\"));\n}\n\n// Allow expired certificates, but use the wrong CA so it should fail still.\nTEST_P(SslSocketTest, FailedClientCertAllowServerExpiredWrongCAVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  OptionalServerConfig server_config;\n  server_config.allow_expired_cert = true;\n  // Fake CA is not used to sign the client's certificate.\n  server_config.trusted_ca = \"{{ test_rundir \"\n                             \"}}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\";\n  configureServerAndExpiredClientCertificate(listener, client, server_config);\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedTransportFailureReasonContains(\"TLSV1_ALERT_UNKNOWN_CA\"));\n}\n\nTEST_P(SslSocketTest, ClientCertificateHashVerification) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = absl::StrCat(R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      verify_certificate_hash: \")EOF\",\n                                                   TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n               .setExpectedSerialNumber(TEST_SAN_URI_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, ClientCertificateHashVerificationNoCA) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = absl::StrCat(R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      verify_certificate_hash: \")EOF\",\n                                                   TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n               .setExpectedSerialNumber(TEST_SAN_URI_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, ClientCertificateHashListVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_hash(TEST_SAN_URI_CERT_256_HASH);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_SAN_DNS_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, ClientCertificateHashListVerificationNoCA) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_hash(TEST_SAN_URI_CERT_256_HASH);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_SAN_DNS_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashVerificationNoClientCertificate) {\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  const std::string server_ctx_yaml = absl::StrCat(R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      verify_certificate_hash: \")EOF\",\n                                                   TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\"));\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashVerificationNoCANoClientCertificate) {\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  const std::string server_ctx_yaml = absl::StrCat(R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      verify_certificate_hash: \")EOF\",\n                                                   TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\"));\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashVerificationWrongClientCertificate) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = absl::StrCat(R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      verify_certificate_hash: \")EOF\",\n                                                   TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_cert_hash\"));\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashVerificationNoCAWrongClientCertificate) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = absl::StrCat(R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      verify_certificate_hash: \")EOF\",\n                                                   TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_cert_hash\"));\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashVerificationWrongCA) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = absl::StrCat(R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"\n      verify_certificate_hash: \")EOF\",\n                                                   TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY));\n}\n\nTEST_P(SslSocketTest, CertificatesWithPassword) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_key.pem\"));\n  server_cert->mutable_password()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_password.txt\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_hash(TEST_PASSWORD_PROTECTED_CERT_256_HASH);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_key.pem\"));\n  client_cert->mutable_password()->set_inline_string(\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir \"\n          \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_password.txt\")));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_PASSWORD_PROTECTED_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, Pkcs12CertificatesWithPassword) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n\n  server_cert->mutable_pkcs12()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_certkey.p12\"));\n  server_cert->mutable_password()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_password.txt\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_hash(TEST_PASSWORD_PROTECTED_CERT_256_HASH);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_pkcs12()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_certkey.p12\"));\n  client_cert->mutable_password()->set_inline_string(\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir \"\n          \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_password.txt\")));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_PASSWORD_PROTECTED_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, Pkcs12CertificatesWithoutPassword) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n\n  server_cert->mutable_pkcs12()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/san_dns3_certkeychain.p12\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_hash(TEST_SAN_DNS3_CERT_256_HASH);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_pkcs12()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/san_dns3_certkeychain.p12\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedServerCertDigest(TEST_SAN_DNS3_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, ClientCertificateSpkiVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_SAN_DNS_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, ClientCertificateSpkiVerificationNoCA) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_SAN_DNS_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationNoClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_HANDSHAKE_FAILURE\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationNoCANoClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_HANDSHAKE_FAILURE\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationWrongClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_cert_hash\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_UNKNOWN\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationNoCAWrongClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_cert_hash\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_UNKNOWN\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationWrongCA) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedTransportFailureReasonContains(\"TLSV1_ALERT_UNKNOWN_CA\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, ClientCertificateHashAndSpkiVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_SAN_DNS_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, ClientCertificateHashAndSpkiVerificationNoCA) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_SAN_DNS_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationNoClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_HANDSHAKE_FAILURE\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationNoCANoClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_HANDSHAKE_FAILURE\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationWrongClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_cert_hash\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_UNKNOWN\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationNoCAWrongClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_cert_hash\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_UNKNOWN\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationWrongCA) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedTransportFailureReasonContains(\"TLSV1_ALERT_UNKNOWN_CA\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\n// Make sure that we do not flush code and do an immediate close if we have not completed the\n// handshake.\nTEST_P(SslSocketTest, FlushCloseDuringHandshake) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_certificates.pem\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), tls_context);\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(tls_context, factory_context_);\n  ContextManagerImpl manager(time_system_);\n  Stats::TestUtil::TestStore server_stats_store;\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  Network::MockTcpListenerCallbacks callbacks;\n  Network::ListenerPtr listener =\n      dispatcher_->createListener(socket, callbacks, runtime_, true, false);\n\n  Network::ClientConnectionPtr client_connection = dispatcher_->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      Network::Test::createRawBufferSocket(), nullptr);\n  client_connection->connect();\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n        Buffer::OwnedImpl data(\"hello\");\n        server_connection->write(data, false);\n        server_connection->close(Network::ConnectionCloseType::FlushWrite);\n      }));\n\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\n// Test that half-close is sent and received correctly\nTEST_P(SslSocketTest, HalfClose) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_certificates.pem\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), server_tls_context);\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(server_tls_context, factory_context_);\n  ContextManagerImpl manager(time_system_);\n  Stats::TestUtil::TestStore server_stats_store;\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  Network::MockTcpListenerCallbacks listener_callbacks;\n  Network::ListenerPtr listener =\n      dispatcher_->createListener(socket, listener_callbacks, runtime_, true, false);\n  std::shared_ptr<Network::MockReadFilter> server_read_filter(new Network::MockReadFilter());\n  std::shared_ptr<Network::MockReadFilter> client_read_filter(new Network::MockReadFilter());\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), tls_context);\n  auto client_cfg = std::make_unique<ClientContextConfigImpl>(tls_context, factory_context_);\n  Stats::TestUtil::TestStore client_stats_store;\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager,\n                                                   client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher_->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      client_ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n  client_connection->enableHalfClose(true);\n  client_connection->addReadFilter(client_read_filter);\n  client_connection->connect();\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  EXPECT_CALL(listener_callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->enableHalfClose(true);\n        server_connection->addReadFilter(server_read_filter);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n        Buffer::OwnedImpl data(\"hello\");\n        server_connection->write(data, true);\n      }));\n\n  EXPECT_CALL(*server_read_filter, onNewConnection())\n      .WillOnce(Return(Network::FilterStatus::Continue));\n  EXPECT_CALL(*client_read_filter, onNewConnection())\n      .WillOnce(Return(Network::FilterStatus::Continue));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected));\n  EXPECT_CALL(*client_read_filter, onData(BufferStringEqual(\"hello\"), true))\n      .WillOnce(Invoke([&](Buffer::Instance&, bool) -> Network::FilterStatus {\n        Buffer::OwnedImpl buffer(\"world\");\n        client_connection->write(buffer, true);\n        return Network::FilterStatus::Continue;\n      }));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  EXPECT_CALL(*server_read_filter, onData(BufferStringEqual(\"world\"), true));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(SslSocketTest, ShutdownWithCloseNotify) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_certificates.pem\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), server_tls_context);\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(server_tls_context, factory_context_);\n  ContextManagerImpl manager(time_system_);\n  Stats::TestUtil::TestStore server_stats_store;\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  Network::MockTcpListenerCallbacks listener_callbacks;\n  Network::ListenerPtr listener =\n      dispatcher_->createListener(socket, listener_callbacks, runtime_, true, false);\n  std::shared_ptr<Network::MockReadFilter> server_read_filter(new Network::MockReadFilter());\n  std::shared_ptr<Network::MockReadFilter> client_read_filter(new Network::MockReadFilter());\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), tls_context);\n  auto client_cfg = std::make_unique<ClientContextConfigImpl>(tls_context, factory_context_);\n  Stats::TestUtil::TestStore client_stats_store;\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager,\n                                                   client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher_->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      client_ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->enableHalfClose(true);\n  client_connection->addReadFilter(client_read_filter);\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  EXPECT_CALL(listener_callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->enableHalfClose(true);\n        server_connection->addReadFilter(server_read_filter);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n  EXPECT_CALL(*server_read_filter, onNewConnection());\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        Buffer::OwnedImpl data(\"hello\");\n        server_connection->write(data, true);\n        EXPECT_EQ(data.length(), 0);\n      }));\n\n  EXPECT_CALL(*client_read_filter, onNewConnection())\n      .WillOnce(Return(Network::FilterStatus::Continue));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected));\n  EXPECT_CALL(*client_read_filter, onData(BufferStringEqual(\"hello\"), true))\n      .WillOnce(Invoke([&](Buffer::Instance& read_buffer, bool) -> Network::FilterStatus {\n        read_buffer.drain(read_buffer.length());\n        client_connection->close(Network::ConnectionCloseType::NoFlush);\n        return Network::FilterStatus::StopIteration;\n      }));\n  EXPECT_CALL(*server_read_filter, onData(_, true));\n\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        server_connection->close(Network::ConnectionCloseType::NoFlush);\n        dispatcher_->exit();\n      }));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(SslSocketTest, ShutdownWithoutCloseNotify) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_certificates.pem\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), server_tls_context);\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(server_tls_context, factory_context_);\n  ContextManagerImpl manager(time_system_);\n  Stats::TestUtil::TestStore server_stats_store;\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  Network::MockTcpListenerCallbacks listener_callbacks;\n  Network::ListenerPtr listener =\n      dispatcher_->createListener(socket, listener_callbacks, runtime_, true, false);\n  std::shared_ptr<Network::MockReadFilter> server_read_filter(new Network::MockReadFilter());\n  std::shared_ptr<Network::MockReadFilter> client_read_filter(new Network::MockReadFilter());\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), tls_context);\n  auto client_cfg = std::make_unique<ClientContextConfigImpl>(tls_context, factory_context_);\n  Stats::TestUtil::TestStore client_stats_store;\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager,\n                                                   client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher_->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      client_ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->enableHalfClose(true);\n  client_connection->addReadFilter(client_read_filter);\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  EXPECT_CALL(listener_callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->enableHalfClose(true);\n        server_connection->addReadFilter(server_read_filter);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        Buffer::OwnedImpl data(\"hello\");\n        server_connection->write(data, false);\n        EXPECT_EQ(data.length(), 0);\n        // Calling close(FlushWrite) in onEvent() callback results in PostIoAction::Close,\n        // after which the connection is closed without write ready event being delivered,\n        // and with all outstanding data (here, \"hello\") being lost.\n      }));\n\n  EXPECT_CALL(*client_read_filter, onNewConnection())\n      .WillOnce(Return(Network::FilterStatus::Continue));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected));\n  EXPECT_CALL(*client_read_filter, onData(BufferStringEqual(\"hello\"), false))\n      .WillOnce(Invoke([&](Buffer::Instance& read_buffer, bool) -> Network::FilterStatus {\n        read_buffer.drain(read_buffer.length());\n        // Close without sending close_notify alert.\n        const SslHandshakerImpl* ssl_socket =\n            dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n        EXPECT_EQ(ssl_socket->state(), Ssl::SocketState::HandshakeComplete);\n        SSL_set_quiet_shutdown(ssl_socket->ssl(), 1);\n        client_connection->close(Network::ConnectionCloseType::FlushWrite);\n        return Network::FilterStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(*server_read_filter, onNewConnection())\n      .WillOnce(Return(Network::FilterStatus::Continue));\n  EXPECT_CALL(*server_read_filter, onData(BufferStringEqual(\"\"), true))\n      .WillOnce(Invoke([&](Buffer::Instance&, bool) -> Network::FilterStatus {\n        // Close without sending close_notify alert.\n        const SslHandshakerImpl* ssl_socket =\n            dynamic_cast<const SslHandshakerImpl*>(server_connection->ssl().get());\n        EXPECT_EQ(ssl_socket->state(), Ssl::SocketState::HandshakeComplete);\n        SSL_set_quiet_shutdown(ssl_socket->ssl(), 1);\n        server_connection->close(Network::ConnectionCloseType::NoFlush);\n        return Network::FilterStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(SslSocketTest, ClientAuthMultipleCAs) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_certificates.pem\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), server_tls_context);\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(server_tls_context, factory_context_);\n  ContextManagerImpl manager(time_system_);\n  Stats::TestUtil::TestStore server_stats_store;\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  Network::MockTcpListenerCallbacks callbacks;\n  Network::ListenerPtr listener =\n      dispatcher_->createListener(socket, callbacks, runtime_, true, false);\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), tls_context);\n  auto client_cfg = std::make_unique<ClientContextConfigImpl>(tls_context, factory_context_);\n  Stats::TestUtil::TestStore client_stats_store;\n  ClientSslSocketFactory ssl_socket_factory(std::move(client_cfg), manager, client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher_->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n\n  // Verify that server sent list with 2 acceptable client certificate CA names.\n  const SslHandshakerImpl* ssl_socket =\n      dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n  SSL_set_cert_cb(\n      ssl_socket->ssl(),\n      [](SSL* ssl, void*) -> int {\n        STACK_OF(X509_NAME)* list = SSL_get_client_CA_list(ssl);\n        EXPECT_NE(nullptr, list);\n        EXPECT_EQ(2U, sk_X509_NAME_num(list));\n        return 1;\n      },\n      nullptr);\n\n  client_connection->connect();\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        server_connection->close(Network::ConnectionCloseType::NoFlush);\n        client_connection->close(Network::ConnectionCloseType::NoFlush);\n        dispatcher_->exit();\n      }));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(1UL, server_stats_store.counter(\"ssl.handshake\").value());\n}\n\nnamespace {\n\n// Test connecting with a client to server1, then trying to reuse the session on server2\nvoid testTicketSessionResumption(const std::string& server_ctx_yaml1,\n                                 const std::vector<std::string>& server_names1,\n                                 const std::string& server_ctx_yaml2,\n                                 const std::vector<std::string>& server_names2,\n                                 const std::string& client_ctx_yaml, bool expect_reuse,\n                                 const Network::Address::IpVersion ip_version,\n                                 const uint32_t expected_lifetime_hint = 0) {\n  Event::SimulatedTimeSystem time_system;\n  ContextManagerImpl manager(*time_system);\n\n  Stats::TestUtil::TestStore server_stats_store;\n  Api::ApiPtr server_api = Api::createApiForTest(server_stats_store, time_system);\n  NiceMock<Runtime::MockLoader> runtime;\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      server_factory_context;\n  ON_CALL(server_factory_context, api()).WillByDefault(ReturnRef(*server_api));\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context1;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml1), server_tls_context1);\n  auto server_cfg1 =\n      std::make_unique<ServerContextConfigImpl>(server_tls_context1, server_factory_context);\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context2;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml2), server_tls_context2);\n  auto server_cfg2 =\n      std::make_unique<ServerContextConfigImpl>(server_tls_context2, server_factory_context);\n  ServerSslSocketFactory server_ssl_socket_factory1(std::move(server_cfg1), manager,\n                                                    server_stats_store, server_names1);\n  ServerSslSocketFactory server_ssl_socket_factory2(std::move(server_cfg2), manager,\n                                                    server_stats_store, server_names2);\n\n  auto socket1 = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(ip_version));\n  auto socket2 = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(ip_version));\n  NiceMock<Network::MockTcpListenerCallbacks> callbacks;\n  Event::DispatcherPtr dispatcher(server_api->allocateDispatcher(\"test_thread\"));\n  Network::ListenerPtr listener1 =\n      dispatcher->createListener(socket1, callbacks, runtime, true, false);\n  Network::ListenerPtr listener2 =\n      dispatcher->createListener(socket2, callbacks, runtime, true, false);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), client_tls_context);\n\n  Stats::TestUtil::TestStore client_stats_store;\n  Api::ApiPtr client_api = Api::createApiForTest(client_stats_store, time_system);\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      client_factory_context;\n  ON_CALL(client_factory_context, api()).WillByDefault(ReturnRef(*client_api));\n\n  auto client_cfg =\n      std::make_unique<ClientContextConfigImpl>(client_tls_context, client_factory_context);\n  ClientSslSocketFactory ssl_socket_factory(std::move(client_cfg), manager, client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher->createClientConnection(\n      socket1->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  SSL_SESSION* ssl_session = nullptr;\n  Network::ConnectionPtr server_connection;\n  StreamInfo::StreamInfoImpl stream_info(time_system, nullptr);\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        Network::TransportSocketFactory& tsf =\n            socket->connectionInfoProvider().localAddress() ==\n                    socket1->connectionInfoProvider().localAddress()\n                ? server_ssl_socket_factory1\n                : server_ssl_socket_factory2;\n        server_connection = dispatcher->createServerConnection(\n            std::move(socket), tsf.createTransportSocket(nullptr), stream_info);\n      }));\n\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        const SslHandshakerImpl* ssl_socket =\n            dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n        ssl_session = SSL_get1_session(ssl_socket->ssl());\n        EXPECT_TRUE(SSL_SESSION_is_resumable(ssl_session));\n        if (expected_lifetime_hint) {\n          auto lifetime_hint = SSL_SESSION_get_ticket_lifetime_hint(ssl_session);\n          EXPECT_TRUE(lifetime_hint <= expected_lifetime_hint);\n        }\n        client_connection->close(Network::ConnectionCloseType::NoFlush);\n        server_connection->close(Network::ConnectionCloseType::NoFlush);\n        dispatcher->exit();\n      }));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n\n  dispatcher->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(0UL, server_stats_store.counter(\"ssl.session_reused\").value());\n  EXPECT_EQ(0UL, client_stats_store.counter(\"ssl.session_reused\").value());\n\n  client_connection = dispatcher->createClientConnection(\n      socket2->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  const SslHandshakerImpl* ssl_socket =\n      dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n  SSL_set_session(ssl_socket->ssl(), ssl_session);\n  SSL_SESSION_free(ssl_session);\n\n  client_connection->connect();\n\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  StreamInfo::StreamInfoImpl stream_info2(time_system, nullptr);\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        Network::TransportSocketFactory& tsf =\n            socket->connectionInfoProvider().localAddress() ==\n                    socket1->connectionInfoProvider().localAddress()\n                ? server_ssl_socket_factory1\n                : server_ssl_socket_factory2;\n        server_connection = dispatcher->createServerConnection(\n            std::move(socket), tsf.createTransportSocket(nullptr), stream_info2);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  // Different tests have different order of whether client or server gets Connected event\n  // first, so always wait until both have happened.\n  size_t connect_count = 0;\n  auto connect_second_time = [&connect_count, &dispatcher, &server_connection, &client_connection,\n                              expect_reuse]() {\n    connect_count++;\n    if (connect_count == 2) {\n      if (expect_reuse) {\n        EXPECT_NE(EMPTY_STRING, server_connection->ssl()->sessionId());\n        EXPECT_EQ(server_connection->ssl()->sessionId(), client_connection->ssl()->sessionId());\n      } else {\n        EXPECT_EQ(EMPTY_STRING, server_connection->ssl()->sessionId());\n      }\n      client_connection->close(Network::ConnectionCloseType::NoFlush);\n      server_connection->close(Network::ConnectionCloseType::NoFlush);\n      dispatcher->exit();\n    }\n  };\n\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n\n  dispatcher->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(expect_reuse ? 1UL : 0UL, server_stats_store.counter(\"ssl.session_reused\").value());\n  EXPECT_EQ(expect_reuse ? 1UL : 0UL, client_stats_store.counter(\"ssl.session_reused\").value());\n}\n\nvoid testSupportForStatelessSessionResumption(const std::string& server_ctx_yaml,\n                                              const std::string& client_ctx_yaml,\n                                              bool expect_support,\n                                              const Network::Address::IpVersion ip_version) {\n  Event::SimulatedTimeSystem time_system;\n  ContextManagerImpl manager(*time_system);\n\n  Stats::IsolatedStoreImpl server_stats_store;\n  Api::ApiPtr server_api = Api::createApiForTest(server_stats_store, time_system);\n  NiceMock<Runtime::MockLoader> runtime;\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      server_factory_context;\n  ON_CALL(server_factory_context, api()).WillByDefault(ReturnRef(*server_api));\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), server_tls_context);\n  auto server_cfg =\n      std::make_unique<ServerContextConfigImpl>(server_tls_context, server_factory_context);\n\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, {});\n  auto tcp_socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(ip_version));\n  NiceMock<Network::MockTcpListenerCallbacks> callbacks;\n  Event::DispatcherPtr dispatcher(server_api->allocateDispatcher(\"test_thread\"));\n  Network::ListenerPtr listener =\n      dispatcher->createListener(tcp_socket, callbacks, runtime, true, false);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), client_tls_context);\n\n  Stats::IsolatedStoreImpl client_stats_store;\n  Api::ApiPtr client_api = Api::createApiForTest(client_stats_store, time_system);\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      client_factory_context;\n  ON_CALL(client_factory_context, api()).WillByDefault(ReturnRef(*client_api));\n\n  auto client_cfg =\n      std::make_unique<ClientContextConfigImpl>(client_tls_context, client_factory_context);\n  ClientSslSocketFactory ssl_socket_factory(std::move(client_cfg), manager, client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher->createClientConnection(\n      tcp_socket->connectionInfoProvider().localAddress(),\n      Network::Address::InstanceConstSharedPtr(), ssl_socket_factory.createTransportSocket(nullptr),\n      nullptr);\n\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  StreamInfo::StreamInfoImpl stream_info(time_system, nullptr);\n  Network::ConnectionPtr server_connection;\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info);\n\n        const SslHandshakerImpl* ssl_socket =\n            dynamic_cast<const SslHandshakerImpl*>(server_connection->ssl().get());\n        SSL* server_ssl_socket = ssl_socket->ssl();\n        SSL_CTX* server_ssl_context = SSL_get_SSL_CTX(server_ssl_socket);\n        if (expect_support) {\n          EXPECT_EQ(0, (SSL_CTX_get_options(server_ssl_context) & SSL_OP_NO_TICKET));\n        } else {\n          EXPECT_EQ(SSL_OP_NO_TICKET, (SSL_CTX_get_options(server_ssl_context) & SSL_OP_NO_TICKET));\n        }\n      }));\n\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        client_connection->close(Network::ConnectionCloseType::NoFlush);\n        server_connection->close(Network::ConnectionCloseType::NoFlush);\n        dispatcher->exit();\n      }));\n\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  dispatcher->run(Event::Dispatcher::RunType::Block);\n}\n\n} // namespace\n\nTEST_P(SslSocketTest, TicketSessionResumption) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml, {}, server_ctx_yaml, {}, client_ctx_yaml, true,\n                              GetParam());\n}\n\nTEST_P(SslSocketTest, TicketSessionResumptionCustomTimeout) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_0\n      tls_maximum_protocol_version: TLSv1_2\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n  session_timeout: 2307s\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml, {}, server_ctx_yaml, {}, client_ctx_yaml, true,\n                              GetParam(), 2307);\n}\n\nTEST_P(SslSocketTest, TicketSessionResumptionWithClientCA) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml, {}, server_ctx_yaml, {}, client_ctx_yaml, true,\n                              GetParam());\n}\n\nTEST_P(SslSocketTest, TicketSessionResumptionRotateKey) {\n  const std::string server_ctx_yaml1 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string server_ctx_yaml2 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_b\"\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, true,\n                              GetParam());\n}\n\nTEST_P(SslSocketTest, TicketSessionResumptionWrongKey) {\n  const std::string server_ctx_yaml1 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string server_ctx_yaml2 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_b\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, false,\n                              GetParam());\n}\n\n// Sessions cannot be resumed even though the server certificates are the same,\n// because of the different SNI requirements.\nTEST_P(SslSocketTest, TicketSessionResumptionDifferentServerNames) {\n  const std::string server_ctx_yaml1 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string server_ctx_yaml2 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  std::vector<std::string> server_names1 = {\"server1.example.com\"};\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, server_names1, server_ctx_yaml2, {},\n                              client_ctx_yaml, false, GetParam());\n}\n\n// Sessions can be resumed because the server certificates are different but the CN/SANs and\n// issuer are identical\nTEST_P(SslSocketTest, TicketSessionResumptionDifferentServerCert) {\n  const std::string server_ctx_yaml1 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string server_ctx_yaml2 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, true,\n                              GetParam());\n}\n\n// Sessions cannot be resumed because the server certificates are different, CN/SANs are identical,\n// but the issuer is different.\nTEST_P(SslSocketTest, TicketSessionResumptionDifferentServerCertIntermediateCA) {\n  const std::string server_ctx_yaml1 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string server_ctx_yaml2 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_chain.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, false,\n                              GetParam());\n}\n\n// Sessions cannot be resumed because the server certificates are different and the SANs\n// are not identical\nTEST_P(SslSocketTest, TicketSessionResumptionDifferentServerCertDifferentSAN) {\n  const std::string server_ctx_yaml1 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string server_ctx_yaml2 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_multiple_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_multiple_dns_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, false,\n                              GetParam());\n}\n\nTEST_P(SslSocketTest, StatelessSessionResumptionDisabled) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  disable_stateless_session_resumption: true\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testSupportForStatelessSessionResumption(server_ctx_yaml, client_ctx_yaml, false, GetParam());\n}\n\nTEST_P(SslSocketTest, SatelessSessionResumptionEnabledExplicitly) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  disable_stateless_session_resumption: false\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testSupportForStatelessSessionResumption(server_ctx_yaml, client_ctx_yaml, true, GetParam());\n}\n\nTEST_P(SslSocketTest, StatelessSessionResumptionEnabledByDefault) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testSupportForStatelessSessionResumption(server_ctx_yaml, client_ctx_yaml, true, GetParam());\n}\n\n// Test that if two listeners use the same cert and session ticket key, but\n// different client CA, that sessions cannot be resumed.\nTEST_P(SslSocketTest, ClientAuthCrossListenerSessionResumption) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  require_client_certificate: true\n)EOF\";\n\n  const std::string server2_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"\n  require_client_certificate: true\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context1;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), tls_context1);\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(tls_context1, factory_context_);\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context2;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server2_ctx_yaml), tls_context2);\n  auto server2_cfg = std::make_unique<ServerContextConfigImpl>(tls_context2, factory_context_);\n  ContextManagerImpl manager(time_system_);\n  Stats::TestUtil::TestStore server_stats_store;\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n  ServerSslSocketFactory server2_ssl_socket_factory(std::move(server2_cfg), manager,\n                                                    server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  auto socket2 = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  Network::MockTcpListenerCallbacks callbacks;\n  Network::ListenerPtr listener =\n      dispatcher_->createListener(socket, callbacks, runtime_, true, false);\n  Network::ListenerPtr listener2 =\n      dispatcher_->createListener(socket2, callbacks, runtime_, true, false);\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), tls_context);\n\n  auto client_cfg = std::make_unique<ClientContextConfigImpl>(tls_context, factory_context_);\n  Stats::TestUtil::TestStore client_stats_store;\n  ClientSslSocketFactory ssl_socket_factory(std::move(client_cfg), manager, client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher_->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  SSL_SESSION* ssl_session = nullptr;\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& accepted_socket) -> void {\n        Network::TransportSocketFactory& tsf =\n            accepted_socket->connectionInfoProvider().localAddress() ==\n                    socket->connectionInfoProvider().localAddress()\n                ? server_ssl_socket_factory\n                : server2_ssl_socket_factory;\n        server_connection = dispatcher_->createServerConnection(\n            std::move(accepted_socket), tsf.createTransportSocket(nullptr), stream_info_);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        const SslHandshakerImpl* ssl_socket =\n            dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n        ssl_session = SSL_get1_session(ssl_socket->ssl());\n        EXPECT_TRUE(SSL_SESSION_is_resumable(ssl_session));\n        server_connection->close(Network::ConnectionCloseType::NoFlush);\n        client_connection->close(Network::ConnectionCloseType::NoFlush);\n        dispatcher_->exit();\n      }));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(1UL, server_stats_store.counter(\"ssl.handshake\").value());\n  EXPECT_EQ(1UL, client_stats_store.counter(\"ssl.handshake\").value());\n\n  client_connection = dispatcher_->createClientConnection(\n      socket2->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  const SslHandshakerImpl* ssl_socket =\n      dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n  SSL_set_session(ssl_socket->ssl(), ssl_session);\n  SSL_SESSION_free(ssl_session);\n\n  client_connection->connect();\n\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& accepted_socket) -> void {\n        Network::TransportSocketFactory& tsf =\n            accepted_socket->connectionInfoProvider().localAddress() ==\n                    socket->connectionInfoProvider().localAddress()\n                ? server_ssl_socket_factory\n                : server2_ssl_socket_factory;\n        server_connection = dispatcher_->createServerConnection(\n            std::move(accepted_socket), tsf.createTransportSocket(nullptr), stream_info_);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(1UL, client_stats_store.counter(\"ssl.connection_error\").value());\n  EXPECT_EQ(0UL, server_stats_store.counter(\"ssl.session_reused\").value());\n  EXPECT_EQ(0UL, client_stats_store.counter(\"ssl.session_reused\").value());\n}\n\nvoid SslSocketTest::testClientSessionResumption(const std::string& server_ctx_yaml,\n                                                const std::string& client_ctx_yaml,\n                                                bool expect_reuse,\n                                                const Network::Address::IpVersion version) {\n  InSequence s;\n\n  ContextManagerImpl manager(time_system_);\n\n  Stats::TestUtil::TestStore server_stats_store;\n  Api::ApiPtr server_api = Api::createApiForTest(server_stats_store, time_system_);\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      server_factory_context;\n  ON_CALL(server_factory_context, api()).WillByDefault(ReturnRef(*server_api));\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_ctx_proto;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), server_ctx_proto);\n  auto server_cfg =\n      std::make_unique<ServerContextConfigImpl>(server_ctx_proto, server_factory_context);\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(version));\n  NiceMock<Network::MockTcpListenerCallbacks> callbacks;\n  Api::ApiPtr api = Api::createApiForTest(server_stats_store, time_system_);\n  Event::DispatcherPtr dispatcher(server_api->allocateDispatcher(\"test_thread\"));\n  Network::ListenerPtr listener =\n      dispatcher->createListener(socket, callbacks, runtime_, true, false);\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client_ctx_proto;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), client_ctx_proto);\n\n  Stats::TestUtil::TestStore client_stats_store;\n  Api::ApiPtr client_api = Api::createApiForTest(client_stats_store, time_system_);\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      client_factory_context;\n  ON_CALL(client_factory_context, api()).WillByDefault(ReturnRef(*client_api));\n\n  auto client_cfg =\n      std::make_unique<ClientContextConfigImpl>(client_ctx_proto, client_factory_context);\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager,\n                                                   client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      client_ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  size_t connect_count = 0;\n  auto connect_second_time = [&connect_count, &server_connection]() {\n    if (++connect_count == 2) {\n      server_connection->close(Network::ConnectionCloseType::NoFlush);\n    }\n  };\n\n  size_t close_count = 0;\n  auto close_second_time = [&close_count, &dispatcher]() {\n    if (++close_count == 2) {\n      dispatcher->exit();\n    }\n  };\n\n  // WillRepeatedly doesn't work with InSequence.\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  const bool expect_tls13 =\n      client_ctx_proto.common_tls_context().tls_params().tls_maximum_protocol_version() ==\n          envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3 &&\n      server_ctx_proto.common_tls_context().tls_params().tls_maximum_protocol_version() ==\n          envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3;\n\n  // The order of \"Connected\" events depends on the version of the TLS protocol (1.3 or older).\n  if (expect_tls13) {\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n  } else {\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n  }\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n\n  dispatcher->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(0UL, server_stats_store.counter(\"ssl.session_reused\").value());\n  EXPECT_EQ(0UL, client_stats_store.counter(\"ssl.session_reused\").value());\n\n  connect_count = 0;\n  close_count = 0;\n\n  client_connection = dispatcher->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      client_ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  // WillRepeatedly doesn't work with InSequence.\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  // The order of \"Connected\" events depends on the version of the TLS protocol (1.3 or older),\n  // and whether or not the session was successfully resumed.\n  if (expect_tls13 || expect_reuse) {\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n  } else {\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n  }\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n\n  dispatcher->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(expect_reuse ? 1UL : 0UL, server_stats_store.counter(\"ssl.session_reused\").value());\n  EXPECT_EQ(expect_reuse ? 1UL : 0UL, client_stats_store.counter(\"ssl.session_reused\").value());\n}\n\n// Test client session resumption using default settings (should be enabled).\nTEST_P(SslSocketTest, ClientSessionResumptionDefault) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n)EOF\";\n\n  testClientSessionResumption(server_ctx_yaml, client_ctx_yaml, true, GetParam());\n}\n\n// Make sure client session resumption is not happening with TLS 1.0-1.2 when it's disabled.\nTEST_P(SslSocketTest, ClientSessionResumptionDisabledTls12) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_0\n      tls_maximum_protocol_version: TLSv1_2\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n  max_session_keys: 0\n)EOF\";\n\n  testClientSessionResumption(server_ctx_yaml, client_ctx_yaml, false, GetParam());\n}\n\n// Test client session resumption with TLS 1.0-1.2.\nTEST_P(SslSocketTest, ClientSessionResumptionEnabledTls12) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_0\n      tls_maximum_protocol_version: TLSv1_2\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_0\n      tls_maximum_protocol_version: TLSv1_2\n  max_session_keys: 2\n)EOF\";\n\n  testClientSessionResumption(server_ctx_yaml, client_ctx_yaml, true, GetParam());\n}\n\n// Make sure client session resumption is not happening with TLS 1.3 when it's disabled.\nTEST_P(SslSocketTest, ClientSessionResumptionDisabledTls13) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_3\n      tls_maximum_protocol_version: TLSv1_3\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_3\n      tls_maximum_protocol_version: TLSv1_3\n  max_session_keys: 0\n)EOF\";\n\n  testClientSessionResumption(server_ctx_yaml, client_ctx_yaml, false, GetParam());\n}\n\n// Test client session resumption with TLS 1.3 (it's different than in older versions of TLS).\nTEST_P(SslSocketTest, ClientSessionResumptionEnabledTls13) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_3\n      tls_maximum_protocol_version: TLSv1_3\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_3\n      tls_maximum_protocol_version: TLSv1_3\n  max_session_keys: 2\n)EOF\";\n\n  testClientSessionResumption(server_ctx_yaml, client_ctx_yaml, true, GetParam());\n}\n\nTEST_P(SslSocketTest, SslError) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"\n      verify_certificate_hash: \"7B:0C:3F:0D:97:0E:FC:16:70:11:7A:0C:35:75:54:6B:17:AB:CF:20:D8:AA:A0:ED:87:08:0F:FB:60:4C:40:77\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), tls_context);\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(tls_context, factory_context_);\n  ContextManagerImpl manager(time_system_);\n  Stats::TestUtil::TestStore server_stats_store;\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  Network::MockTcpListenerCallbacks callbacks;\n  Network::ListenerPtr listener =\n      dispatcher_->createListener(socket, callbacks, runtime_, true, false);\n\n  Network::ClientConnectionPtr client_connection = dispatcher_->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      Network::Test::createRawBufferSocket(), nullptr);\n  client_connection->connect();\n  Buffer::OwnedImpl bad_data(\"bad_handshake_data\");\n  client_connection->write(bad_data, false);\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        client_connection->close(Network::ConnectionCloseType::NoFlush);\n        dispatcher_->exit();\n      }));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(1UL, server_stats_store.counter(\"ssl.connection_error\").value());\n}\n\nTEST_P(SslSocketTest, ProtocolVersions) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::TlsParameters* server_params =\n      tls_context.mutable_common_tls_context()->mutable_tls_params();\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsParameters* client_params =\n      client.mutable_common_tls_context()->mutable_tls_params();\n\n  // Note: There aren't any valid TLSv1.0 or TLSv1.1 cipher suites enabled by default,\n  // so enable them to avoid false positives.\n  client_params->add_cipher_suites(\"ECDHE-RSA-AES128-SHA\");\n  server_params->add_cipher_suites(\"ECDHE-RSA-AES128-SHA\");\n  updateFilterChain(tls_context, *filter_chain);\n\n  // Connection using defaults (client & server) succeeds, negotiating TLSv1.2.\n  TestUtilOptionsV2 tls_v1_2_test_options =\n      createProtocolTestOptions(listener, client, GetParam(), \"TLSv1.2\");\n  testUtilV2(tls_v1_2_test_options);\n\n  // Connection using defaults (client & server) succeeds, negotiating TLSv1.2,\n  // even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(tls_v1_2_test_options);\n  client.set_allow_renegotiation(false);\n\n  TestUtilOptionsV2 error_test_options(listener, client, false, GetParam());\n  error_test_options.setExpectedServerStats(\"ssl.connection_error\")\n      .setExpectedTransportFailureReasonContains(\"TLSV1_ALERT_PROTOCOL_VERSION\");\n\n  // Connection using TLSv1.0 (client) and defaults (server) fails.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  testUtilV2(error_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.1 (client) and defaults (server) fails.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_1);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_1);\n  testUtilV2(error_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.2 (client) and defaults (server) succeeds.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2);\n  testUtilV2(tls_v1_2_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.3 (client) and defaults (server) succeeds.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  TestUtilOptionsV2 tls_v1_3_test_options =\n      createProtocolTestOptions(listener, client, GetParam(), \"TLSv1.3\");\n  testUtilV2(tls_v1_3_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.0-1.3 (client) and defaults (server) succeeds.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  testUtilV2(tls_v1_3_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.0 (client) and TLSv1.0-1.3 (server) succeeds.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  updateFilterChain(tls_context, *filter_chain);\n  TestUtilOptionsV2 tls_v1_test_options =\n      createProtocolTestOptions(listener, client, GetParam(), \"TLSv1\");\n  testUtilV2(tls_v1_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.3 (client) and TLSv1.0-1.3 (server) succeeds.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(tls_v1_3_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  TestUtilOptionsV2 unsupported_protocol_test_options(listener, client, false, GetParam());\n  unsupported_protocol_test_options.setExpectedServerStats(\"ssl.connection_error\")\n      .setExpectedTransportFailureReasonContains(\"UNSUPPORTED_PROTOCOL\");\n\n  // Connection using defaults (client) and TLSv1.0 (server) fails.\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(unsupported_protocol_test_options);\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  // Connection using defaults (client) and TLSv1.1 (server) fails.\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_1);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_1);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(unsupported_protocol_test_options);\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  // Connection using defaults (client) and TLSv1.2 (server) succeeds.\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(tls_v1_2_test_options);\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  // Connection using defaults (client) and TLSv1.3 (server) fails.\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(error_test_options);\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  // Connection using defaults (client) and TLSv1.0-1.3 (server) succeeds.\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(tls_v1_2_test_options);\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.0-TLSv1.3 (client) and TLSv1.0 (server) succeeds.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(tls_v1_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.0-TLSv1.3 (client) and TLSv1.3 (server) succeeds.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(tls_v1_3_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n}\n\nTEST_P(SslSocketTest, ALPN) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CommonTlsContext* server_ctx =\n      tls_context.mutable_common_tls_context();\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::CommonTlsContext* client_ctx =\n      client.mutable_common_tls_context();\n\n  // Connection using defaults (client & server) succeeds, no ALPN is negotiated.\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options);\n\n  // Connection using defaults (client & server) succeeds, no ALPN is negotiated,\n  // even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n  client.set_allow_renegotiation(false);\n\n  // Client connects without ALPN to a server with \"test\" ALPN, no ALPN is negotiated.\n  server_ctx->add_alpn_protocols(\"test\");\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(test_options);\n  server_ctx->clear_alpn_protocols();\n\n  // Client connects with \"test\" ALPN to a server without ALPN, no ALPN is negotiated.\n  client_ctx->add_alpn_protocols(\"test\");\n  testUtilV2(test_options);\n\n  client_ctx->clear_alpn_protocols();\n\n  // Client connects with \"test\" ALPN to a server with \"test\" ALPN, \"test\" ALPN is negotiated.\n  client_ctx->add_alpn_protocols(\"test\");\n  server_ctx->add_alpn_protocols(\"test\");\n  updateFilterChain(tls_context, *filter_chain);\n  test_options.setExpectedALPNProtocol(\"test\");\n  testUtilV2(test_options);\n  test_options.setExpectedALPNProtocol(\"\");\n  client_ctx->clear_alpn_protocols();\n  server_ctx->clear_alpn_protocols();\n\n  // Client connects with \"test\" ALPN to a server with \"test\" ALPN, \"test\" ALPN is negotiated,\n  // even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  client_ctx->add_alpn_protocols(\"test\");\n  server_ctx->add_alpn_protocols(\"test\");\n  updateFilterChain(tls_context, *filter_chain);\n  test_options.setExpectedALPNProtocol(\"test\");\n  testUtilV2(test_options);\n  test_options.setExpectedALPNProtocol(\"\");\n  client.set_allow_renegotiation(false);\n  client_ctx->clear_alpn_protocols();\n  server_ctx->clear_alpn_protocols();\n\n  // Client connects with \"test\" ALPN to a server with \"test2\" ALPN, no ALPN is negotiated.\n  client_ctx->add_alpn_protocols(\"test\");\n  server_ctx->add_alpn_protocols(\"test2\");\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(test_options);\n  client_ctx->clear_alpn_protocols();\n  server_ctx->clear_alpn_protocols();\n\n  // Client attempts to configure ALPN that is too large.\n  client_ctx->add_alpn_protocols(std::string(100000, 'a'));\n  EXPECT_THROW_WITH_MESSAGE(testUtilV2(test_options), EnvoyException,\n                            \"Invalid ALPN protocol string\");\n}\n\nTEST_P(SslSocketTest, CipherSuites) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsParameters* client_params =\n      client.mutable_common_tls_context()->mutable_tls_params();\n\n  // Connection using defaults (client & server) succeeds.\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options);\n\n  // Connection using defaults (client & server) succeeds, even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n  client.set_allow_renegotiation(false);\n\n  // Client connects with one of the supported cipher suites, connection succeeds.\n  std::string common_cipher_suite = \"ECDHE-RSA-CHACHA20-POLY1305\";\n  client_params->add_cipher_suites(common_cipher_suite);\n  envoy::extensions::transport_sockets::tls::v3::TlsParameters* server_params =\n      tls_context.mutable_common_tls_context()->mutable_tls_params();\n  server_params->add_cipher_suites(common_cipher_suite);\n  server_params->add_cipher_suites(\"ECDHE-RSA-AES128-GCM-SHA256\");\n  updateFilterChain(tls_context, *filter_chain);\n  TestUtilOptionsV2 cipher_test_options(listener, client, true, GetParam());\n  cipher_test_options.setExpectedCiphersuite(common_cipher_suite);\n  std::string stats = \"ssl.ciphers.\" + common_cipher_suite;\n  cipher_test_options.setExpectedServerStats(stats).setExpectedClientStats(stats);\n  testUtilV2(cipher_test_options);\n  client_params->clear_cipher_suites();\n  server_params->clear_cipher_suites();\n\n  // Client connects with unsupported cipher suite, connection fails.\n  client_params->add_cipher_suites(\"ECDHE-RSA-AES128-GCM-SHA256\");\n  server_params->add_cipher_suites(\"ECDHE-RSA-CHACHA20-POLY1305\");\n  updateFilterChain(tls_context, *filter_chain);\n  TestUtilOptionsV2 error_test_options(listener, client, false, GetParam());\n  error_test_options.setExpectedServerStats(\"ssl.connection_error\");\n  testUtilV2(error_test_options);\n  client_params->clear_cipher_suites();\n  server_params->clear_cipher_suites();\n\n  // Client connects to a server offering only deprecated cipher suites, connection fails.\n  server_params->add_cipher_suites(\"ECDHE-RSA-AES128-SHA\");\n  updateFilterChain(tls_context, *filter_chain);\n  error_test_options.setExpectedServerStats(\"ssl.connection_error\");\n  testUtilV2(error_test_options);\n  server_params->clear_cipher_suites();\n  updateFilterChain(tls_context, *filter_chain);\n  // Verify that ECDHE-RSA-CHACHA20-POLY1305 is not offered by default in FIPS builds.\n  client_params->add_cipher_suites(common_cipher_suite);\n#ifdef BORINGSSL_FIPS\n  testUtilV2(error_test_options);\n#else\n  testUtilV2(cipher_test_options);\n#endif\n  client_params->clear_cipher_suites();\n}\n\nTEST_P(SslSocketTest, EcdhCurves) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::TlsParameters* server_params =\n      tls_context.mutable_common_tls_context()->mutable_tls_params();\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsParameters* client_params =\n      client.mutable_common_tls_context()->mutable_tls_params();\n\n  // Connection using defaults (client & server) succeeds.\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options);\n\n  // Connection using defaults (client & server) succeeds, even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n  client.set_allow_renegotiation(false);\n\n  // Client connects with one of the supported ECDH curves, connection succeeds.\n  client_params->add_ecdh_curves(\"X25519\");\n  server_params->add_ecdh_curves(\"X25519\");\n  server_params->add_ecdh_curves(\"P-256\");\n  server_params->add_cipher_suites(\"ECDHE-RSA-AES128-GCM-SHA256\");\n  updateFilterChain(tls_context, *filter_chain);\n  TestUtilOptionsV2 ecdh_curves_test_options(listener, client, true, GetParam());\n  std::string stats = \"ssl.curves.X25519\";\n  ecdh_curves_test_options.setExpectedServerStats(stats).setExpectedClientStats(stats);\n  testUtilV2(ecdh_curves_test_options);\n  client_params->clear_ecdh_curves();\n  server_params->clear_ecdh_curves();\n  server_params->clear_cipher_suites();\n\n  // Client connects with unsupported ECDH curve, connection fails.\n  client_params->add_ecdh_curves(\"X25519\");\n  server_params->add_ecdh_curves(\"P-256\");\n  server_params->add_cipher_suites(\"ECDHE-RSA-AES128-GCM-SHA256\");\n  updateFilterChain(tls_context, *filter_chain);\n  TestUtilOptionsV2 error_test_options(listener, client, false, GetParam());\n  error_test_options.setExpectedServerStats(\"ssl.connection_error\");\n  testUtilV2(error_test_options);\n\n  client_params->clear_ecdh_curves();\n  server_params->clear_ecdh_curves();\n  server_params->clear_cipher_suites();\n\n  // Verify that X25519 is not offered by default in FIPS builds.\n  client_params->add_ecdh_curves(\"X25519\");\n  server_params->add_cipher_suites(\"ECDHE-RSA-AES128-GCM-SHA256\");\n  updateFilterChain(tls_context, *filter_chain);\n#ifdef BORINGSSL_FIPS\n  testUtilV2(error_test_options);\n#else\n  testUtilV2(ecdh_curves_test_options);\n#endif\n  client_params->clear_ecdh_curves();\n  server_params->clear_cipher_suites();\n}\n\nTEST_P(SslSocketTest, SignatureAlgorithms) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  // Server ECDSA certificate.\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem\"));\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  // Client RSA certificate.\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  // Connection using defaults (client & server) succeeds.\n  TestUtilOptionsV2 algorithm_test_options(listener, client, true, GetParam());\n  algorithm_test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n      .setExpectedServerStats(\"ssl.sigalgs.rsa_pss_rsae_sha256\")\n      .setExpectedClientStats(\"ssl.sigalgs.ecdsa_secp256r1_sha256\");\n  testUtilV2(algorithm_test_options);\n\n  // Connection using defaults (client & server) succeeds, even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(algorithm_test_options);\n  client.set_allow_renegotiation(false);\n}\n\nTEST_P(SslSocketTest, RevokedCertificate) {\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n\n  // This should fail, since the certificate has been revoked.\n  const std::string revoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n)EOF\";\n\n  TestUtilOptions revoked_test_options(revoked_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(revoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_CERT_REVOKED));\n\n  // This should succeed, since the cert isn't revoked.\n  const std::string successful_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_key.pem\"\n)EOF\";\n\n  TestUtilOptions successful_test_options(successful_client_ctx_yaml, server_ctx_yaml, true,\n                                          GetParam());\n  testUtil(successful_test_options.setExpectedSerialNumber(TEST_SAN_DNS2_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, RevokedCertificateCRLInTrustedCA) {\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert_with_crl.pem\"\n)EOF\";\n\n  // This should fail, since the certificate has been revoked.\n  const std::string revoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n)EOF\";\n\n  TestUtilOptions revoked_test_options(revoked_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(revoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_CERT_REVOKED));\n\n  // This should succeed, since the cert isn't revoked.\n  const std::string successful_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_key.pem\"\n)EOF\";\n  TestUtilOptions successful_test_options(successful_client_ctx_yaml, server_ctx_yaml, true,\n                                          GetParam());\n  testUtil(successful_test_options.setExpectedSerialNumber(TEST_SAN_DNS2_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, RevokedIntermediateCertificate) {\n\n  // This should succeed, since the crl chain is complete.\n  //\n  // Trust chain contains:\n  //  - Root authority certificate (i.e., ca_cert.pem)\n  //  - Intermediate authority certificate (i.e., intermediate_ca_cert.pem)\n  //\n  // Certificate revocation list contains:\n  //  - Root authority certificate revocation list (i.e., ca_cert.crl)\n  //  - Intermediate authority certificate revocation list (i.e., intermediate_ca_cert.crl)\n  const std::string complete_server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert_chain.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert_chain.crl\"\n)EOF\";\n\n  // This should fail, since the crl chain is incomplete.\n  //\n  // Trust chain contains:\n  //  - Root authority certificate (i.e., ca_cert.pem)\n  //  - Intermediate authority certificate (i.e., intermediate_ca_cert.pem)\n  //\n  // Certificate revocation list contains:\n  //  - Root authority certificate revocation list (i.e., ca_cert.crl)\n  //\n  // Certificate revocation list omits:\n  //  - Root authority certificate revocation list (i.e., ca_cert.crl)\n  const std::string incomplete_server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert_chain.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert.crl\"\n)EOF\";\n\n  // This should fail, since the certificate has been revoked.\n  const std::string revoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_key.pem\"\n)EOF\";\n\n  // This should succeed, since the certificate has not been revoked.\n  const std::string unrevoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns4_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns4_key.pem\"\n)EOF\";\n\n  // Ensure that incomplete crl chains fail with revoked certificates.\n  TestUtilOptions incomplete_revoked_test_options(revoked_client_ctx_yaml,\n                                                  incomplete_server_ctx_yaml, false, GetParam());\n  testUtil(incomplete_revoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_CERT_REVOKED));\n\n  // Ensure that incomplete crl chains fail with unrevoked certificates.\n  TestUtilOptions incomplete_unrevoked_test_options(unrevoked_client_ctx_yaml,\n                                                    incomplete_server_ctx_yaml, false, GetParam());\n  testUtil(incomplete_unrevoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_UNABLE_TO_GET_CRL));\n\n  // Ensure that complete crl chains fail with revoked certificates.\n  TestUtilOptions complete_revoked_test_options(revoked_client_ctx_yaml, complete_server_ctx_yaml,\n                                                false, GetParam());\n  testUtil(complete_revoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_CERT_REVOKED));\n\n  // Ensure that complete crl chains succeed with unrevoked certificates.\n  TestUtilOptions complete_unrevoked_test_options(unrevoked_client_ctx_yaml,\n                                                  complete_server_ctx_yaml, true, GetParam());\n  testUtil(complete_unrevoked_test_options.setExpectedSerialNumber(TEST_SAN_DNS4_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, RevokedIntermediateCertificateCRLInTrustedCA) {\n\n  // This should succeed, since the crl chain is complete.\n  //\n  // Trust chain contains:\n  //  - Root authority certificate (i.e., ca_cert.pem)\n  //  - Root authority certificate revocation list (i.e., ca_cert.crl)\n  //  - Intermediate authority certificate (i.e., intermediate_ca_cert.pem)\n  //  - Intermediate authority certificate revocation list (i.e., intermediate_ca_cert.crl)\n  const std::string complete_server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert_chain_with_crl_chain.pem\"\n)EOF\";\n\n  // This should fail, since the crl chain is incomplete.\n  //\n  // Trust chain contains:\n  //  - Root authority certificate (i.e., ca_cert.pem)\n  //  - Intermediate authority certificate (i.e., intermediate_ca_cert.pem)\n  //  - Intermediate authority certificate revocation list (i.e., intermediate_ca_cert.crl)\n  //\n  // Trust chain omits:\n  //  - Root authority certificate revocation list (i.e., ca_cert.crl)\n  const std::string incomplete_server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert_chain_with_crl.pem\"\n)EOF\";\n\n  // This should fail, since the certificate has been revoked.\n  const std::string revoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_key.pem\"\n)EOF\";\n\n  // This should succeed, since the certificate has not been revoked.\n  const std::string unrevoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns4_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns4_key.pem\"\n)EOF\";\n\n  // Ensure that incomplete crl chains fail with revoked certificates.\n  TestUtilOptions incomplete_revoked_test_options(revoked_client_ctx_yaml,\n                                                  incomplete_server_ctx_yaml, false, GetParam());\n  testUtil(incomplete_revoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_CERT_REVOKED));\n\n  // Ensure that incomplete crl chains fail with unrevoked certificates.\n  TestUtilOptions incomplete_unrevoked_test_options(unrevoked_client_ctx_yaml,\n                                                    incomplete_server_ctx_yaml, false, GetParam());\n  testUtil(incomplete_unrevoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_UNABLE_TO_GET_CRL));\n\n  // Ensure that complete crl chains fail with revoked certificates.\n  TestUtilOptions complete_revoked_test_options(revoked_client_ctx_yaml, complete_server_ctx_yaml,\n                                                false, GetParam());\n  testUtil(complete_revoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_CERT_REVOKED));\n\n  // Ensure that complete crl chains succeed with unrevoked certificates.\n  TestUtilOptions complete_unrevoked_test_options(unrevoked_client_ctx_yaml,\n                                                  complete_server_ctx_yaml, true, GetParam());\n  testUtil(complete_unrevoked_test_options.setExpectedSerialNumber(TEST_SAN_DNS4_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, NotRevokedLeafCertificateOnlyLeafCRLValidation) {\n  // The test checks that revoked certificate will makes the validation success even if we set\n  // only_verify_leaf_cert_crl to true.\n  //\n  // Trust chain contains:\n  //  - Root authority certificate (i.e., ca_cert.pem)\n  //  - Intermediate authority certificate (i.e., intermediate_ca_cert.pem)\n  //  - Intermediate authority certificate revocation list (i.e., intermediate_ca_cert.crl)\n  //\n  // Trust chain omits (But this test will succeed):\n  //  - Root authority certificate revocation list (i.e., ca_cert.crl)\n  const std::string incomplete_server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert_chain_with_crl.pem\"\n      only_verify_leaf_cert_crl: true\n)EOF\";\n\n  // This should succeed, since the certificate has not been revoked.\n  const std::string unrevoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns4_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns4_key.pem\"\n)EOF\";\n\n  TestUtilOptions complete_unrevoked_test_options(unrevoked_client_ctx_yaml,\n                                                  incomplete_server_ctx_yaml, true, GetParam());\n  testUtil(complete_unrevoked_test_options.setExpectedSerialNumber(TEST_SAN_DNS4_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, RevokedLeafCertificateOnlyLeafCRLValidation) {\n  // The test checks that revoked certificate will makes the validation fails even if we set\n  // only_verify_leaf_cert_crl to true.\n  //\n  // Trust chain contains:\n  //  - Root authority certificate (i.e., ca_cert.pem)\n  //  - Intermediate authority certificate (i.e., intermediate_ca_cert.pem)\n  //  - Intermediate authority certificate revocation list (i.e., intermediate_ca_cert.crl)\n  //\n  // Trust chain omits (But this test will succeed):\n  //  - Root authority certificate revocation list (i.e., ca_cert.crl)\n  const std::string incomplete_server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert_chain_with_crl.pem\"\n      only_verify_leaf_cert_crl: true\n)EOF\";\n\n  // This should fail, since the certificate has been revoked.\n  const std::string revoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_key.pem\"\n)EOF\";\n\n  TestUtilOptions complete_revoked_test_options(revoked_client_ctx_yaml, incomplete_server_ctx_yaml,\n                                                false, GetParam());\n  testUtil(complete_revoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_CERT_REVOKED));\n}\n\nTEST_P(SslSocketTest, GetRequestedServerName) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  client.set_sni(\"lyft.com\");\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedRequestedServerName(\"lyft.com\"));\n}\n\nTEST_P(SslSocketTest, OverrideRequestedServerName) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  client.set_sni(\"lyft.com\");\n\n  Network::TransportSocketOptionsConstSharedPtr transport_socket_options(\n      new Network::TransportSocketOptionsImpl(\"example.com\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedRequestedServerName(\"example.com\")\n                 .setTransportSocketOptions(transport_socket_options));\n}\n\nTEST_P(SslSocketTest, OverrideRequestedServerNameWithoutSniInUpstreamTlsContext) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  Network::TransportSocketOptionsConstSharedPtr transport_socket_options(\n      new Network::TransportSocketOptionsImpl(\"example.com\"));\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedRequestedServerName(\"example.com\")\n                 .setTransportSocketOptions(transport_socket_options));\n}\n\nTEST_P(SslSocketTest, OverrideApplicationProtocols) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n\n  // Client connects without ALPN to a server with \"test\" ALPN, no ALPN is negotiated.\n  envoy::extensions::transport_sockets::tls::v3::CommonTlsContext* server_ctx =\n      tls_context.mutable_common_tls_context();\n  server_ctx->add_alpn_protocols(\"test\");\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(test_options);\n  server_ctx->clear_alpn_protocols();\n  // Override client side ALPN, \"test\" ALPN is used.\n  server_ctx->add_alpn_protocols(\"test\");\n  updateFilterChain(tls_context, *filter_chain);\n  auto transport_socket_options = std::make_shared<Network::TransportSocketOptionsImpl>(\n      \"\", std::vector<std::string>{}, std::vector<std::string>{\"foo\", \"test\", \"bar\"});\n\n  testUtilV2(test_options.setExpectedALPNProtocol(\"test\").setTransportSocketOptions(\n      transport_socket_options));\n\n  // Set fallback ALPN on the client side ALPN, \"test\" ALPN is used since no ALPN is specified\n  // in the config.\n  server_ctx->add_alpn_protocols(\"test\");\n  transport_socket_options = std::make_shared<Network::TransportSocketOptionsImpl>(\n      \"\", std::vector<std::string>{}, std::vector<std::string>{}, std::vector<std::string>{\"test\"});\n  testUtilV2(test_options.setExpectedALPNProtocol(\"test\").setTransportSocketOptions(\n      transport_socket_options));\n\n  // With multiple fallbacks specified, a single match will match.\n  transport_socket_options = std::make_shared<Network::TransportSocketOptionsImpl>(\n      \"\", std::vector<std::string>{}, std::vector<std::string>{},\n      std::vector<std::string>{\"foo\", \"test\"});\n  testUtilV2(test_options.setExpectedALPNProtocol(\"test\").setTransportSocketOptions(\n      transport_socket_options));\n\n  // With multiple matching fallbacks specified, a single match will match.\n  server_ctx->add_alpn_protocols(\"foo\");\n  transport_socket_options = std::make_shared<Network::TransportSocketOptionsImpl>(\n      \"\", std::vector<std::string>{}, std::vector<std::string>{},\n      std::vector<std::string>{\"foo\", \"test\"});\n  testUtilV2(test_options.setExpectedALPNProtocol(\"test\").setTransportSocketOptions(\n      transport_socket_options));\n\n  // Update the client TLS config to specify ALPN. The fallback value should no longer be used.\n  // Note that the server prefers \"test\" over \"bar\", but since the client only configures \"bar\",\n  // the resulting ALPN will be \"bar\" even though \"test\" is included in the fallback.\n  server_ctx->add_alpn_protocols(\"bar\");\n  updateFilterChain(tls_context, *filter_chain);\n  client.mutable_common_tls_context()->add_alpn_protocols(\"bar\");\n  testUtilV2(test_options.setExpectedALPNProtocol(\"bar\").setTransportSocketOptions(\n      transport_socket_options));\n}\n\n// Validate that if downstream secrets are not yet downloaded from SDS server, Envoy creates\n// NotReadySslSocket object to handle downstream connection.\nTEST_P(SslSocketTest, DownstreamNotReadySslSocket) {\n  Stats::TestUtil::TestStore stats_store;\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext> factory_context;\n  NiceMock<Init::MockManager> init_manager;\n  NiceMock<Event::MockDispatcher> dispatcher;\n  EXPECT_CALL(factory_context, mainThreadDispatcher()).WillRepeatedly(ReturnRef(dispatcher));\n  EXPECT_CALL(factory_context, localInfo()).WillOnce(ReturnRef(local_info));\n  EXPECT_CALL(factory_context, stats()).WillOnce(ReturnRef(stats_store));\n  EXPECT_CALL(factory_context, initManager()).WillRepeatedly(ReturnRef(init_manager));\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  auto sds_secret_configs =\n      tls_context.mutable_common_tls_context()->mutable_tls_certificate_sds_secret_configs()->Add();\n  sds_secret_configs->set_name(\"abc.com\");\n  sds_secret_configs->mutable_sds_config();\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(tls_context, factory_context);\n  EXPECT_TRUE(server_cfg->tlsCertificates().empty());\n  EXPECT_FALSE(server_cfg->isReady());\n\n  ContextManagerImpl manager(time_system_);\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager, stats_store,\n                                                   std::vector<std::string>{});\n  auto transport_socket = server_ssl_socket_factory.createTransportSocket(nullptr);\n  EXPECT_FALSE(transport_socket->startSecureTransport());                                  // Noop\n  transport_socket->configureInitialCongestionWindow(200, std::chrono::microseconds(223)); // Noop\n  EXPECT_EQ(EMPTY_STRING, transport_socket->protocol());\n  EXPECT_EQ(nullptr, transport_socket->ssl());\n  EXPECT_EQ(true, transport_socket->canFlushClose());\n  Buffer::OwnedImpl buffer;\n  Network::IoResult result = transport_socket->doRead(buffer);\n  EXPECT_EQ(Network::PostIoAction::Close, result.action_);\n  result = transport_socket->doWrite(buffer, true);\n  EXPECT_EQ(Network::PostIoAction::Close, result.action_);\n  EXPECT_EQ(\"TLS error: Secret is not supplied by SDS\", transport_socket->failureReason());\n}\n\n// Validate that if upstream secrets are not yet downloaded from SDS server, Envoy creates\n// NotReadySslSocket object to handle upstream connection.\nTEST_P(SslSocketTest, UpstreamNotReadySslSocket) {\n  Stats::TestUtil::TestStore stats_store;\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext> factory_context;\n  NiceMock<Init::MockManager> init_manager;\n  NiceMock<Event::MockDispatcher> dispatcher;\n  EXPECT_CALL(factory_context, localInfo()).WillOnce(ReturnRef(local_info));\n  EXPECT_CALL(factory_context, stats()).WillOnce(ReturnRef(stats_store));\n  EXPECT_CALL(factory_context, initManager()).WillRepeatedly(ReturnRef(init_manager));\n  EXPECT_CALL(factory_context, mainThreadDispatcher()).WillRepeatedly(ReturnRef(dispatcher));\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n  auto sds_secret_configs =\n      tls_context.mutable_common_tls_context()->mutable_tls_certificate_sds_secret_configs()->Add();\n  sds_secret_configs->set_name(\"abc.com\");\n  sds_secret_configs->mutable_sds_config();\n  auto client_cfg = std::make_unique<ClientContextConfigImpl>(tls_context, factory_context);\n  EXPECT_TRUE(client_cfg->tlsCertificates().empty());\n  EXPECT_FALSE(client_cfg->isReady());\n\n  ContextManagerImpl manager(time_system_);\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager, stats_store);\n  auto transport_socket = client_ssl_socket_factory.createTransportSocket(nullptr);\n  EXPECT_EQ(EMPTY_STRING, transport_socket->protocol());\n  EXPECT_EQ(nullptr, transport_socket->ssl());\n  EXPECT_EQ(true, transport_socket->canFlushClose());\n  Buffer::OwnedImpl buffer;\n  Network::IoResult result = transport_socket->doRead(buffer);\n  EXPECT_EQ(Network::PostIoAction::Close, result.action_);\n  result = transport_socket->doWrite(buffer, true);\n  EXPECT_EQ(Network::PostIoAction::Close, result.action_);\n  EXPECT_EQ(\"TLS error: Secret is not supplied by SDS\", transport_socket->failureReason());\n}\n\nTEST_P(SslSocketTest, TestTransportSocketCallback) {\n  // Make MockTransportSocketCallbacks.\n  Network::MockIoHandle io_handle;\n  NiceMock<Network::MockTransportSocketCallbacks> callbacks;\n  ON_CALL(callbacks, ioHandle()).WillByDefault(ReturnRef(io_handle));\n\n  // Make SslSocket.\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext> factory_context;\n  Stats::TestUtil::TestStore stats_store;\n  ON_CALL(factory_context, stats()).WillByDefault(ReturnRef(stats_store));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  ON_CALL(factory_context, localInfo()).WillByDefault(ReturnRef(local_info));\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n  auto client_cfg = std::make_unique<ClientContextConfigImpl>(tls_context, factory_context);\n\n  ContextManagerImpl manager(time_system_);\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager, stats_store);\n\n  Network::TransportSocketPtr transport_socket =\n      client_ssl_socket_factory.createTransportSocket(nullptr);\n\n  SslSocket* ssl_socket = dynamic_cast<SslSocket*>(transport_socket.get());\n\n  // If no transport socket callbacks have been set, this method should return nullptr.\n  EXPECT_EQ(ssl_socket->transportSocketCallbacks(), nullptr);\n\n  // Otherwise, it should return a pointer to the set callbacks object.\n  ssl_socket->setTransportSocketCallbacks(callbacks);\n  EXPECT_EQ(ssl_socket->transportSocketCallbacks(), &callbacks);\n}\n\nclass SslReadBufferLimitTest : public SslSocketTest {\nprotected:\n  void initialize() {\n    TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml_),\n                              downstream_tls_context_);\n    auto server_cfg =\n        std::make_unique<ServerContextConfigImpl>(downstream_tls_context_, factory_context_);\n    manager_ = std::make_unique<ContextManagerImpl>(time_system_);\n    server_ssl_socket_factory_ = std::make_unique<ServerSslSocketFactory>(\n        std::move(server_cfg), *manager_, server_stats_store_, std::vector<std::string>{});\n\n    socket_ = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n        Network::Test::getCanonicalLoopbackAddress(GetParam()));\n    listener_ = dispatcher_->createListener(socket_, listener_callbacks_, runtime_, true, false);\n\n    TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml_), upstream_tls_context_);\n    auto client_cfg =\n        std::make_unique<ClientContextConfigImpl>(upstream_tls_context_, factory_context_);\n\n    client_ssl_socket_factory_ = std::make_unique<ClientSslSocketFactory>(\n        std::move(client_cfg), *manager_, client_stats_store_);\n    auto transport_socket = client_ssl_socket_factory_->createTransportSocket(nullptr);\n    client_transport_socket_ = transport_socket.get();\n    client_connection_ =\n        dispatcher_->createClientConnection(socket_->connectionInfoProvider().localAddress(),\n                                            source_address_, std::move(transport_socket), nullptr);\n    client_connection_->addConnectionCallbacks(client_callbacks_);\n    client_connection_->connect();\n    read_filter_ = std::make_shared<Network::MockReadFilter>();\n  }\n\n  void readBufferLimitTest(uint32_t read_buffer_limit, uint32_t expected_chunk_size,\n                           uint32_t write_size, uint32_t num_writes, bool reserve_write_space) {\n    initialize();\n\n    EXPECT_CALL(listener_callbacks_, onAccept_(_))\n        .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n          server_connection_ = dispatcher_->createServerConnection(\n              std::move(socket), server_ssl_socket_factory_->createTransportSocket(nullptr),\n              stream_info_);\n          server_connection_->setBufferLimits(read_buffer_limit);\n          server_connection_->addConnectionCallbacks(server_callbacks_);\n          server_connection_->addReadFilter(read_filter_);\n          EXPECT_EQ(\"\", server_connection_->nextProtocol());\n          EXPECT_EQ(read_buffer_limit, server_connection_->bufferLimit());\n        }));\n\n    EXPECT_CALL(client_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n    uint32_t filter_seen = 0;\n\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _))\n        .WillRepeatedly(Invoke([&](Buffer::Instance& data, bool) -> Network::FilterStatus {\n          EXPECT_GE(expected_chunk_size, data.length());\n          filter_seen += data.length();\n          data.drain(data.length());\n          if (filter_seen == (write_size * num_writes)) {\n            server_connection_->close(Network::ConnectionCloseType::FlushWrite);\n          }\n          return Network::FilterStatus::StopIteration;\n        }));\n\n    EXPECT_CALL(client_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n          EXPECT_EQ((write_size * num_writes), filter_seen);\n          dispatcher_->exit();\n        }));\n\n    for (uint32_t i = 0; i < num_writes; i++) {\n      Buffer::OwnedImpl data(std::string(write_size, 'a'));\n\n      if (reserve_write_space) {\n        data.appendSliceForTest(absl::string_view());\n        ASSERT_EQ(0, data.describeSlicesForTest().back().data);\n      }\n\n      client_connection_->write(data, false);\n    }\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n    EXPECT_EQ(0UL, server_stats_store_.counter(\"ssl.connection_error\").value());\n    EXPECT_EQ(0UL, client_stats_store_.counter(\"ssl.connection_error\").value());\n  }\n\n  void singleWriteTest(uint32_t read_buffer_limit, uint32_t bytes_to_write) {\n    MockWatermarkBuffer* client_write_buffer = nullptr;\n    MockBufferFactory* factory = new StrictMock<MockBufferFactory>;\n    dispatcher_ = api_->allocateDispatcher(\"test_thread\", Buffer::WatermarkFactoryPtr{factory});\n\n    // By default, expect 4 buffers to be created - the client and server read and write buffers.\n    EXPECT_CALL(*factory, createBuffer_(_, _, _))\n        .Times(4)\n        .WillOnce(Invoke([&](std::function<void()> below_low, std::function<void()> above_high,\n                             std::function<void()> above_overflow) -> Buffer::Instance* {\n          client_write_buffer = new MockWatermarkBuffer(below_low, above_high, above_overflow);\n          return client_write_buffer;\n        }))\n        .WillRepeatedly(Invoke([](std::function<void()> below_low, std::function<void()> above_high,\n                                  std::function<void()> above_overflow) -> Buffer::Instance* {\n          return new Buffer::WatermarkBuffer(below_low, above_high, above_overflow);\n        }));\n\n    initialize();\n\n    EXPECT_CALL(client_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    EXPECT_CALL(listener_callbacks_, onAccept_(_))\n        .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n          server_connection_ = dispatcher_->createServerConnection(\n              std::move(socket), server_ssl_socket_factory_->createTransportSocket(nullptr),\n              stream_info_);\n          server_connection_->setBufferLimits(read_buffer_limit);\n          server_connection_->addConnectionCallbacks(server_callbacks_);\n          server_connection_->addReadFilter(read_filter_);\n          EXPECT_EQ(\"\", server_connection_->nextProtocol());\n          EXPECT_EQ(read_buffer_limit, server_connection_->bufferLimit());\n        }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _)).Times(testing::AnyNumber());\n\n    std::string data_to_write(bytes_to_write, 'a');\n    Buffer::OwnedImpl buffer_to_write(data_to_write);\n    std::string data_written;\n    EXPECT_CALL(*client_write_buffer, move(_))\n        .WillRepeatedly(DoAll(AddBufferToStringWithoutDraining(&data_written),\n                              Invoke(client_write_buffer, &MockWatermarkBuffer::baseMove)));\n    EXPECT_CALL(*client_write_buffer, drain(_)).Times(2).WillOnce(Invoke([&](uint64_t n) -> void {\n      client_write_buffer->baseDrain(n);\n      dispatcher_->exit();\n    }));\n    client_connection_->write(buffer_to_write, false);\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n    EXPECT_EQ(data_to_write, data_written);\n\n    disconnect();\n  }\n\n  void disconnect() {\n    EXPECT_CALL(client_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));\n    EXPECT_CALL(server_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    client_connection_->close(Network::ConnectionCloseType::NoFlush);\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  Stats::TestUtil::TestStore server_stats_store_;\n  Stats::TestUtil::TestStore client_stats_store_;\n  std::shared_ptr<Network::Test::TcpListenSocketImmediateListen> socket_;\n  Network::MockTcpListenerCallbacks listener_callbacks_;\n  const std::string server_ctx_yaml_ = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  const std::string client_ctx_yaml_ = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  NiceMock<Runtime::MockLoader> runtime_;\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext downstream_tls_context_;\n  std::unique_ptr<ContextManagerImpl> manager_;\n  Network::TransportSocketFactoryPtr server_ssl_socket_factory_;\n  Network::ListenerPtr listener_;\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext upstream_tls_context_;\n  Envoy::Ssl::ClientContextSharedPtr client_ctx_;\n  Network::TransportSocketFactoryPtr client_ssl_socket_factory_;\n  Network::ClientConnectionPtr client_connection_;\n  Network::TransportSocket* client_transport_socket_{};\n  Network::ConnectionPtr server_connection_;\n  NiceMock<Network::MockConnectionCallbacks> server_callbacks_;\n  std::shared_ptr<Network::MockReadFilter> read_filter_;\n  StrictMock<Network::MockConnectionCallbacks> client_callbacks_;\n  Network::Address::InstanceConstSharedPtr source_address_;\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, SslReadBufferLimitTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(SslReadBufferLimitTest, NoLimit) {\n  readBufferLimitTest(0, 256 * 1024, 256 * 1024, 1, false);\n}\n\nTEST_P(SslReadBufferLimitTest, NoLimitReserveSpace) { readBufferLimitTest(0, 512, 512, 1, true); }\n\nTEST_P(SslReadBufferLimitTest, NoLimitSmallWrites) {\n  readBufferLimitTest(0, 256 * 1024, 1, 256 * 1024, false);\n}\n\nTEST_P(SslReadBufferLimitTest, SomeLimit) {\n  readBufferLimitTest(32 * 1024, 32 * 1024, 256 * 1024, 1, false);\n}\n\nTEST_P(SslReadBufferLimitTest, WritesSmallerThanBufferLimit) { singleWriteTest(5 * 1024, 1024); }\n\nTEST_P(SslReadBufferLimitTest, WritesLargerThanBufferLimit) { singleWriteTest(1024, 5 * 1024); }\n\nTEST_P(SslReadBufferLimitTest, TestBind) {\n  std::string address_string = TestUtility::getIpv4Loopback();\n  if (GetParam() == Network::Address::IpVersion::v4) {\n    source_address_ = Network::Address::InstanceConstSharedPtr{\n        new Network::Address::Ipv4Instance(address_string, 0, nullptr)};\n  } else {\n    address_string = \"::1\";\n    source_address_ = Network::Address::InstanceConstSharedPtr{\n        new Network::Address::Ipv6Instance(address_string, 0, nullptr)};\n  }\n\n  initialize();\n\n  EXPECT_CALL(listener_callbacks_, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection_ = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory_->createTransportSocket(nullptr),\n            stream_info_);\n        server_connection_->addConnectionCallbacks(server_callbacks_);\n        server_connection_->addReadFilter(read_filter_);\n        EXPECT_EQ(\"\", server_connection_->nextProtocol());\n      }));\n\n  EXPECT_CALL(client_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(address_string,\n            server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString());\n\n  disconnect();\n}\n\n// Regression test for https://github.com/envoyproxy/envoy/issues/6617\nTEST_P(SslReadBufferLimitTest, SmallReadsIntoSameSlice) {\n  // write_size * num_writes must be large enough to cause buffer reserving fragmentation,\n  // but smaller than one reservation so the expected slice to be 1.\n  const uint32_t write_size = 1;\n  const uint32_t num_writes = 12 * 1024;\n  const uint32_t read_buffer_limit = write_size * num_writes;\n  const uint32_t expected_chunk_size = write_size * num_writes;\n\n  initialize();\n\n  EXPECT_CALL(listener_callbacks_, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection_ = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory_->createTransportSocket(nullptr),\n            stream_info_);\n        server_connection_->setBufferLimits(read_buffer_limit);\n        server_connection_->addConnectionCallbacks(server_callbacks_);\n        server_connection_->addReadFilter(read_filter_);\n        EXPECT_EQ(\"\", server_connection_->nextProtocol());\n        EXPECT_EQ(read_buffer_limit, server_connection_->bufferLimit());\n      }));\n\n  EXPECT_CALL(client_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n  uint32_t filter_seen = 0;\n\n  EXPECT_CALL(*read_filter_, onNewConnection());\n  EXPECT_CALL(*read_filter_, onData(_, _))\n      .WillRepeatedly(Invoke([&](Buffer::Instance& data, bool) -> Network::FilterStatus {\n        EXPECT_GE(expected_chunk_size, data.length());\n        EXPECT_EQ(1, data.getRawSlices().size());\n        filter_seen += data.length();\n        data.drain(data.length());\n        if (filter_seen == (write_size * num_writes)) {\n          server_connection_->close(Network::ConnectionCloseType::FlushWrite);\n        }\n        return Network::FilterStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(client_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        EXPECT_EQ((write_size * num_writes), filter_seen);\n        dispatcher_->exit();\n      }));\n\n  for (uint32_t i = 0; i < num_writes; i++) {\n    Buffer::OwnedImpl data(std::string(write_size, 'a'));\n    client_connection_->write(data, false);\n  }\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\n// Test asynchronous signing (ECDHE) using a private key provider.\nTEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncSignSuccess) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: false\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string successful_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-RSA-AES128-GCM-SHA256\n)EOF\";\n\n  TestUtilOptions successful_test_options(successful_client_ctx_yaml, server_ctx_yaml, true,\n                                          GetParam());\n  testUtil(successful_test_options.setPrivateKeyMethodExpected(true));\n}\n\n// Test asynchronous decryption (RSA).\nTEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncDecryptSuccess) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: decrypt\n            sync_mode: false\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string successful_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  TestUtilOptions successful_test_options(successful_client_ctx_yaml, server_ctx_yaml, true,\n                                          GetParam());\n  testUtil(successful_test_options.setPrivateKeyMethodExpected(true));\n}\n\n// Test synchronous signing (ECDHE).\nTEST_P(SslSocketTest, RsaPrivateKeyProviderSyncSignSuccess) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string successful_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-RSA-AES128-GCM-SHA256\n)EOF\";\n\n  TestUtilOptions successful_test_options(successful_client_ctx_yaml, server_ctx_yaml, true,\n                                          GetParam());\n  testUtil(successful_test_options.setPrivateKeyMethodExpected(true));\n}\n\n// Test synchronous decryption (RSA).\nTEST_P(SslSocketTest, RsaPrivateKeyProviderSyncDecryptSuccess) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: decrypt\n            sync_mode: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string successful_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  TestUtilOptions successful_test_options(successful_client_ctx_yaml, server_ctx_yaml, true,\n                                          GetParam());\n  testUtil(successful_test_options.setPrivateKeyMethodExpected(true));\n}\n\n// Test asynchronous signing (ECDHE) failure (invalid signature).\nTEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncSignFailure) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: false\n            crypto_error: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string failing_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-RSA-AES128-GCM-SHA256\n)EOF\";\n\n  TestUtilOptions failing_test_options(failing_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(failing_test_options.setPrivateKeyMethodExpected(true).setExpectedServerStats(\n      \"ssl.connection_error\"));\n}\n\n// Test synchronous signing (ECDHE) failure (invalid signature).\nTEST_P(SslSocketTest, RsaPrivateKeyProviderSyncSignFailure) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: true\n            crypto_error: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string failing_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-RSA-AES128-GCM-SHA256\n)EOF\";\n\n  TestUtilOptions failing_test_options(failing_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(failing_test_options.setPrivateKeyMethodExpected(true).setExpectedServerStats(\n      \"ssl.connection_error\"));\n}\n\n// Test the sign operation return with an error.\nTEST_P(SslSocketTest, RsaPrivateKeyProviderSignFailure) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            method_error: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string failing_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-RSA-AES128-GCM-SHA256\n)EOF\";\n\n  TestUtilOptions failing_test_options(failing_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(failing_test_options.setPrivateKeyMethodExpected(true).setExpectedServerStats(\n      \"ssl.connection_error\"));\n}\n\n// Test the decrypt operation return with an error.\nTEST_P(SslSocketTest, RsaPrivateKeyProviderDecryptFailure) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: decrypt\n            method_error: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string failing_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  TestUtilOptions failing_test_options(failing_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(failing_test_options.setPrivateKeyMethodExpected(true).setExpectedServerStats(\n      \"ssl.connection_error\"));\n}\n\n// Test the sign operation return with an error in complete.\nTEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncSignCompleteFailure) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            async_method_error: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string failing_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-RSA-AES128-GCM-SHA256\n)EOF\";\n\n  TestUtilOptions failing_test_options(failing_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(failing_test_options.setPrivateKeyMethodExpected(true)\n               .setExpectedServerCloseEvent(Network::ConnectionEvent::LocalClose)\n               .setExpectedServerStats(\"ssl.connection_error\"));\n}\n\n// Test the decrypt operation return with an error in complete.\nTEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncDecryptCompleteFailure) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: decrypt\n            async_method_error: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string failing_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  TestUtilOptions failing_test_options(failing_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(failing_test_options.setPrivateKeyMethodExpected(true)\n               .setExpectedServerCloseEvent(Network::ConnectionEvent::LocalClose)\n               .setExpectedServerStats(\"ssl.connection_error\")\n               .setExpectedTransportFailureReasonContains(\"system library\")\n               .setNotExpectedClientStats(\"ssl.connection_error\"));\n}\n\n// Test having one cert with private key method and another with just\n// private key.\nTEST_P(SslSocketTest, RsaPrivateKeyProviderMultiCertSuccess) {\n  const std::string client_ctx_yaml = absl::StrCat(R\"EOF(\n    common_tls_context:\n      tls_params:\n        tls_minimum_protocol_version: TLSv1_2\n        tls_maximum_protocol_version: TLSv1_2\n        cipher_suites:\n        - ECDHE-ECDSA-AES128-GCM-SHA256\n        - ECDHE-RSA-AES128-GCM-SHA256\n      validation_context:\n        verify_certificate_hash: )EOF\",\n                                                   TEST_SELFSIGNED_ECDSA_P256_CERT_256_HASH);\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: false\n            mode: rsa\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setPrivateKeyMethodExpected(true));\n}\n\n// Test having two certs with private key methods. This will\n// synchronously fail because the second certificate is a ECDSA one and\n// the RSA method can't handle it.\nTEST_P(SslSocketTest, RsaPrivateKeyProviderMultiCertFail) {\n  const std::string client_ctx_yaml = absl::StrCat(R\"EOF(\n    common_tls_context:\n      tls_params:\n        tls_minimum_protocol_version: TLSv1_2\n        tls_maximum_protocol_version: TLSv1_2\n        cipher_suites:\n        - ECDHE-ECDSA-AES128-GCM-SHA256\n        - ECDHE-RSA-AES128-GCM-SHA256\n      validation_context:\n        verify_certificate_hash: )EOF\",\n                                                   TEST_SELFSIGNED_ECDSA_P256_CERT_256_HASH);\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: false\n            mode: rsa\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem\"\n            expected_operation: sign\n            sync_mode: false\n            mode: rsa\n)EOF\";\n\n  TestUtilOptions failing_test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  EXPECT_THROW_WITH_MESSAGE(testUtil(failing_test_options.setPrivateKeyMethodExpected(true)),\n                            EnvoyException, \"Private key is not RSA.\")\n}\n\n// Test ECDSA private key method provider mode.\nTEST_P(SslSocketTest, EcdsaPrivateKeyProviderSuccess) {\n  const std::string client_ctx_yaml = absl::StrCat(R\"EOF(\n    common_tls_context:\n      tls_params:\n        tls_minimum_protocol_version: TLSv1_2\n        tls_maximum_protocol_version: TLSv1_2\n        cipher_suites:\n        - ECDHE-ECDSA-AES128-GCM-SHA256\n      validation_context:\n        verify_certificate_hash: )EOF\",\n                                                   TEST_SELFSIGNED_ECDSA_P256_CERT_256_HASH);\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem\"\n            expected_operation: sign\n            mode: ecdsa\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setPrivateKeyMethodExpected(true));\n}\n\n// Test having two certs with different private key method modes. It's expected that the ECDSA\n// provider mode is being used. RSA provider mode is set to fail with \"async_method_error\", but\n// that's not happening.\nTEST_P(SslSocketTest, RsaAndEcdsaPrivateKeyProviderMultiCertSuccess) {\n  const std::string client_ctx_yaml = absl::StrCat(R\"EOF(\n    common_tls_context:\n      tls_params:\n        tls_minimum_protocol_version: TLSv1_2\n        tls_maximum_protocol_version: TLSv1_2\n        cipher_suites:\n        - ECDHE-ECDSA-AES128-GCM-SHA256\n        - ECDHE-RSA-AES128-GCM-SHA256\n      validation_context:\n        verify_certificate_hash: )EOF\",\n                                                   TEST_SELFSIGNED_ECDSA_P256_CERT_256_HASH);\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: false\n            async_method_error: true\n            mode: rsa\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem\"\n            expected_operation: sign\n            mode: ecdsa\n)EOF\";\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setPrivateKeyMethodExpected(true));\n}\n\n// Test having two certs with different private key method modes. ECDSA provider is set to fail.\nTEST_P(SslSocketTest, RsaAndEcdsaPrivateKeyProviderMultiCertFail) {\n  const std::string client_ctx_yaml = absl::StrCat(R\"EOF(\n    common_tls_context:\n      tls_params:\n        tls_minimum_protocol_version: TLSv1_2\n        tls_maximum_protocol_version: TLSv1_2\n        cipher_suites:\n        - ECDHE-ECDSA-AES128-GCM-SHA256\n        - ECDHE-RSA-AES128-GCM-SHA256\n      validation_context:\n        verify_certificate_hash: )EOF\",\n                                                   TEST_SELFSIGNED_ECDSA_P256_CERT_256_HASH);\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: false\n            mode: rsa\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem\"\n            expected_operation: sign\n            async_method_error: true\n            mode: ecdsa\n)EOF\";\n  TestUtilOptions failing_test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(failing_test_options.setPrivateKeyMethodExpected(true)\n               .setExpectedServerCloseEvent(Network::ConnectionEvent::LocalClose)\n               .setExpectedServerStats(\"ssl.connection_error\"));\n}\n\nTEST_P(SslSocketTest, TestStaplesOcspResponseSuccess) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_ocsp_resp.der\"\n  ocsp_staple_policy: lenient_stapling\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n\n  std::string ocsp_response_path =\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_ocsp_resp.der\";\n  std::string expected_response =\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(ocsp_response_path));\n\n  testUtil(test_options.enableOcspStapling()\n               .setExpectedOcspResponse(expected_response)\n               .setExpectedServerStats(\"ssl.ocsp_staple_responses\"));\n}\n\nTEST_P(SslSocketTest, TestNoOcspStapleWhenNotEnabledOnClient) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_ocsp_resp.der\"\n  ocsp_staple_policy: must_staple\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options);\n}\n\nTEST_P(SslSocketTest, TestOcspStapleOmittedOnSkipStaplingAndResponseExpired) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/unknown_ocsp_resp.der\"\n  ocsp_staple_policy: lenient_stapling\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.ocsp_staple_omitted\").enableOcspStapling());\n}\n\nTEST_P(SslSocketTest, TestConnectionFailsOnStapleRequiredAndOcspExpired) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/unknown_ocsp_resp.der\"\n  ocsp_staple_policy: must_staple\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.ocsp_staple_failed\").enableOcspStapling());\n}\n\nTEST_P(SslSocketTest, TestConnectionSucceedsWhenRejectOnExpiredNoOcspResponse) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_key.pem\"\n  ocsp_staple_policy: strict_stapling\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.ocsp_staple_omitted\").enableOcspStapling());\n}\n\nTEST_P(SslSocketTest, TestConnectionFailsWhenRejectOnExpiredAndResponseExpired) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/unknown_ocsp_resp.der\"\n  ocsp_staple_policy: strict_stapling\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.ocsp_staple_failed\").enableOcspStapling());\n}\n\nTEST_P(SslSocketTest, TestConnectionFailsWhenCertIsMustStapleAndResponseExpired) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/revoked_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/revoked_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/revoked_ocsp_resp.der\"\n  ocsp_staple_policy: lenient_stapling\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.ocsp_staple_failed\").enableOcspStapling());\n}\n\nTEST_P(SslSocketTest, TestFilterMultipleCertsFilterByOcspPolicyFallbackOnFirst) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_ocsp_resp.der\"\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/ecdsa_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/ecdsa_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/ecdsa_ocsp_resp.der\"\n  ocsp_staple_policy: must_staple\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-ECDSA-AES128-GCM-SHA256\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  std::string ocsp_response_path =\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_ocsp_resp.der\";\n  std::string expected_response =\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(ocsp_response_path));\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.enableOcspStapling()\n               .setExpectedServerStats(\"ssl.ocsp_staple_responses\")\n               .setExpectedOcspResponse(expected_response));\n}\n\nTEST_P(SslSocketTest, TestConnectionFailsOnMultipleCertificatesNonePassOcspPolicy) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/revoked_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/revoked_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/revoked_ocsp_resp.der\"\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/ecdsa_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/ecdsa_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/ecdsa_ocsp_resp.der\"\n  ocsp_staple_policy: must_staple\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-ECDSA-AES128-GCM-SHA256\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.ocsp_staple_failed\").enableOcspStapling());\n}\n\n} // namespace Tls\n} // namespace TransportSockets\n} // namespace Extensions\n} // namespace Envoy\n"], "fixing_code": ["#pragma once\n\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"envoy/api/api.h\"\n#include \"envoy/common/pure.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/cert.pb.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/common.pb.h\"\n#include \"envoy/type/matcher/v3/string.pb.h\"\n\n#include \"absl/types/optional.h\"\n\nnamespace Envoy {\nnamespace Ssl {\n\n// SECURITY NOTE\n//\n// When adding or changing this interface, it is likely that a change is needed to\n// `DefaultCertValidator::updateDigestForSessionId` in\n// `source/extensions/transport_sockets/tls/cert_validator/default_validator.cc`.\nclass CertificateValidationContextConfig {\npublic:\n  virtual ~CertificateValidationContextConfig() = default;\n\n  /**\n   * @return The CA certificate to use for peer validation.\n   */\n  virtual const std::string& caCert() const PURE;\n\n  /**\n   * @return Path of the CA certificate to use for peer validation or \"<inline>\"\n   * if the CA certificate was inlined.\n   */\n  virtual const std::string& caCertPath() const PURE;\n\n  /**\n   * @return The CRL to check if a cert is revoked.\n   */\n  virtual const std::string& certificateRevocationList() const PURE;\n\n  /**\n   * @return Path of the certificate revocation list, or \"<inline>\" if the CRL\n   * was inlined.\n   */\n  virtual const std::string& certificateRevocationListPath() const PURE;\n\n  /**\n   * @return The subject alt name matchers to be verified, if enabled.\n   */\n  virtual const std::vector<envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher>&\n  subjectAltNameMatchers() const PURE;\n\n  /**\n   * @return A list of a hex-encoded SHA-256 certificate hashes to be verified.\n   */\n  virtual const std::vector<std::string>& verifyCertificateHashList() const PURE;\n\n  /**\n   * @return A list of a hex-encoded SHA-256 SPKI hashes to be verified.\n   */\n  virtual const std::vector<std::string>& verifyCertificateSpkiList() const PURE;\n\n  /**\n   * @return whether to ignore expired certificates (both too new and too old).\n   */\n  virtual bool allowExpiredCertificate() const PURE;\n\n  /**\n   * @return client certificate validation configuration.\n   */\n  virtual envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext::\n      TrustChainVerification\n      trustChainVerification() const PURE;\n\n  /**\n   * @return the configuration for the custom certificate validator if configured.\n   */\n  virtual const absl::optional<envoy::config::core::v3::TypedExtensionConfig>&\n  customValidatorConfig() const PURE;\n\n  /**\n   * @return a reference to the api object.\n   */\n  virtual Api::Api& api() const PURE;\n\n  /**\n   * @return whether to validate certificate chain with all CRL or not.\n   */\n  virtual bool onlyVerifyLeafCertificateCrl() const PURE;\n};\n\nusing CertificateValidationContextConfigPtr = std::unique_ptr<CertificateValidationContextConfig>;\n\n} // namespace Ssl\n} // namespace Envoy\n", "#pragma once\n\n#include <array>\n#include <deque>\n#include <functional>\n#include <string>\n#include <vector>\n\n#include \"envoy/common/pure.h\"\n#include \"envoy/network/transport_socket.h\"\n#include \"envoy/ssl/context.h\"\n#include \"envoy/ssl/context_config.h\"\n#include \"envoy/ssl/private_key/private_key.h\"\n#include \"envoy/ssl/ssl_socket_extended_info.h\"\n\n#include \"source/common/common/matchers.h\"\n#include \"source/common/stats/symbol_table.h\"\n#include \"source/extensions/transport_sockets/tls/stats.h\"\n\n#include \"openssl/ssl.h\"\n#include \"openssl/x509v3.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace TransportSockets {\nnamespace Tls {\n\nclass CertValidator {\npublic:\n  virtual ~CertValidator() = default;\n\n  /**\n   * Called to add the client validation context information to a given ssl context\n   *\n   * @param context the store context\n   * @param require_client_cert whether or not client cert is required\n   */\n  virtual void addClientValidationContext(SSL_CTX* context, bool require_client_cert) PURE;\n\n  /**\n   * Called by verifyCallback to do the actual cert chain verification.\n   *\n   * @param store_ctx the store context\n   * @param ssl_extended_info the info for storing the validation status\n   * @param leaf_cert the peer certificate to verify\n   * @return 1 to indicate verification success and 0 to indicate verification failure.\n   */\n  virtual int\n  doVerifyCertChain(X509_STORE_CTX* store_ctx, Ssl::SslExtendedSocketInfo* ssl_extended_info,\n                    X509& leaf_cert,\n                    const Network::TransportSocketOptions* transport_socket_options) PURE;\n\n  /**\n   * Called to initialize all ssl contexts\n   *\n   * @param contexts the store context\n   * @param handshaker_provides_certificates whether or not a handshaker implementation provides\n   * certificates itself.\n   * @return the ssl verification mode flag\n   */\n  virtual int initializeSslContexts(std::vector<SSL_CTX*> contexts,\n                                    bool handshaker_provides_certificates) PURE;\n\n  /**\n   * Called when calculation hash for session context ids. This hash MUST include all\n   * configuration used to validate a peer certificate, so that if this configuration\n   * is changed, sessions cannot be re-used and must be re-negotiated and re-validated\n   * using the new settings.\n   *\n   * @param md the store context\n   * @param hash_buffer the buffer used for digest calculation\n   * @param hash_length the expected length of hash\n   */\n  virtual void updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                        uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                        unsigned hash_length) PURE;\n\n  virtual size_t daysUntilFirstCertExpires() const PURE;\n  virtual std::string getCaFileName() const PURE;\n  virtual Envoy::Ssl::CertificateDetailsPtr getCaCertInformation() const PURE;\n};\n\nusing CertValidatorPtr = std::unique_ptr<CertValidator>;\n\n} // namespace Tls\n} // namespace TransportSockets\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/extensions/transport_sockets/tls/cert_validator/default_validator.h\"\n\n#include <array>\n#include <deque>\n#include <functional>\n#include <string>\n#include <vector>\n\n#include \"envoy/network/transport_socket.h\"\n#include \"envoy/ssl/context.h\"\n#include \"envoy/ssl/context_config.h\"\n#include \"envoy/ssl/private_key/private_key.h\"\n#include \"envoy/ssl/ssl_socket_extended_info.h\"\n\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/base64.h\"\n#include \"source/common/common/fmt.h\"\n#include \"source/common/common/hex.h\"\n#include \"source/common/common/matchers.h\"\n#include \"source/common/common/utility.h\"\n#include \"source/common/config/utility.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/protobuf/utility.h\"\n#include \"source/common/runtime/runtime_features.h\"\n#include \"source/common/stats/symbol_table.h\"\n#include \"source/common/stats/utility.h\"\n#include \"source/extensions/transport_sockets/tls/cert_validator/cert_validator.h\"\n#include \"source/extensions/transport_sockets/tls/cert_validator/factory.h\"\n#include \"source/extensions/transport_sockets/tls/cert_validator/utility.h\"\n#include \"source/extensions/transport_sockets/tls/stats.h\"\n#include \"source/extensions/transport_sockets/tls/utility.h\"\n\n#include \"absl/synchronization/mutex.h\"\n#include \"openssl/ssl.h\"\n#include \"openssl/x509v3.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace TransportSockets {\nnamespace Tls {\n\nDefaultCertValidator::DefaultCertValidator(\n    const Envoy::Ssl::CertificateValidationContextConfig* config, SslStats& stats,\n    TimeSource& time_source)\n    : config_(config), stats_(stats), time_source_(time_source) {\n  if (config_ != nullptr) {\n    allow_untrusted_certificate_ = config_->trustChainVerification() ==\n                                   envoy::extensions::transport_sockets::tls::v3::\n                                       CertificateValidationContext::ACCEPT_UNTRUSTED;\n  }\n};\n\nint DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> contexts,\n                                                bool provides_certificates) {\n\n  int verify_mode = SSL_VERIFY_NONE;\n  int verify_mode_validation_context = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n\n  if (config_ != nullptr) {\n    envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext::\n        TrustChainVerification verification = config_->trustChainVerification();\n    if (verification == envoy::extensions::transport_sockets::tls::v3::\n                            CertificateValidationContext::ACCEPT_UNTRUSTED) {\n      verify_mode = SSL_VERIFY_PEER; // Ensure client-certs will be requested even if we have\n                                     // nothing to verify against\n      verify_mode_validation_context = SSL_VERIFY_PEER;\n    }\n  }\n\n  if (config_ != nullptr && !config_->caCert().empty() && !provides_certificates) {\n    ca_file_path_ = config_->caCertPath();\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->caCert().data()), config_->caCert().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      bool has_crl = false;\n      for (const X509_INFO* item : list.get()) {\n        if (item->x509) {\n          X509_STORE_add_cert(store, item->x509);\n          if (ca_cert_ == nullptr) {\n            X509_up_ref(item->x509);\n            ca_cert_.reset(item->x509);\n          }\n        }\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n          has_crl = true;\n        }\n      }\n      if (ca_cert_ == nullptr) {\n        throw EnvoyException(\n            absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n      }\n      if (has_crl) {\n        X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                        ? X509_V_FLAG_CRL_CHECK\n                                        : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n      }\n      verify_mode = SSL_VERIFY_PEER;\n      verify_trusted_ca_ = true;\n\n      // NOTE: We're using SSL_CTX_set_cert_verify_callback() instead of X509_verify_cert()\n      // directly. However, our new callback is still calling X509_verify_cert() under\n      // the hood. Therefore, to ignore cert expiration, we need to set the callback\n      // for X509_verify_cert to ignore that error.\n      if (config_->allowExpiredCertificate()) {\n        X509_STORE_set_verify_cb(store, CertValidatorUtil::ignoreCertificateExpirationCallback);\n      }\n    }\n  }\n\n  if (config_ != nullptr && !config_->certificateRevocationList().empty()) {\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->certificateRevocationList().data()),\n                        config_->certificateRevocationList().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load CRL from \", config_->certificateRevocationListPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      for (const X509_INFO* item : list.get()) {\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n        }\n      }\n      X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                      ? X509_V_FLAG_CRL_CHECK\n                                      : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n    }\n  }\n\n  const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_;\n  if (cert_validation_config != nullptr) {\n    if (!cert_validation_config->subjectAltNameMatchers().empty()) {\n      for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& matcher :\n           cert_validation_config->subjectAltNameMatchers()) {\n        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateHashList().empty()) {\n      for (auto hash : cert_validation_config->verifyCertificateHashList()) {\n        // Remove colons from the 95 chars long colon-separated \"fingerprint\"\n        // in order to get the hex-encoded string.\n        if (hash.size() == 95) {\n          hash.erase(std::remove(hash.begin(), hash.end(), ':'), hash.end());\n        }\n        const auto& decoded = Hex::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid hex-encoded SHA-256 \", hash));\n        }\n        verify_certificate_hash_list_.push_back(decoded);\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateSpkiList().empty()) {\n      for (const auto& hash : cert_validation_config->verifyCertificateSpkiList()) {\n        const auto decoded = Base64::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid base64-encoded SHA-256 \", hash));\n        }\n        verify_certificate_spki_list_.emplace_back(decoded.begin(), decoded.end());\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n  }\n\n  return verify_mode;\n}\n\nint DefaultCertValidator::doVerifyCertChain(\n    X509_STORE_CTX* store_ctx, Ssl::SslExtendedSocketInfo* ssl_extended_info, X509& leaf_cert,\n    const Network::TransportSocketOptions* transport_socket_options) {\n  if (verify_trusted_ca_) {\n    int ret = X509_verify_cert(store_ctx);\n    if (ssl_extended_info) {\n      ssl_extended_info->setCertificateValidationStatus(\n          ret == 1 ? Envoy::Ssl::ClientValidationStatus::Validated\n                   : Envoy::Ssl::ClientValidationStatus::Failed);\n    }\n\n    if (ret <= 0) {\n      stats_.fail_verify_error_.inc();\n      ENVOY_LOG(debug, \"{}\", Utility::getX509VerificationErrorInfo(store_ctx));\n      return allow_untrusted_certificate_ ? 1 : ret;\n    }\n  }\n\n  Envoy::Ssl::ClientValidationStatus validated =\n      verifyCertificate(&leaf_cert,\n                        transport_socket_options != nullptr\n                            ? transport_socket_options->verifySubjectAltNameListOverride()\n                            : std::vector<std::string>{},\n                        subject_alt_name_matchers_);\n\n  if (ssl_extended_info) {\n    if (ssl_extended_info->certificateValidationStatus() ==\n        Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    } else if (validated != Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    }\n  }\n\n  // If `trusted_ca` exists, it is already verified in the code above. Thus, we just need to make\n  // sure the verification for other validation context configurations doesn't fail (i.e. either\n  // `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure\n  // other configurations are verified and the verification succeed.\n  int validation_status = verify_trusted_ca_\n                              ? validated != Envoy::Ssl::ClientValidationStatus::Failed\n                              : validated == Envoy::Ssl::ClientValidationStatus::Validated;\n\n  return allow_untrusted_certificate_ ? 1 : validation_status;\n}\n\nEnvoy::Ssl::ClientValidationStatus DefaultCertValidator::verifyCertificate(\n    X509* cert, const std::vector<std::string>& verify_san_list,\n    const std::vector<SanMatcherPtr>& subject_alt_name_matchers) {\n  Envoy::Ssl::ClientValidationStatus validated = Envoy::Ssl::ClientValidationStatus::NotValidated;\n\n  if (!verify_san_list.empty()) {\n    if (!verifySubjectAltName(cert, verify_san_list)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n\n  if (!subject_alt_name_matchers.empty()) {\n    if (!matchSubjectAltName(cert, subject_alt_name_matchers)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n\n  if (!verify_certificate_hash_list_.empty() || !verify_certificate_spki_list_.empty()) {\n    const bool valid_certificate_hash =\n        !verify_certificate_hash_list_.empty() &&\n        verifyCertificateHashList(cert, verify_certificate_hash_list_);\n    const bool valid_certificate_spki =\n        !verify_certificate_spki_list_.empty() &&\n        verifyCertificateSpkiList(cert, verify_certificate_spki_list_);\n\n    if (!valid_certificate_hash && !valid_certificate_spki) {\n      stats_.fail_verify_cert_hash_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n\n  return validated;\n}\n\nbool DefaultCertValidator::verifySubjectAltName(X509* cert,\n                                                const std::vector<std::string>& subject_alt_names) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return false;\n  }\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    const std::string san = Utility::generalNameAsString(general_name);\n    for (auto& config_san : subject_alt_names) {\n      if (general_name->type == GEN_DNS ? Utility::dnsNameMatch(config_san, san.c_str())\n                                        : config_san == san) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nbool DefaultCertValidator::matchSubjectAltName(\n    X509* cert, const std::vector<SanMatcherPtr>& subject_alt_name_matchers) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return false;\n  }\n  for (const auto& config_san_matcher : subject_alt_name_matchers) {\n    for (const GENERAL_NAME* general_name : san_names.get()) {\n      if (config_san_matcher->match(general_name)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nbool DefaultCertValidator::verifyCertificateSpkiList(\n    X509* cert, const std::vector<std::vector<uint8_t>>& expected_hashes) {\n  X509_PUBKEY* pubkey = X509_get_X509_PUBKEY(cert);\n  if (pubkey == nullptr) {\n    return false;\n  }\n  uint8_t* spki = nullptr;\n  const int len = i2d_X509_PUBKEY(pubkey, &spki);\n  if (len < 0) {\n    return false;\n  }\n  bssl::UniquePtr<uint8_t> free_spki(spki);\n\n  std::vector<uint8_t> computed_hash(SHA256_DIGEST_LENGTH);\n  SHA256(spki, len, computed_hash.data());\n\n  for (const auto& expected_hash : expected_hashes) {\n    if (computed_hash == expected_hash) {\n      return true;\n    }\n  }\n  return false;\n}\n\nbool DefaultCertValidator::verifyCertificateHashList(\n    X509* cert, const std::vector<std::vector<uint8_t>>& expected_hashes) {\n  std::vector<uint8_t> computed_hash(SHA256_DIGEST_LENGTH);\n  unsigned int n;\n  X509_digest(cert, EVP_sha256(), computed_hash.data(), &n);\n  RELEASE_ASSERT(n == computed_hash.size(), \"\");\n\n  for (const auto& expected_hash : expected_hashes) {\n    if (computed_hash == expected_hash) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                                    uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                                    unsigned hash_length) {\n  int rc;\n\n  // Hash all the settings that affect whether the server will allow/accept\n  // the client connection. This ensures that the client is always validated against\n  // the correct settings, even if session resumption across different listeners\n  // is enabled.\n  if (ca_cert_ != nullptr) {\n    rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,\n                   fmt::format(\"invalid SHA256 hash length {}\", hash_length));\n\n    rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_hash_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_spki_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  rc = EVP_DigestUpdate(md.get(), &verify_trusted_ca_, sizeof(verify_trusted_ca_));\n  RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n  if (config_ != nullptr) {\n    for (const auto& matcher : config_->subjectAltNameMatchers()) {\n      size_t hash = MessageUtil::hash(matcher);\n      rc = EVP_DigestUpdate(md.get(), &hash, sizeof(hash));\n      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    }\n\n    const std::string& crl = config_->certificateRevocationList();\n    if (!crl.empty()) {\n      rc = EVP_DigestUpdate(md.get(), crl.data(), crl.length());\n      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    }\n\n    bool allow_expired = config_->allowExpiredCertificate();\n    rc = EVP_DigestUpdate(md.get(), &allow_expired, sizeof(allow_expired));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n    auto trust_chain_verification = config_->trustChainVerification();\n    rc = EVP_DigestUpdate(md.get(), &trust_chain_verification, sizeof(trust_chain_verification));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n    auto only_leaf_crl = config_->onlyVerifyLeafCertificateCrl();\n    rc = EVP_DigestUpdate(md.get(), &only_leaf_crl, sizeof(only_leaf_crl));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n}\n\nvoid DefaultCertValidator::addClientValidationContext(SSL_CTX* ctx, bool require_client_cert) {\n  if (config_ == nullptr || config_->caCert().empty()) {\n    return;\n  }\n\n  bssl::UniquePtr<BIO> bio(\n      BIO_new_mem_buf(const_cast<char*>(config_->caCert().data()), config_->caCert().size()));\n  RELEASE_ASSERT(bio != nullptr, \"\");\n  // Based on BoringSSL's SSL_add_file_cert_subjects_to_stack().\n  bssl::UniquePtr<STACK_OF(X509_NAME)> list(sk_X509_NAME_new(\n      [](const X509_NAME** a, const X509_NAME** b) -> int { return X509_NAME_cmp(*a, *b); }));\n  RELEASE_ASSERT(list != nullptr, \"\");\n  for (;;) {\n    bssl::UniquePtr<X509> cert(PEM_read_bio_X509(bio.get(), nullptr, nullptr, nullptr));\n    if (cert == nullptr) {\n      break;\n    }\n    X509_NAME* name = X509_get_subject_name(cert.get());\n    if (name == nullptr) {\n      throw EnvoyException(absl::StrCat(\"Failed to load trusted client CA certificates from \",\n                                        config_->caCertPath()));\n    }\n    // Check for duplicates.\n    if (sk_X509_NAME_find(list.get(), nullptr, name)) {\n      continue;\n    }\n    bssl::UniquePtr<X509_NAME> name_dup(X509_NAME_dup(name));\n    if (name_dup == nullptr || !sk_X509_NAME_push(list.get(), name_dup.release())) {\n      throw EnvoyException(absl::StrCat(\"Failed to load trusted client CA certificates from \",\n                                        config_->caCertPath()));\n    }\n  }\n\n  // Check for EOF.\n  const uint32_t err = ERR_peek_last_error();\n  if (ERR_GET_LIB(err) == ERR_LIB_PEM && ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {\n    ERR_clear_error();\n  } else {\n    throw EnvoyException(\n        absl::StrCat(\"Failed to load trusted client CA certificates from \", config_->caCertPath()));\n  }\n  SSL_CTX_set_client_CA_list(ctx, list.release());\n\n  if (require_client_cert) {\n    SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);\n  }\n}\n\nEnvoy::Ssl::CertificateDetailsPtr DefaultCertValidator::getCaCertInformation() const {\n  if (ca_cert_ == nullptr) {\n    return nullptr;\n  }\n  return Utility::certificateDetails(ca_cert_.get(), getCaFileName(), time_source_);\n}\n\nsize_t DefaultCertValidator::daysUntilFirstCertExpires() const {\n  return Utility::getDaysUntilExpiration(ca_cert_.get(), time_source_);\n}\n\nclass DefaultCertValidatorFactory : public CertValidatorFactory {\npublic:\n  CertValidatorPtr createCertValidator(const Envoy::Ssl::CertificateValidationContextConfig* config,\n                                       SslStats& stats, TimeSource& time_source) override {\n    return std::make_unique<DefaultCertValidator>(config, stats, time_source);\n  }\n\n  absl::string_view name() override { return \"envoy.tls.cert_validator.default\"; }\n};\n\nREGISTER_FACTORY(DefaultCertValidatorFactory, CertValidatorFactory);\n\n} // namespace Tls\n} // namespace TransportSockets\n} // namespace Extensions\n} // namespace Envoy\n", "#include <cstdint>\n#include <memory>\n#include <string>\n\n#include \"envoy/config/listener/v3/listener.pb.h\"\n#include \"envoy/config/listener/v3/listener_components.pb.h\"\n#include \"envoy/extensions/transport_sockets/tls/v3/cert.pb.h\"\n#include \"envoy/network/transport_socket.h\"\n\n#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/event/dispatcher_impl.h\"\n#include \"source/common/json/json_loader.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/network/listen_socket_impl.h\"\n#include \"source/common/network/transport_socket_options_impl.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/common/stream_info/stream_info_impl.h\"\n#include \"source/extensions/transport_sockets/tls/context_config_impl.h\"\n#include \"source/extensions/transport_sockets/tls/context_impl.h\"\n#include \"source/extensions/transport_sockets/tls/private_key/private_key_manager_impl.h\"\n#include \"source/extensions/transport_sockets/tls/ssl_socket.h\"\n\n#include \"test/extensions/transport_sockets/tls/ssl_certs_test.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/ca_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/extensions_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/no_san_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/password_protected_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/san_dns2_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/san_dns3_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/san_dns4_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/san_dns_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/san_uri_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert_info.h\"\n#include \"test/extensions/transport_sockets/tls/test_private_key_method_provider.h\"\n#include \"test/mocks/buffer/mocks.h\"\n#include \"test/mocks/init/mocks.h\"\n#include \"test/mocks/local_info/mocks.h\"\n#include \"test/mocks/network/io_handle.h\"\n#include \"test/mocks/network/mocks.h\"\n#include \"test/mocks/runtime/mocks.h\"\n#include \"test/mocks/secret/mocks.h\"\n#include \"test/mocks/server/transport_socket_factory_context.h\"\n#include \"test/mocks/ssl/mocks.h\"\n#include \"test/mocks/stats/mocks.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/registry.h\"\n#include \"test/test_common/test_runtime.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"absl/strings/str_replace.h\"\n#include \"absl/types/optional.h\"\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n#include \"openssl/ssl.h\"\n\nusing testing::_;\nusing testing::ContainsRegex;\nusing testing::DoAll;\nusing testing::InSequence;\nusing testing::Invoke;\nusing testing::NiceMock;\nusing testing::Return;\nusing testing::ReturnRef;\nusing testing::StrictMock;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace TransportSockets {\nnamespace Tls {\nnamespace {\n\n/**\n * A base class to hold the options for testUtil() and testUtilV2().\n */\nclass TestUtilOptionsBase {\npublic:\n  const std::vector<std::string>& expectedClientCertUri() const {\n    return expected_client_cert_uri_;\n  }\n  const std::string& expectedServerStats() const { return expected_server_stats_; }\n  bool expectSuccess() const { return expect_success_; }\n  Network::Address::IpVersion version() const { return version_; }\n\nprotected:\n  TestUtilOptionsBase(bool expect_success, Network::Address::IpVersion version)\n      : expect_success_(expect_success), version_(version) {}\n\n  void setExpectedClientCertUri(const std::string& expected_client_cert_uri) {\n    expected_client_cert_uri_ = {expected_client_cert_uri};\n  }\n\n  void setExpectedServerStats(const std::string& expected_server_stats) {\n    expected_server_stats_ = expected_server_stats;\n  }\n\nprivate:\n  const bool expect_success_;\n  const Network::Address::IpVersion version_;\n\n  std::string expected_server_stats_;\n  std::vector<std::string> expected_client_cert_uri_;\n};\n\n/**\n * A class to hold the options for testUtil().\n */\nclass TestUtilOptions : public TestUtilOptionsBase {\npublic:\n  TestUtilOptions(const std::string& client_ctx_yaml, const std::string& server_ctx_yaml,\n                  bool expect_success, Network::Address::IpVersion version)\n      : TestUtilOptionsBase(expect_success, version), client_ctx_yaml_(client_ctx_yaml),\n        server_ctx_yaml_(server_ctx_yaml), expect_no_cert_(false), expect_no_cert_chain_(false),\n        expect_private_key_method_(false),\n        expected_server_close_event_(Network::ConnectionEvent::RemoteClose) {\n    if (expect_success) {\n      setExpectedServerStats(\"ssl.handshake\");\n    } else {\n      setExpectedServerStats(\"ssl.fail_verify_error\");\n    }\n  }\n\n  const std::string& clientCtxYaml() const { return client_ctx_yaml_; }\n  const std::string& serverCtxYaml() const { return server_ctx_yaml_; }\n\n  TestUtilOptions& setExpectedServerStats(const std::string& expected_server_stats) {\n    TestUtilOptionsBase::setExpectedServerStats(expected_server_stats);\n    return *this;\n  }\n\n  bool expectNoCert() const { return expect_no_cert_; }\n\n  TestUtilOptions& setExpectNoCert() {\n    expect_no_cert_ = true;\n    return *this;\n  }\n\n  bool expectNoCertChain() const { return expect_no_cert_chain_; }\n\n  TestUtilOptions& setExpectNoCertChain() {\n    expect_no_cert_chain_ = true;\n    return *this;\n  }\n\n  TestUtilOptions& setExpectedClientCertUri(const std::string& expected_client_cert_uri) {\n    TestUtilOptionsBase::setExpectedClientCertUri(expected_client_cert_uri);\n    return *this;\n  }\n\n  TestUtilOptions& setExpectedSha256Digest(const std::string& expected_sha256_digest) {\n    expected_sha256_digest_ = expected_sha256_digest;\n    return *this;\n  }\n\n  const std::string& expectedSha256Digest() const { return expected_sha256_digest_; }\n\n  TestUtilOptions& setExpectedSha1Digest(const std::string& expected_sha1_digest) {\n    expected_sha1_digest_ = expected_sha1_digest;\n    return *this;\n  }\n\n  const std::string& expectedSha1Digest() const { return expected_sha1_digest_; }\n\n  TestUtilOptions& setExpectedLocalUri(const std::string& expected_local_uri) {\n    expected_local_uri_ = {expected_local_uri};\n    return *this;\n  }\n\n  const std::vector<std::string>& expectedLocalUri() const { return expected_local_uri_; }\n\n  TestUtilOptions& setExpectedSerialNumber(const std::string& expected_serial_number) {\n    expected_serial_number_ = expected_serial_number;\n    return *this;\n  }\n\n  const std::string& expectedSerialNumber() const { return expected_serial_number_; }\n\n  TestUtilOptions& setExpectedPeerIssuer(const std::string& expected_peer_issuer) {\n    expected_peer_issuer_ = expected_peer_issuer;\n    return *this;\n  }\n\n  const std::string& expectedPeerIssuer() const { return expected_peer_issuer_; }\n\n  TestUtilOptions& setExpectedPeerSubject(const std::string& expected_peer_subject) {\n    expected_peer_subject_ = expected_peer_subject;\n    return *this;\n  }\n\n  const std::string& expectedPeerSubject() const { return expected_peer_subject_; }\n\n  TestUtilOptions& setExpectedLocalSubject(const std::string& expected_local_subject) {\n    expected_local_subject_ = expected_local_subject;\n    return *this;\n  }\n\n  const std::string& expectedLocalSubject() const { return expected_local_subject_; }\n\n  TestUtilOptions& setExpectedPeerCert(const std::string& expected_peer_cert) {\n    expected_peer_cert_ = expected_peer_cert;\n    return *this;\n  }\n\n  const std::string& expectedPeerCert() const { return expected_peer_cert_; }\n\n  TestUtilOptions& setExpectedPeerCertChain(const std::string& expected_peer_cert_chain) {\n    expected_peer_cert_chain_ = expected_peer_cert_chain;\n    return *this;\n  }\n\n  const std::string& expectedPeerCertChain() const { return expected_peer_cert_chain_; }\n\n  TestUtilOptions& setExpectedValidFromTimePeerCert(const std::string& expected_valid_from) {\n    expected_valid_from_peer_cert_ = expected_valid_from;\n    return *this;\n  }\n\n  const std::string& expectedValidFromTimePeerCert() const {\n    return expected_valid_from_peer_cert_;\n  }\n\n  TestUtilOptions& setExpectedExpirationTimePeerCert(const std::string& expected_expiration) {\n    expected_expiration_peer_cert_ = expected_expiration;\n    return *this;\n  }\n\n  const std::string& expectedExpirationTimePeerCert() const {\n    return expected_expiration_peer_cert_;\n  }\n\n  TestUtilOptions& setPrivateKeyMethodExpected(bool expected_method) {\n    expect_private_key_method_ = expected_method;\n    return *this;\n  }\n\n  bool expectedPrivateKeyMethod() const { return expect_private_key_method_; }\n\n  TestUtilOptions& setExpectedServerCloseEvent(Network::ConnectionEvent expected_event) {\n    expected_server_close_event_ = expected_event;\n    return *this;\n  }\n\n  Network::ConnectionEvent expectedServerCloseEvent() const { return expected_server_close_event_; }\n\n  TestUtilOptions& setExpectedOcspResponse(const std::string& expected_ocsp_response) {\n    expected_ocsp_response_ = expected_ocsp_response;\n    return *this;\n  }\n\n  const std::string& expectedOcspResponse() const { return expected_ocsp_response_; }\n\n  TestUtilOptions& enableOcspStapling() {\n    ocsp_stapling_enabled_ = true;\n    return *this;\n  }\n\n  bool ocspStaplingEnabled() const { return ocsp_stapling_enabled_; }\n\n  TestUtilOptions& setExpectedTransportFailureReasonContains(\n      const std::string& expected_transport_failure_reason_contains) {\n    expected_transport_failure_reason_contains_ = expected_transport_failure_reason_contains;\n    return *this;\n  }\n\n  const std::string& expectedTransportFailureReasonContains() const {\n    return expected_transport_failure_reason_contains_;\n  }\n\n  TestUtilOptions& setNotExpectedClientStats(const std::string& stat) {\n    not_expected_client_stats_ = stat;\n    return *this;\n  }\n  const std::string& notExpectedClientStats() const { return not_expected_client_stats_; }\n\n  TestUtilOptions& setExpectedVerifyErrorCode(int code) {\n    expected_verify_error_code_ = code;\n    return *this;\n  }\n\n  int expectedVerifyErrorCode() const { return expected_verify_error_code_; }\n\nprivate:\n  const std::string client_ctx_yaml_;\n  const std::string server_ctx_yaml_;\n\n  bool expect_no_cert_;\n  bool expect_no_cert_chain_;\n  bool expect_private_key_method_;\n  NiceMock<Runtime::MockLoader> runtime_;\n  Network::ConnectionEvent expected_server_close_event_;\n  std::string expected_sha256_digest_;\n  std::string expected_sha1_digest_;\n  std::vector<std::string> expected_local_uri_;\n  std::string expected_serial_number_;\n  std::string expected_peer_issuer_;\n  std::string expected_peer_subject_;\n  std::string expected_local_subject_;\n  std::string expected_peer_cert_;\n  std::string expected_peer_cert_chain_;\n  std::string expected_valid_from_peer_cert_;\n  std::string expected_expiration_peer_cert_;\n  std::string expected_ocsp_response_;\n  bool ocsp_stapling_enabled_{false};\n  std::string expected_transport_failure_reason_contains_;\n  std::string not_expected_client_stats_;\n  int expected_verify_error_code_{-1};\n};\n\nvoid testUtil(const TestUtilOptions& options) {\n  Event::SimulatedTimeSystem time_system;\n\n  Stats::TestUtil::TestStore server_stats_store;\n  Api::ApiPtr server_api = Api::createApiForTest(server_stats_store, time_system);\n  NiceMock<Runtime::MockLoader> runtime;\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      server_factory_context;\n  ON_CALL(server_factory_context, api()).WillByDefault(ReturnRef(*server_api));\n\n  // For private key method testing.\n  NiceMock<Ssl::MockContextManager> context_manager;\n  Extensions::PrivateKeyMethodProvider::TestPrivateKeyMethodFactory test_factory;\n  Registry::InjectFactory<Ssl::PrivateKeyMethodProviderInstanceFactory>\n      test_private_key_method_factory(test_factory);\n  PrivateKeyMethodManagerImpl private_key_method_manager;\n  if (options.expectedPrivateKeyMethod()) {\n    EXPECT_CALL(server_factory_context, sslContextManager())\n        .WillOnce(ReturnRef(context_manager))\n        .WillRepeatedly(ReturnRef(context_manager));\n    EXPECT_CALL(context_manager, privateKeyMethodManager())\n        .WillOnce(ReturnRef(private_key_method_manager))\n        .WillRepeatedly(ReturnRef(private_key_method_manager));\n  }\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(options.serverCtxYaml()),\n                            server_tls_context);\n  auto server_cfg =\n      std::make_unique<ServerContextConfigImpl>(server_tls_context, server_factory_context);\n  ContextManagerImpl manager(*time_system);\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  Event::DispatcherPtr dispatcher = server_api->allocateDispatcher(\"test_thread\");\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(options.version()));\n  Network::MockTcpListenerCallbacks callbacks;\n  Network::ListenerPtr listener =\n      dispatcher->createListener(socket, callbacks, runtime, true, false);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(options.clientCtxYaml()),\n                            client_tls_context);\n\n  Stats::TestUtil::TestStore client_stats_store;\n  Api::ApiPtr client_api = Api::createApiForTest(client_stats_store, time_system);\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      client_factory_context;\n  ON_CALL(client_factory_context, api()).WillByDefault(ReturnRef(*client_api));\n\n  auto client_cfg =\n      std::make_unique<ClientContextConfigImpl>(client_tls_context, client_factory_context);\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager,\n                                                   client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      client_ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  NiceMock<StreamInfo::MockStreamInfo> stream_info;\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        auto ssl_socket = server_ssl_socket_factory.createTransportSocket(nullptr);\n        // configureInitialCongestionWindow is an unimplemented empty function, this is just to\n        // increase code coverage.\n        ssl_socket->configureInitialCongestionWindow(100, std::chrono::microseconds(123));\n        server_connection = dispatcher->createServerConnection(std::move(socket),\n                                                               std::move(ssl_socket), stream_info);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  if (options.ocspStaplingEnabled()) {\n    const SslHandshakerImpl* ssl_socket =\n        dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n    SSL_enable_ocsp_stapling(ssl_socket->ssl());\n  }\n\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  size_t connect_count = 0;\n  auto connect_second_time = [&]() {\n    if (++connect_count == 2) {\n      if (!options.expectedSha256Digest().empty()) {\n        // Assert twice to ensure a cached value is returned and still valid.\n        EXPECT_EQ(options.expectedSha256Digest(),\n                  server_connection->ssl()->sha256PeerCertificateDigest());\n        EXPECT_EQ(options.expectedSha256Digest(),\n                  server_connection->ssl()->sha256PeerCertificateDigest());\n      }\n      if (!options.expectedSha1Digest().empty()) {\n        // Assert twice to ensure a cached value is returned and still valid.\n        EXPECT_EQ(options.expectedSha1Digest(),\n                  server_connection->ssl()->sha1PeerCertificateDigest());\n        EXPECT_EQ(options.expectedSha1Digest(),\n                  server_connection->ssl()->sha1PeerCertificateDigest());\n      }\n      // Assert twice to ensure a cached value is returned and still valid.\n      EXPECT_EQ(options.expectedClientCertUri(), server_connection->ssl()->uriSanPeerCertificate());\n      EXPECT_EQ(options.expectedClientCertUri(), server_connection->ssl()->uriSanPeerCertificate());\n\n      if (!options.expectedLocalUri().empty()) {\n        // Assert twice to ensure a cached value is returned and still valid.\n        EXPECT_EQ(options.expectedLocalUri(), server_connection->ssl()->uriSanLocalCertificate());\n        EXPECT_EQ(options.expectedLocalUri(), server_connection->ssl()->uriSanLocalCertificate());\n      }\n      EXPECT_EQ(options.expectedSerialNumber(),\n                server_connection->ssl()->serialNumberPeerCertificate());\n      if (!options.expectedPeerIssuer().empty()) {\n        EXPECT_EQ(options.expectedPeerIssuer(), server_connection->ssl()->issuerPeerCertificate());\n      }\n      if (!options.expectedPeerSubject().empty()) {\n        EXPECT_EQ(options.expectedPeerSubject(),\n                  server_connection->ssl()->subjectPeerCertificate());\n      }\n      if (!options.expectedLocalSubject().empty()) {\n        EXPECT_EQ(options.expectedLocalSubject(),\n                  server_connection->ssl()->subjectLocalCertificate());\n      }\n      if (!options.expectedPeerCert().empty()) {\n        std::string urlencoded = absl::StrReplaceAll(\n            options.expectedPeerCert(),\n            {{\"\\r\", \"\"}, {\"\\n\", \"%0A\"}, {\" \", \"%20\"}, {\"+\", \"%2B\"}, {\"/\", \"%2F\"}, {\"=\", \"%3D\"}});\n        // Assert twice to ensure a cached value is returned and still valid.\n        EXPECT_EQ(urlencoded, server_connection->ssl()->urlEncodedPemEncodedPeerCertificate());\n        EXPECT_EQ(urlencoded, server_connection->ssl()->urlEncodedPemEncodedPeerCertificate());\n      }\n      if (!options.expectedPeerCertChain().empty()) {\n        std::string cert_chain = absl::StrReplaceAll(\n            options.expectedPeerCertChain(),\n            {{\"\\r\", \"\"}, {\"\\n\", \"%0A\"}, {\" \", \"%20\"}, {\"+\", \"%2B\"}, {\"/\", \"%2F\"}, {\"=\", \"%3D\"}});\n        // Assert twice to ensure a cached value is returned and still valid.\n        EXPECT_EQ(cert_chain, server_connection->ssl()->urlEncodedPemEncodedPeerCertificateChain());\n        EXPECT_EQ(cert_chain, server_connection->ssl()->urlEncodedPemEncodedPeerCertificateChain());\n      }\n      if (!options.expectedValidFromTimePeerCert().empty()) {\n        const std::string formatted = TestUtility::formatTime(\n            server_connection->ssl()->validFromPeerCertificate().value(), \"%b %e %H:%M:%S %Y GMT\");\n        EXPECT_EQ(options.expectedValidFromTimePeerCert(), formatted);\n      }\n      if (!options.expectedExpirationTimePeerCert().empty()) {\n        const std::string formatted = TestUtility::formatTime(\n            server_connection->ssl()->expirationPeerCertificate().value(), \"%b %e %H:%M:%S %Y GMT\");\n        EXPECT_EQ(options.expectedExpirationTimePeerCert(), formatted);\n      }\n      if (options.expectNoCert()) {\n        EXPECT_FALSE(server_connection->ssl()->peerCertificatePresented());\n        EXPECT_FALSE(server_connection->ssl()->validFromPeerCertificate().has_value());\n        EXPECT_FALSE(server_connection->ssl()->expirationPeerCertificate().has_value());\n        EXPECT_EQ(EMPTY_STRING, server_connection->ssl()->sha256PeerCertificateDigest());\n        EXPECT_EQ(EMPTY_STRING, server_connection->ssl()->sha1PeerCertificateDigest());\n        EXPECT_EQ(EMPTY_STRING, server_connection->ssl()->urlEncodedPemEncodedPeerCertificate());\n        EXPECT_EQ(EMPTY_STRING, server_connection->ssl()->subjectPeerCertificate());\n        EXPECT_EQ(std::vector<std::string>{}, server_connection->ssl()->dnsSansPeerCertificate());\n      }\n      if (options.expectNoCertChain()) {\n        EXPECT_EQ(EMPTY_STRING,\n                  server_connection->ssl()->urlEncodedPemEncodedPeerCertificateChain());\n      }\n\n      const SslHandshakerImpl* ssl_socket =\n          dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n      SSL* client_ssl_socket = ssl_socket->ssl();\n      const uint8_t* response_head;\n      size_t response_len;\n      SSL_get0_ocsp_response(client_ssl_socket, &response_head, &response_len);\n      std::string ocsp_response{reinterpret_cast<const char*>(response_head), response_len};\n      EXPECT_EQ(options.expectedOcspResponse(), ocsp_response);\n\n      // By default, the session is not created with session resumption. The\n      // client should see a session ID but the server should not.\n      EXPECT_EQ(EMPTY_STRING, server_connection->ssl()->sessionId());\n      EXPECT_NE(EMPTY_STRING, client_connection->ssl()->sessionId());\n\n      server_connection->close(Network::ConnectionCloseType::NoFlush);\n      client_connection->close(Network::ConnectionCloseType::NoFlush);\n      dispatcher->exit();\n    }\n  };\n\n  size_t close_count = 0;\n  auto close_second_time = [&close_count, &dispatcher]() {\n    if (++close_count == 2) {\n      dispatcher->exit();\n    }\n  };\n\n  if (options.expectSuccess()) {\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  } else {\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n    EXPECT_CALL(server_connection_callbacks, onEvent(options.expectedServerCloseEvent()))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n  }\n\n  if (options.expectedVerifyErrorCode() != -1) {\n    EXPECT_LOG_CONTAINS(\"debug\", X509_verify_cert_error_string(options.expectedVerifyErrorCode()),\n                        dispatcher->run(Event::Dispatcher::RunType::Block));\n  } else {\n    dispatcher->run(Event::Dispatcher::RunType::Block);\n  }\n\n  if (!options.expectedServerStats().empty()) {\n    EXPECT_EQ(1UL, server_stats_store.counter(options.expectedServerStats()).value());\n  }\n\n  if (!options.notExpectedClientStats().empty()) {\n    EXPECT_EQ(0, client_stats_store.counter(options.notExpectedClientStats()).value());\n  }\n\n  if (options.expectSuccess()) {\n    EXPECT_EQ(\"\", client_connection->transportFailureReason());\n    EXPECT_EQ(\"\", server_connection->transportFailureReason());\n  } else {\n    EXPECT_THAT(std::string(client_connection->transportFailureReason()),\n                ContainsRegex(options.expectedTransportFailureReasonContains()));\n    EXPECT_NE(\"\", server_connection->transportFailureReason());\n  }\n}\n\n/**\n * A class to hold the options for testUtilV2().\n */\nclass TestUtilOptionsV2 : public TestUtilOptionsBase {\npublic:\n  TestUtilOptionsV2(\n      const envoy::config::listener::v3::Listener& listener,\n      const envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext& client_ctx_proto,\n      bool expect_success, Network::Address::IpVersion version)\n      : TestUtilOptionsBase(expect_success, version), listener_(listener),\n        client_ctx_proto_(client_ctx_proto), transport_socket_options_(nullptr) {\n    if (expect_success) {\n      setExpectedServerStats(\"ssl.handshake\").setExpectedClientStats(\"ssl.handshake\");\n    } else {\n      setExpectedServerStats(\"ssl.fail_verify_error\")\n          .setExpectedClientStats(\"ssl.connection_error\");\n    }\n  }\n\n  const envoy::config::listener::v3::Listener& listener() const { return listener_; }\n  const envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext& clientCtxProto() const {\n    return client_ctx_proto_;\n  }\n  const std::string& expectedClientStats() const { return expected_client_stats_; }\n\n  TestUtilOptionsV2& setExpectedServerStats(const std::string& expected_server_stats) {\n    TestUtilOptionsBase::setExpectedServerStats(expected_server_stats);\n    return *this;\n  }\n\n  TestUtilOptionsV2& setExpectedClientCertUri(const std::string& expected_client_cert_uri) {\n    TestUtilOptionsBase::setExpectedClientCertUri(expected_client_cert_uri);\n    return *this;\n  }\n\n  TestUtilOptionsV2& setExpectedClientStats(const std::string& expected_client_stats) {\n    expected_client_stats_ = expected_client_stats;\n    return *this;\n  }\n\n  TestUtilOptionsV2& setClientSession(const std::string& client_session) {\n    client_session_ = client_session;\n    return *this;\n  }\n\n  const std::string& clientSession() const { return client_session_; }\n\n  TestUtilOptionsV2& setExpectedProtocolVersion(const std::string& expected_protocol_version) {\n    expected_protocol_version_ = expected_protocol_version;\n    return *this;\n  }\n\n  const std::string& expectedProtocolVersion() const { return expected_protocol_version_; }\n\n  TestUtilOptionsV2& setExpectedCiphersuite(const std::string& expected_cipher_suite) {\n    expected_cipher_suite_ = expected_cipher_suite;\n    return *this;\n  }\n\n  const std::string& expectedCiphersuite() const { return expected_cipher_suite_; }\n\n  TestUtilOptionsV2& setExpectedServerCertDigest(const std::string& expected_server_cert_digest) {\n    expected_server_cert_digest_ = expected_server_cert_digest;\n    return *this;\n  }\n\n  const std::string& expectedServerCertDigest() const { return expected_server_cert_digest_; }\n\n  TestUtilOptionsV2&\n  setExpectedRequestedServerName(const std::string& expected_requested_server_name) {\n    expected_requested_server_name_ = expected_requested_server_name;\n    return *this;\n  }\n\n  const std::string& expectedRequestedServerName() const { return expected_requested_server_name_; }\n\n  TestUtilOptionsV2& setExpectedALPNProtocol(const std::string& expected_alpn_protocol) {\n    expected_alpn_protocol_ = expected_alpn_protocol;\n    return *this;\n  }\n\n  const std::string& expectedALPNProtocol() const { return expected_alpn_protocol_; }\n\n  TestUtilOptionsV2& setTransportSocketOptions(\n      Network::TransportSocketOptionsConstSharedPtr transport_socket_options) {\n    transport_socket_options_ = transport_socket_options;\n    return *this;\n  }\n\n  Network::TransportSocketOptionsConstSharedPtr transportSocketOptions() const {\n    return transport_socket_options_;\n  }\n\n  TestUtilOptionsV2& setExpectedTransportFailureReasonContains(\n      const std::string& expected_transport_failure_reason_contains) {\n    expected_transport_failure_reason_contains_ = expected_transport_failure_reason_contains;\n    return *this;\n  }\n\n  const std::string& expectedTransportFailureReasonContains() const {\n    return expected_transport_failure_reason_contains_;\n  }\n\nprivate:\n  const envoy::config::listener::v3::Listener& listener_;\n  const envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext& client_ctx_proto_;\n  std::string expected_client_stats_;\n\n  std::string client_session_;\n  std::string expected_cipher_suite_;\n  std::string expected_protocol_version_;\n  std::string expected_server_cert_digest_;\n  std::string expected_requested_server_name_;\n  std::string expected_alpn_protocol_;\n  Network::TransportSocketOptionsConstSharedPtr transport_socket_options_;\n  std::string expected_transport_failure_reason_contains_;\n};\n\nvoid testUtilV2(const TestUtilOptionsV2& options) {\n  Event::SimulatedTimeSystem time_system;\n  ContextManagerImpl manager(*time_system);\n\n  // SNI-based selection logic isn't happening in SslSocket anymore.\n  ASSERT(options.listener().filter_chains().size() == 1);\n  const auto& filter_chain = options.listener().filter_chains(0);\n  std::vector<std::string> server_names(filter_chain.filter_chain_match().server_names().begin(),\n                                        filter_chain.filter_chain_match().server_names().end());\n  Stats::TestUtil::TestStore server_stats_store;\n  Api::ApiPtr server_api = Api::createApiForTest(server_stats_store, time_system);\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      server_factory_context;\n  NiceMock<Runtime::MockLoader> runtime;\n  ON_CALL(server_factory_context, api()).WillByDefault(ReturnRef(*server_api));\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  const envoy::config::core::v3::TransportSocket& transport_socket =\n      filter_chain.transport_socket();\n  ASSERT(transport_socket.has_typed_config());\n  transport_socket.typed_config().UnpackTo(&tls_context);\n\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(tls_context, server_factory_context);\n\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, server_names);\n  EXPECT_FALSE(server_ssl_socket_factory.usesProxyProtocolOptions());\n\n  Event::DispatcherPtr dispatcher(server_api->allocateDispatcher(\"test_thread\"));\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(options.version()));\n  NiceMock<Network::MockTcpListenerCallbacks> callbacks;\n  Network::ListenerPtr listener =\n      dispatcher->createListener(socket, callbacks, runtime, true, false);\n\n  Stats::TestUtil::TestStore client_stats_store;\n  Api::ApiPtr client_api = Api::createApiForTest(client_stats_store, time_system);\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      client_factory_context;\n  ON_CALL(client_factory_context, api()).WillByDefault(ReturnRef(*client_api));\n\n  auto client_cfg =\n      std::make_unique<ClientContextConfigImpl>(options.clientCtxProto(), client_factory_context);\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager,\n                                                   client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      client_ssl_socket_factory.createTransportSocket(options.transportSocketOptions()), nullptr);\n\n  if (!options.clientSession().empty()) {\n    const SslHandshakerImpl* ssl_socket =\n        dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n    SSL* client_ssl_socket = ssl_socket->ssl();\n    SSL_CTX* client_ssl_context = SSL_get_SSL_CTX(client_ssl_socket);\n    SSL_SESSION* client_ssl_session =\n        SSL_SESSION_from_bytes(reinterpret_cast<const uint8_t*>(options.clientSession().data()),\n                               options.clientSession().size(), client_ssl_context);\n    int rc = SSL_set_session(client_ssl_socket, client_ssl_session);\n    ASSERT(rc == 1);\n    SSL_SESSION_free(client_ssl_session);\n  }\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  NiceMock<StreamInfo::MockStreamInfo> stream_info;\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        std::string sni = options.transportSocketOptions() != nullptr &&\n                                  options.transportSocketOptions()->serverNameOverride().has_value()\n                              ? options.transportSocketOptions()->serverNameOverride().value()\n                              : options.clientCtxProto().sni();\n        socket->setRequestedServerName(sni);\n        Network::TransportSocketPtr transport_socket =\n            server_ssl_socket_factory.createTransportSocket(nullptr);\n        EXPECT_FALSE(transport_socket->startSecureTransport());\n        server_connection = dispatcher->createServerConnection(\n            std::move(socket), std::move(transport_socket), stream_info);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  size_t connect_count = 0;\n  auto connect_second_time = [&]() {\n    if (++connect_count == 2) {\n      if (!options.expectedServerCertDigest().empty()) {\n        EXPECT_EQ(options.expectedServerCertDigest(),\n                  client_connection->ssl()->sha256PeerCertificateDigest());\n      }\n      if (!options.expectedALPNProtocol().empty()) {\n        EXPECT_EQ(options.expectedALPNProtocol(), client_connection->nextProtocol());\n      }\n      EXPECT_EQ(options.expectedClientCertUri(), server_connection->ssl()->uriSanPeerCertificate());\n      const SslHandshakerImpl* ssl_socket =\n          dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n      SSL* client_ssl_socket = ssl_socket->ssl();\n      if (!options.expectedProtocolVersion().empty()) {\n        // Assert twice to ensure a cached value is returned and still valid.\n        EXPECT_EQ(options.expectedProtocolVersion(), client_connection->ssl()->tlsVersion());\n        EXPECT_EQ(options.expectedProtocolVersion(), client_connection->ssl()->tlsVersion());\n      }\n      if (!options.expectedCiphersuite().empty()) {\n        EXPECT_EQ(options.expectedCiphersuite(), client_connection->ssl()->ciphersuiteString());\n        const SSL_CIPHER* cipher =\n            SSL_get_cipher_by_value(client_connection->ssl()->ciphersuiteId());\n        EXPECT_NE(nullptr, cipher);\n        EXPECT_EQ(options.expectedCiphersuite(), SSL_CIPHER_get_name(cipher));\n      }\n\n      absl::optional<std::string> server_ssl_requested_server_name;\n      const SslHandshakerImpl* server_ssl_socket =\n          dynamic_cast<const SslHandshakerImpl*>(server_connection->ssl().get());\n      SSL* server_ssl = server_ssl_socket->ssl();\n      auto requested_server_name = SSL_get_servername(server_ssl, TLSEXT_NAMETYPE_host_name);\n      if (requested_server_name != nullptr) {\n        server_ssl_requested_server_name = std::string(requested_server_name);\n      }\n\n      if (!options.expectedRequestedServerName().empty()) {\n        EXPECT_TRUE(server_ssl_requested_server_name.has_value());\n        EXPECT_EQ(options.expectedRequestedServerName(), server_ssl_requested_server_name.value());\n      } else {\n        EXPECT_FALSE(server_ssl_requested_server_name.has_value());\n      }\n\n      const uint16_t tls_version = SSL_version(client_ssl_socket);\n      if (SSL3_VERSION <= tls_version && tls_version <= TLS1_2_VERSION) {\n        // Prior to TLS 1.3, one should be able to resume the session. With TLS\n        // 1.3, tickets come after the handshake and the SSL_SESSION on the\n        // client is a dummy object.\n        SSL_SESSION* client_ssl_session = SSL_get_session(client_ssl_socket);\n        EXPECT_TRUE(SSL_SESSION_is_resumable(client_ssl_session));\n      }\n      server_connection->close(Network::ConnectionCloseType::NoFlush);\n      client_connection->close(Network::ConnectionCloseType::NoFlush);\n      dispatcher->exit();\n    }\n  };\n\n  size_t close_count = 0;\n  auto close_second_time = [&close_count, &dispatcher]() {\n    if (++close_count == 2) {\n      dispatcher->exit();\n    }\n  };\n\n  if (options.expectSuccess()) {\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n          EXPECT_EQ(options.expectedRequestedServerName(),\n                    server_connection->requestedServerName());\n          connect_second_time();\n        }));\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  } else {\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n  }\n\n  dispatcher->run(Event::Dispatcher::RunType::Block);\n\n  if (!options.expectedServerStats().empty()) {\n    EXPECT_EQ(1UL, server_stats_store.counter(options.expectedServerStats()).value())\n        << options.expectedServerStats();\n  }\n\n  if (!options.expectedClientStats().empty()) {\n    EXPECT_EQ(1UL, client_stats_store.counter(options.expectedClientStats()).value());\n  }\n\n  if (options.expectSuccess()) {\n    EXPECT_EQ(\"\", client_connection->transportFailureReason());\n    EXPECT_EQ(\"\", server_connection->transportFailureReason());\n  } else {\n    EXPECT_THAT(std::string(client_connection->transportFailureReason()),\n                ContainsRegex(options.expectedTransportFailureReasonContains()));\n    EXPECT_NE(\"\", server_connection->transportFailureReason());\n  }\n}\n\nvoid updateFilterChain(\n    const envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext& tls_context,\n    envoy::config::listener::v3::FilterChain& filter_chain) {\n  filter_chain.mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_context);\n}\n\nstruct OptionalServerConfig {\n  absl::optional<std::string> cert_hash{};\n  absl::optional<std::string> trusted_ca{};\n  absl::optional<bool> allow_expired_cert{};\n};\n\nvoid configureServerAndExpiredClientCertificate(\n    envoy::config::listener::v3::Listener& listener,\n    envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext& client,\n    const OptionalServerConfig& server_config) {\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"));\n\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  if (server_config.trusted_ca.has_value()) {\n    server_validation_ctx->mutable_trusted_ca()->set_filename(\n        TestEnvironment::substitute(server_config.trusted_ca.value()));\n  } else {\n    server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n        \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  }\n  if (server_config.allow_expired_cert.has_value()) {\n    server_validation_ctx->set_allow_expired_certificate(server_config.allow_expired_cert.value());\n  }\n  if (server_config.cert_hash.has_value()) {\n    server_validation_ctx->add_verify_certificate_hash(server_config.cert_hash.value());\n  }\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/expired_san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/expired_san_uri_key.pem\"));\n}\n\nTestUtilOptionsV2 createProtocolTestOptions(\n    const envoy::config::listener::v3::Listener& listener,\n    const envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext& client_ctx,\n    Network::Address::IpVersion version, std::string protocol) {\n  std::string stats = \"ssl.versions.\" + protocol;\n  TestUtilOptionsV2 options(listener, client_ctx, true, version);\n  options.setExpectedServerStats(stats).setExpectedClientStats(stats);\n  return options.setExpectedProtocolVersion(protocol);\n}\n\n} // namespace\n\nclass SslSocketTest : public SslCertsTest,\n                      public testing::WithParamInterface<Network::Address::IpVersion> {\nprotected:\n  SslSocketTest()\n      : dispatcher_(api_->allocateDispatcher(\"test_thread\")),\n        stream_info_(api_->timeSource(), nullptr) {}\n\n  void testClientSessionResumption(const std::string& server_ctx_yaml,\n                                   const std::string& client_ctx_yaml, bool expect_reuse,\n                                   const Network::Address::IpVersion version);\n\n  NiceMock<Runtime::MockLoader> runtime_;\n  Event::DispatcherPtr dispatcher_;\n  StreamInfo::StreamInfoImpl stream_info_;\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, SslSocketTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(SslSocketTest, GetCertDigest) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedSha256Digest(TEST_NO_SAN_CERT_256_HASH)\n               .setExpectedSha1Digest(TEST_NO_SAN_CERT_1_HASH)\n               .setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, GetCertDigestInvalidFiles) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(\n      test_options.setExpectedSha256Digest(\"\").setExpectedSha1Digest(\"\").setExpectedSerialNumber(\n          \"\"));\n}\n\nTEST_P(SslSocketTest, GetCertDigestInline) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n\n  // From test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem.\n  server_cert->mutable_certificate_chain()->set_inline_bytes(\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\")));\n\n  // From test/extensions/transport_sockets/tls/test_data/san_dns_key.pem.\n  server_cert->mutable_private_key()->set_inline_bytes(\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\")));\n\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  // From test/extensions/transport_sockets/tls/test_data/ca_certificates.pem.\n  server_validation_ctx->mutable_trusted_ca()->set_inline_bytes(\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir \"\n          \"}}/test/extensions/transport_sockets/tls/test_data/ca_certificates.pem\")));\n\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client_ctx;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client_ctx.mutable_common_tls_context()->add_tls_certificates();\n\n  // From test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem.\n  client_cert->mutable_certificate_chain()->set_inline_bytes(\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\")));\n\n  // From test/extensions/transport_sockets/tls/test_data/san_uri_key.pem.\n  client_cert->mutable_private_key()->set_inline_bytes(\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\")));\n\n  TestUtilOptionsV2 test_options(listener, client_ctx, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_SAN_DNS_CERT_256_HASH));\n}\n\nTEST_P(SslSocketTest, GetCertDigestServerCertWithIntermediateCA) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_chain.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedSha256Digest(TEST_NO_SAN_CERT_256_HASH)\n               .setExpectedSha1Digest(TEST_NO_SAN_CERT_1_HASH)\n               .setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, GetCertDigestServerCertWithoutCommonName) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_only_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_only_dns_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedSha256Digest(TEST_NO_SAN_CERT_256_HASH)\n               .setExpectedSha1Digest(TEST_NO_SAN_CERT_1_HASH)\n               .setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, GetUriWithUriSan) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      match_typed_subject_alt_names:\n      - san_type: URI\n        matcher:\n          exact: \"spiffe://lyft.com/test-team\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n               .setExpectedSerialNumber(TEST_SAN_URI_CERT_SERIAL));\n}\n\n// Verify that IP SANs work with an IPv4 address specified in the validation context.\nTEST_P(SslSocketTest, Ipv4San) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamcacert.pem\"\n      match_typed_subject_alt_names:\n      - san_type: IP_ADDRESS\n        matcher:\n          exact: \"127.0.0.1\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamlocalhostcert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamlocalhostkey.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options);\n}\n\n// Verify that IP SANs work with an IPv6 address specified in the validation context.\nTEST_P(SslSocketTest, Ipv6San) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamcacert.pem\"\n      match_typed_subject_alt_names:\n      - san_type: IP_ADDRESS\n        matcher:\n          exact: \"::1\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamlocalhostcert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamlocalhostkey.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options);\n}\n\nTEST_P(SslSocketTest, GetNoUriWithDnsSan) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  // The SAN field only has DNS, expect \"\" for uriSanPeerCertificate().\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedSerialNumber(TEST_SAN_DNS_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, NoCert) {\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.no_certificate\")\n               .setExpectNoCert()\n               .setExpectNoCertChain());\n}\n\n// Prefer ECDSA certificate when multiple RSA certificates are present and the\n// client is RSA/ECDSA capable. We validate TLSv1.2 only here, since we validate\n// the e2e behavior on TLSv1.2/1.3 in ssl_integration_test.\nTEST_P(SslSocketTest, MultiCertPreferEcdsa) {\n  const std::string client_ctx_yaml = absl::StrCat(R\"EOF(\n    common_tls_context:\n      tls_params:\n        tls_minimum_protocol_version: TLSv1_2\n        tls_maximum_protocol_version: TLSv1_2\n        cipher_suites:\n        - ECDHE-ECDSA-AES128-GCM-SHA256\n        - ECDHE-RSA-AES128-GCM-SHA256\n      validation_context:\n        verify_certificate_hash: )EOF\",\n                                                   TEST_SELFSIGNED_ECDSA_P256_CERT_256_HASH);\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_key.pem\"\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options);\n}\n\nTEST_P(SslSocketTest, GetUriWithLocalUriSan) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedLocalUri(\"spiffe://lyft.com/test-team\")\n               .setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, GetSubjectsWithBothCerts) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  require_client_certificate: true\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL)\n               .setExpectedPeerIssuer(\n                   \"CN=Test CA,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedPeerSubject(\n                   \"CN=Test Server,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedLocalSubject(\n                   \"CN=Test Server,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\"));\n}\n\nTEST_P(SslSocketTest, GetPeerCert) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  require_client_certificate: true\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  std::string expected_peer_cert =\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"));\n  testUtil(test_options.setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL)\n               .setExpectedPeerIssuer(\n                   \"CN=Test CA,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedPeerSubject(\n                   \"CN=Test Server,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedLocalSubject(\n                   \"CN=Test Server,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedPeerCert(expected_peer_cert));\n}\n\nTEST_P(SslSocketTest, GetPeerCertAcceptUntrusted) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"\n      trust_chain_verification: ACCEPT_UNTRUSTED\n  require_client_certificate: true\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  std::string expected_peer_cert =\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"));\n  testUtil(test_options.setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL)\n               .setExpectedPeerIssuer(\n                   \"CN=Test CA,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedPeerSubject(\n                   \"CN=Test Server,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedLocalSubject(\n                   \"CN=Test Server,OU=Lyft Engineering,O=Lyft,L=San Francisco,ST=California,C=US\")\n               .setExpectedPeerCert(expected_peer_cert));\n}\n\nTEST_P(SslSocketTest, NoCertUntrustedNotPermitted) {\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"\n      trust_chain_verification: VERIFY_TRUST_CHAIN\n      verify_certificate_hash: \"0000000000000000000000000000000000000000000000000000000000000000\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\"));\n}\n\nTEST_P(SslSocketTest, NoCertUntrustedPermitted) {\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"\n      trust_chain_verification: ACCEPT_UNTRUSTED\n      verify_certificate_hash: \"0000000000000000000000000000000000000000000000000000000000000000\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.no_certificate\")\n               .setExpectNoCert()\n               .setExpectNoCertChain());\n}\n\nTEST_P(SslSocketTest, GetPeerCertChain) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_chain.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  require_client_certificate: true\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  std::string expected_peer_cert_chain =\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir \"\n          \"}}/test/extensions/transport_sockets/tls/test_data/no_san_chain.pem\"));\n  testUtil(test_options.setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL)\n               .setExpectedPeerCertChain(expected_peer_cert_chain));\n}\n\nTEST_P(SslSocketTest, GetIssueExpireTimesPeerCert) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  require_client_certificate: true\n)EOF\";\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedSerialNumber(TEST_NO_SAN_CERT_SERIAL)\n               .setExpectedValidFromTimePeerCert(TEST_NO_SAN_CERT_NOT_BEFORE)\n               .setExpectedExpirationTimePeerCert(TEST_NO_SAN_CERT_NOT_AFTER));\n}\n\nTEST_P(SslSocketTest, FailedClientAuthCaVerificationNoClientCert) {\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  require_client_certificate: true\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\"));\n}\n\nTEST_P(SslSocketTest, FailedClientAuthCaVerification) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY));\n}\n\nTEST_P(SslSocketTest, FailedClientAuthSanVerificationNoClientCert) {\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      match_typed_subject_alt_names:\n      - san_type: DNS\n        matcher:\n          exact: \"example.com\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\"));\n}\n\nTEST_P(SslSocketTest, FailedClientAuthSanVerification) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      match_typed_subject_alt_names:\n      - san_type: DNS\n        matcher:\n          exact: \"example.com\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_san\"));\n}\n\nTEST_P(SslSocketTest, X509ExtensionsCertificateSerialNumber) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/extensions_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/extensions_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/extensions_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/extensions_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  require_client_certificate: true\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedSerialNumber(TEST_EXTENSIONS_CERT_SERIAL));\n}\n\n// By default, expired certificates are not permitted.\nTEST_P(SslSocketTest, FailedClientCertificateDefaultExpirationVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  configureServerAndExpiredClientCertificate(listener, client, /*server_config=*/{});\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_EXPIRED\"));\n}\n\n// Expired certificates will not be accepted when explicitly disallowed via\n// allow_expired_certificate.\nTEST_P(SslSocketTest, FailedClientCertificateExpirationVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  OptionalServerConfig server_config;\n  server_config.allow_expired_cert = false;\n  configureServerAndExpiredClientCertificate(listener, client, server_config);\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_EXPIRED\"));\n}\n\n// Expired certificates will be accepted when explicitly allowed via allow_expired_certificate.\nTEST_P(SslSocketTest, ClientCertificateExpirationAllowedVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  OptionalServerConfig server_config;\n  server_config.allow_expired_cert = true;\n  configureServerAndExpiredClientCertificate(listener, client, server_config);\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_EXPIRED\"));\n}\n\n// Allow expired certificates, but add a certificate hash requirement so it still fails.\nTEST_P(SslSocketTest, FailedClientCertAllowExpiredBadHashVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  OptionalServerConfig server_config;\n  server_config.allow_expired_cert = true;\n  server_config.cert_hash = \"0000000000000000000000000000000000000000000000000000000000000000\";\n  configureServerAndExpiredClientCertificate(listener, client, server_config);\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_cert_hash\")\n                 .setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_EXPIRED\"));\n}\n\n// Allow expired certificates, but use the wrong CA so it should fail still.\nTEST_P(SslSocketTest, FailedClientCertAllowServerExpiredWrongCAVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  OptionalServerConfig server_config;\n  server_config.allow_expired_cert = true;\n  // Fake CA is not used to sign the client's certificate.\n  server_config.trusted_ca = \"{{ test_rundir \"\n                             \"}}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\";\n  configureServerAndExpiredClientCertificate(listener, client, server_config);\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedTransportFailureReasonContains(\"TLSV1_ALERT_UNKNOWN_CA\"));\n}\n\nTEST_P(SslSocketTest, ClientCertificateHashVerification) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = absl::StrCat(R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      verify_certificate_hash: \")EOF\",\n                                                   TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n               .setExpectedSerialNumber(TEST_SAN_URI_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, ClientCertificateHashVerificationNoCA) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = absl::StrCat(R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      verify_certificate_hash: \")EOF\",\n                                                   TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n               .setExpectedSerialNumber(TEST_SAN_URI_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, ClientCertificateHashListVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_hash(TEST_SAN_URI_CERT_256_HASH);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_SAN_DNS_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, ClientCertificateHashListVerificationNoCA) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_hash(TEST_SAN_URI_CERT_256_HASH);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_SAN_DNS_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashVerificationNoClientCertificate) {\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  const std::string server_ctx_yaml = absl::StrCat(R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      verify_certificate_hash: \")EOF\",\n                                                   TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\"));\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashVerificationNoCANoClientCertificate) {\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  const std::string server_ctx_yaml = absl::StrCat(R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      verify_certificate_hash: \")EOF\",\n                                                   TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\"));\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashVerificationWrongClientCertificate) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = absl::StrCat(R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      verify_certificate_hash: \")EOF\",\n                                                   TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_cert_hash\"));\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashVerificationNoCAWrongClientCertificate) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = absl::StrCat(R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      verify_certificate_hash: \")EOF\",\n                                                   TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_cert_hash\"));\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashVerificationWrongCA) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n)EOF\";\n\n  const std::string server_ctx_yaml = absl::StrCat(R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"\n      verify_certificate_hash: \")EOF\",\n                                                   TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY));\n}\n\nTEST_P(SslSocketTest, CertificatesWithPassword) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_key.pem\"));\n  server_cert->mutable_password()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_password.txt\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_hash(TEST_PASSWORD_PROTECTED_CERT_256_HASH);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_key.pem\"));\n  client_cert->mutable_password()->set_inline_string(\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir \"\n          \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_password.txt\")));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_PASSWORD_PROTECTED_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, Pkcs12CertificatesWithPassword) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n\n  server_cert->mutable_pkcs12()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_certkey.p12\"));\n  server_cert->mutable_password()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_password.txt\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_hash(TEST_PASSWORD_PROTECTED_CERT_256_HASH);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_pkcs12()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_certkey.p12\"));\n  client_cert->mutable_password()->set_inline_string(\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(\n          \"{{ test_rundir \"\n          \"}}/test/extensions/transport_sockets/tls/test_data/password_protected_password.txt\")));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_PASSWORD_PROTECTED_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, Pkcs12CertificatesWithoutPassword) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n\n  server_cert->mutable_pkcs12()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/san_dns3_certkeychain.p12\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_hash(TEST_SAN_DNS3_CERT_256_HASH);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_pkcs12()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/san_dns3_certkeychain.p12\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedServerCertDigest(TEST_SAN_DNS3_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, ClientCertificateSpkiVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_SAN_DNS_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, ClientCertificateSpkiVerificationNoCA) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_SAN_DNS_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationNoClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_HANDSHAKE_FAILURE\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationNoCANoClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_HANDSHAKE_FAILURE\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationWrongClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_cert_hash\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_UNKNOWN\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationNoCAWrongClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_cert_hash\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_UNKNOWN\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationWrongCA) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedTransportFailureReasonContains(\"TLSV1_ALERT_UNKNOWN_CA\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, ClientCertificateHashAndSpkiVerification) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_SAN_DNS_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, ClientCertificateHashAndSpkiVerificationNoCA) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_DNS_CERT_SPKI);\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n                 .setExpectedServerCertDigest(TEST_SAN_DNS_CERT_256_HASH));\n\n  // Works even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationNoClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_HANDSHAKE_FAILURE\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationNoCANoClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_no_cert\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_HANDSHAKE_FAILURE\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationWrongClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_cert_hash\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_UNKNOWN\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationNoCAWrongClientCertificate) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedServerStats(\"ssl.fail_verify_cert_hash\")\n                 .setExpectedTransportFailureReasonContains(\"SSLV3_ALERT_CERTIFICATE_UNKNOWN\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\nTEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationWrongCA) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"));\n  server_validation_ctx->add_verify_certificate_hash(\n      \"0000000000000000000000000000000000000000000000000000000000000000\");\n  server_validation_ctx->add_verify_certificate_spki(TEST_SAN_URI_CERT_SPKI);\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  TestUtilOptionsV2 test_options(listener, client, false, GetParam());\n  testUtilV2(test_options.setExpectedTransportFailureReasonContains(\"TLSV1_ALERT_UNKNOWN_CA\"));\n\n  // Fails even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n}\n\n// Make sure that we do not flush code and do an immediate close if we have not completed the\n// handshake.\nTEST_P(SslSocketTest, FlushCloseDuringHandshake) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_certificates.pem\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), tls_context);\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(tls_context, factory_context_);\n  ContextManagerImpl manager(time_system_);\n  Stats::TestUtil::TestStore server_stats_store;\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  Network::MockTcpListenerCallbacks callbacks;\n  Network::ListenerPtr listener =\n      dispatcher_->createListener(socket, callbacks, runtime_, true, false);\n\n  Network::ClientConnectionPtr client_connection = dispatcher_->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      Network::Test::createRawBufferSocket(), nullptr);\n  client_connection->connect();\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n        Buffer::OwnedImpl data(\"hello\");\n        server_connection->write(data, false);\n        server_connection->close(Network::ConnectionCloseType::FlushWrite);\n      }));\n\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\n// Test that half-close is sent and received correctly\nTEST_P(SslSocketTest, HalfClose) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_certificates.pem\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), server_tls_context);\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(server_tls_context, factory_context_);\n  ContextManagerImpl manager(time_system_);\n  Stats::TestUtil::TestStore server_stats_store;\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  Network::MockTcpListenerCallbacks listener_callbacks;\n  Network::ListenerPtr listener =\n      dispatcher_->createListener(socket, listener_callbacks, runtime_, true, false);\n  std::shared_ptr<Network::MockReadFilter> server_read_filter(new Network::MockReadFilter());\n  std::shared_ptr<Network::MockReadFilter> client_read_filter(new Network::MockReadFilter());\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), tls_context);\n  auto client_cfg = std::make_unique<ClientContextConfigImpl>(tls_context, factory_context_);\n  Stats::TestUtil::TestStore client_stats_store;\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager,\n                                                   client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher_->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      client_ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n  client_connection->enableHalfClose(true);\n  client_connection->addReadFilter(client_read_filter);\n  client_connection->connect();\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  EXPECT_CALL(listener_callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->enableHalfClose(true);\n        server_connection->addReadFilter(server_read_filter);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n        Buffer::OwnedImpl data(\"hello\");\n        server_connection->write(data, true);\n      }));\n\n  EXPECT_CALL(*server_read_filter, onNewConnection())\n      .WillOnce(Return(Network::FilterStatus::Continue));\n  EXPECT_CALL(*client_read_filter, onNewConnection())\n      .WillOnce(Return(Network::FilterStatus::Continue));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected));\n  EXPECT_CALL(*client_read_filter, onData(BufferStringEqual(\"hello\"), true))\n      .WillOnce(Invoke([&](Buffer::Instance&, bool) -> Network::FilterStatus {\n        Buffer::OwnedImpl buffer(\"world\");\n        client_connection->write(buffer, true);\n        return Network::FilterStatus::Continue;\n      }));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  EXPECT_CALL(*server_read_filter, onData(BufferStringEqual(\"world\"), true));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(SslSocketTest, ShutdownWithCloseNotify) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_certificates.pem\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), server_tls_context);\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(server_tls_context, factory_context_);\n  ContextManagerImpl manager(time_system_);\n  Stats::TestUtil::TestStore server_stats_store;\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  Network::MockTcpListenerCallbacks listener_callbacks;\n  Network::ListenerPtr listener =\n      dispatcher_->createListener(socket, listener_callbacks, runtime_, true, false);\n  std::shared_ptr<Network::MockReadFilter> server_read_filter(new Network::MockReadFilter());\n  std::shared_ptr<Network::MockReadFilter> client_read_filter(new Network::MockReadFilter());\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), tls_context);\n  auto client_cfg = std::make_unique<ClientContextConfigImpl>(tls_context, factory_context_);\n  Stats::TestUtil::TestStore client_stats_store;\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager,\n                                                   client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher_->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      client_ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->enableHalfClose(true);\n  client_connection->addReadFilter(client_read_filter);\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  EXPECT_CALL(listener_callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->enableHalfClose(true);\n        server_connection->addReadFilter(server_read_filter);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n  EXPECT_CALL(*server_read_filter, onNewConnection());\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        Buffer::OwnedImpl data(\"hello\");\n        server_connection->write(data, true);\n        EXPECT_EQ(data.length(), 0);\n      }));\n\n  EXPECT_CALL(*client_read_filter, onNewConnection())\n      .WillOnce(Return(Network::FilterStatus::Continue));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected));\n  EXPECT_CALL(*client_read_filter, onData(BufferStringEqual(\"hello\"), true))\n      .WillOnce(Invoke([&](Buffer::Instance& read_buffer, bool) -> Network::FilterStatus {\n        read_buffer.drain(read_buffer.length());\n        client_connection->close(Network::ConnectionCloseType::NoFlush);\n        return Network::FilterStatus::StopIteration;\n      }));\n  EXPECT_CALL(*server_read_filter, onData(_, true));\n\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        server_connection->close(Network::ConnectionCloseType::NoFlush);\n        dispatcher_->exit();\n      }));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(SslSocketTest, ShutdownWithoutCloseNotify) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_certificates.pem\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), server_tls_context);\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(server_tls_context, factory_context_);\n  ContextManagerImpl manager(time_system_);\n  Stats::TestUtil::TestStore server_stats_store;\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  Network::MockTcpListenerCallbacks listener_callbacks;\n  Network::ListenerPtr listener =\n      dispatcher_->createListener(socket, listener_callbacks, runtime_, true, false);\n  std::shared_ptr<Network::MockReadFilter> server_read_filter(new Network::MockReadFilter());\n  std::shared_ptr<Network::MockReadFilter> client_read_filter(new Network::MockReadFilter());\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), tls_context);\n  auto client_cfg = std::make_unique<ClientContextConfigImpl>(tls_context, factory_context_);\n  Stats::TestUtil::TestStore client_stats_store;\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager,\n                                                   client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher_->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      client_ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->enableHalfClose(true);\n  client_connection->addReadFilter(client_read_filter);\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  EXPECT_CALL(listener_callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->enableHalfClose(true);\n        server_connection->addReadFilter(server_read_filter);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        Buffer::OwnedImpl data(\"hello\");\n        server_connection->write(data, false);\n        EXPECT_EQ(data.length(), 0);\n        // Calling close(FlushWrite) in onEvent() callback results in PostIoAction::Close,\n        // after which the connection is closed without write ready event being delivered,\n        // and with all outstanding data (here, \"hello\") being lost.\n      }));\n\n  EXPECT_CALL(*client_read_filter, onNewConnection())\n      .WillOnce(Return(Network::FilterStatus::Continue));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected));\n  EXPECT_CALL(*client_read_filter, onData(BufferStringEqual(\"hello\"), false))\n      .WillOnce(Invoke([&](Buffer::Instance& read_buffer, bool) -> Network::FilterStatus {\n        read_buffer.drain(read_buffer.length());\n        // Close without sending close_notify alert.\n        const SslHandshakerImpl* ssl_socket =\n            dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n        EXPECT_EQ(ssl_socket->state(), Ssl::SocketState::HandshakeComplete);\n        SSL_set_quiet_shutdown(ssl_socket->ssl(), 1);\n        client_connection->close(Network::ConnectionCloseType::FlushWrite);\n        return Network::FilterStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(*server_read_filter, onNewConnection())\n      .WillOnce(Return(Network::FilterStatus::Continue));\n  EXPECT_CALL(*server_read_filter, onData(BufferStringEqual(\"\"), true))\n      .WillOnce(Invoke([&](Buffer::Instance&, bool) -> Network::FilterStatus {\n        // Close without sending close_notify alert.\n        const SslHandshakerImpl* ssl_socket =\n            dynamic_cast<const SslHandshakerImpl*>(server_connection->ssl().get());\n        EXPECT_EQ(ssl_socket->state(), Ssl::SocketState::HandshakeComplete);\n        SSL_set_quiet_shutdown(ssl_socket->ssl(), 1);\n        server_connection->close(Network::ConnectionCloseType::NoFlush);\n        return Network::FilterStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(SslSocketTest, ClientAuthMultipleCAs) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_certificates.pem\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), server_tls_context);\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(server_tls_context, factory_context_);\n  ContextManagerImpl manager(time_system_);\n  Stats::TestUtil::TestStore server_stats_store;\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  Network::MockTcpListenerCallbacks callbacks;\n  Network::ListenerPtr listener =\n      dispatcher_->createListener(socket, callbacks, runtime_, true, false);\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), tls_context);\n  auto client_cfg = std::make_unique<ClientContextConfigImpl>(tls_context, factory_context_);\n  Stats::TestUtil::TestStore client_stats_store;\n  ClientSslSocketFactory ssl_socket_factory(std::move(client_cfg), manager, client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher_->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n\n  // Verify that server sent list with 2 acceptable client certificate CA names.\n  const SslHandshakerImpl* ssl_socket =\n      dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n  SSL_set_cert_cb(\n      ssl_socket->ssl(),\n      [](SSL* ssl, void*) -> int {\n        STACK_OF(X509_NAME)* list = SSL_get_client_CA_list(ssl);\n        EXPECT_NE(nullptr, list);\n        EXPECT_EQ(2U, sk_X509_NAME_num(list));\n        return 1;\n      },\n      nullptr);\n\n  client_connection->connect();\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        server_connection->close(Network::ConnectionCloseType::NoFlush);\n        client_connection->close(Network::ConnectionCloseType::NoFlush);\n        dispatcher_->exit();\n      }));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(1UL, server_stats_store.counter(\"ssl.handshake\").value());\n}\n\nnamespace {\n\n// Test connecting with a client to server1, then trying to reuse the session on server2\nvoid testTicketSessionResumption(const std::string& server_ctx_yaml1,\n                                 const std::vector<std::string>& server_names1,\n                                 const std::string& server_ctx_yaml2,\n                                 const std::vector<std::string>& server_names2,\n                                 const std::string& client_ctx_yaml, bool expect_reuse,\n                                 const Network::Address::IpVersion ip_version,\n                                 const uint32_t expected_lifetime_hint = 0) {\n  Event::SimulatedTimeSystem time_system;\n  ContextManagerImpl manager(*time_system);\n\n  Stats::TestUtil::TestStore server_stats_store;\n  Api::ApiPtr server_api = Api::createApiForTest(server_stats_store, time_system);\n  NiceMock<Runtime::MockLoader> runtime;\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      server_factory_context;\n  ON_CALL(server_factory_context, api()).WillByDefault(ReturnRef(*server_api));\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context1;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml1), server_tls_context1);\n  auto server_cfg1 =\n      std::make_unique<ServerContextConfigImpl>(server_tls_context1, server_factory_context);\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context2;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml2), server_tls_context2);\n  auto server_cfg2 =\n      std::make_unique<ServerContextConfigImpl>(server_tls_context2, server_factory_context);\n  ServerSslSocketFactory server_ssl_socket_factory1(std::move(server_cfg1), manager,\n                                                    server_stats_store, server_names1);\n  ServerSslSocketFactory server_ssl_socket_factory2(std::move(server_cfg2), manager,\n                                                    server_stats_store, server_names2);\n\n  auto socket1 = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(ip_version));\n  auto socket2 = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(ip_version));\n  NiceMock<Network::MockTcpListenerCallbacks> callbacks;\n  Event::DispatcherPtr dispatcher(server_api->allocateDispatcher(\"test_thread\"));\n  Network::ListenerPtr listener1 =\n      dispatcher->createListener(socket1, callbacks, runtime, true, false);\n  Network::ListenerPtr listener2 =\n      dispatcher->createListener(socket2, callbacks, runtime, true, false);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), client_tls_context);\n\n  Stats::TestUtil::TestStore client_stats_store;\n  Api::ApiPtr client_api = Api::createApiForTest(client_stats_store, time_system);\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      client_factory_context;\n  ON_CALL(client_factory_context, api()).WillByDefault(ReturnRef(*client_api));\n\n  auto client_cfg =\n      std::make_unique<ClientContextConfigImpl>(client_tls_context, client_factory_context);\n  ClientSslSocketFactory ssl_socket_factory(std::move(client_cfg), manager, client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher->createClientConnection(\n      socket1->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  SSL_SESSION* ssl_session = nullptr;\n  Network::ConnectionPtr server_connection;\n  StreamInfo::StreamInfoImpl stream_info(time_system, nullptr);\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        Network::TransportSocketFactory& tsf =\n            socket->connectionInfoProvider().localAddress() ==\n                    socket1->connectionInfoProvider().localAddress()\n                ? server_ssl_socket_factory1\n                : server_ssl_socket_factory2;\n        server_connection = dispatcher->createServerConnection(\n            std::move(socket), tsf.createTransportSocket(nullptr), stream_info);\n      }));\n\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        const SslHandshakerImpl* ssl_socket =\n            dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n        ssl_session = SSL_get1_session(ssl_socket->ssl());\n        EXPECT_TRUE(SSL_SESSION_is_resumable(ssl_session));\n        if (expected_lifetime_hint) {\n          auto lifetime_hint = SSL_SESSION_get_ticket_lifetime_hint(ssl_session);\n          EXPECT_TRUE(lifetime_hint <= expected_lifetime_hint);\n        }\n        client_connection->close(Network::ConnectionCloseType::NoFlush);\n        server_connection->close(Network::ConnectionCloseType::NoFlush);\n        dispatcher->exit();\n      }));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n\n  dispatcher->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(0UL, server_stats_store.counter(\"ssl.session_reused\").value());\n  EXPECT_EQ(0UL, client_stats_store.counter(\"ssl.session_reused\").value());\n\n  client_connection = dispatcher->createClientConnection(\n      socket2->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  const SslHandshakerImpl* ssl_socket =\n      dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n  SSL_set_session(ssl_socket->ssl(), ssl_session);\n  SSL_SESSION_free(ssl_session);\n\n  client_connection->connect();\n\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  StreamInfo::StreamInfoImpl stream_info2(time_system, nullptr);\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        Network::TransportSocketFactory& tsf =\n            socket->connectionInfoProvider().localAddress() ==\n                    socket1->connectionInfoProvider().localAddress()\n                ? server_ssl_socket_factory1\n                : server_ssl_socket_factory2;\n        server_connection = dispatcher->createServerConnection(\n            std::move(socket), tsf.createTransportSocket(nullptr), stream_info2);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  // Different tests have different order of whether client or server gets Connected event\n  // first, so always wait until both have happened.\n  size_t connect_count = 0;\n  auto connect_second_time = [&connect_count, &dispatcher, &server_connection, &client_connection,\n                              expect_reuse]() {\n    connect_count++;\n    if (connect_count == 2) {\n      if (expect_reuse) {\n        EXPECT_NE(EMPTY_STRING, server_connection->ssl()->sessionId());\n        EXPECT_EQ(server_connection->ssl()->sessionId(), client_connection->ssl()->sessionId());\n      } else {\n        EXPECT_EQ(EMPTY_STRING, server_connection->ssl()->sessionId());\n      }\n      client_connection->close(Network::ConnectionCloseType::NoFlush);\n      server_connection->close(Network::ConnectionCloseType::NoFlush);\n      dispatcher->exit();\n    }\n  };\n\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n\n  dispatcher->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(expect_reuse ? 1UL : 0UL, server_stats_store.counter(\"ssl.session_reused\").value());\n  EXPECT_EQ(expect_reuse ? 1UL : 0UL, client_stats_store.counter(\"ssl.session_reused\").value());\n}\n\nvoid testSupportForStatelessSessionResumption(const std::string& server_ctx_yaml,\n                                              const std::string& client_ctx_yaml,\n                                              bool expect_support,\n                                              const Network::Address::IpVersion ip_version) {\n  Event::SimulatedTimeSystem time_system;\n  ContextManagerImpl manager(*time_system);\n\n  Stats::IsolatedStoreImpl server_stats_store;\n  Api::ApiPtr server_api = Api::createApiForTest(server_stats_store, time_system);\n  NiceMock<Runtime::MockLoader> runtime;\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      server_factory_context;\n  ON_CALL(server_factory_context, api()).WillByDefault(ReturnRef(*server_api));\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), server_tls_context);\n  auto server_cfg =\n      std::make_unique<ServerContextConfigImpl>(server_tls_context, server_factory_context);\n\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, {});\n  auto tcp_socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(ip_version));\n  NiceMock<Network::MockTcpListenerCallbacks> callbacks;\n  Event::DispatcherPtr dispatcher(server_api->allocateDispatcher(\"test_thread\"));\n  Network::ListenerPtr listener =\n      dispatcher->createListener(tcp_socket, callbacks, runtime, true, false);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client_tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), client_tls_context);\n\n  Stats::IsolatedStoreImpl client_stats_store;\n  Api::ApiPtr client_api = Api::createApiForTest(client_stats_store, time_system);\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      client_factory_context;\n  ON_CALL(client_factory_context, api()).WillByDefault(ReturnRef(*client_api));\n\n  auto client_cfg =\n      std::make_unique<ClientContextConfigImpl>(client_tls_context, client_factory_context);\n  ClientSslSocketFactory ssl_socket_factory(std::move(client_cfg), manager, client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher->createClientConnection(\n      tcp_socket->connectionInfoProvider().localAddress(),\n      Network::Address::InstanceConstSharedPtr(), ssl_socket_factory.createTransportSocket(nullptr),\n      nullptr);\n\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  StreamInfo::StreamInfoImpl stream_info(time_system, nullptr);\n  Network::ConnectionPtr server_connection;\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info);\n\n        const SslHandshakerImpl* ssl_socket =\n            dynamic_cast<const SslHandshakerImpl*>(server_connection->ssl().get());\n        SSL* server_ssl_socket = ssl_socket->ssl();\n        SSL_CTX* server_ssl_context = SSL_get_SSL_CTX(server_ssl_socket);\n        if (expect_support) {\n          EXPECT_EQ(0, (SSL_CTX_get_options(server_ssl_context) & SSL_OP_NO_TICKET));\n        } else {\n          EXPECT_EQ(SSL_OP_NO_TICKET, (SSL_CTX_get_options(server_ssl_context) & SSL_OP_NO_TICKET));\n        }\n      }));\n\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        client_connection->close(Network::ConnectionCloseType::NoFlush);\n        server_connection->close(Network::ConnectionCloseType::NoFlush);\n        dispatcher->exit();\n      }));\n\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  dispatcher->run(Event::Dispatcher::RunType::Block);\n}\n\n} // namespace\n\nTEST_P(SslSocketTest, TicketSessionResumption) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml, {}, server_ctx_yaml, {}, client_ctx_yaml, true,\n                              GetParam());\n}\n\nTEST_P(SslSocketTest, TicketSessionResumptionCustomTimeout) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_0\n      tls_maximum_protocol_version: TLSv1_2\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n  session_timeout: 2307s\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml, {}, server_ctx_yaml, {}, client_ctx_yaml, true,\n                              GetParam(), 2307);\n}\n\nTEST_P(SslSocketTest, TicketSessionResumptionWithClientCA) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml, {}, server_ctx_yaml, {}, client_ctx_yaml, true,\n                              GetParam());\n}\n\nTEST_P(SslSocketTest, TicketSessionResumptionRotateKey) {\n  const std::string server_ctx_yaml1 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string server_ctx_yaml2 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_b\"\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, true,\n                              GetParam());\n}\n\nTEST_P(SslSocketTest, TicketSessionResumptionWrongKey) {\n  const std::string server_ctx_yaml1 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string server_ctx_yaml2 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_b\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, false,\n                              GetParam());\n}\n\n// Sessions cannot be resumed even though the server certificates are the same,\n// because of the different SNI requirements.\nTEST_P(SslSocketTest, TicketSessionResumptionDifferentServerNames) {\n  const std::string server_ctx_yaml1 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string server_ctx_yaml2 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  std::vector<std::string> server_names1 = {\"server1.example.com\"};\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, server_names1, server_ctx_yaml2, {},\n                              client_ctx_yaml, false, GetParam());\n}\n\n// Sessions cannot be resumed even though the server certificates are the same,\n// because of the different `verify_certificate_hash` settings.\nTEST_P(SslSocketTest, TicketSessionResumptionDifferentVerifyCertHash) {\n  const std::string server_ctx_yaml1 = absl::StrCat(R\"EOF(\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      verify_certificate_hash:\n        - \")EOF\",\n                                                    TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  const std::string server_ctx_yaml2 = absl::StrCat(R\"EOF(\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      verify_certificate_hash:\n        - \"0000000000000000000000000000000000000000000000000000000000000000\"\n        - \")EOF\",\n                                                    TEST_SAN_URI_CERT_256_HASH, \"\\\"\");\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n)EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml1, {}, client_ctx_yaml, true,\n                              GetParam());\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, false,\n                              GetParam());\n}\n\n// Sessions cannot be resumed even though the server certificates are the same,\n// because of the different `verify_certificate_spki` settings.\nTEST_P(SslSocketTest, TicketSessionResumptionDifferentVerifyCertSpki) {\n  const std::string server_ctx_yaml1 = absl::StrCat(R\"EOF(\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      verify_certificate_spki:\n        - \")EOF\",\n                                                    TEST_SAN_URI_CERT_SPKI, \"\\\"\");\n\n  const std::string server_ctx_yaml2 = absl::StrCat(R\"EOF(\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      verify_certificate_spki:\n        - \"NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=\"\n        - \")EOF\",\n                                                    TEST_SAN_URI_CERT_SPKI, \"\\\"\");\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n)EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml1, {}, client_ctx_yaml, true,\n                              GetParam());\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, false,\n                              GetParam());\n}\n\n// Sessions cannot be resumed even though the server certificates are the same,\n// because of the different `match_subject_alt_names` settings.\nTEST_P(SslSocketTest, TicketSessionResumptionDifferentMatchSAN) {\n  const std::string server_ctx_yaml1 = R\"EOF(\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      match_subject_alt_names:\n        - exact: \"spiffe://lyft.com/test-team\"\n)EOF\";\n\n  const std::string server_ctx_yaml2 = R\"EOF(\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      match_subject_alt_names:\n        - prefix: \"spiffe://lyft.com/test-team\"\n\")EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n)EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml1, {}, client_ctx_yaml, true,\n                              GetParam());\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, false,\n                              GetParam());\n}\n\n// Sessions can be resumed because the server certificates are different but the CN/SANs and\n// issuer are identical\nTEST_P(SslSocketTest, TicketSessionResumptionDifferentServerCert) {\n  const std::string server_ctx_yaml1 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string server_ctx_yaml2 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, true,\n                              GetParam());\n}\n\n// Sessions cannot be resumed because the server certificates are different, CN/SANs are identical,\n// but the issuer is different.\nTEST_P(SslSocketTest, TicketSessionResumptionDifferentServerCertIntermediateCA) {\n  const std::string server_ctx_yaml1 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string server_ctx_yaml2 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_chain.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, false,\n                              GetParam());\n}\n\n// Sessions cannot be resumed because the server certificates are different and the SANs\n// are not identical\nTEST_P(SslSocketTest, TicketSessionResumptionDifferentServerCertDifferentSAN) {\n  const std::string server_ctx_yaml1 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string server_ctx_yaml2 = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_multiple_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_multiple_dns_key.pem\"\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testTicketSessionResumption(server_ctx_yaml1, {}, server_ctx_yaml2, {}, client_ctx_yaml, false,\n                              GetParam());\n}\n\nTEST_P(SslSocketTest, StatelessSessionResumptionDisabled) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  disable_stateless_session_resumption: true\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testSupportForStatelessSessionResumption(server_ctx_yaml, client_ctx_yaml, false, GetParam());\n}\n\nTEST_P(SslSocketTest, SatelessSessionResumptionEnabledExplicitly) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n  disable_stateless_session_resumption: false\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testSupportForStatelessSessionResumption(server_ctx_yaml, client_ctx_yaml, true, GetParam());\n}\n\nTEST_P(SslSocketTest, StatelessSessionResumptionEnabledByDefault) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n    common_tls_context:\n  )EOF\";\n\n  testSupportForStatelessSessionResumption(server_ctx_yaml, client_ctx_yaml, true, GetParam());\n}\n\n// Test that if two listeners use the same cert and session ticket key, but\n// different client CA, that sessions cannot be resumed.\nTEST_P(SslSocketTest, ClientAuthCrossListenerSessionResumption) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n  require_client_certificate: true\n)EOF\";\n\n  const std::string server2_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"\n  require_client_certificate: true\n  session_ticket_keys:\n    keys:\n      filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ticket_key_a\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context1;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), tls_context1);\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(tls_context1, factory_context_);\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context2;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server2_ctx_yaml), tls_context2);\n  auto server2_cfg = std::make_unique<ServerContextConfigImpl>(tls_context2, factory_context_);\n  ContextManagerImpl manager(time_system_);\n  Stats::TestUtil::TestStore server_stats_store;\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n  ServerSslSocketFactory server2_ssl_socket_factory(std::move(server2_cfg), manager,\n                                                    server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  auto socket2 = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  Network::MockTcpListenerCallbacks callbacks;\n  Network::ListenerPtr listener =\n      dispatcher_->createListener(socket, callbacks, runtime_, true, false);\n  Network::ListenerPtr listener2 =\n      dispatcher_->createListener(socket2, callbacks, runtime_, true, false);\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), tls_context);\n\n  auto client_cfg = std::make_unique<ClientContextConfigImpl>(tls_context, factory_context_);\n  Stats::TestUtil::TestStore client_stats_store;\n  ClientSslSocketFactory ssl_socket_factory(std::move(client_cfg), manager, client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher_->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  SSL_SESSION* ssl_session = nullptr;\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& accepted_socket) -> void {\n        Network::TransportSocketFactory& tsf =\n            accepted_socket->connectionInfoProvider().localAddress() ==\n                    socket->connectionInfoProvider().localAddress()\n                ? server_ssl_socket_factory\n                : server2_ssl_socket_factory;\n        server_connection = dispatcher_->createServerConnection(\n            std::move(accepted_socket), tsf.createTransportSocket(nullptr), stream_info_);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        const SslHandshakerImpl* ssl_socket =\n            dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n        ssl_session = SSL_get1_session(ssl_socket->ssl());\n        EXPECT_TRUE(SSL_SESSION_is_resumable(ssl_session));\n        server_connection->close(Network::ConnectionCloseType::NoFlush);\n        client_connection->close(Network::ConnectionCloseType::NoFlush);\n        dispatcher_->exit();\n      }));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(1UL, server_stats_store.counter(\"ssl.handshake\").value());\n  EXPECT_EQ(1UL, client_stats_store.counter(\"ssl.handshake\").value());\n\n  client_connection = dispatcher_->createClientConnection(\n      socket2->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  const SslHandshakerImpl* ssl_socket =\n      dynamic_cast<const SslHandshakerImpl*>(client_connection->ssl().get());\n  SSL_set_session(ssl_socket->ssl(), ssl_session);\n  SSL_SESSION_free(ssl_session);\n\n  client_connection->connect();\n\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& accepted_socket) -> void {\n        Network::TransportSocketFactory& tsf =\n            accepted_socket->connectionInfoProvider().localAddress() ==\n                    socket->connectionInfoProvider().localAddress()\n                ? server_ssl_socket_factory\n                : server2_ssl_socket_factory;\n        server_connection = dispatcher_->createServerConnection(\n            std::move(accepted_socket), tsf.createTransportSocket(nullptr), stream_info_);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(1UL, client_stats_store.counter(\"ssl.connection_error\").value());\n  EXPECT_EQ(0UL, server_stats_store.counter(\"ssl.session_reused\").value());\n  EXPECT_EQ(0UL, client_stats_store.counter(\"ssl.session_reused\").value());\n}\n\nvoid SslSocketTest::testClientSessionResumption(const std::string& server_ctx_yaml,\n                                                const std::string& client_ctx_yaml,\n                                                bool expect_reuse,\n                                                const Network::Address::IpVersion version) {\n  InSequence s;\n\n  ContextManagerImpl manager(time_system_);\n\n  Stats::TestUtil::TestStore server_stats_store;\n  Api::ApiPtr server_api = Api::createApiForTest(server_stats_store, time_system_);\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      server_factory_context;\n  ON_CALL(server_factory_context, api()).WillByDefault(ReturnRef(*server_api));\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext server_ctx_proto;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), server_ctx_proto);\n  auto server_cfg =\n      std::make_unique<ServerContextConfigImpl>(server_ctx_proto, server_factory_context);\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(version));\n  NiceMock<Network::MockTcpListenerCallbacks> callbacks;\n  Api::ApiPtr api = Api::createApiForTest(server_stats_store, time_system_);\n  Event::DispatcherPtr dispatcher(server_api->allocateDispatcher(\"test_thread\"));\n  Network::ListenerPtr listener =\n      dispatcher->createListener(socket, callbacks, runtime_, true, false);\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client_ctx_proto;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml), client_ctx_proto);\n\n  Stats::TestUtil::TestStore client_stats_store;\n  Api::ApiPtr client_api = Api::createApiForTest(client_stats_store, time_system_);\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext>\n      client_factory_context;\n  ON_CALL(client_factory_context, api()).WillByDefault(ReturnRef(*client_api));\n\n  auto client_cfg =\n      std::make_unique<ClientContextConfigImpl>(client_ctx_proto, client_factory_context);\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager,\n                                                   client_stats_store);\n  Network::ClientConnectionPtr client_connection = dispatcher->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      client_ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n\n  Network::MockConnectionCallbacks client_connection_callbacks;\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  size_t connect_count = 0;\n  auto connect_second_time = [&connect_count, &server_connection]() {\n    if (++connect_count == 2) {\n      server_connection->close(Network::ConnectionCloseType::NoFlush);\n    }\n  };\n\n  size_t close_count = 0;\n  auto close_second_time = [&close_count, &dispatcher]() {\n    if (++close_count == 2) {\n      dispatcher->exit();\n    }\n  };\n\n  // WillRepeatedly doesn't work with InSequence.\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  const bool expect_tls13 =\n      client_ctx_proto.common_tls_context().tls_params().tls_maximum_protocol_version() ==\n          envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3 &&\n      server_ctx_proto.common_tls_context().tls_params().tls_maximum_protocol_version() ==\n          envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3;\n\n  // The order of \"Connected\" events depends on the version of the TLS protocol (1.3 or older).\n  if (expect_tls13) {\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n  } else {\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n  }\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n\n  dispatcher->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(0UL, server_stats_store.counter(\"ssl.session_reused\").value());\n  EXPECT_EQ(0UL, client_stats_store.counter(\"ssl.session_reused\").value());\n\n  connect_count = 0;\n  close_count = 0;\n\n  client_connection = dispatcher->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      client_ssl_socket_factory.createTransportSocket(nullptr), nullptr);\n  client_connection->addConnectionCallbacks(client_connection_callbacks);\n  client_connection->connect();\n\n  // WillRepeatedly doesn't work with InSequence.\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  // The order of \"Connected\" events depends on the version of the TLS protocol (1.3 or older),\n  // and whether or not the session was successfully resumed.\n  if (expect_tls13 || expect_reuse) {\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n  } else {\n    EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n    EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { connect_second_time(); }));\n  }\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n  EXPECT_CALL(client_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { close_second_time(); }));\n\n  dispatcher->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(expect_reuse ? 1UL : 0UL, server_stats_store.counter(\"ssl.session_reused\").value());\n  EXPECT_EQ(expect_reuse ? 1UL : 0UL, client_stats_store.counter(\"ssl.session_reused\").value());\n}\n\n// Test client session resumption using default settings (should be enabled).\nTEST_P(SslSocketTest, ClientSessionResumptionDefault) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n)EOF\";\n\n  testClientSessionResumption(server_ctx_yaml, client_ctx_yaml, true, GetParam());\n}\n\n// Make sure client session resumption is not happening with TLS 1.0-1.2 when it's disabled.\nTEST_P(SslSocketTest, ClientSessionResumptionDisabledTls12) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_0\n      tls_maximum_protocol_version: TLSv1_2\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n  max_session_keys: 0\n)EOF\";\n\n  testClientSessionResumption(server_ctx_yaml, client_ctx_yaml, false, GetParam());\n}\n\n// Test client session resumption with TLS 1.0-1.2.\nTEST_P(SslSocketTest, ClientSessionResumptionEnabledTls12) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_0\n      tls_maximum_protocol_version: TLSv1_2\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_0\n      tls_maximum_protocol_version: TLSv1_2\n  max_session_keys: 2\n)EOF\";\n\n  testClientSessionResumption(server_ctx_yaml, client_ctx_yaml, true, GetParam());\n}\n\n// Make sure client session resumption is not happening with TLS 1.3 when it's disabled.\nTEST_P(SslSocketTest, ClientSessionResumptionDisabledTls13) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_3\n      tls_maximum_protocol_version: TLSv1_3\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_3\n      tls_maximum_protocol_version: TLSv1_3\n  max_session_keys: 0\n)EOF\";\n\n  testClientSessionResumption(server_ctx_yaml, client_ctx_yaml, false, GetParam());\n}\n\n// Test client session resumption with TLS 1.3 (it's different than in older versions of TLS).\nTEST_P(SslSocketTest, ClientSessionResumptionEnabledTls13) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_3\n      tls_maximum_protocol_version: TLSv1_3\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n)EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      tls_minimum_protocol_version: TLSv1_3\n      tls_maximum_protocol_version: TLSv1_3\n  max_session_keys: 2\n)EOF\";\n\n  testClientSessionResumption(server_ctx_yaml, client_ctx_yaml, true, GetParam());\n}\n\nTEST_P(SslSocketTest, SslError) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/fake_ca_cert.pem\"\n      verify_certificate_hash: \"7B:0C:3F:0D:97:0E:FC:16:70:11:7A:0C:35:75:54:6B:17:AB:CF:20:D8:AA:A0:ED:87:08:0F:FB:60:4C:40:77\"\n)EOF\";\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml), tls_context);\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(tls_context, factory_context_);\n  ContextManagerImpl manager(time_system_);\n  Stats::TestUtil::TestStore server_stats_store;\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager,\n                                                   server_stats_store, std::vector<std::string>{});\n\n  auto socket = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n      Network::Test::getCanonicalLoopbackAddress(GetParam()));\n  Network::MockTcpListenerCallbacks callbacks;\n  Network::ListenerPtr listener =\n      dispatcher_->createListener(socket, callbacks, runtime_, true, false);\n\n  Network::ClientConnectionPtr client_connection = dispatcher_->createClientConnection(\n      socket->connectionInfoProvider().localAddress(), Network::Address::InstanceConstSharedPtr(),\n      Network::Test::createRawBufferSocket(), nullptr);\n  client_connection->connect();\n  Buffer::OwnedImpl bad_data(\"bad_handshake_data\");\n  client_connection->write(bad_data, false);\n\n  Network::ConnectionPtr server_connection;\n  Network::MockConnectionCallbacks server_connection_callbacks;\n  EXPECT_CALL(callbacks, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory.createTransportSocket(nullptr),\n            stream_info_);\n        server_connection->addConnectionCallbacks(server_connection_callbacks);\n      }));\n\n  EXPECT_CALL(server_connection_callbacks, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        client_connection->close(Network::ConnectionCloseType::NoFlush);\n        dispatcher_->exit();\n      }));\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(1UL, server_stats_store.counter(\"ssl.connection_error\").value());\n}\n\nTEST_P(SslSocketTest, ProtocolVersions) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::TlsParameters* server_params =\n      tls_context.mutable_common_tls_context()->mutable_tls_params();\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsParameters* client_params =\n      client.mutable_common_tls_context()->mutable_tls_params();\n\n  // Note: There aren't any valid TLSv1.0 or TLSv1.1 cipher suites enabled by default,\n  // so enable them to avoid false positives.\n  client_params->add_cipher_suites(\"ECDHE-RSA-AES128-SHA\");\n  server_params->add_cipher_suites(\"ECDHE-RSA-AES128-SHA\");\n  updateFilterChain(tls_context, *filter_chain);\n\n  // Connection using defaults (client & server) succeeds, negotiating TLSv1.2.\n  TestUtilOptionsV2 tls_v1_2_test_options =\n      createProtocolTestOptions(listener, client, GetParam(), \"TLSv1.2\");\n  testUtilV2(tls_v1_2_test_options);\n\n  // Connection using defaults (client & server) succeeds, negotiating TLSv1.2,\n  // even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(tls_v1_2_test_options);\n  client.set_allow_renegotiation(false);\n\n  TestUtilOptionsV2 error_test_options(listener, client, false, GetParam());\n  error_test_options.setExpectedServerStats(\"ssl.connection_error\")\n      .setExpectedTransportFailureReasonContains(\"TLSV1_ALERT_PROTOCOL_VERSION\");\n\n  // Connection using TLSv1.0 (client) and defaults (server) fails.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  testUtilV2(error_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.1 (client) and defaults (server) fails.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_1);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_1);\n  testUtilV2(error_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.2 (client) and defaults (server) succeeds.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2);\n  testUtilV2(tls_v1_2_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.3 (client) and defaults (server) succeeds.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  TestUtilOptionsV2 tls_v1_3_test_options =\n      createProtocolTestOptions(listener, client, GetParam(), \"TLSv1.3\");\n  testUtilV2(tls_v1_3_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.0-1.3 (client) and defaults (server) succeeds.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  testUtilV2(tls_v1_3_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.0 (client) and TLSv1.0-1.3 (server) succeeds.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  updateFilterChain(tls_context, *filter_chain);\n  TestUtilOptionsV2 tls_v1_test_options =\n      createProtocolTestOptions(listener, client, GetParam(), \"TLSv1\");\n  testUtilV2(tls_v1_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.3 (client) and TLSv1.0-1.3 (server) succeeds.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(tls_v1_3_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  TestUtilOptionsV2 unsupported_protocol_test_options(listener, client, false, GetParam());\n  unsupported_protocol_test_options.setExpectedServerStats(\"ssl.connection_error\")\n      .setExpectedTransportFailureReasonContains(\"UNSUPPORTED_PROTOCOL\");\n\n  // Connection using defaults (client) and TLSv1.0 (server) fails.\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(unsupported_protocol_test_options);\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  // Connection using defaults (client) and TLSv1.1 (server) fails.\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_1);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_1);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(unsupported_protocol_test_options);\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  // Connection using defaults (client) and TLSv1.2 (server) succeeds.\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_2);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(tls_v1_2_test_options);\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  // Connection using defaults (client) and TLSv1.3 (server) fails.\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(error_test_options);\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  // Connection using defaults (client) and TLSv1.0-1.3 (server) succeeds.\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(tls_v1_2_test_options);\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.0-TLSv1.3 (client) and TLSv1.0 (server) succeeds.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(tls_v1_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n\n  // Connection using TLSv1.0-TLSv1.3 (client) and TLSv1.3 (server) succeeds.\n  client_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_0);\n  client_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  server_params->set_tls_minimum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  server_params->set_tls_maximum_protocol_version(\n      envoy::extensions::transport_sockets::tls::v3::TlsParameters::TLSv1_3);\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(tls_v1_3_test_options);\n  client_params->clear_tls_minimum_protocol_version();\n  client_params->clear_tls_maximum_protocol_version();\n  server_params->clear_tls_minimum_protocol_version();\n  server_params->clear_tls_maximum_protocol_version();\n}\n\nTEST_P(SslSocketTest, ALPN) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::CommonTlsContext* server_ctx =\n      tls_context.mutable_common_tls_context();\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::CommonTlsContext* client_ctx =\n      client.mutable_common_tls_context();\n\n  // Connection using defaults (client & server) succeeds, no ALPN is negotiated.\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options);\n\n  // Connection using defaults (client & server) succeeds, no ALPN is negotiated,\n  // even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n  client.set_allow_renegotiation(false);\n\n  // Client connects without ALPN to a server with \"test\" ALPN, no ALPN is negotiated.\n  server_ctx->add_alpn_protocols(\"test\");\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(test_options);\n  server_ctx->clear_alpn_protocols();\n\n  // Client connects with \"test\" ALPN to a server without ALPN, no ALPN is negotiated.\n  client_ctx->add_alpn_protocols(\"test\");\n  testUtilV2(test_options);\n\n  client_ctx->clear_alpn_protocols();\n\n  // Client connects with \"test\" ALPN to a server with \"test\" ALPN, \"test\" ALPN is negotiated.\n  client_ctx->add_alpn_protocols(\"test\");\n  server_ctx->add_alpn_protocols(\"test\");\n  updateFilterChain(tls_context, *filter_chain);\n  test_options.setExpectedALPNProtocol(\"test\");\n  testUtilV2(test_options);\n  test_options.setExpectedALPNProtocol(\"\");\n  client_ctx->clear_alpn_protocols();\n  server_ctx->clear_alpn_protocols();\n\n  // Client connects with \"test\" ALPN to a server with \"test\" ALPN, \"test\" ALPN is negotiated,\n  // even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  client_ctx->add_alpn_protocols(\"test\");\n  server_ctx->add_alpn_protocols(\"test\");\n  updateFilterChain(tls_context, *filter_chain);\n  test_options.setExpectedALPNProtocol(\"test\");\n  testUtilV2(test_options);\n  test_options.setExpectedALPNProtocol(\"\");\n  client.set_allow_renegotiation(false);\n  client_ctx->clear_alpn_protocols();\n  server_ctx->clear_alpn_protocols();\n\n  // Client connects with \"test\" ALPN to a server with \"test2\" ALPN, no ALPN is negotiated.\n  client_ctx->add_alpn_protocols(\"test\");\n  server_ctx->add_alpn_protocols(\"test2\");\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(test_options);\n  client_ctx->clear_alpn_protocols();\n  server_ctx->clear_alpn_protocols();\n\n  // Client attempts to configure ALPN that is too large.\n  client_ctx->add_alpn_protocols(std::string(100000, 'a'));\n  EXPECT_THROW_WITH_MESSAGE(testUtilV2(test_options), EnvoyException,\n                            \"Invalid ALPN protocol string\");\n}\n\nTEST_P(SslSocketTest, CipherSuites) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsParameters* client_params =\n      client.mutable_common_tls_context()->mutable_tls_params();\n\n  // Connection using defaults (client & server) succeeds.\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options);\n\n  // Connection using defaults (client & server) succeeds, even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n  client.set_allow_renegotiation(false);\n\n  // Client connects with one of the supported cipher suites, connection succeeds.\n  std::string common_cipher_suite = \"ECDHE-RSA-CHACHA20-POLY1305\";\n  client_params->add_cipher_suites(common_cipher_suite);\n  envoy::extensions::transport_sockets::tls::v3::TlsParameters* server_params =\n      tls_context.mutable_common_tls_context()->mutable_tls_params();\n  server_params->add_cipher_suites(common_cipher_suite);\n  server_params->add_cipher_suites(\"ECDHE-RSA-AES128-GCM-SHA256\");\n  updateFilterChain(tls_context, *filter_chain);\n  TestUtilOptionsV2 cipher_test_options(listener, client, true, GetParam());\n  cipher_test_options.setExpectedCiphersuite(common_cipher_suite);\n  std::string stats = \"ssl.ciphers.\" + common_cipher_suite;\n  cipher_test_options.setExpectedServerStats(stats).setExpectedClientStats(stats);\n  testUtilV2(cipher_test_options);\n  client_params->clear_cipher_suites();\n  server_params->clear_cipher_suites();\n\n  // Client connects with unsupported cipher suite, connection fails.\n  client_params->add_cipher_suites(\"ECDHE-RSA-AES128-GCM-SHA256\");\n  server_params->add_cipher_suites(\"ECDHE-RSA-CHACHA20-POLY1305\");\n  updateFilterChain(tls_context, *filter_chain);\n  TestUtilOptionsV2 error_test_options(listener, client, false, GetParam());\n  error_test_options.setExpectedServerStats(\"ssl.connection_error\");\n  testUtilV2(error_test_options);\n  client_params->clear_cipher_suites();\n  server_params->clear_cipher_suites();\n\n  // Client connects to a server offering only deprecated cipher suites, connection fails.\n  server_params->add_cipher_suites(\"ECDHE-RSA-AES128-SHA\");\n  updateFilterChain(tls_context, *filter_chain);\n  error_test_options.setExpectedServerStats(\"ssl.connection_error\");\n  testUtilV2(error_test_options);\n  server_params->clear_cipher_suites();\n  updateFilterChain(tls_context, *filter_chain);\n  // Verify that ECDHE-RSA-CHACHA20-POLY1305 is not offered by default in FIPS builds.\n  client_params->add_cipher_suites(common_cipher_suite);\n#ifdef BORINGSSL_FIPS\n  testUtilV2(error_test_options);\n#else\n  testUtilV2(cipher_test_options);\n#endif\n  client_params->clear_cipher_suites();\n}\n\nTEST_P(SslSocketTest, EcdhCurves) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  envoy::extensions::transport_sockets::tls::v3::TlsParameters* server_params =\n      tls_context.mutable_common_tls_context()->mutable_tls_params();\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  envoy::extensions::transport_sockets::tls::v3::TlsParameters* client_params =\n      client.mutable_common_tls_context()->mutable_tls_params();\n\n  // Connection using defaults (client & server) succeeds.\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options);\n\n  // Connection using defaults (client & server) succeeds, even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(test_options);\n  client.set_allow_renegotiation(false);\n\n  // Client connects with one of the supported ECDH curves, connection succeeds.\n  client_params->add_ecdh_curves(\"X25519\");\n  server_params->add_ecdh_curves(\"X25519\");\n  server_params->add_ecdh_curves(\"P-256\");\n  server_params->add_cipher_suites(\"ECDHE-RSA-AES128-GCM-SHA256\");\n  updateFilterChain(tls_context, *filter_chain);\n  TestUtilOptionsV2 ecdh_curves_test_options(listener, client, true, GetParam());\n  std::string stats = \"ssl.curves.X25519\";\n  ecdh_curves_test_options.setExpectedServerStats(stats).setExpectedClientStats(stats);\n  testUtilV2(ecdh_curves_test_options);\n  client_params->clear_ecdh_curves();\n  server_params->clear_ecdh_curves();\n  server_params->clear_cipher_suites();\n\n  // Client connects with unsupported ECDH curve, connection fails.\n  client_params->add_ecdh_curves(\"X25519\");\n  server_params->add_ecdh_curves(\"P-256\");\n  server_params->add_cipher_suites(\"ECDHE-RSA-AES128-GCM-SHA256\");\n  updateFilterChain(tls_context, *filter_chain);\n  TestUtilOptionsV2 error_test_options(listener, client, false, GetParam());\n  error_test_options.setExpectedServerStats(\"ssl.connection_error\");\n  testUtilV2(error_test_options);\n\n  client_params->clear_ecdh_curves();\n  server_params->clear_ecdh_curves();\n  server_params->clear_cipher_suites();\n\n  // Verify that X25519 is not offered by default in FIPS builds.\n  client_params->add_ecdh_curves(\"X25519\");\n  server_params->add_cipher_suites(\"ECDHE-RSA-AES128-GCM-SHA256\");\n  updateFilterChain(tls_context, *filter_chain);\n#ifdef BORINGSSL_FIPS\n  testUtilV2(error_test_options);\n#else\n  testUtilV2(ecdh_curves_test_options);\n#endif\n  client_params->clear_ecdh_curves();\n  server_params->clear_cipher_suites();\n}\n\nTEST_P(SslSocketTest, SignatureAlgorithms) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext*\n      server_validation_ctx =\n          tls_context.mutable_common_tls_context()->mutable_validation_context();\n\n  server_validation_ctx->mutable_trusted_ca()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"));\n  // Server ECDSA certificate.\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir \"\n      \"}}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem\"));\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  // Client RSA certificate.\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* client_cert =\n      client.mutable_common_tls_context()->add_tls_certificates();\n  client_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"));\n  client_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"));\n\n  // Connection using defaults (client & server) succeeds.\n  TestUtilOptionsV2 algorithm_test_options(listener, client, true, GetParam());\n  algorithm_test_options.setExpectedClientCertUri(\"spiffe://lyft.com/test-team\")\n      .setExpectedServerStats(\"ssl.sigalgs.rsa_pss_rsae_sha256\")\n      .setExpectedClientStats(\"ssl.sigalgs.ecdsa_secp256r1_sha256\");\n  testUtilV2(algorithm_test_options);\n\n  // Connection using defaults (client & server) succeeds, even with client renegotiation.\n  client.set_allow_renegotiation(true);\n  testUtilV2(algorithm_test_options);\n  client.set_allow_renegotiation(false);\n}\n\nTEST_P(SslSocketTest, RevokedCertificate) {\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n\n  // This should fail, since the certificate has been revoked.\n  const std::string revoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n)EOF\";\n\n  TestUtilOptions revoked_test_options(revoked_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(revoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_CERT_REVOKED));\n\n  // This should succeed, since the cert isn't revoked.\n  const std::string successful_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_key.pem\"\n)EOF\";\n\n  TestUtilOptions successful_test_options(successful_client_ctx_yaml, server_ctx_yaml, true,\n                                          GetParam());\n  testUtil(successful_test_options.setExpectedSerialNumber(TEST_SAN_DNS2_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, RevokedCertificateCRLInTrustedCA) {\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert_with_crl.pem\"\n)EOF\";\n\n  // This should fail, since the certificate has been revoked.\n  const std::string revoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"\n)EOF\";\n\n  TestUtilOptions revoked_test_options(revoked_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(revoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_CERT_REVOKED));\n\n  // This should succeed, since the cert isn't revoked.\n  const std::string successful_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns2_key.pem\"\n)EOF\";\n  TestUtilOptions successful_test_options(successful_client_ctx_yaml, server_ctx_yaml, true,\n                                          GetParam());\n  testUtil(successful_test_options.setExpectedSerialNumber(TEST_SAN_DNS2_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, RevokedIntermediateCertificate) {\n\n  // This should succeed, since the crl chain is complete.\n  //\n  // Trust chain contains:\n  //  - Root authority certificate (i.e., ca_cert.pem)\n  //  - Intermediate authority certificate (i.e., intermediate_ca_cert.pem)\n  //\n  // Certificate revocation list contains:\n  //  - Root authority certificate revocation list (i.e., ca_cert.crl)\n  //  - Intermediate authority certificate revocation list (i.e., intermediate_ca_cert.crl)\n  const std::string complete_server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert_chain.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert_chain.crl\"\n)EOF\";\n\n  // This should fail, since the crl chain is incomplete.\n  //\n  // Trust chain contains:\n  //  - Root authority certificate (i.e., ca_cert.pem)\n  //  - Intermediate authority certificate (i.e., intermediate_ca_cert.pem)\n  //\n  // Certificate revocation list contains:\n  //  - Root authority certificate revocation list (i.e., ca_cert.crl)\n  //\n  // Certificate revocation list omits:\n  //  - Root authority certificate revocation list (i.e., ca_cert.crl)\n  const std::string incomplete_server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert_chain.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert.crl\"\n)EOF\";\n\n  // This should fail, since the certificate has been revoked.\n  const std::string revoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_key.pem\"\n)EOF\";\n\n  // This should succeed, since the certificate has not been revoked.\n  const std::string unrevoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns4_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns4_key.pem\"\n)EOF\";\n\n  // Ensure that incomplete crl chains fail with revoked certificates.\n  TestUtilOptions incomplete_revoked_test_options(revoked_client_ctx_yaml,\n                                                  incomplete_server_ctx_yaml, false, GetParam());\n  testUtil(incomplete_revoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_CERT_REVOKED));\n\n  // Ensure that incomplete crl chains fail with unrevoked certificates.\n  TestUtilOptions incomplete_unrevoked_test_options(unrevoked_client_ctx_yaml,\n                                                    incomplete_server_ctx_yaml, false, GetParam());\n  testUtil(incomplete_unrevoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_UNABLE_TO_GET_CRL));\n\n  // Ensure that complete crl chains fail with revoked certificates.\n  TestUtilOptions complete_revoked_test_options(revoked_client_ctx_yaml, complete_server_ctx_yaml,\n                                                false, GetParam());\n  testUtil(complete_revoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_CERT_REVOKED));\n\n  // Ensure that complete crl chains succeed with unrevoked certificates.\n  TestUtilOptions complete_unrevoked_test_options(unrevoked_client_ctx_yaml,\n                                                  complete_server_ctx_yaml, true, GetParam());\n  testUtil(complete_unrevoked_test_options.setExpectedSerialNumber(TEST_SAN_DNS4_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, RevokedIntermediateCertificateCRLInTrustedCA) {\n\n  // This should succeed, since the crl chain is complete.\n  //\n  // Trust chain contains:\n  //  - Root authority certificate (i.e., ca_cert.pem)\n  //  - Root authority certificate revocation list (i.e., ca_cert.crl)\n  //  - Intermediate authority certificate (i.e., intermediate_ca_cert.pem)\n  //  - Intermediate authority certificate revocation list (i.e., intermediate_ca_cert.crl)\n  const std::string complete_server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert_chain_with_crl_chain.pem\"\n)EOF\";\n\n  // This should fail, since the crl chain is incomplete.\n  //\n  // Trust chain contains:\n  //  - Root authority certificate (i.e., ca_cert.pem)\n  //  - Intermediate authority certificate (i.e., intermediate_ca_cert.pem)\n  //  - Intermediate authority certificate revocation list (i.e., intermediate_ca_cert.crl)\n  //\n  // Trust chain omits:\n  //  - Root authority certificate revocation list (i.e., ca_cert.crl)\n  const std::string incomplete_server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert_chain_with_crl.pem\"\n)EOF\";\n\n  // This should fail, since the certificate has been revoked.\n  const std::string revoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_key.pem\"\n)EOF\";\n\n  // This should succeed, since the certificate has not been revoked.\n  const std::string unrevoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns4_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns4_key.pem\"\n)EOF\";\n\n  // Ensure that incomplete crl chains fail with revoked certificates.\n  TestUtilOptions incomplete_revoked_test_options(revoked_client_ctx_yaml,\n                                                  incomplete_server_ctx_yaml, false, GetParam());\n  testUtil(incomplete_revoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_CERT_REVOKED));\n\n  // Ensure that incomplete crl chains fail with unrevoked certificates.\n  TestUtilOptions incomplete_unrevoked_test_options(unrevoked_client_ctx_yaml,\n                                                    incomplete_server_ctx_yaml, false, GetParam());\n  testUtil(incomplete_unrevoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_UNABLE_TO_GET_CRL));\n\n  // Ensure that complete crl chains fail with revoked certificates.\n  TestUtilOptions complete_revoked_test_options(revoked_client_ctx_yaml, complete_server_ctx_yaml,\n                                                false, GetParam());\n  testUtil(complete_revoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_CERT_REVOKED));\n\n  // Ensure that complete crl chains succeed with unrevoked certificates.\n  TestUtilOptions complete_unrevoked_test_options(unrevoked_client_ctx_yaml,\n                                                  complete_server_ctx_yaml, true, GetParam());\n  testUtil(complete_unrevoked_test_options.setExpectedSerialNumber(TEST_SAN_DNS4_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, NotRevokedLeafCertificateOnlyLeafCRLValidation) {\n  // The test checks that revoked certificate will makes the validation success even if we set\n  // only_verify_leaf_cert_crl to true.\n  //\n  // Trust chain contains:\n  //  - Root authority certificate (i.e., ca_cert.pem)\n  //  - Intermediate authority certificate (i.e., intermediate_ca_cert.pem)\n  //  - Intermediate authority certificate revocation list (i.e., intermediate_ca_cert.crl)\n  //\n  // Trust chain omits (But this test will succeed):\n  //  - Root authority certificate revocation list (i.e., ca_cert.crl)\n  const std::string incomplete_server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert_chain_with_crl.pem\"\n      only_verify_leaf_cert_crl: true\n)EOF\";\n\n  // This should succeed, since the certificate has not been revoked.\n  const std::string unrevoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns4_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns4_key.pem\"\n)EOF\";\n\n  TestUtilOptions complete_unrevoked_test_options(unrevoked_client_ctx_yaml,\n                                                  incomplete_server_ctx_yaml, true, GetParam());\n  testUtil(complete_unrevoked_test_options.setExpectedSerialNumber(TEST_SAN_DNS4_CERT_SERIAL));\n}\n\nTEST_P(SslSocketTest, RevokedLeafCertificateOnlyLeafCRLValidation) {\n  // The test checks that revoked certificate will makes the validation fails even if we set\n  // only_verify_leaf_cert_crl to true.\n  //\n  // Trust chain contains:\n  //  - Root authority certificate (i.e., ca_cert.pem)\n  //  - Intermediate authority certificate (i.e., intermediate_ca_cert.pem)\n  //  - Intermediate authority certificate revocation list (i.e., intermediate_ca_cert.crl)\n  //\n  // Trust chain omits (But this test will succeed):\n  //  - Root authority certificate revocation list (i.e., ca_cert.crl)\n  const std::string incomplete_server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/intermediate_ca_cert_chain_with_crl.pem\"\n      only_verify_leaf_cert_crl: true\n)EOF\";\n\n  // This should fail, since the certificate has been revoked.\n  const std::string revoked_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns3_key.pem\"\n)EOF\";\n\n  TestUtilOptions complete_revoked_test_options(revoked_client_ctx_yaml, incomplete_server_ctx_yaml,\n                                                false, GetParam());\n  testUtil(complete_revoked_test_options.setExpectedServerStats(\"ssl.fail_verify_error\")\n               .setExpectedVerifyErrorCode(X509_V_ERR_CERT_REVOKED));\n}\n\nTEST_P(SslSocketTest, GetRequestedServerName) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  client.set_sni(\"lyft.com\");\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedRequestedServerName(\"lyft.com\"));\n}\n\nTEST_P(SslSocketTest, OverrideRequestedServerName) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  client.set_sni(\"lyft.com\");\n\n  Network::TransportSocketOptionsConstSharedPtr transport_socket_options(\n      new Network::TransportSocketOptionsImpl(\"example.com\"));\n\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedRequestedServerName(\"example.com\")\n                 .setTransportSocketOptions(transport_socket_options));\n}\n\nTEST_P(SslSocketTest, OverrideRequestedServerNameWithoutSniInUpstreamTlsContext) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n  updateFilterChain(tls_context, *filter_chain);\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n\n  Network::TransportSocketOptionsConstSharedPtr transport_socket_options(\n      new Network::TransportSocketOptionsImpl(\"example.com\"));\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n  testUtilV2(test_options.setExpectedRequestedServerName(\"example.com\")\n                 .setTransportSocketOptions(transport_socket_options));\n}\n\nTEST_P(SslSocketTest, OverrideApplicationProtocols) {\n  envoy::config::listener::v3::Listener listener;\n  envoy::config::listener::v3::FilterChain* filter_chain = listener.add_filter_chains();\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  envoy::extensions::transport_sockets::tls::v3::TlsCertificate* server_cert =\n      tls_context.mutable_common_tls_context()->add_tls_certificates();\n\n  server_cert->mutable_certificate_chain()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem\"));\n  server_cert->mutable_private_key()->set_filename(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_key.pem\"));\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext client;\n  TestUtilOptionsV2 test_options(listener, client, true, GetParam());\n\n  // Client connects without ALPN to a server with \"test\" ALPN, no ALPN is negotiated.\n  envoy::extensions::transport_sockets::tls::v3::CommonTlsContext* server_ctx =\n      tls_context.mutable_common_tls_context();\n  server_ctx->add_alpn_protocols(\"test\");\n  updateFilterChain(tls_context, *filter_chain);\n  testUtilV2(test_options);\n  server_ctx->clear_alpn_protocols();\n  // Override client side ALPN, \"test\" ALPN is used.\n  server_ctx->add_alpn_protocols(\"test\");\n  updateFilterChain(tls_context, *filter_chain);\n  auto transport_socket_options = std::make_shared<Network::TransportSocketOptionsImpl>(\n      \"\", std::vector<std::string>{}, std::vector<std::string>{\"foo\", \"test\", \"bar\"});\n\n  testUtilV2(test_options.setExpectedALPNProtocol(\"test\").setTransportSocketOptions(\n      transport_socket_options));\n\n  // Set fallback ALPN on the client side ALPN, \"test\" ALPN is used since no ALPN is specified\n  // in the config.\n  server_ctx->add_alpn_protocols(\"test\");\n  transport_socket_options = std::make_shared<Network::TransportSocketOptionsImpl>(\n      \"\", std::vector<std::string>{}, std::vector<std::string>{}, std::vector<std::string>{\"test\"});\n  testUtilV2(test_options.setExpectedALPNProtocol(\"test\").setTransportSocketOptions(\n      transport_socket_options));\n\n  // With multiple fallbacks specified, a single match will match.\n  transport_socket_options = std::make_shared<Network::TransportSocketOptionsImpl>(\n      \"\", std::vector<std::string>{}, std::vector<std::string>{},\n      std::vector<std::string>{\"foo\", \"test\"});\n  testUtilV2(test_options.setExpectedALPNProtocol(\"test\").setTransportSocketOptions(\n      transport_socket_options));\n\n  // With multiple matching fallbacks specified, a single match will match.\n  server_ctx->add_alpn_protocols(\"foo\");\n  transport_socket_options = std::make_shared<Network::TransportSocketOptionsImpl>(\n      \"\", std::vector<std::string>{}, std::vector<std::string>{},\n      std::vector<std::string>{\"foo\", \"test\"});\n  testUtilV2(test_options.setExpectedALPNProtocol(\"test\").setTransportSocketOptions(\n      transport_socket_options));\n\n  // Update the client TLS config to specify ALPN. The fallback value should no longer be used.\n  // Note that the server prefers \"test\" over \"bar\", but since the client only configures \"bar\",\n  // the resulting ALPN will be \"bar\" even though \"test\" is included in the fallback.\n  server_ctx->add_alpn_protocols(\"bar\");\n  updateFilterChain(tls_context, *filter_chain);\n  client.mutable_common_tls_context()->add_alpn_protocols(\"bar\");\n  testUtilV2(test_options.setExpectedALPNProtocol(\"bar\").setTransportSocketOptions(\n      transport_socket_options));\n}\n\n// Validate that if downstream secrets are not yet downloaded from SDS server, Envoy creates\n// NotReadySslSocket object to handle downstream connection.\nTEST_P(SslSocketTest, DownstreamNotReadySslSocket) {\n  Stats::TestUtil::TestStore stats_store;\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext> factory_context;\n  NiceMock<Init::MockManager> init_manager;\n  NiceMock<Event::MockDispatcher> dispatcher;\n  EXPECT_CALL(factory_context, mainThreadDispatcher()).WillRepeatedly(ReturnRef(dispatcher));\n  EXPECT_CALL(factory_context, localInfo()).WillOnce(ReturnRef(local_info));\n  EXPECT_CALL(factory_context, stats()).WillOnce(ReturnRef(stats_store));\n  EXPECT_CALL(factory_context, initManager()).WillRepeatedly(ReturnRef(init_manager));\n\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n  auto sds_secret_configs =\n      tls_context.mutable_common_tls_context()->mutable_tls_certificate_sds_secret_configs()->Add();\n  sds_secret_configs->set_name(\"abc.com\");\n  sds_secret_configs->mutable_sds_config();\n  auto server_cfg = std::make_unique<ServerContextConfigImpl>(tls_context, factory_context);\n  EXPECT_TRUE(server_cfg->tlsCertificates().empty());\n  EXPECT_FALSE(server_cfg->isReady());\n\n  ContextManagerImpl manager(time_system_);\n  ServerSslSocketFactory server_ssl_socket_factory(std::move(server_cfg), manager, stats_store,\n                                                   std::vector<std::string>{});\n  auto transport_socket = server_ssl_socket_factory.createTransportSocket(nullptr);\n  EXPECT_FALSE(transport_socket->startSecureTransport());                                  // Noop\n  transport_socket->configureInitialCongestionWindow(200, std::chrono::microseconds(223)); // Noop\n  EXPECT_EQ(EMPTY_STRING, transport_socket->protocol());\n  EXPECT_EQ(nullptr, transport_socket->ssl());\n  EXPECT_EQ(true, transport_socket->canFlushClose());\n  Buffer::OwnedImpl buffer;\n  Network::IoResult result = transport_socket->doRead(buffer);\n  EXPECT_EQ(Network::PostIoAction::Close, result.action_);\n  result = transport_socket->doWrite(buffer, true);\n  EXPECT_EQ(Network::PostIoAction::Close, result.action_);\n  EXPECT_EQ(\"TLS error: Secret is not supplied by SDS\", transport_socket->failureReason());\n}\n\n// Validate that if upstream secrets are not yet downloaded from SDS server, Envoy creates\n// NotReadySslSocket object to handle upstream connection.\nTEST_P(SslSocketTest, UpstreamNotReadySslSocket) {\n  Stats::TestUtil::TestStore stats_store;\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext> factory_context;\n  NiceMock<Init::MockManager> init_manager;\n  NiceMock<Event::MockDispatcher> dispatcher;\n  EXPECT_CALL(factory_context, localInfo()).WillOnce(ReturnRef(local_info));\n  EXPECT_CALL(factory_context, stats()).WillOnce(ReturnRef(stats_store));\n  EXPECT_CALL(factory_context, initManager()).WillRepeatedly(ReturnRef(init_manager));\n  EXPECT_CALL(factory_context, mainThreadDispatcher()).WillRepeatedly(ReturnRef(dispatcher));\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n  auto sds_secret_configs =\n      tls_context.mutable_common_tls_context()->mutable_tls_certificate_sds_secret_configs()->Add();\n  sds_secret_configs->set_name(\"abc.com\");\n  sds_secret_configs->mutable_sds_config();\n  auto client_cfg = std::make_unique<ClientContextConfigImpl>(tls_context, factory_context);\n  EXPECT_TRUE(client_cfg->tlsCertificates().empty());\n  EXPECT_FALSE(client_cfg->isReady());\n\n  ContextManagerImpl manager(time_system_);\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager, stats_store);\n  auto transport_socket = client_ssl_socket_factory.createTransportSocket(nullptr);\n  EXPECT_EQ(EMPTY_STRING, transport_socket->protocol());\n  EXPECT_EQ(nullptr, transport_socket->ssl());\n  EXPECT_EQ(true, transport_socket->canFlushClose());\n  Buffer::OwnedImpl buffer;\n  Network::IoResult result = transport_socket->doRead(buffer);\n  EXPECT_EQ(Network::PostIoAction::Close, result.action_);\n  result = transport_socket->doWrite(buffer, true);\n  EXPECT_EQ(Network::PostIoAction::Close, result.action_);\n  EXPECT_EQ(\"TLS error: Secret is not supplied by SDS\", transport_socket->failureReason());\n}\n\nTEST_P(SslSocketTest, TestTransportSocketCallback) {\n  // Make MockTransportSocketCallbacks.\n  Network::MockIoHandle io_handle;\n  NiceMock<Network::MockTransportSocketCallbacks> callbacks;\n  ON_CALL(callbacks, ioHandle()).WillByDefault(ReturnRef(io_handle));\n\n  // Make SslSocket.\n  testing::NiceMock<Server::Configuration::MockTransportSocketFactoryContext> factory_context;\n  Stats::TestUtil::TestStore stats_store;\n  ON_CALL(factory_context, stats()).WillByDefault(ReturnRef(stats_store));\n  NiceMock<LocalInfo::MockLocalInfo> local_info;\n  ON_CALL(factory_context, localInfo()).WillByDefault(ReturnRef(local_info));\n\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls_context;\n  auto client_cfg = std::make_unique<ClientContextConfigImpl>(tls_context, factory_context);\n\n  ContextManagerImpl manager(time_system_);\n  ClientSslSocketFactory client_ssl_socket_factory(std::move(client_cfg), manager, stats_store);\n\n  Network::TransportSocketPtr transport_socket =\n      client_ssl_socket_factory.createTransportSocket(nullptr);\n\n  SslSocket* ssl_socket = dynamic_cast<SslSocket*>(transport_socket.get());\n\n  // If no transport socket callbacks have been set, this method should return nullptr.\n  EXPECT_EQ(ssl_socket->transportSocketCallbacks(), nullptr);\n\n  // Otherwise, it should return a pointer to the set callbacks object.\n  ssl_socket->setTransportSocketCallbacks(callbacks);\n  EXPECT_EQ(ssl_socket->transportSocketCallbacks(), &callbacks);\n}\n\nclass SslReadBufferLimitTest : public SslSocketTest {\nprotected:\n  void initialize() {\n    TestUtility::loadFromYaml(TestEnvironment::substitute(server_ctx_yaml_),\n                              downstream_tls_context_);\n    auto server_cfg =\n        std::make_unique<ServerContextConfigImpl>(downstream_tls_context_, factory_context_);\n    manager_ = std::make_unique<ContextManagerImpl>(time_system_);\n    server_ssl_socket_factory_ = std::make_unique<ServerSslSocketFactory>(\n        std::move(server_cfg), *manager_, server_stats_store_, std::vector<std::string>{});\n\n    socket_ = std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n        Network::Test::getCanonicalLoopbackAddress(GetParam()));\n    listener_ = dispatcher_->createListener(socket_, listener_callbacks_, runtime_, true, false);\n\n    TestUtility::loadFromYaml(TestEnvironment::substitute(client_ctx_yaml_), upstream_tls_context_);\n    auto client_cfg =\n        std::make_unique<ClientContextConfigImpl>(upstream_tls_context_, factory_context_);\n\n    client_ssl_socket_factory_ = std::make_unique<ClientSslSocketFactory>(\n        std::move(client_cfg), *manager_, client_stats_store_);\n    auto transport_socket = client_ssl_socket_factory_->createTransportSocket(nullptr);\n    client_transport_socket_ = transport_socket.get();\n    client_connection_ =\n        dispatcher_->createClientConnection(socket_->connectionInfoProvider().localAddress(),\n                                            source_address_, std::move(transport_socket), nullptr);\n    client_connection_->addConnectionCallbacks(client_callbacks_);\n    client_connection_->connect();\n    read_filter_ = std::make_shared<Network::MockReadFilter>();\n  }\n\n  void readBufferLimitTest(uint32_t read_buffer_limit, uint32_t expected_chunk_size,\n                           uint32_t write_size, uint32_t num_writes, bool reserve_write_space) {\n    initialize();\n\n    EXPECT_CALL(listener_callbacks_, onAccept_(_))\n        .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n          server_connection_ = dispatcher_->createServerConnection(\n              std::move(socket), server_ssl_socket_factory_->createTransportSocket(nullptr),\n              stream_info_);\n          server_connection_->setBufferLimits(read_buffer_limit);\n          server_connection_->addConnectionCallbacks(server_callbacks_);\n          server_connection_->addReadFilter(read_filter_);\n          EXPECT_EQ(\"\", server_connection_->nextProtocol());\n          EXPECT_EQ(read_buffer_limit, server_connection_->bufferLimit());\n        }));\n\n    EXPECT_CALL(client_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n    uint32_t filter_seen = 0;\n\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _))\n        .WillRepeatedly(Invoke([&](Buffer::Instance& data, bool) -> Network::FilterStatus {\n          EXPECT_GE(expected_chunk_size, data.length());\n          filter_seen += data.length();\n          data.drain(data.length());\n          if (filter_seen == (write_size * num_writes)) {\n            server_connection_->close(Network::ConnectionCloseType::FlushWrite);\n          }\n          return Network::FilterStatus::StopIteration;\n        }));\n\n    EXPECT_CALL(client_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n          EXPECT_EQ((write_size * num_writes), filter_seen);\n          dispatcher_->exit();\n        }));\n\n    for (uint32_t i = 0; i < num_writes; i++) {\n      Buffer::OwnedImpl data(std::string(write_size, 'a'));\n\n      if (reserve_write_space) {\n        data.appendSliceForTest(absl::string_view());\n        ASSERT_EQ(0, data.describeSlicesForTest().back().data);\n      }\n\n      client_connection_->write(data, false);\n    }\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n    EXPECT_EQ(0UL, server_stats_store_.counter(\"ssl.connection_error\").value());\n    EXPECT_EQ(0UL, client_stats_store_.counter(\"ssl.connection_error\").value());\n  }\n\n  void singleWriteTest(uint32_t read_buffer_limit, uint32_t bytes_to_write) {\n    MockWatermarkBuffer* client_write_buffer = nullptr;\n    MockBufferFactory* factory = new StrictMock<MockBufferFactory>;\n    dispatcher_ = api_->allocateDispatcher(\"test_thread\", Buffer::WatermarkFactoryPtr{factory});\n\n    // By default, expect 4 buffers to be created - the client and server read and write buffers.\n    EXPECT_CALL(*factory, createBuffer_(_, _, _))\n        .Times(4)\n        .WillOnce(Invoke([&](std::function<void()> below_low, std::function<void()> above_high,\n                             std::function<void()> above_overflow) -> Buffer::Instance* {\n          client_write_buffer = new MockWatermarkBuffer(below_low, above_high, above_overflow);\n          return client_write_buffer;\n        }))\n        .WillRepeatedly(Invoke([](std::function<void()> below_low, std::function<void()> above_high,\n                                  std::function<void()> above_overflow) -> Buffer::Instance* {\n          return new Buffer::WatermarkBuffer(below_low, above_high, above_overflow);\n        }));\n\n    initialize();\n\n    EXPECT_CALL(client_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    EXPECT_CALL(listener_callbacks_, onAccept_(_))\n        .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n          server_connection_ = dispatcher_->createServerConnection(\n              std::move(socket), server_ssl_socket_factory_->createTransportSocket(nullptr),\n              stream_info_);\n          server_connection_->setBufferLimits(read_buffer_limit);\n          server_connection_->addConnectionCallbacks(server_callbacks_);\n          server_connection_->addReadFilter(read_filter_);\n          EXPECT_EQ(\"\", server_connection_->nextProtocol());\n          EXPECT_EQ(read_buffer_limit, server_connection_->bufferLimit());\n        }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _)).Times(testing::AnyNumber());\n\n    std::string data_to_write(bytes_to_write, 'a');\n    Buffer::OwnedImpl buffer_to_write(data_to_write);\n    std::string data_written;\n    EXPECT_CALL(*client_write_buffer, move(_))\n        .WillRepeatedly(DoAll(AddBufferToStringWithoutDraining(&data_written),\n                              Invoke(client_write_buffer, &MockWatermarkBuffer::baseMove)));\n    EXPECT_CALL(*client_write_buffer, drain(_)).Times(2).WillOnce(Invoke([&](uint64_t n) -> void {\n      client_write_buffer->baseDrain(n);\n      dispatcher_->exit();\n    }));\n    client_connection_->write(buffer_to_write, false);\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n    EXPECT_EQ(data_to_write, data_written);\n\n    disconnect();\n  }\n\n  void disconnect() {\n    EXPECT_CALL(client_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));\n    EXPECT_CALL(server_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    client_connection_->close(Network::ConnectionCloseType::NoFlush);\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  Stats::TestUtil::TestStore server_stats_store_;\n  Stats::TestUtil::TestStore client_stats_store_;\n  std::shared_ptr<Network::Test::TcpListenSocketImmediateListen> socket_;\n  Network::MockTcpListenerCallbacks listener_callbacks_;\n  const std::string server_ctx_yaml_ = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n)EOF\";\n\n  const std::string client_ctx_yaml_ = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_key.pem\"\n)EOF\";\n\n  NiceMock<Runtime::MockLoader> runtime_;\n  envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext downstream_tls_context_;\n  std::unique_ptr<ContextManagerImpl> manager_;\n  Network::TransportSocketFactoryPtr server_ssl_socket_factory_;\n  Network::ListenerPtr listener_;\n  envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext upstream_tls_context_;\n  Envoy::Ssl::ClientContextSharedPtr client_ctx_;\n  Network::TransportSocketFactoryPtr client_ssl_socket_factory_;\n  Network::ClientConnectionPtr client_connection_;\n  Network::TransportSocket* client_transport_socket_{};\n  Network::ConnectionPtr server_connection_;\n  NiceMock<Network::MockConnectionCallbacks> server_callbacks_;\n  std::shared_ptr<Network::MockReadFilter> read_filter_;\n  StrictMock<Network::MockConnectionCallbacks> client_callbacks_;\n  Network::Address::InstanceConstSharedPtr source_address_;\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, SslReadBufferLimitTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(SslReadBufferLimitTest, NoLimit) {\n  readBufferLimitTest(0, 256 * 1024, 256 * 1024, 1, false);\n}\n\nTEST_P(SslReadBufferLimitTest, NoLimitReserveSpace) { readBufferLimitTest(0, 512, 512, 1, true); }\n\nTEST_P(SslReadBufferLimitTest, NoLimitSmallWrites) {\n  readBufferLimitTest(0, 256 * 1024, 1, 256 * 1024, false);\n}\n\nTEST_P(SslReadBufferLimitTest, SomeLimit) {\n  readBufferLimitTest(32 * 1024, 32 * 1024, 256 * 1024, 1, false);\n}\n\nTEST_P(SslReadBufferLimitTest, WritesSmallerThanBufferLimit) { singleWriteTest(5 * 1024, 1024); }\n\nTEST_P(SslReadBufferLimitTest, WritesLargerThanBufferLimit) { singleWriteTest(1024, 5 * 1024); }\n\nTEST_P(SslReadBufferLimitTest, TestBind) {\n  std::string address_string = TestUtility::getIpv4Loopback();\n  if (GetParam() == Network::Address::IpVersion::v4) {\n    source_address_ = Network::Address::InstanceConstSharedPtr{\n        new Network::Address::Ipv4Instance(address_string, 0, nullptr)};\n  } else {\n    address_string = \"::1\";\n    source_address_ = Network::Address::InstanceConstSharedPtr{\n        new Network::Address::Ipv6Instance(address_string, 0, nullptr)};\n  }\n\n  initialize();\n\n  EXPECT_CALL(listener_callbacks_, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection_ = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory_->createTransportSocket(nullptr),\n            stream_info_);\n        server_connection_->addConnectionCallbacks(server_callbacks_);\n        server_connection_->addReadFilter(read_filter_);\n        EXPECT_EQ(\"\", server_connection_->nextProtocol());\n      }));\n\n  EXPECT_CALL(client_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_EQ(address_string,\n            server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString());\n\n  disconnect();\n}\n\n// Regression test for https://github.com/envoyproxy/envoy/issues/6617\nTEST_P(SslReadBufferLimitTest, SmallReadsIntoSameSlice) {\n  // write_size * num_writes must be large enough to cause buffer reserving fragmentation,\n  // but smaller than one reservation so the expected slice to be 1.\n  const uint32_t write_size = 1;\n  const uint32_t num_writes = 12 * 1024;\n  const uint32_t read_buffer_limit = write_size * num_writes;\n  const uint32_t expected_chunk_size = write_size * num_writes;\n\n  initialize();\n\n  EXPECT_CALL(listener_callbacks_, onAccept_(_))\n      .WillOnce(Invoke([&](Network::ConnectionSocketPtr& socket) -> void {\n        server_connection_ = dispatcher_->createServerConnection(\n            std::move(socket), server_ssl_socket_factory_->createTransportSocket(nullptr),\n            stream_info_);\n        server_connection_->setBufferLimits(read_buffer_limit);\n        server_connection_->addConnectionCallbacks(server_callbacks_);\n        server_connection_->addReadFilter(read_filter_);\n        EXPECT_EQ(\"\", server_connection_->nextProtocol());\n        EXPECT_EQ(read_buffer_limit, server_connection_->bufferLimit());\n      }));\n\n  EXPECT_CALL(client_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n  uint32_t filter_seen = 0;\n\n  EXPECT_CALL(*read_filter_, onNewConnection());\n  EXPECT_CALL(*read_filter_, onData(_, _))\n      .WillRepeatedly(Invoke([&](Buffer::Instance& data, bool) -> Network::FilterStatus {\n        EXPECT_GE(expected_chunk_size, data.length());\n        EXPECT_EQ(1, data.getRawSlices().size());\n        filter_seen += data.length();\n        data.drain(data.length());\n        if (filter_seen == (write_size * num_writes)) {\n          server_connection_->close(Network::ConnectionCloseType::FlushWrite);\n        }\n        return Network::FilterStatus::StopIteration;\n      }));\n\n  EXPECT_CALL(client_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void {\n        EXPECT_EQ((write_size * num_writes), filter_seen);\n        dispatcher_->exit();\n      }));\n\n  for (uint32_t i = 0; i < num_writes; i++) {\n    Buffer::OwnedImpl data(std::string(write_size, 'a'));\n    client_connection_->write(data, false);\n  }\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\n// Test asynchronous signing (ECDHE) using a private key provider.\nTEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncSignSuccess) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: false\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string successful_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-RSA-AES128-GCM-SHA256\n)EOF\";\n\n  TestUtilOptions successful_test_options(successful_client_ctx_yaml, server_ctx_yaml, true,\n                                          GetParam());\n  testUtil(successful_test_options.setPrivateKeyMethodExpected(true));\n}\n\n// Test asynchronous decryption (RSA).\nTEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncDecryptSuccess) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: decrypt\n            sync_mode: false\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string successful_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  TestUtilOptions successful_test_options(successful_client_ctx_yaml, server_ctx_yaml, true,\n                                          GetParam());\n  testUtil(successful_test_options.setPrivateKeyMethodExpected(true));\n}\n\n// Test synchronous signing (ECDHE).\nTEST_P(SslSocketTest, RsaPrivateKeyProviderSyncSignSuccess) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string successful_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-RSA-AES128-GCM-SHA256\n)EOF\";\n\n  TestUtilOptions successful_test_options(successful_client_ctx_yaml, server_ctx_yaml, true,\n                                          GetParam());\n  testUtil(successful_test_options.setPrivateKeyMethodExpected(true));\n}\n\n// Test synchronous decryption (RSA).\nTEST_P(SslSocketTest, RsaPrivateKeyProviderSyncDecryptSuccess) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: decrypt\n            sync_mode: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string successful_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  TestUtilOptions successful_test_options(successful_client_ctx_yaml, server_ctx_yaml, true,\n                                          GetParam());\n  testUtil(successful_test_options.setPrivateKeyMethodExpected(true));\n}\n\n// Test asynchronous signing (ECDHE) failure (invalid signature).\nTEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncSignFailure) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: false\n            crypto_error: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string failing_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-RSA-AES128-GCM-SHA256\n)EOF\";\n\n  TestUtilOptions failing_test_options(failing_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(failing_test_options.setPrivateKeyMethodExpected(true).setExpectedServerStats(\n      \"ssl.connection_error\"));\n}\n\n// Test synchronous signing (ECDHE) failure (invalid signature).\nTEST_P(SslSocketTest, RsaPrivateKeyProviderSyncSignFailure) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: true\n            crypto_error: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string failing_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-RSA-AES128-GCM-SHA256\n)EOF\";\n\n  TestUtilOptions failing_test_options(failing_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(failing_test_options.setPrivateKeyMethodExpected(true).setExpectedServerStats(\n      \"ssl.connection_error\"));\n}\n\n// Test the sign operation return with an error.\nTEST_P(SslSocketTest, RsaPrivateKeyProviderSignFailure) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            method_error: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string failing_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-RSA-AES128-GCM-SHA256\n)EOF\";\n\n  TestUtilOptions failing_test_options(failing_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(failing_test_options.setPrivateKeyMethodExpected(true).setExpectedServerStats(\n      \"ssl.connection_error\"));\n}\n\n// Test the decrypt operation return with an error.\nTEST_P(SslSocketTest, RsaPrivateKeyProviderDecryptFailure) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: decrypt\n            method_error: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string failing_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  TestUtilOptions failing_test_options(failing_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(failing_test_options.setPrivateKeyMethodExpected(true).setExpectedServerStats(\n      \"ssl.connection_error\"));\n}\n\n// Test the sign operation return with an error in complete.\nTEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncSignCompleteFailure) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            async_method_error: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string failing_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-RSA-AES128-GCM-SHA256\n)EOF\";\n\n  TestUtilOptions failing_test_options(failing_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(failing_test_options.setPrivateKeyMethodExpected(true)\n               .setExpectedServerCloseEvent(Network::ConnectionEvent::LocalClose)\n               .setExpectedServerStats(\"ssl.connection_error\"));\n}\n\n// Test the decrypt operation return with an error in complete.\nTEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncDecryptCompleteFailure) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: decrypt\n            async_method_error: true\n            mode: rsa\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n      crl:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.crl\"\n)EOF\";\n  const std::string failing_client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  TestUtilOptions failing_test_options(failing_client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(failing_test_options.setPrivateKeyMethodExpected(true)\n               .setExpectedServerCloseEvent(Network::ConnectionEvent::LocalClose)\n               .setExpectedServerStats(\"ssl.connection_error\")\n               .setExpectedTransportFailureReasonContains(\"system library\")\n               .setNotExpectedClientStats(\"ssl.connection_error\"));\n}\n\n// Test having one cert with private key method and another with just\n// private key.\nTEST_P(SslSocketTest, RsaPrivateKeyProviderMultiCertSuccess) {\n  const std::string client_ctx_yaml = absl::StrCat(R\"EOF(\n    common_tls_context:\n      tls_params:\n        tls_minimum_protocol_version: TLSv1_2\n        tls_maximum_protocol_version: TLSv1_2\n        cipher_suites:\n        - ECDHE-ECDSA-AES128-GCM-SHA256\n        - ECDHE-RSA-AES128-GCM-SHA256\n      validation_context:\n        verify_certificate_hash: )EOF\",\n                                                   TEST_SELFSIGNED_ECDSA_P256_CERT_256_HASH);\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: false\n            mode: rsa\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem\"\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setPrivateKeyMethodExpected(true));\n}\n\n// Test having two certs with private key methods. This will\n// synchronously fail because the second certificate is a ECDSA one and\n// the RSA method can't handle it.\nTEST_P(SslSocketTest, RsaPrivateKeyProviderMultiCertFail) {\n  const std::string client_ctx_yaml = absl::StrCat(R\"EOF(\n    common_tls_context:\n      tls_params:\n        tls_minimum_protocol_version: TLSv1_2\n        tls_maximum_protocol_version: TLSv1_2\n        cipher_suites:\n        - ECDHE-ECDSA-AES128-GCM-SHA256\n        - ECDHE-RSA-AES128-GCM-SHA256\n      validation_context:\n        verify_certificate_hash: )EOF\",\n                                                   TEST_SELFSIGNED_ECDSA_P256_CERT_256_HASH);\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: false\n            mode: rsa\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem\"\n            expected_operation: sign\n            sync_mode: false\n            mode: rsa\n)EOF\";\n\n  TestUtilOptions failing_test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  EXPECT_THROW_WITH_MESSAGE(testUtil(failing_test_options.setPrivateKeyMethodExpected(true)),\n                            EnvoyException, \"Private key is not RSA.\")\n}\n\n// Test ECDSA private key method provider mode.\nTEST_P(SslSocketTest, EcdsaPrivateKeyProviderSuccess) {\n  const std::string client_ctx_yaml = absl::StrCat(R\"EOF(\n    common_tls_context:\n      tls_params:\n        tls_minimum_protocol_version: TLSv1_2\n        tls_maximum_protocol_version: TLSv1_2\n        cipher_suites:\n        - ECDHE-ECDSA-AES128-GCM-SHA256\n      validation_context:\n        verify_certificate_hash: )EOF\",\n                                                   TEST_SELFSIGNED_ECDSA_P256_CERT_256_HASH);\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem\"\n            expected_operation: sign\n            mode: ecdsa\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setPrivateKeyMethodExpected(true));\n}\n\n// Test having two certs with different private key method modes. It's expected that the ECDSA\n// provider mode is being used. RSA provider mode is set to fail with \"async_method_error\", but\n// that's not happening.\nTEST_P(SslSocketTest, RsaAndEcdsaPrivateKeyProviderMultiCertSuccess) {\n  const std::string client_ctx_yaml = absl::StrCat(R\"EOF(\n    common_tls_context:\n      tls_params:\n        tls_minimum_protocol_version: TLSv1_2\n        tls_maximum_protocol_version: TLSv1_2\n        cipher_suites:\n        - ECDHE-ECDSA-AES128-GCM-SHA256\n        - ECDHE-RSA-AES128-GCM-SHA256\n      validation_context:\n        verify_certificate_hash: )EOF\",\n                                                   TEST_SELFSIGNED_ECDSA_P256_CERT_256_HASH);\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: false\n            async_method_error: true\n            mode: rsa\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem\"\n            expected_operation: sign\n            mode: ecdsa\n)EOF\";\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setPrivateKeyMethodExpected(true));\n}\n\n// Test having two certs with different private key method modes. ECDSA provider is set to fail.\nTEST_P(SslSocketTest, RsaAndEcdsaPrivateKeyProviderMultiCertFail) {\n  const std::string client_ctx_yaml = absl::StrCat(R\"EOF(\n    common_tls_context:\n      tls_params:\n        tls_minimum_protocol_version: TLSv1_2\n        tls_maximum_protocol_version: TLSv1_2\n        cipher_suites:\n        - ECDHE-ECDSA-AES128-GCM-SHA256\n        - ECDHE-RSA-AES128-GCM-SHA256\n      validation_context:\n        verify_certificate_hash: )EOF\",\n                                                   TEST_SELFSIGNED_ECDSA_P256_CERT_256_HASH);\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/unittest_key.pem\"\n            expected_operation: sign\n            sync_mode: false\n            mode: rsa\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert.pem\"\n      private_key_provider:\n        provider_name: test\n        typed_config:\n          \"@type\": type.googleapis.com/google.protobuf.Struct\n          value:\n            private_key_file: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_key.pem\"\n            expected_operation: sign\n            async_method_error: true\n            mode: ecdsa\n)EOF\";\n  TestUtilOptions failing_test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(failing_test_options.setPrivateKeyMethodExpected(true)\n               .setExpectedServerCloseEvent(Network::ConnectionEvent::LocalClose)\n               .setExpectedServerStats(\"ssl.connection_error\"));\n}\n\nTEST_P(SslSocketTest, TestStaplesOcspResponseSuccess) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_ocsp_resp.der\"\n  ocsp_staple_policy: lenient_stapling\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n\n  std::string ocsp_response_path =\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_ocsp_resp.der\";\n  std::string expected_response =\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(ocsp_response_path));\n\n  testUtil(test_options.enableOcspStapling()\n               .setExpectedOcspResponse(expected_response)\n               .setExpectedServerStats(\"ssl.ocsp_staple_responses\"));\n}\n\nTEST_P(SslSocketTest, TestNoOcspStapleWhenNotEnabledOnClient) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_ocsp_resp.der\"\n  ocsp_staple_policy: must_staple\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options);\n}\n\nTEST_P(SslSocketTest, TestOcspStapleOmittedOnSkipStaplingAndResponseExpired) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/unknown_ocsp_resp.der\"\n  ocsp_staple_policy: lenient_stapling\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.ocsp_staple_omitted\").enableOcspStapling());\n}\n\nTEST_P(SslSocketTest, TestConnectionFailsOnStapleRequiredAndOcspExpired) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/unknown_ocsp_resp.der\"\n  ocsp_staple_policy: must_staple\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.ocsp_staple_failed\").enableOcspStapling());\n}\n\nTEST_P(SslSocketTest, TestConnectionSucceedsWhenRejectOnExpiredNoOcspResponse) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_key.pem\"\n  ocsp_staple_policy: strict_stapling\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.ocsp_staple_omitted\").enableOcspStapling());\n}\n\nTEST_P(SslSocketTest, TestConnectionFailsWhenRejectOnExpiredAndResponseExpired) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/unknown_ocsp_resp.der\"\n  ocsp_staple_policy: strict_stapling\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.ocsp_staple_failed\").enableOcspStapling());\n}\n\nTEST_P(SslSocketTest, TestConnectionFailsWhenCertIsMustStapleAndResponseExpired) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/revoked_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/revoked_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/revoked_ocsp_resp.der\"\n  ocsp_staple_policy: lenient_stapling\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.ocsp_staple_failed\").enableOcspStapling());\n}\n\nTEST_P(SslSocketTest, TestFilterMultipleCertsFilterByOcspPolicyFallbackOnFirst) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_ocsp_resp.der\"\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/ecdsa_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/ecdsa_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/ecdsa_ocsp_resp.der\"\n  ocsp_staple_policy: must_staple\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-ECDSA-AES128-GCM-SHA256\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  std::string ocsp_response_path =\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/good_ocsp_resp.der\";\n  std::string expected_response =\n      TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(ocsp_response_path));\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, true, GetParam());\n  testUtil(test_options.enableOcspStapling()\n               .setExpectedServerStats(\"ssl.ocsp_staple_responses\")\n               .setExpectedOcspResponse(expected_response));\n}\n\nTEST_P(SslSocketTest, TestConnectionFailsOnMultipleCertificatesNonePassOcspPolicy) {\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/revoked_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/revoked_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/revoked_ocsp_resp.der\"\n    - certificate_chain:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/ecdsa_cert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/ecdsa_key.pem\"\n      ocsp_staple:\n        filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/ocsp/test_data/ecdsa_ocsp_resp.der\"\n  ocsp_staple_policy: must_staple\n  )EOF\";\n\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_params:\n      cipher_suites:\n      - ECDHE-ECDSA-AES128-GCM-SHA256\n      - TLS_RSA_WITH_AES_128_GCM_SHA256\n)EOF\";\n\n  TestUtilOptions test_options(client_ctx_yaml, server_ctx_yaml, false, GetParam());\n  testUtil(test_options.setExpectedServerStats(\"ssl.ocsp_staple_failed\").enableOcspStapling());\n}\n\n} // namespace Tls\n} // namespace TransportSockets\n} // namespace Extensions\n} // namespace Envoy\n"], "buggy_code_start_loc": [17, 65, 380, 3375], "buggy_code_end_loc": [17, 66, 380, 3375], "fixing_code_start_loc": [18, 65, 381, 3376], "fixing_code_end_loc": [23, 69, 410, 3534], "type": "CWE-295", "message": "Envoy is an open source edge and service proxy, designed for cloud-native applications. Envoy's tls allows re-use when some cert validation settings have changed from their default configuration. The only workaround for this issue is to ensure that default tls settings are used. Users are advised to upgrade.", "other": {"cve": {"id": "CVE-2022-21654", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-22T23:15:11.103", "lastModified": "2022-03-03T18:11:35.557", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Envoy is an open source edge and service proxy, designed for cloud-native applications. Envoy's tls allows re-use when some cert validation settings have changed from their default configuration. The only workaround for this issue is to ensure that default tls settings are used. Users are advised to upgrade."}, {"lang": "es", "value": "Envoy es un proxy de borde y servicio de c\u00f3digo abierto, dise\u00f1ado para aplicaciones nativas de la nube. El tls de Envoy permite la reutilizaci\u00f3n cuando algunos ajustes de validaci\u00f3n de cert han cambiado de su configuraci\u00f3n por defecto. La \u00fanica medida de mitigaci\u00f3n para este problema es asegurarse de que es usada la configuraci\u00f3n tls por defecto. Es recomendado a usuarios actualizar"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.7.0", "versionEndExcluding": "1.18.6", "matchCriteriaId": "62EFF3F2-C20D-497C-ADEC-9FF2FD141466"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.19.0", "versionEndExcluding": "1.19.3", "matchCriteriaId": "2812AC62-44B5-4077-862D-A221CD88981D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.20.0", "versionEndExcluding": "1.20.2", "matchCriteriaId": "F5441B2D-F807-4ED9-AFB9-ED4DE07CE5F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.21.0", "versionEndExcluding": "1.21.1", "matchCriteriaId": "83895D03-DAD1-4893-8A1C-F9143DEEC172"}]}]}], "references": [{"url": "https://github.com/envoyproxy/envoy/commit/e9f936d85dc1edc34fabd0a1725ec180f2316353", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-5j4x-g36v-m283", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/envoyproxy/envoy/commit/e9f936d85dc1edc34fabd0a1725ec180f2316353"}}