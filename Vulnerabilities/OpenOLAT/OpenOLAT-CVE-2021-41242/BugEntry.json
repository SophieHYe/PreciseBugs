{"buggy_code": ["/**\n* OLAT - Online Learning and Training<br>\n* http://www.olat.org\n* <p>\n* Licensed under the Apache License, Version 2.0 (the \"License\"); <br>\n* you may not use this file except in compliance with the License.<br>\n* You may obtain a copy of the License at\n* <p>\n* http://www.apache.org/licenses/LICENSE-2.0\n* <p>\n* Unless required by applicable law or agreed to in writing,<br>\n* software distributed under the License is distributed on an \"AS IS\" BASIS, <br>\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. <br>\n* See the License for the specific language governing permissions and <br>\n* limitations under the License.\n* <p>\n* Copyright (c) since 2004 at Multimedia- & E-Learning Services (MELS),<br>\n* University of Zurich, Switzerland.\n* <hr>\n* <a href=\"http://www.openolat.org\">\n* OpenOLAT - Online Learning and Training</a><br>\n* This file has been modified by the OpenOLAT community. Changes are licensed\n* under the Apache 2.0 license as the original file.  \n* <p>\n*/ \n\npackage org.olat.core.util.vfs;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.logging.log4j.Logger;\nimport org.olat.core.CoreSpringFactory;\nimport org.olat.core.commons.modules.bc.FolderConfig;\nimport org.olat.core.commons.services.vfs.VFSRepositoryModule;\nimport org.olat.core.commons.services.vfs.VFSRepositoryService;\nimport org.olat.core.id.Identity;\nimport org.olat.core.logging.AssertException;\nimport org.olat.core.logging.Tracing;\nimport org.olat.core.logging.activity.ThreadLocalUserActivityLogger;\nimport org.olat.core.util.FileUtils;\nimport org.olat.core.util.vfs.filters.VFSItemFilter;\nimport org.olat.core.util.vfs.filters.VFSSystemItemFilter;\nimport org.olat.core.util.vfs.filters.VFSVersionsItemFilter;\n\n/**\n * Description:<br>\n * VFSContainer implementation that is based on a java.io.File from a local\n * filesystem. It implements a regular directory\n * \n * <P>\n * Initial Date: 23.06.2005 <br>\n * \n * @author Felix Jost\n */\npublic class LocalFolderImpl extends LocalImpl implements VFSContainer {\n\tprivate static final Logger log = Tracing.createLoggerFor(LocalFolderImpl.class);\n\n\tprivate VFSItemFilter defaultFilter;\n\t\n\t/**\n\t * @param folderfile\n\t */\n\tprivate LocalFolderImpl() {\n\t\tsuper(null, null);\n\t\tthrow new AssertException(\"Cannot instantiate LocalFolderImpl().\");\n\t}\n\t\n\t/**\n\t * Constructor\n\t * @param folderFile The real file of type directory wrapped by this VFSContainer\n\t */\n\tpublic LocalFolderImpl(File folderFile) {\n\t\tthis(folderFile, null);\n\t}\n\t\n\t/**\n\t * @param folderfile\n\t */\n\tpublic LocalFolderImpl(File folderfile, VFSContainer parent) {\n\t\tsuper(folderfile, parent);\n\t\tboolean alreadyExists = folderfile.exists();\n\t\tboolean succesfullCreated = alreadyExists || folderfile.mkdirs();\n\t\t//check against concurrent creation of the folder, mkdirs return false if the directory exists\n\t\tif (!alreadyExists && !succesfullCreated && folderfile.exists()) {\n\t\t\tsuccesfullCreated = true;\n\t\t}\n\t\tif (!alreadyExists && !succesfullCreated) {\n\t\t\tthrow new AssertException(\"Cannot create directory of LocalFolderImpl with reason (exists= ): \"+alreadyExists+\" && created= \"+succesfullCreated+\") path: \" + folderfile.getAbsolutePath());\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems() {\n\t\treturn getItems(null);\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems(VFSItemFilter filter) {\n\t\tFile aFolder = getBasefile();\n\t\tif(! aFolder.isDirectory()){\n\t\t\tthrow new AssertException(\"basefile is not a directory: \"+aFolder.getAbsolutePath());\t\t\t\n\t\t}\n\t\tFile[] children = aFolder.listFiles();\n\t\tif(children == null) {\n\t\t\tchildren = new File[0];\n\t\t}\n\t\tint len = children.length;\n\t\tList<VFSItem> res = new ArrayList<>(len);\n\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tFile af = children[i];\n\t\t\tVFSItem item;\n\t\t\tif (af.isDirectory()) {\n\t\t\t\tLocalFolderImpl folderItem = new LocalFolderImpl(af, this);\n\t\t\t\tfolderItem.setDefaultItemFilter(defaultFilter);\n\t\t\t\titem = folderItem;\n\t\t\t} else {\n\t\t\t\titem = new LocalFileImpl(af, this);\n\t\t\t}\n\t\t\tif ((defaultFilter == null || defaultFilter.accept(item))\n\t\t\t\t\t&& (filter == null || filter.accept(item))) {\n\t\t\t\tres.add(item);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t@Override\n\tpublic void setDefaultItemFilter(VFSItemFilter defaultFilter){\n\t\tthis.defaultFilter = defaultFilter;\n\t}\n\n\t@Override\n\tpublic VFSStatus copyFrom(VFSItem source, Identity savedBy) {\n\t\treturn copyFrom(source, true, savedBy);\n\t}\n\t\n\t@Override\n\tpublic VFSStatus copyContentOf(VFSContainer container, Identity savedBy) {\n\t\tVFSStatus status = VFSConstants.YES;\n\t\tfor(VFSItem item:container.getItems(new VFSSystemItemFilter())) {\n\t\t\tstatus = copyFrom(item, true, savedBy);\n\t\t}\n\t\treturn status;\n\t}\n\n\t/**\n\t * Internal copy from, preventing quota checks on subfolders.\n\t * \n\t * @param source\n\t * @param checkQuota\n\t * @param savedBy \n\t * @return\n\t */\n\tprivate VFSStatus copyFrom(VFSItem source, boolean checkQuota, Identity savedBy) {\n\t\tif (source.canCopy() != VFSConstants.YES) {\n\t\t\tlog.warn(\"Cannot copy file {} security denied\", source);\n\t\t\treturn VFSConstants.NO_SECURITY_DENIED;\n\t\t}\n\t\t\n\t\tString sourcename = source.getName();\n\t\tFile basefile = getBasefile();\n\n\t\t// check if there is already an item with the same name...\n\t\tif (resolve(sourcename) != null) {\n\t\t\tlog.warn(\"Cannot copy file {} name already used\", sourcename);\n\t\t\treturn VFSConstants.ERROR_NAME_ALREDY_USED;\n\t\t}\n\t\t\n\t\t// add either file bla.txt or folder blu as a child of this folder\n\t\tif (source instanceof VFSContainer) {\n\t\t\t// copy recursively\n\t\t\tVFSContainer sourcecontainer = (VFSContainer)source;\n\t\t\t// check if this is a containing container...\n\t\t\tif (VFSManager.isSelfOrParent(sourcecontainer, this)) {\n\t\t\t\tlog.warn(\"Cannot copy file {}  overlapping\", this);\n\t\t\t\treturn VFSConstants.ERROR_OVERLAPPING;\n\t\t\t}\n\t\t\t\n\t\t\t// \"copy\" the container means creating a folder with that name\n\t\t\t// and let the children copy\n\n\t\t\t// create the folder\n\t\t\tLocalFolderImpl rootcopyfolder = new LocalFolderImpl(new File(basefile, sourcename), this);\n\t\t\tList<VFSItem> children = sourcecontainer.getItems(new VFSVersionsItemFilter());\n\t\t\tfor (VFSItem chd:children) {\n\t\t\t\tVFSStatus status = rootcopyfolder.copyFrom(chd, false, savedBy);\n\t\t\t\tif (status != VFSConstants.SUCCESS) {\n\t\t\t\t\tlog.warn(\"Cannot copy file {} with status {}\", chd, status);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (source instanceof VFSLeaf) {\n\t\t\t// copy single item\n\t\t\tVFSLeaf s = (VFSLeaf) source;\n\t\t\t// check quota\n\t\t\tif (checkQuota) {\n\t\t\t\tlong quotaLeft = VFSManager.getQuotaLeftKB(this);\n\t\t\t\tif(quotaLeft != Quota.UNLIMITED && quotaLeft < (s.getSize() / 1024)) {\n\t\t\t\t\tlog.warn(\"Cannot copy file {} quota exceeded {}\", s, quotaLeft);\n\t\t\t\t\treturn VFSConstants.ERROR_QUOTA_EXCEEDED;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tFile fTarget = new File(basefile, sourcename);\n\t\t\ttry(InputStream in=s.getInputStream()) {\n\t\t\t\tFileUtils.bcopy(in, fTarget, \"VFScopyFrom\");\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn VFSConstants.ERROR_FAILED;\n\t\t\t}\n\n\t\t\tif(s.canMeta() == VFSConstants.YES || s.canVersion() == VFSConstants.YES) {\n\t\t\t\tVFSItem target = resolve(sourcename);\n\t\t\t\tif(target instanceof VFSLeaf && (target.canMeta() == VFSConstants.YES || s.canVersion() == VFSConstants.YES)) {\n\t\t\t\t\tVFSRepositoryService vfsRepositoryService = CoreSpringFactory.getImpl(VFSRepositoryService.class);\n\t\t\t\t\tvfsRepositoryService.itemSaved( (VFSLeaf)target, savedBy);\n\t\t\t\t\tvfsRepositoryService.copyTo(s, (VFSLeaf)target, this, savedBy);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"neither a leaf nor a container!\");\n\t\t}\n\t\treturn VFSConstants.SUCCESS;\n\t}\n\n\t@Override\n\tpublic VFSStatus canWrite() {\n\t\tVFSContainer inheritingContainer = VFSManager.findInheritingSecurityCallbackContainer(this);\n\t\tif (inheritingContainer != null && !inheritingContainer.getLocalSecurityCallback().canWrite())\n\t\t\treturn VFSConstants.NO_SECURITY_DENIED;\n\t\treturn VFSConstants.YES;\n\t}\n\t\n\t@Override\n\tpublic VFSStatus canVersion() {\n\t\treturn VFSRepositoryModule.canVersion(getBasefile());\n\t}\n\n\t@Override\n\tpublic VFSStatus rename(String newname) {\n\t\tCoreSpringFactory.getImpl(VFSRepositoryService.class).rename(this, newname);\n\t\t\n\t\tFile f = getBasefile();\n\t\tFile par = f.getParentFile();\n\t\tFile nf = new File(par, newname);\n\t\tboolean ren = f.renameTo(nf);\n\t\tif (ren) {\n\t\t\t// f.renameTo() does NOT modify the path contained in the object f!!\n\t\t\t// The guys at sun consider this a feature and not a bug...\n\t\t\t// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4094022\n\t\t\t// We need to manually reload the new basefile and set it in our parent\n\t\t\tsuper.setBasefile(new File(nf.getAbsolutePath()));\n\t\t\treturn VFSConstants.YES; \n\t\t} else {\n\t\t\treturn VFSConstants.NO;\n\t\t}\n\t}\n\n\t@Override\n\tpublic VFSStatus delete() {\n\t\tif(!getBasefile().exists()) {\n\t\t\treturn VFSConstants.YES;  // already non-existent\n\t\t}\n\t\t// we must empty the folders and subfolders first\n\t\tList<VFSItem> children = getItems();\n\t\tfor (VFSItem child:children) {\n\t\t\tchild.delete();\n\t\t}\n\t\t\n\t\t// Versioning makes a copy of the metadata, delete metadata after it\n\t\tif(canMeta() == VFSConstants.YES) {\n\t\t\tIdentity identity = ThreadLocalUserActivityLogger.getLoggedIdentity();\n\t\t\tCoreSpringFactory.getImpl(VFSRepositoryService.class).markAsDeleted(this, identity);\n\t\t}\n\t\t// now delete the directory itself\n\t\treturn deleteBasefile();\n\t}\n\n\t@Override\n\tpublic VFSStatus deleteSilently() {\n\t\tif(!getBasefile().exists()) {\n\t\t\treturn VFSConstants.YES;  // already non-existent\n\t\t}\n\t\t// we must empty the folders and subfolders first\n\t\tList<VFSItem> children = getItems();\n\t\tfor (VFSItem child:children) {\n\t\t\tchild.deleteSilently(); \n\t\t}\n\t\t\n\t\tif(canMeta() == VFSConstants.YES) {\n\t\t\tCoreSpringFactory.getImpl(VFSRepositoryService.class).deleteMetadata(getMetaInfo());\n\t\t}\n\t\t// now delete the directory itself\n\t\treturn deleteBasefile();\n\t}\n\t\n\tprivate VFSStatus deleteBasefile() {\n\t\tVFSStatus status = VFSConstants.NO;\n\t\ttry {\n\t\t\t// walk tree make sure the directory is deleted once all files,\n\t\t\t// versions files and others are properly deleted\n\t\t\tFiles.walkFileTree(getBasefile().toPath(), new SimpleFileVisitor<Path>() {\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n\t\t\t\t\tFiles.delete(file);\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n\t\t\t\t\tFiles.delete(dir);\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t}\n\t\t\t});\n\t\t\tstatus = VFSConstants.YES;\n\t\t} catch(IOException e) {\n\t\t\tlog.error(\"Cannot delete base file: \" + this, e);\n\t\t}\n\t\treturn status;\n\t}\n\t\n\t@Override\n\tpublic VFSItem resolve(String path) {\n\t\tVFSItem resolved = VFSManager.resolveFile(this, path);\n\t\t// set default filter on resolved file if it is a container\n\t\tif (resolved instanceof VFSContainer) {\n\t\t\tVFSContainer resolvedContainer = (VFSContainer) resolved;\n\t\t\tresolvedContainer.setDefaultItemFilter(defaultFilter);\n\t\t}\n\t\treturn resolved;\n\t}\n\n\t@Override\n\tpublic boolean isInPath(String path) {\n\t\tPath bFile = getBasefile().toPath();\n\t\tPath filePath = bFile.resolve(path);\n\t\tPath normalizedPath = filePath.normalize();\n\t\treturn normalizedPath.startsWith(bFile);\n\t}\n\n\t@Override\n\tpublic String getRelPath() {\n\t\tPath bFile = getBasefile().toPath();\n\t\tPath bcRoot = FolderConfig.getCanonicalRootPath();\n\t\t\n\t\tString relPath;\n\t\tif(bFile.startsWith(bcRoot)) {\n\t\t\trelPath = bcRoot.relativize(bFile).toString();\n\t\t\tif(relPath.endsWith(\"/\")) {\n\t\t\t\trelPath = relPath.substring(0, relPath.length() - 1);\n\t\t\t}\n\t\t\tif(!relPath.startsWith(\"/\")) {\n\t\t\t\trelPath = \"/\".concat(relPath);\n\t\t\t}\n\t\t} else {\n\t\t\trelPath = null;\n\t\t}\n\t\treturn relPath;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"LFolder [base=\"+getBasefile()+\"] \";\n\t}\n\n\t@Override\n\tpublic VFSContainer createChildContainer(String name) {\n\t\tFile fNewFile = new File(getBasefile(), name);\n\t\tif(!isInPath(name)) {\n\t\t\tlog.warn(\"Could not create a new container::{} in container::{} - file out of parent directory\", name, getBasefile().getAbsolutePath());\n\t\t\treturn null;\n\t\t}\n\t\tif (!fNewFile.mkdir()) {\n\t\t\treturn null;\n\t\t}\n\t\tLocalFolderImpl locFI =  new LocalFolderImpl(fNewFile, this);\n\t\tlocFI.setDefaultItemFilter(defaultFilter);\n\t\treturn locFI;\n\t}\n\n\t@Override\n\tpublic VFSLeaf createChildLeaf(String name) {\n\t\tFile fNewFile = new File(getBasefile(), name);\n\t\ttry {\n\t\t\tif(!isInPath(name)) {\n\t\t\t\tlog.warn(\"Could not create a new leaf::{} in container::{} - file out of parent directory\", name, getBasefile().getAbsolutePath());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(!fNewFile.getParentFile().exists()) {\n\t\t\t\tfNewFile.getParentFile().mkdirs();\n\t\t\t}\n\t\t\tif (!fNewFile.createNewFile()) {\n\t\t\t\tlog.warn(\"Could not create a new leaf::{} in container::{} - file alreay exists\", name, getBasefile().getAbsolutePath());\n\t\t\t\treturn null;\n\t\t\t} \n\t\t} catch (Exception e) {\n\t\t\tlog.error(\"Error while creating child leaf::{} in container::{}\", name, getBasefile().getAbsolutePath(), e);\n\t\t\treturn null;\n\t\t}\n\t\treturn new LocalFileImpl(fNewFile, this);\n\t}\n\n\t@Override\n\tpublic VFSItemFilter getDefaultItemFilter() {\n\t\treturn defaultFilter;\n\t}\n}\n"], "fixing_code": ["/**\n* OLAT - Online Learning and Training<br>\n* http://www.olat.org\n* <p>\n* Licensed under the Apache License, Version 2.0 (the \"License\"); <br>\n* you may not use this file except in compliance with the License.<br>\n* You may obtain a copy of the License at\n* <p>\n* http://www.apache.org/licenses/LICENSE-2.0\n* <p>\n* Unless required by applicable law or agreed to in writing,<br>\n* software distributed under the License is distributed on an \"AS IS\" BASIS, <br>\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. <br>\n* See the License for the specific language governing permissions and <br>\n* limitations under the License.\n* <p>\n* Copyright (c) since 2004 at Multimedia- & E-Learning Services (MELS),<br>\n* University of Zurich, Switzerland.\n* <hr>\n* <a href=\"http://www.openolat.org\">\n* OpenOLAT - Online Learning and Training</a><br>\n* This file has been modified by the OpenOLAT community. Changes are licensed\n* under the Apache 2.0 license as the original file.  \n* <p>\n*/ \n\npackage org.olat.core.util.vfs;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.logging.log4j.Logger;\nimport org.olat.core.CoreSpringFactory;\nimport org.olat.core.commons.modules.bc.FolderConfig;\nimport org.olat.core.commons.services.vfs.VFSRepositoryModule;\nimport org.olat.core.commons.services.vfs.VFSRepositoryService;\nimport org.olat.core.id.Identity;\nimport org.olat.core.logging.AssertException;\nimport org.olat.core.logging.Tracing;\nimport org.olat.core.logging.activity.ThreadLocalUserActivityLogger;\nimport org.olat.core.util.FileUtils;\nimport org.olat.core.util.vfs.filters.VFSItemFilter;\nimport org.olat.core.util.vfs.filters.VFSSystemItemFilter;\nimport org.olat.core.util.vfs.filters.VFSVersionsItemFilter;\n\n/**\n * Description:<br>\n * VFSContainer implementation that is based on a java.io.File from a local\n * filesystem. It implements a regular directory\n * \n * <P>\n * Initial Date: 23.06.2005 <br>\n * \n * @author Felix Jost\n */\npublic class LocalFolderImpl extends LocalImpl implements VFSContainer {\n\tprivate static final Logger log = Tracing.createLoggerFor(LocalFolderImpl.class);\n\n\tprivate VFSItemFilter defaultFilter;\n\t\n\t/**\n\t * @param folderfile\n\t */\n\tprivate LocalFolderImpl() {\n\t\tsuper(null, null);\n\t\tthrow new AssertException(\"Cannot instantiate LocalFolderImpl().\");\n\t}\n\t\n\t/**\n\t * Constructor\n\t * @param folderFile The real file of type directory wrapped by this VFSContainer\n\t */\n\tpublic LocalFolderImpl(File folderFile) {\n\t\tthis(folderFile, null);\n\t}\n\t\n\t/**\n\t * @param folderfile\n\t */\n\tpublic LocalFolderImpl(File folderfile, VFSContainer parent) {\n\t\tsuper(folderfile, parent);\n\t\tboolean alreadyExists = folderfile.exists();\n\t\tboolean succesfullCreated = alreadyExists || folderfile.mkdirs();\n\t\t//check against concurrent creation of the folder, mkdirs return false if the directory exists\n\t\tif (!alreadyExists && !succesfullCreated && folderfile.exists()) {\n\t\t\tsuccesfullCreated = true;\n\t\t}\n\t\tif (!alreadyExists && !succesfullCreated) {\n\t\t\tthrow new AssertException(\"Cannot create directory of LocalFolderImpl with reason (exists= ): \"+alreadyExists+\" && created= \"+succesfullCreated+\") path: \" + folderfile.getAbsolutePath());\n\t\t}\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems() {\n\t\treturn getItems(null);\n\t}\n\n\t@Override\n\tpublic List<VFSItem> getItems(VFSItemFilter filter) {\n\t\tFile aFolder = getBasefile();\n\t\tif(! aFolder.isDirectory()){\n\t\t\tthrow new AssertException(\"basefile is not a directory: \"+aFolder.getAbsolutePath());\t\t\t\n\t\t}\n\t\tFile[] children = aFolder.listFiles();\n\t\tif(children == null) {\n\t\t\tchildren = new File[0];\n\t\t}\n\t\tint len = children.length;\n\t\tList<VFSItem> res = new ArrayList<>(len);\n\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tFile af = children[i];\n\t\t\tVFSItem item;\n\t\t\tif (af.isDirectory()) {\n\t\t\t\tLocalFolderImpl folderItem = new LocalFolderImpl(af, this);\n\t\t\t\tfolderItem.setDefaultItemFilter(defaultFilter);\n\t\t\t\titem = folderItem;\n\t\t\t} else {\n\t\t\t\titem = new LocalFileImpl(af, this);\n\t\t\t}\n\t\t\tif ((defaultFilter == null || defaultFilter.accept(item))\n\t\t\t\t\t&& (filter == null || filter.accept(item))) {\n\t\t\t\tres.add(item);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t@Override\n\tpublic void setDefaultItemFilter(VFSItemFilter defaultFilter){\n\t\tthis.defaultFilter = defaultFilter;\n\t}\n\n\t@Override\n\tpublic VFSStatus copyFrom(VFSItem source, Identity savedBy) {\n\t\treturn copyFrom(source, true, savedBy);\n\t}\n\t\n\t@Override\n\tpublic VFSStatus copyContentOf(VFSContainer container, Identity savedBy) {\n\t\tVFSStatus status = VFSConstants.YES;\n\t\tfor(VFSItem item:container.getItems(new VFSSystemItemFilter())) {\n\t\t\tstatus = copyFrom(item, true, savedBy);\n\t\t}\n\t\treturn status;\n\t}\n\n\t/**\n\t * Internal copy from, preventing quota checks on subfolders.\n\t * \n\t * @param source\n\t * @param checkQuota\n\t * @param savedBy \n\t * @return\n\t */\n\tprivate VFSStatus copyFrom(VFSItem source, boolean checkQuota, Identity savedBy) {\n\t\tif (source.canCopy() != VFSConstants.YES) {\n\t\t\tlog.warn(\"Cannot copy file {} security denied\", source);\n\t\t\treturn VFSConstants.NO_SECURITY_DENIED;\n\t\t}\n\t\t\n\t\tString sourcename = source.getName();\n\t\tFile basefile = getBasefile();\n\n\t\t// check if there is already an item with the same name...\n\t\tif (resolve(sourcename) != null) {\n\t\t\tlog.warn(\"Cannot copy file {} name already used\", sourcename);\n\t\t\treturn VFSConstants.ERROR_NAME_ALREDY_USED;\n\t\t}\n\t\t\n\t\t// add either file bla.txt or folder blu as a child of this folder\n\t\tif (source instanceof VFSContainer) {\n\t\t\t// copy recursively\n\t\t\tVFSContainer sourcecontainer = (VFSContainer)source;\n\t\t\t// check if this is a containing container...\n\t\t\tif (VFSManager.isSelfOrParent(sourcecontainer, this)) {\n\t\t\t\tlog.warn(\"Cannot copy file {}  overlapping\", this);\n\t\t\t\treturn VFSConstants.ERROR_OVERLAPPING;\n\t\t\t}\n\t\t\t\n\t\t\t// \"copy\" the container means creating a folder with that name\n\t\t\t// and let the children copy\n\n\t\t\t// create the folder\n\t\t\tLocalFolderImpl rootcopyfolder = new LocalFolderImpl(new File(basefile, sourcename), this);\n\t\t\tList<VFSItem> children = sourcecontainer.getItems(new VFSVersionsItemFilter());\n\t\t\tfor (VFSItem chd:children) {\n\t\t\t\tVFSStatus status = rootcopyfolder.copyFrom(chd, false, savedBy);\n\t\t\t\tif (status != VFSConstants.SUCCESS) {\n\t\t\t\t\tlog.warn(\"Cannot copy file {} with status {}\", chd, status);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (source instanceof VFSLeaf) {\n\t\t\t// copy single item\n\t\t\tVFSLeaf s = (VFSLeaf) source;\n\t\t\t// check quota\n\t\t\tif (checkQuota) {\n\t\t\t\tlong quotaLeft = VFSManager.getQuotaLeftKB(this);\n\t\t\t\tif(quotaLeft != Quota.UNLIMITED && quotaLeft < (s.getSize() / 1024)) {\n\t\t\t\t\tlog.warn(\"Cannot copy file {} quota exceeded {}\", s, quotaLeft);\n\t\t\t\t\treturn VFSConstants.ERROR_QUOTA_EXCEEDED;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tFile fTarget = new File(basefile, sourcename);\n\t\t\ttry(InputStream in=s.getInputStream()) {\n\t\t\t\tFileUtils.bcopy(in, fTarget, \"VFScopyFrom\");\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn VFSConstants.ERROR_FAILED;\n\t\t\t}\n\n\t\t\tif(s.canMeta() == VFSConstants.YES || s.canVersion() == VFSConstants.YES) {\n\t\t\t\tVFSItem target = resolve(sourcename);\n\t\t\t\tif(target instanceof VFSLeaf && (target.canMeta() == VFSConstants.YES || s.canVersion() == VFSConstants.YES)) {\n\t\t\t\t\tVFSRepositoryService vfsRepositoryService = CoreSpringFactory.getImpl(VFSRepositoryService.class);\n\t\t\t\t\tvfsRepositoryService.itemSaved( (VFSLeaf)target, savedBy);\n\t\t\t\t\tvfsRepositoryService.copyTo(s, (VFSLeaf)target, this, savedBy);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"neither a leaf nor a container!\");\n\t\t}\n\t\treturn VFSConstants.SUCCESS;\n\t}\n\n\t@Override\n\tpublic VFSStatus canWrite() {\n\t\tVFSContainer inheritingContainer = VFSManager.findInheritingSecurityCallbackContainer(this);\n\t\tif (inheritingContainer != null && !inheritingContainer.getLocalSecurityCallback().canWrite())\n\t\t\treturn VFSConstants.NO_SECURITY_DENIED;\n\t\treturn VFSConstants.YES;\n\t}\n\t\n\t@Override\n\tpublic VFSStatus canVersion() {\n\t\treturn VFSRepositoryModule.canVersion(getBasefile());\n\t}\n\n\t@Override\n\tpublic VFSStatus rename(String newname) {\n\t\tCoreSpringFactory.getImpl(VFSRepositoryService.class).rename(this, newname);\n\t\t\n\t\tFile f = getBasefile();\n\t\tFile par = f.getParentFile();\n\t\tFile nf = new File(par, newname);\n\t\tboolean ren = f.renameTo(nf);\n\t\tif (ren) {\n\t\t\t// f.renameTo() does NOT modify the path contained in the object f!!\n\t\t\t// The guys at sun consider this a feature and not a bug...\n\t\t\t// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4094022\n\t\t\t// We need to manually reload the new basefile and set it in our parent\n\t\t\tsuper.setBasefile(new File(nf.getAbsolutePath()));\n\t\t\treturn VFSConstants.YES; \n\t\t} else {\n\t\t\treturn VFSConstants.NO;\n\t\t}\n\t}\n\n\t@Override\n\tpublic VFSStatus delete() {\n\t\tif(!getBasefile().exists()) {\n\t\t\treturn VFSConstants.YES;  // already non-existent\n\t\t}\n\t\t// we must empty the folders and subfolders first\n\t\tList<VFSItem> children = getItems();\n\t\tfor (VFSItem child:children) {\n\t\t\tchild.delete();\n\t\t}\n\t\t\n\t\t// Versioning makes a copy of the metadata, delete metadata after it\n\t\tif(canMeta() == VFSConstants.YES) {\n\t\t\tIdentity identity = ThreadLocalUserActivityLogger.getLoggedIdentity();\n\t\t\tCoreSpringFactory.getImpl(VFSRepositoryService.class).markAsDeleted(this, identity);\n\t\t}\n\t\t// now delete the directory itself\n\t\treturn deleteBasefile();\n\t}\n\n\t@Override\n\tpublic VFSStatus deleteSilently() {\n\t\tif(!getBasefile().exists()) {\n\t\t\treturn VFSConstants.YES;  // already non-existent\n\t\t}\n\t\t// we must empty the folders and subfolders first\n\t\tList<VFSItem> children = getItems();\n\t\tfor (VFSItem child:children) {\n\t\t\tchild.deleteSilently(); \n\t\t}\n\t\t\n\t\tif(canMeta() == VFSConstants.YES) {\n\t\t\tCoreSpringFactory.getImpl(VFSRepositoryService.class).deleteMetadata(getMetaInfo());\n\t\t}\n\t\t// now delete the directory itself\n\t\treturn deleteBasefile();\n\t}\n\t\n\tprivate VFSStatus deleteBasefile() {\n\t\tVFSStatus status = VFSConstants.NO;\n\t\ttry {\n\t\t\t// walk tree make sure the directory is deleted once all files,\n\t\t\t// versions files and others are properly deleted\n\t\t\tFiles.walkFileTree(getBasefile().toPath(), new SimpleFileVisitor<Path>() {\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n\t\t\t\t\tFiles.delete(file);\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n\t\t\t\t\tFiles.delete(dir);\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t\t}\n\t\t\t});\n\t\t\tstatus = VFSConstants.YES;\n\t\t} catch(IOException e) {\n\t\t\tlog.error(\"Cannot delete base file: \" + this, e);\n\t\t}\n\t\treturn status;\n\t}\n\t\n\t@Override\n\tpublic VFSItem resolve(String path) {\n\t\tVFSItem resolved = VFSManager.resolveFile(this, path);\n\t\t// set default filter on resolved file if it is a container\n\t\tif (resolved instanceof VFSContainer) {\n\t\t\tVFSContainer resolvedContainer = (VFSContainer) resolved;\n\t\t\tresolvedContainer.setDefaultItemFilter(defaultFilter);\n\t\t}\n\t\treturn resolved;\n\t}\n\n\t@Override\n\tpublic boolean isInPath(String path) {\n\t\tPath bFile = getBasefile().toPath();\n\t\tPath filePath = bFile.resolve(path);\n\t\tPath normalizedPath = filePath.normalize();\n\t\treturn normalizedPath.startsWith(bFile);\n\t}\n\n\t@Override\n\tpublic String getRelPath() {\n\t\tPath bFile = getBasefile().toPath();\n\t\tPath bcRoot = FolderConfig.getCanonicalRootPath();\n\t\t\n\t\tString relPath;\n\t\tif(bFile.startsWith(bcRoot)) {\n\t\t\trelPath = bcRoot.relativize(bFile).toString();\n\t\t\tif(relPath.endsWith(\"/\")) {\n\t\t\t\trelPath = relPath.substring(0, relPath.length() - 1);\n\t\t\t}\n\t\t\tif(!relPath.startsWith(\"/\")) {\n\t\t\t\trelPath = \"/\".concat(relPath);\n\t\t\t}\n\t\t} else {\n\t\t\trelPath = null;\n\t\t}\n\t\treturn relPath;\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"LFolder [base=\"+getBasefile()+\"] \";\n\t}\n\n\t@Override\n\tpublic VFSContainer createChildContainer(String name) {\n\t\tname = cleanFilename(name); // backward compatibility\n\t\tFile fNewFile = new File(getBasefile(), name);\n\t\tif(!isInPath(name)) {\n\t\t\tlog.warn(\"Could not create a new container::{} in container::{} - file out of parent directory\", name, getBasefile().getAbsolutePath());\n\t\t\treturn null;\n\t\t}\n\t\tif (!fNewFile.mkdir()) {\n\t\t\treturn null;\n\t\t}\n\t\tLocalFolderImpl locFI =  new LocalFolderImpl(fNewFile, this);\n\t\tlocFI.setDefaultItemFilter(defaultFilter);\n\t\treturn locFI;\n\t}\n\n\t@Override\n\tpublic VFSLeaf createChildLeaf(String name) {\n\t\tname = cleanFilename(name); // backward compatibility\n\t\tFile fNewFile = new File(getBasefile(), name);\n\t\ttry {\n\t\t\tif(!isInPath(name)) {\n\t\t\t\tlog.warn(\"Could not create a new leaf::{} in container::{} - file out of parent directory\", name, getBasefile().getAbsolutePath());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(!fNewFile.getParentFile().exists()) {\n\t\t\t\tfNewFile.getParentFile().mkdirs();\n\t\t\t}\n\t\t\tif (!fNewFile.createNewFile()) {\n\t\t\t\tlog.warn(\"Could not create a new leaf::{} in container::{} - file alreay exists\", name, getBasefile().getAbsolutePath());\n\t\t\t\treturn null;\n\t\t\t} \n\t\t} catch (Exception e) {\n\t\t\tlog.error(\"Error while creating child leaf::{} in container::{}\", name, getBasefile().getAbsolutePath(), e);\n\t\t\treturn null;\n\t\t}\n\t\treturn new LocalFileImpl(fNewFile, this);\n\t}\n\t\n\t/**\n\t * It was allowed to have a filename starting with /, but\n\t * it's not legal.\n\t * \n\t * @param name The name\n\t * @return Name without starting /\n\t */\n\tprivate String cleanFilename(String name) {\n\t\tif(name != null && name.startsWith(\"/\")) {\n\t\t\tname = name.substring(1, name.length());\n\t\t}\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic VFSItemFilter getDefaultItemFilter() {\n\t\treturn defaultFilter;\n\t}\n}\n"], "buggy_code_start_loc": [375], "buggy_code_end_loc": [409], "fixing_code_start_loc": [376], "fixing_code_end_loc": [426], "type": "CWE-22", "message": "OpenOlat is a web-basedlearning management system. A path traversal vulnerability exists in OpenOlat prior to versions 15.5.12 and 16.0.5. By providing a filename that contains a relative path as a parameter in some REST methods, it is possible to create directory structures and write files anywhere on the target system. The attack could be used to write files anywhere in the web root folder or outside, depending on the configuration of the system and the properly configured permission of the application server user. The attack requires an OpenOlat user account, an enabled REST API and the rights on a business object to call the vulnerable REST calls. The problem is fixed in version 15.5.12 and 16.0.5. There is a workaround available. The vulnerability requires the REST module to be enabled. Disabling the REST module or limiting the REST module via some firewall or web-server access rules to be accessed only be trusted systems will mitigate the risk.", "other": {"cve": {"id": "CVE-2021-41242", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-10T23:15:09.527", "lastModified": "2022-08-09T13:18:30.977", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenOlat is a web-basedlearning management system. A path traversal vulnerability exists in OpenOlat prior to versions 15.5.12 and 16.0.5. By providing a filename that contains a relative path as a parameter in some REST methods, it is possible to create directory structures and write files anywhere on the target system. The attack could be used to write files anywhere in the web root folder or outside, depending on the configuration of the system and the properly configured permission of the application server user. The attack requires an OpenOlat user account, an enabled REST API and the rights on a business object to call the vulnerable REST calls. The problem is fixed in version 15.5.12 and 16.0.5. There is a workaround available. The vulnerability requires the REST module to be enabled. Disabling the REST module or limiting the REST module via some firewall or web-server access rules to be accessed only be trusted systems will mitigate the risk."}, {"lang": "es", "value": "OpenOlat es un sistema de administraci\u00f3n de aprendizaje basado en la web. Se presenta una vulnerabilidad de salto de ruta en OpenOlat versiones anteriores a 15.5.12 y 16.0.5. Al proporcionar un nombre de archivo que contiene una ruta relativa como par\u00e1metro en algunos m\u00e9todos REST, es posible crear estructuras de directorio y escribir archivos en cualquier lugar del sistema de destino. El ataque podr\u00eda ser usado para escribir archivos en cualquier lugar de la carpeta root de la web o fuera de ella, dependiendo de la configuraci\u00f3n del sistema y del permiso correctamente configurado del usuario del servidor de aplicaciones. El ataque requiere una cuenta de usuario OpenOlat, una API REST habilitada y los derechos sobre un objeto de negocio para llamar a las llamadas REST vulnerables. El problema ha sido corregido en las versiones 15.5.12 y 16.0.5. Se presenta una soluci\u00f3n disponible. La vulnerabilidad requiere que el m\u00f3dulo REST est\u00e9 habilitado. Deshabilitar el m\u00f3dulo REST o limitar el m\u00f3dulo REST por medio de alg\u00fan firewall o regla de acceso al servidor web para que s\u00f3lo sea accedido a sistemas confiables mitigar\u00e1 el riesgo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.9}, "baseSeverity": "HIGH", "exploitabilityScore": 6.8, "impactScore": 9.2, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-23"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:frentix:openolat:*:*:*:*:*:*:*:*", "versionEndExcluding": "15.5.12", "matchCriteriaId": "BDE49065-E5AA-459D-BB9C-12FB74312F7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:frentix:openolat:*:*:*:*:*:*:*:*", "versionStartIncluding": "16.0.0", "versionEndExcluding": "16.0.5", "matchCriteriaId": "66F3D3B5-DBA1-4CF0-83A3-502E66A0F3D2"}]}]}], "references": [{"url": "https://github.com/OpenOLAT/OpenOLAT/commit/336d5ce80681be61a0bbf4f73d2af5d1ff67e93a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenOLAT/OpenOLAT/commit/c450df7d7ffe6afde39ebca6da9136f1caa16ec4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenOLAT/OpenOLAT/security/advisories/GHSA-62hv-rfp4-hmrm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://jira.openolat.org/browse/OO-5819", "source": "security-advisories@github.com", "tags": ["Permissions Required", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/OpenOLAT/OpenOLAT/commit/336d5ce80681be61a0bbf4f73d2af5d1ff67e93a"}}