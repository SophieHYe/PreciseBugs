{"buggy_code": ["// This file is part of The New Aspell\n// Copyright (C) 2001 by Kevin Atkinson under the GNU LGPL license\n// version 2.0 or 2.1.  You should have received a copy of the LGPL\n// license along with this library if you did not you can find\n// it at http://www.gnu.org/.\n\n//#include <stdio.h>\n//#define DEBUG {fprintf(stderr,\"File: %s(%i)\\n\",__FILE__,__LINE__);}\n#include <string.h>\n#include <stdlib.h>\n#include \"ndebug.hpp\"\n#include <assert.h>\n\n#include \"dirs.h\"\n#include \"settings.h\"\n\n#ifdef USE_LOCALE\n# include <locale.h>\n#endif\n\n#ifdef HAVE_LANGINFO_CODESET\n# include <langinfo.h>\n#endif\n\n#include \"cache.hpp\"\n#include \"asc_ctype.hpp\"\n#include \"config.hpp\"\n#include \"errors.hpp\"\n#include \"file_util.hpp\"\n#include \"fstream.hpp\"\n#include \"getdata.hpp\"\n#include \"itemize.hpp\"\n#include \"mutable_container.hpp\"\n#include \"posib_err.hpp\"\n#include \"string_map.hpp\"\n#include \"stack_ptr.hpp\"\n#include \"char_vector.hpp\"\n#include \"convert.hpp\"\n#include \"vararray.hpp\"\n#include \"string_list.hpp\"\n\n#include \"gettext.h\"\n\n#include \"iostream.hpp\"\n\n#define DEFAULT_LANG \"en_US\"\n\n// NOTE: All filter options are now stored with he \"f-\" prefix.  However\n//   during lookup, the non prefix version is also recognized.\n\n// The \"place_holder\" field in Entry and the \"Vector<int>\" parameter of\n// commit_all are there to deal with the fact than when spacing\n// options on the command line such as \"--key what\" it can not be\n// determined if \"what\" should be a the value of \"key\" or if it should\n// be treated as an independent arg.  This is because \"key\" may\n// be a filter option.  Filter options KeyInfo are not loaded until\n// after a commit which is not done at the time the options are being\n// read in from the command line.  (If the command line arguments are\n// read in after the other settings are read in and committed than any\n// options setting any of the config files will be ignored.  Thus the\n// command line must be parsed and options must be added in an\n// uncommitted state).  So the solution is to assume it is an\n// independent arg until told otherwise, the position in the arg array\n// is stored along with the value in the \"place_holder\" field.  When\n// the config class is finally committed and it is determined that\n// \"what\" is really a value for key the stored arg position is pushed\n// onto the Vector<int> so it can be removed from the arg array.  In\n// the case of a \"lset-*\" this will happen in multiple config\n// \"Entry\"s, so care is taken to only add the arg position once.\n\nnamespace acommon {\n\n  const char * const keyinfo_type_name[4] = {\n    N_(\"string\"), N_(\"integer\"), N_(\"boolean\"), N_(\"list\")\n  };\n\n  const int Config::num_parms_[9] = {1, 1, 0, 0, 0,\n                                     1, 1, 1, 0};\n  \n  typedef Notifier * NotifierPtr;\n  \n  Config::Config(ParmStr name,\n\t\t const KeyInfo * mainbegin, \n\t\t const KeyInfo * mainend)\n    : name_(name)\n    , first_(0), insert_point_(&first_), others_(0)\n    , committed_(true), attached_(false)\n    , md_info_list_index(-1)\n    , settings_read_in_(false)\n    , load_filter_hook(0)\n    , filter_mode_notifier(0)\n  {\n    keyinfo_begin = mainbegin;\n    keyinfo_end   = mainend;\n    extra_begin = 0;\n    extra_end   = 0;\n  }\n\n  Config::~Config() {\n    del();\n  }\n\n  Config::Config(const Config & other) \n  {\n    copy(other);\n  }\n  \n  Config & Config::operator= (const Config & other)\n  {\n    del();\n    copy(other);\n    return *this;\n  }\n  \n  Config * Config::clone() const {\n    return new Config(*this);\n  }\n\n  void Config::assign(const Config * other) {\n    *this = *(const Config *)(other);\n  }\n\n  void Config::copy(const Config & other)\n  {\n    assert(other.others_ == 0);\n    others_ = 0;\n\n    name_ = other.name_;\n\n    committed_ = other.committed_;\n    attached_ = other.attached_;\n    settings_read_in_ = other.settings_read_in_;\n\n    keyinfo_begin = other.keyinfo_begin;\n    keyinfo_end   = other.keyinfo_end;\n    extra_begin   = other.extra_begin;\n    extra_end     = other.extra_end;\n    filter_modules = other.filter_modules;\n\n#ifdef HAVE_LIBDL\n    filter_modules_ptrs = other.filter_modules_ptrs;\n    for (Vector<Cacheable *>::iterator i = filter_modules_ptrs.begin();\n         i != filter_modules_ptrs.end();\n         ++i)\n      (*i)->copy();\n#endif\n\n    md_info_list_index = other.md_info_list_index;\n\n    insert_point_ = 0;\n    Entry * const * src  = &other.first_;\n    Entry * * dest = &first_;\n    while (*src) \n    {\n      *dest = new Entry(**src);\n      if (src == other.insert_point_)\n        insert_point_ = dest;\n      src  = &((*src)->next);\n      dest = &((*dest)->next);\n    }\n    if (insert_point_ == 0)\n      insert_point_ = dest;\n    *dest = 0;\n\n    Vector<Notifier *>::const_iterator i   = other.notifier_list.begin();\n    Vector<Notifier *>::const_iterator end = other.notifier_list.end();\n\n    for(; i != end; ++i) {\n      Notifier * tmp = (*i)->clone(this);\n      if (tmp != 0)\n\tnotifier_list.push_back(tmp);\n    }\n  }\n\n  void Config::del()\n  {\n    while (first_) {\n      Entry * tmp = first_->next;\n      delete first_;\n      first_ = tmp;\n    }\n\n    while (others_) {\n      Entry * tmp = others_->next;\n      delete first_;\n      others_ = tmp;\n    }\n\n    Vector<Notifier *>::iterator i   = notifier_list.begin();\n    Vector<Notifier *>::iterator end = notifier_list.end();\n\n    for(; i != end; ++i) {\n      delete (*i);\n      *i = 0;\n    }\n    \n    notifier_list.clear();\n\n#ifdef HAVE_LIBDL\n    filter_modules.clear();\n    for (Vector<Cacheable *>::iterator i = filter_modules_ptrs.begin();\n         i != filter_modules_ptrs.end();\n         ++i)\n      (*i)->release();\n    filter_modules_ptrs.clear();\n#endif\n  }\n\n  void Config::set_filter_modules(const ConfigModule * modbegin, \n\t\t\t\t  const ConfigModule * modend)\n  {\n    assert(filter_modules_ptrs.empty());\n    filter_modules.clear();\n    filter_modules.assign(modbegin, modend);\n  }\n\n  void Config::set_extra(const KeyInfo * begin, \n\t\t\t       const KeyInfo * end) \n  {\n    extra_begin = begin;\n    extra_end   = end;\n  }\n\n  //\n  //\n  //\n\n\n  //\n  // Notifier methods\n  //\n\n  NotifierEnumeration * Config::notifiers() const \n  {\n    return new NotifierEnumeration(notifier_list);\n  }\n\n  bool Config::add_notifier(Notifier * n) \n  {\n    Vector<Notifier *>::iterator i   = notifier_list.begin();\n    Vector<Notifier *>::iterator end = notifier_list.end();\n\n    while (i != end && *i != n)\n      ++i;\n\n    if (i != end) {\n    \n      return false;\n    \n    } else {\n\n      notifier_list.push_back(n);\n      return true;\n\n    }\n  }\n\n  bool Config::remove_notifier(const Notifier * n) \n  {\n    Vector<Notifier *>::iterator i   = notifier_list.begin();\n    Vector<Notifier *>::iterator end = notifier_list.end();\n\n    while (i != end && *i != n)\n      ++i;\n\n    if (i == end) {\n    \n      return false;\n    \n    } else {\n\n      delete *i;\n      notifier_list.erase(i);\n      return true;\n\n    }\n  }\n\n  bool Config::replace_notifier(const Notifier * o, \n\t\t\t\t      Notifier * n) \n  {\n    Vector<Notifier *>::iterator i   = notifier_list.begin();\n    Vector<Notifier *>::iterator end = notifier_list.end();\n\n    while (i != end && *i != o)\n      ++i;\n\n    if (i == end) {\n    \n      return false;\n    \n    } else {\n\n      delete *i;\n      *i = n;\n      return true;\n\n    }\n  }\n\n  //\n  // retrieve methods\n  //\n\n  const Config::Entry * Config::lookup(const char * key) const\n  {\n    const Entry * res = 0;\n    const Entry * cur = first_;\n\n    while (cur) {\n      if (cur->key == key && cur->action != NoOp)  res = cur;\n      cur = cur->next;\n    }\n\n    if (!res || res->action == Reset) return 0;\n    return res;\n  }\n\n  bool Config::have(ParmStr key) const \n  {\n    PosibErr<const KeyInfo *> pe = keyinfo(key);\n    if (pe.has_err()) {pe.ignore_err(); return false;}\n    return lookup(pe.data->name);\n  }\n\n  PosibErr<String> Config::retrieve(ParmStr key) const\n  {\n    RET_ON_ERR_SET(keyinfo(key), const KeyInfo *, ki);\n    if (ki->type == KeyInfoList) return make_err(key_not_string, ki->name);\n\n    const Entry * cur = lookup(ki->name);\n\n    return cur ? cur->value : get_default(ki);\n  }\n\n  PosibErr<String> Config::retrieve_any(ParmStr key) const\n  {\n    RET_ON_ERR_SET(keyinfo(key), const KeyInfo *, ki);\n\n    if (ki->type != KeyInfoList) {\n      const Entry * cur = lookup(ki->name);\n      return cur ? cur->value : get_default(ki);\n    } else {\n      StringList sl;\n      RET_ON_ERR(retrieve_list(key, &sl));\n      StringListEnumeration els = sl.elements_obj();\n      const char * s;\n      String val;\n      while ( (s = els.next()) != 0 ) {\n        val += s;\n        val += '\\n';\n      }\n      val.pop_back();\n      return val;\n    }\n  }\n\n  PosibErr<bool> Config::retrieve_bool(ParmStr key) const\n  {\n    RET_ON_ERR_SET(keyinfo(key), const KeyInfo *, ki);\n    if (ki->type != KeyInfoBool) return make_err(key_not_bool, ki->name);\n\n    const Entry * cur = lookup(ki->name);\n\n    String value(cur ? cur->value : get_default(ki));\n\n    if (value == \"false\") return false;\n    else                  return true;\n  }\n  \n  PosibErr<int> Config::retrieve_int(ParmStr key) const\n  {\n    assert(committed_); // otherwise the value may not be an integer\n                        // as it has not been verified.\n\n    RET_ON_ERR_SET(keyinfo(key), const KeyInfo *, ki);\n    if (ki->type != KeyInfoInt) return make_err(key_not_int, ki->name);\n\n    const Entry * cur = lookup(ki->name);\n\n    String value(cur ? cur->value : get_default(ki));\n\n    return atoi(value.str());\n  }\n\n  void Config::lookup_list(const KeyInfo * ki,\n                           MutableContainer & m,\n                           bool include_default) const\n  {\n    const Entry * cur = first_;\n    const Entry * first_to_use = 0;\n\n    while (cur) {\n      if (cur->key == ki->name && \n          (first_to_use == 0 || \n           cur->action == Reset || cur->action == Set \n           || cur->action == ListClear)) \n        first_to_use = cur;\n      cur = cur->next;\n    }\n\n    cur = first_to_use;\n\n    if (include_default && \n        (!cur || \n         !(cur->action == Set || cur->action == ListClear)))\n    {\n      String def = get_default(ki);\n      separate_list(def, m, true);\n    }\n\n    if (cur && cur->action == Reset) {\n      cur = cur->next;\n    }\n\n    if (cur && cur->action == Set) {\n      if (!include_default) m.clear();\n      m.add(cur->value);\n      cur = cur->next;\n    }\n\n    if (cur && cur->action == ListClear) {\n      if (!include_default) m.clear();\n      cur = cur->next;\n    }\n\n    while (cur) {\n      if (cur->key == ki->name) {\n        if (cur->action == ListAdd)\n          m.add(cur->value);\n        else if (cur->action == ListRemove)\n          m.remove(cur->value);\n      }\n      cur = cur->next;\n    }\n  }\n\n  PosibErr<void> Config::retrieve_list(ParmStr key, \n\t\t\t\t       MutableContainer * m) const\n  {\n    RET_ON_ERR_SET(keyinfo(key), const KeyInfo *, ki);\n    if (ki->type != KeyInfoList) return make_err(key_not_list, ki->name);\n\n    lookup_list(ki, *m, true);\n\n    return no_err;\n  }\n\n  static const KeyInfo * find(ParmStr key, \n\t\t\t      const KeyInfo * i, \n\t\t\t      const KeyInfo * end) \n  {\n    while (i != end) {\n      if (strcmp(key, i->name) == 0)\n\treturn i;\n      ++i;\n    }\n    return i;\n  }\n\n  static const ConfigModule * find(ParmStr key, \n\t\t\t\t   const ConfigModule * i, \n\t\t\t\t   const ConfigModule * end) \n  {\n    while (i != end) {\n      if (strcmp(key, i->name) == 0)\n\treturn i;\n      ++i;\n    }\n    return i;\n  }\n\n  PosibErr<const KeyInfo *> Config::keyinfo(ParmStr key) const\n  {\n    typedef PosibErr<const KeyInfo *> Ret;\n    {\n      const KeyInfo * i;\n      i = acommon::find(key, keyinfo_begin, keyinfo_end);\n      if (i != keyinfo_end) return Ret(i);\n      \n      i = acommon::find(key, extra_begin, extra_end);\n      if (i != extra_end) return Ret(i);\n      \n      const char * s = strncmp(key, \"f-\", 2) == 0 ? key + 2 : key.str();\n      const char * h = strchr(s, '-');\n      if (h == 0) goto err;\n\n      String k(s, h - s);\n      const ConfigModule * j = acommon::find(k,\n\t\t\t\t\t     filter_modules.pbegin(),\n\t\t\t\t\t     filter_modules.pend());\n      \n      if (j == filter_modules.pend() && load_filter_hook && committed_) {\n        // FIXME: This isn't quite right\n        PosibErrBase pe = load_filter_hook(const_cast<Config *>(this), k);\n        pe.ignore_err();\n        j = acommon::find(k,\n                          filter_modules.pbegin(),\n                          filter_modules.pend());\n      }\n\n      if (j == filter_modules.pend()) goto err;\n\n      i = acommon::find(key, j->begin, j->end);\n      if (i != j->end) return Ret(i);\n      \n      if (strncmp(key, \"f-\", 2) != 0) k = \"f-\";\n      else                            k = \"\";\n      k += key;\n      i = acommon::find(k, j->begin, j->end);\n      if (i != j->end) return Ret(i);\n    }\n  err:  \n    return Ret().prim_err(unknown_key, key);\n  }\n\n  static bool proc_locale_str(ParmStr lang, String & final_str)\n  {\n    if (lang == 0) return false;\n    const char * i = lang;\n    if (!(asc_islower(i[0]) && asc_islower(i[1]))) return false;\n    final_str.assign(i, 2);\n    i += 2;\n    if (! (i[0] == '_' || i[0] == '-')) return true;\n    i += 1;\n    if (!(asc_isupper(i[0]) && asc_isupper(i[1]))) return true;\n    final_str += '_';\n    final_str.append(i, 2);\n    return true;\n  }\n\n  static void get_lang_env(String & str) \n  {\n    if (proc_locale_str(getenv(\"LC_MESSAGES\"), str)) return;\n    if (proc_locale_str(getenv(\"LANG\"), str)) return;\n    if (proc_locale_str(getenv(\"LANGUAGE\"), str)) return;\n    str = DEFAULT_LANG;\n  }\n\n#ifdef USE_LOCALE\n\n  static void get_lang(String & final_str) \n  {\n    // FIXME: THIS IS NOT THREAD SAFE\n    String locale = setlocale (LC_ALL, NULL);\n    if (locale == \"C\")\n      setlocale (LC_ALL, \"\");\n    const char * lang = setlocale (LC_MESSAGES, NULL);\n    bool res = proc_locale_str(lang, final_str);\n    if (locale == \"C\")\n      setlocale(LC_MESSAGES, locale.c_str());\n    if (!res)\n      get_lang_env(final_str);\n  }\n\n#else\n\n  static inline void get_lang(String & str) \n  {\n    get_lang_env(str);\n  }\n\n#endif\n\n#if defined USE_LOCALE && defined HAVE_LANGINFO_CODESET\n\n  static inline void get_encoding(const Config & c, String & final_str)\n  {\n    const char * codeset = nl_langinfo(CODESET);\n    if (ascii_encoding(c, codeset)) codeset = \"none\";\n    final_str = codeset;\n  }\n\n#else\n\n  static inline void get_encoding(const Config &, String & final_str)\n  {\n    final_str = \"none\";\n  }\n\n#endif\n\n  String Config::get_default(const KeyInfo * ki) const\n  {\n    bool   in_replace = false;\n    String final_str;\n    String replace;\n    const char * i = ki->def;\n    if (*i == '!') { // special cases\n      ++i;\n    \n      if (strcmp(i, \"lang\") == 0) {\n        \n        const Entry * entry;\n        if (entry = lookup(\"actual-lang\"), entry) {\n          return entry->value;\n        } else if (have(\"master\")) {\n\t  final_str = \"<unknown>\";\n\t} else {\n\t  get_lang(final_str);\n\t}\n\t\n      } else if (strcmp(i, \"encoding\") == 0) {\n\n        get_encoding(*this, final_str);\n\n      } else if (strcmp(i, \"special\") == 0) {\n\n\t// do nothing\n\n      } else {\n      \n\tabort(); // this should not happen\n      \n      }\n    \n    } else for(; *i; ++i) {\n    \n      if (!in_replace) {\n\n\tif (*i == '<') {\n\t  in_replace = true;\n\t} else {\n\t  final_str += *i;\n\t}\n\n      } else { // in_replace\n      \n\tif (*i == '/' || *i == ':' || *i == '|' || *i == '#' || *i == '^') {\n\t  char sep = *i;\n\t  String second;\n\t  ++i;\n\t  while (*i != '\\0' && *i != '>') second += *i++;\n\t  if (sep == '/') {\n\t    String s1 = retrieve(replace);\n\t    String s2 = retrieve(second);\n\t    final_str += add_possible_dir(s1, s2);\n\t  } else if (sep == ':') {\n\t    String s1 = retrieve(replace);\n\t    final_str += add_possible_dir(s1, second);\n\t  } else if (sep == '#') {\n\t    String s1 = retrieve(replace);\n\t    assert(second.size() == 1);\n\t    unsigned int s = 0;\n\t    while (s != s1.size() && s1[s] != second[0]) ++s;\n\t    final_str.append(s1, s);\n\t  } else if (sep == '^') {\n\t    String s1 = retrieve(replace);\n\t    String s2 = retrieve(second);\n\t    final_str += figure_out_dir(s1, s2);\n\t  } else { // sep == '|'\n\t    assert(replace[0] == '$');\n\t    const char * env = getenv(replace.c_str()+1);\n\t    final_str += env ? env : second;\n\t  }\n\t  replace = \"\";\n\t  in_replace = false;\n\n\t} else if (*i == '>') {\n\n\t  final_str += retrieve(replace).data;\n\t  replace = \"\";\n\t  in_replace = false;\n\n\t} else {\n\n\t  replace += *i;\n\n\t}\n\n      }\n      \n    }\n    return final_str;\n  }\n\n  PosibErr<String> Config::get_default(ParmStr key) const\n  {\n    RET_ON_ERR_SET(keyinfo(key), const KeyInfo *, ki);\n    return get_default(ki);\n  }\n\n\n\n#define TEST(v,l,a)                         \\\n  do {                                      \\\n    if (len == l && memcmp(s, v, l) == 0) { \\\n      if (action) *action = a;              \\\n      return c + 1;                         \\\n    }                                       \\\n  } while (false)\n\n  const char * Config::base_name(const char * s, Action * action)\n  {\n    if (action) *action = Set;\n    const char * c = strchr(s, '-');\n    if (!c) return s;\n    unsigned len = c - s;\n    TEST(\"reset\",   5, Reset);\n    TEST(\"enable\",  6, Enable);\n    TEST(\"dont\",    4, Disable);\n    TEST(\"disable\", 7, Disable);\n    TEST(\"lset\",    4, ListSet);\n    TEST(\"rem\",     3, ListRemove);\n    TEST(\"remove\",  6, ListRemove);\n    TEST(\"add\",     3, ListAdd);\n    TEST(\"clear\",   5, ListClear);\n    return s;\n  }\n\n#undef TEST\n\n  void separate_list(ParmStr value, AddableContainer & out, bool do_unescape)\n  {\n    unsigned len = value.size();\n    \n    VARARRAY(char, buf, len + 1);\n    memcpy(buf, value, len + 1);\n    \n    len = strlen(buf);\n    char * s = buf;\n    char * end = buf + len;\n      \n    while (s < end)\n    {\n      if (do_unescape) while (*s == ' ' || *s == '\\t') ++s;\n      char * b = s;\n      char * e = s;\n      while (*s != '\\0') {\n        if (do_unescape && *s == '\\\\') {\n          ++s;\n          if (*s == '\\0') break;\n          e = s;\n          ++s;\n        } else {\n          if (*s == ':') break;\n          if (!do_unescape || (*s != ' ' && *s != '\\t')) e = s;\n          ++s;\n        }\n      }\n      if (s != b) {\n        ++e;\n        *e = '\\0';\n        if (do_unescape) unescape(b);\n      \n        out.add(b);\n      }\n      ++s;\n    }\n  }\n\n  void combine_list(String & res, const StringList & in)\n  {\n    res.clear();\n    StringListEnumeration els = in.elements_obj();\n    const char * s = 0;\n    while ( (s = els.next()) != 0) \n    {\n      for (; *s; ++s) {\n        if (*s == ':')\n          res.append('\\\\');\n        res.append(*s);\n      }\n      res.append(':');\n    }\n    if (res.back() == ':') res.pop_back();\n  }\n\n  struct ListAddHelper : public AddableContainer \n  {\n    Config * config;\n    Config::Entry * orig_entry;\n    PosibErr<bool> add(ParmStr val);\n  };\n\n  PosibErr<bool> ListAddHelper::add(ParmStr val)\n  {\n    Config::Entry * entry = new Config::Entry(*orig_entry);\n    entry->value = val;\n    entry->action = Config::ListAdd;\n    config->set(entry);\n    return true;\n  }\n\n  void Config::replace_internal(ParmStr key, ParmStr value)\n  {\n    Entry * entry = new Entry;\n    entry->key = key;\n    entry->value = value;\n    entry->action = Set;\n    entry->next = *insert_point_;\n    *insert_point_ = entry;\n    insert_point_ = &entry->next;\n  }\n\n  PosibErr<void> Config::replace(ParmStr key, ParmStr value)\n  {\n    Entry * entry = new Entry;\n    entry->key = key;\n    entry->value = value;\n    return set(entry);\n  }\n  \n  PosibErr<void> Config::remove(ParmStr key)\n  {\n    Entry * entry = new Entry;\n    entry->key = key;\n    entry->action = Reset;\n    return set(entry);\n  }\n\n  PosibErr<void> Config::set(Entry * entry0, bool do_unescape)\n  {\n    StackPtr<Entry> entry(entry0);\n\n    if (entry->action == NoOp)\n      entry->key = base_name(entry->key.str(), &entry->action);\n\n    if (num_parms(entry->action) == 0 && !entry->value.empty()) \n    {\n      if (entry->place_holder == -1) {\n        switch (entry->action) {\n        case Reset:\n          return make_err(no_value_reset, entry->key);\n        case Enable:\n          return make_err(no_value_enable, entry->key);\n        case Disable:\n          return make_err(no_value_disable, entry->key);\n        case ListClear:\n          return make_err(no_value_clear, entry->key);\n        default:\n          abort(); // this shouldn't happen\n        }\n      } else {\n        entry->place_holder = -1;\n      }\n    }\n\n    if (entry->action != ListSet) {\n\n      switch (entry->action) {\n      case Enable:\n        entry->value = \"true\";\n        entry->action = Set;\n        break;\n      case Disable:\n        entry->value = \"false\";\n        entry->action = Set;\n        break;\n      default:\n        ;\n      }\n      if (do_unescape) unescape(entry->value.mstr());\n\n      entry->next = *insert_point_;\n      *insert_point_ = entry;\n      insert_point_ = &entry->next;\n      entry.release();\n      if (committed_) RET_ON_ERR(commit(entry0)); // entry0 == entry\n      \n    } else { // action == ListSet\n\n      Entry * ent = new Entry;\n      ent->key = entry->key;\n      ent->action = ListClear;\n      set(ent);\n\n      ListAddHelper helper;\n      helper.config = this;\n      helper.orig_entry = entry;\n\n      separate_list(entry->value.str(), helper, do_unescape);\n    }\n    return no_err;\n  }\n\n  PosibErr<void> Config::merge(const Config & other)\n  {\n    const Entry * src  = other.first_;\n    while (src) \n    {\n      Entry * entry = new Entry(*src);\n      entry->next = *insert_point_;\n      *insert_point_ = entry;\n      insert_point_ = &entry->next;\n      if (committed_) RET_ON_ERR(commit(entry));\n      src = src->next;\n    }\n    return no_err;\n  }\n\n  void Config::lang_config_merge(const Config & other,\n                                 int which, ParmStr data_encoding)\n  {\n    Conv to_utf8;\n    to_utf8.setup(*this, data_encoding, \"utf-8\", NormTo);\n    const Entry * src  = other.first_;\n    Entry * * ip = &first_;\n    while (src)\n    {\n      const KeyInfo * l_ki = other.keyinfo(src->key);\n      if (l_ki->other_data == which) {\n        const KeyInfo * c_ki = keyinfo(src->key);\n        Entry * entry = new Entry(*src);\n        if (c_ki->flags & KEYINFO_UTF8)\n          entry->value = to_utf8(entry->value);\n        entry->next = *ip;\n        *ip = entry;\n        ip = &entry->next;\n      }\n      src = src->next;\n    }\n  }\n\n\n#define NOTIFY_ALL(fun)                                       \\\n  do {                                                        \\\n    Vector<Notifier *>::iterator   i = notifier_list.begin(); \\\n    Vector<Notifier *>::iterator end = notifier_list.end();   \\\n    while (i != end) {                                        \\\n      RET_ON_ERR((*i)->fun);                                  \\\n      ++i;                                                    \\\n    }                                                         \\\n  } while (false)\n\n  PosibErr<int> Config::commit(Entry * entry, Conv * conv) \n  {\n    PosibErr<const KeyInfo *> pe = keyinfo(entry->key);\n    {\n      if (pe.has_err()) goto error;\n      \n      const KeyInfo * ki = pe;\n\n      entry->key = ki->name;\n      \n      // FIXME: This is the correct thing to do but it causes problems\n      //        with changing a filter mode in \"pipe\" mode and probably\n      //        elsewhere.\n      //if (attached_ && !(ki->flags & KEYINFO_MAY_CHANGE)) {\n      //  pe = make_err(cant_change_value, entry->key);\n      //  goto error;\n      //}\n\n      int place_holder = entry->place_holder;\n      \n      if (conv && ki->flags & KEYINFO_UTF8)\n        entry->value = (*conv)(entry->value);\n\n      if (ki->type != KeyInfoList && list_action(entry->action)) {\n        pe = make_err(key_not_list, entry->key);\n        goto error;\n      }\n      \n      assert(ki->def != 0); // if null this key should never have values\n      // directly added to it\n      String value(entry->action == Reset ? get_default(ki) : entry->value);\n      \n      switch (ki->type) {\n        \n      case KeyInfoBool: {\n\n        bool val;\n      \n        if  (value.empty() || entry->place_holder != -1) {\n          // if entry->place_holder != -1 than IGNORE the value no\n          // matter what it is\n          entry->value = \"true\";\n          val = true;\n          place_holder = -1;\n        } else if (value == \"true\") {\n          val = true;\n        } else if (value == \"false\") {\n          val = false;\n        } else {\n          pe = make_err(bad_value, entry->key, value,\n                        /* TRANSLATORS: \"true\" and \"false\" are literal\n                         * values and should not be translated.*/\n                        _(\"either \\\"true\\\" or \\\"false\\\"\"));\n          goto error;\n        }\n\n        NOTIFY_ALL(item_updated(ki, val));\n        break;\n        \n      } case KeyInfoString:\n        \n        NOTIFY_ALL(item_updated(ki, value));\n        break;\n        \n      case KeyInfoInt: \n      {\n        int num;\n        \n        if (sscanf(value.str(), \"%i\", &num) == 1 && num >= 0) {\n          NOTIFY_ALL(item_updated(ki, num));\n        } else {\n          pe = make_err(bad_value, entry->key, value, _(\"a positive integer\"));\n          goto error;\n        }\n        \n        break;\n      }\n      case KeyInfoList:\n        \n        NOTIFY_ALL(list_updated(ki));\n        break;\n        \n      }\n      return place_holder;\n    }\n  error:\n    entry->action = NoOp;\n    if (!entry->file.empty())\n      return pe.with_file(entry->file, entry->line_num);\n    else\n      return (PosibErrBase &)pe;\n  }\n\n#undef NOTIFY_ALL\n\n\n  /////////////////////////////////////////////////////////////////////\n  /////////////////////////////////////////////////////////////////////\n\n  class PossibleElementsEmul : public KeyInfoEnumeration\n  {\n  private:\n    bool include_extra;\n    bool include_modules;\n    bool module_changed;\n    const Config * cd;\n    const KeyInfo * i;\n    const ConfigModule * m;\n  public:\n    PossibleElementsEmul(const Config * d, bool ic, bool im)\n      : include_extra(ic), include_modules(im), \n        module_changed(false), cd(d), i(d->keyinfo_begin), m(0) {}\n\n    KeyInfoEnumeration * clone() const {\n      return new PossibleElementsEmul(*this);\n    }\n\n    void assign(const KeyInfoEnumeration * other) {\n      *this = *(const PossibleElementsEmul *)(other);\n    }\n\n    virtual bool active_filter_module_changed(void) {\n      return module_changed;\n    }\n\n    const char * active_filter_module_name(void){\n      if (m != 0)\n        return m->name;\n      return \"\";\n    }\n\n    virtual const char * active_filter_module_desc(void) {\n      if (m != 0)\n        return m->desc;\n      return \"\";\n    }\n\n    const KeyInfo * next() {\n      if (i == cd->keyinfo_end) {\n\tif (include_extra)\n\t  i = cd->extra_begin;\n\telse\n\t  i = cd->extra_end;\n      }\n      \n      module_changed = false;\n      if (i == cd->extra_end) {\n\tm = cd->filter_modules.pbegin();\n\tif (!include_modules || m == cd->filter_modules.pend()) return 0;\n\telse {\n          i = m->begin;\n          module_changed = true;\n        }\n      }\n\n      if (m == 0){\n\treturn i++;\n      }\n\n      if (m == cd->filter_modules.pend()){\n\treturn 0;\n      }\n\n      while (i == m->end) {\n\t++m;\n\tif (m == cd->filter_modules.pend()) return 0;\n\telse {\n          i = m->begin;\n          module_changed = true;\n        }\n      }\n\n      return i++;\n    }\n\n    bool at_end() const {\n      return (m == cd->filter_modules.pend());\n    }\n  };\n\n  KeyInfoEnumeration *\n  Config::possible_elements(bool include_extra, bool include_modules) const\n  {\n    return new PossibleElementsEmul(this, include_extra, include_modules);\n  }\n\n  struct ListDefaultDump : public AddableContainer \n  {\n    OStream & out;\n    bool first;\n    const char * first_prefix;\n    unsigned num_blanks;\n    ListDefaultDump(OStream & o);\n    PosibErr<bool> add(ParmStr d);\n  };\n  \n  ListDefaultDump::ListDefaultDump(OStream & o) \n    : out(o), first(false)\n  {\n    first_prefix = _(\"# default: \");\n    num_blanks = strlen(first_prefix) - 1;\n  }\n\n  PosibErr<bool> ListDefaultDump::add(ParmStr d) \n  {\n    if (first) {\n      out.write(first_prefix);\n    } else {\n      out.put('#');\n      for (unsigned i = 0; i != num_blanks; ++i)\n        out.put(' ');\n    }\n    VARARRAY(char, buf, d.size() * 2 + 1);\n    escape(buf, d);\n    out.printl(buf);\n    first = false;\n    return true;\n  }\n\n  class ListDump : public MutableContainer \n  {\n    OStream & out;\n    const char * name;\n  public:\n    ListDump(OStream & o, ParmStr n) \n      : out(o), name(n) {}\n    PosibErr<bool> add(ParmStr d);\n    PosibErr<bool> remove(ParmStr d);\n    PosibErr<void> clear();\n  };\n\n  PosibErr<bool> ListDump::add(ParmStr d) {\n    VARARRAY(char, buf, d.size() * 2 + 1);\n    escape(buf, d);\n    out.printf(\"add-%s %s\\n\", name, buf);\n    return true;\n  }\n  PosibErr<bool> ListDump::remove(ParmStr d) {\n    VARARRAY(char, buf, d.size() * 2 + 1);\n    escape(buf, d);\n    out.printf(\"remove-%s %s\\n\", name, buf);\n    return true;\n  }\n  PosibErr<void> ListDump::clear() {\n    out.printf(\"clear-%s\\n\", name);\n    return no_err;\n  }\n\n  void Config::write_to_stream(OStream & out, \n\t\t\t       bool include_extra) \n  {\n    KeyInfoEnumeration * els = possible_elements(include_extra);\n    const KeyInfo * i;\n    String buf;\n    String obuf;\n    String def;\n    bool have_value;\n\n    while ((i = els->next()) != 0) {\n      if (i->desc == 0) continue;\n\n      if (els->active_filter_module_changed()) {\n        out.printf(_(\"\\n\"\n                     \"#######################################################################\\n\"\n                     \"#\\n\"\n                     \"# Filter: %s\\n\"\n                     \"#   %s\\n\"\n                     \"#\\n\"\n                     \"# configured as follows:\\n\"\n                     \"\\n\"),\n                   els->active_filter_module_name(),\n                   _(els->active_filter_module_desc()));\n      }\n\n      obuf.clear();\n      have_value = false;\n\n      obuf.printf(\"# %s (%s)\\n#   %s\\n\",\n                  i->name, _(keyinfo_type_name[i->type]), _(i->desc));\n      if (i->def != 0) {\n\tif (i->type != KeyInfoList) {\n          buf.resize(strlen(i->def) * 2 + 1);\n          escape(buf.data(), i->def);\n          obuf.printf(\"# default: %s\", buf.data());\n          def = get_default(i);\n          if (def != i->def) {\n            buf.resize(def.size() * 2 + 1);\n            escape(buf.data(), def.str());\n            obuf.printf(\" = %s\", buf.data());\n          }\n          obuf << '\\n';\n          const Entry * entry = lookup(i->name);\n\t  if (entry) {\n            have_value = true;\n            buf.resize(entry->value.size() * 2 + 1);\n            escape(buf.data(), entry->value.str());\n\t    obuf.printf(\"%s %s\\n\", i->name, buf.data());\n          }\n\t} else {\n          unsigned s = obuf.size();\n          ListDump ld(obuf, i->name);\n          lookup_list(i, ld, false);\n          have_value = s != obuf.size();\n\t}\n      }\n      obuf << '\\n';\n      if (!(i->flags & KEYINFO_HIDDEN) || have_value)\n        out.write(obuf);\n    }\n    delete els;\n  }\n\n  PosibErr<void> Config::read_in(IStream & in, ParmStr id) \n  {\n    String buf;\n    DataPair dp;\n    while (getdata_pair(in, dp, buf)) {\n      to_lower(dp.key);\n      Entry * entry = new Entry;\n      entry->key = dp.key;\n      entry->value = dp.value;\n      entry->file = id;\n      entry->line_num = dp.line_num;\n      RET_ON_ERR(set(entry, true));\n    }\n    return no_err;\n  }\n\n  PosibErr<void> Config::read_in_file(ParmStr file) {\n    FStream in;\n    RET_ON_ERR(in.open(file, \"r\"));\n    return read_in(in, file);\n  }\n\n  PosibErr<void> Config::read_in_string(ParmStr str, const char * what) {\n    StringIStream in(str);\n    return read_in(in, what);\n  }\n\n\n  PosibErr<bool> Config::read_in_settings(const Config * other)\n  {\n    if (settings_read_in_) return false;\n\n    bool was_committed = committed_;\n    set_committed_state(false);\n\n    if (other && other->settings_read_in_) {\n\n      assert(empty());\n      del(); // to clean up any notifiers and similar stuff\n      copy(*other);\n\n    } else {\n\n      if (other) merge(*other);\n\n      const char * env = getenv(\"ASPELL_CONF\");\n      if (env != 0) { \n        insert_point_ = &first_;\n        RET_ON_ERR(read_in_string(env, _(\"ASPELL_CONF env var\")));\n      }\n      \n      {\n      insert_point_ = &first_;\n      PosibErrBase pe = read_in_file(retrieve(\"per-conf-path\"));\n      if (pe.has_err() && !pe.has_err(cant_read_file)) return pe;\n      }\n      \n      {\n        insert_point_ = &first_;\n        PosibErrBase pe = read_in_file(retrieve(\"conf-path\"));\n        if (pe.has_err() && !pe.has_err(cant_read_file)) return pe;\n      }\n\n      if (was_committed)\n        RET_ON_ERR(commit_all());\n\n      settings_read_in_ = true;\n    }\n\n    return true;\n  }\n\n  PosibErr<void> Config::commit_all(Vector<int> * phs, const char * codeset)\n  {\n    committed_ = true;\n    others_ = first_;\n    first_ = 0;\n    insert_point_ = &first_;\n    Conv to_utf8;\n    if (codeset)\n      RET_ON_ERR(to_utf8.setup(*this, codeset, \"utf-8\", NormTo));\n    while (others_) {\n      *insert_point_ = others_;\n      others_ = others_->next;\n      (*insert_point_)->next = 0;\n      RET_ON_ERR_SET(commit(*insert_point_, codeset ? &to_utf8 : 0), int, place_holder);\n      if (phs && place_holder != -1 && (phs->empty() || phs->back() != place_holder))\n        phs->push_back(place_holder);\n      insert_point_ = &((*insert_point_)->next);\n    }\n    return no_err;\n  }\n\n  PosibErr<void> Config::set_committed_state(bool val) {\n    if (val && !committed_) {\n      RET_ON_ERR(commit_all());\n    } else if (!val && committed_) {\n      assert(empty());\n      committed_ = false;\n    }\n    return no_err;\n  }\n\n\n#ifdef ENABLE_WIN32_RELOCATABLE\n#  define HOME_DIR \"<prefix>\"\n#  define PERSONAL \"<lang>.pws\"\n#  define REPL     \"<lang>.prepl\"\n#else\n#  define HOME_DIR \"<$HOME|./>\"\n#  define PERSONAL \".aspell.<lang>.pws\"\n#  define REPL     \".aspell.<lang>.prepl\"\n#endif\n\n  static const KeyInfo config_keys[] = {\n    // the description should be under 50 chars\n    {\"actual-dict-dir\", KeyInfoString, \"<dict-dir^master>\", 0}\n    , {\"actual-lang\",     KeyInfoString, \"\", 0} \n    , {\"conf\",     KeyInfoString, \"aspell.conf\",\n       /* TRANSLATORS: The remaining strings in config.cpp should be kept\n          under 50 characters, begin with a lower case character and not\n          include any trailing punctuation marks. */\n       N_(\"main configuration file\")}\n    , {\"conf-dir\", KeyInfoString, CONF_DIR,\n       N_(\"location of main configuration file\")}\n    , {\"conf-path\",     KeyInfoString, \"<conf-dir/conf>\", 0}\n    , {\"data-dir\", KeyInfoString, DATA_DIR,\n       N_(\"location of language data files\")}\n    , {\"dict-alias\", KeyInfoList, \"\",\n       N_(\"create dictionary aliases\")}\n    , {\"dict-dir\", KeyInfoString, DICT_DIR,\n       N_(\"location of the main word list\")}\n    , {\"encoding\",   KeyInfoString, \"!encoding\",\n       N_(\"encoding to expect data to be in\"), KEYINFO_COMMON}\n    , {\"filter\",   KeyInfoList  , \"url\",\n       N_(\"add or removes a filter\"), KEYINFO_MAY_CHANGE}\n    , {\"filter-path\", KeyInfoList, DICT_DIR,\n       N_(\"path(s) aspell looks for filters\")}\n    //, {\"option-path\", KeyInfoList, DATA_DIR,\n    //   N_(\"path(s) aspell looks for options descriptions\")}\n    , {\"mode\",     KeyInfoString, \"url\",\n       N_(\"filter mode\"), KEYINFO_COMMON}\n    , {\"extra-dicts\", KeyInfoList, \"\",\n       N_(\"extra dictionaries to use\")}\n    , {\"home-dir\", KeyInfoString, HOME_DIR,\n       N_(\"location for personal files\")}\n    , {\"ignore\",   KeyInfoInt   , \"1\",\n       N_(\"ignore words <= n chars\"), KEYINFO_MAY_CHANGE}\n    , {\"ignore-accents\" , KeyInfoBool, \"false\",\n       /* TRANSLATORS: It is OK if this is longer than 50 chars */\n       N_(\"ignore accents when checking words -- CURRENTLY IGNORED\"), KEYINFO_MAY_CHANGE | KEYINFO_HIDDEN}\n    , {\"ignore-case\", KeyInfoBool  , \"false\",\n       N_(\"ignore case when checking words\"), KEYINFO_MAY_CHANGE}\n    , {\"ignore-repl\", KeyInfoBool  , \"false\",\n       N_(\"ignore commands to store replacement pairs\"), KEYINFO_MAY_CHANGE}\n    , {\"jargon\",     KeyInfoString, \"\",\n       N_(\"extra information for the word list\"), KEYINFO_HIDDEN}\n    , {\"keyboard\", KeyInfoString, \"standard\",\n       N_(\"keyboard definition to use for typo analysis\")}\n    , {\"lang\", KeyInfoString, \"<language-tag>\",\n       N_(\"language code\"), KEYINFO_COMMON}\n    , {\"language-tag\", KeyInfoString, \"!lang\",\n       N_(\"deprecated, use lang instead\"), KEYINFO_HIDDEN}\n    , {\"local-data-dir\", KeyInfoString, \"<actual-dict-dir>\",\n       N_(\"location of local language data files\")     }\n    , {\"master\",        KeyInfoString, \"<lang>\",\n       N_(\"base name of the main dictionary to use\"), KEYINFO_COMMON}\n    , {\"master-flags\",  KeyInfoString, \"\", 0}\n    , {\"master-path\",   KeyInfoString, \"<dict-dir/master>\",   0}\n    , {\"module\",        KeyInfoString, \"default\",\n       N_(\"set module name\"), KEYINFO_HIDDEN}\n    , {\"module-search-order\", KeyInfoList, \"\",\n       N_(\"search order for modules\"), KEYINFO_HIDDEN}\n    , {\"normalize\", KeyInfoBool, \"true\",\n       N_(\"enable Unicode normalization\")}\n    , {\"norm-required\", KeyInfoBool, \"false\",\n       N_(\"Unicode normalization required for current lang\")}\n    , {\"norm-form\", KeyInfoString, \"nfc\",\n       /* TRANSLATORS: the values after the ':' are literal\n          values and should not be translated. */\n       N_(\"Unicode normalization form: none, nfd, nfc, comp\")}\n    , {\"norm-strict\", KeyInfoBool, \"false\",\n       N_(\"avoid lossy conversions when normalization\")}\n    , {\"per-conf\", KeyInfoString, \".aspell.conf\",\n       N_(\"personal configuration file\")}\n    , {\"per-conf-path\", KeyInfoString, \"<home-dir/per-conf>\", 0}\n    , {\"personal\", KeyInfoString, PERSONAL,\n       N_(\"personal dictionary file name\")}\n    , {\"personal-path\", KeyInfoString, \"<home-dir/personal>\", 0}\n    , {\"prefix\",   KeyInfoString, PREFIX,\n       N_(\"prefix directory\")}\n    , {\"repl\",     KeyInfoString, REPL,\n       N_(\"replacements list file name\") }\n    , {\"repl-path\",     KeyInfoString, \"<home-dir/repl>\",     0}\n    , {\"run-together\",        KeyInfoBool,  \"false\",\n       N_(\"consider run-together words legal\"), KEYINFO_MAY_CHANGE}\n    , {\"run-together-limit\",  KeyInfoInt,   \"2\",\n       N_(\"maximum number that can be strung together\"), KEYINFO_MAY_CHANGE}\n    , {\"run-together-min\",    KeyInfoInt,   \"3\",\n       N_(\"minimal length of interior words\"), KEYINFO_MAY_CHANGE}\n    , {\"save-repl\", KeyInfoBool  , \"true\",\n       N_(\"save replacement pairs on save all\")}\n    , {\"set-prefix\", KeyInfoBool, \"true\",\n       N_(\"set the prefix based on executable location\")}\n    , {\"size\",          KeyInfoString, \"+60\",\n       N_(\"size of the word list\")}\n    , {\"spelling\",   KeyInfoString, \"\",\n       N_(\"no longer used\"), KEYINFO_HIDDEN}\n    , {\"sug-mode\",   KeyInfoString, \"normal\",\n       N_(\"suggestion mode\"), KEYINFO_MAY_CHANGE | KEYINFO_COMMON}\n    , {\"sug-typo-analysis\", KeyInfoBool, \"true\",\n       /* TRANSLATORS: \"sug-mode\" is a literal value and should not be\n          translated. */\n       N_(\"use typo analysis, override sug-mode default\")}\n    , {\"sug-repl-table\", KeyInfoBool, \"true\",\n       N_(\"use replacement tables, override sug-mode default\")}\n    , {\"sug-split-char\", KeyInfoList, \"\\\\ :-\",\n       N_(\"characters to insert when a word is split\"), KEYINFO_UTF8}\n    , {\"use-other-dicts\", KeyInfoBool, \"true\",\n       N_(\"use personal, replacement & session dictionaries\")}\n    , {\"variety\", KeyInfoList, \"\",\n       N_(\"extra information for the word list\")}\n    , {\"word-list-path\", KeyInfoList, DATA_DIR,\n       N_(\"search path for word list information files\"), KEYINFO_HIDDEN}\n    , {\"warn\", KeyInfoBool, \"true\",\n       N_(\"enable warnings\")}\n    \n    \n    //\n    // These options are generally used when creating dictionaries\n    // and may also be specified in the language data file\n    //\n\n    , {\"affix-char\",          KeyInfoString, \"/\", // FIXME: Implement\n       /* TRANSLATORS: It is OK if this is longer than 50 chars */\n       N_(\"indicator for affix flags in word lists -- CURRENTLY IGNORED\"), KEYINFO_UTF8 | KEYINFO_HIDDEN}\n    , {\"affix-compress\", KeyInfoBool, \"false\",\n       N_(\"use affix compression when creating dictionaries\")}\n    , {\"clean-affixes\", KeyInfoBool, \"true\",\n       N_(\"remove invalid affix flags\")}\n    , {\"clean-words\", KeyInfoBool, \"false\",\n       N_(\"attempts to clean words so that they are valid\")}\n    , {\"invisible-soundslike\", KeyInfoBool, \"false\",\n       N_(\"compute soundslike on demand rather than storing\")} \n    , {\"partially-expand\",  KeyInfoBool, \"false\",\n       N_(\"partially expand affixes for better suggestions\")}\n    , {\"skip-invalid-words\",  KeyInfoBool, \"true\",\n       N_(\"skip invalid words\")}\n    , {\"validate-affixes\", KeyInfoBool, \"true\",\n       N_(\"check if affix flags are valid\")}\n    , {\"validate-words\", KeyInfoBool, \"true\",\n       N_(\"check if words are valid\")}\n    \n    //\n    // These options are specific to the \"aspell\" utility.  They are\n    // here so that they can be specified in configuration files.\n    //\n    , {\"backup\",  KeyInfoBool, \"true\",\n       N_(\"create a backup file by appending \\\".bak\\\"\")}\n    , {\"byte-offsets\", KeyInfoBool, \"false\",\n       N_(\"use byte offsets instead of character offsets\")}\n    , {\"guess\", KeyInfoBool, \"false\",\n       N_(\"create missing root/affix combinations\"), KEYINFO_MAY_CHANGE}\n    , {\"keymapping\", KeyInfoString, \"aspell\",\n       N_(\"keymapping for check mode: \\\"aspell\\\" or \\\"ispell\\\"\")}\n    , {\"reverse\", KeyInfoBool, \"false\",\n       N_(\"reverse the order of the suggest list\")}\n    , {\"suggest\", KeyInfoBool, \"true\",\n       N_(\"suggest possible replacements\"), KEYINFO_MAY_CHANGE}\n    , {\"time\"   , KeyInfoBool, \"false\",\n       N_(\"time load time and suggest time in pipe mode\"), KEYINFO_MAY_CHANGE}\n    };\n\n  const KeyInfo * config_impl_keys_begin = config_keys;\n  const KeyInfo * config_impl_keys_end   \n  = config_keys + sizeof(config_keys)/sizeof(KeyInfo);\n\n  Config * new_basic_config() { \n    aspell_gettext_init();\n    return new Config(\"aspell\",\n\t\t      config_impl_keys_begin,\n\t\t      config_impl_keys_end);\n  }\n  \n}\n\n", "// This file is part of The New Aspell\n// Copyright (C) 2001 by Kevin Atkinson under the GNU LGPL license\n// version 2.0 or 2.1.  You should have received a copy of the LGPL\n// license along with this library if you did not you can find\n// it at http://www.gnu.org/.\n\n#include \"settings.h\"\n\n//#include \"iostream.hpp\"\n\n#include \"config.hpp\"\n#include \"file_util.hpp\"\n#include \"fstream.hpp\"\n#include \"errors.hpp\"\n#include \"string_list.hpp\"\n\n#ifdef USE_FILE_LOCKS\n#  include <fcntl.h>\n#  include <unistd.h>\n#  include <sys/types.h>\n#endif\n\n#include <stdio.h>\n#include <sys/stat.h>\n#include <dirent.h>\n\n#ifdef WIN32\n\n#  include <io.h>\n#  define ACCESS _access\n#  include <windows.h>\n#  include <winbase.h>\n\n#else\n\n#  include <unistd.h>\n#  define ACCESS access\n\n#endif\n\n\nnamespace acommon {\n\n  // Return false if file is already an absolute path and does not need\n  // a directory prepended.\n  bool need_dir(ParmString file) {\n    if (file[0] == '/' || (file[0] == '.' && file[1] == '/')\n#ifdef WIN32\n        || (asc_isalpha(file[0]) && file[1] == ':')\n        || file[0] == '\\\\' || (file[0] == '.' && file[1] == '\\\\')\n#endif\n      )\n      return false;\n    else\n      return true;\n  }\n\n  String add_possible_dir(ParmString dir, ParmString file) {\n    if (need_dir(file)) {\n      String path;\n      path += dir;\n      path += '/';\n      path += file;\n      return path;\n    } else {\n      return file;\n    }\n  }\n\n  String figure_out_dir(ParmString dir, ParmString file)\n  {\n    String temp;\n    int s = file.size() - 1;\n    while (s != -1 && file[s] != '/') --s;\n    if (need_dir(file)) {\n      temp += dir;\n      temp += '/';\n    }\n    if (s != -1) {\n      temp.append(file, s);\n    }\n    return temp;\n  }\n\n  time_t get_modification_time(FStream & f) {\n    struct stat s;\n    fstat(f.file_no(), &s);\n    return s.st_mtime;\n  }\n\n  PosibErr<void> open_file_readlock(FStream & in, ParmString file) {\n    RET_ON_ERR(in.open(file, \"r\"));\n#ifdef USE_FILE_LOCKS\n    int fd = in.file_no();\n    struct flock fl;\n    fl.l_type   = F_RDLCK;\n    fl.l_whence = SEEK_SET;\n    fl.l_start  = 0;\n    fl.l_len    = 0;\n    fcntl(fd, F_SETLKW, &fl); // ignore errors\n#endif\n    return no_err;\n  }\n\n  PosibErr<bool> open_file_writelock(FStream & inout, ParmString file) {\n    typedef PosibErr<bool> Ret;\n#ifndef USE_FILE_LOCKS\n    bool exists = file_exists(file);\n#endif\n    {\n     Ret pe = inout.open(file, \"r+\");\n     if (pe.get_err() != 0)\n       pe = inout.open(file, \"w+\");\n     if (pe.has_err())\n       return pe;\n    }\n#ifdef USE_FILE_LOCKS\n    int fd = inout.file_no();\n    struct flock fl;\n    fl.l_type   = F_WRLCK;\n    fl.l_whence = SEEK_SET;\n    fl.l_start  = 0;\n    fl.l_len    = 0;\n    fcntl(fd, F_SETLKW, &fl); // ignore errors\n    struct stat s;\n    fstat(fd, &s);\n    return s.st_size != 0;\n#else\n    return exists;\n#endif\n  }\n\n  void truncate_file(FStream & f, ParmString name) {\n#ifdef USE_FILE_LOCKS\n    f.restart();\n    ftruncate(f.file_no(),0);\n#else\n    f.close();\n    f.open(name, \"w+\");\n#endif\n  }\n\n  bool remove_file(ParmString name) {\n    return remove(name) == 0;\n  }\n\n  bool file_exists(ParmString name) {\n    return ACCESS(name, F_OK) == 0;\n  }\n\n  bool rename_file(ParmString orig_name, ParmString new_name)\n  {\n    remove(new_name);\n    return rename(orig_name, new_name) == 0;\n  }\n \n  const char * get_file_name(const char * path) {\n    const char * file_name;\n    if (path != 0) {\n      file_name = strrchr(path,'/');\n      if (file_name == 0)\n        file_name = path;\n    } else {\n      file_name = 0;\n    }\n    return file_name;\n  }\n\n  unsigned find_file(const Config * config, const char * option, String & filename)\n  {\n    StringList sl;\n    config->retrieve_list(option, &sl);\n    return find_file(sl, filename);\n  }\n\n  unsigned find_file(const StringList & sl, String & filename)\n  {\n    StringListEnumeration els = sl.elements_obj();\n    const char * dir;\n    String path;\n    while ( (dir = els.next()) != 0 ) \n    {\n      path = dir;\n      if (path.back() != '/') path += '/';\n      unsigned dir_len = path.size();\n      path += filename;\n      if (file_exists(path)) {\n        filename.swap(path);\n        return dir_len;\n      }\n    }\n    return 0;\n  }\n\n  PathBrowser::PathBrowser(const StringList & sl, const char * suf)\n    : dir_handle(0)\n  {\n    els = sl.elements();\n    suffix = suf;\n  }\n\n  PathBrowser::~PathBrowser() \n  {\n    delete els;\n    if (dir_handle) closedir((DIR *)dir_handle);\n  }\n\n  const char * PathBrowser::next()\n  {\n    if (dir_handle == 0) goto get_next_dir;\n  begin: {\n      struct dirent * entry = readdir((DIR *)dir_handle);\n      if (entry == 0) goto try_again;\n      const char * name = entry->d_name;\n      unsigned name_len = strlen(name);\n      if (suffix.size() != 0 && \n          !(name_len > suffix.size() \n            && memcmp(name + name_len - suffix.size(), suffix.str(), suffix.size()) == 0))\n        goto begin;\n      path = dir;\n      if (path.back() != '/') path += '/';\n      path += name;\n    }\n    return path.str();\n  try_again:\n    if (dir_handle) closedir((DIR *)dir_handle);\n    dir_handle = 0;\n  get_next_dir:\n    dir = els->next();\n    if (!dir) return 0;\n    dir_handle = opendir(dir);\n    if (dir_handle == 0) goto try_again;\n    goto begin;\n  }\n}\n", "// This file is part of The New Aspell\n// Copyright (C) 2001 by Kevin Atkinson under the GNU LGPL license\n// version 2.0 or 2.1.  You should have received a copy of the LGPL\n// license along with this library if you did not you can find\n// it at http://www.gnu.org/.\n\n#include <string.h>\n\n#include \"getdata.hpp\"\n#include \"string.hpp\"\n#include \"asc_ctype.hpp\"\n\n#include \"iostream.hpp\"\n\nnamespace acommon {\n  unsigned int linenumber = 0 ;\n\n  bool getdata_pair(IStream & in, DataPair & d, String & buf)\n  {\n    char * p;\n\n    // get first non blank line and count all read ones\n    do {\n      buf.clear();\n      buf.append('\\0'); // to avoid some special cases\n      if (!in.append_line(buf)) return false;\n      d.line_num++;\n      p = buf.mstr() + 1;\n      while (*p == ' ' || *p == '\\t') ++p;\n    } while (*p == '#' || *p == '\\0');\n\n    // get key\n    d.key.str = p;\n    while (*p != '\\0' &&\n           ((*p != ' ' && *p != '\\t' && *p != '#') || *(p-1) == '\\\\')) ++p;\n    d.key.size = p - d.key.str;\n\n    // figure out if there is a value and add terminate key\n    d.value.str = p; // in case there is no value\n    d.value.size = 0;\n    if (*p == '#' || *p == '\\0') {*p = '\\0'; return true;}\n    *p = '\\0';\n\n    // skip any whitespace\n    ++p;\n    while (*p == ' ' || *p == '\\t') ++p;\n    if (*p == '\\0' || *p == '#') {return true;}\n\n    // get value\n    d.value.str = p;\n    while (*p != '\\0' && (*p != '#' || *(p-1) == '\\\\')) ++p;\n    \n    // remove trailing white space and terminate value\n    --p;\n    while (*p == ' ' || *p == '\\t') --p;\n    if (*p == '\\\\' && *(p + 1) != '\\0') ++p;\n    ++p;\n    d.value.size = p - d.value.str;\n    *p = '\\0';\n\n    return true;\n  }\n\n  char * unescape(char * dest, const char * src)\n  {\n    while (*src) {\n      if (*src == '\\\\') {\n\t++src;\n\tswitch (*src) {\n\tcase 'n': *dest = '\\n'; break;\n\tcase 'r': *dest = '\\r'; break;\n\tcase 't': *dest = '\\t'; break;\n\tcase 'f': *dest = '\\f'; break;\n\tcase 'v': *dest = '\\v'; break;\n\tdefault: *dest = *src;\n\t}\n      } else {\n\t*dest = *src;\n      }\n      ++src;\n      ++dest;\n    }\n    *dest = '\\0';\n    return dest;\n  }\n\n  bool escape(char * dest, const char * src, size_t limit, const char * others)\n  {\n    const char * begin = src;\n    const char * end = dest + limit;\n    if (asc_isspace(*src)) {\n      if (dest == end) return false;\n      *dest++ = '\\\\';\n      if (dest == end) return false;\n      *dest++ = *src++;\n    }\n    while (*src) {\n      if (dest == end) return false;\n      switch (*src) {\n      case '\\n': *dest++ = '\\\\'; *dest = 'n'; break;\n      case '\\r': *dest++ = '\\\\'; *dest = 'r'; break;\n      case '\\t': *dest++ = '\\\\'; *dest = 't'; break;\n      case '\\f': *dest++ = '\\\\'; *dest = 'f'; break;\n      case '\\v': *dest++ = '\\\\'; *dest = 'v'; break;\n      case '\\\\': *dest++ = '\\\\'; *dest = '\\\\'; break;\n      case '#' : *dest++ = '\\\\'; *dest = '#'; break;\n      default:\n\tif (others && strchr(others, *src)) *dest++ = '\\\\';\n\t*dest = *src;\n      }\n      ++src;\n      ++dest;\n    }\n    if (src > begin + 1 && asc_isspace(src[-1])) {\n      --dest;\n      *dest++ = '\\\\';\n      if (dest == end) return false;\n      *dest++ = src[-1];\n    }\n    *dest = '\\0';\n    return true;\n  }\n\n  void to_lower(char * str)\n  {\n    for (; *str; str++) *str = asc_tolower(*str);\n  }\n\n  void to_lower(String & res, const char * str)\n  {\n    for (; *str; str++) res += asc_tolower(*str);\n  }\n\n  bool split(DataPair & d)\n  {\n    char * p   = d.value;\n    char * end = p + d.value.size;\n    d.key.str = p;\n    while (p != end) {\n      ++p;\n      if ((*p == ' ' || *p == '\\t') && *(p-1) != '\\\\') break;\n    }\n    d.key.size = p - d.key.str;\n    *p = 0;\n    if (p != end) {\n      ++p;\n      while (p != end && (*p == ' ' || *p == '\\t')) ++p;\n    }\n    d.value.str = p;\n    d.value.size = end - p;\n    return d.key.size != 0;\n  }\n\n  void init(ParmString str, DataPair & d, String & buf)\n  {\n    const char * s = str;\n    while (*s == ' ' || *s == '\\t') ++s;\n    size_t l = str.size() - (s - str);\n    buf.assign(s, l);\n    d.value.str  = buf.mstr();\n    d.value.size = l;\n  }\n\n  bool getline(IStream & in, DataPair & d, String & buf)\n  {\n    if (!in.getline(buf)) return false;\n    d.value.str  = buf.mstr();\n    d.value.size = buf.size();\n    return true;\n  }\n\n  char * get_nb_line(IStream & in, String & buf)\n  {\n    char * p;\n    // get first non blank line\n    do {\n      if (!in.getline(buf)) return 0;\n      p = buf.mstr();\n      while (*p == ' ' || *p == '\\t') ++p;\n    } while (*p == '#' || *p == '\\0');\n    return p;\n  }\n\n  void remove_comments(String & buf)\n  {\n    char * p = buf.mstr();\n    char * b = p;\n    while (*p && *p != '#') ++p;\n    if (*p == '#') {--p; while (p >= b && asc_isspace(*p)) --p; ++p;}\n    buf.resize(p - b);\n  }\n\n}\n"], "fixing_code": ["// This file is part of The New Aspell\n// Copyright (C) 2001 by Kevin Atkinson under the GNU LGPL license\n// version 2.0 or 2.1.  You should have received a copy of the LGPL\n// license along with this library if you did not you can find\n// it at http://www.gnu.org/.\n\n//#include <stdio.h>\n//#define DEBUG {fprintf(stderr,\"File: %s(%i)\\n\",__FILE__,__LINE__);}\n#include <string.h>\n#include <stdlib.h>\n#include \"ndebug.hpp\"\n#include <assert.h>\n\n#include \"dirs.h\"\n#include \"settings.h\"\n\n#ifdef USE_LOCALE\n# include <locale.h>\n#endif\n\n#ifdef HAVE_LANGINFO_CODESET\n# include <langinfo.h>\n#endif\n\n#include \"cache.hpp\"\n#include \"asc_ctype.hpp\"\n#include \"config.hpp\"\n#include \"errors.hpp\"\n#include \"file_util.hpp\"\n#include \"fstream.hpp\"\n#include \"getdata.hpp\"\n#include \"itemize.hpp\"\n#include \"mutable_container.hpp\"\n#include \"posib_err.hpp\"\n#include \"string_map.hpp\"\n#include \"stack_ptr.hpp\"\n#include \"char_vector.hpp\"\n#include \"convert.hpp\"\n#include \"vararray.hpp\"\n#include \"string_list.hpp\"\n\n#include \"gettext.h\"\n\n#include \"iostream.hpp\"\n\n#define DEFAULT_LANG \"en_US\"\n\n// NOTE: All filter options are now stored with he \"f-\" prefix.  However\n//   during lookup, the non prefix version is also recognized.\n\n// The \"place_holder\" field in Entry and the \"Vector<int>\" parameter of\n// commit_all are there to deal with the fact than when spacing\n// options on the command line such as \"--key what\" it can not be\n// determined if \"what\" should be a the value of \"key\" or if it should\n// be treated as an independent arg.  This is because \"key\" may\n// be a filter option.  Filter options KeyInfo are not loaded until\n// after a commit which is not done at the time the options are being\n// read in from the command line.  (If the command line arguments are\n// read in after the other settings are read in and committed than any\n// options setting any of the config files will be ignored.  Thus the\n// command line must be parsed and options must be added in an\n// uncommitted state).  So the solution is to assume it is an\n// independent arg until told otherwise, the position in the arg array\n// is stored along with the value in the \"place_holder\" field.  When\n// the config class is finally committed and it is determined that\n// \"what\" is really a value for key the stored arg position is pushed\n// onto the Vector<int> so it can be removed from the arg array.  In\n// the case of a \"lset-*\" this will happen in multiple config\n// \"Entry\"s, so care is taken to only add the arg position once.\n\nnamespace acommon {\n\n  const char * const keyinfo_type_name[4] = {\n    N_(\"string\"), N_(\"integer\"), N_(\"boolean\"), N_(\"list\")\n  };\n\n  const int Config::num_parms_[9] = {1, 1, 0, 0, 0,\n                                     1, 1, 1, 0};\n  \n  typedef Notifier * NotifierPtr;\n  \n  Config::Config(ParmStr name,\n\t\t const KeyInfo * mainbegin, \n\t\t const KeyInfo * mainend)\n    : name_(name)\n    , first_(0), insert_point_(&first_), others_(0)\n    , committed_(true), attached_(false)\n    , md_info_list_index(-1)\n    , settings_read_in_(false)\n    , load_filter_hook(0)\n    , filter_mode_notifier(0)\n  {\n    keyinfo_begin = mainbegin;\n    keyinfo_end   = mainend;\n    extra_begin = 0;\n    extra_end   = 0;\n  }\n\n  Config::~Config() {\n    del();\n  }\n\n  Config::Config(const Config & other) \n  {\n    copy(other);\n  }\n  \n  Config & Config::operator= (const Config & other)\n  {\n    del();\n    copy(other);\n    return *this;\n  }\n  \n  Config * Config::clone() const {\n    return new Config(*this);\n  }\n\n  void Config::assign(const Config * other) {\n    *this = *(const Config *)(other);\n  }\n\n  void Config::copy(const Config & other)\n  {\n    assert(other.others_ == 0);\n    others_ = 0;\n\n    name_ = other.name_;\n\n    committed_ = other.committed_;\n    attached_ = other.attached_;\n    settings_read_in_ = other.settings_read_in_;\n\n    keyinfo_begin = other.keyinfo_begin;\n    keyinfo_end   = other.keyinfo_end;\n    extra_begin   = other.extra_begin;\n    extra_end     = other.extra_end;\n    filter_modules = other.filter_modules;\n\n#ifdef HAVE_LIBDL\n    filter_modules_ptrs = other.filter_modules_ptrs;\n    for (Vector<Cacheable *>::iterator i = filter_modules_ptrs.begin();\n         i != filter_modules_ptrs.end();\n         ++i)\n      (*i)->copy();\n#endif\n\n    md_info_list_index = other.md_info_list_index;\n\n    insert_point_ = 0;\n    Entry * const * src  = &other.first_;\n    Entry * * dest = &first_;\n    while (*src) \n    {\n      *dest = new Entry(**src);\n      if (src == other.insert_point_)\n        insert_point_ = dest;\n      src  = &((*src)->next);\n      dest = &((*dest)->next);\n    }\n    if (insert_point_ == 0)\n      insert_point_ = dest;\n    *dest = 0;\n\n    Vector<Notifier *>::const_iterator i   = other.notifier_list.begin();\n    Vector<Notifier *>::const_iterator end = other.notifier_list.end();\n\n    for(; i != end; ++i) {\n      Notifier * tmp = (*i)->clone(this);\n      if (tmp != 0)\n\tnotifier_list.push_back(tmp);\n    }\n  }\n\n  void Config::del()\n  {\n    while (first_) {\n      Entry * tmp = first_->next;\n      delete first_;\n      first_ = tmp;\n    }\n\n    while (others_) {\n      Entry * tmp = others_->next;\n      delete first_;\n      others_ = tmp;\n    }\n\n    Vector<Notifier *>::iterator i   = notifier_list.begin();\n    Vector<Notifier *>::iterator end = notifier_list.end();\n\n    for(; i != end; ++i) {\n      delete (*i);\n      *i = 0;\n    }\n    \n    notifier_list.clear();\n\n#ifdef HAVE_LIBDL\n    filter_modules.clear();\n    for (Vector<Cacheable *>::iterator i = filter_modules_ptrs.begin();\n         i != filter_modules_ptrs.end();\n         ++i)\n      (*i)->release();\n    filter_modules_ptrs.clear();\n#endif\n  }\n\n  void Config::set_filter_modules(const ConfigModule * modbegin, \n\t\t\t\t  const ConfigModule * modend)\n  {\n    assert(filter_modules_ptrs.empty());\n    filter_modules.clear();\n    filter_modules.assign(modbegin, modend);\n  }\n\n  void Config::set_extra(const KeyInfo * begin, \n\t\t\t       const KeyInfo * end) \n  {\n    extra_begin = begin;\n    extra_end   = end;\n  }\n\n  //\n  //\n  //\n\n\n  //\n  // Notifier methods\n  //\n\n  NotifierEnumeration * Config::notifiers() const \n  {\n    return new NotifierEnumeration(notifier_list);\n  }\n\n  bool Config::add_notifier(Notifier * n) \n  {\n    Vector<Notifier *>::iterator i   = notifier_list.begin();\n    Vector<Notifier *>::iterator end = notifier_list.end();\n\n    while (i != end && *i != n)\n      ++i;\n\n    if (i != end) {\n    \n      return false;\n    \n    } else {\n\n      notifier_list.push_back(n);\n      return true;\n\n    }\n  }\n\n  bool Config::remove_notifier(const Notifier * n) \n  {\n    Vector<Notifier *>::iterator i   = notifier_list.begin();\n    Vector<Notifier *>::iterator end = notifier_list.end();\n\n    while (i != end && *i != n)\n      ++i;\n\n    if (i == end) {\n    \n      return false;\n    \n    } else {\n\n      delete *i;\n      notifier_list.erase(i);\n      return true;\n\n    }\n  }\n\n  bool Config::replace_notifier(const Notifier * o, \n\t\t\t\t      Notifier * n) \n  {\n    Vector<Notifier *>::iterator i   = notifier_list.begin();\n    Vector<Notifier *>::iterator end = notifier_list.end();\n\n    while (i != end && *i != o)\n      ++i;\n\n    if (i == end) {\n    \n      return false;\n    \n    } else {\n\n      delete *i;\n      *i = n;\n      return true;\n\n    }\n  }\n\n  //\n  // retrieve methods\n  //\n\n  const Config::Entry * Config::lookup(const char * key) const\n  {\n    const Entry * res = 0;\n    const Entry * cur = first_;\n\n    while (cur) {\n      if (cur->key == key && cur->action != NoOp)  res = cur;\n      cur = cur->next;\n    }\n\n    if (!res || res->action == Reset) return 0;\n    return res;\n  }\n\n  bool Config::have(ParmStr key) const \n  {\n    PosibErr<const KeyInfo *> pe = keyinfo(key);\n    if (pe.has_err()) {pe.ignore_err(); return false;}\n    return lookup(pe.data->name);\n  }\n\n  PosibErr<String> Config::retrieve(ParmStr key) const\n  {\n    RET_ON_ERR_SET(keyinfo(key), const KeyInfo *, ki);\n    if (ki->type == KeyInfoList) return make_err(key_not_string, ki->name);\n\n    const Entry * cur = lookup(ki->name);\n\n    return cur ? cur->value : get_default(ki);\n  }\n\n  PosibErr<String> Config::retrieve_any(ParmStr key) const\n  {\n    RET_ON_ERR_SET(keyinfo(key), const KeyInfo *, ki);\n\n    if (ki->type != KeyInfoList) {\n      const Entry * cur = lookup(ki->name);\n      return cur ? cur->value : get_default(ki);\n    } else {\n      StringList sl;\n      RET_ON_ERR(retrieve_list(key, &sl));\n      StringListEnumeration els = sl.elements_obj();\n      const char * s;\n      String val;\n      while ( (s = els.next()) != 0 ) {\n        val += s;\n        val += '\\n';\n      }\n      val.pop_back();\n      return val;\n    }\n  }\n\n  PosibErr<bool> Config::retrieve_bool(ParmStr key) const\n  {\n    RET_ON_ERR_SET(keyinfo(key), const KeyInfo *, ki);\n    if (ki->type != KeyInfoBool) return make_err(key_not_bool, ki->name);\n\n    const Entry * cur = lookup(ki->name);\n\n    String value(cur ? cur->value : get_default(ki));\n\n    if (value == \"false\") return false;\n    else                  return true;\n  }\n  \n  PosibErr<int> Config::retrieve_int(ParmStr key) const\n  {\n    assert(committed_); // otherwise the value may not be an integer\n                        // as it has not been verified.\n\n    RET_ON_ERR_SET(keyinfo(key), const KeyInfo *, ki);\n    if (ki->type != KeyInfoInt) return make_err(key_not_int, ki->name);\n\n    const Entry * cur = lookup(ki->name);\n\n    String value(cur ? cur->value : get_default(ki));\n\n    return atoi(value.str());\n  }\n\n  void Config::lookup_list(const KeyInfo * ki,\n                           MutableContainer & m,\n                           bool include_default) const\n  {\n    const Entry * cur = first_;\n    const Entry * first_to_use = 0;\n\n    while (cur) {\n      if (cur->key == ki->name && \n          (first_to_use == 0 || \n           cur->action == Reset || cur->action == Set \n           || cur->action == ListClear)) \n        first_to_use = cur;\n      cur = cur->next;\n    }\n\n    cur = first_to_use;\n\n    if (include_default && \n        (!cur || \n         !(cur->action == Set || cur->action == ListClear)))\n    {\n      String def = get_default(ki);\n      separate_list(def, m, true);\n    }\n\n    if (cur && cur->action == Reset) {\n      cur = cur->next;\n    }\n\n    if (cur && cur->action == Set) {\n      if (!include_default) m.clear();\n      m.add(cur->value);\n      cur = cur->next;\n    }\n\n    if (cur && cur->action == ListClear) {\n      if (!include_default) m.clear();\n      cur = cur->next;\n    }\n\n    while (cur) {\n      if (cur->key == ki->name) {\n        if (cur->action == ListAdd)\n          m.add(cur->value);\n        else if (cur->action == ListRemove)\n          m.remove(cur->value);\n      }\n      cur = cur->next;\n    }\n  }\n\n  PosibErr<void> Config::retrieve_list(ParmStr key, \n\t\t\t\t       MutableContainer * m) const\n  {\n    RET_ON_ERR_SET(keyinfo(key), const KeyInfo *, ki);\n    if (ki->type != KeyInfoList) return make_err(key_not_list, ki->name);\n\n    lookup_list(ki, *m, true);\n\n    return no_err;\n  }\n\n  static const KeyInfo * find(ParmStr key, \n\t\t\t      const KeyInfo * i, \n\t\t\t      const KeyInfo * end) \n  {\n    while (i != end) {\n      if (strcmp(key, i->name) == 0)\n\treturn i;\n      ++i;\n    }\n    return i;\n  }\n\n  static const ConfigModule * find(ParmStr key, \n\t\t\t\t   const ConfigModule * i, \n\t\t\t\t   const ConfigModule * end) \n  {\n    while (i != end) {\n      if (strcmp(key, i->name) == 0)\n\treturn i;\n      ++i;\n    }\n    return i;\n  }\n\n  PosibErr<const KeyInfo *> Config::keyinfo(ParmStr key) const\n  {\n    typedef PosibErr<const KeyInfo *> Ret;\n    {\n      const KeyInfo * i;\n      i = acommon::find(key, keyinfo_begin, keyinfo_end);\n      if (i != keyinfo_end) return Ret(i);\n      \n      i = acommon::find(key, extra_begin, extra_end);\n      if (i != extra_end) return Ret(i);\n      \n      const char * s = strncmp(key, \"f-\", 2) == 0 ? key + 2 : key.str();\n      const char * h = strchr(s, '-');\n      if (h == 0) goto err;\n\n      String k(s, h - s);\n      const ConfigModule * j = acommon::find(k,\n\t\t\t\t\t     filter_modules.pbegin(),\n\t\t\t\t\t     filter_modules.pend());\n      \n      if (j == filter_modules.pend() && load_filter_hook && committed_) {\n        // FIXME: This isn't quite right\n        PosibErrBase pe = load_filter_hook(const_cast<Config *>(this), k);\n        pe.ignore_err();\n        j = acommon::find(k,\n                          filter_modules.pbegin(),\n                          filter_modules.pend());\n      }\n\n      if (j == filter_modules.pend()) goto err;\n\n      i = acommon::find(key, j->begin, j->end);\n      if (i != j->end) return Ret(i);\n      \n      if (strncmp(key, \"f-\", 2) != 0) k = \"f-\";\n      else                            k = \"\";\n      k += key;\n      i = acommon::find(k, j->begin, j->end);\n      if (i != j->end) return Ret(i);\n    }\n  err:  \n    return Ret().prim_err(unknown_key, key);\n  }\n\n  static bool proc_locale_str(ParmStr lang, String & final_str)\n  {\n    if (lang == 0) return false;\n    const char * i = lang;\n    if (!(asc_islower(i[0]) && asc_islower(i[1]))) return false;\n    final_str.assign(i, 2);\n    i += 2;\n    if (! (i[0] == '_' || i[0] == '-')) return true;\n    i += 1;\n    if (!(asc_isupper(i[0]) && asc_isupper(i[1]))) return true;\n    final_str += '_';\n    final_str.append(i, 2);\n    return true;\n  }\n\n  static void get_lang_env(String & str) \n  {\n    if (proc_locale_str(getenv(\"LC_MESSAGES\"), str)) return;\n    if (proc_locale_str(getenv(\"LANG\"), str)) return;\n    if (proc_locale_str(getenv(\"LANGUAGE\"), str)) return;\n    str = DEFAULT_LANG;\n  }\n\n#ifdef USE_LOCALE\n\n  static void get_lang(String & final_str) \n  {\n    // FIXME: THIS IS NOT THREAD SAFE\n    String locale = setlocale (LC_ALL, NULL);\n    if (locale == \"C\")\n      setlocale (LC_ALL, \"\");\n    const char * lang = setlocale (LC_MESSAGES, NULL);\n    bool res = proc_locale_str(lang, final_str);\n    if (locale == \"C\")\n      setlocale(LC_MESSAGES, locale.c_str());\n    if (!res)\n      get_lang_env(final_str);\n  }\n\n#else\n\n  static inline void get_lang(String & str) \n  {\n    get_lang_env(str);\n  }\n\n#endif\n\n#if defined USE_LOCALE && defined HAVE_LANGINFO_CODESET\n\n  static inline void get_encoding(const Config & c, String & final_str)\n  {\n    const char * codeset = nl_langinfo(CODESET);\n    if (ascii_encoding(c, codeset)) codeset = \"none\";\n    final_str = codeset;\n  }\n\n#else\n\n  static inline void get_encoding(const Config &, String & final_str)\n  {\n    final_str = \"none\";\n  }\n\n#endif\n\n  String Config::get_default(const KeyInfo * ki) const\n  {\n    bool   in_replace = false;\n    String final_str;\n    String replace;\n    const char * i = ki->def;\n    if (*i == '!') { // special cases\n      ++i;\n    \n      if (strcmp(i, \"lang\") == 0) {\n        \n        const Entry * entry;\n        if (entry = lookup(\"actual-lang\"), entry) {\n          return entry->value;\n        } else if (have(\"master\")) {\n\t  final_str = \"<unknown>\";\n\t} else {\n\t  get_lang(final_str);\n\t}\n\t\n      } else if (strcmp(i, \"encoding\") == 0) {\n\n        get_encoding(*this, final_str);\n\n      } else if (strcmp(i, \"special\") == 0) {\n\n\t// do nothing\n\n      } else {\n      \n\tabort(); // this should not happen\n      \n      }\n    \n    } else for(; *i; ++i) {\n    \n      if (!in_replace) {\n\n\tif (*i == '<') {\n\t  in_replace = true;\n\t} else {\n\t  final_str += *i;\n\t}\n\n      } else { // in_replace\n      \n\tif (*i == '/' || *i == ':' || *i == '|' || *i == '#' || *i == '^') {\n\t  char sep = *i;\n\t  String second;\n\t  ++i;\n\t  while (*i != '\\0' && *i != '>') second += *i++;\n\t  if (sep == '/') {\n\t    String s1 = retrieve(replace);\n\t    String s2 = retrieve(second);\n\t    final_str += add_possible_dir(s1, s2);\n\t  } else if (sep == ':') {\n\t    String s1 = retrieve(replace);\n\t    final_str += add_possible_dir(s1, second);\n\t  } else if (sep == '#') {\n\t    String s1 = retrieve(replace);\n\t    assert(second.size() == 1);\n\t    unsigned int s = 0;\n\t    while (s != s1.size() && s1[s] != second[0]) ++s;\n\t    final_str.append(s1, s);\n\t  } else if (sep == '^') {\n\t    String s1 = retrieve(replace);\n\t    String s2 = retrieve(second);\n\t    final_str += figure_out_dir(s1, s2);\n\t  } else { // sep == '|'\n\t    assert(replace[0] == '$');\n\t    const char * env = getenv(replace.c_str()+1);\n\t    final_str += env ? env : second;\n\t  }\n\t  replace = \"\";\n\t  in_replace = false;\n\n\t} else if (*i == '>') {\n\n\t  final_str += retrieve(replace).data;\n\t  replace = \"\";\n\t  in_replace = false;\n\n\t} else {\n\n\t  replace += *i;\n\n\t}\n\n      }\n      \n    }\n    return final_str;\n  }\n\n  PosibErr<String> Config::get_default(ParmStr key) const\n  {\n    RET_ON_ERR_SET(keyinfo(key), const KeyInfo *, ki);\n    return get_default(ki);\n  }\n\n\n\n#define TEST(v,l,a)                         \\\n  do {                                      \\\n    if (len == l && memcmp(s, v, l) == 0) { \\\n      if (action) *action = a;              \\\n      return c + 1;                         \\\n    }                                       \\\n  } while (false)\n\n  const char * Config::base_name(const char * s, Action * action)\n  {\n    if (action) *action = Set;\n    const char * c = strchr(s, '-');\n    if (!c) return s;\n    unsigned len = c - s;\n    TEST(\"reset\",   5, Reset);\n    TEST(\"enable\",  6, Enable);\n    TEST(\"dont\",    4, Disable);\n    TEST(\"disable\", 7, Disable);\n    TEST(\"lset\",    4, ListSet);\n    TEST(\"rem\",     3, ListRemove);\n    TEST(\"remove\",  6, ListRemove);\n    TEST(\"add\",     3, ListAdd);\n    TEST(\"clear\",   5, ListClear);\n    return s;\n  }\n\n#undef TEST\n\n  void separate_list(ParmStr value, AddableContainer & out, bool do_unescape)\n  {\n    unsigned len = value.size();\n    \n    VARARRAY(char, buf, len + 1);\n    memcpy(buf, value, len + 1);\n    \n    len = strlen(buf);\n    char * s = buf;\n    char * end = buf + len;\n      \n    while (s < end)\n    {\n      if (do_unescape) while (*s == ' ' || *s == '\\t') ++s;\n      char * b = s;\n      char * e = s;\n      while (*s != '\\0') {\n        if (do_unescape && *s == '\\\\') {\n          ++s;\n          if (*s == '\\0') break;\n          e = s;\n          ++s;\n        } else {\n          if (*s == ':') break;\n          if (!do_unescape || (*s != ' ' && *s != '\\t')) e = s;\n          ++s;\n        }\n      }\n      if (s != b) {\n        ++e;\n        *e = '\\0';\n        if (do_unescape) unescape(b);\n      \n        out.add(b);\n      }\n      ++s;\n    }\n  }\n\n  void combine_list(String & res, const StringList & in)\n  {\n    res.clear();\n    StringListEnumeration els = in.elements_obj();\n    const char * s = 0;\n    while ( (s = els.next()) != 0) \n    {\n      for (; *s; ++s) {\n        if (*s == ':')\n          res.append('\\\\');\n        res.append(*s);\n      }\n      res.append(':');\n    }\n    if (!res.empty() && res.back() == ':') res.pop_back();\n  }\n\n  struct ListAddHelper : public AddableContainer \n  {\n    Config * config;\n    Config::Entry * orig_entry;\n    PosibErr<bool> add(ParmStr val);\n  };\n\n  PosibErr<bool> ListAddHelper::add(ParmStr val)\n  {\n    Config::Entry * entry = new Config::Entry(*orig_entry);\n    entry->value = val;\n    entry->action = Config::ListAdd;\n    config->set(entry);\n    return true;\n  }\n\n  void Config::replace_internal(ParmStr key, ParmStr value)\n  {\n    Entry * entry = new Entry;\n    entry->key = key;\n    entry->value = value;\n    entry->action = Set;\n    entry->next = *insert_point_;\n    *insert_point_ = entry;\n    insert_point_ = &entry->next;\n  }\n\n  PosibErr<void> Config::replace(ParmStr key, ParmStr value)\n  {\n    Entry * entry = new Entry;\n    entry->key = key;\n    entry->value = value;\n    return set(entry);\n  }\n  \n  PosibErr<void> Config::remove(ParmStr key)\n  {\n    Entry * entry = new Entry;\n    entry->key = key;\n    entry->action = Reset;\n    return set(entry);\n  }\n\n  PosibErr<void> Config::set(Entry * entry0, bool do_unescape)\n  {\n    StackPtr<Entry> entry(entry0);\n\n    if (entry->action == NoOp)\n      entry->key = base_name(entry->key.str(), &entry->action);\n\n    if (num_parms(entry->action) == 0 && !entry->value.empty()) \n    {\n      if (entry->place_holder == -1) {\n        switch (entry->action) {\n        case Reset:\n          return make_err(no_value_reset, entry->key);\n        case Enable:\n          return make_err(no_value_enable, entry->key);\n        case Disable:\n          return make_err(no_value_disable, entry->key);\n        case ListClear:\n          return make_err(no_value_clear, entry->key);\n        default:\n          abort(); // this shouldn't happen\n        }\n      } else {\n        entry->place_holder = -1;\n      }\n    }\n\n    if (entry->action != ListSet) {\n\n      switch (entry->action) {\n      case Enable:\n        entry->value = \"true\";\n        entry->action = Set;\n        break;\n      case Disable:\n        entry->value = \"false\";\n        entry->action = Set;\n        break;\n      default:\n        ;\n      }\n      if (do_unescape) unescape(entry->value.mstr());\n\n      entry->next = *insert_point_;\n      *insert_point_ = entry;\n      insert_point_ = &entry->next;\n      entry.release();\n      if (committed_) RET_ON_ERR(commit(entry0)); // entry0 == entry\n      \n    } else { // action == ListSet\n\n      Entry * ent = new Entry;\n      ent->key = entry->key;\n      ent->action = ListClear;\n      set(ent);\n\n      ListAddHelper helper;\n      helper.config = this;\n      helper.orig_entry = entry;\n\n      separate_list(entry->value.str(), helper, do_unescape);\n    }\n    return no_err;\n  }\n\n  PosibErr<void> Config::merge(const Config & other)\n  {\n    const Entry * src  = other.first_;\n    while (src) \n    {\n      Entry * entry = new Entry(*src);\n      entry->next = *insert_point_;\n      *insert_point_ = entry;\n      insert_point_ = &entry->next;\n      if (committed_) RET_ON_ERR(commit(entry));\n      src = src->next;\n    }\n    return no_err;\n  }\n\n  void Config::lang_config_merge(const Config & other,\n                                 int which, ParmStr data_encoding)\n  {\n    Conv to_utf8;\n    to_utf8.setup(*this, data_encoding, \"utf-8\", NormTo);\n    const Entry * src  = other.first_;\n    Entry * * ip = &first_;\n    while (src)\n    {\n      const KeyInfo * l_ki = other.keyinfo(src->key);\n      if (l_ki->other_data == which) {\n        const KeyInfo * c_ki = keyinfo(src->key);\n        Entry * entry = new Entry(*src);\n        if (c_ki->flags & KEYINFO_UTF8)\n          entry->value = to_utf8(entry->value);\n        entry->next = *ip;\n        *ip = entry;\n        ip = &entry->next;\n      }\n      src = src->next;\n    }\n  }\n\n\n#define NOTIFY_ALL(fun)                                       \\\n  do {                                                        \\\n    Vector<Notifier *>::iterator   i = notifier_list.begin(); \\\n    Vector<Notifier *>::iterator end = notifier_list.end();   \\\n    while (i != end) {                                        \\\n      RET_ON_ERR((*i)->fun);                                  \\\n      ++i;                                                    \\\n    }                                                         \\\n  } while (false)\n\n  PosibErr<int> Config::commit(Entry * entry, Conv * conv) \n  {\n    PosibErr<const KeyInfo *> pe = keyinfo(entry->key);\n    {\n      if (pe.has_err()) goto error;\n      \n      const KeyInfo * ki = pe;\n\n      entry->key = ki->name;\n      \n      // FIXME: This is the correct thing to do but it causes problems\n      //        with changing a filter mode in \"pipe\" mode and probably\n      //        elsewhere.\n      //if (attached_ && !(ki->flags & KEYINFO_MAY_CHANGE)) {\n      //  pe = make_err(cant_change_value, entry->key);\n      //  goto error;\n      //}\n\n      int place_holder = entry->place_holder;\n      \n      if (conv && ki->flags & KEYINFO_UTF8)\n        entry->value = (*conv)(entry->value);\n\n      if (ki->type != KeyInfoList && list_action(entry->action)) {\n        pe = make_err(key_not_list, entry->key);\n        goto error;\n      }\n      \n      assert(ki->def != 0); // if null this key should never have values\n      // directly added to it\n      String value(entry->action == Reset ? get_default(ki) : entry->value);\n      \n      switch (ki->type) {\n        \n      case KeyInfoBool: {\n\n        bool val;\n      \n        if  (value.empty() || entry->place_holder != -1) {\n          // if entry->place_holder != -1 than IGNORE the value no\n          // matter what it is\n          entry->value = \"true\";\n          val = true;\n          place_holder = -1;\n        } else if (value == \"true\") {\n          val = true;\n        } else if (value == \"false\") {\n          val = false;\n        } else {\n          pe = make_err(bad_value, entry->key, value,\n                        /* TRANSLATORS: \"true\" and \"false\" are literal\n                         * values and should not be translated.*/\n                        _(\"either \\\"true\\\" or \\\"false\\\"\"));\n          goto error;\n        }\n\n        NOTIFY_ALL(item_updated(ki, val));\n        break;\n        \n      } case KeyInfoString:\n        \n        NOTIFY_ALL(item_updated(ki, value));\n        break;\n        \n      case KeyInfoInt: \n      {\n        int num;\n        \n        if (sscanf(value.str(), \"%i\", &num) == 1 && num >= 0) {\n          NOTIFY_ALL(item_updated(ki, num));\n        } else {\n          pe = make_err(bad_value, entry->key, value, _(\"a positive integer\"));\n          goto error;\n        }\n        \n        break;\n      }\n      case KeyInfoList:\n        \n        NOTIFY_ALL(list_updated(ki));\n        break;\n        \n      }\n      return place_holder;\n    }\n  error:\n    entry->action = NoOp;\n    if (!entry->file.empty())\n      return pe.with_file(entry->file, entry->line_num);\n    else\n      return (PosibErrBase &)pe;\n  }\n\n#undef NOTIFY_ALL\n\n\n  /////////////////////////////////////////////////////////////////////\n  /////////////////////////////////////////////////////////////////////\n\n  class PossibleElementsEmul : public KeyInfoEnumeration\n  {\n  private:\n    bool include_extra;\n    bool include_modules;\n    bool module_changed;\n    const Config * cd;\n    const KeyInfo * i;\n    const ConfigModule * m;\n  public:\n    PossibleElementsEmul(const Config * d, bool ic, bool im)\n      : include_extra(ic), include_modules(im), \n        module_changed(false), cd(d), i(d->keyinfo_begin), m(0) {}\n\n    KeyInfoEnumeration * clone() const {\n      return new PossibleElementsEmul(*this);\n    }\n\n    void assign(const KeyInfoEnumeration * other) {\n      *this = *(const PossibleElementsEmul *)(other);\n    }\n\n    virtual bool active_filter_module_changed(void) {\n      return module_changed;\n    }\n\n    const char * active_filter_module_name(void){\n      if (m != 0)\n        return m->name;\n      return \"\";\n    }\n\n    virtual const char * active_filter_module_desc(void) {\n      if (m != 0)\n        return m->desc;\n      return \"\";\n    }\n\n    const KeyInfo * next() {\n      if (i == cd->keyinfo_end) {\n\tif (include_extra)\n\t  i = cd->extra_begin;\n\telse\n\t  i = cd->extra_end;\n      }\n      \n      module_changed = false;\n      if (i == cd->extra_end) {\n\tm = cd->filter_modules.pbegin();\n\tif (!include_modules || m == cd->filter_modules.pend()) return 0;\n\telse {\n          i = m->begin;\n          module_changed = true;\n        }\n      }\n\n      if (m == 0){\n\treturn i++;\n      }\n\n      if (m == cd->filter_modules.pend()){\n\treturn 0;\n      }\n\n      while (i == m->end) {\n\t++m;\n\tif (m == cd->filter_modules.pend()) return 0;\n\telse {\n          i = m->begin;\n          module_changed = true;\n        }\n      }\n\n      return i++;\n    }\n\n    bool at_end() const {\n      return (m == cd->filter_modules.pend());\n    }\n  };\n\n  KeyInfoEnumeration *\n  Config::possible_elements(bool include_extra, bool include_modules) const\n  {\n    return new PossibleElementsEmul(this, include_extra, include_modules);\n  }\n\n  struct ListDefaultDump : public AddableContainer \n  {\n    OStream & out;\n    bool first;\n    const char * first_prefix;\n    unsigned num_blanks;\n    ListDefaultDump(OStream & o);\n    PosibErr<bool> add(ParmStr d);\n  };\n  \n  ListDefaultDump::ListDefaultDump(OStream & o) \n    : out(o), first(false)\n  {\n    first_prefix = _(\"# default: \");\n    num_blanks = strlen(first_prefix) - 1;\n  }\n\n  PosibErr<bool> ListDefaultDump::add(ParmStr d) \n  {\n    if (first) {\n      out.write(first_prefix);\n    } else {\n      out.put('#');\n      for (unsigned i = 0; i != num_blanks; ++i)\n        out.put(' ');\n    }\n    VARARRAY(char, buf, d.size() * 2 + 1);\n    escape(buf, d);\n    out.printl(buf);\n    first = false;\n    return true;\n  }\n\n  class ListDump : public MutableContainer \n  {\n    OStream & out;\n    const char * name;\n  public:\n    ListDump(OStream & o, ParmStr n) \n      : out(o), name(n) {}\n    PosibErr<bool> add(ParmStr d);\n    PosibErr<bool> remove(ParmStr d);\n    PosibErr<void> clear();\n  };\n\n  PosibErr<bool> ListDump::add(ParmStr d) {\n    VARARRAY(char, buf, d.size() * 2 + 1);\n    escape(buf, d);\n    out.printf(\"add-%s %s\\n\", name, buf);\n    return true;\n  }\n  PosibErr<bool> ListDump::remove(ParmStr d) {\n    VARARRAY(char, buf, d.size() * 2 + 1);\n    escape(buf, d);\n    out.printf(\"remove-%s %s\\n\", name, buf);\n    return true;\n  }\n  PosibErr<void> ListDump::clear() {\n    out.printf(\"clear-%s\\n\", name);\n    return no_err;\n  }\n\n  void Config::write_to_stream(OStream & out, \n\t\t\t       bool include_extra) \n  {\n    KeyInfoEnumeration * els = possible_elements(include_extra);\n    const KeyInfo * i;\n    String buf;\n    String obuf;\n    String def;\n    bool have_value;\n\n    while ((i = els->next()) != 0) {\n      if (i->desc == 0) continue;\n\n      if (els->active_filter_module_changed()) {\n        out.printf(_(\"\\n\"\n                     \"#######################################################################\\n\"\n                     \"#\\n\"\n                     \"# Filter: %s\\n\"\n                     \"#   %s\\n\"\n                     \"#\\n\"\n                     \"# configured as follows:\\n\"\n                     \"\\n\"),\n                   els->active_filter_module_name(),\n                   _(els->active_filter_module_desc()));\n      }\n\n      obuf.clear();\n      have_value = false;\n\n      obuf.printf(\"# %s (%s)\\n#   %s\\n\",\n                  i->name, _(keyinfo_type_name[i->type]), _(i->desc));\n      if (i->def != 0) {\n\tif (i->type != KeyInfoList) {\n          buf.resize(strlen(i->def) * 2 + 1);\n          escape(buf.data(), i->def);\n          obuf.printf(\"# default: %s\", buf.data());\n          def = get_default(i);\n          if (def != i->def) {\n            buf.resize(def.size() * 2 + 1);\n            escape(buf.data(), def.str());\n            obuf.printf(\" = %s\", buf.data());\n          }\n          obuf << '\\n';\n          const Entry * entry = lookup(i->name);\n\t  if (entry) {\n            have_value = true;\n            buf.resize(entry->value.size() * 2 + 1);\n            escape(buf.data(), entry->value.str());\n\t    obuf.printf(\"%s %s\\n\", i->name, buf.data());\n          }\n\t} else {\n          unsigned s = obuf.size();\n          ListDump ld(obuf, i->name);\n          lookup_list(i, ld, false);\n          have_value = s != obuf.size();\n\t}\n      }\n      obuf << '\\n';\n      if (!(i->flags & KEYINFO_HIDDEN) || have_value)\n        out.write(obuf);\n    }\n    delete els;\n  }\n\n  PosibErr<void> Config::read_in(IStream & in, ParmStr id) \n  {\n    String buf;\n    DataPair dp;\n    while (getdata_pair(in, dp, buf)) {\n      to_lower(dp.key);\n      Entry * entry = new Entry;\n      entry->key = dp.key;\n      entry->value = dp.value;\n      entry->file = id;\n      entry->line_num = dp.line_num;\n      RET_ON_ERR(set(entry, true));\n    }\n    return no_err;\n  }\n\n  PosibErr<void> Config::read_in_file(ParmStr file) {\n    FStream in;\n    RET_ON_ERR(in.open(file, \"r\"));\n    return read_in(in, file);\n  }\n\n  PosibErr<void> Config::read_in_string(ParmStr str, const char * what) {\n    StringIStream in(str);\n    return read_in(in, what);\n  }\n\n\n  PosibErr<bool> Config::read_in_settings(const Config * other)\n  {\n    if (settings_read_in_) return false;\n\n    bool was_committed = committed_;\n    set_committed_state(false);\n\n    if (other && other->settings_read_in_) {\n\n      assert(empty());\n      del(); // to clean up any notifiers and similar stuff\n      copy(*other);\n\n    } else {\n\n      if (other) merge(*other);\n\n      const char * env = getenv(\"ASPELL_CONF\");\n      if (env != 0) { \n        insert_point_ = &first_;\n        RET_ON_ERR(read_in_string(env, _(\"ASPELL_CONF env var\")));\n      }\n      \n      {\n      insert_point_ = &first_;\n      PosibErrBase pe = read_in_file(retrieve(\"per-conf-path\"));\n      if (pe.has_err() && !pe.has_err(cant_read_file)) return pe;\n      }\n      \n      {\n        insert_point_ = &first_;\n        PosibErrBase pe = read_in_file(retrieve(\"conf-path\"));\n        if (pe.has_err() && !pe.has_err(cant_read_file)) return pe;\n      }\n\n      if (was_committed)\n        RET_ON_ERR(commit_all());\n\n      settings_read_in_ = true;\n    }\n\n    return true;\n  }\n\n  PosibErr<void> Config::commit_all(Vector<int> * phs, const char * codeset)\n  {\n    committed_ = true;\n    others_ = first_;\n    first_ = 0;\n    insert_point_ = &first_;\n    Conv to_utf8;\n    if (codeset)\n      RET_ON_ERR(to_utf8.setup(*this, codeset, \"utf-8\", NormTo));\n    while (others_) {\n      *insert_point_ = others_;\n      others_ = others_->next;\n      (*insert_point_)->next = 0;\n      RET_ON_ERR_SET(commit(*insert_point_, codeset ? &to_utf8 : 0), int, place_holder);\n      if (phs && place_holder != -1 && (phs->empty() || phs->back() != place_holder))\n        phs->push_back(place_holder);\n      insert_point_ = &((*insert_point_)->next);\n    }\n    return no_err;\n  }\n\n  PosibErr<void> Config::set_committed_state(bool val) {\n    if (val && !committed_) {\n      RET_ON_ERR(commit_all());\n    } else if (!val && committed_) {\n      assert(empty());\n      committed_ = false;\n    }\n    return no_err;\n  }\n\n\n#ifdef ENABLE_WIN32_RELOCATABLE\n#  define HOME_DIR \"<prefix>\"\n#  define PERSONAL \"<lang>.pws\"\n#  define REPL     \"<lang>.prepl\"\n#else\n#  define HOME_DIR \"<$HOME|./>\"\n#  define PERSONAL \".aspell.<lang>.pws\"\n#  define REPL     \".aspell.<lang>.prepl\"\n#endif\n\n  static const KeyInfo config_keys[] = {\n    // the description should be under 50 chars\n    {\"actual-dict-dir\", KeyInfoString, \"<dict-dir^master>\", 0}\n    , {\"actual-lang\",     KeyInfoString, \"\", 0} \n    , {\"conf\",     KeyInfoString, \"aspell.conf\",\n       /* TRANSLATORS: The remaining strings in config.cpp should be kept\n          under 50 characters, begin with a lower case character and not\n          include any trailing punctuation marks. */\n       N_(\"main configuration file\")}\n    , {\"conf-dir\", KeyInfoString, CONF_DIR,\n       N_(\"location of main configuration file\")}\n    , {\"conf-path\",     KeyInfoString, \"<conf-dir/conf>\", 0}\n    , {\"data-dir\", KeyInfoString, DATA_DIR,\n       N_(\"location of language data files\")}\n    , {\"dict-alias\", KeyInfoList, \"\",\n       N_(\"create dictionary aliases\")}\n    , {\"dict-dir\", KeyInfoString, DICT_DIR,\n       N_(\"location of the main word list\")}\n    , {\"encoding\",   KeyInfoString, \"!encoding\",\n       N_(\"encoding to expect data to be in\"), KEYINFO_COMMON}\n    , {\"filter\",   KeyInfoList  , \"url\",\n       N_(\"add or removes a filter\"), KEYINFO_MAY_CHANGE}\n    , {\"filter-path\", KeyInfoList, DICT_DIR,\n       N_(\"path(s) aspell looks for filters\")}\n    //, {\"option-path\", KeyInfoList, DATA_DIR,\n    //   N_(\"path(s) aspell looks for options descriptions\")}\n    , {\"mode\",     KeyInfoString, \"url\",\n       N_(\"filter mode\"), KEYINFO_COMMON}\n    , {\"extra-dicts\", KeyInfoList, \"\",\n       N_(\"extra dictionaries to use\")}\n    , {\"home-dir\", KeyInfoString, HOME_DIR,\n       N_(\"location for personal files\")}\n    , {\"ignore\",   KeyInfoInt   , \"1\",\n       N_(\"ignore words <= n chars\"), KEYINFO_MAY_CHANGE}\n    , {\"ignore-accents\" , KeyInfoBool, \"false\",\n       /* TRANSLATORS: It is OK if this is longer than 50 chars */\n       N_(\"ignore accents when checking words -- CURRENTLY IGNORED\"), KEYINFO_MAY_CHANGE | KEYINFO_HIDDEN}\n    , {\"ignore-case\", KeyInfoBool  , \"false\",\n       N_(\"ignore case when checking words\"), KEYINFO_MAY_CHANGE}\n    , {\"ignore-repl\", KeyInfoBool  , \"false\",\n       N_(\"ignore commands to store replacement pairs\"), KEYINFO_MAY_CHANGE}\n    , {\"jargon\",     KeyInfoString, \"\",\n       N_(\"extra information for the word list\"), KEYINFO_HIDDEN}\n    , {\"keyboard\", KeyInfoString, \"standard\",\n       N_(\"keyboard definition to use for typo analysis\")}\n    , {\"lang\", KeyInfoString, \"<language-tag>\",\n       N_(\"language code\"), KEYINFO_COMMON}\n    , {\"language-tag\", KeyInfoString, \"!lang\",\n       N_(\"deprecated, use lang instead\"), KEYINFO_HIDDEN}\n    , {\"local-data-dir\", KeyInfoString, \"<actual-dict-dir>\",\n       N_(\"location of local language data files\")     }\n    , {\"master\",        KeyInfoString, \"<lang>\",\n       N_(\"base name of the main dictionary to use\"), KEYINFO_COMMON}\n    , {\"master-flags\",  KeyInfoString, \"\", 0}\n    , {\"master-path\",   KeyInfoString, \"<dict-dir/master>\",   0}\n    , {\"module\",        KeyInfoString, \"default\",\n       N_(\"set module name\"), KEYINFO_HIDDEN}\n    , {\"module-search-order\", KeyInfoList, \"\",\n       N_(\"search order for modules\"), KEYINFO_HIDDEN}\n    , {\"normalize\", KeyInfoBool, \"true\",\n       N_(\"enable Unicode normalization\")}\n    , {\"norm-required\", KeyInfoBool, \"false\",\n       N_(\"Unicode normalization required for current lang\")}\n    , {\"norm-form\", KeyInfoString, \"nfc\",\n       /* TRANSLATORS: the values after the ':' are literal\n          values and should not be translated. */\n       N_(\"Unicode normalization form: none, nfd, nfc, comp\")}\n    , {\"norm-strict\", KeyInfoBool, \"false\",\n       N_(\"avoid lossy conversions when normalization\")}\n    , {\"per-conf\", KeyInfoString, \".aspell.conf\",\n       N_(\"personal configuration file\")}\n    , {\"per-conf-path\", KeyInfoString, \"<home-dir/per-conf>\", 0}\n    , {\"personal\", KeyInfoString, PERSONAL,\n       N_(\"personal dictionary file name\")}\n    , {\"personal-path\", KeyInfoString, \"<home-dir/personal>\", 0}\n    , {\"prefix\",   KeyInfoString, PREFIX,\n       N_(\"prefix directory\")}\n    , {\"repl\",     KeyInfoString, REPL,\n       N_(\"replacements list file name\") }\n    , {\"repl-path\",     KeyInfoString, \"<home-dir/repl>\",     0}\n    , {\"run-together\",        KeyInfoBool,  \"false\",\n       N_(\"consider run-together words legal\"), KEYINFO_MAY_CHANGE}\n    , {\"run-together-limit\",  KeyInfoInt,   \"2\",\n       N_(\"maximum number that can be strung together\"), KEYINFO_MAY_CHANGE}\n    , {\"run-together-min\",    KeyInfoInt,   \"3\",\n       N_(\"minimal length of interior words\"), KEYINFO_MAY_CHANGE}\n    , {\"save-repl\", KeyInfoBool  , \"true\",\n       N_(\"save replacement pairs on save all\")}\n    , {\"set-prefix\", KeyInfoBool, \"true\",\n       N_(\"set the prefix based on executable location\")}\n    , {\"size\",          KeyInfoString, \"+60\",\n       N_(\"size of the word list\")}\n    , {\"spelling\",   KeyInfoString, \"\",\n       N_(\"no longer used\"), KEYINFO_HIDDEN}\n    , {\"sug-mode\",   KeyInfoString, \"normal\",\n       N_(\"suggestion mode\"), KEYINFO_MAY_CHANGE | KEYINFO_COMMON}\n    , {\"sug-typo-analysis\", KeyInfoBool, \"true\",\n       /* TRANSLATORS: \"sug-mode\" is a literal value and should not be\n          translated. */\n       N_(\"use typo analysis, override sug-mode default\")}\n    , {\"sug-repl-table\", KeyInfoBool, \"true\",\n       N_(\"use replacement tables, override sug-mode default\")}\n    , {\"sug-split-char\", KeyInfoList, \"\\\\ :-\",\n       N_(\"characters to insert when a word is split\"), KEYINFO_UTF8}\n    , {\"use-other-dicts\", KeyInfoBool, \"true\",\n       N_(\"use personal, replacement & session dictionaries\")}\n    , {\"variety\", KeyInfoList, \"\",\n       N_(\"extra information for the word list\")}\n    , {\"word-list-path\", KeyInfoList, DATA_DIR,\n       N_(\"search path for word list information files\"), KEYINFO_HIDDEN}\n    , {\"warn\", KeyInfoBool, \"true\",\n       N_(\"enable warnings\")}\n    \n    \n    //\n    // These options are generally used when creating dictionaries\n    // and may also be specified in the language data file\n    //\n\n    , {\"affix-char\",          KeyInfoString, \"/\", // FIXME: Implement\n       /* TRANSLATORS: It is OK if this is longer than 50 chars */\n       N_(\"indicator for affix flags in word lists -- CURRENTLY IGNORED\"), KEYINFO_UTF8 | KEYINFO_HIDDEN}\n    , {\"affix-compress\", KeyInfoBool, \"false\",\n       N_(\"use affix compression when creating dictionaries\")}\n    , {\"clean-affixes\", KeyInfoBool, \"true\",\n       N_(\"remove invalid affix flags\")}\n    , {\"clean-words\", KeyInfoBool, \"false\",\n       N_(\"attempts to clean words so that they are valid\")}\n    , {\"invisible-soundslike\", KeyInfoBool, \"false\",\n       N_(\"compute soundslike on demand rather than storing\")} \n    , {\"partially-expand\",  KeyInfoBool, \"false\",\n       N_(\"partially expand affixes for better suggestions\")}\n    , {\"skip-invalid-words\",  KeyInfoBool, \"true\",\n       N_(\"skip invalid words\")}\n    , {\"validate-affixes\", KeyInfoBool, \"true\",\n       N_(\"check if affix flags are valid\")}\n    , {\"validate-words\", KeyInfoBool, \"true\",\n       N_(\"check if words are valid\")}\n    \n    //\n    // These options are specific to the \"aspell\" utility.  They are\n    // here so that they can be specified in configuration files.\n    //\n    , {\"backup\",  KeyInfoBool, \"true\",\n       N_(\"create a backup file by appending \\\".bak\\\"\")}\n    , {\"byte-offsets\", KeyInfoBool, \"false\",\n       N_(\"use byte offsets instead of character offsets\")}\n    , {\"guess\", KeyInfoBool, \"false\",\n       N_(\"create missing root/affix combinations\"), KEYINFO_MAY_CHANGE}\n    , {\"keymapping\", KeyInfoString, \"aspell\",\n       N_(\"keymapping for check mode: \\\"aspell\\\" or \\\"ispell\\\"\")}\n    , {\"reverse\", KeyInfoBool, \"false\",\n       N_(\"reverse the order of the suggest list\")}\n    , {\"suggest\", KeyInfoBool, \"true\",\n       N_(\"suggest possible replacements\"), KEYINFO_MAY_CHANGE}\n    , {\"time\"   , KeyInfoBool, \"false\",\n       N_(\"time load time and suggest time in pipe mode\"), KEYINFO_MAY_CHANGE}\n    };\n\n  const KeyInfo * config_impl_keys_begin = config_keys;\n  const KeyInfo * config_impl_keys_end   \n  = config_keys + sizeof(config_keys)/sizeof(KeyInfo);\n\n  Config * new_basic_config() { \n    aspell_gettext_init();\n    return new Config(\"aspell\",\n\t\t      config_impl_keys_begin,\n\t\t      config_impl_keys_end);\n  }\n  \n}\n\n", "// This file is part of The New Aspell\n// Copyright (C) 2001 by Kevin Atkinson under the GNU LGPL license\n// version 2.0 or 2.1.  You should have received a copy of the LGPL\n// license along with this library if you did not you can find\n// it at http://www.gnu.org/.\n\n#include \"settings.h\"\n\n//#include \"iostream.hpp\"\n\n#include \"config.hpp\"\n#include \"file_util.hpp\"\n#include \"fstream.hpp\"\n#include \"errors.hpp\"\n#include \"string_list.hpp\"\n\n#ifdef USE_FILE_LOCKS\n#  include <fcntl.h>\n#  include <unistd.h>\n#  include <sys/types.h>\n#endif\n\n#include <stdio.h>\n#include <sys/stat.h>\n#include <dirent.h>\n\n#ifdef WIN32\n\n#  include <io.h>\n#  define ACCESS _access\n#  include <windows.h>\n#  include <winbase.h>\n\n#else\n\n#  include <unistd.h>\n#  define ACCESS access\n\n#endif\n\n\nnamespace acommon {\n\n  // Return false if file is already an absolute path and does not need\n  // a directory prepended.\n  bool need_dir(ParmString file) {\n    if (file[0] == '/' || (file[0] == '.' && file[1] == '/')\n#ifdef WIN32\n        || (asc_isalpha(file[0]) && file[1] == ':')\n        || file[0] == '\\\\' || (file[0] == '.' && file[1] == '\\\\')\n#endif\n      )\n      return false;\n    else\n      return true;\n  }\n\n  String add_possible_dir(ParmString dir, ParmString file) {\n    if (need_dir(file)) {\n      String path;\n      path += dir;\n      path += '/';\n      path += file;\n      return path;\n    } else {\n      return file;\n    }\n  }\n\n  String figure_out_dir(ParmString dir, ParmString file)\n  {\n    String temp;\n    int s = file.size() - 1;\n    while (s != -1 && file[s] != '/') --s;\n    if (need_dir(file)) {\n      temp += dir;\n      temp += '/';\n    }\n    if (s != -1) {\n      temp.append(file, s);\n    }\n    return temp;\n  }\n\n  time_t get_modification_time(FStream & f) {\n    struct stat s;\n    fstat(f.file_no(), &s);\n    return s.st_mtime;\n  }\n\n  PosibErr<void> open_file_readlock(FStream & in, ParmString file) {\n    RET_ON_ERR(in.open(file, \"r\"));\n#ifdef USE_FILE_LOCKS\n    int fd = in.file_no();\n    struct flock fl;\n    fl.l_type   = F_RDLCK;\n    fl.l_whence = SEEK_SET;\n    fl.l_start  = 0;\n    fl.l_len    = 0;\n    fcntl(fd, F_SETLKW, &fl); // ignore errors\n#endif\n    return no_err;\n  }\n\n  PosibErr<bool> open_file_writelock(FStream & inout, ParmString file) {\n    typedef PosibErr<bool> Ret;\n#ifndef USE_FILE_LOCKS\n    bool exists = file_exists(file);\n#endif\n    {\n     Ret pe = inout.open(file, \"r+\");\n     if (pe.get_err() != 0)\n       pe = inout.open(file, \"w+\");\n     if (pe.has_err())\n       return pe;\n    }\n#ifdef USE_FILE_LOCKS\n    int fd = inout.file_no();\n    struct flock fl;\n    fl.l_type   = F_WRLCK;\n    fl.l_whence = SEEK_SET;\n    fl.l_start  = 0;\n    fl.l_len    = 0;\n    fcntl(fd, F_SETLKW, &fl); // ignore errors\n    struct stat s;\n    fstat(fd, &s);\n    return s.st_size != 0;\n#else\n    return exists;\n#endif\n  }\n\n  void truncate_file(FStream & f, ParmString name) {\n#ifdef USE_FILE_LOCKS\n    f.restart();\n    ftruncate(f.file_no(),0);\n#else\n    f.close();\n    f.open(name, \"w+\");\n#endif\n  }\n\n  bool remove_file(ParmString name) {\n    return remove(name) == 0;\n  }\n\n  bool file_exists(ParmString name) {\n    return ACCESS(name, F_OK) == 0;\n  }\n\n  bool rename_file(ParmString orig_name, ParmString new_name)\n  {\n    remove(new_name);\n    return rename(orig_name, new_name) == 0;\n  }\n \n  const char * get_file_name(const char * path) {\n    const char * file_name;\n    if (path != 0) {\n      file_name = strrchr(path,'/');\n      if (file_name == 0)\n        file_name = path;\n    } else {\n      file_name = 0;\n    }\n    return file_name;\n  }\n\n  unsigned find_file(const Config * config, const char * option, String & filename)\n  {\n    StringList sl;\n    config->retrieve_list(option, &sl);\n    return find_file(sl, filename);\n  }\n\n  unsigned find_file(const StringList & sl, String & filename)\n  {\n    StringListEnumeration els = sl.elements_obj();\n    const char * dir;\n    String path;\n    while ( (dir = els.next()) != 0 ) \n    {\n      path = dir;\n      if (path.empty()) continue;\n      if (path.back() != '/') path += '/';\n      unsigned dir_len = path.size();\n      path += filename;\n      if (file_exists(path)) {\n        filename.swap(path);\n        return dir_len;\n      }\n    }\n    return 0;\n  }\n\n  PathBrowser::PathBrowser(const StringList & sl, const char * suf)\n    : dir_handle(0)\n  {\n    els = sl.elements();\n    suffix = suf;\n  }\n\n  PathBrowser::~PathBrowser() \n  {\n    delete els;\n    if (dir_handle) closedir((DIR *)dir_handle);\n  }\n\n  const char * PathBrowser::next()\n  {\n    if (dir_handle == 0) goto get_next_dir;\n  begin: {\n      struct dirent * entry = readdir((DIR *)dir_handle);\n      if (entry == 0) goto try_again;\n      const char * name = entry->d_name;\n      unsigned name_len = strlen(name);\n      if (suffix.size() != 0 && \n          !(name_len > suffix.size() \n            && memcmp(name + name_len - suffix.size(), suffix.str(), suffix.size()) == 0))\n        goto begin;\n      path = dir;\n      if (path.back() != '/') path += '/';\n      path += name;\n    }\n    return path.str();\n  try_again:\n    if (dir_handle) closedir((DIR *)dir_handle);\n    dir_handle = 0;\n  get_next_dir:\n    dir = els->next();\n    if (!dir) return 0;\n    dir_handle = opendir(dir);\n    if (dir_handle == 0) goto try_again;\n    goto begin;\n  }\n}\n", "// This file is part of The New Aspell\n// Copyright (C) 2001 by Kevin Atkinson under the GNU LGPL license\n// version 2.0 or 2.1.  You should have received a copy of the LGPL\n// license along with this library if you did not you can find\n// it at http://www.gnu.org/.\n\n#include <string.h>\n\n#include \"getdata.hpp\"\n#include \"string.hpp\"\n#include \"asc_ctype.hpp\"\n\n#include \"iostream.hpp\"\n\nnamespace acommon {\n  unsigned int linenumber = 0 ;\n\n  bool getdata_pair(IStream & in, DataPair & d, String & buf)\n  {\n    char * p;\n\n    // get first non blank line and count all read ones\n    do {\n      buf.clear();\n      buf.append('\\0'); // to avoid some special cases\n      if (!in.append_line(buf)) return false;\n      d.line_num++;\n      p = buf.mstr() + 1;\n      while (*p == ' ' || *p == '\\t') ++p;\n    } while (*p == '#' || *p == '\\0');\n\n    // get key\n    d.key.str = p;\n    while (*p != '\\0' &&\n           ((*p != ' ' && *p != '\\t' && *p != '#') || *(p-1) == '\\\\')) ++p;\n    d.key.size = p - d.key.str;\n\n    // figure out if there is a value and add terminate key\n    d.value.str = p; // in case there is no value\n    d.value.size = 0;\n    if (*p == '#' || *p == '\\0') {*p = '\\0'; return true;}\n    *p = '\\0';\n\n    // skip any whitespace\n    ++p;\n    while (*p == ' ' || *p == '\\t') ++p;\n    if (*p == '\\0' || *p == '#') {return true;}\n\n    // get value\n    d.value.str = p;\n    while (*p != '\\0' && (*p != '#' || *(p-1) == '\\\\')) ++p;\n    \n    // remove trailing white space and terminate value\n    --p;\n    while (*p == ' ' || *p == '\\t') --p;\n    if (*p == '\\\\' && *(p + 1) != '\\0') ++p;\n    ++p;\n    d.value.size = p - d.value.str;\n    *p = '\\0';\n\n    return true;\n  }\n\n  char * unescape(char * dest, const char * src)\n  {\n    while (*src) {\n      if (*src == '\\\\' && src[1]) {\n\t++src;\n\tswitch (*src) {\n\tcase 'n': *dest = '\\n'; break;\n\tcase 'r': *dest = '\\r'; break;\n\tcase 't': *dest = '\\t'; break;\n\tcase 'f': *dest = '\\f'; break;\n\tcase 'v': *dest = '\\v'; break;\n\tdefault: *dest = *src;\n\t}\n      } else {\n\t*dest = *src;\n      }\n      ++src;\n      ++dest;\n    }\n    *dest = '\\0';\n    return dest;\n  }\n\n  bool escape(char * dest, const char * src, size_t limit, const char * others)\n  {\n    const char * begin = src;\n    const char * end = dest + limit;\n    if (asc_isspace(*src)) {\n      if (dest == end) return false;\n      *dest++ = '\\\\';\n      if (dest == end) return false;\n      *dest++ = *src++;\n    }\n    while (*src) {\n      if (dest == end) return false;\n      switch (*src) {\n      case '\\n': *dest++ = '\\\\'; *dest = 'n'; break;\n      case '\\r': *dest++ = '\\\\'; *dest = 'r'; break;\n      case '\\t': *dest++ = '\\\\'; *dest = 't'; break;\n      case '\\f': *dest++ = '\\\\'; *dest = 'f'; break;\n      case '\\v': *dest++ = '\\\\'; *dest = 'v'; break;\n      case '\\\\': *dest++ = '\\\\'; *dest = '\\\\'; break;\n      case '#' : *dest++ = '\\\\'; *dest = '#'; break;\n      default:\n\tif (others && strchr(others, *src)) *dest++ = '\\\\';\n\t*dest = *src;\n      }\n      ++src;\n      ++dest;\n    }\n    if (src > begin + 1 && asc_isspace(src[-1])) {\n      --dest;\n      *dest++ = '\\\\';\n      if (dest == end) return false;\n      *dest++ = src[-1];\n    }\n    *dest = '\\0';\n    return true;\n  }\n\n  void to_lower(char * str)\n  {\n    for (; *str; str++) *str = asc_tolower(*str);\n  }\n\n  void to_lower(String & res, const char * str)\n  {\n    for (; *str; str++) res += asc_tolower(*str);\n  }\n\n  bool split(DataPair & d)\n  {\n    char * p   = d.value;\n    char * end = p + d.value.size;\n    d.key.str = p;\n    while (p != end) {\n      ++p;\n      if ((*p == ' ' || *p == '\\t') && *(p-1) != '\\\\') break;\n    }\n    d.key.size = p - d.key.str;\n    *p = 0;\n    if (p != end) {\n      ++p;\n      while (p != end && (*p == ' ' || *p == '\\t')) ++p;\n    }\n    d.value.str = p;\n    d.value.size = end - p;\n    return d.key.size != 0;\n  }\n\n  void init(ParmString str, DataPair & d, String & buf)\n  {\n    const char * s = str;\n    while (*s == ' ' || *s == '\\t') ++s;\n    size_t l = str.size() - (s - str);\n    buf.assign(s, l);\n    d.value.str  = buf.mstr();\n    d.value.size = l;\n  }\n\n  bool getline(IStream & in, DataPair & d, String & buf)\n  {\n    if (!in.getline(buf)) return false;\n    d.value.str  = buf.mstr();\n    d.value.size = buf.size();\n    return true;\n  }\n\n  char * get_nb_line(IStream & in, String & buf)\n  {\n    char * p;\n    // get first non blank line\n    do {\n      if (!in.getline(buf)) return 0;\n      p = buf.mstr();\n      while (*p == ' ' || *p == '\\t') ++p;\n    } while (*p == '#' || *p == '\\0');\n    return p;\n  }\n\n  void remove_comments(String & buf)\n  {\n    char * p = buf.mstr();\n    char * b = p;\n    while (*p && *p != '#') ++p;\n    if (*p == '#') {--p; while (p >= b && asc_isspace(*p)) --p; ++p;}\n    buf.resize(p - b);\n  }\n\n}\n"], "buggy_code_start_loc": [766, 183, 67], "buggy_code_end_loc": [767, 183, 68], "fixing_code_start_loc": [766, 184, 67], "fixing_code_end_loc": [767, 185, 68], "type": "CWE-125", "message": "libaspell.a in GNU Aspell before 0.60.8 has a stack-based buffer over-read in acommon::unescape in common/getdata.cpp via an isolated \\ character.", "other": {"cve": {"id": "CVE-2019-17544", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-14T02:15:10.953", "lastModified": "2021-08-02T00:15:08.537", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "libaspell.a in GNU Aspell before 0.60.8 has a stack-based buffer over-read in acommon::unescape in common/getdata.cpp via an isolated \\ character."}, {"lang": "es", "value": "La biblioteca libaspell.a en GNU Aspell versiones anteriores a 0.60.8, presenta una lectura excesiva del b\u00fafer en la regi\u00f3n stack de la memoria en la funci\u00f3n acommon::unescape en el archivo common/getdata.cpp por medio de un car\u00e1cter \\ aislado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnu:aspell:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.60.8", "matchCriteriaId": "641C572A-E8C6-44DB-ADEA-BD5B59E3F06F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=16109", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/GNUAspell/aspell/commit/80fa26c74279fced8d778351cff19d1d8f44fe4e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/GNUAspell/aspell/compare/rel-0.60.7...rel-0.60.8", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00027.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2021/07/msg00021.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4155-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4155-2/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2021/dsa-4948", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/GNUAspell/aspell/commit/80fa26c74279fced8d778351cff19d1d8f44fe4e"}}