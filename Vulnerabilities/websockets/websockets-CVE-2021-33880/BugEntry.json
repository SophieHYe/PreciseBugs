{"buggy_code": ["Changelog\n---------\n\n.. currentmodule:: websockets\n\n.. _backwards-compatibility policy:\n\nBackwards-compatibility policy\n..............................\n\n``websockets`` is intended for production use. Therefore, stability is a goal.\n\n``websockets`` also aims at providing the best API for WebSocket in Python.\n\nWhile we value stability, we value progress more. When an improvement requires\nchanging a public API, we make the change and document it in this changelog.\n\nWhen possible with reasonable effort, we preserve backwards-compatibility for\nfive years after the release that introduced the change.\n\nWhen a release contains backwards-incompatible API changes, the major version\nis increased, else the minor version is increased. Patch versions are only for\nfixing regressions shortly after a release.\n\nOnly documented APIs are public. Undocumented APIs are considered private.\nThey may change at any time.\n\n9.1\n...\n\n*In development*\n\n9.0.2\n.....\n\n*May 15, 2021*\n\n* Restored compatibility of ``python -m websockets`` with Python < 3.9.\n\n* Restored compatibility with mypy.\n\n9.0.1\n.....\n\n*May 2, 2021*\n\n* Fixed issues with the packaging of the 9.0 release.\n\n9.0\n...\n\n*May 1, 2021*\n\n.. note::\n\n    **Version 9.0 moves or deprecates several APIs.**\n\n    Aliases provide backwards compatibility for all previously public APIs.\n\n    * :class:`~datastructures.Headers` and\n      :exc:`~datastructures.MultipleValuesError` were moved from\n      ``websockets.http`` to :mod:`websockets.datastructures`. If you're using\n      them, you should adjust the import path.\n\n    * The ``client``, ``server``, ``protocol``, and ``auth`` modules were\n      moved from the ``websockets`` package to ``websockets.legacy``\n      sub-package, as part of an upcoming refactoring. Despite the name,\n      they're still fully supported. The refactoring should be a transparent\n      upgrade for most uses when it's available. The legacy implementation\n      will be preserved according to the `backwards-compatibility policy`_.\n\n    * The ``framing``, ``handshake``, ``headers``, ``http``, and ``uri``\n      modules in the ``websockets`` package are deprecated. These modules\n      provided low-level APIs for reuse by other WebSocket implementations,\n      but that never happened. Keeping these APIs public makes it more\n      difficult to improve websockets for no actual benefit.\n\n.. note::\n\n    **Version 9.0 may require changes if you use static code analysis tools.**\n\n    Convenience imports from the ``websockets`` module are performed lazily.\n    While this is supported by Python, static code analysis tools such as mypy\n    are unable to understand the behavior.\n\n    If you depend on such tools, use the real import path, which can be found\n    in the API documentation::\n\n        from websockets.client import connect\n        from websockets.server import serve\n\n* Added compatibility with Python 3.9.\n\n* Added support for IRIs in addition to URIs.\n\n* Added close codes 1012, 1013, and 1014.\n\n* Raised an error when passing a :class:`dict` to\n  :meth:`~legacy.protocol.WebSocketCommonProtocol.send`.\n\n* Fixed sending fragmented, compressed messages.\n\n* Fixed ``Host`` header sent when connecting to an IPv6 address.\n\n* Fixed creating a client or a server with an existing Unix socket.\n\n* Aligned maximum cookie size with popular web browsers.\n\n* Ensured cancellation always propagates, even on Python versions where\n  :exc:`~asyncio.CancelledError` inherits :exc:`Exception`.\n\n* Improved error reporting.\n\n\n8.1\n...\n\n*November 1, 2019*\n\n* Added compatibility with Python 3.8.\n\n8.0.2\n.....\n\n*July 31, 2019*\n\n* Restored the ability to pass a socket with the ``sock`` parameter of\n  :func:`~legacy.server.serve`.\n\n* Removed an incorrect assertion when a connection drops.\n\n8.0.1\n.....\n\n*July 21, 2019*\n\n* Restored the ability to import ``WebSocketProtocolError`` from\n  ``websockets``.\n\n8.0\n...\n\n*July 7, 2019*\n\n.. warning::\n\n    **Version 8.0 drops compatibility with Python 3.4 and 3.5.**\n\n.. note::\n\n    **Version 8.0 expects** ``process_request`` **to be a coroutine.**\n\n    Previously, it could be a function or a coroutine.\n\n    If you're passing a ``process_request`` argument to\n    :func:`~legacy.server.serve`\n    or :class:`~legacy.server.WebSocketServerProtocol`, or if you're overriding\n    :meth:`~legacy.server.WebSocketServerProtocol.process_request` in a subclass,\n    define it with ``async def`` instead of ``def``.\n\n    For backwards compatibility, functions are still mostly supported, but\n    mixing functions and coroutines won't work in some inheritance scenarios.\n\n.. note::\n\n    **Version 8.0 changes the behavior of the** ``max_queue`` **parameter.**\n\n    If you were setting ``max_queue=0`` to make the queue of incoming messages\n    unbounded, change it to ``max_queue=None``.\n\n.. note::\n\n    **Version 8.0 deprecates the** ``host`` **,** ``port`` **, and** ``secure``\n    **attributes of** :class:`~legacy.protocol.WebSocketCommonProtocol`.\n\n    Use :attr:`~legacy.protocol.WebSocketCommonProtocol.local_address` in\n    servers and\n    :attr:`~legacy.protocol.WebSocketCommonProtocol.remote_address` in clients\n    instead of ``host`` and ``port``.\n\n.. note::\n\n    **Version 8.0 renames the** ``WebSocketProtocolError`` **exception**\n    to :exc:`~exceptions.ProtocolError` **.**\n\n    A ``WebSocketProtocolError`` alias provides backwards compatibility.\n\n.. note::\n\n    **Version 8.0 adds the reason phrase to the return type of the low-level\n    API** ``read_response()`` **.**\n\nAlso:\n\n* :meth:`~legacy.protocol.WebSocketCommonProtocol.send`,\n  :meth:`~legacy.protocol.WebSocketCommonProtocol.ping`, and\n  :meth:`~legacy.protocol.WebSocketCommonProtocol.pong` support bytes-like\n  types :class:`bytearray` and :class:`memoryview` in addition to\n  :class:`bytes`.\n\n* Added :exc:`~exceptions.ConnectionClosedOK` and\n  :exc:`~exceptions.ConnectionClosedError` subclasses of\n  :exc:`~exceptions.ConnectionClosed` to tell apart normal connection\n  termination from errors.\n\n* Added :func:`~legacy.auth.basic_auth_protocol_factory` to enforce HTTP\n  Basic Auth on the server side.\n\n* :func:`~legacy.client.connect` handles redirects from the server during the\n  handshake.\n\n* :func:`~legacy.client.connect` supports overriding ``host`` and ``port``.\n\n* Added :func:`~legacy.client.unix_connect` for connecting to Unix sockets.\n\n* Improved support for sending fragmented messages by accepting asynchronous\n  iterators in :meth:`~legacy.protocol.WebSocketCommonProtocol.send`.\n\n* Prevented spurious log messages about :exc:`~exceptions.ConnectionClosed`\n  exceptions in keepalive ping task. If you were using ``ping_timeout=None``\n  as a workaround, you can remove it.\n\n* Changed :meth:`WebSocketServer.close()\n  <legacy.server.WebSocketServer.close>` to perform a proper closing handshake\n  instead of failing the connection.\n\n* Avoided a crash when a ``extra_headers`` callable returns ``None``.\n\n* Improved error messages when HTTP parsing fails.\n\n* Enabled readline in the interactive client.\n\n* Added type hints (:pep:`484`).\n\n* Added a FAQ to the documentation.\n\n* Added documentation for extensions.\n\n* Documented how to optimize memory usage.\n\n* Improved API documentation.\n\n7.0\n...\n\n*November 1, 2018*\n\n.. warning::\n\n    ``websockets`` **now sends Ping frames at regular intervals and closes the\n    connection if it doesn't receive a matching Pong frame.**\n\n    See :class:`~legacy.protocol.WebSocketCommonProtocol` for details.\n\n.. warning::\n\n    **Version 7.0 changes how a server terminates connections when it's closed\n    with** :meth:`WebSocketServer.close()\n    <legacy.server.WebSocketServer.close>` **.**\n\n    Previously, connections handlers were canceled. Now, connections are\n    closed with close code 1001 (going away). From the perspective of the\n    connection handler, this is the same as if the remote endpoint was\n    disconnecting. This removes the need to prepare for\n    :exc:`~asyncio.CancelledError` in connection handlers.\n\n    You can restore the previous behavior by adding the following line at the\n    beginning of connection handlers::\n\n        def handler(websocket, path):\n            closed = asyncio.ensure_future(websocket.wait_closed())\n            closed.add_done_callback(lambda task: task.cancel())\n\n.. note::\n\n    **Version 7.0 renames the** ``timeout`` **argument of**\n    :func:`~legacy.server.serve` **and** :func:`~legacy.client.connect` **to**\n    ``close_timeout`` **.**\n\n    This prevents confusion with ``ping_timeout``.\n\n    For backwards compatibility, ``timeout`` is still supported.\n\n.. note::\n\n    **Version 7.0 changes how a**\n    :meth:`~legacy.protocol.WebSocketCommonProtocol.ping` **that hasn't\n    received a pong yet behaves when the connection is closed.**\n\n    The ping \u2014 as in ``ping = await websocket.ping()`` \u2014 used to be canceled\n    when the connection is closed, so that ``await ping`` raised\n    :exc:`~asyncio.CancelledError`. Now ``await ping`` raises\n    :exc:`~exceptions.ConnectionClosed` like other public APIs.\n\n.. note::\n\n    **Version 7.0 raises a** :exc:`RuntimeError` **exception if two coroutines\n    call** :meth:`~legacy.protocol.WebSocketCommonProtocol.recv`\n    **concurrently.**\n\n    Concurrent calls lead to non-deterministic behavior because there are no\n    guarantees about which coroutine will receive which message.\n\nAlso:\n\n* Added ``process_request`` and ``select_subprotocol`` arguments to\n  :func:`~legacy.server.serve` and\n  :class:`~legacy.server.WebSocketServerProtocol` to customize\n  :meth:`~legacy.server.WebSocketServerProtocol.process_request` and\n  :meth:`~legacy.server.WebSocketServerProtocol.select_subprotocol` without\n  subclassing :class:`~legacy.server.WebSocketServerProtocol`.\n\n* Added support for sending fragmented messages.\n\n* Added the :meth:`~legacy.protocol.WebSocketCommonProtocol.wait_closed`\n  method to protocols.\n\n* Added an interactive client: ``python -m websockets <uri>``.\n\n* Changed the ``origins`` argument to represent the lack of an origin with\n  ``None`` rather than ``''``.\n\n* Fixed a data loss bug in\n  :meth:`~legacy.protocol.WebSocketCommonProtocol.recv`:\n  canceling it at the wrong time could result in messages being dropped.\n\n* Improved handling of multiple HTTP headers with the same name.\n\n* Improved error messages when a required HTTP header is missing.\n\n6.0\n...\n\n*July 16, 2018*\n\n.. warning::\n\n    **Version 6.0 introduces the** :class:`~datastructures.Headers` **class\n    for managing HTTP headers and changes several public APIs:**\n\n    * :meth:`~legacy.server.WebSocketServerProtocol.process_request` now\n      receives a :class:`~datastructures.Headers` instead of a\n      ``http.client.HTTPMessage`` in the ``request_headers`` argument.\n\n    * The ``request_headers`` and ``response_headers`` attributes of\n      :class:`~legacy.protocol.WebSocketCommonProtocol` are\n      :class:`~datastructures.Headers` instead of ``http.client.HTTPMessage``.\n\n    * The ``raw_request_headers`` and ``raw_response_headers`` attributes of\n      :class:`~legacy.protocol.WebSocketCommonProtocol` are removed. Use\n      :meth:`~datastructures.Headers.raw_items` instead.\n\n    * Functions defined in the ``handshake`` module now receive\n      :class:`~datastructures.Headers` in argument instead of ``get_header``\n      or ``set_header`` functions. This affects libraries that rely on\n      low-level APIs.\n\n    * Functions defined in the ``http`` module now return HTTP headers as\n      :class:`~datastructures.Headers` instead of lists of ``(name, value)``\n      pairs.\n\n    Since :class:`~datastructures.Headers` and ``http.client.HTTPMessage``\n    provide similar APIs, this change won't affect most of the code dealing\n    with HTTP headers.\n\n\nAlso:\n\n* Added compatibility with Python 3.7.\n\n5.0.1\n.....\n\n*May 24, 2018*\n\n* Fixed a regression in 5.0 that broke some invocations of\n  :func:`~legacy.server.serve` and :func:`~legacy.client.connect`.\n\n5.0\n...\n\n*May 22, 2018*\n\n.. note::\n\n    **Version 5.0 fixes a security issue introduced in version 4.0.**\n\n    Version 4.0 was vulnerable to denial of service by memory exhaustion\n    because it didn't enforce ``max_size`` when decompressing compressed\n    messages (`CVE-2018-1000518`_).\n\n    .. _CVE-2018-1000518: https://nvd.nist.gov/vuln/detail/CVE-2018-1000518\n\n.. note::\n\n    **Version 5.0 adds a** ``user_info`` **field to the return value of**\n    :func:`~uri.parse_uri` **and** :class:`~uri.WebSocketURI` **.**\n\n    If you're unpacking :class:`~uri.WebSocketURI` into four variables, adjust\n    your code to account for that fifth field.\n\nAlso:\n\n* :func:`~legacy.client.connect` performs HTTP Basic Auth when the URI contains\n  credentials.\n\n* Iterating on incoming messages no longer raises an exception when the\n  connection terminates with close code 1001 (going away).\n\n* A plain HTTP request now receives a 426 Upgrade Required response and\n  doesn't log a stack trace.\n\n* :func:`~legacy.server.unix_serve` can be used as an asynchronous context\n  manager on Python \u2265 3.5.1.\n\n* Added the :attr:`~legacy.protocol.WebSocketCommonProtocol.closed` property\n  to protocols.\n\n* If a :meth:`~legacy.protocol.WebSocketCommonProtocol.ping` doesn't receive a\n  pong, it's canceled when the connection is closed.\n\n* Reported the cause of :exc:`~exceptions.ConnectionClosed` exceptions.\n\n* Added new examples in the documentation.\n\n* Updated documentation with new features from Python 3.6.\n\n* Improved several other sections of the documentation.\n\n* Fixed missing close code, which caused :exc:`TypeError` on connection close.\n\n* Fixed a race condition in the closing handshake that raised\n  :exc:`~exceptions.InvalidState`.\n\n* Stopped logging stack traces when the TCP connection dies prematurely.\n\n* Prevented writing to a closing TCP connection during unclean shutdowns.\n\n* Made connection termination more robust to network congestion.\n\n* Prevented processing of incoming frames after failing the connection.\n\n4.0.1\n.....\n\n*November 2, 2017*\n\n* Fixed issues with the packaging of the 4.0 release.\n\n4.0\n...\n\n*November 2, 2017*\n\n.. warning::\n\n    **Version 4.0 drops compatibility with Python 3.3.**\n\n.. note::\n\n    **Version 4.0 enables compression with the permessage-deflate extension.**\n\n    In August 2017, Firefox and Chrome support it, but not Safari and IE.\n\n    Compression should improve performance but it increases RAM and CPU use.\n\n    If you want to disable compression, add ``compression=None`` when calling\n    :func:`~legacy.server.serve` or :func:`~legacy.client.connect`.\n\n.. note::\n\n    **Version 4.0 removes the** ``state_name`` **attribute of protocols.**\n\n    Use ``protocol.state.name`` instead of ``protocol.state_name``.\n\nAlso:\n\n* :class:`~legacy.protocol.WebSocketCommonProtocol` instances can be used as\n  asynchronous iterators on Python \u2265 3.6. They yield incoming messages.\n\n* Added :func:`~legacy.server.unix_serve` for listening on Unix sockets.\n\n* Added the :attr:`~legacy.server.WebSocketServer.sockets` attribute to the\n  return value of :func:`~legacy.server.serve`.\n\n* Reorganized and extended documentation.\n\n* Aborted connections if they don't close within the configured ``timeout``.\n\n* Rewrote connection termination to increase robustness in edge cases.\n\n* Stopped leaking pending tasks when :meth:`~asyncio.Task.cancel` is called on\n  a connection while it's being closed.\n\n* Reduced verbosity of \"Failing the WebSocket connection\" logs.\n\n* Allowed ``extra_headers`` to override ``Server`` and ``User-Agent`` headers.\n\n3.4\n...\n\n*August 20, 2017*\n\n* Renamed :func:`~legacy.server.serve` and :func:`~legacy.client.connect`'s\n  ``klass`` argument to ``create_protocol`` to reflect that it can also be a\n  callable. For backwards compatibility, ``klass`` is still supported.\n\n* :func:`~legacy.server.serve` can be used as an asynchronous context manager\n  on Python \u2265 3.5.1.\n\n* Added support for customizing handling of incoming connections with\n  :meth:`~legacy.server.WebSocketServerProtocol.process_request`.\n\n* Made read and write buffer sizes configurable.\n\n* Rewrote HTTP handling for simplicity and performance.\n\n* Added an optional C extension to speed up low-level operations.\n\n* An invalid response status code during :func:`~legacy.client.connect` now\n  raises :class:`~exceptions.InvalidStatusCode` with a ``code`` attribute.\n\n* Providing a ``sock`` argument to :func:`~legacy.client.connect` no longer\n  crashes.\n\n3.3\n...\n\n*March 29, 2017*\n\n* Ensured compatibility with Python 3.6.\n\n* Reduced noise in logs caused by connection resets.\n\n* Avoided crashing on concurrent writes on slow connections.\n\n3.2\n...\n\n*August 17, 2016*\n\n* Added ``timeout``, ``max_size``, and ``max_queue`` arguments to\n  :func:`~legacy.client.connect` and :func:`~legacy.server.serve`.\n\n* Made server shutdown more robust.\n\n3.1\n...\n\n*April 21, 2016*\n\n* Avoided a warning when closing a connection before the opening handshake.\n\n* Added flow control for incoming data.\n\n3.0\n...\n\n*December 25, 2015*\n\n.. warning::\n\n    **Version 3.0 introduces a backwards-incompatible change in the**\n    :meth:`~legacy.protocol.WebSocketCommonProtocol.recv` **API.**\n\n    **If you're upgrading from 2.x or earlier, please read this carefully.**\n\n    :meth:`~legacy.protocol.WebSocketCommonProtocol.recv` used to return\n    ``None`` when the connection was closed. This required checking the return\n    value of every call::\n\n        message = await websocket.recv()\n        if message is None:\n            return\n\n    Now it raises a :exc:`~exceptions.ConnectionClosed` exception instead.\n    This is more Pythonic. The previous code can be simplified to::\n\n        message = await websocket.recv()\n\n    When implementing a server, which is the more popular use case, there's no\n    strong reason to handle such exceptions. Let them bubble up, terminate the\n    handler coroutine, and the server will simply ignore them.\n\n    In order to avoid stranding projects built upon an earlier version, the\n    previous behavior can be restored by passing ``legacy_recv=True`` to\n    :func:`~legacy.server.serve`, :func:`~legacy.client.connect`,\n    :class:`~legacy.server.WebSocketServerProtocol`, or\n    :class:`~legacy.client.WebSocketClientProtocol`. ``legacy_recv`` isn't\n    documented in their signatures but isn't scheduled for deprecation either.\n\nAlso:\n\n* :func:`~legacy.client.connect` can be used as an asynchronous context\n  manager on Python \u2265 3.5.1.\n\n* Updated documentation with ``await`` and ``async`` syntax from Python 3.5.\n\n* :meth:`~legacy.protocol.WebSocketCommonProtocol.ping` and\n  :meth:`~legacy.protocol.WebSocketCommonProtocol.pong` support data passed as\n  :class:`str` in addition to :class:`bytes`.\n\n* Worked around an :mod:`asyncio` bug affecting connection termination under\n  load.\n\n* Made ``state_name`` attribute on protocols a public API.\n\n* Improved documentation.\n\n2.7\n...\n\n*November 18, 2015*\n\n* Added compatibility with Python 3.5.\n\n* Refreshed documentation.\n\n2.6\n...\n\n*August 18, 2015*\n\n* Added ``local_address`` and ``remote_address`` attributes on protocols.\n\n* Closed open connections with code 1001 when a server shuts down.\n\n* Avoided TCP fragmentation of small frames.\n\n2.5\n...\n\n*July 28, 2015*\n\n* Improved documentation.\n\n* Provided access to handshake request and response HTTP headers.\n\n* Allowed customizing handshake request and response HTTP headers.\n\n* Added support for running on a non-default event loop.\n\n* Returned a 403 status code instead of 400 when the request Origin isn't\n  allowed.\n\n* Canceling :meth:`~legacy.protocol.WebSocketCommonProtocol.recv` no longer\n  drops the next message.\n\n* Clarified that the closing handshake can be initiated by the client.\n\n* Set the close code and reason more consistently.\n\n* Strengthened connection termination by simplifying the implementation.\n\n* Improved tests, added tox configuration, and enforced 100% branch coverage.\n\n2.4\n...\n\n*January 31, 2015*\n\n* Added support for subprotocols.\n\n* Added ``loop`` argument to :func:`~legacy.client.connect` and\n  :func:`~legacy.server.serve`.\n\n2.3\n...\n\n*November 3, 2014*\n\n* Improved compliance of close codes.\n\n2.2\n...\n\n*July 28, 2014*\n\n* Added support for limiting message size.\n\n2.1\n...\n\n*April 26, 2014*\n\n* Added ``host``, ``port`` and ``secure`` attributes on protocols.\n\n* Added support for providing and checking Origin_.\n\n.. _Origin: https://tools.ietf.org/html/rfc6455#section-10.2\n\n2.0\n...\n\n*February 16, 2014*\n\n.. warning::\n\n    **Version 2.0 introduces a backwards-incompatible change in the**\n    :meth:`~legacy.protocol.WebSocketCommonProtocol.send`,\n    :meth:`~legacy.protocol.WebSocketCommonProtocol.ping`, and\n    :meth:`~legacy.protocol.WebSocketCommonProtocol.pong` **APIs.**\n\n    **If you're upgrading from 1.x or earlier, please read this carefully.**\n\n    These APIs used to be functions. Now they're coroutines.\n\n    Instead of::\n\n        websocket.send(message)\n\n    you must now write::\n\n        await websocket.send(message)\n\nAlso:\n\n* Added flow control for outgoing data.\n\n1.0\n...\n\n*November 14, 2013*\n\n* Initial public release.\n", "\"\"\"\n:mod:`websockets.legacy.auth` provides HTTP Basic Authentication according to\n:rfc:`7235` and :rfc:`7617`.\n\n\"\"\"\n\n\nimport functools\nimport http\nfrom typing import Any, Awaitable, Callable, Iterable, Optional, Tuple, Union, cast\n\nfrom ..datastructures import Headers\nfrom ..exceptions import InvalidHeader\nfrom ..headers import build_www_authenticate_basic, parse_authorization_basic\nfrom .server import HTTPResponse, WebSocketServerProtocol\n\n\n__all__ = [\"BasicAuthWebSocketServerProtocol\", \"basic_auth_protocol_factory\"]\n\nCredentials = Tuple[str, str]\n\n\ndef is_credentials(value: Any) -> bool:\n    try:\n        username, password = value\n    except (TypeError, ValueError):\n        return False\n    else:\n        return isinstance(username, str) and isinstance(password, str)\n\n\nclass BasicAuthWebSocketServerProtocol(WebSocketServerProtocol):\n    \"\"\"\n    WebSocket server protocol that enforces HTTP Basic Auth.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: Any,\n        realm: str,\n        check_credentials: Callable[[str, str], Awaitable[bool]],\n        **kwargs: Any,\n    ) -> None:\n        self.realm = realm\n        self.check_credentials = check_credentials\n        super().__init__(*args, **kwargs)\n\n    async def process_request(\n        self, path: str, request_headers: Headers\n    ) -> Optional[HTTPResponse]:\n        \"\"\"\n        Check HTTP Basic Auth and return a HTTP 401 or 403 response if needed.\n\n        \"\"\"\n        try:\n            authorization = request_headers[\"Authorization\"]\n        except KeyError:\n            return (\n                http.HTTPStatus.UNAUTHORIZED,\n                [(\"WWW-Authenticate\", build_www_authenticate_basic(self.realm))],\n                b\"Missing credentials\\n\",\n            )\n\n        try:\n            username, password = parse_authorization_basic(authorization)\n        except InvalidHeader:\n            return (\n                http.HTTPStatus.UNAUTHORIZED,\n                [(\"WWW-Authenticate\", build_www_authenticate_basic(self.realm))],\n                b\"Unsupported credentials\\n\",\n            )\n\n        if not await self.check_credentials(username, password):\n            return (\n                http.HTTPStatus.UNAUTHORIZED,\n                [(\"WWW-Authenticate\", build_www_authenticate_basic(self.realm))],\n                b\"Invalid credentials\\n\",\n            )\n\n        self.username = username\n\n        return await super().process_request(path, request_headers)\n\n\ndef basic_auth_protocol_factory(\n    realm: str,\n    credentials: Optional[Union[Credentials, Iterable[Credentials]]] = None,\n    check_credentials: Optional[Callable[[str, str], Awaitable[bool]]] = None,\n    create_protocol: Optional[Callable[[Any], BasicAuthWebSocketServerProtocol]] = None,\n) -> Callable[[Any], BasicAuthWebSocketServerProtocol]:\n    \"\"\"\n    Protocol factory that enforces HTTP Basic Auth.\n\n    ``basic_auth_protocol_factory`` is designed to integrate with\n    :func:`~websockets.legacy.server.serve` like this::\n\n        websockets.serve(\n            ...,\n            create_protocol=websockets.basic_auth_protocol_factory(\n                realm=\"my dev server\",\n                credentials=(\"hello\", \"iloveyou\"),\n            )\n        )\n\n    ``realm`` indicates the scope of protection. It should contain only ASCII\n    characters because the encoding of non-ASCII characters is undefined.\n    Refer to section 2.2 of :rfc:`7235` for details.\n\n    ``credentials`` defines hard coded authorized credentials. It can be a\n    ``(username, password)`` pair or a list of such pairs.\n\n    ``check_credentials`` defines a coroutine that checks whether credentials\n    are authorized. This coroutine receives ``username`` and ``password``\n    arguments and returns a :class:`bool`.\n\n    One of ``credentials`` or ``check_credentials`` must be provided but not\n    both.\n\n    By default, ``basic_auth_protocol_factory`` creates a factory for building\n    :class:`BasicAuthWebSocketServerProtocol` instances. You can override this\n    with the ``create_protocol`` parameter.\n\n    :param realm: scope of protection\n    :param credentials: hard coded credentials\n    :param check_credentials: coroutine that verifies credentials\n    :raises TypeError: if the credentials argument has the wrong type\n\n    \"\"\"\n    if (credentials is None) == (check_credentials is None):\n        raise TypeError(\"provide either credentials or check_credentials\")\n\n    if credentials is not None:\n        if is_credentials(credentials):\n\n            async def check_credentials(username: str, password: str) -> bool:\n                return (username, password) == credentials\n\n        elif isinstance(credentials, Iterable):\n            credentials_list = list(credentials)\n            if all(is_credentials(item) for item in credentials_list):\n                credentials_dict = dict(credentials_list)\n\n                async def check_credentials(username: str, password: str) -> bool:\n                    return credentials_dict.get(username) == password\n\n            else:\n                raise TypeError(f\"invalid credentials argument: {credentials}\")\n\n        else:\n            raise TypeError(f\"invalid credentials argument: {credentials}\")\n\n    if create_protocol is None:\n        # Not sure why mypy cannot figure this out.\n        create_protocol = cast(\n            Callable[[Any], BasicAuthWebSocketServerProtocol],\n            BasicAuthWebSocketServerProtocol,\n        )\n\n    return functools.partial(\n        create_protocol, realm=realm, check_credentials=check_credentials\n    )\n", "import unittest\nimport urllib.error\n\nfrom websockets.exceptions import InvalidStatusCode\nfrom websockets.headers import build_authorization_basic\nfrom websockets.legacy.auth import *\nfrom websockets.legacy.auth import is_credentials\n\nfrom .test_client_server import ClientServerTestsMixin, with_client, with_server\nfrom .utils import AsyncioTestCase\n\n\nclass AuthTests(unittest.TestCase):\n    def test_is_credentials(self):\n        self.assertTrue(is_credentials((\"username\", \"password\")))\n\n    def test_is_not_credentials(self):\n        self.assertFalse(is_credentials(None))\n        self.assertFalse(is_credentials(\"username\"))\n\n\nclass CustomWebSocketServerProtocol(BasicAuthWebSocketServerProtocol):\n    async def process_request(self, path, request_headers):\n        type(self).used = True\n        return await super().process_request(path, request_headers)\n\n\nclass AuthClientServerTests(ClientServerTestsMixin, AsyncioTestCase):\n\n    create_protocol = basic_auth_protocol_factory(\n        realm=\"auth-tests\", credentials=(\"hello\", \"iloveyou\")\n    )\n\n    @with_server(create_protocol=create_protocol)\n    @with_client(user_info=(\"hello\", \"iloveyou\"))\n    def test_basic_auth(self):\n        req_headers = self.client.request_headers\n        resp_headers = self.client.response_headers\n        self.assertEqual(req_headers[\"Authorization\"], \"Basic aGVsbG86aWxvdmV5b3U=\")\n        self.assertNotIn(\"WWW-Authenticate\", resp_headers)\n\n        self.loop.run_until_complete(self.client.send(\"Hello!\"))\n        self.loop.run_until_complete(self.client.recv())\n\n    def test_basic_auth_server_no_credentials(self):\n        with self.assertRaises(TypeError) as raised:\n            basic_auth_protocol_factory(realm=\"auth-tests\", credentials=None)\n        self.assertEqual(\n            str(raised.exception), \"provide either credentials or check_credentials\"\n        )\n\n    def test_basic_auth_server_bad_credentials(self):\n        with self.assertRaises(TypeError) as raised:\n            basic_auth_protocol_factory(realm=\"auth-tests\", credentials=42)\n        self.assertEqual(str(raised.exception), \"invalid credentials argument: 42\")\n\n    create_protocol_multiple_credentials = basic_auth_protocol_factory(\n        realm=\"auth-tests\",\n        credentials=[(\"hello\", \"iloveyou\"), (\"goodbye\", \"stillloveu\")],\n    )\n\n    @with_server(create_protocol=create_protocol_multiple_credentials)\n    @with_client(user_info=(\"hello\", \"iloveyou\"))\n    def test_basic_auth_server_multiple_credentials(self):\n        self.loop.run_until_complete(self.client.send(\"Hello!\"))\n        self.loop.run_until_complete(self.client.recv())\n\n    def test_basic_auth_bad_multiple_credentials(self):\n        with self.assertRaises(TypeError) as raised:\n            basic_auth_protocol_factory(\n                realm=\"auth-tests\", credentials=[(\"hello\", \"iloveyou\"), 42]\n            )\n        self.assertEqual(\n            str(raised.exception),\n            \"invalid credentials argument: [('hello', 'iloveyou'), 42]\",\n        )\n\n    async def check_credentials(username, password):\n        return password == \"iloveyou\"\n\n    create_protocol_check_credentials = basic_auth_protocol_factory(\n        realm=\"auth-tests\",\n        check_credentials=check_credentials,\n    )\n\n    @with_server(create_protocol=create_protocol_check_credentials)\n    @with_client(user_info=(\"hello\", \"iloveyou\"))\n    def test_basic_auth_check_credentials(self):\n        self.loop.run_until_complete(self.client.send(\"Hello!\"))\n        self.loop.run_until_complete(self.client.recv())\n\n    create_protocol_custom_protocol = basic_auth_protocol_factory(\n        realm=\"auth-tests\",\n        credentials=[(\"hello\", \"iloveyou\")],\n        create_protocol=CustomWebSocketServerProtocol,\n    )\n\n    @with_server(create_protocol=create_protocol_custom_protocol)\n    @with_client(user_info=(\"hello\", \"iloveyou\"))\n    def test_basic_auth_custom_protocol(self):\n        self.assertTrue(CustomWebSocketServerProtocol.used)\n        del CustomWebSocketServerProtocol.used\n        self.loop.run_until_complete(self.client.send(\"Hello!\"))\n        self.loop.run_until_complete(self.client.recv())\n\n    @with_server(create_protocol=create_protocol)\n    def test_basic_auth_missing_credentials(self):\n        with self.assertRaises(InvalidStatusCode) as raised:\n            self.start_client()\n        self.assertEqual(raised.exception.status_code, 401)\n\n    @with_server(create_protocol=create_protocol)\n    def test_basic_auth_missing_credentials_details(self):\n        with self.assertRaises(urllib.error.HTTPError) as raised:\n            self.loop.run_until_complete(self.make_http_request())\n        self.assertEqual(raised.exception.code, 401)\n        self.assertEqual(\n            raised.exception.headers[\"WWW-Authenticate\"],\n            'Basic realm=\"auth-tests\", charset=\"UTF-8\"',\n        )\n        self.assertEqual(raised.exception.read().decode(), \"Missing credentials\\n\")\n\n    @with_server(create_protocol=create_protocol)\n    def test_basic_auth_unsupported_credentials(self):\n        with self.assertRaises(InvalidStatusCode) as raised:\n            self.start_client(extra_headers={\"Authorization\": \"Digest ...\"})\n        self.assertEqual(raised.exception.status_code, 401)\n\n    @with_server(create_protocol=create_protocol)\n    def test_basic_auth_unsupported_credentials_details(self):\n        with self.assertRaises(urllib.error.HTTPError) as raised:\n            self.loop.run_until_complete(\n                self.make_http_request(headers={\"Authorization\": \"Digest ...\"})\n            )\n        self.assertEqual(raised.exception.code, 401)\n        self.assertEqual(\n            raised.exception.headers[\"WWW-Authenticate\"],\n            'Basic realm=\"auth-tests\", charset=\"UTF-8\"',\n        )\n        self.assertEqual(raised.exception.read().decode(), \"Unsupported credentials\\n\")\n\n    @with_server(create_protocol=create_protocol)\n    def test_basic_auth_invalid_credentials(self):\n        with self.assertRaises(InvalidStatusCode) as raised:\n            self.start_client(user_info=(\"hello\", \"ihateyou\"))\n        self.assertEqual(raised.exception.status_code, 401)\n\n    @with_server(create_protocol=create_protocol)\n    def test_basic_auth_invalid_credentials_details(self):\n        with self.assertRaises(urllib.error.HTTPError) as raised:\n            authorization = build_authorization_basic(\"hello\", \"ihateyou\")\n            self.loop.run_until_complete(\n                self.make_http_request(headers={\"Authorization\": authorization})\n            )\n        self.assertEqual(raised.exception.code, 401)\n        self.assertEqual(\n            raised.exception.headers[\"WWW-Authenticate\"],\n            'Basic realm=\"auth-tests\", charset=\"UTF-8\"',\n        )\n        self.assertEqual(raised.exception.read().decode(), \"Invalid credentials\\n\")\n"], "fixing_code": ["Changelog\n---------\n\n.. currentmodule:: websockets\n\n.. _backwards-compatibility policy:\n\nBackwards-compatibility policy\n..............................\n\n``websockets`` is intended for production use. Therefore, stability is a goal.\n\n``websockets`` also aims at providing the best API for WebSocket in Python.\n\nWhile we value stability, we value progress more. When an improvement requires\nchanging a public API, we make the change and document it in this changelog.\n\nWhen possible with reasonable effort, we preserve backwards-compatibility for\nfive years after the release that introduced the change.\n\nWhen a release contains backwards-incompatible API changes, the major version\nis increased, else the minor version is increased. Patch versions are only for\nfixing regressions shortly after a release.\n\nOnly documented APIs are public. Undocumented APIs are considered private.\nThey may change at any time.\n\n9.1\n...\n\n*In development*\n\n.. note::\n\n    **Version 9.1 fixes a security issue introduced in version 8.0.**\n\n    Version 8.0 was vulnerable to timing attacks on HTTP Basic Auth passwords.\n\n9.0.2\n.....\n\n*May 15, 2021*\n\n* Restored compatibility of ``python -m websockets`` with Python < 3.9.\n\n* Restored compatibility with mypy.\n\n9.0.1\n.....\n\n*May 2, 2021*\n\n* Fixed issues with the packaging of the 9.0 release.\n\n9.0\n...\n\n*May 1, 2021*\n\n.. note::\n\n    **Version 9.0 moves or deprecates several APIs.**\n\n    Aliases provide backwards compatibility for all previously public APIs.\n\n    * :class:`~datastructures.Headers` and\n      :exc:`~datastructures.MultipleValuesError` were moved from\n      ``websockets.http`` to :mod:`websockets.datastructures`. If you're using\n      them, you should adjust the import path.\n\n    * The ``client``, ``server``, ``protocol``, and ``auth`` modules were\n      moved from the ``websockets`` package to ``websockets.legacy``\n      sub-package, as part of an upcoming refactoring. Despite the name,\n      they're still fully supported. The refactoring should be a transparent\n      upgrade for most uses when it's available. The legacy implementation\n      will be preserved according to the `backwards-compatibility policy`_.\n\n    * The ``framing``, ``handshake``, ``headers``, ``http``, and ``uri``\n      modules in the ``websockets`` package are deprecated. These modules\n      provided low-level APIs for reuse by other WebSocket implementations,\n      but that never happened. Keeping these APIs public makes it more\n      difficult to improve websockets for no actual benefit.\n\n.. note::\n\n    **Version 9.0 may require changes if you use static code analysis tools.**\n\n    Convenience imports from the ``websockets`` module are performed lazily.\n    While this is supported by Python, static code analysis tools such as mypy\n    are unable to understand the behavior.\n\n    If you depend on such tools, use the real import path, which can be found\n    in the API documentation::\n\n        from websockets.client import connect\n        from websockets.server import serve\n\n* Added compatibility with Python 3.9.\n\n* Added support for IRIs in addition to URIs.\n\n* Added close codes 1012, 1013, and 1014.\n\n* Raised an error when passing a :class:`dict` to\n  :meth:`~legacy.protocol.WebSocketCommonProtocol.send`.\n\n* Fixed sending fragmented, compressed messages.\n\n* Fixed ``Host`` header sent when connecting to an IPv6 address.\n\n* Fixed creating a client or a server with an existing Unix socket.\n\n* Aligned maximum cookie size with popular web browsers.\n\n* Ensured cancellation always propagates, even on Python versions where\n  :exc:`~asyncio.CancelledError` inherits :exc:`Exception`.\n\n* Improved error reporting.\n\n\n8.1\n...\n\n*November 1, 2019*\n\n* Added compatibility with Python 3.8.\n\n8.0.2\n.....\n\n*July 31, 2019*\n\n* Restored the ability to pass a socket with the ``sock`` parameter of\n  :func:`~legacy.server.serve`.\n\n* Removed an incorrect assertion when a connection drops.\n\n8.0.1\n.....\n\n*July 21, 2019*\n\n* Restored the ability to import ``WebSocketProtocolError`` from\n  ``websockets``.\n\n8.0\n...\n\n*July 7, 2019*\n\n.. warning::\n\n    **Version 8.0 drops compatibility with Python 3.4 and 3.5.**\n\n.. note::\n\n    **Version 8.0 expects** ``process_request`` **to be a coroutine.**\n\n    Previously, it could be a function or a coroutine.\n\n    If you're passing a ``process_request`` argument to\n    :func:`~legacy.server.serve`\n    or :class:`~legacy.server.WebSocketServerProtocol`, or if you're overriding\n    :meth:`~legacy.server.WebSocketServerProtocol.process_request` in a subclass,\n    define it with ``async def`` instead of ``def``.\n\n    For backwards compatibility, functions are still mostly supported, but\n    mixing functions and coroutines won't work in some inheritance scenarios.\n\n.. note::\n\n    **Version 8.0 changes the behavior of the** ``max_queue`` **parameter.**\n\n    If you were setting ``max_queue=0`` to make the queue of incoming messages\n    unbounded, change it to ``max_queue=None``.\n\n.. note::\n\n    **Version 8.0 deprecates the** ``host`` **,** ``port`` **, and** ``secure``\n    **attributes of** :class:`~legacy.protocol.WebSocketCommonProtocol`.\n\n    Use :attr:`~legacy.protocol.WebSocketCommonProtocol.local_address` in\n    servers and\n    :attr:`~legacy.protocol.WebSocketCommonProtocol.remote_address` in clients\n    instead of ``host`` and ``port``.\n\n.. note::\n\n    **Version 8.0 renames the** ``WebSocketProtocolError`` **exception**\n    to :exc:`~exceptions.ProtocolError` **.**\n\n    A ``WebSocketProtocolError`` alias provides backwards compatibility.\n\n.. note::\n\n    **Version 8.0 adds the reason phrase to the return type of the low-level\n    API** ``read_response()`` **.**\n\nAlso:\n\n* :meth:`~legacy.protocol.WebSocketCommonProtocol.send`,\n  :meth:`~legacy.protocol.WebSocketCommonProtocol.ping`, and\n  :meth:`~legacy.protocol.WebSocketCommonProtocol.pong` support bytes-like\n  types :class:`bytearray` and :class:`memoryview` in addition to\n  :class:`bytes`.\n\n* Added :exc:`~exceptions.ConnectionClosedOK` and\n  :exc:`~exceptions.ConnectionClosedError` subclasses of\n  :exc:`~exceptions.ConnectionClosed` to tell apart normal connection\n  termination from errors.\n\n* Added :func:`~legacy.auth.basic_auth_protocol_factory` to enforce HTTP\n  Basic Auth on the server side.\n\n* :func:`~legacy.client.connect` handles redirects from the server during the\n  handshake.\n\n* :func:`~legacy.client.connect` supports overriding ``host`` and ``port``.\n\n* Added :func:`~legacy.client.unix_connect` for connecting to Unix sockets.\n\n* Improved support for sending fragmented messages by accepting asynchronous\n  iterators in :meth:`~legacy.protocol.WebSocketCommonProtocol.send`.\n\n* Prevented spurious log messages about :exc:`~exceptions.ConnectionClosed`\n  exceptions in keepalive ping task. If you were using ``ping_timeout=None``\n  as a workaround, you can remove it.\n\n* Changed :meth:`WebSocketServer.close()\n  <legacy.server.WebSocketServer.close>` to perform a proper closing handshake\n  instead of failing the connection.\n\n* Avoided a crash when a ``extra_headers`` callable returns ``None``.\n\n* Improved error messages when HTTP parsing fails.\n\n* Enabled readline in the interactive client.\n\n* Added type hints (:pep:`484`).\n\n* Added a FAQ to the documentation.\n\n* Added documentation for extensions.\n\n* Documented how to optimize memory usage.\n\n* Improved API documentation.\n\n7.0\n...\n\n*November 1, 2018*\n\n.. warning::\n\n    ``websockets`` **now sends Ping frames at regular intervals and closes the\n    connection if it doesn't receive a matching Pong frame.**\n\n    See :class:`~legacy.protocol.WebSocketCommonProtocol` for details.\n\n.. warning::\n\n    **Version 7.0 changes how a server terminates connections when it's closed\n    with** :meth:`WebSocketServer.close()\n    <legacy.server.WebSocketServer.close>` **.**\n\n    Previously, connections handlers were canceled. Now, connections are\n    closed with close code 1001 (going away). From the perspective of the\n    connection handler, this is the same as if the remote endpoint was\n    disconnecting. This removes the need to prepare for\n    :exc:`~asyncio.CancelledError` in connection handlers.\n\n    You can restore the previous behavior by adding the following line at the\n    beginning of connection handlers::\n\n        def handler(websocket, path):\n            closed = asyncio.ensure_future(websocket.wait_closed())\n            closed.add_done_callback(lambda task: task.cancel())\n\n.. note::\n\n    **Version 7.0 renames the** ``timeout`` **argument of**\n    :func:`~legacy.server.serve` **and** :func:`~legacy.client.connect` **to**\n    ``close_timeout`` **.**\n\n    This prevents confusion with ``ping_timeout``.\n\n    For backwards compatibility, ``timeout`` is still supported.\n\n.. note::\n\n    **Version 7.0 changes how a**\n    :meth:`~legacy.protocol.WebSocketCommonProtocol.ping` **that hasn't\n    received a pong yet behaves when the connection is closed.**\n\n    The ping \u2014 as in ``ping = await websocket.ping()`` \u2014 used to be canceled\n    when the connection is closed, so that ``await ping`` raised\n    :exc:`~asyncio.CancelledError`. Now ``await ping`` raises\n    :exc:`~exceptions.ConnectionClosed` like other public APIs.\n\n.. note::\n\n    **Version 7.0 raises a** :exc:`RuntimeError` **exception if two coroutines\n    call** :meth:`~legacy.protocol.WebSocketCommonProtocol.recv`\n    **concurrently.**\n\n    Concurrent calls lead to non-deterministic behavior because there are no\n    guarantees about which coroutine will receive which message.\n\nAlso:\n\n* Added ``process_request`` and ``select_subprotocol`` arguments to\n  :func:`~legacy.server.serve` and\n  :class:`~legacy.server.WebSocketServerProtocol` to customize\n  :meth:`~legacy.server.WebSocketServerProtocol.process_request` and\n  :meth:`~legacy.server.WebSocketServerProtocol.select_subprotocol` without\n  subclassing :class:`~legacy.server.WebSocketServerProtocol`.\n\n* Added support for sending fragmented messages.\n\n* Added the :meth:`~legacy.protocol.WebSocketCommonProtocol.wait_closed`\n  method to protocols.\n\n* Added an interactive client: ``python -m websockets <uri>``.\n\n* Changed the ``origins`` argument to represent the lack of an origin with\n  ``None`` rather than ``''``.\n\n* Fixed a data loss bug in\n  :meth:`~legacy.protocol.WebSocketCommonProtocol.recv`:\n  canceling it at the wrong time could result in messages being dropped.\n\n* Improved handling of multiple HTTP headers with the same name.\n\n* Improved error messages when a required HTTP header is missing.\n\n6.0\n...\n\n*July 16, 2018*\n\n.. warning::\n\n    **Version 6.0 introduces the** :class:`~datastructures.Headers` **class\n    for managing HTTP headers and changes several public APIs:**\n\n    * :meth:`~legacy.server.WebSocketServerProtocol.process_request` now\n      receives a :class:`~datastructures.Headers` instead of a\n      ``http.client.HTTPMessage`` in the ``request_headers`` argument.\n\n    * The ``request_headers`` and ``response_headers`` attributes of\n      :class:`~legacy.protocol.WebSocketCommonProtocol` are\n      :class:`~datastructures.Headers` instead of ``http.client.HTTPMessage``.\n\n    * The ``raw_request_headers`` and ``raw_response_headers`` attributes of\n      :class:`~legacy.protocol.WebSocketCommonProtocol` are removed. Use\n      :meth:`~datastructures.Headers.raw_items` instead.\n\n    * Functions defined in the ``handshake`` module now receive\n      :class:`~datastructures.Headers` in argument instead of ``get_header``\n      or ``set_header`` functions. This affects libraries that rely on\n      low-level APIs.\n\n    * Functions defined in the ``http`` module now return HTTP headers as\n      :class:`~datastructures.Headers` instead of lists of ``(name, value)``\n      pairs.\n\n    Since :class:`~datastructures.Headers` and ``http.client.HTTPMessage``\n    provide similar APIs, this change won't affect most of the code dealing\n    with HTTP headers.\n\n\nAlso:\n\n* Added compatibility with Python 3.7.\n\n5.0.1\n.....\n\n*May 24, 2018*\n\n* Fixed a regression in 5.0 that broke some invocations of\n  :func:`~legacy.server.serve` and :func:`~legacy.client.connect`.\n\n5.0\n...\n\n*May 22, 2018*\n\n.. note::\n\n    **Version 5.0 fixes a security issue introduced in version 4.0.**\n\n    Version 4.0 was vulnerable to denial of service by memory exhaustion\n    because it didn't enforce ``max_size`` when decompressing compressed\n    messages (`CVE-2018-1000518`_).\n\n    .. _CVE-2018-1000518: https://nvd.nist.gov/vuln/detail/CVE-2018-1000518\n\n.. note::\n\n    **Version 5.0 adds a** ``user_info`` **field to the return value of**\n    :func:`~uri.parse_uri` **and** :class:`~uri.WebSocketURI` **.**\n\n    If you're unpacking :class:`~uri.WebSocketURI` into four variables, adjust\n    your code to account for that fifth field.\n\nAlso:\n\n* :func:`~legacy.client.connect` performs HTTP Basic Auth when the URI contains\n  credentials.\n\n* Iterating on incoming messages no longer raises an exception when the\n  connection terminates with close code 1001 (going away).\n\n* A plain HTTP request now receives a 426 Upgrade Required response and\n  doesn't log a stack trace.\n\n* :func:`~legacy.server.unix_serve` can be used as an asynchronous context\n  manager on Python \u2265 3.5.1.\n\n* Added the :attr:`~legacy.protocol.WebSocketCommonProtocol.closed` property\n  to protocols.\n\n* If a :meth:`~legacy.protocol.WebSocketCommonProtocol.ping` doesn't receive a\n  pong, it's canceled when the connection is closed.\n\n* Reported the cause of :exc:`~exceptions.ConnectionClosed` exceptions.\n\n* Added new examples in the documentation.\n\n* Updated documentation with new features from Python 3.6.\n\n* Improved several other sections of the documentation.\n\n* Fixed missing close code, which caused :exc:`TypeError` on connection close.\n\n* Fixed a race condition in the closing handshake that raised\n  :exc:`~exceptions.InvalidState`.\n\n* Stopped logging stack traces when the TCP connection dies prematurely.\n\n* Prevented writing to a closing TCP connection during unclean shutdowns.\n\n* Made connection termination more robust to network congestion.\n\n* Prevented processing of incoming frames after failing the connection.\n\n4.0.1\n.....\n\n*November 2, 2017*\n\n* Fixed issues with the packaging of the 4.0 release.\n\n4.0\n...\n\n*November 2, 2017*\n\n.. warning::\n\n    **Version 4.0 drops compatibility with Python 3.3.**\n\n.. note::\n\n    **Version 4.0 enables compression with the permessage-deflate extension.**\n\n    In August 2017, Firefox and Chrome support it, but not Safari and IE.\n\n    Compression should improve performance but it increases RAM and CPU use.\n\n    If you want to disable compression, add ``compression=None`` when calling\n    :func:`~legacy.server.serve` or :func:`~legacy.client.connect`.\n\n.. note::\n\n    **Version 4.0 removes the** ``state_name`` **attribute of protocols.**\n\n    Use ``protocol.state.name`` instead of ``protocol.state_name``.\n\nAlso:\n\n* :class:`~legacy.protocol.WebSocketCommonProtocol` instances can be used as\n  asynchronous iterators on Python \u2265 3.6. They yield incoming messages.\n\n* Added :func:`~legacy.server.unix_serve` for listening on Unix sockets.\n\n* Added the :attr:`~legacy.server.WebSocketServer.sockets` attribute to the\n  return value of :func:`~legacy.server.serve`.\n\n* Reorganized and extended documentation.\n\n* Aborted connections if they don't close within the configured ``timeout``.\n\n* Rewrote connection termination to increase robustness in edge cases.\n\n* Stopped leaking pending tasks when :meth:`~asyncio.Task.cancel` is called on\n  a connection while it's being closed.\n\n* Reduced verbosity of \"Failing the WebSocket connection\" logs.\n\n* Allowed ``extra_headers`` to override ``Server`` and ``User-Agent`` headers.\n\n3.4\n...\n\n*August 20, 2017*\n\n* Renamed :func:`~legacy.server.serve` and :func:`~legacy.client.connect`'s\n  ``klass`` argument to ``create_protocol`` to reflect that it can also be a\n  callable. For backwards compatibility, ``klass`` is still supported.\n\n* :func:`~legacy.server.serve` can be used as an asynchronous context manager\n  on Python \u2265 3.5.1.\n\n* Added support for customizing handling of incoming connections with\n  :meth:`~legacy.server.WebSocketServerProtocol.process_request`.\n\n* Made read and write buffer sizes configurable.\n\n* Rewrote HTTP handling for simplicity and performance.\n\n* Added an optional C extension to speed up low-level operations.\n\n* An invalid response status code during :func:`~legacy.client.connect` now\n  raises :class:`~exceptions.InvalidStatusCode` with a ``code`` attribute.\n\n* Providing a ``sock`` argument to :func:`~legacy.client.connect` no longer\n  crashes.\n\n3.3\n...\n\n*March 29, 2017*\n\n* Ensured compatibility with Python 3.6.\n\n* Reduced noise in logs caused by connection resets.\n\n* Avoided crashing on concurrent writes on slow connections.\n\n3.2\n...\n\n*August 17, 2016*\n\n* Added ``timeout``, ``max_size``, and ``max_queue`` arguments to\n  :func:`~legacy.client.connect` and :func:`~legacy.server.serve`.\n\n* Made server shutdown more robust.\n\n3.1\n...\n\n*April 21, 2016*\n\n* Avoided a warning when closing a connection before the opening handshake.\n\n* Added flow control for incoming data.\n\n3.0\n...\n\n*December 25, 2015*\n\n.. warning::\n\n    **Version 3.0 introduces a backwards-incompatible change in the**\n    :meth:`~legacy.protocol.WebSocketCommonProtocol.recv` **API.**\n\n    **If you're upgrading from 2.x or earlier, please read this carefully.**\n\n    :meth:`~legacy.protocol.WebSocketCommonProtocol.recv` used to return\n    ``None`` when the connection was closed. This required checking the return\n    value of every call::\n\n        message = await websocket.recv()\n        if message is None:\n            return\n\n    Now it raises a :exc:`~exceptions.ConnectionClosed` exception instead.\n    This is more Pythonic. The previous code can be simplified to::\n\n        message = await websocket.recv()\n\n    When implementing a server, which is the more popular use case, there's no\n    strong reason to handle such exceptions. Let them bubble up, terminate the\n    handler coroutine, and the server will simply ignore them.\n\n    In order to avoid stranding projects built upon an earlier version, the\n    previous behavior can be restored by passing ``legacy_recv=True`` to\n    :func:`~legacy.server.serve`, :func:`~legacy.client.connect`,\n    :class:`~legacy.server.WebSocketServerProtocol`, or\n    :class:`~legacy.client.WebSocketClientProtocol`. ``legacy_recv`` isn't\n    documented in their signatures but isn't scheduled for deprecation either.\n\nAlso:\n\n* :func:`~legacy.client.connect` can be used as an asynchronous context\n  manager on Python \u2265 3.5.1.\n\n* Updated documentation with ``await`` and ``async`` syntax from Python 3.5.\n\n* :meth:`~legacy.protocol.WebSocketCommonProtocol.ping` and\n  :meth:`~legacy.protocol.WebSocketCommonProtocol.pong` support data passed as\n  :class:`str` in addition to :class:`bytes`.\n\n* Worked around an :mod:`asyncio` bug affecting connection termination under\n  load.\n\n* Made ``state_name`` attribute on protocols a public API.\n\n* Improved documentation.\n\n2.7\n...\n\n*November 18, 2015*\n\n* Added compatibility with Python 3.5.\n\n* Refreshed documentation.\n\n2.6\n...\n\n*August 18, 2015*\n\n* Added ``local_address`` and ``remote_address`` attributes on protocols.\n\n* Closed open connections with code 1001 when a server shuts down.\n\n* Avoided TCP fragmentation of small frames.\n\n2.5\n...\n\n*July 28, 2015*\n\n* Improved documentation.\n\n* Provided access to handshake request and response HTTP headers.\n\n* Allowed customizing handshake request and response HTTP headers.\n\n* Added support for running on a non-default event loop.\n\n* Returned a 403 status code instead of 400 when the request Origin isn't\n  allowed.\n\n* Canceling :meth:`~legacy.protocol.WebSocketCommonProtocol.recv` no longer\n  drops the next message.\n\n* Clarified that the closing handshake can be initiated by the client.\n\n* Set the close code and reason more consistently.\n\n* Strengthened connection termination by simplifying the implementation.\n\n* Improved tests, added tox configuration, and enforced 100% branch coverage.\n\n2.4\n...\n\n*January 31, 2015*\n\n* Added support for subprotocols.\n\n* Added ``loop`` argument to :func:`~legacy.client.connect` and\n  :func:`~legacy.server.serve`.\n\n2.3\n...\n\n*November 3, 2014*\n\n* Improved compliance of close codes.\n\n2.2\n...\n\n*July 28, 2014*\n\n* Added support for limiting message size.\n\n2.1\n...\n\n*April 26, 2014*\n\n* Added ``host``, ``port`` and ``secure`` attributes on protocols.\n\n* Added support for providing and checking Origin_.\n\n.. _Origin: https://tools.ietf.org/html/rfc6455#section-10.2\n\n2.0\n...\n\n*February 16, 2014*\n\n.. warning::\n\n    **Version 2.0 introduces a backwards-incompatible change in the**\n    :meth:`~legacy.protocol.WebSocketCommonProtocol.send`,\n    :meth:`~legacy.protocol.WebSocketCommonProtocol.ping`, and\n    :meth:`~legacy.protocol.WebSocketCommonProtocol.pong` **APIs.**\n\n    **If you're upgrading from 1.x or earlier, please read this carefully.**\n\n    These APIs used to be functions. Now they're coroutines.\n\n    Instead of::\n\n        websocket.send(message)\n\n    you must now write::\n\n        await websocket.send(message)\n\nAlso:\n\n* Added flow control for outgoing data.\n\n1.0\n...\n\n*November 14, 2013*\n\n* Initial public release.\n", "\"\"\"\n:mod:`websockets.legacy.auth` provides HTTP Basic Authentication according to\n:rfc:`7235` and :rfc:`7617`.\n\n\"\"\"\n\n\nimport functools\nimport hmac\nimport http\nfrom typing import Any, Awaitable, Callable, Iterable, Optional, Tuple, Union, cast\n\nfrom ..datastructures import Headers\nfrom ..exceptions import InvalidHeader\nfrom ..headers import build_www_authenticate_basic, parse_authorization_basic\nfrom .server import HTTPResponse, WebSocketServerProtocol\n\n\n__all__ = [\"BasicAuthWebSocketServerProtocol\", \"basic_auth_protocol_factory\"]\n\nCredentials = Tuple[str, str]\n\n\ndef is_credentials(value: Any) -> bool:\n    try:\n        username, password = value\n    except (TypeError, ValueError):\n        return False\n    else:\n        return isinstance(username, str) and isinstance(password, str)\n\n\nclass BasicAuthWebSocketServerProtocol(WebSocketServerProtocol):\n    \"\"\"\n    WebSocket server protocol that enforces HTTP Basic Auth.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: Any,\n        realm: str,\n        check_credentials: Callable[[str, str], Awaitable[bool]],\n        **kwargs: Any,\n    ) -> None:\n        self.realm = realm\n        self.check_credentials = check_credentials\n        super().__init__(*args, **kwargs)\n\n    async def process_request(\n        self, path: str, request_headers: Headers\n    ) -> Optional[HTTPResponse]:\n        \"\"\"\n        Check HTTP Basic Auth and return a HTTP 401 or 403 response if needed.\n\n        \"\"\"\n        try:\n            authorization = request_headers[\"Authorization\"]\n        except KeyError:\n            return (\n                http.HTTPStatus.UNAUTHORIZED,\n                [(\"WWW-Authenticate\", build_www_authenticate_basic(self.realm))],\n                b\"Missing credentials\\n\",\n            )\n\n        try:\n            username, password = parse_authorization_basic(authorization)\n        except InvalidHeader:\n            return (\n                http.HTTPStatus.UNAUTHORIZED,\n                [(\"WWW-Authenticate\", build_www_authenticate_basic(self.realm))],\n                b\"Unsupported credentials\\n\",\n            )\n\n        if not await self.check_credentials(username, password):\n            return (\n                http.HTTPStatus.UNAUTHORIZED,\n                [(\"WWW-Authenticate\", build_www_authenticate_basic(self.realm))],\n                b\"Invalid credentials\\n\",\n            )\n\n        self.username = username\n\n        return await super().process_request(path, request_headers)\n\n\ndef basic_auth_protocol_factory(\n    realm: str,\n    credentials: Optional[Union[Credentials, Iterable[Credentials]]] = None,\n    check_credentials: Optional[Callable[[str, str], Awaitable[bool]]] = None,\n    create_protocol: Optional[Callable[[Any], BasicAuthWebSocketServerProtocol]] = None,\n) -> Callable[[Any], BasicAuthWebSocketServerProtocol]:\n    \"\"\"\n    Protocol factory that enforces HTTP Basic Auth.\n\n    ``basic_auth_protocol_factory`` is designed to integrate with\n    :func:`~websockets.legacy.server.serve` like this::\n\n        websockets.serve(\n            ...,\n            create_protocol=websockets.basic_auth_protocol_factory(\n                realm=\"my dev server\",\n                credentials=(\"hello\", \"iloveyou\"),\n            )\n        )\n\n    ``realm`` indicates the scope of protection. It should contain only ASCII\n    characters because the encoding of non-ASCII characters is undefined.\n    Refer to section 2.2 of :rfc:`7235` for details.\n\n    ``credentials`` defines hard coded authorized credentials. It can be a\n    ``(username, password)`` pair or a list of such pairs.\n\n    ``check_credentials`` defines a coroutine that checks whether credentials\n    are authorized. This coroutine receives ``username`` and ``password``\n    arguments and returns a :class:`bool`.\n\n    One of ``credentials`` or ``check_credentials`` must be provided but not\n    both.\n\n    By default, ``basic_auth_protocol_factory`` creates a factory for building\n    :class:`BasicAuthWebSocketServerProtocol` instances. You can override this\n    with the ``create_protocol`` parameter.\n\n    :param realm: scope of protection\n    :param credentials: hard coded credentials\n    :param check_credentials: coroutine that verifies credentials\n    :raises TypeError: if the credentials argument has the wrong type\n\n    \"\"\"\n    if (credentials is None) == (check_credentials is None):\n        raise TypeError(\"provide either credentials or check_credentials\")\n\n    if credentials is not None:\n        if is_credentials(credentials):\n            credentials_list = [cast(Credentials, credentials)]\n        elif isinstance(credentials, Iterable):\n            credentials_list = list(credentials)\n            if not all(is_credentials(item) for item in credentials_list):\n                raise TypeError(f\"invalid credentials argument: {credentials}\")\n        else:\n            raise TypeError(f\"invalid credentials argument: {credentials}\")\n\n        credentials_dict = dict(credentials_list)\n\n        async def check_credentials(username: str, password: str) -> bool:\n            try:\n                expected_password = credentials_dict[username]\n            except KeyError:\n                return False\n            return hmac.compare_digest(expected_password, password)\n\n    if create_protocol is None:\n        # Not sure why mypy cannot figure this out.\n        create_protocol = cast(\n            Callable[[Any], BasicAuthWebSocketServerProtocol],\n            BasicAuthWebSocketServerProtocol,\n        )\n\n    return functools.partial(\n        create_protocol,\n        realm=realm,\n        check_credentials=check_credentials,\n    )\n", "import hmac\nimport unittest\nimport urllib.error\n\nfrom websockets.exceptions import InvalidStatusCode\nfrom websockets.headers import build_authorization_basic\nfrom websockets.legacy.auth import *\nfrom websockets.legacy.auth import is_credentials\n\nfrom .test_client_server import ClientServerTestsMixin, with_client, with_server\nfrom .utils import AsyncioTestCase\n\n\nclass AuthTests(unittest.TestCase):\n    def test_is_credentials(self):\n        self.assertTrue(is_credentials((\"username\", \"password\")))\n\n    def test_is_not_credentials(self):\n        self.assertFalse(is_credentials(None))\n        self.assertFalse(is_credentials(\"username\"))\n\n\nclass CustomWebSocketServerProtocol(BasicAuthWebSocketServerProtocol):\n    async def process_request(self, path, request_headers):\n        type(self).used = True\n        return await super().process_request(path, request_headers)\n\n\nclass AuthClientServerTests(ClientServerTestsMixin, AsyncioTestCase):\n\n    create_protocol = basic_auth_protocol_factory(\n        realm=\"auth-tests\", credentials=(\"hello\", \"iloveyou\")\n    )\n\n    @with_server(create_protocol=create_protocol)\n    @with_client(user_info=(\"hello\", \"iloveyou\"))\n    def test_basic_auth(self):\n        req_headers = self.client.request_headers\n        resp_headers = self.client.response_headers\n        self.assertEqual(req_headers[\"Authorization\"], \"Basic aGVsbG86aWxvdmV5b3U=\")\n        self.assertNotIn(\"WWW-Authenticate\", resp_headers)\n\n        self.loop.run_until_complete(self.client.send(\"Hello!\"))\n        self.loop.run_until_complete(self.client.recv())\n\n    def test_basic_auth_server_no_credentials(self):\n        with self.assertRaises(TypeError) as raised:\n            basic_auth_protocol_factory(realm=\"auth-tests\", credentials=None)\n        self.assertEqual(\n            str(raised.exception), \"provide either credentials or check_credentials\"\n        )\n\n    def test_basic_auth_server_bad_credentials(self):\n        with self.assertRaises(TypeError) as raised:\n            basic_auth_protocol_factory(realm=\"auth-tests\", credentials=42)\n        self.assertEqual(str(raised.exception), \"invalid credentials argument: 42\")\n\n    create_protocol_multiple_credentials = basic_auth_protocol_factory(\n        realm=\"auth-tests\",\n        credentials=[(\"hello\", \"iloveyou\"), (\"goodbye\", \"stillloveu\")],\n    )\n\n    @with_server(create_protocol=create_protocol_multiple_credentials)\n    @with_client(user_info=(\"hello\", \"iloveyou\"))\n    def test_basic_auth_server_multiple_credentials(self):\n        self.loop.run_until_complete(self.client.send(\"Hello!\"))\n        self.loop.run_until_complete(self.client.recv())\n\n    def test_basic_auth_bad_multiple_credentials(self):\n        with self.assertRaises(TypeError) as raised:\n            basic_auth_protocol_factory(\n                realm=\"auth-tests\", credentials=[(\"hello\", \"iloveyou\"), 42]\n            )\n        self.assertEqual(\n            str(raised.exception),\n            \"invalid credentials argument: [('hello', 'iloveyou'), 42]\",\n        )\n\n    async def check_credentials(username, password):\n        return hmac.compare_digest(password, \"iloveyou\")\n\n    create_protocol_check_credentials = basic_auth_protocol_factory(\n        realm=\"auth-tests\",\n        check_credentials=check_credentials,\n    )\n\n    @with_server(create_protocol=create_protocol_check_credentials)\n    @with_client(user_info=(\"hello\", \"iloveyou\"))\n    def test_basic_auth_check_credentials(self):\n        self.loop.run_until_complete(self.client.send(\"Hello!\"))\n        self.loop.run_until_complete(self.client.recv())\n\n    create_protocol_custom_protocol = basic_auth_protocol_factory(\n        realm=\"auth-tests\",\n        credentials=[(\"hello\", \"iloveyou\")],\n        create_protocol=CustomWebSocketServerProtocol,\n    )\n\n    @with_server(create_protocol=create_protocol_custom_protocol)\n    @with_client(user_info=(\"hello\", \"iloveyou\"))\n    def test_basic_auth_custom_protocol(self):\n        self.assertTrue(CustomWebSocketServerProtocol.used)\n        del CustomWebSocketServerProtocol.used\n        self.loop.run_until_complete(self.client.send(\"Hello!\"))\n        self.loop.run_until_complete(self.client.recv())\n\n    @with_server(create_protocol=create_protocol)\n    def test_basic_auth_missing_credentials(self):\n        with self.assertRaises(InvalidStatusCode) as raised:\n            self.start_client()\n        self.assertEqual(raised.exception.status_code, 401)\n\n    @with_server(create_protocol=create_protocol)\n    def test_basic_auth_missing_credentials_details(self):\n        with self.assertRaises(urllib.error.HTTPError) as raised:\n            self.loop.run_until_complete(self.make_http_request())\n        self.assertEqual(raised.exception.code, 401)\n        self.assertEqual(\n            raised.exception.headers[\"WWW-Authenticate\"],\n            'Basic realm=\"auth-tests\", charset=\"UTF-8\"',\n        )\n        self.assertEqual(raised.exception.read().decode(), \"Missing credentials\\n\")\n\n    @with_server(create_protocol=create_protocol)\n    def test_basic_auth_unsupported_credentials(self):\n        with self.assertRaises(InvalidStatusCode) as raised:\n            self.start_client(extra_headers={\"Authorization\": \"Digest ...\"})\n        self.assertEqual(raised.exception.status_code, 401)\n\n    @with_server(create_protocol=create_protocol)\n    def test_basic_auth_unsupported_credentials_details(self):\n        with self.assertRaises(urllib.error.HTTPError) as raised:\n            self.loop.run_until_complete(\n                self.make_http_request(headers={\"Authorization\": \"Digest ...\"})\n            )\n        self.assertEqual(raised.exception.code, 401)\n        self.assertEqual(\n            raised.exception.headers[\"WWW-Authenticate\"],\n            'Basic realm=\"auth-tests\", charset=\"UTF-8\"',\n        )\n        self.assertEqual(raised.exception.read().decode(), \"Unsupported credentials\\n\")\n\n    @with_server(create_protocol=create_protocol)\n    def test_basic_auth_invalid_username(self):\n        with self.assertRaises(InvalidStatusCode) as raised:\n            self.start_client(user_info=(\"goodbye\", \"iloveyou\"))\n        self.assertEqual(raised.exception.status_code, 401)\n\n    @with_server(create_protocol=create_protocol)\n    def test_basic_auth_invalid_password(self):\n        with self.assertRaises(InvalidStatusCode) as raised:\n            self.start_client(user_info=(\"hello\", \"ihateyou\"))\n        self.assertEqual(raised.exception.status_code, 401)\n\n    @with_server(create_protocol=create_protocol)\n    def test_basic_auth_invalid_credentials_details(self):\n        with self.assertRaises(urllib.error.HTTPError) as raised:\n            authorization = build_authorization_basic(\"hello\", \"ihateyou\")\n            self.loop.run_until_complete(\n                self.make_http_request(headers={\"Authorization\": authorization})\n            )\n        self.assertEqual(raised.exception.code, 401)\n        self.assertEqual(\n            raised.exception.headers[\"WWW-Authenticate\"],\n            'Basic realm=\"auth-tests\", charset=\"UTF-8\"',\n        )\n        self.assertEqual(raised.exception.read().decode(), \"Invalid credentials\\n\")\n"], "buggy_code_start_loc": [31, 8, 0], "buggy_code_end_loc": [31, 162, 144], "fixing_code_start_loc": [32, 9, 1], "fixing_code_end_loc": [38, 164, 151], "type": "CWE-203", "message": "The aaugustin websockets library before 9.1 for Python has an Observable Timing Discrepancy on servers when HTTP Basic Authentication is enabled with basic_auth_protocol_factory(credentials=...). An attacker may be able to guess a password via a timing attack.", "other": {"cve": {"id": "CVE-2021-33880", "sourceIdentifier": "cve@mitre.org", "published": "2021-06-06T15:15:07.407", "lastModified": "2022-05-12T14:07:03.327", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The aaugustin websockets library before 9.1 for Python has an Observable Timing Discrepancy on servers when HTTP Basic Authentication is enabled with basic_auth_protocol_factory(credentials=...). An attacker may be able to guess a password via a timing attack."}, {"lang": "es", "value": "La biblioteca aaugustin websockets versiones anteriores a 9.1, para Python presenta una Discrepancia de Sincronizaci\u00f3n Observable en servidores cuando la Autenticaci\u00f3n B\u00e1sica HTTP est\u00e1 habilitada con basic_auth_protocol_factory(credentials=...). Un atacante puede ser capaz de adivinar una contrase\u00f1a por medio de un ataque de sincronizaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6}, "baseSeverity": "LOW", "exploitabilityScore": 4.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:websockets_project:websockets:*:*:*:*:*:python:*:*", "versionEndExcluding": "9.1", "matchCriteriaId": "29051853-F65A-4735-9E59-4371D0A663A3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_policy:1.14.0:*:*:*:*:*:*:*", "matchCriteriaId": "4479F76A-4B67-41CC-98C7-C76B81050F8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_security_edge_protection_proxy:1.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "DAEB09CA-9352-43CD-AF66-92BE416E039C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_service_communication_proxy:1.14.0:*:*:*:*:*:*:*", "matchCriteriaId": "0AB059F2-FEC4-4180-8A90-39965495055E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_unified_data_repository:1.14.0:*:*:*:*:*:*:*", "matchCriteriaId": "5A276784-877B-4A29-A8F1-70518A438A9A"}]}]}], "references": [{"url": "https://github.com/aaugustin/websockets/commit/547a26b685d08cac0aa64e5e65f7867ac0ea9bc0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2022.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/aaugustin/websockets/commit/547a26b685d08cac0aa64e5e65f7867ac0ea9bc0"}}