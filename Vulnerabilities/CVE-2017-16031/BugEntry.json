{"buggy_code": ["/*!\n * socket.io-node\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar fs = require('fs')\n  , url = require('url')\n  , tty = require('tty')\n  , util = require('./util')\n  , store = require('./store')\n  , client = require('socket.io-client')\n  , transports = require('./transports')\n  , Logger = require('./logger')\n  , Socket = require('./socket')\n  , MemoryStore = require('./stores/memory')\n  , SocketNamespace = require('./namespace')\n  , Static = require('./static')\n  , EventEmitter = process.EventEmitter;\n\n/**\n * Export the constructor.\n */\n\nexports = module.exports = Manager;\n\n/**\n * Default transports.\n */\n\nvar defaultTransports = exports.defaultTransports = [\n    'websocket'\n  , 'htmlfile'\n  , 'xhr-polling'\n  , 'jsonp-polling'\n];\n\n/**\n * Inherited defaults.\n */\n\nvar parent = module.parent.exports\n  , protocol = parent.protocol\n  , jsonpolling_re = /^\\d+$/;\n\n/**\n * Manager constructor.\n *\n * @param {HTTPServer} server\n * @param {Object} options, optional\n * @api public\n */\n\nfunction Manager (server, options) {\n  this.server = server;\n  this.namespaces = {};\n  this.sockets = this.of('');\n  this.settings = {\n      origins: '*:*'\n    , log: true\n    , store: new MemoryStore\n    , logger: new Logger\n    , static: new Static(this)\n    , heartbeats: true\n    , resource: '/socket.io'\n    , transports: defaultTransports\n    , authorization: false\n    , blacklist: ['disconnect']\n    , 'log level': 3\n    , 'log colors': tty.isatty(process.stdout.fd)\n    , 'close timeout': 60\n    , 'heartbeat interval': 25\n    , 'heartbeat timeout': 60\n    , 'polling duration': 20\n    , 'flash policy server': true\n    , 'flash policy port': 10843\n    , 'destroy upgrade': true\n    , 'destroy buffer size': 10E7\n    , 'browser client': true\n    , 'browser client cache': true\n    , 'browser client minification': false\n    , 'browser client etag': false\n    , 'browser client expires': 315360000\n    , 'browser client gzip': false\n    , 'browser client handler': false\n    , 'client store expiration': 15\n    , 'match origin protocol': false\n  };\n\n  for (var i in options) {\n    this.settings[i] = options[i];\n  }\n\n  var self = this;\n\n  // default error handler\n  server.on('error', function(err) {\n    self.log.warn('error raised: ' + err);\n  });\n\n  this.initStore();\n\n  this.on('set:store', function() {\n    self.initStore();\n  });\n\n  // reset listeners\n  this.oldListeners = server.listeners('request').splice(0);\n\n  server.on('request', function (req, res) {\n    self.handleRequest(req, res);\n  });\n\n  server.on('upgrade', function (req, socket, head) {\n    self.handleUpgrade(req, socket, head);\n  });\n\n  server.on('close', function () {\n    clearInterval(self.gc);\n  });\n\n  server.once('listening', function () {\n    self.gc = setInterval(self.garbageCollection.bind(self), 10000);\n  });\n\n  for (var i in transports) {\n    if (transports[i].init) {\n      transports[i].init(this);\n    }\n  }\n\n  // forward-compatibility with 1.0\n  var self = this;\n  this.sockets.on('connection', function (conn) {\n    self.emit('connection', conn);\n  });\n\n  this.log.info('socket.io started');\n};\n\nManager.prototype.__proto__ = EventEmitter.prototype\n\n/**\n * Store accessor shortcut.\n *\n * @api public\n */\n\nManager.prototype.__defineGetter__('store', function () {\n  var store = this.get('store');\n  store.manager = this;\n  return store;\n});\n\n/**\n * Logger accessor.\n *\n * @api public\n */\n\nManager.prototype.__defineGetter__('log', function () {\n  var logger = this.get('logger');\n\n  logger.level = this.get('log level') || -1;\n  logger.colors = this.get('log colors');\n  logger.enabled = this.enabled('log');\n\n  return logger;\n});\n\n/**\n * Static accessor.\n *\n * @api public\n */\n\nManager.prototype.__defineGetter__('static', function () {\n  return this.get('static');\n});\n\n/**\n * Get settings.\n *\n * @api public\n */\n\nManager.prototype.get = function (key) {\n  return this.settings[key];\n};\n\n/**\n * Set settings\n *\n * @api public\n */\n\nManager.prototype.set = function (key, value) {\n  if (arguments.length == 1) return this.get(key);\n  this.settings[key] = value;\n  this.emit('set:' + key, this.settings[key], key);\n  return this;\n};\n\n/**\n * Enable a setting\n *\n * @api public\n */\n\nManager.prototype.enable = function (key) {\n  this.settings[key] = true;\n  this.emit('set:' + key, this.settings[key], key);\n  return this;\n};\n\n/**\n * Disable a setting\n *\n * @api public\n */\n\nManager.prototype.disable = function (key) {\n  this.settings[key] = false;\n  this.emit('set:' + key, this.settings[key], key);\n  return this;\n};\n\n/**\n * Checks if a setting is enabled\n *\n * @api public\n */\n\nManager.prototype.enabled = function (key) {\n  return !!this.settings[key];\n};\n\n/**\n * Checks if a setting is disabled\n *\n * @api public\n */\n\nManager.prototype.disabled = function (key) {\n  return !this.settings[key];\n};\n\n/**\n * Configure callbacks.\n *\n * @api public\n */\n\nManager.prototype.configure = function (env, fn) {\n  if ('function' == typeof env) {\n    env.call(this);\n  } else if (env == (process.env.NODE_ENV || 'development')) {\n    fn.call(this);\n  }\n\n  return this;\n};\n\n/**\n * Initializes everything related to the message dispatcher.\n *\n * @api private\n */\n\nManager.prototype.initStore = function () {\n  this.handshaken = {};\n  this.connected = {};\n  this.open = {};\n  this.closed = {};\n  this.rooms = {};\n  this.roomClients = {};\n\n  var self = this;\n\n  this.store.subscribe('handshake', function (id, data) {\n    self.onHandshake(id, data);\n  });\n\n  this.store.subscribe('connect', function (id) {\n    self.onConnect(id);\n  });\n\n  this.store.subscribe('open', function (id) {\n    self.onOpen(id);\n  });\n\n  this.store.subscribe('join', function (id, room) {\n    self.onJoin(id, room);\n  });\n\n  this.store.subscribe('leave', function (id, room) {\n    self.onLeave(id, room);\n  });\n\n  this.store.subscribe('close', function (id) {\n    self.onClose(id);\n  });\n\n  this.store.subscribe('dispatch', function (room, packet, volatile, exceptions) {\n    self.onDispatch(room, packet, volatile, exceptions);\n  });\n\n  this.store.subscribe('disconnect', function (id) {\n    self.onDisconnect(id);\n  });\n};\n\n/**\n * Called when a client handshakes.\n *\n * @param text\n */\n\nManager.prototype.onHandshake = function (id, data) {\n  this.handshaken[id] = data;\n};\n\n/**\n * Called when a client connects (ie: transport first opens)\n *\n * @api private\n */\n\nManager.prototype.onConnect = function (id) {\n  this.connected[id] = true;\n};\n\n/**\n * Called when a client opens a request in a different node.\n *\n * @api private\n */\n\nManager.prototype.onOpen = function (id) {\n  this.open[id] = true;\n\n  if (this.closed[id]) {\n    var self = this;\n\n    this.store.unsubscribe('dispatch:' + id, function () {\n      var transport = self.transports[id];\n      if (self.closed[id] && self.closed[id].length && transport) {\n\n        // if we have buffered messages that accumulate between calling\n        // onOpen an this async callback, send them if the transport is \n        // still open, otherwise leave them buffered\n        if (transport.open) {\n          transport.payload(self.closed[id]);\n          self.closed[id] = [];\n        }\n      }\n    });\n  }\n\n  // clear the current transport\n  if (this.transports[id]) {\n    this.transports[id].discard();\n    this.transports[id] = null;\n  }\n};\n\n/**\n * Called when a message is sent to a namespace and/or room.\n *\n * @api private\n */\n\nManager.prototype.onDispatch = function (room, packet, volatile, exceptions) {\n  if (this.rooms[room]) {\n    for (var i = 0, l = this.rooms[room].length; i < l; i++) {\n      var id = this.rooms[room][i];\n\n      if (!~exceptions.indexOf(id)) {\n        if (this.transports[id] && this.transports[id].open) {\n          this.transports[id].onDispatch(packet, volatile);\n        } else if (!volatile) {\n          this.onClientDispatch(id, packet);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Called when a client joins a nsp / room.\n *\n * @api private\n */\n\nManager.prototype.onJoin = function (id, name) {\n  if (!this.roomClients[id]) {\n    this.roomClients[id] = {};\n  }\n\n  if (!this.rooms[name]) {\n    this.rooms[name] = [];\n  }\n\n  if (!~this.rooms[name].indexOf(id)) {\n    this.rooms[name].push(id);\n    this.roomClients[id][name] = true;\n  }\n};\n\n/**\n * Called when a client leaves a nsp / room.\n *\n * @param private\n */\n\nManager.prototype.onLeave = function (id, room) {\n  if (this.rooms[room]) {\n    var index = this.rooms[room].indexOf(id);\n\n    if (index >= 0) {\n      this.rooms[room].splice(index, 1);\n    }\n\n    if (!this.rooms[room].length) {\n      delete this.rooms[room];\n    }\n    delete this.roomClients[id][room];\n  }\n};\n\n/**\n * Called when a client closes a request in different node.\n *\n * @api private\n */\n\nManager.prototype.onClose = function (id) {\n  if (this.open[id]) {\n    delete this.open[id];\n  }\n\n  this.closed[id] = [];\n\n  var self = this;\n\n  this.store.subscribe('dispatch:' + id, function (packet, volatile) {\n    if (!volatile) {\n      self.onClientDispatch(id, packet);\n    }\n  });\n};\n\n/**\n * Dispatches a message for a closed client.\n *\n * @api private\n */\n\nManager.prototype.onClientDispatch = function (id, packet) {\n  if (this.closed[id]) {\n    this.closed[id].push(packet);\n  }\n};\n\n/**\n * Receives a message for a client.\n *\n * @api private\n */\n\nManager.prototype.onClientMessage = function (id, packet) {\n  if (this.namespaces[packet.endpoint]) {\n    this.namespaces[packet.endpoint].handlePacket(id, packet);\n  }\n};\n\n/**\n * Fired when a client disconnects (not triggered).\n *\n * @api private\n */\n\nManager.prototype.onClientDisconnect = function (id, reason) {\n  for (var name in this.namespaces) {\n    this.namespaces[name].handleDisconnect(id, reason, typeof this.roomClients[id] !== 'undefined' &&\n      typeof this.roomClients[id][name] !== 'undefined');\n  }\n\n  this.onDisconnect(id);\n};\n\n/**\n * Called when a client disconnects.\n *\n * @param text\n */\n\nManager.prototype.onDisconnect = function (id, local) {\n  delete this.handshaken[id];\n\n  if (this.open[id]) {\n    delete this.open[id];\n  }\n\n  if (this.connected[id]) {\n    delete this.connected[id];\n  }\n\n  if (this.transports[id]) {\n    this.transports[id].discard();\n    delete this.transports[id];\n  }\n\n  if (this.closed[id]) {\n    delete this.closed[id];\n  }\n\n  if (this.roomClients[id]) {\n    for (var room in this.roomClients[id]) {\n      this.onLeave(id, room);\n    }\n    delete this.roomClients[id]\n  }\n\n  this.store.destroyClient(id, this.get('client store expiration'));\n\n  this.store.unsubscribe('dispatch:' + id);\n\n  if (local) {\n    this.store.unsubscribe('message:' + id);\n    this.store.unsubscribe('disconnect:' + id);\n  }\n};\n\n/**\n * Handles an HTTP request.\n *\n * @api private\n */\n\nManager.prototype.handleRequest = function (req, res) {\n  var data = this.checkRequest(req);\n\n  if (!data) {\n    for (var i = 0, l = this.oldListeners.length; i < l; i++) {\n      this.oldListeners[i].call(this.server, req, res);\n    }\n\n    return;\n  }\n\n  if (data.static || !data.transport && !data.protocol) {\n    if (data.static && this.enabled('browser client')) {\n      this.static.write(data.path, req, res);\n    } else {\n      res.writeHead(200);\n      res.end('Welcome to socket.io.');\n\n      this.log.info('unhandled socket.io url');\n    }\n\n    return;\n  }\n\n  if (data.protocol != protocol) {\n    res.writeHead(500);\n    res.end('Protocol version not supported.');\n\n    this.log.info('client protocol version unsupported');\n  } else {\n    if (data.id) {\n      this.handleHTTPRequest(data, req, res);\n    } else {\n      this.handleHandshake(data, req, res);\n    }\n  }\n};\n\n/**\n * Handles an HTTP Upgrade.\n *\n * @api private\n */\n\nManager.prototype.handleUpgrade = function (req, socket, head) {\n  var data = this.checkRequest(req)\n    , self = this;\n\n  if (!data) {\n    if (this.enabled('destroy upgrade')) {\n      socket.end();\n      this.log.debug('destroying non-socket.io upgrade');\n    }\n\n    return;\n  }\n\n  req.head = head;\n  this.handleClient(data, req);\n};\n\n/**\n * Handles a normal handshaken HTTP request (eg: long-polling)\n *\n * @api private\n */\n\nManager.prototype.handleHTTPRequest = function (data, req, res) {\n  req.res = res;\n  this.handleClient(data, req);\n};\n\n/**\n * Intantiantes a new client.\n *\n * @api private\n */\n\nManager.prototype.handleClient = function (data, req) {\n  var socket = req.socket\n    , store = this.store\n    , self = this;\n\n  if (undefined != data.query.disconnect) {\n    if (this.transports[data.id] && this.transports[data.id].open) {\n      this.transports[data.id].onForcedDisconnect();\n    } else {\n      this.store.publish('disconnect-force:' + data.id);\n    }\n    return;\n  }\n\n  if (!~this.get('transports').indexOf(data.transport)) {\n    this.log.warn('unknown transport: \"' + data.transport + '\"');\n    req.connection.end();\n    return;\n  }\n\n  var transport = new transports[data.transport](this, data, req)\n    , handshaken = this.handshaken[data.id];\n\n  if (transport.disconnected) {\n    // failed during transport setup\n    req.connection.end();\n    return;\n  }\n  if (handshaken) {\n    if (transport.open) {\n      if (this.closed[data.id] && this.closed[data.id].length) {\n        transport.payload(this.closed[data.id]);\n        this.closed[data.id] = [];\n      }\n\n      this.onOpen(data.id);\n      this.store.publish('open', data.id);\n      this.transports[data.id] = transport;\n    }\n\n    if (!this.connected[data.id]) {\n      this.onConnect(data.id);\n      this.store.publish('connect', data.id);\n\n      // flag as used\n      delete handshaken.issued;\n      this.onHandshake(data.id, handshaken);\n      this.store.publish('handshake', data.id, handshaken);\n\n      // initialize the socket for all namespaces\n      for (var i in this.namespaces) {\n        var socket = this.namespaces[i].socket(data.id, true);\n\n        // echo back connect packet and fire connection event\n        if (i === '') {\n          this.namespaces[i].handlePacket(data.id, { type: 'connect' });\n        }\n      }\n\n      this.store.subscribe('message:' + data.id, function (packet) {\n        self.onClientMessage(data.id, packet);\n      });\n\n      this.store.subscribe('disconnect:' + data.id, function (reason) {\n        self.onClientDisconnect(data.id, reason);\n      });\n    }\n  } else {\n    if (transport.open) {\n      transport.error('client not handshaken', 'reconnect');\n    }\n\n    transport.discard();\n  }\n};\n\n/**\n * Generates a session id.\n *\n * @api private\n */\n\nManager.prototype.generateId = function () {\n  return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString()\n    + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();\n};\n\n/**\n * Handles a handshake request.\n *\n * @api private\n */\n\nManager.prototype.handleHandshake = function (data, req, res) {\n  var self = this\n    , origin = req.headers.origin\n    , headers = {\n        'Content-Type': 'text/plain'\n    };\n\n  function writeErr (status, message) {\n    if (data.query.jsonp && jsonpolling_re.test(data.query.jsonp)) {\n      res.writeHead(200, { 'Content-Type': 'application/javascript' });\n      res.end('io.j[' + data.query.jsonp + '](new Error(\"' + message + '\"));');\n    } else {\n      res.writeHead(status, headers);\n      res.end(message);\n    }\n  };\n\n  function error (err) {\n    writeErr(500, 'handshake error');\n    self.log.warn('handshake error ' + err);\n  };\n\n  if (!this.verifyOrigin(req)) {\n    writeErr(403, 'handshake bad origin');\n    return;\n  }\n\n  var handshakeData = this.handshakeData(data);\n\n  if (origin) {\n    // https://developer.mozilla.org/En/HTTP_Access_Control\n    headers['Access-Control-Allow-Origin'] = origin;\n    headers['Access-Control-Allow-Credentials'] = 'true';\n  }\n\n  this.authorize(handshakeData, function (err, authorized, newData) {\n    if (err) return error(err);\n\n    if (authorized) {\n      var id = self.generateId()\n        , hs = [\n              id\n            , self.enabled('heartbeats') ? self.get('heartbeat timeout') || '' : ''\n            , self.get('close timeout') || ''\n            , self.transports(data).join(',')\n          ].join(':');\n\n      if (data.query.jsonp && jsonpolling_re.test(data.query.jsonp)) {\n        hs = 'io.j[' + data.query.jsonp + '](' + JSON.stringify(hs) + ');';\n        res.writeHead(200, { 'Content-Type': 'application/javascript' });\n      } else {\n        res.writeHead(200, headers);\n      }\n\n      res.end(hs);\n\n      self.onHandshake(id, newData || handshakeData);\n      self.store.publish('handshake', id, newData || handshakeData);\n\n      self.log.info('handshake authorized', id);\n    } else {\n      writeErr(403, 'handshake unauthorized');\n      self.log.info('handshake unauthorized');\n    }\n  })\n};\n\n/**\n * Gets normalized handshake data\n *\n * @api private\n */\n\nManager.prototype.handshakeData = function (data) {\n  var connection = data.request.connection\n    , connectionAddress\n    , date = new Date;\n\n  if (connection.remoteAddress) {\n    connectionAddress = {\n        address: connection.remoteAddress\n      , port: connection.remotePort\n    };\n  } else if (connection.socket && connection.socket.remoteAddress) {\n    connectionAddress = {\n        address: connection.socket.remoteAddress\n      , port: connection.socket.remotePort\n    };\n  }\n\n  return {\n      headers: data.headers\n    , address: connectionAddress\n    , time: date.toString()\n    , query: data.query\n    , url: data.request.url\n    , xdomain: !!data.request.headers.origin\n    , secure: data.request.connection.secure\n    , issued: +date\n  };\n};\n\n/**\n * Verifies the origin of a request.\n *\n * @api private\n */\n\nManager.prototype.verifyOrigin = function (request) {\n  var origin = request.headers.origin || request.headers.referer\n    , origins = this.get('origins');\n\n  if (origin === 'null') origin = '*';\n\n  if (origins.indexOf('*:*') !== -1) {\n    return true;\n  }\n\n  if (origin) {\n    try {\n      var parts = url.parse(origin);\n      parts.port = parts.port || 80;\n      var ok =\n        ~origins.indexOf(parts.hostname + ':' + parts.port) ||\n        ~origins.indexOf(parts.hostname + ':*') ||\n        ~origins.indexOf('*:' + parts.port);\n      if (!ok) this.log.warn('illegal origin: ' + origin);\n      return ok;\n    } catch (ex) {\n      this.log.warn('error parsing origin');\n    }\n  }\n  else {\n    this.log.warn('origin missing from handshake, yet required by config');\n  }\n  return false;\n};\n\n/**\n * Handles an incoming packet.\n *\n * @api private\n */\n\nManager.prototype.handlePacket = function (sessid, packet) {\n  this.of(packet.endpoint || '').handlePacket(sessid, packet);\n};\n\n/**\n * Performs authentication.\n *\n * @param Object client request data\n * @api private\n */\n\nManager.prototype.authorize = function (data, fn) {\n  if (this.get('authorization')) {\n    var self = this;\n\n    this.get('authorization').call(this, data, function (err, authorized) {\n      self.log.debug('client ' + authorized ? 'authorized' : 'unauthorized');\n      fn(err, authorized);\n    });\n  } else {\n    this.log.debug('client authorized');\n    fn(null, true);\n  }\n\n  return this;\n};\n\n/**\n * Retrieves the transports adviced to the user.\n *\n * @api private\n */\n\nManager.prototype.transports = function (data) {\n  var transp = this.get('transports')\n    , ret = [];\n\n  for (var i = 0, l = transp.length; i < l; i++) {\n    var transport = transp[i];\n\n    if (transport) {\n      if (!transport.checkClient || transport.checkClient(data)) {\n        ret.push(transport);\n      }\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Checks whether a request is a socket.io one.\n *\n * @return {Object} a client request data object or `false`\n * @api private\n */\n\nvar regexp = /^\\/([^\\/]+)\\/?([^\\/]+)?\\/?([^\\/]+)?\\/?$/\n\nManager.prototype.checkRequest = function (req) {\n  var resource = this.get('resource');\n\n  var match;\n  if (typeof resource === 'string') {\n    match = req.url.substr(0, resource.length);\n    if (match !== resource) match = null;\n  } else {\n    match = resource.exec(req.url);\n    if (match) match = match[0];\n  }\n\n  if (match) {\n    var uri = url.parse(req.url.substr(match.length), true)\n      , path = uri.pathname || ''\n      , pieces = path.match(regexp);\n\n    // client request data\n    var data = {\n        query: uri.query || {}\n      , headers: req.headers\n      , request: req\n      , path: path\n    };\n\n    if (pieces) {\n      data.protocol = Number(pieces[1]);\n      data.transport = pieces[2];\n      data.id = pieces[3];\n      data.static = !!this.static.has(path);\n    };\n\n    return data;\n  }\n\n  return false;\n};\n\n/**\n * Declares a socket namespace\n *\n * @api public\n */\n\nManager.prototype.of = function (nsp) {\n  if (this.namespaces[nsp]) {\n    return this.namespaces[nsp];\n  }\n\n  return this.namespaces[nsp] = new SocketNamespace(this, nsp);\n};\n\n/**\n * Perform garbage collection on long living objects and properties that cannot\n * be removed automatically.\n *\n * @api private\n */\n\nManager.prototype.garbageCollection = function () {\n  // clean up unused handshakes\n  var ids = Object.keys(this.handshaken)\n    , i = ids.length\n    , now = Date.now()\n    , handshake;\n\n  while (i--) {\n    handshake = this.handshaken[ids[i]];\n\n    if ('issued' in handshake && (now - handshake.issued) >= 3E4) {\n      this.onDisconnect(ids[i]);\n    }\n  }\n};\n", "/*!\n * socket.io-node\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Test dependencies.\n */\n\nvar sio = require('../')\n  , http = require('http')\n  , should = require('./common')\n  , ports = 15100;\n\n/**\n * Test.\n */\n\nmodule.exports = {\n\n  'test setting and getting a configuration flag': function (done) {\n    var port = ++ports\n      , io = sio.listen(http.createServer());\n\n    io.set('a', 'b');\n    io.get('a').should.eql('b');\n\n    var port = ++ports\n      , io = sio.listen(http.createServer());\n\n    io.configure(function () {\n      io.set('a', 'b');\n      io.enable('tobi');\n    });\n\n    io.get('a').should.eql('b');\n\n    done();\n  },\n\n  'test enabling and disabling a configuration flag': function (done) {\n    var port = ++ports\n      , io = sio.listen(http.createServer());\n\n    io.enable('flag');\n    io.enabled('flag').should.be.true;\n    io.disabled('flag').should.be.false;\n\n    io.disable('flag');\n    var port = ++ports\n      , io = sio.listen(http.createServer());\n\n    io.configure(function () {\n      io.enable('tobi');\n    });\n\n    io.enabled('tobi').should.be.true;\n\n    done();\n  },\n\n  'test configuration callbacks with envs': function (done) {\n    var port = ++ports\n      , io = sio.listen(http.createServer());\n\n    process.env.NODE_ENV = 'development';\n\n    io.configure('production', function () {\n      io.set('ferret', 'tobi');\n    });\n\n    io.configure('development', function () {\n      io.set('ferret', 'jane');\n    });\n\n    io.get('ferret').should.eql('jane');\n    done();\n  },\n\n  'test configuration callbacks conserve scope': function (done) {\n    var port = ++ports\n      , io = sio.listen(http.createServer())\n      , calls = 0;\n\n    process.env.NODE_ENV = 'development';\n\n    io.configure(function () {\n      this.should.eql(io);\n      calls++;\n    });\n\n    io.configure('development', function () {\n      this.should.eql(io);\n      calls++;\n    });\n\n    calls.should.eql(2);\n    done();\n  },\n\n  'test configuration update notifications': function (done) {\n    var port = ++ports\n      , io = sio.listen(http.createServer())\n      , calls = 0;\n\n    io.on('set:foo', function () {\n      calls++;\n    });\n\n    io.set('foo', 'bar');\n    io.set('baz', 'bar');\n\n    calls.should.eql(1);\n\n    io.enable('foo');\n    io.disable('foo');\n\n    calls.should.eql(3);\n\n    done();\n  },\n\n  'test that normal requests are still served': function (done) {\n    var server = http.createServer(function (req, res) {\n      res.writeHead(200);\n      res.end('woot');\n    });\n\n    var io = sio.listen(server)\n      , port = ++ports\n      , cl = client(port);\n\n    server.listen(ports);\n\n    cl.get('/socket.io', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.eql('Welcome to socket.io.');\n\n      cl.get('/woot', function (res, data) {\n        res.statusCode.should.eql(200);\n        data.should.eql('woot');\n\n        cl.end();\n        server.close();\n        done();\n      });\n    });\n  },\n\n  'test that you can disable clients': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.disable('browser client');\n    });\n\n    cl.get('/socket.io/socket.io.js', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.eql('Welcome to socket.io.');\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test handshake': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.match(/([^:]+):([0-9]+)?:([0-9]+)?:(.+)/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test handshake with unsupported protocol version': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    cl.get('/socket.io/-1/', function (res, data) {\n      res.statusCode.should.eql(500);\n      data.should.match(/Protocol version not supported/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test authorization failure in handshake': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      function auth (data, fn) {\n        fn(null, false);\n      };\n\n      io.set('authorization', auth);\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(403);\n      data.should.match(/handshake unauthorized/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test a handshake error': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      function auth (data, fn) {\n        fn(new Error);\n      };\n\n      io.set('authorization', auth);\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(500);\n      data.should.match(/handshake error/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test that a referer is accepted for *:* origin': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('origins', '*:*');\n    });\n\n    cl.get('/socket.io/{protocol}', { headers: { referer: 'http://foo.bar.com:82/something' } }, function (res, data) {\n      res.statusCode.should.eql(200);\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test that valid referer is accepted for addr:* origin': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('origins', 'foo.bar.com:*');\n    });\n\n    cl.get('/socket.io/{protocol}', { headers: { referer: 'http://foo.bar.com/something' } }, function (res, data) {\n      res.statusCode.should.eql(200);\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test that a referer with implicit port 80 is accepted for foo.bar.com:80 origin': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('origins', 'foo.bar.com:80');\n    });\n\n    cl.get('/socket.io/{protocol}', { headers: { referer: 'http://foo.bar.com/something' } }, function (res, data) {\n      res.statusCode.should.eql(200);\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test that erroneous referer is denied for addr:* origin': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('origins', 'foo.bar.com:*');\n    });\n\n    cl.get('/socket.io/{protocol}', { headers: { referer: 'http://baz.bar.com/something' } }, function (res, data) {\n      res.statusCode.should.eql(403);\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test that valid referer port is accepted for addr:port origin': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('origins', 'foo.bar.com:81');\n    });\n\n    cl.get('/socket.io/{protocol}', { headers: { referer: 'http://foo.bar.com:81/something' } }, function (res, data) {\n      res.statusCode.should.eql(200);\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test that erroneous referer port is denied for addr:port origin': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('origins', 'foo.bar.com:81');\n    });\n\n    cl.get('/socket.io/{protocol}', { headers: { referer: 'http://foo.bar.com/something' } }, function (res, data) {\n      res.statusCode.should.eql(403);\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test handshake cross domain access control': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port)\n      , headers = {\n            Origin: 'http://example.org:1337'\n          , Cookie: 'name=value'\n        };\n\n    cl.get('/socket.io/{protocol}/', { headers:headers }, function (res, data) {\n      res.statusCode.should.eql(200);\n      res.headers['access-control-allow-origin'].should.eql('http://example.org:1337');\n      res.headers['access-control-allow-credentials'].should.eql('true');\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test limiting the supported transports for a manager': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('transports', ['tobi', 'jane']);\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.match(/([^:]+):([0-9]+)?:([0-9]+)?:tobi,jane/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test setting a custom close timeout': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('close timeout', 66);\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.match(/([^:]+):([0-9]+)?:66?:(.*)/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test setting a custom heartbeat timeout': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('heartbeat timeout', 33);\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.match(/([^:]+):33:([0-9]+)?:(.*)/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test disabling timeouts': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('heartbeat timeout', null);\n      io.set('close timeout', '');\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.match(/([^:]+)::?:(.*)/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test disabling heartbeats': function (done) {\n    var port = ++ports\n      , cl = client(port)\n      , io = create(cl)\n      , messages = 0\n      , beat = false\n      , ws;\n\n    io.configure(function () {\n      io.disable('heartbeats');\n      io.set('heartbeat interval', .05);\n      io.set('heartbeat timeout', .05);\n      io.set('close timeout', .05);\n    });\n\n    io.sockets.on('connection', function (socket) {\n      setTimeout(function () {\n        socket.disconnect();\n      }, io.get('heartbeat timeout') * 1000 + 100);\n\n      socket.on('disconnect', function (reason) {\n        beat.should.be.false;\n        ws.finishClose();\n        cl.end();\n        io.server.close();\n        done();\n      });\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.match(/([^:]+)::[\\.0-9]+:(.*)/);\n\n      cl.handshake(function (sid) {\n        ws = websocket(cl, sid);\n        ws.on('message', function (packet) {\n          if (++messages == 1) {\n            packet.type.should.eql('connect');\n          } else if (packet.type == 'heartbeat'){\n            beat = true;\n          }\n        });\n      });\n    });\n  },\n\n  'no duplicate room members': function (done) {\n    var port = ++ports\n      , io = sio.listen(port);\n\n    Object.keys(io.rooms).length.should.equal(0);\n\n    io.onJoin(123, 'foo');\n    io.rooms.foo.length.should.equal(1);\n\n    io.onJoin(123, 'foo');\n    io.rooms.foo.length.should.equal(1);\n\n    io.onJoin(124, 'foo');\n    io.rooms.foo.length.should.equal(2);\n\n    io.onJoin(124, 'foo');\n    io.rooms.foo.length.should.equal(2);\n\n    io.onJoin(123, 'bar');\n    io.rooms.foo.length.should.equal(2);\n    io.rooms.bar.length.should.equal(1);\n\n    io.onJoin(123, 'bar');\n    io.rooms.foo.length.should.equal(2);\n    io.rooms.bar.length.should.equal(1);\n\n    io.onJoin(124, 'bar');\n    io.rooms.foo.length.should.equal(2);\n    io.rooms.bar.length.should.equal(2);\n\n    io.onJoin(124, 'bar');\n    io.rooms.foo.length.should.equal(2);\n    io.rooms.bar.length.should.equal(2);\n\n    process.nextTick(function() {\n      io.server.close();\n      done();\n    });\n  },\n\n  'test passing options directly to the Manager through listen': function (done) {\n    var port = ++ports\n      , io = sio.listen(port, { resource: '/my resource', custom: 'opt' });\n\n    io.get('resource').should.equal('/my resource');\n    io.get('custom').should.equal('opt');\n    process.nextTick(function() {\n      io.server.close();\n      done();\n    });\n  },\n\n  'test disabling the log': function (done) {\n    var port = ++ports\n      , io = sio.listen(port, { log: false })\n      , _console = console.log\n      , calls = 0;\n\n    // the logger uses console.log to output data, override it to see if get's\n    // used\n    console.log = function () { ++calls };\n\n    io.log.debug('test');\n    io.log.log('testing');\n\n    console.log = _console;\n    calls.should.equal(0);\n\n    process.nextTick(function() {\n      io.server.close();\n      done();\n    });\n  },\n\n  'test disabling logging with colors': function (done) {\n     var port = ++ports\n      , io = sio.listen(port, { 'log colors': false })\n      , _console = console.log\n      , calls = 0;\n\n    // the logger uses console.log to output data, override it to see if get's\n    // used\n    console.log = function (data) {\n      ++calls;\n      data.indexOf('\\033').should.equal(-1);\n    };\n\n    io.log.debug('test');\n    io.log.log('testing');\n\n    console.log = _console;\n    calls.should.equal(2);\n\n    process.nextTick(function() {\n      io.server.close();\n      done();\n    });\n  }\n};\n"], "fixing_code": ["/*!\n * socket.io-node\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar fs = require('fs')\n  , url = require('url')\n  , tty = require('tty')\n  , crypto = require('crypto')\n  , util = require('./util')\n  , store = require('./store')\n  , client = require('socket.io-client')\n  , transports = require('./transports')\n  , Logger = require('./logger')\n  , Socket = require('./socket')\n  , MemoryStore = require('./stores/memory')\n  , SocketNamespace = require('./namespace')\n  , Static = require('./static')\n  , EventEmitter = process.EventEmitter;\n\n/**\n * Export the constructor.\n */\n\nexports = module.exports = Manager;\n\n/**\n * Default transports.\n */\n\nvar defaultTransports = exports.defaultTransports = [\n    'websocket'\n  , 'htmlfile'\n  , 'xhr-polling'\n  , 'jsonp-polling'\n];\n\n/**\n * Inherited defaults.\n */\n\nvar parent = module.parent.exports\n  , protocol = parent.protocol\n  , jsonpolling_re = /^\\d+$/;\n\n/**\n * Manager constructor.\n *\n * @param {HTTPServer} server\n * @param {Object} options, optional\n * @api public\n */\n\nfunction Manager (server, options) {\n  this.server = server;\n  this.namespaces = {};\n  this.sockets = this.of('');\n  this.settings = {\n      origins: '*:*'\n    , log: true\n    , store: new MemoryStore\n    , logger: new Logger\n    , static: new Static(this)\n    , heartbeats: true\n    , resource: '/socket.io'\n    , transports: defaultTransports\n    , authorization: false\n    , blacklist: ['disconnect']\n    , 'log level': 3\n    , 'log colors': tty.isatty(process.stdout.fd)\n    , 'close timeout': 60\n    , 'heartbeat interval': 25\n    , 'heartbeat timeout': 60\n    , 'polling duration': 20\n    , 'flash policy server': true\n    , 'flash policy port': 10843\n    , 'destroy upgrade': true\n    , 'destroy buffer size': 10E7\n    , 'browser client': true\n    , 'browser client cache': true\n    , 'browser client minification': false\n    , 'browser client etag': false\n    , 'browser client expires': 315360000\n    , 'browser client gzip': false\n    , 'browser client handler': false\n    , 'client store expiration': 15\n    , 'match origin protocol': false\n  };\n\n  for (var i in options) {\n    this.settings[i] = options[i];\n  }\n\n  var self = this;\n\n  // default error handler\n  server.on('error', function(err) {\n    self.log.warn('error raised: ' + err);\n  });\n\n  this.initStore();\n\n  this.on('set:store', function() {\n    self.initStore();\n  });\n\n  // reset listeners\n  this.oldListeners = server.listeners('request').splice(0);\n\n  server.on('request', function (req, res) {\n    self.handleRequest(req, res);\n  });\n\n  server.on('upgrade', function (req, socket, head) {\n    self.handleUpgrade(req, socket, head);\n  });\n\n  server.on('close', function () {\n    clearInterval(self.gc);\n  });\n\n  server.once('listening', function () {\n    self.gc = setInterval(self.garbageCollection.bind(self), 10000);\n  });\n\n  for (var i in transports) {\n    if (transports[i].init) {\n      transports[i].init(this);\n    }\n  }\n\n  // forward-compatibility with 1.0\n  var self = this;\n  this.sockets.on('connection', function (conn) {\n    self.emit('connection', conn);\n  });\n\n  this.sequenceNumber = Date.now() | 0;\n \n  this.log.info('socket.io started');\n};\n\nManager.prototype.__proto__ = EventEmitter.prototype\n\n/**\n * Store accessor shortcut.\n *\n * @api public\n */\n\nManager.prototype.__defineGetter__('store', function () {\n  var store = this.get('store');\n  store.manager = this;\n  return store;\n});\n\n/**\n * Logger accessor.\n *\n * @api public\n */\n\nManager.prototype.__defineGetter__('log', function () {\n  var logger = this.get('logger');\n\n  logger.level = this.get('log level') || -1;\n  logger.colors = this.get('log colors');\n  logger.enabled = this.enabled('log');\n\n  return logger;\n});\n\n/**\n * Static accessor.\n *\n * @api public\n */\n\nManager.prototype.__defineGetter__('static', function () {\n  return this.get('static');\n});\n\n/**\n * Get settings.\n *\n * @api public\n */\n\nManager.prototype.get = function (key) {\n  return this.settings[key];\n};\n\n/**\n * Set settings\n *\n * @api public\n */\n\nManager.prototype.set = function (key, value) {\n  if (arguments.length == 1) return this.get(key);\n  this.settings[key] = value;\n  this.emit('set:' + key, this.settings[key], key);\n  return this;\n};\n\n/**\n * Enable a setting\n *\n * @api public\n */\n\nManager.prototype.enable = function (key) {\n  this.settings[key] = true;\n  this.emit('set:' + key, this.settings[key], key);\n  return this;\n};\n\n/**\n * Disable a setting\n *\n * @api public\n */\n\nManager.prototype.disable = function (key) {\n  this.settings[key] = false;\n  this.emit('set:' + key, this.settings[key], key);\n  return this;\n};\n\n/**\n * Checks if a setting is enabled\n *\n * @api public\n */\n\nManager.prototype.enabled = function (key) {\n  return !!this.settings[key];\n};\n\n/**\n * Checks if a setting is disabled\n *\n * @api public\n */\n\nManager.prototype.disabled = function (key) {\n  return !this.settings[key];\n};\n\n/**\n * Configure callbacks.\n *\n * @api public\n */\n\nManager.prototype.configure = function (env, fn) {\n  if ('function' == typeof env) {\n    env.call(this);\n  } else if (env == (process.env.NODE_ENV || 'development')) {\n    fn.call(this);\n  }\n\n  return this;\n};\n\n/**\n * Initializes everything related to the message dispatcher.\n *\n * @api private\n */\n\nManager.prototype.initStore = function () {\n  this.handshaken = {};\n  this.connected = {};\n  this.open = {};\n  this.closed = {};\n  this.rooms = {};\n  this.roomClients = {};\n\n  var self = this;\n\n  this.store.subscribe('handshake', function (id, data) {\n    self.onHandshake(id, data);\n  });\n\n  this.store.subscribe('connect', function (id) {\n    self.onConnect(id);\n  });\n\n  this.store.subscribe('open', function (id) {\n    self.onOpen(id);\n  });\n\n  this.store.subscribe('join', function (id, room) {\n    self.onJoin(id, room);\n  });\n\n  this.store.subscribe('leave', function (id, room) {\n    self.onLeave(id, room);\n  });\n\n  this.store.subscribe('close', function (id) {\n    self.onClose(id);\n  });\n\n  this.store.subscribe('dispatch', function (room, packet, volatile, exceptions) {\n    self.onDispatch(room, packet, volatile, exceptions);\n  });\n\n  this.store.subscribe('disconnect', function (id) {\n    self.onDisconnect(id);\n  });\n};\n\n/**\n * Called when a client handshakes.\n *\n * @param text\n */\n\nManager.prototype.onHandshake = function (id, data) {\n  this.handshaken[id] = data;\n};\n\n/**\n * Called when a client connects (ie: transport first opens)\n *\n * @api private\n */\n\nManager.prototype.onConnect = function (id) {\n  this.connected[id] = true;\n};\n\n/**\n * Called when a client opens a request in a different node.\n *\n * @api private\n */\n\nManager.prototype.onOpen = function (id) {\n  this.open[id] = true;\n\n  if (this.closed[id]) {\n    var self = this;\n\n    this.store.unsubscribe('dispatch:' + id, function () {\n      var transport = self.transports[id];\n      if (self.closed[id] && self.closed[id].length && transport) {\n\n        // if we have buffered messages that accumulate between calling\n        // onOpen an this async callback, send them if the transport is \n        // still open, otherwise leave them buffered\n        if (transport.open) {\n          transport.payload(self.closed[id]);\n          self.closed[id] = [];\n        }\n      }\n    });\n  }\n\n  // clear the current transport\n  if (this.transports[id]) {\n    this.transports[id].discard();\n    this.transports[id] = null;\n  }\n};\n\n/**\n * Called when a message is sent to a namespace and/or room.\n *\n * @api private\n */\n\nManager.prototype.onDispatch = function (room, packet, volatile, exceptions) {\n  if (this.rooms[room]) {\n    for (var i = 0, l = this.rooms[room].length; i < l; i++) {\n      var id = this.rooms[room][i];\n\n      if (!~exceptions.indexOf(id)) {\n        if (this.transports[id] && this.transports[id].open) {\n          this.transports[id].onDispatch(packet, volatile);\n        } else if (!volatile) {\n          this.onClientDispatch(id, packet);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Called when a client joins a nsp / room.\n *\n * @api private\n */\n\nManager.prototype.onJoin = function (id, name) {\n  if (!this.roomClients[id]) {\n    this.roomClients[id] = {};\n  }\n\n  if (!this.rooms[name]) {\n    this.rooms[name] = [];\n  }\n\n  if (!~this.rooms[name].indexOf(id)) {\n    this.rooms[name].push(id);\n    this.roomClients[id][name] = true;\n  }\n};\n\n/**\n * Called when a client leaves a nsp / room.\n *\n * @param private\n */\n\nManager.prototype.onLeave = function (id, room) {\n  if (this.rooms[room]) {\n    var index = this.rooms[room].indexOf(id);\n\n    if (index >= 0) {\n      this.rooms[room].splice(index, 1);\n    }\n\n    if (!this.rooms[room].length) {\n      delete this.rooms[room];\n    }\n    delete this.roomClients[id][room];\n  }\n};\n\n/**\n * Called when a client closes a request in different node.\n *\n * @api private\n */\n\nManager.prototype.onClose = function (id) {\n  if (this.open[id]) {\n    delete this.open[id];\n  }\n\n  this.closed[id] = [];\n\n  var self = this;\n\n  this.store.subscribe('dispatch:' + id, function (packet, volatile) {\n    if (!volatile) {\n      self.onClientDispatch(id, packet);\n    }\n  });\n};\n\n/**\n * Dispatches a message for a closed client.\n *\n * @api private\n */\n\nManager.prototype.onClientDispatch = function (id, packet) {\n  if (this.closed[id]) {\n    this.closed[id].push(packet);\n  }\n};\n\n/**\n * Receives a message for a client.\n *\n * @api private\n */\n\nManager.prototype.onClientMessage = function (id, packet) {\n  if (this.namespaces[packet.endpoint]) {\n    this.namespaces[packet.endpoint].handlePacket(id, packet);\n  }\n};\n\n/**\n * Fired when a client disconnects (not triggered).\n *\n * @api private\n */\n\nManager.prototype.onClientDisconnect = function (id, reason) {\n  for (var name in this.namespaces) {\n    this.namespaces[name].handleDisconnect(id, reason, typeof this.roomClients[id] !== 'undefined' &&\n      typeof this.roomClients[id][name] !== 'undefined');\n  }\n\n  this.onDisconnect(id);\n};\n\n/**\n * Called when a client disconnects.\n *\n * @param text\n */\n\nManager.prototype.onDisconnect = function (id, local) {\n  delete this.handshaken[id];\n\n  if (this.open[id]) {\n    delete this.open[id];\n  }\n\n  if (this.connected[id]) {\n    delete this.connected[id];\n  }\n\n  if (this.transports[id]) {\n    this.transports[id].discard();\n    delete this.transports[id];\n  }\n\n  if (this.closed[id]) {\n    delete this.closed[id];\n  }\n\n  if (this.roomClients[id]) {\n    for (var room in this.roomClients[id]) {\n      this.onLeave(id, room);\n    }\n    delete this.roomClients[id]\n  }\n\n  this.store.destroyClient(id, this.get('client store expiration'));\n\n  this.store.unsubscribe('dispatch:' + id);\n\n  if (local) {\n    this.store.unsubscribe('message:' + id);\n    this.store.unsubscribe('disconnect:' + id);\n  }\n};\n\n/**\n * Handles an HTTP request.\n *\n * @api private\n */\n\nManager.prototype.handleRequest = function (req, res) {\n  var data = this.checkRequest(req);\n\n  if (!data) {\n    for (var i = 0, l = this.oldListeners.length; i < l; i++) {\n      this.oldListeners[i].call(this.server, req, res);\n    }\n\n    return;\n  }\n\n  if (data.static || !data.transport && !data.protocol) {\n    if (data.static && this.enabled('browser client')) {\n      this.static.write(data.path, req, res);\n    } else {\n      res.writeHead(200);\n      res.end('Welcome to socket.io.');\n\n      this.log.info('unhandled socket.io url');\n    }\n\n    return;\n  }\n\n  if (data.protocol != protocol) {\n    res.writeHead(500);\n    res.end('Protocol version not supported.');\n\n    this.log.info('client protocol version unsupported');\n  } else {\n    if (data.id) {\n      this.handleHTTPRequest(data, req, res);\n    } else {\n      this.handleHandshake(data, req, res);\n    }\n  }\n};\n\n/**\n * Handles an HTTP Upgrade.\n *\n * @api private\n */\n\nManager.prototype.handleUpgrade = function (req, socket, head) {\n  var data = this.checkRequest(req)\n    , self = this;\n\n  if (!data) {\n    if (this.enabled('destroy upgrade')) {\n      socket.end();\n      this.log.debug('destroying non-socket.io upgrade');\n    }\n\n    return;\n  }\n\n  req.head = head;\n  this.handleClient(data, req);\n};\n\n/**\n * Handles a normal handshaken HTTP request (eg: long-polling)\n *\n * @api private\n */\n\nManager.prototype.handleHTTPRequest = function (data, req, res) {\n  req.res = res;\n  this.handleClient(data, req);\n};\n\n/**\n * Intantiantes a new client.\n *\n * @api private\n */\n\nManager.prototype.handleClient = function (data, req) {\n  var socket = req.socket\n    , store = this.store\n    , self = this;\n\n  if (undefined != data.query.disconnect) {\n    if (this.transports[data.id] && this.transports[data.id].open) {\n      this.transports[data.id].onForcedDisconnect();\n    } else {\n      this.store.publish('disconnect-force:' + data.id);\n    }\n    return;\n  }\n\n  if (!~this.get('transports').indexOf(data.transport)) {\n    this.log.warn('unknown transport: \"' + data.transport + '\"');\n    req.connection.end();\n    return;\n  }\n\n  var transport = new transports[data.transport](this, data, req)\n    , handshaken = this.handshaken[data.id];\n\n  if (transport.disconnected) {\n    // failed during transport setup\n    req.connection.end();\n    return;\n  }\n  if (handshaken) {\n    if (transport.open) {\n      if (this.closed[data.id] && this.closed[data.id].length) {\n        transport.payload(this.closed[data.id]);\n        this.closed[data.id] = [];\n      }\n\n      this.onOpen(data.id);\n      this.store.publish('open', data.id);\n      this.transports[data.id] = transport;\n    }\n\n    if (!this.connected[data.id]) {\n      this.onConnect(data.id);\n      this.store.publish('connect', data.id);\n\n      // flag as used\n      delete handshaken.issued;\n      this.onHandshake(data.id, handshaken);\n      this.store.publish('handshake', data.id, handshaken);\n\n      // initialize the socket for all namespaces\n      for (var i in this.namespaces) {\n        var socket = this.namespaces[i].socket(data.id, true);\n\n        // echo back connect packet and fire connection event\n        if (i === '') {\n          this.namespaces[i].handlePacket(data.id, { type: 'connect' });\n        }\n      }\n\n      this.store.subscribe('message:' + data.id, function (packet) {\n        self.onClientMessage(data.id, packet);\n      });\n\n      this.store.subscribe('disconnect:' + data.id, function (reason) {\n        self.onClientDisconnect(data.id, reason);\n      });\n    }\n  } else {\n    if (transport.open) {\n      transport.error('client not handshaken', 'reconnect');\n    }\n\n    transport.discard();\n  }\n};\n\n/**\n * Generates a session id.\n *\n * @api private\n */\n\nManager.prototype.generateId = function (data) {\n  var rand = new Buffer(15); // multiple of 3 for base64\n  this.sequenceNumber = (this.sequenceNumber + 1) | 0;\n  rand.writeInt32BE(this.sequenceNumber, 11);\n  crypto.randomBytes(12).copy(rand);\n  return rand.toString('base64').replace(/\\//g, '_').replace(/\\+/g, '-');\n};\n\n/**\n * Handles a handshake request.\n *\n * @api private\n */\n\nManager.prototype.handleHandshake = function (data, req, res) {\n  var self = this\n    , origin = req.headers.origin\n    , headers = {\n        'Content-Type': 'text/plain'\n    };\n\n  function writeErr (status, message) {\n    if (data.query.jsonp && jsonpolling_re.test(data.query.jsonp)) {\n      res.writeHead(200, { 'Content-Type': 'application/javascript' });\n      res.end('io.j[' + data.query.jsonp + '](new Error(\"' + message + '\"));');\n    } else {\n      res.writeHead(status, headers);\n      res.end(message);\n    }\n  };\n\n  function error (err) {\n    writeErr(500, 'handshake error');\n    self.log.warn('handshake error ' + err);\n  };\n\n  if (!this.verifyOrigin(req)) {\n    writeErr(403, 'handshake bad origin');\n    return;\n  }\n\n  var handshakeData = this.handshakeData(data);\n\n  if (origin) {\n    // https://developer.mozilla.org/En/HTTP_Access_Control\n    headers['Access-Control-Allow-Origin'] = origin;\n    headers['Access-Control-Allow-Credentials'] = 'true';\n  }\n\n  this.authorize(handshakeData, function (err, authorized, newData) {\n    if (err) return error(err);\n\n    if (authorized) {\n      var id = self.generateId(newData || handshakeData)\n        , hs = [\n              id\n            , self.enabled('heartbeats') ? self.get('heartbeat timeout') || '' : ''\n            , self.get('close timeout') || ''\n            , self.transports(data).join(',')\n          ].join(':');\n\n      if (data.query.jsonp && jsonpolling_re.test(data.query.jsonp)) {\n        hs = 'io.j[' + data.query.jsonp + '](' + JSON.stringify(hs) + ');';\n        res.writeHead(200, { 'Content-Type': 'application/javascript' });\n      } else {\n        res.writeHead(200, headers);\n      }\n\n      res.end(hs);\n\n      self.onHandshake(id, newData || handshakeData);\n      self.store.publish('handshake', id, newData || handshakeData);\n\n      self.log.info('handshake authorized', id);\n    } else {\n      writeErr(403, 'handshake unauthorized');\n      self.log.info('handshake unauthorized');\n    }\n  })\n};\n\n/**\n * Gets normalized handshake data\n *\n * @api private\n */\n\nManager.prototype.handshakeData = function (data) {\n  var connection = data.request.connection\n    , connectionAddress\n    , date = new Date;\n\n  if (connection.remoteAddress) {\n    connectionAddress = {\n        address: connection.remoteAddress\n      , port: connection.remotePort\n    };\n  } else if (connection.socket && connection.socket.remoteAddress) {\n    connectionAddress = {\n        address: connection.socket.remoteAddress\n      , port: connection.socket.remotePort\n    };\n  }\n\n  return {\n      headers: data.headers\n    , address: connectionAddress\n    , time: date.toString()\n    , query: data.query\n    , url: data.request.url\n    , xdomain: !!data.request.headers.origin\n    , secure: data.request.connection.secure\n    , issued: +date\n  };\n};\n\n/**\n * Verifies the origin of a request.\n *\n * @api private\n */\n\nManager.prototype.verifyOrigin = function (request) {\n  var origin = request.headers.origin || request.headers.referer\n    , origins = this.get('origins');\n\n  if (origin === 'null') origin = '*';\n\n  if (origins.indexOf('*:*') !== -1) {\n    return true;\n  }\n\n  if (origin) {\n    try {\n      var parts = url.parse(origin);\n      parts.port = parts.port || 80;\n      var ok =\n        ~origins.indexOf(parts.hostname + ':' + parts.port) ||\n        ~origins.indexOf(parts.hostname + ':*') ||\n        ~origins.indexOf('*:' + parts.port);\n      if (!ok) this.log.warn('illegal origin: ' + origin);\n      return ok;\n    } catch (ex) {\n      this.log.warn('error parsing origin');\n    }\n  }\n  else {\n    this.log.warn('origin missing from handshake, yet required by config');\n  }\n  return false;\n};\n\n/**\n * Handles an incoming packet.\n *\n * @api private\n */\n\nManager.prototype.handlePacket = function (sessid, packet) {\n  this.of(packet.endpoint || '').handlePacket(sessid, packet);\n};\n\n/**\n * Performs authentication.\n *\n * @param Object client request data\n * @api private\n */\n\nManager.prototype.authorize = function (data, fn) {\n  if (this.get('authorization')) {\n    var self = this;\n\n    this.get('authorization').call(this, data, function (err, authorized, newData) {\n      self.log.debug('client ' + authorized ? 'authorized' : 'unauthorized');\n      fn(err, authorized, newData);\n    });\n  } else {\n    this.log.debug('client authorized');\n    fn(null, true);\n  }\n\n  return this;\n};\n\n/**\n * Retrieves the transports adviced to the user.\n *\n * @api private\n */\n\nManager.prototype.transports = function (data) {\n  var transp = this.get('transports')\n    , ret = [];\n\n  for (var i = 0, l = transp.length; i < l; i++) {\n    var transport = transp[i];\n\n    if (transport) {\n      if (!transport.checkClient || transport.checkClient(data)) {\n        ret.push(transport);\n      }\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Checks whether a request is a socket.io one.\n *\n * @return {Object} a client request data object or `false`\n * @api private\n */\n\nvar regexp = /^\\/([^\\/]+)\\/?([^\\/]+)?\\/?([^\\/]+)?\\/?$/\n\nManager.prototype.checkRequest = function (req) {\n  var resource = this.get('resource');\n\n  var match;\n  if (typeof resource === 'string') {\n    match = req.url.substr(0, resource.length);\n    if (match !== resource) match = null;\n  } else {\n    match = resource.exec(req.url);\n    if (match) match = match[0];\n  }\n\n  if (match) {\n    var uri = url.parse(req.url.substr(match.length), true)\n      , path = uri.pathname || ''\n      , pieces = path.match(regexp);\n\n    // client request data\n    var data = {\n        query: uri.query || {}\n      , headers: req.headers\n      , request: req\n      , path: path\n    };\n\n    if (pieces) {\n      data.protocol = Number(pieces[1]);\n      data.transport = pieces[2];\n      data.id = pieces[3];\n      data.static = !!this.static.has(path);\n    };\n\n    return data;\n  }\n\n  return false;\n};\n\n/**\n * Declares a socket namespace\n *\n * @api public\n */\n\nManager.prototype.of = function (nsp) {\n  if (this.namespaces[nsp]) {\n    return this.namespaces[nsp];\n  }\n\n  return this.namespaces[nsp] = new SocketNamespace(this, nsp);\n};\n\n/**\n * Perform garbage collection on long living objects and properties that cannot\n * be removed automatically.\n *\n * @api private\n */\n\nManager.prototype.garbageCollection = function () {\n  // clean up unused handshakes\n  var ids = Object.keys(this.handshaken)\n    , i = ids.length\n    , now = Date.now()\n    , handshake;\n\n  while (i--) {\n    handshake = this.handshaken[ids[i]];\n\n    if ('issued' in handshake && (now - handshake.issued) >= 3E4) {\n      this.onDisconnect(ids[i]);\n    }\n  }\n};\n", "/*!\n * socket.io-node\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Test dependencies.\n */\n\nvar sio = require('../')\n  , http = require('http')\n  , should = require('./common')\n  , ports = 15100;\n\n/**\n * Test.\n */\n\nmodule.exports = {\n\n  'test setting and getting a configuration flag': function (done) {\n    var port = ++ports\n      , io = sio.listen(http.createServer());\n\n    io.set('a', 'b');\n    io.get('a').should.eql('b');\n\n    var port = ++ports\n      , io = sio.listen(http.createServer());\n\n    io.configure(function () {\n      io.set('a', 'b');\n      io.enable('tobi');\n    });\n\n    io.get('a').should.eql('b');\n\n    done();\n  },\n\n  'test enabling and disabling a configuration flag': function (done) {\n    var port = ++ports\n      , io = sio.listen(http.createServer());\n\n    io.enable('flag');\n    io.enabled('flag').should.be.true;\n    io.disabled('flag').should.be.false;\n\n    io.disable('flag');\n    var port = ++ports\n      , io = sio.listen(http.createServer());\n\n    io.configure(function () {\n      io.enable('tobi');\n    });\n\n    io.enabled('tobi').should.be.true;\n\n    done();\n  },\n\n  'test configuration callbacks with envs': function (done) {\n    var port = ++ports\n      , io = sio.listen(http.createServer());\n\n    process.env.NODE_ENV = 'development';\n\n    io.configure('production', function () {\n      io.set('ferret', 'tobi');\n    });\n\n    io.configure('development', function () {\n      io.set('ferret', 'jane');\n    });\n\n    io.get('ferret').should.eql('jane');\n    done();\n  },\n\n  'test configuration callbacks conserve scope': function (done) {\n    var port = ++ports\n      , io = sio.listen(http.createServer())\n      , calls = 0;\n\n    process.env.NODE_ENV = 'development';\n\n    io.configure(function () {\n      this.should.eql(io);\n      calls++;\n    });\n\n    io.configure('development', function () {\n      this.should.eql(io);\n      calls++;\n    });\n\n    calls.should.eql(2);\n    done();\n  },\n\n  'test configuration update notifications': function (done) {\n    var port = ++ports\n      , io = sio.listen(http.createServer())\n      , calls = 0;\n\n    io.on('set:foo', function () {\n      calls++;\n    });\n\n    io.set('foo', 'bar');\n    io.set('baz', 'bar');\n\n    calls.should.eql(1);\n\n    io.enable('foo');\n    io.disable('foo');\n\n    calls.should.eql(3);\n\n    done();\n  },\n\n  'test that normal requests are still served': function (done) {\n    var server = http.createServer(function (req, res) {\n      res.writeHead(200);\n      res.end('woot');\n    });\n\n    var io = sio.listen(server)\n      , port = ++ports\n      , cl = client(port);\n\n    server.listen(ports);\n\n    cl.get('/socket.io', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.eql('Welcome to socket.io.');\n\n      cl.get('/woot', function (res, data) {\n        res.statusCode.should.eql(200);\n        data.should.eql('woot');\n\n        cl.end();\n        server.close();\n        done();\n      });\n    });\n  },\n\n  'test that you can disable clients': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.disable('browser client');\n    });\n\n    cl.get('/socket.io/socket.io.js', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.eql('Welcome to socket.io.');\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test handshake': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.match(/([^:]+):([0-9]+)?:([0-9]+)?:(.+)/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test handshake with unsupported protocol version': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    cl.get('/socket.io/-1/', function (res, data) {\n      res.statusCode.should.eql(500);\n      data.should.match(/Protocol version not supported/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test authorization failure in handshake': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      function auth (data, fn) {\n        fn(null, false);\n      };\n\n      io.set('authorization', auth);\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(403);\n      data.should.match(/handshake unauthorized/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test authorization gets handshake data': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      function auth (data, fn) {\n        data.query.should.have.foo;\n        data.query.foo.should.eql('bar');\n        fn(null, false);\n      };\n\n      io.set('authorization', auth);\n    });\n\n    cl.get('/socket.io/{protocol}/?foo=bar', function (res, data) {\n      res.statusCode.should.eql(403);\n      data.should.match(/handshake unauthorized/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test that authorization can view handshake data': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      function auth (data, fn) {\n        data.query.should.have.foo;\n        data.query.foo.should.eql('bar');\n        fn(null, true);\n      };\n\n      io.set('authorization', auth);\n    });\n\n    cl.get('/socket.io/{protocol}/?foo=bar', function (res, data) {\n      res.statusCode.should.eql(200);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test that authorization can change handshake data': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      function auth (data, fn) {\n        var replacement = { baz: 'qu' };\n        for (i in data) {\n          if (data.hasOwnProperty(i)) {\n            replacement[i] = data[i];\n          }\n        }\n        fn(null, true, replacement);\n      };\n\n      io.set('authorization', auth);\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      var id = data.split(':', 2)[0];\n      res.statusCode.should.eql(200);\n      io.handshaken[id].should.have.baz;\n      io.handshaken[id].baz.should.eql('qu');\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test a handshake error': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      function auth (data, fn) {\n        fn(new Error);\n      };\n\n      io.set('authorization', auth);\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(500);\n      data.should.match(/handshake error/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test that a referer is accepted for *:* origin': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('origins', '*:*');\n    });\n\n    cl.get('/socket.io/{protocol}', { headers: { referer: 'http://foo.bar.com:82/something' } }, function (res, data) {\n      res.statusCode.should.eql(200);\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test that valid referer is accepted for addr:* origin': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('origins', 'foo.bar.com:*');\n    });\n\n    cl.get('/socket.io/{protocol}', { headers: { referer: 'http://foo.bar.com/something' } }, function (res, data) {\n      res.statusCode.should.eql(200);\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test that a referer with implicit port 80 is accepted for foo.bar.com:80 origin': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('origins', 'foo.bar.com:80');\n    });\n\n    cl.get('/socket.io/{protocol}', { headers: { referer: 'http://foo.bar.com/something' } }, function (res, data) {\n      res.statusCode.should.eql(200);\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test that erroneous referer is denied for addr:* origin': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('origins', 'foo.bar.com:*');\n    });\n\n    cl.get('/socket.io/{protocol}', { headers: { referer: 'http://baz.bar.com/something' } }, function (res, data) {\n      res.statusCode.should.eql(403);\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test that valid referer port is accepted for addr:port origin': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('origins', 'foo.bar.com:81');\n    });\n\n    cl.get('/socket.io/{protocol}', { headers: { referer: 'http://foo.bar.com:81/something' } }, function (res, data) {\n      res.statusCode.should.eql(200);\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test that erroneous referer port is denied for addr:port origin': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('origins', 'foo.bar.com:81');\n    });\n\n    cl.get('/socket.io/{protocol}', { headers: { referer: 'http://foo.bar.com/something' } }, function (res, data) {\n      res.statusCode.should.eql(403);\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test handshake cross domain access control': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port)\n      , headers = {\n            Origin: 'http://example.org:1337'\n          , Cookie: 'name=value'\n        };\n\n    cl.get('/socket.io/{protocol}/', { headers:headers }, function (res, data) {\n      res.statusCode.should.eql(200);\n      res.headers['access-control-allow-origin'].should.eql('http://example.org:1337');\n      res.headers['access-control-allow-credentials'].should.eql('true');\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test limiting the supported transports for a manager': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('transports', ['tobi', 'jane']);\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.match(/([^:]+):([0-9]+)?:([0-9]+)?:tobi,jane/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test setting a custom close timeout': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('close timeout', 66);\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.match(/([^:]+):([0-9]+)?:66?:(.*)/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test setting a custom heartbeat timeout': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('heartbeat timeout', 33);\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.match(/([^:]+):33:([0-9]+)?:(.*)/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test disabling timeouts': function (done) {\n    var port = ++ports\n      , io = sio.listen(port)\n      , cl = client(port);\n\n    io.configure(function () {\n      io.set('heartbeat timeout', null);\n      io.set('close timeout', '');\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.match(/([^:]+)::?:(.*)/);\n\n      cl.end();\n      io.server.close();\n      done();\n    });\n  },\n\n  'test disabling heartbeats': function (done) {\n    var port = ++ports\n      , cl = client(port)\n      , io = create(cl)\n      , messages = 0\n      , beat = false\n      , ws;\n\n    io.configure(function () {\n      io.disable('heartbeats');\n      io.set('heartbeat interval', .05);\n      io.set('heartbeat timeout', .05);\n      io.set('close timeout', .05);\n    });\n\n    io.sockets.on('connection', function (socket) {\n      setTimeout(function () {\n        socket.disconnect();\n      }, io.get('heartbeat timeout') * 1000 + 100);\n\n      socket.on('disconnect', function (reason) {\n        beat.should.be.false;\n        ws.finishClose();\n        cl.end();\n        io.server.close();\n        done();\n      });\n    });\n\n    cl.get('/socket.io/{protocol}/', function (res, data) {\n      res.statusCode.should.eql(200);\n      data.should.match(/([^:]+)::[\\.0-9]+:(.*)/);\n\n      cl.handshake(function (sid) {\n        ws = websocket(cl, sid);\n        ws.on('message', function (packet) {\n          if (++messages == 1) {\n            packet.type.should.eql('connect');\n          } else if (packet.type == 'heartbeat'){\n            beat = true;\n          }\n        });\n      });\n    });\n  },\n\n  'no duplicate room members': function (done) {\n    var port = ++ports\n      , io = sio.listen(port);\n\n    Object.keys(io.rooms).length.should.equal(0);\n\n    io.onJoin(123, 'foo');\n    io.rooms.foo.length.should.equal(1);\n\n    io.onJoin(123, 'foo');\n    io.rooms.foo.length.should.equal(1);\n\n    io.onJoin(124, 'foo');\n    io.rooms.foo.length.should.equal(2);\n\n    io.onJoin(124, 'foo');\n    io.rooms.foo.length.should.equal(2);\n\n    io.onJoin(123, 'bar');\n    io.rooms.foo.length.should.equal(2);\n    io.rooms.bar.length.should.equal(1);\n\n    io.onJoin(123, 'bar');\n    io.rooms.foo.length.should.equal(2);\n    io.rooms.bar.length.should.equal(1);\n\n    io.onJoin(124, 'bar');\n    io.rooms.foo.length.should.equal(2);\n    io.rooms.bar.length.should.equal(2);\n\n    io.onJoin(124, 'bar');\n    io.rooms.foo.length.should.equal(2);\n    io.rooms.bar.length.should.equal(2);\n\n    process.nextTick(function() {\n      io.server.close();\n      done();\n    });\n  },\n\n  'test passing options directly to the Manager through listen': function (done) {\n    var port = ++ports\n      , io = sio.listen(port, { resource: '/my resource', custom: 'opt' });\n\n    io.get('resource').should.equal('/my resource');\n    io.get('custom').should.equal('opt');\n    process.nextTick(function() {\n      io.server.close();\n      done();\n    });\n  },\n\n  'test disabling the log': function (done) {\n    var port = ++ports\n      , io = sio.listen(port, { log: false })\n      , _console = console.log\n      , calls = 0;\n\n    // the logger uses console.log to output data, override it to see if get's\n    // used\n    console.log = function () { ++calls };\n\n    io.log.debug('test');\n    io.log.log('testing');\n\n    console.log = _console;\n    calls.should.equal(0);\n\n    process.nextTick(function() {\n      io.server.close();\n      done();\n    });\n  },\n\n  'test disabling logging with colors': function (done) {\n     var port = ++ports\n      , io = sio.listen(port, { 'log colors': false })\n      , _console = console.log\n      , calls = 0;\n\n    // the logger uses console.log to output data, override it to see if get's\n    // used\n    console.log = function (data) {\n      ++calls;\n      data.indexOf('\\033').should.equal(-1);\n    };\n\n    io.log.debug('test');\n    io.log.log('testing');\n\n    console.log = _console;\n    calls.should.equal(2);\n\n    process.nextTick(function() {\n      io.server.close();\n      done();\n    });\n  }\n};\n"], "filenames": ["lib/manager.js", "test/manager.test.js"], "buggy_code_start_loc": [13, 215], "buggy_code_end_loc": [878, 215], "fixing_code_start_loc": [14, 216], "fixing_code_end_loc": [884, 296], "type": "CWE-330", "message": "Socket.io is a realtime application framework that provides communication via websockets. Because socket.io 0.9.6 and earlier depends on `Math.random()` to create socket IDs, the IDs are predictable. An attacker is able to guess the socket ID and gain access to socket.io servers, potentially obtaining sensitive information.", "other": {"cve": {"id": "CVE-2017-16031", "sourceIdentifier": "support@hackerone.com", "published": "2018-06-04T19:29:01.727", "lastModified": "2018-07-31T14:42:06.780", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Socket.io is a realtime application framework that provides communication via websockets. Because socket.io 0.9.6 and earlier depends on `Math.random()` to create socket IDs, the IDs are predictable. An attacker is able to guess the socket ID and gain access to socket.io servers, potentially obtaining sensitive information."}, {"lang": "es", "value": "Socket.io es un framework de aplicaci\u00f3n en tiempo real que proporciona comunicaciones mediante websockets. Debido a que las versiones 0.9.6 y anteriores de socket.io dependen de \"Math.random()\" para crear ID de socket, estos ID son predecibles. Un atacante puede adivinar el ID de socket y obtener acceso a los servidores socket.io, pudiendo obtener informaci\u00f3n sensible."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-330"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:socket:socket.io:*:*:*:*:*:node.js:*:*", "versionEndIncluding": "0.9.6", "matchCriteriaId": "922F52F1-F3F6-40AB-8C62-71D6A24E7B3F"}]}]}], "references": [{"url": "https://github.com/socketio/socket.io/commit/67b4eb9abdf111dfa9be4176d1709374a2b4ded8", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/socketio/socket.io/issues/856", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/socketio/socket.io/pull/857", "source": "support@hackerone.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://nodesecurity.io/advisories/321", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/socketio/socket.io/commit/67b4eb9abdf111dfa9be4176d1709374a2b4ded8"}}