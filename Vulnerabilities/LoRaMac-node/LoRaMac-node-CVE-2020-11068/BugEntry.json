{"buggy_code": ["/*!\r\n * \\file      LoRaMac.c\r\n *\r\n * \\brief     LoRa MAC layer implementation\r\n *\r\n * \\copyright Revised BSD License, see section \\ref LICENSE.\r\n *\r\n * \\code\r\n *                ______                              _\r\n *               / _____)             _              | |\r\n *              ( (____  _____ ____ _| |_ _____  ____| |__\r\n *               \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\r\n *               _____) ) ____| | | || |_| ____( (___| | | |\r\n *              (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\r\n *              (C)2013-2017 Semtech\r\n *\r\n *               ___ _____ _   ___ _  _____ ___  ___  ___ ___\r\n *              / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\r\n *              \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\r\n *              |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\r\n *              embedded.connectivity.solutions===============\r\n *\r\n * \\endcode\r\n *\r\n * \\author    Miguel Luis ( Semtech )\r\n *\r\n * \\author    Gregory Cristian ( Semtech )\r\n *\r\n * \\author    Daniel Jaeckle ( STACKFORCE )\r\n *\r\n * \\author    Johannes Bruder ( STACKFORCE )\r\n */\r\n#include \"utilities.h\"\r\n#include \"region/Region.h\"\r\n#include \"LoRaMacClassB.h\"\r\n#include \"LoRaMacCrypto.h\"\r\n#include \"secure-element.h\"\r\n#include \"LoRaMacTest.h\"\r\n#include \"LoRaMacTypes.h\"\r\n#include \"LoRaMacConfirmQueue.h\"\r\n#include \"LoRaMacHeaderTypes.h\"\r\n#include \"LoRaMacMessageTypes.h\"\r\n#include \"LoRaMacParser.h\"\r\n#include \"LoRaMacCommands.h\"\r\n#include \"LoRaMacAdr.h\"\r\n\r\n#include \"LoRaMac.h\"\r\n\r\n#ifndef LORAMAC_VERSION\r\n/*!\r\n * LORaWAN version definition.\r\n */\r\n#define LORAMAC_VERSION                             0x01000300\r\n#endif\r\n\r\n/*!\r\n * Maximum PHY layer payload size\r\n */\r\n#define LORAMAC_PHY_MAXPAYLOAD                      255\r\n\r\n/*!\r\n * Maximum MAC commands buffer size\r\n */\r\n#define LORA_MAC_COMMAND_MAX_LENGTH                 128\r\n\r\n/*!\r\n * Maximum length of the fOpts field\r\n */\r\n#define LORA_MAC_COMMAND_MAX_FOPTS_LENGTH           15\r\n\r\n/*!\r\n * LoRaMac duty cycle for the back-off procedure during the first hour.\r\n */\r\n#define BACKOFF_DC_1_HOUR                           100\r\n\r\n/*!\r\n * LoRaMac duty cycle for the back-off procedure during the next 10 hours.\r\n */\r\n#define BACKOFF_DC_10_HOURS                         1000\r\n\r\n/*!\r\n * LoRaMac duty cycle for the back-off procedure during the next 24 hours.\r\n */\r\n#define BACKOFF_DC_24_HOURS                         10000\r\n\r\n/*!\r\n * LoRaMac internal states\r\n */\r\nenum eLoRaMacState\r\n{\r\n    LORAMAC_IDLE          = 0x00000000,\r\n    LORAMAC_STOPPED       = 0x00000001,\r\n    LORAMAC_TX_RUNNING    = 0x00000002,\r\n    LORAMAC_RX            = 0x00000004,\r\n    LORAMAC_ACK_RETRY     = 0x00000010,\r\n    LORAMAC_TX_DELAYED    = 0x00000020,\r\n    LORAMAC_TX_CONFIG     = 0x00000040,\r\n    LORAMAC_RX_ABORT      = 0x00000080,\r\n};\r\n\r\n/*\r\n * Request permission state\r\n */\r\ntypedef enum eLoRaMacRequestHandling\r\n{\r\n    LORAMAC_REQUEST_HANDLING_OFF = 0,\r\n    LORAMAC_REQUEST_HANDLING_ON = !LORAMAC_REQUEST_HANDLING_OFF\r\n}LoRaMacRequestHandling_t;\r\n\r\ntypedef struct sLoRaMacNvmCtx\r\n{\r\n    /*\r\n     * LoRaMac region.\r\n     */\r\n    LoRaMacRegion_t Region;\r\n    /*\r\n     * LoRaMac default parameters\r\n     */\r\n    LoRaMacParams_t MacParamsDefaults;\r\n    /*\r\n     * Network ID ( 3 bytes )\r\n     */\r\n    uint32_t NetID;\r\n    /*\r\n     * Mote Address\r\n     */\r\n    uint32_t DevAddr;\r\n    /*!\r\n    * Multicast channel list\r\n    */\r\n    MulticastCtx_t MulticastChannelList[LORAMAC_MAX_MC_CTX];\r\n    /*\r\n     * Actual device class\r\n     */\r\n    DeviceClass_t DeviceClass;\r\n    /*\r\n     * Indicates if the node is connected to\r\n     * a private or public network\r\n     */\r\n    bool PublicNetwork;\r\n    /*\r\n     * LoRaMac ADR control status\r\n     */\r\n    bool AdrCtrlOn;\r\n    /*\r\n     * Counts the number of missed ADR acknowledgements\r\n     */\r\n    uint32_t AdrAckCounter;\r\n\r\n    /*\r\n     * LoRaMac parameters\r\n     */\r\n    LoRaMacParams_t MacParams;\r\n    /*\r\n     * Maximum duty cycle\r\n     * \\remark Possibility to shutdown the device.\r\n     */\r\n    uint8_t MaxDCycle;\r\n    /*\r\n    * Enables/Disables duty cycle management (Test only)\r\n    */\r\n    bool DutyCycleOn;\r\n    /*\r\n     * Current channel index\r\n     */\r\n    uint8_t LastTxChannel;\r\n    /*\r\n     * Buffer containing the MAC layer commands\r\n     */\r\n    uint8_t MacCommandsBuffer[LORA_MAC_COMMAND_MAX_LENGTH];\r\n    /*\r\n     * If the server has sent a FRAME_TYPE_DATA_CONFIRMED_DOWN this variable indicates\r\n     * if the ACK bit must be set for the next transmission\r\n     */\r\n    bool SrvAckRequested;\r\n    /*\r\n     * Aggregated duty cycle management\r\n     */\r\n    uint16_t AggregatedDCycle;\r\n    /*\r\n    * Aggregated duty cycle management\r\n    */\r\n    TimerTime_t LastTxDoneTime;\r\n    TimerTime_t AggregatedTimeOff;\r\n    /*\r\n    * Stores the time at LoRaMac initialization.\r\n    *\r\n    * \\remark Used for the BACKOFF_DC computation.\r\n    */\r\n    SysTime_t InitializationTime;\r\n    /*\r\n     * Current LoRaWAN Version\r\n     */\r\n    Version_t Version;\r\n    /*\r\n     * End-Device network activation\r\n     */\r\n    ActivationType_t NetworkActivation;\r\n    /*!\r\n     * Last received Message integrity Code (MIC)\r\n     */\r\n    uint32_t LastRxMic;\r\n}LoRaMacNvmCtx_t;\r\n\r\ntypedef struct sLoRaMacCtx\r\n{\r\n    /*\r\n    * Length of packet in PktBuffer\r\n    */\r\n    uint16_t PktBufferLen;\r\n    /*\r\n    * Buffer containing the data to be sent or received.\r\n    */\r\n    uint8_t PktBuffer[LORAMAC_PHY_MAXPAYLOAD];\r\n    /*!\r\n    * Current processed transmit message\r\n    */\r\n    LoRaMacMessage_t TxMsg;\r\n    /*!\r\n    * Buffer containing the data received by the application.\r\n    */\r\n    uint8_t AppData[LORAMAC_PHY_MAXPAYLOAD];\r\n    /*\r\n    * Size of buffer containing the application data.\r\n    */\r\n    uint8_t AppDataSize;\r\n    /*\r\n    * Buffer containing the upper layer data.\r\n    */\r\n    uint8_t RxPayload[LORAMAC_PHY_MAXPAYLOAD];\r\n    SysTime_t LastTxSysTime;\r\n    /*\r\n    * LoRaMac internal state\r\n    */\r\n    uint32_t MacState;\r\n    /*\r\n    * LoRaMac upper layer event functions\r\n    */\r\n    LoRaMacPrimitives_t* MacPrimitives;\r\n    /*\r\n    * LoRaMac upper layer callback functions\r\n    */\r\n    LoRaMacCallback_t* MacCallbacks;\r\n    /*\r\n    * Radio events function pointer\r\n    */\r\n    RadioEvents_t RadioEvents;\r\n    /*\r\n    * LoRaMac duty cycle delayed Tx timer\r\n    */\r\n    TimerEvent_t TxDelayedTimer;\r\n    /*\r\n    * LoRaMac reception windows timers\r\n    */\r\n    TimerEvent_t RxWindowTimer1;\r\n    TimerEvent_t RxWindowTimer2;\r\n    /*\r\n    * LoRaMac reception windows delay\r\n    * \\remark normal frame: RxWindowXDelay = ReceiveDelayX - RADIO_WAKEUP_TIME\r\n    *         join frame  : RxWindowXDelay = JoinAcceptDelayX - RADIO_WAKEUP_TIME\r\n    */\r\n    uint32_t RxWindow1Delay;\r\n    uint32_t RxWindow2Delay;\r\n    /*\r\n    * LoRaMac Rx windows configuration\r\n    */\r\n    RxConfigParams_t RxWindow1Config;\r\n    RxConfigParams_t RxWindow2Config;\r\n    RxConfigParams_t RxWindowCConfig;\r\n    /*\r\n     * Limit of uplinks without any donwlink response before the ADRACKReq bit will be set.\r\n     */\r\n    uint16_t AdrAckLimit;\r\n    /*\r\n     * Limit of uplinks without any donwlink response after a the first frame with set ADRACKReq bit\r\n     * before the trying to regain the connectivity.\r\n     */\r\n    uint16_t AdrAckDelay;\r\n    /*\r\n    * Acknowledge timeout timer. Used for packet retransmissions.\r\n    */\r\n    TimerEvent_t AckTimeoutTimer;\r\n    /*\r\n     * Uplink messages repetitions counter\r\n     */\r\n    uint8_t ChannelsNbTransCounter;\r\n    /*\r\n     * Number of trials to get a frame acknowledged\r\n     */\r\n    uint8_t AckTimeoutRetries;\r\n    /*\r\n     * Number of trials to get a frame acknowledged\r\n     */\r\n    uint8_t AckTimeoutRetriesCounter;\r\n    /*\r\n     * Indicates if the AckTimeout timer has expired or not\r\n     */\r\n    bool AckTimeoutRetry;\r\n    /*\r\n     * If the node has sent a FRAME_TYPE_DATA_CONFIRMED_UP this variable indicates\r\n     * if the nodes needs to manage the server acknowledgement.\r\n     */\r\n    bool NodeAckRequested;\r\n    /*\r\n     * Current channel index\r\n     */\r\n    uint8_t Channel;\r\n    /*\r\n    * Last transmission time on air\r\n    */\r\n    TimerTime_t TxTimeOnAir;\r\n    /*\r\n    * Structure to hold an MCPS indication data.\r\n    */\r\n    McpsIndication_t McpsIndication;\r\n    /*\r\n    * Structure to hold MCPS confirm data.\r\n    */\r\n    McpsConfirm_t McpsConfirm;\r\n    /*\r\n    * Structure to hold MLME confirm data.\r\n    */\r\n    MlmeConfirm_t MlmeConfirm;\r\n    /*\r\n    * Structure to hold MLME indication data.\r\n    */\r\n    MlmeIndication_t MlmeIndication;\r\n    /*\r\n    * Holds the current rx window slot\r\n    */\r\n    LoRaMacRxSlot_t RxSlot;\r\n    /*\r\n    * LoRaMac tx/rx operation state\r\n    */\r\n    LoRaMacFlags_t MacFlags;\r\n    /*\r\n    * Data structure indicating if a request is allowed or not.\r\n    */\r\n    LoRaMacRequestHandling_t AllowRequests;\r\n    /*\r\n    * Non-volatile module context structure\r\n    */\r\n    LoRaMacNvmCtx_t* NvmCtx;\r\n}LoRaMacCtx_t;\r\n\r\n/*\r\n * Module context.\r\n */\r\nstatic LoRaMacCtx_t MacCtx;\r\n\r\n/*\r\n * Non-volatile module context.\r\n */\r\nstatic LoRaMacNvmCtx_t NvmMacCtx;\r\n\r\n\r\n\r\n/*\r\n * List of module contexts.\r\n */\r\nLoRaMacCtxs_t Contexts;\r\n\r\n/*!\r\n * Defines the LoRaMac radio events status\r\n */\r\ntypedef union uLoRaMacRadioEvents\r\n{\r\n    uint32_t Value;\r\n    struct sEvents\r\n    {\r\n        uint32_t RxTimeout : 1;\r\n        uint32_t RxError   : 1;\r\n        uint32_t TxTimeout : 1;\r\n        uint32_t RxDone    : 1;\r\n        uint32_t TxDone    : 1;\r\n    }Events;\r\n}LoRaMacRadioEvents_t;\r\n\r\n/*!\r\n * LoRaMac radio events status\r\n */\r\nLoRaMacRadioEvents_t LoRaMacRadioEvents = { .Value = 0 };\r\n\r\n/*!\r\n * \\brief Function to be executed on Radio Tx Done event\r\n */\r\nstatic void OnRadioTxDone( void );\r\n\r\n/*!\r\n * \\brief This function prepares the MAC to abort the execution of function\r\n *        OnRadioRxDone in case of a reception error.\r\n */\r\nstatic void PrepareRxDoneAbort( void );\r\n\r\n/*!\r\n * \\brief Function to be executed on Radio Rx Done event\r\n */\r\nstatic void OnRadioRxDone( uint8_t* payload, uint16_t size, int16_t rssi, int8_t snr );\r\n\r\n/*!\r\n * \\brief Function executed on Radio Tx Timeout event\r\n */\r\nstatic void OnRadioTxTimeout( void );\r\n\r\n/*!\r\n * \\brief Function executed on Radio Rx error event\r\n */\r\nstatic void OnRadioRxError( void );\r\n\r\n/*!\r\n * \\brief Function executed on Radio Rx Timeout event\r\n */\r\nstatic void OnRadioRxTimeout( void );\r\n\r\n/*!\r\n * \\brief Function executed on duty cycle delayed Tx  timer event\r\n */\r\nstatic void OnTxDelayedTimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on first Rx window timer event\r\n */\r\nstatic void OnRxWindow1TimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on second Rx window timer event\r\n */\r\nstatic void OnRxWindow2TimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on AckTimeout timer event\r\n */\r\nstatic void OnAckTimeoutTimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Configures the events to trigger an MLME-Indication with\r\n *        a MLME type of MLME_SCHEDULE_UPLINK.\r\n */\r\nstatic void SetMlmeScheduleUplinkIndication( void );\r\n\r\n/*!\r\n * Computes next 32 bit downlink counter value and determines the frame counter ID.\r\n *\r\n * \\param[IN]     addrID                - Address identifier\r\n * \\param[IN]     fType                 - Frame type\r\n * \\param[IN]     macMsg                - Data message object, holding the current 16 bit transmitted frame counter\r\n * \\param[IN]     lrWanVersion          - LoRaWAN version\r\n * \\param[IN]     maxFCntGap            - Maximum allowed frame counter difference (only for 1.0.X necessary)\r\n * \\param[OUT]    fCntID                - Frame counter identifier\r\n * \\param[OUT]    currentDown           - Current downlink counter value\r\n *\r\n * \\retval                              - Status of the operation\r\n */\r\nstatic LoRaMacCryptoStatus_t GetFCntDown( AddressIdentifier_t addrID, FType_t fType, LoRaMacMessageData_t* macMsg, Version_t lrWanVersion,\r\n                                          uint16_t maxFCntGap, FCntIdentifier_t* fCntID, uint32_t* currentDown );\r\n\r\n/*!\r\n * \\brief Switches the device class\r\n *\r\n * \\param [IN] deviceClass Device class to switch to\r\n */\r\nstatic LoRaMacStatus_t SwitchClass( DeviceClass_t deviceClass );\r\n\r\n/*!\r\n * \\brief Gets the maximum application payload length in the absence of the optional FOpt field.\r\n *\r\n * \\param [IN] datarate        Current datarate\r\n *\r\n * \\retval                    Max length\r\n */\r\nstatic uint8_t GetMaxAppPayloadWithoutFOptsLength( int8_t datarate );\r\n\r\n/*!\r\n * \\brief Validates if the payload fits into the frame, taking the datarate\r\n *        into account.\r\n *\r\n * \\details Refer to chapter 4.3.2 of the LoRaWAN specification, v1.0\r\n *\r\n * \\param lenN Length of the application payload. The length depends on the\r\n *             datarate and is region specific\r\n *\r\n * \\param datarate Current datarate\r\n *\r\n * \\param fOptsLen Length of the fOpts field\r\n *\r\n * \\retval [false: payload does not fit into the frame, true: payload fits into\r\n *          the frame]\r\n */\r\nstatic bool ValidatePayloadLength( uint8_t lenN, int8_t datarate, uint8_t fOptsLen );\r\n\r\n/*!\r\n * \\brief Decodes MAC commands in the fOpts field and in the payload\r\n *\r\n * \\param [IN] payload      A pointer to the payload\r\n * \\param [IN] macIndex     The index of the payload where the MAC commands start\r\n * \\param [IN] commandsSize The size of the MAC commands\r\n * \\param [IN] snr          The SNR value  of the frame\r\n * \\param [IN] rxSlot       The RX slot where the frame was received\r\n */\r\nstatic void ProcessMacCommands( uint8_t* payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer generic send frame\r\n *\r\n * \\param [IN] macHdr      MAC header field\r\n * \\param [IN] fPort       MAC payload port\r\n * \\param [IN] fBuffer     MAC data buffer to be sent\r\n * \\param [IN] fBufferSize MAC data buffer size\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t Send( LoRaMacHeader_t* macHdr, uint8_t fPort, void* fBuffer, uint16_t fBufferSize );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer send join/rejoin request\r\n *\r\n * \\param [IN] joinReqType Type of join-request or rejoin\r\n *\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t SendReJoinReq( JoinReqIdentifier_t joinReqType );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer frame buffer initialization\r\n *\r\n * \\param [IN] macHdr      MAC header field\r\n * \\param [IN] fCtrl       MAC frame control field\r\n * \\param [IN] fOpts       MAC commands buffer\r\n * \\param [IN] fPort       MAC payload port\r\n * \\param [IN] fBuffer     MAC data buffer to be sent\r\n * \\param [IN] fBufferSize MAC data buffer size\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t PrepareFrame( LoRaMacHeader_t* macHdr, LoRaMacFrameCtrl_t* fCtrl, uint8_t fPort, void* fBuffer, uint16_t fBufferSize );\r\n\r\n/*\r\n * \\brief Schedules the frame according to the duty cycle\r\n *\r\n * \\param [IN] allowDelayedTx When set to true, the a frame will be delayed,\r\n *                            the duty cycle restriction is active\r\n * \\retval Status of the operation\r\n */\r\nstatic LoRaMacStatus_t ScheduleTx( bool allowDelayedTx );\r\n\r\n/*\r\n * \\brief Secures the current processed frame ( TxMsg )\r\n * \\param[IN]     txDr      Data rate used for the transmission\r\n * \\param[IN]     txCh      Index of the channel used for the transmission\r\n * \\retval status           Status of the operation\r\n */\r\nstatic LoRaMacStatus_t SecureFrame( uint8_t txDr, uint8_t txCh );\r\n\r\n/*\r\n * \\brief Calculates the back-off time for the band of a channel.\r\n *\r\n * \\param [IN] channel     The last Tx channel index\r\n */\r\nstatic void CalculateBackOff( uint8_t channel );\r\n\r\n/*\r\n * \\brief Function to remove pending MAC commands\r\n *\r\n * \\param [IN] rxSlot     The RX slot on which the frame was received\r\n * \\param [IN] fCtrl      The frame control field of the received frame\r\n * \\param [IN] request    The request type\r\n */\r\nstatic void RemoveMacCommands( LoRaMacRxSlot_t rxSlot, LoRaMacFrameCtrl_t fCtrl, Mcps_t request );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer prepared frame buffer transmission with channel specification\r\n *\r\n * \\remark PrepareFrame must be called at least once before calling this\r\n *         function.\r\n *\r\n * \\param [IN] channel     Channel to transmit on\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t SendFrameOnChannel( uint8_t channel );\r\n\r\n/*!\r\n * \\brief Sets the radio in continuous transmission mode\r\n *\r\n * \\remark Uses the radio parameters set on the previous transmission.\r\n *\r\n * \\param [IN] timeout     Time in seconds while the radio is kept in continuous wave mode\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t SetTxContinuousWave( uint16_t timeout );\r\n\r\n/*!\r\n * \\brief Sets the radio in continuous transmission mode\r\n *\r\n * \\remark Uses the radio parameters set on the previous transmission.\r\n *\r\n * \\param [IN] timeout     Time in seconds while the radio is kept in continuous wave mode\r\n * \\param [IN] frequency   RF frequency to be set.\r\n * \\param [IN] power       RF output power to be set.\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t SetTxContinuousWave1( uint16_t timeout, uint32_t frequency, uint8_t power );\r\n\r\n/*!\r\n * \\brief Resets MAC specific parameters to default\r\n */\r\nstatic void ResetMacParameters( void );\r\n\r\n/*!\r\n * \\brief Initializes and opens the reception window\r\n *\r\n * \\param [IN] rxTimer  Window timer to be topped.\r\n * \\param [IN] rxConfig Window parameters to be setup\r\n */\r\nstatic void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig );\r\n\r\n/*!\r\n * \\brief Opens up a continuous RX C window. This is used for\r\n *        class c devices.\r\n */\r\nstatic void OpenContinuousRxCWindow( void );\r\n\r\n/*!\r\n * \\brief   Returns a pointer to the internal contexts structure.\r\n *\r\n * \\retval  void Points to a structure containing all contexts\r\n */\r\nLoRaMacCtxs_t* GetCtxs( void );\r\n\r\n/*!\r\n * \\brief   Restoring of internal module contexts\r\n *\r\n * \\details This function allows to restore module contexts by a given pointer.\r\n *\r\n *\r\n * \\retval  LoRaMacStatus_t Status of the operation. Possible returns are:\r\n *          returns are:\r\n *          \\ref LORAMAC_STATUS_OK,\r\n *          \\ref LORAMAC_STATUS_PARAMETER_INVALID,\r\n */\r\nLoRaMacStatus_t RestoreCtxs( LoRaMacCtxs_t* contexts );\r\n\r\n/*!\r\n * \\brief   Determines the frame type\r\n *\r\n * \\param [IN] macMsg Data message object\r\n *\r\n * \\param [OUT] fType Frame type\r\n *\r\n * \\retval  LoRaMacStatus_t Status of the operation. Possible returns are:\r\n *          returns are:\r\n *          \\ref LORAMAC_STATUS_OK,\r\n *          \\ref LORAMAC_STATUS_PARAMETER_INVALID,\r\n */\r\nLoRaMacStatus_t DetermineFrameType( LoRaMacMessageData_t* macMsg, FType_t* fType );\r\n\r\n/*!\r\n * \\brief Checks if the retransmission should be stopped in case of a unconfirmed uplink\r\n *\r\n * \\retval Returns true if it should be stopped.\r\n */\r\nstatic bool CheckRetransUnconfirmedUplink( void );\r\n\r\n/*!\r\n * \\brief Checks if the retransmission should be stopped in case of a confirmed uplink\r\n *\r\n * \\retval Returns true it should be stopped.\r\n */\r\nstatic bool CheckRetransConfirmedUplink( void );\r\n\r\n/*!\r\n * \\brief Stops the uplink retransmission\r\n *\r\n * \\retval Returns true if successful.\r\n */\r\nstatic bool StopRetransmission( void );\r\n\r\n/*!\r\n * \\brief Handles the ACK retries algorithm.\r\n *        Increments the re-tries counter up until the specified number of\r\n *        trials or the allowed maximum. Decrease the uplink datarate every 2\r\n *        trials.\r\n */\r\nstatic void AckTimeoutRetriesProcess( void );\r\n\r\n/*!\r\n * \\brief Finalizes the ACK retries algorithm.\r\n *        If no ACK is received restores the default channels\r\n */\r\nstatic void AckTimeoutRetriesFinalize( void );\r\n\r\n/*!\r\n * \\brief Calls the callback to indicate that a context changed\r\n */\r\nstatic void CallNvmCtxCallback( LoRaMacNvmCtxModule_t module );\r\n\r\n/*!\r\n * \\brief MAC NVM Context has been changed\r\n */\r\nstatic void EventMacNvmCtxChanged( void );\r\n\r\n/*!\r\n * \\brief Region NVM Context has been changed\r\n */\r\nstatic void EventRegionNvmCtxChanged( void );\r\n\r\n/*!\r\n * \\brief Crypto NVM Context has been changed\r\n */\r\nstatic void EventCryptoNvmCtxChanged( void );\r\n\r\n/*!\r\n * \\brief Secure Element NVM Context has been changed\r\n */\r\nstatic void EventSecureElementNvmCtxChanged( void );\r\n\r\n/*!\r\n * \\brief MAC commands module nvm context has been changed\r\n */\r\nstatic void EventCommandsNvmCtxChanged( void );\r\n\r\n/*!\r\n * \\brief Class B module nvm context has been changed\r\n */\r\nstatic void EventClassBNvmCtxChanged( void );\r\n\r\n/*!\r\n * \\brief Confirm Queue module nvm context has been changed\r\n */\r\nstatic void EventConfirmQueueNvmCtxChanged( void );\r\n\r\n/*!\r\n * \\brief Verifies if a request is pending currently\r\n *\r\n *\\retval 1: Request pending, 0: request not pending\r\n */\r\nstatic uint8_t IsRequestPending( void );\r\n\r\n/*!\r\n * \\brief Enabled the possibility to perform requests\r\n *\r\n * \\param [IN] requestState Request permission state\r\n */\r\nstatic void LoRaMacEnableRequests( LoRaMacRequestHandling_t requestState );\r\n\r\n/*!\r\n * \\brief This function verifies if a RX abort occurred\r\n */\r\nstatic void LoRaMacCheckForRxAbort( void );\r\n\r\n/*!\r\n * \\brief This function verifies if a beacon acquisition MLME\r\n *        request was pending\r\n *\r\n * \\retval 1: Request pending, 0: no request pending\r\n */\r\nstatic uint8_t LoRaMacCheckForBeaconAcquisition( void );\r\n\r\n/*!\r\n * \\brief This function handles join request\r\n */\r\nstatic void LoRaMacHandleMlmeRequest( void );\r\n\r\n/*!\r\n * \\brief This function handles mcps request\r\n */\r\nstatic void LoRaMacHandleMcpsRequest( void );\r\n\r\n/*!\r\n * \\brief This function handles callback events for requests\r\n */\r\nstatic void LoRaMacHandleRequestEvents( void );\r\n\r\n/*!\r\n * \\brief This function handles callback events for indications\r\n */\r\nstatic void LoRaMacHandleIndicationEvents( void );\r\n\r\n/*!\r\n * Structure used to store the radio Tx event data\r\n */\r\nstruct\r\n{\r\n    TimerTime_t CurTime;\r\n}TxDoneParams;\r\n\r\n/*!\r\n * Structure used to store the radio Rx event data\r\n */\r\nstruct\r\n{\r\n    TimerTime_t LastRxDone;\r\n    uint8_t *Payload;\r\n    uint16_t Size;\r\n    int16_t Rssi;\r\n    int8_t Snr;\r\n}RxDoneParams;\r\n\r\nstatic void OnRadioTxDone( void )\r\n{\r\n    TxDoneParams.CurTime = TimerGetCurrentTime( );\r\n    MacCtx.LastTxSysTime = SysTimeGet( );\r\n\r\n    LoRaMacRadioEvents.Events.TxDone = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioRxDone( uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr )\r\n{\r\n    RxDoneParams.LastRxDone = TimerGetCurrentTime( );\r\n    RxDoneParams.Payload = payload;\r\n    RxDoneParams.Size = size;\r\n    RxDoneParams.Rssi = rssi;\r\n    RxDoneParams.Snr = snr;\r\n\r\n    LoRaMacRadioEvents.Events.RxDone = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioTxTimeout( void )\r\n{\r\n    LoRaMacRadioEvents.Events.TxTimeout = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioRxError( void )\r\n{\r\n    LoRaMacRadioEvents.Events.RxError = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioRxTimeout( void )\r\n{\r\n    LoRaMacRadioEvents.Events.RxTimeout = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void UpdateRxSlotIdleState( void )\r\n{\r\n    if( MacCtx.NvmCtx->DeviceClass != CLASS_C )\r\n    {\r\n        MacCtx.RxSlot = RX_SLOT_NONE;\r\n    }\r\n    else\r\n    {\r\n        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n    }\r\n}\r\n\r\nstatic void ProcessRadioTxDone( void )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n    SetBandTxDoneParams_t txDone;\r\n\r\n    if( MacCtx.NvmCtx->DeviceClass != CLASS_C )\r\n    {\r\n        Radio.Sleep( );\r\n    }\r\n    // Setup timers\r\n    TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay );\r\n    TimerStart( &MacCtx.RxWindowTimer1 );\r\n    TimerSetValue( &MacCtx.RxWindowTimer2, MacCtx.RxWindow2Delay );\r\n    TimerStart( &MacCtx.RxWindowTimer2 );\r\n\r\n    if( ( MacCtx.NvmCtx->DeviceClass == CLASS_C ) || ( MacCtx.NodeAckRequested == true ) )\r\n    {\r\n        getPhy.Attribute = PHY_ACK_TIMEOUT;\r\n        phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );\r\n        TimerStart( &MacCtx.AckTimeoutTimer );\r\n    }\r\n\r\n    // Store last Tx channel\r\n    MacCtx.NvmCtx->LastTxChannel = MacCtx.Channel;\r\n    // Update last tx done time for the current channel\r\n    txDone.Channel = MacCtx.Channel;\r\n    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        txDone.Joined  = false;\r\n    }\r\n    else\r\n    {\r\n        txDone.Joined  = true;\r\n    }\r\n    txDone.LastTxDoneTime = TxDoneParams.CurTime;\r\n    RegionSetBandTxDone( MacCtx.NvmCtx->Region, &txDone );\r\n    // Update Aggregated last tx done time\r\n    MacCtx.NvmCtx->LastTxDoneTime = TxDoneParams.CurTime;\r\n\r\n    if( MacCtx.NodeAckRequested == false )\r\n    {\r\n        MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n    }\r\n}\r\n\r\nstatic void PrepareRxDoneAbort( void )\r\n{\r\n    MacCtx.MacState |= LORAMAC_RX_ABORT;\r\n\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        OnAckTimeoutTimerEvent( NULL );\r\n    }\r\n\r\n    MacCtx.MacFlags.Bits.McpsInd = 1;\r\n    MacCtx.MacFlags.Bits.MacDone = 1;\r\n\r\n    UpdateRxSlotIdleState( );\r\n}\r\n\r\nstatic void ProcessRadioRxDone( void )\r\n{\r\n    LoRaMacHeader_t macHdr;\r\n    ApplyCFListParams_t applyCFList;\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n    LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR;\r\n\r\n    LoRaMacMessageData_t macMsgData;\r\n    LoRaMacMessageJoinAccept_t macMsgJoinAccept;\r\n    uint8_t *payload = RxDoneParams.Payload;\r\n    uint16_t size = RxDoneParams.Size;\r\n    int16_t rssi = RxDoneParams.Rssi;\r\n    int8_t snr = RxDoneParams.Snr;\r\n\r\n    uint8_t pktHeaderLen = 0;\r\n\r\n    uint32_t downLinkCounter = 0;\r\n    uint32_t address = MacCtx.NvmCtx->DevAddr;\r\n    uint8_t multicast = 0;\r\n    AddressIdentifier_t addrID = UNICAST_DEV_ADDR;\r\n    FCntIdentifier_t fCntID;\r\n\r\n    MacCtx.McpsConfirm.AckReceived = false;\r\n    MacCtx.McpsIndication.Rssi = rssi;\r\n    MacCtx.McpsIndication.Snr = snr;\r\n    MacCtx.McpsIndication.RxSlot = MacCtx.RxSlot;\r\n    MacCtx.McpsIndication.Port = 0;\r\n    MacCtx.McpsIndication.Multicast = 0;\r\n    MacCtx.McpsIndication.FramePending = 0;\r\n    MacCtx.McpsIndication.Buffer = NULL;\r\n    MacCtx.McpsIndication.BufferSize = 0;\r\n    MacCtx.McpsIndication.RxData = false;\r\n    MacCtx.McpsIndication.AckReceived = false;\r\n    MacCtx.McpsIndication.DownLinkCounter = 0;\r\n    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;\r\n    MacCtx.McpsIndication.DevAddress = 0;\r\n    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;\r\n\r\n    Radio.Sleep( );\r\n    TimerStop( &MacCtx.RxWindowTimer2 );\r\n\r\n    // This function must be called even if we are not in class b mode yet.\r\n    if( LoRaMacClassBRxBeacon( payload, size ) == true )\r\n    {\r\n        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;\r\n        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;\r\n        return;\r\n    }\r\n    // Check if we expect a ping or a multicast slot.\r\n    if( MacCtx.NvmCtx->DeviceClass == CLASS_B )\r\n    {\r\n        if( LoRaMacClassBIsPingExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBPingSlotTimerEvent( NULL );\r\n            MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;\r\n        }\r\n        else if( LoRaMacClassBIsMulticastExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBMulticastSlotTimerEvent( NULL );\r\n            MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;\r\n        }\r\n    }\r\n\r\n    macHdr.Value = payload[pktHeaderLen++];\r\n\r\n    switch( macHdr.Bits.MType )\r\n    {\r\n        case FRAME_TYPE_JOIN_ACCEPT:\r\n            macMsgJoinAccept.Buffer = payload;\r\n            macMsgJoinAccept.BufSize = size;\r\n\r\n            // Abort in case if the device isn't joined yet and no rejoin request is ongoing.\r\n            if( MacCtx.NvmCtx->NetworkActivation != ACTIVATION_TYPE_NONE )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus )\r\n            {\r\n                // Network ID\r\n                MacCtx.NvmCtx->NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];\r\n                MacCtx.NvmCtx->NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );\r\n                MacCtx.NvmCtx->NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );\r\n\r\n                // Device Address\r\n                MacCtx.NvmCtx->DevAddr = macMsgJoinAccept.DevAddr;\r\n\r\n                // DLSettings\r\n                MacCtx.NvmCtx->MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;\r\n                MacCtx.NvmCtx->MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\r\n                MacCtx.NvmCtx->MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\r\n\r\n                // RxDelay\r\n                MacCtx.NvmCtx->MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;\r\n                if( MacCtx.NvmCtx->MacParams.ReceiveDelay1 == 0 )\r\n                {\r\n                    MacCtx.NvmCtx->MacParams.ReceiveDelay1 = 1;\r\n                }\r\n                MacCtx.NvmCtx->MacParams.ReceiveDelay1 *= 1000;\r\n                MacCtx.NvmCtx->MacParams.ReceiveDelay2 = MacCtx.NvmCtx->MacParams.ReceiveDelay1 + 1000;\r\n\r\n                MacCtx.NvmCtx->Version.Fields.Minor = 0;\r\n\r\n                // Apply CF list\r\n                applyCFList.Payload = macMsgJoinAccept.CFList;\r\n                // Size of the regular payload is 12. Plus 1 byte MHDR and 4 bytes MIC\r\n                applyCFList.Size = size - 17;\r\n\r\n                RegionApplyCFList( MacCtx.NvmCtx->Region, &applyCFList );\r\n\r\n                MacCtx.NvmCtx->NetworkActivation = ACTIVATION_TYPE_OTAA;\r\n\r\n                // MLME handling\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_JOIN );\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // MLME handling\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );\r\n                }\r\n            }\r\n            break;\r\n        case FRAME_TYPE_DATA_CONFIRMED_DOWN:\r\n            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;\r\n            // Intentional fall through\r\n        case FRAME_TYPE_DATA_UNCONFIRMED_DOWN:\r\n            // Check if the received payload size is valid\r\n            getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;\r\n            getPhy.Attribute = PHY_MAX_PAYLOAD;\r\n            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n            if( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORA_MAC_FRMPAYLOAD_OVERHEAD ) ) > ( int16_t )phyParam.Value )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n            macMsgData.Buffer = payload;\r\n            macMsgData.BufSize = size;\r\n            macMsgData.FRMPayload = MacCtx.RxPayload;\r\n            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;\r\n\r\n            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            // Store device address\r\n            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;\r\n\r\n            FType_t fType;\r\n            if( LORAMAC_STATUS_OK != DetermineFrameType( &macMsgData, &fType ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            //Check if it is a multicast message\r\n            multicast = 0;\r\n            downLinkCounter = 0;\r\n            for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n            {\r\n                if( ( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&\r\n                    ( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.IsEnabled == true ) )\r\n                {\r\n                    multicast = 1;\r\n                    addrID = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.GroupID;\r\n                    downLinkCounter = *( MacCtx.NvmCtx->MulticastChannelList[i].DownLinkCounter );\r\n                    address = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address;\r\n                    if( MacCtx.NvmCtx->DeviceClass == CLASS_C )\r\n                    {\r\n                        MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Filter messages according to multicast downlink exceptions\r\n            if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||\r\n                                        ( macMsgData.FHDR.FCtrl.Bits.Ack == true ) ||\r\n                                        ( macMsgData.FHDR.FCtrl.Bits.AdrAckReq == true ) ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            // Get maximum allowed counter difference\r\n            getPhy.Attribute = PHY_MAX_FCNT_GAP;\r\n            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n\r\n            // Get downlink frame counter value\r\n            macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, MacCtx.NvmCtx->Version, phyParam.Value, &fCntID, &downLinkCounter );\r\n            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )\r\n            {\r\n                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )\r\n                {\r\n                    // Catch the case of repeated downlink frame counter\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;\r\n                    if( ( MacCtx.NvmCtx->Version.Fields.Minor == 0 ) && ( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) && ( MacCtx.NvmCtx->LastRxMic == macMsgData.MIC ) )\r\n                    {\r\n                        MacCtx.NvmCtx->SrvAckRequested = true;\r\n                    }\r\n                }\r\n                else if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT )\r\n                {\r\n                    // Lost too many frames\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS;\r\n                }\r\n                else\r\n                {\r\n                    // Other errors\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                }\r\n                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );\r\n            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )\r\n            {\r\n                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_ADDRESS )\r\n                {\r\n                    // We are not the destination of this frame.\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL;\r\n                }\r\n                else\r\n                {\r\n                    // MIC calculation fail\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;\r\n                }\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            // Frame is valid\r\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n            MacCtx.McpsIndication.Multicast = multicast;\r\n            MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending;\r\n            MacCtx.McpsIndication.Buffer = NULL;\r\n            MacCtx.McpsIndication.BufferSize = 0;\r\n            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;\r\n            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;\r\n\r\n            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;\r\n\r\n            // Reset ADR ACK Counter only, when RX1 or RX2 slot\r\n            if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||\r\n                ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) )\r\n            {\r\n                MacCtx.NvmCtx->AdrAckCounter = 0;\r\n            }\r\n\r\n            // MCPS Indication and ack requested handling\r\n            if( multicast == 1 )\r\n            {\r\n                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;\r\n            }\r\n            else\r\n            {\r\n                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )\r\n                {\r\n                    MacCtx.NvmCtx->SrvAckRequested = true;\r\n                    if( MacCtx.NvmCtx->Version.Fields.Minor == 0 )\r\n                    {\r\n                        MacCtx.NvmCtx->LastRxMic = macMsgData.MIC;\r\n                    }\r\n                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;\r\n                }\r\n                else\r\n                {\r\n                    MacCtx.NvmCtx->SrvAckRequested = false;\r\n                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;\r\n                }\r\n            }\r\n\r\n            RemoveMacCommands( MacCtx.McpsIndication.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );\r\n\r\n            switch( fType )\r\n            {\r\n                case FRAME_TYPE_A:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    > 0   |   X  |  > 0  |       X      |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // Decode MAC commands in FOpts field\r\n                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;\r\n                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;\r\n                    MacCtx.McpsIndication.RxData = true;\r\n                    break;\r\n                }\r\n                case FRAME_TYPE_B:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    > 0   |   X  |   -   |       -      |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // Decode MAC commands in FOpts field\r\n                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    break;\r\n                }\r\n                case FRAME_TYPE_C:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    = 0   |   -  |  = 0  | MAC commands |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // Decode MAC commands in FRMPayload\r\n                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.McpsIndication.RxSlot );\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    break;\r\n                }\r\n                case FRAME_TYPE_D:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    = 0   |   -  |  > 0  |       X      |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // No MAC commands just application payload\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;\r\n                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;\r\n                    MacCtx.McpsIndication.RxData = true;\r\n                    break;\r\n                }\r\n                default:\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                    PrepareRxDoneAbort( );\r\n                    break;\r\n            }\r\n\r\n            // Provide always an indication, skip the callback to the user application,\r\n            // in case of a confirmed downlink retransmission.\r\n            MacCtx.MacFlags.Bits.McpsInd = 1;\r\n\r\n            break;\r\n        case FRAME_TYPE_PROPRIETARY:\r\n            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );\r\n\r\n            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;\r\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;\r\n            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;\r\n\r\n            MacCtx.MacFlags.Bits.McpsInd = 1;\r\n            break;\r\n        default:\r\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n            PrepareRxDoneAbort( );\r\n            break;\r\n    }\r\n\r\n    // Verify if we need to disable the AckTimeoutTimer\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        if( MacCtx.McpsConfirm.AckReceived == true )\r\n        {\r\n            OnAckTimeoutTimerEvent( NULL );\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if( MacCtx.NvmCtx->DeviceClass == CLASS_C )\r\n        {\r\n            OnAckTimeoutTimerEvent( NULL );\r\n        }\r\n    }\r\n    MacCtx.MacFlags.Bits.MacDone = 1;\r\n\r\n    UpdateRxSlotIdleState( );\r\n}\r\n\r\nstatic void ProcessRadioTxTimeout( void )\r\n{\r\n    if( MacCtx.NvmCtx->DeviceClass != CLASS_C )\r\n    {\r\n        Radio.Sleep( );\r\n    }\r\n    UpdateRxSlotIdleState( );\r\n\r\n    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;\r\n    LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT );\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        MacCtx.AckTimeoutRetry = true;\r\n    }\r\n    MacCtx.MacFlags.Bits.MacDone = 1;\r\n}\r\n\r\nstatic void HandleRadioRxErrorTimeout( LoRaMacEventInfoStatus_t rx1EventInfoStatus, LoRaMacEventInfoStatus_t rx2EventInfoStatus )\r\n{\r\n    bool classBRx = false;\r\n\r\n    if( MacCtx.NvmCtx->DeviceClass != CLASS_C )\r\n    {\r\n        Radio.Sleep( );\r\n    }\r\n\r\n    if( LoRaMacClassBIsBeaconExpected( ) == true )\r\n    {\r\n        LoRaMacClassBSetBeaconState( BEACON_STATE_TIMEOUT );\r\n        LoRaMacClassBBeaconTimerEvent( NULL );\r\n        classBRx = true;\r\n    }\r\n    if( MacCtx.NvmCtx->DeviceClass == CLASS_B )\r\n    {\r\n        if( LoRaMacClassBIsPingExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBPingSlotTimerEvent( NULL );\r\n            classBRx = true;\r\n        }\r\n        if( LoRaMacClassBIsMulticastExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBMulticastSlotTimerEvent( NULL );\r\n            classBRx = true;\r\n        }\r\n    }\r\n\r\n    if( classBRx == false )\r\n    {\r\n        if( MacCtx.RxSlot == RX_SLOT_WIN_1 )\r\n        {\r\n            if( MacCtx.NodeAckRequested == true )\r\n            {\r\n                MacCtx.McpsConfirm.Status = rx1EventInfoStatus;\r\n            }\r\n            LoRaMacConfirmQueueSetStatusCmn( rx1EventInfoStatus );\r\n\r\n            if( TimerGetElapsedTime( MacCtx.NvmCtx->LastTxDoneTime ) >= MacCtx.RxWindow2Delay )\r\n            {\r\n                TimerStop( &MacCtx.RxWindowTimer2 );\r\n                MacCtx.MacFlags.Bits.MacDone = 1;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if( MacCtx.NodeAckRequested == true )\r\n            {\r\n                MacCtx.McpsConfirm.Status = rx2EventInfoStatus;\r\n            }\r\n            LoRaMacConfirmQueueSetStatusCmn( rx2EventInfoStatus );\r\n\r\n            if( MacCtx.NvmCtx->DeviceClass != CLASS_C )\r\n            {\r\n                MacCtx.MacFlags.Bits.MacDone = 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    UpdateRxSlotIdleState( );\r\n}\r\n\r\nstatic void ProcessRadioRxError( void )\r\n{\r\n    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_ERROR, LORAMAC_EVENT_INFO_STATUS_RX2_ERROR );\r\n}\r\n\r\nstatic void ProcessRadioRxTimeout( void )\r\n{\r\n    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT, LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT );\r\n}\r\n\r\nstatic void LoRaMacHandleIrqEvents( void )\r\n{\r\n    LoRaMacRadioEvents_t events;\r\n\r\n    CRITICAL_SECTION_BEGIN( );\r\n    events = LoRaMacRadioEvents;\r\n    LoRaMacRadioEvents.Value = 0;\r\n    CRITICAL_SECTION_END( );\r\n\r\n    if( events.Value != 0 )\r\n    {\r\n        if( events.Events.TxDone == 1 )\r\n        {\r\n            ProcessRadioTxDone( );\r\n        }\r\n        if( events.Events.RxDone == 1 )\r\n        {\r\n            ProcessRadioRxDone( );\r\n        }\r\n        if( events.Events.TxTimeout == 1 )\r\n        {\r\n            ProcessRadioTxTimeout( );\r\n        }\r\n        if( events.Events.RxError == 1 )\r\n        {\r\n            ProcessRadioRxError( );\r\n        }\r\n        if( events.Events.RxTimeout == 1 )\r\n        {\r\n            ProcessRadioRxTimeout( );\r\n        }\r\n    }\r\n}\r\n\r\nbool LoRaMacIsBusy( void )\r\n{\r\n    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&\r\n        ( MacCtx.AllowRequests == LORAMAC_REQUEST_HANDLING_ON ) )\r\n    {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\nstatic void LoRaMacEnableRequests( LoRaMacRequestHandling_t requestState )\r\n{\r\n    MacCtx.AllowRequests = requestState;\r\n}\r\n\r\nstatic void LoRaMacHandleRequestEvents( void )\r\n{\r\n    // Handle events\r\n    LoRaMacFlags_t reqEvents = MacCtx.MacFlags;\r\n\r\n    if( MacCtx.MacState == LORAMAC_IDLE )\r\n    {\r\n        // Update event bits\r\n        if( MacCtx.MacFlags.Bits.McpsReq == 1 )\r\n        {\r\n            MacCtx.MacFlags.Bits.McpsReq = 0;\r\n        }\r\n\r\n        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\r\n        {\r\n            MacCtx.MacFlags.Bits.MlmeReq = 0;\r\n        }\r\n\r\n        // Allow requests again\r\n        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );\r\n\r\n        // Handle callbacks\r\n        if( reqEvents.Bits.McpsReq == 1 )\r\n        {\r\n            MacCtx.MacPrimitives->MacMcpsConfirm( &MacCtx.McpsConfirm );\r\n        }\r\n\r\n        if( reqEvents.Bits.MlmeReq == 1 )\r\n        {\r\n            LoRaMacConfirmQueueHandleCb( &MacCtx.MlmeConfirm );\r\n            if( LoRaMacConfirmQueueGetCnt( ) > 0 )\r\n            {\r\n                MacCtx.MacFlags.Bits.MlmeReq = 1;\r\n            }\r\n        }\r\n\r\n        // Start beaconing again\r\n        LoRaMacClassBResumeBeaconing( );\r\n\r\n        // Procedure done. Reset variables.\r\n        MacCtx.MacFlags.Bits.MacDone = 0;\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleScheduleUplinkEvent( void )\r\n{\r\n    // Handle events\r\n    if( MacCtx.MacState == LORAMAC_IDLE )\r\n    {\r\n        // Verify if sticky MAC commands are pending or not\r\n        bool isStickyMacCommandPending = false;\r\n        LoRaMacCommandsStickyCmdsPending( &isStickyMacCommandPending );\r\n        if( isStickyMacCommandPending == true )\r\n        {// Setup MLME indication\r\n            SetMlmeScheduleUplinkIndication( );\r\n        }\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleIndicationEvents( void )\r\n{\r\n    // Handle MLME indication\r\n    if( MacCtx.MacFlags.Bits.MlmeInd == 1 )\r\n    {\r\n        MacCtx.MacFlags.Bits.MlmeInd = 0;\r\n        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication );\r\n    }\r\n\r\n    if( MacCtx.MacFlags.Bits.MlmeSchedUplinkInd == 1 )\r\n    {\r\n        MlmeIndication_t schduleUplinkIndication;\r\n        schduleUplinkIndication.MlmeIndication = MLME_SCHEDULE_UPLINK;\r\n        schduleUplinkIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n\r\n        MacCtx.MacPrimitives->MacMlmeIndication( &schduleUplinkIndication );\r\n        MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 0;\r\n    }\r\n\r\n    // Handle MCPS indication\r\n    if( MacCtx.MacFlags.Bits.McpsInd == 1 )\r\n    {\r\n        MacCtx.MacFlags.Bits.McpsInd = 0;\r\n        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication );\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleMcpsRequest( void )\r\n{\r\n    // Handle MCPS uplinks\r\n    if( MacCtx.MacFlags.Bits.McpsReq == 1 )\r\n    {\r\n        bool stopRetransmission = false;\r\n        bool waitForRetransmission = false;\r\n\r\n        if( ( MacCtx.McpsConfirm.McpsRequest == MCPS_UNCONFIRMED ) ||\r\n            ( MacCtx.McpsConfirm.McpsRequest == MCPS_PROPRIETARY ) )\r\n        {\r\n            stopRetransmission = CheckRetransUnconfirmedUplink( );\r\n        }\r\n        else if( MacCtx.McpsConfirm.McpsRequest == MCPS_CONFIRMED )\r\n        {\r\n            if( MacCtx.AckTimeoutRetry == true )\r\n            {\r\n                stopRetransmission = CheckRetransConfirmedUplink( );\r\n\r\n                if( MacCtx.NvmCtx->Version.Fields.Minor == 0 )\r\n                {\r\n                    if( stopRetransmission == false )\r\n                    {\r\n                        AckTimeoutRetriesProcess( );\r\n                    }\r\n                    else\r\n                    {\r\n                        AckTimeoutRetriesFinalize( );\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                waitForRetransmission = true;\r\n            }\r\n        }\r\n\r\n        if( stopRetransmission == true )\r\n        {// Stop retransmission\r\n            TimerStop( &MacCtx.TxDelayedTimer );\r\n            MacCtx.MacState &= ~LORAMAC_TX_DELAYED;\r\n            StopRetransmission( );\r\n        }\r\n        else if( waitForRetransmission == false )\r\n        {// Arrange further retransmission\r\n            MacCtx.MacFlags.Bits.MacDone = 0;\r\n            // Reset the state of the AckTimeout\r\n            MacCtx.AckTimeoutRetry = false;\r\n            // Sends the same frame again\r\n            OnTxDelayedTimerEvent( NULL );\r\n        }\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleMlmeRequest( void )\r\n{\r\n    // Handle join request\r\n    if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\r\n    {\r\n        if( ( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true ) )\r\n        {\r\n            if( LoRaMacConfirmQueueGetStatus( MLME_JOIN ) == LORAMAC_EVENT_INFO_STATUS_OK )\r\n            {// Node joined successfully\r\n                MacCtx.ChannelsNbTransCounter = 0;\r\n            }\r\n            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n        }\r\n        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||\r\n                 ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW_1 ) == true ) )\r\n        {\r\n            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n        }\r\n    }\r\n}\r\n\r\nstatic uint8_t LoRaMacCheckForBeaconAcquisition( void )\r\n{\r\n    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&\r\n        ( MacCtx.MacFlags.Bits.McpsReq == 0 ) )\r\n    {\r\n        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\r\n        {\r\n            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n            return 0x01;\r\n        }\r\n    }\r\n    return 0x00;\r\n}\r\n\r\nstatic void LoRaMacCheckForRxAbort( void )\r\n{\r\n    // A error occurs during receiving\r\n    if( ( MacCtx.MacState & LORAMAC_RX_ABORT ) == LORAMAC_RX_ABORT )\r\n    {\r\n        MacCtx.MacState &= ~LORAMAC_RX_ABORT;\r\n        MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n    }\r\n}\r\n\r\n\r\nvoid LoRaMacProcess( void )\r\n{\r\n    uint8_t noTx = false;\r\n\r\n    LoRaMacHandleIrqEvents( );\r\n    LoRaMacClassBProcess( );\r\n\r\n    // MAC proceeded a state and is ready to check\r\n    if( MacCtx.MacFlags.Bits.MacDone == 1 )\r\n    {\r\n        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_OFF );\r\n        LoRaMacCheckForRxAbort( );\r\n\r\n        // An error occurs during transmitting\r\n        if( IsRequestPending( ) > 0 )\r\n        {\r\n            noTx |= LoRaMacCheckForBeaconAcquisition( );\r\n        }\r\n\r\n        if( noTx == 0x00 )\r\n        {\r\n            LoRaMacHandleMlmeRequest( );\r\n            LoRaMacHandleMcpsRequest( );\r\n        }\r\n        LoRaMacHandleRequestEvents( );\r\n        LoRaMacHandleScheduleUplinkEvent( );\r\n        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );\r\n    }\r\n    LoRaMacHandleIndicationEvents( );\r\n    if( MacCtx.RxSlot == RX_SLOT_WIN_CLASS_C )\r\n    {\r\n        OpenContinuousRxCWindow( );\r\n    }\r\n}\r\n\r\nstatic void OnTxDelayedTimerEvent( void* context )\r\n{\r\n    TimerStop( &MacCtx.TxDelayedTimer );\r\n    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;\r\n\r\n    // Schedule frame, allow delayed frame transmissions\r\n    switch( ScheduleTx( true ) )\r\n    {\r\n        case LORAMAC_STATUS_OK:\r\n        case LORAMAC_STATUS_DUTYCYCLE_RESTRICTED:\r\n        {\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            // Stop retransmission attempt\r\n            MacCtx.McpsConfirm.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n            MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;\r\n            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;\r\n            LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR );\r\n            StopRetransmission( );\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nstatic void OnRxWindow1TimerEvent( void* context )\r\n{\r\n    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;\r\n    MacCtx.RxWindow1Config.DrOffset = MacCtx.NvmCtx->MacParams.Rx1DrOffset;\r\n    MacCtx.RxWindow1Config.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n    MacCtx.RxWindow1Config.RxContinuous = false;\r\n    MacCtx.RxWindow1Config.RxSlot = RX_SLOT_WIN_1;\r\n\r\n    RxWindowSetup( &MacCtx.RxWindowTimer1, &MacCtx.RxWindow1Config );\r\n}\r\n\r\nstatic void OnRxWindow2TimerEvent( void* context )\r\n{\r\n    // Check if we are processing Rx1 window.\r\n    // If yes, we don't setup the Rx2 window.\r\n    if( MacCtx.RxSlot == RX_SLOT_WIN_1 )\r\n    {\r\n        return;\r\n    }\r\n    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;\r\n    MacCtx.RxWindow2Config.Frequency = MacCtx.NvmCtx->MacParams.Rx2Channel.Frequency;\r\n    MacCtx.RxWindow2Config.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n    MacCtx.RxWindow2Config.RxContinuous = false;\r\n    MacCtx.RxWindow2Config.RxSlot = RX_SLOT_WIN_2;\r\n\r\n    RxWindowSetup( &MacCtx.RxWindowTimer2, &MacCtx.RxWindow2Config );\r\n}\r\n\r\nstatic void OnAckTimeoutTimerEvent( void* context )\r\n{\r\n    TimerStop( &MacCtx.AckTimeoutTimer );\r\n\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        MacCtx.AckTimeoutRetry = true;\r\n    }\r\n    if( MacCtx.NvmCtx->DeviceClass == CLASS_C )\r\n    {\r\n        MacCtx.MacFlags.Bits.MacDone = 1;\r\n    }\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic LoRaMacCryptoStatus_t GetFCntDown( AddressIdentifier_t addrID, FType_t fType, LoRaMacMessageData_t* macMsg, Version_t lrWanVersion,\r\n                                          uint16_t maxFCntGap, FCntIdentifier_t* fCntID, uint32_t* currentDown )\r\n{\r\n    if( ( macMsg == NULL ) || ( fCntID == NULL ) ||\r\n        ( currentDown == NULL ) )\r\n    {\r\n        return LORAMAC_CRYPTO_ERROR_NPE;\r\n    }\r\n\r\n    // Determine the frame counter identifier and choose counter from FCntList\r\n    switch( addrID )\r\n    {\r\n        case UNICAST_DEV_ADDR:\r\n            if( lrWanVersion.Fields.Minor == 1 )\r\n            {\r\n                if( ( fType == FRAME_TYPE_A ) || ( fType == FRAME_TYPE_D ) )\r\n                {\r\n                    *fCntID = A_FCNT_DOWN;\r\n                }\r\n                else\r\n                {\r\n                    *fCntID = N_FCNT_DOWN;\r\n                }\r\n            }\r\n            else\r\n            { // For LoRaWAN 1.0.X\r\n                *fCntID = FCNT_DOWN;\r\n            }\r\n            break;\r\n        case MULTICAST_0_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_0;\r\n            break;\r\n        case MULTICAST_1_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_1;\r\n            break;\r\n        case MULTICAST_2_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_2;\r\n            break;\r\n        case MULTICAST_3_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_3;\r\n            break;\r\n        default:\r\n            return LORAMAC_CRYPTO_FAIL_FCNT_ID;\r\n    }\r\n\r\n    return LoRaMacCryptoGetFCntDown( *fCntID, maxFCntGap, macMsg->FHDR.FCnt, currentDown );\r\n}\r\n\r\nstatic LoRaMacStatus_t SwitchClass( DeviceClass_t deviceClass )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n\r\n    switch( MacCtx.NvmCtx->DeviceClass )\r\n    {\r\n        case CLASS_A:\r\n        {\r\n            if( deviceClass == CLASS_A )\r\n            {\r\n                // Revert back RxC parameters\r\n                MacCtx.NvmCtx->MacParams.RxCChannel = MacCtx.NvmCtx->MacParams.Rx2Channel;\r\n            }\r\n            if( deviceClass == CLASS_B )\r\n            {\r\n                status = LoRaMacClassBSwitchClass( deviceClass );\r\n                if( status == LORAMAC_STATUS_OK )\r\n                {\r\n                    MacCtx.NvmCtx->DeviceClass = deviceClass;\r\n                }\r\n            }\r\n\r\n            if( deviceClass == CLASS_C )\r\n            {\r\n                MacCtx.NvmCtx->DeviceClass = deviceClass;\r\n\r\n                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;\r\n                MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n\r\n                for( int8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n                {\r\n                    if( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.IsEnabled == true )\r\n                    // TODO: Check multicast channel device class.\r\n                    {\r\n                        MacCtx.NvmCtx->MacParams.RxCChannel.Frequency = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.RxParams.ClassC.Frequency;\r\n                        MacCtx.NvmCtx->MacParams.RxCChannel.Datarate = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.RxParams.ClassC.Datarate;\r\n\r\n                        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;\r\n                        MacCtx.RxWindowCConfig.Frequency = MacCtx.NvmCtx->MacParams.RxCChannel.Frequency;\r\n                        MacCtx.RxWindowCConfig.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n                        MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;\r\n                        MacCtx.RxWindowCConfig.RxContinuous = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Set the NodeAckRequested indicator to default\r\n                MacCtx.NodeAckRequested = false;\r\n                // Set the radio into sleep mode in case we are still in RX mode\r\n                Radio.Sleep( );\r\n\r\n                OpenContinuousRxCWindow( );\r\n\r\n                status = LORAMAC_STATUS_OK;\r\n            }\r\n            break;\r\n        }\r\n        case CLASS_B:\r\n        {\r\n            status = LoRaMacClassBSwitchClass( deviceClass );\r\n            if( status == LORAMAC_STATUS_OK )\r\n            {\r\n                MacCtx.NvmCtx->DeviceClass = deviceClass;\r\n            }\r\n            break;\r\n        }\r\n        case CLASS_C:\r\n        {\r\n            if( deviceClass == CLASS_A )\r\n            {\r\n                MacCtx.NvmCtx->DeviceClass = deviceClass;\r\n\r\n                // Set the radio into sleep to setup a defined state\r\n                Radio.Sleep( );\r\n\r\n                status = LORAMAC_STATUS_OK;\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\nstatic uint8_t GetMaxAppPayloadWithoutFOptsLength( int8_t datarate )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n\r\n    // Setup PHY request\r\n    getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n    getPhy.Datarate = datarate;\r\n    getPhy.Attribute = PHY_MAX_PAYLOAD;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n\r\n    return phyParam.Value;\r\n}\r\n\r\nstatic bool ValidatePayloadLength( uint8_t lenN, int8_t datarate, uint8_t fOptsLen )\r\n{\r\n    uint16_t maxN = 0;\r\n    uint16_t payloadSize = 0;\r\n\r\n    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );\r\n\r\n    // Calculate the resulting payload size\r\n    payloadSize = ( lenN + fOptsLen );\r\n\r\n    // Validation of the application payload size\r\n    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )\r\n    {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic void SetMlmeScheduleUplinkIndication( void )\r\n{\r\n    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;\r\n}\r\n\r\nstatic void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )\r\n{\r\n    uint8_t status = 0;\r\n    bool adrBlockFound = false;\r\n    uint8_t macCmdPayload[2] = { 0x00, 0x00 };\r\n\r\n    while( macIndex < commandsSize )\r\n    {\r\n        // Make sure to parse only complete MAC commands\r\n        if( ( LoRaMacCommandsGetCmdSize( payload[macIndex] ) + macIndex ) > commandsSize )\r\n        {\r\n            return;\r\n        }\r\n\r\n        // Decode Frame MAC commands\r\n        switch( payload[macIndex++] )\r\n        {\r\n            case SRV_MAC_LINK_CHECK_ANS:\r\n            {\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_LINK_CHECK ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_LINK_CHECK );\r\n                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];\r\n                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_LINK_ADR_REQ:\r\n            {\r\n                LinkAdrReqParams_t linkAdrReq;\r\n                int8_t linkAdrDatarate = DR_0;\r\n                int8_t linkAdrTxPower = TX_POWER_0;\r\n                uint8_t linkAdrNbRep = 0;\r\n                uint8_t linkAdrNbBytesParsed = 0;\r\n\r\n                if( adrBlockFound == false )\r\n                {\r\n                    adrBlockFound = true;\r\n\r\n                    // Fill parameter structure\r\n                    linkAdrReq.Payload = &payload[macIndex - 1];\r\n                    linkAdrReq.PayloadSize = commandsSize - ( macIndex - 1 );\r\n                    linkAdrReq.AdrEnabled = MacCtx.NvmCtx->AdrCtrlOn;\r\n                    linkAdrReq.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n                    linkAdrReq.CurrentDatarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n                    linkAdrReq.CurrentTxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n                    linkAdrReq.CurrentNbRep = MacCtx.NvmCtx->MacParams.ChannelsNbTrans;\r\n                    linkAdrReq.Version = MacCtx.NvmCtx->Version;\r\n\r\n                    // Process the ADR requests\r\n                    status = RegionLinkAdrReq( MacCtx.NvmCtx->Region, &linkAdrReq, &linkAdrDatarate,\r\n                                               &linkAdrTxPower, &linkAdrNbRep, &linkAdrNbBytesParsed );\r\n\r\n                    if( ( status & 0x07 ) == 0x07 )\r\n                    {\r\n                        MacCtx.NvmCtx->MacParams.ChannelsDatarate = linkAdrDatarate;\r\n                        MacCtx.NvmCtx->MacParams.ChannelsTxPower = linkAdrTxPower;\r\n                        MacCtx.NvmCtx->MacParams.ChannelsNbTrans = linkAdrNbRep;\r\n                    }\r\n\r\n                    // Add the answers to the buffer\r\n                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )\r\n                    {\r\n                        LoRaMacCommandsAddCmd( MOTE_MAC_LINK_ADR_ANS, &status, 1 );\r\n                    }\r\n                    // Update MAC index\r\n                    macIndex += linkAdrNbBytesParsed - 1;\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_DUTY_CYCLE_REQ:\r\n            {\r\n                MacCtx.NvmCtx->MaxDCycle = payload[macIndex++] & 0x0F;\r\n                MacCtx.NvmCtx->AggregatedDCycle = 1 << MacCtx.NvmCtx->MaxDCycle;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_DUTY_CYCLE_ANS, macCmdPayload, 0 );\r\n                break;\r\n            }\r\n            case SRV_MAC_RX_PARAM_SETUP_REQ:\r\n            {\r\n                RxParamSetupReqParams_t rxParamSetupReq;\r\n                status = 0x07;\r\n\r\n                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;\r\n                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;\r\n                macIndex++;\r\n\r\n                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];\r\n                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;\r\n                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;\r\n                rxParamSetupReq.Frequency *= 100;\r\n\r\n                // Perform request on region\r\n                status = RegionRxParamSetupReq( MacCtx.NvmCtx->Region, &rxParamSetupReq );\r\n\r\n                if( ( status & 0x07 ) == 0x07 )\r\n                {\r\n                    MacCtx.NvmCtx->MacParams.Rx2Channel.Datarate = rxParamSetupReq.Datarate;\r\n                    MacCtx.NvmCtx->MacParams.RxCChannel.Datarate = rxParamSetupReq.Datarate;\r\n                    MacCtx.NvmCtx->MacParams.Rx2Channel.Frequency = rxParamSetupReq.Frequency;\r\n                    MacCtx.NvmCtx->MacParams.RxCChannel.Frequency = rxParamSetupReq.Frequency;\r\n                    MacCtx.NvmCtx->MacParams.Rx1DrOffset = rxParamSetupReq.DrOffset;\r\n                }\r\n                macCmdPayload[0] = status;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_RX_PARAM_SETUP_ANS, macCmdPayload, 1 );\r\n                // Setup indication to inform the application\r\n                SetMlmeScheduleUplinkIndication( );\r\n                break;\r\n            }\r\n            case SRV_MAC_DEV_STATUS_REQ:\r\n            {\r\n                uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;\r\n                if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->GetBatteryLevel != NULL ) )\r\n                {\r\n                    batteryLevel = MacCtx.MacCallbacks->GetBatteryLevel( );\r\n                }\r\n                macCmdPayload[0] = batteryLevel;\r\n                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_DEV_STATUS_ANS, macCmdPayload, 2 );\r\n                break;\r\n            }\r\n            case SRV_MAC_NEW_CHANNEL_REQ:\r\n            {\r\n                NewChannelReqParams_t newChannelReq;\r\n                ChannelParams_t chParam;\r\n                status = 0x03;\r\n\r\n                newChannelReq.ChannelId = payload[macIndex++];\r\n                newChannelReq.NewChannel = &chParam;\r\n\r\n                chParam.Frequency = ( uint32_t ) payload[macIndex++];\r\n                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;\r\n                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;\r\n                chParam.Frequency *= 100;\r\n                chParam.Rx1Frequency = 0;\r\n                chParam.DrRange.Value = payload[macIndex++];\r\n\r\n                status = RegionNewChannelReq( MacCtx.NvmCtx->Region, &newChannelReq );\r\n\r\n                macCmdPayload[0] = status;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_NEW_CHANNEL_ANS, macCmdPayload, 1 );\r\n                break;\r\n            }\r\n            case SRV_MAC_RX_TIMING_SETUP_REQ:\r\n            {\r\n                uint8_t delay = payload[macIndex++] & 0x0F;\r\n\r\n                if( delay == 0 )\r\n                {\r\n                    delay++;\r\n                }\r\n                MacCtx.NvmCtx->MacParams.ReceiveDelay1 = delay * 1000;\r\n                MacCtx.NvmCtx->MacParams.ReceiveDelay2 = MacCtx.NvmCtx->MacParams.ReceiveDelay1 + 1000;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );\r\n                // Setup indication to inform the application\r\n                SetMlmeScheduleUplinkIndication( );\r\n                break;\r\n            }\r\n            case SRV_MAC_TX_PARAM_SETUP_REQ:\r\n            {\r\n                TxParamSetupReqParams_t txParamSetupReq;\r\n                GetPhyParams_t getPhy;\r\n                PhyParam_t phyParam;\r\n                uint8_t eirpDwellTime = payload[macIndex++];\r\n\r\n                txParamSetupReq.UplinkDwellTime = 0;\r\n                txParamSetupReq.DownlinkDwellTime = 0;\r\n\r\n                if( ( eirpDwellTime & 0x20 ) == 0x20 )\r\n                {\r\n                    txParamSetupReq.DownlinkDwellTime = 1;\r\n                }\r\n                if( ( eirpDwellTime & 0x10 ) == 0x10 )\r\n                {\r\n                    txParamSetupReq.UplinkDwellTime = 1;\r\n                }\r\n                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;\r\n\r\n                // Check the status for correctness\r\n                if( RegionTxParamSetupReq( MacCtx.NvmCtx->Region, &txParamSetupReq ) != -1 )\r\n                {\r\n                    // Accept command\r\n                    MacCtx.NvmCtx->MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;\r\n                    MacCtx.NvmCtx->MacParams.DownlinkDwellTime = txParamSetupReq.DownlinkDwellTime;\r\n                    MacCtx.NvmCtx->MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];\r\n                    // Update the datarate in case of the new configuration limits it\r\n                    getPhy.Attribute = PHY_MIN_TX_DR;\r\n                    getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n                    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n                    MacCtx.NvmCtx->MacParams.ChannelsDatarate = MAX( MacCtx.NvmCtx->MacParams.ChannelsDatarate, ( int8_t )phyParam.Value );\r\n\r\n                    // Add command response\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_DL_CHANNEL_REQ:\r\n            {\r\n                DlChannelReqParams_t dlChannelReq;\r\n                status = 0x03;\r\n\r\n                dlChannelReq.ChannelId = payload[macIndex++];\r\n                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];\r\n                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;\r\n                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;\r\n                dlChannelReq.Rx1Frequency *= 100;\r\n\r\n                status = RegionDlChannelReq( MacCtx.NvmCtx->Region, &dlChannelReq );\r\n                macCmdPayload[0] = status;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );\r\n                // Setup indication to inform the application\r\n                SetMlmeScheduleUplinkIndication( );\r\n                break;\r\n            }\r\n            case SRV_MAC_DEVICE_TIME_ANS:\r\n            {\r\n                SysTime_t gpsEpochTime = { 0 };\r\n                SysTime_t sysTime = { 0 };\r\n                SysTime_t sysTimeCurrent = { 0 };\r\n\r\n                gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];\r\n                gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;\r\n                gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;\r\n                gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;\r\n                gpsEpochTime.SubSeconds = payload[macIndex++];\r\n\r\n                // Convert the fractional second received in ms\r\n                // round( pow( 0.5, 8.0 ) * 1000 ) = 3.90625\r\n                gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );\r\n\r\n                // Copy received GPS Epoch time into system time\r\n                sysTime = gpsEpochTime;\r\n                // Add Unix to Gps epcoh offset. The system time is based on Unix time.\r\n                sysTime.Seconds += UNIX_GPS_EPOCH_OFFSET;\r\n\r\n                // Compensate time difference between Tx Done time and now\r\n                sysTimeCurrent = SysTimeGet( );\r\n                sysTime = SysTimeAdd( sysTimeCurrent, SysTimeSub( sysTime, MacCtx.LastTxSysTime ) );\r\n\r\n                // Apply the new system time.\r\n                SysTimeSet( sysTime );\r\n                LoRaMacClassBDeviceTimeAns( );\r\n                MacCtx.McpsIndication.DeviceTimeAnsReceived = true;\r\n                break;\r\n            }\r\n            case SRV_MAC_PING_SLOT_INFO_ANS:\r\n            {\r\n                // According to the specification, it is not allowed to process this answer in\r\n                // a ping or multicast slot\r\n                if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )\r\n                {\r\n                    LoRaMacClassBPingSlotInfoAns( );\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_PING_SLOT_CHANNEL_REQ:\r\n            {\r\n                uint8_t status = 0x03;\r\n                uint32_t frequency = 0;\r\n                uint8_t datarate;\r\n\r\n                frequency = ( uint32_t )payload[macIndex++];\r\n                frequency |= ( uint32_t )payload[macIndex++] << 8;\r\n                frequency |= ( uint32_t )payload[macIndex++] << 16;\r\n                frequency *= 100;\r\n                datarate = payload[macIndex++] & 0x0F;\r\n\r\n                status = LoRaMacClassBPingSlotChannelReq( datarate, frequency );\r\n                macCmdPayload[0] = status;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_FREQ_ANS, macCmdPayload, 1 );\r\n                break;\r\n            }\r\n            case SRV_MAC_BEACON_TIMING_ANS:\r\n            {\r\n                uint16_t beaconTimingDelay = 0;\r\n                uint8_t beaconTimingChannel = 0;\r\n\r\n                beaconTimingDelay = ( uint16_t )payload[macIndex++];\r\n                beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;\r\n                beaconTimingChannel = payload[macIndex++];\r\n\r\n                LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );\r\n                break;\r\n            }\r\n            case SRV_MAC_BEACON_FREQ_REQ:\r\n                {\r\n                    uint32_t frequency = 0;\r\n\r\n                    frequency = ( uint32_t )payload[macIndex++];\r\n                    frequency |= ( uint32_t )payload[macIndex++] << 8;\r\n                    frequency |= ( uint32_t )payload[macIndex++] << 16;\r\n                    frequency *= 100;\r\n\r\n                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )\r\n                    {\r\n                        macCmdPayload[0] = 1;\r\n                    }\r\n                    else\r\n                    {\r\n                        macCmdPayload[0] = 0;\r\n                    }\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );\r\n                }\r\n                break;\r\n            default:\r\n                // Unknown command. ABORT MAC commands processing\r\n                return;\r\n        }\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t Send( LoRaMacHeader_t* macHdr, uint8_t fPort, void* fBuffer, uint16_t fBufferSize )\r\n{\r\n    LoRaMacFrameCtrl_t fCtrl;\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n    int8_t datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n    int8_t txPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n    uint32_t adrAckCounter = MacCtx.NvmCtx->AdrAckCounter;\r\n    CalcNextAdrParams_t adrNext;\r\n\r\n    // Check if we are joined\r\n    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        return LORAMAC_STATUS_NO_NETWORK_JOINED;\r\n    }\r\n    if( MacCtx.NvmCtx->MaxDCycle == 0 )\r\n    {\r\n        MacCtx.NvmCtx->AggregatedTimeOff = 0;\r\n    }\r\n\r\n    fCtrl.Value = 0;\r\n    fCtrl.Bits.FOptsLen      = 0;\r\n    fCtrl.Bits.Adr           = MacCtx.NvmCtx->AdrCtrlOn;\r\n\r\n    // Check class b\r\n    if( MacCtx.NvmCtx->DeviceClass == CLASS_B )\r\n    {\r\n        fCtrl.Bits.FPending      = 1;\r\n    }\r\n    else\r\n    {\r\n        fCtrl.Bits.FPending      = 0;\r\n    }\r\n\r\n    // Check server ack\r\n    if( MacCtx.NvmCtx->SrvAckRequested == true )\r\n    {\r\n        fCtrl.Bits.Ack = 1;\r\n    }\r\n\r\n    // ADR next request\r\n    adrNext.Version = MacCtx.NvmCtx->Version;\r\n    adrNext.UpdateChanMask = true;\r\n    adrNext.AdrEnabled = fCtrl.Bits.Adr;\r\n    adrNext.AdrAckCounter = MacCtx.NvmCtx->AdrAckCounter;\r\n    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;\r\n    adrNext.AdrAckDelay = MacCtx.AdrAckDelay;\r\n    adrNext.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n    adrNext.TxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n    adrNext.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n    adrNext.Region = MacCtx.NvmCtx->Region;\r\n\r\n    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &MacCtx.NvmCtx->MacParams.ChannelsDatarate,\r\n                                               &MacCtx.NvmCtx->MacParams.ChannelsTxPower, &adrAckCounter );\r\n\r\n    // Prepare the frame\r\n    status = PrepareFrame( macHdr, &fCtrl, fPort, fBuffer, fBufferSize );\r\n\r\n    // Validate status\r\n    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )\r\n    {\r\n        // Schedule frame, do not allow delayed transmissions\r\n        status = ScheduleTx( false );\r\n    }\r\n\r\n    // Post processing\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        // Bad case - restore\r\n        // Store local variables\r\n        MacCtx.NvmCtx->MacParams.ChannelsDatarate = datarate;\r\n        MacCtx.NvmCtx->MacParams.ChannelsTxPower = txPower;\r\n    }\r\n    else\r\n    {\r\n        // Good case\r\n        MacCtx.NvmCtx->SrvAckRequested = false;\r\n        MacCtx.NvmCtx->AdrAckCounter = adrAckCounter;\r\n        // Remove all none sticky MAC commands\r\n        if( LoRaMacCommandsRemoveNoneStickyCmds( ) != LORAMAC_COMMANDS_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n        }\r\n    }\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t SendReJoinReq( JoinReqIdentifier_t joinReqType )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_OK;\r\n    LoRaMacHeader_t macHdr;\r\n    macHdr.Value = 0;\r\n    bool allowDelayedTx = true;\r\n\r\n    // Setup join/rejoin message\r\n    switch( joinReqType )\r\n    {\r\n        case JOIN_REQ:\r\n        {\r\n            SwitchClass( CLASS_A );\r\n\r\n            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_JOIN_REQUEST;\r\n            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;\r\n            MacCtx.TxMsg.Message.JoinReq.BufSize = LORAMAC_PHY_MAXPAYLOAD;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_JOIN_REQ;\r\n            MacCtx.TxMsg.Message.JoinReq.MHDR.Value = macHdr.Value;\r\n\r\n            memcpy1( MacCtx.TxMsg.Message.JoinReq.JoinEUI, SecureElementGetJoinEui( ), LORAMAC_JOIN_EUI_FIELD_SIZE );\r\n            memcpy1( MacCtx.TxMsg.Message.JoinReq.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );\r\n\r\n            allowDelayedTx = false;\r\n\r\n            break;\r\n        }\r\n        default:\r\n            status = LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n            break;\r\n    }\r\n\r\n    // Schedule frame\r\n    status = ScheduleTx( allowDelayedTx );\r\n    return status;\r\n}\r\n\r\nstatic LoRaMacStatus_t CheckForClassBCollision( void )\r\n{\r\n    if( LoRaMacClassBIsBeaconExpected( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY_BEACON_RESERVED_TIME;\r\n    }\r\n\r\n    if( MacCtx.NvmCtx->DeviceClass == CLASS_B )\r\n    {\r\n        if( LoRaMacClassBIsPingExpected( ) == true )\r\n        {\r\n            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;\r\n        }\r\n        else if( LoRaMacClassBIsMulticastExpected( ) == true )\r\n        {\r\n            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;\r\n        }\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic LoRaMacStatus_t ScheduleTx( bool allowDelayedTx )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n    TimerTime_t dutyCycleTimeOff = 0;\r\n    NextChanParams_t nextChan;\r\n    size_t macCmdsSize = 0;\r\n\r\n    // Check class b collisions\r\n    status = CheckForClassBCollision( );\r\n\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        return status;\r\n    }\r\n\r\n    // Update back-off\r\n    CalculateBackOff( MacCtx.NvmCtx->LastTxChannel );\r\n\r\n    nextChan.AggrTimeOff = MacCtx.NvmCtx->AggregatedTimeOff;\r\n    nextChan.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n    nextChan.DutyCycleEnabled = MacCtx.NvmCtx->DutyCycleOn;\r\n    nextChan.QueryNextTxDelayOnly = false;\r\n    nextChan.Joined = false;\r\n    if( MacCtx.NvmCtx->NetworkActivation != ACTIVATION_TYPE_NONE )\r\n    {\r\n        nextChan.Joined = true;\r\n    }\r\n    nextChan.LastAggrTx = MacCtx.NvmCtx->LastTxDoneTime;\r\n\r\n    // Select channel\r\n    status = RegionNextChannel( MacCtx.NvmCtx->Region, &nextChan, &MacCtx.Channel, &dutyCycleTimeOff, &MacCtx.NvmCtx->AggregatedTimeOff );\r\n\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        if( ( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED ) &&\r\n            ( allowDelayedTx == true ) )\r\n        {\r\n            // Allow delayed transmissions. We have to allow it in case\r\n            // the MAC must retransmit a frame with the frame repetitions\r\n            if( dutyCycleTimeOff != 0 )\r\n            {// Send later - prepare timer\r\n                MacCtx.MacState |= LORAMAC_TX_DELAYED;\r\n                TimerSetValue( &MacCtx.TxDelayedTimer, dutyCycleTimeOff );\r\n                TimerStart( &MacCtx.TxDelayedTimer );\r\n            }\r\n            return LORAMAC_STATUS_OK;\r\n        }\r\n        else\r\n        {// State where the MAC cannot send a frame\r\n            return status;\r\n        }\r\n    }\r\n\r\n    // Compute Rx1 windows parameters\r\n    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,\r\n                                     RegionApplyDrOffset( MacCtx.NvmCtx->Region, MacCtx.NvmCtx->MacParams.DownlinkDwellTime, MacCtx.NvmCtx->MacParams.ChannelsDatarate, MacCtx.NvmCtx->MacParams.Rx1DrOffset ),\r\n                                     MacCtx.NvmCtx->MacParams.MinRxSymbols,\r\n                                     MacCtx.NvmCtx->MacParams.SystemMaxRxError,\r\n                                     &MacCtx.RxWindow1Config );\r\n    // Compute Rx2 windows parameters\r\n    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,\r\n                                     MacCtx.NvmCtx->MacParams.Rx2Channel.Datarate,\r\n                                     MacCtx.NvmCtx->MacParams.MinRxSymbols,\r\n                                     MacCtx.NvmCtx->MacParams.SystemMaxRxError,\r\n                                     &MacCtx.RxWindow2Config );\r\n\r\n    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        MacCtx.RxWindow1Delay = MacCtx.NvmCtx->MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;\r\n        MacCtx.RxWindow2Delay = MacCtx.NvmCtx->MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;\r\n    }\r\n    else\r\n    {\r\n        if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n        }\r\n\r\n        if( ValidatePayloadLength( MacCtx.AppDataSize, MacCtx.NvmCtx->MacParams.ChannelsDatarate, macCmdsSize ) == false )\r\n        {\r\n            return LORAMAC_STATUS_LENGTH_ERROR;\r\n        }\r\n        MacCtx.RxWindow1Delay = MacCtx.NvmCtx->MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;\r\n        MacCtx.RxWindow2Delay = MacCtx.NvmCtx->MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;\r\n    }\r\n\r\n    // Secure frame\r\n    LoRaMacStatus_t retval = SecureFrame( MacCtx.NvmCtx->MacParams.ChannelsDatarate, MacCtx.Channel );\r\n    if( retval != LORAMAC_STATUS_OK )\r\n    {\r\n        return retval;\r\n    }\r\n\r\n    // Try to send now\r\n    return SendFrameOnChannel( MacCtx.Channel );\r\n}\r\n\r\nstatic LoRaMacStatus_t SecureFrame( uint8_t txDr, uint8_t txCh )\r\n{\r\n    LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR;\r\n    uint32_t fCntUp = 0;\r\n\r\n    switch( MacCtx.TxMsg.Type )\r\n    {\r\n        case LORAMAC_MSG_TYPE_JOIN_REQUEST:\r\n            macCryptoStatus = LoRaMacCryptoPrepareJoinRequest( &MacCtx.TxMsg.Message.JoinReq );\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.JoinReq.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_DATA:\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )\r\n            {\r\n                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;\r\n            }\r\n\r\n            if( ( MacCtx.ChannelsNbTransCounter >= 1 ) || ( MacCtx.AckTimeoutRetriesCounter > 1 ) )\r\n            {\r\n                fCntUp -= 1;\r\n            }\r\n\r\n            macCryptoStatus = LoRaMacCryptoSecureMessage( fCntUp, txDr, txCh, &MacCtx.TxMsg.Message.Data );\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_JOIN_ACCEPT:\r\n        case LORAMAC_MSG_TYPE_UNDEF:\r\n        default:\r\n            return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic void CalculateBackOff( uint8_t channel )\r\n{\r\n    CalcBackOffParams_t calcBackOff;\r\n\r\n    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        calcBackOff.Joined = false;\r\n    }\r\n    else\r\n    {\r\n        calcBackOff.Joined = true;\r\n    }\r\n    calcBackOff.DutyCycleEnabled = MacCtx.NvmCtx->DutyCycleOn;\r\n    calcBackOff.Channel = channel;\r\n    calcBackOff.ElapsedTime = SysTimeSub( SysTimeGetMcuTime( ), MacCtx.NvmCtx->InitializationTime );\r\n    calcBackOff.TxTimeOnAir = MacCtx.TxTimeOnAir;\r\n    calcBackOff.LastTxIsJoinRequest = false;\r\n\r\n    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        calcBackOff.LastTxIsJoinRequest = true;\r\n    }\r\n\r\n    // Update regional back-off\r\n    RegionCalcBackOff( MacCtx.NvmCtx->Region, &calcBackOff );\r\n\r\n    // Update aggregated time-off. This must be an assignment and no incremental\r\n    // update as we do only calculate the time-off based on the last transmission\r\n    MacCtx.NvmCtx->AggregatedTimeOff = ( MacCtx.TxTimeOnAir * MacCtx.NvmCtx->AggregatedDCycle - MacCtx.TxTimeOnAir );\r\n}\r\n\r\nstatic void RemoveMacCommands( LoRaMacRxSlot_t rxSlot, LoRaMacFrameCtrl_t fCtrl, Mcps_t request )\r\n{\r\n    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )\r\n    {\r\n        // Remove all sticky MAC commands answers since we can assume\r\n        // that they have been received by the server.\r\n        if( request == MCPS_CONFIRMED )\r\n        {\r\n            if( fCtrl.Bits.Ack == 1 )\r\n            {  // For confirmed uplinks only if we have received an ACK.\r\n                LoRaMacCommandsRemoveStickyAnsCmds( );\r\n            }\r\n        }\r\n        else\r\n        {\r\n            LoRaMacCommandsRemoveStickyAnsCmds( );\r\n        }\r\n    }\r\n}\r\n\r\n\r\nstatic void ResetMacParameters( void )\r\n{\r\n    MacCtx.NvmCtx->NetworkActivation = ACTIVATION_TYPE_NONE;\r\n\r\n    // ADR counter\r\n    MacCtx.NvmCtx->AdrAckCounter = 0;\r\n\r\n    MacCtx.ChannelsNbTransCounter = 0;\r\n    MacCtx.AckTimeoutRetries = 1;\r\n    MacCtx.AckTimeoutRetriesCounter = 1;\r\n    MacCtx.AckTimeoutRetry = false;\r\n\r\n    MacCtx.NvmCtx->MaxDCycle = 0;\r\n    MacCtx.NvmCtx->AggregatedDCycle = 1;\r\n\r\n    MacCtx.NvmCtx->MacParams.ChannelsTxPower = MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower;\r\n    MacCtx.NvmCtx->MacParams.ChannelsDatarate = MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate;\r\n    MacCtx.NvmCtx->MacParams.Rx1DrOffset = MacCtx.NvmCtx->MacParamsDefaults.Rx1DrOffset;\r\n    MacCtx.NvmCtx->MacParams.Rx2Channel = MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel;\r\n    MacCtx.NvmCtx->MacParams.RxCChannel = MacCtx.NvmCtx->MacParamsDefaults.RxCChannel;\r\n    MacCtx.NvmCtx->MacParams.UplinkDwellTime = MacCtx.NvmCtx->MacParamsDefaults.UplinkDwellTime;\r\n    MacCtx.NvmCtx->MacParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParamsDefaults.DownlinkDwellTime;\r\n    MacCtx.NvmCtx->MacParams.MaxEirp = MacCtx.NvmCtx->MacParamsDefaults.MaxEirp;\r\n    MacCtx.NvmCtx->MacParams.AntennaGain = MacCtx.NvmCtx->MacParamsDefaults.AntennaGain;\r\n\r\n    MacCtx.NodeAckRequested = false;\r\n    MacCtx.NvmCtx->SrvAckRequested = false;\r\n\r\n    // Reset to application defaults\r\n    InitDefaultsParams_t params;\r\n    params.Type = INIT_TYPE_INIT;\r\n    params.NvmCtx = NULL;\r\n    RegionInitDefaults( MacCtx.NvmCtx->Region, &params );\r\n\r\n    // Initialize channel index.\r\n    MacCtx.Channel = 0;\r\n    MacCtx.NvmCtx->LastTxChannel = MacCtx.Channel;\r\n\r\n    // Initialize Rx2 config parameters.\r\n    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;\r\n    MacCtx.RxWindow2Config.Frequency = MacCtx.NvmCtx->MacParams.Rx2Channel.Frequency;\r\n    MacCtx.RxWindow2Config.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n    MacCtx.RxWindow2Config.RxContinuous = false;\r\n    MacCtx.RxWindow2Config.RxSlot = RX_SLOT_WIN_2;\r\n\r\n    // Initialize RxC config parameters.\r\n    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;\r\n    MacCtx.RxWindowCConfig.RxContinuous = true;\r\n    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n\r\n}\r\n\r\n/*!\r\n * \\brief Initializes and opens the reception window\r\n *\r\n * \\param [IN] rxTimer  Window timer to be topped.\r\n * \\param [IN] rxConfig Window parameters to be setup\r\n */\r\nstatic void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )\r\n{\r\n    TimerStop( rxTimer );\r\n\r\n    // Ensure the radio is Idle\r\n    Radio.Standby( );\r\n\r\n    if( RegionRxConfig( MacCtx.NvmCtx->Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )\r\n    {\r\n        Radio.Rx( MacCtx.NvmCtx->MacParams.MaxRxWindow );\r\n        MacCtx.RxSlot = rxConfig->RxSlot;\r\n    }\r\n}\r\n\r\nstatic void OpenContinuousRxCWindow( void )\r\n{\r\n    // Compute RxC windows parameters\r\n    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,\r\n                                     MacCtx.NvmCtx->MacParams.RxCChannel.Datarate,\r\n                                     MacCtx.NvmCtx->MacParams.MinRxSymbols,\r\n                                     MacCtx.NvmCtx->MacParams.SystemMaxRxError,\r\n                                     &MacCtx.RxWindowCConfig );\r\n\r\n    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n    // Setup continuous listening\r\n    MacCtx.RxWindowCConfig.RxContinuous = true;\r\n\r\n    // At this point the Radio should be idle.\r\n    // Thus, there is no need to set the radio in standby mode.\r\n    if( RegionRxConfig( MacCtx.NvmCtx->Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )\r\n    {\r\n        Radio.Rx( 0 ); // Continuous mode\r\n        MacCtx.RxSlot = MacCtx.RxWindowCConfig.RxSlot;\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t PrepareFrame( LoRaMacHeader_t* macHdr, LoRaMacFrameCtrl_t* fCtrl, uint8_t fPort, void* fBuffer, uint16_t fBufferSize )\r\n{\r\n    MacCtx.PktBufferLen = 0;\r\n    MacCtx.NodeAckRequested = false;\r\n    uint32_t fCntUp = 0;\r\n    size_t macCmdsSize = 0;\r\n    uint8_t availableSize = 0;\r\n\r\n    if( fBuffer == NULL )\r\n    {\r\n        fBufferSize = 0;\r\n    }\r\n\r\n    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );\r\n    MacCtx.AppDataSize = fBufferSize;\r\n    MacCtx.PktBuffer[0] = macHdr->Value;\r\n\r\n    switch( macHdr->Bits.MType )\r\n    {\r\n        case FRAME_TYPE_DATA_CONFIRMED_UP:\r\n            MacCtx.NodeAckRequested = true;\r\n            // Intentional fall through\r\n        case FRAME_TYPE_DATA_UNCONFIRMED_UP:\r\n            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;\r\n            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;\r\n            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;\r\n            MacCtx.TxMsg.Message.Data.MHDR.Value = macHdr->Value;\r\n            MacCtx.TxMsg.Message.Data.FPort = fPort;\r\n            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = MacCtx.NvmCtx->DevAddr;\r\n            MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;\r\n            MacCtx.TxMsg.Message.Data.FRMPayloadSize = MacCtx.AppDataSize;\r\n            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )\r\n            {\r\n                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;\r\n            }\r\n            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;\r\n\r\n            // Reset confirm parameters\r\n            MacCtx.McpsConfirm.NbRetries = 0;\r\n            MacCtx.McpsConfirm.AckReceived = false;\r\n            MacCtx.McpsConfirm.UpLinkCounter = fCntUp;\r\n\r\n            // Handle the MAC commands if there are any available\r\n            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n\r\n            if( macCmdsSize > 0 )\r\n            {\r\n                availableSize = GetMaxAppPayloadWithoutFOptsLength( MacCtx.NvmCtx->MacParams.ChannelsDatarate );\r\n\r\n                // There is application payload available and the MAC commands fit into FOpts field.\r\n                if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )\r\n                {\r\n                    if( LoRaMacCommandsSerializeCmds( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH, &macCmdsSize, MacCtx.TxMsg.Message.Data.FHDR.FOpts ) != LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                    }\r\n                    fCtrl->Bits.FOptsLen = macCmdsSize;\r\n                    // Update FCtrl field with new value of FOptionsLength\r\n                    MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;\r\n                }\r\n                // There is application payload available but the MAC commands does NOT fit into FOpts field.\r\n                else if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize > LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )\r\n                {\r\n\r\n                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.NvmCtx->MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                    }\r\n                    return LORAMAC_STATUS_SKIPPED_APP_DATA;\r\n                }\r\n                // No application payload available therefore add all mac commands to the FRMPayload.\r\n                else\r\n                {\r\n                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.NvmCtx->MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                    }\r\n                    // Force FPort to be zero\r\n                    MacCtx.TxMsg.Message.Data.FPort = 0;\r\n\r\n                    MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.NvmCtx->MacCommandsBuffer;\r\n                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;\r\n                }\r\n            }\r\n\r\n            break;\r\n        case FRAME_TYPE_PROPRIETARY:\r\n            if( ( fBuffer != NULL ) && ( MacCtx.AppDataSize > 0 ) )\r\n            {\r\n                memcpy1( MacCtx.PktBuffer + LORAMAC_MHDR_FIELD_SIZE, ( uint8_t* ) fBuffer, MacCtx.AppDataSize );\r\n                MacCtx.PktBufferLen = LORAMAC_MHDR_FIELD_SIZE + MacCtx.AppDataSize;\r\n            }\r\n            break;\r\n        default:\r\n            return LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n    }\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t SendFrameOnChannel( uint8_t channel )\r\n{\r\n    TxConfigParams_t txConfig;\r\n    int8_t txPower = 0;\r\n\r\n    txConfig.Channel = channel;\r\n    txConfig.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n    txConfig.TxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n    txConfig.MaxEirp = MacCtx.NvmCtx->MacParams.MaxEirp;\r\n    txConfig.AntennaGain = MacCtx.NvmCtx->MacParams.AntennaGain;\r\n    txConfig.PktLen = MacCtx.PktBufferLen;\r\n\r\n    RegionTxConfig( MacCtx.NvmCtx->Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );\r\n\r\n    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n    MacCtx.McpsConfirm.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n    MacCtx.McpsConfirm.TxPower = txPower;\r\n    MacCtx.McpsConfirm.Channel = channel;\r\n\r\n    // Store the time on air\r\n    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;\r\n    MacCtx.MlmeConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;\r\n\r\n    if( LoRaMacClassBIsBeaconModeActive( ) == true )\r\n    {\r\n        // Currently, the Time-On-Air can only be computed when the radio is configured with\r\n        // the TX configuration\r\n        TimerTime_t collisionTime = LoRaMacClassBIsUplinkCollision( MacCtx.TxTimeOnAir );\r\n\r\n        if( collisionTime > 0 )\r\n        {\r\n            return LORAMAC_STATUS_BUSY_UPLINK_COLLISION;\r\n        }\r\n    }\r\n\r\n    if( MacCtx.NvmCtx->DeviceClass == CLASS_B )\r\n    {\r\n        // Stop slots for class b\r\n        LoRaMacClassBStopRxSlots( );\r\n    }\r\n\r\n    LoRaMacClassBHaltBeaconing( );\r\n\r\n    MacCtx.MacState |= LORAMAC_TX_RUNNING;\r\n    if( MacCtx.NodeAckRequested == false )\r\n    {\r\n        MacCtx.ChannelsNbTransCounter++;\r\n    }\r\n\r\n    // Send now\r\n    Radio.Send( MacCtx.PktBuffer, MacCtx.PktBufferLen );\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t SetTxContinuousWave( uint16_t timeout )\r\n{\r\n    ContinuousWaveParams_t continuousWave;\r\n\r\n    continuousWave.Channel = MacCtx.Channel;\r\n    continuousWave.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n    continuousWave.TxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n    continuousWave.MaxEirp = MacCtx.NvmCtx->MacParams.MaxEirp;\r\n    continuousWave.AntennaGain = MacCtx.NvmCtx->MacParams.AntennaGain;\r\n    continuousWave.Timeout = timeout;\r\n\r\n    RegionSetContinuousWave( MacCtx.NvmCtx->Region, &continuousWave );\r\n\r\n    MacCtx.MacState |= LORAMAC_TX_RUNNING;\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t SetTxContinuousWave1( uint16_t timeout, uint32_t frequency, uint8_t power )\r\n{\r\n    Radio.SetTxContinuousWave( frequency, power, timeout );\r\n\r\n    MacCtx.MacState |= LORAMAC_TX_RUNNING;\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacCtxs_t* GetCtxs( void )\r\n{\r\n    Contexts.MacNvmCtx = &NvmMacCtx;\r\n    Contexts.MacNvmCtxSize = sizeof( NvmMacCtx );\r\n    Contexts.CryptoNvmCtx = LoRaMacCryptoGetNvmCtx( &Contexts.CryptoNvmCtxSize );\r\n    GetNvmCtxParams_t params ={ 0 };\r\n    Contexts.RegionNvmCtx = RegionGetNvmCtx( MacCtx.NvmCtx->Region, &params );\r\n    Contexts.RegionNvmCtxSize = params.nvmCtxSize;\r\n    Contexts.SecureElementNvmCtx = SecureElementGetNvmCtx( &Contexts.SecureElementNvmCtxSize );\r\n    Contexts.CommandsNvmCtx = LoRaMacCommandsGetNvmCtx( &Contexts.CommandsNvmCtxSize );\r\n    Contexts.ClassBNvmCtx = LoRaMacClassBGetNvmCtx( &Contexts.ClassBNvmCtxSize );\r\n    Contexts.ConfirmQueueNvmCtx = LoRaMacConfirmQueueGetNvmCtx( &Contexts.ConfirmQueueNvmCtxSize );\r\n    return &Contexts;\r\n}\r\n\r\nLoRaMacStatus_t RestoreCtxs( LoRaMacCtxs_t* contexts )\r\n{\r\n    if( contexts == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    if( MacCtx.MacState != LORAMAC_STOPPED )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( contexts->MacNvmCtx != NULL )\r\n    {\r\n        memcpy1( ( uint8_t* ) &NvmMacCtx, ( uint8_t* ) contexts->MacNvmCtx, contexts->MacNvmCtxSize );\r\n    }\r\n\r\n    InitDefaultsParams_t params;\r\n    params.Type = INIT_TYPE_RESTORE_CTX;\r\n    params.NvmCtx = contexts->RegionNvmCtx;\r\n    RegionInitDefaults( MacCtx.NvmCtx->Region, &params );\r\n\r\n    // Initialize RxC config parameters.\r\n    MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;\r\n    MacCtx.RxWindowCConfig.Frequency = MacCtx.NvmCtx->MacParams.RxCChannel.Frequency;\r\n    MacCtx.RxWindowCConfig.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n    MacCtx.RxWindowCConfig.RxContinuous = true;\r\n    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n\r\n    if( SecureElementRestoreNvmCtx( contexts->SecureElementNvmCtx ) != SECURE_ELEMENT_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    if( LoRaMacCryptoRestoreNvmCtx( contexts->CryptoNvmCtx ) != LORAMAC_CRYPTO_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    if( LoRaMacCommandsRestoreNvmCtx( contexts->CommandsNvmCtx ) != LORAMAC_COMMANDS_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n    }\r\n\r\n    if( LoRaMacClassBRestoreNvmCtx( contexts->ClassBNvmCtx ) != true )\r\n    {\r\n        return LORAMAC_STATUS_CLASS_B_ERROR;\r\n    }\r\n\r\n    if( LoRaMacConfirmQueueRestoreNvmCtx( contexts->ConfirmQueueNvmCtx ) != true )\r\n    {\r\n        return LORAMAC_STATUS_CONFIRM_QUEUE_ERROR;\r\n    }\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t DetermineFrameType( LoRaMacMessageData_t* macMsg, FType_t* fType )\r\n{\r\n    if( ( macMsg == NULL ) || ( fType == NULL ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    /* The LoRaWAN specification allows several possible configurations how data up/down frames are built up.\r\n     * In sake of clearness the following naming is applied. Please keep in mind that this is\r\n     * implementation specific since there is no definition in the LoRaWAN specification included.\r\n     *\r\n     * X -> Field is available\r\n     * - -> Field is not available\r\n     *\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * | FType |  | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   A   |  |    > 0   |   X  |  > 0  |       X      |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   B   |  |   >= 0   |  X/- |   -   |       -      |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   C   |  |    = 0   |   -  |  = 0  | MAC commands |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   D   |  |    = 0   |   -  |  > 0  |       X      |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     */\r\n\r\n    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )\r\n    {\r\n        *fType = FRAME_TYPE_A;\r\n    }\r\n    else if( macMsg->FRMPayloadSize == 0 )\r\n    {\r\n        *fType = FRAME_TYPE_B;\r\n    }\r\n    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort == 0 ) )\r\n    {\r\n        *fType = FRAME_TYPE_C;\r\n    }\r\n    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort > 0 ) )\r\n    {\r\n        *fType = FRAME_TYPE_D;\r\n    }\r\n    else\r\n    {\r\n        // Should never happen.\r\n        return LORAMAC_STATUS_ERROR;\r\n    }\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic bool CheckRetransUnconfirmedUplink( void )\r\n{\r\n    // Unconfirmed uplink, when all retransmissions are done.\r\n    if( MacCtx.ChannelsNbTransCounter >=\r\n        MacCtx.NvmCtx->MacParams.ChannelsNbTrans )\r\n    {\r\n        return true;\r\n    }\r\n    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )\r\n    {\r\n        // For Class A stop in each case\r\n        if( MacCtx.NvmCtx->DeviceClass == CLASS_A )\r\n        {\r\n            return true;\r\n        }\r\n        else\r\n        {// For Class B & C stop only if the frame was received in RX1 window\r\n            if( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 )\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic bool CheckRetransConfirmedUplink( void )\r\n{\r\n    // Confirmed uplink, when all retransmissions ( tries to get a ack ) are done.\r\n    if( MacCtx.AckTimeoutRetriesCounter >=\r\n        MacCtx.AckTimeoutRetries )\r\n    {\r\n        return true;\r\n    }\r\n    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )\r\n    {\r\n        if( MacCtx.McpsConfirm.AckReceived == true )\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic bool StopRetransmission( void )\r\n{\r\n    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||\r\n        ( ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_1 ) &&\r\n          ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_2 ) ) )\r\n    {   // Maximum repetitions without downlink. Increase ADR Ack counter.\r\n        // Only process the case when the MAC did not receive a downlink.\r\n        if( MacCtx.NvmCtx->AdrCtrlOn == true )\r\n        {\r\n            MacCtx.NvmCtx->AdrAckCounter++;\r\n        }\r\n    }\r\n\r\n    MacCtx.ChannelsNbTransCounter = 0;\r\n    MacCtx.NodeAckRequested = false;\r\n    MacCtx.AckTimeoutRetry = false;\r\n    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n\r\n    return true;\r\n}\r\n\r\nstatic void AckTimeoutRetriesProcess( void )\r\n{\r\n    if( MacCtx.AckTimeoutRetriesCounter < MacCtx.AckTimeoutRetries )\r\n    {\r\n        MacCtx.AckTimeoutRetriesCounter++;\r\n        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )\r\n        {\r\n            GetPhyParams_t getPhy;\r\n            PhyParam_t phyParam;\r\n\r\n            getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;\r\n            getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n            getPhy.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n            MacCtx.NvmCtx->MacParams.ChannelsDatarate = phyParam.Value;\r\n        }\r\n    }\r\n}\r\n\r\nstatic void AckTimeoutRetriesFinalize( void )\r\n{\r\n    if( MacCtx.McpsConfirm.AckReceived == false )\r\n    {\r\n        InitDefaultsParams_t params;\r\n        params.Type = INIT_TYPE_RESTORE_DEFAULT_CHANNELS;\r\n        params.NvmCtx = Contexts.RegionNvmCtx;\r\n        RegionInitDefaults( MacCtx.NvmCtx->Region, &params );\r\n\r\n        MacCtx.NodeAckRequested = false;\r\n        MacCtx.McpsConfirm.AckReceived = false;\r\n    }\r\n    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;\r\n}\r\n\r\nstatic void CallNvmCtxCallback( LoRaMacNvmCtxModule_t module )\r\n{\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->NvmContextChange != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->NvmContextChange( module );\r\n    }\r\n}\r\n\r\nstatic void EventMacNvmCtxChanged( void )\r\n{\r\n    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_MAC );\r\n}\r\n\r\nstatic void EventRegionNvmCtxChanged( void )\r\n{\r\n    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_REGION );\r\n}\r\n\r\nstatic void EventCryptoNvmCtxChanged( void )\r\n{\r\n    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_CRYPTO );\r\n}\r\n\r\nstatic void EventSecureElementNvmCtxChanged( void )\r\n{\r\n    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_SECURE_ELEMENT );\r\n}\r\n\r\nstatic void EventCommandsNvmCtxChanged( void )\r\n{\r\n    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_COMMANDS );\r\n}\r\n\r\nstatic void EventClassBNvmCtxChanged( void )\r\n{\r\n    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_CLASS_B );\r\n}\r\n\r\nstatic void EventConfirmQueueNvmCtxChanged( void )\r\n{\r\n    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_CONFIRM_QUEUE );\r\n}\r\n\r\nstatic uint8_t IsRequestPending( void )\r\n{\r\n    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||\r\n        ( MacCtx.MacFlags.Bits.McpsReq == 1 ) )\r\n    {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nLoRaMacStatus_t LoRaMacInitialization( LoRaMacPrimitives_t* primitives, LoRaMacCallback_t* callbacks, LoRaMacRegion_t region )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n    LoRaMacClassBCallback_t classBCallbacks;\r\n    LoRaMacClassBParams_t classBParams;\r\n\r\n    if( ( primitives == NULL ) ||\r\n        ( callbacks == NULL ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    if( ( primitives->MacMcpsConfirm == NULL ) ||\r\n        ( primitives->MacMcpsIndication == NULL ) ||\r\n        ( primitives->MacMlmeConfirm == NULL ) ||\r\n        ( primitives->MacMlmeIndication == NULL ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    // Verify if the region is supported\r\n    if( RegionIsActive( region ) == false )\r\n    {\r\n        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;\r\n    }\r\n\r\n    // Confirm queue reset\r\n    LoRaMacConfirmQueueInit( primitives, EventConfirmQueueNvmCtxChanged );\r\n\r\n    // Initialize the module context with zeros\r\n    memset1( ( uint8_t* ) &NvmMacCtx, 0x00, sizeof( LoRaMacNvmCtx_t ) );\r\n    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );\r\n    MacCtx.NvmCtx = &NvmMacCtx;\r\n\r\n    // Set non zero variables to its default value\r\n    MacCtx.AckTimeoutRetriesCounter = 1;\r\n    MacCtx.AckTimeoutRetries = 1;\r\n    MacCtx.NvmCtx->Region = region;\r\n    MacCtx.NvmCtx->DeviceClass = CLASS_A;\r\n\r\n    // Setup version\r\n    MacCtx.NvmCtx->Version.Value = LORAMAC_VERSION;\r\n\r\n    // Reset to defaults\r\n    getPhy.Attribute = PHY_DUTY_CYCLE;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->DutyCycleOn = ( bool ) phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_TX_POWER;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_TX_DR;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_MAX_RX_WINDOW;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.MaxRxWindow = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_RECEIVE_DELAY1;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.ReceiveDelay1 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_RECEIVE_DELAY2;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.ReceiveDelay2 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_DR1_OFFSET;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.Rx1DrOffset = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;\r\n    MacCtx.NvmCtx->MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_RX2_DR;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;\r\n    MacCtx.NvmCtx->MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.UplinkDwellTime = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.DownlinkDwellTime = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_MAX_EIRP;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.MaxEirp = phyParam.fValue;\r\n\r\n    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.AntennaGain = phyParam.fValue;\r\n\r\n    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.AdrAckLimit = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.AdrAckDelay = phyParam.Value;\r\n\r\n    // Init parameters which are not set in function ResetMacParameters\r\n    MacCtx.NvmCtx->MacParamsDefaults.ChannelsNbTrans = 1;\r\n    MacCtx.NvmCtx->MacParamsDefaults.SystemMaxRxError = 10;\r\n    MacCtx.NvmCtx->MacParamsDefaults.MinRxSymbols = 6;\r\n\r\n    MacCtx.NvmCtx->MacParams.SystemMaxRxError = MacCtx.NvmCtx->MacParamsDefaults.SystemMaxRxError;\r\n    MacCtx.NvmCtx->MacParams.MinRxSymbols = MacCtx.NvmCtx->MacParamsDefaults.MinRxSymbols;\r\n    MacCtx.NvmCtx->MacParams.MaxRxWindow = MacCtx.NvmCtx->MacParamsDefaults.MaxRxWindow;\r\n    MacCtx.NvmCtx->MacParams.ReceiveDelay1 = MacCtx.NvmCtx->MacParamsDefaults.ReceiveDelay1;\r\n    MacCtx.NvmCtx->MacParams.ReceiveDelay2 = MacCtx.NvmCtx->MacParamsDefaults.ReceiveDelay2;\r\n    MacCtx.NvmCtx->MacParams.JoinAcceptDelay1 = MacCtx.NvmCtx->MacParamsDefaults.JoinAcceptDelay1;\r\n    MacCtx.NvmCtx->MacParams.JoinAcceptDelay2 = MacCtx.NvmCtx->MacParamsDefaults.JoinAcceptDelay2;\r\n    MacCtx.NvmCtx->MacParams.ChannelsNbTrans = MacCtx.NvmCtx->MacParamsDefaults.ChannelsNbTrans;\r\n\r\n    InitDefaultsParams_t params;\r\n    params.Type = INIT_TYPE_BANDS;\r\n    params.NvmCtx = NULL;\r\n    RegionInitDefaults( MacCtx.NvmCtx->Region, &params );\r\n\r\n    ResetMacParameters( );\r\n\r\n    MacCtx.NvmCtx->PublicNetwork = true;\r\n\r\n    MacCtx.MacPrimitives = primitives;\r\n    MacCtx.MacCallbacks = callbacks;\r\n    MacCtx.MacFlags.Value = 0;\r\n    MacCtx.MacState = LORAMAC_STOPPED;\r\n\r\n    // Reset duty cycle times\r\n    MacCtx.NvmCtx->LastTxDoneTime = 0;\r\n    MacCtx.NvmCtx->AggregatedTimeOff = 0;\r\n\r\n    // Initialize timers\r\n    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );\r\n    TimerInit( &MacCtx.RxWindowTimer1, OnRxWindow1TimerEvent );\r\n    TimerInit( &MacCtx.RxWindowTimer2, OnRxWindow2TimerEvent );\r\n    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );\r\n\r\n    // Store the current initialization time\r\n    MacCtx.NvmCtx->InitializationTime = SysTimeGetMcuTime( );\r\n\r\n    // Initialize Radio driver\r\n    MacCtx.RadioEvents.TxDone = OnRadioTxDone;\r\n    MacCtx.RadioEvents.RxDone = OnRadioRxDone;\r\n    MacCtx.RadioEvents.RxError = OnRadioRxError;\r\n    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;\r\n    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;\r\n    Radio.Init( &MacCtx.RadioEvents );\r\n\r\n    // Initialize the Secure Element driver\r\n    if( SecureElementInit( EventSecureElementNvmCtxChanged ) != SECURE_ELEMENT_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    // Initialize Crypto module\r\n    if( LoRaMacCryptoInit( EventCryptoNvmCtxChanged ) != LORAMAC_CRYPTO_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    // Initialize MAC commands module\r\n    if( LoRaMacCommandsInit( EventCommandsNvmCtxChanged ) != LORAMAC_COMMANDS_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n    }\r\n\r\n    // Set multicast downlink counter reference\r\n    if( LoRaMacCryptoSetMulticastReference( MacCtx.NvmCtx->MulticastChannelList ) != LORAMAC_CRYPTO_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    // Random seed initialization\r\n    srand1( Radio.Random( ) );\r\n\r\n    Radio.SetPublicNetwork( MacCtx.NvmCtx->PublicNetwork );\r\n    Radio.Sleep( );\r\n\r\n    // Initialize class b\r\n    // Apply callback\r\n    classBCallbacks.GetTemperatureLevel = NULL;\r\n    classBCallbacks.MacProcessNotify = NULL;\r\n    if( callbacks != NULL )\r\n    {\r\n        classBCallbacks.GetTemperatureLevel = callbacks->GetTemperatureLevel;\r\n        classBCallbacks.MacProcessNotify = callbacks->MacProcessNotify;\r\n    }\r\n\r\n    // Must all be static. Don't use local references.\r\n    classBParams.MlmeIndication = &MacCtx.MlmeIndication;\r\n    classBParams.McpsIndication = &MacCtx.McpsIndication;\r\n    classBParams.MlmeConfirm = &MacCtx.MlmeConfirm;\r\n    classBParams.LoRaMacFlags = &MacCtx.MacFlags;\r\n    classBParams.LoRaMacDevAddr = &MacCtx.NvmCtx->DevAddr;\r\n    classBParams.LoRaMacRegion = &MacCtx.NvmCtx->Region;\r\n    classBParams.LoRaMacParams = &MacCtx.NvmCtx->MacParams;\r\n    classBParams.MulticastChannels = &MacCtx.NvmCtx->MulticastChannelList[0];\r\n\r\n    LoRaMacClassBInit( &classBParams, &classBCallbacks, &EventClassBNvmCtxChanged );\r\n\r\n    LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacStart( void )\r\n{\r\n    MacCtx.MacState = LORAMAC_IDLE;\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacStop( void )\r\n{\r\n    if( LoRaMacIsBusy( ) == false )\r\n    {\r\n        MacCtx.MacState = LORAMAC_STOPPED;\r\n        return LORAMAC_STATUS_OK;\r\n    }\r\n    else if(  MacCtx.MacState == LORAMAC_STOPPED )\r\n    {\r\n        return LORAMAC_STATUS_OK;\r\n    }\r\n    return LORAMAC_STATUS_BUSY;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacQueryNextTxDelay( int8_t datarate, TimerTime_t* time )\r\n{\r\n    NextChanParams_t nextChan;\r\n    uint8_t channel = 0;\r\n\r\n    CalcNextAdrParams_t adrNext;\r\n    uint32_t adrAckCounter = MacCtx.NvmCtx->AdrAckCounter;\r\n    int8_t txPower = MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower;\r\n\r\n    if( time == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    if( MacCtx.NvmCtx->LastTxDoneTime == 0 )\r\n    {\r\n        *time = 0;\r\n        return LORAMAC_STATUS_OK;\r\n    }\r\n\r\n    // Update back-off\r\n    CalculateBackOff( MacCtx.NvmCtx->LastTxChannel );\r\n\r\n    nextChan.AggrTimeOff = MacCtx.NvmCtx->AggregatedTimeOff;\r\n    nextChan.Datarate = datarate;\r\n    nextChan.DutyCycleEnabled = MacCtx.NvmCtx->DutyCycleOn;\r\n    nextChan.QueryNextTxDelayOnly = true;\r\n    nextChan.Joined = true;\r\n    nextChan.LastAggrTx = MacCtx.NvmCtx->LastTxDoneTime;\r\n\r\n    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        nextChan.Joined = false;\r\n    }\r\n    if( MacCtx.NvmCtx->AdrCtrlOn == true )\r\n    {\r\n        // Setup ADR request\r\n        adrNext.UpdateChanMask = false;\r\n        adrNext.AdrEnabled = MacCtx.NvmCtx->AdrCtrlOn;\r\n        adrNext.AdrAckCounter = MacCtx.NvmCtx->AdrAckCounter;\r\n        adrNext.AdrAckLimit = MacCtx.AdrAckLimit;\r\n        adrNext.AdrAckDelay = MacCtx.AdrAckDelay;\r\n        adrNext.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n        adrNext.TxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n        adrNext.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n        adrNext.Region = MacCtx.NvmCtx->Region;\r\n\r\n        // We call the function for information purposes only. We don't want to\r\n        // apply the datarate, the tx power and the ADR ack counter.\r\n        LoRaMacAdrCalcNext( &adrNext, &nextChan.Datarate, &txPower, &adrAckCounter );\r\n    }\r\n\r\n    // Select channel\r\n    return RegionNextChannel( MacCtx.NvmCtx->Region, &nextChan, &channel, time, &MacCtx.NvmCtx->AggregatedTimeOff );\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacQueryTxPossible( uint8_t size, LoRaMacTxInfo_t* txInfo )\r\n{\r\n    CalcNextAdrParams_t adrNext;\r\n    uint32_t adrAckCounter = MacCtx.NvmCtx->AdrAckCounter;\r\n    int8_t datarate = MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate;\r\n    int8_t txPower = MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower;\r\n    size_t macCmdsSize = 0;\r\n\r\n    if( txInfo == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    // Setup ADR request\r\n    adrNext.Version = MacCtx.NvmCtx->Version;\r\n    adrNext.UpdateChanMask = false;\r\n    adrNext.AdrEnabled = MacCtx.NvmCtx->AdrCtrlOn;\r\n    adrNext.AdrAckCounter = MacCtx.NvmCtx->AdrAckCounter;\r\n    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;\r\n    adrNext.AdrAckDelay = MacCtx.AdrAckDelay;\r\n    adrNext.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n    adrNext.TxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n    adrNext.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n    adrNext.Region = MacCtx.NvmCtx->Region;\r\n\r\n    // We call the function for information purposes only. We don't want to\r\n    // apply the datarate, the tx power and the ADR ack counter.\r\n    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &adrAckCounter );\r\n\r\n    txInfo->CurrentPossiblePayloadSize = GetMaxAppPayloadWithoutFOptsLength( datarate );\r\n\r\n    if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n    }\r\n\r\n    // Verify if the MAC commands fit into the FOpts and into the maximum payload.\r\n    if( ( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH >= macCmdsSize ) && ( txInfo->CurrentPossiblePayloadSize >= macCmdsSize ) )\r\n    {\r\n        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;\r\n\r\n        // Verify if the application data together with MAC command fit into the maximum payload.\r\n        if( txInfo->CurrentPossiblePayloadSize >= ( macCmdsSize + size ) )\r\n        {\r\n            return LORAMAC_STATUS_OK;\r\n        }\r\n        else\r\n        {\r\n           return LORAMAC_STATUS_LENGTH_ERROR;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        txInfo->MaxPossibleApplicationDataSize = 0;\r\n        return LORAMAC_STATUS_LENGTH_ERROR;\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMibGetRequestConfirm( MibRequestConfirm_t* mibGet )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_OK;\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n\r\n    if( mibGet == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    switch( mibGet->Type )\r\n    {\r\n        case MIB_DEVICE_CLASS:\r\n        {\r\n            mibGet->Param.Class = MacCtx.NvmCtx->DeviceClass;\r\n            break;\r\n        }\r\n        case MIB_NETWORK_ACTIVATION:\r\n        {\r\n            mibGet->Param.NetworkActivation = MacCtx.NvmCtx->NetworkActivation;\r\n            break;\r\n        }\r\n        case MIB_DEV_EUI:\r\n        {\r\n            mibGet->Param.DevEui = SecureElementGetDevEui( );\r\n            break;\r\n        }\r\n        case MIB_JOIN_EUI:\r\n        {\r\n            mibGet->Param.JoinEui = SecureElementGetJoinEui( );\r\n            break;\r\n        }\r\n        case MIB_SE_PIN:\r\n        {\r\n            mibGet->Param.JoinEui = SecureElementGetPin( );\r\n            break;\r\n        }\r\n        case MIB_ADR:\r\n        {\r\n            mibGet->Param.AdrEnable = MacCtx.NvmCtx->AdrCtrlOn;\r\n            break;\r\n        }\r\n        case MIB_NET_ID:\r\n        {\r\n            mibGet->Param.NetID = MacCtx.NvmCtx->NetID;\r\n            break;\r\n        }\r\n        case MIB_DEV_ADDR:\r\n        {\r\n            mibGet->Param.DevAddr = MacCtx.NvmCtx->DevAddr;\r\n            break;\r\n        }\r\n        case MIB_PUBLIC_NETWORK:\r\n        {\r\n            mibGet->Param.EnablePublicNetwork = MacCtx.NvmCtx->PublicNetwork;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS:\r\n        {\r\n            getPhy.Attribute = PHY_CHANNELS;\r\n            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n\r\n            mibGet->Param.ChannelList = phyParam.Channels;\r\n            break;\r\n        }\r\n        case MIB_RX2_CHANNEL:\r\n        {\r\n            mibGet->Param.Rx2Channel = MacCtx.NvmCtx->MacParams.Rx2Channel;\r\n            break;\r\n        }\r\n        case MIB_RX2_DEFAULT_CHANNEL:\r\n        {\r\n            mibGet->Param.Rx2Channel = MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel;\r\n            break;\r\n        }\r\n        case MIB_RXC_CHANNEL:\r\n        {\r\n            mibGet->Param.RxCChannel = MacCtx.NvmCtx->MacParams.RxCChannel;\r\n            break;\r\n        }\r\n        case MIB_RXC_DEFAULT_CHANNEL:\r\n        {\r\n            mibGet->Param.RxCChannel = MacCtx.NvmCtx->MacParamsDefaults.RxCChannel;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_MASK:\r\n        {\r\n            getPhy.Attribute = PHY_CHANNELS_DEFAULT_MASK;\r\n            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n\r\n            mibGet->Param.ChannelsDefaultMask = phyParam.ChannelsMask;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_MASK:\r\n        {\r\n            getPhy.Attribute = PHY_CHANNELS_MASK;\r\n            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n\r\n            mibGet->Param.ChannelsMask = phyParam.ChannelsMask;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_NB_TRANS:\r\n        {\r\n            mibGet->Param.ChannelsNbTrans = MacCtx.NvmCtx->MacParams.ChannelsNbTrans;\r\n            break;\r\n        }\r\n        case MIB_MAX_RX_WINDOW_DURATION:\r\n        {\r\n            mibGet->Param.MaxRxWindow = MacCtx.NvmCtx->MacParams.MaxRxWindow;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_1:\r\n        {\r\n            mibGet->Param.ReceiveDelay1 = MacCtx.NvmCtx->MacParams.ReceiveDelay1;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_2:\r\n        {\r\n            mibGet->Param.ReceiveDelay2 = MacCtx.NvmCtx->MacParams.ReceiveDelay2;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_1:\r\n        {\r\n            mibGet->Param.JoinAcceptDelay1 = MacCtx.NvmCtx->MacParams.JoinAcceptDelay1;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_2:\r\n        {\r\n            mibGet->Param.JoinAcceptDelay2 = MacCtx.NvmCtx->MacParams.JoinAcceptDelay2;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_DATARATE:\r\n        {\r\n            mibGet->Param.ChannelsDefaultDatarate = MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DATARATE:\r\n        {\r\n            mibGet->Param.ChannelsDatarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_TX_POWER:\r\n        {\r\n            mibGet->Param.ChannelsDefaultTxPower = MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_TX_POWER:\r\n        {\r\n            mibGet->Param.ChannelsTxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n            break;\r\n        }\r\n        case MIB_SYSTEM_MAX_RX_ERROR:\r\n        {\r\n            mibGet->Param.SystemMaxRxError = MacCtx.NvmCtx->MacParams.SystemMaxRxError;\r\n            break;\r\n        }\r\n        case MIB_MIN_RX_SYMBOLS:\r\n        {\r\n            mibGet->Param.MinRxSymbols = MacCtx.NvmCtx->MacParams.MinRxSymbols;\r\n            break;\r\n        }\r\n        case MIB_ANTENNA_GAIN:\r\n        {\r\n            mibGet->Param.AntennaGain = MacCtx.NvmCtx->MacParams.AntennaGain;\r\n            break;\r\n        }\r\n        case MIB_NVM_CTXS:\r\n        {\r\n            mibGet->Param.Contexts = GetCtxs( );\r\n            break;\r\n        }\r\n        case MIB_DEFAULT_ANTENNA_GAIN:\r\n        {\r\n            mibGet->Param.DefaultAntennaGain = MacCtx.NvmCtx->MacParamsDefaults.AntennaGain;\r\n            break;\r\n        }\r\n        case MIB_LORAWAN_VERSION:\r\n        {\r\n            mibGet->Param.LrWanVersion.LoRaWan = MacCtx.NvmCtx->Version;\r\n            mibGet->Param.LrWanVersion.LoRaWanRegion = RegionGetVersion( );\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            status = LoRaMacClassBMibGetRequestConfirm( mibGet );\r\n            break;\r\n        }\r\n    }\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMibSetRequestConfirm( MibRequestConfirm_t* mibSet )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_OK;\r\n    ChanMaskSetParams_t chanMaskSet;\r\n    VerifyParams_t verify;\r\n\r\n    if( mibSet == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    switch( mibSet->Type )\r\n    {\r\n        case MIB_DEVICE_CLASS:\r\n        {\r\n            status = SwitchClass( mibSet->Param.Class );\r\n            break;\r\n        }\r\n        case MIB_NETWORK_ACTIVATION:\r\n        {\r\n            if( mibSet->Param.NetworkActivation != ACTIVATION_TYPE_OTAA  )\r\n            {\r\n                MacCtx.NvmCtx->NetworkActivation = mibSet->Param.NetworkActivation;\r\n            }\r\n            else\r\n            {   // Do not allow to set ACTIVATION_TYPE_OTAA since the MAC will set it automatically after a successful join process.\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_DEV_EUI:\r\n        {\r\n            if( SecureElementSetDevEui( mibSet->Param.DevEui ) != SECURE_ELEMENT_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_JOIN_EUI:\r\n        {\r\n            if( SecureElementSetJoinEui( mibSet->Param.JoinEui ) != SECURE_ELEMENT_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_SE_PIN:\r\n        {\r\n            if( SecureElementSetPin( mibSet->Param.SePin ) != SECURE_ELEMENT_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_ADR:\r\n        {\r\n            MacCtx.NvmCtx->AdrCtrlOn = mibSet->Param.AdrEnable;\r\n            break;\r\n        }\r\n        case MIB_NET_ID:\r\n        {\r\n            MacCtx.NvmCtx->NetID = mibSet->Param.NetID;\r\n            break;\r\n        }\r\n        case MIB_DEV_ADDR:\r\n        {\r\n            MacCtx.NvmCtx->DevAddr = mibSet->Param.DevAddr;\r\n            break;\r\n        }\r\n        case MIB_APP_KEY:\r\n        {\r\n            if( mibSet->Param.AppKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_KEY, mibSet->Param.AppKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_NWK_KEY:\r\n        {\r\n            if( mibSet->Param.NwkKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_KEY, mibSet->Param.NwkKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_J_S_INT_KEY:\r\n        {\r\n            if( mibSet->Param.JSIntKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( J_S_INT_KEY, mibSet->Param.JSIntKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_J_S_ENC_KEY:\r\n        {\r\n            if( mibSet->Param.JSEncKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( J_S_ENC_KEY, mibSet->Param.JSEncKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_F_NWK_S_INT_KEY:\r\n        {\r\n            if( mibSet->Param.FNwkSIntKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( F_NWK_S_INT_KEY, mibSet->Param.FNwkSIntKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_S_NWK_S_INT_KEY:\r\n        {\r\n            if( mibSet->Param.SNwkSIntKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( S_NWK_S_INT_KEY, mibSet->Param.SNwkSIntKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_NWK_S_ENC_KEY:\r\n        {\r\n            if( mibSet->Param.NwkSEncKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_S_ENC_KEY, mibSet->Param.NwkSEncKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_APP_S_KEY:\r\n        {\r\n            if( mibSet->Param.AppSKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_S_KEY, mibSet->Param.AppSKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KE_KEY:\r\n        {\r\n            if( mibSet->Param.McKEKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KE_KEY, mibSet->Param.McKEKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_0:\r\n        {\r\n            if( mibSet->Param.McKey0 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_0, mibSet->Param.McKey0 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_0:\r\n        {\r\n            if( mibSet->Param.McAppSKey0 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_0, mibSet->Param.McAppSKey0 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_0:\r\n        {\r\n            if( mibSet->Param.McNwkSKey0 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_0, mibSet->Param.McNwkSKey0 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_1:\r\n        {\r\n            if( mibSet->Param.McKey1 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_1, mibSet->Param.McKey1 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_1:\r\n        {\r\n            if( mibSet->Param.McAppSKey1 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_1, mibSet->Param.McAppSKey1 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_1:\r\n        {\r\n            if( mibSet->Param.McNwkSKey1 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_1, mibSet->Param.McNwkSKey1 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_2:\r\n        {\r\n            if( mibSet->Param.McKey2 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_2, mibSet->Param.McKey2 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_2:\r\n        {\r\n            if( mibSet->Param.McAppSKey2 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_2, mibSet->Param.McAppSKey2 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_2:\r\n        {\r\n            if( mibSet->Param.McNwkSKey2 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_2, mibSet->Param.McNwkSKey2 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_3:\r\n        {\r\n            if( mibSet->Param.McKey3 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_3, mibSet->Param.McKey3 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_3:\r\n        {\r\n            if( mibSet->Param.McAppSKey3 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_3, mibSet->Param.McAppSKey3 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_3:\r\n        {\r\n            if( mibSet->Param.McNwkSKey3 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_3, mibSet->Param.McNwkSKey3 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_PUBLIC_NETWORK:\r\n        {\r\n            MacCtx.NvmCtx->PublicNetwork = mibSet->Param.EnablePublicNetwork;\r\n            Radio.SetPublicNetwork( MacCtx.NvmCtx->PublicNetwork );\r\n            break;\r\n        }\r\n        case MIB_RX2_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParams.Rx2Channel = mibSet->Param.Rx2Channel;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_RX2_DEFAULT_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_RXC_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParams.RxCChannel = mibSet->Param.RxCChannel;\r\n\r\n                if( ( MacCtx.NvmCtx->DeviceClass == CLASS_C ) && ( MacCtx.NvmCtx->NetworkActivation != ACTIVATION_TYPE_NONE ) )\r\n                {\r\n                    // We can only compute the RX window parameters directly, if we are already\r\n                    // in class c mode and joined. We cannot setup an RX window in case of any other\r\n                    // class type.\r\n                    // Set the radio into sleep mode in case we are still in RX mode\r\n                    Radio.Sleep( );\r\n\r\n                    OpenContinuousRxCWindow( );\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_RXC_DEFAULT_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParamsDefaults.RxCChannel = mibSet->Param.RxCDefaultChannel;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_MASK:\r\n        {\r\n            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsDefaultMask;\r\n            chanMaskSet.ChannelsMaskType = CHANNELS_DEFAULT_MASK;\r\n\r\n            if( RegionChanMaskSet( MacCtx.NvmCtx->Region, &chanMaskSet ) == false )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_MASK:\r\n        {\r\n            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsMask;\r\n            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;\r\n\r\n            if( RegionChanMaskSet( MacCtx.NvmCtx->Region, &chanMaskSet ) == false )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_NB_TRANS:\r\n        {\r\n            if( ( mibSet->Param.ChannelsNbTrans >= 1 ) &&\r\n                ( mibSet->Param.ChannelsNbTrans <= 15 ) )\r\n            {\r\n                MacCtx.NvmCtx->MacParams.ChannelsNbTrans = mibSet->Param.ChannelsNbTrans;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MAX_RX_WINDOW_DURATION:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.MaxRxWindow = mibSet->Param.MaxRxWindow;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_1:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.ReceiveDelay1 = mibSet->Param.ReceiveDelay1;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_2:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.ReceiveDelay2 = mibSet->Param.ReceiveDelay2;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_1:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.JoinAcceptDelay1 = mibSet->Param.JoinAcceptDelay1;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_2:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.JoinAcceptDelay2 = mibSet->Param.JoinAcceptDelay2;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_DATARATE:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_DEF_TX_DR ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate = verify.DatarateParams.Datarate;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DATARATE:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDatarate;\r\n            verify.DatarateParams.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_TX_DR ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParams.ChannelsDatarate = verify.DatarateParams.Datarate;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_TX_POWER:\r\n        {\r\n            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_DEF_TX_POWER ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower = verify.TxPower;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_TX_POWER:\r\n        {\r\n            verify.TxPower = mibSet->Param.ChannelsTxPower;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_TX_POWER ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParams.ChannelsTxPower = verify.TxPower;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_SYSTEM_MAX_RX_ERROR:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.SystemMaxRxError = MacCtx.NvmCtx->MacParamsDefaults.SystemMaxRxError = mibSet->Param.SystemMaxRxError;\r\n            break;\r\n        }\r\n        case MIB_MIN_RX_SYMBOLS:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.MinRxSymbols = MacCtx.NvmCtx->MacParamsDefaults.MinRxSymbols = mibSet->Param.MinRxSymbols;\r\n            break;\r\n        }\r\n        case MIB_ANTENNA_GAIN:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.AntennaGain = mibSet->Param.AntennaGain;\r\n            break;\r\n        }\r\n        case MIB_DEFAULT_ANTENNA_GAIN:\r\n        {\r\n            MacCtx.NvmCtx->MacParamsDefaults.AntennaGain = mibSet->Param.DefaultAntennaGain;\r\n            break;\r\n        }\r\n        case MIB_NVM_CTXS:\r\n        {\r\n            if( mibSet->Param.Contexts != 0 )\r\n            {\r\n                status = RestoreCtxs( mibSet->Param.Contexts );\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_ABP_LORAWAN_VERSION:\r\n        {\r\n            if( mibSet->Param.AbpLrWanVersion.Fields.Minor <= 1 )\r\n            {\r\n                MacCtx.NvmCtx->Version = mibSet->Param.AbpLrWanVersion;\r\n\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            status = LoRaMacMibClassBSetRequestConfirm( mibSet );\r\n            break;\r\n        }\r\n    }\r\n    EventRegionNvmCtxChanged( );\r\n    EventMacNvmCtxChanged( );\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacChannelAdd( uint8_t id, ChannelParams_t params )\r\n{\r\n    ChannelAddParams_t channelAdd;\r\n\r\n    // Validate if the MAC is in a correct state\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        if( ( MacCtx.MacState & LORAMAC_TX_CONFIG ) != LORAMAC_TX_CONFIG )\r\n        {\r\n            return LORAMAC_STATUS_BUSY;\r\n        }\r\n    }\r\n\r\n    channelAdd.NewChannel = &params;\r\n    channelAdd.ChannelId = id;\r\n\r\n    EventRegionNvmCtxChanged( );\r\n    return RegionChannelAdd( MacCtx.NvmCtx->Region, &channelAdd );\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacChannelRemove( uint8_t id )\r\n{\r\n    ChannelRemoveParams_t channelRemove;\r\n\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        if( ( MacCtx.MacState & LORAMAC_TX_CONFIG ) != LORAMAC_TX_CONFIG )\r\n        {\r\n            return LORAMAC_STATUS_BUSY;\r\n        }\r\n    }\r\n\r\n    channelRemove.ChannelId = id;\r\n\r\n    if( RegionChannelsRemove( MacCtx.NvmCtx->Region, &channelRemove ) == false )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    EventRegionNvmCtxChanged( );\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcChannelSetup( McChannelParams_t *channel )\r\n{\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( channel->GroupID >= LORAMAC_MAX_MC_CTX )\r\n    {\r\n        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;\r\n    }\r\n\r\n    MacCtx.NvmCtx->MulticastChannelList[channel->GroupID].ChannelParams = *channel;\r\n\r\n    if( channel->IsRemotelySetup == true )\r\n    {\r\n        const KeyIdentifier_t mcKeys[LORAMAC_MAX_MC_CTX] = { MC_KEY_0, MC_KEY_1, MC_KEY_2, MC_KEY_3 };\r\n        if( LoRaMacCryptoSetKey( mcKeys[channel->GroupID], channel->McKeys.McKeyE ) != LORAMAC_CRYPTO_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n\r\n        if( LoRaMacCryptoDeriveMcSessionKeyPair( channel->GroupID, channel->Address ) != LORAMAC_CRYPTO_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        const KeyIdentifier_t mcAppSKeys[LORAMAC_MAX_MC_CTX] = { MC_APP_S_KEY_0, MC_APP_S_KEY_1, MC_APP_S_KEY_2, MC_APP_S_KEY_3 };\r\n        const KeyIdentifier_t mcNwkSKeys[LORAMAC_MAX_MC_CTX] = { MC_NWK_S_KEY_0, MC_NWK_S_KEY_1, MC_NWK_S_KEY_2, MC_NWK_S_KEY_3 };\r\n        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcAppSKeys[channel->GroupID], channel->McKeys.Session.McAppSKey ) )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcNwkSKeys[channel->GroupID], channel->McKeys.Session.McNwkSKey ) )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n    }\r\n\r\n    if( channel->Class == CLASS_B )\r\n    {\r\n        // Calculate class b parameters\r\n        LoRaMacClassBSetMulticastPeriodicity( &MacCtx.NvmCtx->MulticastChannelList[channel->GroupID] );\r\n    }\r\n\r\n    // Reset multicast channel downlink counter to initial value.\r\n    *MacCtx.NvmCtx->MulticastChannelList[channel->GroupID].DownLinkCounter = FCNT_DOWN_INITAL_VALUE;\r\n\r\n    EventMacNvmCtxChanged( );\r\n    EventRegionNvmCtxChanged( );\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcChannelDelete( AddressIdentifier_t groupID )\r\n{\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( ( groupID >= LORAMAC_MAX_MC_CTX ) || \r\n        ( MacCtx.NvmCtx->MulticastChannelList[groupID].ChannelParams.IsEnabled == false ) )\r\n    {\r\n        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;\r\n    }\r\n\r\n    McChannelParams_t channel;\r\n\r\n    // Set all channel fields with 0\r\n    memset1( ( uint8_t* )&channel, 0, sizeof( McChannelParams_t ) );\r\n\r\n    MacCtx.NvmCtx->MulticastChannelList[groupID].ChannelParams = channel;\r\n\r\n    EventMacNvmCtxChanged( );\r\n    EventRegionNvmCtxChanged( );\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nuint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )\r\n{\r\n    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n    {\r\n        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )\r\n        {\r\n            return i;\r\n        }\r\n    }\r\n    return 0xFF;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcChannelSetupRxParams( AddressIdentifier_t groupID, McRxParams_t *rxParams, uint8_t *status )\r\n{\r\n   *status = 0x1C + ( groupID & 0x03 );\r\n\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    DeviceClass_t devClass = MacCtx.NvmCtx->MulticastChannelList[groupID].ChannelParams.Class;\r\n    if( ( devClass == CLASS_A ) || ( devClass > CLASS_C ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    if( ( groupID >= LORAMAC_MAX_MC_CTX ) || \r\n        ( MacCtx.NvmCtx->MulticastChannelList[groupID].ChannelParams.IsEnabled == false ) )\r\n    {\r\n        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;\r\n    }\r\n    *status &= 0x0F; // groupID OK\r\n\r\n    VerifyParams_t verify;\r\n    // Check datarate\r\n    if( devClass == CLASS_B )\r\n    {\r\n        verify.DatarateParams.Datarate = rxParams->ClassB.Datarate;\r\n    }\r\n    else\r\n    {\r\n        verify.DatarateParams.Datarate = rxParams->ClassC.Datarate;\r\n    }\r\n    verify.DatarateParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n\r\n    if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_RX_DR ) == true )\r\n    {\r\n        *status &= 0xFB; // datarate OK\r\n    }\r\n\r\n    // Check frequency\r\n    if( devClass == CLASS_B )\r\n    {\r\n        verify.Frequency = rxParams->ClassB.Frequency;\r\n    }\r\n    else\r\n    {\r\n        verify.Frequency = rxParams->ClassC.Frequency;\r\n    }\r\n    if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_FREQUENCY ) == true )\r\n    {\r\n        *status &= 0xF7; // frequency OK\r\n    }\r\n\r\n    if( *status == ( groupID & 0x03 ) )\r\n    {\r\n        // Apply parameters\r\n        MacCtx.NvmCtx->MulticastChannelList[groupID].ChannelParams.RxParams = *rxParams;\r\n    }\r\n\r\n    EventMacNvmCtxChanged( );\r\n    EventRegionNvmCtxChanged( );\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMlmeRequest( MlmeReq_t* mlmeRequest )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n    MlmeConfirmQueue_t queueElement;\r\n    uint8_t macCmdPayload[2] = { 0x00, 0x00 };\r\n\r\n    if( mlmeRequest == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    if( LoRaMacIsBusy( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n    if( LoRaMacConfirmQueueIsFull( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( LoRaMacConfirmQueueGetCnt( ) == 0 )\r\n    {\r\n        memset1( ( uint8_t* ) &MacCtx.MlmeConfirm, 0, sizeof( MacCtx.MlmeConfirm ) );\r\n    }\r\n    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n\r\n    MacCtx.MacFlags.Bits.MlmeReq = 1;\r\n    queueElement.Request = mlmeRequest->Type;\r\n    queueElement.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n    queueElement.RestrictCommonReadyToHandle = false;\r\n\r\n    switch( mlmeRequest->Type )\r\n    {\r\n        case MLME_JOIN:\r\n        {\r\n            if( ( MacCtx.MacState & LORAMAC_TX_DELAYED ) == LORAMAC_TX_DELAYED )\r\n            {\r\n                return LORAMAC_STATUS_BUSY;\r\n            }\r\n\r\n            ResetMacParameters( );\r\n\r\n            MacCtx.NvmCtx->MacParams.ChannelsDatarate = RegionAlternateDr( MacCtx.NvmCtx->Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );\r\n\r\n            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;\r\n\r\n            status = SendReJoinReq( JOIN_REQ );\r\n\r\n            if( status != LORAMAC_STATUS_OK )\r\n            {\r\n                // Revert back the previous datarate ( mainly used for US915 like regions )\r\n                MacCtx.NvmCtx->MacParams.ChannelsDatarate = RegionAlternateDr( MacCtx.NvmCtx->Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR_RESTORE );\r\n            }\r\n            break;\r\n        }\r\n        case MLME_LINK_CHECK:\r\n        {\r\n            // LoRaMac will send this command piggy-pack\r\n            status = LORAMAC_STATUS_OK;\r\n            if( LoRaMacCommandsAddCmd( MOTE_MAC_LINK_CHECK_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n            break;\r\n        }\r\n        case MLME_TXCW:\r\n        {\r\n            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );\r\n            break;\r\n        }\r\n        case MLME_TXCW_1:\r\n        {\r\n\r\n            status = SetTxContinuousWave1( mlmeRequest->Req.TxCw.Timeout, mlmeRequest->Req.TxCw.Frequency, mlmeRequest->Req.TxCw.Power );\r\n            break;\r\n        }\r\n        case MLME_DEVICE_TIME:\r\n        {\r\n            // LoRaMac will send this command piggy-pack\r\n            status = LORAMAC_STATUS_OK;\r\n            if( LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_TIME_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n            break;\r\n        }\r\n        case MLME_PING_SLOT_INFO:\r\n        {\r\n            if( MacCtx.NvmCtx->DeviceClass == CLASS_A )\r\n            {\r\n                uint8_t value = mlmeRequest->Req.PingSlotInfo.PingSlot.Value;\r\n\r\n                // LoRaMac will send this command piggy-pack\r\n                LoRaMacClassBSetPingSlotInfo( mlmeRequest->Req.PingSlotInfo.PingSlot.Fields.Periodicity );\r\n                macCmdPayload[0] = value;\r\n                status = LORAMAC_STATUS_OK;\r\n                if( LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_INFO_REQ, macCmdPayload, 1 ) != LORAMAC_COMMANDS_SUCCESS )\r\n                {\r\n                    status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        case MLME_BEACON_TIMING:\r\n        {\r\n            // LoRaMac will send this command piggy-pack\r\n            status = LORAMAC_STATUS_OK;\r\n            if( LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_TIMING_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n            break;\r\n        }\r\n        case MLME_BEACON_ACQUISITION:\r\n        {\r\n            // Apply the request\r\n            queueElement.RestrictCommonReadyToHandle = true;\r\n\r\n            if( LoRaMacClassBIsAcquisitionInProgress( ) == false )\r\n            {\r\n                // Start class B algorithm\r\n                LoRaMacClassBSetBeaconState( BEACON_STATE_ACQUISITION );\r\n                LoRaMacClassBBeaconTimerEvent( NULL );\r\n\r\n                status = LORAMAC_STATUS_OK;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_BUSY;\r\n            }\r\n            break;\r\n        }\r\n        default:\r\n            break;\r\n    }\r\n\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        if( LoRaMacConfirmQueueGetCnt( ) == 0 )\r\n        {\r\n            MacCtx.NodeAckRequested = false;\r\n            MacCtx.MacFlags.Bits.MlmeReq = 0;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        LoRaMacConfirmQueueAdd( &queueElement );\r\n        EventMacNvmCtxChanged( );\r\n    }\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcpsRequest( McpsReq_t* mcpsRequest )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n    LoRaMacHeader_t macHdr;\r\n    VerifyParams_t verify;\r\n    uint8_t fPort = 0;\r\n    void* fBuffer;\r\n    uint16_t fBufferSize;\r\n    int8_t datarate = DR_0;\r\n    bool readyToSend = false;\r\n\r\n    if( mcpsRequest == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    if( LoRaMacIsBusy( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    macHdr.Value = 0;\r\n    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );\r\n    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n\r\n    // AckTimeoutRetriesCounter must be reset every time a new request (unconfirmed or confirmed) is performed.\r\n    MacCtx.AckTimeoutRetriesCounter = 1;\r\n\r\n    switch( mcpsRequest->Type )\r\n    {\r\n        case MCPS_UNCONFIRMED:\r\n        {\r\n            readyToSend = true;\r\n            MacCtx.AckTimeoutRetries = 1;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;\r\n            fPort = mcpsRequest->Req.Unconfirmed.fPort;\r\n            fBuffer = mcpsRequest->Req.Unconfirmed.fBuffer;\r\n            fBufferSize = mcpsRequest->Req.Unconfirmed.fBufferSize;\r\n            datarate = mcpsRequest->Req.Unconfirmed.Datarate;\r\n            break;\r\n        }\r\n        case MCPS_CONFIRMED:\r\n        {\r\n            readyToSend = true;\r\n            MacCtx.AckTimeoutRetries = MIN( mcpsRequest->Req.Confirmed.NbTrials, MAX_ACK_RETRIES );\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;\r\n            fPort = mcpsRequest->Req.Confirmed.fPort;\r\n            fBuffer = mcpsRequest->Req.Confirmed.fBuffer;\r\n            fBufferSize = mcpsRequest->Req.Confirmed.fBufferSize;\r\n            datarate = mcpsRequest->Req.Confirmed.Datarate;\r\n            break;\r\n        }\r\n        case MCPS_PROPRIETARY:\r\n        {\r\n            readyToSend = true;\r\n            MacCtx.AckTimeoutRetries = 1;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_PROPRIETARY;\r\n            fBuffer = mcpsRequest->Req.Proprietary.fBuffer;\r\n            fBufferSize = mcpsRequest->Req.Proprietary.fBufferSize;\r\n            datarate = mcpsRequest->Req.Proprietary.Datarate;\r\n            break;\r\n        }\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // Get the minimum possible datarate\r\n    getPhy.Attribute = PHY_MIN_TX_DR;\r\n    getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    // Apply the minimum possible datarate.\r\n    // Some regions have limitations for the minimum datarate.\r\n    datarate = MAX( datarate, ( int8_t )phyParam.Value );\r\n\r\n    if( readyToSend == true )\r\n    {\r\n        if( MacCtx.NvmCtx->AdrCtrlOn == false )\r\n        {\r\n            verify.DatarateParams.Datarate = datarate;\r\n            verify.DatarateParams.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_TX_DR ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParams.ChannelsDatarate = verify.DatarateParams.Datarate;\r\n            }\r\n            else\r\n            {\r\n                return LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n        }\r\n\r\n        status = Send( &macHdr, fPort, fBuffer, fBufferSize );\r\n        if( status == LORAMAC_STATUS_OK )\r\n        {\r\n            MacCtx.McpsConfirm.McpsRequest = mcpsRequest->Type;\r\n            MacCtx.MacFlags.Bits.McpsReq = 1;\r\n        }\r\n        else\r\n        {\r\n            MacCtx.NodeAckRequested = false;\r\n        }\r\n    }\r\n\r\n    EventMacNvmCtxChanged( );\r\n    return status;\r\n}\r\n\r\nvoid LoRaMacTestSetDutyCycleOn( bool enable )\r\n{\r\n    VerifyParams_t verify;\r\n\r\n    verify.DutyCycle = enable;\r\n\r\n    if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_DUTY_CYCLE ) == true )\r\n    {\r\n        MacCtx.NvmCtx->DutyCycleOn = enable;\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacDeInitialization( void )\r\n{\r\n    // Check the current state of the LoRaMac\r\n    if ( LoRaMacStop( ) == LORAMAC_STATUS_OK )\r\n    {\r\n        // Stop Timers\r\n        TimerStop( &MacCtx.TxDelayedTimer );\r\n        TimerStop( &MacCtx.RxWindowTimer1 );\r\n        TimerStop( &MacCtx.RxWindowTimer2 );\r\n        TimerStop( &MacCtx.AckTimeoutTimer );\r\n\r\n        // Take care about class B\r\n        LoRaMacClassBHaltBeaconing( );\r\n\r\n        // Reset Mac parameters\r\n        ResetMacParameters( );\r\n\r\n        // Switch off Radio\r\n        Radio.Sleep( );\r\n\r\n        // Return success\r\n        return LORAMAC_STATUS_OK;\r\n    }\r\n    else\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n}\r\n", "/**\n * @file      atecc608a-tnglora-se.c\n *\n * @brief     ATECC608A-TNGLORA Secure Element hardware implementation\n *\n * @remark    Current implementation only supports LoRaWAN 1.0.x version\n *\n * @copyright Copyright (c) 2020 The Things Industries B.V.\n *\n * Revised BSD License\n * Copyright The Things Industries B.V 2020. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the Things Industries B.V nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE THINGS INDUSTRIES B.V BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"atca_basic.h\"\n#include \"cryptoauthlib.h\"\n#include \"atca_devtypes.h\"\n\n#include \"secure-element.h\"\n#include \"se-identity.h\"\n#include \"atecc608a-tnglora-se-hal.h\"\n\n/*!\n * Number of supported crypto keys\n */\n#define NUM_OF_KEYS 15\n\n#define DEV_EUI_ASCII_SIZE_BYTE 16U\n\n/*!\n * Identifier value pair type for Keys\n */\ntypedef struct sKey\n{\n    /*\n     * Key identifier (used for maping the stack MAC key to the ATECC608A-TNGLoRaWAN slot)\n     */\n    KeyIdentifier_t KeyID;\n    /*\n     * Key slot number\n     */\n    uint16_t KeySlotNumber;\n    /*\n     * Key block index within slot (each block can contain two keys, so index is either 0 or 1)\n     */\n    uint8_t KeyBlockIndex;\n} Key_t;\n\n/*\n * Secure Element Non Volatile Context structure\n */\ntypedef struct sSecureElementNvCtx\n{\n    /*!\n     * DevEUI storage\n     */\n    uint8_t DevEui[SE_EUI_SIZE];\n    /*!\n     * Join EUI storage\n     */\n    uint8_t JoinEui[SE_EUI_SIZE];\n    /*!\n     * Pin storage\n     */\n    uint8_t Pin[SE_PIN_SIZE];\n    /*!\n     * CMAC computation context variable\n     */\n    atca_aes_cmac_ctx_t AtcaAesCmacCtx;\n    /*!\n     * LoRaWAN key list\n     */\n    Key_t KeyList[NUM_OF_KEYS];\n} SecureElementNvCtx_t;\n\n/*!\n * Secure element context\n */\nstatic SecureElementNvCtx_t SeNvmCtx = {\n    /*!\n     * end-device IEEE EUI (big endian)\n     */\n    .DevEui = { 0 },\n    /*!\n     * App/Join server IEEE EUI (big endian)\n     */\n    .JoinEui = { 0 },\n    /*!\n     * Secure-element pin (big endian)\n     */\n    .Pin = SECURE_ELEMENT_PIN,\n    /*!\n     * LoRaWAN key list\n     */\n    .KeyList = ATECC608A_SE_KEY_LIST\n};\n\nstatic SecureElementNvmEvent SeNvmCtxChanged;\n\nstatic ATCAIfaceCfg atecc608_i2c_config;\n\nstatic ATCA_STATUS convert_ascii_devEUI( uint8_t* devEUI_ascii, uint8_t* devEUI );\n\nstatic ATCA_STATUS atcab_read_joinEUI( uint8_t* joinEUI )\n{\n    ATCA_STATUS status = ATCA_GEN_FAIL;\n    uint8_t     read_buf[ATCA_BLOCK_SIZE];\n\n    if( joinEUI == NULL )\n    {\n        return ATCA_BAD_PARAM;\n    }\n\n    do\n    {\n        status = atcab_read_zone( ATCA_ZONE_DATA, TNGLORA_JOIN_EUI_SLOT, 0, 0, read_buf, ATCA_BLOCK_SIZE );\n        if( status != ATCA_SUCCESS )\n        {\n            break;\n        }\n        memcpy1( joinEUI, read_buf, SE_EUI_SIZE );\n    } while( 0 );\n\n    return status;\n}\n\nstatic ATCA_STATUS atcab_read_ascii_devEUI( uint8_t* devEUI_ascii )\n{\n    ATCA_STATUS status = ATCA_GEN_FAIL;\n    uint8_t     read_buf[ATCA_BLOCK_SIZE];\n\n    if( devEUI_ascii == NULL )\n    {\n        return ATCA_BAD_PARAM;\n    }\n\n    do\n    {\n        status = atcab_read_zone( ATCA_ZONE_DATA, TNGLORA_DEV_EUI_SLOT, 0, 0, read_buf, ATCA_BLOCK_SIZE );\n        if( status != ATCA_SUCCESS )\n        {\n            break;\n        }\n        memcpy1( devEUI_ascii, read_buf, DEV_EUI_ASCII_SIZE_BYTE );\n    } while( 0 );\n\n    return status;\n}\n\nstatic ATCA_STATUS convert_ascii_devEUI( uint8_t* devEUI_ascii, uint8_t* devEUI )\n{\n    for( size_t pos = 0; pos < DEV_EUI_ASCII_SIZE_BYTE; pos += 2 )\n    {\n        uint8_t temp = 0;\n        if( ( devEUI_ascii[pos] >= '0' ) && ( devEUI_ascii[pos] <= '9' ) )\n        {\n            temp = ( devEUI_ascii[pos] - '0' ) << 4;\n        }\n        else if( ( devEUI_ascii[pos] >= 'A' ) && ( devEUI_ascii[pos] <= 'F' ) )\n        {\n            temp = ( ( devEUI_ascii[pos] - 'A' ) + 10 ) << 4;\n        }\n        else\n        {\n            return ATCA_BAD_PARAM;\n        }\n        if( ( devEUI_ascii[pos + 1] >= '0' ) && ( devEUI_ascii[pos + 1] <= '9' ) )\n        {\n            temp |= devEUI_ascii[pos + 1] - '0';\n        }\n        else if( ( devEUI_ascii[pos + 1] >= 'A' ) && ( devEUI_ascii[pos + 1] <= 'F' ) )\n        {\n            temp |= ( devEUI_ascii[pos + 1] - 'A' ) + 10;\n        }\n        else\n        {\n            return ATCA_BAD_PARAM;\n        }\n        devEUI[pos / 2] = temp;\n    }\n    return ATCA_SUCCESS;\n}\n\nstatic ATCA_STATUS atcab_read_devEUI( uint8_t* devEUI )\n{\n    ATCA_STATUS status = ATCA_GEN_FAIL;\n    uint8_t     devEUI_ascii[DEV_EUI_ASCII_SIZE_BYTE];\n\n    status = atcab_read_ascii_devEUI( devEUI_ascii );\n    if( status != ATCA_SUCCESS )\n    {\n        return status;\n    }\n    status = convert_ascii_devEUI( devEUI_ascii, devEUI );\n    return status;\n}\n\n/*\n * Gets key item from key list.\n *\n *  cmac = aes128_cmac(keyID, B0 | msg)\n *\n * \\param[IN]  keyID          - Key identifier\n * \\param[OUT] keyItem        - Key item reference\n * \\retval                    - Status of the operation\n */\nSecureElementStatus_t GetKeyByID( KeyIdentifier_t keyID, Key_t** keyItem )\n{\n    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )\n    {\n        if( SeNvmCtx.KeyList[i].KeyID == keyID )\n        {\n            *keyItem = &( SeNvmCtx.KeyList[i] );\n            return SECURE_ELEMENT_SUCCESS;\n        }\n    }\n    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n}\n\n/*\n * Dummy callback in case if the user provides NULL function pointer\n */\nstatic void DummyCB( void )\n{\n    return;\n}\n\n/*\n * Computes a CMAC of a message using provided initial Bx block\n *\n *  cmac = aes128_cmac(keyID, blocks[i].Buffer)\n *\n * \\param[IN]  micBxBuffer    - Buffer containing the initial Bx block\n * \\param[IN]  buffer         - Data buffer\n * \\param[IN]  size           - Data buffer size\n * \\param[IN]  keyID          - Key identifier to determine the AES key to be used\n * \\param[OUT] cmac           - Computed cmac\n * \\retval                    - Status of the operation\n */\nstatic SecureElementStatus_t ComputeCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,\n                                          uint32_t* cmac )\n{\n    if( ( buffer == NULL ) || ( cmac == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    uint8_t Cmac[16] = { 0 };\n\n    Key_t*                keyItem;\n    SecureElementStatus_t retval = GetKeyByID( keyID, &keyItem );\n    if( retval != SECURE_ELEMENT_SUCCESS )\n    {\n        return retval;\n    }\n\n    ATCA_STATUS status =\n        atcab_aes_cmac_init( &SeNvmCtx.AtcaAesCmacCtx, keyItem->KeySlotNumber, keyItem->KeyBlockIndex );\n\n    if( ATCA_SUCCESS == status )\n    {\n        if( micBxBuffer != NULL )\n        {\n            atcab_aes_cmac_update( &SeNvmCtx.AtcaAesCmacCtx, micBxBuffer, 16 );\n        }\n\n        atcab_aes_cmac_update( &SeNvmCtx.AtcaAesCmacCtx, buffer, size );\n\n        atcab_aes_cmac_finish( &SeNvmCtx.AtcaAesCmacCtx, Cmac, 16 );\n\n        *cmac = ( uint32_t )( ( uint32_t ) Cmac[3] << 24 | ( uint32_t ) Cmac[2] << 16 | ( uint32_t ) Cmac[1] << 8 |\n                              ( uint32_t ) Cmac[0] );\n        return SECURE_ELEMENT_SUCCESS;\n    }\n    else\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n}\n\nSecureElementStatus_t SecureElementInit( SecureElementNvmEvent seNvmCtxChanged )\n{\n#if !defined( SECURE_ELEMENT_PRE_PROVISIONED )\n#error \"ATECC608A is always pre-provisioned. Please set SECURE_ELEMENT_PRE_PROVISIONED to ON\"\n#endif\n    atecc608_i2c_config.iface_type            = ATCA_I2C_IFACE;\n    atecc608_i2c_config.atcai2c.baud          = ATCA_HAL_ATECC608A_I2C_FREQUENCY;\n    atecc608_i2c_config.atcai2c.bus           = ATCA_HAL_ATECC608A_I2C_BUS_PINS;\n    atecc608_i2c_config.atcai2c.slave_address = ATCA_HAL_ATECC608A_I2C_ADDRESS;\n    atecc608_i2c_config.devtype               = ATECC608A;\n    atecc608_i2c_config.rx_retries            = ATCA_HAL_ATECC608A_I2C_RX_RETRIES;\n    atecc608_i2c_config.wake_delay            = ATCA_HAL_ATECC608A_I2C_WAKEUP_DELAY;\n\n    if( atcab_init( &atecc608_i2c_config ) != ATCA_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n\n    if( atcab_read_devEUI( SeNvmCtx.DevEui ) != ATCA_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n\n    if( atcab_read_joinEUI( SeNvmCtx.JoinEui ) != ATCA_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n\n    // Assign callback\n    if( seNvmCtxChanged != 0 )\n    {\n        SeNvmCtxChanged = seNvmCtxChanged;\n    }\n    else\n    {\n        SeNvmCtxChanged = DummyCB;\n    }\n\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementRestoreNvmCtx( void* seNvmCtx )\n{\n    // Restore nvm context\n    if( seNvmCtx != 0 )\n    {\n        memcpy1( ( uint8_t* ) &SeNvmCtx, ( uint8_t* ) seNvmCtx, sizeof( SeNvmCtx ) );\n        return SECURE_ELEMENT_SUCCESS;\n    }\n    else\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n}\n\nvoid* SecureElementGetNvmCtx( size_t* seNvmCtxSize )\n{\n    *seNvmCtxSize = sizeof( SeNvmCtx );\n    return &SeNvmCtx;\n}\n\nSecureElementStatus_t SecureElementSetKey( KeyIdentifier_t keyID, uint8_t* key )\n{\n    // No key setting for HW SE, can only derive keys\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementComputeAesCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size,\n                                                   KeyIdentifier_t keyID, uint32_t* cmac )\n{\n    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )\n    {\n        // Never accept multicast key identifier for cmac computation\n        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n    }\n    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );\n}\n\nSecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,\n                                                  KeyIdentifier_t keyID )\n{\n    if( buffer == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    SecureElementStatus_t retval   = SECURE_ELEMENT_ERROR;\n    uint32_t              compCmac = 0;\n\n    retval = ComputeCmac( NULL, buffer, size, keyID, &compCmac );\n    if( retval != SECURE_ELEMENT_SUCCESS )\n    {\n        return retval;\n    }\n\n    if( expectedCmac != compCmac )\n    {\n        retval = SECURE_ELEMENT_FAIL_CMAC;\n    }\n\n    return retval;\n}\n\nSecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,\n                                               uint8_t* encBuffer )\n{\n    if( buffer == NULL || encBuffer == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Check if the size is divisible by 16,\n    if( ( size % 16 ) != 0 )\n    {\n        return SECURE_ELEMENT_ERROR_BUF_SIZE;\n    }\n\n    Key_t*                pItem;\n    SecureElementStatus_t retval = GetKeyByID( keyID, &pItem );\n\n    if( retval == SECURE_ELEMENT_SUCCESS )\n    {\n        uint8_t block = 0;\n\n        while( size != 0 )\n        {\n            atcab_aes_encrypt( pItem->KeySlotNumber, pItem->KeyBlockIndex, &buffer[block], &encBuffer[block] );\n            block = block + 16;\n            size  = size - 16;\n        }\n    }\n    return retval;\n}\n\nSecureElementStatus_t SecureElementDeriveAndStoreKey( Version_t version, uint8_t* input, KeyIdentifier_t rootKeyID,\n                                                      KeyIdentifier_t targetKeyID )\n{\n    if( input == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Source key slot is the LSB and target key slot is the MSB\n    uint16_t    source_target_ids = 0;\n    Key_t*      source_key;\n    Key_t*      target_key;\n    ATCA_STATUS status = ATCA_SUCCESS;\n\n    // In case of MC_KE_KEY, only McRootKey can be used as root key\n    if( targetKeyID == MC_KE_KEY )\n    {\n        if( rootKeyID != MC_ROOT_KEY )\n        {\n            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n        }\n    }\n\n    if( ( rootKeyID == APP_KEY ) || ( rootKeyID == MC_ROOT_KEY ) || ( rootKeyID == MC_KE_KEY ) )\n    {\n        // Allow the stack to move forward as these rootkeys dont exist inside SE.\n        return SECURE_ELEMENT_SUCCESS;\n    }\n\n    if( GetKeyByID( rootKeyID, &source_key ) != SECURE_ELEMENT_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n    }\n\n    if( GetKeyByID( targetKeyID, &target_key ) != SECURE_ELEMENT_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n    }\n\n    source_target_ids = target_key->KeySlotNumber << 8;\n    source_target_ids += source_key->KeySlotNumber;\n\n    uint32_t detail = source_key->KeyBlockIndex;\n\n    status = atcab_kdf( KDF_MODE_ALG_AES | KDF_MODE_SOURCE_SLOT | KDF_MODE_TARGET_SLOT, source_target_ids, detail,\n                        input, NULL, NULL );\n    if( status == ATCA_SUCCESS )\n    {\n        return SECURE_ELEMENT_SUCCESS;\n    }\n    else\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n}\n\nSecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,\n                                                      uint16_t devNonce, uint8_t* encJoinAccept,\n                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,\n                                                      uint8_t* versionMinor )\n{\n    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Determine decryption key\n    KeyIdentifier_t encKeyID = NWK_KEY;\n\n    if( joinReqType != JOIN_REQ )\n    {\n        encKeyID = J_S_ENC_KEY;\n    }\n\n    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );\n\n    // Decrypt JoinAccept, skip MHDR\n    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,\n                                 encKeyID, decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS )\n    {\n        return SECURE_ELEMENT_FAIL_ENCRYPT;\n    }\n\n    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;\n\n    uint32_t mic = 0;\n\n    mic = ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE] << 0 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1] << 8 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );\n\n    //  - Header buffer to be used for MIC computation\n    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]\n    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]\n\n    // Verify mic\n    if( *versionMinor == 0 )\n    {\n        // For LoRaWAN 1.0.x\n        //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |\n        //   CFListType)\n        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=\n            SECURE_ELEMENT_SUCCESS )\n        {\n            return SECURE_ELEMENT_FAIL_CMAC;\n        }\n    }\n#if( USE_LRWAN_1_1_X_CRYPTO == 1 )\n    else if( *versionMinor == 1 )\n    {\n        uint8_t  micHeader11[JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n        uint16_t bufItr                                          = 0;\n\n        micHeader11[bufItr++] = ( uint8_t ) joinReqType;\n\n        memcpyr( micHeader11 + bufItr, joinEui, LORAMAC_JOIN_EUI_FIELD_SIZE );\n        bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;\n\n        micHeader11[bufItr++] = devNonce & 0xFF;\n        micHeader11[bufItr++] = ( devNonce >> 8 ) & 0xFF;\n\n        // For LoRaWAN 1.1.x and later:\n        //   cmac = aes128_cmac(JSIntKey, JoinReqType | JoinEUI | DevNonce | MHDR | JoinNonce | NetID | DevAddr |\n        //   DLSettings | RxDelay | CFList | CFListType)\n        // Prepare the msg for integrity check (adding JoinReqType, JoinEUI and DevNonce)\n        uint8_t localBuffer[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n\n        memcpy1( localBuffer, micHeader11, JOIN_ACCEPT_MIC_COMPUTATION_OFFSET );\n        memcpy1( localBuffer + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET - 1, decJoinAccept, encJoinAcceptSize );\n\n        if( SecureElementVerifyAesCmac( localBuffer,\n                                        encJoinAcceptSize + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET -\n                                            LORAMAC_MHDR_FIELD_SIZE - LORAMAC_MIC_FIELD_SIZE,\n                                        mic, J_S_INT_KEY ) != SECURE_ELEMENT_SUCCESS )\n        {\n            return SECURE_ELEMENT_FAIL_CMAC;\n        }\n    }\n#endif\n    else\n    {\n        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;\n    }\n\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementRandomNumber( uint32_t* randomNum )\n{\n    if( randomNum == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    *randomNum = ATECC608ASeHalGetRandomNumber( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementSetDevEui( uint8_t* devEui )\n{\n    if( devEui == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    memcpy1( SeNvmCtx.DevEui, devEui, SE_EUI_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetDevEui( void )\n{\n    return SeNvmCtx.DevEui;\n}\n\nSecureElementStatus_t SecureElementSetJoinEui( uint8_t* joinEui )\n{\n    if( joinEui == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    memcpy1( SeNvmCtx.JoinEui, joinEui, SE_EUI_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetJoinEui( void )\n{\n    return SeNvmCtx.JoinEui;\n}\n\nSecureElementStatus_t SecureElementSetPin( uint8_t* pin )\n{\n    if( pin == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    memcpy1( SeNvmCtx.Pin, pin, SE_PIN_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetPin( void )\n{\n    return SeNvmCtx.Pin;\n}\n", "/*!\n * \\file      lr1110-se.c\n *\n * \\brief     LR1110 Secure Element hardware implementation\n *\n * \\copyright Revised BSD License, see section \\ref LICENSE.\n *\n * \\code\n *                ______                              _\n *               / _____)             _              | |\n *              ( (____  _____ ____ _| |_ _____  ____| |__\n *               \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n *               _____) ) ____| | | || |_| ____( (___| | | |\n *              (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n *              (C)2019-2019 Semtech\n *\n * \\endcode\n *\n * \\authors    Semtech WSP Applications Team\n */\n#include <stdlib.h>\n#include <stdint.h>\n\n#include \"lr1110.h\"\n#include \"lr1110_system.h\"\n#include \"lr1110_crypto_engine.h\"\n\n#include \"secure-element.h\"\n#include \"se-identity.h\"\n#include \"lr1110-se-hal.h\"\n\n/*!\n * Number of supported crypto keys\n */\n#define NUM_OF_KEYS 23\n\n/*\n * CMAC/AES Message Integrity Code (MIC) Block B0 size\n */\n#define MIC_BLOCK_BX_SIZE 16\n\n/*\n * Maximum size of the message that can be handled by the crypto operations\n */\n#define CRYPTO_MAXMESSAGE_SIZE 256\n\n/*\n * Maximum size of the buffer for crypto operations\n */\n#define CRYPTO_BUFFER_SIZE CRYPTO_MAXMESSAGE_SIZE + MIC_BLOCK_BX_SIZE\n\n/*!\n * Secure-element LoRaWAN identity local storage.\n */\ntypedef struct sSecureElementNvCtx\n{\n    /*\n     * DevEUI storage\n     */\n    uint8_t DevEui[SE_EUI_SIZE];\n    /*\n     * Join EUI storage\n     */\n    uint8_t JoinEui[SE_EUI_SIZE];\n    /*\n     * PIN of the LR1110\n     */\n    uint8_t Pin[SE_PIN_SIZE];\n} SecureElementNvCtx_t;\n\nstatic SecureElementNvCtx_t SeContext = {\n    /*!\n     * end-device IEEE EUI (big endian)\n     *\n     * \\remark In this application the value is automatically generated by calling\n     *         BoardGetUniqueId function\n     */\n    .DevEui = LORAWAN_DEVICE_EUI,\n    /*!\n     * App/Join server IEEE EUI (big endian)\n     */\n    .JoinEui = LORAWAN_JOIN_EUI,\n    /*!\n     * Secure-element pin (big endian)\n     */\n    .Pin = SECURE_ELEMENT_PIN,\n};\n\nstatic SecureElementNvmEvent SeNvmCtxChanged;\n\n/*!\n * LR1110 radio context\n */\nextern lr1110_t LR1110;\n\n/*!\n * Converts key ids from SecureElement to LR1110\n *\n * \\param [IN] key_id SecureElement key id to be converted\n *\n * \\retval key_id Converted LR1110 key id\n */\nstatic lr1110_crypto_keys_idx_t convert_key_id_from_se_to_lr1110( KeyIdentifier_t key_id );\n\n/*!\n * Dummy callback in case if the user provides NULL function pointer\n */\nstatic void DummyCB( void )\n{\n    return;\n}\n\nSecureElementStatus_t SecureElementInit( SecureElementNvmEvent seNvmCtxChanged )\n{\n    lr1110_crypto_status_t status = LR1110_CRYPTO_STATUS_ERROR;\n\n    // Assign callback\n    if( seNvmCtxChanged != 0 )\n    {\n        SeNvmCtxChanged = seNvmCtxChanged;\n    }\n    else\n    {\n        SeNvmCtxChanged = DummyCB;\n    }\n\n    lr1110_crypto_restore_from_flash( &LR1110, &status );\n\n#if defined( SECURE_ELEMENT_PRE_PROVISIONED )\n    // Read LR1110 pre-provisioned identity\n    lr1110_system_read_uid( &LR1110, SeContext.DevEui );\n    lr1110_system_read_join_eui( &LR1110, SeContext.JoinEui );\n    lr1110_system_read_pin( &LR1110, SeContext.Pin );\n#else\n#if( STATIC_DEVICE_EUI == 0 )\n    // Get a DevEUI from MCU unique ID\n    LR1110SeHalGetUniqueId( SeContext.DevEui );\n#endif\n#endif\n\n    SeNvmCtxChanged( );\n\n    return ( SecureElementStatus_t ) status;\n}\n\nSecureElementStatus_t SecureElementRestoreNvmCtx( void* seNvmCtx )\n{\n    lr1110_crypto_status_t status = LR1110_CRYPTO_STATUS_ERROR;\n\n    if( seNvmCtx == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Restore lr1110 crypto context\n    lr1110_crypto_restore_from_flash( &LR1110, &status );\n\n    // Restore nvm context\n    memcpy1( ( uint8_t* ) &SeContext, ( uint8_t* ) seNvmCtx, sizeof( SeContext ) );\n\n    return ( SecureElementStatus_t ) status;\n}\n\nvoid* SecureElementGetNvmCtx( size_t* seNvmCtxSize )\n{\n    *seNvmCtxSize = sizeof( SeContext );\n    return &SeContext;\n}\n\nSecureElementStatus_t SecureElementSetKey( KeyIdentifier_t keyID, uint8_t* key )\n{\n    if( key == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;\n\n    if( ( keyID == MC_KEY_0 ) || ( keyID == MC_KEY_1 ) || ( keyID == MC_KEY_2 ) || ( keyID == MC_KEY_3 ) )\n    {  // Decrypt the key if its a Mckey\n\n        lr1110_crypto_derive_and_store_key( &LR1110, ( lr1110_crypto_status_t* ) &status,\n                                            convert_key_id_from_se_to_lr1110( MC_KE_KEY ),\n                                            convert_key_id_from_se_to_lr1110( keyID ), key );\n\n        if( status == SECURE_ELEMENT_SUCCESS )\n        {\n            lr1110_crypto_store_to_flash( &LR1110, ( lr1110_crypto_status_t* ) &status );\n        }\n        return status;\n    }\n    else\n    {\n        lr1110_crypto_set_key( &LR1110, ( lr1110_crypto_status_t* ) &status, convert_key_id_from_se_to_lr1110( keyID ),\n                               key );\n        if( status == SECURE_ELEMENT_SUCCESS )\n        {\n            lr1110_crypto_store_to_flash( &LR1110, ( lr1110_crypto_status_t* ) &status );\n        }\n        return status;\n    }\n}\n\nSecureElementStatus_t SecureElementComputeAesCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size,\n                                                   KeyIdentifier_t keyID, uint32_t* cmac )\n{\n    SecureElementStatus_t status      = SECURE_ELEMENT_ERROR;\n    uint16_t              localSize   = size;\n    uint8_t*              localbuffer = buffer;\n\n    if( micBxBuffer != NULL )\n    {\n        uint8_t micBuff[CRYPTO_BUFFER_SIZE];\n\n        memset1( micBuff, 0, CRYPTO_BUFFER_SIZE );\n\n        memcpy1( micBuff, micBxBuffer, MIC_BLOCK_BX_SIZE );\n        memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), buffer, size );\n        localSize += MIC_BLOCK_BX_SIZE;\n        localbuffer = micBuff;\n    }\n\n    lr1110_crypto_compute_aes_cmac( &LR1110, ( lr1110_crypto_status_t* ) &status,\n                                    convert_key_id_from_se_to_lr1110( keyID ), localbuffer, localSize,\n                                    ( uint8_t* ) cmac );\n\n    return status;\n}\n\nSecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,\n                                                  KeyIdentifier_t keyID )\n{\n    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;\n\n    if( buffer == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    lr1110_crypto_verify_aes_cmac( &LR1110, ( lr1110_crypto_status_t* ) &status,\n                                   convert_key_id_from_se_to_lr1110( keyID ), buffer, size,\n                                   ( uint8_t* ) &expectedCmac );\n\n    return status;\n}\n\nSecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,\n                                               uint8_t* encBuffer )\n{\n    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;\n\n    if( ( buffer == NULL ) || ( encBuffer == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    lr1110_crypto_aes_encrypt_01( &LR1110, ( lr1110_crypto_status_t* ) &status,\n                                  convert_key_id_from_se_to_lr1110( keyID ), buffer, size, encBuffer );\n\n    return status;\n}\n\nSecureElementStatus_t SecureElementDeriveAndStoreKey( Version_t version, uint8_t* input, KeyIdentifier_t rootKeyID,\n                                                      KeyIdentifier_t targetKeyID )\n{\n    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;\n\n    if( input == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    lr1110_crypto_derive_and_store_key( &LR1110, ( lr1110_crypto_status_t* ) &status,\n                                        convert_key_id_from_se_to_lr1110( rootKeyID ),\n                                        convert_key_id_from_se_to_lr1110( targetKeyID ), input );\n\n    lr1110_crypto_store_to_flash( &LR1110, ( lr1110_crypto_status_t* ) &status );\n    return status;\n}\n\nSecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,\n                                                      uint16_t devNonce, uint8_t* encJoinAccept,\n                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,\n                                                      uint8_t* versionMinor )\n{\n    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;\n\n    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Determine decryption key\n    KeyIdentifier_t encKeyID = NWK_KEY;\n\n    if( joinReqType != JOIN_REQ )\n    {\n        encKeyID = J_S_ENC_KEY;\n    }\n\n    //  - Header buffer to be used for MIC computation\n    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]\n    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]\n\n    // Try first to process LoRaWAN 1.0.x JoinAccept\n    uint8_t micHeader10[1] = { 0x20 };\n\n    //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |\n    //   CFListType)\n    lr1110_crypto_process_join_accept(\n        &LR1110, ( lr1110_crypto_status_t* ) &status, convert_key_id_from_se_to_lr1110( encKeyID ),\n        convert_key_id_from_se_to_lr1110( NWK_KEY ), ( lr1110_crypto_lorawan_version_t ) 0, micHeader10,\n        encJoinAccept + 1, encJoinAcceptSize - 1, decJoinAccept + 1 );\n\n    if( status == SECURE_ELEMENT_SUCCESS )\n    {\n        *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;\n        if( *versionMinor == 0 )\n        {\n            // Network server is operating according to LoRaWAN 1.0.x\n            return SECURE_ELEMENT_SUCCESS;\n        }\n    }\n\n#if( USE_LRWAN_1_1_X_CRYPTO == 1 )\n    // 1.0.x trial failed. Trying to process LoRaWAN 1.1.x JoinAccept\n    uint8_t  micHeader11[JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n    uint16_t bufItr                                     = 0;\n\n    //   cmac = aes128_cmac(JSIntKey, JoinReqType | JoinEUI | DevNonce | MHDR | JoinNonce | NetID | DevAddr |\n    //   DLSettings | RxDelay | CFList | CFListType)\n    micHeader11[bufItr++] = ( uint8_t ) joinReqType;\n\n    memcpyr( micHeader11 + bufItr, joinEui, LORAMAC_JOIN_EUI_FIELD_SIZE );\n    bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;\n\n    micHeader11[bufItr++] = devNonce & 0xFF;\n    micHeader11[bufItr++] = ( devNonce >> 8 ) & 0xFF;\n\n    micHeader11[bufItr++] = 0x20;\n\n    lr1110_crypto_process_join_accept(\n        &LR1110, ( lr1110_crypto_status_t* ) &status, convert_key_id_from_se_to_lr1110( encKeyID ),\n        convert_key_id_from_se_to_lr1110( J_S_INT_KEY ), ( lr1110_crypto_lorawan_version_t ) 1, micHeader11,\n        encJoinAccept + 1, encJoinAcceptSize - 1, decJoinAccept + 1 );\n\n    if( status == SECURE_ELEMENT_SUCCESS )\n    {\n        *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;\n        if( *versionMinor == 1 )\n        {\n            // Network server is operating according to LoRaWAN 1.1.x\n            return SECURE_ELEMENT_SUCCESS;\n        }\n    }\n#endif\n\n    return status;\n}\n\nSecureElementStatus_t SecureElementRandomNumber( uint32_t* randomNum )\n{\n    if( randomNum == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    *randomNum = LR1110SeHalGetRandomNumber( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementSetDevEui( uint8_t* devEui )\n{\n    if( devEui == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    memcpy1( SeContext.DevEui, devEui, SE_EUI_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetDevEui( void )\n{\n    return SeContext.DevEui;\n}\n\nSecureElementStatus_t SecureElementSetJoinEui( uint8_t* joinEui )\n{\n    if( joinEui == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    memcpy1( SeContext.JoinEui, joinEui, SE_EUI_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetJoinEui( void )\n{\n    return SeContext.JoinEui;\n}\n\nSecureElementStatus_t SecureElementSetPin( uint8_t* pin )\n{\n    if( pin == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    memcpy1( SeContext.Pin, pin, SE_PIN_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetPin( void )\n{\n    return SeContext.Pin;\n}\n\nstatic lr1110_crypto_keys_idx_t convert_key_id_from_se_to_lr1110( KeyIdentifier_t key_id )\n{\n    lr1110_crypto_keys_idx_t id = LR1110_CRYPTO_KEYS_IDX_GP0;\n\n    switch( key_id )\n    {\n        case APP_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_APP_KEY;\n            break;\n        case NWK_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_NWK_KEY;\n            break;\n        case J_S_INT_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_J_S_INT_KEY;\n            break;\n        case J_S_ENC_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_J_S_ENC_KEY;\n            break;\n        case F_NWK_S_INT_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_F_NWK_S_INT_KEY;\n            break;\n        case S_NWK_S_INT_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_S_NWK_S_INT_KEY;\n            break;\n        case NWK_S_ENC_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_NWK_S_ENC_KEY;\n            break;\n        case APP_S_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_APP_S_KEY;\n            break;\n        case MC_ROOT_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_5;\n            break;\n        case MC_KE_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_4;\n            break;\n        case MC_KEY_0:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_0;\n            break;\n        case MC_APP_S_KEY_0:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_0;\n            break;\n        case MC_NWK_S_KEY_0:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_0;\n            break;\n        case MC_KEY_1:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_1;\n            break;\n        case MC_APP_S_KEY_1:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_1;\n            break;\n        case MC_NWK_S_KEY_1:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_1;\n            break;\n        case MC_KEY_2:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_2;\n            break;\n        case MC_APP_S_KEY_2:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_2;\n            break;\n        case MC_NWK_S_KEY_2:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_2;\n            break;\n        case MC_KEY_3:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_3;\n            break;\n        case MC_APP_S_KEY_3:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_3;\n            break;\n        case MC_NWK_S_KEY_3:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_3;\n            break;\n        case SLOT_RAND_ZERO_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_GP0;\n            break;\n        default:\n            id = LR1110_CRYPTO_KEYS_IDX_GP1;\n            break;\n    }\n    return id;\n}\n", "/*!\n * \\file      soft-se.c\n *\n * \\brief     Secure Element software implementation\n *\n * \\copyright Revised BSD License, see section \\ref LICENSE.\n *\n * \\code\n *                ______                              _\n *               / _____)             _              | |\n *              ( (____  _____ ____ _| |_ _____  ____| |__\n *               \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n *               _____) ) ____| | | || |_| ____( (___| | | |\n *              (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n *              (C)2020 Semtech\n *\n *               ___ _____ _   ___ _  _____ ___  ___  ___ ___\n *              / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n *              \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n *              |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\n *              embedded.connectivity.solutions===============\n *\n * \\endcode\n *\n */\n#include <stdlib.h>\n#include <stdint.h>\n\n#include \"utilities.h\"\n#include \"aes.h\"\n#include \"cmac.h\"\n\n#include \"LoRaMacHeaderTypes.h\"\n\n#include \"secure-element.h\"\n#include \"se-identity.h\"\n#include \"soft-se-hal.h\"\n\n/*!\n * Number of supported crypto keys\n */\n#define NUM_OF_KEYS 23\n\n/*!\n * Identifier value pair type for Keys\n */\ntypedef struct sKey\n{\n    /*\n     * Key identifier\n     */\n    KeyIdentifier_t KeyID;\n    /*\n     * Key value\n     */\n    uint8_t KeyValue[SE_KEY_SIZE];\n} Key_t;\n\n/*\n * Secure Element Non Volatile Context structure\n */\ntypedef struct sSecureElementNvCtx\n{\n    /*\n     * DevEUI storage\n     */\n    uint8_t DevEui[SE_EUI_SIZE];\n    /*\n     * Join EUI storage\n     */\n    uint8_t JoinEui[SE_EUI_SIZE];\n    /*\n     * Pin storage\n     */\n    uint8_t Pin[SE_PIN_SIZE];\n    /*\n     * AES computation context variable\n     */\n    aes_context AesContext;\n    /*\n     * CMAC computation context variable\n     */\n    AES_CMAC_CTX AesCmacCtx[1];\n    /*\n     * Key List\n     */\n    Key_t KeyList[NUM_OF_KEYS];\n} SecureElementNvCtx_t;\n\n/*!\n * Secure element context\n */\nstatic SecureElementNvCtx_t SeNvmCtx = {\n    /*!\n     * end-device IEEE EUI (big endian)\n     *\n     * \\remark In this application the value is automatically generated by calling\n     *         BoardGetUniqueId function\n     */\n    .DevEui = LORAWAN_DEVICE_EUI,\n    /*!\n     * App/Join server IEEE EUI (big endian)\n     */\n    .JoinEui = LORAWAN_JOIN_EUI,\n    /*!\n     * Secure-element pin (big endian)\n     */\n    .Pin = SECURE_ELEMENT_PIN,\n    /*!\n     * LoRaWAN key list\n     */\n    .KeyList = SOFT_SE_KEY_LIST\n};\n\nstatic SecureElementNvmEvent SeNvmCtxChanged;\n\n/*\n * Local functions\n */\n\n/*\n * Gets key item from key list.\n *\n * \\param[IN]  keyID          - Key identifier\n * \\param[OUT] keyItem        - Key item reference\n * \\retval                    - Status of the operation\n */\nstatic SecureElementStatus_t GetKeyByID( KeyIdentifier_t keyID, Key_t** keyItem )\n{\n    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )\n    {\n        if( SeNvmCtx.KeyList[i].KeyID == keyID )\n        {\n            *keyItem = &( SeNvmCtx.KeyList[i] );\n            return SECURE_ELEMENT_SUCCESS;\n        }\n    }\n    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n}\n\n/*\n * Dummy callback in case if the user provides NULL function pointer\n */\nstatic void DummyCB( void )\n{\n    return;\n}\n\n/*\n * Computes a CMAC of a message using provided initial Bx block\n *\n *  cmac = aes128_cmac(keyID, blocks[i].Buffer)\n *\n * \\param[IN]  micBxBuffer    - Buffer containing the initial Bx block\n * \\param[IN]  buffer         - Data buffer\n * \\param[IN]  size           - Data buffer size\n * \\param[IN]  keyID          - Key identifier to determine the AES key to be used\n * \\param[OUT] cmac           - Computed cmac\n * \\retval                    - Status of the operation\n */\nstatic SecureElementStatus_t ComputeCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,\n                                          uint32_t* cmac )\n{\n    if( ( buffer == NULL ) || ( cmac == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    uint8_t Cmac[16];\n\n    AES_CMAC_Init( SeNvmCtx.AesCmacCtx );\n\n    Key_t*                keyItem;\n    SecureElementStatus_t retval = GetKeyByID( keyID, &keyItem );\n\n    if( retval == SECURE_ELEMENT_SUCCESS )\n    {\n        AES_CMAC_SetKey( SeNvmCtx.AesCmacCtx, keyItem->KeyValue );\n\n        if( micBxBuffer != NULL )\n        {\n            AES_CMAC_Update( SeNvmCtx.AesCmacCtx, micBxBuffer, 16 );\n        }\n\n        AES_CMAC_Update( SeNvmCtx.AesCmacCtx, buffer, size );\n\n        AES_CMAC_Final( Cmac, SeNvmCtx.AesCmacCtx );\n\n        // Bring into the required format\n        *cmac = ( uint32_t )( ( uint32_t ) Cmac[3] << 24 | ( uint32_t ) Cmac[2] << 16 | ( uint32_t ) Cmac[1] << 8 |\n                              ( uint32_t ) Cmac[0] );\n    }\n\n    return retval;\n}\n\n/*\n * API functions\n */\n\nSecureElementStatus_t SecureElementInit( SecureElementNvmEvent seNvmCtxChanged )\n{\n    // Assign callback\n    if( seNvmCtxChanged != 0 )\n    {\n        SeNvmCtxChanged = seNvmCtxChanged;\n    }\n    else\n    {\n        SeNvmCtxChanged = DummyCB;\n    }\n\n#if !defined( SECURE_ELEMENT_PRE_PROVISIONED )\n#if( STATIC_DEVICE_EUI == 0 )\n    // Get a DevEUI from MCU unique ID\n    SoftSeHalGetUniqueId( SeNvmCtx.DevEui );\n#endif\n#endif\n\n    SeNvmCtxChanged( );\n\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementRestoreNvmCtx( void* seNvmCtx )\n{\n    // Restore nvm context\n    if( seNvmCtx != 0 )\n    {\n        memcpy1( ( uint8_t* ) &SeNvmCtx, ( uint8_t* ) seNvmCtx, sizeof( SeNvmCtx ) );\n        return SECURE_ELEMENT_SUCCESS;\n    }\n    else\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n}\n\nvoid* SecureElementGetNvmCtx( size_t* seNvmCtxSize )\n{\n    *seNvmCtxSize = sizeof( SeNvmCtx );\n    return &SeNvmCtx;\n}\n\nSecureElementStatus_t SecureElementSetKey( KeyIdentifier_t keyID, uint8_t* key )\n{\n    if( key == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )\n    {\n        if( SeNvmCtx.KeyList[i].KeyID == keyID )\n        {\n            if( ( keyID == MC_KEY_0 ) || ( keyID == MC_KEY_1 ) || ( keyID == MC_KEY_2 ) || ( keyID == MC_KEY_3 ) )\n            {  // Decrypt the key if its a Mckey\n                SecureElementStatus_t retval           = SECURE_ELEMENT_ERROR;\n                uint8_t               decryptedKey[16] = { 0 };\n\n                retval = SecureElementAesEncrypt( key, 16, MC_KE_KEY, decryptedKey );\n\n                memcpy1( SeNvmCtx.KeyList[i].KeyValue, decryptedKey, SE_KEY_SIZE );\n                SeNvmCtxChanged( );\n\n                return retval;\n            }\n            else\n            {\n                memcpy1( SeNvmCtx.KeyList[i].KeyValue, key, SE_KEY_SIZE );\n                SeNvmCtxChanged( );\n                return SECURE_ELEMENT_SUCCESS;\n            }\n        }\n    }\n\n    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n}\n\nSecureElementStatus_t SecureElementComputeAesCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size,\n                                                   KeyIdentifier_t keyID, uint32_t* cmac )\n{\n    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )\n    {\n        // Never accept multicast key identifier for cmac computation\n        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n    }\n\n    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );\n}\n\nSecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,\n                                                  KeyIdentifier_t keyID )\n{\n    if( buffer == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    SecureElementStatus_t retval   = SECURE_ELEMENT_ERROR;\n    uint32_t              compCmac = 0;\n    retval                         = ComputeCmac( NULL, buffer, size, keyID, &compCmac );\n    if( retval != SECURE_ELEMENT_SUCCESS )\n    {\n        return retval;\n    }\n\n    if( expectedCmac != compCmac )\n    {\n        retval = SECURE_ELEMENT_FAIL_CMAC;\n    }\n\n    return retval;\n}\n\nSecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,\n                                               uint8_t* encBuffer )\n{\n    if( buffer == NULL || encBuffer == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Check if the size is divisible by 16,\n    if( ( size % 16 ) != 0 )\n    {\n        return SECURE_ELEMENT_ERROR_BUF_SIZE;\n    }\n\n    memset1( SeNvmCtx.AesContext.ksch, '\\0', 240 );\n\n    Key_t*                pItem;\n    SecureElementStatus_t retval = GetKeyByID( keyID, &pItem );\n\n    if( retval == SECURE_ELEMENT_SUCCESS )\n    {\n        aes_set_key( pItem->KeyValue, 16, &SeNvmCtx.AesContext );\n\n        uint8_t block = 0;\n\n        while( size != 0 )\n        {\n            aes_encrypt( &buffer[block], &encBuffer[block], &SeNvmCtx.AesContext );\n            block = block + 16;\n            size  = size - 16;\n        }\n    }\n    return retval;\n}\n\nSecureElementStatus_t SecureElementDeriveAndStoreKey( Version_t version, uint8_t* input, KeyIdentifier_t rootKeyID,\n                                                      KeyIdentifier_t targetKeyID )\n{\n    if( input == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;\n    uint8_t               key[16] = { 0 };\n\n    // In case of MC_KE_KEY, only McRootKey can be used as root key\n    if( targetKeyID == MC_KE_KEY )\n    {\n        if( rootKeyID != MC_ROOT_KEY )\n        {\n            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n        }\n    }\n\n    // Derive key\n    retval = SecureElementAesEncrypt( input, 16, rootKeyID, key );\n    if( retval != SECURE_ELEMENT_SUCCESS )\n    {\n        return retval;\n    }\n\n    // Store key\n    retval = SecureElementSetKey( targetKeyID, key );\n    if( retval != SECURE_ELEMENT_SUCCESS )\n    {\n        return retval;\n    }\n\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,\n                                                      uint16_t devNonce, uint8_t* encJoinAccept,\n                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,\n                                                      uint8_t* versionMinor )\n{\n    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Determine decryption key\n    KeyIdentifier_t encKeyID = NWK_KEY;\n\n    if( joinReqType != JOIN_REQ )\n    {\n        encKeyID = J_S_ENC_KEY;\n    }\n\n    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );\n\n    // Decrypt JoinAccept, skip MHDR\n    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,\n                                 encKeyID, decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS )\n    {\n        return SECURE_ELEMENT_FAIL_ENCRYPT;\n    }\n\n    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;\n\n    uint32_t mic = 0;\n\n    mic = ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE] << 0 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1] << 8 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );\n\n    //  - Header buffer to be used for MIC computation\n    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]\n    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]\n\n    // Verify mic\n    if( *versionMinor == 0 )\n    {\n        // For LoRaWAN 1.0.x\n        //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |\n        //   CFListType)\n        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=\n            SECURE_ELEMENT_SUCCESS )\n        {\n            return SECURE_ELEMENT_FAIL_CMAC;\n        }\n    }\n#if( USE_LRWAN_1_1_X_CRYPTO == 1 )\n    else if( *versionMinor == 1 )\n    {\n        uint8_t  micHeader11[JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n        uint16_t bufItr                                          = 0;\n\n        micHeader11[bufItr++] = ( uint8_t ) joinReqType;\n\n        memcpyr( micHeader11 + bufItr, joinEui, LORAMAC_JOIN_EUI_FIELD_SIZE );\n        bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;\n\n        micHeader11[bufItr++] = devNonce & 0xFF;\n        micHeader11[bufItr++] = ( devNonce >> 8 ) & 0xFF;\n\n        // For LoRaWAN 1.1.x and later:\n        //   cmac = aes128_cmac(JSIntKey, JoinReqType | JoinEUI | DevNonce | MHDR | JoinNonce | NetID | DevAddr |\n        //   DLSettings | RxDelay | CFList | CFListType)\n        // Prepare the msg for integrity check (adding JoinReqType, JoinEUI and DevNonce)\n        uint8_t localBuffer[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n\n        memcpy1( localBuffer, micHeader11, JOIN_ACCEPT_MIC_COMPUTATION_OFFSET );\n        memcpy1( localBuffer + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET - 1, decJoinAccept, encJoinAcceptSize );\n\n        if( SecureElementVerifyAesCmac( localBuffer,\n                                        encJoinAcceptSize + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET -\n                                            LORAMAC_MHDR_FIELD_SIZE - LORAMAC_MIC_FIELD_SIZE,\n                                        mic, J_S_INT_KEY ) != SECURE_ELEMENT_SUCCESS )\n        {\n            return SECURE_ELEMENT_FAIL_CMAC;\n        }\n    }\n#endif\n    else\n    {\n        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;\n    }\n\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementRandomNumber( uint32_t* randomNum )\n{\n    if( randomNum == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    *randomNum = SoftSeHalGetRandomNumber( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementSetDevEui( uint8_t* devEui )\n{\n    if( devEui == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    memcpy1( SeNvmCtx.DevEui, devEui, SE_EUI_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetDevEui( void )\n{\n    return SeNvmCtx.DevEui;\n}\n\nSecureElementStatus_t SecureElementSetJoinEui( uint8_t* joinEui )\n{\n    if( joinEui == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    memcpy1( SeNvmCtx.JoinEui, joinEui, SE_EUI_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetJoinEui( void )\n{\n    return SeNvmCtx.JoinEui;\n}\n\nSecureElementStatus_t SecureElementSetPin( uint8_t* pin )\n{\n    if( pin == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    memcpy1( SeNvmCtx.Pin, pin, SE_PIN_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetPin( void )\n{\n    return SeNvmCtx.Pin;\n}\n"], "fixing_code": ["/*!\r\n * \\file      LoRaMac.c\r\n *\r\n * \\brief     LoRa MAC layer implementation\r\n *\r\n * \\copyright Revised BSD License, see section \\ref LICENSE.\r\n *\r\n * \\code\r\n *                ______                              _\r\n *               / _____)             _              | |\r\n *              ( (____  _____ ____ _| |_ _____  ____| |__\r\n *               \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\r\n *               _____) ) ____| | | || |_| ____( (___| | | |\r\n *              (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\r\n *              (C)2013-2017 Semtech\r\n *\r\n *               ___ _____ _   ___ _  _____ ___  ___  ___ ___\r\n *              / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\r\n *              \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\r\n *              |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\r\n *              embedded.connectivity.solutions===============\r\n *\r\n * \\endcode\r\n *\r\n * \\author    Miguel Luis ( Semtech )\r\n *\r\n * \\author    Gregory Cristian ( Semtech )\r\n *\r\n * \\author    Daniel Jaeckle ( STACKFORCE )\r\n *\r\n * \\author    Johannes Bruder ( STACKFORCE )\r\n */\r\n#include \"utilities.h\"\r\n#include \"region/Region.h\"\r\n#include \"LoRaMacClassB.h\"\r\n#include \"LoRaMacCrypto.h\"\r\n#include \"secure-element.h\"\r\n#include \"LoRaMacTest.h\"\r\n#include \"LoRaMacTypes.h\"\r\n#include \"LoRaMacConfirmQueue.h\"\r\n#include \"LoRaMacHeaderTypes.h\"\r\n#include \"LoRaMacMessageTypes.h\"\r\n#include \"LoRaMacParser.h\"\r\n#include \"LoRaMacCommands.h\"\r\n#include \"LoRaMacAdr.h\"\r\n\r\n#include \"LoRaMac.h\"\r\n\r\n#ifndef LORAMAC_VERSION\r\n/*!\r\n * LORaWAN version definition.\r\n */\r\n#define LORAMAC_VERSION                             0x01000300\r\n#endif\r\n\r\n/*!\r\n * Maximum PHY layer payload size\r\n */\r\n#define LORAMAC_PHY_MAXPAYLOAD                      255\r\n\r\n/*!\r\n * Maximum MAC commands buffer size\r\n */\r\n#define LORA_MAC_COMMAND_MAX_LENGTH                 128\r\n\r\n/*!\r\n * Maximum length of the fOpts field\r\n */\r\n#define LORA_MAC_COMMAND_MAX_FOPTS_LENGTH           15\r\n\r\n/*!\r\n * LoRaMac duty cycle for the back-off procedure during the first hour.\r\n */\r\n#define BACKOFF_DC_1_HOUR                           100\r\n\r\n/*!\r\n * LoRaMac duty cycle for the back-off procedure during the next 10 hours.\r\n */\r\n#define BACKOFF_DC_10_HOURS                         1000\r\n\r\n/*!\r\n * LoRaMac duty cycle for the back-off procedure during the next 24 hours.\r\n */\r\n#define BACKOFF_DC_24_HOURS                         10000\r\n\r\n/*!\r\n * LoRaMac internal states\r\n */\r\nenum eLoRaMacState\r\n{\r\n    LORAMAC_IDLE          = 0x00000000,\r\n    LORAMAC_STOPPED       = 0x00000001,\r\n    LORAMAC_TX_RUNNING    = 0x00000002,\r\n    LORAMAC_RX            = 0x00000004,\r\n    LORAMAC_ACK_RETRY     = 0x00000010,\r\n    LORAMAC_TX_DELAYED    = 0x00000020,\r\n    LORAMAC_TX_CONFIG     = 0x00000040,\r\n    LORAMAC_RX_ABORT      = 0x00000080,\r\n};\r\n\r\n/*\r\n * Request permission state\r\n */\r\ntypedef enum eLoRaMacRequestHandling\r\n{\r\n    LORAMAC_REQUEST_HANDLING_OFF = 0,\r\n    LORAMAC_REQUEST_HANDLING_ON = !LORAMAC_REQUEST_HANDLING_OFF\r\n}LoRaMacRequestHandling_t;\r\n\r\ntypedef struct sLoRaMacNvmCtx\r\n{\r\n    /*\r\n     * LoRaMac region.\r\n     */\r\n    LoRaMacRegion_t Region;\r\n    /*\r\n     * LoRaMac default parameters\r\n     */\r\n    LoRaMacParams_t MacParamsDefaults;\r\n    /*\r\n     * Network ID ( 3 bytes )\r\n     */\r\n    uint32_t NetID;\r\n    /*\r\n     * Mote Address\r\n     */\r\n    uint32_t DevAddr;\r\n    /*!\r\n    * Multicast channel list\r\n    */\r\n    MulticastCtx_t MulticastChannelList[LORAMAC_MAX_MC_CTX];\r\n    /*\r\n     * Actual device class\r\n     */\r\n    DeviceClass_t DeviceClass;\r\n    /*\r\n     * Indicates if the node is connected to\r\n     * a private or public network\r\n     */\r\n    bool PublicNetwork;\r\n    /*\r\n     * LoRaMac ADR control status\r\n     */\r\n    bool AdrCtrlOn;\r\n    /*\r\n     * Counts the number of missed ADR acknowledgements\r\n     */\r\n    uint32_t AdrAckCounter;\r\n\r\n    /*\r\n     * LoRaMac parameters\r\n     */\r\n    LoRaMacParams_t MacParams;\r\n    /*\r\n     * Maximum duty cycle\r\n     * \\remark Possibility to shutdown the device.\r\n     */\r\n    uint8_t MaxDCycle;\r\n    /*\r\n    * Enables/Disables duty cycle management (Test only)\r\n    */\r\n    bool DutyCycleOn;\r\n    /*\r\n     * Current channel index\r\n     */\r\n    uint8_t LastTxChannel;\r\n    /*\r\n     * Buffer containing the MAC layer commands\r\n     */\r\n    uint8_t MacCommandsBuffer[LORA_MAC_COMMAND_MAX_LENGTH];\r\n    /*\r\n     * If the server has sent a FRAME_TYPE_DATA_CONFIRMED_DOWN this variable indicates\r\n     * if the ACK bit must be set for the next transmission\r\n     */\r\n    bool SrvAckRequested;\r\n    /*\r\n     * Aggregated duty cycle management\r\n     */\r\n    uint16_t AggregatedDCycle;\r\n    /*\r\n    * Aggregated duty cycle management\r\n    */\r\n    TimerTime_t LastTxDoneTime;\r\n    TimerTime_t AggregatedTimeOff;\r\n    /*\r\n    * Stores the time at LoRaMac initialization.\r\n    *\r\n    * \\remark Used for the BACKOFF_DC computation.\r\n    */\r\n    SysTime_t InitializationTime;\r\n    /*\r\n     * Current LoRaWAN Version\r\n     */\r\n    Version_t Version;\r\n    /*\r\n     * End-Device network activation\r\n     */\r\n    ActivationType_t NetworkActivation;\r\n    /*!\r\n     * Last received Message integrity Code (MIC)\r\n     */\r\n    uint32_t LastRxMic;\r\n}LoRaMacNvmCtx_t;\r\n\r\ntypedef struct sLoRaMacCtx\r\n{\r\n    /*\r\n    * Length of packet in PktBuffer\r\n    */\r\n    uint16_t PktBufferLen;\r\n    /*\r\n    * Buffer containing the data to be sent or received.\r\n    */\r\n    uint8_t PktBuffer[LORAMAC_PHY_MAXPAYLOAD];\r\n    /*!\r\n    * Current processed transmit message\r\n    */\r\n    LoRaMacMessage_t TxMsg;\r\n    /*!\r\n    * Buffer containing the data received by the application.\r\n    */\r\n    uint8_t AppData[LORAMAC_PHY_MAXPAYLOAD];\r\n    /*\r\n    * Size of buffer containing the application data.\r\n    */\r\n    uint8_t AppDataSize;\r\n    /*\r\n    * Buffer containing the upper layer data.\r\n    */\r\n    uint8_t RxPayload[LORAMAC_PHY_MAXPAYLOAD];\r\n    SysTime_t LastTxSysTime;\r\n    /*\r\n    * LoRaMac internal state\r\n    */\r\n    uint32_t MacState;\r\n    /*\r\n    * LoRaMac upper layer event functions\r\n    */\r\n    LoRaMacPrimitives_t* MacPrimitives;\r\n    /*\r\n    * LoRaMac upper layer callback functions\r\n    */\r\n    LoRaMacCallback_t* MacCallbacks;\r\n    /*\r\n    * Radio events function pointer\r\n    */\r\n    RadioEvents_t RadioEvents;\r\n    /*\r\n    * LoRaMac duty cycle delayed Tx timer\r\n    */\r\n    TimerEvent_t TxDelayedTimer;\r\n    /*\r\n    * LoRaMac reception windows timers\r\n    */\r\n    TimerEvent_t RxWindowTimer1;\r\n    TimerEvent_t RxWindowTimer2;\r\n    /*\r\n    * LoRaMac reception windows delay\r\n    * \\remark normal frame: RxWindowXDelay = ReceiveDelayX - RADIO_WAKEUP_TIME\r\n    *         join frame  : RxWindowXDelay = JoinAcceptDelayX - RADIO_WAKEUP_TIME\r\n    */\r\n    uint32_t RxWindow1Delay;\r\n    uint32_t RxWindow2Delay;\r\n    /*\r\n    * LoRaMac Rx windows configuration\r\n    */\r\n    RxConfigParams_t RxWindow1Config;\r\n    RxConfigParams_t RxWindow2Config;\r\n    RxConfigParams_t RxWindowCConfig;\r\n    /*\r\n     * Limit of uplinks without any donwlink response before the ADRACKReq bit will be set.\r\n     */\r\n    uint16_t AdrAckLimit;\r\n    /*\r\n     * Limit of uplinks without any donwlink response after a the first frame with set ADRACKReq bit\r\n     * before the trying to regain the connectivity.\r\n     */\r\n    uint16_t AdrAckDelay;\r\n    /*\r\n    * Acknowledge timeout timer. Used for packet retransmissions.\r\n    */\r\n    TimerEvent_t AckTimeoutTimer;\r\n    /*\r\n     * Uplink messages repetitions counter\r\n     */\r\n    uint8_t ChannelsNbTransCounter;\r\n    /*\r\n     * Number of trials to get a frame acknowledged\r\n     */\r\n    uint8_t AckTimeoutRetries;\r\n    /*\r\n     * Number of trials to get a frame acknowledged\r\n     */\r\n    uint8_t AckTimeoutRetriesCounter;\r\n    /*\r\n     * Indicates if the AckTimeout timer has expired or not\r\n     */\r\n    bool AckTimeoutRetry;\r\n    /*\r\n     * If the node has sent a FRAME_TYPE_DATA_CONFIRMED_UP this variable indicates\r\n     * if the nodes needs to manage the server acknowledgement.\r\n     */\r\n    bool NodeAckRequested;\r\n    /*\r\n     * Current channel index\r\n     */\r\n    uint8_t Channel;\r\n    /*\r\n    * Last transmission time on air\r\n    */\r\n    TimerTime_t TxTimeOnAir;\r\n    /*\r\n    * Structure to hold an MCPS indication data.\r\n    */\r\n    McpsIndication_t McpsIndication;\r\n    /*\r\n    * Structure to hold MCPS confirm data.\r\n    */\r\n    McpsConfirm_t McpsConfirm;\r\n    /*\r\n    * Structure to hold MLME confirm data.\r\n    */\r\n    MlmeConfirm_t MlmeConfirm;\r\n    /*\r\n    * Structure to hold MLME indication data.\r\n    */\r\n    MlmeIndication_t MlmeIndication;\r\n    /*\r\n    * Holds the current rx window slot\r\n    */\r\n    LoRaMacRxSlot_t RxSlot;\r\n    /*\r\n    * LoRaMac tx/rx operation state\r\n    */\r\n    LoRaMacFlags_t MacFlags;\r\n    /*\r\n    * Data structure indicating if a request is allowed or not.\r\n    */\r\n    LoRaMacRequestHandling_t AllowRequests;\r\n    /*\r\n    * Non-volatile module context structure\r\n    */\r\n    LoRaMacNvmCtx_t* NvmCtx;\r\n}LoRaMacCtx_t;\r\n\r\n/*\r\n * Module context.\r\n */\r\nstatic LoRaMacCtx_t MacCtx;\r\n\r\n/*\r\n * Non-volatile module context.\r\n */\r\nstatic LoRaMacNvmCtx_t NvmMacCtx;\r\n\r\n\r\n\r\n/*\r\n * List of module contexts.\r\n */\r\nLoRaMacCtxs_t Contexts;\r\n\r\n/*!\r\n * Defines the LoRaMac radio events status\r\n */\r\ntypedef union uLoRaMacRadioEvents\r\n{\r\n    uint32_t Value;\r\n    struct sEvents\r\n    {\r\n        uint32_t RxTimeout : 1;\r\n        uint32_t RxError   : 1;\r\n        uint32_t TxTimeout : 1;\r\n        uint32_t RxDone    : 1;\r\n        uint32_t TxDone    : 1;\r\n    }Events;\r\n}LoRaMacRadioEvents_t;\r\n\r\n/*!\r\n * LoRaMac radio events status\r\n */\r\nLoRaMacRadioEvents_t LoRaMacRadioEvents = { .Value = 0 };\r\n\r\n/*!\r\n * \\brief Function to be executed on Radio Tx Done event\r\n */\r\nstatic void OnRadioTxDone( void );\r\n\r\n/*!\r\n * \\brief This function prepares the MAC to abort the execution of function\r\n *        OnRadioRxDone in case of a reception error.\r\n */\r\nstatic void PrepareRxDoneAbort( void );\r\n\r\n/*!\r\n * \\brief Function to be executed on Radio Rx Done event\r\n */\r\nstatic void OnRadioRxDone( uint8_t* payload, uint16_t size, int16_t rssi, int8_t snr );\r\n\r\n/*!\r\n * \\brief Function executed on Radio Tx Timeout event\r\n */\r\nstatic void OnRadioTxTimeout( void );\r\n\r\n/*!\r\n * \\brief Function executed on Radio Rx error event\r\n */\r\nstatic void OnRadioRxError( void );\r\n\r\n/*!\r\n * \\brief Function executed on Radio Rx Timeout event\r\n */\r\nstatic void OnRadioRxTimeout( void );\r\n\r\n/*!\r\n * \\brief Function executed on duty cycle delayed Tx  timer event\r\n */\r\nstatic void OnTxDelayedTimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on first Rx window timer event\r\n */\r\nstatic void OnRxWindow1TimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on second Rx window timer event\r\n */\r\nstatic void OnRxWindow2TimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Function executed on AckTimeout timer event\r\n */\r\nstatic void OnAckTimeoutTimerEvent( void* context );\r\n\r\n/*!\r\n * \\brief Configures the events to trigger an MLME-Indication with\r\n *        a MLME type of MLME_SCHEDULE_UPLINK.\r\n */\r\nstatic void SetMlmeScheduleUplinkIndication( void );\r\n\r\n/*!\r\n * Computes next 32 bit downlink counter value and determines the frame counter ID.\r\n *\r\n * \\param[IN]     addrID                - Address identifier\r\n * \\param[IN]     fType                 - Frame type\r\n * \\param[IN]     macMsg                - Data message object, holding the current 16 bit transmitted frame counter\r\n * \\param[IN]     lrWanVersion          - LoRaWAN version\r\n * \\param[IN]     maxFCntGap            - Maximum allowed frame counter difference (only for 1.0.X necessary)\r\n * \\param[OUT]    fCntID                - Frame counter identifier\r\n * \\param[OUT]    currentDown           - Current downlink counter value\r\n *\r\n * \\retval                              - Status of the operation\r\n */\r\nstatic LoRaMacCryptoStatus_t GetFCntDown( AddressIdentifier_t addrID, FType_t fType, LoRaMacMessageData_t* macMsg, Version_t lrWanVersion,\r\n                                          uint16_t maxFCntGap, FCntIdentifier_t* fCntID, uint32_t* currentDown );\r\n\r\n/*!\r\n * \\brief Switches the device class\r\n *\r\n * \\param [IN] deviceClass Device class to switch to\r\n */\r\nstatic LoRaMacStatus_t SwitchClass( DeviceClass_t deviceClass );\r\n\r\n/*!\r\n * \\brief Gets the maximum application payload length in the absence of the optional FOpt field.\r\n *\r\n * \\param [IN] datarate        Current datarate\r\n *\r\n * \\retval                    Max length\r\n */\r\nstatic uint8_t GetMaxAppPayloadWithoutFOptsLength( int8_t datarate );\r\n\r\n/*!\r\n * \\brief Validates if the payload fits into the frame, taking the datarate\r\n *        into account.\r\n *\r\n * \\details Refer to chapter 4.3.2 of the LoRaWAN specification, v1.0\r\n *\r\n * \\param lenN Length of the application payload. The length depends on the\r\n *             datarate and is region specific\r\n *\r\n * \\param datarate Current datarate\r\n *\r\n * \\param fOptsLen Length of the fOpts field\r\n *\r\n * \\retval [false: payload does not fit into the frame, true: payload fits into\r\n *          the frame]\r\n */\r\nstatic bool ValidatePayloadLength( uint8_t lenN, int8_t datarate, uint8_t fOptsLen );\r\n\r\n/*!\r\n * \\brief Decodes MAC commands in the fOpts field and in the payload\r\n *\r\n * \\param [IN] payload      A pointer to the payload\r\n * \\param [IN] macIndex     The index of the payload where the MAC commands start\r\n * \\param [IN] commandsSize The size of the MAC commands\r\n * \\param [IN] snr          The SNR value  of the frame\r\n * \\param [IN] rxSlot       The RX slot where the frame was received\r\n */\r\nstatic void ProcessMacCommands( uint8_t* payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer generic send frame\r\n *\r\n * \\param [IN] macHdr      MAC header field\r\n * \\param [IN] fPort       MAC payload port\r\n * \\param [IN] fBuffer     MAC data buffer to be sent\r\n * \\param [IN] fBufferSize MAC data buffer size\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t Send( LoRaMacHeader_t* macHdr, uint8_t fPort, void* fBuffer, uint16_t fBufferSize );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer send join/rejoin request\r\n *\r\n * \\param [IN] joinReqType Type of join-request or rejoin\r\n *\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t SendReJoinReq( JoinReqIdentifier_t joinReqType );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer frame buffer initialization\r\n *\r\n * \\param [IN] macHdr      MAC header field\r\n * \\param [IN] fCtrl       MAC frame control field\r\n * \\param [IN] fOpts       MAC commands buffer\r\n * \\param [IN] fPort       MAC payload port\r\n * \\param [IN] fBuffer     MAC data buffer to be sent\r\n * \\param [IN] fBufferSize MAC data buffer size\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t PrepareFrame( LoRaMacHeader_t* macHdr, LoRaMacFrameCtrl_t* fCtrl, uint8_t fPort, void* fBuffer, uint16_t fBufferSize );\r\n\r\n/*\r\n * \\brief Schedules the frame according to the duty cycle\r\n *\r\n * \\param [IN] allowDelayedTx When set to true, the a frame will be delayed,\r\n *                            the duty cycle restriction is active\r\n * \\retval Status of the operation\r\n */\r\nstatic LoRaMacStatus_t ScheduleTx( bool allowDelayedTx );\r\n\r\n/*\r\n * \\brief Secures the current processed frame ( TxMsg )\r\n * \\param[IN]     txDr      Data rate used for the transmission\r\n * \\param[IN]     txCh      Index of the channel used for the transmission\r\n * \\retval status           Status of the operation\r\n */\r\nstatic LoRaMacStatus_t SecureFrame( uint8_t txDr, uint8_t txCh );\r\n\r\n/*\r\n * \\brief Calculates the back-off time for the band of a channel.\r\n *\r\n * \\param [IN] channel     The last Tx channel index\r\n */\r\nstatic void CalculateBackOff( uint8_t channel );\r\n\r\n/*\r\n * \\brief Function to remove pending MAC commands\r\n *\r\n * \\param [IN] rxSlot     The RX slot on which the frame was received\r\n * \\param [IN] fCtrl      The frame control field of the received frame\r\n * \\param [IN] request    The request type\r\n */\r\nstatic void RemoveMacCommands( LoRaMacRxSlot_t rxSlot, LoRaMacFrameCtrl_t fCtrl, Mcps_t request );\r\n\r\n/*!\r\n * \\brief LoRaMAC layer prepared frame buffer transmission with channel specification\r\n *\r\n * \\remark PrepareFrame must be called at least once before calling this\r\n *         function.\r\n *\r\n * \\param [IN] channel     Channel to transmit on\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t SendFrameOnChannel( uint8_t channel );\r\n\r\n/*!\r\n * \\brief Sets the radio in continuous transmission mode\r\n *\r\n * \\remark Uses the radio parameters set on the previous transmission.\r\n *\r\n * \\param [IN] timeout     Time in seconds while the radio is kept in continuous wave mode\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t SetTxContinuousWave( uint16_t timeout );\r\n\r\n/*!\r\n * \\brief Sets the radio in continuous transmission mode\r\n *\r\n * \\remark Uses the radio parameters set on the previous transmission.\r\n *\r\n * \\param [IN] timeout     Time in seconds while the radio is kept in continuous wave mode\r\n * \\param [IN] frequency   RF frequency to be set.\r\n * \\param [IN] power       RF output power to be set.\r\n * \\retval status          Status of the operation.\r\n */\r\nLoRaMacStatus_t SetTxContinuousWave1( uint16_t timeout, uint32_t frequency, uint8_t power );\r\n\r\n/*!\r\n * \\brief Resets MAC specific parameters to default\r\n */\r\nstatic void ResetMacParameters( void );\r\n\r\n/*!\r\n * \\brief Initializes and opens the reception window\r\n *\r\n * \\param [IN] rxTimer  Window timer to be topped.\r\n * \\param [IN] rxConfig Window parameters to be setup\r\n */\r\nstatic void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig );\r\n\r\n/*!\r\n * \\brief Opens up a continuous RX C window. This is used for\r\n *        class c devices.\r\n */\r\nstatic void OpenContinuousRxCWindow( void );\r\n\r\n/*!\r\n * \\brief   Returns a pointer to the internal contexts structure.\r\n *\r\n * \\retval  void Points to a structure containing all contexts\r\n */\r\nLoRaMacCtxs_t* GetCtxs( void );\r\n\r\n/*!\r\n * \\brief   Restoring of internal module contexts\r\n *\r\n * \\details This function allows to restore module contexts by a given pointer.\r\n *\r\n *\r\n * \\retval  LoRaMacStatus_t Status of the operation. Possible returns are:\r\n *          returns are:\r\n *          \\ref LORAMAC_STATUS_OK,\r\n *          \\ref LORAMAC_STATUS_PARAMETER_INVALID,\r\n */\r\nLoRaMacStatus_t RestoreCtxs( LoRaMacCtxs_t* contexts );\r\n\r\n/*!\r\n * \\brief   Determines the frame type\r\n *\r\n * \\param [IN] macMsg Data message object\r\n *\r\n * \\param [OUT] fType Frame type\r\n *\r\n * \\retval  LoRaMacStatus_t Status of the operation. Possible returns are:\r\n *          returns are:\r\n *          \\ref LORAMAC_STATUS_OK,\r\n *          \\ref LORAMAC_STATUS_PARAMETER_INVALID,\r\n */\r\nLoRaMacStatus_t DetermineFrameType( LoRaMacMessageData_t* macMsg, FType_t* fType );\r\n\r\n/*!\r\n * \\brief Checks if the retransmission should be stopped in case of a unconfirmed uplink\r\n *\r\n * \\retval Returns true if it should be stopped.\r\n */\r\nstatic bool CheckRetransUnconfirmedUplink( void );\r\n\r\n/*!\r\n * \\brief Checks if the retransmission should be stopped in case of a confirmed uplink\r\n *\r\n * \\retval Returns true it should be stopped.\r\n */\r\nstatic bool CheckRetransConfirmedUplink( void );\r\n\r\n/*!\r\n * \\brief Stops the uplink retransmission\r\n *\r\n * \\retval Returns true if successful.\r\n */\r\nstatic bool StopRetransmission( void );\r\n\r\n/*!\r\n * \\brief Handles the ACK retries algorithm.\r\n *        Increments the re-tries counter up until the specified number of\r\n *        trials or the allowed maximum. Decrease the uplink datarate every 2\r\n *        trials.\r\n */\r\nstatic void AckTimeoutRetriesProcess( void );\r\n\r\n/*!\r\n * \\brief Finalizes the ACK retries algorithm.\r\n *        If no ACK is received restores the default channels\r\n */\r\nstatic void AckTimeoutRetriesFinalize( void );\r\n\r\n/*!\r\n * \\brief Calls the callback to indicate that a context changed\r\n */\r\nstatic void CallNvmCtxCallback( LoRaMacNvmCtxModule_t module );\r\n\r\n/*!\r\n * \\brief MAC NVM Context has been changed\r\n */\r\nstatic void EventMacNvmCtxChanged( void );\r\n\r\n/*!\r\n * \\brief Region NVM Context has been changed\r\n */\r\nstatic void EventRegionNvmCtxChanged( void );\r\n\r\n/*!\r\n * \\brief Crypto NVM Context has been changed\r\n */\r\nstatic void EventCryptoNvmCtxChanged( void );\r\n\r\n/*!\r\n * \\brief Secure Element NVM Context has been changed\r\n */\r\nstatic void EventSecureElementNvmCtxChanged( void );\r\n\r\n/*!\r\n * \\brief MAC commands module nvm context has been changed\r\n */\r\nstatic void EventCommandsNvmCtxChanged( void );\r\n\r\n/*!\r\n * \\brief Class B module nvm context has been changed\r\n */\r\nstatic void EventClassBNvmCtxChanged( void );\r\n\r\n/*!\r\n * \\brief Confirm Queue module nvm context has been changed\r\n */\r\nstatic void EventConfirmQueueNvmCtxChanged( void );\r\n\r\n/*!\r\n * \\brief Verifies if a request is pending currently\r\n *\r\n *\\retval 1: Request pending, 0: request not pending\r\n */\r\nstatic uint8_t IsRequestPending( void );\r\n\r\n/*!\r\n * \\brief Enabled the possibility to perform requests\r\n *\r\n * \\param [IN] requestState Request permission state\r\n */\r\nstatic void LoRaMacEnableRequests( LoRaMacRequestHandling_t requestState );\r\n\r\n/*!\r\n * \\brief This function verifies if a RX abort occurred\r\n */\r\nstatic void LoRaMacCheckForRxAbort( void );\r\n\r\n/*!\r\n * \\brief This function verifies if a beacon acquisition MLME\r\n *        request was pending\r\n *\r\n * \\retval 1: Request pending, 0: no request pending\r\n */\r\nstatic uint8_t LoRaMacCheckForBeaconAcquisition( void );\r\n\r\n/*!\r\n * \\brief This function handles join request\r\n */\r\nstatic void LoRaMacHandleMlmeRequest( void );\r\n\r\n/*!\r\n * \\brief This function handles mcps request\r\n */\r\nstatic void LoRaMacHandleMcpsRequest( void );\r\n\r\n/*!\r\n * \\brief This function handles callback events for requests\r\n */\r\nstatic void LoRaMacHandleRequestEvents( void );\r\n\r\n/*!\r\n * \\brief This function handles callback events for indications\r\n */\r\nstatic void LoRaMacHandleIndicationEvents( void );\r\n\r\n/*!\r\n * Structure used to store the radio Tx event data\r\n */\r\nstruct\r\n{\r\n    TimerTime_t CurTime;\r\n}TxDoneParams;\r\n\r\n/*!\r\n * Structure used to store the radio Rx event data\r\n */\r\nstruct\r\n{\r\n    TimerTime_t LastRxDone;\r\n    uint8_t *Payload;\r\n    uint16_t Size;\r\n    int16_t Rssi;\r\n    int8_t Snr;\r\n}RxDoneParams;\r\n\r\nstatic void OnRadioTxDone( void )\r\n{\r\n    TxDoneParams.CurTime = TimerGetCurrentTime( );\r\n    MacCtx.LastTxSysTime = SysTimeGet( );\r\n\r\n    LoRaMacRadioEvents.Events.TxDone = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioRxDone( uint8_t *payload, uint16_t size, int16_t rssi, int8_t snr )\r\n{\r\n    RxDoneParams.LastRxDone = TimerGetCurrentTime( );\r\n    RxDoneParams.Payload = payload;\r\n    RxDoneParams.Size = size;\r\n    RxDoneParams.Rssi = rssi;\r\n    RxDoneParams.Snr = snr;\r\n\r\n    LoRaMacRadioEvents.Events.RxDone = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioTxTimeout( void )\r\n{\r\n    LoRaMacRadioEvents.Events.TxTimeout = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioRxError( void )\r\n{\r\n    LoRaMacRadioEvents.Events.RxError = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void OnRadioRxTimeout( void )\r\n{\r\n    LoRaMacRadioEvents.Events.RxTimeout = 1;\r\n\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic void UpdateRxSlotIdleState( void )\r\n{\r\n    if( MacCtx.NvmCtx->DeviceClass != CLASS_C )\r\n    {\r\n        MacCtx.RxSlot = RX_SLOT_NONE;\r\n    }\r\n    else\r\n    {\r\n        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n    }\r\n}\r\n\r\nstatic void ProcessRadioTxDone( void )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n    SetBandTxDoneParams_t txDone;\r\n\r\n    if( MacCtx.NvmCtx->DeviceClass != CLASS_C )\r\n    {\r\n        Radio.Sleep( );\r\n    }\r\n    // Setup timers\r\n    TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay );\r\n    TimerStart( &MacCtx.RxWindowTimer1 );\r\n    TimerSetValue( &MacCtx.RxWindowTimer2, MacCtx.RxWindow2Delay );\r\n    TimerStart( &MacCtx.RxWindowTimer2 );\r\n\r\n    if( ( MacCtx.NvmCtx->DeviceClass == CLASS_C ) || ( MacCtx.NodeAckRequested == true ) )\r\n    {\r\n        getPhy.Attribute = PHY_ACK_TIMEOUT;\r\n        phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );\r\n        TimerStart( &MacCtx.AckTimeoutTimer );\r\n    }\r\n\r\n    // Store last Tx channel\r\n    MacCtx.NvmCtx->LastTxChannel = MacCtx.Channel;\r\n    // Update last tx done time for the current channel\r\n    txDone.Channel = MacCtx.Channel;\r\n    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        txDone.Joined  = false;\r\n    }\r\n    else\r\n    {\r\n        txDone.Joined  = true;\r\n    }\r\n    txDone.LastTxDoneTime = TxDoneParams.CurTime;\r\n    RegionSetBandTxDone( MacCtx.NvmCtx->Region, &txDone );\r\n    // Update Aggregated last tx done time\r\n    MacCtx.NvmCtx->LastTxDoneTime = TxDoneParams.CurTime;\r\n\r\n    if( MacCtx.NodeAckRequested == false )\r\n    {\r\n        MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n    }\r\n}\r\n\r\nstatic void PrepareRxDoneAbort( void )\r\n{\r\n    MacCtx.MacState |= LORAMAC_RX_ABORT;\r\n\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        OnAckTimeoutTimerEvent( NULL );\r\n    }\r\n\r\n    MacCtx.MacFlags.Bits.McpsInd = 1;\r\n    MacCtx.MacFlags.Bits.MacDone = 1;\r\n\r\n    UpdateRxSlotIdleState( );\r\n}\r\n\r\nstatic void ProcessRadioRxDone( void )\r\n{\r\n    LoRaMacHeader_t macHdr;\r\n    ApplyCFListParams_t applyCFList;\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n    LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR;\r\n\r\n    LoRaMacMessageData_t macMsgData;\r\n    LoRaMacMessageJoinAccept_t macMsgJoinAccept;\r\n    uint8_t *payload = RxDoneParams.Payload;\r\n    uint16_t size = RxDoneParams.Size;\r\n    int16_t rssi = RxDoneParams.Rssi;\r\n    int8_t snr = RxDoneParams.Snr;\r\n\r\n    uint8_t pktHeaderLen = 0;\r\n\r\n    uint32_t downLinkCounter = 0;\r\n    uint32_t address = MacCtx.NvmCtx->DevAddr;\r\n    uint8_t multicast = 0;\r\n    AddressIdentifier_t addrID = UNICAST_DEV_ADDR;\r\n    FCntIdentifier_t fCntID;\r\n\r\n    MacCtx.McpsConfirm.AckReceived = false;\r\n    MacCtx.McpsIndication.Rssi = rssi;\r\n    MacCtx.McpsIndication.Snr = snr;\r\n    MacCtx.McpsIndication.RxSlot = MacCtx.RxSlot;\r\n    MacCtx.McpsIndication.Port = 0;\r\n    MacCtx.McpsIndication.Multicast = 0;\r\n    MacCtx.McpsIndication.FramePending = 0;\r\n    MacCtx.McpsIndication.Buffer = NULL;\r\n    MacCtx.McpsIndication.BufferSize = 0;\r\n    MacCtx.McpsIndication.RxData = false;\r\n    MacCtx.McpsIndication.AckReceived = false;\r\n    MacCtx.McpsIndication.DownLinkCounter = 0;\r\n    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;\r\n    MacCtx.McpsIndication.DevAddress = 0;\r\n    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;\r\n\r\n    Radio.Sleep( );\r\n    TimerStop( &MacCtx.RxWindowTimer2 );\r\n\r\n    // This function must be called even if we are not in class b mode yet.\r\n    if( LoRaMacClassBRxBeacon( payload, size ) == true )\r\n    {\r\n        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;\r\n        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;\r\n        return;\r\n    }\r\n    // Check if we expect a ping or a multicast slot.\r\n    if( MacCtx.NvmCtx->DeviceClass == CLASS_B )\r\n    {\r\n        if( LoRaMacClassBIsPingExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBPingSlotTimerEvent( NULL );\r\n            MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;\r\n        }\r\n        else if( LoRaMacClassBIsMulticastExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBMulticastSlotTimerEvent( NULL );\r\n            MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;\r\n        }\r\n    }\r\n\r\n    macHdr.Value = payload[pktHeaderLen++];\r\n\r\n    switch( macHdr.Bits.MType )\r\n    {\r\n        case FRAME_TYPE_JOIN_ACCEPT:\r\n            // Check if the received frame size is valid\r\n            if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n            macMsgJoinAccept.Buffer = payload;\r\n            macMsgJoinAccept.BufSize = size;\r\n\r\n            // Abort in case if the device isn't joined yet and no rejoin request is ongoing.\r\n            if( MacCtx.NvmCtx->NetworkActivation != ACTIVATION_TYPE_NONE )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus )\r\n            {\r\n                // Network ID\r\n                MacCtx.NvmCtx->NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];\r\n                MacCtx.NvmCtx->NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );\r\n                MacCtx.NvmCtx->NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );\r\n\r\n                // Device Address\r\n                MacCtx.NvmCtx->DevAddr = macMsgJoinAccept.DevAddr;\r\n\r\n                // DLSettings\r\n                MacCtx.NvmCtx->MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;\r\n                MacCtx.NvmCtx->MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\r\n                MacCtx.NvmCtx->MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\r\n\r\n                // RxDelay\r\n                MacCtx.NvmCtx->MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;\r\n                if( MacCtx.NvmCtx->MacParams.ReceiveDelay1 == 0 )\r\n                {\r\n                    MacCtx.NvmCtx->MacParams.ReceiveDelay1 = 1;\r\n                }\r\n                MacCtx.NvmCtx->MacParams.ReceiveDelay1 *= 1000;\r\n                MacCtx.NvmCtx->MacParams.ReceiveDelay2 = MacCtx.NvmCtx->MacParams.ReceiveDelay1 + 1000;\r\n\r\n                MacCtx.NvmCtx->Version.Fields.Minor = 0;\r\n\r\n                // Apply CF list\r\n                applyCFList.Payload = macMsgJoinAccept.CFList;\r\n                // Size of the regular payload is 12. Plus 1 byte MHDR and 4 bytes MIC\r\n                applyCFList.Size = size - 17;\r\n\r\n                RegionApplyCFList( MacCtx.NvmCtx->Region, &applyCFList );\r\n\r\n                MacCtx.NvmCtx->NetworkActivation = ACTIVATION_TYPE_OTAA;\r\n\r\n                // MLME handling\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_JOIN );\r\n                }\r\n            }\r\n            else\r\n            {\r\n                // MLME handling\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );\r\n                }\r\n            }\r\n            break;\r\n        case FRAME_TYPE_DATA_CONFIRMED_DOWN:\r\n            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;\r\n            // Intentional fall through\r\n        case FRAME_TYPE_DATA_UNCONFIRMED_DOWN:\r\n            // Check if the received payload size is valid\r\n            getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;\r\n            getPhy.Attribute = PHY_MAX_PAYLOAD;\r\n            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||\r\n                ( size < LORAMAC_FRAME_PAYLOAD_MIN_SIZE ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n            macMsgData.Buffer = payload;\r\n            macMsgData.BufSize = size;\r\n            macMsgData.FRMPayload = MacCtx.RxPayload;\r\n            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;\r\n\r\n            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            // Store device address\r\n            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;\r\n\r\n            FType_t fType;\r\n            if( LORAMAC_STATUS_OK != DetermineFrameType( &macMsgData, &fType ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            //Check if it is a multicast message\r\n            multicast = 0;\r\n            downLinkCounter = 0;\r\n            for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n            {\r\n                if( ( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&\r\n                    ( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.IsEnabled == true ) )\r\n                {\r\n                    multicast = 1;\r\n                    addrID = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.GroupID;\r\n                    downLinkCounter = *( MacCtx.NvmCtx->MulticastChannelList[i].DownLinkCounter );\r\n                    address = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address;\r\n                    if( MacCtx.NvmCtx->DeviceClass == CLASS_C )\r\n                    {\r\n                        MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Filter messages according to multicast downlink exceptions\r\n            if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||\r\n                                        ( macMsgData.FHDR.FCtrl.Bits.Ack == true ) ||\r\n                                        ( macMsgData.FHDR.FCtrl.Bits.AdrAckReq == true ) ) )\r\n            {\r\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            // Get maximum allowed counter difference\r\n            getPhy.Attribute = PHY_MAX_FCNT_GAP;\r\n            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n\r\n            // Get downlink frame counter value\r\n            macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, MacCtx.NvmCtx->Version, phyParam.Value, &fCntID, &downLinkCounter );\r\n            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )\r\n            {\r\n                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )\r\n                {\r\n                    // Catch the case of repeated downlink frame counter\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;\r\n                    if( ( MacCtx.NvmCtx->Version.Fields.Minor == 0 ) && ( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) && ( MacCtx.NvmCtx->LastRxMic == macMsgData.MIC ) )\r\n                    {\r\n                        MacCtx.NvmCtx->SrvAckRequested = true;\r\n                    }\r\n                }\r\n                else if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT )\r\n                {\r\n                    // Lost too many frames\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS;\r\n                }\r\n                else\r\n                {\r\n                    // Other errors\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                }\r\n                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );\r\n            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )\r\n            {\r\n                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_ADDRESS )\r\n                {\r\n                    // We are not the destination of this frame.\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL;\r\n                }\r\n                else\r\n                {\r\n                    // MIC calculation fail\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;\r\n                }\r\n                PrepareRxDoneAbort( );\r\n                return;\r\n            }\r\n\r\n            // Frame is valid\r\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n            MacCtx.McpsIndication.Multicast = multicast;\r\n            MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending;\r\n            MacCtx.McpsIndication.Buffer = NULL;\r\n            MacCtx.McpsIndication.BufferSize = 0;\r\n            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;\r\n            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;\r\n\r\n            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;\r\n\r\n            // Reset ADR ACK Counter only, when RX1 or RX2 slot\r\n            if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||\r\n                ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) )\r\n            {\r\n                MacCtx.NvmCtx->AdrAckCounter = 0;\r\n            }\r\n\r\n            // MCPS Indication and ack requested handling\r\n            if( multicast == 1 )\r\n            {\r\n                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;\r\n            }\r\n            else\r\n            {\r\n                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )\r\n                {\r\n                    MacCtx.NvmCtx->SrvAckRequested = true;\r\n                    if( MacCtx.NvmCtx->Version.Fields.Minor == 0 )\r\n                    {\r\n                        MacCtx.NvmCtx->LastRxMic = macMsgData.MIC;\r\n                    }\r\n                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;\r\n                }\r\n                else\r\n                {\r\n                    MacCtx.NvmCtx->SrvAckRequested = false;\r\n                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;\r\n                }\r\n            }\r\n\r\n            RemoveMacCommands( MacCtx.McpsIndication.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );\r\n\r\n            switch( fType )\r\n            {\r\n                case FRAME_TYPE_A:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    > 0   |   X  |  > 0  |       X      |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // Decode MAC commands in FOpts field\r\n                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;\r\n                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;\r\n                    MacCtx.McpsIndication.RxData = true;\r\n                    break;\r\n                }\r\n                case FRAME_TYPE_B:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    > 0   |   X  |   -   |       -      |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // Decode MAC commands in FOpts field\r\n                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    break;\r\n                }\r\n                case FRAME_TYPE_C:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    = 0   |   -  |  = 0  | MAC commands |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // Decode MAC commands in FRMPayload\r\n                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.McpsIndication.RxSlot );\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    break;\r\n                }\r\n                case FRAME_TYPE_D:\r\n                {  /* +----------+------+-------+--------------+\r\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n                    * +----------+------+-------+--------------+\r\n                    * |    = 0   |   -  |  > 0  |       X      |\r\n                    * +----------+------+-------+--------------+\r\n                    */\r\n\r\n                    // No MAC commands just application payload\r\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\r\n                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;\r\n                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;\r\n                    MacCtx.McpsIndication.RxData = true;\r\n                    break;\r\n                }\r\n                default:\r\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n                    PrepareRxDoneAbort( );\r\n                    break;\r\n            }\r\n\r\n            // Provide always an indication, skip the callback to the user application,\r\n            // in case of a confirmed downlink retransmission.\r\n            MacCtx.MacFlags.Bits.McpsInd = 1;\r\n\r\n            break;\r\n        case FRAME_TYPE_PROPRIETARY:\r\n            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );\r\n\r\n            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;\r\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;\r\n            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;\r\n\r\n            MacCtx.MacFlags.Bits.McpsInd = 1;\r\n            break;\r\n        default:\r\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n            PrepareRxDoneAbort( );\r\n            break;\r\n    }\r\n\r\n    // Verify if we need to disable the AckTimeoutTimer\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        if( MacCtx.McpsConfirm.AckReceived == true )\r\n        {\r\n            OnAckTimeoutTimerEvent( NULL );\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if( MacCtx.NvmCtx->DeviceClass == CLASS_C )\r\n        {\r\n            OnAckTimeoutTimerEvent( NULL );\r\n        }\r\n    }\r\n    MacCtx.MacFlags.Bits.MacDone = 1;\r\n\r\n    UpdateRxSlotIdleState( );\r\n}\r\n\r\nstatic void ProcessRadioTxTimeout( void )\r\n{\r\n    if( MacCtx.NvmCtx->DeviceClass != CLASS_C )\r\n    {\r\n        Radio.Sleep( );\r\n    }\r\n    UpdateRxSlotIdleState( );\r\n\r\n    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;\r\n    LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT );\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        MacCtx.AckTimeoutRetry = true;\r\n    }\r\n    MacCtx.MacFlags.Bits.MacDone = 1;\r\n}\r\n\r\nstatic void HandleRadioRxErrorTimeout( LoRaMacEventInfoStatus_t rx1EventInfoStatus, LoRaMacEventInfoStatus_t rx2EventInfoStatus )\r\n{\r\n    bool classBRx = false;\r\n\r\n    if( MacCtx.NvmCtx->DeviceClass != CLASS_C )\r\n    {\r\n        Radio.Sleep( );\r\n    }\r\n\r\n    if( LoRaMacClassBIsBeaconExpected( ) == true )\r\n    {\r\n        LoRaMacClassBSetBeaconState( BEACON_STATE_TIMEOUT );\r\n        LoRaMacClassBBeaconTimerEvent( NULL );\r\n        classBRx = true;\r\n    }\r\n    if( MacCtx.NvmCtx->DeviceClass == CLASS_B )\r\n    {\r\n        if( LoRaMacClassBIsPingExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBPingSlotTimerEvent( NULL );\r\n            classBRx = true;\r\n        }\r\n        if( LoRaMacClassBIsMulticastExpected( ) == true )\r\n        {\r\n            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\r\n            LoRaMacClassBMulticastSlotTimerEvent( NULL );\r\n            classBRx = true;\r\n        }\r\n    }\r\n\r\n    if( classBRx == false )\r\n    {\r\n        if( MacCtx.RxSlot == RX_SLOT_WIN_1 )\r\n        {\r\n            if( MacCtx.NodeAckRequested == true )\r\n            {\r\n                MacCtx.McpsConfirm.Status = rx1EventInfoStatus;\r\n            }\r\n            LoRaMacConfirmQueueSetStatusCmn( rx1EventInfoStatus );\r\n\r\n            if( TimerGetElapsedTime( MacCtx.NvmCtx->LastTxDoneTime ) >= MacCtx.RxWindow2Delay )\r\n            {\r\n                TimerStop( &MacCtx.RxWindowTimer2 );\r\n                MacCtx.MacFlags.Bits.MacDone = 1;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if( MacCtx.NodeAckRequested == true )\r\n            {\r\n                MacCtx.McpsConfirm.Status = rx2EventInfoStatus;\r\n            }\r\n            LoRaMacConfirmQueueSetStatusCmn( rx2EventInfoStatus );\r\n\r\n            if( MacCtx.NvmCtx->DeviceClass != CLASS_C )\r\n            {\r\n                MacCtx.MacFlags.Bits.MacDone = 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    UpdateRxSlotIdleState( );\r\n}\r\n\r\nstatic void ProcessRadioRxError( void )\r\n{\r\n    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_ERROR, LORAMAC_EVENT_INFO_STATUS_RX2_ERROR );\r\n}\r\n\r\nstatic void ProcessRadioRxTimeout( void )\r\n{\r\n    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT, LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT );\r\n}\r\n\r\nstatic void LoRaMacHandleIrqEvents( void )\r\n{\r\n    LoRaMacRadioEvents_t events;\r\n\r\n    CRITICAL_SECTION_BEGIN( );\r\n    events = LoRaMacRadioEvents;\r\n    LoRaMacRadioEvents.Value = 0;\r\n    CRITICAL_SECTION_END( );\r\n\r\n    if( events.Value != 0 )\r\n    {\r\n        if( events.Events.TxDone == 1 )\r\n        {\r\n            ProcessRadioTxDone( );\r\n        }\r\n        if( events.Events.RxDone == 1 )\r\n        {\r\n            ProcessRadioRxDone( );\r\n        }\r\n        if( events.Events.TxTimeout == 1 )\r\n        {\r\n            ProcessRadioTxTimeout( );\r\n        }\r\n        if( events.Events.RxError == 1 )\r\n        {\r\n            ProcessRadioRxError( );\r\n        }\r\n        if( events.Events.RxTimeout == 1 )\r\n        {\r\n            ProcessRadioRxTimeout( );\r\n        }\r\n    }\r\n}\r\n\r\nbool LoRaMacIsBusy( void )\r\n{\r\n    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&\r\n        ( MacCtx.AllowRequests == LORAMAC_REQUEST_HANDLING_ON ) )\r\n    {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\nstatic void LoRaMacEnableRequests( LoRaMacRequestHandling_t requestState )\r\n{\r\n    MacCtx.AllowRequests = requestState;\r\n}\r\n\r\nstatic void LoRaMacHandleRequestEvents( void )\r\n{\r\n    // Handle events\r\n    LoRaMacFlags_t reqEvents = MacCtx.MacFlags;\r\n\r\n    if( MacCtx.MacState == LORAMAC_IDLE )\r\n    {\r\n        // Update event bits\r\n        if( MacCtx.MacFlags.Bits.McpsReq == 1 )\r\n        {\r\n            MacCtx.MacFlags.Bits.McpsReq = 0;\r\n        }\r\n\r\n        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\r\n        {\r\n            MacCtx.MacFlags.Bits.MlmeReq = 0;\r\n        }\r\n\r\n        // Allow requests again\r\n        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );\r\n\r\n        // Handle callbacks\r\n        if( reqEvents.Bits.McpsReq == 1 )\r\n        {\r\n            MacCtx.MacPrimitives->MacMcpsConfirm( &MacCtx.McpsConfirm );\r\n        }\r\n\r\n        if( reqEvents.Bits.MlmeReq == 1 )\r\n        {\r\n            LoRaMacConfirmQueueHandleCb( &MacCtx.MlmeConfirm );\r\n            if( LoRaMacConfirmQueueGetCnt( ) > 0 )\r\n            {\r\n                MacCtx.MacFlags.Bits.MlmeReq = 1;\r\n            }\r\n        }\r\n\r\n        // Start beaconing again\r\n        LoRaMacClassBResumeBeaconing( );\r\n\r\n        // Procedure done. Reset variables.\r\n        MacCtx.MacFlags.Bits.MacDone = 0;\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleScheduleUplinkEvent( void )\r\n{\r\n    // Handle events\r\n    if( MacCtx.MacState == LORAMAC_IDLE )\r\n    {\r\n        // Verify if sticky MAC commands are pending or not\r\n        bool isStickyMacCommandPending = false;\r\n        LoRaMacCommandsStickyCmdsPending( &isStickyMacCommandPending );\r\n        if( isStickyMacCommandPending == true )\r\n        {// Setup MLME indication\r\n            SetMlmeScheduleUplinkIndication( );\r\n        }\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleIndicationEvents( void )\r\n{\r\n    // Handle MLME indication\r\n    if( MacCtx.MacFlags.Bits.MlmeInd == 1 )\r\n    {\r\n        MacCtx.MacFlags.Bits.MlmeInd = 0;\r\n        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication );\r\n    }\r\n\r\n    if( MacCtx.MacFlags.Bits.MlmeSchedUplinkInd == 1 )\r\n    {\r\n        MlmeIndication_t schduleUplinkIndication;\r\n        schduleUplinkIndication.MlmeIndication = MLME_SCHEDULE_UPLINK;\r\n        schduleUplinkIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;\r\n\r\n        MacCtx.MacPrimitives->MacMlmeIndication( &schduleUplinkIndication );\r\n        MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 0;\r\n    }\r\n\r\n    // Handle MCPS indication\r\n    if( MacCtx.MacFlags.Bits.McpsInd == 1 )\r\n    {\r\n        MacCtx.MacFlags.Bits.McpsInd = 0;\r\n        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication );\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleMcpsRequest( void )\r\n{\r\n    // Handle MCPS uplinks\r\n    if( MacCtx.MacFlags.Bits.McpsReq == 1 )\r\n    {\r\n        bool stopRetransmission = false;\r\n        bool waitForRetransmission = false;\r\n\r\n        if( ( MacCtx.McpsConfirm.McpsRequest == MCPS_UNCONFIRMED ) ||\r\n            ( MacCtx.McpsConfirm.McpsRequest == MCPS_PROPRIETARY ) )\r\n        {\r\n            stopRetransmission = CheckRetransUnconfirmedUplink( );\r\n        }\r\n        else if( MacCtx.McpsConfirm.McpsRequest == MCPS_CONFIRMED )\r\n        {\r\n            if( MacCtx.AckTimeoutRetry == true )\r\n            {\r\n                stopRetransmission = CheckRetransConfirmedUplink( );\r\n\r\n                if( MacCtx.NvmCtx->Version.Fields.Minor == 0 )\r\n                {\r\n                    if( stopRetransmission == false )\r\n                    {\r\n                        AckTimeoutRetriesProcess( );\r\n                    }\r\n                    else\r\n                    {\r\n                        AckTimeoutRetriesFinalize( );\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                waitForRetransmission = true;\r\n            }\r\n        }\r\n\r\n        if( stopRetransmission == true )\r\n        {// Stop retransmission\r\n            TimerStop( &MacCtx.TxDelayedTimer );\r\n            MacCtx.MacState &= ~LORAMAC_TX_DELAYED;\r\n            StopRetransmission( );\r\n        }\r\n        else if( waitForRetransmission == false )\r\n        {// Arrange further retransmission\r\n            MacCtx.MacFlags.Bits.MacDone = 0;\r\n            // Reset the state of the AckTimeout\r\n            MacCtx.AckTimeoutRetry = false;\r\n            // Sends the same frame again\r\n            OnTxDelayedTimerEvent( NULL );\r\n        }\r\n    }\r\n}\r\n\r\nstatic void LoRaMacHandleMlmeRequest( void )\r\n{\r\n    // Handle join request\r\n    if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\r\n    {\r\n        if( ( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true ) )\r\n        {\r\n            if( LoRaMacConfirmQueueGetStatus( MLME_JOIN ) == LORAMAC_EVENT_INFO_STATUS_OK )\r\n            {// Node joined successfully\r\n                MacCtx.ChannelsNbTransCounter = 0;\r\n            }\r\n            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n        }\r\n        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||\r\n                 ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW_1 ) == true ) )\r\n        {\r\n            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n        }\r\n    }\r\n}\r\n\r\nstatic uint8_t LoRaMacCheckForBeaconAcquisition( void )\r\n{\r\n    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&\r\n        ( MacCtx.MacFlags.Bits.McpsReq == 0 ) )\r\n    {\r\n        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\r\n        {\r\n            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n            return 0x01;\r\n        }\r\n    }\r\n    return 0x00;\r\n}\r\n\r\nstatic void LoRaMacCheckForRxAbort( void )\r\n{\r\n    // A error occurs during receiving\r\n    if( ( MacCtx.MacState & LORAMAC_RX_ABORT ) == LORAMAC_RX_ABORT )\r\n    {\r\n        MacCtx.MacState &= ~LORAMAC_RX_ABORT;\r\n        MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n    }\r\n}\r\n\r\n\r\nvoid LoRaMacProcess( void )\r\n{\r\n    uint8_t noTx = false;\r\n\r\n    LoRaMacHandleIrqEvents( );\r\n    LoRaMacClassBProcess( );\r\n\r\n    // MAC proceeded a state and is ready to check\r\n    if( MacCtx.MacFlags.Bits.MacDone == 1 )\r\n    {\r\n        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_OFF );\r\n        LoRaMacCheckForRxAbort( );\r\n\r\n        // An error occurs during transmitting\r\n        if( IsRequestPending( ) > 0 )\r\n        {\r\n            noTx |= LoRaMacCheckForBeaconAcquisition( );\r\n        }\r\n\r\n        if( noTx == 0x00 )\r\n        {\r\n            LoRaMacHandleMlmeRequest( );\r\n            LoRaMacHandleMcpsRequest( );\r\n        }\r\n        LoRaMacHandleRequestEvents( );\r\n        LoRaMacHandleScheduleUplinkEvent( );\r\n        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );\r\n    }\r\n    LoRaMacHandleIndicationEvents( );\r\n    if( MacCtx.RxSlot == RX_SLOT_WIN_CLASS_C )\r\n    {\r\n        OpenContinuousRxCWindow( );\r\n    }\r\n}\r\n\r\nstatic void OnTxDelayedTimerEvent( void* context )\r\n{\r\n    TimerStop( &MacCtx.TxDelayedTimer );\r\n    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;\r\n\r\n    // Schedule frame, allow delayed frame transmissions\r\n    switch( ScheduleTx( true ) )\r\n    {\r\n        case LORAMAC_STATUS_OK:\r\n        case LORAMAC_STATUS_DUTYCYCLE_RESTRICTED:\r\n        {\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            // Stop retransmission attempt\r\n            MacCtx.McpsConfirm.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n            MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;\r\n            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;\r\n            LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR );\r\n            StopRetransmission( );\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nstatic void OnRxWindow1TimerEvent( void* context )\r\n{\r\n    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;\r\n    MacCtx.RxWindow1Config.DrOffset = MacCtx.NvmCtx->MacParams.Rx1DrOffset;\r\n    MacCtx.RxWindow1Config.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n    MacCtx.RxWindow1Config.RxContinuous = false;\r\n    MacCtx.RxWindow1Config.RxSlot = RX_SLOT_WIN_1;\r\n\r\n    RxWindowSetup( &MacCtx.RxWindowTimer1, &MacCtx.RxWindow1Config );\r\n}\r\n\r\nstatic void OnRxWindow2TimerEvent( void* context )\r\n{\r\n    // Check if we are processing Rx1 window.\r\n    // If yes, we don't setup the Rx2 window.\r\n    if( MacCtx.RxSlot == RX_SLOT_WIN_1 )\r\n    {\r\n        return;\r\n    }\r\n    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;\r\n    MacCtx.RxWindow2Config.Frequency = MacCtx.NvmCtx->MacParams.Rx2Channel.Frequency;\r\n    MacCtx.RxWindow2Config.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n    MacCtx.RxWindow2Config.RxContinuous = false;\r\n    MacCtx.RxWindow2Config.RxSlot = RX_SLOT_WIN_2;\r\n\r\n    RxWindowSetup( &MacCtx.RxWindowTimer2, &MacCtx.RxWindow2Config );\r\n}\r\n\r\nstatic void OnAckTimeoutTimerEvent( void* context )\r\n{\r\n    TimerStop( &MacCtx.AckTimeoutTimer );\r\n\r\n    if( MacCtx.NodeAckRequested == true )\r\n    {\r\n        MacCtx.AckTimeoutRetry = true;\r\n    }\r\n    if( MacCtx.NvmCtx->DeviceClass == CLASS_C )\r\n    {\r\n        MacCtx.MacFlags.Bits.MacDone = 1;\r\n    }\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->MacProcessNotify( );\r\n    }\r\n}\r\n\r\nstatic LoRaMacCryptoStatus_t GetFCntDown( AddressIdentifier_t addrID, FType_t fType, LoRaMacMessageData_t* macMsg, Version_t lrWanVersion,\r\n                                          uint16_t maxFCntGap, FCntIdentifier_t* fCntID, uint32_t* currentDown )\r\n{\r\n    if( ( macMsg == NULL ) || ( fCntID == NULL ) ||\r\n        ( currentDown == NULL ) )\r\n    {\r\n        return LORAMAC_CRYPTO_ERROR_NPE;\r\n    }\r\n\r\n    // Determine the frame counter identifier and choose counter from FCntList\r\n    switch( addrID )\r\n    {\r\n        case UNICAST_DEV_ADDR:\r\n            if( lrWanVersion.Fields.Minor == 1 )\r\n            {\r\n                if( ( fType == FRAME_TYPE_A ) || ( fType == FRAME_TYPE_D ) )\r\n                {\r\n                    *fCntID = A_FCNT_DOWN;\r\n                }\r\n                else\r\n                {\r\n                    *fCntID = N_FCNT_DOWN;\r\n                }\r\n            }\r\n            else\r\n            { // For LoRaWAN 1.0.X\r\n                *fCntID = FCNT_DOWN;\r\n            }\r\n            break;\r\n        case MULTICAST_0_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_0;\r\n            break;\r\n        case MULTICAST_1_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_1;\r\n            break;\r\n        case MULTICAST_2_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_2;\r\n            break;\r\n        case MULTICAST_3_ADDR:\r\n            *fCntID = MC_FCNT_DOWN_3;\r\n            break;\r\n        default:\r\n            return LORAMAC_CRYPTO_FAIL_FCNT_ID;\r\n    }\r\n\r\n    return LoRaMacCryptoGetFCntDown( *fCntID, maxFCntGap, macMsg->FHDR.FCnt, currentDown );\r\n}\r\n\r\nstatic LoRaMacStatus_t SwitchClass( DeviceClass_t deviceClass )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n\r\n    switch( MacCtx.NvmCtx->DeviceClass )\r\n    {\r\n        case CLASS_A:\r\n        {\r\n            if( deviceClass == CLASS_A )\r\n            {\r\n                // Revert back RxC parameters\r\n                MacCtx.NvmCtx->MacParams.RxCChannel = MacCtx.NvmCtx->MacParams.Rx2Channel;\r\n            }\r\n            if( deviceClass == CLASS_B )\r\n            {\r\n                status = LoRaMacClassBSwitchClass( deviceClass );\r\n                if( status == LORAMAC_STATUS_OK )\r\n                {\r\n                    MacCtx.NvmCtx->DeviceClass = deviceClass;\r\n                }\r\n            }\r\n\r\n            if( deviceClass == CLASS_C )\r\n            {\r\n                MacCtx.NvmCtx->DeviceClass = deviceClass;\r\n\r\n                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;\r\n                MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n\r\n                for( int8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n                {\r\n                    if( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.IsEnabled == true )\r\n                    // TODO: Check multicast channel device class.\r\n                    {\r\n                        MacCtx.NvmCtx->MacParams.RxCChannel.Frequency = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.RxParams.ClassC.Frequency;\r\n                        MacCtx.NvmCtx->MacParams.RxCChannel.Datarate = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.RxParams.ClassC.Datarate;\r\n\r\n                        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;\r\n                        MacCtx.RxWindowCConfig.Frequency = MacCtx.NvmCtx->MacParams.RxCChannel.Frequency;\r\n                        MacCtx.RxWindowCConfig.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n                        MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;\r\n                        MacCtx.RxWindowCConfig.RxContinuous = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Set the NodeAckRequested indicator to default\r\n                MacCtx.NodeAckRequested = false;\r\n                // Set the radio into sleep mode in case we are still in RX mode\r\n                Radio.Sleep( );\r\n\r\n                OpenContinuousRxCWindow( );\r\n\r\n                status = LORAMAC_STATUS_OK;\r\n            }\r\n            break;\r\n        }\r\n        case CLASS_B:\r\n        {\r\n            status = LoRaMacClassBSwitchClass( deviceClass );\r\n            if( status == LORAMAC_STATUS_OK )\r\n            {\r\n                MacCtx.NvmCtx->DeviceClass = deviceClass;\r\n            }\r\n            break;\r\n        }\r\n        case CLASS_C:\r\n        {\r\n            if( deviceClass == CLASS_A )\r\n            {\r\n                MacCtx.NvmCtx->DeviceClass = deviceClass;\r\n\r\n                // Set the radio into sleep to setup a defined state\r\n                Radio.Sleep( );\r\n\r\n                status = LORAMAC_STATUS_OK;\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    return status;\r\n}\r\n\r\nstatic uint8_t GetMaxAppPayloadWithoutFOptsLength( int8_t datarate )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n\r\n    // Setup PHY request\r\n    getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n    getPhy.Datarate = datarate;\r\n    getPhy.Attribute = PHY_MAX_PAYLOAD;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n\r\n    return phyParam.Value;\r\n}\r\n\r\nstatic bool ValidatePayloadLength( uint8_t lenN, int8_t datarate, uint8_t fOptsLen )\r\n{\r\n    uint16_t maxN = 0;\r\n    uint16_t payloadSize = 0;\r\n\r\n    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );\r\n\r\n    // Calculate the resulting payload size\r\n    payloadSize = ( lenN + fOptsLen );\r\n\r\n    // Validation of the application payload size\r\n    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )\r\n    {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic void SetMlmeScheduleUplinkIndication( void )\r\n{\r\n    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;\r\n}\r\n\r\nstatic void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )\r\n{\r\n    uint8_t status = 0;\r\n    bool adrBlockFound = false;\r\n    uint8_t macCmdPayload[2] = { 0x00, 0x00 };\r\n\r\n    while( macIndex < commandsSize )\r\n    {\r\n        // Make sure to parse only complete MAC commands\r\n        if( ( LoRaMacCommandsGetCmdSize( payload[macIndex] ) + macIndex ) > commandsSize )\r\n        {\r\n            return;\r\n        }\r\n\r\n        // Decode Frame MAC commands\r\n        switch( payload[macIndex++] )\r\n        {\r\n            case SRV_MAC_LINK_CHECK_ANS:\r\n            {\r\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_LINK_CHECK ) == true )\r\n                {\r\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_LINK_CHECK );\r\n                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];\r\n                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_LINK_ADR_REQ:\r\n            {\r\n                LinkAdrReqParams_t linkAdrReq;\r\n                int8_t linkAdrDatarate = DR_0;\r\n                int8_t linkAdrTxPower = TX_POWER_0;\r\n                uint8_t linkAdrNbRep = 0;\r\n                uint8_t linkAdrNbBytesParsed = 0;\r\n\r\n                if( adrBlockFound == false )\r\n                {\r\n                    adrBlockFound = true;\r\n\r\n                    // Fill parameter structure\r\n                    linkAdrReq.Payload = &payload[macIndex - 1];\r\n                    linkAdrReq.PayloadSize = commandsSize - ( macIndex - 1 );\r\n                    linkAdrReq.AdrEnabled = MacCtx.NvmCtx->AdrCtrlOn;\r\n                    linkAdrReq.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n                    linkAdrReq.CurrentDatarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n                    linkAdrReq.CurrentTxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n                    linkAdrReq.CurrentNbRep = MacCtx.NvmCtx->MacParams.ChannelsNbTrans;\r\n                    linkAdrReq.Version = MacCtx.NvmCtx->Version;\r\n\r\n                    // Process the ADR requests\r\n                    status = RegionLinkAdrReq( MacCtx.NvmCtx->Region, &linkAdrReq, &linkAdrDatarate,\r\n                                               &linkAdrTxPower, &linkAdrNbRep, &linkAdrNbBytesParsed );\r\n\r\n                    if( ( status & 0x07 ) == 0x07 )\r\n                    {\r\n                        MacCtx.NvmCtx->MacParams.ChannelsDatarate = linkAdrDatarate;\r\n                        MacCtx.NvmCtx->MacParams.ChannelsTxPower = linkAdrTxPower;\r\n                        MacCtx.NvmCtx->MacParams.ChannelsNbTrans = linkAdrNbRep;\r\n                    }\r\n\r\n                    // Add the answers to the buffer\r\n                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )\r\n                    {\r\n                        LoRaMacCommandsAddCmd( MOTE_MAC_LINK_ADR_ANS, &status, 1 );\r\n                    }\r\n                    // Update MAC index\r\n                    macIndex += linkAdrNbBytesParsed - 1;\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_DUTY_CYCLE_REQ:\r\n            {\r\n                MacCtx.NvmCtx->MaxDCycle = payload[macIndex++] & 0x0F;\r\n                MacCtx.NvmCtx->AggregatedDCycle = 1 << MacCtx.NvmCtx->MaxDCycle;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_DUTY_CYCLE_ANS, macCmdPayload, 0 );\r\n                break;\r\n            }\r\n            case SRV_MAC_RX_PARAM_SETUP_REQ:\r\n            {\r\n                RxParamSetupReqParams_t rxParamSetupReq;\r\n                status = 0x07;\r\n\r\n                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;\r\n                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;\r\n                macIndex++;\r\n\r\n                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];\r\n                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;\r\n                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;\r\n                rxParamSetupReq.Frequency *= 100;\r\n\r\n                // Perform request on region\r\n                status = RegionRxParamSetupReq( MacCtx.NvmCtx->Region, &rxParamSetupReq );\r\n\r\n                if( ( status & 0x07 ) == 0x07 )\r\n                {\r\n                    MacCtx.NvmCtx->MacParams.Rx2Channel.Datarate = rxParamSetupReq.Datarate;\r\n                    MacCtx.NvmCtx->MacParams.RxCChannel.Datarate = rxParamSetupReq.Datarate;\r\n                    MacCtx.NvmCtx->MacParams.Rx2Channel.Frequency = rxParamSetupReq.Frequency;\r\n                    MacCtx.NvmCtx->MacParams.RxCChannel.Frequency = rxParamSetupReq.Frequency;\r\n                    MacCtx.NvmCtx->MacParams.Rx1DrOffset = rxParamSetupReq.DrOffset;\r\n                }\r\n                macCmdPayload[0] = status;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_RX_PARAM_SETUP_ANS, macCmdPayload, 1 );\r\n                // Setup indication to inform the application\r\n                SetMlmeScheduleUplinkIndication( );\r\n                break;\r\n            }\r\n            case SRV_MAC_DEV_STATUS_REQ:\r\n            {\r\n                uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;\r\n                if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->GetBatteryLevel != NULL ) )\r\n                {\r\n                    batteryLevel = MacCtx.MacCallbacks->GetBatteryLevel( );\r\n                }\r\n                macCmdPayload[0] = batteryLevel;\r\n                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_DEV_STATUS_ANS, macCmdPayload, 2 );\r\n                break;\r\n            }\r\n            case SRV_MAC_NEW_CHANNEL_REQ:\r\n            {\r\n                NewChannelReqParams_t newChannelReq;\r\n                ChannelParams_t chParam;\r\n                status = 0x03;\r\n\r\n                newChannelReq.ChannelId = payload[macIndex++];\r\n                newChannelReq.NewChannel = &chParam;\r\n\r\n                chParam.Frequency = ( uint32_t ) payload[macIndex++];\r\n                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;\r\n                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;\r\n                chParam.Frequency *= 100;\r\n                chParam.Rx1Frequency = 0;\r\n                chParam.DrRange.Value = payload[macIndex++];\r\n\r\n                status = RegionNewChannelReq( MacCtx.NvmCtx->Region, &newChannelReq );\r\n\r\n                macCmdPayload[0] = status;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_NEW_CHANNEL_ANS, macCmdPayload, 1 );\r\n                break;\r\n            }\r\n            case SRV_MAC_RX_TIMING_SETUP_REQ:\r\n            {\r\n                uint8_t delay = payload[macIndex++] & 0x0F;\r\n\r\n                if( delay == 0 )\r\n                {\r\n                    delay++;\r\n                }\r\n                MacCtx.NvmCtx->MacParams.ReceiveDelay1 = delay * 1000;\r\n                MacCtx.NvmCtx->MacParams.ReceiveDelay2 = MacCtx.NvmCtx->MacParams.ReceiveDelay1 + 1000;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );\r\n                // Setup indication to inform the application\r\n                SetMlmeScheduleUplinkIndication( );\r\n                break;\r\n            }\r\n            case SRV_MAC_TX_PARAM_SETUP_REQ:\r\n            {\r\n                TxParamSetupReqParams_t txParamSetupReq;\r\n                GetPhyParams_t getPhy;\r\n                PhyParam_t phyParam;\r\n                uint8_t eirpDwellTime = payload[macIndex++];\r\n\r\n                txParamSetupReq.UplinkDwellTime = 0;\r\n                txParamSetupReq.DownlinkDwellTime = 0;\r\n\r\n                if( ( eirpDwellTime & 0x20 ) == 0x20 )\r\n                {\r\n                    txParamSetupReq.DownlinkDwellTime = 1;\r\n                }\r\n                if( ( eirpDwellTime & 0x10 ) == 0x10 )\r\n                {\r\n                    txParamSetupReq.UplinkDwellTime = 1;\r\n                }\r\n                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;\r\n\r\n                // Check the status for correctness\r\n                if( RegionTxParamSetupReq( MacCtx.NvmCtx->Region, &txParamSetupReq ) != -1 )\r\n                {\r\n                    // Accept command\r\n                    MacCtx.NvmCtx->MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;\r\n                    MacCtx.NvmCtx->MacParams.DownlinkDwellTime = txParamSetupReq.DownlinkDwellTime;\r\n                    MacCtx.NvmCtx->MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];\r\n                    // Update the datarate in case of the new configuration limits it\r\n                    getPhy.Attribute = PHY_MIN_TX_DR;\r\n                    getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n                    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n                    MacCtx.NvmCtx->MacParams.ChannelsDatarate = MAX( MacCtx.NvmCtx->MacParams.ChannelsDatarate, ( int8_t )phyParam.Value );\r\n\r\n                    // Add command response\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_DL_CHANNEL_REQ:\r\n            {\r\n                DlChannelReqParams_t dlChannelReq;\r\n                status = 0x03;\r\n\r\n                dlChannelReq.ChannelId = payload[macIndex++];\r\n                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];\r\n                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;\r\n                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;\r\n                dlChannelReq.Rx1Frequency *= 100;\r\n\r\n                status = RegionDlChannelReq( MacCtx.NvmCtx->Region, &dlChannelReq );\r\n                macCmdPayload[0] = status;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );\r\n                // Setup indication to inform the application\r\n                SetMlmeScheduleUplinkIndication( );\r\n                break;\r\n            }\r\n            case SRV_MAC_DEVICE_TIME_ANS:\r\n            {\r\n                SysTime_t gpsEpochTime = { 0 };\r\n                SysTime_t sysTime = { 0 };\r\n                SysTime_t sysTimeCurrent = { 0 };\r\n\r\n                gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];\r\n                gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;\r\n                gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;\r\n                gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;\r\n                gpsEpochTime.SubSeconds = payload[macIndex++];\r\n\r\n                // Convert the fractional second received in ms\r\n                // round( pow( 0.5, 8.0 ) * 1000 ) = 3.90625\r\n                gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );\r\n\r\n                // Copy received GPS Epoch time into system time\r\n                sysTime = gpsEpochTime;\r\n                // Add Unix to Gps epcoh offset. The system time is based on Unix time.\r\n                sysTime.Seconds += UNIX_GPS_EPOCH_OFFSET;\r\n\r\n                // Compensate time difference between Tx Done time and now\r\n                sysTimeCurrent = SysTimeGet( );\r\n                sysTime = SysTimeAdd( sysTimeCurrent, SysTimeSub( sysTime, MacCtx.LastTxSysTime ) );\r\n\r\n                // Apply the new system time.\r\n                SysTimeSet( sysTime );\r\n                LoRaMacClassBDeviceTimeAns( );\r\n                MacCtx.McpsIndication.DeviceTimeAnsReceived = true;\r\n                break;\r\n            }\r\n            case SRV_MAC_PING_SLOT_INFO_ANS:\r\n            {\r\n                // According to the specification, it is not allowed to process this answer in\r\n                // a ping or multicast slot\r\n                if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )\r\n                {\r\n                    LoRaMacClassBPingSlotInfoAns( );\r\n                }\r\n                break;\r\n            }\r\n            case SRV_MAC_PING_SLOT_CHANNEL_REQ:\r\n            {\r\n                uint8_t status = 0x03;\r\n                uint32_t frequency = 0;\r\n                uint8_t datarate;\r\n\r\n                frequency = ( uint32_t )payload[macIndex++];\r\n                frequency |= ( uint32_t )payload[macIndex++] << 8;\r\n                frequency |= ( uint32_t )payload[macIndex++] << 16;\r\n                frequency *= 100;\r\n                datarate = payload[macIndex++] & 0x0F;\r\n\r\n                status = LoRaMacClassBPingSlotChannelReq( datarate, frequency );\r\n                macCmdPayload[0] = status;\r\n                LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_FREQ_ANS, macCmdPayload, 1 );\r\n                break;\r\n            }\r\n            case SRV_MAC_BEACON_TIMING_ANS:\r\n            {\r\n                uint16_t beaconTimingDelay = 0;\r\n                uint8_t beaconTimingChannel = 0;\r\n\r\n                beaconTimingDelay = ( uint16_t )payload[macIndex++];\r\n                beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;\r\n                beaconTimingChannel = payload[macIndex++];\r\n\r\n                LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );\r\n                break;\r\n            }\r\n            case SRV_MAC_BEACON_FREQ_REQ:\r\n                {\r\n                    uint32_t frequency = 0;\r\n\r\n                    frequency = ( uint32_t )payload[macIndex++];\r\n                    frequency |= ( uint32_t )payload[macIndex++] << 8;\r\n                    frequency |= ( uint32_t )payload[macIndex++] << 16;\r\n                    frequency *= 100;\r\n\r\n                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )\r\n                    {\r\n                        macCmdPayload[0] = 1;\r\n                    }\r\n                    else\r\n                    {\r\n                        macCmdPayload[0] = 0;\r\n                    }\r\n                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );\r\n                }\r\n                break;\r\n            default:\r\n                // Unknown command. ABORT MAC commands processing\r\n                return;\r\n        }\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t Send( LoRaMacHeader_t* macHdr, uint8_t fPort, void* fBuffer, uint16_t fBufferSize )\r\n{\r\n    LoRaMacFrameCtrl_t fCtrl;\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n    int8_t datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n    int8_t txPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n    uint32_t adrAckCounter = MacCtx.NvmCtx->AdrAckCounter;\r\n    CalcNextAdrParams_t adrNext;\r\n\r\n    // Check if we are joined\r\n    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        return LORAMAC_STATUS_NO_NETWORK_JOINED;\r\n    }\r\n    if( MacCtx.NvmCtx->MaxDCycle == 0 )\r\n    {\r\n        MacCtx.NvmCtx->AggregatedTimeOff = 0;\r\n    }\r\n\r\n    fCtrl.Value = 0;\r\n    fCtrl.Bits.FOptsLen      = 0;\r\n    fCtrl.Bits.Adr           = MacCtx.NvmCtx->AdrCtrlOn;\r\n\r\n    // Check class b\r\n    if( MacCtx.NvmCtx->DeviceClass == CLASS_B )\r\n    {\r\n        fCtrl.Bits.FPending      = 1;\r\n    }\r\n    else\r\n    {\r\n        fCtrl.Bits.FPending      = 0;\r\n    }\r\n\r\n    // Check server ack\r\n    if( MacCtx.NvmCtx->SrvAckRequested == true )\r\n    {\r\n        fCtrl.Bits.Ack = 1;\r\n    }\r\n\r\n    // ADR next request\r\n    adrNext.Version = MacCtx.NvmCtx->Version;\r\n    adrNext.UpdateChanMask = true;\r\n    adrNext.AdrEnabled = fCtrl.Bits.Adr;\r\n    adrNext.AdrAckCounter = MacCtx.NvmCtx->AdrAckCounter;\r\n    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;\r\n    adrNext.AdrAckDelay = MacCtx.AdrAckDelay;\r\n    adrNext.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n    adrNext.TxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n    adrNext.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n    adrNext.Region = MacCtx.NvmCtx->Region;\r\n\r\n    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &MacCtx.NvmCtx->MacParams.ChannelsDatarate,\r\n                                               &MacCtx.NvmCtx->MacParams.ChannelsTxPower, &adrAckCounter );\r\n\r\n    // Prepare the frame\r\n    status = PrepareFrame( macHdr, &fCtrl, fPort, fBuffer, fBufferSize );\r\n\r\n    // Validate status\r\n    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )\r\n    {\r\n        // Schedule frame, do not allow delayed transmissions\r\n        status = ScheduleTx( false );\r\n    }\r\n\r\n    // Post processing\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        // Bad case - restore\r\n        // Store local variables\r\n        MacCtx.NvmCtx->MacParams.ChannelsDatarate = datarate;\r\n        MacCtx.NvmCtx->MacParams.ChannelsTxPower = txPower;\r\n    }\r\n    else\r\n    {\r\n        // Good case\r\n        MacCtx.NvmCtx->SrvAckRequested = false;\r\n        MacCtx.NvmCtx->AdrAckCounter = adrAckCounter;\r\n        // Remove all none sticky MAC commands\r\n        if( LoRaMacCommandsRemoveNoneStickyCmds( ) != LORAMAC_COMMANDS_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n        }\r\n    }\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t SendReJoinReq( JoinReqIdentifier_t joinReqType )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_OK;\r\n    LoRaMacHeader_t macHdr;\r\n    macHdr.Value = 0;\r\n    bool allowDelayedTx = true;\r\n\r\n    // Setup join/rejoin message\r\n    switch( joinReqType )\r\n    {\r\n        case JOIN_REQ:\r\n        {\r\n            SwitchClass( CLASS_A );\r\n\r\n            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_JOIN_REQUEST;\r\n            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;\r\n            MacCtx.TxMsg.Message.JoinReq.BufSize = LORAMAC_PHY_MAXPAYLOAD;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_JOIN_REQ;\r\n            MacCtx.TxMsg.Message.JoinReq.MHDR.Value = macHdr.Value;\r\n\r\n            memcpy1( MacCtx.TxMsg.Message.JoinReq.JoinEUI, SecureElementGetJoinEui( ), LORAMAC_JOIN_EUI_FIELD_SIZE );\r\n            memcpy1( MacCtx.TxMsg.Message.JoinReq.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );\r\n\r\n            allowDelayedTx = false;\r\n\r\n            break;\r\n        }\r\n        default:\r\n            status = LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n            break;\r\n    }\r\n\r\n    // Schedule frame\r\n    status = ScheduleTx( allowDelayedTx );\r\n    return status;\r\n}\r\n\r\nstatic LoRaMacStatus_t CheckForClassBCollision( void )\r\n{\r\n    if( LoRaMacClassBIsBeaconExpected( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY_BEACON_RESERVED_TIME;\r\n    }\r\n\r\n    if( MacCtx.NvmCtx->DeviceClass == CLASS_B )\r\n    {\r\n        if( LoRaMacClassBIsPingExpected( ) == true )\r\n        {\r\n            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;\r\n        }\r\n        else if( LoRaMacClassBIsMulticastExpected( ) == true )\r\n        {\r\n            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;\r\n        }\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic LoRaMacStatus_t ScheduleTx( bool allowDelayedTx )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n    TimerTime_t dutyCycleTimeOff = 0;\r\n    NextChanParams_t nextChan;\r\n    size_t macCmdsSize = 0;\r\n\r\n    // Check class b collisions\r\n    status = CheckForClassBCollision( );\r\n\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        return status;\r\n    }\r\n\r\n    // Update back-off\r\n    CalculateBackOff( MacCtx.NvmCtx->LastTxChannel );\r\n\r\n    nextChan.AggrTimeOff = MacCtx.NvmCtx->AggregatedTimeOff;\r\n    nextChan.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n    nextChan.DutyCycleEnabled = MacCtx.NvmCtx->DutyCycleOn;\r\n    nextChan.QueryNextTxDelayOnly = false;\r\n    nextChan.Joined = false;\r\n    if( MacCtx.NvmCtx->NetworkActivation != ACTIVATION_TYPE_NONE )\r\n    {\r\n        nextChan.Joined = true;\r\n    }\r\n    nextChan.LastAggrTx = MacCtx.NvmCtx->LastTxDoneTime;\r\n\r\n    // Select channel\r\n    status = RegionNextChannel( MacCtx.NvmCtx->Region, &nextChan, &MacCtx.Channel, &dutyCycleTimeOff, &MacCtx.NvmCtx->AggregatedTimeOff );\r\n\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        if( ( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED ) &&\r\n            ( allowDelayedTx == true ) )\r\n        {\r\n            // Allow delayed transmissions. We have to allow it in case\r\n            // the MAC must retransmit a frame with the frame repetitions\r\n            if( dutyCycleTimeOff != 0 )\r\n            {// Send later - prepare timer\r\n                MacCtx.MacState |= LORAMAC_TX_DELAYED;\r\n                TimerSetValue( &MacCtx.TxDelayedTimer, dutyCycleTimeOff );\r\n                TimerStart( &MacCtx.TxDelayedTimer );\r\n            }\r\n            return LORAMAC_STATUS_OK;\r\n        }\r\n        else\r\n        {// State where the MAC cannot send a frame\r\n            return status;\r\n        }\r\n    }\r\n\r\n    // Compute Rx1 windows parameters\r\n    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,\r\n                                     RegionApplyDrOffset( MacCtx.NvmCtx->Region, MacCtx.NvmCtx->MacParams.DownlinkDwellTime, MacCtx.NvmCtx->MacParams.ChannelsDatarate, MacCtx.NvmCtx->MacParams.Rx1DrOffset ),\r\n                                     MacCtx.NvmCtx->MacParams.MinRxSymbols,\r\n                                     MacCtx.NvmCtx->MacParams.SystemMaxRxError,\r\n                                     &MacCtx.RxWindow1Config );\r\n    // Compute Rx2 windows parameters\r\n    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,\r\n                                     MacCtx.NvmCtx->MacParams.Rx2Channel.Datarate,\r\n                                     MacCtx.NvmCtx->MacParams.MinRxSymbols,\r\n                                     MacCtx.NvmCtx->MacParams.SystemMaxRxError,\r\n                                     &MacCtx.RxWindow2Config );\r\n\r\n    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        MacCtx.RxWindow1Delay = MacCtx.NvmCtx->MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;\r\n        MacCtx.RxWindow2Delay = MacCtx.NvmCtx->MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;\r\n    }\r\n    else\r\n    {\r\n        if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n        }\r\n\r\n        if( ValidatePayloadLength( MacCtx.AppDataSize, MacCtx.NvmCtx->MacParams.ChannelsDatarate, macCmdsSize ) == false )\r\n        {\r\n            return LORAMAC_STATUS_LENGTH_ERROR;\r\n        }\r\n        MacCtx.RxWindow1Delay = MacCtx.NvmCtx->MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;\r\n        MacCtx.RxWindow2Delay = MacCtx.NvmCtx->MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;\r\n    }\r\n\r\n    // Secure frame\r\n    LoRaMacStatus_t retval = SecureFrame( MacCtx.NvmCtx->MacParams.ChannelsDatarate, MacCtx.Channel );\r\n    if( retval != LORAMAC_STATUS_OK )\r\n    {\r\n        return retval;\r\n    }\r\n\r\n    // Try to send now\r\n    return SendFrameOnChannel( MacCtx.Channel );\r\n}\r\n\r\nstatic LoRaMacStatus_t SecureFrame( uint8_t txDr, uint8_t txCh )\r\n{\r\n    LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR;\r\n    uint32_t fCntUp = 0;\r\n\r\n    switch( MacCtx.TxMsg.Type )\r\n    {\r\n        case LORAMAC_MSG_TYPE_JOIN_REQUEST:\r\n            macCryptoStatus = LoRaMacCryptoPrepareJoinRequest( &MacCtx.TxMsg.Message.JoinReq );\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.JoinReq.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_DATA:\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )\r\n            {\r\n                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;\r\n            }\r\n\r\n            if( ( MacCtx.ChannelsNbTransCounter >= 1 ) || ( MacCtx.AckTimeoutRetriesCounter > 1 ) )\r\n            {\r\n                fCntUp -= 1;\r\n            }\r\n\r\n            macCryptoStatus = LoRaMacCryptoSecureMessage( fCntUp, txDr, txCh, &MacCtx.TxMsg.Message.Data );\r\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\r\n            {\r\n                return LORAMAC_STATUS_CRYPTO_ERROR;\r\n            }\r\n            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;\r\n            break;\r\n        case LORAMAC_MSG_TYPE_JOIN_ACCEPT:\r\n        case LORAMAC_MSG_TYPE_UNDEF:\r\n        default:\r\n            return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic void CalculateBackOff( uint8_t channel )\r\n{\r\n    CalcBackOffParams_t calcBackOff;\r\n\r\n    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        calcBackOff.Joined = false;\r\n    }\r\n    else\r\n    {\r\n        calcBackOff.Joined = true;\r\n    }\r\n    calcBackOff.DutyCycleEnabled = MacCtx.NvmCtx->DutyCycleOn;\r\n    calcBackOff.Channel = channel;\r\n    calcBackOff.ElapsedTime = SysTimeSub( SysTimeGetMcuTime( ), MacCtx.NvmCtx->InitializationTime );\r\n    calcBackOff.TxTimeOnAir = MacCtx.TxTimeOnAir;\r\n    calcBackOff.LastTxIsJoinRequest = false;\r\n\r\n    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        calcBackOff.LastTxIsJoinRequest = true;\r\n    }\r\n\r\n    // Update regional back-off\r\n    RegionCalcBackOff( MacCtx.NvmCtx->Region, &calcBackOff );\r\n\r\n    // Update aggregated time-off. This must be an assignment and no incremental\r\n    // update as we do only calculate the time-off based on the last transmission\r\n    MacCtx.NvmCtx->AggregatedTimeOff = ( MacCtx.TxTimeOnAir * MacCtx.NvmCtx->AggregatedDCycle - MacCtx.TxTimeOnAir );\r\n}\r\n\r\nstatic void RemoveMacCommands( LoRaMacRxSlot_t rxSlot, LoRaMacFrameCtrl_t fCtrl, Mcps_t request )\r\n{\r\n    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )\r\n    {\r\n        // Remove all sticky MAC commands answers since we can assume\r\n        // that they have been received by the server.\r\n        if( request == MCPS_CONFIRMED )\r\n        {\r\n            if( fCtrl.Bits.Ack == 1 )\r\n            {  // For confirmed uplinks only if we have received an ACK.\r\n                LoRaMacCommandsRemoveStickyAnsCmds( );\r\n            }\r\n        }\r\n        else\r\n        {\r\n            LoRaMacCommandsRemoveStickyAnsCmds( );\r\n        }\r\n    }\r\n}\r\n\r\n\r\nstatic void ResetMacParameters( void )\r\n{\r\n    MacCtx.NvmCtx->NetworkActivation = ACTIVATION_TYPE_NONE;\r\n\r\n    // ADR counter\r\n    MacCtx.NvmCtx->AdrAckCounter = 0;\r\n\r\n    MacCtx.ChannelsNbTransCounter = 0;\r\n    MacCtx.AckTimeoutRetries = 1;\r\n    MacCtx.AckTimeoutRetriesCounter = 1;\r\n    MacCtx.AckTimeoutRetry = false;\r\n\r\n    MacCtx.NvmCtx->MaxDCycle = 0;\r\n    MacCtx.NvmCtx->AggregatedDCycle = 1;\r\n\r\n    MacCtx.NvmCtx->MacParams.ChannelsTxPower = MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower;\r\n    MacCtx.NvmCtx->MacParams.ChannelsDatarate = MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate;\r\n    MacCtx.NvmCtx->MacParams.Rx1DrOffset = MacCtx.NvmCtx->MacParamsDefaults.Rx1DrOffset;\r\n    MacCtx.NvmCtx->MacParams.Rx2Channel = MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel;\r\n    MacCtx.NvmCtx->MacParams.RxCChannel = MacCtx.NvmCtx->MacParamsDefaults.RxCChannel;\r\n    MacCtx.NvmCtx->MacParams.UplinkDwellTime = MacCtx.NvmCtx->MacParamsDefaults.UplinkDwellTime;\r\n    MacCtx.NvmCtx->MacParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParamsDefaults.DownlinkDwellTime;\r\n    MacCtx.NvmCtx->MacParams.MaxEirp = MacCtx.NvmCtx->MacParamsDefaults.MaxEirp;\r\n    MacCtx.NvmCtx->MacParams.AntennaGain = MacCtx.NvmCtx->MacParamsDefaults.AntennaGain;\r\n\r\n    MacCtx.NodeAckRequested = false;\r\n    MacCtx.NvmCtx->SrvAckRequested = false;\r\n\r\n    // Reset to application defaults\r\n    InitDefaultsParams_t params;\r\n    params.Type = INIT_TYPE_INIT;\r\n    params.NvmCtx = NULL;\r\n    RegionInitDefaults( MacCtx.NvmCtx->Region, &params );\r\n\r\n    // Initialize channel index.\r\n    MacCtx.Channel = 0;\r\n    MacCtx.NvmCtx->LastTxChannel = MacCtx.Channel;\r\n\r\n    // Initialize Rx2 config parameters.\r\n    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;\r\n    MacCtx.RxWindow2Config.Frequency = MacCtx.NvmCtx->MacParams.Rx2Channel.Frequency;\r\n    MacCtx.RxWindow2Config.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n    MacCtx.RxWindow2Config.RxContinuous = false;\r\n    MacCtx.RxWindow2Config.RxSlot = RX_SLOT_WIN_2;\r\n\r\n    // Initialize RxC config parameters.\r\n    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;\r\n    MacCtx.RxWindowCConfig.RxContinuous = true;\r\n    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n\r\n}\r\n\r\n/*!\r\n * \\brief Initializes and opens the reception window\r\n *\r\n * \\param [IN] rxTimer  Window timer to be topped.\r\n * \\param [IN] rxConfig Window parameters to be setup\r\n */\r\nstatic void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )\r\n{\r\n    TimerStop( rxTimer );\r\n\r\n    // Ensure the radio is Idle\r\n    Radio.Standby( );\r\n\r\n    if( RegionRxConfig( MacCtx.NvmCtx->Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )\r\n    {\r\n        Radio.Rx( MacCtx.NvmCtx->MacParams.MaxRxWindow );\r\n        MacCtx.RxSlot = rxConfig->RxSlot;\r\n    }\r\n}\r\n\r\nstatic void OpenContinuousRxCWindow( void )\r\n{\r\n    // Compute RxC windows parameters\r\n    RegionComputeRxWindowParameters( MacCtx.NvmCtx->Region,\r\n                                     MacCtx.NvmCtx->MacParams.RxCChannel.Datarate,\r\n                                     MacCtx.NvmCtx->MacParams.MinRxSymbols,\r\n                                     MacCtx.NvmCtx->MacParams.SystemMaxRxError,\r\n                                     &MacCtx.RxWindowCConfig );\r\n\r\n    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n    // Setup continuous listening\r\n    MacCtx.RxWindowCConfig.RxContinuous = true;\r\n\r\n    // At this point the Radio should be idle.\r\n    // Thus, there is no need to set the radio in standby mode.\r\n    if( RegionRxConfig( MacCtx.NvmCtx->Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )\r\n    {\r\n        Radio.Rx( 0 ); // Continuous mode\r\n        MacCtx.RxSlot = MacCtx.RxWindowCConfig.RxSlot;\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t PrepareFrame( LoRaMacHeader_t* macHdr, LoRaMacFrameCtrl_t* fCtrl, uint8_t fPort, void* fBuffer, uint16_t fBufferSize )\r\n{\r\n    MacCtx.PktBufferLen = 0;\r\n    MacCtx.NodeAckRequested = false;\r\n    uint32_t fCntUp = 0;\r\n    size_t macCmdsSize = 0;\r\n    uint8_t availableSize = 0;\r\n\r\n    if( fBuffer == NULL )\r\n    {\r\n        fBufferSize = 0;\r\n    }\r\n\r\n    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );\r\n    MacCtx.AppDataSize = fBufferSize;\r\n    MacCtx.PktBuffer[0] = macHdr->Value;\r\n\r\n    switch( macHdr->Bits.MType )\r\n    {\r\n        case FRAME_TYPE_DATA_CONFIRMED_UP:\r\n            MacCtx.NodeAckRequested = true;\r\n            // Intentional fall through\r\n        case FRAME_TYPE_DATA_UNCONFIRMED_UP:\r\n            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;\r\n            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;\r\n            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;\r\n            MacCtx.TxMsg.Message.Data.MHDR.Value = macHdr->Value;\r\n            MacCtx.TxMsg.Message.Data.FPort = fPort;\r\n            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = MacCtx.NvmCtx->DevAddr;\r\n            MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;\r\n            MacCtx.TxMsg.Message.Data.FRMPayloadSize = MacCtx.AppDataSize;\r\n            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;\r\n\r\n            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )\r\n            {\r\n                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;\r\n            }\r\n            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;\r\n\r\n            // Reset confirm parameters\r\n            MacCtx.McpsConfirm.NbRetries = 0;\r\n            MacCtx.McpsConfirm.AckReceived = false;\r\n            MacCtx.McpsConfirm.UpLinkCounter = fCntUp;\r\n\r\n            // Handle the MAC commands if there are any available\r\n            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n\r\n            if( macCmdsSize > 0 )\r\n            {\r\n                availableSize = GetMaxAppPayloadWithoutFOptsLength( MacCtx.NvmCtx->MacParams.ChannelsDatarate );\r\n\r\n                // There is application payload available and the MAC commands fit into FOpts field.\r\n                if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )\r\n                {\r\n                    if( LoRaMacCommandsSerializeCmds( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH, &macCmdsSize, MacCtx.TxMsg.Message.Data.FHDR.FOpts ) != LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                    }\r\n                    fCtrl->Bits.FOptsLen = macCmdsSize;\r\n                    // Update FCtrl field with new value of FOptionsLength\r\n                    MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;\r\n                }\r\n                // There is application payload available but the MAC commands does NOT fit into FOpts field.\r\n                else if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize > LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )\r\n                {\r\n\r\n                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.NvmCtx->MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                    }\r\n                    return LORAMAC_STATUS_SKIPPED_APP_DATA;\r\n                }\r\n                // No application payload available therefore add all mac commands to the FRMPayload.\r\n                else\r\n                {\r\n                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.NvmCtx->MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )\r\n                    {\r\n                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                    }\r\n                    // Force FPort to be zero\r\n                    MacCtx.TxMsg.Message.Data.FPort = 0;\r\n\r\n                    MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.NvmCtx->MacCommandsBuffer;\r\n                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;\r\n                }\r\n            }\r\n\r\n            break;\r\n        case FRAME_TYPE_PROPRIETARY:\r\n            if( ( fBuffer != NULL ) && ( MacCtx.AppDataSize > 0 ) )\r\n            {\r\n                memcpy1( MacCtx.PktBuffer + LORAMAC_MHDR_FIELD_SIZE, ( uint8_t* ) fBuffer, MacCtx.AppDataSize );\r\n                MacCtx.PktBufferLen = LORAMAC_MHDR_FIELD_SIZE + MacCtx.AppDataSize;\r\n            }\r\n            break;\r\n        default:\r\n            return LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n    }\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t SendFrameOnChannel( uint8_t channel )\r\n{\r\n    TxConfigParams_t txConfig;\r\n    int8_t txPower = 0;\r\n\r\n    txConfig.Channel = channel;\r\n    txConfig.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n    txConfig.TxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n    txConfig.MaxEirp = MacCtx.NvmCtx->MacParams.MaxEirp;\r\n    txConfig.AntennaGain = MacCtx.NvmCtx->MacParams.AntennaGain;\r\n    txConfig.PktLen = MacCtx.PktBufferLen;\r\n\r\n    RegionTxConfig( MacCtx.NvmCtx->Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );\r\n\r\n    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n    MacCtx.McpsConfirm.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n    MacCtx.McpsConfirm.TxPower = txPower;\r\n    MacCtx.McpsConfirm.Channel = channel;\r\n\r\n    // Store the time on air\r\n    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;\r\n    MacCtx.MlmeConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;\r\n\r\n    if( LoRaMacClassBIsBeaconModeActive( ) == true )\r\n    {\r\n        // Currently, the Time-On-Air can only be computed when the radio is configured with\r\n        // the TX configuration\r\n        TimerTime_t collisionTime = LoRaMacClassBIsUplinkCollision( MacCtx.TxTimeOnAir );\r\n\r\n        if( collisionTime > 0 )\r\n        {\r\n            return LORAMAC_STATUS_BUSY_UPLINK_COLLISION;\r\n        }\r\n    }\r\n\r\n    if( MacCtx.NvmCtx->DeviceClass == CLASS_B )\r\n    {\r\n        // Stop slots for class b\r\n        LoRaMacClassBStopRxSlots( );\r\n    }\r\n\r\n    LoRaMacClassBHaltBeaconing( );\r\n\r\n    MacCtx.MacState |= LORAMAC_TX_RUNNING;\r\n    if( MacCtx.NodeAckRequested == false )\r\n    {\r\n        MacCtx.ChannelsNbTransCounter++;\r\n    }\r\n\r\n    // Send now\r\n    Radio.Send( MacCtx.PktBuffer, MacCtx.PktBufferLen );\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t SetTxContinuousWave( uint16_t timeout )\r\n{\r\n    ContinuousWaveParams_t continuousWave;\r\n\r\n    continuousWave.Channel = MacCtx.Channel;\r\n    continuousWave.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n    continuousWave.TxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n    continuousWave.MaxEirp = MacCtx.NvmCtx->MacParams.MaxEirp;\r\n    continuousWave.AntennaGain = MacCtx.NvmCtx->MacParams.AntennaGain;\r\n    continuousWave.Timeout = timeout;\r\n\r\n    RegionSetContinuousWave( MacCtx.NvmCtx->Region, &continuousWave );\r\n\r\n    MacCtx.MacState |= LORAMAC_TX_RUNNING;\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t SetTxContinuousWave1( uint16_t timeout, uint32_t frequency, uint8_t power )\r\n{\r\n    Radio.SetTxContinuousWave( frequency, power, timeout );\r\n\r\n    MacCtx.MacState |= LORAMAC_TX_RUNNING;\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacCtxs_t* GetCtxs( void )\r\n{\r\n    Contexts.MacNvmCtx = &NvmMacCtx;\r\n    Contexts.MacNvmCtxSize = sizeof( NvmMacCtx );\r\n    Contexts.CryptoNvmCtx = LoRaMacCryptoGetNvmCtx( &Contexts.CryptoNvmCtxSize );\r\n    GetNvmCtxParams_t params ={ 0 };\r\n    Contexts.RegionNvmCtx = RegionGetNvmCtx( MacCtx.NvmCtx->Region, &params );\r\n    Contexts.RegionNvmCtxSize = params.nvmCtxSize;\r\n    Contexts.SecureElementNvmCtx = SecureElementGetNvmCtx( &Contexts.SecureElementNvmCtxSize );\r\n    Contexts.CommandsNvmCtx = LoRaMacCommandsGetNvmCtx( &Contexts.CommandsNvmCtxSize );\r\n    Contexts.ClassBNvmCtx = LoRaMacClassBGetNvmCtx( &Contexts.ClassBNvmCtxSize );\r\n    Contexts.ConfirmQueueNvmCtx = LoRaMacConfirmQueueGetNvmCtx( &Contexts.ConfirmQueueNvmCtxSize );\r\n    return &Contexts;\r\n}\r\n\r\nLoRaMacStatus_t RestoreCtxs( LoRaMacCtxs_t* contexts )\r\n{\r\n    if( contexts == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    if( MacCtx.MacState != LORAMAC_STOPPED )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( contexts->MacNvmCtx != NULL )\r\n    {\r\n        memcpy1( ( uint8_t* ) &NvmMacCtx, ( uint8_t* ) contexts->MacNvmCtx, contexts->MacNvmCtxSize );\r\n    }\r\n\r\n    InitDefaultsParams_t params;\r\n    params.Type = INIT_TYPE_RESTORE_CTX;\r\n    params.NvmCtx = contexts->RegionNvmCtx;\r\n    RegionInitDefaults( MacCtx.NvmCtx->Region, &params );\r\n\r\n    // Initialize RxC config parameters.\r\n    MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;\r\n    MacCtx.RxWindowCConfig.Frequency = MacCtx.NvmCtx->MacParams.RxCChannel.Frequency;\r\n    MacCtx.RxWindowCConfig.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n    MacCtx.RxWindowCConfig.RxContinuous = true;\r\n    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;\r\n\r\n    if( SecureElementRestoreNvmCtx( contexts->SecureElementNvmCtx ) != SECURE_ELEMENT_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    if( LoRaMacCryptoRestoreNvmCtx( contexts->CryptoNvmCtx ) != LORAMAC_CRYPTO_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    if( LoRaMacCommandsRestoreNvmCtx( contexts->CommandsNvmCtx ) != LORAMAC_COMMANDS_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n    }\r\n\r\n    if( LoRaMacClassBRestoreNvmCtx( contexts->ClassBNvmCtx ) != true )\r\n    {\r\n        return LORAMAC_STATUS_CLASS_B_ERROR;\r\n    }\r\n\r\n    if( LoRaMacConfirmQueueRestoreNvmCtx( contexts->ConfirmQueueNvmCtx ) != true )\r\n    {\r\n        return LORAMAC_STATUS_CONFIRM_QUEUE_ERROR;\r\n    }\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t DetermineFrameType( LoRaMacMessageData_t* macMsg, FType_t* fType )\r\n{\r\n    if( ( macMsg == NULL ) || ( fType == NULL ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    /* The LoRaWAN specification allows several possible configurations how data up/down frames are built up.\r\n     * In sake of clearness the following naming is applied. Please keep in mind that this is\r\n     * implementation specific since there is no definition in the LoRaWAN specification included.\r\n     *\r\n     * X -> Field is available\r\n     * - -> Field is not available\r\n     *\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * | FType |  | FOptsLen | Fopt | FPort |  FRMPayload  |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   A   |  |    > 0   |   X  |  > 0  |       X      |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   B   |  |   >= 0   |  X/- |   -   |       -      |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   C   |  |    = 0   |   -  |  = 0  | MAC commands |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     * |   D   |  |    = 0   |   -  |  > 0  |       X      |\r\n     * +-------+  +----------+------+-------+--------------+\r\n     */\r\n\r\n    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )\r\n    {\r\n        *fType = FRAME_TYPE_A;\r\n    }\r\n    else if( macMsg->FRMPayloadSize == 0 )\r\n    {\r\n        *fType = FRAME_TYPE_B;\r\n    }\r\n    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort == 0 ) )\r\n    {\r\n        *fType = FRAME_TYPE_C;\r\n    }\r\n    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort > 0 ) )\r\n    {\r\n        *fType = FRAME_TYPE_D;\r\n    }\r\n    else\r\n    {\r\n        // Should never happen.\r\n        return LORAMAC_STATUS_ERROR;\r\n    }\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nstatic bool CheckRetransUnconfirmedUplink( void )\r\n{\r\n    // Unconfirmed uplink, when all retransmissions are done.\r\n    if( MacCtx.ChannelsNbTransCounter >=\r\n        MacCtx.NvmCtx->MacParams.ChannelsNbTrans )\r\n    {\r\n        return true;\r\n    }\r\n    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )\r\n    {\r\n        // For Class A stop in each case\r\n        if( MacCtx.NvmCtx->DeviceClass == CLASS_A )\r\n        {\r\n            return true;\r\n        }\r\n        else\r\n        {// For Class B & C stop only if the frame was received in RX1 window\r\n            if( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 )\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic bool CheckRetransConfirmedUplink( void )\r\n{\r\n    // Confirmed uplink, when all retransmissions ( tries to get a ack ) are done.\r\n    if( MacCtx.AckTimeoutRetriesCounter >=\r\n        MacCtx.AckTimeoutRetries )\r\n    {\r\n        return true;\r\n    }\r\n    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )\r\n    {\r\n        if( MacCtx.McpsConfirm.AckReceived == true )\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nstatic bool StopRetransmission( void )\r\n{\r\n    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||\r\n        ( ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_1 ) &&\r\n          ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_2 ) ) )\r\n    {   // Maximum repetitions without downlink. Increase ADR Ack counter.\r\n        // Only process the case when the MAC did not receive a downlink.\r\n        if( MacCtx.NvmCtx->AdrCtrlOn == true )\r\n        {\r\n            MacCtx.NvmCtx->AdrAckCounter++;\r\n        }\r\n    }\r\n\r\n    MacCtx.ChannelsNbTransCounter = 0;\r\n    MacCtx.NodeAckRequested = false;\r\n    MacCtx.AckTimeoutRetry = false;\r\n    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;\r\n\r\n    return true;\r\n}\r\n\r\nstatic void AckTimeoutRetriesProcess( void )\r\n{\r\n    if( MacCtx.AckTimeoutRetriesCounter < MacCtx.AckTimeoutRetries )\r\n    {\r\n        MacCtx.AckTimeoutRetriesCounter++;\r\n        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )\r\n        {\r\n            GetPhyParams_t getPhy;\r\n            PhyParam_t phyParam;\r\n\r\n            getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;\r\n            getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n            getPhy.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n            MacCtx.NvmCtx->MacParams.ChannelsDatarate = phyParam.Value;\r\n        }\r\n    }\r\n}\r\n\r\nstatic void AckTimeoutRetriesFinalize( void )\r\n{\r\n    if( MacCtx.McpsConfirm.AckReceived == false )\r\n    {\r\n        InitDefaultsParams_t params;\r\n        params.Type = INIT_TYPE_RESTORE_DEFAULT_CHANNELS;\r\n        params.NvmCtx = Contexts.RegionNvmCtx;\r\n        RegionInitDefaults( MacCtx.NvmCtx->Region, &params );\r\n\r\n        MacCtx.NodeAckRequested = false;\r\n        MacCtx.McpsConfirm.AckReceived = false;\r\n    }\r\n    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;\r\n}\r\n\r\nstatic void CallNvmCtxCallback( LoRaMacNvmCtxModule_t module )\r\n{\r\n    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->NvmContextChange != NULL ) )\r\n    {\r\n        MacCtx.MacCallbacks->NvmContextChange( module );\r\n    }\r\n}\r\n\r\nstatic void EventMacNvmCtxChanged( void )\r\n{\r\n    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_MAC );\r\n}\r\n\r\nstatic void EventRegionNvmCtxChanged( void )\r\n{\r\n    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_REGION );\r\n}\r\n\r\nstatic void EventCryptoNvmCtxChanged( void )\r\n{\r\n    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_CRYPTO );\r\n}\r\n\r\nstatic void EventSecureElementNvmCtxChanged( void )\r\n{\r\n    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_SECURE_ELEMENT );\r\n}\r\n\r\nstatic void EventCommandsNvmCtxChanged( void )\r\n{\r\n    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_COMMANDS );\r\n}\r\n\r\nstatic void EventClassBNvmCtxChanged( void )\r\n{\r\n    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_CLASS_B );\r\n}\r\n\r\nstatic void EventConfirmQueueNvmCtxChanged( void )\r\n{\r\n    CallNvmCtxCallback( LORAMAC_NVMCTXMODULE_CONFIRM_QUEUE );\r\n}\r\n\r\nstatic uint8_t IsRequestPending( void )\r\n{\r\n    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||\r\n        ( MacCtx.MacFlags.Bits.McpsReq == 1 ) )\r\n    {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nLoRaMacStatus_t LoRaMacInitialization( LoRaMacPrimitives_t* primitives, LoRaMacCallback_t* callbacks, LoRaMacRegion_t region )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n    LoRaMacClassBCallback_t classBCallbacks;\r\n    LoRaMacClassBParams_t classBParams;\r\n\r\n    if( ( primitives == NULL ) ||\r\n        ( callbacks == NULL ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    if( ( primitives->MacMcpsConfirm == NULL ) ||\r\n        ( primitives->MacMcpsIndication == NULL ) ||\r\n        ( primitives->MacMlmeConfirm == NULL ) ||\r\n        ( primitives->MacMlmeIndication == NULL ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    // Verify if the region is supported\r\n    if( RegionIsActive( region ) == false )\r\n    {\r\n        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;\r\n    }\r\n\r\n    // Confirm queue reset\r\n    LoRaMacConfirmQueueInit( primitives, EventConfirmQueueNvmCtxChanged );\r\n\r\n    // Initialize the module context with zeros\r\n    memset1( ( uint8_t* ) &NvmMacCtx, 0x00, sizeof( LoRaMacNvmCtx_t ) );\r\n    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );\r\n    MacCtx.NvmCtx = &NvmMacCtx;\r\n\r\n    // Set non zero variables to its default value\r\n    MacCtx.AckTimeoutRetriesCounter = 1;\r\n    MacCtx.AckTimeoutRetries = 1;\r\n    MacCtx.NvmCtx->Region = region;\r\n    MacCtx.NvmCtx->DeviceClass = CLASS_A;\r\n\r\n    // Setup version\r\n    MacCtx.NvmCtx->Version.Value = LORAMAC_VERSION;\r\n\r\n    // Reset to defaults\r\n    getPhy.Attribute = PHY_DUTY_CYCLE;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->DutyCycleOn = ( bool ) phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_TX_POWER;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_TX_DR;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_MAX_RX_WINDOW;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.MaxRxWindow = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_RECEIVE_DELAY1;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.ReceiveDelay1 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_RECEIVE_DELAY2;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.ReceiveDelay2 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_DR1_OFFSET;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.Rx1DrOffset = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;\r\n    MacCtx.NvmCtx->MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_RX2_DR;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;\r\n    MacCtx.NvmCtx->MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.UplinkDwellTime = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.DownlinkDwellTime = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_MAX_EIRP;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.MaxEirp = phyParam.fValue;\r\n\r\n    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.NvmCtx->MacParamsDefaults.AntennaGain = phyParam.fValue;\r\n\r\n    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.AdrAckLimit = phyParam.Value;\r\n\r\n    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    MacCtx.AdrAckDelay = phyParam.Value;\r\n\r\n    // Init parameters which are not set in function ResetMacParameters\r\n    MacCtx.NvmCtx->MacParamsDefaults.ChannelsNbTrans = 1;\r\n    MacCtx.NvmCtx->MacParamsDefaults.SystemMaxRxError = 10;\r\n    MacCtx.NvmCtx->MacParamsDefaults.MinRxSymbols = 6;\r\n\r\n    MacCtx.NvmCtx->MacParams.SystemMaxRxError = MacCtx.NvmCtx->MacParamsDefaults.SystemMaxRxError;\r\n    MacCtx.NvmCtx->MacParams.MinRxSymbols = MacCtx.NvmCtx->MacParamsDefaults.MinRxSymbols;\r\n    MacCtx.NvmCtx->MacParams.MaxRxWindow = MacCtx.NvmCtx->MacParamsDefaults.MaxRxWindow;\r\n    MacCtx.NvmCtx->MacParams.ReceiveDelay1 = MacCtx.NvmCtx->MacParamsDefaults.ReceiveDelay1;\r\n    MacCtx.NvmCtx->MacParams.ReceiveDelay2 = MacCtx.NvmCtx->MacParamsDefaults.ReceiveDelay2;\r\n    MacCtx.NvmCtx->MacParams.JoinAcceptDelay1 = MacCtx.NvmCtx->MacParamsDefaults.JoinAcceptDelay1;\r\n    MacCtx.NvmCtx->MacParams.JoinAcceptDelay2 = MacCtx.NvmCtx->MacParamsDefaults.JoinAcceptDelay2;\r\n    MacCtx.NvmCtx->MacParams.ChannelsNbTrans = MacCtx.NvmCtx->MacParamsDefaults.ChannelsNbTrans;\r\n\r\n    InitDefaultsParams_t params;\r\n    params.Type = INIT_TYPE_BANDS;\r\n    params.NvmCtx = NULL;\r\n    RegionInitDefaults( MacCtx.NvmCtx->Region, &params );\r\n\r\n    ResetMacParameters( );\r\n\r\n    MacCtx.NvmCtx->PublicNetwork = true;\r\n\r\n    MacCtx.MacPrimitives = primitives;\r\n    MacCtx.MacCallbacks = callbacks;\r\n    MacCtx.MacFlags.Value = 0;\r\n    MacCtx.MacState = LORAMAC_STOPPED;\r\n\r\n    // Reset duty cycle times\r\n    MacCtx.NvmCtx->LastTxDoneTime = 0;\r\n    MacCtx.NvmCtx->AggregatedTimeOff = 0;\r\n\r\n    // Initialize timers\r\n    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );\r\n    TimerInit( &MacCtx.RxWindowTimer1, OnRxWindow1TimerEvent );\r\n    TimerInit( &MacCtx.RxWindowTimer2, OnRxWindow2TimerEvent );\r\n    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );\r\n\r\n    // Store the current initialization time\r\n    MacCtx.NvmCtx->InitializationTime = SysTimeGetMcuTime( );\r\n\r\n    // Initialize Radio driver\r\n    MacCtx.RadioEvents.TxDone = OnRadioTxDone;\r\n    MacCtx.RadioEvents.RxDone = OnRadioRxDone;\r\n    MacCtx.RadioEvents.RxError = OnRadioRxError;\r\n    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;\r\n    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;\r\n    Radio.Init( &MacCtx.RadioEvents );\r\n\r\n    // Initialize the Secure Element driver\r\n    if( SecureElementInit( EventSecureElementNvmCtxChanged ) != SECURE_ELEMENT_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    // Initialize Crypto module\r\n    if( LoRaMacCryptoInit( EventCryptoNvmCtxChanged ) != LORAMAC_CRYPTO_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    // Initialize MAC commands module\r\n    if( LoRaMacCommandsInit( EventCommandsNvmCtxChanged ) != LORAMAC_COMMANDS_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n    }\r\n\r\n    // Set multicast downlink counter reference\r\n    if( LoRaMacCryptoSetMulticastReference( MacCtx.NvmCtx->MulticastChannelList ) != LORAMAC_CRYPTO_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_CRYPTO_ERROR;\r\n    }\r\n\r\n    // Random seed initialization\r\n    srand1( Radio.Random( ) );\r\n\r\n    Radio.SetPublicNetwork( MacCtx.NvmCtx->PublicNetwork );\r\n    Radio.Sleep( );\r\n\r\n    // Initialize class b\r\n    // Apply callback\r\n    classBCallbacks.GetTemperatureLevel = NULL;\r\n    classBCallbacks.MacProcessNotify = NULL;\r\n    if( callbacks != NULL )\r\n    {\r\n        classBCallbacks.GetTemperatureLevel = callbacks->GetTemperatureLevel;\r\n        classBCallbacks.MacProcessNotify = callbacks->MacProcessNotify;\r\n    }\r\n\r\n    // Must all be static. Don't use local references.\r\n    classBParams.MlmeIndication = &MacCtx.MlmeIndication;\r\n    classBParams.McpsIndication = &MacCtx.McpsIndication;\r\n    classBParams.MlmeConfirm = &MacCtx.MlmeConfirm;\r\n    classBParams.LoRaMacFlags = &MacCtx.MacFlags;\r\n    classBParams.LoRaMacDevAddr = &MacCtx.NvmCtx->DevAddr;\r\n    classBParams.LoRaMacRegion = &MacCtx.NvmCtx->Region;\r\n    classBParams.LoRaMacParams = &MacCtx.NvmCtx->MacParams;\r\n    classBParams.MulticastChannels = &MacCtx.NvmCtx->MulticastChannelList[0];\r\n\r\n    LoRaMacClassBInit( &classBParams, &classBCallbacks, &EventClassBNvmCtxChanged );\r\n\r\n    LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );\r\n\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacStart( void )\r\n{\r\n    MacCtx.MacState = LORAMAC_IDLE;\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacStop( void )\r\n{\r\n    if( LoRaMacIsBusy( ) == false )\r\n    {\r\n        MacCtx.MacState = LORAMAC_STOPPED;\r\n        return LORAMAC_STATUS_OK;\r\n    }\r\n    else if(  MacCtx.MacState == LORAMAC_STOPPED )\r\n    {\r\n        return LORAMAC_STATUS_OK;\r\n    }\r\n    return LORAMAC_STATUS_BUSY;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacQueryNextTxDelay( int8_t datarate, TimerTime_t* time )\r\n{\r\n    NextChanParams_t nextChan;\r\n    uint8_t channel = 0;\r\n\r\n    CalcNextAdrParams_t adrNext;\r\n    uint32_t adrAckCounter = MacCtx.NvmCtx->AdrAckCounter;\r\n    int8_t txPower = MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower;\r\n\r\n    if( time == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    if( MacCtx.NvmCtx->LastTxDoneTime == 0 )\r\n    {\r\n        *time = 0;\r\n        return LORAMAC_STATUS_OK;\r\n    }\r\n\r\n    // Update back-off\r\n    CalculateBackOff( MacCtx.NvmCtx->LastTxChannel );\r\n\r\n    nextChan.AggrTimeOff = MacCtx.NvmCtx->AggregatedTimeOff;\r\n    nextChan.Datarate = datarate;\r\n    nextChan.DutyCycleEnabled = MacCtx.NvmCtx->DutyCycleOn;\r\n    nextChan.QueryNextTxDelayOnly = true;\r\n    nextChan.Joined = true;\r\n    nextChan.LastAggrTx = MacCtx.NvmCtx->LastTxDoneTime;\r\n\r\n    if( MacCtx.NvmCtx->NetworkActivation == ACTIVATION_TYPE_NONE )\r\n    {\r\n        nextChan.Joined = false;\r\n    }\r\n    if( MacCtx.NvmCtx->AdrCtrlOn == true )\r\n    {\r\n        // Setup ADR request\r\n        adrNext.UpdateChanMask = false;\r\n        adrNext.AdrEnabled = MacCtx.NvmCtx->AdrCtrlOn;\r\n        adrNext.AdrAckCounter = MacCtx.NvmCtx->AdrAckCounter;\r\n        adrNext.AdrAckLimit = MacCtx.AdrAckLimit;\r\n        adrNext.AdrAckDelay = MacCtx.AdrAckDelay;\r\n        adrNext.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n        adrNext.TxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n        adrNext.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n        adrNext.Region = MacCtx.NvmCtx->Region;\r\n\r\n        // We call the function for information purposes only. We don't want to\r\n        // apply the datarate, the tx power and the ADR ack counter.\r\n        LoRaMacAdrCalcNext( &adrNext, &nextChan.Datarate, &txPower, &adrAckCounter );\r\n    }\r\n\r\n    // Select channel\r\n    return RegionNextChannel( MacCtx.NvmCtx->Region, &nextChan, &channel, time, &MacCtx.NvmCtx->AggregatedTimeOff );\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacQueryTxPossible( uint8_t size, LoRaMacTxInfo_t* txInfo )\r\n{\r\n    CalcNextAdrParams_t adrNext;\r\n    uint32_t adrAckCounter = MacCtx.NvmCtx->AdrAckCounter;\r\n    int8_t datarate = MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate;\r\n    int8_t txPower = MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower;\r\n    size_t macCmdsSize = 0;\r\n\r\n    if( txInfo == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    // Setup ADR request\r\n    adrNext.Version = MacCtx.NvmCtx->Version;\r\n    adrNext.UpdateChanMask = false;\r\n    adrNext.AdrEnabled = MacCtx.NvmCtx->AdrCtrlOn;\r\n    adrNext.AdrAckCounter = MacCtx.NvmCtx->AdrAckCounter;\r\n    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;\r\n    adrNext.AdrAckDelay = MacCtx.AdrAckDelay;\r\n    adrNext.Datarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n    adrNext.TxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n    adrNext.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n    adrNext.Region = MacCtx.NvmCtx->Region;\r\n\r\n    // We call the function for information purposes only. We don't want to\r\n    // apply the datarate, the tx power and the ADR ack counter.\r\n    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &adrAckCounter );\r\n\r\n    txInfo->CurrentPossiblePayloadSize = GetMaxAppPayloadWithoutFOptsLength( datarate );\r\n\r\n    if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )\r\n    {\r\n        return LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n    }\r\n\r\n    // Verify if the MAC commands fit into the FOpts and into the maximum payload.\r\n    if( ( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH >= macCmdsSize ) && ( txInfo->CurrentPossiblePayloadSize >= macCmdsSize ) )\r\n    {\r\n        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;\r\n\r\n        // Verify if the application data together with MAC command fit into the maximum payload.\r\n        if( txInfo->CurrentPossiblePayloadSize >= ( macCmdsSize + size ) )\r\n        {\r\n            return LORAMAC_STATUS_OK;\r\n        }\r\n        else\r\n        {\r\n           return LORAMAC_STATUS_LENGTH_ERROR;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        txInfo->MaxPossibleApplicationDataSize = 0;\r\n        return LORAMAC_STATUS_LENGTH_ERROR;\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMibGetRequestConfirm( MibRequestConfirm_t* mibGet )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_OK;\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n\r\n    if( mibGet == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    switch( mibGet->Type )\r\n    {\r\n        case MIB_DEVICE_CLASS:\r\n        {\r\n            mibGet->Param.Class = MacCtx.NvmCtx->DeviceClass;\r\n            break;\r\n        }\r\n        case MIB_NETWORK_ACTIVATION:\r\n        {\r\n            mibGet->Param.NetworkActivation = MacCtx.NvmCtx->NetworkActivation;\r\n            break;\r\n        }\r\n        case MIB_DEV_EUI:\r\n        {\r\n            mibGet->Param.DevEui = SecureElementGetDevEui( );\r\n            break;\r\n        }\r\n        case MIB_JOIN_EUI:\r\n        {\r\n            mibGet->Param.JoinEui = SecureElementGetJoinEui( );\r\n            break;\r\n        }\r\n        case MIB_SE_PIN:\r\n        {\r\n            mibGet->Param.JoinEui = SecureElementGetPin( );\r\n            break;\r\n        }\r\n        case MIB_ADR:\r\n        {\r\n            mibGet->Param.AdrEnable = MacCtx.NvmCtx->AdrCtrlOn;\r\n            break;\r\n        }\r\n        case MIB_NET_ID:\r\n        {\r\n            mibGet->Param.NetID = MacCtx.NvmCtx->NetID;\r\n            break;\r\n        }\r\n        case MIB_DEV_ADDR:\r\n        {\r\n            mibGet->Param.DevAddr = MacCtx.NvmCtx->DevAddr;\r\n            break;\r\n        }\r\n        case MIB_PUBLIC_NETWORK:\r\n        {\r\n            mibGet->Param.EnablePublicNetwork = MacCtx.NvmCtx->PublicNetwork;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS:\r\n        {\r\n            getPhy.Attribute = PHY_CHANNELS;\r\n            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n\r\n            mibGet->Param.ChannelList = phyParam.Channels;\r\n            break;\r\n        }\r\n        case MIB_RX2_CHANNEL:\r\n        {\r\n            mibGet->Param.Rx2Channel = MacCtx.NvmCtx->MacParams.Rx2Channel;\r\n            break;\r\n        }\r\n        case MIB_RX2_DEFAULT_CHANNEL:\r\n        {\r\n            mibGet->Param.Rx2Channel = MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel;\r\n            break;\r\n        }\r\n        case MIB_RXC_CHANNEL:\r\n        {\r\n            mibGet->Param.RxCChannel = MacCtx.NvmCtx->MacParams.RxCChannel;\r\n            break;\r\n        }\r\n        case MIB_RXC_DEFAULT_CHANNEL:\r\n        {\r\n            mibGet->Param.RxCChannel = MacCtx.NvmCtx->MacParamsDefaults.RxCChannel;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_MASK:\r\n        {\r\n            getPhy.Attribute = PHY_CHANNELS_DEFAULT_MASK;\r\n            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n\r\n            mibGet->Param.ChannelsDefaultMask = phyParam.ChannelsMask;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_MASK:\r\n        {\r\n            getPhy.Attribute = PHY_CHANNELS_MASK;\r\n            phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n\r\n            mibGet->Param.ChannelsMask = phyParam.ChannelsMask;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_NB_TRANS:\r\n        {\r\n            mibGet->Param.ChannelsNbTrans = MacCtx.NvmCtx->MacParams.ChannelsNbTrans;\r\n            break;\r\n        }\r\n        case MIB_MAX_RX_WINDOW_DURATION:\r\n        {\r\n            mibGet->Param.MaxRxWindow = MacCtx.NvmCtx->MacParams.MaxRxWindow;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_1:\r\n        {\r\n            mibGet->Param.ReceiveDelay1 = MacCtx.NvmCtx->MacParams.ReceiveDelay1;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_2:\r\n        {\r\n            mibGet->Param.ReceiveDelay2 = MacCtx.NvmCtx->MacParams.ReceiveDelay2;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_1:\r\n        {\r\n            mibGet->Param.JoinAcceptDelay1 = MacCtx.NvmCtx->MacParams.JoinAcceptDelay1;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_2:\r\n        {\r\n            mibGet->Param.JoinAcceptDelay2 = MacCtx.NvmCtx->MacParams.JoinAcceptDelay2;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_DATARATE:\r\n        {\r\n            mibGet->Param.ChannelsDefaultDatarate = MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DATARATE:\r\n        {\r\n            mibGet->Param.ChannelsDatarate = MacCtx.NvmCtx->MacParams.ChannelsDatarate;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_TX_POWER:\r\n        {\r\n            mibGet->Param.ChannelsDefaultTxPower = MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_TX_POWER:\r\n        {\r\n            mibGet->Param.ChannelsTxPower = MacCtx.NvmCtx->MacParams.ChannelsTxPower;\r\n            break;\r\n        }\r\n        case MIB_SYSTEM_MAX_RX_ERROR:\r\n        {\r\n            mibGet->Param.SystemMaxRxError = MacCtx.NvmCtx->MacParams.SystemMaxRxError;\r\n            break;\r\n        }\r\n        case MIB_MIN_RX_SYMBOLS:\r\n        {\r\n            mibGet->Param.MinRxSymbols = MacCtx.NvmCtx->MacParams.MinRxSymbols;\r\n            break;\r\n        }\r\n        case MIB_ANTENNA_GAIN:\r\n        {\r\n            mibGet->Param.AntennaGain = MacCtx.NvmCtx->MacParams.AntennaGain;\r\n            break;\r\n        }\r\n        case MIB_NVM_CTXS:\r\n        {\r\n            mibGet->Param.Contexts = GetCtxs( );\r\n            break;\r\n        }\r\n        case MIB_DEFAULT_ANTENNA_GAIN:\r\n        {\r\n            mibGet->Param.DefaultAntennaGain = MacCtx.NvmCtx->MacParamsDefaults.AntennaGain;\r\n            break;\r\n        }\r\n        case MIB_LORAWAN_VERSION:\r\n        {\r\n            mibGet->Param.LrWanVersion.LoRaWan = MacCtx.NvmCtx->Version;\r\n            mibGet->Param.LrWanVersion.LoRaWanRegion = RegionGetVersion( );\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            status = LoRaMacClassBMibGetRequestConfirm( mibGet );\r\n            break;\r\n        }\r\n    }\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMibSetRequestConfirm( MibRequestConfirm_t* mibSet )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_OK;\r\n    ChanMaskSetParams_t chanMaskSet;\r\n    VerifyParams_t verify;\r\n\r\n    if( mibSet == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    switch( mibSet->Type )\r\n    {\r\n        case MIB_DEVICE_CLASS:\r\n        {\r\n            status = SwitchClass( mibSet->Param.Class );\r\n            break;\r\n        }\r\n        case MIB_NETWORK_ACTIVATION:\r\n        {\r\n            if( mibSet->Param.NetworkActivation != ACTIVATION_TYPE_OTAA  )\r\n            {\r\n                MacCtx.NvmCtx->NetworkActivation = mibSet->Param.NetworkActivation;\r\n            }\r\n            else\r\n            {   // Do not allow to set ACTIVATION_TYPE_OTAA since the MAC will set it automatically after a successful join process.\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_DEV_EUI:\r\n        {\r\n            if( SecureElementSetDevEui( mibSet->Param.DevEui ) != SECURE_ELEMENT_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_JOIN_EUI:\r\n        {\r\n            if( SecureElementSetJoinEui( mibSet->Param.JoinEui ) != SECURE_ELEMENT_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_SE_PIN:\r\n        {\r\n            if( SecureElementSetPin( mibSet->Param.SePin ) != SECURE_ELEMENT_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_ADR:\r\n        {\r\n            MacCtx.NvmCtx->AdrCtrlOn = mibSet->Param.AdrEnable;\r\n            break;\r\n        }\r\n        case MIB_NET_ID:\r\n        {\r\n            MacCtx.NvmCtx->NetID = mibSet->Param.NetID;\r\n            break;\r\n        }\r\n        case MIB_DEV_ADDR:\r\n        {\r\n            MacCtx.NvmCtx->DevAddr = mibSet->Param.DevAddr;\r\n            break;\r\n        }\r\n        case MIB_APP_KEY:\r\n        {\r\n            if( mibSet->Param.AppKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_KEY, mibSet->Param.AppKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_NWK_KEY:\r\n        {\r\n            if( mibSet->Param.NwkKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_KEY, mibSet->Param.NwkKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_J_S_INT_KEY:\r\n        {\r\n            if( mibSet->Param.JSIntKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( J_S_INT_KEY, mibSet->Param.JSIntKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_J_S_ENC_KEY:\r\n        {\r\n            if( mibSet->Param.JSEncKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( J_S_ENC_KEY, mibSet->Param.JSEncKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_F_NWK_S_INT_KEY:\r\n        {\r\n            if( mibSet->Param.FNwkSIntKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( F_NWK_S_INT_KEY, mibSet->Param.FNwkSIntKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_S_NWK_S_INT_KEY:\r\n        {\r\n            if( mibSet->Param.SNwkSIntKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( S_NWK_S_INT_KEY, mibSet->Param.SNwkSIntKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_NWK_S_ENC_KEY:\r\n        {\r\n            if( mibSet->Param.NwkSEncKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_S_ENC_KEY, mibSet->Param.NwkSEncKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_APP_S_KEY:\r\n        {\r\n            if( mibSet->Param.AppSKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_S_KEY, mibSet->Param.AppSKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KE_KEY:\r\n        {\r\n            if( mibSet->Param.McKEKey != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KE_KEY, mibSet->Param.McKEKey ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_0:\r\n        {\r\n            if( mibSet->Param.McKey0 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_0, mibSet->Param.McKey0 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_0:\r\n        {\r\n            if( mibSet->Param.McAppSKey0 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_0, mibSet->Param.McAppSKey0 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_0:\r\n        {\r\n            if( mibSet->Param.McNwkSKey0 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_0, mibSet->Param.McNwkSKey0 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_1:\r\n        {\r\n            if( mibSet->Param.McKey1 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_1, mibSet->Param.McKey1 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_1:\r\n        {\r\n            if( mibSet->Param.McAppSKey1 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_1, mibSet->Param.McAppSKey1 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_1:\r\n        {\r\n            if( mibSet->Param.McNwkSKey1 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_1, mibSet->Param.McNwkSKey1 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_2:\r\n        {\r\n            if( mibSet->Param.McKey2 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_2, mibSet->Param.McKey2 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_2:\r\n        {\r\n            if( mibSet->Param.McAppSKey2 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_2, mibSet->Param.McAppSKey2 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_2:\r\n        {\r\n            if( mibSet->Param.McNwkSKey2 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_2, mibSet->Param.McNwkSKey2 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_KEY_3:\r\n        {\r\n            if( mibSet->Param.McKey3 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_3, mibSet->Param.McKey3 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_APP_S_KEY_3:\r\n        {\r\n            if( mibSet->Param.McAppSKey3 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_3, mibSet->Param.McAppSKey3 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MC_NWK_S_KEY_3:\r\n        {\r\n            if( mibSet->Param.McNwkSKey3 != NULL )\r\n            {\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_3, mibSet->Param.McNwkSKey3 ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_PUBLIC_NETWORK:\r\n        {\r\n            MacCtx.NvmCtx->PublicNetwork = mibSet->Param.EnablePublicNetwork;\r\n            Radio.SetPublicNetwork( MacCtx.NvmCtx->PublicNetwork );\r\n            break;\r\n        }\r\n        case MIB_RX2_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParams.Rx2Channel = mibSet->Param.Rx2Channel;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_RX2_DEFAULT_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_RXC_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParams.RxCChannel = mibSet->Param.RxCChannel;\r\n\r\n                if( ( MacCtx.NvmCtx->DeviceClass == CLASS_C ) && ( MacCtx.NvmCtx->NetworkActivation != ACTIVATION_TYPE_NONE ) )\r\n                {\r\n                    // We can only compute the RX window parameters directly, if we are already\r\n                    // in class c mode and joined. We cannot setup an RX window in case of any other\r\n                    // class type.\r\n                    // Set the radio into sleep mode in case we are still in RX mode\r\n                    Radio.Sleep( );\r\n\r\n                    OpenContinuousRxCWindow( );\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_RXC_DEFAULT_CHANNEL:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;\r\n            verify.DatarateParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_RX_DR ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParamsDefaults.RxCChannel = mibSet->Param.RxCDefaultChannel;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_MASK:\r\n        {\r\n            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsDefaultMask;\r\n            chanMaskSet.ChannelsMaskType = CHANNELS_DEFAULT_MASK;\r\n\r\n            if( RegionChanMaskSet( MacCtx.NvmCtx->Region, &chanMaskSet ) == false )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_MASK:\r\n        {\r\n            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsMask;\r\n            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;\r\n\r\n            if( RegionChanMaskSet( MacCtx.NvmCtx->Region, &chanMaskSet ) == false )\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_NB_TRANS:\r\n        {\r\n            if( ( mibSet->Param.ChannelsNbTrans >= 1 ) &&\r\n                ( mibSet->Param.ChannelsNbTrans <= 15 ) )\r\n            {\r\n                MacCtx.NvmCtx->MacParams.ChannelsNbTrans = mibSet->Param.ChannelsNbTrans;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_MAX_RX_WINDOW_DURATION:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.MaxRxWindow = mibSet->Param.MaxRxWindow;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_1:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.ReceiveDelay1 = mibSet->Param.ReceiveDelay1;\r\n            break;\r\n        }\r\n        case MIB_RECEIVE_DELAY_2:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.ReceiveDelay2 = mibSet->Param.ReceiveDelay2;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_1:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.JoinAcceptDelay1 = mibSet->Param.JoinAcceptDelay1;\r\n            break;\r\n        }\r\n        case MIB_JOIN_ACCEPT_DELAY_2:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.JoinAcceptDelay2 = mibSet->Param.JoinAcceptDelay2;\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_DATARATE:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_DEF_TX_DR ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParamsDefaults.ChannelsDatarate = verify.DatarateParams.Datarate;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DATARATE:\r\n        {\r\n            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDatarate;\r\n            verify.DatarateParams.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_TX_DR ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParams.ChannelsDatarate = verify.DatarateParams.Datarate;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_DEFAULT_TX_POWER:\r\n        {\r\n            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_DEF_TX_POWER ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParamsDefaults.ChannelsTxPower = verify.TxPower;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_CHANNELS_TX_POWER:\r\n        {\r\n            verify.TxPower = mibSet->Param.ChannelsTxPower;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_TX_POWER ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParams.ChannelsTxPower = verify.TxPower;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_SYSTEM_MAX_RX_ERROR:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.SystemMaxRxError = MacCtx.NvmCtx->MacParamsDefaults.SystemMaxRxError = mibSet->Param.SystemMaxRxError;\r\n            break;\r\n        }\r\n        case MIB_MIN_RX_SYMBOLS:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.MinRxSymbols = MacCtx.NvmCtx->MacParamsDefaults.MinRxSymbols = mibSet->Param.MinRxSymbols;\r\n            break;\r\n        }\r\n        case MIB_ANTENNA_GAIN:\r\n        {\r\n            MacCtx.NvmCtx->MacParams.AntennaGain = mibSet->Param.AntennaGain;\r\n            break;\r\n        }\r\n        case MIB_DEFAULT_ANTENNA_GAIN:\r\n        {\r\n            MacCtx.NvmCtx->MacParamsDefaults.AntennaGain = mibSet->Param.DefaultAntennaGain;\r\n            break;\r\n        }\r\n        case MIB_NVM_CTXS:\r\n        {\r\n            if( mibSet->Param.Contexts != 0 )\r\n            {\r\n                status = RestoreCtxs( mibSet->Param.Contexts );\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        case MIB_ABP_LORAWAN_VERSION:\r\n        {\r\n            if( mibSet->Param.AbpLrWanVersion.Fields.Minor <= 1 )\r\n            {\r\n                MacCtx.NvmCtx->Version = mibSet->Param.AbpLrWanVersion;\r\n\r\n                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )\r\n                {\r\n                    return LORAMAC_STATUS_CRYPTO_ERROR;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n            break;\r\n        }\r\n        default:\r\n        {\r\n            status = LoRaMacMibClassBSetRequestConfirm( mibSet );\r\n            break;\r\n        }\r\n    }\r\n    EventRegionNvmCtxChanged( );\r\n    EventMacNvmCtxChanged( );\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacChannelAdd( uint8_t id, ChannelParams_t params )\r\n{\r\n    ChannelAddParams_t channelAdd;\r\n\r\n    // Validate if the MAC is in a correct state\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        if( ( MacCtx.MacState & LORAMAC_TX_CONFIG ) != LORAMAC_TX_CONFIG )\r\n        {\r\n            return LORAMAC_STATUS_BUSY;\r\n        }\r\n    }\r\n\r\n    channelAdd.NewChannel = &params;\r\n    channelAdd.ChannelId = id;\r\n\r\n    EventRegionNvmCtxChanged( );\r\n    return RegionChannelAdd( MacCtx.NvmCtx->Region, &channelAdd );\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacChannelRemove( uint8_t id )\r\n{\r\n    ChannelRemoveParams_t channelRemove;\r\n\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        if( ( MacCtx.MacState & LORAMAC_TX_CONFIG ) != LORAMAC_TX_CONFIG )\r\n        {\r\n            return LORAMAC_STATUS_BUSY;\r\n        }\r\n    }\r\n\r\n    channelRemove.ChannelId = id;\r\n\r\n    if( RegionChannelsRemove( MacCtx.NvmCtx->Region, &channelRemove ) == false )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    EventRegionNvmCtxChanged( );\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcChannelSetup( McChannelParams_t *channel )\r\n{\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( channel->GroupID >= LORAMAC_MAX_MC_CTX )\r\n    {\r\n        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;\r\n    }\r\n\r\n    MacCtx.NvmCtx->MulticastChannelList[channel->GroupID].ChannelParams = *channel;\r\n\r\n    if( channel->IsRemotelySetup == true )\r\n    {\r\n        const KeyIdentifier_t mcKeys[LORAMAC_MAX_MC_CTX] = { MC_KEY_0, MC_KEY_1, MC_KEY_2, MC_KEY_3 };\r\n        if( LoRaMacCryptoSetKey( mcKeys[channel->GroupID], channel->McKeys.McKeyE ) != LORAMAC_CRYPTO_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n\r\n        if( LoRaMacCryptoDeriveMcSessionKeyPair( channel->GroupID, channel->Address ) != LORAMAC_CRYPTO_SUCCESS )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        const KeyIdentifier_t mcAppSKeys[LORAMAC_MAX_MC_CTX] = { MC_APP_S_KEY_0, MC_APP_S_KEY_1, MC_APP_S_KEY_2, MC_APP_S_KEY_3 };\r\n        const KeyIdentifier_t mcNwkSKeys[LORAMAC_MAX_MC_CTX] = { MC_NWK_S_KEY_0, MC_NWK_S_KEY_1, MC_NWK_S_KEY_2, MC_NWK_S_KEY_3 };\r\n        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcAppSKeys[channel->GroupID], channel->McKeys.Session.McAppSKey ) )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n        if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( mcNwkSKeys[channel->GroupID], channel->McKeys.Session.McNwkSKey ) )\r\n        {\r\n            return LORAMAC_STATUS_CRYPTO_ERROR;\r\n        }\r\n    }\r\n\r\n    if( channel->Class == CLASS_B )\r\n    {\r\n        // Calculate class b parameters\r\n        LoRaMacClassBSetMulticastPeriodicity( &MacCtx.NvmCtx->MulticastChannelList[channel->GroupID] );\r\n    }\r\n\r\n    // Reset multicast channel downlink counter to initial value.\r\n    *MacCtx.NvmCtx->MulticastChannelList[channel->GroupID].DownLinkCounter = FCNT_DOWN_INITAL_VALUE;\r\n\r\n    EventMacNvmCtxChanged( );\r\n    EventRegionNvmCtxChanged( );\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcChannelDelete( AddressIdentifier_t groupID )\r\n{\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( ( groupID >= LORAMAC_MAX_MC_CTX ) || \r\n        ( MacCtx.NvmCtx->MulticastChannelList[groupID].ChannelParams.IsEnabled == false ) )\r\n    {\r\n        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;\r\n    }\r\n\r\n    McChannelParams_t channel;\r\n\r\n    // Set all channel fields with 0\r\n    memset1( ( uint8_t* )&channel, 0, sizeof( McChannelParams_t ) );\r\n\r\n    MacCtx.NvmCtx->MulticastChannelList[groupID].ChannelParams = channel;\r\n\r\n    EventMacNvmCtxChanged( );\r\n    EventRegionNvmCtxChanged( );\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nuint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )\r\n{\r\n    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n    {\r\n        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )\r\n        {\r\n            return i;\r\n        }\r\n    }\r\n    return 0xFF;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcChannelSetupRxParams( AddressIdentifier_t groupID, McRxParams_t *rxParams, uint8_t *status )\r\n{\r\n   *status = 0x1C + ( groupID & 0x03 );\r\n\r\n    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    DeviceClass_t devClass = MacCtx.NvmCtx->MulticastChannelList[groupID].ChannelParams.Class;\r\n    if( ( devClass == CLASS_A ) || ( devClass > CLASS_C ) )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n\r\n    if( ( groupID >= LORAMAC_MAX_MC_CTX ) || \r\n        ( MacCtx.NvmCtx->MulticastChannelList[groupID].ChannelParams.IsEnabled == false ) )\r\n    {\r\n        return LORAMAC_STATUS_MC_GROUP_UNDEFINED;\r\n    }\r\n    *status &= 0x0F; // groupID OK\r\n\r\n    VerifyParams_t verify;\r\n    // Check datarate\r\n    if( devClass == CLASS_B )\r\n    {\r\n        verify.DatarateParams.Datarate = rxParams->ClassB.Datarate;\r\n    }\r\n    else\r\n    {\r\n        verify.DatarateParams.Datarate = rxParams->ClassC.Datarate;\r\n    }\r\n    verify.DatarateParams.DownlinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime;\r\n\r\n    if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_RX_DR ) == true )\r\n    {\r\n        *status &= 0xFB; // datarate OK\r\n    }\r\n\r\n    // Check frequency\r\n    if( devClass == CLASS_B )\r\n    {\r\n        verify.Frequency = rxParams->ClassB.Frequency;\r\n    }\r\n    else\r\n    {\r\n        verify.Frequency = rxParams->ClassC.Frequency;\r\n    }\r\n    if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_FREQUENCY ) == true )\r\n    {\r\n        *status &= 0xF7; // frequency OK\r\n    }\r\n\r\n    if( *status == ( groupID & 0x03 ) )\r\n    {\r\n        // Apply parameters\r\n        MacCtx.NvmCtx->MulticastChannelList[groupID].ChannelParams.RxParams = *rxParams;\r\n    }\r\n\r\n    EventMacNvmCtxChanged( );\r\n    EventRegionNvmCtxChanged( );\r\n    return LORAMAC_STATUS_OK;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMlmeRequest( MlmeReq_t* mlmeRequest )\r\n{\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n    MlmeConfirmQueue_t queueElement;\r\n    uint8_t macCmdPayload[2] = { 0x00, 0x00 };\r\n\r\n    if( mlmeRequest == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    if( LoRaMacIsBusy( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n    if( LoRaMacConfirmQueueIsFull( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    if( LoRaMacConfirmQueueGetCnt( ) == 0 )\r\n    {\r\n        memset1( ( uint8_t* ) &MacCtx.MlmeConfirm, 0, sizeof( MacCtx.MlmeConfirm ) );\r\n    }\r\n    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n\r\n    MacCtx.MacFlags.Bits.MlmeReq = 1;\r\n    queueElement.Request = mlmeRequest->Type;\r\n    queueElement.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n    queueElement.RestrictCommonReadyToHandle = false;\r\n\r\n    switch( mlmeRequest->Type )\r\n    {\r\n        case MLME_JOIN:\r\n        {\r\n            if( ( MacCtx.MacState & LORAMAC_TX_DELAYED ) == LORAMAC_TX_DELAYED )\r\n            {\r\n                return LORAMAC_STATUS_BUSY;\r\n            }\r\n\r\n            ResetMacParameters( );\r\n\r\n            MacCtx.NvmCtx->MacParams.ChannelsDatarate = RegionAlternateDr( MacCtx.NvmCtx->Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );\r\n\r\n            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;\r\n\r\n            status = SendReJoinReq( JOIN_REQ );\r\n\r\n            if( status != LORAMAC_STATUS_OK )\r\n            {\r\n                // Revert back the previous datarate ( mainly used for US915 like regions )\r\n                MacCtx.NvmCtx->MacParams.ChannelsDatarate = RegionAlternateDr( MacCtx.NvmCtx->Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR_RESTORE );\r\n            }\r\n            break;\r\n        }\r\n        case MLME_LINK_CHECK:\r\n        {\r\n            // LoRaMac will send this command piggy-pack\r\n            status = LORAMAC_STATUS_OK;\r\n            if( LoRaMacCommandsAddCmd( MOTE_MAC_LINK_CHECK_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n            break;\r\n        }\r\n        case MLME_TXCW:\r\n        {\r\n            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );\r\n            break;\r\n        }\r\n        case MLME_TXCW_1:\r\n        {\r\n\r\n            status = SetTxContinuousWave1( mlmeRequest->Req.TxCw.Timeout, mlmeRequest->Req.TxCw.Frequency, mlmeRequest->Req.TxCw.Power );\r\n            break;\r\n        }\r\n        case MLME_DEVICE_TIME:\r\n        {\r\n            // LoRaMac will send this command piggy-pack\r\n            status = LORAMAC_STATUS_OK;\r\n            if( LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_TIME_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n            break;\r\n        }\r\n        case MLME_PING_SLOT_INFO:\r\n        {\r\n            if( MacCtx.NvmCtx->DeviceClass == CLASS_A )\r\n            {\r\n                uint8_t value = mlmeRequest->Req.PingSlotInfo.PingSlot.Value;\r\n\r\n                // LoRaMac will send this command piggy-pack\r\n                LoRaMacClassBSetPingSlotInfo( mlmeRequest->Req.PingSlotInfo.PingSlot.Fields.Periodicity );\r\n                macCmdPayload[0] = value;\r\n                status = LORAMAC_STATUS_OK;\r\n                if( LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_INFO_REQ, macCmdPayload, 1 ) != LORAMAC_COMMANDS_SUCCESS )\r\n                {\r\n                    status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n        case MLME_BEACON_TIMING:\r\n        {\r\n            // LoRaMac will send this command piggy-pack\r\n            status = LORAMAC_STATUS_OK;\r\n            if( LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_TIMING_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )\r\n            {\r\n                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;\r\n            }\r\n            break;\r\n        }\r\n        case MLME_BEACON_ACQUISITION:\r\n        {\r\n            // Apply the request\r\n            queueElement.RestrictCommonReadyToHandle = true;\r\n\r\n            if( LoRaMacClassBIsAcquisitionInProgress( ) == false )\r\n            {\r\n                // Start class B algorithm\r\n                LoRaMacClassBSetBeaconState( BEACON_STATE_ACQUISITION );\r\n                LoRaMacClassBBeaconTimerEvent( NULL );\r\n\r\n                status = LORAMAC_STATUS_OK;\r\n            }\r\n            else\r\n            {\r\n                status = LORAMAC_STATUS_BUSY;\r\n            }\r\n            break;\r\n        }\r\n        default:\r\n            break;\r\n    }\r\n\r\n    if( status != LORAMAC_STATUS_OK )\r\n    {\r\n        if( LoRaMacConfirmQueueGetCnt( ) == 0 )\r\n        {\r\n            MacCtx.NodeAckRequested = false;\r\n            MacCtx.MacFlags.Bits.MlmeReq = 0;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        LoRaMacConfirmQueueAdd( &queueElement );\r\n        EventMacNvmCtxChanged( );\r\n    }\r\n    return status;\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacMcpsRequest( McpsReq_t* mcpsRequest )\r\n{\r\n    GetPhyParams_t getPhy;\r\n    PhyParam_t phyParam;\r\n    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;\r\n    LoRaMacHeader_t macHdr;\r\n    VerifyParams_t verify;\r\n    uint8_t fPort = 0;\r\n    void* fBuffer;\r\n    uint16_t fBufferSize;\r\n    int8_t datarate = DR_0;\r\n    bool readyToSend = false;\r\n\r\n    if( mcpsRequest == NULL )\r\n    {\r\n        return LORAMAC_STATUS_PARAMETER_INVALID;\r\n    }\r\n    if( LoRaMacIsBusy( ) == true )\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n\r\n    macHdr.Value = 0;\r\n    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );\r\n    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\r\n\r\n    // AckTimeoutRetriesCounter must be reset every time a new request (unconfirmed or confirmed) is performed.\r\n    MacCtx.AckTimeoutRetriesCounter = 1;\r\n\r\n    switch( mcpsRequest->Type )\r\n    {\r\n        case MCPS_UNCONFIRMED:\r\n        {\r\n            readyToSend = true;\r\n            MacCtx.AckTimeoutRetries = 1;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;\r\n            fPort = mcpsRequest->Req.Unconfirmed.fPort;\r\n            fBuffer = mcpsRequest->Req.Unconfirmed.fBuffer;\r\n            fBufferSize = mcpsRequest->Req.Unconfirmed.fBufferSize;\r\n            datarate = mcpsRequest->Req.Unconfirmed.Datarate;\r\n            break;\r\n        }\r\n        case MCPS_CONFIRMED:\r\n        {\r\n            readyToSend = true;\r\n            MacCtx.AckTimeoutRetries = MIN( mcpsRequest->Req.Confirmed.NbTrials, MAX_ACK_RETRIES );\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;\r\n            fPort = mcpsRequest->Req.Confirmed.fPort;\r\n            fBuffer = mcpsRequest->Req.Confirmed.fBuffer;\r\n            fBufferSize = mcpsRequest->Req.Confirmed.fBufferSize;\r\n            datarate = mcpsRequest->Req.Confirmed.Datarate;\r\n            break;\r\n        }\r\n        case MCPS_PROPRIETARY:\r\n        {\r\n            readyToSend = true;\r\n            MacCtx.AckTimeoutRetries = 1;\r\n\r\n            macHdr.Bits.MType = FRAME_TYPE_PROPRIETARY;\r\n            fBuffer = mcpsRequest->Req.Proprietary.fBuffer;\r\n            fBufferSize = mcpsRequest->Req.Proprietary.fBufferSize;\r\n            datarate = mcpsRequest->Req.Proprietary.Datarate;\r\n            break;\r\n        }\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // Get the minimum possible datarate\r\n    getPhy.Attribute = PHY_MIN_TX_DR;\r\n    getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n    phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy );\r\n    // Apply the minimum possible datarate.\r\n    // Some regions have limitations for the minimum datarate.\r\n    datarate = MAX( datarate, ( int8_t )phyParam.Value );\r\n\r\n    if( readyToSend == true )\r\n    {\r\n        if( MacCtx.NvmCtx->AdrCtrlOn == false )\r\n        {\r\n            verify.DatarateParams.Datarate = datarate;\r\n            verify.DatarateParams.UplinkDwellTime = MacCtx.NvmCtx->MacParams.UplinkDwellTime;\r\n\r\n            if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_TX_DR ) == true )\r\n            {\r\n                MacCtx.NvmCtx->MacParams.ChannelsDatarate = verify.DatarateParams.Datarate;\r\n            }\r\n            else\r\n            {\r\n                return LORAMAC_STATUS_PARAMETER_INVALID;\r\n            }\r\n        }\r\n\r\n        status = Send( &macHdr, fPort, fBuffer, fBufferSize );\r\n        if( status == LORAMAC_STATUS_OK )\r\n        {\r\n            MacCtx.McpsConfirm.McpsRequest = mcpsRequest->Type;\r\n            MacCtx.MacFlags.Bits.McpsReq = 1;\r\n        }\r\n        else\r\n        {\r\n            MacCtx.NodeAckRequested = false;\r\n        }\r\n    }\r\n\r\n    EventMacNvmCtxChanged( );\r\n    return status;\r\n}\r\n\r\nvoid LoRaMacTestSetDutyCycleOn( bool enable )\r\n{\r\n    VerifyParams_t verify;\r\n\r\n    verify.DutyCycle = enable;\r\n\r\n    if( RegionVerify( MacCtx.NvmCtx->Region, &verify, PHY_DUTY_CYCLE ) == true )\r\n    {\r\n        MacCtx.NvmCtx->DutyCycleOn = enable;\r\n    }\r\n}\r\n\r\nLoRaMacStatus_t LoRaMacDeInitialization( void )\r\n{\r\n    // Check the current state of the LoRaMac\r\n    if ( LoRaMacStop( ) == LORAMAC_STATUS_OK )\r\n    {\r\n        // Stop Timers\r\n        TimerStop( &MacCtx.TxDelayedTimer );\r\n        TimerStop( &MacCtx.RxWindowTimer1 );\r\n        TimerStop( &MacCtx.RxWindowTimer2 );\r\n        TimerStop( &MacCtx.AckTimeoutTimer );\r\n\r\n        // Take care about class B\r\n        LoRaMacClassBHaltBeaconing( );\r\n\r\n        // Reset Mac parameters\r\n        ResetMacParameters( );\r\n\r\n        // Switch off Radio\r\n        Radio.Sleep( );\r\n\r\n        // Return success\r\n        return LORAMAC_STATUS_OK;\r\n    }\r\n    else\r\n    {\r\n        return LORAMAC_STATUS_BUSY;\r\n    }\r\n}\r\n", "/**\n * @file      atecc608a-tnglora-se.c\n *\n * @brief     ATECC608A-TNGLORA Secure Element hardware implementation\n *\n * @remark    Current implementation only supports LoRaWAN 1.0.x version\n *\n * @copyright Copyright (c) 2020 The Things Industries B.V.\n *\n * Revised BSD License\n * Copyright The Things Industries B.V 2020. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the Things Industries B.V nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE THINGS INDUSTRIES B.V BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"atca_basic.h\"\n#include \"cryptoauthlib.h\"\n#include \"atca_devtypes.h\"\n\n#include \"secure-element.h\"\n#include \"se-identity.h\"\n#include \"atecc608a-tnglora-se-hal.h\"\n\n/*!\n * Number of supported crypto keys\n */\n#define NUM_OF_KEYS 15\n\n#define DEV_EUI_ASCII_SIZE_BYTE 16U\n\n/*!\n * Identifier value pair type for Keys\n */\ntypedef struct sKey\n{\n    /*\n     * Key identifier (used for maping the stack MAC key to the ATECC608A-TNGLoRaWAN slot)\n     */\n    KeyIdentifier_t KeyID;\n    /*\n     * Key slot number\n     */\n    uint16_t KeySlotNumber;\n    /*\n     * Key block index within slot (each block can contain two keys, so index is either 0 or 1)\n     */\n    uint8_t KeyBlockIndex;\n} Key_t;\n\n/*\n * Secure Element Non Volatile Context structure\n */\ntypedef struct sSecureElementNvCtx\n{\n    /*!\n     * DevEUI storage\n     */\n    uint8_t DevEui[SE_EUI_SIZE];\n    /*!\n     * Join EUI storage\n     */\n    uint8_t JoinEui[SE_EUI_SIZE];\n    /*!\n     * Pin storage\n     */\n    uint8_t Pin[SE_PIN_SIZE];\n    /*!\n     * CMAC computation context variable\n     */\n    atca_aes_cmac_ctx_t AtcaAesCmacCtx;\n    /*!\n     * LoRaWAN key list\n     */\n    Key_t KeyList[NUM_OF_KEYS];\n} SecureElementNvCtx_t;\n\n/*!\n * Secure element context\n */\nstatic SecureElementNvCtx_t SeNvmCtx = {\n    /*!\n     * end-device IEEE EUI (big endian)\n     */\n    .DevEui = { 0 },\n    /*!\n     * App/Join server IEEE EUI (big endian)\n     */\n    .JoinEui = { 0 },\n    /*!\n     * Secure-element pin (big endian)\n     */\n    .Pin = SECURE_ELEMENT_PIN,\n    /*!\n     * LoRaWAN key list\n     */\n    .KeyList = ATECC608A_SE_KEY_LIST\n};\n\nstatic SecureElementNvmEvent SeNvmCtxChanged;\n\nstatic ATCAIfaceCfg atecc608_i2c_config;\n\nstatic ATCA_STATUS convert_ascii_devEUI( uint8_t* devEUI_ascii, uint8_t* devEUI );\n\nstatic ATCA_STATUS atcab_read_joinEUI( uint8_t* joinEUI )\n{\n    ATCA_STATUS status = ATCA_GEN_FAIL;\n    uint8_t     read_buf[ATCA_BLOCK_SIZE];\n\n    if( joinEUI == NULL )\n    {\n        return ATCA_BAD_PARAM;\n    }\n\n    do\n    {\n        status = atcab_read_zone( ATCA_ZONE_DATA, TNGLORA_JOIN_EUI_SLOT, 0, 0, read_buf, ATCA_BLOCK_SIZE );\n        if( status != ATCA_SUCCESS )\n        {\n            break;\n        }\n        memcpy1( joinEUI, read_buf, SE_EUI_SIZE );\n    } while( 0 );\n\n    return status;\n}\n\nstatic ATCA_STATUS atcab_read_ascii_devEUI( uint8_t* devEUI_ascii )\n{\n    ATCA_STATUS status = ATCA_GEN_FAIL;\n    uint8_t     read_buf[ATCA_BLOCK_SIZE];\n\n    if( devEUI_ascii == NULL )\n    {\n        return ATCA_BAD_PARAM;\n    }\n\n    do\n    {\n        status = atcab_read_zone( ATCA_ZONE_DATA, TNGLORA_DEV_EUI_SLOT, 0, 0, read_buf, ATCA_BLOCK_SIZE );\n        if( status != ATCA_SUCCESS )\n        {\n            break;\n        }\n        memcpy1( devEUI_ascii, read_buf, DEV_EUI_ASCII_SIZE_BYTE );\n    } while( 0 );\n\n    return status;\n}\n\nstatic ATCA_STATUS convert_ascii_devEUI( uint8_t* devEUI_ascii, uint8_t* devEUI )\n{\n    for( size_t pos = 0; pos < DEV_EUI_ASCII_SIZE_BYTE; pos += 2 )\n    {\n        uint8_t temp = 0;\n        if( ( devEUI_ascii[pos] >= '0' ) && ( devEUI_ascii[pos] <= '9' ) )\n        {\n            temp = ( devEUI_ascii[pos] - '0' ) << 4;\n        }\n        else if( ( devEUI_ascii[pos] >= 'A' ) && ( devEUI_ascii[pos] <= 'F' ) )\n        {\n            temp = ( ( devEUI_ascii[pos] - 'A' ) + 10 ) << 4;\n        }\n        else\n        {\n            return ATCA_BAD_PARAM;\n        }\n        if( ( devEUI_ascii[pos + 1] >= '0' ) && ( devEUI_ascii[pos + 1] <= '9' ) )\n        {\n            temp |= devEUI_ascii[pos + 1] - '0';\n        }\n        else if( ( devEUI_ascii[pos + 1] >= 'A' ) && ( devEUI_ascii[pos + 1] <= 'F' ) )\n        {\n            temp |= ( devEUI_ascii[pos + 1] - 'A' ) + 10;\n        }\n        else\n        {\n            return ATCA_BAD_PARAM;\n        }\n        devEUI[pos / 2] = temp;\n    }\n    return ATCA_SUCCESS;\n}\n\nstatic ATCA_STATUS atcab_read_devEUI( uint8_t* devEUI )\n{\n    ATCA_STATUS status = ATCA_GEN_FAIL;\n    uint8_t     devEUI_ascii[DEV_EUI_ASCII_SIZE_BYTE];\n\n    status = atcab_read_ascii_devEUI( devEUI_ascii );\n    if( status != ATCA_SUCCESS )\n    {\n        return status;\n    }\n    status = convert_ascii_devEUI( devEUI_ascii, devEUI );\n    return status;\n}\n\n/*\n * Gets key item from key list.\n *\n *  cmac = aes128_cmac(keyID, B0 | msg)\n *\n * \\param[IN]  keyID          - Key identifier\n * \\param[OUT] keyItem        - Key item reference\n * \\retval                    - Status of the operation\n */\nSecureElementStatus_t GetKeyByID( KeyIdentifier_t keyID, Key_t** keyItem )\n{\n    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )\n    {\n        if( SeNvmCtx.KeyList[i].KeyID == keyID )\n        {\n            *keyItem = &( SeNvmCtx.KeyList[i] );\n            return SECURE_ELEMENT_SUCCESS;\n        }\n    }\n    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n}\n\n/*\n * Dummy callback in case if the user provides NULL function pointer\n */\nstatic void DummyCB( void )\n{\n    return;\n}\n\n/*\n * Computes a CMAC of a message using provided initial Bx block\n *\n *  cmac = aes128_cmac(keyID, blocks[i].Buffer)\n *\n * \\param[IN]  micBxBuffer    - Buffer containing the initial Bx block\n * \\param[IN]  buffer         - Data buffer\n * \\param[IN]  size           - Data buffer size\n * \\param[IN]  keyID          - Key identifier to determine the AES key to be used\n * \\param[OUT] cmac           - Computed cmac\n * \\retval                    - Status of the operation\n */\nstatic SecureElementStatus_t ComputeCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,\n                                          uint32_t* cmac )\n{\n    if( ( buffer == NULL ) || ( cmac == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    uint8_t Cmac[16] = { 0 };\n\n    Key_t*                keyItem;\n    SecureElementStatus_t retval = GetKeyByID( keyID, &keyItem );\n    if( retval != SECURE_ELEMENT_SUCCESS )\n    {\n        return retval;\n    }\n\n    ATCA_STATUS status =\n        atcab_aes_cmac_init( &SeNvmCtx.AtcaAesCmacCtx, keyItem->KeySlotNumber, keyItem->KeyBlockIndex );\n\n    if( ATCA_SUCCESS == status )\n    {\n        if( micBxBuffer != NULL )\n        {\n            atcab_aes_cmac_update( &SeNvmCtx.AtcaAesCmacCtx, micBxBuffer, 16 );\n        }\n\n        atcab_aes_cmac_update( &SeNvmCtx.AtcaAesCmacCtx, buffer, size );\n\n        atcab_aes_cmac_finish( &SeNvmCtx.AtcaAesCmacCtx, Cmac, 16 );\n\n        *cmac = ( uint32_t )( ( uint32_t ) Cmac[3] << 24 | ( uint32_t ) Cmac[2] << 16 | ( uint32_t ) Cmac[1] << 8 |\n                              ( uint32_t ) Cmac[0] );\n        return SECURE_ELEMENT_SUCCESS;\n    }\n    else\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n}\n\nSecureElementStatus_t SecureElementInit( SecureElementNvmEvent seNvmCtxChanged )\n{\n#if !defined( SECURE_ELEMENT_PRE_PROVISIONED )\n#error \"ATECC608A is always pre-provisioned. Please set SECURE_ELEMENT_PRE_PROVISIONED to ON\"\n#endif\n    atecc608_i2c_config.iface_type            = ATCA_I2C_IFACE;\n    atecc608_i2c_config.atcai2c.baud          = ATCA_HAL_ATECC608A_I2C_FREQUENCY;\n    atecc608_i2c_config.atcai2c.bus           = ATCA_HAL_ATECC608A_I2C_BUS_PINS;\n    atecc608_i2c_config.atcai2c.slave_address = ATCA_HAL_ATECC608A_I2C_ADDRESS;\n    atecc608_i2c_config.devtype               = ATECC608A;\n    atecc608_i2c_config.rx_retries            = ATCA_HAL_ATECC608A_I2C_RX_RETRIES;\n    atecc608_i2c_config.wake_delay            = ATCA_HAL_ATECC608A_I2C_WAKEUP_DELAY;\n\n    if( atcab_init( &atecc608_i2c_config ) != ATCA_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n\n    if( atcab_read_devEUI( SeNvmCtx.DevEui ) != ATCA_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n\n    if( atcab_read_joinEUI( SeNvmCtx.JoinEui ) != ATCA_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n\n    // Assign callback\n    if( seNvmCtxChanged != 0 )\n    {\n        SeNvmCtxChanged = seNvmCtxChanged;\n    }\n    else\n    {\n        SeNvmCtxChanged = DummyCB;\n    }\n\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementRestoreNvmCtx( void* seNvmCtx )\n{\n    // Restore nvm context\n    if( seNvmCtx != 0 )\n    {\n        memcpy1( ( uint8_t* ) &SeNvmCtx, ( uint8_t* ) seNvmCtx, sizeof( SeNvmCtx ) );\n        return SECURE_ELEMENT_SUCCESS;\n    }\n    else\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n}\n\nvoid* SecureElementGetNvmCtx( size_t* seNvmCtxSize )\n{\n    *seNvmCtxSize = sizeof( SeNvmCtx );\n    return &SeNvmCtx;\n}\n\nSecureElementStatus_t SecureElementSetKey( KeyIdentifier_t keyID, uint8_t* key )\n{\n    // No key setting for HW SE, can only derive keys\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementComputeAesCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size,\n                                                   KeyIdentifier_t keyID, uint32_t* cmac )\n{\n    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )\n    {\n        // Never accept multicast key identifier for cmac computation\n        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n    }\n    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );\n}\n\nSecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,\n                                                  KeyIdentifier_t keyID )\n{\n    if( buffer == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    SecureElementStatus_t retval   = SECURE_ELEMENT_ERROR;\n    uint32_t              compCmac = 0;\n\n    retval = ComputeCmac( NULL, buffer, size, keyID, &compCmac );\n    if( retval != SECURE_ELEMENT_SUCCESS )\n    {\n        return retval;\n    }\n\n    if( expectedCmac != compCmac )\n    {\n        retval = SECURE_ELEMENT_FAIL_CMAC;\n    }\n\n    return retval;\n}\n\nSecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,\n                                               uint8_t* encBuffer )\n{\n    if( buffer == NULL || encBuffer == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Check if the size is divisible by 16,\n    if( ( size % 16 ) != 0 )\n    {\n        return SECURE_ELEMENT_ERROR_BUF_SIZE;\n    }\n\n    Key_t*                pItem;\n    SecureElementStatus_t retval = GetKeyByID( keyID, &pItem );\n\n    if( retval == SECURE_ELEMENT_SUCCESS )\n    {\n        uint8_t block = 0;\n\n        while( size != 0 )\n        {\n            atcab_aes_encrypt( pItem->KeySlotNumber, pItem->KeyBlockIndex, &buffer[block], &encBuffer[block] );\n            block = block + 16;\n            size  = size - 16;\n        }\n    }\n    return retval;\n}\n\nSecureElementStatus_t SecureElementDeriveAndStoreKey( Version_t version, uint8_t* input, KeyIdentifier_t rootKeyID,\n                                                      KeyIdentifier_t targetKeyID )\n{\n    if( input == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Source key slot is the LSB and target key slot is the MSB\n    uint16_t    source_target_ids = 0;\n    Key_t*      source_key;\n    Key_t*      target_key;\n    ATCA_STATUS status = ATCA_SUCCESS;\n\n    // In case of MC_KE_KEY, only McRootKey can be used as root key\n    if( targetKeyID == MC_KE_KEY )\n    {\n        if( rootKeyID != MC_ROOT_KEY )\n        {\n            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n        }\n    }\n\n    if( ( rootKeyID == APP_KEY ) || ( rootKeyID == MC_ROOT_KEY ) || ( rootKeyID == MC_KE_KEY ) )\n    {\n        // Allow the stack to move forward as these rootkeys dont exist inside SE.\n        return SECURE_ELEMENT_SUCCESS;\n    }\n\n    if( GetKeyByID( rootKeyID, &source_key ) != SECURE_ELEMENT_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n    }\n\n    if( GetKeyByID( targetKeyID, &target_key ) != SECURE_ELEMENT_SUCCESS )\n    {\n        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n    }\n\n    source_target_ids = target_key->KeySlotNumber << 8;\n    source_target_ids += source_key->KeySlotNumber;\n\n    uint32_t detail = source_key->KeyBlockIndex;\n\n    status = atcab_kdf( KDF_MODE_ALG_AES | KDF_MODE_SOURCE_SLOT | KDF_MODE_TARGET_SLOT, source_target_ids, detail,\n                        input, NULL, NULL );\n    if( status == ATCA_SUCCESS )\n    {\n        return SECURE_ELEMENT_SUCCESS;\n    }\n    else\n    {\n        return SECURE_ELEMENT_ERROR;\n    }\n}\n\nSecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,\n                                                      uint16_t devNonce, uint8_t* encJoinAccept,\n                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,\n                                                      uint8_t* versionMinor )\n{\n    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Check that frame size isn't bigger than a JoinAccept with CFList size\n    if( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE )\n    {\n        return SECURE_ELEMENT_ERROR_BUF_SIZE;\n    }\n\n    // Determine decryption key\n    KeyIdentifier_t encKeyID = NWK_KEY;\n\n    if( joinReqType != JOIN_REQ )\n    {\n        encKeyID = J_S_ENC_KEY;\n    }\n\n    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );\n\n    // Decrypt JoinAccept, skip MHDR\n    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,\n                                 encKeyID, decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS )\n    {\n        return SECURE_ELEMENT_FAIL_ENCRYPT;\n    }\n\n    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;\n\n    uint32_t mic = 0;\n\n    mic = ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE] << 0 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1] << 8 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );\n\n    //  - Header buffer to be used for MIC computation\n    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]\n    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]\n\n    // Verify mic\n    if( *versionMinor == 0 )\n    {\n        // For LoRaWAN 1.0.x\n        //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |\n        //   CFListType)\n        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=\n            SECURE_ELEMENT_SUCCESS )\n        {\n            return SECURE_ELEMENT_FAIL_CMAC;\n        }\n    }\n#if( USE_LRWAN_1_1_X_CRYPTO == 1 )\n    else if( *versionMinor == 1 )\n    {\n        uint8_t  micHeader11[JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n        uint16_t bufItr                                          = 0;\n\n        micHeader11[bufItr++] = ( uint8_t ) joinReqType;\n\n        memcpyr( micHeader11 + bufItr, joinEui, LORAMAC_JOIN_EUI_FIELD_SIZE );\n        bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;\n\n        micHeader11[bufItr++] = devNonce & 0xFF;\n        micHeader11[bufItr++] = ( devNonce >> 8 ) & 0xFF;\n\n        // For LoRaWAN 1.1.x and later:\n        //   cmac = aes128_cmac(JSIntKey, JoinReqType | JoinEUI | DevNonce | MHDR | JoinNonce | NetID | DevAddr |\n        //   DLSettings | RxDelay | CFList | CFListType)\n        // Prepare the msg for integrity check (adding JoinReqType, JoinEUI and DevNonce)\n        uint8_t localBuffer[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n\n        memcpy1( localBuffer, micHeader11, JOIN_ACCEPT_MIC_COMPUTATION_OFFSET );\n        memcpy1( localBuffer + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET - 1, decJoinAccept, encJoinAcceptSize );\n\n        if( SecureElementVerifyAesCmac( localBuffer,\n                                        encJoinAcceptSize + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET -\n                                            LORAMAC_MHDR_FIELD_SIZE - LORAMAC_MIC_FIELD_SIZE,\n                                        mic, J_S_INT_KEY ) != SECURE_ELEMENT_SUCCESS )\n        {\n            return SECURE_ELEMENT_FAIL_CMAC;\n        }\n    }\n#endif\n    else\n    {\n        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;\n    }\n\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementRandomNumber( uint32_t* randomNum )\n{\n    if( randomNum == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    *randomNum = ATECC608ASeHalGetRandomNumber( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementSetDevEui( uint8_t* devEui )\n{\n    if( devEui == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    memcpy1( SeNvmCtx.DevEui, devEui, SE_EUI_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetDevEui( void )\n{\n    return SeNvmCtx.DevEui;\n}\n\nSecureElementStatus_t SecureElementSetJoinEui( uint8_t* joinEui )\n{\n    if( joinEui == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    memcpy1( SeNvmCtx.JoinEui, joinEui, SE_EUI_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetJoinEui( void )\n{\n    return SeNvmCtx.JoinEui;\n}\n\nSecureElementStatus_t SecureElementSetPin( uint8_t* pin )\n{\n    if( pin == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    memcpy1( SeNvmCtx.Pin, pin, SE_PIN_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetPin( void )\n{\n    return SeNvmCtx.Pin;\n}\n", "/*!\n * \\file      lr1110-se.c\n *\n * \\brief     LR1110 Secure Element hardware implementation\n *\n * \\copyright Revised BSD License, see section \\ref LICENSE.\n *\n * \\code\n *                ______                              _\n *               / _____)             _              | |\n *              ( (____  _____ ____ _| |_ _____  ____| |__\n *               \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n *               _____) ) ____| | | || |_| ____( (___| | | |\n *              (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n *              (C)2019-2019 Semtech\n *\n * \\endcode\n *\n * \\authors    Semtech WSP Applications Team\n */\n#include <stdlib.h>\n#include <stdint.h>\n\n#include \"lr1110.h\"\n#include \"lr1110_system.h\"\n#include \"lr1110_crypto_engine.h\"\n\n#include \"secure-element.h\"\n#include \"se-identity.h\"\n#include \"lr1110-se-hal.h\"\n\n/*!\n * Number of supported crypto keys\n */\n#define NUM_OF_KEYS 23\n\n/*\n * CMAC/AES Message Integrity Code (MIC) Block B0 size\n */\n#define MIC_BLOCK_BX_SIZE 16\n\n/*\n * Maximum size of the message that can be handled by the crypto operations\n */\n#define CRYPTO_MAXMESSAGE_SIZE 256\n\n/*\n * Maximum size of the buffer for crypto operations\n */\n#define CRYPTO_BUFFER_SIZE CRYPTO_MAXMESSAGE_SIZE + MIC_BLOCK_BX_SIZE\n\n/*!\n * Secure-element LoRaWAN identity local storage.\n */\ntypedef struct sSecureElementNvCtx\n{\n    /*\n     * DevEUI storage\n     */\n    uint8_t DevEui[SE_EUI_SIZE];\n    /*\n     * Join EUI storage\n     */\n    uint8_t JoinEui[SE_EUI_SIZE];\n    /*\n     * PIN of the LR1110\n     */\n    uint8_t Pin[SE_PIN_SIZE];\n} SecureElementNvCtx_t;\n\nstatic SecureElementNvCtx_t SeContext = {\n    /*!\n     * end-device IEEE EUI (big endian)\n     *\n     * \\remark In this application the value is automatically generated by calling\n     *         BoardGetUniqueId function\n     */\n    .DevEui = LORAWAN_DEVICE_EUI,\n    /*!\n     * App/Join server IEEE EUI (big endian)\n     */\n    .JoinEui = LORAWAN_JOIN_EUI,\n    /*!\n     * Secure-element pin (big endian)\n     */\n    .Pin = SECURE_ELEMENT_PIN,\n};\n\nstatic SecureElementNvmEvent SeNvmCtxChanged;\n\n/*!\n * LR1110 radio context\n */\nextern lr1110_t LR1110;\n\n/*!\n * Converts key ids from SecureElement to LR1110\n *\n * \\param [IN] key_id SecureElement key id to be converted\n *\n * \\retval key_id Converted LR1110 key id\n */\nstatic lr1110_crypto_keys_idx_t convert_key_id_from_se_to_lr1110( KeyIdentifier_t key_id );\n\n/*!\n * Dummy callback in case if the user provides NULL function pointer\n */\nstatic void DummyCB( void )\n{\n    return;\n}\n\nSecureElementStatus_t SecureElementInit( SecureElementNvmEvent seNvmCtxChanged )\n{\n    lr1110_crypto_status_t status = LR1110_CRYPTO_STATUS_ERROR;\n\n    // Assign callback\n    if( seNvmCtxChanged != 0 )\n    {\n        SeNvmCtxChanged = seNvmCtxChanged;\n    }\n    else\n    {\n        SeNvmCtxChanged = DummyCB;\n    }\n\n    lr1110_crypto_restore_from_flash( &LR1110, &status );\n\n#if defined( SECURE_ELEMENT_PRE_PROVISIONED )\n    // Read LR1110 pre-provisioned identity\n    lr1110_system_read_uid( &LR1110, SeContext.DevEui );\n    lr1110_system_read_join_eui( &LR1110, SeContext.JoinEui );\n    lr1110_system_read_pin( &LR1110, SeContext.Pin );\n#else\n#if( STATIC_DEVICE_EUI == 0 )\n    // Get a DevEUI from MCU unique ID\n    LR1110SeHalGetUniqueId( SeContext.DevEui );\n#endif\n#endif\n\n    SeNvmCtxChanged( );\n\n    return ( SecureElementStatus_t ) status;\n}\n\nSecureElementStatus_t SecureElementRestoreNvmCtx( void* seNvmCtx )\n{\n    lr1110_crypto_status_t status = LR1110_CRYPTO_STATUS_ERROR;\n\n    if( seNvmCtx == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Restore lr1110 crypto context\n    lr1110_crypto_restore_from_flash( &LR1110, &status );\n\n    // Restore nvm context\n    memcpy1( ( uint8_t* ) &SeContext, ( uint8_t* ) seNvmCtx, sizeof( SeContext ) );\n\n    return ( SecureElementStatus_t ) status;\n}\n\nvoid* SecureElementGetNvmCtx( size_t* seNvmCtxSize )\n{\n    *seNvmCtxSize = sizeof( SeContext );\n    return &SeContext;\n}\n\nSecureElementStatus_t SecureElementSetKey( KeyIdentifier_t keyID, uint8_t* key )\n{\n    if( key == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;\n\n    if( ( keyID == MC_KEY_0 ) || ( keyID == MC_KEY_1 ) || ( keyID == MC_KEY_2 ) || ( keyID == MC_KEY_3 ) )\n    {  // Decrypt the key if its a Mckey\n\n        lr1110_crypto_derive_and_store_key( &LR1110, ( lr1110_crypto_status_t* ) &status,\n                                            convert_key_id_from_se_to_lr1110( MC_KE_KEY ),\n                                            convert_key_id_from_se_to_lr1110( keyID ), key );\n\n        if( status == SECURE_ELEMENT_SUCCESS )\n        {\n            lr1110_crypto_store_to_flash( &LR1110, ( lr1110_crypto_status_t* ) &status );\n        }\n        return status;\n    }\n    else\n    {\n        lr1110_crypto_set_key( &LR1110, ( lr1110_crypto_status_t* ) &status, convert_key_id_from_se_to_lr1110( keyID ),\n                               key );\n        if( status == SECURE_ELEMENT_SUCCESS )\n        {\n            lr1110_crypto_store_to_flash( &LR1110, ( lr1110_crypto_status_t* ) &status );\n        }\n        return status;\n    }\n}\n\nSecureElementStatus_t SecureElementComputeAesCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size,\n                                                   KeyIdentifier_t keyID, uint32_t* cmac )\n{\n    SecureElementStatus_t status      = SECURE_ELEMENT_ERROR;\n    uint16_t              localSize   = size;\n    uint8_t*              localbuffer = buffer;\n\n    if( micBxBuffer != NULL )\n    {\n        uint8_t micBuff[CRYPTO_BUFFER_SIZE];\n\n        memset1( micBuff, 0, CRYPTO_BUFFER_SIZE );\n\n        memcpy1( micBuff, micBxBuffer, MIC_BLOCK_BX_SIZE );\n        memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), buffer, size );\n        localSize += MIC_BLOCK_BX_SIZE;\n        localbuffer = micBuff;\n    }\n\n    lr1110_crypto_compute_aes_cmac( &LR1110, ( lr1110_crypto_status_t* ) &status,\n                                    convert_key_id_from_se_to_lr1110( keyID ), localbuffer, localSize,\n                                    ( uint8_t* ) cmac );\n\n    return status;\n}\n\nSecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,\n                                                  KeyIdentifier_t keyID )\n{\n    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;\n\n    if( buffer == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    lr1110_crypto_verify_aes_cmac( &LR1110, ( lr1110_crypto_status_t* ) &status,\n                                   convert_key_id_from_se_to_lr1110( keyID ), buffer, size,\n                                   ( uint8_t* ) &expectedCmac );\n\n    return status;\n}\n\nSecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,\n                                               uint8_t* encBuffer )\n{\n    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;\n\n    if( ( buffer == NULL ) || ( encBuffer == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    lr1110_crypto_aes_encrypt_01( &LR1110, ( lr1110_crypto_status_t* ) &status,\n                                  convert_key_id_from_se_to_lr1110( keyID ), buffer, size, encBuffer );\n\n    return status;\n}\n\nSecureElementStatus_t SecureElementDeriveAndStoreKey( Version_t version, uint8_t* input, KeyIdentifier_t rootKeyID,\n                                                      KeyIdentifier_t targetKeyID )\n{\n    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;\n\n    if( input == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    lr1110_crypto_derive_and_store_key( &LR1110, ( lr1110_crypto_status_t* ) &status,\n                                        convert_key_id_from_se_to_lr1110( rootKeyID ),\n                                        convert_key_id_from_se_to_lr1110( targetKeyID ), input );\n\n    lr1110_crypto_store_to_flash( &LR1110, ( lr1110_crypto_status_t* ) &status );\n    return status;\n}\n\nSecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,\n                                                      uint16_t devNonce, uint8_t* encJoinAccept,\n                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,\n                                                      uint8_t* versionMinor )\n{\n    SecureElementStatus_t status = SECURE_ELEMENT_ERROR;\n\n    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Check that frame size isn't bigger than a JoinAccept with CFList size\n    if( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE )\n    {\n        return SECURE_ELEMENT_ERROR_BUF_SIZE;\n    }\n\n    // Determine decryption key\n    KeyIdentifier_t encKeyID = NWK_KEY;\n\n    if( joinReqType != JOIN_REQ )\n    {\n        encKeyID = J_S_ENC_KEY;\n    }\n\n    //  - Header buffer to be used for MIC computation\n    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]\n    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]\n\n    // Try first to process LoRaWAN 1.0.x JoinAccept\n    uint8_t micHeader10[1] = { 0x20 };\n\n    //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |\n    //   CFListType)\n    lr1110_crypto_process_join_accept(\n        &LR1110, ( lr1110_crypto_status_t* ) &status, convert_key_id_from_se_to_lr1110( encKeyID ),\n        convert_key_id_from_se_to_lr1110( NWK_KEY ), ( lr1110_crypto_lorawan_version_t ) 0, micHeader10,\n        encJoinAccept + 1, encJoinAcceptSize - 1, decJoinAccept + 1 );\n\n    if( status == SECURE_ELEMENT_SUCCESS )\n    {\n        *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;\n        if( *versionMinor == 0 )\n        {\n            // Network server is operating according to LoRaWAN 1.0.x\n            return SECURE_ELEMENT_SUCCESS;\n        }\n    }\n\n#if( USE_LRWAN_1_1_X_CRYPTO == 1 )\n    // 1.0.x trial failed. Trying to process LoRaWAN 1.1.x JoinAccept\n    uint8_t  micHeader11[JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n    uint16_t bufItr                                     = 0;\n\n    //   cmac = aes128_cmac(JSIntKey, JoinReqType | JoinEUI | DevNonce | MHDR | JoinNonce | NetID | DevAddr |\n    //   DLSettings | RxDelay | CFList | CFListType)\n    micHeader11[bufItr++] = ( uint8_t ) joinReqType;\n\n    memcpyr( micHeader11 + bufItr, joinEui, LORAMAC_JOIN_EUI_FIELD_SIZE );\n    bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;\n\n    micHeader11[bufItr++] = devNonce & 0xFF;\n    micHeader11[bufItr++] = ( devNonce >> 8 ) & 0xFF;\n\n    micHeader11[bufItr++] = 0x20;\n\n    lr1110_crypto_process_join_accept(\n        &LR1110, ( lr1110_crypto_status_t* ) &status, convert_key_id_from_se_to_lr1110( encKeyID ),\n        convert_key_id_from_se_to_lr1110( J_S_INT_KEY ), ( lr1110_crypto_lorawan_version_t ) 1, micHeader11,\n        encJoinAccept + 1, encJoinAcceptSize - 1, decJoinAccept + 1 );\n\n    if( status == SECURE_ELEMENT_SUCCESS )\n    {\n        *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;\n        if( *versionMinor == 1 )\n        {\n            // Network server is operating according to LoRaWAN 1.1.x\n            return SECURE_ELEMENT_SUCCESS;\n        }\n    }\n#endif\n\n    return status;\n}\n\nSecureElementStatus_t SecureElementRandomNumber( uint32_t* randomNum )\n{\n    if( randomNum == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    *randomNum = LR1110SeHalGetRandomNumber( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementSetDevEui( uint8_t* devEui )\n{\n    if( devEui == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    memcpy1( SeContext.DevEui, devEui, SE_EUI_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetDevEui( void )\n{\n    return SeContext.DevEui;\n}\n\nSecureElementStatus_t SecureElementSetJoinEui( uint8_t* joinEui )\n{\n    if( joinEui == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    memcpy1( SeContext.JoinEui, joinEui, SE_EUI_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetJoinEui( void )\n{\n    return SeContext.JoinEui;\n}\n\nSecureElementStatus_t SecureElementSetPin( uint8_t* pin )\n{\n    if( pin == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    memcpy1( SeContext.Pin, pin, SE_PIN_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetPin( void )\n{\n    return SeContext.Pin;\n}\n\nstatic lr1110_crypto_keys_idx_t convert_key_id_from_se_to_lr1110( KeyIdentifier_t key_id )\n{\n    lr1110_crypto_keys_idx_t id = LR1110_CRYPTO_KEYS_IDX_GP0;\n\n    switch( key_id )\n    {\n        case APP_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_APP_KEY;\n            break;\n        case NWK_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_NWK_KEY;\n            break;\n        case J_S_INT_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_J_S_INT_KEY;\n            break;\n        case J_S_ENC_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_J_S_ENC_KEY;\n            break;\n        case F_NWK_S_INT_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_F_NWK_S_INT_KEY;\n            break;\n        case S_NWK_S_INT_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_S_NWK_S_INT_KEY;\n            break;\n        case NWK_S_ENC_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_NWK_S_ENC_KEY;\n            break;\n        case APP_S_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_APP_S_KEY;\n            break;\n        case MC_ROOT_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_5;\n            break;\n        case MC_KE_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_4;\n            break;\n        case MC_KEY_0:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_0;\n            break;\n        case MC_APP_S_KEY_0:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_0;\n            break;\n        case MC_NWK_S_KEY_0:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_0;\n            break;\n        case MC_KEY_1:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_1;\n            break;\n        case MC_APP_S_KEY_1:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_1;\n            break;\n        case MC_NWK_S_KEY_1:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_1;\n            break;\n        case MC_KEY_2:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_2;\n            break;\n        case MC_APP_S_KEY_2:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_2;\n            break;\n        case MC_NWK_S_KEY_2:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_2;\n            break;\n        case MC_KEY_3:\n            id = LR1110_CRYPTO_KEYS_IDX_GP_KE_KEY_3;\n            break;\n        case MC_APP_S_KEY_3:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_APP_S_KEY_3;\n            break;\n        case MC_NWK_S_KEY_3:\n            id = LR1110_CRYPTO_KEYS_IDX_MC_NWK_S_KEY_3;\n            break;\n        case SLOT_RAND_ZERO_KEY:\n            id = LR1110_CRYPTO_KEYS_IDX_GP0;\n            break;\n        default:\n            id = LR1110_CRYPTO_KEYS_IDX_GP1;\n            break;\n    }\n    return id;\n}\n", "/*!\n * \\file      soft-se.c\n *\n * \\brief     Secure Element software implementation\n *\n * \\copyright Revised BSD License, see section \\ref LICENSE.\n *\n * \\code\n *                ______                              _\n *               / _____)             _              | |\n *              ( (____  _____ ____ _| |_ _____  ____| |__\n *               \\____ \\| ___ |    (_   _) ___ |/ ___)  _ \\\n *               _____) ) ____| | | || |_| ____( (___| | | |\n *              (______/|_____)_|_|_| \\__)_____)\\____)_| |_|\n *              (C)2020 Semtech\n *\n *               ___ _____ _   ___ _  _____ ___  ___  ___ ___\n *              / __|_   _/_\\ / __| |/ / __/ _ \\| _ \\/ __| __|\n *              \\__ \\ | |/ _ \\ (__| ' <| _| (_) |   / (__| _|\n *              |___/ |_/_/ \\_\\___|_|\\_\\_| \\___/|_|_\\\\___|___|\n *              embedded.connectivity.solutions===============\n *\n * \\endcode\n *\n */\n#include <stdlib.h>\n#include <stdint.h>\n\n#include \"utilities.h\"\n#include \"aes.h\"\n#include \"cmac.h\"\n\n#include \"LoRaMacHeaderTypes.h\"\n\n#include \"secure-element.h\"\n#include \"se-identity.h\"\n#include \"soft-se-hal.h\"\n\n/*!\n * Number of supported crypto keys\n */\n#define NUM_OF_KEYS 23\n\n/*!\n * Identifier value pair type for Keys\n */\ntypedef struct sKey\n{\n    /*\n     * Key identifier\n     */\n    KeyIdentifier_t KeyID;\n    /*\n     * Key value\n     */\n    uint8_t KeyValue[SE_KEY_SIZE];\n} Key_t;\n\n/*\n * Secure Element Non Volatile Context structure\n */\ntypedef struct sSecureElementNvCtx\n{\n    /*\n     * DevEUI storage\n     */\n    uint8_t DevEui[SE_EUI_SIZE];\n    /*\n     * Join EUI storage\n     */\n    uint8_t JoinEui[SE_EUI_SIZE];\n    /*\n     * Pin storage\n     */\n    uint8_t Pin[SE_PIN_SIZE];\n    /*\n     * AES computation context variable\n     */\n    aes_context AesContext;\n    /*\n     * CMAC computation context variable\n     */\n    AES_CMAC_CTX AesCmacCtx[1];\n    /*\n     * Key List\n     */\n    Key_t KeyList[NUM_OF_KEYS];\n} SecureElementNvCtx_t;\n\n/*!\n * Secure element context\n */\nstatic SecureElementNvCtx_t SeNvmCtx = {\n    /*!\n     * end-device IEEE EUI (big endian)\n     *\n     * \\remark In this application the value is automatically generated by calling\n     *         BoardGetUniqueId function\n     */\n    .DevEui = LORAWAN_DEVICE_EUI,\n    /*!\n     * App/Join server IEEE EUI (big endian)\n     */\n    .JoinEui = LORAWAN_JOIN_EUI,\n    /*!\n     * Secure-element pin (big endian)\n     */\n    .Pin = SECURE_ELEMENT_PIN,\n    /*!\n     * LoRaWAN key list\n     */\n    .KeyList = SOFT_SE_KEY_LIST\n};\n\nstatic SecureElementNvmEvent SeNvmCtxChanged;\n\n/*\n * Local functions\n */\n\n/*\n * Gets key item from key list.\n *\n * \\param[IN]  keyID          - Key identifier\n * \\param[OUT] keyItem        - Key item reference\n * \\retval                    - Status of the operation\n */\nstatic SecureElementStatus_t GetKeyByID( KeyIdentifier_t keyID, Key_t** keyItem )\n{\n    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )\n    {\n        if( SeNvmCtx.KeyList[i].KeyID == keyID )\n        {\n            *keyItem = &( SeNvmCtx.KeyList[i] );\n            return SECURE_ELEMENT_SUCCESS;\n        }\n    }\n    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n}\n\n/*\n * Dummy callback in case if the user provides NULL function pointer\n */\nstatic void DummyCB( void )\n{\n    return;\n}\n\n/*\n * Computes a CMAC of a message using provided initial Bx block\n *\n *  cmac = aes128_cmac(keyID, blocks[i].Buffer)\n *\n * \\param[IN]  micBxBuffer    - Buffer containing the initial Bx block\n * \\param[IN]  buffer         - Data buffer\n * \\param[IN]  size           - Data buffer size\n * \\param[IN]  keyID          - Key identifier to determine the AES key to be used\n * \\param[OUT] cmac           - Computed cmac\n * \\retval                    - Status of the operation\n */\nstatic SecureElementStatus_t ComputeCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,\n                                          uint32_t* cmac )\n{\n    if( ( buffer == NULL ) || ( cmac == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    uint8_t Cmac[16];\n\n    AES_CMAC_Init( SeNvmCtx.AesCmacCtx );\n\n    Key_t*                keyItem;\n    SecureElementStatus_t retval = GetKeyByID( keyID, &keyItem );\n\n    if( retval == SECURE_ELEMENT_SUCCESS )\n    {\n        AES_CMAC_SetKey( SeNvmCtx.AesCmacCtx, keyItem->KeyValue );\n\n        if( micBxBuffer != NULL )\n        {\n            AES_CMAC_Update( SeNvmCtx.AesCmacCtx, micBxBuffer, 16 );\n        }\n\n        AES_CMAC_Update( SeNvmCtx.AesCmacCtx, buffer, size );\n\n        AES_CMAC_Final( Cmac, SeNvmCtx.AesCmacCtx );\n\n        // Bring into the required format\n        *cmac = ( uint32_t )( ( uint32_t ) Cmac[3] << 24 | ( uint32_t ) Cmac[2] << 16 | ( uint32_t ) Cmac[1] << 8 |\n                              ( uint32_t ) Cmac[0] );\n    }\n\n    return retval;\n}\n\n/*\n * API functions\n */\n\nSecureElementStatus_t SecureElementInit( SecureElementNvmEvent seNvmCtxChanged )\n{\n    // Assign callback\n    if( seNvmCtxChanged != 0 )\n    {\n        SeNvmCtxChanged = seNvmCtxChanged;\n    }\n    else\n    {\n        SeNvmCtxChanged = DummyCB;\n    }\n\n#if !defined( SECURE_ELEMENT_PRE_PROVISIONED )\n#if( STATIC_DEVICE_EUI == 0 )\n    // Get a DevEUI from MCU unique ID\n    SoftSeHalGetUniqueId( SeNvmCtx.DevEui );\n#endif\n#endif\n\n    SeNvmCtxChanged( );\n\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementRestoreNvmCtx( void* seNvmCtx )\n{\n    // Restore nvm context\n    if( seNvmCtx != 0 )\n    {\n        memcpy1( ( uint8_t* ) &SeNvmCtx, ( uint8_t* ) seNvmCtx, sizeof( SeNvmCtx ) );\n        return SECURE_ELEMENT_SUCCESS;\n    }\n    else\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n}\n\nvoid* SecureElementGetNvmCtx( size_t* seNvmCtxSize )\n{\n    *seNvmCtxSize = sizeof( SeNvmCtx );\n    return &SeNvmCtx;\n}\n\nSecureElementStatus_t SecureElementSetKey( KeyIdentifier_t keyID, uint8_t* key )\n{\n    if( key == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )\n    {\n        if( SeNvmCtx.KeyList[i].KeyID == keyID )\n        {\n            if( ( keyID == MC_KEY_0 ) || ( keyID == MC_KEY_1 ) || ( keyID == MC_KEY_2 ) || ( keyID == MC_KEY_3 ) )\n            {  // Decrypt the key if its a Mckey\n                SecureElementStatus_t retval           = SECURE_ELEMENT_ERROR;\n                uint8_t               decryptedKey[16] = { 0 };\n\n                retval = SecureElementAesEncrypt( key, 16, MC_KE_KEY, decryptedKey );\n\n                memcpy1( SeNvmCtx.KeyList[i].KeyValue, decryptedKey, SE_KEY_SIZE );\n                SeNvmCtxChanged( );\n\n                return retval;\n            }\n            else\n            {\n                memcpy1( SeNvmCtx.KeyList[i].KeyValue, key, SE_KEY_SIZE );\n                SeNvmCtxChanged( );\n                return SECURE_ELEMENT_SUCCESS;\n            }\n        }\n    }\n\n    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n}\n\nSecureElementStatus_t SecureElementComputeAesCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size,\n                                                   KeyIdentifier_t keyID, uint32_t* cmac )\n{\n    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )\n    {\n        // Never accept multicast key identifier for cmac computation\n        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n    }\n\n    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );\n}\n\nSecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,\n                                                  KeyIdentifier_t keyID )\n{\n    if( buffer == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    SecureElementStatus_t retval   = SECURE_ELEMENT_ERROR;\n    uint32_t              compCmac = 0;\n    retval                         = ComputeCmac( NULL, buffer, size, keyID, &compCmac );\n    if( retval != SECURE_ELEMENT_SUCCESS )\n    {\n        return retval;\n    }\n\n    if( expectedCmac != compCmac )\n    {\n        retval = SECURE_ELEMENT_FAIL_CMAC;\n    }\n\n    return retval;\n}\n\nSecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,\n                                               uint8_t* encBuffer )\n{\n    if( buffer == NULL || encBuffer == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Check if the size is divisible by 16,\n    if( ( size % 16 ) != 0 )\n    {\n        return SECURE_ELEMENT_ERROR_BUF_SIZE;\n    }\n\n    memset1( SeNvmCtx.AesContext.ksch, '\\0', 240 );\n\n    Key_t*                pItem;\n    SecureElementStatus_t retval = GetKeyByID( keyID, &pItem );\n\n    if( retval == SECURE_ELEMENT_SUCCESS )\n    {\n        aes_set_key( pItem->KeyValue, 16, &SeNvmCtx.AesContext );\n\n        uint8_t block = 0;\n\n        while( size != 0 )\n        {\n            aes_encrypt( &buffer[block], &encBuffer[block], &SeNvmCtx.AesContext );\n            block = block + 16;\n            size  = size - 16;\n        }\n    }\n    return retval;\n}\n\nSecureElementStatus_t SecureElementDeriveAndStoreKey( Version_t version, uint8_t* input, KeyIdentifier_t rootKeyID,\n                                                      KeyIdentifier_t targetKeyID )\n{\n    if( input == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;\n    uint8_t               key[16] = { 0 };\n\n    // In case of MC_KE_KEY, only McRootKey can be used as root key\n    if( targetKeyID == MC_KE_KEY )\n    {\n        if( rootKeyID != MC_ROOT_KEY )\n        {\n            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;\n        }\n    }\n\n    // Derive key\n    retval = SecureElementAesEncrypt( input, 16, rootKeyID, key );\n    if( retval != SECURE_ELEMENT_SUCCESS )\n    {\n        return retval;\n    }\n\n    // Store key\n    retval = SecureElementSetKey( targetKeyID, key );\n    if( retval != SECURE_ELEMENT_SUCCESS )\n    {\n        return retval;\n    }\n\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,\n                                                      uint16_t devNonce, uint8_t* encJoinAccept,\n                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,\n                                                      uint8_t* versionMinor )\n{\n    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    // Check that frame size isn't bigger than a JoinAccept with CFList size\n    if( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE )\n    {\n        return SECURE_ELEMENT_ERROR_BUF_SIZE;\n    }\n\n    // Determine decryption key\n    KeyIdentifier_t encKeyID = NWK_KEY;\n\n    if( joinReqType != JOIN_REQ )\n    {\n        encKeyID = J_S_ENC_KEY;\n    }\n\n    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );\n\n    // Decrypt JoinAccept, skip MHDR\n    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,\n                                 encKeyID, decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS )\n    {\n        return SECURE_ELEMENT_FAIL_ENCRYPT;\n    }\n\n    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;\n\n    uint32_t mic = 0;\n\n    mic = ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE] << 0 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1] << 8 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );\n    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );\n\n    //  - Header buffer to be used for MIC computation\n    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]\n    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]\n\n    // Verify mic\n    if( *versionMinor == 0 )\n    {\n        // For LoRaWAN 1.0.x\n        //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |\n        //   CFListType)\n        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=\n            SECURE_ELEMENT_SUCCESS )\n        {\n            return SECURE_ELEMENT_FAIL_CMAC;\n        }\n    }\n#if( USE_LRWAN_1_1_X_CRYPTO == 1 )\n    else if( *versionMinor == 1 )\n    {\n        uint8_t  micHeader11[JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n        uint16_t bufItr                                          = 0;\n\n        micHeader11[bufItr++] = ( uint8_t ) joinReqType;\n\n        memcpyr( micHeader11 + bufItr, joinEui, LORAMAC_JOIN_EUI_FIELD_SIZE );\n        bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;\n\n        micHeader11[bufItr++] = devNonce & 0xFF;\n        micHeader11[bufItr++] = ( devNonce >> 8 ) & 0xFF;\n\n        // For LoRaWAN 1.1.x and later:\n        //   cmac = aes128_cmac(JSIntKey, JoinReqType | JoinEUI | DevNonce | MHDR | JoinNonce | NetID | DevAddr |\n        //   DLSettings | RxDelay | CFList | CFListType)\n        // Prepare the msg for integrity check (adding JoinReqType, JoinEUI and DevNonce)\n        uint8_t localBuffer[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET] = { 0 };\n\n        memcpy1( localBuffer, micHeader11, JOIN_ACCEPT_MIC_COMPUTATION_OFFSET );\n        memcpy1( localBuffer + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET - 1, decJoinAccept, encJoinAcceptSize );\n\n        if( SecureElementVerifyAesCmac( localBuffer,\n                                        encJoinAcceptSize + JOIN_ACCEPT_MIC_COMPUTATION_OFFSET -\n                                            LORAMAC_MHDR_FIELD_SIZE - LORAMAC_MIC_FIELD_SIZE,\n                                        mic, J_S_INT_KEY ) != SECURE_ELEMENT_SUCCESS )\n        {\n            return SECURE_ELEMENT_FAIL_CMAC;\n        }\n    }\n#endif\n    else\n    {\n        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;\n    }\n\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementRandomNumber( uint32_t* randomNum )\n{\n    if( randomNum == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    *randomNum = SoftSeHalGetRandomNumber( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nSecureElementStatus_t SecureElementSetDevEui( uint8_t* devEui )\n{\n    if( devEui == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    memcpy1( SeNvmCtx.DevEui, devEui, SE_EUI_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetDevEui( void )\n{\n    return SeNvmCtx.DevEui;\n}\n\nSecureElementStatus_t SecureElementSetJoinEui( uint8_t* joinEui )\n{\n    if( joinEui == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n    memcpy1( SeNvmCtx.JoinEui, joinEui, SE_EUI_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetJoinEui( void )\n{\n    return SeNvmCtx.JoinEui;\n}\n\nSecureElementStatus_t SecureElementSetPin( uint8_t* pin )\n{\n    if( pin == NULL )\n    {\n        return SECURE_ELEMENT_ERROR_NPE;\n    }\n\n    memcpy1( SeNvmCtx.Pin, pin, SE_PIN_SIZE );\n    SeNvmCtxChanged( );\n    return SECURE_ELEMENT_SUCCESS;\n}\n\nuint8_t* SecureElementGetPin( void )\n{\n    return SeNvmCtx.Pin;\n}\n"], "buggy_code_start_loc": [999, 501, 292, 397], "buggy_code_end_loc": [1072, 501, 292, 397], "fixing_code_start_loc": [1000, 502, 293, 398], "fixing_code_end_loc": [1080, 508, 299, 404], "type": "CWE-120", "message": "In LoRaMac-node before 4.4.4, a reception buffer overflow can happen due to the received buffer size not being checked. This has been fixed in 4.4.4.", "other": {"cve": {"id": "CVE-2020-11068", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-23T17:15:11.500", "lastModified": "2020-07-01T18:38:14.077", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In LoRaMac-node before 4.4.4, a reception buffer overflow can happen due to the received buffer size not being checked. This has been fixed in 4.4.4."}, {"lang": "es", "value": "En el nodo LoRaMac versiones anteriores a 4.4.4, un desbordamiento del b\u00fafer de recepci\u00f3n puede presentarse debido a que no es comprobado el tama\u00f1o del b\u00fafer recibido. Esto ha sido corregido en la versi\u00f3n 4.4.4"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:semtech:loramac-node:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.4.4", "matchCriteriaId": "285BEBFB-4B3E-4537-910F-56180BD77544"}]}]}], "references": [{"url": "https://github.com/Lora-net/LoRaMac-node/commit/e3063a91daa7ad8a687223efa63079f0c24568e4", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Lora-net/LoRaMac-node/security/advisories/GHSA-559p-6xgm-fpv9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Lora-net/LoRaMac-node/commit/e3063a91daa7ad8a687223efa63079f0c24568e4"}}