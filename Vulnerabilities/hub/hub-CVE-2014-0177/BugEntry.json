{"buggy_code": ["module Hub\n  # The Commands module houses the git commands that hub\n  # lovingly wraps. If a method exists here, it is expected to have a\n  # corresponding git command which either gets run before or after\n  # the method executes.\n  #\n  # The typical flow is as follows:\n  #\n  # 1. hub is invoked from the command line:\n  #    $ hub clone rtomayko/tilt\n  #\n  # 2. The Runner class is initialized:\n  #    >> Hub::Runner.new('clone', 'rtomayko/tilt')\n  #\n  # 3. The method representing the git subcommand is executed with the\n  #    full args:\n  #    >> Hub::Commands.clone(['clone', 'rtomayko/tilt'])\n  #\n  # 4. That method rewrites the args as it sees fit:\n  #    >> args[1] = \"git://github.com/\" + args[1] + \".git\"\n  #    => \"git://github.com/rtomayko/tilt.git\"\n  #\n  # 5. The new args are used to run `git`:\n  #    >> exec \"git\", \"clone\", \"git://github.com/rtomayko/tilt.git\"\n  #\n  # An optional `after` callback can be set. If so, it is run after\n  # step 5 (which then performs a `system` call rather than an\n  # `exec`). See `Hub::Args` for more information on the `after` callback.\n  module Commands\n    # We are a blank slate.\n    instance_methods.each { |m| undef_method(m) unless m =~ /(^__|send|to\\?$)/ }\n    extend self\n\n    # provides git interrogation methods\n    extend Context\n\n    NAME_RE = /[\\w.][\\w.-]*/\n    OWNER_RE = /[a-zA-Z0-9][a-zA-Z0-9-]*/\n    NAME_WITH_OWNER_RE = /^(?:#{NAME_RE}|#{OWNER_RE}\\/#{NAME_RE})$/\n\n    CUSTOM_COMMANDS = %w[alias create browse compare fork pull-request ci-status]\n\n    def run(args)\n      slurp_global_flags(args)\n\n      # Hack to emulate git-style\n      args.unshift 'help' if args.empty?\n\n      cmd = args[0]\n      if expanded_args = expand_alias(cmd)\n        cmd = expanded_args[0]\n        expanded_args.concat args[1..-1]\n      end\n\n      respect_help_flags(expanded_args || args) if custom_command? cmd\n\n      # git commands can have dashes\n      cmd = cmd.gsub(/(\\w)-/, '\\1_')\n      if method_defined?(cmd) and cmd != 'run'\n        args.replace expanded_args if expanded_args\n        send(cmd, args)\n      end\n    rescue Errno::ENOENT\n      if $!.message.include? \"No such file or directory - git\"\n        abort \"Error: `git` command not found\"\n      else\n        raise\n      end\n    rescue Context::FatalError => err\n      abort \"fatal: #{err.message}\"\n    end\n\n\n    # $ hub ci-status\n    # $ hub ci-status 6f6d9797f9d6e56c3da623a97cfc3f45daf9ae5f\n    # $ hub ci-status master\n    # $ hub ci-status origin/master\n    def ci_status(args)\n      args.shift\n      ref = args.words.first || 'HEAD'\n      verbose = args.include?('-v')\n\n      unless project = local_repo.main_project\n        abort \"Aborted: the origin remote doesn't point to a GitHub repository.\"\n      end\n\n      unless sha = local_repo.git_command(\"rev-parse -q #{ref}\")\n        abort \"Aborted: no revision could be determined from '#{ref}'\"\n      end\n\n      statuses = api_client.statuses(project, sha)\n      status = statuses.first\n      if status\n        ref_state = status['state']\n        ref_target_url = status['target_url']\n      else\n        ref_state = 'no status'\n        ref_target_url = nil\n      end\n\n      exit_code = case ref_state\n        when 'success'          then 0\n        when 'failure', 'error' then 1\n        when 'pending'          then 2\n        else 3\n        end\n\n      if verbose and ref_target_url\n        $stdout.puts \"%s: %s\" % [ref_state, ref_target_url]\n      else\n        $stdout.puts ref_state\n      end\n      exit exit_code\n    rescue GitHubAPI::Exceptions\n      response = $!.response\n      display_api_exception(\"fetching CI status\", response)\n      exit 1\n    end\n\n    # $ hub pull-request\n    # $ hub pull-request \"My humble contribution\"\n    # $ hub pull-request https://github.com/rtomayko/tilt/issues/92\n    def pull_request(args)\n      args.shift\n      options = { }\n      force = explicit_owner = false\n      base_project = local_repo.main_project\n      tracked_branch, head_project = remote_branch_and_project(method(:github_user))\n\n      unless current_branch\n        abort \"Aborted: not currently on any branch.\"\n      end\n\n      unless base_project\n        abort \"Aborted: the origin remote doesn't point to a GitHub repository.\"\n      end\n\n      from_github_ref = lambda do |ref, context_project|\n        if ref.index(':')\n          owner, ref = ref.split(':', 2)\n          project = github_project(context_project.name, owner)\n        end\n        [project || context_project, ref]\n      end\n\n      while arg = args.shift\n        case arg\n        when '-f'\n          force = true\n        when '-F', '--file'\n          file = args.shift\n          text = file == '-' ? $stdin.read : File.read(file)\n          options[:title], options[:body] = read_msg(text)\n        when '-m', '--message'\n          text = args.shift\n          options[:title], options[:body] = read_msg(text)\n        when '-b'\n          base_project, options[:base] = from_github_ref.call(args.shift, base_project)\n        when '-h'\n          head = args.shift\n          explicit_owner = !!head.index(':')\n          head_project, options[:head] = from_github_ref.call(head, head_project)\n        when '-i'\n          options[:issue] = args.shift\n        when '-o', '--browse'\n          open_with_browser = true\n        else\n          if url = resolve_github_url(arg) and url.project_path =~ /^issues\\/(\\d+)/\n            options[:issue] = $1\n            base_project = url.project\n          elsif !options[:title] && arg.index('-') != 0\n            options[:title] = arg\n            warn \"hub: Specifying pull request title without a flag is deprecated.\"\n            warn \"Please use one of `-m' or `-F' options.\"\n          else\n            abort \"invalid argument: #{arg}\"\n          end\n        end\n      end\n\n      if options[:issue]\n        warn \"Warning: Issue to pull request conversion is deprecated and might not work in the future.\"\n      end\n\n      options[:project] = base_project\n      options[:base] ||= master_branch.short_name\n\n      if options[:head].nil? && tracked_branch\n        if !tracked_branch.remote?\n          # The current branch is tracking another local branch. Pretend there is\n          # no upstream configuration at all.\n          tracked_branch = nil\n        elsif base_project == head_project and tracked_branch.short_name == options[:base]\n          $stderr.puts \"Aborted: head branch is the same as base (#{options[:base].inspect})\"\n          warn \"(use `-h <branch>` to specify an explicit pull request head)\"\n          abort\n        end\n      end\n      options[:head] ||= (tracked_branch || current_branch).short_name\n\n      remote_branch = \"#{head_project.remote}/#{options[:head]}\"\n      options[:head] = \"#{head_project.owner}:#{options[:head]}\"\n\n      if !force and tracked_branch and local_commits = rev_list(remote_branch, nil)\n        $stderr.puts \"Aborted: #{local_commits.split(\"\\n\").size} commits are not yet pushed to #{remote_branch}\"\n        warn \"(use `-f` to force submit a pull request anyway)\"\n        abort\n      end\n\n      if args.noop?\n        puts \"Would request a pull to #{base_project.owner}:#{options[:base]} from #{options[:head]}\"\n        exit\n      end\n\n      unless options[:title] or options[:issue]\n        base_branch = \"#{base_project.remote}/#{options[:base]}\"\n        commits = rev_list(base_branch, remote_branch).to_s.split(\"\\n\")\n\n        case commits.size\n        when 0\n          default_message = commit_summary = nil\n        when 1\n          format = '%w(78,0,0)%s%n%+b'\n          default_message = git_command \"show -s --format='#{format}' #{commits.first}\"\n          commit_summary = nil\n        else\n          format = '%h (%aN, %ar)%n%w(78,3,3)%s%n%+b'\n          default_message = nil\n          commit_summary = git_command \"log --no-color --format='%s' --cherry %s...%s\" %\n            [format, base_branch, remote_branch]\n        end\n\n        options[:title], options[:body] = pullrequest_editmsg(commit_summary) { |msg, initial_message|\n          initial_message ||= default_message\n          msg.puts initial_message if initial_message\n          msg.puts \"\"\n          msg.puts \"# Requesting a pull to #{base_project.owner}:#{options[:base]} from #{options[:head]}\"\n          msg.puts \"#\"\n          msg.puts \"# Write a message for this pull request. The first block\"\n          msg.puts \"# of text is the title and the rest is description.\"\n        }\n      end\n\n      pull = api_client.create_pullrequest(options)\n\n      args.push('-u') unless open_with_browser\n      browse_command(args) do\n        pull['html_url']\n      end\n    rescue GitHubAPI::Exceptions\n      response = $!.response\n      display_api_exception(\"creating pull request\", response)\n      if 404 == response.status\n        base_url = base_project.web_url.split('://', 2).last\n        warn \"Are you sure that #{base_url} exists?\"\n      end\n      exit 1\n    else\n      delete_editmsg\n    end\n\n    # $ hub e-note\n    # $ hub e-note \"My humble contribution\"\n    # $ hub e-note -i 92\n    # $ hub e-note https://github.com/rtomayko/tilt/issues/92\n    alias_method :e_note, :pull_request\n\n    # $ hub clone rtomayko/tilt\n    # > git clone git://github.com/rtomayko/tilt.\n    #\n    # $ hub clone -p kneath/hemingway\n    # > git clone git@github.com:kneath/hemingway.git\n    #\n    # $ hub clone tilt\n    # > git clone git://github.com/YOUR_LOGIN/tilt.\n    #\n    # $ hub clone -p github\n    # > git clone git@github.com:YOUR_LOGIN/hemingway.git\n    def clone(args)\n      ssh = args.delete('-p')\n      has_values = /^(--(upload-pack|template|depth|origin|branch|reference|name)|-[ubo])$/\n\n      idx = 1\n      while idx < args.length\n        arg = args[idx]\n        if arg.index('-') == 0\n          idx += 1 if arg =~ has_values\n        else\n          # $ hub clone rtomayko/tilt\n          # $ hub clone tilt\n          if arg =~ NAME_WITH_OWNER_RE and !File.directory?(arg)\n            name, owner = arg, nil\n            owner, name = name.split('/', 2) if name.index('/')\n            project = github_project(name, owner || github_user)\n            unless ssh || args[0] == 'submodule' || args.noop? || https_protocol?\n              repo_info = api_client.repo_info(project)\n              ssh = repo_info.success? && (repo_info.data['private'] || repo_info.data['permissions']['push'])\n            end\n            args[idx] = project.git_url(:private => ssh, :https => https_protocol?)\n          end\n          break\n        end\n        idx += 1\n      end\n    end\n\n    # $ hub submodule add wycats/bundler vendor/bundler\n    # > git submodule add git://github.com/wycats/bundler.git vendor/bundler\n    #\n    # $ hub submodule add -p wycats/bundler vendor/bundler\n    # > git submodule add git@github.com:wycats/bundler.git vendor/bundler\n    #\n    # $ hub submodule add -b ryppl --name pip ryppl/pip vendor/pip\n    # > git submodule add -b ryppl --name pip git://github.com/ryppl/pip.git vendor/pip\n    def submodule(args)\n      return unless index = args.index('add')\n      args.delete_at index\n\n      clone(args)\n      args.insert index, 'add'\n    end\n\n    # $ hub remote add pjhyett\n    # > git remote add pjhyett git://github.com/pjhyett/THIS_REPO.git\n    #\n    # $ hub remote add -p mojombo\n    # > git remote add mojombo git@github.com:mojombo/THIS_REPO.git\n    #\n    # $ hub remote add origin\n    # > git remote add origin git://github.com/YOUR_LOGIN/THIS_REPO.git\n    def remote(args)\n      if %w[add set-url].include?(args[1])\n        name = args.last\n        if name =~ /^(#{OWNER_RE})$/ || name =~ /^(#{OWNER_RE})\\/(#{NAME_RE})$/\n          user, repo = $1, $2 || repo_name\n        end\n      end\n      return unless user # do not touch arguments\n\n      ssh = args.delete('-p')\n\n      if args.words[2] == 'origin' && args.words[3].nil?\n        # Origin special case triggers default user/repo\n        user, repo = github_user, repo_name\n      elsif args.words[-2] == args.words[1]\n        # rtomayko/tilt => rtomayko\n        # Make sure you dance around flags.\n        idx = args.index( args.words[-1] )\n        args[idx] = user\n      else\n        # They're specifying the remote name manually (e.g.\n        # git remote add blah rtomayko/tilt), so just drop the last\n        # argument.\n        args.pop\n      end\n\n      args << git_url(user, repo, :private => ssh)\n    end\n\n    # $ hub fetch mislav\n    # > git remote add mislav git://github.com/mislav/REPO.git\n    # > git fetch mislav\n    #\n    # $ hub fetch --multiple mislav xoebus\n    # > git remote add mislav ...\n    # > git remote add xoebus ...\n    # > git fetch --multiple mislav xoebus\n    def fetch(args)\n      # $ hub fetch --multiple <name1>, <name2>, ...\n      if args.include?('--multiple')\n        names = args.words[1..-1]\n      # $ hub fetch <name>\n      elsif remote_name = args.words[1]\n        # $ hub fetch <name1>,<name2>,...\n        if remote_name =~ /^\\w+(,\\w+)+$/\n          index = args.index(remote_name)\n          args.delete(remote_name)\n          names = remote_name.split(',')\n          args.insert(index, *names)\n          args.insert(index, '--multiple')\n        else\n          names = [remote_name]\n        end\n      else\n        names = []\n      end\n\n      projects = names.map { |name|\n        unless name !~ /^#{OWNER_RE}$/ or remotes.include?(name) or remotes_group(name)\n          project = github_project(nil, name)\n          repo_info = api_client.repo_info(project)\n          if repo_info.success?\n            project.repo_data = repo_info.data\n            project\n          end\n        end\n      }.compact\n\n      if projects.any?\n        projects.each do |project|\n          args.before ['remote', 'add', project.owner, project.git_url(:https => https_protocol?)]\n        end\n      end\n    end\n\n    # $ git checkout https://github.com/defunkt/hub/pull/73\n    # > git remote add -f -t feature git://github:com/mislav/hub.git\n    # > git checkout --track -B mislav-feature mislav/feature\n    def checkout(args)\n      _, url_arg, new_branch_name = args.words\n      if url = resolve_github_url(url_arg) and url.project_path =~ /^pull\\/(\\d+)/\n        pull_id = $1\n        pull_data = api_client.pullrequest_info(url.project, pull_id)\n\n        args.delete new_branch_name\n        user, branch = pull_data['head']['label'].split(':', 2)\n        abort \"Error: #{user}'s fork is not available anymore\" unless pull_data['head']['repo']\n        new_branch_name ||= \"#{user}-#{branch}\"\n\n        if remotes.include? user\n          args.before ['remote', 'set-branches', '--add', user, branch]\n          args.before ['fetch', user, \"+refs/heads/#{branch}:refs/remotes/#{user}/#{branch}\"]\n        else\n          url = github_project(url.project_name, user).git_url(:private => pull_data['head']['repo']['private'],\n                                                               :https => https_protocol?)\n          args.before ['remote', 'add', '-f', '-t', branch, user, url]\n        end\n        idx = args.index url_arg\n        args.delete_at idx\n        args.insert idx, '--track', '-B', new_branch_name, \"#{user}/#{branch}\"\n      end\n    end\n\n    # $ git merge https://github.com/defunkt/hub/pull/73\n    # > git fetch git://github.com/mislav/hub.git +refs/heads/feature:refs/remotes/mislav/feature\n    # > git merge mislav/feature --no-ff -m 'Merge pull request #73 from mislav/feature...'\n    def merge(args)\n      _, url_arg = args.words\n      if url = resolve_github_url(url_arg) and url.project_path =~ /^pull\\/(\\d+)/\n        pull_id = $1\n        pull_data = api_client.pullrequest_info(url.project, pull_id)\n\n        user, branch = pull_data['head']['label'].split(':', 2)\n        abort \"Error: #{user}'s fork is not available anymore\" unless pull_data['head']['repo']\n\n        repo_name = pull_data['head']['repo']['name']\n        url = github_project(repo_name, user).git_url(:private => pull_data['head']['repo']['private'],\n                                                      :https => https_protocol?)\n\n        merge_head = \"#{user}/#{branch}\"\n        args.before ['fetch', url, \"+refs/heads/#{branch}:refs/remotes/#{merge_head}\"]\n\n        idx = args.index url_arg\n        args.delete_at idx\n        args.insert idx, merge_head, '-m', \"Merge pull request ##{pull_id} from #{merge_head}\\n\\n#{pull_data['title']}\"\n        idx = args.index '-m'\n        args.insert idx, '--no-ff' unless args.include?('--ff-only')\n      end\n    end\n\n    # $ git cherry-pick http://github.com/mislav/hub/commit/a319d88#comments\n    # > git remote add -f mislav git://github.com/mislav/hub.git\n    # > git cherry-pick a319d88\n    #\n    # $ git cherry-pick mislav@a319d88\n    # > git remote add -f mislav git://github.com/mislav/hub.git\n    # > git cherry-pick a319d88\n    #\n    # $ git cherry-pick mislav@SHA\n    # > git fetch mislav\n    # > git cherry-pick SHA\n    def cherry_pick(args)\n      unless args.include?('-m') or args.include?('--mainline')\n        ref = args.words.last\n        if url = resolve_github_url(ref) and url.project_path =~ /^commit\\/([a-f0-9]{7,40})/\n          sha = $1\n          project = url.project\n        elsif ref =~ /^(#{OWNER_RE})@([a-f0-9]{7,40})$/\n          owner, sha = $1, $2\n          project = local_repo.main_project.owned_by(owner)\n        end\n\n        if project\n          args[args.index(ref)] = sha\n\n          if remote = project.remote and remotes.include? remote\n            args.before ['fetch', remote.to_s]\n          else\n            args.before ['remote', 'add', '-f', project.owner, project.git_url(:https => https_protocol?)]\n          end\n        end\n      end\n    end\n\n    # $ hub am https://github.com/defunkt/hub/pull/55\n    # ... downloads patch via API ...\n    # > git am /tmp/55.patch\n    def am(args)\n      if url = args.find { |a| a =~ %r{^https?://(gist\\.)?github\\.com/} }\n        idx = args.index(url)\n        if $1 == 'gist.'\n          path_parts = $'.sub(/#.*/, '').split('/')\n          gist_id = path_parts.last\n          patch_name = \"gist-#{gist_id}.txt\"\n          patch = api_client.gist_raw(gist_id)\n        else\n          gh_url = resolve_github_url(url)\n          case gh_url.project_path\n          when /^pull\\/(\\d+)/\n            pull_id = $1.to_i\n            patch_name = \"#{pull_id}.patch\"\n            patch = api_client.pullrequest_patch(gh_url.project, pull_id)\n          when /^commit\\/([a-f0-9]{7,40})/\n            commit_sha = $1\n            patch_name = \"#{commit_sha}.patch\"\n            patch = api_client.commit_patch(gh_url.project, commit_sha)\n          else\n            raise ArgumentError, url\n          end\n        end\n\n        patch_file = File.join(tmp_dir, patch_name)\n        File.open(patch_file, 'w') { |file| file.write(patch) }\n        args[idx] = patch_file\n      end\n    end\n\n    # $ hub apply https://github.com/defunkt/hub/pull/55\n    # ... downloads patch via API ...\n    # > git apply /tmp/55.patch\n    alias_method :apply, :am\n\n    # $ hub init -g\n    # > git init\n    # > git remote add origin git@github.com:USER/REPO.git\n    def init(args)\n      if args.delete('-g')\n        project = github_project(File.basename(current_dir))\n        url = project.git_url(:private => true, :https => https_protocol?)\n        args.after ['remote', 'add', 'origin', url]\n      end\n    end\n\n    # $ hub fork\n    # ... hardcore forking action ...\n    # > git remote add -f YOUR_USER git@github.com:YOUR_USER/CURRENT_REPO.git\n    def fork(args)\n      unless project = local_repo.main_project\n        abort \"Error: repository under 'origin' remote is not a GitHub project\"\n      end\n      forked_project = project.owned_by(github_user(project.host))\n\n      existing_repo = api_client.repo_info(forked_project)\n      if existing_repo.success?\n        parent_data = existing_repo.data['parent']\n        parent_url  = parent_data && resolve_github_url(parent_data['html_url'])\n        if !parent_url or parent_url.project != project\n          abort \"Error creating fork: %s already exists on %s\" %\n            [ forked_project.name_with_owner, forked_project.host ]\n        end\n      else\n        api_client.fork_repo(project) unless args.noop?\n      end\n\n      if args.include?('--no-remote')\n        exit\n      else\n        origin_url = project.remote.github_url\n        url = forked_project.git_url(:private => true, :https => https_protocol?)\n        args.replace %W\"remote add -f #{forked_project.owner} #{origin_url}\"\n        args.after %W\"remote set-url #{forked_project.owner} #{url}\"\n        args.after 'echo', ['new remote:', forked_project.owner]\n      end\n    rescue GitHubAPI::Exceptions\n      display_api_exception(\"creating fork\", $!.response)\n      exit 1\n    end\n\n    # $ hub create\n    # ... create repo on github ...\n    # > git remote add -f origin git@github.com:YOUR_USER/CURRENT_REPO.git\n    def create(args)\n      if !is_repo?\n        abort \"'create' must be run from inside a git repository\"\n      else\n        owner = github_user\n        args.shift\n        options = {}\n        options[:private] = true if args.delete('-p')\n        new_repo_name = nil\n\n        until args.empty?\n          case arg = args.shift\n          when '-d'\n            options[:description] = args.shift\n          when '-h'\n            options[:homepage] = args.shift\n          else\n            if arg =~ /^[^-]/ and new_repo_name.nil?\n              new_repo_name = arg\n              owner, new_repo_name = new_repo_name.split('/', 2) if new_repo_name.index('/')\n            else\n              abort \"invalid argument: #{arg}\"\n            end\n          end\n        end\n        new_repo_name ||= repo_name\n        new_project = github_project(new_repo_name, owner)\n\n        if api_client.repo_exists?(new_project)\n          warn \"#{new_project.name_with_owner} already exists on #{new_project.host}\"\n          action = \"set remote origin\"\n        else\n          action = \"created repository\"\n          unless args.noop?\n            repo_data = api_client.create_repo(new_project, options)\n            new_project = github_project(repo_data['full_name'])\n          end\n        end\n\n        url = new_project.git_url(:private => true, :https => https_protocol?)\n\n        if remotes.first != 'origin'\n          args.replace %W\"remote add -f origin #{url}\"\n        else\n          args.replace %W\"remote -v\"\n        end\n\n        args.after 'echo', [\"#{action}:\", new_project.name_with_owner]\n      end\n    rescue GitHubAPI::Exceptions\n      display_api_exception(\"creating repository\", $!.response)\n      exit 1\n    end\n\n    # $ hub push origin,staging cool-feature\n    # > git push origin cool-feature\n    # > git push staging cool-feature\n    def push(args)\n      return if args[1].nil? || !args[1].index(',')\n\n      refs    = args.words[2..-1]\n      remotes = args[1].split(',')\n      args[1] = remotes.shift\n\n      if refs.empty?\n        # add current branch as explicit ref when there are no refs specified\n        refs = [current_branch.short_name]\n        args.concat refs\n      end\n\n      remotes.each do |name|\n        args.after ['push', name, *refs]\n      end\n    end\n\n    # $ hub browse\n    # > open https://github.com/CURRENT_REPO\n    #\n    # $ hub browse -- issues\n    # > open https://github.com/CURRENT_REPO/issues\n    #\n    # $ hub browse pjhyett/github-services\n    # > open https://github.com/pjhyett/github-services\n    #\n    # $ hub browse github-services\n    # > open https://github.com/YOUR_LOGIN/github-services\n    #\n    # $ hub browse github-services wiki\n    # > open https://github.com/YOUR_LOGIN/github-services/wiki\n    def browse(args)\n      args.shift\n      browse_command(args) do\n        dest = args.shift\n        dest = nil if dest == '--'\n        # $ hub browse -- wiki\n        subpage = args.shift\n\n        if dest\n          # $ hub browse pjhyett/github-services\n          # $ hub browse github-services\n          project = github_project dest\n          branch = master_branch\n        elsif subpage && !%w[commits tree blob settings].include?(subpage)\n          branch = master_branch\n          project = local_repo.main_project\n        else\n          # $ hub browse\n          prefer_upstream = current_branch.master?\n          branch, project = remote_branch_and_project(method(:github_user), prefer_upstream)\n          branch ||= master_branch\n        end\n\n        abort \"Usage: hub browse [<USER>/]<REPOSITORY>\" unless project\n\n        path = case subpage\n        when 'commits'\n          \"/commits/#{branch_in_url(branch)}\"\n        when 'tree', NilClass\n          \"/tree/#{branch_in_url(branch)}\" if branch and !branch.master?\n        else\n          \"/#{subpage}\"\n        end\n\n        project.web_url(path, api_client.config.method(:protocol))\n      end\n    end\n\n    # $ hub compare 1.0..fix\n    # > open https://github.com/CURRENT_REPO/compare/1.0...fix\n    # $ hub compare refactor\n    # > open https://github.com/CURRENT_REPO/compare/refactor\n    # $ hub compare myfork feature\n    # > open https://github.com/myfork/REPO/compare/feature\n    # $ hub compare -u 1.0...2.0\n    # \"https://github.com/CURRENT_REPO/compare/1.0...2.0\"\n    def compare(args)\n      args.shift\n      browse_command(args) do\n        branch, project = remote_branch_and_project(method(:github_user))\n        if args.empty?\n          if branch and not branch.master?\n            range = branch.short_name\n          else\n            abort \"Usage: hub compare [USER] [<START>...]<END>\"\n          end\n        else\n          sha_or_tag = /((?:#{OWNER_RE}:)?\\w[\\w.-]+\\w)/\n          # replaces two dots with three: \"sha1...sha2\"\n          range = args.pop.sub(/^#{sha_or_tag}\\.\\.#{sha_or_tag}$/, '\\1...\\2')\n          if owner = args.pop\n            project = project.owned_by(owner)\n          end\n        end\n\n        path = '/compare/%s' % range.tr('/', ';')\n        project.web_url(path, api_client.config.method(:protocol))\n      end\n    end\n\n    # $ hub hub standalone\n    # Prints the \"standalone\" version of hub for an easy, memorable\n    # installation sequence:\n    #\n    # $ gem install hub\n    # $ hub hub standalone > ~/bin/hub && chmod 755 ~/bin/hub\n    # $ gem uninstall hub\n    def hub(args)\n      return help(args) unless args[1] == 'standalone'\n      require 'hub/standalone'\n      Hub::Standalone.build $stdout\n      exit\n    rescue LoadError\n      abort \"hub is already running in standalone mode.\"\n    rescue Errno::EPIPE\n      exit # ignore broken pipe\n    end\n\n    def alias(args)\n      shells = %w[bash zsh sh ksh csh fish]\n\n      script = !!args.delete('-s')\n      shell = args[1] || ENV['SHELL']\n      abort \"hub alias: unknown shell\" if shell.nil? or shell.empty?\n      shell = File.basename shell\n\n      unless shells.include? shell\n        $stderr.puts \"hub alias: unsupported shell\"\n        warn \"supported shells: #{shells.join(' ')}\"\n        abort\n      end\n\n      if script\n        puts \"alias git=hub\"\n      else\n        profile = case shell\n          when 'bash' then '~/.bash_profile'\n          when 'zsh'  then '~/.zshrc'\n          when 'ksh'  then '~/.profile'\n          when 'fish' then '~/.config/fish/config.fish'\n          else\n            'your profile'\n          end\n\n        puts \"# Wrap git automatically by adding the following to #{profile}:\"\n        puts\n        if shell == 'fish'\n          puts 'eval (hub alias -s)'\n        else\n          puts 'eval \"$(hub alias -s)\"'\n        end\n      end\n\n      exit\n    end\n\n    # $ hub version\n    # > git version\n    # (print hub version)\n    def version(args)\n      args.after 'echo', ['hub version', Version]\n    end\n    alias_method \"--version\", :version\n\n    # $ hub help\n    # (print improved help text)\n    def help(args)\n      command = args.words[1]\n\n      if command == 'hub' || custom_command?(command)\n        puts hub_manpage\n        exit\n      elsif command.nil?\n        if args.has_flag?('-a', '--all')\n          # Add the special hub commands to the end of \"git help -a\" output.\n          args.after 'echo', [\"\\nhub custom commands\\n\"]\n          args.after 'echo', CUSTOM_COMMANDS.map {|cmd| \"  #{cmd}\" }\n        else\n          ENV['GIT_PAGER'] = '' unless args.has_flag?('-p', '--paginate') # Use `cat`.\n          puts improved_help_text\n          exit\n        end\n      end\n    end\n    alias_method \"--help\", :help\n\n  private\n    #\n    # Helper methods are private so they cannot be invoked\n    # from the command line.\n    #\n\n    def branch_in_url(branch)\n      CGI.escape(branch.short_name).gsub(\"%2F\", \"/\")\n    end\n\n    def api_client\n      @api_client ||= begin\n        config_file = ENV['HUB_CONFIG'] || '~/.config/hub'\n        file_store = GitHubAPI::FileStore.new File.expand_path(config_file)\n        file_config = GitHubAPI::Configuration.new file_store\n        GitHubAPI.new file_config,\n          :app_url => 'http://hub.github.com/',\n          :verbose => !ENV['HUB_VERBOSE'].to_s.empty?\n      end\n    end\n\n    def github_user host = nil, &block\n      host ||= (local_repo(false) || Context::LocalRepo).default_host\n      api_client.username_via_auth_dance(host, &block)\n    end\n\n    def custom_command? cmd\n      CUSTOM_COMMANDS.include? cmd\n    end\n\n    # Show short usage help for `-h` flag, and open man page for `--help`\n    def respect_help_flags args\n      return if args.size > 2\n      case args[1]\n      when '-h'\n        pattern = /(git|hub) #{Regexp.escape args[0].gsub('-', '\\-')}/\n        hub_raw_manpage.each_line { |line|\n          if line =~ pattern\n            $stderr.print \"Usage: \"\n            $stderr.puts line.gsub(/\\\\f./, '').gsub('\\-', '-')\n            abort\n          end\n        }\n        abort \"Error: couldn't find usage help for #{args[0]}\"\n      when '--help'\n        puts hub_manpage\n        exit\n      end\n    end\n\n    # The text print when `hub help` is run, kept in its own method\n    # for the convenience of the author.\n    def improved_help_text\n      <<-help\nusage: git [--version] [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p|--paginate|--no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           [-c name=value] [--help]\n           <command> [<args>]\n\nBasic Commands:\n   init       Create an empty git repository or reinitialize an existing one\n   add        Add new or modified files to the staging area\n   rm         Remove files from the working directory and staging area\n   mv         Move or rename a file, a directory, or a symlink\n   status     Show the status of the working directory and staging area\n   commit     Record changes to the repository\n\nHistory Commands:\n   log        Show the commit history log\n   diff       Show changes between commits, commit and working tree, etc\n   show       Show information about commits, tags or files\n\nBranching Commands:\n   branch     List, create, or delete branches\n   checkout   Switch the active branch to another branch\n   merge      Join two or more development histories (branches) together\n   tag        Create, list, delete, sign or verify a tag object\n\nRemote Commands:\n   clone      Clone a remote repository into a new directory\n   fetch      Download data, tags and branches from a remote repository\n   pull       Fetch from and merge with another repository or a local branch\n   push       Upload data, tags and branches to a remote repository\n   remote     View and manage a set of remote repositories\n\nAdvanced Commands:\n   reset      Reset your staging area or working directory to another point\n   rebase     Re-apply a series of patches in one branch onto another\n   bisect     Find by binary search the change that introduced a bug\n   grep       Print files with lines matching a pattern in your codebase\n\nGitHub Commands:\n   pull-request   Open a pull request on GitHub\n   fork           Make a fork of a remote repository on GitHub and add as remote\n   create         Create this repository on GitHub and add GitHub as origin\n   browse         Open a GitHub page in the default browser\n   compare        Open a compare page on GitHub\n   ci-status      Show the CI status of a commit\n\nSee 'git help <command>' for more information on a specific command.\nhelp\n    end\n\n    # Extract global flags from the front of the arguments list.\n    # Makes sure important ones are supplied for calls to subcommands.\n    #\n    # Known flags are:\n    #   --version --exec-path=<path> --html-path\n    #   -p|--paginate|--no-pager --no-replace-objects\n    #   --bare --git-dir=<path> --work-tree=<path>\n    #   -c name=value --help\n    #\n    # Special: `--version`, `--help` are replaced with \"version\" and \"help\".\n    # Ignored: `--exec-path`, `--html-path` are kept in args list untouched.\n    def slurp_global_flags(args)\n      flags = %w[ --noop -c -p --paginate --no-pager --no-replace-objects --bare --version --help ]\n      flags2 = %w[ --exec-path= --git-dir= --work-tree= ]\n\n      # flags that should be present in subcommands, too\n      globals = []\n      # flags that apply only to main command\n      locals = []\n\n      while args[0] && (flags.include?(args[0]) || flags2.any? {|f| args[0].index(f) == 0 })\n        flag = args.shift\n        case flag\n        when '--noop'\n          args.noop!\n        when '--version', '--help'\n          args.unshift flag.sub('--', '')\n        when '-c'\n          # slurp one additional argument\n          config_pair = args.shift\n          # add configuration to our local cache\n          key, value = config_pair.split('=', 2)\n          git_reader.stub_config_value(key, value)\n\n          globals << flag << config_pair\n        when '-p', '--paginate', '--no-pager'\n          locals << flag\n        else\n          globals << flag\n        end\n      end\n\n      git_reader.add_exec_flags(globals)\n      args.add_exec_flags(globals)\n      args.add_exec_flags(locals)\n    end\n\n    # Handles common functionality of browser commands like `browse`\n    # and `compare`. Yields a block that returns params for `github_url`.\n    def browse_command(args)\n      url_only = args.delete('-u')\n      warn \"Warning: the `-p` flag has no effect anymore\" if args.delete('-p')\n      url = yield\n\n      args.executable = url_only ? 'echo' : browser_launcher\n      args.push url\n    end\n\n    # Returns the terminal-formatted manpage, ready to be printed to\n    # the screen.\n    def hub_manpage\n      abort \"** Can't find groff(1)\" unless command?('groff')\n\n      require 'open3'\n      out = nil\n      Open3.popen3(groff_command) do |stdin, stdout, _|\n        stdin.puts hub_raw_manpage\n        stdin.close\n        out = stdout.read.strip\n      end\n      out\n    end\n\n    # The groff command complete with crazy arguments we need to run\n    # in order to turn our raw roff (manpage markup) into something\n    # readable on the terminal.\n    def groff_command\n      cols = terminal_width\n      \"groff -Wall -mtty-char -mandoc -Tascii -rLL=#{cols}n -rLT=#{cols}n\"\n    end\n\n    # Returns the raw hub manpage. If we're not running in standalone\n    # mode, it's a file sitting at the root under the `man`\n    # directory.\n    #\n    # If we are running in standalone mode the manpage will be\n    # included after the __END__ of the file so we can grab it using\n    # DATA.\n    def hub_raw_manpage\n      if File.exist? file = File.dirname(__FILE__) + '/../../man/hub.1'\n        File.read(file)\n      else\n        DATA.read\n      end\n    end\n\n    # All calls to `puts` in after hooks or commands are paged,\n    # git-style.\n    def puts(*args)\n      page_stdout\n      super\n    end\n\n    # http://nex-3.com/posts/73-git-style-automatic-paging-in-ruby\n    def page_stdout\n      return if not $stdout.tty? or windows?\n\n      read, write = IO.pipe\n\n      if Kernel.fork\n        # Parent process, become pager\n        $stdin.reopen(read)\n        read.close\n        write.close\n\n        # Don't page if the input is short enough\n        ENV['LESS'] = 'FSR'\n\n        # Wait until we have input before we start the pager\n        Kernel.select [STDIN]\n\n        pager = ENV['GIT_PAGER'] ||\n          `git config --get-all core.pager`.split(\"\\n\").first ||\n          ENV['PAGER'] ||\n          'less -isr'\n\n        pager = 'cat' if pager.empty?\n\n        exec pager rescue exec \"/bin/sh\", \"-c\", pager\n      else\n        # Child process\n        $stdout.reopen(write)\n        $stderr.reopen(write) if $stderr.tty?\n        read.close\n        write.close\n      end\n    rescue NotImplementedError\n      # fork might not available, such as in JRuby\n    end\n\n    def pullrequest_editmsg(changes)\n      message_file = pullrequest_editmsg_file\n\n      if valid_editmsg_file?(message_file)\n        title, body = read_editmsg(message_file)\n        previous_message = [title, body].compact.join(\"\\n\\n\") if title\n      end\n\n      File.open(message_file, 'w') { |msg|\n        yield msg, previous_message\n        if changes\n          msg.puts \"#\\n# Changes:\\n#\"\n          msg.puts changes.gsub(/^/, '# ').gsub(/ +$/, '')\n        end\n      }\n\n      edit_cmd = Array(git_editor).dup\n      edit_cmd << '-c' << 'set ft=gitcommit tw=0 wrap lbr' if edit_cmd[0] =~ /^[mg]?vim$/\n      edit_cmd << message_file\n      system(*edit_cmd)\n\n      unless $?.success?\n        # writing was cancelled, or the editor never opened in the first place\n        delete_editmsg(message_file)\n        abort \"error using text editor for pull request message\"\n      end\n\n      title, body = read_editmsg(message_file)\n      abort \"Aborting due to empty pull request title\" unless title\n      [title, body]\n    end\n\n    # This unfortunate hack is because older versions of hub never cleaned up\n    # the pullrequest_editmsg_file, which newer hub would pick up and\n    # misinterpret as a message which should be reused after a failed PR.\n    def valid_editmsg_file?(message_file)\n      File.exist?(message_file) &&\n        File.mtime(message_file) > File.mtime(__FILE__)\n    end\n\n    def read_msg(message)\n      message.split(\"\\n\\n\", 2).each {|s| s.strip! }.reject {|s| s.empty? }\n    end\n\n    def pullrequest_editmsg_file\n      File.join(git_dir, 'PULLREQ_EDITMSG')\n    end\n\n    def read_editmsg(file)\n      title, body = '', ''\n      File.open(file, 'r') { |msg|\n        msg.each_line do |line|\n          next if line.index('#') == 0\n          ((title.empty? and line =~ /\\S/) ? title : body) << line\n        end\n      }\n      title.tr!(\"\\n\", ' ')\n      title.strip!\n      body.strip!\n\n      [title =~ /\\S/ ? title : nil, body =~ /\\S/ ? body : nil]\n    end\n\n    def delete_editmsg(file = pullrequest_editmsg_file)\n      File.delete(file) if File.exist?(file)\n    end\n\n    def expand_alias(cmd)\n      if expanded = git_alias_for(cmd)\n        if expanded.index('!') != 0\n          require 'shellwords' unless defined?(::Shellwords)\n          Shellwords.shellwords(expanded)\n        end\n      end\n    end\n\n    def display_api_exception(action, response)\n      $stderr.puts \"Error #{action}: #{response.message.strip} (HTTP #{response.status})\"\n      if 422 == response.status and response.error_message?\n        # display validation errors\n        msg = response.error_message\n        msg = msg.join(\"\\n\") if msg.respond_to? :join\n        warn msg\n      end\n    end\n\n  end\nend\n", "require 'shellwords'\nrequire 'forwardable'\nrequire 'delegate'\n\nmodule Hub\n  # Methods for inspecting the environment, such as reading git config,\n  # repository info, and other.\n  module Context\n    extend Forwardable\n\n    NULL = defined?(File::NULL) ? File::NULL : File.exist?('/dev/null') ? '/dev/null' : 'NUL'\n\n    # Shells out to git to get output of its commands\n    class GitReader\n      attr_reader :executable\n\n      def initialize(executable = nil, &read_proc)\n        @executable = executable || 'git'\n        # caches output when shelling out to git\n        read_proc ||= lambda { |cache, cmd|\n          str = command_to_string(cmd)\n          result = silence_stderr { %x{#{str}}.chomp }\n          cache[cmd] = $?.success? && !result.empty? ? result : nil\n        }\n        @cache = Hash.new(&read_proc)\n      end\n\n      def add_exec_flags(flags)\n        @executable = Array(executable).concat(flags)\n      end\n\n      def read_config(cmd, all = false)\n        config_cmd = ['config', (all ? '--get-all' : '--get'), *cmd]\n        config_cmd = config_cmd.join(' ') unless cmd.respond_to? :join\n        read config_cmd\n      end\n\n      def read(cmd)\n        @cache[cmd]\n      end\n\n      def stub_config_value(key, value, get = '--get')\n        stub_command_output \"config #{get} #{key}\", value\n      end\n\n      def stub_command_output(cmd, value)\n        @cache[cmd] = value.nil? ? nil : value.to_s\n      end\n\n      def stub!(values)\n        @cache.update values\n      end\n\n      private\n\n      def to_exec(args)\n        args = Shellwords.shellwords(args) if args.respond_to? :to_str\n        Array(executable) + Array(args)\n      end\n\n      def command_to_string(cmd)\n        full_cmd = to_exec(cmd)\n        full_cmd.respond_to?(:shelljoin) ? full_cmd.shelljoin : full_cmd.join(' ')\n      end\n\n      def silence_stderr\n        oldio = STDERR.dup\n        STDERR.reopen(NULL)\n        yield\n      ensure\n        STDERR.reopen(oldio)\n      end\n    end\n\n    module GitReaderMethods\n      extend Forwardable\n\n      def_delegator :git_reader, :read_config, :git_config\n      def_delegator :git_reader, :read, :git_command\n\n      def self.extended(base)\n        base.extend Forwardable\n        base.def_delegators :'self.class', :git_config, :git_command\n      end\n    end\n\n    class Error < RuntimeError; end\n    class FatalError < Error; end\n\n    private\n\n    def git_reader\n      @git_reader ||= GitReader.new ENV['GIT']\n    end\n\n    include GitReaderMethods\n    private :git_config, :git_command\n\n    def local_repo(fatal = true)\n      return nil if defined?(@local_repo) && @local_repo == false\n      @local_repo =\n        if git_dir = git_command('rev-parse -q --git-dir')\n          LocalRepo.new(git_reader, current_dir, git_dir)\n        elsif fatal\n          raise FatalError, \"Not a git repository\"\n        else\n          false\n        end\n    end\n\n    repo_methods = [\n      :current_branch, :git_dir,\n      :remote_branch_and_project,\n      :repo_owner, :repo_host,\n      :remotes, :remotes_group, :origin_remote\n    ]\n    def_delegator :local_repo, :name, :repo_name\n    def_delegators :local_repo, *repo_methods\n    private :repo_name, *repo_methods\n\n    def master_branch\n      if local_repo(false)\n        local_repo.master_branch\n      else\n        # FIXME: duplicates functionality of LocalRepo#master_branch\n        Branch.new nil, 'refs/heads/master'\n      end\n    end\n\n    class LocalRepo < Struct.new(:git_reader, :dir, :git_dir)\n      include GitReaderMethods\n\n      def name\n        if project = main_project\n          project.name\n        else\n          File.basename(dir)\n        end\n      end\n\n      def repo_owner\n        if project = main_project\n          project.owner\n        end\n      end\n\n      def repo_host\n        project = main_project and project.host\n      end\n\n      def main_project\n        remote = origin_remote and remote.project\n      end\n\n      def remote_branch_and_project(username_fetcher, prefer_upstream = false)\n        project = main_project\n        if project and branch = current_branch\n          branch = branch.push_target(username_fetcher.call(project.host), prefer_upstream)\n          project = remote_by_name(branch.remote_name).project if branch && branch.remote?\n        end\n        [branch, project]\n      end\n\n      def current_branch\n        @current_branch ||= branch_at_ref('HEAD')\n      end\n\n      def branch_at_ref(*parts)\n        begin\n          head = file_read(*parts)\n        rescue Errno::ENOENT\n          return nil\n        else\n          Branch.new(self, head.rstrip) if head.sub!('ref: ', '')\n        end\n      end\n\n      def file_read(*parts)\n        File.read(File.join(git_dir, *parts))\n      end\n\n      def file_exist?(*parts)\n        File.exist?(File.join(git_dir, *parts))\n      end\n\n      def master_branch\n        if remote = origin_remote\n          default_branch = branch_at_ref(\"refs/remotes/#{remote}/HEAD\")\n        end\n        default_branch || Branch.new(self, 'refs/heads/master')\n      end\n\n      ORIGIN_NAMES = %w[ upstream github origin ]\n\n      def remotes\n        @remotes ||= begin\n          names = []\n          url_memo = Hash.new {|h,k| names << k; h[k]=[] }\n          git_command('remote -v').to_s.split(\"\\n\").map do |line|\n            next if line !~ /^(.+?)\\t(.+) \\(/\n            name, url = $1, $2\n            url_memo[name] << url\n          end\n          ((ORIGIN_NAMES + names) & names).map do |name|\n            urls = url_memo[name].uniq\n            Remote.new(self, name, urls)\n          end\n        end\n      end\n\n      def remotes_for_publish(owner_name)\n        list = ORIGIN_NAMES.map {|n| remote_by_name(n) }\n        list << remotes.find {|r| p = r.project and p.owner == owner_name }\n        list.compact.uniq.reverse\n      end\n\n      def remotes_group(name)\n        git_config \"remotes.#{name}\"\n      end\n\n      def origin_remote\n        remotes.detect {|r| r.urls.any? }\n      end\n\n      def remote_by_name(remote_name)\n        remotes.find {|r| r.name == remote_name }\n      end\n\n      def known_host?(host)\n        default = default_host\n        default == host || \"ssh.#{default}\" == host ||\n          git_config('hub.host', :all).to_s.split(\"\\n\").include?(host)\n      end\n\n      def self.default_host\n        ENV['GITHUB_HOST'] || main_host\n      end\n\n      def self.main_host\n        'github.com'\n      end\n\n      extend Forwardable\n      def_delegators :'self.class', :default_host, :main_host\n\n      def ssh_config\n        @ssh_config ||= SshConfig.new\n      end\n    end\n\n    class GithubProject < Struct.new(:local_repo, :owner, :name, :host)\n      def self.from_url(url, local_repo)\n        if local_repo.known_host?(url.host)\n          _, owner, name = url.path.split('/', 4)\n          GithubProject.new(local_repo, owner, name.sub(/\\.git$/, ''), url.host)\n        end\n      end\n\n      attr_accessor :repo_data\n\n      def initialize(*args)\n        super\n        self.name = self.name.tr(' ', '-')\n        self.host ||= (local_repo || LocalRepo).default_host\n        self.host = host.sub(/^ssh\\./i, '') if 'ssh.github.com' == host.downcase\n      end\n\n      def private?\n        repo_data ? repo_data.fetch('private') :\n          host != (local_repo || LocalRepo).main_host\n      end\n\n      def owned_by(new_owner)\n        new_project = dup\n        new_project.owner = new_owner\n        new_project\n      end\n\n      def name_with_owner\n        \"#{owner}/#{name}\"\n      end\n\n      def ==(other)\n        name_with_owner == other.name_with_owner\n      end\n\n      def remote\n        local_repo.remotes.find { |r| r.project == self }\n      end\n\n      def web_url(path = nil, protocol_config = nil)\n        project_name = name_with_owner\n        if project_name.sub!(/\\.wiki$/, '')\n          unless '/wiki' == path\n            path = if path =~ %r{^/commits/} then '/_history'\n                   else path.to_s.sub(/\\w+/, '_\\0')\n                   end\n            path = '/wiki' + path\n          end\n        end\n        '%s://%s/%s' % [\n          protocol_config ? protocol_config.call(host) : 'https',\n          host,\n          project_name + path.to_s\n        ]\n      end\n\n      def git_url(options = {})\n        if options[:https] then \"https://#{host}/\"\n        elsif options[:private] or private? then \"git@#{host}:\"\n        else \"git://#{host}/\"\n        end + name_with_owner + '.git'\n      end\n    end\n\n    class GithubURL < DelegateClass(URI::HTTP)\n      extend Forwardable\n\n      attr_reader :project\n      def_delegator :project, :name, :project_name\n      def_delegator :project, :owner, :project_owner\n\n      def self.resolve(url, local_repo)\n        u = URI(url)\n        if %[http https].include? u.scheme and project = GithubProject.from_url(u, local_repo)\n          self.new(u, project)\n        end\n      rescue URI::InvalidURIError\n        nil\n      end\n\n      def initialize(uri, project)\n        @project = project\n        super(uri)\n      end\n\n      # segment of path after the project owner and name\n      def project_path\n        path.split('/', 4)[3]\n      end\n    end\n\n    class Branch < Struct.new(:local_repo, :name)\n      alias to_s name\n\n      def short_name\n        name.sub(%r{^refs/(remotes/)?.+?/}, '')\n      end\n\n      def master?\n        master_name = if local_repo then local_repo.master_branch.short_name\n        else 'master'\n        end\n        short_name == master_name\n      end\n\n      def upstream\n        if branch = local_repo.git_command(\"rev-parse --symbolic-full-name #{short_name}@{upstream}\")\n          Branch.new local_repo, branch\n        end\n      end\n\n      def push_target(owner_name, prefer_upstream = false)\n        push_default = local_repo.git_config('push.default')\n        if %w[upstream tracking].include?(push_default)\n          upstream\n        else\n          short = short_name\n          refs = local_repo.remotes_for_publish(owner_name).map { |remote|\n            \"refs/remotes/#{remote}/#{short}\"\n          }\n          refs.reverse! if prefer_upstream\n          if branch = refs.detect {|ref| local_repo.file_exist?(ref) }\n            Branch.new(local_repo, branch)\n          end\n        end\n      end\n\n      def remote?\n        name.index('refs/remotes/') == 0\n      end\n\n      def remote_name\n        name =~ %r{^refs/remotes/([^/]+)} and $1 or\n          raise Error, \"can't get remote name from #{name.inspect}\"\n      end\n    end\n\n    class Remote < Struct.new(:local_repo, :name, :raw_urls)\n      alias to_s name\n\n      def ==(other)\n        other.respond_to?(:to_str) ? name == other.to_str : super\n      end\n\n      def project\n        urls.each { |url|\n          if valid = GithubProject.from_url(url, local_repo)\n            return valid\n          end\n        }\n        nil\n      end\n\n      def github_url\n        urls.detect {|url| local_repo.known_host?(url.host) }\n      end\n\n      def urls\n        @urls ||= raw_urls.map do |url|\n          with_normalized_url(url) do |normalized|\n            begin\n              uri_parse(normalized)\n            rescue URI::InvalidURIError\n            end\n          end\n        end.compact\n      end\n\n      def with_normalized_url(url)\n        if url =~ %r{^[\\w-]+://} || url =~ %r{^([^/]+?):}\n          url = \"ssh://#{$1}/#{$'}\" if $1\n          yield url\n        end\n      end\n\n      def uri_parse uri\n        uri = URI.parse uri\n        if uri.host != local_repo.default_host\n          ssh = local_repo.ssh_config\n          uri.host = ssh.get_value(uri.host, :HostName) { uri.host }\n        end\n        uri\n      end\n    end\n\n    ## helper methods for local repo, GH projects\n\n    def github_project(name, owner = nil)\n      if owner and owner.index('/')\n        owner, name = owner.split('/', 2)\n      elsif name and name.index('/')\n        owner, name = name.split('/', 2)\n      else\n        name ||= repo_name\n        owner ||= github_user\n      end\n\n      if local_repo(false) and main_project = local_repo.main_project\n        project = main_project.dup\n        project.owner = owner\n        project.name = name\n        project\n      else\n        GithubProject.new(local_repo(false), owner, name)\n      end\n    end\n\n    def git_url(owner = nil, name = nil, options = {})\n      project = github_project(name, owner)\n      project.git_url({:https => https_protocol?}.update(options))\n    end\n\n    def resolve_github_url(url)\n      GithubURL.resolve(url, local_repo) if url =~ /^https?:/\n    end\n\n    # legacy setting\n    def http_clone?\n      git_config('--bool hub.http-clone') == 'true'\n    end\n\n    def https_protocol?\n      git_config('hub.protocol') == 'https' or http_clone?\n    end\n\n    def git_alias_for(name)\n      git_config \"alias.#{name}\"\n    end\n\n    def rev_list(a, b)\n      git_command(\"rev-list --cherry-pick --right-only --no-merges #{a}...#{b}\")\n    end\n\n    PWD = Dir.pwd\n\n    def current_dir\n      PWD\n    end\n\n    def is_repo?\n      !!local_repo(false)\n    end\n\n    def git_editor\n      # possible: ~/bin/vi, $SOME_ENVIRONMENT_VARIABLE, \"C:\\Program Files\\Vim\\gvim.exe\" --nofork\n      editor = git_command 'var GIT_EDITOR'\n      editor.gsub!(/\\$(\\w+|\\{\\w+\\})/) { ENV[$1.tr('{}', '')] }\n      editor = ENV[$1] if editor =~ /^\\$(\\w+)$/\n      editor = File.expand_path editor if (editor =~ /^[~.]/ or editor.index('/')) and editor !~ /[\"']/\n      # avoid shellsplitting \"C:\\Program Files\"\n      if File.exist? editor then [editor]\n      else editor.shellsplit\n      end\n    end\n\n    module System\n      # Cross-platform web browser command; respects the value set in $BROWSER.\n      # \n      # Returns an array, e.g.: ['open']\n      def browser_launcher\n        browser = ENV['BROWSER'] || (\n          osx? ? 'open' : windows? ? %w[cmd /c start] :\n          %w[xdg-open cygstart x-www-browser firefox opera mozilla netscape].find { |comm| which comm }\n        )\n\n        abort \"Please set $BROWSER to a web launcher to use this command.\" unless browser\n        Array(browser)\n      end\n\n      def osx?\n        require 'rbconfig'\n        RbConfig::CONFIG['host_os'].to_s.include?('darwin')\n      end\n\n      def windows?\n        require 'rbconfig'\n        RbConfig::CONFIG['host_os'] =~ /msdos|mswin|djgpp|mingw|windows/\n      end\n\n      def unix?\n        require 'rbconfig'\n        RbConfig::CONFIG['host_os'] =~ /(aix|darwin|linux|(net|free|open)bsd|cygwin|solaris|irix|hpux)/i\n      end\n\n      # Cross-platform way of finding an executable in the $PATH.\n      #\n      #   which('ruby') #=> /usr/bin/ruby\n      def which(cmd)\n        exts = ENV['PATHEXT'] ? ENV['PATHEXT'].split(';') : ['']\n        ENV['PATH'].split(File::PATH_SEPARATOR).each do |path|\n          exts.each { |ext|\n            exe = \"#{path}/#{cmd}#{ext}\"\n            return exe if File.executable? exe\n          }\n        end\n        return nil\n      end\n\n      # Checks whether a command exists on this system in the $PATH.\n      #\n      # name - The String name of the command to check for.\n      #\n      # Returns a Boolean.\n      def command?(name)\n        !which(name).nil?\n      end\n\n      def tmp_dir\n        ENV['TMPDIR'] || ENV['TEMP'] || '/tmp'\n      end\n\n      def terminal_width\n        if unix?\n          width = %x{stty size 2>#{NULL}}.split[1].to_i\n          width = %x{tput cols 2>#{NULL}}.to_i if width.zero?\n        else\n          width = 0\n        end\n        width < 10 ? 78 : width\n      end\n    end\n\n    include System\n    extend System\n  end\nend\n"], "fixing_code": ["module Hub\n  # The Commands module houses the git commands that hub\n  # lovingly wraps. If a method exists here, it is expected to have a\n  # corresponding git command which either gets run before or after\n  # the method executes.\n  #\n  # The typical flow is as follows:\n  #\n  # 1. hub is invoked from the command line:\n  #    $ hub clone rtomayko/tilt\n  #\n  # 2. The Runner class is initialized:\n  #    >> Hub::Runner.new('clone', 'rtomayko/tilt')\n  #\n  # 3. The method representing the git subcommand is executed with the\n  #    full args:\n  #    >> Hub::Commands.clone(['clone', 'rtomayko/tilt'])\n  #\n  # 4. That method rewrites the args as it sees fit:\n  #    >> args[1] = \"git://github.com/\" + args[1] + \".git\"\n  #    => \"git://github.com/rtomayko/tilt.git\"\n  #\n  # 5. The new args are used to run `git`:\n  #    >> exec \"git\", \"clone\", \"git://github.com/rtomayko/tilt.git\"\n  #\n  # An optional `after` callback can be set. If so, it is run after\n  # step 5 (which then performs a `system` call rather than an\n  # `exec`). See `Hub::Args` for more information on the `after` callback.\n  module Commands\n    # We are a blank slate.\n    instance_methods.each { |m| undef_method(m) unless m =~ /(^__|send|to\\?$)/ }\n    extend self\n\n    # provides git interrogation methods\n    extend Context\n\n    NAME_RE = /[\\w.][\\w.-]*/\n    OWNER_RE = /[a-zA-Z0-9][a-zA-Z0-9-]*/\n    NAME_WITH_OWNER_RE = /^(?:#{NAME_RE}|#{OWNER_RE}\\/#{NAME_RE})$/\n\n    CUSTOM_COMMANDS = %w[alias create browse compare fork pull-request ci-status]\n\n    def run(args)\n      slurp_global_flags(args)\n\n      # Hack to emulate git-style\n      args.unshift 'help' if args.empty?\n\n      cmd = args[0]\n      if expanded_args = expand_alias(cmd)\n        cmd = expanded_args[0]\n        expanded_args.concat args[1..-1]\n      end\n\n      respect_help_flags(expanded_args || args) if custom_command? cmd\n\n      # git commands can have dashes\n      cmd = cmd.gsub(/(\\w)-/, '\\1_')\n      if method_defined?(cmd) and cmd != 'run'\n        args.replace expanded_args if expanded_args\n        send(cmd, args)\n      end\n    rescue Errno::ENOENT\n      if $!.message.include? \"No such file or directory - git\"\n        abort \"Error: `git` command not found\"\n      else\n        raise\n      end\n    rescue Context::FatalError => err\n      abort \"fatal: #{err.message}\"\n    end\n\n\n    # $ hub ci-status\n    # $ hub ci-status 6f6d9797f9d6e56c3da623a97cfc3f45daf9ae5f\n    # $ hub ci-status master\n    # $ hub ci-status origin/master\n    def ci_status(args)\n      args.shift\n      ref = args.words.first || 'HEAD'\n      verbose = args.include?('-v')\n\n      unless project = local_repo.main_project\n        abort \"Aborted: the origin remote doesn't point to a GitHub repository.\"\n      end\n\n      unless sha = local_repo.git_command(\"rev-parse -q #{ref}\")\n        abort \"Aborted: no revision could be determined from '#{ref}'\"\n      end\n\n      statuses = api_client.statuses(project, sha)\n      status = statuses.first\n      if status\n        ref_state = status['state']\n        ref_target_url = status['target_url']\n      else\n        ref_state = 'no status'\n        ref_target_url = nil\n      end\n\n      exit_code = case ref_state\n        when 'success'          then 0\n        when 'failure', 'error' then 1\n        when 'pending'          then 2\n        else 3\n        end\n\n      if verbose and ref_target_url\n        $stdout.puts \"%s: %s\" % [ref_state, ref_target_url]\n      else\n        $stdout.puts ref_state\n      end\n      exit exit_code\n    rescue GitHubAPI::Exceptions\n      response = $!.response\n      display_api_exception(\"fetching CI status\", response)\n      exit 1\n    end\n\n    # $ hub pull-request\n    # $ hub pull-request \"My humble contribution\"\n    # $ hub pull-request https://github.com/rtomayko/tilt/issues/92\n    def pull_request(args)\n      args.shift\n      options = { }\n      force = explicit_owner = false\n      base_project = local_repo.main_project\n      tracked_branch, head_project = remote_branch_and_project(method(:github_user))\n\n      unless current_branch\n        abort \"Aborted: not currently on any branch.\"\n      end\n\n      unless base_project\n        abort \"Aborted: the origin remote doesn't point to a GitHub repository.\"\n      end\n\n      from_github_ref = lambda do |ref, context_project|\n        if ref.index(':')\n          owner, ref = ref.split(':', 2)\n          project = github_project(context_project.name, owner)\n        end\n        [project || context_project, ref]\n      end\n\n      while arg = args.shift\n        case arg\n        when '-f'\n          force = true\n        when '-F', '--file'\n          file = args.shift\n          text = file == '-' ? $stdin.read : File.read(file)\n          options[:title], options[:body] = read_msg(text)\n        when '-m', '--message'\n          text = args.shift\n          options[:title], options[:body] = read_msg(text)\n        when '-b'\n          base_project, options[:base] = from_github_ref.call(args.shift, base_project)\n        when '-h'\n          head = args.shift\n          explicit_owner = !!head.index(':')\n          head_project, options[:head] = from_github_ref.call(head, head_project)\n        when '-i'\n          options[:issue] = args.shift\n        when '-o', '--browse'\n          open_with_browser = true\n        else\n          if url = resolve_github_url(arg) and url.project_path =~ /^issues\\/(\\d+)/\n            options[:issue] = $1\n            base_project = url.project\n          elsif !options[:title] && arg.index('-') != 0\n            options[:title] = arg\n            warn \"hub: Specifying pull request title without a flag is deprecated.\"\n            warn \"Please use one of `-m' or `-F' options.\"\n          else\n            abort \"invalid argument: #{arg}\"\n          end\n        end\n      end\n\n      if options[:issue]\n        warn \"Warning: Issue to pull request conversion is deprecated and might not work in the future.\"\n      end\n\n      options[:project] = base_project\n      options[:base] ||= master_branch.short_name\n\n      if options[:head].nil? && tracked_branch\n        if !tracked_branch.remote?\n          # The current branch is tracking another local branch. Pretend there is\n          # no upstream configuration at all.\n          tracked_branch = nil\n        elsif base_project == head_project and tracked_branch.short_name == options[:base]\n          $stderr.puts \"Aborted: head branch is the same as base (#{options[:base].inspect})\"\n          warn \"(use `-h <branch>` to specify an explicit pull request head)\"\n          abort\n        end\n      end\n      options[:head] ||= (tracked_branch || current_branch).short_name\n\n      remote_branch = \"#{head_project.remote}/#{options[:head]}\"\n      options[:head] = \"#{head_project.owner}:#{options[:head]}\"\n\n      if !force and tracked_branch and local_commits = rev_list(remote_branch, nil)\n        $stderr.puts \"Aborted: #{local_commits.split(\"\\n\").size} commits are not yet pushed to #{remote_branch}\"\n        warn \"(use `-f` to force submit a pull request anyway)\"\n        abort\n      end\n\n      if args.noop?\n        puts \"Would request a pull to #{base_project.owner}:#{options[:base]} from #{options[:head]}\"\n        exit\n      end\n\n      unless options[:title] or options[:issue]\n        base_branch = \"#{base_project.remote}/#{options[:base]}\"\n        commits = rev_list(base_branch, remote_branch).to_s.split(\"\\n\")\n\n        case commits.size\n        when 0\n          default_message = commit_summary = nil\n        when 1\n          format = '%w(78,0,0)%s%n%+b'\n          default_message = git_command \"show -s --format='#{format}' #{commits.first}\"\n          commit_summary = nil\n        else\n          format = '%h (%aN, %ar)%n%w(78,3,3)%s%n%+b'\n          default_message = nil\n          commit_summary = git_command \"log --no-color --format='%s' --cherry %s...%s\" %\n            [format, base_branch, remote_branch]\n        end\n\n        options[:title], options[:body] = pullrequest_editmsg(commit_summary) { |msg, initial_message|\n          initial_message ||= default_message\n          msg.puts initial_message if initial_message\n          msg.puts \"\"\n          msg.puts \"# Requesting a pull to #{base_project.owner}:#{options[:base]} from #{options[:head]}\"\n          msg.puts \"#\"\n          msg.puts \"# Write a message for this pull request. The first block\"\n          msg.puts \"# of text is the title and the rest is description.\"\n        }\n      end\n\n      pull = api_client.create_pullrequest(options)\n\n      args.push('-u') unless open_with_browser\n      browse_command(args) do\n        pull['html_url']\n      end\n    rescue GitHubAPI::Exceptions\n      response = $!.response\n      display_api_exception(\"creating pull request\", response)\n      if 404 == response.status\n        base_url = base_project.web_url.split('://', 2).last\n        warn \"Are you sure that #{base_url} exists?\"\n      end\n      exit 1\n    else\n      delete_editmsg\n    end\n\n    # $ hub e-note\n    # $ hub e-note \"My humble contribution\"\n    # $ hub e-note -i 92\n    # $ hub e-note https://github.com/rtomayko/tilt/issues/92\n    alias_method :e_note, :pull_request\n\n    # $ hub clone rtomayko/tilt\n    # > git clone git://github.com/rtomayko/tilt.\n    #\n    # $ hub clone -p kneath/hemingway\n    # > git clone git@github.com:kneath/hemingway.git\n    #\n    # $ hub clone tilt\n    # > git clone git://github.com/YOUR_LOGIN/tilt.\n    #\n    # $ hub clone -p github\n    # > git clone git@github.com:YOUR_LOGIN/hemingway.git\n    def clone(args)\n      ssh = args.delete('-p')\n      has_values = /^(--(upload-pack|template|depth|origin|branch|reference|name)|-[ubo])$/\n\n      idx = 1\n      while idx < args.length\n        arg = args[idx]\n        if arg.index('-') == 0\n          idx += 1 if arg =~ has_values\n        else\n          # $ hub clone rtomayko/tilt\n          # $ hub clone tilt\n          if arg =~ NAME_WITH_OWNER_RE and !File.directory?(arg)\n            name, owner = arg, nil\n            owner, name = name.split('/', 2) if name.index('/')\n            project = github_project(name, owner || github_user)\n            unless ssh || args[0] == 'submodule' || args.noop? || https_protocol?\n              repo_info = api_client.repo_info(project)\n              ssh = repo_info.success? && (repo_info.data['private'] || repo_info.data['permissions']['push'])\n            end\n            args[idx] = project.git_url(:private => ssh, :https => https_protocol?)\n          end\n          break\n        end\n        idx += 1\n      end\n    end\n\n    # $ hub submodule add wycats/bundler vendor/bundler\n    # > git submodule add git://github.com/wycats/bundler.git vendor/bundler\n    #\n    # $ hub submodule add -p wycats/bundler vendor/bundler\n    # > git submodule add git@github.com:wycats/bundler.git vendor/bundler\n    #\n    # $ hub submodule add -b ryppl --name pip ryppl/pip vendor/pip\n    # > git submodule add -b ryppl --name pip git://github.com/ryppl/pip.git vendor/pip\n    def submodule(args)\n      return unless index = args.index('add')\n      args.delete_at index\n\n      clone(args)\n      args.insert index, 'add'\n    end\n\n    # $ hub remote add pjhyett\n    # > git remote add pjhyett git://github.com/pjhyett/THIS_REPO.git\n    #\n    # $ hub remote add -p mojombo\n    # > git remote add mojombo git@github.com:mojombo/THIS_REPO.git\n    #\n    # $ hub remote add origin\n    # > git remote add origin git://github.com/YOUR_LOGIN/THIS_REPO.git\n    def remote(args)\n      if %w[add set-url].include?(args[1])\n        name = args.last\n        if name =~ /^(#{OWNER_RE})$/ || name =~ /^(#{OWNER_RE})\\/(#{NAME_RE})$/\n          user, repo = $1, $2 || repo_name\n        end\n      end\n      return unless user # do not touch arguments\n\n      ssh = args.delete('-p')\n\n      if args.words[2] == 'origin' && args.words[3].nil?\n        # Origin special case triggers default user/repo\n        user, repo = github_user, repo_name\n      elsif args.words[-2] == args.words[1]\n        # rtomayko/tilt => rtomayko\n        # Make sure you dance around flags.\n        idx = args.index( args.words[-1] )\n        args[idx] = user\n      else\n        # They're specifying the remote name manually (e.g.\n        # git remote add blah rtomayko/tilt), so just drop the last\n        # argument.\n        args.pop\n      end\n\n      args << git_url(user, repo, :private => ssh)\n    end\n\n    # $ hub fetch mislav\n    # > git remote add mislav git://github.com/mislav/REPO.git\n    # > git fetch mislav\n    #\n    # $ hub fetch --multiple mislav xoebus\n    # > git remote add mislav ...\n    # > git remote add xoebus ...\n    # > git fetch --multiple mislav xoebus\n    def fetch(args)\n      # $ hub fetch --multiple <name1>, <name2>, ...\n      if args.include?('--multiple')\n        names = args.words[1..-1]\n      # $ hub fetch <name>\n      elsif remote_name = args.words[1]\n        # $ hub fetch <name1>,<name2>,...\n        if remote_name =~ /^\\w+(,\\w+)+$/\n          index = args.index(remote_name)\n          args.delete(remote_name)\n          names = remote_name.split(',')\n          args.insert(index, *names)\n          args.insert(index, '--multiple')\n        else\n          names = [remote_name]\n        end\n      else\n        names = []\n      end\n\n      projects = names.map { |name|\n        unless name !~ /^#{OWNER_RE}$/ or remotes.include?(name) or remotes_group(name)\n          project = github_project(nil, name)\n          repo_info = api_client.repo_info(project)\n          if repo_info.success?\n            project.repo_data = repo_info.data\n            project\n          end\n        end\n      }.compact\n\n      if projects.any?\n        projects.each do |project|\n          args.before ['remote', 'add', project.owner, project.git_url(:https => https_protocol?)]\n        end\n      end\n    end\n\n    # $ git checkout https://github.com/defunkt/hub/pull/73\n    # > git remote add -f -t feature git://github:com/mislav/hub.git\n    # > git checkout --track -B mislav-feature mislav/feature\n    def checkout(args)\n      _, url_arg, new_branch_name = args.words\n      if url = resolve_github_url(url_arg) and url.project_path =~ /^pull\\/(\\d+)/\n        pull_id = $1\n        pull_data = api_client.pullrequest_info(url.project, pull_id)\n\n        args.delete new_branch_name\n        user, branch = pull_data['head']['label'].split(':', 2)\n        abort \"Error: #{user}'s fork is not available anymore\" unless pull_data['head']['repo']\n        new_branch_name ||= \"#{user}-#{branch}\"\n\n        if remotes.include? user\n          args.before ['remote', 'set-branches', '--add', user, branch]\n          args.before ['fetch', user, \"+refs/heads/#{branch}:refs/remotes/#{user}/#{branch}\"]\n        else\n          url = github_project(url.project_name, user).git_url(:private => pull_data['head']['repo']['private'],\n                                                               :https => https_protocol?)\n          args.before ['remote', 'add', '-f', '-t', branch, user, url]\n        end\n        idx = args.index url_arg\n        args.delete_at idx\n        args.insert idx, '--track', '-B', new_branch_name, \"#{user}/#{branch}\"\n      end\n    end\n\n    # $ git merge https://github.com/defunkt/hub/pull/73\n    # > git fetch git://github.com/mislav/hub.git +refs/heads/feature:refs/remotes/mislav/feature\n    # > git merge mislav/feature --no-ff -m 'Merge pull request #73 from mislav/feature...'\n    def merge(args)\n      _, url_arg = args.words\n      if url = resolve_github_url(url_arg) and url.project_path =~ /^pull\\/(\\d+)/\n        pull_id = $1\n        pull_data = api_client.pullrequest_info(url.project, pull_id)\n\n        user, branch = pull_data['head']['label'].split(':', 2)\n        abort \"Error: #{user}'s fork is not available anymore\" unless pull_data['head']['repo']\n\n        repo_name = pull_data['head']['repo']['name']\n        url = github_project(repo_name, user).git_url(:private => pull_data['head']['repo']['private'],\n                                                      :https => https_protocol?)\n\n        merge_head = \"#{user}/#{branch}\"\n        args.before ['fetch', url, \"+refs/heads/#{branch}:refs/remotes/#{merge_head}\"]\n\n        idx = args.index url_arg\n        args.delete_at idx\n        args.insert idx, merge_head, '-m', \"Merge pull request ##{pull_id} from #{merge_head}\\n\\n#{pull_data['title']}\"\n        idx = args.index '-m'\n        args.insert idx, '--no-ff' unless args.include?('--ff-only')\n      end\n    end\n\n    # $ git cherry-pick http://github.com/mislav/hub/commit/a319d88#comments\n    # > git remote add -f mislav git://github.com/mislav/hub.git\n    # > git cherry-pick a319d88\n    #\n    # $ git cherry-pick mislav@a319d88\n    # > git remote add -f mislav git://github.com/mislav/hub.git\n    # > git cherry-pick a319d88\n    #\n    # $ git cherry-pick mislav@SHA\n    # > git fetch mislav\n    # > git cherry-pick SHA\n    def cherry_pick(args)\n      unless args.include?('-m') or args.include?('--mainline')\n        ref = args.words.last\n        if url = resolve_github_url(ref) and url.project_path =~ /^commit\\/([a-f0-9]{7,40})/\n          sha = $1\n          project = url.project\n        elsif ref =~ /^(#{OWNER_RE})@([a-f0-9]{7,40})$/\n          owner, sha = $1, $2\n          project = local_repo.main_project.owned_by(owner)\n        end\n\n        if project\n          args[args.index(ref)] = sha\n\n          if remote = project.remote and remotes.include? remote\n            args.before ['fetch', remote.to_s]\n          else\n            args.before ['remote', 'add', '-f', project.owner, project.git_url(:https => https_protocol?)]\n          end\n        end\n      end\n    end\n\n    # $ hub am https://github.com/defunkt/hub/pull/55\n    # ... downloads patch via API ...\n    # > git am /tmp/55.patch\n    def am(args)\n      if url = args.find { |a| a =~ %r{^https?://(gist\\.)?github\\.com/} }\n        idx = args.index(url)\n        if $1 == 'gist.'\n          path_parts = $'.sub(/#.*/, '').split('/')\n          gist_id = path_parts.last\n          patch_name = \"gist-#{gist_id}.txt\"\n          patch = api_client.gist_raw(gist_id)\n        else\n          gh_url = resolve_github_url(url)\n          case gh_url.project_path\n          when /^pull\\/(\\d+)/\n            pull_id = $1.to_i\n            patch_name = \"#{pull_id}.patch\"\n            patch = api_client.pullrequest_patch(gh_url.project, pull_id)\n          when /^commit\\/([a-f0-9]{7,40})/\n            commit_sha = $1\n            patch_name = \"#{commit_sha}.patch\"\n            patch = api_client.commit_patch(gh_url.project, commit_sha)\n          else\n            raise ArgumentError, url\n          end\n        end\n\n        patch_file = Tempfile.new('patch_name')\n        File.open(patch_file, 'w') { |file| file.write(patch) }\n        args[idx] = patch_file\n      end\n    end\n\n    # $ hub apply https://github.com/defunkt/hub/pull/55\n    # ... downloads patch via API ...\n    # > git apply /tmp/55.patch\n    alias_method :apply, :am\n\n    # $ hub init -g\n    # > git init\n    # > git remote add origin git@github.com:USER/REPO.git\n    def init(args)\n      if args.delete('-g')\n        project = github_project(File.basename(current_dir))\n        url = project.git_url(:private => true, :https => https_protocol?)\n        args.after ['remote', 'add', 'origin', url]\n      end\n    end\n\n    # $ hub fork\n    # ... hardcore forking action ...\n    # > git remote add -f YOUR_USER git@github.com:YOUR_USER/CURRENT_REPO.git\n    def fork(args)\n      unless project = local_repo.main_project\n        abort \"Error: repository under 'origin' remote is not a GitHub project\"\n      end\n      forked_project = project.owned_by(github_user(project.host))\n\n      existing_repo = api_client.repo_info(forked_project)\n      if existing_repo.success?\n        parent_data = existing_repo.data['parent']\n        parent_url  = parent_data && resolve_github_url(parent_data['html_url'])\n        if !parent_url or parent_url.project != project\n          abort \"Error creating fork: %s already exists on %s\" %\n            [ forked_project.name_with_owner, forked_project.host ]\n        end\n      else\n        api_client.fork_repo(project) unless args.noop?\n      end\n\n      if args.include?('--no-remote')\n        exit\n      else\n        origin_url = project.remote.github_url\n        url = forked_project.git_url(:private => true, :https => https_protocol?)\n        args.replace %W\"remote add -f #{forked_project.owner} #{origin_url}\"\n        args.after %W\"remote set-url #{forked_project.owner} #{url}\"\n        args.after 'echo', ['new remote:', forked_project.owner]\n      end\n    rescue GitHubAPI::Exceptions\n      display_api_exception(\"creating fork\", $!.response)\n      exit 1\n    end\n\n    # $ hub create\n    # ... create repo on github ...\n    # > git remote add -f origin git@github.com:YOUR_USER/CURRENT_REPO.git\n    def create(args)\n      if !is_repo?\n        abort \"'create' must be run from inside a git repository\"\n      else\n        owner = github_user\n        args.shift\n        options = {}\n        options[:private] = true if args.delete('-p')\n        new_repo_name = nil\n\n        until args.empty?\n          case arg = args.shift\n          when '-d'\n            options[:description] = args.shift\n          when '-h'\n            options[:homepage] = args.shift\n          else\n            if arg =~ /^[^-]/ and new_repo_name.nil?\n              new_repo_name = arg\n              owner, new_repo_name = new_repo_name.split('/', 2) if new_repo_name.index('/')\n            else\n              abort \"invalid argument: #{arg}\"\n            end\n          end\n        end\n        new_repo_name ||= repo_name\n        new_project = github_project(new_repo_name, owner)\n\n        if api_client.repo_exists?(new_project)\n          warn \"#{new_project.name_with_owner} already exists on #{new_project.host}\"\n          action = \"set remote origin\"\n        else\n          action = \"created repository\"\n          unless args.noop?\n            repo_data = api_client.create_repo(new_project, options)\n            new_project = github_project(repo_data['full_name'])\n          end\n        end\n\n        url = new_project.git_url(:private => true, :https => https_protocol?)\n\n        if remotes.first != 'origin'\n          args.replace %W\"remote add -f origin #{url}\"\n        else\n          args.replace %W\"remote -v\"\n        end\n\n        args.after 'echo', [\"#{action}:\", new_project.name_with_owner]\n      end\n    rescue GitHubAPI::Exceptions\n      display_api_exception(\"creating repository\", $!.response)\n      exit 1\n    end\n\n    # $ hub push origin,staging cool-feature\n    # > git push origin cool-feature\n    # > git push staging cool-feature\n    def push(args)\n      return if args[1].nil? || !args[1].index(',')\n\n      refs    = args.words[2..-1]\n      remotes = args[1].split(',')\n      args[1] = remotes.shift\n\n      if refs.empty?\n        # add current branch as explicit ref when there are no refs specified\n        refs = [current_branch.short_name]\n        args.concat refs\n      end\n\n      remotes.each do |name|\n        args.after ['push', name, *refs]\n      end\n    end\n\n    # $ hub browse\n    # > open https://github.com/CURRENT_REPO\n    #\n    # $ hub browse -- issues\n    # > open https://github.com/CURRENT_REPO/issues\n    #\n    # $ hub browse pjhyett/github-services\n    # > open https://github.com/pjhyett/github-services\n    #\n    # $ hub browse github-services\n    # > open https://github.com/YOUR_LOGIN/github-services\n    #\n    # $ hub browse github-services wiki\n    # > open https://github.com/YOUR_LOGIN/github-services/wiki\n    def browse(args)\n      args.shift\n      browse_command(args) do\n        dest = args.shift\n        dest = nil if dest == '--'\n        # $ hub browse -- wiki\n        subpage = args.shift\n\n        if dest\n          # $ hub browse pjhyett/github-services\n          # $ hub browse github-services\n          project = github_project dest\n          branch = master_branch\n        elsif subpage && !%w[commits tree blob settings].include?(subpage)\n          branch = master_branch\n          project = local_repo.main_project\n        else\n          # $ hub browse\n          prefer_upstream = current_branch.master?\n          branch, project = remote_branch_and_project(method(:github_user), prefer_upstream)\n          branch ||= master_branch\n        end\n\n        abort \"Usage: hub browse [<USER>/]<REPOSITORY>\" unless project\n\n        path = case subpage\n        when 'commits'\n          \"/commits/#{branch_in_url(branch)}\"\n        when 'tree', NilClass\n          \"/tree/#{branch_in_url(branch)}\" if branch and !branch.master?\n        else\n          \"/#{subpage}\"\n        end\n\n        project.web_url(path, api_client.config.method(:protocol))\n      end\n    end\n\n    # $ hub compare 1.0..fix\n    # > open https://github.com/CURRENT_REPO/compare/1.0...fix\n    # $ hub compare refactor\n    # > open https://github.com/CURRENT_REPO/compare/refactor\n    # $ hub compare myfork feature\n    # > open https://github.com/myfork/REPO/compare/feature\n    # $ hub compare -u 1.0...2.0\n    # \"https://github.com/CURRENT_REPO/compare/1.0...2.0\"\n    def compare(args)\n      args.shift\n      browse_command(args) do\n        branch, project = remote_branch_and_project(method(:github_user))\n        if args.empty?\n          if branch and not branch.master?\n            range = branch.short_name\n          else\n            abort \"Usage: hub compare [USER] [<START>...]<END>\"\n          end\n        else\n          sha_or_tag = /((?:#{OWNER_RE}:)?\\w[\\w.-]+\\w)/\n          # replaces two dots with three: \"sha1...sha2\"\n          range = args.pop.sub(/^#{sha_or_tag}\\.\\.#{sha_or_tag}$/, '\\1...\\2')\n          if owner = args.pop\n            project = project.owned_by(owner)\n          end\n        end\n\n        path = '/compare/%s' % range.tr('/', ';')\n        project.web_url(path, api_client.config.method(:protocol))\n      end\n    end\n\n    # $ hub hub standalone\n    # Prints the \"standalone\" version of hub for an easy, memorable\n    # installation sequence:\n    #\n    # $ gem install hub\n    # $ hub hub standalone > ~/bin/hub && chmod 755 ~/bin/hub\n    # $ gem uninstall hub\n    def hub(args)\n      return help(args) unless args[1] == 'standalone'\n      require 'hub/standalone'\n      Hub::Standalone.build $stdout\n      exit\n    rescue LoadError\n      abort \"hub is already running in standalone mode.\"\n    rescue Errno::EPIPE\n      exit # ignore broken pipe\n    end\n\n    def alias(args)\n      shells = %w[bash zsh sh ksh csh fish]\n\n      script = !!args.delete('-s')\n      shell = args[1] || ENV['SHELL']\n      abort \"hub alias: unknown shell\" if shell.nil? or shell.empty?\n      shell = File.basename shell\n\n      unless shells.include? shell\n        $stderr.puts \"hub alias: unsupported shell\"\n        warn \"supported shells: #{shells.join(' ')}\"\n        abort\n      end\n\n      if script\n        puts \"alias git=hub\"\n      else\n        profile = case shell\n          when 'bash' then '~/.bash_profile'\n          when 'zsh'  then '~/.zshrc'\n          when 'ksh'  then '~/.profile'\n          when 'fish' then '~/.config/fish/config.fish'\n          else\n            'your profile'\n          end\n\n        puts \"# Wrap git automatically by adding the following to #{profile}:\"\n        puts\n        if shell == 'fish'\n          puts 'eval (hub alias -s)'\n        else\n          puts 'eval \"$(hub alias -s)\"'\n        end\n      end\n\n      exit\n    end\n\n    # $ hub version\n    # > git version\n    # (print hub version)\n    def version(args)\n      args.after 'echo', ['hub version', Version]\n    end\n    alias_method \"--version\", :version\n\n    # $ hub help\n    # (print improved help text)\n    def help(args)\n      command = args.words[1]\n\n      if command == 'hub' || custom_command?(command)\n        puts hub_manpage\n        exit\n      elsif command.nil?\n        if args.has_flag?('-a', '--all')\n          # Add the special hub commands to the end of \"git help -a\" output.\n          args.after 'echo', [\"\\nhub custom commands\\n\"]\n          args.after 'echo', CUSTOM_COMMANDS.map {|cmd| \"  #{cmd}\" }\n        else\n          ENV['GIT_PAGER'] = '' unless args.has_flag?('-p', '--paginate') # Use `cat`.\n          puts improved_help_text\n          exit\n        end\n      end\n    end\n    alias_method \"--help\", :help\n\n  private\n    #\n    # Helper methods are private so they cannot be invoked\n    # from the command line.\n    #\n\n    def branch_in_url(branch)\n      CGI.escape(branch.short_name).gsub(\"%2F\", \"/\")\n    end\n\n    def api_client\n      @api_client ||= begin\n        config_file = ENV['HUB_CONFIG'] || '~/.config/hub'\n        file_store = GitHubAPI::FileStore.new File.expand_path(config_file)\n        file_config = GitHubAPI::Configuration.new file_store\n        GitHubAPI.new file_config,\n          :app_url => 'http://hub.github.com/',\n          :verbose => !ENV['HUB_VERBOSE'].to_s.empty?\n      end\n    end\n\n    def github_user host = nil, &block\n      host ||= (local_repo(false) || Context::LocalRepo).default_host\n      api_client.username_via_auth_dance(host, &block)\n    end\n\n    def custom_command? cmd\n      CUSTOM_COMMANDS.include? cmd\n    end\n\n    # Show short usage help for `-h` flag, and open man page for `--help`\n    def respect_help_flags args\n      return if args.size > 2\n      case args[1]\n      when '-h'\n        pattern = /(git|hub) #{Regexp.escape args[0].gsub('-', '\\-')}/\n        hub_raw_manpage.each_line { |line|\n          if line =~ pattern\n            $stderr.print \"Usage: \"\n            $stderr.puts line.gsub(/\\\\f./, '').gsub('\\-', '-')\n            abort\n          end\n        }\n        abort \"Error: couldn't find usage help for #{args[0]}\"\n      when '--help'\n        puts hub_manpage\n        exit\n      end\n    end\n\n    # The text print when `hub help` is run, kept in its own method\n    # for the convenience of the author.\n    def improved_help_text\n      <<-help\nusage: git [--version] [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p|--paginate|--no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           [-c name=value] [--help]\n           <command> [<args>]\n\nBasic Commands:\n   init       Create an empty git repository or reinitialize an existing one\n   add        Add new or modified files to the staging area\n   rm         Remove files from the working directory and staging area\n   mv         Move or rename a file, a directory, or a symlink\n   status     Show the status of the working directory and staging area\n   commit     Record changes to the repository\n\nHistory Commands:\n   log        Show the commit history log\n   diff       Show changes between commits, commit and working tree, etc\n   show       Show information about commits, tags or files\n\nBranching Commands:\n   branch     List, create, or delete branches\n   checkout   Switch the active branch to another branch\n   merge      Join two or more development histories (branches) together\n   tag        Create, list, delete, sign or verify a tag object\n\nRemote Commands:\n   clone      Clone a remote repository into a new directory\n   fetch      Download data, tags and branches from a remote repository\n   pull       Fetch from and merge with another repository or a local branch\n   push       Upload data, tags and branches to a remote repository\n   remote     View and manage a set of remote repositories\n\nAdvanced Commands:\n   reset      Reset your staging area or working directory to another point\n   rebase     Re-apply a series of patches in one branch onto another\n   bisect     Find by binary search the change that introduced a bug\n   grep       Print files with lines matching a pattern in your codebase\n\nGitHub Commands:\n   pull-request   Open a pull request on GitHub\n   fork           Make a fork of a remote repository on GitHub and add as remote\n   create         Create this repository on GitHub and add GitHub as origin\n   browse         Open a GitHub page in the default browser\n   compare        Open a compare page on GitHub\n   ci-status      Show the CI status of a commit\n\nSee 'git help <command>' for more information on a specific command.\nhelp\n    end\n\n    # Extract global flags from the front of the arguments list.\n    # Makes sure important ones are supplied for calls to subcommands.\n    #\n    # Known flags are:\n    #   --version --exec-path=<path> --html-path\n    #   -p|--paginate|--no-pager --no-replace-objects\n    #   --bare --git-dir=<path> --work-tree=<path>\n    #   -c name=value --help\n    #\n    # Special: `--version`, `--help` are replaced with \"version\" and \"help\".\n    # Ignored: `--exec-path`, `--html-path` are kept in args list untouched.\n    def slurp_global_flags(args)\n      flags = %w[ --noop -c -p --paginate --no-pager --no-replace-objects --bare --version --help ]\n      flags2 = %w[ --exec-path= --git-dir= --work-tree= ]\n\n      # flags that should be present in subcommands, too\n      globals = []\n      # flags that apply only to main command\n      locals = []\n\n      while args[0] && (flags.include?(args[0]) || flags2.any? {|f| args[0].index(f) == 0 })\n        flag = args.shift\n        case flag\n        when '--noop'\n          args.noop!\n        when '--version', '--help'\n          args.unshift flag.sub('--', '')\n        when '-c'\n          # slurp one additional argument\n          config_pair = args.shift\n          # add configuration to our local cache\n          key, value = config_pair.split('=', 2)\n          git_reader.stub_config_value(key, value)\n\n          globals << flag << config_pair\n        when '-p', '--paginate', '--no-pager'\n          locals << flag\n        else\n          globals << flag\n        end\n      end\n\n      git_reader.add_exec_flags(globals)\n      args.add_exec_flags(globals)\n      args.add_exec_flags(locals)\n    end\n\n    # Handles common functionality of browser commands like `browse`\n    # and `compare`. Yields a block that returns params for `github_url`.\n    def browse_command(args)\n      url_only = args.delete('-u')\n      warn \"Warning: the `-p` flag has no effect anymore\" if args.delete('-p')\n      url = yield\n\n      args.executable = url_only ? 'echo' : browser_launcher\n      args.push url\n    end\n\n    # Returns the terminal-formatted manpage, ready to be printed to\n    # the screen.\n    def hub_manpage\n      abort \"** Can't find groff(1)\" unless command?('groff')\n\n      require 'open3'\n      out = nil\n      Open3.popen3(groff_command) do |stdin, stdout, _|\n        stdin.puts hub_raw_manpage\n        stdin.close\n        out = stdout.read.strip\n      end\n      out\n    end\n\n    # The groff command complete with crazy arguments we need to run\n    # in order to turn our raw roff (manpage markup) into something\n    # readable on the terminal.\n    def groff_command\n      cols = terminal_width\n      \"groff -Wall -mtty-char -mandoc -Tascii -rLL=#{cols}n -rLT=#{cols}n\"\n    end\n\n    # Returns the raw hub manpage. If we're not running in standalone\n    # mode, it's a file sitting at the root under the `man`\n    # directory.\n    #\n    # If we are running in standalone mode the manpage will be\n    # included after the __END__ of the file so we can grab it using\n    # DATA.\n    def hub_raw_manpage\n      if File.exist? file = File.dirname(__FILE__) + '/../../man/hub.1'\n        File.read(file)\n      else\n        DATA.read\n      end\n    end\n\n    # All calls to `puts` in after hooks or commands are paged,\n    # git-style.\n    def puts(*args)\n      page_stdout\n      super\n    end\n\n    # http://nex-3.com/posts/73-git-style-automatic-paging-in-ruby\n    def page_stdout\n      return if not $stdout.tty? or windows?\n\n      read, write = IO.pipe\n\n      if Kernel.fork\n        # Parent process, become pager\n        $stdin.reopen(read)\n        read.close\n        write.close\n\n        # Don't page if the input is short enough\n        ENV['LESS'] = 'FSR'\n\n        # Wait until we have input before we start the pager\n        Kernel.select [STDIN]\n\n        pager = ENV['GIT_PAGER'] ||\n          `git config --get-all core.pager`.split(\"\\n\").first ||\n          ENV['PAGER'] ||\n          'less -isr'\n\n        pager = 'cat' if pager.empty?\n\n        exec pager rescue exec \"/bin/sh\", \"-c\", pager\n      else\n        # Child process\n        $stdout.reopen(write)\n        $stderr.reopen(write) if $stderr.tty?\n        read.close\n        write.close\n      end\n    rescue NotImplementedError\n      # fork might not available, such as in JRuby\n    end\n\n    def pullrequest_editmsg(changes)\n      message_file = pullrequest_editmsg_file\n\n      if valid_editmsg_file?(message_file)\n        title, body = read_editmsg(message_file)\n        previous_message = [title, body].compact.join(\"\\n\\n\") if title\n      end\n\n      File.open(message_file, 'w') { |msg|\n        yield msg, previous_message\n        if changes\n          msg.puts \"#\\n# Changes:\\n#\"\n          msg.puts changes.gsub(/^/, '# ').gsub(/ +$/, '')\n        end\n      }\n\n      edit_cmd = Array(git_editor).dup\n      edit_cmd << '-c' << 'set ft=gitcommit tw=0 wrap lbr' if edit_cmd[0] =~ /^[mg]?vim$/\n      edit_cmd << message_file\n      system(*edit_cmd)\n\n      unless $?.success?\n        # writing was cancelled, or the editor never opened in the first place\n        delete_editmsg(message_file)\n        abort \"error using text editor for pull request message\"\n      end\n\n      title, body = read_editmsg(message_file)\n      abort \"Aborting due to empty pull request title\" unless title\n      [title, body]\n    end\n\n    # This unfortunate hack is because older versions of hub never cleaned up\n    # the pullrequest_editmsg_file, which newer hub would pick up and\n    # misinterpret as a message which should be reused after a failed PR.\n    def valid_editmsg_file?(message_file)\n      File.exist?(message_file) &&\n        File.mtime(message_file) > File.mtime(__FILE__)\n    end\n\n    def read_msg(message)\n      message.split(\"\\n\\n\", 2).each {|s| s.strip! }.reject {|s| s.empty? }\n    end\n\n    def pullrequest_editmsg_file\n      File.join(git_dir, 'PULLREQ_EDITMSG')\n    end\n\n    def read_editmsg(file)\n      title, body = '', ''\n      File.open(file, 'r') { |msg|\n        msg.each_line do |line|\n          next if line.index('#') == 0\n          ((title.empty? and line =~ /\\S/) ? title : body) << line\n        end\n      }\n      title.tr!(\"\\n\", ' ')\n      title.strip!\n      body.strip!\n\n      [title =~ /\\S/ ? title : nil, body =~ /\\S/ ? body : nil]\n    end\n\n    def delete_editmsg(file = pullrequest_editmsg_file)\n      File.delete(file) if File.exist?(file)\n    end\n\n    def expand_alias(cmd)\n      if expanded = git_alias_for(cmd)\n        if expanded.index('!') != 0\n          require 'shellwords' unless defined?(::Shellwords)\n          Shellwords.shellwords(expanded)\n        end\n      end\n    end\n\n    def display_api_exception(action, response)\n      $stderr.puts \"Error #{action}: #{response.message.strip} (HTTP #{response.status})\"\n      if 422 == response.status and response.error_message?\n        # display validation errors\n        msg = response.error_message\n        msg = msg.join(\"\\n\") if msg.respond_to? :join\n        warn msg\n      end\n    end\n\n  end\nend\n", "require 'shellwords'\nrequire 'forwardable'\nrequire 'delegate'\n\nmodule Hub\n  # Methods for inspecting the environment, such as reading git config,\n  # repository info, and other.\n  module Context\n    extend Forwardable\n\n    NULL = defined?(File::NULL) ? File::NULL : File.exist?('/dev/null') ? '/dev/null' : 'NUL'\n\n    # Shells out to git to get output of its commands\n    class GitReader\n      attr_reader :executable\n\n      def initialize(executable = nil, &read_proc)\n        @executable = executable || 'git'\n        # caches output when shelling out to git\n        read_proc ||= lambda { |cache, cmd|\n          str = command_to_string(cmd)\n          result = silence_stderr { %x{#{str}}.chomp }\n          cache[cmd] = $?.success? && !result.empty? ? result : nil\n        }\n        @cache = Hash.new(&read_proc)\n      end\n\n      def add_exec_flags(flags)\n        @executable = Array(executable).concat(flags)\n      end\n\n      def read_config(cmd, all = false)\n        config_cmd = ['config', (all ? '--get-all' : '--get'), *cmd]\n        config_cmd = config_cmd.join(' ') unless cmd.respond_to? :join\n        read config_cmd\n      end\n\n      def read(cmd)\n        @cache[cmd]\n      end\n\n      def stub_config_value(key, value, get = '--get')\n        stub_command_output \"config #{get} #{key}\", value\n      end\n\n      def stub_command_output(cmd, value)\n        @cache[cmd] = value.nil? ? nil : value.to_s\n      end\n\n      def stub!(values)\n        @cache.update values\n      end\n\n      private\n\n      def to_exec(args)\n        args = Shellwords.shellwords(args) if args.respond_to? :to_str\n        Array(executable) + Array(args)\n      end\n\n      def command_to_string(cmd)\n        full_cmd = to_exec(cmd)\n        full_cmd.respond_to?(:shelljoin) ? full_cmd.shelljoin : full_cmd.join(' ')\n      end\n\n      def silence_stderr\n        oldio = STDERR.dup\n        STDERR.reopen(NULL)\n        yield\n      ensure\n        STDERR.reopen(oldio)\n      end\n    end\n\n    module GitReaderMethods\n      extend Forwardable\n\n      def_delegator :git_reader, :read_config, :git_config\n      def_delegator :git_reader, :read, :git_command\n\n      def self.extended(base)\n        base.extend Forwardable\n        base.def_delegators :'self.class', :git_config, :git_command\n      end\n    end\n\n    class Error < RuntimeError; end\n    class FatalError < Error; end\n\n    private\n\n    def git_reader\n      @git_reader ||= GitReader.new ENV['GIT']\n    end\n\n    include GitReaderMethods\n    private :git_config, :git_command\n\n    def local_repo(fatal = true)\n      return nil if defined?(@local_repo) && @local_repo == false\n      @local_repo =\n        if git_dir = git_command('rev-parse -q --git-dir')\n          LocalRepo.new(git_reader, current_dir, git_dir)\n        elsif fatal\n          raise FatalError, \"Not a git repository\"\n        else\n          false\n        end\n    end\n\n    repo_methods = [\n      :current_branch, :git_dir,\n      :remote_branch_and_project,\n      :repo_owner, :repo_host,\n      :remotes, :remotes_group, :origin_remote\n    ]\n    def_delegator :local_repo, :name, :repo_name\n    def_delegators :local_repo, *repo_methods\n    private :repo_name, *repo_methods\n\n    def master_branch\n      if local_repo(false)\n        local_repo.master_branch\n      else\n        # FIXME: duplicates functionality of LocalRepo#master_branch\n        Branch.new nil, 'refs/heads/master'\n      end\n    end\n\n    class LocalRepo < Struct.new(:git_reader, :dir, :git_dir)\n      include GitReaderMethods\n\n      def name\n        if project = main_project\n          project.name\n        else\n          File.basename(dir)\n        end\n      end\n\n      def repo_owner\n        if project = main_project\n          project.owner\n        end\n      end\n\n      def repo_host\n        project = main_project and project.host\n      end\n\n      def main_project\n        remote = origin_remote and remote.project\n      end\n\n      def remote_branch_and_project(username_fetcher, prefer_upstream = false)\n        project = main_project\n        if project and branch = current_branch\n          branch = branch.push_target(username_fetcher.call(project.host), prefer_upstream)\n          project = remote_by_name(branch.remote_name).project if branch && branch.remote?\n        end\n        [branch, project]\n      end\n\n      def current_branch\n        @current_branch ||= branch_at_ref('HEAD')\n      end\n\n      def branch_at_ref(*parts)\n        begin\n          head = file_read(*parts)\n        rescue Errno::ENOENT\n          return nil\n        else\n          Branch.new(self, head.rstrip) if head.sub!('ref: ', '')\n        end\n      end\n\n      def file_read(*parts)\n        File.read(File.join(git_dir, *parts))\n      end\n\n      def file_exist?(*parts)\n        File.exist?(File.join(git_dir, *parts))\n      end\n\n      def master_branch\n        if remote = origin_remote\n          default_branch = branch_at_ref(\"refs/remotes/#{remote}/HEAD\")\n        end\n        default_branch || Branch.new(self, 'refs/heads/master')\n      end\n\n      ORIGIN_NAMES = %w[ upstream github origin ]\n\n      def remotes\n        @remotes ||= begin\n          names = []\n          url_memo = Hash.new {|h,k| names << k; h[k]=[] }\n          git_command('remote -v').to_s.split(\"\\n\").map do |line|\n            next if line !~ /^(.+?)\\t(.+) \\(/\n            name, url = $1, $2\n            url_memo[name] << url\n          end\n          ((ORIGIN_NAMES + names) & names).map do |name|\n            urls = url_memo[name].uniq\n            Remote.new(self, name, urls)\n          end\n        end\n      end\n\n      def remotes_for_publish(owner_name)\n        list = ORIGIN_NAMES.map {|n| remote_by_name(n) }\n        list << remotes.find {|r| p = r.project and p.owner == owner_name }\n        list.compact.uniq.reverse\n      end\n\n      def remotes_group(name)\n        git_config \"remotes.#{name}\"\n      end\n\n      def origin_remote\n        remotes.detect {|r| r.urls.any? }\n      end\n\n      def remote_by_name(remote_name)\n        remotes.find {|r| r.name == remote_name }\n      end\n\n      def known_host?(host)\n        default = default_host\n        default == host || \"ssh.#{default}\" == host ||\n          git_config('hub.host', :all).to_s.split(\"\\n\").include?(host)\n      end\n\n      def self.default_host\n        ENV['GITHUB_HOST'] || main_host\n      end\n\n      def self.main_host\n        'github.com'\n      end\n\n      extend Forwardable\n      def_delegators :'self.class', :default_host, :main_host\n\n      def ssh_config\n        @ssh_config ||= SshConfig.new\n      end\n    end\n\n    class GithubProject < Struct.new(:local_repo, :owner, :name, :host)\n      def self.from_url(url, local_repo)\n        if local_repo.known_host?(url.host)\n          _, owner, name = url.path.split('/', 4)\n          GithubProject.new(local_repo, owner, name.sub(/\\.git$/, ''), url.host)\n        end\n      end\n\n      attr_accessor :repo_data\n\n      def initialize(*args)\n        super\n        self.name = self.name.tr(' ', '-')\n        self.host ||= (local_repo || LocalRepo).default_host\n        self.host = host.sub(/^ssh\\./i, '') if 'ssh.github.com' == host.downcase\n      end\n\n      def private?\n        repo_data ? repo_data.fetch('private') :\n          host != (local_repo || LocalRepo).main_host\n      end\n\n      def owned_by(new_owner)\n        new_project = dup\n        new_project.owner = new_owner\n        new_project\n      end\n\n      def name_with_owner\n        \"#{owner}/#{name}\"\n      end\n\n      def ==(other)\n        name_with_owner == other.name_with_owner\n      end\n\n      def remote\n        local_repo.remotes.find { |r| r.project == self }\n      end\n\n      def web_url(path = nil, protocol_config = nil)\n        project_name = name_with_owner\n        if project_name.sub!(/\\.wiki$/, '')\n          unless '/wiki' == path\n            path = if path =~ %r{^/commits/} then '/_history'\n                   else path.to_s.sub(/\\w+/, '_\\0')\n                   end\n            path = '/wiki' + path\n          end\n        end\n        '%s://%s/%s' % [\n          protocol_config ? protocol_config.call(host) : 'https',\n          host,\n          project_name + path.to_s\n        ]\n      end\n\n      def git_url(options = {})\n        if options[:https] then \"https://#{host}/\"\n        elsif options[:private] or private? then \"git@#{host}:\"\n        else \"git://#{host}/\"\n        end + name_with_owner + '.git'\n      end\n    end\n\n    class GithubURL < DelegateClass(URI::HTTP)\n      extend Forwardable\n\n      attr_reader :project\n      def_delegator :project, :name, :project_name\n      def_delegator :project, :owner, :project_owner\n\n      def self.resolve(url, local_repo)\n        u = URI(url)\n        if %[http https].include? u.scheme and project = GithubProject.from_url(u, local_repo)\n          self.new(u, project)\n        end\n      rescue URI::InvalidURIError\n        nil\n      end\n\n      def initialize(uri, project)\n        @project = project\n        super(uri)\n      end\n\n      # segment of path after the project owner and name\n      def project_path\n        path.split('/', 4)[3]\n      end\n    end\n\n    class Branch < Struct.new(:local_repo, :name)\n      alias to_s name\n\n      def short_name\n        name.sub(%r{^refs/(remotes/)?.+?/}, '')\n      end\n\n      def master?\n        master_name = if local_repo then local_repo.master_branch.short_name\n        else 'master'\n        end\n        short_name == master_name\n      end\n\n      def upstream\n        if branch = local_repo.git_command(\"rev-parse --symbolic-full-name #{short_name}@{upstream}\")\n          Branch.new local_repo, branch\n        end\n      end\n\n      def push_target(owner_name, prefer_upstream = false)\n        push_default = local_repo.git_config('push.default')\n        if %w[upstream tracking].include?(push_default)\n          upstream\n        else\n          short = short_name\n          refs = local_repo.remotes_for_publish(owner_name).map { |remote|\n            \"refs/remotes/#{remote}/#{short}\"\n          }\n          refs.reverse! if prefer_upstream\n          if branch = refs.detect {|ref| local_repo.file_exist?(ref) }\n            Branch.new(local_repo, branch)\n          end\n        end\n      end\n\n      def remote?\n        name.index('refs/remotes/') == 0\n      end\n\n      def remote_name\n        name =~ %r{^refs/remotes/([^/]+)} and $1 or\n          raise Error, \"can't get remote name from #{name.inspect}\"\n      end\n    end\n\n    class Remote < Struct.new(:local_repo, :name, :raw_urls)\n      alias to_s name\n\n      def ==(other)\n        other.respond_to?(:to_str) ? name == other.to_str : super\n      end\n\n      def project\n        urls.each { |url|\n          if valid = GithubProject.from_url(url, local_repo)\n            return valid\n          end\n        }\n        nil\n      end\n\n      def github_url\n        urls.detect {|url| local_repo.known_host?(url.host) }\n      end\n\n      def urls\n        @urls ||= raw_urls.map do |url|\n          with_normalized_url(url) do |normalized|\n            begin\n              uri_parse(normalized)\n            rescue URI::InvalidURIError\n            end\n          end\n        end.compact\n      end\n\n      def with_normalized_url(url)\n        if url =~ %r{^[\\w-]+://} || url =~ %r{^([^/]+?):}\n          url = \"ssh://#{$1}/#{$'}\" if $1\n          yield url\n        end\n      end\n\n      def uri_parse uri\n        uri = URI.parse uri\n        if uri.host != local_repo.default_host\n          ssh = local_repo.ssh_config\n          uri.host = ssh.get_value(uri.host, :HostName) { uri.host }\n        end\n        uri\n      end\n    end\n\n    ## helper methods for local repo, GH projects\n\n    def github_project(name, owner = nil)\n      if owner and owner.index('/')\n        owner, name = owner.split('/', 2)\n      elsif name and name.index('/')\n        owner, name = name.split('/', 2)\n      else\n        name ||= repo_name\n        owner ||= github_user\n      end\n\n      if local_repo(false) and main_project = local_repo.main_project\n        project = main_project.dup\n        project.owner = owner\n        project.name = name\n        project\n      else\n        GithubProject.new(local_repo(false), owner, name)\n      end\n    end\n\n    def git_url(owner = nil, name = nil, options = {})\n      project = github_project(name, owner)\n      project.git_url({:https => https_protocol?}.update(options))\n    end\n\n    def resolve_github_url(url)\n      GithubURL.resolve(url, local_repo) if url =~ /^https?:/\n    end\n\n    # legacy setting\n    def http_clone?\n      git_config('--bool hub.http-clone') == 'true'\n    end\n\n    def https_protocol?\n      git_config('hub.protocol') == 'https' or http_clone?\n    end\n\n    def git_alias_for(name)\n      git_config \"alias.#{name}\"\n    end\n\n    def rev_list(a, b)\n      git_command(\"rev-list --cherry-pick --right-only --no-merges #{a}...#{b}\")\n    end\n\n    PWD = Dir.pwd\n\n    def current_dir\n      PWD\n    end\n\n    def is_repo?\n      !!local_repo(false)\n    end\n\n    def git_editor\n      # possible: ~/bin/vi, $SOME_ENVIRONMENT_VARIABLE, \"C:\\Program Files\\Vim\\gvim.exe\" --nofork\n      editor = git_command 'var GIT_EDITOR'\n      editor.gsub!(/\\$(\\w+|\\{\\w+\\})/) { ENV[$1.tr('{}', '')] }\n      editor = ENV[$1] if editor =~ /^\\$(\\w+)$/\n      editor = File.expand_path editor if (editor =~ /^[~.]/ or editor.index('/')) and editor !~ /[\"']/\n      # avoid shellsplitting \"C:\\Program Files\"\n      if File.exist? editor then [editor]\n      else editor.shellsplit\n      end\n    end\n\n    module System\n      # Cross-platform web browser command; respects the value set in $BROWSER.\n      # \n      # Returns an array, e.g.: ['open']\n      def browser_launcher\n        browser = ENV['BROWSER'] || (\n          osx? ? 'open' : windows? ? %w[cmd /c start] :\n          %w[xdg-open cygstart x-www-browser firefox opera mozilla netscape].find { |comm| which comm }\n        )\n\n        abort \"Please set $BROWSER to a web launcher to use this command.\" unless browser\n        Array(browser)\n      end\n\n      def osx?\n        require 'rbconfig'\n        RbConfig::CONFIG['host_os'].to_s.include?('darwin')\n      end\n\n      def windows?\n        require 'rbconfig'\n        RbConfig::CONFIG['host_os'] =~ /msdos|mswin|djgpp|mingw|windows/\n      end\n\n      def unix?\n        require 'rbconfig'\n        RbConfig::CONFIG['host_os'] =~ /(aix|darwin|linux|(net|free|open)bsd|cygwin|solaris|irix|hpux)/i\n      end\n\n      # Cross-platform way of finding an executable in the $PATH.\n      #\n      #   which('ruby') #=> /usr/bin/ruby\n      def which(cmd)\n        exts = ENV['PATHEXT'] ? ENV['PATHEXT'].split(';') : ['']\n        ENV['PATH'].split(File::PATH_SEPARATOR).each do |path|\n          exts.each { |ext|\n            exe = \"#{path}/#{cmd}#{ext}\"\n            return exe if File.executable? exe\n          }\n        end\n        return nil\n      end\n\n      # Checks whether a command exists on this system in the $PATH.\n      #\n      # name - The String name of the command to check for.\n      #\n      # Returns a Boolean.\n      def command?(name)\n        !which(name).nil?\n      end\n\n      def terminal_width\n        if unix?\n          width = %x{stty size 2>#{NULL}}.split[1].to_i\n          width = %x{tput cols 2>#{NULL}}.to_i if width.zero?\n        else\n          width = 0\n        end\n        width < 10 ? 78 : width\n      end\n    end\n\n    include System\n    extend System\n  end\nend\n"], "buggy_code_start_loc": [522, 559], "buggy_code_end_loc": [523, 563], "fixing_code_start_loc": [522, 558], "fixing_code_end_loc": [523, 558], "type": "CWE-310", "message": "The am function in lib/hub/commands.rb in hub before 1.12.1 allows local users to overwrite arbitrary files via a symlink attack on a temporary patch file.", "other": {"cve": {"id": "CVE-2014-0177", "sourceIdentifier": "secalert@redhat.com", "published": "2014-05-27T14:55:10.540", "lastModified": "2023-06-06T14:02:25.683", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The am function in lib/hub/commands.rb in hub before 1.12.1 allows local users to overwrite arbitrary files via a symlink attack on a temporary patch file."}, {"lang": "es", "value": "La funci\u00f3n am en lib/hub/commands.rb en hub anterior a 1.12.1 permite a usuarios locales sobrescribir archivos arbitrarios a trav\u00e9s de un ataque de enlace simb\u00f3lico sobre un archivo de parche temporal."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-310"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:github:hub:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.12.0", "matchCriteriaId": "53E52D34-F842-4DB6-AE48-7480A645A58D"}]}]}], "references": [{"url": "https://github.com/github/hub/commit/016ec99d25b1cb83cb4367e541177aa431beb600", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/github/hub/commit/016ec99d25b1cb83cb4367e541177aa431beb600"}}