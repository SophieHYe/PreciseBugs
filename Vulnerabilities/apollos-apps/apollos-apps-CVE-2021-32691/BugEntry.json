{"buggy_code": ["import { graphql } from 'graphql';\nimport { fetch } from 'apollo-server-env';\nimport ApollosConfig from '@apollosproject/config';\nimport { createTestHelpers } from '@apollosproject/server-core/lib/testUtils';\nimport { peopleSchema, mediaSchema } from '@apollosproject/data-schema';\n\nimport * as Auth from '../index';\nimport * as Person from '../../people/index';\n\nimport { generateToken, registerToken } from '../token';\n\nApollosConfig.loadJs({\n  ROCK: {\n    API_URL: 'https://apollosrock.newspring.cc/api',\n    API_TOKEN: 'some-rock-token',\n  },\n});\n\nclass CacheMock {\n  get = jest.fn();\n\n  set = jest.fn();\n}\n\nconst Cache = { dataSource: CacheMock };\n\nconst { getContext, getSchema } = createTestHelpers({ Auth, Person, Cache });\n\ndescribe('Auth', () => {\n  let schema;\n  let context;\n  beforeEach(() => {\n    fetch.resetMocks();\n    fetch.mockRockDataSourceAPI();\n    schema = getSchema([peopleSchema, mediaSchema]);\n    context = getContext();\n  });\n\n  it('logs in a user', async () => {\n    const query = `\n      mutation {\n        authenticate(identity: \"some-identity\", password: \"good\") {\n          user {\n            id\n            profile {\n              email\n            }\n            rockToken\n            rock {\n              authCookie\n              authToken\n            }\n          }\n        }\n      }\n    `;\n    const rootValue = {};\n\n    context.dataSources.Auth.getAuthToken = jest.fn(() => 'some token');\n    const result = await graphql(schema, query, rootValue, context);\n    expect(result).toMatchSnapshot();\n    expect(context.dataSources.Cache.set.mock.calls).toMatchSnapshot();\n  });\n\n  it('throws invalid credentials error on bad password', async () => {\n    const query = `\n      mutation {\n        authenticate(identity: \"some-identity\", password: \"bad\") {\n          user {\n            id\n          }\n        }\n      }\n    `;\n    const rootValue = {};\n\n    const result = await graphql(schema, query, rootValue, context);\n    expect(result).toMatchSnapshot();\n  });\n\n  describe('currentUser query', () => {\n    const query = `\n      query {\n        currentUser {\n          id\n          profile {\n            email\n          }\n        }\n      }\n    `;\n    it('requires you to be logged in', async () => {\n      const rootValue = {};\n\n      const result = await graphql(schema, query, rootValue, context);\n      expect(result).toMatchSnapshot();\n    });\n\n    it('queries current user when logged in', async () => {\n      const rootValue = {};\n      const token = generateToken({ cookie: 'some-cookie', sessionId: 123 });\n\n      context = getContext({\n        req: {\n          headers: { authorization: token },\n        },\n      });\n\n      const result = await graphql(schema, query, rootValue, context);\n      expect(result).toMatchSnapshot();\n    });\n\n    it('will return current person from context to avoid duplicate checks', async () => {\n      const rootValue = {};\n      const token = generateToken({ cookie: 'some-cookie', sessionId: 123 });\n\n      context = getContext({\n        req: {\n          headers: { authorization: token },\n        },\n      });\n\n      context.dataSources.Auth.get = jest.fn(() => ({}));\n\n      context.currentPerson = { id: 123456 };\n\n      const result = await graphql(schema, query, rootValue, context);\n      expect(result).toMatchSnapshot();\n      expect(context.dataSources.Auth.get.mock).toMatchSnapshot();\n      // the `get` method shouldn't bet hit b/c we aren't calling `currentUser`\n      // the current user is already on the context\n      expect(context.dataSources.Auth.get.mock.calls.length).toEqual(0);\n    });\n\n    it('logs a user out without a sessionId', async () => {\n      const rootValue = {};\n      const token = generateToken({ cookie: 'some-cookie' });\n      context = getContext({\n        req: {\n          headers: { authorization: token },\n        },\n      });\n\n      const result = await graphql(schema, query, rootValue, context);\n      expect(result).toMatchSnapshot();\n    });\n\n    it('queries current user when logged in', async () => {\n      const rootValue = {};\n      try {\n        const { userToken, rockCookie } = registerToken('asdfasdfasdf');\n        context.userToken = userToken;\n        context.rockCookie = rockCookie;\n\n        await graphql(schema, query, rootValue, context);\n      } catch (e) {\n        expect(e.message).toEqual('Invalid token');\n      }\n    });\n  });\n\n  it('registers an auth token and passes the cookie on requests to rock', async () => {\n    const token = generateToken({ cookie: 'some-cookie', sessionId: 123 });\n    const secondContext = getContext({\n      req: {\n        headers: { authorization: token },\n      },\n    });\n    const query = `\n      query {\n        currentUser {\n          id\n        }\n      }\n    `;\n    const rootValue = {};\n    await graphql(schema, query, rootValue, secondContext);\n    expect(fetch.mock.calls[0][0].headers).toMatchSnapshot();\n  });\n\n  describe('Change Password', () => {\n    it('throws error without a current user', async () => {\n      try {\n        await context.dataSources.Auth.changePassword({\n          password: 'newPassword',\n        });\n      } catch (e) {\n        expect(e.message).toEqual('Must be logged in');\n      }\n    });\n\n    it('generates a new token', async () => {\n      const { userToken, rockCookie } = registerToken(\n        generateToken({ cookie: 'some-cookie' })\n      );\n      context.userToken = userToken;\n      context.rockCookie = rockCookie;\n      const {\n        rockCookie: newCookie,\n        token: newToken,\n      } = await context.dataSources.Auth.changePassword({\n        password: 'good',\n      });\n      expect(newCookie).toEqual('some cookie');\n      expect(typeof newToken).toEqual('string');\n    });\n  });\n\n  describe('User Registration', () => {\n    it('checks if user is already registered', async () => {\n      const result = await context.dataSources.Auth.personExists({\n        identity: 'isaac.hardy@newspring.cc',\n      });\n\n      expect(result).toEqual(true);\n    });\n\n    it('throws error in personExists', async () => {\n      const result = await context.dataSources.Auth.personExists({\n        identity: 'fake',\n      });\n\n      expect(result).toEqual(false);\n    });\n\n    it('creates user profile', async () => {\n      const result = await context.dataSources.Auth.createUserProfile({\n        email: 'isaac.hardy@newspring.cc',\n      });\n\n      expect(result).toEqual('35');\n    });\n\n    it('throws error in createUserProfile', async () => {\n      try {\n        await context.dataSources.Auth.createUserProfile({\n          email: '',\n        });\n      } catch (e) {\n        expect(e.message).toEqual('Unable to create profile!');\n      }\n    });\n\n    it('creates user login', async () => {\n      const result = await context.dataSources.Auth.createUserLogin({\n        email: 'isaac.hardy@newspring.cc',\n        password: 'password',\n        personId: 35,\n      });\n\n      expect(result).toEqual({ id: 21 });\n    });\n\n    it('throws error in createUserLogin', async () => {\n      try {\n        await context.dataSources.Auth.createUserLogin({\n          email: '',\n          password: 'password',\n          personId: 35,\n        });\n      } catch (e) {\n        expect(e.message).toEqual('Unable to create user login!');\n      }\n    });\n\n    it('creates new registration', async () => {\n      const query = `\n        mutation {\n          registerPerson(email: \"hello.world@earth.org\", password: \"good\") {\n            user {\n              id\n              profile {\n                email\n              }\n            }\n          }\n        }\n      `;\n\n      const rootValue = {};\n\n      const result = await graphql(schema, query, rootValue, context);\n      expect(result).toMatchSnapshot();\n    });\n\n    it('passes the right args when creating a registration', async () => {\n      const query = `\n        mutation {\n          registerPerson(email: \"hello.world@earth.org\", password: \"good\") {\n            user {\n              id\n              profile {\n                id\n                email\n              }\n            }\n          }\n        }\n      `;\n\n      const createUserProfile = jest\n        .fn()\n        .mockImplementation(async () => Promise.resolve('123'));\n      const createUserLogin = jest.fn();\n      const rootValue = {};\n\n      context.dataSources.Auth.createUserLogin = createUserLogin;\n      context.dataSources.Auth.createUserProfile = createUserProfile;\n\n      await graphql(schema, query, rootValue, context);\n\n      expect(createUserProfile.mock.calls).toMatchSnapshot();\n      expect(createUserLogin.mock.calls).toMatchSnapshot();\n    });\n  });\n});\n", "// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Person Throws an error if trying to set an invalid gender 1`] = `\"Rock gender must be either Unknown, Male, or Female\"`;\n\nexports[`Person creates a profile 1`] = `\nArray [\n  Array [\n    \"/People\",\n    Object {\n      \"BirthDay\": 1,\n      \"BirthMonth\": 2,\n      \"BirthYear\": 2020,\n      \"FirstName\": \"Vincent\",\n      \"Gender\": 1,\n      \"IsSystem\": false,\n    },\n  ],\n]\n`;\n\nexports[`Person creates a profile 2`] = `Object {}`;\n\nexports[`Person gets person from aliasId: The call to fetch the alias id 1`] = `\nArray [\n  Array [\n    \"/PersonAlias?%24filter=Id%20eq%2051&%24select=PersonId&%24top=1\",\n    Object {},\n    Object {},\n  ],\n]\n`;\n\nexports[`Person gets person from aliasId: The call to fetch the person by id 1`] = `\nArray [\n  Array [\n    123,\n  ],\n]\n`;\n\nexports[`Person gets person from aliasId: The result from getAliasId 1`] = `\nObject {\n  \"firstName\": \"John\",\n  \"id\": 321,\n}\n`;\n\nexports[`Person gets person from id 1`] = `\nArray [\n  Array [\n    \"People?%24filter=Id%20eq%2051&%24expand=Photo&%24top=1\",\n    Object {},\n    Object {},\n  ],\n]\n`;\n\nexports[`Person gets person from id 2`] = `\nObject {\n  \"id\": 51,\n}\n`;\n\nexports[`Person returns null when getPersonByAliasId is not valid: The call to fetch the alias id 1`] = `\nArray [\n  Array [\n    \"/PersonAlias?%24filter=Id%20eq%2051&%24select=PersonId&%24top=1\",\n    Object {},\n    Object {},\n  ],\n]\n`;\n\nexports[`Person returns null when getPersonByAliasId is not valid: The result from getAliasId 1`] = `null`;\n\nexports[`Person throws an error setting an invalid birth date 1`] = `\"BirthDate must be a valid date\"`;\n\nexports[`Person updates a user's birth date attributes 1`] = `\nObject {\n  \"birthDate\": \"1996-11-02T07:00:00.000Z\",\n  \"firstName\": \"Vincent\",\n  \"id\": 51,\n  \"lastName\": \"Wilson\",\n}\n`;\n\nexports[`Person updates a user's birth date attributes 2`] = `\nArray [\n  Array [],\n]\n`;\n\nexports[`Person updates a user's birth date attributes 3`] = `\nArray [\n  Array [\n    \"/People/51\",\n    Object {\n      \"BirthDay\": 2,\n      \"BirthMonth\": 11,\n      \"BirthYear\": 1996,\n    },\n  ],\n]\n`;\n\nexports[`Person updates a user's gender attributes: current person 1`] = `\nArray [\n  Array [],\n]\n`;\n\nexports[`Person updates a user's gender attributes: result 1`] = `\nObject {\n  \"firstName\": \"Vincent\",\n  \"gender\": \"Male\",\n  \"id\": 51,\n  \"lastName\": \"Wilson\",\n}\n`;\n\nexports[`Person updates a user's gender attributes: rock patch 1`] = `Array []`;\n\nexports[`Person updates a user's profile attributes 1`] = `\nArray [\n  Array [],\n]\n`;\n\nexports[`Person updates a user's profile attributes 2`] = `Array []`;\n\nexports[`Person updates a user's profile attributes 3`] = `\nObject {\n  \"firstName\": \"Nick\",\n  \"id\": 51,\n  \"lastName\": \"Wilson\",\n}\n`;\n\nexports[`Person uploads a user's profile picture: Get media datasource mock 1`] = `\nArray [\n  Array [\n    \"456\",\n  ],\n]\n`;\n\nexports[`Person uploads a user's profile picture: Get updated profile mock 1`] = `Array []`;\n\nexports[`Person uploads a user's profile picture: Update profile mock 1`] = `\nArray [\n  Array [\n    Array [\n      Object {\n        \"field\": \"PhotoId\",\n        \"value\": \"456\",\n      },\n    ],\n  ],\n]\n`;\n\nexports[`Person uploads a user's profile picture: Upload datasource mock 1`] = `\nArray [\n  Array [\n    Object {\n      \"filename\": \"img.jpg\",\n      \"length\": 456,\n      \"stream\": \"123\",\n    },\n  ],\n]\n`;\n\nexports[`Person uploads a user's profile picture: Upload result 1`] = `\nObject {\n  \"firstName\": \"Vincent\",\n  \"id\": 51,\n  \"lastName\": \"Wilson\",\n  \"photo\": Object {\n    \"id\": 123,\n    \"url\": \"http://imageurl.....\",\n  },\n}\n`;\n", "import { AuthenticationError, UserInputError } from 'apollo-server';\nimport { camelCase, mapKeys } from 'lodash';\nimport RockApolloDataSource from '@apollosproject/rock-apollo-data-source';\nimport moment from 'moment';\nimport { fieldsAsObject } from '../utils';\n\nconst RockGenderMap = {\n  Unknown: 0,\n  Male: 1,\n  Female: 2,\n};\n\nexport const mapApollosFieldsToRock = (fields) => {\n  const profileFields = { ...fields };\n\n  if (profileFields.Gender) {\n    if (!Object.keys(RockGenderMap).includes(profileFields.Gender)) {\n      throw new UserInputError(\n        'Rock gender must be either Unknown, Male, or Female'\n      );\n    }\n    profileFields.Gender = RockGenderMap[profileFields.Gender];\n  }\n\n  let rockUpdateFields = { ...profileFields };\n\n  if (profileFields.BirthDate) {\n    delete rockUpdateFields.BirthDate;\n    const birthDate = moment(profileFields.BirthDate);\n\n    if (!birthDate.isValid()) {\n      throw new UserInputError('BirthDate must be a valid date');\n    }\n\n    rockUpdateFields = {\n      ...rockUpdateFields,\n      // months in moment are 0 indexed\n      BirthMonth: birthDate.month() + 1,\n      BirthDay: birthDate.date(),\n      BirthYear: birthDate.year(),\n    };\n  }\n\n  return rockUpdateFields;\n};\n\nexport default class Person extends RockApolloDataSource {\n  resource = 'People';\n\n  getFromId = (id) =>\n    this.request().filter(`Id eq ${id}`).expand('Photo').first();\n\n  getFromAliasId = async (id) => {\n    // Fetch the PersonAlias, selecting only the PersonId.\n    const personAlias = await this.request('/PersonAlias')\n      .filter(`Id eq ${id}`)\n      .select('PersonId')\n      .first();\n\n    // If we have a personAlias, return him.\n    if (personAlias) {\n      return this.getFromId(personAlias.personId);\n    }\n    // Otherwise, return null.\n    return null;\n  };\n\n  create = (profile) => {\n    const rockUpdateFields = this.mapApollosFieldsToRock(profile);\n    return this.post('/People', {\n      Gender: 0, // required by Rock. Listed first so it can be overridden.\n      ...rockUpdateFields,\n      IsSystem: false, // required by rock\n    });\n  };\n\n  mapGender = ({ gender }) => {\n    // If the gender is coming from Rock (an int) map into the string value.\n    if (typeof gender === 'number') {\n      return Object.keys(RockGenderMap).find(\n        (key) => RockGenderMap[key] === gender\n      );\n    }\n    // Otherwise return the string value.\n    return gender;\n  };\n\n  mapApollosFieldsToRock = (fields) => {\n    return mapApollosFieldsToRock(fields);\n  };\n\n  // fields is an array of objects matching the pattern\n  // [{ field: String, value: String }]\n  updateProfile = async (fields) => {\n    const currentPerson = await this.context.dataSources.Auth.getCurrentPerson();\n\n    if (!currentPerson) throw new AuthenticationError('Invalid Credentials');\n\n    const profileFields = fieldsAsObject(fields);\n    const rockUpdateFields = this.mapApollosFieldsToRock(profileFields);\n\n    // Because we have a custom enum for Gender, we do this transform prior to creating our \"update object\"\n    // i.e. our schema will send Gender: 1 as Gender: Male\n    await this.patch(`/People/${currentPerson.id}`, rockUpdateFields);\n\n    return {\n      ...currentPerson,\n      ...mapKeys(profileFields, (_, key) => camelCase(key)),\n    };\n  };\n\n  uploadProfileImage = async (file, length) => {\n    const {\n      dataSources: { Auth, BinaryFiles },\n    } = this.context;\n\n    const currentPerson = await Auth.getCurrentPerson();\n\n    if (!currentPerson) throw new AuthenticationError('Invalid Credentials');\n\n    const { createReadStream, filename } = await file;\n\n    const stream = createReadStream();\n\n    const photoId = await BinaryFiles.uploadFile({ filename, stream, length });\n\n    const person = await this.updateProfile([\n      { field: 'PhotoId', value: photoId },\n    ]);\n\n    const photo = await BinaryFiles.getFromId(photoId);\n    return { ...person, photo };\n  };\n}\n"], "fixing_code": ["import { graphql } from 'graphql';\nimport { fetch } from 'apollo-server-env';\nimport ApollosConfig from '@apollosproject/config';\nimport { createTestHelpers } from '@apollosproject/server-core/lib/testUtils';\nimport { peopleSchema, mediaSchema } from '@apollosproject/data-schema';\n\nimport * as Auth from '../index';\nimport * as Person from '../../people/index';\n\nimport { generateToken, registerToken } from '../token';\n\nApollosConfig.loadJs({\n  ROCK: {\n    API_URL: 'https://apollosrock.newspring.cc/api',\n    API_TOKEN: 'some-rock-token',\n  },\n});\n\nclass CacheMock {\n  get = jest.fn();\n\n  set = jest.fn();\n}\n\nconst Cache = { dataSource: CacheMock };\n\nconst { getContext, getSchema } = createTestHelpers({ Auth, Person, Cache });\n\ndescribe('Auth', () => {\n  let schema;\n  let context;\n  beforeEach(() => {\n    fetch.resetMocks();\n    fetch.mockRockDataSourceAPI();\n    schema = getSchema([peopleSchema, mediaSchema]);\n    context = getContext();\n  });\n\n  it('logs in a user', async () => {\n    const query = `\n      mutation {\n        authenticate(identity: \"some-identity\", password: \"good\") {\n          user {\n            id\n            profile {\n              email\n            }\n            rockToken\n            rock {\n              authCookie\n              authToken\n            }\n          }\n        }\n      }\n    `;\n    const rootValue = {};\n\n    context.dataSources.Auth.getAuthToken = jest.fn(() => 'some token');\n    const result = await graphql(schema, query, rootValue, context);\n    expect(result).toMatchSnapshot();\n    expect(context.dataSources.Cache.set.mock.calls).toMatchSnapshot();\n  });\n\n  it('throws invalid credentials error on bad password', async () => {\n    const query = `\n      mutation {\n        authenticate(identity: \"some-identity\", password: \"bad\") {\n          user {\n            id\n          }\n        }\n      }\n    `;\n    const rootValue = {};\n\n    const result = await graphql(schema, query, rootValue, context);\n    expect(result).toMatchSnapshot();\n  });\n\n  describe('currentUser query', () => {\n    const query = `\n      query {\n        currentUser {\n          id\n          profile {\n            email\n          }\n        }\n      }\n    `;\n    it('requires you to be logged in', async () => {\n      const rootValue = {};\n\n      const result = await graphql(schema, query, rootValue, context);\n      expect(result).toMatchSnapshot();\n    });\n\n    it('queries current user when logged in', async () => {\n      const rootValue = {};\n      const token = generateToken({ cookie: 'some-cookie', sessionId: 123 });\n\n      context = getContext({\n        req: {\n          headers: { authorization: token },\n        },\n      });\n\n      const result = await graphql(schema, query, rootValue, context);\n      expect(result).toMatchSnapshot();\n    });\n\n    it('will return current person from context to avoid duplicate checks', async () => {\n      const rootValue = {};\n      const token = generateToken({ cookie: 'some-cookie', sessionId: 123 });\n\n      context = getContext({\n        req: {\n          headers: { authorization: token },\n        },\n      });\n\n      context.dataSources.Auth.get = jest.fn(() => ({}));\n\n      context.currentPerson = { id: 123456 };\n\n      const result = await graphql(schema, query, rootValue, context);\n      expect(result).toMatchSnapshot();\n      expect(context.dataSources.Auth.get.mock).toMatchSnapshot();\n      // the `get` method shouldn't bet hit b/c we aren't calling `currentUser`\n      // the current user is already on the context\n      expect(context.dataSources.Auth.get.mock.calls.length).toEqual(0);\n    });\n\n    it('logs a user out without a sessionId', async () => {\n      const rootValue = {};\n      const token = generateToken({ cookie: 'some-cookie' });\n      context = getContext({\n        req: {\n          headers: { authorization: token },\n        },\n      });\n\n      const result = await graphql(schema, query, rootValue, context);\n      expect(result).toMatchSnapshot();\n    });\n\n    it('queries current user when logged in', async () => {\n      const rootValue = {};\n      try {\n        const { userToken, rockCookie } = registerToken('asdfasdfasdf');\n        context.userToken = userToken;\n        context.rockCookie = rockCookie;\n\n        await graphql(schema, query, rootValue, context);\n      } catch (e) {\n        expect(e.message).toEqual('Invalid token');\n      }\n    });\n  });\n\n  it('registers an auth token and passes the cookie on requests to rock', async () => {\n    const token = generateToken({ cookie: 'some-cookie', sessionId: 123 });\n    const secondContext = getContext({\n      req: {\n        headers: { authorization: token },\n      },\n    });\n    const query = `\n      query {\n        currentUser {\n          id\n        }\n      }\n    `;\n    const rootValue = {};\n    await graphql(schema, query, rootValue, secondContext);\n    expect(fetch.mock.calls[0][0].headers).toMatchSnapshot();\n  });\n\n  describe('Change Password', () => {\n    it('throws error without a current user', async () => {\n      try {\n        await context.dataSources.Auth.changePassword({\n          password: 'newPassword',\n        });\n      } catch (e) {\n        expect(e.message).toEqual('Must be logged in');\n      }\n    });\n\n    it('generates a new token', async () => {\n      const { userToken, rockCookie } = registerToken(\n        generateToken({ cookie: 'some-cookie' })\n      );\n      context.userToken = userToken;\n      context.rockCookie = rockCookie;\n      const {\n        rockCookie: newCookie,\n        token: newToken,\n      } = await context.dataSources.Auth.changePassword({\n        password: 'good',\n      });\n      expect(newCookie).toEqual('some cookie');\n      expect(typeof newToken).toEqual('string');\n    });\n  });\n\n  describe('User Registration', () => {\n    it('checks if user is already registered', async () => {\n      const result = await context.dataSources.Auth.personExists({\n        identity: 'isaac.hardy@newspring.cc',\n      });\n\n      expect(result).toEqual(true);\n    });\n\n    it('throws error in personExists', async () => {\n      const result = await context.dataSources.Auth.personExists({\n        identity: 'fake',\n      });\n\n      expect(result).toEqual(false);\n    });\n\n    it('creates user profile', async () => {\n      context.dataSources.Person.create = jest.fn(() => 35);\n      const result = await context.dataSources.Auth.createUserProfile({\n        email: 'isaac.hardy@newspring.cc',\n      });\n\n      expect(result).toEqual(35);\n    });\n\n    it('throws error in createUserProfile', async () => {\n      try {\n        await context.dataSources.Auth.createUserProfile({\n          email: '',\n        });\n      } catch (e) {\n        expect(e.message).toEqual('Unable to create profile!');\n      }\n    });\n\n    it('creates user login', async () => {\n      const result = await context.dataSources.Auth.createUserLogin({\n        email: 'isaac.hardy@newspring.cc',\n        password: 'password',\n        personId: 35,\n      });\n\n      expect(result).toEqual({ id: 21 });\n    });\n\n    it('throws error in createUserLogin', async () => {\n      try {\n        await context.dataSources.Auth.createUserLogin({\n          email: '',\n          password: 'password',\n          personId: 35,\n        });\n      } catch (e) {\n        expect(e.message).toEqual('Unable to create user login!');\n      }\n    });\n\n    it('creates new registration', async () => {\n      const query = `\n        mutation {\n          registerPerson(email: \"hello.world@earth.org\", password: \"good\") {\n            user {\n              id\n              profile {\n                email\n              }\n            }\n          }\n        }\n      `;\n      context.dataSources.Person.create = jest.fn(() => 1);\n\n      const rootValue = {};\n\n      const result = await graphql(schema, query, rootValue, context);\n      expect(result).toMatchSnapshot();\n    });\n\n    it('passes the right args when creating a registration', async () => {\n      const query = `\n        mutation {\n          registerPerson(email: \"hello.world@earth.org\", password: \"good\") {\n            user {\n              id\n              profile {\n                id\n                email\n              }\n            }\n          }\n        }\n      `;\n\n      const createUserProfile = jest\n        .fn()\n        .mockImplementation(async () => Promise.resolve('123'));\n      const createUserLogin = jest.fn();\n      const rootValue = {};\n\n      context.dataSources.Auth.createUserLogin = createUserLogin;\n      context.dataSources.Auth.createUserProfile = createUserProfile;\n\n      await graphql(schema, query, rootValue, context);\n\n      expect(createUserProfile.mock.calls).toMatchSnapshot();\n      expect(createUserLogin.mock.calls).toMatchSnapshot();\n    });\n  });\n});\n", "// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Person Throws an error if trying to set an invalid gender 1`] = `\"Rock gender must be either Unknown, Male, or Female\"`;\n\nexports[`Person creates a profile 1`] = `\nArray [\n  Array [\n    \"/People\",\n    Object {\n      \"Gender\": 0,\n      \"IsSystem\": false,\n    },\n  ],\n]\n`;\n\nexports[`Person gets person from aliasId: The call to fetch the alias id 1`] = `\nArray [\n  Array [\n    \"/PersonAlias?%24filter=Id%20eq%2051&%24select=PersonId&%24top=1\",\n    Object {},\n    Object {},\n  ],\n]\n`;\n\nexports[`Person gets person from aliasId: The call to fetch the person by id 1`] = `\nArray [\n  Array [\n    123,\n  ],\n]\n`;\n\nexports[`Person gets person from aliasId: The result from getAliasId 1`] = `\nObject {\n  \"firstName\": \"John\",\n  \"id\": 321,\n}\n`;\n\nexports[`Person gets person from id 1`] = `\nArray [\n  Array [\n    \"People?%24filter=Id%20eq%2051&%24expand=Photo&%24top=1\",\n    Object {},\n    Object {},\n  ],\n]\n`;\n\nexports[`Person gets person from id 2`] = `\nObject {\n  \"id\": 51,\n}\n`;\n\nexports[`Person returns null when getPersonByAliasId is not valid: The call to fetch the alias id 1`] = `\nArray [\n  Array [\n    \"/PersonAlias?%24filter=Id%20eq%2051&%24select=PersonId&%24top=1\",\n    Object {},\n    Object {},\n  ],\n]\n`;\n\nexports[`Person returns null when getPersonByAliasId is not valid: The result from getAliasId 1`] = `null`;\n\nexports[`Person throws an error setting an invalid birth date 1`] = `\"BirthDate must be a valid date\"`;\n\nexports[`Person updates a user's birth date attributes 1`] = `\nObject {\n  \"birthDate\": \"1996-11-02T07:00:00.000Z\",\n  \"firstName\": \"Vincent\",\n  \"id\": 51,\n  \"lastName\": \"Wilson\",\n}\n`;\n\nexports[`Person updates a user's birth date attributes 2`] = `\nArray [\n  Array [],\n]\n`;\n\nexports[`Person updates a user's birth date attributes 3`] = `\nArray [\n  Array [\n    \"/People/51\",\n    Object {\n      \"BirthDay\": 2,\n      \"BirthMonth\": 11,\n      \"BirthYear\": 1996,\n    },\n  ],\n]\n`;\n\nexports[`Person updates a user's gender attributes: current person 1`] = `\nArray [\n  Array [],\n]\n`;\n\nexports[`Person updates a user's gender attributes: result 1`] = `\nObject {\n  \"firstName\": \"Vincent\",\n  \"gender\": \"Male\",\n  \"id\": 51,\n  \"lastName\": \"Wilson\",\n}\n`;\n\nexports[`Person updates a user's gender attributes: rock patch 1`] = `Array []`;\n\nexports[`Person updates a user's profile attributes 1`] = `\nArray [\n  Array [],\n]\n`;\n\nexports[`Person updates a user's profile attributes 2`] = `Array []`;\n\nexports[`Person updates a user's profile attributes 3`] = `\nObject {\n  \"firstName\": \"Nick\",\n  \"id\": 51,\n  \"lastName\": \"Wilson\",\n}\n`;\n\nexports[`Person uploads a user's profile picture: Get media datasource mock 1`] = `\nArray [\n  Array [\n    \"456\",\n  ],\n]\n`;\n\nexports[`Person uploads a user's profile picture: Get updated profile mock 1`] = `Array []`;\n\nexports[`Person uploads a user's profile picture: Update profile mock 1`] = `\nArray [\n  Array [\n    Array [\n      Object {\n        \"field\": \"PhotoId\",\n        \"value\": \"456\",\n      },\n    ],\n  ],\n]\n`;\n\nexports[`Person uploads a user's profile picture: Upload datasource mock 1`] = `\nArray [\n  Array [\n    Object {\n      \"filename\": \"img.jpg\",\n      \"length\": 456,\n      \"stream\": \"123\",\n    },\n  ],\n]\n`;\n\nexports[`Person uploads a user's profile picture: Upload result 1`] = `\nObject {\n  \"firstName\": \"Vincent\",\n  \"id\": 51,\n  \"lastName\": \"Wilson\",\n  \"photo\": Object {\n    \"id\": 123,\n    \"url\": \"http://imageurl.....\",\n  },\n}\n`;\n", "import { AuthenticationError, UserInputError } from 'apollo-server';\nimport { camelCase, mapKeys } from 'lodash';\nimport RockApolloDataSource from '@apollosproject/rock-apollo-data-source';\nimport moment from 'moment';\nimport { fieldsAsObject } from '../utils';\n\nconst RockGenderMap = {\n  Unknown: 0,\n  Male: 1,\n  Female: 2,\n};\n\nexport const mapApollosFieldsToRock = (fields) => {\n  const profileFields = { ...fields };\n\n  if (profileFields.Gender) {\n    if (!Object.keys(RockGenderMap).includes(profileFields.Gender)) {\n      throw new UserInputError(\n        'Rock gender must be either Unknown, Male, or Female'\n      );\n    }\n    profileFields.Gender = RockGenderMap[profileFields.Gender];\n  }\n\n  let rockUpdateFields = { ...profileFields };\n\n  if (profileFields.BirthDate) {\n    delete rockUpdateFields.BirthDate;\n    const birthDate = moment(profileFields.BirthDate);\n\n    if (!birthDate.isValid()) {\n      throw new UserInputError('BirthDate must be a valid date');\n    }\n\n    rockUpdateFields = {\n      ...rockUpdateFields,\n      // months in moment are 0 indexed\n      BirthMonth: birthDate.month() + 1,\n      BirthDay: birthDate.date(),\n      BirthYear: birthDate.year(),\n    };\n  }\n\n  return rockUpdateFields;\n};\n\nexport default class Person extends RockApolloDataSource {\n  resource = 'People';\n\n  getFromId = (id) =>\n    this.request().filter(`Id eq ${id}`).expand('Photo').first();\n\n  getFromAliasId = async (id) => {\n    // Fetch the PersonAlias, selecting only the PersonId.\n    const personAlias = await this.request('/PersonAlias')\n      .filter(`Id eq ${id}`)\n      .select('PersonId')\n      .first();\n\n    // If we have a personAlias, return him.\n    if (personAlias) {\n      return this.getFromId(personAlias.personId);\n    }\n    // Otherwise, return null.\n    return null;\n  };\n\n  create = async (profile) => {\n    const rockUpdateFields = this.mapApollosFieldsToRock(profile);\n    // auto-merge functionality is compromised\n    // we are creating a new user and patching them with profile details\n    const id = await this.post('/People', {\n      Gender: 0, // required by Rock. Listed first so it can be overridden.\n      IsSystem: false, // required by rock\n    });\n    await this.patch(`/People/${id}`, {\n      ...rockUpdateFields,\n    });\n    return id;\n  };\n\n  mapGender = ({ gender }) => {\n    // If the gender is coming from Rock (an int) map into the string value.\n    if (typeof gender === 'number') {\n      return Object.keys(RockGenderMap).find(\n        (key) => RockGenderMap[key] === gender\n      );\n    }\n    // Otherwise return the string value.\n    return gender;\n  };\n\n  mapApollosFieldsToRock = (fields) => {\n    return mapApollosFieldsToRock(fields);\n  };\n\n  // fields is an array of objects matching the pattern\n  // [{ field: String, value: String }]\n  updateProfile = async (fields) => {\n    const currentPerson = await this.context.dataSources.Auth.getCurrentPerson();\n\n    if (!currentPerson) throw new AuthenticationError('Invalid Credentials');\n\n    const profileFields = fieldsAsObject(fields);\n    const rockUpdateFields = this.mapApollosFieldsToRock(profileFields);\n\n    // Because we have a custom enum for Gender, we do this transform prior to creating our \"update object\"\n    // i.e. our schema will send Gender: 1 as Gender: Male\n    await this.patch(`/People/${currentPerson.id}`, rockUpdateFields);\n\n    return {\n      ...currentPerson,\n      ...mapKeys(profileFields, (_, key) => camelCase(key)),\n    };\n  };\n\n  uploadProfileImage = async (file, length) => {\n    const {\n      dataSources: { Auth, BinaryFiles },\n    } = this.context;\n\n    const currentPerson = await Auth.getCurrentPerson();\n\n    if (!currentPerson) throw new AuthenticationError('Invalid Credentials');\n\n    const { createReadStream, filename } = await file;\n\n    const stream = createReadStream();\n\n    const photoId = await BinaryFiles.uploadFile({ filename, stream, length });\n\n    const person = await this.updateProfile([\n      { field: 'PhotoId', value: photoId },\n    ]);\n\n    const photo = await BinaryFiles.getFromId(photoId);\n    return { ...person, photo };\n  };\n}\n"], "buggy_code_start_loc": [226, 10, 68], "buggy_code_end_loc": [278, 22, 74], "fixing_code_start_loc": [227, 10, 68], "fixing_code_end_loc": [281, 15, 80], "type": "CWE-287", "message": "Apollos Apps is an open source platform for launching church-related apps. In Apollos Apps versions prior to 2.20.0, new user registrations are able to access anyone's account by only knowing their basic profile information (name, birthday, gender, etc). This includes all app functionality within the app, as well as any authenticated links to Rock-based webpages (such as giving and events). There is a patch in version 2.20.0. As a workaround, one can patch one's server by overriding the `create` data source method on the `People` class.", "other": {"cve": {"id": "CVE-2021-32691", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-16T22:15:07.830", "lastModified": "2022-07-02T19:58:20.047", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Apollos Apps is an open source platform for launching church-related apps. In Apollos Apps versions prior to 2.20.0, new user registrations are able to access anyone's account by only knowing their basic profile information (name, birthday, gender, etc). This includes all app functionality within the app, as well as any authenticated links to Rock-based webpages (such as giving and events). There is a patch in version 2.20.0. As a workaround, one can patch one's server by overriding the `create` data source method on the `People` class."}, {"lang": "es", "value": "Apollos Apps es una plataforma de c\u00f3digo abierto para lanzar aplicaciones church-related. En Apollos Apps anterior a versi\u00f3n 2.20.0, los nuevos registros de usuarios pueden acceder a la cuenta de cualquier persona al solo conocer su informaci\u00f3n b\u00e1sica de perfil (nombre, cumplea\u00f1os, sexo, etc.). Esto incluye toda la funcionalidad de la aplicaci\u00f3n dentro de la misma, as\u00ed como cualquier enlace autentificado a las p\u00e1ginas web basadas en Rock (como donaciones y eventos). Hay un parche en la versi\u00f3n 2.20.0. Como soluci\u00f3n, uno puede parchear su servidor anulando el m\u00e9todo de fuente de datos \"create\" en la clase \"People\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-303"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apollosapp:data-connector-rock:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.20.0", "matchCriteriaId": "B30332C0-EF0D-4E0F-B2D8-06E18F621A4F"}]}]}], "references": [{"url": "https://github.com/ApollosProject/apollos-apps/commit/cb5f8f1c0b24f1b215b2bb5eb6f9a8e16d728ce2", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ApollosProject/apollos-apps/releases/tag/v2.20.0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ApollosProject/apollos-apps/security/advisories/GHSA-r578-pj6f-r4ff", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ApollosProject/apollos-apps/commit/cb5f8f1c0b24f1b215b2bb5eb6f9a8e16d728ce2"}}