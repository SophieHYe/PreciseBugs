{"buggy_code": ["# encoding: utf-8\n#\n# Redmine - project management software\n# Copyright (C) 2006-2017  Jean-Philippe Lang\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nrequire 'redmine/export/csv'\n\nmodule QueriesHelper\n  include ApplicationHelper\n\n  def filters_options_for_select(query)\n    ungrouped = []\n    grouped = {}\n    query.available_filters.map do |field, field_options|\n      if field_options[:type] == :relation\n        group = :label_relations\n      elsif field_options[:type] == :tree\n        group = query.is_a?(IssueQuery) ? :label_relations : nil\n      elsif field =~ /^cf_\\d+\\./\n        group = (field_options[:through] || field_options[:field]).try(:name)\n      elsif field =~ /^(.+)\\./\n        # association filters\n        group = \"field_#{$1}\".to_sym\n      elsif %w(member_of_group assigned_to_role).include?(field)\n        group = :field_assigned_to\n      elsif field_options[:type] == :date_past || field_options[:type] == :date\n        group = :label_date\n      end\n      if group\n        (grouped[group] ||= []) << [field_options[:name], field]\n      else\n        ungrouped << [field_options[:name], field]\n      end\n    end\n    # Don't group dates if there's only one (eg. time entries filters)\n    if grouped[:label_date].try(:size) == 1\n      ungrouped << grouped.delete(:label_date).first\n    end\n    s = options_for_select([[]] + ungrouped)\n    if grouped.present?\n      localized_grouped = grouped.map {|k,v| [k.is_a?(Symbol) ? l(k) : k.to_s, v]}\n      s << grouped_options_for_select(localized_grouped)\n    end\n    s\n  end\n\n  def query_filters_hidden_tags(query)\n    tags = ''.html_safe\n    query.filters.each do |field, options|\n      tags << hidden_field_tag(\"f[]\", field, :id => nil)\n      tags << hidden_field_tag(\"op[#{field}]\", options[:operator], :id => nil)\n      options[:values].each do |value|\n        tags << hidden_field_tag(\"v[#{field}][]\", value, :id => nil)\n      end\n    end\n    tags\n  end\n\n  def query_columns_hidden_tags(query)\n    tags = ''.html_safe\n    query.columns.each do |column|\n      tags << hidden_field_tag(\"c[]\", column.name, :id => nil)\n    end\n    tags\n  end\n\n  def query_hidden_tags(query)\n    query_filters_hidden_tags(query) + query_columns_hidden_tags(query)\n  end\n\n  def group_by_column_select_tag(query)\n    options = [[]] + query.groupable_columns.collect {|c| [c.caption, c.name.to_s]}\n    select_tag('group_by', options_for_select(options, @query.group_by))\n  end\n\n  def available_block_columns_tags(query)\n    tags = ''.html_safe\n    query.available_block_columns.each do |column|\n      tags << content_tag('label', check_box_tag('c[]', column.name.to_s, query.has_column?(column), :id => nil) + \" #{column.caption}\", :class => 'inline')\n    end\n    tags\n  end\n\n  def available_totalable_columns_tags(query, options={})\n    tag_name = (options[:name] || 't') + '[]'\n    tags = ''.html_safe\n    query.available_totalable_columns.each do |column|\n      tags << content_tag('label', check_box_tag(tag_name, column.name.to_s, query.totalable_columns.include?(column), :id => nil) + \" #{column.caption}\", :class => 'inline')\n    end\n    tags << hidden_field_tag(tag_name, '')\n    tags\n  end\n\n  def query_available_inline_columns_options(query)\n    (query.available_inline_columns - query.columns).reject(&:frozen?).collect {|column| [column.caption, column.name]}\n  end\n\n  def query_selected_inline_columns_options(query)\n    (query.inline_columns & query.available_inline_columns).reject(&:frozen?).collect {|column| [column.caption, column.name]}\n  end\n\n  def render_query_columns_selection(query, options={})\n    tag_name = (options[:name] || 'c') + '[]'\n    render :partial => 'queries/columns', :locals => {:query => query, :tag_name => tag_name}\n  end\n\n  def grouped_query_results(items, query, &block)\n    result_count_by_group = query.result_count_by_group\n    previous_group, first = false, true\n    totals_by_group = query.totalable_columns.inject({}) do |h, column|\n      h[column] = query.total_by_group_for(column)\n      h\n    end\n    items.each do |item|\n      group_name = group_count = nil\n      if query.grouped?\n        group = query.group_by_column.value(item)\n        if first || group != previous_group\n          if group.blank? && group != false\n            group_name = \"(#{l(:label_blank_value)})\"\n          else\n            group_name = format_object(group)\n          end\n          group_name ||= \"\"\n          group_count = result_count_by_group ? result_count_by_group[group] : nil\n          group_totals = totals_by_group.map {|column, t| total_tag(column, t[group] || 0)}.join(\" \").html_safe\n        end\n      end\n      yield item, group_name, group_count, group_totals\n      previous_group, first = group, false\n    end\n  end\n\n  def render_query_totals(query)\n    return unless query.totalable_columns.present?\n    totals = query.totalable_columns.map do |column|\n      total_tag(column, query.total_for(column))\n    end\n    content_tag('p', totals.join(\" \").html_safe, :class => \"query-totals\")\n  end\n\n  def total_tag(column, value)\n    label = content_tag('span', \"#{column.caption}:\")\n    value = if [:hours, :spent_hours, :total_spent_hours, :estimated_hours].include? column.name\n      format_hours(value)\n    else\n      format_object(value)\n    end\n    value = content_tag('span', value, :class => 'value')\n    content_tag('span', label + \" \" + value, :class => \"total-for-#{column.name.to_s.dasherize}\")\n  end\n\n  def column_header(query, column, options={})\n    if column.sortable?\n      css, order = nil, column.default_order\n      if column.name.to_s == query.sort_criteria.first_key\n        if query.sort_criteria.first_asc?\n          css = 'sort asc'\n          order = 'desc'\n        else\n          css = 'sort desc'\n          order = 'asc'\n        end\n      end\n      param_key = options[:sort_param] || :sort\n      sort_param = { param_key => query.sort_criteria.add(column.name, order).to_param }\n      while sort_param.keys.first.to_s =~ /^(.+)\\[(.+)\\]$/\n        sort_param = {$1 => {$2 => sort_param.values.first}}\n      end\n      link_options = {\n          :title => l(:label_sort_by, \"\\\"#{column.caption}\\\"\"),\n          :class => css\n        }\n      if options[:sort_link_options]\n        link_options.merge! options[:sort_link_options]\n      end\n      content = link_to(column.caption,\n          {:params => request.query_parameters.deep_merge(sort_param)},\n          link_options\n        )\n    else\n      content = column.caption\n    end\n    content_tag('th', content)\n  end\n\n  def column_content(column, item)\n    value = column.value_object(item)\n    if value.is_a?(Array)\n      value.collect {|v| column_value(column, item, v)}.compact.join(', ').html_safe\n    else\n      column_value(column, item, value)\n    end\n  end\n\n  def column_value(column, item, value)\n    case column.name\n    when :id\n      link_to value, issue_path(item)\n    when :subject\n      link_to value, issue_path(item)\n    when :parent\n      value ? (value.visible? ? link_to_issue(value, :subject => false) : \"##{value.id}\") : ''\n    when :description\n      item.description? ? content_tag('div', textilizable(item, :description), :class => \"wiki\") : ''\n    when :last_notes\n      item.last_notes.present? ? content_tag('div', textilizable(item, :last_notes), :class => \"wiki\") : ''\n    when :done_ratio\n      progress_bar(value)\n    when :relations\n      content_tag('span',\n        value.to_s(item) {|other| link_to_issue(other, :subject => false, :tracker => false)}.html_safe,\n        :class => value.css_classes_for(item))\n    when :hours, :estimated_hours\n      format_hours(value)\n    when :spent_hours\n      link_to_if(value > 0, format_hours(value), project_time_entries_path(item.project, :issue_id => \"#{item.id}\"))\n    when :total_spent_hours\n      link_to_if(value > 0, format_hours(value), project_time_entries_path(item.project, :issue_id => \"~#{item.id}\"))\n    when :attachments\n      value.to_a.map {|a| format_object(a)}.join(\" \").html_safe\n    else\n      format_object(value)\n    end\n  end\n\n  def csv_content(column, item)\n    value = column.value_object(item)\n    if value.is_a?(Array)\n      value.collect {|v| csv_value(column, item, v)}.compact.join(', ')\n    else\n      csv_value(column, item, value)\n    end\n  end\n\n  def csv_value(column, object, value)\n    case column.name\n    when :attachments\n      value.to_a.map {|a| a.filename}.join(\"\\n\")\n    else\n      format_object(value, false) do |value|\n        case value.class.name\n        when 'Float'\n          sprintf(\"%.2f\", value).gsub('.', l(:general_csv_decimal_separator))\n        when 'IssueRelation'\n          value.to_s(object)\n        when 'Issue'\n          if object.is_a?(TimeEntry)\n            \"#{value.tracker} ##{value.id}: #{value.subject}\"\n          else\n            value.id\n          end\n        else\n          value\n        end\n      end\n    end\n  end\n\n  def query_to_csv(items, query, options={})\n    columns = query.columns\n\n    Redmine::Export::CSV.generate do |csv|\n      # csv header fields\n      csv << columns.map {|c| c.caption.to_s}\n      # csv lines\n      items.each do |item|\n        csv << columns.map {|c| csv_content(c, item)}\n      end\n    end\n  end\n\n  # Retrieve query from session or build a new query\n  def retrieve_query(klass=IssueQuery, use_session=true, options={})\n    session_key = klass.name.underscore.to_sym\n\n    if params[:query_id].present?\n      cond = \"project_id IS NULL\"\n      cond << \" OR project_id = #{@project.id}\" if @project\n      @query = klass.where(cond).find(params[:query_id])\n      raise ::Unauthorized unless @query.visible?\n      @query.project = @project\n      session[session_key] = {:id => @query.id, :project_id => @query.project_id} if use_session\n    elsif api_request? || params[:set_filter] || !use_session || session[session_key].nil? || session[session_key][:project_id] != (@project ? @project.id : nil)\n      # Give it a name, required to be valid\n      @query = klass.new(:name => \"_\", :project => @project)\n      @query.build_from_params(params, options[:defaults])\n      session[session_key] = {:project_id => @query.project_id, :filters => @query.filters, :group_by => @query.group_by, :column_names => @query.column_names, :totalable_names => @query.totalable_names, :sort => @query.sort_criteria.to_a} if use_session\n    else\n      # retrieve from session\n      @query = nil\n      @query = klass.find_by_id(session[session_key][:id]) if session[session_key][:id]\n      @query ||= klass.new(:name => \"_\", :filters => session[session_key][:filters], :group_by => session[session_key][:group_by], :column_names => session[session_key][:column_names], :totalable_names => session[session_key][:totalable_names], :sort_criteria => session[session_key][:sort])\n      @query.project = @project\n    end\n    if params[:sort].present?\n      @query.sort_criteria = params[:sort]\n      if use_session\n        session[session_key] ||= {}\n        session[session_key][:sort] = @query.sort_criteria.to_a\n      end\n    end\n    @query\n  end\n\n  def retrieve_query_from_session(klass=IssueQuery)\n    session_key = klass.name.underscore.to_sym\n    session_data = session[session_key]\n\n    if session_data\n      if session_data[:id]\n        @query = IssueQuery.find_by_id(session_data[:id])\n        return unless @query\n      else\n        @query = IssueQuery.new(:name => \"_\", :filters => session_data[:filters], :group_by => session_data[:group_by], :column_names => session_data[:column_names], :totalable_names => session_data[:totalable_names], :sort_criteria => session[session_key][:sort])\n      end\n      if session_data.has_key?(:project_id)\n        @query.project_id = session_data[:project_id]\n      else\n        @query.project = @project\n      end\n      @query\n    end\n  end\n\n  # Returns the query definition as hidden field tags\n  def query_as_hidden_field_tags(query)\n    tags = hidden_field_tag(\"set_filter\", \"1\", :id => nil)\n\n    if query.filters.present?\n      query.filters.each do |field, filter|\n        tags << hidden_field_tag(\"f[]\", field, :id => nil)\n        tags << hidden_field_tag(\"op[#{field}]\", filter[:operator], :id => nil)\n        filter[:values].each do |value|\n          tags << hidden_field_tag(\"v[#{field}][]\", value, :id => nil)\n        end\n      end\n    else\n      tags << hidden_field_tag(\"f[]\", \"\", :id => nil)\n    end\n    query.columns.each do |column|\n      tags << hidden_field_tag(\"c[]\", column.name, :id => nil)\n    end\n    if query.totalable_names.present?\n      query.totalable_names.each do |name|\n        tags << hidden_field_tag(\"t[]\", name, :id => nil)\n      end\n    end\n    if query.group_by.present?\n      tags << hidden_field_tag(\"group_by\", query.group_by, :id => nil)\n    end\n    if query.sort_criteria.present?\n      tags << hidden_field_tag(\"sort\", query.sort_criteria.to_param, :id => nil)\n    end\n\n    tags\n  end\n \n  def query_hidden_sort_tag(query)\n    hidden_field_tag(\"sort\", query.sort_criteria.to_param, :id => nil)\n  end\n\n  # Returns the queries that are rendered in the sidebar\n  def sidebar_queries(klass, project)\n    klass.visible.global_or_on_project(@project).sorted.to_a\n  end\n\n  # Renders a group of queries\n  def query_links(title, queries)\n    return '' if queries.empty?\n    # links to #index on issues/show\n    url_params = controller_name == 'issues' ? {:controller => 'issues', :action => 'index', :project_id => @project} : {}\n\n    content_tag('h3', title) + \"\\n\" +\n      content_tag('ul',\n        queries.collect {|query|\n            css = 'query'\n            css << ' selected' if query == @query\n            content_tag('li', link_to(query.name, url_params.merge(:query_id => query), :class => css))\n          }.join(\"\\n\").html_safe,\n        :class => 'queries'\n      ) + \"\\n\"\n  end\n\n  # Renders the list of queries for the sidebar\n  def render_sidebar_queries(klass, project)\n    queries = sidebar_queries(klass, project)\n\n    out = ''.html_safe\n    out << query_links(l(:label_my_queries), queries.select(&:is_private?))\n    out << query_links(l(:label_query_plural), queries.reject(&:is_private?))\n    out\n  end\nend\n"], "fixing_code": ["# encoding: utf-8\n#\n# Redmine - project management software\n# Copyright (C) 2006-2017  Jean-Philippe Lang\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nrequire 'redmine/export/csv'\n\nmodule QueriesHelper\n  include ApplicationHelper\n\n  def filters_options_for_select(query)\n    ungrouped = []\n    grouped = {}\n    query.available_filters.map do |field, field_options|\n      if field_options[:type] == :relation\n        group = :label_relations\n      elsif field_options[:type] == :tree\n        group = query.is_a?(IssueQuery) ? :label_relations : nil\n      elsif field =~ /^cf_\\d+\\./\n        group = (field_options[:through] || field_options[:field]).try(:name)\n      elsif field =~ /^(.+)\\./\n        # association filters\n        group = \"field_#{$1}\".to_sym\n      elsif %w(member_of_group assigned_to_role).include?(field)\n        group = :field_assigned_to\n      elsif field_options[:type] == :date_past || field_options[:type] == :date\n        group = :label_date\n      end\n      if group\n        (grouped[group] ||= []) << [field_options[:name], field]\n      else\n        ungrouped << [field_options[:name], field]\n      end\n    end\n    # Don't group dates if there's only one (eg. time entries filters)\n    if grouped[:label_date].try(:size) == 1\n      ungrouped << grouped.delete(:label_date).first\n    end\n    s = options_for_select([[]] + ungrouped)\n    if grouped.present?\n      localized_grouped = grouped.map {|k,v| [k.is_a?(Symbol) ? l(k) : k.to_s, v]}\n      s << grouped_options_for_select(localized_grouped)\n    end\n    s\n  end\n\n  def query_filters_hidden_tags(query)\n    tags = ''.html_safe\n    query.filters.each do |field, options|\n      tags << hidden_field_tag(\"f[]\", field, :id => nil)\n      tags << hidden_field_tag(\"op[#{field}]\", options[:operator], :id => nil)\n      options[:values].each do |value|\n        tags << hidden_field_tag(\"v[#{field}][]\", value, :id => nil)\n      end\n    end\n    tags\n  end\n\n  def query_columns_hidden_tags(query)\n    tags = ''.html_safe\n    query.columns.each do |column|\n      tags << hidden_field_tag(\"c[]\", column.name, :id => nil)\n    end\n    tags\n  end\n\n  def query_hidden_tags(query)\n    query_filters_hidden_tags(query) + query_columns_hidden_tags(query)\n  end\n\n  def group_by_column_select_tag(query)\n    options = [[]] + query.groupable_columns.collect {|c| [c.caption, c.name.to_s]}\n    select_tag('group_by', options_for_select(options, @query.group_by))\n  end\n\n  def available_block_columns_tags(query)\n    tags = ''.html_safe\n    query.available_block_columns.each do |column|\n      tags << content_tag('label', check_box_tag('c[]', column.name.to_s, query.has_column?(column), :id => nil) + \" #{column.caption}\", :class => 'inline')\n    end\n    tags\n  end\n\n  def available_totalable_columns_tags(query, options={})\n    tag_name = (options[:name] || 't') + '[]'\n    tags = ''.html_safe\n    query.available_totalable_columns.each do |column|\n      tags << content_tag('label', check_box_tag(tag_name, column.name.to_s, query.totalable_columns.include?(column), :id => nil) + \" #{column.caption}\", :class => 'inline')\n    end\n    tags << hidden_field_tag(tag_name, '')\n    tags\n  end\n\n  def query_available_inline_columns_options(query)\n    (query.available_inline_columns - query.columns).reject(&:frozen?).collect {|column| [column.caption, column.name]}\n  end\n\n  def query_selected_inline_columns_options(query)\n    (query.inline_columns & query.available_inline_columns).reject(&:frozen?).collect {|column| [column.caption, column.name]}\n  end\n\n  def render_query_columns_selection(query, options={})\n    tag_name = (options[:name] || 'c') + '[]'\n    render :partial => 'queries/columns', :locals => {:query => query, :tag_name => tag_name}\n  end\n\n  def grouped_query_results(items, query, &block)\n    result_count_by_group = query.result_count_by_group\n    previous_group, first = false, true\n    totals_by_group = query.totalable_columns.inject({}) do |h, column|\n      h[column] = query.total_by_group_for(column)\n      h\n    end\n    items.each do |item|\n      group_name = group_count = nil\n      if query.grouped?\n        group = query.group_by_column.value(item)\n        if first || group != previous_group\n          if group.blank? && group != false\n            group_name = \"(#{l(:label_blank_value)})\"\n          else\n            group_name = format_object(group)\n          end\n          group_name ||= \"\"\n          group_count = result_count_by_group ? result_count_by_group[group] : nil\n          group_totals = totals_by_group.map {|column, t| total_tag(column, t[group] || 0)}.join(\" \").html_safe\n        end\n      end\n      yield item, group_name, group_count, group_totals\n      previous_group, first = group, false\n    end\n  end\n\n  def render_query_totals(query)\n    return unless query.totalable_columns.present?\n    totals = query.totalable_columns.map do |column|\n      total_tag(column, query.total_for(column))\n    end\n    content_tag('p', totals.join(\" \").html_safe, :class => \"query-totals\")\n  end\n\n  def total_tag(column, value)\n    label = content_tag('span', \"#{column.caption}:\")\n    value = if [:hours, :spent_hours, :total_spent_hours, :estimated_hours].include? column.name\n      format_hours(value)\n    else\n      format_object(value)\n    end\n    value = content_tag('span', value, :class => 'value')\n    content_tag('span', label + \" \" + value, :class => \"total-for-#{column.name.to_s.dasherize}\")\n  end\n\n  def column_header(query, column, options={})\n    if column.sortable?\n      css, order = nil, column.default_order\n      if column.name.to_s == query.sort_criteria.first_key\n        if query.sort_criteria.first_asc?\n          css = 'sort asc'\n          order = 'desc'\n        else\n          css = 'sort desc'\n          order = 'asc'\n        end\n      end\n      param_key = options[:sort_param] || :sort\n      sort_param = { param_key => query.sort_criteria.add(column.name, order).to_param }\n      while sort_param.keys.first.to_s =~ /^(.+)\\[(.+)\\]$/\n        sort_param = {$1 => {$2 => sort_param.values.first}}\n      end\n      link_options = {\n          :title => l(:label_sort_by, \"\\\"#{column.caption}\\\"\"),\n          :class => css\n        }\n      if options[:sort_link_options]\n        link_options.merge! options[:sort_link_options]\n      end\n      content = link_to(column.caption,\n          {:params => request.query_parameters.deep_merge(sort_param)},\n          link_options\n        )\n    else\n      content = column.caption\n    end\n    content_tag('th', content)\n  end\n\n  def column_content(column, item)\n    value = column.value_object(item)\n    if value.is_a?(Array)\n      values = value.collect {|v| column_value(column, item, v)}.compact\n      safe_join(values, ', ')\n    else\n      column_value(column, item, value)\n    end\n  end\n\n  def column_value(column, item, value)\n    case column.name\n    when :id\n      link_to value, issue_path(item)\n    when :subject\n      link_to value, issue_path(item)\n    when :parent\n      value ? (value.visible? ? link_to_issue(value, :subject => false) : \"##{value.id}\") : ''\n    when :description\n      item.description? ? content_tag('div', textilizable(item, :description), :class => \"wiki\") : ''\n    when :last_notes\n      item.last_notes.present? ? content_tag('div', textilizable(item, :last_notes), :class => \"wiki\") : ''\n    when :done_ratio\n      progress_bar(value)\n    when :relations\n      content_tag('span',\n        value.to_s(item) {|other| link_to_issue(other, :subject => false, :tracker => false)}.html_safe,\n        :class => value.css_classes_for(item))\n    when :hours, :estimated_hours\n      format_hours(value)\n    when :spent_hours\n      link_to_if(value > 0, format_hours(value), project_time_entries_path(item.project, :issue_id => \"#{item.id}\"))\n    when :total_spent_hours\n      link_to_if(value > 0, format_hours(value), project_time_entries_path(item.project, :issue_id => \"~#{item.id}\"))\n    when :attachments\n      value.to_a.map {|a| format_object(a)}.join(\" \").html_safe\n    else\n      format_object(value)\n    end\n  end\n\n  def csv_content(column, item)\n    value = column.value_object(item)\n    if value.is_a?(Array)\n      value.collect {|v| csv_value(column, item, v)}.compact.join(', ')\n    else\n      csv_value(column, item, value)\n    end\n  end\n\n  def csv_value(column, object, value)\n    case column.name\n    when :attachments\n      value.to_a.map {|a| a.filename}.join(\"\\n\")\n    else\n      format_object(value, false) do |value|\n        case value.class.name\n        when 'Float'\n          sprintf(\"%.2f\", value).gsub('.', l(:general_csv_decimal_separator))\n        when 'IssueRelation'\n          value.to_s(object)\n        when 'Issue'\n          if object.is_a?(TimeEntry)\n            \"#{value.tracker} ##{value.id}: #{value.subject}\"\n          else\n            value.id\n          end\n        else\n          value\n        end\n      end\n    end\n  end\n\n  def query_to_csv(items, query, options={})\n    columns = query.columns\n\n    Redmine::Export::CSV.generate do |csv|\n      # csv header fields\n      csv << columns.map {|c| c.caption.to_s}\n      # csv lines\n      items.each do |item|\n        csv << columns.map {|c| csv_content(c, item)}\n      end\n    end\n  end\n\n  # Retrieve query from session or build a new query\n  def retrieve_query(klass=IssueQuery, use_session=true, options={})\n    session_key = klass.name.underscore.to_sym\n\n    if params[:query_id].present?\n      cond = \"project_id IS NULL\"\n      cond << \" OR project_id = #{@project.id}\" if @project\n      @query = klass.where(cond).find(params[:query_id])\n      raise ::Unauthorized unless @query.visible?\n      @query.project = @project\n      session[session_key] = {:id => @query.id, :project_id => @query.project_id} if use_session\n    elsif api_request? || params[:set_filter] || !use_session || session[session_key].nil? || session[session_key][:project_id] != (@project ? @project.id : nil)\n      # Give it a name, required to be valid\n      @query = klass.new(:name => \"_\", :project => @project)\n      @query.build_from_params(params, options[:defaults])\n      session[session_key] = {:project_id => @query.project_id, :filters => @query.filters, :group_by => @query.group_by, :column_names => @query.column_names, :totalable_names => @query.totalable_names, :sort => @query.sort_criteria.to_a} if use_session\n    else\n      # retrieve from session\n      @query = nil\n      @query = klass.find_by_id(session[session_key][:id]) if session[session_key][:id]\n      @query ||= klass.new(:name => \"_\", :filters => session[session_key][:filters], :group_by => session[session_key][:group_by], :column_names => session[session_key][:column_names], :totalable_names => session[session_key][:totalable_names], :sort_criteria => session[session_key][:sort])\n      @query.project = @project\n    end\n    if params[:sort].present?\n      @query.sort_criteria = params[:sort]\n      if use_session\n        session[session_key] ||= {}\n        session[session_key][:sort] = @query.sort_criteria.to_a\n      end\n    end\n    @query\n  end\n\n  def retrieve_query_from_session(klass=IssueQuery)\n    session_key = klass.name.underscore.to_sym\n    session_data = session[session_key]\n\n    if session_data\n      if session_data[:id]\n        @query = IssueQuery.find_by_id(session_data[:id])\n        return unless @query\n      else\n        @query = IssueQuery.new(:name => \"_\", :filters => session_data[:filters], :group_by => session_data[:group_by], :column_names => session_data[:column_names], :totalable_names => session_data[:totalable_names], :sort_criteria => session[session_key][:sort])\n      end\n      if session_data.has_key?(:project_id)\n        @query.project_id = session_data[:project_id]\n      else\n        @query.project = @project\n      end\n      @query\n    end\n  end\n\n  # Returns the query definition as hidden field tags\n  def query_as_hidden_field_tags(query)\n    tags = hidden_field_tag(\"set_filter\", \"1\", :id => nil)\n\n    if query.filters.present?\n      query.filters.each do |field, filter|\n        tags << hidden_field_tag(\"f[]\", field, :id => nil)\n        tags << hidden_field_tag(\"op[#{field}]\", filter[:operator], :id => nil)\n        filter[:values].each do |value|\n          tags << hidden_field_tag(\"v[#{field}][]\", value, :id => nil)\n        end\n      end\n    else\n      tags << hidden_field_tag(\"f[]\", \"\", :id => nil)\n    end\n    query.columns.each do |column|\n      tags << hidden_field_tag(\"c[]\", column.name, :id => nil)\n    end\n    if query.totalable_names.present?\n      query.totalable_names.each do |name|\n        tags << hidden_field_tag(\"t[]\", name, :id => nil)\n      end\n    end\n    if query.group_by.present?\n      tags << hidden_field_tag(\"group_by\", query.group_by, :id => nil)\n    end\n    if query.sort_criteria.present?\n      tags << hidden_field_tag(\"sort\", query.sort_criteria.to_param, :id => nil)\n    end\n\n    tags\n  end\n \n  def query_hidden_sort_tag(query)\n    hidden_field_tag(\"sort\", query.sort_criteria.to_param, :id => nil)\n  end\n\n  # Returns the queries that are rendered in the sidebar\n  def sidebar_queries(klass, project)\n    klass.visible.global_or_on_project(@project).sorted.to_a\n  end\n\n  # Renders a group of queries\n  def query_links(title, queries)\n    return '' if queries.empty?\n    # links to #index on issues/show\n    url_params = controller_name == 'issues' ? {:controller => 'issues', :action => 'index', :project_id => @project} : {}\n\n    content_tag('h3', title) + \"\\n\" +\n      content_tag('ul',\n        queries.collect {|query|\n            css = 'query'\n            css << ' selected' if query == @query\n            content_tag('li', link_to(query.name, url_params.merge(:query_id => query), :class => css))\n          }.join(\"\\n\").html_safe,\n        :class => 'queries'\n      ) + \"\\n\"\n  end\n\n  # Renders the list of queries for the sidebar\n  def render_sidebar_queries(klass, project)\n    queries = sidebar_queries(klass, project)\n\n    out = ''.html_safe\n    out << query_links(l(:label_my_queries), queries.select(&:is_private?))\n    out << query_links(l(:label_query_plural), queries.reject(&:is_private?))\n    out\n  end\nend\n"], "buggy_code_start_loc": [204], "buggy_code_end_loc": [205], "fixing_code_start_loc": [204], "fixing_code_end_loc": [206], "type": "CWE-79", "message": "In Redmine before 3.2.8, 3.3.x before 3.3.5, and 3.4.x before 3.4.3, XSS exists in app/helpers/queries_helper.rb via a multi-value field with a crafted value that is mishandled during rendering of an issue list.", "other": {"cve": {"id": "CVE-2017-15569", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-18T02:29:00.310", "lastModified": "2019-03-14T14:57:12.507", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Redmine before 3.2.8, 3.3.x before 3.3.5, and 3.4.x before 3.4.3, XSS exists in app/helpers/queries_helper.rb via a multi-value field with a crafted value that is mishandled during rendering of an issue list."}, {"lang": "es", "value": "En Redmine en versiones anteriores a la 3.2.8, 3.3.x en versiones anteriores a la 3.3.5 y 3.4.x en versiones anteriores a la 3.4.3, existe XSS en app/helpers/queries_helper.rb mediante un campo de m\u00faltiples valores con un valor manipulado que se gestiona de manera incorrecta durante la representaci\u00f3n del historial de problemas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2.7", "matchCriteriaId": "506353CE-8310-44AC-B47C-4F3752DB7D0E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "196CF994-54D8-4E36-B37E-EAF1CC108F61"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "5AE4FC9C-3291-4344-81D5-83BA91D52FA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "67E1F17B-7B25-48B3-8953-18C47D99B443"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "9ADF69D6-449E-4845-811D-D588B4D05665"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "DEAD6AFD-E3DE-4E0F-A2C8-78A1CD316A6D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "22FD314E-A7E6-4073-BC98-452B9C5826E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "6982CC59-BE97-400C-A653-47AD6802C3F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "4D6A2E76-528B-48FA-89A4-B6BEE20E901A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/redmine/redmine/commit/56c8ee0440d8555aa7822d947ba9091c8a791508", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4191", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.redmine.org/issues/27186", "source": "cve@mitre.org", "tags": ["Permissions Required", "Vendor Advisory"]}, {"url": "https://www.redmine.org/projects/redmine/wiki/Security_Advisories", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/redmine/redmine/commit/56c8ee0440d8555aa7822d947ba9091c8a791508"}}