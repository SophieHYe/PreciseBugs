{"buggy_code": ["var fs = require('fs');\r\n\r\n// don't let users crawl up the folder structure by using a/../../../c/d\r\nvar cleanUrl = function(url) { \r\n\turl = decodeURIComponent(url);\r\n\twhile(url.indexOf('..').length > 0) { url = url.replace('..', ''); }\r\n\treturn url;\r\n};\r\n\r\n/*  \r\nexample usage:\r\n\trequire('http').createServer(function (req, res) {\r\n\t\tserver.handleRequest(port, path, req, res, vpath);\r\n\t}).listen(port);\r\n*/\r\nexports.handleRequest = function(vpath, path, req, res, readOnly, logHeadRequests) {\t\r\n\t// vpath: (optional) virtual path to host in the url\r\n\t// path: the file system path to serve\r\n\t// readOnly: whether to allow modifications to the file\r\n\r\n\t// our error handler\r\n\tvar writeError = function (err, code) { \r\n\t\tcode = code || 500;\r\n\t\tconsole.log('Error ' + code + ': ' + err);\r\n\t\t// write the error to the response, if possible\r\n\t\ttry {\t\t\t\r\n\t\t\tres.statusCode = code;\r\n\t\t\tres.setHeader('Content-Type', 'application/json');\r\n\t\t\tres.end(JSON.stringify(err));\t\r\n\t\t} catch(resErr) {\r\n\t\t\tconsole.log('failed to write error to response: ' + resErr);\r\n\t\t}\r\n\t};\r\n\r\n\tif(path.lastIndexOf('/') !== path.length - 1) { path += '/'; } // make sure path ends with a slash\t\r\n\tvar parsedUrl = require('url').parse(req.url);\t\r\n\tvar query = query ? {} : require('querystring').parse(parsedUrl.query);\r\n    var url = cleanUrl(parsedUrl.pathname);\r\n\t\r\n\t// normalize the url such that there is no trailing or leading slash /\r\n\tif(url.lastIndexOf('/') === url.length - 1) { url = url.slice(0, url.length ); }\r\n\tif(url[0] === '/') { url = url.slice(1, url.length);  }\r\n\r\n\t// check that url begins with vpath\r\n\tif(vpath && url.indexOf(vpath) != 0) {\r\n\t\tconsole.log('url does not begin with vpath');\r\n\t\tthrow 'url [' + url + '] does not begin with vpath [' + vpath + ']';\r\n\t}\r\n\r\n\tif(req.method != 'HEAD') {\r\n\t\tconsole.log(req.method + ' ' + req.url);\r\n\t}\r\n\tvar relativePath = vpath && url.indexOf(vpath) == 0 ?\r\n\t\tpath + url.slice(vpath.length + 1, url.length):\r\n\t\tpath + url;\t\r\n\t\r\n\ttry {\r\n\t\tif(readOnly && req.method != 'GET') {\r\n\t\t\twriteError(req.method + ' forbidden on this resource', 403);\r\n\t\t} else {\r\n\t\t\tswitch(req.method) {\r\n\t\t\t\tcase 'HEAD':\r\n\t\t\t\t\tif(logHeadRequests) {\r\n\t\t\t\t\t\tconsole.log('head: ' + relativePath);\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfs.stat(relativePath, function(err, stats) { // determine if the resource is a file or directory\r\n\t\t\t\t\t\tif(err) { writeError(err); } \r\n\t\t\t\t\t\telse {\t\t\t\t\t\r\n\t\t\t\t\t\t\tres.setHeader('Last-Modified', stats.mtime);\t\t\r\n\t\t\t\t\t\t\tres.setHeader(\"Expires\", \"Sat, 01 Jan 2000 00:00:00 GMT\");\r\n\t\t\t\t\t\t\tres.setHeader(\"Cache-Control\", \"no-store, no-cache, must-revalidate, max-age=0\");\r\n\t\t\t\t\t\t\tres.setHeader(\"Cache-Control\", \"post-check=0, pre-check=0\");\r\n\t\t\t\t\t\t\tres.setHeader(\"Pragma\", \"no-cache\");\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(stats.isDirectory()) {\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tres.setHeader('Content-Type', query.type == 'json' || query.dir == 'json' ? 'application/json' : 'text/html');\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif(query.type == 'json' || query.dir == 'json') {\r\n\t\t\t\t\t\t\t\t\tres.setHeader('Content-Type', 'application/json');\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tvar type = require('mime').lookup(relativePath);\r\n\t\t\t\t\t\t\t\t\tres.setHeader('Content-Type', type);\r\n\t\t\t\t\t\t\t\t\tres.setHeader('Content-Length', stats.size);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tres.end();\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'GET': // returns file or directory contents\r\n\t\t\t\t\tconsole.log('relativePath: ' + relativePath);\r\n\t\t\t\t\tif(url === 'favicon.ico') { \t\r\n\t\t\t\t\t\tres.end(); // if the browser requests favicon, just return an empty response\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfs.stat(relativePath, function(err, stats) { // determine if the resource is a file or directory\r\n\t\t\t\t\t\t\tif(err) { writeError(err); } \r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tif(stats.isDirectory()) {\r\n\t\t\t\t\t\t\t\t\tres.setHeader('Last-Modified', stats.mtime);\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tres.setHeader(\"Expires\", \"Sat, 01 Jan 2000 00:00:00 GMT\");\r\n\t\t\t\t\t\t\t\t\tres.setHeader(\"Cache-Control\", \"no-store, no-cache, must-revalidate, max-age=0\");\r\n\t\t\t\t\t\t\t\t\tres.setHeader(\"Cache-Control\", \"post-check=0, pre-check=0\");\r\n\t\t\t\t\t\t\t\t\tres.setHeader(\"Pragma\", \"no-cache\");\r\n\t\t\t\t\t\t\t\t\t// if it's a directory, return the files as a JSONified array\r\n\t\t\t\t\t\t\t\t\tconsole.log('reading directory ' + relativePath);\r\n\t\t\t\t\t\t\t\t\tfs.readdir(relativePath, function(err, files) {\r\n\t\t\t\t\t\t\t\t\t\tif(err) { \r\n\t\t\t\t\t\t\t\t\t\t\tconsole.log('writeError');\r\n\t\t\t\t\t\t\t\t\t\t\twriteError(err); \r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\tvar results = [];\r\n\t\t\t\t\t\t\t\t\t\t\tvar search = {};\r\n\t\t\t\t\t\t\t\t\t\t\tsearch.stats = function(files) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(files.length) { \r\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar file = files.shift();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tfs.stat(relativePath + '/' + file, function(err, stats) { \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(err) { writeError(err); } \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstats.name = file;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstats.isFile = stats.isFile();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstats.isDirectory = stats.isDirectory();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstats.isBlockDevice = stats.isBlockDevice();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstats.isFIFO = stats.isFIFO();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstats.isSocket = stats.isSocket();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tresults.push(stats);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsearch.stats(files);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(query.type == 'json' || query.dir == 'json') {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.setHeader('Content-Type', 'application/json');\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.write(JSON.stringify(results)); \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.end();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else { \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.setHeader('Content-Type', 'text/html');\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.write('<html><body>');\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(var f = 0; f < results.length; f++) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar name = results[f].name;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar normalized = url + '/' + name;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(normalized[0] == '/') { normalized = normalized.slice(1, normalized.length); }\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(normalized.indexOf('\"') >= 0) throw new Error('unsupported file name')\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname = name.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.write('\\r\\n<p><a href=\"/' + normalized + '\"><span>' + name + '</span></a></p>');\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.end('\\r\\n</body></html>');\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\t\t\t\tsearch.stats(files);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// if it's a file, return the contents of a file with the correct content type\r\n\t\t\t\t\t\t\t\t\tconsole.log('reading file ' + relativePath);\r\n\t\t\t\t\t\t\t\t\tif(query.type == 'json' || query.dir == 'json') {\r\n\t\t\t\t\t\t\t\t\t\tvar type = 'application/json';\r\n\t\t\t\t\t\t\t\t\t\tres.setHeader('Content-Type', type);\r\n\t\t\t\t\t\t\t\t\t\tfs.readFile(relativePath, function(err, data) { \r\n\t\t\t\t\t\t\t\t\t\t\tif(err) { writeError(err); }\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\tres.end(JSON.stringify({ \r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdata: data.toString(),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: require('mime').lookup(relativePath),\r\n\t\t\t\t\t\t\t\t\t\t\t\t})); \r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tvar type = require('mime').lookup(relativePath);\r\n\t\t\t\t\t\t\t\t\t\tres.setHeader('Content-Type', type);\r\n\t\t\t\t\t\t\t\t\t\tfs.readFile(relativePath, function(err, data) { \r\n\t\t\t\t\t\t\t\t\t\t\tif(err) { writeError(err); }\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\tres.setHeader('Content-Length', data.length);\r\n\t\t\t\t\t\t\t\t\t\t\t\tres.end(data); \r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\tcase 'PUT': // write a file\r\n\t\t\t\t\tconsole.log('writing ' + relativePath);\r\n\t\t\t\t\tvar stream = fs.createWriteStream(relativePath);\t\t\r\n\t\t\t\t\tstream.ok = true;\r\n\t\t\t\t\treq.pipe(stream); // TODO: limit data length\r\n\t\t\t\t\tstream.on('close', function() { \r\n\t\t\t\t\t\tif(stream.ok) {\r\n\t\t\t\t\t\t\tres.end();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tstream.on('error', function(err) { \t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tstream.ok = false;\r\n\t\t\t\t\t\twriteError(err);\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn;\r\n\t\t\t\tcase 'POST': // create a directory or rename a file or directory\r\n\t\t\t\t\tif(query.rename) { // rename a file or directory\r\n\t\t\t\t\t\tconsole.log('rename: ' + relativePath);\r\n\t\t\t\t\t\t// e.g., http://localhost/old-name.html?rename=new-name.html\r\n\t\t\t\t\t\tquery.rename = cleanUrl(query.rename);\r\n\t\t\t\t\t\t// TODO: handle missing vpath here\r\n\t\t\t\t\t\tif(vpath) { \r\n\t\t\t\t\t\t\tif(query.rename.indexOf('/' + vpath + '/') == 0) { \r\n\t\t\t\t\t\t\t\tquery.rename = query.rename.slice(vpath.length + 2, query.rename.length);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthrow 'renamed url [' + query.rename + '] does not begin with vpath [' + vpath + ']';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t\tconsole.log('renaming ' + relativePath + ' to ' + path + query.rename);\r\n\t\t\t\t\t\tfs.rename(relativePath, path + query.rename, function(err) {\r\n\t\t\t\t\t\t\tif(err) { writeError(err); } \r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tres.end();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else if(query.create == 'directory') { // rename a directory\r\n\t\t\t\t\t\t// e.g., http://localhost/new-directory?create=directory\r\n\t\t\t\t\t\tconsole.log('creating directory ' + relativePath);\r\n\t\t\t\t\t\tfs.mkdir(relativePath, 0777, function(err) { \r\n\t\t\t\t\t\t\tif(err) { writeError(err); } \r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tres.end();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.log('relativePath: ' + relativePath);\r\n\t\t\t\t\t\twriteError('valid queries are ' + url + '?rename=[new name] or ' + url + '?create=directory');\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\tcase 'DELETE': // delete a file or directory\t\t\t\t\r\n\t\t\t\t\tfs.stat(relativePath, function(err, stats) { \r\n\t\t\t\t\t\tif(err) { writeError(err); } \r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif(stats.isDirectory()) { // delete a directory\r\n\t\t\t\t\t\t\t\tconsole.log('deleting directory ' + relativePath);\r\n\t\t\t\t\t\t\t\tfs.rmdir(relativePath, function(err) {\r\n\t\t\t\t\t\t\t\t\tif(err) { writeError(err); }\r\n\t\t\t\t\t\t\t\t\telse { \r\n\t\t\t\t\t\t\t\t\t\tres.end(); \r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t} else { // delete a file\r\n\t\t\t\t\t\t\t\tconsole.log('deleting file ' + relativePath);\r\n\t\t\t\t\t\t\t\tfs.unlink(relativePath, function(err) {\r\n\t\t\t\t\t\t\t\t\tif(err) { writeError(err); }\r\n\t\t\t\t\t\t\t\t\telse { \r\n\t\t\t\t\t\t\t\t\t\tres.end(); \r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\t\t\t\r\n\t\t\t\t\treturn;\r\n\t\t\t\tdefault: // unsupported method! tell the client ...\r\n\t\t\t\t\tconsole.log('unsupported: ' + relativePath);\t\t\t\t\r\n\t\t\t\t\twriteError('Method ' + method + ' not allowed', 405);\r\n\t\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t} catch(err) { \r\n\t\t// file system ('fs') errors are just bubbled up to this error handler\r\n\t\t// for example, if the GET is called on a non-existent file, an error will be thrown\r\n\t\t// and caught here\r\n\t\t// writeError will write the error information to the response\r\n\t\twriteError('unhandled error: ' + err);\r\n\t}\r\n};\r\n", "{\n  \"name\": \"crud-file-server\",\n  \"version\": \"0.8.0\",\n  \"description\": \"file server supporting basic create, read, update, & delete for any kind of file\",\n  \"bin\": {\n    \"crud-file-server\": \"./bin/crud-file-server\"\n  },\n  \"main\": \"./crud-file-server.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/omphalos/crud-file-server.git\"\n  },\n  \"keywords\": [\n    \"static\",\n    \"file\",\n    \"fs\",\n    \"http\"\n  ],\n  \"dependencies\": {\n    \"optimist\": \"0.3.4\",\n\t\"mime\": \"1.2.7\"\n  },\n  \"license\": \"unlicense\",\n  \"engine\": {\n    \"node\": \">=0.8.1\"\n  },\n  \"author\": \"omphalos\"\n}\n"], "fixing_code": ["var fs = require('fs');\r\n\r\n// don't let users crawl up the folder structure by using a/../../../c/d\r\nvar cleanUrl = function(url) { \r\n\turl = decodeURIComponent(url);\r\n\twhile(url.indexOf('..') >= 0) { url = url.replace('..', ''); }\r\n\treturn url;\r\n};\r\n\r\n/*  \r\nexample usage:\r\n\trequire('http').createServer(function (req, res) {\r\n\t\tserver.handleRequest(port, path, req, res, vpath);\r\n\t}).listen(port);\r\n*/\r\nexports.handleRequest = function(vpath, path, req, res, readOnly, logHeadRequests) {\t\r\n\t// vpath: (optional) virtual path to host in the url\r\n\t// path: the file system path to serve\r\n\t// readOnly: whether to allow modifications to the file\r\n\r\n\t// our error handler\r\n\tvar writeError = function (err, code) { \r\n\t\tcode = code || 500;\r\n\t\tconsole.log('Error ' + code + ': ' + err);\r\n\t\t// write the error to the response, if possible\r\n\t\ttry {\t\t\t\r\n\t\t\tres.statusCode = code;\r\n\t\t\tres.setHeader('Content-Type', 'application/json');\r\n\t\t\tres.end(JSON.stringify(err));\t\r\n\t\t} catch(resErr) {\r\n\t\t\tconsole.log('failed to write error to response: ' + resErr);\r\n\t\t}\r\n\t};\r\n\r\n\tif(path.lastIndexOf('/') !== path.length - 1) { path += '/'; } // make sure path ends with a slash\t\r\n\tvar parsedUrl = require('url').parse(req.url);\t\r\n\tvar query = query ? {} : require('querystring').parse(parsedUrl.query);\r\n    var url = cleanUrl(parsedUrl.pathname);\r\n\t\r\n\t// normalize the url such that there is no trailing or leading slash /\r\n\tif(url.lastIndexOf('/') === url.length - 1) { url = url.slice(0, url.length ); }\r\n\tif(url[0] === '/') { url = url.slice(1, url.length);  }\r\n\r\n\t// check that url begins with vpath\r\n\tif(vpath && url.indexOf(vpath) != 0) {\r\n\t\tconsole.log('url does not begin with vpath');\r\n\t\tthrow 'url [' + url + '] does not begin with vpath [' + vpath + ']';\r\n\t}\r\n\r\n\tif(req.method != 'HEAD') {\r\n\t\tconsole.log(req.method + ' ' + req.url);\r\n\t}\r\n\tvar relativePath = vpath && url.indexOf(vpath) == 0 ?\r\n\t\tpath + url.slice(vpath.length + 1, url.length):\r\n\t\tpath + url;\t\r\n\t\r\n\ttry {\r\n\t\tif(readOnly && req.method != 'GET') {\r\n\t\t\twriteError(req.method + ' forbidden on this resource', 403);\r\n\t\t} else {\r\n\t\t\tswitch(req.method) {\r\n\t\t\t\tcase 'HEAD':\r\n\t\t\t\t\tif(logHeadRequests) {\r\n\t\t\t\t\t\tconsole.log('head: ' + relativePath);\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfs.stat(relativePath, function(err, stats) { // determine if the resource is a file or directory\r\n\t\t\t\t\t\tif(err) { writeError(err); } \r\n\t\t\t\t\t\telse {\t\t\t\t\t\r\n\t\t\t\t\t\t\tres.setHeader('Last-Modified', stats.mtime);\t\t\r\n\t\t\t\t\t\t\tres.setHeader(\"Expires\", \"Sat, 01 Jan 2000 00:00:00 GMT\");\r\n\t\t\t\t\t\t\tres.setHeader(\"Cache-Control\", \"no-store, no-cache, must-revalidate, max-age=0\");\r\n\t\t\t\t\t\t\tres.setHeader(\"Cache-Control\", \"post-check=0, pre-check=0\");\r\n\t\t\t\t\t\t\tres.setHeader(\"Pragma\", \"no-cache\");\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif(stats.isDirectory()) {\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tres.setHeader('Content-Type', query.type == 'json' || query.dir == 'json' ? 'application/json' : 'text/html');\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif(query.type == 'json' || query.dir == 'json') {\r\n\t\t\t\t\t\t\t\t\tres.setHeader('Content-Type', 'application/json');\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tvar type = require('mime').lookup(relativePath);\r\n\t\t\t\t\t\t\t\t\tres.setHeader('Content-Type', type);\r\n\t\t\t\t\t\t\t\t\tres.setHeader('Content-Length', stats.size);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tres.end();\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'GET': // returns file or directory contents\r\n\t\t\t\t\tconsole.log('relativePath: ' + relativePath);\r\n\t\t\t\t\tif(url === 'favicon.ico') { \t\r\n\t\t\t\t\t\tres.end(); // if the browser requests favicon, just return an empty response\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfs.stat(relativePath, function(err, stats) { // determine if the resource is a file or directory\r\n\t\t\t\t\t\t\tif(err) { writeError(err); } \r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tif(stats.isDirectory()) {\r\n\t\t\t\t\t\t\t\t\tres.setHeader('Last-Modified', stats.mtime);\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tres.setHeader(\"Expires\", \"Sat, 01 Jan 2000 00:00:00 GMT\");\r\n\t\t\t\t\t\t\t\t\tres.setHeader(\"Cache-Control\", \"no-store, no-cache, must-revalidate, max-age=0\");\r\n\t\t\t\t\t\t\t\t\tres.setHeader(\"Cache-Control\", \"post-check=0, pre-check=0\");\r\n\t\t\t\t\t\t\t\t\tres.setHeader(\"Pragma\", \"no-cache\");\r\n\t\t\t\t\t\t\t\t\t// if it's a directory, return the files as a JSONified array\r\n\t\t\t\t\t\t\t\t\tconsole.log('reading directory ' + relativePath);\r\n\t\t\t\t\t\t\t\t\tfs.readdir(relativePath, function(err, files) {\r\n\t\t\t\t\t\t\t\t\t\tif(err) { \r\n\t\t\t\t\t\t\t\t\t\t\tconsole.log('writeError');\r\n\t\t\t\t\t\t\t\t\t\t\twriteError(err); \r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\tvar results = [];\r\n\t\t\t\t\t\t\t\t\t\t\tvar search = {};\r\n\t\t\t\t\t\t\t\t\t\t\tsearch.stats = function(files) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(files.length) { \r\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar file = files.shift();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tfs.stat(relativePath + '/' + file, function(err, stats) { \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(err) { writeError(err); } \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstats.name = file;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstats.isFile = stats.isFile();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstats.isDirectory = stats.isDirectory();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstats.isBlockDevice = stats.isBlockDevice();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstats.isFIFO = stats.isFIFO();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstats.isSocket = stats.isSocket();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tresults.push(stats);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsearch.stats(files);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(query.type == 'json' || query.dir == 'json') {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.setHeader('Content-Type', 'application/json');\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.write(JSON.stringify(results)); \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.end();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else { \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.setHeader('Content-Type', 'text/html');\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.write('<html><body>');\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor(var f = 0; f < results.length; f++) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar name = results[f].name;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar normalized = url + '/' + name;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile(normalized[0] == '/') { normalized = normalized.slice(1, normalized.length); }\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(normalized.indexOf('\"') >= 0) throw new Error('unsupported file name')\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname = name.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.write('\\r\\n<p><a href=\"/' + normalized + '\"><span>' + name + '</span></a></p>');\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tres.end('\\r\\n</body></html>');\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\t\t\t\tsearch.stats(files);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t// if it's a file, return the contents of a file with the correct content type\r\n\t\t\t\t\t\t\t\t\tconsole.log('reading file ' + relativePath);\r\n\t\t\t\t\t\t\t\t\tif(query.type == 'json' || query.dir == 'json') {\r\n\t\t\t\t\t\t\t\t\t\tvar type = 'application/json';\r\n\t\t\t\t\t\t\t\t\t\tres.setHeader('Content-Type', type);\r\n\t\t\t\t\t\t\t\t\t\tfs.readFile(relativePath, function(err, data) { \r\n\t\t\t\t\t\t\t\t\t\t\tif(err) { writeError(err); }\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\tres.end(JSON.stringify({ \r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdata: data.toString(),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: require('mime').lookup(relativePath),\r\n\t\t\t\t\t\t\t\t\t\t\t\t})); \r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tvar type = require('mime').lookup(relativePath);\r\n\t\t\t\t\t\t\t\t\t\tres.setHeader('Content-Type', type);\r\n\t\t\t\t\t\t\t\t\t\tfs.readFile(relativePath, function(err, data) { \r\n\t\t\t\t\t\t\t\t\t\t\tif(err) { writeError(err); }\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\tres.setHeader('Content-Length', data.length);\r\n\t\t\t\t\t\t\t\t\t\t\t\tres.end(data); \r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\tcase 'PUT': // write a file\r\n\t\t\t\t\tconsole.log('writing ' + relativePath);\r\n\t\t\t\t\tvar stream = fs.createWriteStream(relativePath);\t\t\r\n\t\t\t\t\tstream.ok = true;\r\n\t\t\t\t\treq.pipe(stream); // TODO: limit data length\r\n\t\t\t\t\tstream.on('close', function() { \r\n\t\t\t\t\t\tif(stream.ok) {\r\n\t\t\t\t\t\t\tres.end();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tstream.on('error', function(err) { \t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tstream.ok = false;\r\n\t\t\t\t\t\twriteError(err);\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn;\r\n\t\t\t\tcase 'POST': // create a directory or rename a file or directory\r\n\t\t\t\t\tif(query.rename) { // rename a file or directory\r\n\t\t\t\t\t\tconsole.log('rename: ' + relativePath);\r\n\t\t\t\t\t\t// e.g., http://localhost/old-name.html?rename=new-name.html\r\n\t\t\t\t\t\tquery.rename = cleanUrl(query.rename);\r\n\t\t\t\t\t\t// TODO: handle missing vpath here\r\n\t\t\t\t\t\tif(vpath) { \r\n\t\t\t\t\t\t\tif(query.rename.indexOf('/' + vpath + '/') == 0) { \r\n\t\t\t\t\t\t\t\tquery.rename = query.rename.slice(vpath.length + 2, query.rename.length);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthrow 'renamed url [' + query.rename + '] does not begin with vpath [' + vpath + ']';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t\tconsole.log('renaming ' + relativePath + ' to ' + path + query.rename);\r\n\t\t\t\t\t\tfs.rename(relativePath, path + query.rename, function(err) {\r\n\t\t\t\t\t\t\tif(err) { writeError(err); } \r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tres.end();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else if(query.create == 'directory') { // rename a directory\r\n\t\t\t\t\t\t// e.g., http://localhost/new-directory?create=directory\r\n\t\t\t\t\t\tconsole.log('creating directory ' + relativePath);\r\n\t\t\t\t\t\tfs.mkdir(relativePath, 0777, function(err) { \r\n\t\t\t\t\t\t\tif(err) { writeError(err); } \r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tres.end();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.log('relativePath: ' + relativePath);\r\n\t\t\t\t\t\twriteError('valid queries are ' + url + '?rename=[new name] or ' + url + '?create=directory');\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\tcase 'DELETE': // delete a file or directory\t\t\t\t\r\n\t\t\t\t\tfs.stat(relativePath, function(err, stats) { \r\n\t\t\t\t\t\tif(err) { writeError(err); } \r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif(stats.isDirectory()) { // delete a directory\r\n\t\t\t\t\t\t\t\tconsole.log('deleting directory ' + relativePath);\r\n\t\t\t\t\t\t\t\tfs.rmdir(relativePath, function(err) {\r\n\t\t\t\t\t\t\t\t\tif(err) { writeError(err); }\r\n\t\t\t\t\t\t\t\t\telse { \r\n\t\t\t\t\t\t\t\t\t\tres.end(); \r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t} else { // delete a file\r\n\t\t\t\t\t\t\t\tconsole.log('deleting file ' + relativePath);\r\n\t\t\t\t\t\t\t\tfs.unlink(relativePath, function(err) {\r\n\t\t\t\t\t\t\t\t\tif(err) { writeError(err); }\r\n\t\t\t\t\t\t\t\t\telse { \r\n\t\t\t\t\t\t\t\t\t\tres.end(); \r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\t\t\t\r\n\t\t\t\t\treturn;\r\n\t\t\t\tdefault: // unsupported method! tell the client ...\r\n\t\t\t\t\tconsole.log('unsupported: ' + relativePath);\t\t\t\t\r\n\t\t\t\t\twriteError('Method ' + method + ' not allowed', 405);\r\n\t\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t} catch(err) { \r\n\t\t// file system ('fs') errors are just bubbled up to this error handler\r\n\t\t// for example, if the GET is called on a non-existent file, an error will be thrown\r\n\t\t// and caught here\r\n\t\t// writeError will write the error information to the response\r\n\t\twriteError('unhandled error: ' + err);\r\n\t}\r\n};\r\n", "{\n  \"name\": \"crud-file-server\",\n  \"version\": \"0.9.0\",\n  \"description\": \"file server supporting basic create, read, update, & delete for any kind of file\",\n  \"bin\": {\n    \"crud-file-server\": \"./bin/crud-file-server\"\n  },\n  \"main\": \"./crud-file-server.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/omphalos/crud-file-server.git\"\n  },\n  \"keywords\": [\n    \"static\",\n    \"file\",\n    \"fs\",\n    \"http\"\n  ],\n  \"dependencies\": {\n    \"optimist\": \"0.3.4\",\n\t\"mime\": \"1.2.7\"\n  },\n  \"license\": \"unlicense\",\n  \"engine\": {\n    \"node\": \">=0.8.1\"\n  },\n  \"author\": \"omphalos\"\n}\n"], "buggy_code_start_loc": [6, 3], "buggy_code_end_loc": [7, 4], "fixing_code_start_loc": [6, 3], "fixing_code_end_loc": [7, 4], "type": "CWE-22", "message": "crud-file-server node module before 0.9.0 suffers from a Path Traversal vulnerability due to incorrect validation of url, which allows a malicious user to read content of any file with known path.", "other": {"cve": {"id": "CVE-2018-3733", "sourceIdentifier": "support@hackerone.com", "published": "2018-05-29T20:29:02.643", "lastModified": "2023-02-28T18:03:14.700", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "crud-file-server node module before 0.9.0 suffers from a Path Traversal vulnerability due to incorrect validation of url, which allows a malicious user to read content of any file with known path."}, {"lang": "es", "value": "El m\u00f3dulo crud-file-server node en versiones anteriores a la 0.9.0 sufre de una vulnerabilidad de salto de directorio debido a la validaci\u00f3n incorrecta de URL, que permite que un usuario malicioso lea contenido de cualquier archivo con una ruta conocida."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:crud-file-server_project:crud-file-server:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.9.0", "matchCriteriaId": "9BDC9518-BFA7-4267-9FC1-BD4E3EFA5BE9"}]}]}], "references": [{"url": "https://github.com/omphalos/crud-file-server/commit/4fc3b404f718abb789f4ce4272c39c7a138c7a82", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/310690", "source": "support@hackerone.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/omphalos/crud-file-server/commit/4fc3b404f718abb789f4ce4272c39c7a138c7a82"}}