{"buggy_code": ["<?php\n\nuse phpseclib\\Crypt\\RSA;\nuse phpseclib\\Crypt\\AES;\nuse phpseclib\\Crypt\\Random;\n\nclass JOSE_JWE extends JOSE_JWT {\n    var $plain_text;\n    var $cipher_text;\n    var $content_encryption_key;\n    var $jwe_encrypted_key;\n    var $encryption_key;\n    var $mac_key;\n    var $iv;\n    var $authentication_tag;\n    var $auth_data;\n\n    function __construct($input = null) {\n        if ($input instanceof JOSE_JWT) {\n            $this->raw = $input->toString();\n        } else {\n            $this->raw = $input;\n        }\n        unset($this->header['typ']);\n    }\n\n    function encrypt($public_key_or_secret, $algorithm = 'RSA1_5', $encryption_method = 'A128CBC-HS256') {\n        $this->header['alg'] = $algorithm;\n        $this->header['enc'] = $encryption_method;\n        if (\n            $public_key_or_secret instanceof JOSE_JWK &&\n            !array_key_exists('kid', $this->header) &&\n            array_key_exists('kid', $public_key_or_secret->components)\n        ) {\n            $this->header['kid'] = $public_key_or_secret->components['kid'];\n        }\n        $this->plain_text = $this->raw;\n        $this->generateContentEncryptionKey($public_key_or_secret);\n        $this->encryptContentEncryptionKey($public_key_or_secret);\n        $this->generateIv();\n        $this->deriveEncryptionAndMacKeys();\n        $this->encryptCipherText();\n        $this->generateAuthenticationTag();\n        return $this;\n    }\n\n    function decrypt($private_key_or_secret) {\n        $this->decryptContentEncryptionKey($private_key_or_secret);\n        $this->deriveEncryptionAndMacKeys();\n        $this->decryptCipherText();\n        $this->checkAuthenticationTag();\n        return $this;\n    }\n\n    function toString() {\n        return implode('.', array(\n            $this->compact((object) $this->header),\n            $this->compact($this->jwe_encrypted_key),\n            $this->compact($this->iv),\n            $this->compact($this->cipher_text),\n            $this->compact($this->authentication_tag)\n        ));\n    }\n\n    private function rsa($public_or_private_key, $padding_mode) {\n        if ($public_or_private_key instanceof JOSE_JWK) {\n            $rsa = $public_or_private_key->toKey();\n        } else if ($public_or_private_key instanceof RSA) {\n            $rsa = $public_or_private_key;\n        } else {\n            $rsa = new RSA();\n            $rsa->loadKey($public_or_private_key);\n        }\n        $rsa->setEncryptionMode($padding_mode);\n        return $rsa;\n    }\n\n    private function cipher() {\n        switch ($this->header['enc']) {\n            case 'A128GCM':\n            case 'A256GCM':\n                throw new JOSE_Exception_UnexpectedAlgorithm('Algorithm not supported');\n            case 'A128CBC-HS256':\n            case 'A256CBC-HS512':\n                $cipher = new AES(AES::MODE_CBC);\n                break;\n            default:\n                throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n        }\n        switch ($this->header['enc']) {\n            case 'A128GCM':\n            case 'A128CBC-HS256':\n                $cipher->setBlockLength(128);\n                break;\n            case 'A256GCM':\n            case 'A256CBC-HS512':\n                $cipher->setBlockLength(256);\n                break;\n            default:\n                throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n        }\n        return $cipher;\n    }\n\n    private function generateRandomBytes($length) {\n        return Random::string($length);\n    }\n\n    private function generateIv() {\n        switch ($this->header['enc']) {\n            case 'A128GCM':\n            case 'A128CBC-HS256':\n                $this->iv = $this->generateRandomBytes(128 / 8);\n                break;\n            case 'A256GCM':\n            case 'A256CBC-HS512':\n                $this->iv = $this->generateRandomBytes(256 / 8);\n                break;\n            default:\n                throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n        }\n    }\n\n    private function generateContentEncryptionKey($public_key_or_secret) {\n        if ($this->header['alg'] == 'dir') {\n            $this->content_encryption_key = $public_key_or_secret;\n        } else {\n            switch ($this->header['enc']) {\n                case 'A128GCM':\n                case 'A128CBC-HS256':\n                    $this->content_encryption_key = $this->generateRandomBytes(256 / 8);\n                    break;\n                case 'A256GCM':\n                case 'A256CBC-HS512':\n                    $this->content_encryption_key = $this->generateRandomBytes(512 / 8);\n                    break;\n                default:\n                    throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n            }\n        }\n    }\n\n    private function encryptContentEncryptionKey($public_key_or_secret) {\n        switch ($this->header['alg']) {\n            case 'RSA1_5':\n                $rsa = $this->rsa($public_key_or_secret, RSA::ENCRYPTION_PKCS1);\n                $this->jwe_encrypted_key = $rsa->encrypt($this->content_encryption_key);\n                break;\n            case 'RSA-OAEP':\n                $rsa = $this->rsa($public_key_or_secret, RSA::ENCRYPTION_OAEP);\n                $this->jwe_encrypted_key = $rsa->encrypt($this->content_encryption_key);\n                break;\n            case 'dir':\n                $this->jwe_encrypted_key = '';\n                return;\n            case 'A128KW':\n            case 'A256KW':\n            case 'ECDH-ES':\n            case 'ECDH-ES+A128KW':\n            case 'ECDH-ES+A256KW':\n                throw new JOSE_Exception_UnexpectedAlgorithm('Algorithm not supported');\n            default:\n                throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n        }\n        if (!$this->jwe_encrypted_key) {\n            throw new JOSE_Exception_EncryptionFailed('Master key encryption failed');\n        }\n    }\n\n    private function decryptContentEncryptionKey($private_key_or_secret) {\n        switch ($this->header['alg']) {\n            case 'RSA1_5':\n                $rsa = $this->rsa($private_key_or_secret, RSA::ENCRYPTION_PKCS1);\n                $this->content_encryption_key = $rsa->decrypt($this->jwe_encrypted_key);\n                break;\n            case 'RSA-OAEP':\n                $rsa = $this->rsa($private_key_or_secret, RSA::ENCRYPTION_OAEP);\n                $this->content_encryption_key = $rsa->decrypt($this->jwe_encrypted_key);\n                break;\n            case 'dir':\n                $this->content_encryption_key = $private_key_or_secret;\n                break;\n            case 'A128KW':\n            case 'A256KW':\n            case 'ECDH-ES':\n            case 'ECDH-ES+A128KW':\n            case 'ECDH-ES+A256KW':\n                throw new JOSE_Exception_UnexpectedAlgorithm('Algorithm not supported');\n            default:\n                throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n        }\n        if (!$this->content_encryption_key) {\n            # NOTE:\n            #  Not to disclose timing difference between CEK decryption error and others.\n            #  Mitigating Bleichenbacher Attack on PKCS#1 v1.5\n            #  ref.) http://inaz2.hatenablog.com/entry/2016/01/26/222303\n            $this->generateContentEncryptionKey(null);\n        }\n    }\n\n    private function deriveEncryptionAndMacKeys() {\n        switch ($this->header['enc']) {\n            case 'A128GCM':\n            case 'A256GCM':\n                $this->encryption_key = $this->content_encryption_key;\n                $this->mac_key = \"won't be used\";\n                break;\n            case 'A128CBC-HS256':\n                $this->deriveEncryptionAndMacKeysCBC(256);\n                break;\n            case 'A256CBC-HS512':\n                $this->deriveEncryptionAndMacKeysCBC(512);\n                break;\n            default:\n                throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n        }\n        if (!$this->encryption_key || !$this->mac_key) {\n            throw new JOSE_Exception_DecryptionFailed('Encryption/Mac key derivation failed');\n        }\n    }\n\n    private function deriveEncryptionAndMacKeysCBC($sha_size) {\n        $this->mac_key = substr($this->content_encryption_key, 0, $sha_size / 2 / 8);\n        $this->encryption_key = substr($this->content_encryption_key, $sha_size / 2 / 8);\n    }\n\n    private function encryptCipherText() {\n        $cipher = $this->cipher();\n        $cipher->setKey($this->encryption_key);\n        $cipher->setIV($this->iv);\n        $this->cipher_text = $cipher->encrypt($this->plain_text);\n        if (!$this->cipher_text) {\n            throw new JOSE_Exception_DecryptionFailed('Payload encryption failed');\n        }\n    }\n\n    private function decryptCipherText() {\n        $cipher = $this->cipher();\n        $cipher->setKey($this->encryption_key);\n        $cipher->setIV($this->iv);\n        $this->plain_text = $cipher->decrypt($this->cipher_text);\n        if (!$this->plain_text) {\n            throw new JOSE_Exception_DecryptionFailed('Payload decryption failed');\n        }\n    }\n\n    private function generateAuthenticationTag() {\n        $this->authentication_tag = $this->calculateAuthenticationTag();\n    }\n\n    private function calculateAuthenticationTag($use_raw = false) {\n        switch ($this->header['enc']) {\n            case 'A128GCM':\n            case 'A256GCM':\n                throw new JOSE_Exception_UnexpectedAlgorithm('Algorithm not supported');\n            case 'A128CBC-HS256':\n                return $this->calculateAuthenticationTagCBC(256);\n            case 'A256CBC-HS512':\n                return $this->calculateAuthenticationTagCBC(512);\n            default:\n                throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n        }\n    }\n\n    private function calculateAuthenticationTagCBC($sha_size) {\n        if (!$this->auth_data) {\n            $this->auth_data = $this->compact((object) $this->header);\n        }\n        $auth_data_length = strlen($this->auth_data);\n        $max_32bit = 2147483647;\n        $secured_input = implode('', array(\n            $this->auth_data,\n            $this->iv,\n            $this->cipher_text,\n            // NOTE: PHP doesn't support 64bit big endian, so handling upper & lower 32bit.\n            pack('N2', ($auth_data_length / $max_32bit) * 8, ($auth_data_length % $max_32bit) * 8)\n        ));\n        return substr(\n            hash_hmac('sha' . $sha_size, $secured_input, $this->mac_key, true),\n            0, $sha_size / 2 / 8\n        );\n    }\n\n    private function checkAuthenticationTag() {\n        if ($this->authentication_tag === $this->calculateAuthenticationTag()) {\n            return true;\n        } else {\n            throw new JOSE_Exception_UnexpectedAlgorithm('Invalid authentication tag');\n        }\n    }\n}\n"], "fixing_code": ["<?php\n\nuse phpseclib\\Crypt\\RSA;\nuse phpseclib\\Crypt\\AES;\nuse phpseclib\\Crypt\\Random;\n\nclass JOSE_JWE extends JOSE_JWT {\n    var $plain_text;\n    var $cipher_text;\n    var $content_encryption_key;\n    var $jwe_encrypted_key;\n    var $encryption_key;\n    var $mac_key;\n    var $iv;\n    var $authentication_tag;\n    var $auth_data;\n\n    function __construct($input = null) {\n        if ($input instanceof JOSE_JWT) {\n            $this->raw = $input->toString();\n        } else {\n            $this->raw = $input;\n        }\n        unset($this->header['typ']);\n    }\n\n    function encrypt($public_key_or_secret, $algorithm = 'RSA1_5', $encryption_method = 'A128CBC-HS256') {\n        $this->header['alg'] = $algorithm;\n        $this->header['enc'] = $encryption_method;\n        if (\n            $public_key_or_secret instanceof JOSE_JWK &&\n            !array_key_exists('kid', $this->header) &&\n            array_key_exists('kid', $public_key_or_secret->components)\n        ) {\n            $this->header['kid'] = $public_key_or_secret->components['kid'];\n        }\n        $this->plain_text = $this->raw;\n        $this->generateContentEncryptionKey($public_key_or_secret);\n        $this->encryptContentEncryptionKey($public_key_or_secret);\n        $this->generateIv();\n        $this->deriveEncryptionAndMacKeys();\n        $this->encryptCipherText();\n        $this->generateAuthenticationTag();\n        return $this;\n    }\n\n    function decrypt($private_key_or_secret) {\n        $this->decryptContentEncryptionKey($private_key_or_secret);\n        $this->deriveEncryptionAndMacKeys();\n        $this->decryptCipherText();\n        $this->checkAuthenticationTag();\n        return $this;\n    }\n\n    function toString() {\n        return implode('.', array(\n            $this->compact((object) $this->header),\n            $this->compact($this->jwe_encrypted_key),\n            $this->compact($this->iv),\n            $this->compact($this->cipher_text),\n            $this->compact($this->authentication_tag)\n        ));\n    }\n\n    private function rsa($public_or_private_key, $padding_mode) {\n        if ($public_or_private_key instanceof JOSE_JWK) {\n            $rsa = $public_or_private_key->toKey();\n        } else if ($public_or_private_key instanceof RSA) {\n            $rsa = $public_or_private_key;\n        } else {\n            $rsa = new RSA();\n            $rsa->loadKey($public_or_private_key);\n        }\n        $rsa->setEncryptionMode($padding_mode);\n        return $rsa;\n    }\n\n    private function cipher() {\n        switch ($this->header['enc']) {\n            case 'A128GCM':\n            case 'A256GCM':\n                throw new JOSE_Exception_UnexpectedAlgorithm('Algorithm not supported');\n            case 'A128CBC-HS256':\n            case 'A256CBC-HS512':\n                $cipher = new AES(AES::MODE_CBC);\n                break;\n            default:\n                throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n        }\n        switch ($this->header['enc']) {\n            case 'A128GCM':\n            case 'A128CBC-HS256':\n                $cipher->setBlockLength(128);\n                break;\n            case 'A256GCM':\n            case 'A256CBC-HS512':\n                $cipher->setBlockLength(256);\n                break;\n            default:\n                throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n        }\n        return $cipher;\n    }\n\n    private function generateRandomBytes($length) {\n        return Random::string($length);\n    }\n\n    private function generateIv() {\n        switch ($this->header['enc']) {\n            case 'A128GCM':\n            case 'A128CBC-HS256':\n                $this->iv = $this->generateRandomBytes(128 / 8);\n                break;\n            case 'A256GCM':\n            case 'A256CBC-HS512':\n                $this->iv = $this->generateRandomBytes(256 / 8);\n                break;\n            default:\n                throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n        }\n    }\n\n    private function generateContentEncryptionKey($public_key_or_secret) {\n        if ($this->header['alg'] == 'dir') {\n            $this->content_encryption_key = $public_key_or_secret;\n        } else {\n            switch ($this->header['enc']) {\n                case 'A128GCM':\n                case 'A128CBC-HS256':\n                    $this->content_encryption_key = $this->generateRandomBytes(256 / 8);\n                    break;\n                case 'A256GCM':\n                case 'A256CBC-HS512':\n                    $this->content_encryption_key = $this->generateRandomBytes(512 / 8);\n                    break;\n                default:\n                    throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n            }\n        }\n    }\n\n    private function encryptContentEncryptionKey($public_key_or_secret) {\n        switch ($this->header['alg']) {\n            case 'RSA1_5':\n                $rsa = $this->rsa($public_key_or_secret, RSA::ENCRYPTION_PKCS1);\n                $this->jwe_encrypted_key = $rsa->encrypt($this->content_encryption_key);\n                break;\n            case 'RSA-OAEP':\n                $rsa = $this->rsa($public_key_or_secret, RSA::ENCRYPTION_OAEP);\n                $this->jwe_encrypted_key = $rsa->encrypt($this->content_encryption_key);\n                break;\n            case 'dir':\n                $this->jwe_encrypted_key = '';\n                return;\n            case 'A128KW':\n            case 'A256KW':\n            case 'ECDH-ES':\n            case 'ECDH-ES+A128KW':\n            case 'ECDH-ES+A256KW':\n                throw new JOSE_Exception_UnexpectedAlgorithm('Algorithm not supported');\n            default:\n                throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n        }\n        if (!$this->jwe_encrypted_key) {\n            throw new JOSE_Exception_EncryptionFailed('Master key encryption failed');\n        }\n    }\n\n    private function decryptContentEncryptionKey($private_key_or_secret) {\n        $this->generateContentEncryptionKey(null); # NOTE: run this always not to make timing difference\n        $fake_content_encryption_key = $this->content_encryption_key;\n        switch ($this->header['alg']) {\n            case 'RSA1_5':\n                $rsa = $this->rsa($private_key_or_secret, RSA::ENCRYPTION_PKCS1);\n                $this->content_encryption_key = $rsa->decrypt($this->jwe_encrypted_key);\n                break;\n            case 'RSA-OAEP':\n                $rsa = $this->rsa($private_key_or_secret, RSA::ENCRYPTION_OAEP);\n                $this->content_encryption_key = $rsa->decrypt($this->jwe_encrypted_key);\n                break;\n            case 'dir':\n                $this->content_encryption_key = $private_key_or_secret;\n                break;\n            case 'A128KW':\n            case 'A256KW':\n            case 'ECDH-ES':\n            case 'ECDH-ES+A128KW':\n            case 'ECDH-ES+A256KW':\n                throw new JOSE_Exception_UnexpectedAlgorithm('Algorithm not supported');\n            default:\n                throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n        }\n        if (!$this->content_encryption_key) {\n            # NOTE:\n            #  Not to disclose timing difference between CEK decryption error and others.\n            #  Mitigating Bleichenbacher Attack on PKCS#1 v1.5\n            #  ref.) http://inaz2.hatenablog.com/entry/2016/01/26/222303\n            $this->content_encryption_key = $fake_content_encryption_key;\n        }\n    }\n\n    private function deriveEncryptionAndMacKeys() {\n        switch ($this->header['enc']) {\n            case 'A128GCM':\n            case 'A256GCM':\n                $this->encryption_key = $this->content_encryption_key;\n                $this->mac_key = \"won't be used\";\n                break;\n            case 'A128CBC-HS256':\n                $this->deriveEncryptionAndMacKeysCBC(256);\n                break;\n            case 'A256CBC-HS512':\n                $this->deriveEncryptionAndMacKeysCBC(512);\n                break;\n            default:\n                throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n        }\n        if (!$this->encryption_key || !$this->mac_key) {\n            throw new JOSE_Exception_DecryptionFailed('Encryption/Mac key derivation failed');\n        }\n    }\n\n    private function deriveEncryptionAndMacKeysCBC($sha_size) {\n        $this->mac_key = substr($this->content_encryption_key, 0, $sha_size / 2 / 8);\n        $this->encryption_key = substr($this->content_encryption_key, $sha_size / 2 / 8);\n    }\n\n    private function encryptCipherText() {\n        $cipher = $this->cipher();\n        $cipher->setKey($this->encryption_key);\n        $cipher->setIV($this->iv);\n        $this->cipher_text = $cipher->encrypt($this->plain_text);\n        if (!$this->cipher_text) {\n            throw new JOSE_Exception_DecryptionFailed('Payload encryption failed');\n        }\n    }\n\n    private function decryptCipherText() {\n        $cipher = $this->cipher();\n        $cipher->setKey($this->encryption_key);\n        $cipher->setIV($this->iv);\n        $this->plain_text = $cipher->decrypt($this->cipher_text);\n        if (!$this->plain_text) {\n            throw new JOSE_Exception_DecryptionFailed('Payload decryption failed');\n        }\n    }\n\n    private function generateAuthenticationTag() {\n        $this->authentication_tag = $this->calculateAuthenticationTag();\n    }\n\n    private function calculateAuthenticationTag($use_raw = false) {\n        switch ($this->header['enc']) {\n            case 'A128GCM':\n            case 'A256GCM':\n                throw new JOSE_Exception_UnexpectedAlgorithm('Algorithm not supported');\n            case 'A128CBC-HS256':\n                return $this->calculateAuthenticationTagCBC(256);\n            case 'A256CBC-HS512':\n                return $this->calculateAuthenticationTagCBC(512);\n            default:\n                throw new JOSE_Exception_UnexpectedAlgorithm('Unknown algorithm');\n        }\n    }\n\n    private function calculateAuthenticationTagCBC($sha_size) {\n        if (!$this->auth_data) {\n            $this->auth_data = $this->compact((object) $this->header);\n        }\n        $auth_data_length = strlen($this->auth_data);\n        $max_32bit = 2147483647;\n        $secured_input = implode('', array(\n            $this->auth_data,\n            $this->iv,\n            $this->cipher_text,\n            // NOTE: PHP doesn't support 64bit big endian, so handling upper & lower 32bit.\n            pack('N2', ($auth_data_length / $max_32bit) * 8, ($auth_data_length % $max_32bit) * 8)\n        ));\n        return substr(\n            hash_hmac('sha' . $sha_size, $secured_input, $this->mac_key, true),\n            0, $sha_size / 2 / 8\n        );\n    }\n\n    private function checkAuthenticationTag() {\n        if (hash_equals($this->authentication_tag, $this->calculateAuthenticationTag())) {\n            return true;\n        } else {\n            throw new JOSE_Exception_UnexpectedAlgorithm('Invalid authentication tag');\n        }\n    }\n}\n"], "buggy_code_start_loc": [170], "buggy_code_end_loc": [286], "fixing_code_start_loc": [171], "fixing_code_end_loc": [288], "type": "CWE-200", "message": "The RSA 1.5 algorithm implementation in the JOSE_JWE class in JWE.php in jose-php before 2.2.1 lacks the Random Filling protection mechanism, which makes it easier for remote attackers to obtain cleartext data via a Million Message Attack (MMA).", "other": {"cve": {"id": "CVE-2016-5430", "sourceIdentifier": "secalert@redhat.com", "published": "2016-09-03T20:59:07.280", "lastModified": "2019-12-19T15:03:32.707", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The RSA 1.5 algorithm implementation in the JOSE_JWE class in JWE.php in jose-php before 2.2.1 lacks the Random Filling protection mechanism, which makes it easier for remote attackers to obtain cleartext data via a Million Message Attack (MMA)."}, {"lang": "es", "value": "La implementaci\u00f3n del algoritmo RSA 1.5 en la clase JOSE_JWE en JWE.php en jose-php en versiones anteriores a 2.2.1 carece del mecanismo de protecci\u00f3n Random Filling, lo que hace m\u00e1s f\u00e1cil a atacantes remotos obtener datos en texto plano a trav\u00e9s de un Million Message Attack (MMA)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}, {"lang": "en", "value": "CWE-310"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jose-php_project:jose-php:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.1", "matchCriteriaId": "B1053065-CC9C-4137-BEC3-2E3AE4CA58C5"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/92741", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/nov/jose-php/commit/f03b986b4439e20b0fd635109b48afe96cf0099b#diff-37b0d289d6375ba4a7740401950ccdd6R199", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/nov/jose-php/commit/f03b986b4439e20b0fd635109b48afe96cf0099b#diff-37b0d289d6375ba4a7740401950ccdd6R199"}}