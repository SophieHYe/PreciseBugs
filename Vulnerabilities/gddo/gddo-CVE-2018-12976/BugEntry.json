{"buggy_code": ["// Copyright 2013 The Go Authors. All rights reserved.\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd.\n\n// Package gosrc fetches Go package source code from version control services.\npackage gosrc\n\nimport (\n\t\"context\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"path\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst ExpiresAfter = 2 * 365 * 24 * time.Hour // Package with no commits and imports expires.\n\n// File represents a file.\ntype File struct {\n\t// File name with no directory.\n\tName string\n\n\t// Contents of the file.\n\tData []byte\n\n\t// Location of file on version control service website.\n\tBrowseURL string\n}\n\ntype DirectoryStatus int\n\nconst (\n\tActive          DirectoryStatus = iota\n\tDeadEndFork                     // Forks with no commits\n\tQuickFork                       // Forks with less than 3 commits, all within a week from creation\n\tNoRecentCommits                 // No commits for ExpiresAfter\n\n\t// No commits for ExpiresAfter and no imports.\n\t// This is a status derived from NoRecentCommits and the imports count information in the db.\n\tInactive\n)\n\n// Directory describes a directory on a version control service.\ntype Directory struct {\n\t// The import path for this package.\n\tImportPath string\n\n\t// Import path of package after resolving go-import meta tags, if any.\n\tResolvedPath string\n\n\t// Import path prefix for all packages in the project.\n\tProjectRoot string\n\n\t// Name of the project.\n\tProjectName string\n\n\t// Project home page.\n\tProjectURL string\n\n\t// Version control system: git, hg, bzr, ...\n\tVCS string\n\n\t// Version control: active or should be suppressed.\n\tStatus DirectoryStatus\n\n\t// Cache validation tag. This tag is not necessarily an HTTP entity tag.\n\t// The tag is \"\" if there is no meaningful cache validation for the VCS.\n\tEtag string\n\n\t// Files.\n\tFiles []*File\n\n\t// Subdirectories, not guaranteed to contain Go code.\n\tSubdirectories []string\n\n\t// Location of directory on version control service website.\n\tBrowseURL string\n\n\t// Format specifier for link to source line. It must contain one %s (file URL)\n\t// followed by one %d (source line number), or be empty string if not available.\n\t// Example: \"%s#L%d\".\n\tLineFmt string\n\n\t// Whether the repository of this directory is a fork of another one.\n\tFork bool\n\n\t// How many stars (for a GitHub project) or followers (for a BitBucket\n\t// project) the repository of this directory has.\n\tStars int\n}\n\n// Project represents a repository.\ntype Project struct {\n\tDescription string\n}\n\n// NotFoundError indicates that the directory or presentation was not found.\ntype NotFoundError struct {\n\t// Diagnostic message describing why the directory was not found.\n\tMessage string\n\n\t// Redirect specifies the path where package can be found.\n\tRedirect string\n}\n\nfunc (e NotFoundError) Error() string {\n\treturn e.Message\n}\n\n// IsNotFound returns true if err is of type NotFoundError.\nfunc IsNotFound(err error) bool {\n\t_, ok := err.(NotFoundError)\n\treturn ok\n}\n\ntype RemoteError struct {\n\tHost string\n\terr  error\n}\n\nfunc (e *RemoteError) Error() string {\n\treturn e.err.Error()\n}\n\ntype NotModifiedError struct {\n\tSince  time.Time\n\tStatus DirectoryStatus\n}\n\nfunc (e NotModifiedError) Error() string {\n\tmsg := \"package not modified\"\n\tif !e.Since.IsZero() {\n\t\tmsg += fmt.Sprintf(\" since %s\", e.Since.Format(time.RFC1123))\n\t}\n\tif e.Status == QuickFork {\n\t\tmsg += \" (package is a quick fork)\"\n\t}\n\treturn msg\n}\n\nvar errNoMatch = errors.New(\"no match\")\n\n// service represents a source code control service.\ntype service struct {\n\tpattern         *regexp.Regexp\n\tprefix          string\n\tget             func(context.Context, *http.Client, map[string]string, string) (*Directory, error)\n\tgetPresentation func(context.Context, *http.Client, map[string]string) (*Presentation, error)\n\tgetProject      func(context.Context, *http.Client, map[string]string) (*Project, error)\n}\n\nvar services []*service\n\nfunc addService(s *service) {\n\tif s.prefix == \"\" {\n\t\tservices = append(services, s)\n\t} else {\n\t\tservices = append([]*service{s}, services...)\n\t}\n}\n\nfunc (s *service) match(importPath string) (map[string]string, error) {\n\tif !strings.HasPrefix(importPath, s.prefix) {\n\t\treturn nil, nil\n\t}\n\tm := s.pattern.FindStringSubmatch(importPath)\n\tif m == nil {\n\t\tif s.prefix != \"\" {\n\t\t\treturn nil, NotFoundError{Message: \"Import path prefix matches known service, but regexp does not.\"}\n\t\t}\n\t\treturn nil, nil\n\t}\n\tmatch := map[string]string{\"importPath\": importPath}\n\tfor i, n := range s.pattern.SubexpNames() {\n\t\tif n != \"\" {\n\t\t\tmatch[n] = m[i]\n\t\t}\n\t}\n\treturn match, nil\n}\n\n// importMeta represents the values in a go-import meta tag.\ntype importMeta struct {\n\tprojectRoot string\n\tvcs         string\n\trepo        string\n}\n\n// sourceMeta represents the values in a go-source meta tag.\ntype sourceMeta struct {\n\tprojectRoot  string\n\tprojectURL   string\n\tdirTemplate  string\n\tfileTemplate string\n}\n\nfunc isHTTPURL(s string) bool {\n\treturn strings.HasPrefix(s, \"https://\") || strings.HasPrefix(s, \"http://\")\n}\n\nfunc replaceDir(s string, dir string) string {\n\tslashDir := \"\"\n\tdir = strings.Trim(dir, \"/\")\n\tif dir != \"\" {\n\t\tslashDir = \"/\" + dir\n\t}\n\ts = strings.Replace(s, \"{dir}\", dir, -1)\n\ts = strings.Replace(s, \"{/dir}\", slashDir, -1)\n\treturn s\n}\n\nfunc attrValue(attrs []xml.Attr, name string) string {\n\tfor _, a := range attrs {\n\t\tif strings.EqualFold(a.Name.Local, name) {\n\t\t\treturn a.Value\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc fetchMeta(ctx context.Context, client *http.Client, importPath string) (scheme string, im *importMeta, sm *sourceMeta, redir bool, err error) {\n\turi := importPath\n\tif !strings.Contains(uri, \"/\") {\n\t\t// Add slash for root of domain.\n\t\turi = uri + \"/\"\n\t}\n\turi = uri + \"?go-get=1\"\n\n\tc := httpClient{client: client}\n\tscheme = \"https\"\n\tresp, err := c.get(ctx, scheme+\"://\"+uri)\n\tif err != nil || resp.StatusCode != 200 {\n\t\tif err == nil {\n\t\t\tresp.Body.Close()\n\t\t}\n\t\tscheme = \"http\"\n\t\tresp, err = c.get(ctx, scheme+\"://\"+uri)\n\t\tif err != nil {\n\t\t\treturn scheme, nil, nil, false, err\n\t\t}\n\t}\n\tdefer resp.Body.Close()\n\tim, sm, redir, err = parseMeta(scheme, importPath, resp.Body)\n\treturn scheme, im, sm, redir, err\n}\n\nvar refreshToGodocPat = regexp.MustCompile(`(?i)^\\d+; url=https?://godoc\\.org/`)\n\nfunc parseMeta(scheme, importPath string, r io.Reader) (im *importMeta, sm *sourceMeta, redir bool, err error) {\n\terrorMessage := \"go-import meta tag not found\"\n\n\td := xml.NewDecoder(r)\n\td.Strict = false\nmetaScan:\n\tfor {\n\t\tt, tokenErr := d.Token()\n\t\tif tokenErr != nil {\n\t\t\tbreak metaScan\n\t\t}\n\t\tswitch t := t.(type) {\n\t\tcase xml.EndElement:\n\t\t\tif strings.EqualFold(t.Name.Local, \"head\") {\n\t\t\t\tbreak metaScan\n\t\t\t}\n\t\tcase xml.StartElement:\n\t\t\tif strings.EqualFold(t.Name.Local, \"body\") {\n\t\t\t\tbreak metaScan\n\t\t\t}\n\t\t\tif !strings.EqualFold(t.Name.Local, \"meta\") {\n\t\t\t\tcontinue metaScan\n\t\t\t}\n\t\t\tif strings.EqualFold(attrValue(t.Attr, \"http-equiv\"), \"refresh\") {\n\t\t\t\t// Check for http-equiv refresh back to godoc.org.\n\t\t\t\tredir = refreshToGodocPat.MatchString(attrValue(t.Attr, \"content\"))\n\t\t\t\tcontinue metaScan\n\t\t\t}\n\t\t\tnameAttr := attrValue(t.Attr, \"name\")\n\t\t\tif nameAttr != \"go-import\" && nameAttr != \"go-source\" {\n\t\t\t\tcontinue metaScan\n\t\t\t}\n\t\t\tfields := strings.Fields(attrValue(t.Attr, \"content\"))\n\t\t\tif len(fields) < 1 {\n\t\t\t\tcontinue metaScan\n\t\t\t}\n\t\t\tprojectRoot := fields[0]\n\t\t\tif !strings.HasPrefix(importPath, projectRoot) ||\n\t\t\t\t!(len(importPath) == len(projectRoot) || importPath[len(projectRoot)] == '/') {\n\t\t\t\t// Ignore if root is not a prefix of the  path. This allows a\n\t\t\t\t// site to use a single error page for multiple repositories.\n\t\t\t\tcontinue metaScan\n\t\t\t}\n\t\t\tswitch nameAttr {\n\t\t\tcase \"go-import\":\n\t\t\t\tif len(fields) != 3 {\n\t\t\t\t\terrorMessage = \"go-import meta tag content attribute does not have three fields\"\n\t\t\t\t\tcontinue metaScan\n\t\t\t\t}\n\t\t\t\tif fields[1] == \"mod\" {\n\t\t\t\t\t// vgo adds a special mod vcs type; we can skip this\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif im != nil {\n\t\t\t\t\tim = nil\n\t\t\t\t\terrorMessage = \"more than one go-import meta tag found\"\n\t\t\t\t\tbreak metaScan\n\t\t\t\t}\n\t\t\t\tim = &importMeta{\n\t\t\t\t\tprojectRoot: projectRoot,\n\t\t\t\t\tvcs:         fields[1],\n\t\t\t\t\trepo:        fields[2],\n\t\t\t\t}\n\t\t\tcase \"go-source\":\n\t\t\t\tif sm != nil {\n\t\t\t\t\t// Ignore extra go-source meta tags.\n\t\t\t\t\tcontinue metaScan\n\t\t\t\t}\n\t\t\t\tif len(fields) != 4 {\n\t\t\t\t\tcontinue metaScan\n\t\t\t\t}\n\t\t\t\tsm = &sourceMeta{\n\t\t\t\t\tprojectRoot:  projectRoot,\n\t\t\t\t\tprojectURL:   fields[1],\n\t\t\t\t\tdirTemplate:  fields[2],\n\t\t\t\t\tfileTemplate: fields[3],\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif im == nil {\n\t\treturn nil, nil, redir, NotFoundError{Message: fmt.Sprintf(\"%s at %s://%s\", errorMessage, scheme, importPath)}\n\t}\n\tif sm != nil && sm.projectRoot != im.projectRoot {\n\t\tsm = nil\n\t}\n\treturn im, sm, redir, nil\n}\n\n// getVCSDirFn is called by getDynamic to fetch source using VCS commands. The\n// default value here does nothing. If the code is not built for App Engine,\n// then getVCSDirFn is set getVCSDir, the function that actually does the work.\nvar getVCSDirFn = func(ctx context.Context, client *http.Client, m map[string]string, etag string) (*Directory, error) {\n\treturn nil, errNoMatch\n}\n\n// getDynamic gets a directory from a service that is not statically known.\nfunc getDynamic(ctx context.Context, client *http.Client, importPath, etag string) (*Directory, error) {\n\tmetaProto, im, sm, redir, err := fetchMeta(ctx, client, importPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif im.projectRoot != importPath {\n\t\tvar imRoot *importMeta\n\t\tmetaProto, imRoot, _, redir, err = fetchMeta(ctx, client, im.projectRoot)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif *imRoot != *im {\n\t\t\treturn nil, NotFoundError{Message: \"project root mismatch.\"}\n\t\t}\n\t}\n\n\t// clonePath is the repo URL from import meta tag, with the \"scheme://\" prefix removed.\n\t// It should be used for cloning repositories.\n\t// repo is the repo URL from import meta tag, with the \"scheme://\" prefix removed, and\n\t// a possible \".vcs\" suffix trimmed.\n\ti := strings.Index(im.repo, \"://\")\n\tif i < 0 {\n\t\treturn nil, NotFoundError{Message: \"bad repo URL: \" + im.repo}\n\t}\n\tproto := im.repo[:i]\n\tclonePath := im.repo[i+len(\"://\"):]\n\trepo := strings.TrimSuffix(clonePath, \".\"+im.vcs)\n\tdirName := importPath[len(im.projectRoot):]\n\n\tresolvedPath := repo + dirName\n\tdir, err := getStatic(ctx, client, resolvedPath, etag)\n\tif err == errNoMatch {\n\t\tresolvedPath = repo + \".\" + im.vcs + dirName\n\t\tmatch := map[string]string{\n\t\t\t\"dir\":        dirName,\n\t\t\t\"importPath\": importPath,\n\t\t\t\"clonePath\":  clonePath,\n\t\t\t\"repo\":       repo,\n\t\t\t\"scheme\":     proto,\n\t\t\t\"vcs\":        im.vcs,\n\t\t}\n\t\tdir, err = getVCSDirFn(ctx, client, match, etag)\n\t}\n\tif err != nil || dir == nil {\n\t\treturn nil, err\n\t}\n\n\tdir.ImportPath = importPath\n\tdir.ProjectRoot = im.projectRoot\n\tdir.ResolvedPath = resolvedPath\n\tdir.ProjectName = path.Base(im.projectRoot)\n\tif !redir {\n\t\tdir.ProjectURL = metaProto + \"://\" + im.projectRoot\n\t}\n\n\tif sm == nil {\n\t\treturn dir, nil\n\t}\n\n\tif isHTTPURL(sm.projectURL) {\n\t\tdir.ProjectURL = sm.projectURL\n\t}\n\n\tif isHTTPURL(sm.dirTemplate) {\n\t\tdir.BrowseURL = replaceDir(sm.dirTemplate, dirName)\n\t}\n\n\t// TODO: Refactor this to be simpler, implement the go-source meta tag spec fully.\n\tif isHTTPURL(sm.fileTemplate) {\n\t\tfileTemplate := replaceDir(sm.fileTemplate, dirName)\n\t\tif strings.Contains(fileTemplate, \"{file}\") {\n\t\t\tcut := strings.LastIndex(fileTemplate, \"{file}\") + len(\"{file}\") // Cut point is right after last {file} section.\n\t\t\tswitch hash := strings.Index(fileTemplate, \"#\"); {\n\t\t\tcase hash == -1: // If there's no '#', place cut at the end.\n\t\t\t\tcut = len(fileTemplate)\n\t\t\tcase hash > cut: // If a '#' comes after last {file}, use it as cut point.\n\t\t\t\tcut = hash\n\t\t\t}\n\t\t\thead, tail := fileTemplate[:cut], fileTemplate[cut:]\n\t\t\tfor _, f := range dir.Files {\n\t\t\t\tf.BrowseURL = strings.Replace(head, \"{file}\", f.Name, -1)\n\t\t\t}\n\n\t\t\tif strings.Contains(tail, \"{line}\") {\n\t\t\t\ts := strings.Replace(tail, \"%\", \"%%\", -1)\n\t\t\t\ts = strings.Replace(s, \"{line}\", \"%d\", 1)\n\t\t\t\tdir.LineFmt = \"%s\" + s\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dir, nil\n}\n\n// getStatic gets a diretory from a statically known service. getStatic\n// returns errNoMatch if the import path is not recognized.\nfunc getStatic(ctx context.Context, client *http.Client, importPath, etag string) (*Directory, error) {\n\tfor _, s := range services {\n\t\tif s.get == nil {\n\t\t\tcontinue\n\t\t}\n\t\tmatch, err := s.match(importPath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif match != nil {\n\t\t\tdir, err := s.get(ctx, client, match, etag)\n\t\t\tif dir != nil {\n\t\t\t\tdir.ImportPath = importPath\n\t\t\t\tdir.ResolvedPath = importPath\n\t\t\t}\n\t\t\treturn dir, err\n\t\t}\n\t}\n\treturn nil, errNoMatch\n}\n\nfunc Get(ctx context.Context, client *http.Client, importPath string, etag string) (dir *Directory, err error) {\n\tswitch {\n\tcase localPath != \"\":\n\t\tdir, err = getLocal(importPath)\n\tcase IsGoRepoPath(importPath):\n\t\tdir, err = getStandardDir(ctx, client, importPath, etag)\n\tcase IsValidRemotePath(importPath):\n\t\tdir, err = getStatic(ctx, client, importPath, etag)\n\t\tif err == errNoMatch {\n\t\t\tdir, err = getDynamic(ctx, client, importPath, etag)\n\t\t}\n\tdefault:\n\t\terr = errNoMatch\n\t}\n\n\tif err == errNoMatch {\n\t\terr = NotFoundError{Message: \"Import path not valid:\"}\n\t}\n\n\treturn dir, err\n}\n\n// GetPresentation gets a presentation from the the given path.\nfunc GetPresentation(ctx context.Context, client *http.Client, importPath string) (*Presentation, error) {\n\text := path.Ext(importPath)\n\tif ext != \".slide\" && ext != \".article\" {\n\t\treturn nil, NotFoundError{Message: \"unknown file extension.\"}\n\t}\n\n\timportPath, file := path.Split(importPath)\n\timportPath = strings.TrimSuffix(importPath, \"/\")\n\tfor _, s := range services {\n\t\tif s.getPresentation == nil {\n\t\t\tcontinue\n\t\t}\n\t\tmatch, err := s.match(importPath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif match != nil {\n\t\t\tmatch[\"file\"] = file\n\t\t\treturn s.getPresentation(ctx, client, match)\n\t\t}\n\t}\n\treturn nil, NotFoundError{Message: \"path does not match registered service\"}\n}\n\n// GetProject gets information about a repository.\nfunc GetProject(ctx context.Context, client *http.Client, importPath string) (*Project, error) {\n\tfor _, s := range services {\n\t\tif s.getProject == nil {\n\t\t\tcontinue\n\t\t}\n\t\tmatch, err := s.match(importPath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif match != nil {\n\t\t\treturn s.getProject(ctx, client, match)\n\t\t}\n\t}\n\treturn nil, NotFoundError{Message: \"path does not match registered service\"}\n}\n", "// Copyright 2014 The Go Authors. All rights reserved.\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd.\n\npackage gosrc\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nvar testWeb = map[string]string{\n\t// Package at root of a GitHub repo.\n\t\"https://alice.org/pkg\": `<head> <meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\"></head>`,\n\t// Package in sub-diretory.\n\t\"https://alice.org/pkg/sub\": `<head> <meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\"><body>`,\n\t// Fallback to http.\n\t\"http://alice.org/pkg/http\": `<head> <meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\">`,\n\t// Meta tag in sub-directory does not match meta tag at root.\n\t\"https://alice.org/pkg/mismatch\": `<head> <meta name=\"go-import\" content=\"alice.org/pkg hg https://github.com/alice/pkg\">`,\n\t// More than one matching meta tag.\n\t\"http://alice.org/pkg/multiple\": `<head> ` +\n\t\t`<meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\">` +\n\t\t`<meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\">`,\n\t// Package with go-source meta tag.\n\t\"https://alice.org/pkg/source\": `<head>` +\n\t\t`<meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\">` +\n\t\t`<meta name=\"go-source\" content=\"alice.org/pkg http://alice.org/pkg http://alice.org/pkg{/dir} http://alice.org/pkg{/dir}?f={file}#Line{line}\">`,\n\t\"https://alice.org/pkg/ignore\": `<head>` +\n\t\t`<title>Hello</title>` +\n\t\t// Unknown meta name\n\t\t`<meta name=\"go-junk\" content=\"alice.org/pkg http://alice.org/pkg http://alice.org/pkg{/dir} http://alice.org/pkg{/dir}?f={file}#Line{line}\">` +\n\t\t// go-source before go-meta\n\t\t`<meta name=\"go-source\" content=\"alice.org/pkg http://alice.org/pkg http://alice.org/pkg{/dir} http://alice.org/pkg{/dir}?f={file}#Line{line}\">` +\n\t\t// go-import tag for the package\n\t\t`<meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\">` +\n\t\t// go-import with wrong number of fields\n\t\t`<meta name=\"go-import\" content=\"alice.org/pkg https://github.com/alice/pkg\">` +\n\t\t// go-import with no fields\n\t\t`<meta name=\"go-import\" content=\"\">` +\n\t\t// go-source with wrong number of fields\n\t\t`<meta name=\"go-source\" content=\"alice.org/pkg blah\">` +\n\t\t// meta tag for a different package\n\t\t`<meta name=\"go-import\" content=\"alice.org/other git https://github.com/alice/other\">` +\n\t\t// meta tag for a different package\n\t\t`<meta name=\"go-import\" content=\"alice.org/other git https://github.com/alice/other\">` +\n\t\t`</head>` +\n\t\t// go-import outside of head\n\t\t`<meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\">`,\n\n\t// Package at root of a Git repo.\n\t\"https://bob.com/pkg\": `<head> <meta name=\"go-import\" content=\"bob.com/pkg git https://vcs.net/bob/pkg.git\">`,\n\t// Package at in sub-directory of a Git repo.\n\t\"https://bob.com/pkg/sub\": `<head> <meta name=\"go-import\" content=\"bob.com/pkg git https://vcs.net/bob/pkg.git\">`,\n\t// Package with go-source meta tag.\n\t\"https://bob.com/pkg/source\": `<head>` +\n\t\t`<meta name=\"go-import\" content=\"bob.com/pkg git https://vcs.net/bob/pkg.git\">` +\n\t\t`<meta name=\"go-source\" content=\"bob.com/pkg http://bob.com/pkg http://bob.com/pkg{/dir}/ http://bob.com/pkg{/dir}/?f={file}#Line{line}\">`,\n\t// Meta refresh to godoc.org\n\t\"http://rsc.io/benchstat\": `<!DOCTYPE html><html><head>` +\n\t\t`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>` +\n\t\t`<meta name=\"go-import\" content=\"rsc.io/benchstat git https://github.com/rsc/benchstat\">` +\n\t\t`<meta http-equiv=\"refresh\" content=\"0; url=https://godoc.org/rsc.io/benchstat\">` +\n\t\t`</head>`,\n\n\t// Package with go-source meta tag, where {file} appears on the right of '#' in the file field URL template.\n\t\"https://azul3d.org/examples\": `<!DOCTYPE html><html><head>` +\n\t\t`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>` +\n\t\t`<meta name=\"go-import\" content=\"azul3d.org/examples git https://github.com/azul3d/examples\">` +\n\t\t`<meta name=\"go-source\" content=\"azul3d.org/examples https://github.com/azul3d/examples https://gotools.org/azul3d.org/examples{/dir} https://gotools.org/azul3d.org/examples{/dir}#{file}-L{line}\">` +\n\t\t`<meta http-equiv=\"refresh\" content=\"0; url=https://godoc.org/azul3d.org/examples\">` +\n\t\t`</head>`,\n\t\"https://azul3d.org/examples/abs\": `<!DOCTYPE html><html><head>` +\n\t\t`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>` +\n\t\t`<meta name=\"go-import\" content=\"azul3d.org/examples git https://github.com/azul3d/examples\">` +\n\t\t`<meta name=\"go-source\" content=\"azul3d.org/examples https://github.com/azul3d/examples https://gotools.org/azul3d.org/examples{/dir} https://gotools.org/azul3d.org/examples{/dir}#{file}-L{line}\">` +\n\t\t`<meta http-equiv=\"refresh\" content=\"0; url=https://godoc.org/azul3d.org/examples/abs\">` +\n\t\t`</head>`,\n\n\t// Multiple go-import meta tags; one of which is a vgo-special mod vcs type\n\t\"http://myitcv.io/blah2\": `<!DOCTYPE html><html><head>` +\n\t\t`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>` +\n\t\t`<meta name=\"go-import\" content=\"myitcv.io/blah2 git https://github.com/myitcv/x\">` +\n\t\t`<meta name=\"go-import\" content=\"myitcv.io/blah2 mod https://raw.githubusercontent.com/myitcv/pubx/master\">` +\n\t\t`<meta name=\"go-source\" content=\"myitcv.io https://github.com/myitcv/x/wiki https://github.com/myitcv/x/tree/master{/dir} https://github.com/myitcv/x/blob/master{/dir}/{file}#L{line}\">` +\n\t\t`</head>`,\n}\n\nvar getDynamicTests = []struct {\n\timportPath string\n\tdir        *Directory\n}{\n\t{\"alice.org/pkg\", &Directory{\n\t\tBrowseURL:    \"https://github.com/alice/pkg\",\n\t\tImportPath:   \"alice.org/pkg\",\n\t\tLineFmt:      \"%s#L%d\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"alice.org/pkg\",\n\t\tProjectURL:   \"https://alice.org/pkg\",\n\t\tResolvedPath: \"github.com/alice/pkg\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"https://github.com/alice/pkg/blob/master/main.go\"}},\n\t}},\n\t{\"alice.org/pkg/sub\", &Directory{\n\t\tBrowseURL:    \"https://github.com/alice/pkg/tree/master/sub\",\n\t\tImportPath:   \"alice.org/pkg/sub\",\n\t\tLineFmt:      \"%s#L%d\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"alice.org/pkg\",\n\t\tProjectURL:   \"https://alice.org/pkg\",\n\t\tResolvedPath: \"github.com/alice/pkg/sub\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"https://github.com/alice/pkg/blob/master/sub/main.go\"}},\n\t}},\n\t{\"alice.org/pkg/http\", &Directory{\n\t\tBrowseURL:    \"https://github.com/alice/pkg/tree/master/http\",\n\t\tImportPath:   \"alice.org/pkg/http\",\n\t\tLineFmt:      \"%s#L%d\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"alice.org/pkg\",\n\t\tProjectURL:   \"https://alice.org/pkg\",\n\t\tResolvedPath: \"github.com/alice/pkg/http\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"https://github.com/alice/pkg/blob/master/http/main.go\"}},\n\t}},\n\t{\"alice.org/pkg/source\", &Directory{\n\t\tBrowseURL:    \"http://alice.org/pkg/source\",\n\t\tImportPath:   \"alice.org/pkg/source\",\n\t\tLineFmt:      \"%s#Line%d\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"alice.org/pkg\",\n\t\tProjectURL:   \"http://alice.org/pkg\",\n\t\tResolvedPath: \"github.com/alice/pkg/source\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"http://alice.org/pkg/source?f=main.go\"}},\n\t}},\n\t{\"alice.org/pkg/ignore\", &Directory{\n\t\tBrowseURL:    \"http://alice.org/pkg/ignore\",\n\t\tImportPath:   \"alice.org/pkg/ignore\",\n\t\tLineFmt:      \"%s#Line%d\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"alice.org/pkg\",\n\t\tProjectURL:   \"http://alice.org/pkg\",\n\t\tResolvedPath: \"github.com/alice/pkg/ignore\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"http://alice.org/pkg/ignore?f=main.go\"}},\n\t}},\n\t{\"alice.org/pkg/mismatch\", nil},\n\t{\"alice.org/pkg/multiple\", nil},\n\t{\"alice.org/pkg/notfound\", nil},\n\n\t{\"bob.com/pkg\", &Directory{\n\t\tImportPath:   \"bob.com/pkg\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"bob.com/pkg\",\n\t\tProjectURL:   \"https://bob.com/pkg\",\n\t\tResolvedPath: \"vcs.net/bob/pkg.git\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\"}},\n\t}},\n\t{\"bob.com/pkg/sub\", &Directory{\n\t\tImportPath:   \"bob.com/pkg/sub\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"bob.com/pkg\",\n\t\tProjectURL:   \"https://bob.com/pkg\",\n\t\tResolvedPath: \"vcs.net/bob/pkg.git/sub\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\"}},\n\t}},\n\t{\"bob.com/pkg/source\", &Directory{\n\t\tBrowseURL:    \"http://bob.com/pkg/source/\",\n\t\tImportPath:   \"bob.com/pkg/source\",\n\t\tLineFmt:      \"%s#Line%d\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"bob.com/pkg\",\n\t\tProjectURL:   \"http://bob.com/pkg\",\n\t\tResolvedPath: \"vcs.net/bob/pkg.git/source\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"http://bob.com/pkg/source/?f=main.go\"}},\n\t}},\n\t{\"rsc.io/benchstat\", &Directory{\n\t\tBrowseURL:    \"https://github.com/rsc/benchstat\",\n\t\tImportPath:   \"rsc.io/benchstat\",\n\t\tLineFmt:      \"%s#L%d\",\n\t\tProjectName:  \"benchstat\",\n\t\tProjectRoot:  \"rsc.io/benchstat\",\n\t\tProjectURL:   \"https://github.com/rsc/benchstat\",\n\t\tResolvedPath: \"github.com/rsc/benchstat\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"https://github.com/rsc/benchstat/blob/master/main.go\"}},\n\t}},\n\t{\"azul3d.org/examples/abs\", &Directory{\n\t\tBrowseURL:    \"https://gotools.org/azul3d.org/examples/abs\",\n\t\tImportPath:   \"azul3d.org/examples/abs\",\n\t\tLineFmt:      \"%s-L%d\",\n\t\tProjectName:  \"examples\",\n\t\tProjectRoot:  \"azul3d.org/examples\",\n\t\tProjectURL:   \"https://github.com/azul3d/examples\",\n\t\tResolvedPath: \"github.com/azul3d/examples/abs\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"https://gotools.org/azul3d.org/examples/abs#main.go\"}},\n\t}},\n\t{\"myitcv.io/blah2\", &Directory{\n\t\tBrowseURL:    \"https://github.com/myitcv/x\",\n\t\tImportPath:   \"myitcv.io/blah2\",\n\t\tLineFmt:      \"%s#L%d\",\n\t\tProjectName:  \"blah2\",\n\t\tProjectRoot:  \"myitcv.io/blah2\",\n\t\tProjectURL:   \"http://myitcv.io/blah2\",\n\t\tResolvedPath: \"github.com/myitcv/x\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"https://github.com/myitcv/x/blob/master/main.go\"}},\n\t}},\n}\n\ntype testTransport map[string]string\n\nfunc (t testTransport) RoundTrip(req *http.Request) (*http.Response, error) {\n\tstatusCode := http.StatusOK\n\treq.URL.RawQuery = \"\"\n\tbody, ok := t[req.URL.String()]\n\tif !ok {\n\t\tstatusCode = http.StatusNotFound\n\t}\n\tresp := &http.Response{\n\t\tStatusCode: statusCode,\n\t\tBody:       ioutil.NopCloser(strings.NewReader(body)),\n\t}\n\treturn resp, nil\n}\n\nvar githubPattern = regexp.MustCompile(`^github\\.com/(?P<owner>[a-z0-9A-Z_.\\-]+)/(?P<repo>[a-z0-9A-Z_.\\-]+)(?P<dir>/[a-z0-9A-Z_.\\-/]*)?$`)\n\nfunc testGet(ctx context.Context, client *http.Client, match map[string]string, etag string) (*Directory, error) {\n\timportPath := match[\"importPath\"]\n\n\tif m := githubPattern.FindStringSubmatch(importPath); m != nil {\n\t\tbrowseURL := fmt.Sprintf(\"https://github.com/%s/%s\", m[1], m[2])\n\t\tif m[3] != \"\" {\n\t\t\tbrowseURL = fmt.Sprintf(\"%s/tree/master%s\", browseURL, m[3])\n\t\t}\n\t\treturn &Directory{\n\t\t\tBrowseURL:   browseURL,\n\t\t\tImportPath:  importPath,\n\t\t\tLineFmt:     \"%s#L%d\",\n\t\t\tProjectName: m[2],\n\t\t\tProjectRoot: fmt.Sprintf(\"github.com/%s/%s\", m[1], m[2]),\n\t\t\tProjectURL:  fmt.Sprintf(\"https://github.com/%s/%s\", m[1], m[2]),\n\t\t\tVCS:         \"git\",\n\t\t\tFiles: []*File{{\n\t\t\t\tName:      \"main.go\",\n\t\t\t\tBrowseURL: fmt.Sprintf(\"https://github.com/%s/%s/blob/master%s/main.go\", m[1], m[2], m[3]),\n\t\t\t}},\n\t\t}, nil\n\t}\n\n\tif strings.HasPrefix(match[\"repo\"], \"vcs.net\") {\n\t\treturn &Directory{\n\t\t\tImportPath:  importPath,\n\t\t\tProjectName: path.Base(match[\"repo\"]),\n\t\t\tProjectRoot: fmt.Sprintf(\"%s.%s\", match[\"repo\"], match[\"vcs\"]),\n\t\t\tVCS:         match[\"vcs\"],\n\t\t\tFiles:       []*File{{Name: \"main.go\"}},\n\t\t}, nil\n\t}\n\n\treturn nil, errNoMatch\n}\n\nfunc TestGetDynamic(t *testing.T) {\n\tsavedServices := services\n\tsavedGetVCSDirFn := getVCSDirFn\n\tdefer func() {\n\t\tservices = savedServices\n\t\tgetVCSDirFn = savedGetVCSDirFn\n\t}()\n\tservices = []*service{{pattern: regexp.MustCompile(\".*\"), get: testGet}}\n\tgetVCSDirFn = testGet\n\tclient := &http.Client{Transport: testTransport(testWeb)}\n\n\tfor _, tt := range getDynamicTests {\n\t\tdir, err := getDynamic(context.Background(), client, tt.importPath, \"\")\n\n\t\tif tt.dir == nil {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"getDynamic(client, %q, etag) did not return expected error\", tt.importPath)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"getDynamic(client, %q, etag) return unexpected error: %v\", tt.importPath, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !cmp.Equal(dir, tt.dir) {\n\t\t\tt.Errorf(\"getDynamic(client, %q, etag) =\\n     %+v,\\nwant %+v\", tt.importPath, dir, tt.dir)\n\t\t\tfor i, f := range dir.Files {\n\t\t\t\tvar want *File\n\t\t\t\tif i < len(tt.dir.Files) {\n\t\t\t\t\twant = tt.dir.Files[i]\n\t\t\t\t}\n\t\t\t\tt.Errorf(\"file %d = %+v, want %+v\", i, f, want)\n\t\t\t}\n\t\t}\n\t}\n}\n"], "fixing_code": ["// Copyright 2013 The Go Authors. All rights reserved.\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd.\n\n// Package gosrc fetches Go package source code from version control services.\npackage gosrc\n\nimport (\n\t\"context\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"path\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst ExpiresAfter = 2 * 365 * 24 * time.Hour // Package with no commits and imports expires.\n\n// File represents a file.\ntype File struct {\n\t// File name with no directory.\n\tName string\n\n\t// Contents of the file.\n\tData []byte\n\n\t// Location of file on version control service website.\n\tBrowseURL string\n}\n\ntype DirectoryStatus int\n\nconst (\n\tActive          DirectoryStatus = iota\n\tDeadEndFork                     // Forks with no commits\n\tQuickFork                       // Forks with less than 3 commits, all within a week from creation\n\tNoRecentCommits                 // No commits for ExpiresAfter\n\n\t// No commits for ExpiresAfter and no imports.\n\t// This is a status derived from NoRecentCommits and the imports count information in the db.\n\tInactive\n)\n\n// Directory describes a directory on a version control service.\ntype Directory struct {\n\t// The import path for this package.\n\tImportPath string\n\n\t// Import path of package after resolving go-import meta tags, if any.\n\tResolvedPath string\n\n\t// Import path prefix for all packages in the project.\n\tProjectRoot string\n\n\t// Name of the project.\n\tProjectName string\n\n\t// Project home page.\n\tProjectURL string\n\n\t// Version control system: git, hg, bzr, ...\n\tVCS string\n\n\t// Version control: active or should be suppressed.\n\tStatus DirectoryStatus\n\n\t// Cache validation tag. This tag is not necessarily an HTTP entity tag.\n\t// The tag is \"\" if there is no meaningful cache validation for the VCS.\n\tEtag string\n\n\t// Files.\n\tFiles []*File\n\n\t// Subdirectories, not guaranteed to contain Go code.\n\tSubdirectories []string\n\n\t// Location of directory on version control service website.\n\tBrowseURL string\n\n\t// Format specifier for link to source line. It must contain one %s (file URL)\n\t// followed by one %d (source line number), or be empty string if not available.\n\t// Example: \"%s#L%d\".\n\tLineFmt string\n\n\t// Whether the repository of this directory is a fork of another one.\n\tFork bool\n\n\t// How many stars (for a GitHub project) or followers (for a BitBucket\n\t// project) the repository of this directory has.\n\tStars int\n}\n\n// Project represents a repository.\ntype Project struct {\n\tDescription string\n}\n\n// NotFoundError indicates that the directory or presentation was not found.\ntype NotFoundError struct {\n\t// Diagnostic message describing why the directory was not found.\n\tMessage string\n\n\t// Redirect specifies the path where package can be found.\n\tRedirect string\n}\n\nfunc (e NotFoundError) Error() string {\n\treturn e.Message\n}\n\n// IsNotFound returns true if err is of type NotFoundError.\nfunc IsNotFound(err error) bool {\n\t_, ok := err.(NotFoundError)\n\treturn ok\n}\n\ntype RemoteError struct {\n\tHost string\n\terr  error\n}\n\nfunc (e *RemoteError) Error() string {\n\treturn e.err.Error()\n}\n\ntype NotModifiedError struct {\n\tSince  time.Time\n\tStatus DirectoryStatus\n}\n\nfunc (e NotModifiedError) Error() string {\n\tmsg := \"package not modified\"\n\tif !e.Since.IsZero() {\n\t\tmsg += fmt.Sprintf(\" since %s\", e.Since.Format(time.RFC1123))\n\t}\n\tif e.Status == QuickFork {\n\t\tmsg += \" (package is a quick fork)\"\n\t}\n\treturn msg\n}\n\nvar errNoMatch = errors.New(\"no match\")\n\n// service represents a source code control service.\ntype service struct {\n\tpattern         *regexp.Regexp\n\tprefix          string\n\tget             func(context.Context, *http.Client, map[string]string, string) (*Directory, error)\n\tgetPresentation func(context.Context, *http.Client, map[string]string) (*Presentation, error)\n\tgetProject      func(context.Context, *http.Client, map[string]string) (*Project, error)\n}\n\nvar services []*service\n\nfunc addService(s *service) {\n\tif s.prefix == \"\" {\n\t\tservices = append(services, s)\n\t} else {\n\t\tservices = append([]*service{s}, services...)\n\t}\n}\n\nfunc (s *service) match(importPath string) (map[string]string, error) {\n\tif !strings.HasPrefix(importPath, s.prefix) {\n\t\treturn nil, nil\n\t}\n\tm := s.pattern.FindStringSubmatch(importPath)\n\tif m == nil {\n\t\tif s.prefix != \"\" {\n\t\t\treturn nil, NotFoundError{Message: \"Import path prefix matches known service, but regexp does not.\"}\n\t\t}\n\t\treturn nil, nil\n\t}\n\tmatch := map[string]string{\"importPath\": importPath}\n\tfor i, n := range s.pattern.SubexpNames() {\n\t\tif n != \"\" {\n\t\t\tmatch[n] = m[i]\n\t\t}\n\t}\n\treturn match, nil\n}\n\n// importMeta represents the values in a go-import meta tag.\ntype importMeta struct {\n\tprojectRoot string\n\tvcs         string\n\trepo        string\n}\n\n// sourceMeta represents the values in a go-source meta tag.\ntype sourceMeta struct {\n\tprojectRoot  string\n\tprojectURL   string\n\tdirTemplate  string\n\tfileTemplate string\n}\n\nfunc isHTTPURL(s string) bool {\n\treturn strings.HasPrefix(s, \"https://\") || strings.HasPrefix(s, \"http://\")\n}\n\nfunc replaceDir(s string, dir string) string {\n\tslashDir := \"\"\n\tdir = strings.Trim(dir, \"/\")\n\tif dir != \"\" {\n\t\tslashDir = \"/\" + dir\n\t}\n\ts = strings.Replace(s, \"{dir}\", dir, -1)\n\ts = strings.Replace(s, \"{/dir}\", slashDir, -1)\n\treturn s\n}\n\nfunc attrValue(attrs []xml.Attr, name string) string {\n\tfor _, a := range attrs {\n\t\tif strings.EqualFold(a.Name.Local, name) {\n\t\t\treturn a.Value\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc fetchMeta(ctx context.Context, client *http.Client, importPath string) (scheme string, im *importMeta, sm *sourceMeta, redir bool, err error) {\n\turi := importPath\n\tif !strings.Contains(uri, \"/\") {\n\t\t// Add slash for root of domain.\n\t\turi = uri + \"/\"\n\t}\n\turi = uri + \"?go-get=1\"\n\n\tc := httpClient{client: client}\n\tscheme = \"https\"\n\tresp, err := c.get(ctx, scheme+\"://\"+uri)\n\tif err != nil || resp.StatusCode != 200 {\n\t\tif err == nil {\n\t\t\tresp.Body.Close()\n\t\t}\n\t\tscheme = \"http\"\n\t\tresp, err = c.get(ctx, scheme+\"://\"+uri)\n\t\tif err != nil {\n\t\t\treturn scheme, nil, nil, false, err\n\t\t}\n\t}\n\tdefer resp.Body.Close()\n\tim, sm, redir, err = parseMeta(scheme, importPath, resp.Body)\n\treturn scheme, im, sm, redir, err\n}\n\nvar refreshToGodocPat = regexp.MustCompile(`(?i)^\\d+; url=https?://godoc\\.org/`)\n\nfunc parseMeta(scheme, importPath string, r io.Reader) (im *importMeta, sm *sourceMeta, redir bool, err error) {\n\terrorMessage := \"go-import meta tag not found\"\n\n\td := xml.NewDecoder(r)\n\td.Strict = false\nmetaScan:\n\tfor {\n\t\tt, tokenErr := d.Token()\n\t\tif tokenErr != nil {\n\t\t\tbreak metaScan\n\t\t}\n\t\tswitch t := t.(type) {\n\t\tcase xml.EndElement:\n\t\t\tif strings.EqualFold(t.Name.Local, \"head\") {\n\t\t\t\tbreak metaScan\n\t\t\t}\n\t\tcase xml.StartElement:\n\t\t\tif strings.EqualFold(t.Name.Local, \"body\") {\n\t\t\t\tbreak metaScan\n\t\t\t}\n\t\t\tif !strings.EqualFold(t.Name.Local, \"meta\") {\n\t\t\t\tcontinue metaScan\n\t\t\t}\n\t\t\tif strings.EqualFold(attrValue(t.Attr, \"http-equiv\"), \"refresh\") {\n\t\t\t\t// Check for http-equiv refresh back to godoc.org.\n\t\t\t\tredir = refreshToGodocPat.MatchString(attrValue(t.Attr, \"content\"))\n\t\t\t\tcontinue metaScan\n\t\t\t}\n\t\t\tnameAttr := attrValue(t.Attr, \"name\")\n\t\t\tif nameAttr != \"go-import\" && nameAttr != \"go-source\" {\n\t\t\t\tcontinue metaScan\n\t\t\t}\n\t\t\tfields := strings.Fields(attrValue(t.Attr, \"content\"))\n\t\t\tif len(fields) < 1 {\n\t\t\t\tcontinue metaScan\n\t\t\t}\n\t\t\tprojectRoot := fields[0]\n\t\t\tif !strings.HasPrefix(importPath, projectRoot) ||\n\t\t\t\t!(len(importPath) == len(projectRoot) || importPath[len(projectRoot)] == '/') {\n\t\t\t\t// Ignore if root is not a prefix of the  path. This allows a\n\t\t\t\t// site to use a single error page for multiple repositories.\n\t\t\t\tcontinue metaScan\n\t\t\t}\n\t\t\tswitch nameAttr {\n\t\t\tcase \"go-import\":\n\t\t\t\tif len(fields) != 3 {\n\t\t\t\t\terrorMessage = \"go-import meta tag content attribute does not have three fields\"\n\t\t\t\t\tcontinue metaScan\n\t\t\t\t}\n\t\t\t\tif fields[1] == \"mod\" {\n\t\t\t\t\t// vgo adds a special mod vcs type; we can skip this\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif im != nil {\n\t\t\t\t\tim = nil\n\t\t\t\t\terrorMessage = \"more than one go-import meta tag found\"\n\t\t\t\t\tbreak metaScan\n\t\t\t\t}\n\t\t\t\tim = &importMeta{\n\t\t\t\t\tprojectRoot: projectRoot,\n\t\t\t\t\tvcs:         fields[1],\n\t\t\t\t\trepo:        fields[2],\n\t\t\t\t}\n\t\t\tcase \"go-source\":\n\t\t\t\tif sm != nil {\n\t\t\t\t\t// Ignore extra go-source meta tags.\n\t\t\t\t\tcontinue metaScan\n\t\t\t\t}\n\t\t\t\tif len(fields) != 4 {\n\t\t\t\t\tcontinue metaScan\n\t\t\t\t}\n\t\t\t\tsm = &sourceMeta{\n\t\t\t\t\tprojectRoot:  projectRoot,\n\t\t\t\t\tprojectURL:   fields[1],\n\t\t\t\t\tdirTemplate:  fields[2],\n\t\t\t\t\tfileTemplate: fields[3],\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif im == nil {\n\t\treturn nil, nil, redir, NotFoundError{Message: fmt.Sprintf(\"%s at %s://%s\", errorMessage, scheme, importPath)}\n\t}\n\tif sm != nil && sm.projectRoot != im.projectRoot {\n\t\tsm = nil\n\t}\n\treturn im, sm, redir, nil\n}\n\n// getVCSDirFn is called by getDynamic to fetch source using VCS commands. The\n// default value here does nothing. If the code is not built for App Engine,\n// then getVCSDirFn is set getVCSDir, the function that actually does the work.\nvar getVCSDirFn = func(ctx context.Context, client *http.Client, m map[string]string, etag string) (*Directory, error) {\n\treturn nil, errNoMatch\n}\n\n// getDynamic gets a directory from a service that is not statically known.\nfunc getDynamic(ctx context.Context, client *http.Client, importPath, etag string) (*Directory, error) {\n\tmetaProto, im, sm, redir, err := fetchMeta(ctx, client, importPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif im.projectRoot != importPath {\n\t\tvar imRoot *importMeta\n\t\tmetaProto, imRoot, _, redir, err = fetchMeta(ctx, client, im.projectRoot)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif *imRoot != *im {\n\t\t\treturn nil, NotFoundError{Message: \"project root mismatch.\"}\n\t\t}\n\t}\n\n\t// clonePath is the repo URL from import meta tag, with the \"scheme://\" prefix removed.\n\t// It should be used for cloning repositories.\n\t// repo is the repo URL from import meta tag, with the \"scheme://\" prefix removed, and\n\t// a possible \".vcs\" suffix trimmed.\n\ti := strings.Index(im.repo, \"://\")\n\tif i < 0 {\n\t\treturn nil, NotFoundError{Message: \"bad repo URL: \" + im.repo}\n\t}\n\tproto := im.repo[:i]\n\tclonePath := im.repo[i+len(\"://\"):]\n\trepo := strings.TrimSuffix(clonePath, \".\"+im.vcs)\n\tif !IsValidRemotePath(repo) {\n\t\treturn nil, fmt.Errorf(\"bad path from meta: %s\", repo)\n\t}\n\tdirName := importPath[len(im.projectRoot):]\n\n\tresolvedPath := repo + dirName\n\tdir, err := getStatic(ctx, client, resolvedPath, etag)\n\tif err == errNoMatch {\n\t\tresolvedPath = repo + \".\" + im.vcs + dirName\n\t\tmatch := map[string]string{\n\t\t\t\"dir\":        dirName,\n\t\t\t\"importPath\": importPath,\n\t\t\t\"clonePath\":  clonePath,\n\t\t\t\"repo\":       repo,\n\t\t\t\"scheme\":     proto,\n\t\t\t\"vcs\":        im.vcs,\n\t\t}\n\t\tdir, err = getVCSDirFn(ctx, client, match, etag)\n\t}\n\tif err != nil || dir == nil {\n\t\treturn nil, err\n\t}\n\n\tdir.ImportPath = importPath\n\tdir.ProjectRoot = im.projectRoot\n\tdir.ResolvedPath = resolvedPath\n\tdir.ProjectName = path.Base(im.projectRoot)\n\tif !redir {\n\t\tdir.ProjectURL = metaProto + \"://\" + im.projectRoot\n\t}\n\n\tif sm == nil {\n\t\treturn dir, nil\n\t}\n\n\tif isHTTPURL(sm.projectURL) {\n\t\tdir.ProjectURL = sm.projectURL\n\t}\n\n\tif isHTTPURL(sm.dirTemplate) {\n\t\tdir.BrowseURL = replaceDir(sm.dirTemplate, dirName)\n\t}\n\n\t// TODO: Refactor this to be simpler, implement the go-source meta tag spec fully.\n\tif isHTTPURL(sm.fileTemplate) {\n\t\tfileTemplate := replaceDir(sm.fileTemplate, dirName)\n\t\tif strings.Contains(fileTemplate, \"{file}\") {\n\t\t\tcut := strings.LastIndex(fileTemplate, \"{file}\") + len(\"{file}\") // Cut point is right after last {file} section.\n\t\t\tswitch hash := strings.Index(fileTemplate, \"#\"); {\n\t\t\tcase hash == -1: // If there's no '#', place cut at the end.\n\t\t\t\tcut = len(fileTemplate)\n\t\t\tcase hash > cut: // If a '#' comes after last {file}, use it as cut point.\n\t\t\t\tcut = hash\n\t\t\t}\n\t\t\thead, tail := fileTemplate[:cut], fileTemplate[cut:]\n\t\t\tfor _, f := range dir.Files {\n\t\t\t\tf.BrowseURL = strings.Replace(head, \"{file}\", f.Name, -1)\n\t\t\t}\n\n\t\t\tif strings.Contains(tail, \"{line}\") {\n\t\t\t\ts := strings.Replace(tail, \"%\", \"%%\", -1)\n\t\t\t\ts = strings.Replace(s, \"{line}\", \"%d\", 1)\n\t\t\t\tdir.LineFmt = \"%s\" + s\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dir, nil\n}\n\n// getStatic gets a diretory from a statically known service. getStatic\n// returns errNoMatch if the import path is not recognized.\nfunc getStatic(ctx context.Context, client *http.Client, importPath, etag string) (*Directory, error) {\n\tfor _, s := range services {\n\t\tif s.get == nil {\n\t\t\tcontinue\n\t\t}\n\t\tmatch, err := s.match(importPath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif match != nil {\n\t\t\tdir, err := s.get(ctx, client, match, etag)\n\t\t\tif dir != nil {\n\t\t\t\tdir.ImportPath = importPath\n\t\t\t\tdir.ResolvedPath = importPath\n\t\t\t}\n\t\t\treturn dir, err\n\t\t}\n\t}\n\treturn nil, errNoMatch\n}\n\nfunc Get(ctx context.Context, client *http.Client, importPath string, etag string) (dir *Directory, err error) {\n\tswitch {\n\tcase localPath != \"\":\n\t\tdir, err = getLocal(importPath)\n\tcase IsGoRepoPath(importPath):\n\t\tdir, err = getStandardDir(ctx, client, importPath, etag)\n\tcase IsValidRemotePath(importPath):\n\t\tdir, err = getStatic(ctx, client, importPath, etag)\n\t\tif err == errNoMatch {\n\t\t\tdir, err = getDynamic(ctx, client, importPath, etag)\n\t\t}\n\tdefault:\n\t\terr = errNoMatch\n\t}\n\n\tif err == errNoMatch {\n\t\terr = NotFoundError{Message: \"Import path not valid:\"}\n\t}\n\n\treturn dir, err\n}\n\n// GetPresentation gets a presentation from the the given path.\nfunc GetPresentation(ctx context.Context, client *http.Client, importPath string) (*Presentation, error) {\n\text := path.Ext(importPath)\n\tif ext != \".slide\" && ext != \".article\" {\n\t\treturn nil, NotFoundError{Message: \"unknown file extension.\"}\n\t}\n\n\timportPath, file := path.Split(importPath)\n\timportPath = strings.TrimSuffix(importPath, \"/\")\n\tfor _, s := range services {\n\t\tif s.getPresentation == nil {\n\t\t\tcontinue\n\t\t}\n\t\tmatch, err := s.match(importPath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif match != nil {\n\t\t\tmatch[\"file\"] = file\n\t\t\treturn s.getPresentation(ctx, client, match)\n\t\t}\n\t}\n\treturn nil, NotFoundError{Message: \"path does not match registered service\"}\n}\n\n// GetProject gets information about a repository.\nfunc GetProject(ctx context.Context, client *http.Client, importPath string) (*Project, error) {\n\tfor _, s := range services {\n\t\tif s.getProject == nil {\n\t\t\tcontinue\n\t\t}\n\t\tmatch, err := s.match(importPath)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif match != nil {\n\t\t\treturn s.getProject(ctx, client, match)\n\t\t}\n\t}\n\treturn nil, NotFoundError{Message: \"path does not match registered service\"}\n}\n", "// Copyright 2014 The Go Authors. All rights reserved.\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd.\n\npackage gosrc\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nvar testWeb = map[string]string{\n\t// Package at root of a GitHub repo.\n\t\"https://alice.org/pkg\": `<head> <meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\"></head>`,\n\t// Package in sub-diretory.\n\t\"https://alice.org/pkg/sub\": `<head> <meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\"><body>`,\n\t// Fallback to http.\n\t\"http://alice.org/pkg/http\": `<head> <meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\">`,\n\t// Meta tag in sub-directory does not match meta tag at root.\n\t\"https://alice.org/pkg/mismatch\": `<head> <meta name=\"go-import\" content=\"alice.org/pkg hg https://github.com/alice/pkg\">`,\n\t// More than one matching meta tag.\n\t\"http://alice.org/pkg/multiple\": `<head> ` +\n\t\t`<meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\">` +\n\t\t`<meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\">`,\n\t// Package with go-source meta tag.\n\t\"https://alice.org/pkg/source\": `<head>` +\n\t\t`<meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\">` +\n\t\t`<meta name=\"go-source\" content=\"alice.org/pkg http://alice.org/pkg http://alice.org/pkg{/dir} http://alice.org/pkg{/dir}?f={file}#Line{line}\">`,\n\t\"https://alice.org/pkg/ignore\": `<head>` +\n\t\t`<title>Hello</title>` +\n\t\t// Unknown meta name\n\t\t`<meta name=\"go-junk\" content=\"alice.org/pkg http://alice.org/pkg http://alice.org/pkg{/dir} http://alice.org/pkg{/dir}?f={file}#Line{line}\">` +\n\t\t// go-source before go-meta\n\t\t`<meta name=\"go-source\" content=\"alice.org/pkg http://alice.org/pkg http://alice.org/pkg{/dir} http://alice.org/pkg{/dir}?f={file}#Line{line}\">` +\n\t\t// go-import tag for the package\n\t\t`<meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\">` +\n\t\t// go-import with wrong number of fields\n\t\t`<meta name=\"go-import\" content=\"alice.org/pkg https://github.com/alice/pkg\">` +\n\t\t// go-import with no fields\n\t\t`<meta name=\"go-import\" content=\"\">` +\n\t\t// go-source with wrong number of fields\n\t\t`<meta name=\"go-source\" content=\"alice.org/pkg blah\">` +\n\t\t// meta tag for a different package\n\t\t`<meta name=\"go-import\" content=\"alice.org/other git https://github.com/alice/other\">` +\n\t\t// meta tag for a different package\n\t\t`<meta name=\"go-import\" content=\"alice.org/other git https://github.com/alice/other\">` +\n\t\t`</head>` +\n\t\t// go-import outside of head\n\t\t`<meta name=\"go-import\" content=\"alice.org/pkg git https://github.com/alice/pkg\">`,\n\n\t// Package at root of a Git repo.\n\t\"https://bob.com/pkg\": `<head> <meta name=\"go-import\" content=\"bob.com/pkg git https://vcs.net/bob/pkg.git\">`,\n\t// Package at in sub-directory of a Git repo.\n\t\"https://bob.com/pkg/sub\": `<head> <meta name=\"go-import\" content=\"bob.com/pkg git https://vcs.net/bob/pkg.git\">`,\n\t// Package with go-source meta tag.\n\t\"https://bob.com/pkg/source\": `<head>` +\n\t\t`<meta name=\"go-import\" content=\"bob.com/pkg git https://vcs.net/bob/pkg.git\">` +\n\t\t`<meta name=\"go-source\" content=\"bob.com/pkg http://bob.com/pkg http://bob.com/pkg{/dir}/ http://bob.com/pkg{/dir}/?f={file}#Line{line}\">`,\n\t// Meta refresh to godoc.org\n\t\"http://rsc.io/benchstat\": `<!DOCTYPE html><html><head>` +\n\t\t`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>` +\n\t\t`<meta name=\"go-import\" content=\"rsc.io/benchstat git https://github.com/rsc/benchstat\">` +\n\t\t`<meta http-equiv=\"refresh\" content=\"0; url=https://godoc.org/rsc.io/benchstat\">` +\n\t\t`</head>`,\n\n\t// Package with go-source meta tag, where {file} appears on the right of '#' in the file field URL template.\n\t\"https://azul3d.org/examples\": `<!DOCTYPE html><html><head>` +\n\t\t`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>` +\n\t\t`<meta name=\"go-import\" content=\"azul3d.org/examples git https://github.com/azul3d/examples\">` +\n\t\t`<meta name=\"go-source\" content=\"azul3d.org/examples https://github.com/azul3d/examples https://gotools.org/azul3d.org/examples{/dir} https://gotools.org/azul3d.org/examples{/dir}#{file}-L{line}\">` +\n\t\t`<meta http-equiv=\"refresh\" content=\"0; url=https://godoc.org/azul3d.org/examples\">` +\n\t\t`</head>`,\n\t\"https://azul3d.org/examples/abs\": `<!DOCTYPE html><html><head>` +\n\t\t`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>` +\n\t\t`<meta name=\"go-import\" content=\"azul3d.org/examples git https://github.com/azul3d/examples\">` +\n\t\t`<meta name=\"go-source\" content=\"azul3d.org/examples https://github.com/azul3d/examples https://gotools.org/azul3d.org/examples{/dir} https://gotools.org/azul3d.org/examples{/dir}#{file}-L{line}\">` +\n\t\t`<meta http-equiv=\"refresh\" content=\"0; url=https://godoc.org/azul3d.org/examples/abs\">` +\n\t\t`</head>`,\n\n\t// Multiple go-import meta tags; one of which is a vgo-special mod vcs type\n\t\"http://myitcv.io/blah2\": `<!DOCTYPE html><html><head>` +\n\t\t`<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/>` +\n\t\t`<meta name=\"go-import\" content=\"myitcv.io/blah2 git https://github.com/myitcv/x\">` +\n\t\t`<meta name=\"go-import\" content=\"myitcv.io/blah2 mod https://raw.githubusercontent.com/myitcv/pubx/master\">` +\n\t\t`<meta name=\"go-source\" content=\"myitcv.io https://github.com/myitcv/x/wiki https://github.com/myitcv/x/tree/master{/dir} https://github.com/myitcv/x/blob/master{/dir}/{file}#L{line}\">` +\n\t\t`</head>`,\n\n\t// The repo element of go-import includes \"../\"\n\t\"http://my.host/pkg\": `<head> <meta name=\"go-import\" content=\"my.host/pkg git http://vcs.net/myhost/../../tmp/pkg.git\"></head>`,\n}\n\nvar getDynamicTests = []struct {\n\timportPath string\n\tdir        *Directory\n}{\n\t{\"alice.org/pkg\", &Directory{\n\t\tBrowseURL:    \"https://github.com/alice/pkg\",\n\t\tImportPath:   \"alice.org/pkg\",\n\t\tLineFmt:      \"%s#L%d\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"alice.org/pkg\",\n\t\tProjectURL:   \"https://alice.org/pkg\",\n\t\tResolvedPath: \"github.com/alice/pkg\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"https://github.com/alice/pkg/blob/master/main.go\"}},\n\t}},\n\t{\"alice.org/pkg/sub\", &Directory{\n\t\tBrowseURL:    \"https://github.com/alice/pkg/tree/master/sub\",\n\t\tImportPath:   \"alice.org/pkg/sub\",\n\t\tLineFmt:      \"%s#L%d\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"alice.org/pkg\",\n\t\tProjectURL:   \"https://alice.org/pkg\",\n\t\tResolvedPath: \"github.com/alice/pkg/sub\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"https://github.com/alice/pkg/blob/master/sub/main.go\"}},\n\t}},\n\t{\"alice.org/pkg/http\", &Directory{\n\t\tBrowseURL:    \"https://github.com/alice/pkg/tree/master/http\",\n\t\tImportPath:   \"alice.org/pkg/http\",\n\t\tLineFmt:      \"%s#L%d\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"alice.org/pkg\",\n\t\tProjectURL:   \"https://alice.org/pkg\",\n\t\tResolvedPath: \"github.com/alice/pkg/http\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"https://github.com/alice/pkg/blob/master/http/main.go\"}},\n\t}},\n\t{\"alice.org/pkg/source\", &Directory{\n\t\tBrowseURL:    \"http://alice.org/pkg/source\",\n\t\tImportPath:   \"alice.org/pkg/source\",\n\t\tLineFmt:      \"%s#Line%d\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"alice.org/pkg\",\n\t\tProjectURL:   \"http://alice.org/pkg\",\n\t\tResolvedPath: \"github.com/alice/pkg/source\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"http://alice.org/pkg/source?f=main.go\"}},\n\t}},\n\t{\"alice.org/pkg/ignore\", &Directory{\n\t\tBrowseURL:    \"http://alice.org/pkg/ignore\",\n\t\tImportPath:   \"alice.org/pkg/ignore\",\n\t\tLineFmt:      \"%s#Line%d\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"alice.org/pkg\",\n\t\tProjectURL:   \"http://alice.org/pkg\",\n\t\tResolvedPath: \"github.com/alice/pkg/ignore\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"http://alice.org/pkg/ignore?f=main.go\"}},\n\t}},\n\t{\"alice.org/pkg/mismatch\", nil},\n\t{\"alice.org/pkg/multiple\", nil},\n\t{\"alice.org/pkg/notfound\", nil},\n\n\t{\"bob.com/pkg\", &Directory{\n\t\tImportPath:   \"bob.com/pkg\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"bob.com/pkg\",\n\t\tProjectURL:   \"https://bob.com/pkg\",\n\t\tResolvedPath: \"vcs.net/bob/pkg.git\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\"}},\n\t}},\n\t{\"bob.com/pkg/sub\", &Directory{\n\t\tImportPath:   \"bob.com/pkg/sub\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"bob.com/pkg\",\n\t\tProjectURL:   \"https://bob.com/pkg\",\n\t\tResolvedPath: \"vcs.net/bob/pkg.git/sub\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\"}},\n\t}},\n\t{\"bob.com/pkg/source\", &Directory{\n\t\tBrowseURL:    \"http://bob.com/pkg/source/\",\n\t\tImportPath:   \"bob.com/pkg/source\",\n\t\tLineFmt:      \"%s#Line%d\",\n\t\tProjectName:  \"pkg\",\n\t\tProjectRoot:  \"bob.com/pkg\",\n\t\tProjectURL:   \"http://bob.com/pkg\",\n\t\tResolvedPath: \"vcs.net/bob/pkg.git/source\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"http://bob.com/pkg/source/?f=main.go\"}},\n\t}},\n\t{\"rsc.io/benchstat\", &Directory{\n\t\tBrowseURL:    \"https://github.com/rsc/benchstat\",\n\t\tImportPath:   \"rsc.io/benchstat\",\n\t\tLineFmt:      \"%s#L%d\",\n\t\tProjectName:  \"benchstat\",\n\t\tProjectRoot:  \"rsc.io/benchstat\",\n\t\tProjectURL:   \"https://github.com/rsc/benchstat\",\n\t\tResolvedPath: \"github.com/rsc/benchstat\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"https://github.com/rsc/benchstat/blob/master/main.go\"}},\n\t}},\n\t{\"azul3d.org/examples/abs\", &Directory{\n\t\tBrowseURL:    \"https://gotools.org/azul3d.org/examples/abs\",\n\t\tImportPath:   \"azul3d.org/examples/abs\",\n\t\tLineFmt:      \"%s-L%d\",\n\t\tProjectName:  \"examples\",\n\t\tProjectRoot:  \"azul3d.org/examples\",\n\t\tProjectURL:   \"https://github.com/azul3d/examples\",\n\t\tResolvedPath: \"github.com/azul3d/examples/abs\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"https://gotools.org/azul3d.org/examples/abs#main.go\"}},\n\t}},\n\t{\"myitcv.io/blah2\", &Directory{\n\t\tBrowseURL:    \"https://github.com/myitcv/x\",\n\t\tImportPath:   \"myitcv.io/blah2\",\n\t\tLineFmt:      \"%s#L%d\",\n\t\tProjectName:  \"blah2\",\n\t\tProjectRoot:  \"myitcv.io/blah2\",\n\t\tProjectURL:   \"http://myitcv.io/blah2\",\n\t\tResolvedPath: \"github.com/myitcv/x\",\n\t\tVCS:          \"git\",\n\t\tFiles:        []*File{{Name: \"main.go\", BrowseURL: \"https://github.com/myitcv/x/blob/master/main.go\"}},\n\t}},\n\t{\"my.host/pkg\", nil},\n}\n\ntype testTransport map[string]string\n\nfunc (t testTransport) RoundTrip(req *http.Request) (*http.Response, error) {\n\tstatusCode := http.StatusOK\n\treq.URL.RawQuery = \"\"\n\tbody, ok := t[req.URL.String()]\n\tif !ok {\n\t\tstatusCode = http.StatusNotFound\n\t}\n\tresp := &http.Response{\n\t\tStatusCode: statusCode,\n\t\tBody:       ioutil.NopCloser(strings.NewReader(body)),\n\t}\n\treturn resp, nil\n}\n\nvar githubPattern = regexp.MustCompile(`^github\\.com/(?P<owner>[a-z0-9A-Z_.\\-]+)/(?P<repo>[a-z0-9A-Z_.\\-]+)(?P<dir>/[a-z0-9A-Z_.\\-/]*)?$`)\n\nfunc testGet(ctx context.Context, client *http.Client, match map[string]string, etag string) (*Directory, error) {\n\timportPath := match[\"importPath\"]\n\n\tif m := githubPattern.FindStringSubmatch(importPath); m != nil {\n\t\tbrowseURL := fmt.Sprintf(\"https://github.com/%s/%s\", m[1], m[2])\n\t\tif m[3] != \"\" {\n\t\t\tbrowseURL = fmt.Sprintf(\"%s/tree/master%s\", browseURL, m[3])\n\t\t}\n\t\treturn &Directory{\n\t\t\tBrowseURL:   browseURL,\n\t\t\tImportPath:  importPath,\n\t\t\tLineFmt:     \"%s#L%d\",\n\t\t\tProjectName: m[2],\n\t\t\tProjectRoot: fmt.Sprintf(\"github.com/%s/%s\", m[1], m[2]),\n\t\t\tProjectURL:  fmt.Sprintf(\"https://github.com/%s/%s\", m[1], m[2]),\n\t\t\tVCS:         \"git\",\n\t\t\tFiles: []*File{{\n\t\t\t\tName:      \"main.go\",\n\t\t\t\tBrowseURL: fmt.Sprintf(\"https://github.com/%s/%s/blob/master%s/main.go\", m[1], m[2], m[3]),\n\t\t\t}},\n\t\t}, nil\n\t}\n\n\tif strings.HasPrefix(match[\"repo\"], \"vcs.net\") {\n\t\treturn &Directory{\n\t\t\tImportPath:  importPath,\n\t\t\tProjectName: path.Base(match[\"repo\"]),\n\t\t\tProjectRoot: fmt.Sprintf(\"%s.%s\", match[\"repo\"], match[\"vcs\"]),\n\t\t\tVCS:         match[\"vcs\"],\n\t\t\tFiles:       []*File{{Name: \"main.go\"}},\n\t\t}, nil\n\t}\n\n\treturn nil, errNoMatch\n}\n\nfunc TestGetDynamic(t *testing.T) {\n\tsavedServices := services\n\tsavedGetVCSDirFn := getVCSDirFn\n\tdefer func() {\n\t\tservices = savedServices\n\t\tgetVCSDirFn = savedGetVCSDirFn\n\t}()\n\tservices = []*service{{pattern: regexp.MustCompile(\".*\"), get: testGet}}\n\tgetVCSDirFn = testGet\n\tclient := &http.Client{Transport: testTransport(testWeb)}\n\n\tfor _, tt := range getDynamicTests {\n\t\tdir, err := getDynamic(context.Background(), client, tt.importPath, \"\")\n\n\t\tif tt.dir == nil {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"getDynamic(ctx, client, %q, etag) did not return expected error\", tt.importPath)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"getDynamic(ctx, client, %q, etag) return unexpected error: %v\", tt.importPath, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif !cmp.Equal(dir, tt.dir) {\n\t\t\tt.Errorf(\"getDynamic(client, %q, etag) =\\n     %+v,\\nwant %+v\", tt.importPath, dir, tt.dir)\n\t\t\tfor i, f := range dir.Files {\n\t\t\t\tvar want *File\n\t\t\t\tif i < len(tt.dir.Files) {\n\t\t\t\t\twant = tt.dir.Files[i]\n\t\t\t\t}\n\t\t\t\tt.Errorf(\"file %d = %+v, want %+v\", i, f, want)\n\t\t\t}\n\t\t}\n\t}\n}\n"], "buggy_code_start_loc": [380, 96], "buggy_code_end_loc": [380, 303], "fixing_code_start_loc": [381, 97], "fixing_code_end_loc": [384, 307], "type": "CWE-22", "message": "In Go Doc Dot Org (gddo) through 2018-06-27, an attacker could use specially crafted <go-import> tags in packages being fetched by gddo to cause a directory traversal and remote code execution.", "other": {"cve": {"id": "CVE-2018-12976", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-05T18:29:00.487", "lastModified": "2018-09-05T17:48:21.357", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Go Doc Dot Org (gddo) through 2018-06-27, an attacker could use specially crafted <go-import> tags in packages being fetched by gddo to cause a directory traversal and remote code execution."}, {"lang": "es", "value": "En Go Doc Dot Org (gddo) hasta el 2018-06-27, un atacante podr\u00eda emplear etiquetas  especialmente manipuladas en los paquetes que son recuperados por gddo para provocar un salto de directorio y la ejecuci\u00f3n remota de c\u00f3digo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:godoc:go_doc_dot_org:*:*:*:*:*:*:*:*", "versionEndIncluding": "2018-06-27", "matchCriteriaId": "F57CE873-57B6-4EA5-ABC3-224253E0E72F"}]}]}], "references": [{"url": "https://github.com/golang/gddo/commit/daffe1f90ec57f8ed69464f9094753fc6452e983", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/forum/#!msg/golang-announce/4rpTbfzYB1k/no6MEwlQAwAJ", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/golang/gddo/commit/daffe1f90ec57f8ed69464f9094753fc6452e983"}}