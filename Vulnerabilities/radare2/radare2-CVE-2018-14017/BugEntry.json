{"buggy_code": ["/* Apache 2.0 - Copyright 2007-2018 - pancake and dso\n   class.c rewrite: Adam Pridgen <dso@rice.edu || adam.pridgen@thecoverofnight.com>\n */\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_bin.h>\n#include <math.h>\n#include <sdb.h>\n#include \"class.h\"\n#include \"dsojson.h\"\n\nstatic PrintfCallback Eprintf =(PrintfCallback) printf;\n#ifdef IFDBG\n#undef IFDBG\n#endif\n#define DO_THE_DBG 0\n#define IFDBG  if (DO_THE_DBG)\n#define IFINT  if (0)\n\n#define MAX_CPITEMS 8192\n\nR_API char *U(r_bin_java_unmangle_method)(const char *flags, const char *name, const char *params, const char *r_value);\nR_API int r_bin_java_is_fm_type_private(RBinJavaField *fm_type);\nR_API int r_bin_java_is_fm_type_protected(RBinJavaField *fm_type);\nR_API ut32 U(r_bin_java_swap_uint)(ut32 x);\n\n// R_API const char * r_bin_java_get_this_class_name(RBinJavaObj *bin);\nR_API void U(add_cp_objs_to_sdb)(RBinJavaObj * bin);\nR_API void U(add_field_infos_to_sdb)(RBinJavaObj * bin);\nR_API void U(add_method_infos_to_sdb)(RBinJavaObj * bin);\nR_API RList *retrieve_all_access_string_and_value(RBinJavaAccessFlags *access_flags);\nR_API char *retrieve_access_string(ut16 flags, RBinJavaAccessFlags *access_flags);\nR_API ut16 calculate_access_value(const char *access_flags_str, RBinJavaAccessFlags *access_flags);\nR_API int r_bin_java_new_bin(RBinJavaObj *bin, ut64 loadaddr, Sdb *kv, const ut8 *buf, ut64 len);\nR_API int extract_type_value(const char *arg_str, char **output);\nR_API int r_bin_java_check_reset_cp_obj(RBinJavaCPTypeObj *cp_obj, ut8 tag);\nR_API ut8 *r_bin_java_cp_get_4bytes(ut8 tag, ut32 *out_sz, const ut8 *buf, const ut64 len);\nR_API ut8 *r_bin_java_cp_get_8bytes(ut8 tag, ut32 *out_sz, const ut8 *buf, const ut64 len);\nR_API ut8 *r_bin_java_cp_get_utf8(ut8 tag, ut32 *out_sz, const ut8 *buf, const ut64 len);\n\nR_API RBinJavaCPTypeObj *r_bin_java_get_item_from_bin_cp_list(RBinJavaObj *bin, ut64 idx);\nR_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp_item_list(RList *cp_list, ut64 idx);\n// Allocs for objects\nR_API RBinJavaCPTypeObj *r_bin_java_class_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_fieldref_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_methodref_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_interfacemethodref_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_name_and_type_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_string_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_integer_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_float_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_long_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_double_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_utf8_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_do_nothing_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz);\nR_API RBinJavaCPTypeObj *r_bin_java_clone_cp_item(RBinJavaCPTypeObj *obj);\nR_API RBinJavaCPTypeObj *r_bin_java_clone_cp_idx(RBinJavaObj *bin, ut32 idx);\nR_API RBinJavaCPTypeObj *r_bin_java_methodhandle_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz);\nR_API RBinJavaCPTypeObj *r_bin_java_methodtype_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz);\nR_API RBinJavaCPTypeObj *r_bin_java_invokedynamic_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz);\n// Deallocs for type objects\nR_API void r_bin_java_default_free(void /*RBinJavaCPTypeObj*/ *obj);\nR_API void r_bin_java_obj_free(void /*RBinJavaCPTypeObj*/ *obj);\nR_API void r_bin_java_utf8_info_free(void /*RBinJavaCPTypeObj*/ *obj);\nR_API void r_bin_java_do_nothing_free(void /*RBinJavaCPTypeObj*/ *obj);\nR_API void r_bin_java_fmtype_free(void /*RBinJavaField*/ *fm_type);\n// handle freeing the lists\n// handle the reading of the various field\nR_API RBinJavaAttrInfo *r_bin_java_read_next_attr(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len);\nR_API RBinJavaCPTypeObj *r_bin_java_read_next_constant_pool_item(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, ut64 len);\nR_API RBinJavaAttrMetas *r_bin_java_get_attr_type_by_name(const char *name);\nR_API RBinJavaCPTypeObj *r_bin_java_get_java_null_cp();\nR_API ut64 r_bin_java_read_class_file2(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, ut64 len);\nR_API RBinJavaAttrInfo *r_bin_java_get_attr_from_field(RBinJavaField *field, R_BIN_JAVA_ATTR_TYPE attr_type, ut32 pos);\nR_API RBinJavaField *r_bin_java_read_next_field(RBinJavaObj *bin, const ut64 offset, const ut8 *buffer, const ut64 len);\nR_API RBinJavaField *r_bin_java_read_next_method(RBinJavaObj *bin, const ut64 offset, const ut8 *buffer, const ut64 len);\nR_API void r_bin_java_print_utf8_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_name_and_type_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_double_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_long_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_float_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_integer_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_string_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_classref_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_fieldref_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_methodref_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_interfacemethodref_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_unknown_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_null_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_unknown_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_methodhandle_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_methodtype_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_invokedynamic_cp_summary(RBinJavaCPTypeObj *obj);\nR_API RBinJavaCPTypeObj *r_bin_java_unknown_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz);\nR_API RBinJavaInterfaceInfo *r_bin_java_interface_new(RBinJavaObj *bin, const ut8 *buf, ut64 sz);\nR_API RBinJavaInterfaceInfo *r_bin_java_read_next_interface_item(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, ut64 len);\nR_API void r_bin_java_interface_free(void /*RBinJavaInterfaceInfo*/ *obj);\nR_API void r_bin_java_stack_frame_free(void /*RBinJavaStackMapFrame*/ *obj);\nR_API void r_bin_java_stack_map_table_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_verification_info_free(void /*RBinJavaVerificationObj*/ *obj);\nR_API void r_bin_java_print_stack_map_table_attr_summary(RBinJavaAttrInfo *obj);\nR_API void r_bin_java_print_stack_map_frame_summary(RBinJavaStackMapFrame *obj);\nR_API void r_bin_java_print_verification_info_summary(RBinJavaVerificationObj *obj);\nR_API RBinJavaStackMapFrame *r_bin_java_build_stack_frame_from_local_variable_table(RBinJavaObj *bin, RBinJavaAttrInfo *attr);\nR_API void U(r_bin_java_print_stack_map_append_frame_summary)(RBinJavaStackMapFrame * obj);\nR_API void U(r_bin_java_stack_frame_default_free)(void /*RBinJavaStackMapFrame*/ *stack_frame);\nR_API void U(r_bin_java_stack_frame_do_nothing_free)(void /*RBinJavaStackMapFrame*/ *stack_frame);\nR_API void U(r_bin_java_stack_frame_do_nothing_new)(RBinJavaObj * bin, RBinJavaStackMapFrame * stack_frame, ut64 offset);\nR_API RBinJavaStackMapFrame *r_bin_java_stack_map_frame_new(ut8 *buffer, ut64 sz, RBinJavaStackMapFrame *p_frame, ut64 buf_offset);\n// R_API RBinJavaStackMapFrame* r_bin_java_stack_map_frame_new (ut8* buffer, ut64 sz, ut64 buf_offset);\nR_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset);\n// R_API RBinJavaVerificationObj* r_bin_java_read_next_verification_info_new(ut8* buffer, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset);\nR_API RBinJavaElementValuePair *r_bin_java_element_pair_new(ut8 *buffer, ut64 sz, ut64 buf_offset);\nR_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset);\n// R_API RBinJavaBootStrapArgument* r_bin_java_bootstrap_method_argument_new(ut8* buffer, ut64 sz, ut64 buf_offset);\nR_API RBinJavaBootStrapMethod *r_bin_java_bootstrap_method_new(ut8 *buffer, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAnnotationsArray *r_bin_java_annotation_array_new(ut8 *buffer, ut64 sz, ut64 buf_offset);\nR_API RBinJavaElementValueMetas *r_bin_java_get_ev_meta_from_tag(ut8 tag);\nR_API RBinJavaCPTypeMetas *U(r_bin_java_get_cp_meta_from_tag)(ut8 tag);\nR_API void r_bin_java_inner_classes_attr_entry_free(void /*RBinJavaClassesAttribute*/ *attr);\nR_API void r_bin_java_annotation_default_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_enclosing_methods_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_local_variable_type_table_attr_entry_free(void /*RBinJavaLocalVariableTypeAttribute*/ *lvattr);\nR_API void r_bin_java_local_variable_type_table_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_signature_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_source_debug_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_element_value_free(void /*RBinJavaElementValue*/ *element_value);\nR_API void r_bin_java_element_pair_free(void /*RBinJavaElementValuePair*/ *ev_pair);\nR_API void r_bin_java_annotation_free(void /*RBinJavaAnnotation*/ *annotation);\nR_API void r_bin_java_rtv_annotations_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_rti_annotations_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_annotation_array_free(void /*RBinJavaAnnotationsArray*/ *annotation_array);\nR_API void r_bin_java_bootstrap_methods_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_bootstrap_method_free(void /*RBinJavaBootStrapMethod*/ *bsm);\nR_API void r_bin_java_bootstrap_method_argument_free(void /*RBinJavaBootStrapArgument*/ *bsm_arg);\nR_API void r_bin_java_rtvp_annotations_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_rtip_annotations_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_unknown_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_code_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_constant_value_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_deprecated_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_exceptions_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_inner_classes_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_line_number_table_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_local_variable_table_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_source_code_file_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_synthetic_attr_free(void /*RBinJavaAttrInfo*/ *attr);\n\nR_API void r_bin_java_print_annotation_default_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_enclosing_methods_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_local_variable_type_attr_summary(RBinJavaLocalVariableTypeAttribute *lvattr);\nR_API void r_bin_java_print_local_variable_type_table_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_signature_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_source_debug_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_element_value_summary(RBinJavaElementValue *element_value);\nR_API void r_bin_java_print_annotation_summary(RBinJavaAnnotation *annotation);\nR_API void r_bin_java_print_element_pair_summary(RBinJavaElementValuePair *ev_pair);\nR_API void r_bin_java_print_bootstrap_methods_attr_summary(RBinJavaAttrInfo *attr);\n// R_API void r_bin_java_bootstrap_method_summary(RBinJavaBootStrapMethod *bsm);\n// R_API void r_bin_java_bootstrap_method_argument_summary(RBinJavaBootStrapArgument *bsm_arg);\nR_API void r_bin_java_print_rtv_annotations_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_rti_annotations_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_annotation_array_summary(RBinJavaAnnotationsArray *annotation_array);\nR_API void r_bin_java_print_rtvp_annotations_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_rtip_annotations_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_attribute_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_constant_pool(void /*RBinJavaCPTypeObj*/ *obj);\nR_API void r_bin_java_print_field_summary(RBinJavaField *field);\n// R_API void r_bin_java_print_interface_summary(RBinJavaField *field);\nR_API void r_bin_java_print_method_summary(RBinJavaField *field);\nR_API void r_bin_java_print_code_exceptions_attr_summary(RBinJavaExceptionEntry *exc_entry);\nR_API void r_bin_java_print_code_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_constant_value_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_deprecated_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_exceptions_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_classes_attr_summary(RBinJavaClassesAttribute *icattr);\nR_API void r_bin_java_print_inner_classes_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_line_number_table_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_local_variable_attr_summary(RBinJavaLocalVariableAttribute *lvattr);\nR_API void r_bin_java_print_local_variable_table_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_source_code_file_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_synthetic_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_attr_summary(RBinJavaAttrInfo *attr);\nR_API RBinJavaAttrInfo *r_bin_java_read_next_attr_from_buffer(ut8 *buffer, st64 sz, st64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_unknown_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_signature_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_rtvp_annotations_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_rtip_annotations_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_code_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_deprecated_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_exceptions_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_local_variable_table_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API ut64 r_bin_java_unknown_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_annotation_default_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_enclosing_methods_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_local_variable_type_table_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_signature_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_source_debug_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_bootstrap_methods_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_rtv_annotations_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_rti_annotations_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_rtvp_annotations_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_rtip_annotations_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_code_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_constant_value_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_deprecated_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_exceptions_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_inner_classes_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_line_number_table_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_local_variable_table_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_source_code_file_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_stack_map_table_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_synthetic_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_bootstrap_method_calc_size(RBinJavaBootStrapMethod *bsm);\nR_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *ev_pair);\nR_API ut64 r_bin_java_element_value_calc_size(RBinJavaElementValue *element_value);\n\nR_API ut64 r_bin_java_unknown_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_class_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_fieldref_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_methodref_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_interfacemethodref_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_name_and_type_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_string_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_integer_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_float_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_long_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_double_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_utf8_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_do_nothing_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_methodhandle_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_methodtype_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_invokedynamic_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API RBinJavaStackMapFrame *r_bin_java_default_stack_frame();\n\nR_API RList *r_bin_java_find_cp_const_by_val_float(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len);\nR_API RList *r_bin_java_find_cp_const_by_val_double(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len);\nR_API RList *r_bin_java_find_cp_const_by_val_int(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len);\nR_API RList *r_bin_java_find_cp_const_by_val_long(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len);\nR_API RList *r_bin_java_find_cp_const_by_val_utf8(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len);\nR_API ut8 *r_bin_java_cp_append_classref_and_name(RBinJavaObj *bin, ut32 *out_sz, const char *classname, const ut32 classname_len);\nR_API ut8 *U(r_bin_java_cp_append_ref_cname_fname_ftype)(RBinJavaObj * bin, ut32 * out_sz, ut8 tag, const char *cname, const ut32 c_len, const char *fname, const ut32 f_len, const char *tname, const ut32 t_len);\nR_API ut8 *r_bin_java_cp_get_classref(RBinJavaObj *bin, ut32 *out_sz, const char *classname, const ut32 classname_len, const ut16 name_idx);\nR_API ut8 *U(r_bin_java_cp_get_method_ref)(RBinJavaObj * bin, ut32 * out_sz, ut16 class_idx, ut16 name_and_type_idx);\nR_API ut8 *U(r_bin_java_cp_get_field_ref)(RBinJavaObj * bin, ut32 * out_sz, ut16 class_idx, ut16 name_and_type_idx);\nR_API ut8 *r_bin_java_cp_get_fm_ref(RBinJavaObj *bin, ut32 *out_sz, ut8 tag, ut16 class_idx, ut16 name_and_type_idx);\nR_API ut8 *r_bin_java_cp_get_2_ut16(RBinJavaObj *bin, ut32 *out_sz, ut8 tag, ut16 ut16_one, ut16 ut16_two);\nR_API ut8 *r_bin_java_cp_get_name_type(RBinJavaObj *bin, ut32 *out_sz, ut16 name_idx, ut16 type_idx);\n\nstatic char *convert_string(const char *bytes, ut32 len) {\n\tut32 idx = 0, pos = 0;\n\tut32 str_sz = 32 * len + 1;\n\tchar *cpy_buffer = len > 0 ? malloc (str_sz) : NULL;\n\tif (!cpy_buffer) {\n\t\treturn cpy_buffer;\n\t}\n\t// 4x is the increase from byte to \\xHH where HH represents hexed byte\n\tmemset (cpy_buffer, 0, str_sz);\n\twhile (idx < len && pos < len) {\n\t\tif (dso_json_char_needs_hexing (bytes[idx])) {\n\t\t\tif (pos + 2 < len) {\n\t\t\t\tfree (cpy_buffer);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tsprintf (cpy_buffer + pos, \"\\\\x%02x\", bytes[idx]);\n\t\t\tpos += 4;\n\t\t} else {\n\t\t\tcpy_buffer[pos] = bytes[idx];\n\t\t\tpos++;\n\t\t}\n\t\tidx++;\n\t}\n\treturn cpy_buffer;\n}\n\n// taken from LLVM Code Byte Swap\n// TODO: move into r_util\nR_API ut32 U(r_bin_java_swap_uint)(ut32 x) {\n\tconst ut32 Byte0 = x & 0x000000FF;\n\tconst ut32 Byte1 = x & 0x0000FF00;\n\tconst ut32 Byte2 = x & 0x00FF0000;\n\tconst ut32 Byte3 = x & 0xFF000000;\n\treturn (Byte0 << 24) | (Byte1 << 8) | (Byte2 >> 8) | (Byte3 >> 24);\n}\n\nstatic bool R_BIN_JAVA_NULL_TYPE_INITTED = false;\n// XXX - this is a global variable used while parsing the class file\n// if multi-threaded class parsing is enabled, this variable needs to\n// be guarded with a lock.\nstatic RBinJavaObj *R_BIN_JAVA_GLOBAL_BIN = NULL;\nstatic RBinJavaAccessFlags FIELD_ACCESS_FLAGS[] = {\n\t{ \"public\", R_BIN_JAVA_FIELD_ACC_PUBLIC, 6 },\n\t{ \"private\", R_BIN_JAVA_FIELD_ACC_PRIVATE, 7 },\n\t{ \"protected\", R_BIN_JAVA_FIELD_ACC_PROTECTED, 9 },\n\t{ \"static\", R_BIN_JAVA_FIELD_ACC_STATIC, 6 },\n\t{ \"final\", R_BIN_JAVA_FIELD_ACC_FINAL, 5 },\n\t{ \"undefined.0x0020\", 0x0020, 16 },\n\t{ \"volatile\", R_BIN_JAVA_FIELD_ACC_VOLATILE, 8 },\n\t{ \"transient\", R_BIN_JAVA_FIELD_ACC_TRANSIENT, 9 },\n\t{ \"undefined.0x0100\", 0x0100, 16 },\n\t{ \"undefined.0x0200\", 0x0200, 16 },\n\t{ \"undefined.0x0400\", 0x0400, 16 },\n\t{ \"undefined.0x0800\", 0x0800, 16 },\n\t{ \"synthetic\", R_BIN_JAVA_FIELD_ACC_SYNTHETIC, 9 },\n\t{ \"undefined.0x2000\", 0x2000, 16 },\n\t{ \"enum\", R_BIN_JAVA_FIELD_ACC_ENUM, 16 },\n\t{ \"undefined.0x8000\", 0x8000, 16 },\n\t{ NULL, 0, 0 }\n};\nstatic RBinJavaAccessFlags METHOD_ACCESS_FLAGS[] = {\n\t{ \"public\", R_BIN_JAVA_METHOD_ACC_PUBLIC, 6 },\n\t{ \"private\", R_BIN_JAVA_METHOD_ACC_PRIVATE, 7 },\n\t{ \"protected\", R_BIN_JAVA_METHOD_ACC_PROTECTED, 9 },\n\t{ \"static\", R_BIN_JAVA_METHOD_ACC_STATIC, 6 },\n\t{ \"final\", R_BIN_JAVA_METHOD_ACC_FINAL, 5 },\n\t{ \"synchronized\", R_BIN_JAVA_METHOD_ACC_SYNCHRONIZED, 12 },\n\t{ \"bridge\", R_BIN_JAVA_METHOD_ACC_BRIDGE, 6 },\n\t{ \"varargs\", R_BIN_JAVA_METHOD_ACC_VARARGS, 7 },\n\t{ \"native\", R_BIN_JAVA_METHOD_ACC_NATIVE, 6 },\n\t{ \"interface\", R_BIN_JAVA_METHOD_ACC_INTERFACE, 9 },\n\t{ \"abstract\", R_BIN_JAVA_METHOD_ACC_ABSTRACT, 8 },\n\t{ \"strict\", R_BIN_JAVA_METHOD_ACC_STRICT, 6 },\n\t{ \"synthetic\", R_BIN_JAVA_METHOD_ACC_SYNTHETIC, 9 },\n\t{ \"annotation\", R_BIN_JAVA_METHOD_ACC_ANNOTATION, 10 },\n\t{ \"enum\", R_BIN_JAVA_METHOD_ACC_ENUM, 4 },\n\t{ \"undefined.0x8000\", 0x8000, 16 },\n\t{ NULL, 0, 0 }\n};\n// XXX - Fix these there are some incorrect ongs\nstatic RBinJavaAccessFlags CLASS_ACCESS_FLAGS[] = {\n\t{ \"public\", R_BIN_JAVA_CLASS_ACC_PUBLIC, 6 },\n\t{ \"undefined.0x0002\", 0x0002, 16 },\n\t{ \"undefined.0x0004\", 0x0004, 16 },\n\t{ \"undefined.0x0008\", 0x0008, 16 },\n\t{ \"final\", R_BIN_JAVA_CLASS_ACC_FINAL, 5 },\n\t{ \"super\", R_BIN_JAVA_CLASS_ACC_SUPER, 5 },\n\t{ \"undefined.0x0040\", 0x0040, 16 },\n\t{ \"undefined.0x0080\", 0x0080, 16 },\n\t{ \"undefined.0x0100\", 0x0100, 16 },\n\t{ \"interface\", R_BIN_JAVA_CLASS_ACC_INTERFACE, 9 },\n\t{ \"abstract\", R_BIN_JAVA_CLASS_ACC_ABSTRACT, 8 },\n\t{ \"undefined.0x0800\", 0x0800, 16 },\n\t{ \"synthetic\", R_BIN_JAVA_CLASS_ACC_SYNTHETIC, 9 },\n\t{ \"annotation\", R_BIN_JAVA_CLASS_ACC_ANNOTATION, 10 },\n\t{ \"enum\", R_BIN_JAVA_CLASS_ACC_ENUM, 4 },\n\t{ \"undefined.0x8000\", 0x8000, 16 },\n\t{ NULL, 0, 0 }\n};\nstatic RBinJavaRefMetas R_BIN_JAVA_REF_METAS[] = {\n\t{ \"Unknown\", R_BIN_JAVA_REF_UNKNOWN },\n\t{ \"GetField\", R_BIN_JAVA_REF_GETFIELD },\n\t{ \"GetStatic\", R_BIN_JAVA_REF_GETSTATIC },\n\t{ \"PutField\", R_BIN_JAVA_REF_PUTFIELD },\n\t{ \"PutStatic\", R_BIN_JAVA_REF_PUTSTATIC },\n\t{ \"InvokeVirtual\", R_BIN_JAVA_REF_INVOKEVIRTUAL },\n\t{ \"InvokeStatic\", R_BIN_JAVA_REF_INVOKESTATIC },\n\t{ \"InvokeSpecial\", R_BIN_JAVA_REF_INVOKESPECIAL },\n\t{ \"NewInvokeSpecial\", R_BIN_JAVA_REF_NEWINVOKESPECIAL },\n\t{ \"InvokeInterface\", R_BIN_JAVA_REF_INVOKEINTERFACE }\n};\nstatic ut16 R_BIN_JAVA_ELEMENT_VALUE_METAS_SZ = 14;\nstatic RBinJavaElementValueMetas R_BIN_JAVA_ELEMENT_VALUE_METAS[] = {\n\t{ \"Byte\", R_BIN_JAVA_EV_TAG_BYTE, NULL },\n\t{ \"Char\", R_BIN_JAVA_EV_TAG_CHAR, NULL },\n\t{ \"Double\", R_BIN_JAVA_EV_TAG_DOUBLE, NULL },\n\t{ \"Float\", R_BIN_JAVA_EV_TAG_FLOAT, NULL },\n\t{ \"Integer\", R_BIN_JAVA_EV_TAG_INT, NULL },\n\t{ \"Long\", R_BIN_JAVA_EV_TAG_LONG, NULL },\n\t{ \"Short\", R_BIN_JAVA_EV_TAG_SHORT, NULL },\n\t{ \"Boolean\", R_BIN_JAVA_EV_TAG_BOOLEAN, NULL },\n\t{ \"Array of \", R_BIN_JAVA_EV_TAG_ARRAY, NULL },\n\t{ \"String\", R_BIN_JAVA_EV_TAG_STRING, NULL },\n\t{ \"Enum\", R_BIN_JAVA_EV_TAG_ENUM, NULL },\n\t{ \"Class\", R_BIN_JAVA_EV_TAG_CLASS, NULL },\n\t{ \"Annotation\", R_BIN_JAVA_EV_TAG_ANNOTATION, NULL },\n\t{ \"Unknown\", R_BIN_JAVA_EV_TAG_UNKNOWN, NULL },\n};\nstatic RBinJavaVerificationMetas R_BIN_JAVA_VERIFICATION_METAS[] = {\n\t{ \"Top\", R_BIN_JAVA_STACKMAP_TOP },\n\t{ \"Integer\", R_BIN_JAVA_STACKMAP_INTEGER },\n\t{ \"Float\", R_BIN_JAVA_STACKMAP_FLOAT },\n\t{ \"Double\", R_BIN_JAVA_STACKMAP_DOUBLE },\n\t{ \"Long\", R_BIN_JAVA_STACKMAP_LONG },\n\t{ \"NULL\", R_BIN_JAVA_STACKMAP_NULL },\n\t{ \"This\", R_BIN_JAVA_STACKMAP_THIS },\n\t{ \"Object\", R_BIN_JAVA_STACKMAP_OBJECT },\n\t{ \"Uninitialized\", R_BIN_JAVA_STACKMAP_UNINIT },\n\t{ \"Unknown\", R_BIN_JAVA_STACKMAP_UNKNOWN }\n};\nstatic RBinJavaStackMapFrameMetas R_BIN_JAVA_STACK_MAP_FRAME_METAS[] = {\n\t{ \"ImplicitStackFrame\", R_BIN_JAVA_STACK_FRAME_IMPLICIT, NULL },\n\t{ \"Same\", R_BIN_JAVA_STACK_FRAME_SAME, NULL },\n\t{ \"SameLocals1StackItem\", R_BIN_JAVA_STACK_FRAME_SAME_LOCALS_1, NULL },\n\t{ \"Chop\", R_BIN_JAVA_STACK_FRAME_CHOP, NULL },\n\t{ \"SameFrameExtended\", R_BIN_JAVA_STACK_FRAME_SAME_FRAME_EXTENDED, NULL },\n\t{ \"Append\", R_BIN_JAVA_STACK_FRAME_APPEND, NULL },\n\t{ \"FullFrame\", R_BIN_JAVA_STACK_FRAME_FULL_FRAME, NULL },\n\t{ \"Reserved\", R_BIN_JAVA_STACK_FRAME_RESERVED, NULL }\n};\n\nstatic RBinJavaCPTypeObjectAllocs R_BIN_ALLOCS_CONSTANTS[] = {\n\t{ r_bin_java_do_nothing_new, r_bin_java_do_nothing_free, r_bin_java_print_null_cp_summary, r_bin_java_do_nothing_calc_size, r_bin_java_print_null_cp_stringify },\n\t{ r_bin_java_utf8_cp_new, r_bin_java_utf8_info_free, r_bin_java_print_utf8_cp_summary, r_bin_java_utf8_cp_calc_size, r_bin_java_print_utf8_cp_stringify },\n\t{ r_bin_java_unknown_cp_new, r_bin_java_default_free, r_bin_java_print_unknown_cp_summary, r_bin_java_unknown_cp_calc_size, r_bin_java_print_unknown_cp_stringify },\n\t{ r_bin_java_integer_cp_new, r_bin_java_default_free, r_bin_java_print_integer_cp_summary, r_bin_java_integer_cp_calc_size, r_bin_java_print_integer_cp_stringify },\n\t{ r_bin_java_float_cp_new, r_bin_java_default_free, r_bin_java_print_float_cp_summary, r_bin_java_float_cp_calc_size, r_bin_java_print_float_cp_stringify },\n\t{ r_bin_java_long_cp_new, r_bin_java_default_free, r_bin_java_print_long_cp_summary, r_bin_java_long_cp_calc_size, r_bin_java_print_long_cp_stringify },\n\t{ r_bin_java_double_cp_new, r_bin_java_default_free, r_bin_java_print_double_cp_summary, r_bin_java_double_cp_calc_size, r_bin_java_print_double_cp_stringify },\n\t{ r_bin_java_class_cp_new, r_bin_java_default_free, r_bin_java_print_classref_cp_summary, r_bin_java_class_cp_calc_size, r_bin_java_print_classref_cp_stringify },\n\t{ r_bin_java_string_cp_new, r_bin_java_default_free, r_bin_java_print_string_cp_summary, r_bin_java_string_cp_calc_size, r_bin_java_print_string_cp_stringify },\n\t{ r_bin_java_fieldref_cp_new, r_bin_java_default_free, r_bin_java_print_fieldref_cp_summary, r_bin_java_fieldref_cp_calc_size, r_bin_java_print_fieldref_cp_stringify },\n\t{ r_bin_java_methodref_cp_new, r_bin_java_default_free, r_bin_java_print_methodref_cp_summary, r_bin_java_methodref_cp_calc_size, r_bin_java_print_methodref_cp_stringify },\n\t{ r_bin_java_interfacemethodref_cp_new, r_bin_java_default_free, r_bin_java_print_interfacemethodref_cp_summary, r_bin_java_interfacemethodref_cp_calc_size, r_bin_java_print_interfacemethodref_cp_stringify },\n\t{ r_bin_java_name_and_type_cp_new, r_bin_java_default_free, r_bin_java_print_name_and_type_cp_summary, r_bin_java_name_and_type_cp_calc_size, r_bin_java_print_name_and_type_cp_stringify },\n\t{ NULL, NULL, NULL, NULL, NULL },\n\t{ NULL, NULL, NULL, NULL, NULL },\n\t{ r_bin_java_methodhandle_cp_new, r_bin_java_default_free, r_bin_java_print_methodhandle_cp_summary, r_bin_java_methodhandle_cp_calc_size, r_bin_java_print_methodhandle_cp_stringify },\n\t{ r_bin_java_methodtype_cp_new, r_bin_java_default_free, r_bin_java_print_methodtype_cp_summary, r_bin_java_methodtype_cp_calc_size, r_bin_java_print_methodtype_cp_stringify },\n\t{ NULL, NULL, NULL, NULL, NULL },\n\t{ r_bin_java_invokedynamic_cp_new, r_bin_java_default_free, r_bin_java_print_invokedynamic_cp_summary, r_bin_java_invokedynamic_cp_calc_size, r_bin_java_print_invokedynamic_cp_stringify },\n};\nstatic RBinJavaCPTypeObj R_BIN_JAVA_NULL_TYPE;\nstatic ut8 R_BIN_JAVA_CP_METAS_SZ = 12;\nstatic RBinJavaCPTypeMetas R_BIN_JAVA_CP_METAS[] = {\n\t// Each field has a name pointer and a tag field\n\t{ \"NULL\", R_BIN_JAVA_CP_NULL, 0, &R_BIN_ALLOCS_CONSTANTS[0] },\n\t{ \"Utf8\", R_BIN_JAVA_CP_UTF8, 3, &R_BIN_ALLOCS_CONSTANTS[1] },  // 2 bytes = length, N bytes string (containts a pointer in the field)\n\t{ \"Unknown\", R_BIN_JAVA_CP_UNKNOWN, 0, &R_BIN_ALLOCS_CONSTANTS[2] },\n\t{ \"Integer\", R_BIN_JAVA_CP_INTEGER, 5, &R_BIN_ALLOCS_CONSTANTS[3] },  // 4 bytes\n\t{ \"Float\", R_BIN_JAVA_CP_FLOAT, 5, &R_BIN_ALLOCS_CONSTANTS[4] },  // 4 bytes\n\t{ \"Long\", R_BIN_JAVA_CP_LONG, 9, &R_BIN_ALLOCS_CONSTANTS[5] }, // 4 high 4 low\n\t{ \"Double\", R_BIN_JAVA_CP_DOUBLE, 9, &R_BIN_ALLOCS_CONSTANTS[6] }, // 4 high 4 low\n\t{ \"Class\", R_BIN_JAVA_CP_CLASS, 3, &R_BIN_ALLOCS_CONSTANTS[7] }, // 2 name_idx\n\t{ \"String\", R_BIN_JAVA_CP_STRING, 3, &R_BIN_ALLOCS_CONSTANTS[8] }, // 2 string_idx\n\t{ \"FieldRef\", R_BIN_JAVA_CP_FIELDREF, 5, &R_BIN_ALLOCS_CONSTANTS[9] }, // 2 class idx, 2 name/type_idx\n\t{ \"MethodRef\", R_BIN_JAVA_CP_METHODREF, 5, &R_BIN_ALLOCS_CONSTANTS[10] }, // 2 class idx, 2 name/type_idx\n\t{ \"InterfaceMethodRef\", R_BIN_JAVA_CP_INTERFACEMETHOD_REF, 5, &R_BIN_ALLOCS_CONSTANTS[11] },  // 2 class idx, 2 name/type_idx\n\t{ \"NameAndType\", R_BIN_JAVA_CP_NAMEANDTYPE, 5, &R_BIN_ALLOCS_CONSTANTS[12] }, // 4 high 4 low\n\t{ \"Unknown\", R_BIN_JAVA_CP_UNKNOWN, 0, &R_BIN_ALLOCS_CONSTANTS[2] },\n\t{ \"Unknown\", R_BIN_JAVA_CP_UNKNOWN, 0, &R_BIN_ALLOCS_CONSTANTS[2] },\n\t{ \"MethodHandle\", R_BIN_JAVA_CP_METHODHANDLE, 4, &R_BIN_ALLOCS_CONSTANTS[15] }, // 4 high 4 low\n\t{ \"MethodType\", R_BIN_JAVA_CP_METHODTYPE, 3, &R_BIN_ALLOCS_CONSTANTS[16] }, // 4 high 4 low\n\t{ \"Unknown\", R_BIN_JAVA_CP_UNKNOWN, 0, &R_BIN_ALLOCS_CONSTANTS[2] },\n\t{ \"InvokeDynamic\", R_BIN_JAVA_CP_INVOKEDYNAMIC, 5, &R_BIN_ALLOCS_CONSTANTS[18] }, // 4 high 4 low\n};\nstatic RBinJavaAttrInfoObjectAllocs RBIN_JAVA_ATTRS_ALLOCS[] = {\n\t{ r_bin_java_annotation_default_attr_new, r_bin_java_annotation_default_attr_free, r_bin_java_print_annotation_default_attr_summary, r_bin_java_annotation_default_attr_calc_size },\n\t{ r_bin_java_bootstrap_methods_attr_new, r_bin_java_bootstrap_methods_attr_free, r_bin_java_print_bootstrap_methods_attr_summary, r_bin_java_bootstrap_methods_attr_calc_size },\n\t{ r_bin_java_code_attr_new, r_bin_java_code_attr_free, r_bin_java_print_code_attr_summary, r_bin_java_code_attr_calc_size },\n\t{ r_bin_java_constant_value_attr_new, r_bin_java_constant_value_attr_free, r_bin_java_print_constant_value_attr_summary, r_bin_java_constant_value_attr_calc_size },\n\t{ r_bin_java_deprecated_attr_new, r_bin_java_deprecated_attr_free, r_bin_java_print_deprecated_attr_summary, r_bin_java_deprecated_attr_calc_size },\n\t{ r_bin_java_enclosing_methods_attr_new, r_bin_java_enclosing_methods_attr_free, r_bin_java_print_enclosing_methods_attr_summary, r_bin_java_enclosing_methods_attr_calc_size },\n\t{ r_bin_java_exceptions_attr_new, r_bin_java_exceptions_attr_free, r_bin_java_print_exceptions_attr_summary, r_bin_java_exceptions_attr_calc_size },\n\t{ r_bin_java_inner_classes_attr_new, r_bin_java_inner_classes_attr_free, r_bin_java_print_inner_classes_attr_summary, r_bin_java_inner_classes_attr_calc_size },\n\t{ r_bin_java_line_number_table_attr_new, r_bin_java_line_number_table_attr_free, r_bin_java_print_line_number_table_attr_summary, r_bin_java_line_number_table_attr_calc_size },\n\t{ r_bin_java_local_variable_table_attr_new, r_bin_java_local_variable_table_attr_free, r_bin_java_print_local_variable_table_attr_summary, r_bin_java_local_variable_table_attr_calc_size },\n\t{ r_bin_java_local_variable_type_table_attr_new, r_bin_java_local_variable_type_table_attr_free, r_bin_java_print_local_variable_type_table_attr_summary, r_bin_java_local_variable_type_table_attr_calc_size },\n\t{ r_bin_java_rti_annotations_attr_new, r_bin_java_rti_annotations_attr_free, r_bin_java_print_rti_annotations_attr_summary, r_bin_java_rti_annotations_attr_calc_size },\n\t{ r_bin_java_rtip_annotations_attr_new, r_bin_java_rtip_annotations_attr_free, r_bin_java_print_rtip_annotations_attr_summary, r_bin_java_rtip_annotations_attr_calc_size },\n\t{ r_bin_java_rtv_annotations_attr_new, r_bin_java_rtv_annotations_attr_free, r_bin_java_print_rtv_annotations_attr_summary, r_bin_java_rtv_annotations_attr_calc_size },\n\t{ r_bin_java_rtvp_annotations_attr_new, r_bin_java_rtvp_annotations_attr_free, r_bin_java_print_rtvp_annotations_attr_summary, r_bin_java_rtvp_annotations_attr_calc_size },\n\t{ r_bin_java_signature_attr_new, r_bin_java_signature_attr_free, r_bin_java_print_signature_attr_summary, r_bin_java_signature_attr_calc_size },\n\t{ r_bin_java_source_debug_attr_new, r_bin_java_source_debug_attr_free, r_bin_java_print_source_debug_attr_summary, r_bin_java_source_debug_attr_calc_size },\n\t{ r_bin_java_source_code_file_attr_new, r_bin_java_source_code_file_attr_free, r_bin_java_print_source_code_file_attr_summary, r_bin_java_source_code_file_attr_calc_size },\n\t{ r_bin_java_stack_map_table_attr_new, r_bin_java_stack_map_table_attr_free, r_bin_java_print_stack_map_table_attr_summary, r_bin_java_stack_map_table_attr_calc_size },\n\t{ r_bin_java_synthetic_attr_new, r_bin_java_synthetic_attr_free, r_bin_java_print_synthetic_attr_summary, r_bin_java_synthetic_attr_calc_size },\n\t{ r_bin_java_unknown_attr_new, r_bin_java_unknown_attr_free, r_bin_java_print_unknown_attr_summary, r_bin_java_unknown_attr_calc_size }\n};\n// R_API ut32 RBIN_JAVA_ATTRS_METAS_SZ = 21;\nstatic ut32 RBIN_JAVA_ATTRS_METAS_SZ = 20;\nstatic RBinJavaAttrMetas RBIN_JAVA_ATTRS_METAS[] = {\n\t{ \"AnnotationDefault\", R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[0] },\n\t{ \"BootstrapMethods\", R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[1] },\n\t{ \"Code\", R_BIN_JAVA_ATTR_TYPE_CODE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[2] },\n\t{ \"ConstantValue\", R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[3] },\n\t{ \"Deperecated\", R_BIN_JAVA_ATTR_TYPE_DEPRECATED_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[4] },\n\t{ \"EnclosingMethod\", R_BIN_JAVA_ATTR_TYPE_ENCLOSING_METHOD_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[5] },\n\t{ \"Exceptions\", R_BIN_JAVA_ATTR_TYPE_EXCEPTIONS_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[6] },\n\t{ \"InnerClasses\", R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[7] },\n\t{ \"LineNumberTable\", R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[8] },\n\t{ \"LocalVariableTable\", R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TABLE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[9] },\n\t{ \"LocalVariableTypeTable\", R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TYPE_TABLE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[10] },\n\t{ \"RuntimeInvisibleAnnotations\", R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[11] },\n\t{ \"RuntimeInvisibleParameterAnnotations\", R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_PARAMETER_ANNOTATION_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[12] },\n\t{ \"RuntimeVisibleAnnotations\", R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_ANNOTATION_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[13] },\n\t{ \"RuntimeVisibleParameterAnnotations\", R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_PARAMETER_ANNOTATION_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[14] },\n\t{ \"Signature\", R_BIN_JAVA_ATTR_TYPE_SIGNATURE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[15] },\n\t{ \"SourceDebugExtension\", R_BIN_JAVA_ATTR_TYPE_SOURCE_DEBUG_EXTENTSION_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[16] },\n\t{ \"SourceFile\", R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[17] },\n\t{ \"StackMapTable\", R_BIN_JAVA_ATTR_TYPE_STACK_MAP_TABLE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[18] },\n\t// { \"StackMap\", R_BIN_JAVA_ATTR_TYPE_STACK_MAP_TABLE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[18]},\n\t{ \"Synthetic\", R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[19] },\n\t{ \"Unknown\", R_BIN_JAVA_ATTR_TYPE_UNKNOWN_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[20] }\n};\n\nR_API void r_bin_java_reset_bin_info(RBinJavaObj *bin) {\n\tfree (bin->cf2.flags_str);\n\tfree (bin->cf2.this_class_name);\n\tr_list_free (bin->imports_list);\n\tr_list_free (bin->methods_list);\n\tr_list_free (bin->fields_list);\n\tr_list_free (bin->attrs_list);\n\tr_list_free (bin->cp_list);\n\tr_list_free (bin->interfaces_list);\n\tmemset (bin, 0, sizeof (RBinJavaObj));\n\tbin->cf2.flags_str = strdup (\"unknown\");\n\tbin->cf2.this_class_name = strdup (\"unknown\");\n\tbin->imports_list = r_list_newf (free);\n\tbin->methods_list = r_list_newf (r_bin_java_fmtype_free);\n\tbin->fields_list = r_list_newf (r_bin_java_fmtype_free);\n\tbin->attrs_list = r_list_newf (r_bin_java_attribute_free);\n\tbin->cp_list = r_list_newf (r_bin_java_constant_pool);\n\tbin->interfaces_list = r_list_newf (r_bin_java_interface_free);\n}\n\nR_API char *r_bin_java_unmangle_method(const char *flags, const char *name, const char *params, const char *r_value) {\n\tRList *the_list = params ? r_bin_java_extract_type_values (params) : r_list_new ();\n\tRListIter *iter = NULL;\n\t// second case removes leading space if no flags are given\n\tconst char *fmt = flags ? \"%s %s %s (%s)\" : \"%s%s %s (%s)\";\n\tchar *str = NULL, *f_val_str = NULL, *r_val_str = NULL, *prototype = NULL, *p_val_str = NULL;\n\tut32 params_idx = 0, params_len = 0, prototype_len = 0;\n\tif (!extract_type_value (r_value, &r_val_str)) {\n\t\tr_list_free (the_list);\n\t\treturn NULL;\n\t}\n\tif (!r_val_str) {\n\t\tr_val_str = strdup (\"UNKNOWN\");\n\t}\n\tf_val_str = strdup (flags ? flags : \"\");\n\tparams_idx = 0;\n\tr_list_foreach (the_list, iter, str) {\n\t\tparams_len += strlen (str);\n\t\tif (params_idx > 0) {\n\t\t\tparams_len += 2;\n\t\t}\n\t\tparams_idx++;\n\t}\n\tif (params_len > 0) {\n\t\tut32 offset = 0;\n\t\tparams_len += 1;\n\t\tp_val_str = malloc (params_len);\n\t\tparams_idx = 0;\n\t\tr_list_foreach (the_list, iter, str) {\n\t\t\tif (offset != 0) {\n\t\t\t\toffset += snprintf (p_val_str + offset, params_len - offset, \", %s\", str);\n\t\t\t} else {\n\t\t\t\toffset += snprintf (p_val_str + offset, params_len - offset, \"%s\", str);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tp_val_str = strdup (\"\");\n\t}\n\n\tprototype_len += (flags ? strlen (flags) + 1 : 0); // space vs no space\n\tprototype_len += strlen (name) + 1; // name + space\n\tprototype_len += strlen (r_val_str) + 1; // r_value + space\n\tprototype_len += strlen (p_val_str) + 3; // space + l_paren + params + r_paren\n\tprototype_len += 1; // null\n\tprototype = malloc (prototype_len);\n\t/// TODO enable this function and start using it to demangle strings\n\tsnprintf (prototype, prototype_len, fmt, f_val_str, r_val_str, name, p_val_str);\n\tfree (f_val_str);\n\tfree (r_val_str);\n\tfree (p_val_str);\n\tr_list_free (the_list);\n\treturn prototype;\n}\n\nR_API char *r_bin_java_unmangle(const char *flags, const char *name, const char *descriptor) {\n\tut32 l_paren_pos = -1, r_paren_pos = -1;\n\tchar *result = NULL;\n\tut32 desc_len = descriptor && *descriptor ? strlen (descriptor) : 0,\n\tname_len = name && *name ? strlen (name) : 0,\n\tflags_len = flags && *flags ? strlen (flags) : 0,\n\ti = 0;\n\tif (desc_len == 0 || name == 0) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < desc_len; i++) {\n\t\tif (descriptor[i] == '(') {\n\t\t\tl_paren_pos = i;\n\t\t} else if (l_paren_pos != (ut32) - 1 && descriptor[i] == ')') {\n\t\t\tr_paren_pos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// handle field case;\n\tif (l_paren_pos == (ut32) - 1 && r_paren_pos == (ut32) - 1) {\n\t\tchar *unmangle_field_desc = NULL;\n\t\tut32 len = extract_type_value (descriptor, &unmangle_field_desc);\n\t\tif (len == 0) {\n\t\t\teprintf (\"Warning: attempting to unmangle invalid type descriptor.\\n\");\n\t\t\tfree (unmangle_field_desc);\n\t\t\treturn result;\n\t\t}\n\t\tif (flags_len > 0) {\n\t\t\tlen += (flags_len + name_len + 5); // space and null\n\t\t\tresult = malloc (len);\n\t\t\tsnprintf (result, len, \"%s %s %s\", flags, unmangle_field_desc, name);\n\t\t} else {\n\t\t\tlen += (name_len + 5); // space and null\n\t\t\tresult = malloc (len);\n\t\t\tsnprintf (result, len, \"%s %s\", unmangle_field_desc, name);\n\t\t}\n\t\tfree (unmangle_field_desc);\n\t} else if (l_paren_pos != (ut32) - 1 &&\n\tr_paren_pos != (ut32) - 1 &&\n\tl_paren_pos < r_paren_pos) {\n\t\t// params_len account for l_paren + 1 and null\n\t\tut32 params_len = r_paren_pos - (l_paren_pos + 1) != 0 ? r_paren_pos - (l_paren_pos + 1) + 1 : 0;\n\t\tchar *params = params_len ? malloc (params_len) : NULL;\n\t\tconst char *rvalue = descriptor + r_paren_pos + 1;\n\t\tif (params) {\n\t\t\tsnprintf (params, params_len, \"%s\", descriptor + l_paren_pos + 1);\n\t\t}\n\t\tresult = r_bin_java_unmangle_method (flags, name, params, rvalue);\n\t\tfree (params);\n\t}\n\treturn result;\n}\n\nR_API DsoJsonObj *r_bin_java_get_bin_obj_json(RBinJavaObj *bin) {\n\tDsoJsonObj *imports_list = r_bin_java_get_import_json_definitions (bin);\n\tDsoJsonObj *fields_list = r_bin_java_get_field_json_definitions (bin);\n\tDsoJsonObj *methods_list = r_bin_java_get_method_json_definitions (bin);\n\t// interfaces_list = r_bin_java_get_interface_json_definitions (bin);\n\tDsoJsonObj *class_dict = r_bin_java_get_class_info_json (bin);\n\tchar *res = dso_json_obj_to_str (methods_list);\n\t// eprintf (\"Resulting methods json: \\n%s\\n\", res);\n\tfree (res);\n\tdso_json_dict_insert_str_key_obj (class_dict, \"methods\", methods_list);\n\t// dso_json_list_free (methods_list);\n\tdso_json_obj_del (methods_list);\n\n\tres = dso_json_obj_to_str (fields_list);\n\t// eprintf (\"Resulting fields json: \\n%s\\n\", res);\n\tfree (res);\n\tdso_json_dict_insert_str_key_obj (class_dict, \"fields\", fields_list);\n\t// dso_json_list_free (fields_list);\n\tdso_json_obj_del (fields_list);\n\n\tres = dso_json_obj_to_str (imports_list);\n\t// eprintf (\"Resulting imports json: \\n%s\\n\", res);\n\tfree (res);\n\tdso_json_dict_insert_str_key_obj (class_dict, \"imports\", imports_list);\n\t// dso_json_list_free (imports_list);\n\tdso_json_obj_del (imports_list);\n\n\t// res = dso_json_obj_to_str (interfaces_list);\n\t// eprintf (\"Resulting interfaces json: \\n%s\\n\", res);\n\t// free (res);\n\t// dso_json_dict_insert_str_key_obj (class_dict, \"interfaces\", interfaces_list);\n\n\tres = dso_json_obj_to_str (class_dict);\n\t// eprintf (\"Resulting class info json: \\n%s\\n\", res);\n\tfree (res);\n\t// dso_json_obj_del (class_dict);\n\treturn class_dict;\n}\n\nR_API DsoJsonObj *r_bin_java_get_import_json_definitions(RBinJavaObj *bin) {\n\tRList *the_list;\n\tDsoJsonObj *json_list = dso_json_list_new ();\n\tRListIter *iter = NULL;\n\tchar *new_str;\n\n\tif (!bin || !(the_list = r_bin_java_get_lib_names (bin))) {\n\t\treturn json_list;\n\t}\n\n\tr_list_foreach (the_list, iter, new_str) {\n\t\tchar *tmp = new_str;\n\t\t// eprintf (\"Processing string: %s\\n\", new_str);\n\t\twhile (*tmp) {\n\t\t\tif (*tmp == '/') {\n\t\t\t\t*tmp = '.';\n\t\t\t}\n\t\t\ttmp++;\n\t\t}\n\t\t// eprintf (\"adding string: %s\\n\", new_str);\n\t\tdso_json_list_append_str (json_list, new_str);\n\t}\n\tr_list_free (the_list);\n\treturn json_list;\n}\n\nR_API DsoJsonObj *r_bin_java_get_class_info_json(RBinJavaObj *bin) {\n\tRList *classes = r_bin_java_get_classes (bin);\n\tDsoJsonObj *interfaces_list = dso_json_list_new ();\n\tDsoJsonObj *class_info_dict = dso_json_dict_new ();\n\tRBinClass *class_ = r_list_get_n (classes, 0);\n\n\tif (class_) {\n\t\tint dummy = 0;\n\t\tRListIter *iter;\n\t\tRBinClass *class_v = NULL;\n\t\t// add access flags like in methods\n\t\tbool is_public = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_PUBLIC) != 0);\n\t\tbool is_final = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_FINAL) != 0);\n\t\tbool is_super = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_SUPER) != 0);\n\t\tbool is_interface = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_INTERFACE) != 0);\n\t\tbool is_abstract = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_ABSTRACT) != 0);\n\t\tbool is_synthetic = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_SYNTHETIC) != 0);\n\t\tbool is_annotation = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_ANNOTATION) != 0);\n\t\tbool is_enum = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_ENUM) != 0);\n\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"access_flags\", class_->visibility);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_public\", is_public);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_final\", is_final);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_super\", is_super);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_interface\", is_interface);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_abstract\", is_abstract);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_synthetic\", is_synthetic);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_annotation\", is_annotation);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_enum\", is_enum);\n\t\tdso_json_dict_insert_str_key_str (class_info_dict, \"name\", class_->name);\n\n\t\tif (!class_->super) {\n\t\t\tDsoJsonObj *str = dso_json_str_new ();\n\t\t\tdso_json_dict_insert_str_key_obj (class_info_dict, \"super\", str);\n\t\t\tdso_json_str_free (str);\n\t\t} else {\n\t\t\tdso_json_dict_insert_str_key_str (class_info_dict, \"super\", class_->super);\n\t\t}\n\n\t\tr_list_foreach (classes, iter, class_v) {\n\t\t\tif (!dummy) {\n\t\t\t\tdummy++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// enumerate all interface classes and append them to the interfaces\n\t\t\tif ((class_v->visibility & R_BIN_JAVA_CLASS_ACC_INTERFACE) != 0) {\n\t\t\t\tdso_json_list_append_str (interfaces_list, class_v->name);\n\t\t\t}\n\t\t}\n\t}\n\tdso_json_dict_insert_str_key_obj (class_info_dict, \"interfaces\", interfaces_list);\n\tr_list_free (classes);\n\t// dso_json_list_free (interfaces_list);\n\tdso_json_obj_del (interfaces_list);\n\treturn class_info_dict;\n}\n\nR_API DsoJsonObj *r_bin_java_get_interface_json_definitions(RBinJavaObj *bin) {\n\tRList *the_list;\n\tDsoJsonObj *json_list = dso_json_list_new ();\n\tRListIter *iter = NULL;\n\tchar *new_str;\n\n\tif (!bin || !(the_list = r_bin_java_get_interface_names (bin))) {\n\t\treturn json_list;\n\t}\n\n\tr_list_foreach (the_list, iter, new_str) {\n\t\tchar *tmp = new_str;\n\t\t// eprintf (\"Processing string: %s\\n\", new_str);\n\t\twhile (*tmp) {\n\t\t\tif (*tmp == '/') {\n\t\t\t\t*tmp = '.';\n\t\t\t}\n\t\t\ttmp++;\n\t\t}\n\t\t// eprintf (\"adding string: %s\\n\", new_str);\n\t\tdso_json_list_append_str (json_list, new_str);\n\t}\n\tr_list_free (the_list);\n\treturn json_list;\n}\n\nR_API DsoJsonObj *r_bin_java_get_method_json_definitions(RBinJavaObj *bin) {\n\tRBinJavaField *fm_type = NULL;\n\tRListIter *iter = NULL;\n\tDsoJsonObj *json_list = dso_json_list_new ();\n\tif (!bin) {\n\t\treturn json_list;\n\t}\n\tr_list_foreach (bin->methods_list, iter, fm_type) {\n\t\tDsoJsonObj *method_proto = r_bin_java_get_method_json_definition (bin, fm_type);\n\t\t// eprintf (\"Method json: %s\\n\", method_proto);\n\t\tdso_json_list_append (json_list, method_proto);\n\t}\n\treturn json_list;\n}\n\nR_API DsoJsonObj *r_bin_java_get_field_json_definitions(RBinJavaObj *bin) {\n\tRBinJavaField *fm_type = NULL;\n\tRListIter *iter = NULL;\n\tDsoJsonObj *json_list = dso_json_list_new ();\n\tif (!bin) {\n\t\treturn json_list;\n\t}\n\tr_list_foreach (bin->fields_list, iter, fm_type) {\n\t\tDsoJsonObj *field_proto = r_bin_java_get_field_json_definition (bin, fm_type);\n\t\t// eprintf (\"Field json: %s\\n\", field_proto);\n\t\tdso_json_list_append (json_list, field_proto);\n\t}\n\treturn json_list;\n}\n\nR_API char *r_bin_java_create_method_fq_str(const char *klass, const char *name, const char *signature) {\n\tif (!klass) {\n\t\tklass = \"null_class\";\n\t}\n\tif (!name) {\n\t\tname = \"null_name\";\n\t}\n\tif (!signature) {\n\t\tsignature = \"null_signature\";\n\t}\n\treturn r_str_newf (\"%s.%s.%s\", klass, name, signature);\n}\n\nR_API char *r_bin_java_create_field_fq_str(const char *klass, const char *name, const char *signature) {\n\tif (!klass) {\n\t\tklass = \"null_class\";\n\t}\n\tif (!name) {\n\t\tname = \"null_name\";\n\t}\n\tif (!signature) {\n\t\tsignature = \"null_signature\";\n\t}\n\treturn r_str_newf (\"%s %s.%s\", signature, klass, name);\n}\n\nR_API DsoJsonObj *r_bin_java_get_fm_type_definition_json(RBinJavaObj *bin, RBinJavaField *fm_type, int is_method) {\n\tut64 addr = UT64_MAX;\n\tchar *prototype = NULL, *fq_name = NULL;\n\tbool is_native = ((fm_type->flags & R_BIN_JAVA_METHOD_ACC_NATIVE) != 0);\n\tbool is_static = ((fm_type->flags & R_BIN_JAVA_METHOD_ACC_STATIC) != 0);\n\tbool is_synthetic = ((fm_type->flags & R_BIN_JAVA_METHOD_ACC_SYNTHETIC) != 0);\n\tbool is_private = ((fm_type->flags & R_BIN_JAVA_METHOD_ACC_PRIVATE) != 0);\n\tbool is_public = ((fm_type->flags & R_BIN_JAVA_METHOD_ACC_PUBLIC) != 0);\n\tbool is_protected = ((fm_type->flags & R_BIN_JAVA_METHOD_ACC_PROTECTED) != 0);\n\tbool is_super = ((fm_type->flags & R_BIN_JAVA_CLASS_ACC_SUPER) != 0);\n\n\tDsoJsonObj *fm_type_dict = dso_json_dict_new ();\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"access_flags\", fm_type->flags);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_method\", is_method);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_native\", is_native);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_synthetic\", is_synthetic);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_private\", is_private);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_public\", is_public);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_static\", is_static);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_protected\", is_protected);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_super\", is_super);\n\n\taddr = r_bin_java_get_method_code_offset (fm_type);\n\tif (addr == 0) {\n\t\taddr = fm_type->file_offset;\n\t}\n\taddr += bin->loadaddr;\n\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"addr\", addr);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"offset\", fm_type->file_offset + bin->loadaddr);\n\tdso_json_dict_insert_str_key_str (fm_type_dict, \"class_name\", fm_type->class_name);\n\tdso_json_dict_insert_str_key_str (fm_type_dict, \"signature\", fm_type->descriptor);\n\tdso_json_dict_insert_str_key_str (fm_type_dict, \"name\", fm_type->name);\n\n\tif (is_method) {\n\t\tfq_name = r_bin_java_create_method_fq_str (fm_type->class_name, fm_type->name, fm_type->descriptor);\n\t} else {\n\t\tfq_name = r_bin_java_create_field_fq_str (fm_type->class_name, fm_type->name, fm_type->descriptor);\n\t}\n\tdso_json_dict_insert_str_key_str (fm_type_dict, \"fq_name\", fq_name);\n\n\tprototype = r_bin_java_unmangle (fm_type->flags_str, fm_type->name, fm_type->descriptor);\n\tdso_json_dict_insert_str_key_str (fm_type_dict, \"prototype\", prototype);\n\tfree (prototype);\n\tfree (fq_name);\n\treturn fm_type_dict;\n}\n\nR_API char *r_bin_java_get_method_definition(RBinJavaField *fm_type) {\n\treturn r_bin_java_unmangle (fm_type->flags_str, fm_type->name, fm_type->descriptor);\n}\n\nR_API char *r_bin_java_get_field_definition(RBinJavaField *fm_type) {\n\treturn r_bin_java_unmangle (fm_type->flags_str, fm_type->name, fm_type->descriptor);\n}\n\nR_API DsoJsonObj *r_bin_java_get_method_json_definition(RBinJavaObj *bin, RBinJavaField *fm_type) {\n\treturn r_bin_java_get_fm_type_definition_json (bin, fm_type, 1);\n}\n\nR_API DsoJsonObj *r_bin_java_get_field_json_definition(RBinJavaObj *bin, RBinJavaField *fm_type) {\n\treturn r_bin_java_get_fm_type_definition_json (bin, fm_type, 0);\n}\n\nR_API int r_bin_java_extract_reference_name(const char *input_str, char **ref_str, ut8 array_cnt) {\n\tchar *new_str = NULL;\n\tut32 str_len = array_cnt ? (array_cnt + 1) * 2 : 0;\n\tconst char *str_pos = input_str;\n\tint consumed = 0, len = 0;\n\tif (!str_pos || *str_pos != 'L' || !*str_pos) {\n\t\treturn -1;\n\t}\n\tconsumed++;\n\tstr_pos++;\n\twhile (*str_pos && *str_pos != ';') {\n\t\tstr_pos++;\n\t\tlen++;\n\t\tconsumed++;\n\t}\n\tstr_pos = input_str + 1;\n\tfree (*ref_str);\n\tstr_len += len;\n\t*ref_str = malloc (str_len + 1);\n\tnew_str = *ref_str;\n\tmemcpy (new_str, input_str + 1, str_len);\n\tnew_str[str_len] = 0;\n\twhile (*new_str) {\n\t\tif (*new_str == '/') {\n\t\t\t*new_str = '.';\n\t\t}\n\t\tnew_str++;\n\t}\n\treturn len + 2;\n}\n\nR_API void UNUSED_FUNCTION(r_bin_java_print_prototypes)(RBinJavaObj * bin) {\n\tRList *the_list = r_bin_java_get_method_definitions (bin);\n\tRListIter *iter;\n\tchar *str;\n\tr_list_foreach (the_list, iter, str) {\n\t\teprintf (\"%s;\\n\", str);\n\t}\n\tr_list_free (the_list);\n}\n\nR_API char *get_type_value_str(const char *arg_str, ut8 array_cnt) {\n\tut32 str_len = array_cnt ? (array_cnt + 1) * 2 + strlen (arg_str) : strlen (arg_str);\n\tchar *str = malloc (str_len + 1);\n\tut32 bytes_written = snprintf (str, str_len + 1, \"%s\", arg_str);\n\twhile (array_cnt > 0) {\n\t\tbytes_written = snprintf (str + bytes_written, str_len - bytes_written, \"[]\");\n\t\tarray_cnt--;\n\t}\n\treturn str;\n}\n\nR_API int extract_type_value(const char *arg_str, char **output) {\n\tut8 found_one = 0, array_cnt = 0;\n\tut32 len = 0, consumed = 0;\n\tchar *str = NULL;\n\tif (!arg_str || !output) {\n\t\treturn 0;\n\t}\n\tif (output && *output && *output != NULL) {\n\t\tfree (*output);\n\t\t*output = NULL;\n\t}\n\twhile (arg_str && *arg_str && !found_one) {\n\t\tlen = 0;\n\t\t// handle the end of an object\n\t\tswitch (*arg_str) {\n\t\tcase 'V':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"void\", array_cnt);\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"long\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"int\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"double\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"float\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"byte\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"char\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"boolean\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"short\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase '[': len = 1; array_cnt++; break;\n\t\tcase 'L':\n\t\t\tlen = r_bin_java_extract_reference_name (arg_str, &str, array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase '(': len = 1; str = strdup (\"(\"); break;\n\t\tcase ')': len = 1; str = strdup (\")\"); break;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\tif (len < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tconsumed += len;\n\t\targ_str += len;\n\t\tif (str) {\n\t\t\t*output = str;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn consumed;\n}\n\nR_API RList *r_bin_java_extract_type_values(const char *arg_str) {\n\tRList *list_args = r_list_new ();\n\tif (!list_args) {\n\t\treturn NULL;\n\t}\n\tchar *str = NULL;\n\tconst char *str_cur_pos = NULL;\n\tut32 len = 0;\n\tif (!arg_str) {\n\t\treturn list_args;\n\t}\n\tstr_cur_pos = arg_str;\n\tlist_args->free = free;\n\twhile (str_cur_pos && *str_cur_pos) {\n\t\t// handle the end of an object\n\t\tlen = extract_type_value (str_cur_pos, &str);\n\t\tif (len < 1) {\n\t\t\tr_list_free (list_args);\n\t\t\treturn NULL;\n\t\t}\n\t\tstr_cur_pos += len;\n\t\tr_list_append (list_args, str);\n\t\tstr = NULL;\n\t}\n\treturn list_args;\n}\n\nR_API int r_bin_java_is_fm_type_private(RBinJavaField *fm_type) {\n\tif (fm_type && fm_type->type == R_BIN_JAVA_FIELD_TYPE_METHOD) {\n\t\treturn fm_type->flags & R_BIN_JAVA_METHOD_ACC_PRIVATE;\n\t}\n\tif (fm_type && fm_type->type == R_BIN_JAVA_FIELD_TYPE_FIELD) {\n\t\treturn fm_type->flags & R_BIN_JAVA_FIELD_ACC_PRIVATE;\n\t}\n\treturn 0;\n}\n\nR_API int r_bin_java_is_fm_type_protected(RBinJavaField *fm_type) {\n\tif (fm_type && fm_type->type == R_BIN_JAVA_FIELD_TYPE_METHOD) {\n\t\treturn fm_type->flags & R_BIN_JAVA_METHOD_ACC_PROTECTED;\n\t}\n\tif (fm_type && fm_type->type == R_BIN_JAVA_FIELD_TYPE_FIELD) {\n\t\treturn fm_type->flags & R_BIN_JAVA_FIELD_ACC_PROTECTED;\n\t}\n\treturn 0;\n}\n\nR_API RList *r_bin_java_get_args(RBinJavaField *fm_type) {\n\tRList *the_list = r_bin_java_extract_type_values (fm_type->descriptor);\n\tRList *arg_list = r_list_new ();\n\tut8 in_args = 0;\n\tRListIter *desc_iter;\n\tchar *str;\n\tr_list_foreach (the_list, desc_iter, str) {\n\t\tif (str && *str == '(') {\n\t\t\tin_args = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (str && *str == ')') {\n\t\t\tbreak;\n\t\t}\n\t\tif (in_args) {\n\t\t\tr_list_append (arg_list, strdup (str));\n\t\t}\n\t}\n\tr_list_free (the_list);\n\treturn arg_list;\n}\n\nR_API RList *r_bin_java_get_ret(RBinJavaField *fm_type) {\n\tRList *the_list = r_bin_java_extract_type_values (fm_type->descriptor);\n\tRList *ret_list = r_list_new ();\n\tut8 in_ret = 0;\n\tRListIter *desc_iter;\n\tchar *str;\n\tr_list_foreach (the_list, desc_iter, str) {\n\t\tif (str && *str != ')') {\n\t\t\tin_ret = 0;\n\t\t}\n\t\tif (in_ret) {\n\t\t\tr_list_append (ret_list, strdup (str));\n\t\t}\n\t}\n\tr_list_free (the_list);\n\treturn ret_list;\n}\n\nR_API char *r_bin_java_get_this_class_name(RBinJavaObj *bin) {\n\treturn (bin->cf2.this_class_name ? strdup (bin->cf2.this_class_name) : strdup (\"unknown\"));\n}\n\nR_API ut16 calculate_access_value(const char *access_flags_str, RBinJavaAccessFlags *access_flags) {\n\tut16 result = 0;\n\tut16 size = strlen (access_flags_str) + 1;\n\tchar *p_flags, *my_flags = malloc (size);\n\tRBinJavaAccessFlags *iter = NULL;\n\tif (size < 5 || !my_flags) {\n\t\tfree (my_flags);\n\t\treturn result;\n\t}\n\tmemcpy (my_flags, access_flags_str, size);\n\tp_flags = strtok (my_flags, \" \");\n\twhile (p_flags && access_flags) {\n\t\tint idx = 0;\n\t\tdo {\n\t\t\titer = &access_flags[idx];\n\t\t\tif (!iter || !iter->str) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (iter->len > 0 && iter->len != 16) {\n\t\t\t\tif (!strncmp (iter->str, p_flags, iter->len)) {\n\t\t\t\t\tresult |= iter->value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidx++;\n\t\t} while (access_flags[idx].str != NULL);\n\t\tp_flags = strtok (NULL, \" \");\n\t}\n\tfree (my_flags);\n\treturn result;\n}\n\nR_API RList *retrieve_all_access_string_and_value(RBinJavaAccessFlags *access_flags) {\n\tconst char *fmt = \"%s = 0x%04x\";\n\tRList *result = r_list_new ();\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\tresult->free = free;\n\tint i = 0;\n\tfor (i = 0; access_flags[i].str != NULL; i++) {\n\t\tchar *str = malloc (50);\n\t\tif (!str) {\n\t\t\tr_list_free (result);\n\t\t\treturn NULL;\n\t\t}\n\t\tsnprintf (str, 49, fmt, access_flags[i].str, access_flags[i].value);\n\t\tr_list_append (result, str);\n\t}\n\treturn result;\n}\n\nR_API char *retrieve_access_string(ut16 flags, RBinJavaAccessFlags *access_flags) {\n\tchar *outbuffer = NULL, *cur_pos = NULL;\n\tut16 i;\n\tut16 max_str_len = 0;\n\tfor (i = 0; access_flags[i].str != NULL; i++) {\n\t\tif (flags & access_flags[i].value) {\n\t\t\tmax_str_len += (strlen (access_flags[i].str) + 1);\n\t\t\tif (max_str_len < strlen (access_flags[i].str)) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\tmax_str_len++;\n\toutbuffer = (char *) malloc (max_str_len);\n\tif (outbuffer) {\n\t\tmemset (outbuffer, 0, max_str_len);\n\t\tcur_pos = outbuffer;\n\t\tfor (i = 0; access_flags[i].str != NULL; i++) {\n\t\t\tif (flags & access_flags[i].value) {\n\t\t\t\tut8 len = strlen (access_flags[i].str);\n\t\t\t\tconst char *the_string = access_flags[i].str;\n\t\t\t\tmemcpy (cur_pos, the_string, len);\n\t\t\t\tmemcpy (cur_pos + len, \" \", 1);\n\t\t\t\tcur_pos += len + 1;\n\t\t\t}\n\t\t}\n\t\tif (cur_pos != outbuffer) {\n\t\t\t*(cur_pos - 1) = 0;\n\t\t}\n\t}\n\treturn outbuffer;\n}\n\nR_API char *retrieve_method_access_string(ut16 flags) {\n\treturn retrieve_access_string (flags, METHOD_ACCESS_FLAGS);\n}\n\nR_API char *retrieve_field_access_string(ut16 flags) {\n\treturn retrieve_access_string (flags, FIELD_ACCESS_FLAGS);\n}\n\nR_API char *retrieve_class_method_access_string(ut16 flags) {\n\treturn retrieve_access_string (flags, CLASS_ACCESS_FLAGS);\n}\n\nR_API char *r_bin_java_build_obj_key(RBinJavaObj *bin) {\n\tchar *jvcname = NULL;\n\tchar *cname = r_bin_java_get_this_class_name (bin);\n\tut32 class_name_len = cname ? strlen (cname) : strlen (\"_unknown_\");\n\tjvcname = malloc (class_name_len + 8 + 30);\n\tif (cname) {\n\t\tsnprintf (jvcname, class_name_len + 30, \"%d.%s.class\", bin->id, cname);\n\t\tfree (cname);\n\t} else {\n\t\tsnprintf (jvcname, class_name_len + 30, \"%d._unknown_.class\", bin->id);\n\t}\n\treturn jvcname;\n}\n\nR_API int sdb_iterate_build_list(void *user, const char *k, const char *v) {\n\tRList *bin_objs_list = (RList *) user;\n\tsize_t value = (size_t) sdb_atoi (v);\n\tRBinJavaObj *bin_obj = NULL;\n\tIFDBG eprintf(\"Found %s == %\"PFMT64x \" bin_objs db\\n\", k, (ut64) value);\n\tif (value != 0 && value != (size_t) -1) {\n\t\tbin_obj = (RBinJavaObj *) value;\n\t\tr_list_append (bin_objs_list, bin_obj);\n\t}\n\treturn true;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_get_java_null_cp() {\n\tif (R_BIN_JAVA_NULL_TYPE_INITTED) {\n\t\treturn &R_BIN_JAVA_NULL_TYPE;\n\t}\n\tmemset (&R_BIN_JAVA_NULL_TYPE, 0, sizeof (R_BIN_JAVA_NULL_TYPE));\n\tR_BIN_JAVA_NULL_TYPE.metas = R_NEW0 (RBinJavaMetaInfo);\n\tif (!R_BIN_JAVA_NULL_TYPE.metas) {\n\t\treturn NULL;\n\t}\n\tmemset (R_BIN_JAVA_NULL_TYPE.metas, 0, sizeof (RBinJavaMetaInfo));\n\tR_BIN_JAVA_NULL_TYPE.metas->type_info = &R_BIN_JAVA_CP_METAS[0];\n\tR_BIN_JAVA_NULL_TYPE.metas->ord = 0;\n\tR_BIN_JAVA_NULL_TYPE.file_offset = 0;\n\tR_BIN_JAVA_NULL_TYPE_INITTED = true;\n\treturn &R_BIN_JAVA_NULL_TYPE;\n}\n\nR_API RBinJavaElementValueMetas *r_bin_java_get_ev_meta_from_tag(ut8 tag) {\n\tut16 i = 0;\n\tRBinJavaElementValueMetas *res = &R_BIN_JAVA_ELEMENT_VALUE_METAS[13];\n\tfor (i = 0; i < R_BIN_JAVA_ELEMENT_VALUE_METAS_SZ; i++) {\n\t\tif (tag == R_BIN_JAVA_ELEMENT_VALUE_METAS[i].tag) {\n\t\t\tres = &R_BIN_JAVA_ELEMENT_VALUE_METAS[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API ut8 r_bin_java_quick_check(ut8 expected_tag, ut8 actual_tag, ut32 actual_len, const char *name) {\n\tut8 res = 0;\n\tif (expected_tag > R_BIN_JAVA_CP_METAS_SZ) {\n\t\teprintf (\"Invalid tag '%d' expected 0x%02x for %s.\\n\", actual_tag, expected_tag, name);\n\t\tres = 1;\n\t} else if (expected_tag != actual_tag)  {\n\t\teprintf (\"Invalid tag '%d' expected 0x%02x for %s.\\n\", actual_tag, expected_tag, name);\n\t\tres = 1;\n\t} else if (actual_len < R_BIN_JAVA_CP_METAS[expected_tag].len)  {\n\t\teprintf (\"Unable to parse '%d' expected sz=0x%02x got 0x%02x for %s.\\n\",\n\t\t\tactual_tag, R_BIN_JAVA_CP_METAS[expected_tag].len, actual_len, name);\n\t\tres = 2;\n\t}\n\treturn res;\n}\n\nR_API ut64 r_bin_java_raw_to_long(const ut8 *raw, ut64 offset) {\n\treturn R_BIN_JAVA_LONG (raw, offset);\n}\n// yanked from careercup, because i am lazy:\n// 1) dont want to figure out how make radare use math library\n// 2) dont feel like figuring it out when google does it in O(1).\nR_API double my_pow(ut64 base, int exp) {\n\tut8 flag = 0;\n\tut64 res = 1;\n\tif (exp < 0) {\n\t\tflag = 1;\n\t\texp *= -1;\n\t}\n\twhile (exp) {\n\t\tif (exp & 1) {\n\t\t\tres *= base;\n\t\t}\n\t\texp >>= 1;\n\t\tbase *= base;\n\t\tIFDBG eprintf(\"Result: %\"PFMT64d \", base: %\"PFMT64d \", exp: %d\\n\", res, base, exp);\n\t}\n\tif (flag == 0) {\n\t\treturn 1.0 * res;\n\t}\n\treturn (1.0 / res);\n}\n\nR_API double r_bin_java_raw_to_double(const ut8 *raw, ut64 offset) {\n\tut64 bits = R_BIN_JAVA_LONG (raw, offset);\n\tint s = ((bits >> 63) == 0) ? 1 : -1;\n\tint e = (int) ((bits >> 52) & 0x7ffL);\n\tlong m = (e == 0) ?\n\t(bits & 0xfffffffffffffLL) << 1 :\n\t(bits & 0xfffffffffffffLL) | 0x10000000000000LL;\n\tdouble res = 0.0;\n\tIFDBG eprintf(\"Convert Long to Double: %08\"PFMT64x \"\\n\", bits);\n\tif (bits == 0x7ff0000000000000LL) {\n\t\treturn INFINITY;\n\t}\n\tif (bits == 0xfff0000000000000LL) {\n\t\treturn -INFINITY;\n\t}\n\tif (0x7ff0000000000001LL <= bits && bits <= 0x7fffffffffffffffLL) {\n\t\treturn NAN;\n\t}\n\tif (0xfff0000000000001LL <= bits && bits <= 0xffffffffffffffffLL) {\n\t\treturn NAN;\n\t}\n\tres = s * m * my_pow (2, e - 1075);// XXXX TODO Get double to work correctly here\n\tIFDBG eprintf(\"\tHigh-bytes = %02x %02x %02x %02x\\n\", raw[0], raw[1], raw[2], raw[3]);\n\tIFDBG eprintf(\"\tLow-bytes = %02x %02x %02x %02x\\n\", raw[4], raw[5], raw[6], raw[7]);\n\tIFDBG eprintf(\"Convert Long to Double s: %d, m: 0x%08lx, e: 0x%08x, res: %f\\n\", s, m, e, res);\n\treturn res;\n}\n\nR_API RBinJavaField *r_bin_java_read_next_method(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tut32 i, idx;\n\tconst ut8 *f_buf = buf + offset;\n\tut64 adv = 0;\n\tRBinJavaCPTypeObj *item = NULL;\n\tRBinJavaField *method;\n\tif (bin == NULL) {\n\t\treturn NULL;\n\t}\n\tif (offset + 8 >= len) {\n\t\treturn NULL;\n\t}\n\tmethod = (RBinJavaField *) R_NEW0 (RBinJavaField);\n\tif (method == NULL) {\n\t\teprintf (\"Unable to allocate memory for method information\\n\");\n\t\treturn NULL;\n\t}\n\tmethod->metas = (RBinJavaMetaInfo *) R_NEW0 (RBinJavaMetaInfo);\n\tif (method->metas == NULL) {\n\t\teprintf (\"Unable to allocate memory for meta information\\n\");\n\t\tfree (method);\n\t\treturn NULL;\n\t}\n\tmethod->file_offset = offset;\n\tmethod->flags = R_BIN_JAVA_USHORT (f_buf, 0);\n\tmethod->flags_str = retrieve_method_access_string (method->flags);\n\t// need to subtract 1 for the idx\n\tmethod->name_idx = R_BIN_JAVA_USHORT (f_buf, 2);\n\tmethod->descriptor_idx = R_BIN_JAVA_USHORT (f_buf, 4);\n\tmethod->attr_count = R_BIN_JAVA_USHORT (f_buf, 6);\n\tmethod->attributes = r_list_newf (r_bin_java_attribute_free);\n\tmethod->type = R_BIN_JAVA_FIELD_TYPE_METHOD;\n\tmethod->metas->ord = bin->method_idx;\n\tadv += 8;\n\tidx = method->name_idx;\n\titem = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tmethod->name = r_bin_java_get_utf8_from_bin_cp_list (bin, (ut32) (method->name_idx));\n\tIFDBG eprintf(\"Method name_idx: %d, which is: ord: %d, name: %s, value: %s\\n\", idx, item->metas->ord, ((RBinJavaCPTypeMetas *)item->metas->type_info)->name, method->name);\n\tif (method->name == NULL) {\n\t\tmethod->name = (char *) malloc (21);\n\t\tsnprintf ((char *) method->name, 20, \"sym.method_%08x\", method->metas->ord);\n\t\tIFDBG eprintf(\"r_bin_java_read_next_method: Unable to find the name for 0x%02x index.\\n\", method->name_idx);\n\t}\n\tidx = method->descriptor_idx;\n\titem = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tmethod->descriptor = r_bin_java_get_utf8_from_bin_cp_list (bin, (ut32) method->descriptor_idx);\n\tIFDBG eprintf(\"Method descriptor_idx: %d, which is: ord: %d, name: %s, value: %s\\n\", idx, item->metas->ord, ((RBinJavaCPTypeMetas *)item->metas->type_info)->name, method->descriptor);\n\tif (method->descriptor == NULL) {\n\t\tmethod->descriptor = r_str_dup (NULL, \"NULL\");\n\t\tIFDBG eprintf(\"r_bin_java_read_next_method: Unable to find the descriptor for 0x%02x index.\\n\", method->descriptor_idx);\n\t}\n\tIFDBG eprintf(\"Looking for a NameAndType CP with name_idx: %d descriptor_idx: %d\\n\", method->name_idx, method->descriptor_idx);\n\tmethod->field_ref_cp_obj = r_bin_java_find_cp_ref_info_from_name_and_type (bin, method->name_idx, method->descriptor_idx);\n\tif (method->field_ref_cp_obj) {\n\t\tIFDBG eprintf(\"Found the obj.\\n\");\n\t\titem = r_bin_java_get_item_from_bin_cp_list (bin, method->field_ref_cp_obj->info.cp_method.class_idx);\n\t\tIFDBG eprintf(\"Method class reference value: %d, which is: ord: %d, name: %s\\n\", method->field_ref_cp_obj->info.cp_method.class_idx, item->metas->ord, ((RBinJavaCPTypeMetas *)item->metas->type_info)->name);\n\t\tmethod->class_name = r_bin_java_get_item_name_from_bin_cp_list (bin, item);\n\t\tIFDBG eprintf(\"Method requesting ref_cp_obj the following which is: ord: %d, name: %s\\n\", method->field_ref_cp_obj->metas->ord, ((RBinJavaCPTypeMetas *)method->field_ref_cp_obj->metas->type_info)->name);\n\t\tIFDBG eprintf(\"MethodRef class name resolves to: %s\\n\", method->class_name);\n\t\tif (method->class_name == NULL) {\n\t\t\tmethod->class_name = r_str_dup (NULL, \"NULL\");\n\t\t}\n\t} else {\n\t\t// XXX - default to this class?\n\t\tmethod->field_ref_cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, bin->cf2.this_class);\n\t\tmethod->class_name = r_bin_java_get_item_name_from_bin_cp_list (bin, method->field_ref_cp_obj);\n\t}\n\tIFDBG eprintf(\"Parsing %s(%s)\\n\", method->name, method->descriptor);\n\tif (method->attr_count > 0) {\n\t\tmethod->attr_offset = adv + offset;\n\t\tRBinJavaAttrInfo *attr = NULL;\n\t\tfor (i = 0; i < method->attr_count; i++) {\n\t\t\tattr = r_bin_java_read_next_attr (bin, adv + offset, buf, len);\n\t\t\tif (!attr) {\n\t\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Method Attribute: %d.\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((r_bin_java_get_attr_type_by_name (attr->name))->type == R_BIN_JAVA_ATTR_TYPE_CODE_ATTR) {\n\t\t\t\t// This is necessary for determing the appropriate number of bytes when readin\n\t\t\t\t// uoffset, ustack, ulocalvar values\n\t\t\t\tbin->cur_method_code_length = attr->info.code_attr.code_length;\n\t\t\t\tbin->offset_sz = 2;// (attr->info.code_attr.code_length > 65535) ? 4 : 2;\n\t\t\t\tbin->ustack_sz = 2;// (attr->info.code_attr.max_stack > 65535) ? 4 : 2;\n\t\t\t\tbin->ulocalvar_sz = 2;// (attr->info.code_attr.max_locals > 65535) ? 4 : 2;\n\t\t\t}\n\t\t\tIFDBG eprintf(\"Parsing @ 0x%\"PFMT64x \" (%s) = 0x%\"PFMT64x \" bytes\\n\", attr->file_offset, attr->name, attr->size);\n\t\t\tr_list_append (method->attributes, attr);\n\t\t\tadv += attr->size;\n\t\t\tif (adv + offset >= len) {\n\t\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Method Attribute: %d.\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmethod->size = adv;\n\t// reset after parsing the method attributes\n\tIFDBG eprintf(\"Parsing @ 0x%\"PFMT64x \" %s(%s) = 0x%\"PFMT64x \" bytes\\n\", method->file_offset, method->name, method->descriptor, method->size);\n\treturn method;\n}\n\nR_API RBinJavaField *r_bin_java_read_next_field(RBinJavaObj *bin, const ut64 offset, const ut8 *buffer, const ut64 len) {\n\tRBinJavaAttrInfo *attr;\n\tut32 i, idx;\n\tut8 buf[8];\n\tRBinJavaCPTypeObj *item = NULL;\n\tconst ut8 *f_buf = buffer + offset;\n\tut64 adv = 0;\n\tRBinJavaField *field;\n\tif (bin == NULL) {\n\t\treturn NULL;\n\t}\n\tif (offset + 8 >= len) {\n\t\treturn NULL;\n\t}\n\tfield = (RBinJavaField *) R_NEW0 (RBinJavaField);\n\tif (field == NULL) {\n\t\teprintf (\"Unable to allocate memory for field information\\n\");\n\t\treturn NULL;\n\t}\n\tfield->metas = (RBinJavaMetaInfo *) R_NEW0 (RBinJavaMetaInfo);\n\tif (field->metas == NULL) {\n\t\teprintf (\"Unable to allocate memory for meta information\\n\");\n\t\tfree (field);\n\t\treturn NULL;\n\t}\n\tmemcpy (buf, f_buf, 8);\n\tfield->file_offset = offset;\n\tfield->flags = R_BIN_JAVA_USHORT (buf, 0);\n\tfield->flags_str = retrieve_field_access_string (field->flags);\n\tfield->name_idx = R_BIN_JAVA_USHORT (buf, 2);\n\tfield->descriptor_idx = R_BIN_JAVA_USHORT (buf, 4);\n\tfield->attr_count = R_BIN_JAVA_USHORT (buf, 6);\n\tfield->attributes = r_list_newf (r_bin_java_attribute_free);\n\tfield->type = R_BIN_JAVA_FIELD_TYPE_FIELD;\n\tadv += 8;\n\tfield->metas->ord = bin->field_idx;\n\n\tidx = field->name_idx;\n\titem = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tfield->name = r_bin_java_get_utf8_from_bin_cp_list (bin, (ut32) (field->name_idx));\n\tIFDBG eprintf(\"Field name_idx: %d, which is: ord: %d, name: %s, value: %s\\n\", idx, item->metas->ord, ((RBinJavaCPTypeMetas *)item->metas->type_info)->name, field->name);\n\tif (field->name == NULL) {\n\t\tfield->name = (char *) malloc (21);\n\t\tsnprintf ((char *) field->name, 20, \"sym.field_%08x\", field->metas->ord);\n\t\tIFDBG eprintf(\"r_bin_java_read_next_field: Unable to find the name for 0x%02x index.\\n\", field->name_idx);\n\t}\n\tidx = field->descriptor_idx;\n\titem = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tfield->descriptor = r_bin_java_get_utf8_from_bin_cp_list (bin, (ut32) field->descriptor_idx);\n\tIFDBG eprintf(\"Field descriptor_idx: %d, which is: ord: %d, name: %s, value: %s\\n\", idx, item->metas->ord, ((RBinJavaCPTypeMetas *)item->metas->type_info)->name, field->descriptor);\n\tif (field->descriptor == NULL) {\n\t\tfield->descriptor = r_str_dup (NULL, \"NULL\");\n\t\tIFDBG eprintf(\"r_bin_java_read_next_field: Unable to find the descriptor for 0x%02x index.\\n\", field->descriptor_idx);\n\t}\n\tIFDBG eprintf(\"Looking for a NameAndType CP with name_idx: %d descriptor_idx: %d\\n\", field->name_idx, field->descriptor_idx);\n\tfield->field_ref_cp_obj = r_bin_java_find_cp_ref_info_from_name_and_type (bin, field->name_idx, field->descriptor_idx);\n\tif (field->field_ref_cp_obj) {\n\t\tIFDBG eprintf(\"Found the obj.\\n\");\n\t\titem = r_bin_java_get_item_from_bin_cp_list (bin, field->field_ref_cp_obj->info.cp_field.class_idx);\n\t\tIFDBG eprintf(\"Field class reference value: %d, which is: ord: %d, name: %s\\n\", field->field_ref_cp_obj->info.cp_field.class_idx, item->metas->ord, ((RBinJavaCPTypeMetas *)item->metas->type_info)->name);\n\t\tfield->class_name = r_bin_java_get_item_name_from_bin_cp_list (bin, item);\n\t\tIFDBG eprintf(\"Field requesting ref_cp_obj the following which is: ord: %d, name: %s\\n\", field->field_ref_cp_obj->metas->ord, ((RBinJavaCPTypeMetas *)field->field_ref_cp_obj->metas->type_info)->name);\n\t\tIFDBG eprintf(\"FieldRef class name resolves to: %s\\n\", field->class_name);\n\t\tif (field->class_name == NULL) {\n\t\t\tfield->class_name = r_str_dup (NULL, \"NULL\");\n\t\t}\n\t} else {\n\t\t// XXX - default to this class?\n\t\tfield->field_ref_cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, bin->cf2.this_class);\n\t\tfield->class_name = r_bin_java_get_item_name_from_bin_cp_list (bin, field->field_ref_cp_obj);\n\t}\n\tIFDBG eprintf(\"Parsing %s(%s)\", field->name, field->descriptor);\n\tif (field->attr_count > 0) {\n\t\tfield->attr_offset = adv + offset;\n\t\tfor (i = 0; i < field->attr_count && offset + adv < len; i++) {\n\t\t\tattr = r_bin_java_read_next_attr (bin, offset + adv, buffer, len);\n\t\t\tif (!attr) {\n\t\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Field Attribute: %d.\\n\", i);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif ((r_bin_java_get_attr_type_by_name (attr->name))->type == R_BIN_JAVA_ATTR_TYPE_CODE_ATTR) {\n\t\t\t\t// This is necessary for determing the appropriate number of bytes when readin\n\t\t\t\t// uoffset, ustack, ulocalvar values\n\t\t\t\tbin->cur_method_code_length = attr->info.code_attr.code_length;\n\t\t\t\tbin->offset_sz = 2;// (attr->info.code_attr.code_length > 65535) ? 4 : 2;\n\t\t\t\tbin->ustack_sz = 2;// (attr->info.code_attr.max_stack > 65535) ? 4 : 2;\n\t\t\t\tbin->ulocalvar_sz = 2;// (attr->info.code_attr.max_locals > 65535) ? 4 : 2;\n\t\t\t}\n\t\t\tr_list_append (field->attributes, attr);\n\t\t\tadv += attr->size;\n\t\t\tif (adv + offset >= len) {\n\t\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Field Attribute: %d.\\n\", i);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\tfield->size = adv;\n\treturn field;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_clone_cp_idx(RBinJavaObj *bin, ut32 idx) {\n\tRBinJavaCPTypeObj *obj = NULL;\n\tif (bin) {\n\t\tobj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\t}\n\treturn r_bin_java_clone_cp_item (obj);\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_clone_cp_item(RBinJavaCPTypeObj *obj) {\n\tRBinJavaCPTypeObj *clone_obj = NULL;\n\tif (obj == NULL) {\n\t\treturn clone_obj;\n\t}\n\tclone_obj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (clone_obj) {\n\t\tmemcpy (clone_obj, obj, sizeof (RBinJavaCPTypeObj));\n\t\tclone_obj->metas = (RBinJavaMetaInfo *) R_NEW0 (RBinJavaMetaInfo);\n\t\tclone_obj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[clone_obj->tag];\n\t\tclone_obj->name = strdup (obj->name? obj->name: \"unk\");\n\t\tif (obj->tag == R_BIN_JAVA_CP_UTF8) {\n\t\t\tclone_obj->info.cp_utf8.bytes = (ut8 *) malloc (obj->info.cp_utf8.length + 1);\n\t\t\tif (clone_obj->info.cp_utf8.bytes) {\n\t\t\t\tmemcpy (clone_obj->info.cp_utf8.bytes, obj->info.cp_utf8.bytes, clone_obj->info.cp_utf8.length);\n\t\t\t} else {\n\t\t\t\t// TODO: eprintf allocation error\n\t\t\t}\n\t\t}\n\t}\n\treturn clone_obj;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_read_next_constant_pool_item(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, ut64 len) {\n\tRBinJavaCPTypeMetas *java_constant_info = NULL;\n\tut8 tag = 0;\n\tut64 buf_sz = 0;\n\tut8 *cp_buf = NULL;\n\tut32 str_len = 0;\n\tRBinJavaCPTypeObj *java_obj = NULL;\n\ttag = buf[offset];\n\tif (tag > R_BIN_JAVA_CP_METAS_SZ) {\n\t\teprintf (\"Invalid tag '%d' at offset 0x%08\"PFMT64x \"\\n\", tag, (ut64) offset);\n\t\treturn NULL;\n#if 0\n\t\tjava_obj = r_bin_java_unknown_cp_new (bin, &tag, 1);\n\t\tif (java_obj != NULL && java_obj->metas != NULL) {\n\t\t\tjava_obj->file_offset = offset;\n\t\t\tjava_obj->loadaddr = bin->loadaddr;\n\t\t}\n\t\treturn NULL; // early error to avoid future overflows\n\t\t// return java_obj;\n#endif\n\t}\n\tjava_constant_info = &R_BIN_JAVA_CP_METAS[tag];\n\tif (java_constant_info->tag == 0 || java_constant_info->tag == 2) {\n\t\treturn java_obj;\n\t}\n\tbuf_sz += java_constant_info->len;\n\tif (java_constant_info->tag == 1) {\n\t\tif (offset + 32 < len) {\n\t\t\tstr_len = R_BIN_JAVA_USHORT (buf, offset + 1);\n\t\t\tbuf_sz += str_len;\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tcp_buf = calloc (buf_sz, 1);\n\tif (!cp_buf) {\n\t\treturn java_obj;\n\t}\n\tif (offset + buf_sz < len) {\n\t\tmemcpy (cp_buf, (ut8 *) buf + offset, buf_sz);\n\t\tIFDBG eprintf(\"Parsed the tag '%d':%s and create object from offset 0x%08\"PFMT64x \".\\n\", tag, R_BIN_JAVA_CP_METAS[tag].name, offset);\n\t\tjava_obj = (*java_constant_info->allocs->new_obj)(bin, cp_buf, buf_sz);\n\t\tif (java_obj != NULL && java_obj->metas != NULL) {\n\t\t\tjava_obj->file_offset = offset;\n\t\t\t// IFDBG eprintf (\"java_obj->file_offset = 0x%08\"PFMT64x\".\\n\",java_obj->file_offset);\n\t\t} else if (!java_obj) {\n\t\t\teprintf (\"Unable to parse the tag '%d' and create valid object.\\n\", tag);\n\t\t} else if (!java_obj->metas) {\n\t\t\teprintf (\"Unable to parse the tag '%d' and create valid object.\\n\", tag);\n\t\t} else {\n\t\t\teprintf (\"Failed to set the java_obj->metas-file_offset for '%d' offset is(0x%08\"PFMT64x \").\\n\", tag, offset);\n\t\t}\n\t}\n\tfree (cp_buf);\n\treturn java_obj;\n}\n\nR_API RBinJavaInterfaceInfo *r_bin_java_read_next_interface_item(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tut8 idx[2] = {\n\t\t0\n\t};\n\tRBinJavaInterfaceInfo *ifobj;\n\tconst ut8 *if_buf = buf + offset;\n\tif (offset + 2 >= len) {\n\t\treturn NULL;\n\t}\n\tmemcpy (&idx, if_buf, 2);\n\tifobj = r_bin_java_interface_new (bin, if_buf, len - offset);\n\tif (ifobj) {\n\t\tifobj->file_offset = offset;\n\t}\n\treturn ifobj;\n}\n// R_API void addrow (RBinJavaObj *bin, int addr, int line) {\n// int n = bin->lines.count++;\n//// XXX. possible memleak\n// bin->lines.addr = realloc (bin->lines.addr, sizeof (int)*n+1);\n// bin->lines.addr[n] = addr;\n// bin->lines.line = realloc (bin->lines.line, sizeof (int)*n+1);\n// bin->lines.line[n] = line;\n// }\n// R_API struct r_bin_java_cp_item_t* r_bin_java_get_item_from_cp_CP(RBinJavaObj *bin, int i) {\n// return (i<0||i>bin->cf.cp_count)? &cp_null_item: &bin->cp_items[i];\n// }\n\nR_API char *r_bin_java_get_utf8_from_bin_cp_list(RBinJavaObj *bin, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: new char* for caller to free.\n\t*/\n\tif (bin == NULL) {\n\t\treturn NULL;\n\t}\n\treturn r_bin_java_get_utf8_from_cp_item_list (bin->cp_list, idx);\n}\n\nR_API ut32 r_bin_java_get_utf8_len_from_bin_cp_list(RBinJavaObj *bin, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: new char* for caller to free.\n\t*/\n\tif (bin == NULL) {\n\t\treturn 0;\n\t}\n\treturn r_bin_java_get_utf8_len_from_cp_item_list (bin->cp_list, idx);\n}\n\nR_API char *r_bin_java_get_name_from_bin_cp_list(RBinJavaObj *bin, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: new char* for caller to free.\n\t*/\n\tif (bin == NULL) {\n\t\treturn NULL;\n\t}\n\treturn r_bin_java_get_name_from_cp_item_list (bin->cp_list, idx);\n}\n\nR_API char *r_bin_java_get_desc_from_bin_cp_list(RBinJavaObj *bin, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: new char* for caller to free.\n\t*/\n\tif (bin == NULL) {\n\t\treturn NULL;\n\t}\n\treturn r_bin_java_get_desc_from_cp_item_list (bin->cp_list, idx);\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_get_item_from_bin_cp_list(RBinJavaObj *bin, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: RBinJavaObj* (user does NOT free).\n\t*/\n\tif (bin == NULL) {\n\t\treturn NULL;\n\t}\n\tif (idx > bin->cp_count || idx == 0) {\n\t\treturn r_bin_java_get_java_null_cp ();\n\t}\n\treturn r_bin_java_get_item_from_cp_item_list (bin->cp_list, idx);\n}\n\nR_API char *r_bin_java_get_item_name_from_bin_cp_list(RBinJavaObj *bin, RBinJavaCPTypeObj *obj) {\n\tchar *res = NULL;\n\t/*\n\tGiven a constant poool object Class, FieldRef, MethodRef, or InterfaceMethodRef\n\treturn the actual descriptor string.\n\t@param cp_list: RList of RBinJavaCPTypeObj *\n\t@param obj object to look up the name for\n\t@rvalue char* (user frees) or NULL\n\t*/\n\tif (bin && obj) {\n\t\tres = r_bin_java_get_item_name_from_cp_item_list (\n\t\t\tbin->cp_list, obj, MAX_CPITEMS);\n\t}\n\treturn res;\n}\n\nR_API char *r_bin_java_get_item_desc_from_bin_cp_list(RBinJavaObj *bin, RBinJavaCPTypeObj *obj) {\n\t/*\n\tGiven a constant poool object Class, FieldRef, MethodRef, or InterfaceMethodRef\n\treturn the actual descriptor string.\n\t@param cp_list: RList of RBinJavaCPTypeObj *\n\t@param obj object to look up the name for\n\t@rvalue char* (user frees) or NULL\n\t*/\n\tif (bin == NULL) {\n\t\treturn NULL;\n\t}\n\treturn r_bin_java_get_item_desc_from_cp_item_list (bin->cp_list, obj, MAX_CPITEMS);\n}\n\nR_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: new char* for caller to free.\n\t*/\n\tchar *value = NULL;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *item = NULL;\n\tif (cp_list == NULL) {\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);\n\tif (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {\n\t\tvalue = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);\n\t}\n\tif (value == NULL) {\n\t\tr_list_foreach (cp_list, iter, item) {\n\t\t\tif (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {\n\t\t\t\tvalue = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API ut32 r_bin_java_get_utf8_len_from_cp_item_list(RList *cp_list, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: new ut32 .\n\t*/\n\tut32 value = -1;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *item = NULL;\n\tif (cp_list == NULL) {\n\t\treturn 0;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);\n\tif (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {\n\t\tvalue = item->info.cp_utf8.length;\n\t}\n\tif (value == -1) {\n\t\tr_list_foreach (cp_list, iter, item) {\n\t\t\tif (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {\n\t\t\t\tvalue = item->info.cp_utf8.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp_item_list(RList *cp_list, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\trvalue: RBinJavaObj *\n\t*/\n\tRBinJavaCPTypeObj *item = NULL;\n\tif (cp_list == NULL) {\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);\n\treturn item;\n}\n\nR_API char *r_bin_java_get_item_name_from_cp_item_list(RList *cp_list, RBinJavaCPTypeObj *obj, int depth) {\n\t/*\n\tGiven a constant poool object Class, FieldRef, MethodRef, or InterfaceMethodRef\n\treturn the actual descriptor string.\n\t@param cp_list: RList of RBinJavaCPTypeObj *\n\t@param obj object to look up the name for\n\t@rvalue ut8* (user frees) or NULL\n\t*/\n\tif (obj == NULL || cp_list == NULL || depth < 0) {\n\t\treturn NULL;\n\t}\n\tswitch (obj->tag) {\n\tcase R_BIN_JAVA_CP_NAMEANDTYPE:\n\t\treturn r_bin_java_get_utf8_from_cp_item_list (\n\t\t\tcp_list, obj->info.cp_name_and_type.name_idx);\n\tcase R_BIN_JAVA_CP_CLASS:\n\t\treturn r_bin_java_get_utf8_from_cp_item_list (\n\t\t\tcp_list, obj->info.cp_class.name_idx);\n\t// XXX - Probably not good form, but they are the same memory structure\n\tcase R_BIN_JAVA_CP_FIELDREF:\n\tcase R_BIN_JAVA_CP_INTERFACEMETHOD_REF:\n\tcase R_BIN_JAVA_CP_METHODREF:\n\t\tobj = r_bin_java_get_item_from_cp_item_list (\n\t\t\tcp_list, obj->info.cp_method.name_and_type_idx);\n\t\treturn r_bin_java_get_item_name_from_cp_item_list (\n\t\t\tcp_list, obj, depth - 1);\n\tdefault:\n\t\treturn NULL;\n\tcase 0:\n\t\tIFDBG eprintf(\"Invalid 0 tag in the constant pool\\n\");\n\t\treturn NULL;\n\t}\n\treturn NULL;\n}\n\nR_API char *r_bin_java_get_name_from_cp_item_list(RList *cp_list, ut64 idx) {\n\t/*\n\tGiven a constant poool object Class, FieldRef, MethodRef, or InterfaceMethodRef\n\treturn the actual descriptor string.\n\t@param cp_list: RList of RBinJavaCPTypeObj *\n\t@param obj object to look up the name for\n\t@rvalue ut8* (user frees) or NULL\n\t*/\n\tRBinJavaCPTypeObj *obj = r_bin_java_get_item_from_cp_item_list (\n\t\tcp_list, idx);\n\tif (obj && cp_list) {\n\t\treturn r_bin_java_get_item_name_from_cp_item_list (\n\t\t\tcp_list, obj, MAX_CPITEMS);\n\t}\n\treturn NULL;\n}\n\nR_API char *r_bin_java_get_item_desc_from_cp_item_list(RList *cp_list, RBinJavaCPTypeObj *obj, int depth) {\n\t/*\n\tGiven a constant poool object FieldRef, MethodRef, or InterfaceMethodRef\n\treturn the actual descriptor string.\n\t@rvalue ut8* (user frees) or NULL\n\t*/\n\tif (!obj || !cp_list || depth < 0) {\n\t\treturn NULL;\n\t}\n\tswitch (obj->tag) {\n\tcase R_BIN_JAVA_CP_NAMEANDTYPE:\n\t\treturn r_bin_java_get_utf8_from_cp_item_list (cp_list,\n\t\t\tobj->info.cp_name_and_type.descriptor_idx);\n\t// XXX - Probably not good form, but they are the same memory structure\n\tcase R_BIN_JAVA_CP_FIELDREF:\n\tcase R_BIN_JAVA_CP_INTERFACEMETHOD_REF:\n\tcase R_BIN_JAVA_CP_METHODREF:\n\t\tobj = r_bin_java_get_item_from_cp_item_list (cp_list,\n\t\t\tobj->info.cp_method.name_and_type_idx);\n\t\treturn r_bin_java_get_item_desc_from_cp_item_list (\n\t\t\tcp_list, obj, depth - 1);\n\tdefault:\n\t\treturn NULL;\n\t}\n\treturn NULL;\n}\n\nR_API char *r_bin_java_get_desc_from_cp_item_list(RList *cp_list, ut64 idx) {\n\t/*\n\tGiven a constant poool object FieldRef, MethodRef, or InterfaceMethodRef\n\treturn the actual descriptor string.\n\t@rvalue ut8* (user frees) or NULL\n\t*/\n\tRBinJavaCPTypeObj *obj = r_bin_java_get_item_from_cp_item_list (cp_list, idx);\n\tif (cp_list == NULL) {\n\t\treturn NULL;\n\t}\n\treturn r_bin_java_get_item_desc_from_cp_item_list (cp_list, obj, MAX_CPITEMS);\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_get_method_code_attribute(const RBinJavaField *method) {\n\t/*\n\tSearch through a methods attributes and return the code attr.\n\trvalue: RBinJavaAttrInfo* if found otherwise NULL.\n\t*/\n\tRBinJavaAttrInfo *res = NULL, *attr = NULL;\n\tRListIter *iter;\n\tif (method) {\n\t\tr_list_foreach (method->attributes, iter, attr) {\n\t\t\tif (attr && (attr->type == R_BIN_JAVA_ATTR_TYPE_CODE_ATTR)) {\n\t\t\t\tres = attr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_get_attr_from_field(RBinJavaField *field, R_BIN_JAVA_ATTR_TYPE attr_type, ut32 pos) {\n\t/*\n\tSearch through the Attribute list for the given type starting at position pos.\n\trvalue: NULL or the first occurrence of attr_type after pos\n\t*/\n\tRBinJavaAttrInfo *attr = NULL, *item;\n\tRListIter *iter;\n\tut32 i = 0;\n\tif (field) {\n\t\tr_list_foreach (field->attributes, iter, item) {\n\t\t\t// Note the increment happens after the comparison\n\t\t\tif ((i++) >= pos) {\n\t\t\t\tif (item && (item->type == attr_type)) {\n\t\t\t\t\tattr = item;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn attr;\n}\n\nR_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tut8 *attr_buf = NULL;\n\tint pending = len - offset;\n\tconst ut8 *a_buf = offset + buf;\n\tattr_buf = (ut8 *) calloc (pending + 1, 1);\n\tif (attr_buf == NULL) {\n\t\teprintf (\"Unable to allocate enough bytes (0x%04\"PFMT64x\n\t\t\t\") to read in the attribute.\\n\", sz);\n\t\treturn attr_buf;\n\t}\n\tmemcpy (attr_buf, a_buf, pending); // sz+1);\n\treturn attr_buf;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_default_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\t// NOTE: this function receives the buffer offset in the original buffer,\n\t// but the buffer is already point to that particular offset.\n\t// XXX - all the code that relies on this function should probably be modified\n\t// so that the original buffer pointer is passed in and then the buffer+buf_offset\n\t// points to the correct location.\n\tRBinJavaAttrInfo *attr = R_NEW0 (RBinJavaAttrInfo);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrMetas *type_info = NULL;\n\tattr->metas = R_NEW0 (RBinJavaMetaInfo);\n\tif (attr->metas == NULL) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tattr->file_offset = buf_offset;\n\tattr->name_idx = R_BIN_JAVA_USHORT (buffer, 0);\n\tattr->length = R_BIN_JAVA_UINT (buffer, 2);\n\tattr->size = R_BIN_JAVA_UINT (buffer, 2) + 6;\n\tattr->name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->name_idx);\n\tif (attr->name == NULL) {\n\t\t// Something bad has happened\n\t\tattr->name = r_str_dup (NULL, \"NULL\");\n\t\teprintf (\"r_bin_java_default_attr_new: Unable to find the name for %d index.\\n\", attr->name_idx);\n\t}\n\ttype_info = r_bin_java_get_attr_type_by_name (attr->name);\n\tattr->metas->ord = (R_BIN_JAVA_GLOBAL_BIN->attr_idx++);\n\tattr->metas->type_info = (void *) type_info;\n\t// IFDBG eprintf (\"\tAddrs for type_info [tag=%d]: 0x%08\"PFMT64x\"\\n\", type_val, &attr->metas->type_info);\n\treturn attr;\n}\n\nR_API RBinJavaAttrMetas *r_bin_java_get_attr_type_by_name(const char *name) {\n\t// TODO: use sdb/hashtable here\n\tint i;\n\tfor (i = 0; i < RBIN_JAVA_ATTRS_METAS_SZ; i++) {\n\t\tif (!strcmp ((const char *) name, RBIN_JAVA_ATTRS_METAS[i].name)) {\n\t\t\treturn &RBIN_JAVA_ATTRS_METAS[i];\n\t\t}\n\t}\n\treturn &RBIN_JAVA_ATTRS_METAS[R_BIN_JAVA_ATTR_TYPE_UNKNOWN_ATTR];\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_read_next_attr(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 buf_len) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tut32 sz = 0;\n\tut8 *buffer = NULL;\n\tconst ut8 *a_buf = offset + buf;\n\tut8 attr_idx_len = 6;\n\tif (offset + 6 > buf_len) {\n\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile in Attribute offset \"\n\t\t\t\"(0x%\"PFMT64x \") > len  of remaining bytes (0x%\"PFMT64x \").\\n\", offset, buf_len);\n\t\treturn NULL;\n\t}\n\t// ut16 attr_idx, ut32 length of attr.\n\tsz = R_BIN_JAVA_UINT (a_buf, 2) + attr_idx_len; // r_bin_java_read_int (bin, buf_offset+2) + attr_idx_len;\n\tif (sz + offset > buf_len) {\n\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile in Attribute len \"\n\t\t\t\"(0x%x) + offset (0x%\"PFMT64x \") exceeds length of buffer (0x%\"PFMT64x \").\\n\",\n\t\t\tsz, offset, buf_len);\n\t\treturn NULL;\n\t}\n\t// when reading the attr bytes, need to also\n\t// include the initial 6 bytes, which\n\t// are not included in the attribute length\n\t// ,\n\t// sz, buf_offset, buf_offset+sz);\n\tbuffer = r_bin_java_get_attr_buf (bin, sz, offset, buf, buf_len);\n\t// printf (\"%d %d %d\\n\", sz, buf_len, offset);\n\tif (offset < buf_len) {\n\t\tattr = r_bin_java_read_next_attr_from_buffer (buffer, buf_len - offset, offset);\n\t\tfree (buffer);\n\n\t\tif (!attr) {\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->size = sz;\n\t} else {\n\t\teprintf (\"IS OOB\\n\");\n\t}\n\treturn attr;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_read_next_attr_from_buffer(ut8 *buffer, st64 sz, st64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tchar *name = NULL;\n\tut64 offset = 0;\n\tut16 name_idx;\n\tst64 nsz;\n\tRBinJavaAttrMetas *type_info = NULL;\n\n\tif (!buffer || ((int) sz) < 4 || buf_offset < 0) {\n\t\teprintf (\"r_bin_Java_read_next_attr_from_buffer: invalid buffer size %d\\n\", (int) sz);\n\t\treturn NULL;\n\t}\n\tname_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tnsz = R_BIN_JAVA_UINT (buffer, offset);\n\toffset += 4;\n\tname = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, name_idx);\n\tif (!name) {\n\t\tname = strdup (\"unknown\");\n\t}\n\tIFDBG eprintf(\"r_bin_java_read_next_attr: name_idx = %d is %s\\n\", name_idx, name);\n\ttype_info = r_bin_java_get_attr_type_by_name (name);\n\tif (type_info) {\n\t\tIFDBG eprintf(\"Typeinfo: %s, was %s\\n\", type_info->name, name);\n\t\t// printf (\"SZ %d %d %d\\n\", nsz, sz, buf_offset);\n\t\tif (nsz > sz) {\n\t\t\tfree (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((attr = type_info->allocs->new_obj (buffer, nsz, buf_offset))) {\n\t\t\tattr->metas->ord = (R_BIN_JAVA_GLOBAL_BIN->attr_idx++);\n\t\t}\n\t} else {\n\t\teprintf (\"r_bin_java_read_next_attr_from_buffer: Cannot find type_info for %s\\n\", name);\n\t}\n\tfree (name);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_read_class_file2(RBinJavaObj *bin, const ut64 offset, const ut8 *obuf, ut64 len) {\n\tconst ut8 *cf2_buf = obuf + offset;\n\tRBinJavaCPTypeObj *this_class_cp_obj = NULL;\n\tIFDBG eprintf(\"\\n0x%\"PFMT64x \" Offset before reading the cf2 structure\\n\", offset);\n\t/*\n\tReading the following fields:\n\tut16 access_flags;\n\tut16 this_class;\n\tut16 super_class;\n\t*/\n\tif (cf2_buf + 6 > obuf + len) {\n\t\treturn 0;\n\t}\n\tbin->cf2.cf2_size = 6;\n\tbin->cf2.access_flags = R_BIN_JAVA_USHORT (cf2_buf, 0);\n\tbin->cf2.this_class = R_BIN_JAVA_USHORT (cf2_buf, 2);\n\tbin->cf2.super_class = R_BIN_JAVA_USHORT (cf2_buf, 4);\n\tfree (bin->cf2.flags_str);\n\tfree (bin->cf2.this_class_name);\n\tbin->cf2.flags_str = retrieve_class_method_access_string (bin->cf2.access_flags);\n\tthis_class_cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, bin->cf2.this_class);\n\tbin->cf2.this_class_name = r_bin_java_get_item_name_from_bin_cp_list (bin, this_class_cp_obj);\n\tIFDBG eprintf(\"This class flags are: %s\\n\", bin->cf2.flags_str);\n\treturn bin->cf2.cf2_size;\n}\n\nR_API ut64 r_bin_java_parse_cp_pool(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tint ord = 0;\n\tut64 adv = 0;\n\tRBinJavaCPTypeObj *obj = NULL;\n\tconst ut8 *cp_buf = buf + offset;\n\tr_list_free (bin->cp_list);\n\tbin->cp_list = r_list_newf (r_bin_java_constant_pool);\n\tbin->cp_offset = offset;\n\tmemcpy ((char *) &bin->cp_count, cp_buf, 2);\n\tbin->cp_count = R_BIN_JAVA_USHORT (cp_buf, 0) - 1;\n\tadv += 2;\n\tIFDBG eprintf(\"ConstantPoolCount %d\\n\", bin->cp_count);\n\tr_list_append (bin->cp_list, r_bin_java_get_java_null_cp ());\n\tfor (ord = 1, bin->cp_idx = 0; bin->cp_idx < bin->cp_count && adv < len; ord++, bin->cp_idx++) {\n\t\tobj = r_bin_java_read_next_constant_pool_item (bin, offset + adv, buf, len);\n\t\tif (obj) {\n\t\t\t// IFDBG eprintf (\"SUCCESS Read ConstantPoolItem %d\\n\", i);\n\t\t\tobj->metas->ord = ord;\n\t\t\tobj->idx = ord;\n\t\t\tr_list_append (bin->cp_list, obj);\n\t\t\tif (obj->tag == R_BIN_JAVA_CP_LONG || obj->tag == R_BIN_JAVA_CP_DOUBLE) {\n\t\t\t\t// i++;\n\t\t\t\tord++;\n\t\t\t\tbin->cp_idx++;\n\t\t\t\tr_list_append (bin->cp_list, &R_BIN_JAVA_NULL_TYPE);\n\t\t\t}\n\n\t\t\tIFDBG ((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->print_summary (obj);\n\t\t\tadv += ((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->calc_size (obj);\n\t\t\tif (offset + adv > len) {\n\t\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Constant Pool Object: %d.\\n\", ord);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tIFDBG eprintf(\"Failed to read ConstantPoolItem %d\\n\", bin->cp_idx);\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Update the imports\n\tr_bin_java_set_imports (bin);\n\tbin->cp_size = adv;\n\treturn bin->cp_size;\n}\n\nR_API ut64 r_bin_java_parse_interfaces(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tint i = 0;\n\tut64 adv = 0;\n\tRBinJavaInterfaceInfo *interfaces_obj;\n\tconst ut8 *if_buf = buf + offset;\n\tbin->cp_offset = offset;\n\tbin->interfaces_offset = offset;\n\tr_list_free (bin->interfaces_list);\n\tbin->interfaces_list = r_list_newf (r_bin_java_interface_free);\n\tif (offset + 2 > len) {\n\t\tbin->interfaces_size = 0;\n\t\treturn 0;\n\t}\n\tbin->interfaces_count = R_BIN_JAVA_USHORT (if_buf, 0);\n\tadv += 2;\n\tIFDBG eprintf(\"Interfaces count: %d\\n\", bin->interfaces_count);\n\tif (bin->interfaces_count > 0) {\n\t\tfor (i = 0; i < bin->interfaces_count; i++) {\n\t\t\tinterfaces_obj = r_bin_java_read_next_interface_item (bin, offset + adv, buf, len);\n\t\t\tif (interfaces_obj) {\n\t\t\t\tr_list_append (bin->interfaces_list, interfaces_obj);\n\t\t\t\tadv += interfaces_obj->size;\n\t\t\t\tif (offset + adv > len) {\n\t\t\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Interface: %d.\\n\", i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbin->interfaces_size = adv;\n\treturn adv;\n}\n\nR_API ut64 r_bin_java_parse_fields(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tint i = 0;\n\tut64 adv = 0;\n\tRBinJavaField *field;\n\tconst ut8 *fm_buf = buf + offset;\n\tr_list_free (bin->fields_list);\n\tbin->fields_list = r_list_newf (r_bin_java_fmtype_free);\n\tbin->fields_offset = offset;\n\tif (offset + 2 >= len) {\n\t\treturn UT64_MAX;\n\t}\n\tbin->fields_count = R_BIN_JAVA_USHORT (fm_buf, 0);\n\tadv += 2;\n\tIFDBG eprintf(\"Fields count: %d 0x%\"PFMT64x \"\\n\", bin->fields_count, bin->fields_offset);\n\tif (bin->fields_count > 0) {\n\t\tfor (i = 0; i < bin->fields_count; i++, bin->field_idx++) {\n\t\t\tfield = r_bin_java_read_next_field (bin, offset + adv, buf, len);\n\t\t\tif (field) {\n\t\t\t\tadv += field->size;\n\t\t\t\tr_list_append (bin->fields_list, field);\n\t\t\t\tIFDBG r_bin_java_print_field_summary(field);\n\t\t\t\tif (adv + offset > len) {\n\t\t\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Field: %d.\\n\", i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tIFDBG eprintf(\"Failed to read Field %d\\n\", i);\n\t\t\t}\n\t\t}\n\t}\n\tbin->fields_size = adv;\n\treturn adv;\n}\n\nR_API ut64 r_bin_java_parse_attrs(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tint i = 0;\n\tut64 adv = 0;\n\tconst ut8 *a_buf = buf + offset;\n\tif (offset + 2 >= len) {\n\t\t// Check if we can read that USHORT\n\t\treturn UT64_MAX;\n\t}\n\tr_list_free (bin->attrs_list);\n\tbin->attrs_list = r_list_newf (r_bin_java_attribute_free);\n\tbin->attrs_offset = offset;\n\tbin->attrs_count = R_BIN_JAVA_USHORT (a_buf, adv);\n\tadv += 2;\n\tif (bin->attrs_count > 0) {\n\t\tfor (i = 0; i < bin->attrs_count; i++, bin->attr_idx++) {\n\t\t\tRBinJavaAttrInfo *attr = r_bin_java_read_next_attr (bin, offset + adv, buf, len);\n\t\t\tif (!attr) {\n\t\t\t\t// eprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Attribute: %d.\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (bin->attrs_list, attr);\n\t\t\tadv += attr->size;\n\t\t\tif (adv + offset >= len) {\n\t\t\t\t// eprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Attribute: %d.\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbin->attrs_size = adv;\n\treturn adv;\n}\n\nR_API ut64 r_bin_java_parse_methods(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tint i = 0;\n\tut64 adv = 0;\n\tRBinJavaField *method;\n\tconst ut8 *fm_buf = buf + offset;\n\tr_list_free (bin->methods_list);\n\tbin->methods_list = r_list_newf (r_bin_java_fmtype_free);\n\n\tif (offset + 2 >= len) {\n\t\treturn 0LL;\n\t}\n\tbin->methods_offset = offset;\n\tbin->methods_count = R_BIN_JAVA_USHORT (fm_buf, 0);\n\tadv += 2;\n\tIFDBG eprintf(\"Methods count: %d 0x%\"PFMT64x \"\\n\", bin->methods_count, bin->methods_offset);\n\tbin->main = NULL;\n\tbin->entrypoint = NULL;\n\tbin->main_code_attr = NULL;\n\tbin->entrypoint_code_attr = NULL;\n\tfor (i = 0; i < bin->methods_count; i++, bin->method_idx++) {\n\t\tmethod = r_bin_java_read_next_method (bin, offset + adv, buf, len);\n\t\tif (method) {\n\t\t\tadv += method->size;\n\t\t\tr_list_append (bin->methods_list, method);\n\t\t}\n\t\t// Update Main, Init, or Class Init\n\t\tif (method && !strcmp ((const char *) method->name, \"main\")) {\n\t\t\tbin->main = method;\n\t\t\t// get main code attr\n\t\t\tbin->main_code_attr = r_bin_java_get_attr_from_field (method, R_BIN_JAVA_ATTR_TYPE_CODE_ATTR, 0);\n\t\t} else if (method && (!strcmp ((const char *) method->name, \"<init>\") || !strcmp ((const char *) method->name, \"init\")))   {\n\t\t\tIFDBG eprintf(\"FOund an init function.\\n\");\n\t\t\tbin->entrypoint = method;\n\t\t\tbin->entrypoint_code_attr = r_bin_java_get_attr_from_field (method, R_BIN_JAVA_ATTR_TYPE_CODE_ATTR, 0);\n\t\t} else if (method && (!strcmp ((const char *) method->name, \"<cinit>\") || !strcmp ((const char *) method->name, \"cinit\")))   {\n\t\t\tbin->cf2.this_class_entrypoint = method;\n\t\t\tbin->cf2.this_class_entrypoint_code_attr = r_bin_java_get_attr_from_field (method, R_BIN_JAVA_ATTR_TYPE_CODE_ATTR, 0);\n\t\t}\n\t\tif (adv + offset > len) {\n\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Method: %d.\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t\tIFDBG r_bin_java_print_field_summary(method);\n\t}\n\tbin->methods_size = adv;\n\treturn adv;\n}\n\nR_API int r_bin_java_new_bin(RBinJavaObj *bin, ut64 loadaddr, Sdb *kv, const ut8 *buf, ut64 len) {\n\tR_BIN_JAVA_GLOBAL_BIN = bin;\n\tbin->lines.count = 0;\n\tbin->loadaddr = loadaddr;\n\tr_bin_java_get_java_null_cp ();\n\tbin->id = r_num_rand (UT32_MAX);\n\tbin->kv = kv ? kv : sdb_new (NULL, NULL, 0);\n\tbin->AllJavaBinObjs = NULL;\n\treturn r_bin_java_load_bin (bin, buf, len);\n}\n\nR_API int r_bin_java_load_bin(RBinJavaObj *bin, const ut8 *buf, ut64 buf_sz) {\n\tut64 adv = 0;\n\tR_BIN_JAVA_GLOBAL_BIN = bin;\n\tif (!bin) {\n\t\treturn false;\n\t}\n\tr_bin_java_reset_bin_info (bin);\n\tmemcpy ((ut8 *) &bin->cf, buf, 10);\n\tif (memcmp (bin->cf.cafebabe, \"\\xCA\\xFE\\xBA\\xBE\", 4)) {\n\t\teprintf (\"r_bin_java_new_bin: Invalid header (%02x %02x %02x %02x)\\n\",\n\t\t\tbin->cf.cafebabe[0], bin->cf.cafebabe[1],\n\t\t\tbin->cf.cafebabe[2], bin->cf.cafebabe[3]);\n\t\treturn false;\n\t}\n\tif (bin->cf.major[0] == bin->cf.major[1] && bin->cf.major[0] == 0) {\n\t\teprintf (\"Java CLASS with MACH0 header?\\n\");\n\t\treturn false;\n\t}\n\tadv += 8;\n\t// -2 so that the cp_count will be parsed\n\tadv += r_bin_java_parse_cp_pool (bin, adv, buf, buf_sz);\n\tif (adv > buf_sz) {\n\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Constant Pool.\\n\");\n\t\treturn true;\n\t}\n\tadv += r_bin_java_read_class_file2 (bin, adv, buf, buf_sz);\n\tif (adv > buf_sz) {\n\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after class file info.\\n\");\n\t\treturn true;\n\t}\n\tIFDBG eprintf(\"This class: %d %s\\n\", bin->cf2.this_class, bin->cf2.this_class_name);\n\tIFDBG eprintf(\"0x%\"PFMT64x \" Access flags: 0x%04x\\n\", adv, bin->cf2.access_flags);\n\tadv += r_bin_java_parse_interfaces (bin, adv, buf, buf_sz);\n\tif (adv > buf_sz) {\n\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Interfaces.\\n\");\n\t\treturn true;\n\t}\n\tadv += r_bin_java_parse_fields (bin, adv, buf, buf_sz);\n\tif (adv > buf_sz) {\n\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Fields.\\n\");\n\t\treturn true;\n\t}\n\tadv += r_bin_java_parse_methods (bin, adv, buf, buf_sz);\n\tif (adv > buf_sz) {\n\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Methods.\\n\");\n\t\treturn true;\n\t}\n\tadv += r_bin_java_parse_attrs (bin, adv, buf, buf_sz);\n\tbin->calc_size = adv;\n\t// if (adv > buf_sz) {\n\t// eprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Attributes.\\n\");\n\t// return true;\n\t// }\n\n\t// add_cp_objs_to_sdb(bin);\n\t// add_method_infos_to_sdb(bin);\n\t// add_field_infos_to_sdb(bin);\n\treturn true;\n}\n\nR_API char *r_bin_java_get_version(RBinJavaObj *bin) {\n\treturn r_str_newf (\"0x%02x%02x 0x%02x%02x\",\n\t\tbin->cf.major[1], bin->cf.major[0],\n\t\tbin->cf.minor[1], bin->cf.minor[0]);\n}\n\nR_API RList *r_bin_java_get_entrypoints(RBinJavaObj *bin) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaField *fm_type;\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach_safe (bin->methods_list, iter, iter_tmp, fm_type) {\n\t\tif (!strcmp (fm_type->name, \"main\")\n\t\t|| !strcmp (fm_type->name, \"<init>\")\n\t\t|| !strcmp (fm_type->name, \"<clinit>\")\n\t\t|| strstr (fm_type->flags_str, \"static\")) {\n\t\t\tRBinAddr *addr = R_NEW0 (RBinAddr);\n\t\t\tif (addr) {\n\t\t\t\taddr->vaddr = addr->paddr = \\\n\t\t\t\t\tr_bin_java_get_method_code_offset (fm_type) + bin->loadaddr;\n\t\t\t\taddr->haddr = fm_type->file_offset;\n\t\t\t\tr_list_append (ret, addr);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API RBinJavaField *r_bin_java_get_method_code_attribute_with_addr(RBinJavaObj *bin, ut64 addr) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaField *fm_type, *res = NULL;\n\tif (bin == NULL && R_BIN_JAVA_GLOBAL_BIN) {\n\t\tbin = R_BIN_JAVA_GLOBAL_BIN;\n\t} else if (bin == NULL) {\n\t\teprintf (\"Attempting to analyse function when the R_BIN_JAVA_GLOBAL_BIN has not been set.\\n\");\n\t\treturn NULL;\n\t}\n\tr_list_foreach_safe (bin->methods_list, iter, iter_tmp, fm_type) {\n\t\tut64 offset = r_bin_java_get_method_code_offset (fm_type) + bin->loadaddr,\n\t\tsize = r_bin_java_get_method_code_size (fm_type);\n\t\tif (addr >= offset && addr <= size + offset) {\n\t\t\tres = fm_type;\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API RBinAddr *r_bin_java_get_entrypoint(RBinJavaObj *bin, int sym) {\n\tRBinAddr *ret = NULL;\n\tret = R_NEW0 (RBinAddr);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->paddr = UT64_MAX;\n\tswitch (sym) {\n\tcase R_BIN_SYM_ENTRY:\n\tcase R_BIN_SYM_INIT:\n\t\tret->paddr = r_bin_java_find_method_offset (bin, \"<init>\");\n\t\tif (ret->paddr == UT64_MAX) {\n\t\t\tret->paddr = r_bin_java_find_method_offset (bin, \"<cinit>\");\n\t\t}\n\t\tbreak;\n\tcase R_BIN_SYM_FINI:\n\t\tret->paddr = UT64_MAX;\n\t\tbreak;\n\tcase R_BIN_SYM_MAIN:\n\t\tret->paddr = r_bin_java_find_method_offset (bin, \"main\");\n\t\tbreak;\n\tdefault:\n\t\tret->paddr = -1;\n\t}\n\tif (ret->paddr != -1) {\n\t\tret->paddr += bin->loadaddr;\n\t}\n\treturn ret;\n}\n\nR_API ut64 r_bin_java_get_method_code_size(RBinJavaField *fm_type) {\n\tRListIter *attr_iter = NULL, *attr_iter_tmp = NULL;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 sz = 0;\n\tr_list_foreach_safe (fm_type->attributes, attr_iter, attr_iter_tmp, attr) {\n\t\tif (attr->type == R_BIN_JAVA_ATTR_TYPE_CODE_ATTR) {\n\t\t\tsz = attr->info.code_attr.code_length;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn sz;\n}\n\nR_API ut64 r_bin_java_find_method_offset(RBinJavaObj *bin, const char *method_name) {\n\tRListIter *attr_iter = NULL, *attr_iter_tmp = NULL;\n\tRBinJavaField *method = NULL;\n\tut64 offset = -1;\n\tr_list_foreach_safe (bin->methods_list, attr_iter, attr_iter_tmp, method) {\n\t\tif (method && !strcmp ((const char *) method->name, method_name)) {\n\t\t\toffset = r_bin_java_get_method_code_offset (method) + bin->loadaddr;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn offset;\n}\n\nR_API ut64 r_bin_java_get_method_code_offset(RBinJavaField *fm_type) {\n\tRListIter *attr_iter = NULL, *attr_iter_tmp = NULL;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tr_list_foreach_safe (fm_type->attributes, attr_iter, attr_iter_tmp, attr) {\n\t\tif (attr->type == R_BIN_JAVA_ATTR_TYPE_CODE_ATTR) {\n\t\t\toffset = attr->info.code_attr.code_offset;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn offset;\n}\n\nR_API RBinField *r_bin_java_allocate_rbinfield() {\n\tRBinField *t = (RBinField *) malloc (sizeof (RBinField));\n\tif (t) {\n\t\tmemset (t, 0, sizeof (RBinField));\n\t}\n\treturn t;\n}\n\nR_API RBinField *r_bin_java_create_new_rbinfield_from_field(RBinJavaField *fm_type, ut64 baddr) {\n\tRBinField *field = r_bin_java_allocate_rbinfield ();\n\tif (field) {\n\t\tfield->name = strdup (fm_type->name);\n\t\tfield->paddr = fm_type->file_offset + baddr;\n\t\tfield->visibility = fm_type->flags;\n\t}\n\treturn field;\n}\n\nR_API RBinSymbol *r_bin_java_create_new_symbol_from_field(RBinJavaField *fm_type, ut64 baddr) {\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (fm_type == NULL || fm_type->field_ref_cp_obj == NULL || fm_type->field_ref_cp_obj == &R_BIN_JAVA_NULL_TYPE) {\n\t\tfree (sym);\n\t\tsym = NULL;\n\t}\n\tif (sym) {\n\t\tsym->name = strdup (fm_type->name);\n\t\t// strncpy (sym->type, fm_type->descriptor, R_BIN_SIZEOF_STRINGS);\n\t\tif (fm_type->type == R_BIN_JAVA_FIELD_TYPE_METHOD) {\n\t\t\tsym->type = r_str_const (R_BIN_TYPE_FUNC_STR);\n\t\t\tsym->paddr = r_bin_java_get_method_code_offset (fm_type);\n\t\t\tsym->vaddr = r_bin_java_get_method_code_offset (fm_type) + baddr;\n\t\t\tsym->size = r_bin_java_get_method_code_size (fm_type);\n\t\t} else {\n\t\t\tsym->type = r_str_const (\"FIELD\");\n\t\t\tsym->paddr = fm_type->file_offset;// r_bin_java_get_method_code_offset (fm_type);\n\t\t\tsym->vaddr = fm_type->file_offset + baddr;\n\t\t\tsym->size = fm_type->size;\n\t\t}\n\t\tif (r_bin_java_is_fm_type_protected (fm_type)) {\n\t\t\tsym->bind = r_str_const (R_BIN_BIND_LOCAL_STR);\n\t\t} else if (r_bin_java_is_fm_type_private (fm_type)) {\n\t\t\tsym->bind = r_str_const (R_BIN_BIND_LOCAL_STR);\n\t\t} else if (r_bin_java_is_fm_type_protected (fm_type)) {\n\t\t\tsym->bind = r_str_const (R_BIN_BIND_GLOBAL_STR);\n\t\t}\n\t\tsym->forwarder = r_str_const (\"NONE\");\n\t\tif (fm_type->class_name) {\n\t\t\tsym->classname = strdup (fm_type->class_name);\n\t\t} else {\n\t\t\tsym->classname = strdup (\"UNKNOWN\"); // dupped names?\n\t\t}\n\t\tsym->ordinal = fm_type->metas->ord;\n\t\tsym->visibility = fm_type->flags;\n\t\tif (fm_type->flags_str) {\n\t\t\tsym->visibility_str = strdup (fm_type->flags_str);\n\t\t}\n\t}\n\treturn sym;\n}\n\nR_API RBinSymbol *r_bin_java_create_new_symbol_from_fm_type_meta(RBinJavaField *fm_type, ut64 baddr) {\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (!sym || !fm_type || !fm_type->field_ref_cp_obj || fm_type->field_ref_cp_obj == &R_BIN_JAVA_NULL_TYPE) {\n\t\tfree (sym);\n\t\treturn NULL;\n\t}\n\t// ut32 new_name_len = strlen (fm_type->name) + strlen (\"_meta\") + 1;\n\t// char *new_name = malloc (new_name_len);\n\tsym->name = r_str_newf (\"meta_%s\", fm_type->name);\n\tif (fm_type->type == R_BIN_JAVA_FIELD_TYPE_METHOD) {\n\t\tsym->type = r_str_const (\"FUNC_META\");\n\t} else {\n\t\tsym->type = r_str_const (\"FIELD_META\");\n\t}\n\tif (r_bin_java_is_fm_type_protected (fm_type)) {\n\t\tsym->bind = r_str_const (R_BIN_BIND_LOCAL_STR);\n\t} else if (r_bin_java_is_fm_type_private (fm_type)) {\n\t\tsym->bind = r_str_const (R_BIN_BIND_LOCAL_STR);\n\t} else if (r_bin_java_is_fm_type_protected (fm_type)) {\n\t\tsym->bind = r_str_const (R_BIN_BIND_GLOBAL_STR);\n\t}\n\tsym->forwarder = r_str_const (\"NONE\");\n\tif (fm_type->class_name) {\n\t\tsym->classname = strdup (fm_type->class_name);\n\t} else {\n\t\tsym->classname = strdup (\"UNKNOWN\");\n\t}\n\tsym->paddr = fm_type->file_offset;// r_bin_java_get_method_code_offset (fm_type);\n\tsym->vaddr = fm_type->file_offset + baddr;\n\tsym->ordinal = fm_type->metas->ord;\n\tsym->size = fm_type->size;\n\tsym->visibility = fm_type->flags;\n\tif (fm_type->flags_str) {\n\t\tsym->visibility_str = strdup (fm_type->flags_str);\n\t}\n\treturn sym;\n}\n\nR_API RBinSymbol *r_bin_java_create_new_symbol_from_ref(RBinJavaCPTypeObj *obj, ut64 baddr) {\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (!sym) {\n\t\treturn NULL;\n\t}\n\tchar *class_name, *name, *type_name;\n\tif (obj == NULL || (obj->tag != R_BIN_JAVA_CP_METHODREF &&\n\tobj->tag != R_BIN_JAVA_CP_INTERFACEMETHOD_REF &&\n\tobj->tag != R_BIN_JAVA_CP_FIELDREF)) {\n\t\tfree (sym);\n\t\tsym = NULL;\n\t\treturn sym;\n\t}\n\tif (sym) {\n\t\tclass_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN,\n\t\t\tobj->info.cp_method.class_idx);\n\t\tname = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN,\n\t\t\tobj->info.cp_method.name_and_type_idx);\n\t\ttype_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN,\n\t\t\tobj->info.cp_method.name_and_type_idx);\n\t\tif (name) {\n\t\t\tsym->name = name;\n\t\t\tname = NULL;\n\t\t}\n\t\tif (type_name) {\n\t\t\tsym->type = r_str_const (type_name);\n\t\t\tR_FREE (type_name);\n\t\t}\n\t\tif (class_name) {\n\t\t\tsym->classname = strdup (class_name);\n\t\t}\n\t\tsym->paddr = obj->file_offset + baddr;\n\t\tsym->vaddr = obj->file_offset + baddr;\n\t\tsym->ordinal = obj->metas->ord;\n\t\tsym->size = 0;\n\t}\n\treturn sym;\n}\n\nR_API RList *r_bin_java_get_sections(RBinJavaObj *bin) {\n\tRBinSection *section = NULL;\n\tRList *sections = r_list_newf (free);\n\tut64 baddr = bin->loadaddr;\n\tRBinJavaField *fm_type;\n\tRListIter *iter = NULL;\n\tif (bin->cp_count > 0) {\n\t\tsection = R_NEW0 (RBinSection);\n\t\tif (section) {\n\t\t\tstrcpy (section->name, \"constant_pool\");\n\t\t\tsection->size = bin->cp_size;\n\t\t\tsection->paddr = bin->cp_offset + baddr;\n\t\t\tsection->srwx = R_BIN_SCN_READABLE;\n\t\t\tsection->add = true;\n\t\t\tr_list_append (sections, section);\n\t\t}\n\t\tsection = NULL;\n\t}\n\tif (bin->fields_count > 0) {\n\t\tsection = R_NEW0 (RBinSection);\n\t\tif (section) {\n\t\t\tstrcpy (section->name, \"fields\");\n\t\t\tsection->size = bin->fields_size;\n\t\t\tsection->paddr = bin->fields_offset + baddr;\n\t\t\tsection->srwx = R_BIN_SCN_READABLE;\n\t\t\tsection->add = true;\n\t\t\tr_list_append (sections, section);\n\t\t\tsection = NULL;\n\t\t\tr_list_foreach (bin->fields_list, iter, fm_type) {\n\t\t\t\tif (fm_type->attr_offset == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsection = R_NEW0 (RBinSection);\n\t\t\t\tif (section) {\n\t\t\t\t\tsnprintf (section->name, R_BIN_SIZEOF_STRINGS, \"attrs.%s\", fm_type->name);\n\t\t\t\t\tsection->size = fm_type->size - (fm_type->file_offset - fm_type->attr_offset);\n\t\t\t\t\tsection->paddr = fm_type->attr_offset + baddr;\n\t\t\t\t\tsection->srwx = R_BIN_SCN_READABLE;\n\t\t\t\t\tsection->add = true;\n\t\t\t\t\tr_list_append (sections, section);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (bin->methods_count > 0) {\n\t\tsection = R_NEW0 (RBinSection);\n\t\tif (section) {\n\t\t\tstrcpy (section->name, \"methods\");\n\t\t\tsection->size = bin->methods_size;\n\t\t\tsection->paddr = bin->methods_offset + baddr;\n\t\t\tsection->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_EXECUTABLE;\n\t\t\tsection->add = true;\n\t\t\tr_list_append (sections, section);\n\t\t\tsection = NULL;\n\t\t\tr_list_foreach (bin->methods_list, iter, fm_type) {\n\t\t\t\tif (fm_type->attr_offset == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsection = R_NEW0 (RBinSection);\n\t\t\t\tif (section) {\n\t\t\t\t\tsnprintf (section->name, R_BIN_SIZEOF_STRINGS, \"attrs.%s\", fm_type->name);\n\t\t\t\t\tsection->size = fm_type->size - (fm_type->file_offset - fm_type->attr_offset);\n\t\t\t\t\tsection->paddr = fm_type->attr_offset + baddr;\n\t\t\t\t\tsection->srwx = R_BIN_SCN_READABLE;\n\t\t\t\t\tsection->add = true;\n\t\t\t\t\tr_list_append (sections, section);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (bin->interfaces_count > 0) {\n\t\tsection = R_NEW0 (RBinSection);\n\t\tif (section) {\n\t\t\tstrcpy (section->name, \"interfaces\");\n\t\t\tsection->size = bin->interfaces_size;\n\t\t\tsection->paddr = bin->interfaces_offset + baddr;\n\t\t\tsection->srwx = R_BIN_SCN_READABLE;\n\t\t\tsection->add = true;\n\t\t\tr_list_append (sections, section);\n\t\t}\n\t\tsection = NULL;\n\t}\n\tif (bin->attrs_count > 0) {\n\t\tsection = R_NEW0 (RBinSection);\n\t\tif (section) {\n\t\t\tstrcpy (section->name, \"attributes\");\n\t\t\tsection->size = bin->attrs_size;\n\t\t\tsection->paddr = bin->attrs_offset + baddr;\n\t\t\tsection->srwx = R_BIN_SCN_READABLE;\n\t\t\tsection->add = true;\n\t\t\tr_list_append (sections, section);\n\t\t}\n\t\tsection = NULL;\n\t}\n\treturn sections;\n}\n\nR_API RList *r_bin_java_enum_class_methods(RBinJavaObj *bin, ut16 class_idx) {\n\tRList *methods = r_list_newf (free);\n\tRListIter *iter;\n\tRBinJavaField *field;\n\tr_list_foreach (bin->methods_list, iter, field) {\n\t\tif (field->field_ref_cp_obj && 0) {\n\t\t\tif ((field && field->field_ref_cp_obj->metas->ord == class_idx)) {\n\t\t\t\tRBinSymbol *sym = r_bin_java_create_new_symbol_from_ref (\n\t\t\t\t\t\tfield->field_ref_cp_obj, bin->loadaddr);\n\t\t\t\tif (sym) {\n\t\t\t\t\tr_list_append (methods, sym);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tsym->name = strdup (field->name);\n\t\t\t// func defintion\n\t\t\t// sym->paddr = field->file_offset + bin->loadaddr;\n\t\t\t// code implementation\n\t\t\tsym->paddr = r_bin_java_get_method_code_offset (field);\n\t\t\tsym->vaddr = sym->paddr; // + bin->loadaddr;\n\t\t\tr_list_append (methods, sym);\n\t\t}\n\t}\n\treturn methods;\n}\n\nR_API RList *r_bin_java_enum_class_fields(RBinJavaObj *bin, ut16 class_idx) {\n\tRList *fields = r_list_newf (free);\n\tRListIter *iter;\n\tRBinJavaField *fm_type;\n\tRBinField *field = NULL;\n\tr_list_foreach (bin->fields_list, iter, fm_type) {\n\t\tif (fm_type) {\n\t\t\tif (fm_type && fm_type->field_ref_cp_obj\n\t\t\t&& fm_type->field_ref_cp_obj->metas->ord == class_idx) {\n\t\t\t\tfield = r_bin_java_create_new_rbinfield_from_field (fm_type, bin->loadaddr);\n\t\t\t\tif (field) {\n\t\t\t\t\tr_list_append (fields, field);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn fields;\n}\n\nR_API int is_class_interface(RBinJavaObj *bin, RBinJavaCPTypeObj *cp_obj) {\n\tRBinJavaInterfaceInfo *ifobj;\n\tRListIter *iter;\n\tint res = false;\n\tr_list_foreach (bin->interfaces_list, iter, ifobj) {\n\t\tif (ifobj) {\n\t\t\tres = cp_obj == ifobj->cp_class;\n\t\t\tif (res) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n/*\n   R_API RList * r_bin_java_get_interface_classes(RBinJavaObj * bin) {\n        RList *interfaces_names = r_list_new();\n        RListIter *iter;\n        RBinJavaInterfaceInfo *ifobj;\n        r_list_foreach(bin->interfaces_list, iter, iinfo) {\n                RBinClass *class_ = R_NEW0 (RBinClass);\n                RBinJavaCPTypeObj *cp_obj = ;\n                if (ifobj && ifobj->name) {\n                        ut8 * name = strdup(ifobj->name);\n                        r_list_append(interfaces_names, name);\n                }\n        }\n        return interfaces_names;\n   }\n*/\n\nR_API RList *r_bin_java_get_lib_names(RBinJavaObj *bin) {\n\tRList *lib_names = r_list_newf (free);\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *cp_obj = NULL;\n\tif (!bin) {\n\t\treturn lib_names;\n\t}\n\tr_list_foreach (bin->cp_list, iter, cp_obj) {\n\t\tif (cp_obj && cp_obj->tag == R_BIN_JAVA_CP_CLASS &&\n\t\t(bin->cf2.this_class != cp_obj->info.cp_class.name_idx || !is_class_interface (bin, cp_obj))) {\n\t\t\tchar *name = r_bin_java_get_item_name_from_bin_cp_list (bin, cp_obj);\n\t\t\tr_list_append (lib_names, name);\n\t\t}\n\t}\n\treturn lib_names;\n}\n\nR_API void r_bin_java_classes_free(void /*RBinClass*/ *k) {\n\tRBinClass *klass = k;\n\tif (klass) {\n\t\tr_list_free (klass->methods);\n\t\tr_list_free (klass->fields);\n\t\tfree (klass->name);\n\t\tfree (klass->super);\n\t\tfree (klass->visibility_str);\n\t\tfree (klass);\n\t}\n}\n\nR_API RList *r_bin_java_get_classes(RBinJavaObj *bin) {\n\tRList *classes = r_list_newf (r_bin_java_classes_free);\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *cp_obj = NULL;\n\tRBinJavaCPTypeObj *this_class_cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, bin->cf2.this_class);\n\tut32 idx = 0;\n\tRBinClass *k = R_NEW0 (RBinClass);\n\tif (!k) {\n\t\tr_list_free (classes);\n\t\treturn NULL;\n\t}\n\tk->visibility = bin->cf2.access_flags;\n\tif (bin->cf2.flags_str) {\n\t\tk->visibility_str = strdup (bin->cf2.flags_str);\n\t}\n\tk->methods = r_bin_java_enum_class_methods (bin, bin->cf2.this_class);\n\tk->fields = r_bin_java_enum_class_fields (bin, bin->cf2.this_class);\n\tk->name = r_bin_java_get_this_class_name (bin);\n\tk->super = r_bin_java_get_name_from_bin_cp_list (bin, bin->cf2.super_class);\n\tk->index = (idx++);\n\tr_list_append (classes, k);\n\tr_list_foreach (bin->cp_list, iter, cp_obj) {\n\t\tif (cp_obj && cp_obj->tag == R_BIN_JAVA_CP_CLASS\n\t\t&& (this_class_cp_obj != cp_obj && is_class_interface (bin, cp_obj))) {\n\t\t\tk = R_NEW0 (RBinClass);\n\t\t\tif (!k) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk->methods = r_bin_java_enum_class_methods (bin, cp_obj->info.cp_class.name_idx);\n\t\t\tk->fields = r_bin_java_enum_class_fields (bin, cp_obj->info.cp_class.name_idx);\n\t\t\tk->index = idx;\n\t\t\tk->name = r_bin_java_get_item_name_from_bin_cp_list (bin, cp_obj);\n\t\t\tr_list_append (classes, k);\n\t\t\tidx++;\n\t\t}\n\t}\n\treturn classes;\n}\n\nR_API RBinSymbol *r_bin_java_create_new_symbol_from_invoke_dynamic(RBinJavaCPTypeObj *obj, ut64 baddr) {\n\tif (!obj || (obj->tag != R_BIN_JAVA_CP_INVOKEDYNAMIC)) {\n\t\treturn NULL;\n\t}\n\treturn r_bin_java_create_new_symbol_from_cp_idx (obj->info.cp_invoke_dynamic.name_and_type_index, baddr);\n}\n\nR_API RBinSymbol *r_bin_java_create_new_symbol_from_cp_idx(ut32 cp_idx, ut64 baddr) {\n\tRBinSymbol *sym = NULL;\n\tRBinJavaCPTypeObj *obj = r_bin_java_get_item_from_bin_cp_list (\n\t\tR_BIN_JAVA_GLOBAL_BIN, cp_idx);\n\tif (obj) {\n\t\tswitch (obj->tag) {\n\t\tcase R_BIN_JAVA_CP_METHODREF:\n\t\tcase R_BIN_JAVA_CP_FIELDREF:\n\t\tcase R_BIN_JAVA_CP_INTERFACEMETHOD_REF:\n\t\t\tsym = r_bin_java_create_new_symbol_from_ref (obj, baddr);\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_CP_INVOKEDYNAMIC:\n\t\t\tsym = r_bin_java_create_new_symbol_from_invoke_dynamic (obj, baddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn sym;\n}\n\nR_API RList *U(r_bin_java_get_fields)(RBinJavaObj * bin) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRList *fields = r_list_new ();\n\tRBinJavaField *fm_type;\n\tRBinField *field;\n\tr_list_foreach_safe (bin->fields_list, iter, iter_tmp, fm_type) {\n\t\tfield = r_bin_java_create_new_rbinfield_from_field (fm_type, bin->loadaddr);\n\t\tif (field) {\n\t\t\tr_list_append (fields, field);\n\t\t}\n\t}\n\treturn fields;\n}\n\nR_API void r_bin_add_import(RBinJavaObj *bin, RBinJavaCPTypeObj *obj, const char *type) {\n\tRBinImport *imp = R_NEW0 (RBinImport);\n\tchar *class_name = r_bin_java_get_name_from_bin_cp_list (bin, obj->info.cp_method.class_idx);\n\tchar *name = r_bin_java_get_name_from_bin_cp_list (bin, obj->info.cp_method.name_and_type_idx);\n\tchar *descriptor = r_bin_java_get_desc_from_bin_cp_list (bin, obj->info.cp_method.name_and_type_idx);\n\tclass_name = class_name ? class_name : strdup (\"INVALID CLASS NAME INDEX\");\n\tname = name ? name : strdup (\"InvalidNameIndex\");\n\tdescriptor = descriptor ? descriptor : strdup (\"INVALID DESCRIPTOR INDEX\");\n\timp->classname = class_name;\n\timp->name = name;\n\timp->bind = r_str_const (\"NONE\");\n\timp->type = r_str_const (type);\n\timp->descriptor = descriptor;\n\timp->ordinal = obj->idx;\n\tr_list_append (bin->imports_list, imp);\n}\n\nR_API void r_bin_java_set_imports(RBinJavaObj *bin) {\n\tRListIter *iter = NULL;\n\tRBinJavaCPTypeObj *obj = NULL;\n\tr_list_free (bin->imports_list);\n\tbin->imports_list = r_list_newf (free);\n\tr_list_foreach (bin->cp_list, iter, obj) {\n\t\tconst char *type = NULL;\n\t\tswitch (obj->tag) {\n\t\tcase R_BIN_JAVA_CP_METHODREF: type = \"METHOD\"; break;\n\t\tcase R_BIN_JAVA_CP_INTERFACEMETHOD_REF: type = \"FIELD\"; break;\n\t\tcase R_BIN_JAVA_CP_FIELDREF: type = \"INTERFACE_METHOD\"; break;\n\t\tdefault: type = NULL; break;\n\t\t}\n\t\tif (type) {\n\t\t\tr_bin_add_import (bin, obj, type);\n\t\t}\n\t}\n}\n\nR_API RList *r_bin_java_get_imports(RBinJavaObj *bin) {\n\tRList *ret = r_list_newf (free);\n\tRBinImport *import = NULL;\n\tRListIter *iter;\n\tr_list_foreach (bin->imports_list, iter, import) {\n\t\tRBinImport *n_import = R_NEW0 (RBinImport);\n\t\tif (!n_import) {\n\t\t\tr_list_free (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy (n_import, import, sizeof (RBinImport));\n\t\tr_list_append (ret, n_import);\n\t}\n\treturn ret;\n}\n\nR_API RList *r_bin_java_get_symbols(RBinJavaObj *bin) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRList *imports, *symbols = r_list_newf (free);\n\tRBinSymbol *sym = NULL;\n\tRBinImport *imp;\n\tRBinJavaField *fm_type;\n\tr_list_foreach_safe (bin->methods_list, iter, iter_tmp, fm_type) {\n\t\tsym = r_bin_java_create_new_symbol_from_field (fm_type, bin->loadaddr);\n\t\tif (sym) {\n\t\t\tr_list_append (symbols, (void *) sym);\n\t\t}\n\t\tsym = r_bin_java_create_new_symbol_from_fm_type_meta (fm_type, bin->loadaddr);\n\t\tif (sym) {\n\t\t\tr_list_append (symbols, (void *) sym);\n\t\t}\n\t}\n\tr_list_foreach_safe (bin->fields_list, iter, iter_tmp, fm_type) {\n\t\tsym = r_bin_java_create_new_symbol_from_field (fm_type, bin->loadaddr);\n\t\tif (sym) {\n\t\t\tr_list_append (symbols, (void *) sym);\n\t\t}\n\t\tsym = r_bin_java_create_new_symbol_from_fm_type_meta (fm_type, bin->loadaddr);\n\t\tif (sym) {\n\t\t\tr_list_append (symbols, (void *) sym);\n\t\t}\n\t}\n\tbin->lang = \"java\";\n\timports = r_bin_java_get_imports (bin);\n\tr_list_foreach (imports, iter, imp) {\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tif (imp->classname && !strncmp (imp->classname, \"kotlin/jvm\", 10)) {\n\t\t\tbin->lang = \"kotlin\";\n\t\t}\n\t\tsym->name = r_str_newf (\"imp.%s\", imp->name);\n\t\tif (!sym->name) {\n\t\t\tfree (sym);\n\t\t\tbreak;\n\t\t}\n\t\tsym->type = r_str_const (\"import\");\n\t\tif (!sym->type) {\n\t\t\tfree (sym);\n\t\t\tbreak;\n\t\t}\n\t\tsym->vaddr = sym->paddr = imp->ordinal;\n\t\tsym->ordinal = imp->ordinal;\n\t\tr_list_append (symbols, (void *) sym);\n\t}\n\tr_list_free (imports);\n\treturn symbols;\n}\n\nR_API RList *r_bin_java_get_strings(RBinJavaObj *bin) {\n\tRList *strings = r_list_newf (free);\n\tRBinString *str = NULL;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaCPTypeObj *cp_obj = NULL;\n\tr_list_foreach_safe (bin->cp_list, iter, iter_tmp, cp_obj) {\n\t\tif (cp_obj && cp_obj->tag == R_BIN_JAVA_CP_UTF8) {\n\t\t\tstr = (RBinString *) R_NEW0 (RBinString);\n\t\t\tif (str) {\n\t\t\t\tstr->paddr = cp_obj->file_offset + bin->loadaddr;\n\t\t\t\tstr->ordinal = cp_obj->metas->ord;\n\t\t\t\tstr->size = cp_obj->info.cp_utf8.length + 3;\n\t\t\t\tstr->length = cp_obj->info.cp_utf8.length;\n\t\t\t\tif (str->size > 0) {\n\t\t\t\t\tstr->string = r_str_ndup ((const char *)\n\t\t\t\t\t\tcp_obj->info.cp_utf8.bytes,\n\t\t\t\t\t\tR_BIN_JAVA_MAXSTR);\n\t\t\t\t}\n\t\t\t\tr_list_append (strings, (void *) str);\n\t\t\t}\n\t\t}\n\t}\n\treturn strings;\n}\n\nR_API void *r_bin_java_free(RBinJavaObj *bin) {\n\tchar *bin_obj_key = NULL;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\t// Delete the bin object from the data base.\n\tbin_obj_key = r_bin_java_build_obj_key (bin);\n\t// if (bin->AllJavaBinObjs && sdb_exists (bin->AllJavaBinObjs, bin_obj_key)) {\n\t// sdb_unset (bin->AllJavaBinObjs, bin_obj_key, 0);\n\t// }\n\tfree (bin_obj_key);\n\tr_list_free (bin->imports_list);\n\t// XXX - Need to remove all keys belonging to this class from\n\t// the share meta information sdb.\n\t// TODO e.g. iterate over bin->kv and delete all obj, func, etc. keys\n\t// sdb_free (bin->kv);\n\t// free up the constant pool list\n\tr_list_free (bin->cp_list);\n\t// free up the fields list\n\tr_list_free (bin->fields_list);\n\t// free up methods list\n\tr_list_free (bin->methods_list);\n\t// free up interfaces list\n\tr_list_free (bin->interfaces_list);\n\tr_list_free (bin->attrs_list);\n\t// TODO: XXX if a class list of all inner classes\n\t// are formed then this will need to be updated\n\tfree (bin->cf2.flags_str);\n\tfree (bin->cf2.this_class_name);\n\tif (bin == R_BIN_JAVA_GLOBAL_BIN) {\n\t\tR_BIN_JAVA_GLOBAL_BIN = NULL;\n\t}\n\tfree (bin->file);\n\tfree (bin);\n\treturn NULL;\n}\n\nR_API RBinJavaObj *r_bin_java_new_buf(RBuffer *buf, ut64 loadaddr, Sdb *kv) {\n\tRBinJavaObj *bin = R_NEW0 (RBinJavaObj);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (!r_bin_java_new_bin (bin, loadaddr, kv, buf->buf, buf->length)) {\n\t\treturn r_bin_java_free (bin);\n\t}\n\treturn bin;\n}\n\nR_API void r_bin_java_attribute_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tIFDBG eprintf(\"Deleting attr %s, %p\\n\", attr->name, attr);\n\t\t((RBinJavaAttrMetas *) attr->metas->type_info)->allocs->delete_obj (attr);\n\t\t// free (attr->metas);\n\t\t// free (attr);\n\t}\n}\n\nR_API void r_bin_java_constant_pool(void /*RBinJavaCPTypeObj*/ *o) {\n\tRBinJavaCPTypeObj *obj = o;\n\tif (obj != &R_BIN_JAVA_NULL_TYPE) {\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t}\n}\n\nR_API void r_bin_java_fmtype_free(void /*RBinJavaField*/ *f) {\n\tRBinJavaField *fm_type = f;\n\tif (!fm_type) {\n\t\treturn;\n\t}\n\tfree (fm_type->descriptor);\n\tfree (fm_type->name);\n\tfree (fm_type->flags_str);\n\tfree (fm_type->class_name);\n\tfree (fm_type->metas);\n\tr_list_free (fm_type->attributes);\n\tfree (fm_type);\n}\n// Start Free the various attribute types\nR_API void r_bin_java_unknown_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_local_variable_table_attr_entry_free(void /*RBinJavaLocalVariableAttribute*/ *a) {\n\tRBinJavaLocalVariableAttribute *lvattr = a;\n\tif (lvattr) {\n\t\tfree (lvattr->descriptor);\n\t\tfree (lvattr->name);\n\t\tfree (lvattr);\n\t}\n}\n\nR_API void r_bin_java_local_variable_table_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tr_list_free (attr->info.local_variable_table_attr.local_variable_table);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_local_variable_type_table_attr_entry_free(void /*RBinJavaLocalVariableTypeAttribute*/ *a) {\n\tRBinJavaLocalVariableTypeAttribute *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->signature);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_local_variable_type_table_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tr_list_free (attr->info.local_variable_type_table_attr.local_variable_table);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_deprecated_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_enclosing_methods_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr->info.enclosing_method_attr.class_name);\n\t\tfree (attr->info.enclosing_method_attr.method_name);\n\t\tfree (attr->info.enclosing_method_attr.method_descriptor);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_synthetic_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_constant_value_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_line_number_table_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tr_list_free (attr->info.line_number_table_attr.line_number_table);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_code_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\t// XXX - Intentional memory leak here.  When one of the\n\t\t// Code attributes is parsed, the code (the r_bin_java)\n\t\t// is not properly parsing the class file\n\t\tr_bin_java_stack_frame_free (attr->info.code_attr.implicit_frame);\n\t\tr_list_free (attr->info.code_attr.attributes);\n\t\tfree (attr->info.code_attr.code);\n\t\tr_list_free (attr->info.code_attr.exception_table);\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_exceptions_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr->info.exceptions_attr.exception_idx_table);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_inner_classes_attr_entry_free(void /*RBinJavaClassesAttribute*/ *a) {\n\tRBinJavaClassesAttribute *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->flags_str);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_inner_classes_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tr_list_free (attr->info.inner_classes_attr.classes);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_signature_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr->info.signature_attr.signature);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_source_debug_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr->info.debug_extensions.debug_extension);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_source_code_file_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_stack_map_table_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tr_list_free (attr->info.stack_map_table_attr.stack_map_frame_entries);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_stack_frame_free(void /*RBinJavaStackMapFrame*/ *o) {\n\tRBinJavaStackMapFrame *obj = o;\n\tif (obj) {\n\t\tr_list_free (obj->local_items);\n\t\tr_list_free (obj->stack_items);\n\t\tfree (obj->metas);\n\t\tfree (obj);\n\t}\n}\n\nR_API void r_bin_java_verification_info_free(void /*RBinJavaVerificationObj*/ *o) {\n\tRBinJavaVerificationObj *obj = o;\n\t// eprintf (\"Freeing verification object\\n\");\n\tif (obj) {\n\t\tfree (obj->name);\n\t\tfree (obj);\n\t}\n}\n\nR_API void r_bin_java_interface_free(void /*RBinJavaInterfaceInfo*/ *o) {\n\tRBinJavaInterfaceInfo *obj = o;\n\tif (obj) {\n\t\tfree (obj->name);\n\t\tfree (obj);\n\t}\n}\n// End Free the various attribute types\n// Start the various attibute types new\nR_API ut64 r_bin_java_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? ((RBinJavaAttrMetas *) attr->metas->type_info)->allocs->calc_size (attr) : 0;\n}\n\nR_API ut64 r_bin_java_unknown_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? 6 : 0;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_unknown_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\treturn r_bin_java_default_attr_new (buffer, sz, buf_offset);\n}\n\nR_API ut64 r_bin_java_code_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tRListIter *iter;\n\t// RListIter *iter_tmp;\n\tut64 size = 0;\n\tif (attr) {\n\t\t// attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\t\tsize += 6;\n\t\t// attr->info.code_attr.max_stack = R_BIN_JAVA_USHORT (buffer, 0);\n\t\tsize += 2;\n\t\t// attr->info.code_attr.max_locals = R_BIN_JAVA_USHORT (buffer, 2);\n\t\tsize += 2;\n\t\t// attr->info.code_attr.code_length = R_BIN_JAVA_UINT (buffer, 4);\n\t\tsize += 2;\n\t\tif (attr->info.code_attr.code) {\n\t\t\tsize += attr->info.code_attr.code_length;\n\t\t}\n\t\t// attr->info.code_attr.exception_table_length =  R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// RBinJavaExceptionEntry *exc_entry;\n\t\t// r_list_foreach_safe (attr->info.code_attr.exception_table, iter, iter_tmp, exc_entry) {\n\t\tr_list_foreach_iter (attr->info.code_attr.exception_table, iter) {\n\t\t\t// exc_entry->start_pc = R_BIN_JAVA_USHORT (buffer,offset);\n\t\t\tsize += 2;\n\t\t\t// exc_entry->end_pc = R_BIN_JAVA_USHORT (buffer,offset);\n\t\t\tsize += 2;\n\t\t\t// exc_entry->handler_pc = R_BIN_JAVA_USHORT (buffer,offset);\n\t\t\tsize += 2;\n\t\t\t// exc_entry->catch_type = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t}\n\t\t// attr->info.code_attr.attributes_count = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// RBinJavaAttrInfo *_attr;\n\t\tif (attr->info.code_attr.attributes_count > 0) {\n\t\t\t// r_list_foreach_safe (attr->info.code_attr.attributes, iter, iter_tmp, _attr) {\n\t\t\tr_list_foreach_iter (attr->info.code_attr.attributes, iter) {\n\t\t\t\tsize += r_bin_java_attr_calc_size (attr);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_code_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL, *_attr = NULL;\n\tut32 k = 0, curpos;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tif (sz < 16 || sz > buf_offset) {// sz > buf_offset) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_CODE_ATTR;\n\tattr->info.code_attr.max_stack = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.code_attr.max_locals = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.code_attr.code_length = R_BIN_JAVA_UINT (buffer, offset);\n\toffset += 4;\n\t// BUG: possible unsigned integer overflow here\n\tattr->info.code_attr.code_offset = buf_offset + offset;\n\tattr->info.code_attr.code = (ut8 *) malloc (attr->info.code_attr.code_length);\n\tif (attr->info.code_attr.code == NULL) {\n\t\teprintf (\"Handling Code Attributes: Unable to allocate memory \"\n\t\t\t\"(%u bytes) for a code.\\n\", attr->info.code_attr.code_length);\n\t\treturn attr;\n\t}\n\tR_BIN_JAVA_GLOBAL_BIN->current_code_attr = attr;\n\t{\n\t\tint len = attr->info.code_attr.code_length;\n\t\tmemset (attr->info.code_attr.code, 0, len);\n\t\tif (offset + len >= sz) {\n\t\t\tlen = sz;\n\t\t\treturn attr;\n\t\t}\n\t\tmemcpy (attr->info.code_attr.code, buffer + offset, len);\n\t\toffset += len;\n\t}\n\tattr->info.code_attr.exception_table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.code_attr.exception_table = r_list_newf (free);\n\tfor (k = 0; k < attr->info.code_attr.exception_table_length; k++) {\n\t\tcurpos = buf_offset + offset;\n\t\tif (curpos + 8 > sz) {\n\t\t\treturn attr;\n\t\t}\n\t\tRBinJavaExceptionEntry *e = R_NEW0 (RBinJavaExceptionEntry);\n\t\tif (!e) {\n\t\t\tfree (attr);\n\t\t\treturn NULL;\n\t\t}\n\t\te->file_offset = curpos;\n\t\te->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\te->end_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\te->handler_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\te->catch_type = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tr_list_append (attr->info.code_attr.exception_table, e);\n\t\te->size = 8;\n\t}\n\tattr->info.code_attr.attributes_count = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\t// IFDBG eprintf (\"\tcode Attributes_count: %d\\n\", attr->info.code_attr.attributes_count);\n\t// XXX - attr->info.code_attr.attributes is not freed because one of the code attributes is improperly parsed.\n\tattr->info.code_attr.attributes = r_list_newf (r_bin_java_attribute_free);\n\tif (attr->info.code_attr.attributes_count > 0) {\n\t\tfor (k = 0; k < attr->info.code_attr.attributes_count; k++) {\n\t\t\tint size = (offset < sz) ? sz - offset : 0;\n\t\t\tif (size > sz || size <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t_attr = r_bin_java_read_next_attr_from_buffer (buffer + offset, size, buf_offset + offset);\n\t\t\tif (!_attr) {\n\t\t\t\teprintf (\"[X] r_bin_java_code_attr_new: Error unable to parse remainder of classfile after Method's Code Attribute: %d.\\n\", k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tIFDBG eprintf(\"Parsing @ 0x%\"PFMT64x \" (%s) = 0x%\"PFMT64x \" bytes, %p\\n\", _attr->file_offset, _attr->name, _attr->size, _attr);\n\t\t\toffset += _attr->size;\n\t\t\tr_list_append (attr->info.code_attr.attributes, _attr);\n\t\t\tif (_attr->type == R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TABLE_ATTR) {\n\t\t\t\tIFDBG eprintf(\"Parsed the LocalVariableTable, preparing the implicit mthod frame.\\n\");\n\t\t\t\t// r_bin_java_print_attr_summary(_attr);\n\t\t\t\tattr->info.code_attr.implicit_frame = r_bin_java_build_stack_frame_from_local_variable_table (R_BIN_JAVA_GLOBAL_BIN, _attr);\n\t\t\t\tattr->info.code_attr.implicit_frame->file_offset = buf_offset;\n\t\t\t\tIFDBG r_bin_java_print_stack_map_frame_summary(attr->info.code_attr.implicit_frame);\n\t\t\t\t// r_list_append (attr->info.code_attr.attributes, attr->info.code_attr.implicit_frame);\n\t\t\t}\n\t\t\t// if (offset > sz) {\n\t\t\t// eprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Attribute: %d.\\n\", k);\n\t\t\t// break;\n\t\t\t// }\n\n\t\t}\n\t}\n\tif (attr->info.code_attr.implicit_frame == NULL) {\n\t\t// build a default implicit_frame\n\t\tattr->info.code_attr.implicit_frame = r_bin_java_default_stack_frame ();\n\t\t// r_list_append (attr->info.code_attr.attributes, attr->info.code_attr.implicit_frame);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;\n\t\tattr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->size = offset;\n\t}\n\t// IFDBG r_bin_java_print_constant_value_attr_summary(attr);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_constant_value_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? 8 : 0;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_deprecated_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_DEPRECATED_ATTR;\n\t\tattr->size = offset;\n\t}\n\t// IFDBG r_bin_java_print_deprecated_attr_summary(attr);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_deprecated_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? 6 : 0;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_signature_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SIGNATURE_ATTR;\n\t// attr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t// offset += 2;\n\tattr->info.signature_attr.signature_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.signature_attr.signature = r_bin_java_get_utf8_from_bin_cp_list (\n\t\tR_BIN_JAVA_GLOBAL_BIN, attr->info.signature_attr.signature_idx);\n\tif (!attr->info.signature_attr.signature) {\n\t\teprintf (\"r_bin_java_signature_attr_new: Unable to resolve the \"\n\t\t\t\"Signature UTF8 String Index: 0x%02x\\n\", attr->info.signature_attr.signature_idx);\n\t}\n\tattr->size = offset;\n\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_signature_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tif (attr == NULL) {\n\t\t// TODO eprintf allocation fail\n\t\treturn size;\n\t}\n\tsize += 6;\n\t// attr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\tsize += 2;\n\t// attr->info.signature_attr.signature_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_ENCLOSING_METHOD_ATTR;\n\tattr->info.enclosing_method_attr.class_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.enclosing_method_attr.method_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.enclosing_method_attr.class_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.class_idx);\n\tif (attr->info.enclosing_method_attr.class_name == NULL) {\n\t\teprintf (\"Could not resolve enclosing class name for the enclosed method.\\n\");\n\t}\n\tattr->info.enclosing_method_attr.method_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.method_idx);\n\tif (attr->info.enclosing_method_attr.class_name == NULL) {\n\t\teprintf (\"Could not resolve method descriptor for the enclosed method.\\n\");\n\t}\n\tattr->info.enclosing_method_attr.method_descriptor = r_bin_java_get_desc_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.method_idx);\n\tif (attr->info.enclosing_method_attr.method_name == NULL) {\n\t\teprintf (\"Could not resolve method name for the enclosed method.\\n\");\n\t}\n\tattr->size = offset;\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_enclosing_methods_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tif (attr) {\n\t\tsize += 6;\n\t\t// attr->info.enclosing_method_attr.class_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// attr->info.enclosing_method_attr.method_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_exceptions_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0, offset = 0;\n\tut64 size;\n\tRBinJavaAttrInfo *attr = NULL;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr == NULL) {\n\t\t// TODO eprintf\n\t\treturn attr;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;\n\tattr->info.exceptions_attr.number_of_exceptions = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tsize = sizeof (ut16) * attr->info.exceptions_attr.number_of_exceptions;\n\tif (size < attr->info.exceptions_attr.number_of_exceptions) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tattr->info.exceptions_attr.exception_idx_table = (ut16 *) malloc (size);\n\tif (!attr->info.exceptions_attr.exception_idx_table) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < attr->info.exceptions_attr.number_of_exceptions; i++) {\n\t\tattr->info.exceptions_attr.exception_idx_table[i] = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t}\n\tattr->size = offset;\n\t// IFDBG r_bin_java_print_exceptions_attr_summary(attr);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_exceptions_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0, i = 0;\n\tif (attr) {\n\t\tsize += 6;\n\t\tfor (i = 0; i < attr->info.exceptions_attr.number_of_exceptions; i++) {\n\t\t\t// attr->info.exceptions_attr.exception_idx_table[i] = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaClassesAttribute *icattr;\n\tRBinJavaAttrInfo *attr = NULL;\n\tRBinJavaCPTypeObj *obj;\n\tut32 i = 0;\n\tut64 offset = 0, curpos;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr == NULL) {\n\t\t// TODO eprintf\n\t\treturn attr;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n\tattr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n\tfor (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tif (offset + 8 > sz) {\n\t\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ticattr = R_NEW0 (RBinJavaClassesAttribute);\n\t\tif (!icattr) {\n\t\t\tbreak;\n\t\t}\n\t\ticattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->flags_str = retrieve_class_method_access_string (icattr->inner_class_access_flags);\n\t\ticattr->file_offset = curpos;\n\t\ticattr->size = 8;\n\n\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_name_idx);\n\t\tif (obj == NULL) {\n\t\t\teprintf (\"BINCPLIS IS HULL %d\\n\", icattr->inner_name_idx);\n\t\t}\n\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\tif (!icattr->name) {\n\t\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_class_info_idx);\n\t\t\tif (!obj) {\n\t\t\t\teprintf (\"BINCPLIST IS NULL %d\\n\", icattr->inner_class_info_idx);\n\t\t\t}\n\t\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\t\tif (!icattr->name) {\n\t\t\t\ticattr->name = r_str_dup (NULL, \"NULL\");\n\t\t\t\teprintf (\"r_bin_java_inner_classes_attr: Unable to find the name for %d index.\\n\", icattr->inner_name_idx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tIFDBG eprintf(\"r_bin_java_inner_classes_attr: Inner class name %d is %s.\\n\", icattr->inner_name_idx, icattr->name);\n\t\tr_list_append (attr->info.inner_classes_attr.classes, (void *) icattr);\n\t}\n\tattr->size = offset;\n\t// IFDBG r_bin_java_print_inner_classes_attr_summary(attr);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_inner_class_attr_calc_size(RBinJavaClassesAttribute *icattr) {\n\tut64 size = 0;\n\tif (icattr) {\n\t\t// icattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// icattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// icattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// icattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t}\n\treturn size;\n}\n\nR_API ut64 r_bin_java_inner_classes_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tRBinJavaClassesAttribute *icattr = NULL;\n\tRListIter *iter;\n\tut64 size = 6;\n\tif (!attr) {\n\t\treturn 0;\n\t}\n\tr_list_foreach (attr->info.inner_classes_attr.classes, iter, icattr) {\n\t\tsize += r_bin_java_inner_class_attr_calc_size (icattr);\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 curpos, offset = 0;\n\tRBinJavaLineNumberAttribute *lnattr;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;\n\tattr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.line_number_table_attr.line_number_table = r_list_newf (free);\n\n\tut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;\n\tRList *linenum_list = attr->info.line_number_table_attr.line_number_table;\n\tif (linenum_len > sz) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < linenum_len; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\t// printf (\"%llx %llx \\n\", curpos, sz);\n\t\t// XXX if (curpos + 8 >= sz) break;\n\t\tlnattr = R_NEW0 (RBinJavaLineNumberAttribute);\n\t\tif (!lnattr) {\n\t\t\tbreak;\n\t\t}\n\t\tlnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->file_offset = curpos;\n\t\tlnattr->size = 4;\n\t\tr_list_append (linenum_list, lnattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_line_number_table_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 6;\n\t// RBinJavaLineNumberAttribute *lnattr;\n\tRListIter *iter;\n\t// RListIter *iter_tmp;\n\tif (!attr) {\n\t\treturn 0LL;\n\t}\n\t// r_list_foreach_safe (attr->info.line_number_table_attr.line_number_table, iter, iter_tmp, lnattr) {\n\tr_list_foreach_iter (attr->info.line_number_table_attr.line_number_table, iter) {\n\t\t// lnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// lnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_DEBUG_EXTENTSION_ATTR;\n\tif (attr->length == 0) {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Attempting to allocate 0 bytes for debug_extension.\\n\");\n\t\tattr->info.debug_extensions.debug_extension = NULL;\n\t\treturn attr;\n\t} else if ((attr->length + offset) > sz) {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Expected %d byte(s) got %\"\n\t\t\tPFMT64d \" bytes for debug_extension.\\n\", attr->length, (offset + sz));\n\t}\n\tattr->info.debug_extensions.debug_extension = (ut8 *) malloc (attr->length);\n\tif (attr->info.debug_extensions.debug_extension && (attr->length > (sz - offset))) {\n\t\tmemcpy (attr->info.debug_extensions.debug_extension, buffer + offset, sz - offset);\n\t} else if (attr->info.debug_extensions.debug_extension) {\n\t\tmemcpy (attr->info.debug_extensions.debug_extension, buffer + offset, attr->length);\n\t} else {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Unable to allocate the data for the debug_extension.\\n\");\n\t}\n\toffset += attr->length;\n\tattr->size = offset;\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_source_debug_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 6;\n\tif (!attr) {\n\t\treturn 0LL;\n\t}\n\tif (attr->info.debug_extensions.debug_extension) {\n\t\tsize += attr->length;\n\t}\n\treturn size;\n}\n\nR_API ut64 r_bin_java_local_variable_table_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\t// ut64 offset = 0;\n\tRListIter *iter;\n\t// RBinJavaLocalVariableAttribute *lvattr;\n\tif (!attr) {\n\t\treturn 0LL;\n\t}\n\tsize += 6;\n\t// attr->info.local_variable_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\tsize += 2;\n\t// r_list_foreach (attr->info.local_variable_table_attr.local_variable_table, iter, lvattr) {\n\tr_list_foreach_iter (attr->info.local_variable_table_attr.local_variable_table, iter) {\n\t\t// lvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// lvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// lvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// lvattr->descriptor_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// lvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_local_variable_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaLocalVariableAttribute *lvattr;\n\tut64 curpos = 0, offset = 6;\n\tRBinJavaAttrInfo *attr;\n\tut32 i = 0;\n\tif (!buffer || sz < 1) {\n\t\treturn NULL;\n\t}\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TABLE_ATTR;\n\tattr->info.local_variable_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.local_variable_table_attr.local_variable_table =\\\n\t\tr_list_newf (r_bin_java_local_variable_table_attr_entry_free);\n\tfor (i = 0; i < attr->info.local_variable_table_attr.table_length; i++) {\n\t\tif (offset + 10 > sz) {\n\t\t\tbreak;\n\t\t}\n\t\tcurpos = buf_offset + offset;\n\t\tlvattr = R_NEW0 (RBinJavaLocalVariableAttribute);\n\t\tlvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->descriptor_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->file_offset = curpos;\n\t\tlvattr->name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->name_idx);\n\t\tlvattr->size = 10;\n\t\tif (!lvattr->name) {\n\t\t\tlvattr->name = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_table_attr_new: Unable to find the name for %d index.\\n\", lvattr->name_idx);\n\t\t}\n\t\tlvattr->descriptor = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->descriptor_idx);\n\t\tif (!lvattr->descriptor) {\n\t\t\tlvattr->descriptor = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_table_attr_new: Unable to find the descriptor for %d index.\\n\", lvattr->descriptor_idx);\n\t\t}\n\t\tr_list_append (attr->info.local_variable_table_attr.local_variable_table, lvattr);\n\t}\n\tattr->size = offset;\n\t// IFDBG r_bin_java_print_local_variable_table_attr_summary(attr);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_local_variable_type_table_attr_calc_size(RBinJavaAttrInfo *attr) {\n\t// RBinJavaLocalVariableTypeAttribute *lvattr;\n\tRListIter *iter;\n\tut64 size = 0;\n\tif (attr) {\n\t\tRList *list = attr->info.local_variable_type_table_attr.local_variable_table;\n\t\tsize += 6;\n\t\t// attr->info.local_variable_type_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// r_list_foreach (list, iter, lvattr) {\n\t\tr_list_foreach_iter (list, iter) {\n\t\t\t// lvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->signature_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaLocalVariableTypeAttribute *lvattr;\n\tut64 offset = 6;\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, 0);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TYPE_TABLE_ATTR;\n\tattr->info.local_variable_type_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.local_variable_type_table_attr.local_variable_table = r_list_newf (r_bin_java_local_variable_type_table_attr_entry_free);\n\tfor (i = 0; i < attr->info.local_variable_type_table_attr.table_length; i++) {\n\t\tut64 curpos = buf_offset + offset;\n\t\tlvattr = R_NEW0 (RBinJavaLocalVariableTypeAttribute);\n\t\tif (!lvattr) {\n\t\t\tperror (\"calloc\");\n\t\t\tbreak;\n\t\t}\n\t\tlvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->signature_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->file_offset = curpos;\n\t\tlvattr->name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->name_idx);\n\t\tlvattr->size = 10;\n\t\tif (!lvattr->name) {\n\t\t\tlvattr->name = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_type_table_attr_new: Unable to find the name for %d index.\\n\", lvattr->name_idx);\n\t\t}\n\t\tlvattr->signature = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->signature_idx);\n\t\tif (!lvattr->signature) {\n\t\t\tlvattr->signature = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_type_table_attr_new: Unable to find the descriptor for %d index.\\n\", lvattr->signature_idx);\n\t\t}\n\t\tr_list_append (attr->info.local_variable_type_table_attr.local_variable_table, lvattr);\n\t}\n\t// IFDBG r_bin_java_print_local_variable_type_table_attr_summary(attr);\n\tattr->size = offset;\n\treturn attr;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tif (!sz) {\n\t\treturn NULL;\n\t}\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;\n\t// if (buffer + offset > buffer + sz) return NULL;\n\tattr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->size = offset;\n\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_source_code_file_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? 8 : 0;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n\tattr->size = offset;\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_synthetic_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? 12 : 6;\n}\n\nR_API RBinJavaInterfaceInfo *r_bin_java_interface_new(RBinJavaObj *bin, const ut8 *buffer, ut64 sz) {\n\tRBinJavaInterfaceInfo *ifobj = NULL;\n\tifobj = R_NEW0 (RBinJavaInterfaceInfo);\n\tIFDBG eprintf(\"Parsing RBinJavaInterfaceInfo\\n\");\n\tif (ifobj) {\n\t\tif (buffer) {\n\t\t\tifobj->class_info_idx = R_BIN_JAVA_USHORT (buffer, 0);\n\t\t\tifobj->cp_class = r_bin_java_get_item_from_bin_cp_list (bin, ifobj->class_info_idx);\n\t\t\tif (ifobj->cp_class) {\n\t\t\t\tifobj->name = r_bin_java_get_item_name_from_bin_cp_list (bin, ifobj->cp_class);\n\t\t\t} else {\n\t\t\t\tifobj->name = r_str_dup (NULL, \"NULL\");\n\t\t\t}\n\t\t\tifobj->size = 2;\n\t\t} else {\n\t\t\tifobj->class_info_idx = 0;\n\t\t\tifobj->name = r_str_dup (NULL, \"NULL\");\n\t\t}\n\t}\n\treturn ifobj;\n}\n\nR_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->tag = type;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = (ut16) value;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\t/*if (bin->offset_sz == 4) {\n\t\tse->info.uninit_offset = value;\n\t\t} else {\n\t\tse->info.uninit_offset = (ut16) value;\n\t\t}*/\n\t\tse->info.uninit_offset = (ut16) value;\n\t}\n\treturn se;\n}\n\nR_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->file_offset = buf_offset;\n\tse->tag = buffer[offset];\n\toffset += 1;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tse->info.uninit_offset = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t}\n\tif (R_BIN_JAVA_STACKMAP_UNINIT < se->tag) {\n\t\tr_bin_java_verification_info_free (se);\n\t\treturn NULL;\n\t}\n\tse->size = offset;\n\treturn se;\n}\n\nR_API ut64 rbin_java_verification_info_calc_size(RBinJavaVerificationObj *se) {\n\tut64 sz = 1;\n\tif (!se) {\n\t\treturn 0;\n\t}\n\t// r_buf_read_at (bin->b, offset, (ut8*)(&se->tag), 1)\n\tswitch (se->tag) {\n\tcase R_BIN_JAVA_STACKMAP_OBJECT:\n\t\t// r_buf_read_at (bin->b, offset+1, (ut8*)buf, 2)\n\t\tsz += 2;\n\t\tbreak;\n\tcase R_BIN_JAVA_STACKMAP_UNINIT:\n\t\t// r_buf_read_at (bin->b, offset+1, (ut8*)buf, 2)\n\t\tsz += 2;\n\t\tbreak;\n\t}\n\treturn sz;\n}\n\nR_API RBinJavaStackMapFrameMetas *r_bin_java_determine_stack_frame_type(ut8 tag) {\n\tut8 type_value = 0;\n\tif (tag < 64) {\n\t\ttype_value = R_BIN_JAVA_STACK_FRAME_SAME;\n\t} else if (63 < tag && tag < 128) {\n\t\ttype_value = R_BIN_JAVA_STACK_FRAME_SAME_LOCALS_1;\n\t} else if (247 < tag && tag < 251) {\n\t\ttype_value = R_BIN_JAVA_STACK_FRAME_CHOP;\n\t} else if (tag == 251) {\n\t\ttype_value = R_BIN_JAVA_STACK_FRAME_SAME_FRAME_EXTENDED;\n\t} else if (251 < tag && tag < 255) {\n\t\ttype_value = R_BIN_JAVA_STACK_FRAME_APPEND;\n\t} else if (tag == 255) {\n\t\ttype_value = R_BIN_JAVA_STACK_FRAME_FULL_FRAME;\n\t} else {\n\t\ttype_value = R_BIN_JAVA_STACK_FRAME_RESERVED;\n\t}\n\treturn &R_BIN_JAVA_STACK_MAP_FRAME_METAS[type_value];\n}\n\nR_API ut64 r_bin_java_stack_map_frame_calc_size(RBinJavaStackMapFrame *sf) {\n\tut64 size = 0;\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaVerificationObj *se;\n\tif (sf) {\n\t\t// sf->tag = buffer[offset];\n\t\tsize += 1;\n\t\tswitch (sf->type) {\n\t\tcase R_BIN_JAVA_STACK_FRAME_SAME:\n\t\t\t// Nothing to read\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_SAME_LOCALS_1:\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_CHOP:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_SAME_FRAME_EXTENDED:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_APPEND:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_FULL_FRAME:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// sf->number_of_locals = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->local_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\t// sf->number_of_stack_items = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Unknown type\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API RBinJavaStackMapFrame *r_bin_java_stack_map_frame_new(ut8 *buffer, ut64 sz, RBinJavaStackMapFrame *p_frame, ut64 buf_offset) {\n\tRBinJavaStackMapFrame *stack_frame = r_bin_java_default_stack_frame ();\n\tRBinJavaVerificationObj *se = NULL;\n\tut64 offset = 0;\n\tif (!stack_frame) {\n\t\treturn NULL;\n\t}\n\tstack_frame->tag = buffer[offset];\n\toffset += 1;\n\tstack_frame->metas->type_info = (void *) r_bin_java_determine_stack_frame_type (stack_frame->tag);\n\tstack_frame->type = ((RBinJavaStackMapFrameMetas *) stack_frame->metas->type_info)->type;\n\tstack_frame->file_offset = buf_offset;\n\tstack_frame->p_stack_frame = p_frame;\n\tswitch (stack_frame->type) {\n\tcase R_BIN_JAVA_STACK_FRAME_SAME:\n\t\t// Maybe?  1. Copy the previous frames locals and set the locals count.\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals;\n\t\t} else {\n\t\t\tIFINT eprintf(\"><?><\\n\");\n\t\t\tIFDBG eprintf(\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: TODO Stack Frame Same Locals Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_SAME_LOCALS_1:\n\t\t// 1. Read the stack type\n\t\tstack_frame->number_of_stack_items = 1;\n\t\tif (offset > sz) {\n\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\treturn NULL;\n\t\t}\n\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Parsed R_BIN_JAVA_STACK_FRAME_SAME_LOCALS_1.\\n\");\n\t\tif (se) {\n\t\t\toffset += se->size;\n\t\t} else {\n\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the Stack Items for the stack frame.\\n\");\n\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\treturn NULL;\n\t\t}\n\t\tr_list_append (stack_frame->stack_items, (void *) se);\n\t\t// Maybe?  3. Copy the previous frames locals and set the locals count.\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals;\n\t\t} else {\n\t\t\tIFDBG eprintf(\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: TODO Stack Frame Same Locals 1 Stack Element Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_CHOP:\n\t\t// 1. Calculate the max index we want to copy from the list of the\n\t\t// previous frames locals\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Parsing R_BIN_JAVA_STACK_FRAME_CHOP.\\n\");\n\t\t// ut16 k = 251 - stack_frame->tag;\n\t\t/*,\n\t\tidx = p_frame->number_of_locals - k;\n\t\t*/\n\t\t// 2.  read the uoffset value\n\t\tstack_frame->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// Maybe? 3. Copy the previous frames locals and set the locals count.\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals;\n\t\t} else {\n\t\t\tIFINT eprintf(\"><?><\\n\");\n\t\t\tIFDBG eprintf(\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: TODO Stack Frame Chop Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_SAME_FRAME_EXTENDED:\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Parsing R_BIN_JAVA_STACK_FRAME_SAME_FRAME_EXTENDED.\\n\");\n\t\t// 1. Read the uoffset\n\t\tstack_frame->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// 2. Read the stack element type\n\t\tstack_frame->number_of_stack_items = 1;\n\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (se) {\n\t\t\toffset += se->size;\n\t\t} else {\n\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the Stack Items for the stack frame.\\n\");\n\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\treturn NULL;\n\t\t}\n\t\tr_list_append (stack_frame->stack_items, (void *) se);\n\t\t// Maybe? 3. Copy the previous frames locals to the current locals\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals;\n\t\t} else {\n\t\t\tIFINT eprintf(\"><?><\\n\");\n\t\t\tIFDBG eprintf(\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: TODO Stack Frame Same Locals Frame Stack 1 Extended Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_APPEND:\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Parsing R_BIN_JAVA_STACK_FRAME_APPEND.\\n\");\n\t\t// 1. Calculate the max index we want to copy from the list of the\n\t\t// previous frames locals\n\t\tut16 k = stack_frame->tag - 251,\n\t\ti = 0;\n\t\t// 2. Read the uoffset\n\t\tstack_frame->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// Maybe? 3. Copy the previous frames locals to the current locals\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\t// 4. Read off the rest of the appended locals types\n\t\tfor (i = 0; i < k; i++) {\n\t\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Parsing verifying the k'th frame: %d of %d.\\n\", i, k);\n\t\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Completed Parsing\\n\");\n\t\t\tif (se) {\n\t\t\t\toffset += se->size;\n\t\t\t} else {\n\t\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the locals for the stack frame.\\n\");\n\t\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tr_list_append (stack_frame->local_items, (void *) se);\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Breaking out of loop\");\n\t\tIFDBG eprintf(\"p_frame: %p\\n\", p_frame);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals + k;\n\t\t} else {\n\t\t\tIFINT eprintf(\"><?><\\n\");\n\t\t\tIFDBG eprintf(\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: TODO Stack Frame Same Locals Frame Stack 1 Extended Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_FULL_FRAME:\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Parsing R_BIN_JAVA_STACK_FRAME_FULL_FRAME.\\n\");\n\t\tstack_frame->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// IFDBG eprintf (\"r_bin_java_stack_map_frame_new: Code Size > 65535, read(%d byte(s)), offset = 0x%08x.\\n\", var_sz, stack_frame->offset_delta);\n\t\t// Read the number of variables based on the max # local variable\n\t\tstack_frame->number_of_locals = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// IFDBG eprintf (\"r_bin_java_stack_map_frame_new: Max ulocalvar > 65535, read(%d byte(s)), number_of_locals = 0x%08x.\\n\", var_sz, stack_frame->number_of_locals);\n\t\tIFDBG r_bin_java_print_stack_map_frame_summary(stack_frame);\n\t\t// read the number of locals off the stack\n\t\tfor (i = 0; i < stack_frame->number_of_locals; i++) {\n\t\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (se) {\n\t\t\t\toffset += se->size;\n\t\t\t\t// r_list_append (stack_frame->local_items, (void *) se);\n\t\t\t} else {\n\t\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the locals for the stack frame.\\n\");\n\t\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tr_list_append (stack_frame->local_items, (void *) se);\n\t\t}\n\t\t// Read the number of stack items based on the max size of stack\n\t\tstack_frame->number_of_stack_items = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// IFDBG eprintf (\"r_bin_java_stack_map_frame_new: Max ustack items > 65535, read(%d byte(s)), number_of_locals = 0x%08x.\\n\", var_sz, stack_frame->number_of_stack_items);\n\t\t// read the stack items\n\t\tfor (i = 0; i < stack_frame->number_of_stack_items; i++) {\n\t\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (se) {\n\t\t\t\toffset += se->size;\n\t\t\t\t// r_list_append (stack_frame->stack_items, (void *) se);\n\t\t\t} else {\n\t\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the stack items for the stack frame.\\n\");\n\t\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tr_list_append (stack_frame->local_items, (void *) se);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"java: Unknown type\\n\");\n\t\tbreak;\n\t}\n\t// IFDBG eprintf (\"Created a stack frame at offset(0x%08\"PFMT64x\") of size: %d\\n\", buf_offset, stack_frame->size);//r_bin_java_print_stack_map_frame_summary(stack_frame);\n\tstack_frame->size = offset;\n\t// IFDBG r_bin_java_print_stack_map_frame_summary(stack_frame);\n\treturn stack_frame;\n}\n\nR_API ut16 r_bin_java_find_cp_class_ref_from_name_idx(RBinJavaObj *bin, ut16 name_idx) {\n\tut16 pos, len = (ut16) r_list_length (bin->cp_list);\n\tRBinJavaCPTypeObj *item;\n\tfor (pos = 0; pos < len; pos++) {\n\t\titem = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, pos);\n\t\tif (item && item->tag == R_BIN_JAVA_CP_CLASS && item->info.cp_class.name_idx == name_idx) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (pos != len) ? pos : 0;\n}\n\nR_API RBinJavaStackMapFrame *r_bin_java_default_stack_frame() {\n\tRBinJavaStackMapFrame *sf = R_NEW0 (RBinJavaStackMapFrame);\n\tif (!sf) {\n\t\treturn NULL;\n\t}\n\tsf->metas = R_NEW0 (RBinJavaMetaInfo);\n\tif (!sf->metas) {\n\t\tfree (sf);\n\t\treturn NULL;\n\t}\n\tsf->metas->type_info = (void *) &R_BIN_JAVA_STACK_MAP_FRAME_METAS[R_BIN_JAVA_STACK_FRAME_IMPLICIT];\n\tsf->type = ((RBinJavaStackMapFrameMetas *) sf->metas->type_info)->type;\n\tsf->local_items = r_list_newf (r_bin_java_verification_info_free);\n\tsf->stack_items = r_list_newf (r_bin_java_verification_info_free);\n\tsf->number_of_stack_items = 0;\n\tsf->number_of_locals = 0;\n\treturn sf;\n}\n\nR_API RBinJavaStackMapFrame *r_bin_java_build_stack_frame_from_local_variable_table(RBinJavaObj *bin, RBinJavaAttrInfo *attr) {\n\tRBinJavaStackMapFrame *sf = r_bin_java_default_stack_frame ();\n\tRBinJavaLocalVariableAttribute *lvattr = NULL;\n\tRBinJavaVerificationObj *type_item;\n\tRListIter *iter = NULL;\n\tut32 value_cnt = 0;\n\tut8 value;\n\tif (!sf || !bin || !attr || attr->type != R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TABLE_ATTR) {\n\t\teprintf (\"Attempting to create a stack_map frame from a bad attribute.\\n\");\n\t\treturn sf;\n\t}\n\tsf->number_of_locals = attr->info.local_variable_table_attr.table_length;\n\tr_list_foreach (attr->info.local_variable_table_attr.local_variable_table, iter, lvattr) {\n\t\tut32 pos = 0;\n\t\t// knock the array Types\n\t\twhile (lvattr->descriptor[pos] == '[') {\n\t\t\tpos++;\n\t\t}\n\t\tvalue = lvattr->descriptor[pos];\n\t\t// IFDBG eprintf (\"Found the following type value: %c at pos %d in %s\\n\", value, pos, lvattr->descriptor);\n\t\tswitch (value) {\n\t\tcase 'I':\n\t\tcase 'Z':\n\t\tcase 'S':\n\t\tcase 'B':\n\t\tcase 'C':\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_INTEGER, 0);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_FLOAT, 0);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_DOUBLE, 0);\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_LONG, 0);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\t// TODO: FIXME write something that will iterate over the CP Pool and find the\n\t\t\t// CONSTANT_Class_info referencing this\n\t\t{\n\t\t\tut16 idx = r_bin_java_find_cp_class_ref_from_name_idx (bin, lvattr->name_idx);\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_OBJECT, idx);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"r_bin_java_build_stack_frame_from_local_variable_table: \"\n\t\t\t\t\"not sure how to handle: name: %s, type: %s\\n\", lvattr->name, lvattr->descriptor);\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_NULL, 0);\n\t\t}\n\t\tif (type_item) {\n\t\t\tr_list_append (sf->local_items, (void *) type_item);\n\t\t}\n\t\tvalue_cnt++;\n\t}\n\tif (value_cnt != attr->info.local_variable_table_attr.table_length) {\n\t\tIFDBG eprintf(\"r_bin_java_build_stack_frame_from_local_variable_table: \"\n\t\t\"Number of locals not accurate.  Expected %d but got %d\",\n\t\tattr->info.local_variable_table_attr.table_length, value_cnt);\n\t}\n\treturn sf;\n}\n\nR_API ut64 r_bin_java_stack_map_table_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaStackMapFrame *sf;\n\tif (attr) {\n\t\t// attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\t\tsize += 6;\n\t\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n\t\t// Current spec does not call for variable sizes.\n\t\t// attr->info.stack_map_table_attr.number_of_entries = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\tr_list_foreach_safe (attr->info.stack_map_table_attr.stack_map_frame_entries, iter, iter_tmp, sf) {\n\t\t\tsize += r_bin_java_stack_map_frame_calc_size (sf);\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tRBinJavaStackMapFrame *stack_frame = NULL, *new_stack_frame = NULL;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tIFDBG eprintf(\"r_bin_java_stack_map_table_attr_new: New stack map allocated.\\n\");\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->info.stack_map_table_attr.stack_map_frame_entries = r_list_newf (r_bin_java_stack_frame_free);\n\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n\t// Current spec does not call for variable sizes.\n\tattr->info.stack_map_table_attr.number_of_entries = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tIFDBG eprintf(\"r_bin_java_stack_map_table_attr_new: Processing stack map, summary is:\\n\");\n\tIFDBG r_bin_java_print_stack_map_table_attr_summary(attr);\n\tfor (i = 0; i < attr->info.stack_map_table_attr.number_of_entries; i++) {\n\t\t// read next stack frame\n\t\tIFDBG eprintf(\"Reading StackMap Entry #%d @ 0x%08\"PFMT64x \"\\n\", i, buf_offset + offset);\n\t\tif (stack_frame == NULL && R_BIN_JAVA_GLOBAL_BIN && R_BIN_JAVA_GLOBAL_BIN->current_code_attr) {\n\t\t\tIFDBG eprintf(\"Setting an implicit frame at #%d @ 0x%08\"PFMT64x \"\\n\", i, buf_offset + offset);\n\t\t\tstack_frame = R_BIN_JAVA_GLOBAL_BIN->current_code_attr->info.code_attr.implicit_frame;\n\t\t}\n\t\tIFDBG eprintf(\"Reading StackMap Entry #%d @ 0x%08\"PFMT64x \", current stack_frame: %p\\n\", i, buf_offset + offset, stack_frame);\n\t\tif (offset > sz) {\n\t\t\tr_bin_java_stack_map_table_attr_free (attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_stack_frame = r_bin_java_stack_map_frame_new (buffer + offset, sz - offset, stack_frame, buf_offset + offset);\n\t\tif (new_stack_frame) {\n\t\t\toffset += new_stack_frame->size;\n\t\t\t// append stack frame to the list\n\t\t\tr_list_append (attr->info.stack_map_table_attr.stack_map_frame_entries, (void *) new_stack_frame);\n\t\t\tstack_frame = new_stack_frame;\n\t\t} else {\n\t\t\teprintf (\"r_bin_java_stack_map_table_attr_new: Unable to parse the stack frame for the stack map table.\\n\");\n\t\t\tr_bin_java_stack_map_table_attr_free (attr);\n\t\t\tattr = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (attr) {\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n// End attribute types new\n// Start new Constant Pool Types\nR_API RBinJavaCPTypeObj *r_bin_java_do_nothing_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\treturn (RBinJavaCPTypeObj *) NULL;\n}\n\nR_API ut64 r_bin_java_do_nothing_calc_size(RBinJavaCPTypeObj *obj) {\n\treturn 0;\n}\n\nR_API void r_bin_java_do_nothing_free(void /*RBinJavaCPTypeObj*/ *obj) {\n\treturn;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_unknown_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tobj = (RBinJavaCPTypeObj *) malloc (sizeof (RBinJavaCPTypeObj));\n\tif (obj) {\n\t\tmemset (obj, 0, sizeof (RBinJavaCPTypeObj));\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[R_BIN_JAVA_CP_UNKNOWN];\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_unknown_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\treturn 1LL;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_class_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tint quick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_CLASS, tag, sz, \"Class\");\n\tif (quick_check > 0) {\n\t\treturn NULL;\n\t}\n\tRBinJavaCPTypeObj *obj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (obj) {\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->info.cp_class.name_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_class_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// ut8 tag = buffer[0];\n\tsize += 1;\n\t// obj->info.cp_class.name_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_fieldref_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tint quick_check = 0;\n\tquick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_FIELDREF, tag, sz, \"FieldRef\");\n\tif (quick_check > 0) {\n\t\treturn obj;\n\t}\n\tobj = (RBinJavaCPTypeObj *) malloc (sizeof (RBinJavaCPTypeObj));\n\tif (obj) {\n\t\tmemset (obj, 0, sizeof (RBinJavaCPTypeObj));\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->info.cp_field.class_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\t\tobj->info.cp_field.name_and_type_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\n\t}\n\treturn (RBinJavaCPTypeObj *) obj;\n}\n\nR_API ut64 r_bin_java_fieldref_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_field.class_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 2;\n\t// obj->info.cp_field.name_and_type_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_methodref_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tint quick_check = 0;\n\tquick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_METHODREF, tag, sz, \"MethodRef\");\n\tif (quick_check > 0) {\n\t\treturn obj;\n\t}\n\tobj = (RBinJavaCPTypeObj *) malloc (sizeof (RBinJavaCPTypeObj));\n\tif (obj) {\n\t\tmemset (obj, 0, sizeof (RBinJavaCPTypeObj));\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->info.cp_method.class_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\t\tobj->info.cp_method.name_and_type_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_methodref_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_method.class_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 2;\n\t// obj->info.cp_method.name_and_type_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_interfacemethodref_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tint quick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_INTERFACEMETHOD_REF, tag, sz, \"InterfaceMethodRef\");\n\tif (quick_check > 0) {\n\t\treturn NULL;\n\t}\n\tRBinJavaCPTypeObj *obj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (obj) {\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);\n\t\tobj->info.cp_interface.class_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\t\tobj->info.cp_interface.name_and_type_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_interfacemethodref_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_interface.class_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 2;\n\t// obj->info.cp_interface.name_and_type_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_string_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tint quick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_STRING, tag, sz, \"String\");\n\tif (quick_check > 0) {\n\t\treturn NULL;\n\t}\n\tRBinJavaCPTypeObj *obj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (obj) {\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);\n\t\tobj->info.cp_string.string_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_string_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_string.string_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_integer_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tint quick_check = 0;\n\tquick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_INTEGER, tag, sz, \"Integer\");\n\tif (quick_check > 0) {\n\t\treturn obj;\n\t}\n\tobj = (RBinJavaCPTypeObj *) R_NEW0 (RBinJavaCPTypeObj);\n\tif (obj) {\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);\n\t\tmemset (&obj->info.cp_integer.bytes, 0, sizeof (obj->info.cp_integer.bytes));\n\t\tmemcpy (&obj->info.cp_integer.bytes.raw, buffer + 1, 4);\n\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_integer_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_string.string_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 4;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_float_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tint quick_check = 0;\n\tquick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_FLOAT, tag, sz, \"Float\");\n\tif (quick_check > 0) {\n\t\treturn obj;\n\t}\n\tobj = (RBinJavaCPTypeObj *) calloc (1, sizeof (RBinJavaCPTypeObj));\n\tif (obj) {\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);\n\t\tmemset (&obj->info.cp_float.bytes, 0, sizeof (obj->info.cp_float.bytes));\n\t\tmemcpy (&obj->info.cp_float.bytes.raw, buffer, 4);\n\t}\n\treturn (RBinJavaCPTypeObj *) obj;\n}\n\nR_API ut64 r_bin_java_float_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_string.string_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 4;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_long_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tint quick_check = 0;\n\tquick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_LONG, tag, sz, \"Long\");\n\tif (quick_check > 0) {\n\t\treturn obj;\n\t}\n\tobj = (RBinJavaCPTypeObj *) malloc (sizeof (RBinJavaCPTypeObj));\n\tif (obj) {\n\t\tmemset (obj, 0, sizeof (RBinJavaCPTypeObj));\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);\n\t\tmemset (&obj->info.cp_long.bytes, 0, sizeof (obj->info.cp_long.bytes));\n\t\tmemcpy (&(obj->info.cp_long.bytes), buffer + 1, 8);\n\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_long_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_string.string_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 8;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_double_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tint quick_check = 0;\n\tquick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_DOUBLE, tag, sz, \"Double\");\n\tif (quick_check > 0) {\n\t\treturn (RBinJavaCPTypeObj *) obj;\n\t}\n\tobj = (RBinJavaCPTypeObj *) malloc (sizeof (RBinJavaCPTypeObj));\n\tif (obj) {\n\t\tmemset (obj, 0, sizeof (RBinJavaCPTypeObj));\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);\n\t\tmemset (&obj->info.cp_double.bytes, 0, sizeof (obj->info.cp_double.bytes));\n\t\tmemcpy (&obj->info.cp_double.bytes, buffer + 1, 8);\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_double_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_string.string_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 8;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_utf8_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj;\n\tint quick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_UTF8, tag, sz, \"Utf8\");\n\tif (quick_check > 0) {\n\t\treturn NULL;\n\t}\n\tif ((obj = R_NEW0 (RBinJavaCPTypeObj))) {\n\t\tmemset (obj, 0, sizeof (RBinJavaCPTypeObj));\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);\n\t\tobj->info.cp_utf8.length = R_BIN_JAVA_USHORT (buffer, 1);\n\t\tobj->info.cp_utf8.bytes = (ut8 *) malloc (obj->info.cp_utf8.length + 1);\n\t\tif (obj->info.cp_utf8.bytes) {\n\t\t\tmemset (obj->info.cp_utf8.bytes, 0, obj->info.cp_utf8.length + 1);\n\t\t\tif (obj->info.cp_utf8.length < (sz - 3)) {\n\t\t\t\tmemcpy (obj->info.cp_utf8.bytes, buffer + 3, (sz - 3));\n\t\t\t\tobj->info.cp_utf8.length = sz - 3;\n\t\t\t} else {\n\t\t\t\tmemcpy (obj->info.cp_utf8.bytes, buffer + 3, obj->info.cp_utf8.length);\n\t\t\t}\n\t\t\tobj->value = obj->info.cp_utf8.bytes;\n\t\t} else {\n\t\t\tr_bin_java_obj_free (obj);\n\t\t\tobj = NULL;\n\t\t}\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_utf8_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\tsize += 1;\n\tif (obj && R_BIN_JAVA_CP_UTF8 == obj->tag) {\n\t\tsize += 2;\n\t\tsize += obj->info.cp_utf8.length;\n\t}\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_name_and_type_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tint quick_check = 0;\n\tquick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_NAMEANDTYPE, tag, sz, \"RBinJavaCPTypeNameAndType\");\n\tif (quick_check > 0) {\n\t\treturn obj;\n\t}\n\tobj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (obj) {\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);;\n\t\tobj->tag = tag;\n\t\tobj->info.cp_name_and_type.name_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\t\tobj->info.cp_name_and_type.descriptor_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_name_and_type_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\tif (obj) {\n\t\tsize += 1;\n\t\t// obj->info.cp_name_and_type.name_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\t\tsize += 2;\n\t\t// obj->info.cp_name_and_type.descriptor_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\t\tsize += 2;\n\t}\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_methodtype_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tint quick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_METHODTYPE, tag, sz, \"RBinJavaCPTypeMethodType\");\n\tif (quick_check > 0) {\n\t\treturn NULL;\n\t}\n\tRBinJavaCPTypeObj *obj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (obj) {\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);;\n\t\tobj->tag = tag;\n\t\tobj->info.cp_method_type.descriptor_index = R_BIN_JAVA_USHORT (buffer, 1);\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_methodtype_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\tsize += 1;\n\t// obj->info.cp_method_type.descriptor_index = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_methodhandle_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tint quick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_METHODHANDLE, tag, sz, \"RBinJavaCPTypeMethodHandle\");\n\tif (quick_check > 0) {\n\t\treturn NULL;\n\t}\n\tRBinJavaCPTypeObj *obj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (obj) {\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);;\n\t\tobj->tag = tag;\n\t\tobj->info.cp_method_handle.reference_kind = buffer[1];\n\t\tobj->info.cp_method_handle.reference_index = R_BIN_JAVA_USHORT (buffer, 2);\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_methodhandle_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\tsize += 1;\n\t// obj->info.cp_method_handle.reference_index =  R_BIN_JAVA_USHORT (buffer, 2);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_invokedynamic_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj;\n\tint quick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_INVOKEDYNAMIC, tag, sz, \"RBinJavaCPTypeMethodHandle\");\n\tif (quick_check > 0) {\n\t\treturn NULL;\n\t}\n\tif ((obj = R_NEW0 (RBinJavaCPTypeObj))) {\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);;\n\t\tobj->tag = tag;\n\t\tobj->info.cp_invoke_dynamic.bootstrap_method_attr_index = R_BIN_JAVA_USHORT (buffer, 1);\n\t\tobj->info.cp_invoke_dynamic.name_and_type_index = R_BIN_JAVA_USHORT (buffer, 3);\n\t}\n\treturn obj;\n}\n\nR_API int r_bin_java_check_reset_cp_obj(RBinJavaCPTypeObj *cp_obj, ut8 tag) {\n\tbool res = false;\n\tif (tag < R_BIN_JAVA_CP_METAS_SZ) {\n\t\tif (tag != cp_obj->tag) {\n\t\t\tif (cp_obj->tag == R_BIN_JAVA_CP_UTF8) {\n\t\t\t\tfree (cp_obj->info.cp_utf8.bytes);\n\t\t\t\tcp_obj->info.cp_utf8.bytes = NULL;\n\t\t\t\tcp_obj->info.cp_utf8.length = 0;\n\t\t\t\tfree (cp_obj->name);\n\t\t\t\tcp_obj->name = NULL;\n\t\t\t\tres = true;\n\t\t\t}\n\t\t\tcp_obj->tag = tag;\n\t\t\tcp_obj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\t\tcp_obj->name = strdup (R_BIN_JAVA_CP_METAS[tag].name);\n\t\t\tres = true;\n\t\t} else {\n\t\t\teprintf (\"Invalid tag\\n\");\n\t\t}\n\t} else {\n\t\teprintf (\"Invalid tag '%d'.\\n\", tag);\n\t}\n\treturn res;\n}\n\nR_API ut8 *r_bin_java_cp_get_4bytes(ut8 tag, ut32 *out_sz, const ut8 *buf, const ut64 len) {\n\tut8 *buffer = malloc (5);\n\tif (!buffer) {\n\t\treturn NULL;\n\t}\n\tut32 val = 0;\n\tif (!buffer || len < 4) {\n\t\tif (out_sz) {\n\t\t\t*out_sz = 0;\n\t\t}\n\t\tfree (buffer);\n\t\treturn NULL;\n\t}\n\tbuffer[0] = tag;\n\tval = R_BIN_JAVA_UINT (buf, 0);\n\tmemcpy (buffer + 1, (const char *) &val, 4);\n\t*out_sz = 5;\n\treturn buffer;\n}\n\nR_API ut8 *r_bin_java_cp_get_8bytes(ut8 tag, ut32 *out_sz, const ut8 *buf, const ut64 len) {\n\tut8 *buffer = malloc (10);\n\tif (!buffer) {\n\t\treturn NULL;\n\t}\n\tut64 val = 0;\n\tif (len < 8) {\n\t\t*out_sz = 0;\n\t\tfree (buffer);\n\t\treturn NULL;\n\t}\n\tbuffer[0] = tag;\n\tval = r_bin_java_raw_to_long (buf, 0);\n\tmemcpy (buffer + 1, (const char *) &val, 8);\n\t*out_sz = 9;\n\treturn buffer;\n}\n\nR_API ut8 *r_bin_java_cp_append_classref_and_name(RBinJavaObj *bin, ut32 *out_sz, const char *classname, const ut32 classname_len) {\n\tut16 use_name_idx = bin->cp_idx + 1;\n\tut8 *bytes = NULL, *name_bytes = NULL;\n\tname_bytes = r_bin_java_cp_get_utf8 (R_BIN_JAVA_CP_UTF8, out_sz, (const ut8 *) classname, classname_len);\n\tif (*out_sz > 0 && name_bytes) {\n\t\tut8 *idx_addr = (ut8 *) &use_name_idx;\n\t\tbytes = malloc (*out_sz + 3);\n\t\tmemcpy (bytes, name_bytes, *out_sz);\n\t\tbytes[*out_sz + 0] = R_BIN_JAVA_CP_CLASS;\n\t\tbytes[*out_sz + 1] = idx_addr[1];\n\t\tbytes[*out_sz + 2] = idx_addr[0];\n\t\t*out_sz += 3;\n\t}\n\tfree (name_bytes);\n\treturn bytes;\n}\n\nR_API ut8 *r_bin_java_cp_get_fref_bytes(RBinJavaObj *bin, ut32 *out_sz, ut8 tag, ut16 cn_idx, ut16 fn_idx, ut16 ft_idx) {\n\tut8 *bytes = NULL, *fnt_bytes = NULL;\n\tRBinJavaCPTypeObj *ref_cp_obj = NULL;\n\tut16 fnt_idx = 0, cref_idx = 0;\n\tut32 fnt_len = 0;\n\tut16 ref_cp_obj_idx = r_bin_java_find_cp_class_ref_from_name_idx (bin, cn_idx);\n\tif (!ref_cp_obj_idx) {\n\t\treturn NULL;\n\t}\n\tref_cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, ref_cp_obj_idx);\n\tif (ref_cp_obj) {\n\t\tcref_idx = ref_cp_obj->idx;\n\t}\n\tref_cp_obj = r_bin_java_find_cp_name_and_type_info (bin, fn_idx, ft_idx);\n\tif (ref_cp_obj) {\n\t\tfnt_idx = ref_cp_obj->idx;\n\t} else {\n\t\tfnt_bytes = r_bin_java_cp_get_name_type (bin, &fnt_len, fn_idx, ft_idx);\n\t\tfnt_idx = bin->cp_idx + 1;\n\t}\n\tif (cref_idx && fnt_idx) {\n\t\tbytes = r_bin_java_cp_get_fm_ref (bin, out_sz, tag, cref_idx, fnt_idx);\n\t\tif (fnt_bytes) {\n\t\t\tut8 *tbuf = malloc (fnt_len + *out_sz);\n\t\t\tif (!tbuf) {\n\t\t\t\tfree (bytes);\n\t\t\t\tfree (fnt_bytes);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t// copy the bytes to the new buffer\n\t\t\tmemcpy (tbuf, fnt_bytes, fnt_len);\n\t\t\tmemcpy (tbuf + fnt_len, bytes, *out_sz);\n\t\t\t// update the values free old buffer\n\t\t\t*out_sz += fnt_len;\n\t\t\tfree (bytes);\n\t\t\tbytes = tbuf;\n\t\t}\n\t}\n\tfree (fnt_bytes);\n\treturn bytes;\n}\n\nR_API ut8 *r_bin_java_cp_get_classref(RBinJavaObj *bin, ut32 *out_sz, const char *classname, const ut32 classname_len, const ut16 name_idx) {\n\tut16 use_name_idx = -1;\n\tut8 *bytes = NULL;\n\tif (name_idx == (ut16) - 1 && classname && *classname && classname_len > 0) {\n\t\t// find class_name_idx by class name\n\t\tRList *results = r_bin_java_find_cp_const_by_val_utf8 (bin, (const ut8 *) classname, classname_len);\n\t\tif (r_list_length (results) == 1) {\n\t\t\tuse_name_idx = (ut16) * ((ut32 *) r_list_get_n (results, 0));\n\t\t}\n\t\tr_list_free (results);\n\t} else if (name_idx != (ut16) - 1 && name_idx != 0) {\n\t\tuse_name_idx = name_idx;\n\t}\n\tif (use_name_idx == (ut16) - 1 && classname && *classname && classname_len > 0) {\n\t\tbytes = r_bin_java_cp_append_classref_and_name (bin, out_sz, classname, classname_len);\n\t} else if (use_name_idx != (ut16) - 1) {\n\t\tut8 *idx_addr = (ut8 *) &use_name_idx;\n\t\tbytes = malloc (3);\n\t\tif (!bytes) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbytes[0] = R_BIN_JAVA_CP_CLASS;\n\t\tbytes[1] = idx_addr[1];\n\t\tbytes[2] = idx_addr[0];\n\t\t*out_sz += 3;\n\t}\n\treturn bytes;\n}\n\nR_API ut8 *r_bin_java_cp_get_fm_ref(RBinJavaObj *bin, ut32 *out_sz, ut8 tag, ut16 class_idx, ut16 name_and_type_idx) {\n\treturn r_bin_java_cp_get_2_ut16 (bin, out_sz, tag, class_idx, name_and_type_idx);\n}\n\nR_API ut8 *r_bin_java_cp_get_2_ut16(RBinJavaObj *bin, ut32 *out_sz, ut8 tag, ut16 ut16_one, ut16 ut16_two) {\n\tut8 *bytes = malloc (7);\n\tif (!bytes) {\n\t\treturn NULL;\n\t}\n\tut8 *idx_addr = NULL;\n\tbytes[*out_sz] = tag;\n\t*out_sz += 1;\n\tidx_addr = (ut8 *) &ut16_one;\n\tbytes[*out_sz + 1] = idx_addr[1];\n\tbytes[*out_sz + 2] = idx_addr[0];\n\t*out_sz += 3;\n\tidx_addr = (ut8 *) &ut16_two;\n\tbytes[*out_sz + 1] = idx_addr[1];\n\tbytes[*out_sz + 2] = idx_addr[0];\n\t*out_sz += 3;\n\treturn bytes;\n}\n\nR_API ut8 *r_bin_java_cp_get_name_type(RBinJavaObj *bin, ut32 *out_sz, ut16 name_idx, ut16 type_idx) {\n\treturn r_bin_java_cp_get_2_ut16 (bin, out_sz, R_BIN_JAVA_CP_NAMEANDTYPE, name_idx, type_idx);\n}\n\nR_API ut8 *r_bin_java_cp_get_utf8(ut8 tag, ut32 *out_sz, const ut8 *buf, const ut64 len) {\n\tut8 *buffer = NULL;\n\tut16 sz = 0;\n\tut16 t = (ut16) len;\n\tif (len > 0 && len > (ut16) - 1) {\n\t\t*out_sz = 0;\n\t\treturn NULL;\n\t}\n\tsz = R_BIN_JAVA_USHORT (((ut8 *) (ut16 *) &t), 0);\n\t*out_sz = 3 + t; // tag + sz + bytes\n\tbuffer = malloc (*out_sz + 3);\n\tif (!buffer) {\n\t\treturn NULL;\n\t}\n\t// XXX - excess bytes are created to ensure null for string operations.\n\tmemset (buffer, 0, *out_sz + 3);\n\tbuffer[0] = tag;\n\tmemcpy (buffer + 1, (const char *) &sz, 2);\n\tmemcpy (buffer + 3, buf, *out_sz - 3);\n\treturn buffer;\n}\n\nR_API ut64 r_bin_java_invokedynamic_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\tsize += 1;\n\t// obj->info.cp_invoke_dynamic.bootstrap_method_attr_index = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 2;\n\t// obj->info.cp_invoke_dynamic.name_and_type_index = R_BIN_JAVA_USHORT (buffer, 3);\n\tsize += 2;\n\treturn size;\n}\n// End new Constant Pool types\n// Start free Constant Pool types\nR_API void r_bin_java_default_free(void /* RBinJavaCPTypeObj*/ *o) {\n\tRBinJavaCPTypeObj *obj = o;\n\tif (obj) {\n\t\tfree (obj->metas);\n\t\tfree (obj->name);\n\t\tfree (obj->value);\n\t\tfree (obj);\n\t}\n}\n\nR_API void r_bin_java_utf8_info_free(void /* RBinJavaCPTypeObj*/ *o) {\n\tRBinJavaCPTypeObj *obj = o;\n\tif (obj) {\n\t\tfree (obj->name);\n\t\tfree (obj->metas);\n\t\tfree (obj->info.cp_utf8.bytes);\n\t\tfree (obj);\n\t}\n}\n// Deallocs for type objects\nR_API void r_bin_java_obj_free(void /*RBinJavaCPTypeObj*/ *o) {\n\tRBinJavaCPTypeObj *obj = o;\n\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n}\n\nR_API void r_bin_java_print_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (attr == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *.\\n\");\n\t\treturn;\n\t}\n\t((RBinJavaAttrMetas *) attr->metas->type_info)->allocs->print_summary (attr);\n}\n\nR_API void r_bin_java_print_source_debug_attr_summary(RBinJavaAttrInfo *attr) {\n\tut32 i = 0;\n\tif (attr == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaSourceDebugExtensionAttr *.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Source Debug Extension Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Extension Length: %d\\n\", attr->length);\n\tEprintf (\"  Source Debug Extension value: \\n\");\n\tfor (i = 0; i < attr->length; i++) {\n\t\tEprintf (\"%c\", attr->info.debug_extensions.debug_extension[i]);\n\t}\n\tEprintf (\"\\n  Source Debug Extension End\\n\");\n}\n\nR_API void r_bin_java_print_unknown_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (attr == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *Unknown.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Unknown Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n}\n\nR_API void r_bin_java_print_code_exceptions_attr_summary(RBinJavaExceptionEntry *exc_entry) {\n\tif (exc_entry == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaExceptionEntry *.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"  Exception Table Entry Information\\n\");\n\tEprintf (\"    offset:\t0x%08\"PFMT64x\"\\n\", exc_entry->file_offset);\n\tEprintf (\"    catch_type: %d\\n\", exc_entry->catch_type);\n\tEprintf (\"    start_pc:   0x%04x\\n\", exc_entry->start_pc);\n\tEprintf (\"    end_pc:\t0x%04x\\n\", exc_entry->end_pc);\n\tEprintf (\"    handler_pc: 0x%04x\\n\", exc_entry->handler_pc);\n}\n// End free Constant Pool types\nR_API void r_bin_java_print_code_attr_summary(RBinJavaAttrInfo *attr) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaExceptionEntry *exc_entry = NULL;\n\tRBinJavaAttrInfo *_attr = NULL;\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *Code.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Code Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d, Attribute Count: %d\\n\", attr->length, attr->info.code_attr.attributes_count);\n\tEprintf (\"    Max Stack: %d\\n\", attr->info.code_attr.max_stack);\n\tEprintf (\"    Max Locals: %d\\n\", attr->info.code_attr.max_locals);\n\tEprintf (\"    Code Length: %d\\n\", attr->info.code_attr.code_length);\n\tEprintf (\"    Code At Offset: 0x%08\"PFMT64x \"\\n\", (ut64) attr->info.code_attr.code_offset);\n\tEprintf (\"Code Attribute Exception Table Information:\\n\");\n\tEprintf (\"  Exception Table Length: %d\\n\", attr->info.code_attr.exception_table_length);\n\tif (attr->info.code_attr.exception_table) {\n\t\t// Delete the attr entries\n\t\tr_list_foreach_safe (attr->info.code_attr.exception_table, iter, iter_tmp, exc_entry) {\n\t\t\tr_bin_java_print_code_exceptions_attr_summary (exc_entry);\n\t\t}\n\t}\n\tEprintf (\"  Implicit Method Stack Frame:\\n\");\n\tr_bin_java_print_stack_map_frame_summary (attr->info.code_attr.implicit_frame);\n\tEprintf (\"Code Attribute Attributes Information:\\n\");\n\tif (attr->info.code_attr.attributes && attr->info.code_attr.attributes_count > 0) {\n\t\tEprintf (\"  Code Attribute Attributes Count: %d\\n\", attr->info.code_attr.attributes_count);\n\t\tr_list_foreach_safe (attr->info.code_attr.attributes, iter, iter_tmp, _attr) {\n\t\t\tr_bin_java_print_attr_summary (_attr);\n\t\t}\n\t}\n}\n\nR_API void r_bin_java_print_constant_value_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *ConstantValue.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Constant Value Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tEprintf (\"  ConstantValue Index: %d\\n\", attr->info.constant_value_attr.constantvalue_idx);\n}\n\nR_API void r_bin_java_print_deprecated_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *Deperecated.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Deperecated Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n}\n\nR_API void r_bin_java_print_enclosing_methods_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *Deperecated.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Enclosing Method Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tEprintf (\"  Class Info Index : 0x%02x\\n\", attr->info.enclosing_method_attr.class_idx);\n\tEprintf (\"  Method Name and Type Index : 0x%02x\\n\", attr->info.enclosing_method_attr.method_idx);\n\tEprintf (\"  Class Name : %s\\n\", attr->info.enclosing_method_attr.class_name);\n\tEprintf (\"  Method Name and Desc : %s %s\\n\", attr->info.enclosing_method_attr.method_name, attr->info.enclosing_method_attr.method_descriptor);\n}\n\nR_API void r_bin_java_print_exceptions_attr_summary(RBinJavaAttrInfo *attr) {\n\tut32 i = 0;\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *Exceptions.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Exceptions Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tfor (i = 0; i < attr->info.exceptions_attr.number_of_exceptions; i++) {\n\t\tEprintf (\"  Exceptions Attribute Index[%d]: %d\\n\", i, attr->info.exceptions_attr.exception_idx_table[i]);\n\t}\n}\n\nR_API void r_bin_java_print_classes_attr_summary(RBinJavaClassesAttribute *icattr) {\n\tif (!icattr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaClassesAttribute* (InnerClasses element).\\n\");\n\t\treturn;\n\t}\n\teprintf (\"   Inner Classes Class Attribute Offset: 0x%08\"PFMT64x \"\\n\", icattr->file_offset);\n\teprintf (\"   Inner Classes Class Attribute Class Name (%d): %s\\n\", icattr->inner_name_idx, icattr->name);\n\teprintf (\"   Inner Classes Class Attribute Class inner_class_info_idx: %d\\n\", icattr->inner_class_info_idx);\n\teprintf (\"   Inner Classes Class Attribute Class inner_class_access_flags: 0x%02x %s\\n\", icattr->inner_class_access_flags, icattr->flags_str);\n\teprintf (\"   Inner Classes Class Attribute Class outer_class_info_idx: %d\\n\", icattr->outer_class_info_idx);\n\teprintf (\"   Inner Classes Class Field Information:\\n\");\n\tr_bin_java_print_field_summary (icattr->clint_field);\n\teprintf (\"   Inner Classes Class Field Information:\\n\");\n\tr_bin_java_print_field_summary (icattr->clint_field);\n\teprintf (\"   Inner Classes Class Attr Info Information:\\n\");\n\tr_bin_java_print_attr_summary (icattr->clint_attr);\n}\n\nR_API void r_bin_java_print_inner_classes_attr_summary(RBinJavaAttrInfo *attr) {\n\tRBinJavaClassesAttribute *icattr;\n\tRListIter *iter, *iter_tmp;\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *InnerClasses.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Inner Classes Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tr_list_foreach_safe (attr->info.inner_classes_attr.classes, iter, iter_tmp, icattr) {\n\t\tr_bin_java_print_classes_attr_summary (icattr);\n\t}\n}\n\nR_API void r_bin_java_print_line_number_attr_summary(RBinJavaLineNumberAttribute *lnattr) {\n\tif (!lnattr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaLineNumberAttribute *.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"  Line Number Attribute Offset: 0x%08\"PFMT64x \"\\n\", lnattr->file_offset);\n\tEprintf (\"  Line Number Attribute StartPC: %d\\n\", lnattr->start_pc);\n\tEprintf (\"  Line Number Attribute LineNumber: %d\\n\", lnattr->line_number);\n}\n\nR_API void r_bin_java_print_line_number_table_attr_summary(RBinJavaAttrInfo *attr) {\n\tRBinJavaLineNumberAttribute *lnattr;\n\tRListIter *iter, *iter_tmp;\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *LineNumberTable.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Line Number Table Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tr_list_foreach_safe (attr->info.line_number_table_attr.line_number_table, iter, iter_tmp, lnattr) {\n\t\tr_bin_java_print_line_number_attr_summary (lnattr);\n\t}\n}\n\nR_API void r_bin_java_print_local_variable_attr_summary(RBinJavaLocalVariableAttribute *lvattr) {\n\tif (!lvattr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaLocalVariableAttribute *.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"  Local Variable Attribute offset: 0x%08\"PFMT64x \"\\n\", lvattr->file_offset);\n\tEprintf (\"  Local Variable Attribute start_pc: %d\\n\", lvattr->start_pc);\n\tEprintf (\"  Local Variable Attribute Length: %d\\n\", lvattr->length);\n\tEprintf (\"  Local Variable Attribute name_idx: %d\\n\", lvattr->name_idx);\n\tEprintf (\"  Local Variable Attribute name: %s\\n\", lvattr->name);\n\tEprintf (\"  Local Variable Attribute descriptor_idx: %d\\n\", lvattr->descriptor_idx);\n\tEprintf (\"  Local Variable Attribute descriptor: %s\\n\", lvattr->descriptor);\n\tEprintf (\"  Local Variable Attribute index: %d\\n\", lvattr->index);\n}\n\nR_API void r_bin_java_print_local_variable_table_attr_summary(RBinJavaAttrInfo *attr) {\n\tRBinJavaLocalVariableAttribute *lvattr;\n\tRListIter *iter, *iter_tmp;\n\tif (attr == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *LocalVariableTable.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Local Variable Table Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tr_list_foreach_safe (attr->info.local_variable_table_attr.local_variable_table, iter, iter_tmp, lvattr) {\n\t\tr_bin_java_print_local_variable_attr_summary (lvattr);\n\t}\n}\n\nR_API void r_bin_java_print_local_variable_type_attr_summary(RBinJavaLocalVariableTypeAttribute *lvattr) {\n\tif (!lvattr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaLocalVariableTypeAttribute *.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"   Local Variable Type Attribute offset: 0x%08\"PFMT64x \"\\n\", lvattr->file_offset);\n\teprintf (\"   Local Variable Type Attribute start_pc: %d\\n\", lvattr->start_pc);\n\teprintf (\"   Local Variable Type Attribute Length: %d\\n\", lvattr->length);\n\teprintf (\"   Local Variable Type Attribute name_idx: %d\\n\", lvattr->name_idx);\n\teprintf (\"   Local Variable Type Attribute name: %s\\n\", lvattr->name);\n\teprintf (\"   Local Variable Type Attribute signature_idx: %d\\n\", lvattr->signature_idx);\n\teprintf (\"   Local Variable Type Attribute signature: %s\\n\", lvattr->signature);\n\teprintf (\"   Local Variable Type Attribute index: %d\\n\", lvattr->index);\n}\n\nR_API void r_bin_java_print_local_variable_type_table_attr_summary(RBinJavaAttrInfo *attr) {\n\tRBinJavaLocalVariableTypeAttribute *lvtattr;\n\tRListIter *iter, *iter_tmp;\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *LocalVariableTable.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"Local Variable Type Table Attribute Information:\\n\");\n\teprintf (\"   Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\teprintf (\"   Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\teprintf (\"   Attribute Length: %d\\n\", attr->length);\n\tr_list_foreach_safe (attr->info.local_variable_type_table_attr.local_variable_table, iter, iter_tmp, lvtattr) {\n\t\tr_bin_java_print_local_variable_type_attr_summary (lvtattr);\n\t}\n}\n\nR_API void r_bin_java_print_signature_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *SignatureAttr.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Signature Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tEprintf (\"  Signature UTF8 Index: %d\\n\", attr->info.signature_attr.signature_idx);\n\tEprintf (\"  Signature string: %s\\n\", attr->info.signature_attr.signature);\n}\n\nR_API void r_bin_java_print_source_code_file_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *SourceFile.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Source File Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tEprintf (\"  Source File Index: %d\\n\", attr->info.source_file_attr.sourcefile_idx);\n}\n\nR_API void r_bin_java_print_synthetic_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (attr == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *Synthetic.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Synthetic Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tEprintf (\"  Attribute Index: %d\\n\", attr->info.source_file_attr.sourcefile_idx);\n}\n\nR_API void r_bin_java_print_stack_map_table_attr_summary(RBinJavaAttrInfo *attr) {\n\tRListIter *iter, *iter_tmp;\n\tRList *ptrList;\n\tRBinJavaStackMapFrame *frame;\n\tif (attr == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaStackMapTableAttr*  .\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"StackMapTable Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tEprintf (\"  StackMapTable Method Code Size: 0x%08x\\n\", attr->info.stack_map_table_attr.code_size);\n\tEprintf (\"  StackMapTable Frame Entries: 0x%08x\\n\", attr->info.stack_map_table_attr.number_of_entries);\n\tEprintf (\"  StackMapTable Frames:\\n\");\n\tptrList = attr->info.stack_map_table_attr.stack_map_frame_entries;\n\tif (ptrList) {\n\t\tr_list_foreach_safe (ptrList, iter, iter_tmp, frame) {\n\t\t\tr_bin_java_print_stack_map_frame_summary (frame);\n\t\t}\n\t}\n}\n\nR_API void r_bin_java_print_stack_map_frame_summary(RBinJavaStackMapFrame *obj) {\n\tRListIter *iter, *iter_tmp;\n\tRList *ptrList;\n\tRBinJavaVerificationObj *ver_obj;\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaStackMapFrame*  .\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Stack Map Frame Information\\n\");\n\tEprintf (\"  Tag Value = 0x%02x Name: %s\\n\", obj->tag, ((RBinJavaStackMapFrameMetas *) obj->metas->type_info)->name);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\\n\", obj->file_offset);\n\tEprintf (\"  Local Variable Count = 0x%04x\\n\", obj->number_of_locals);\n\tEprintf (\"  Stack Items Count = 0x%04x\\n\", obj->number_of_stack_items);\n\tEprintf (\"  Local Variables:\\n\");\n\tptrList = obj->local_items;\n\tr_list_foreach_safe (ptrList, iter, iter_tmp, ver_obj) {\n\t\tr_bin_java_print_verification_info_summary (ver_obj);\n\t}\n\tEprintf (\"  Stack Items:\\n\");\n\tptrList = obj->stack_items;\n\tr_list_foreach_safe (ptrList, iter, iter_tmp, ver_obj) {\n\t\tr_bin_java_print_verification_info_summary (ver_obj);\n\t}\n}\n\nR_API void r_bin_java_print_verification_info_summary(RBinJavaVerificationObj *obj) {\n\tut8 tag_value = R_BIN_JAVA_STACKMAP_UNKNOWN;\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaVerificationObj*  .\\n\");\n\t\treturn;\n\t}\n\tif (obj->tag < R_BIN_JAVA_STACKMAP_UNKNOWN) {\n\t\ttag_value = obj->tag;\n\t}\n\tEprintf (\"Verification Information\\n\");\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\", obj->file_offset);\n\tEprintf (\"  Tag Value = 0x%02x\\n\", obj->tag);\n\tEprintf (\"  Name = %s\\n\", R_BIN_JAVA_VERIFICATION_METAS[tag_value].name);\n\tif (obj->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tEprintf (\"  Object Constant Pool Index = 0x%x\\n\", obj->info.obj_val_cp_idx);\n\t} else if (obj->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tEprintf (\"  Uninitialized Object offset in code = 0x%x\\n\", obj->info.uninit_offset);\n\t}\n}\n\nR_API void r_bin_java_print_field_summary(RBinJavaField *field) {\n\tRBinJavaAttrInfo *attr;\n\tRListIter *iter, *iter_tmp;\n\tif (field) {\n\t\tif (field->type == R_BIN_JAVA_FIELD_TYPE_METHOD) {\n\t\t\tr_bin_java_print_method_summary (field);\n\t\t} else {\n#if 0\n\t\t\tr_bin_java_print_interface_summary (field);\n\t\t\treturn;\n\t\t} * /\n#endif\n\t\t\tEprintf (\"Field Summary Information:\\n\");\n\t\t\tEprintf (\"  File Offset: 0x%08\"PFMT64x \"\\n\", field->file_offset);\n\t\t\tEprintf (\"  Name Index: %d (%s)\\n\", field->name_idx, field->name);\n\t\t\tEprintf (\"  Descriptor Index: %d (%s)\\n\", field->descriptor_idx, field->descriptor);\n\t\t\tEprintf (\"  Access Flags: 0x%02x (%s)\\n\", field->flags, field->flags_str);\n\t\t\tEprintf (\"  Field Attributes Count: %d\\n\", field->attr_count);\n\t\t\tEprintf (\"  Field Attributes:\\n\");\n\t\t\tr_list_foreach_safe (field->attributes, iter, iter_tmp, attr) {\n\t\t\t\tr_bin_java_print_attr_summary (attr);\n\t\t\t}\n\t\t}\n\t} else {\n\t\teprintf (\"Attempting to print an invalid RBinJavaField* Field.\\n\");\n\t}\n}\n\nR_API void r_bin_java_print_method_summary(RBinJavaField *field) {\n\tRBinJavaAttrInfo *attr;\n\tRListIter *iter, *iter_tmp;\n\tif (field == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaField* Method.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Method Summary Information:\\n\");\n\tEprintf (\"  File Offset: 0x%08\"PFMT64x \"\\n\", field->file_offset);\n\tEprintf (\"  Name Index: %d (%s)\\n\", field->name_idx, field->name);\n\tEprintf (\"  Descriptor Index: %d (%s)\\n\", field->descriptor_idx, field->descriptor);\n\tEprintf (\"  Access Flags: 0x%02x (%s)\\n\", field->flags, field->flags_str);\n\tEprintf (\"  Method Attributes Count: %d\\n\", field->attr_count);\n\tEprintf (\"  Method Attributes:\\n\");\n\tr_list_foreach_safe (field->attributes, iter, iter_tmp, attr) {\n\t\tr_bin_java_print_attr_summary (attr);\n\t}\n}\n/*\n   R_API void r_bin_java_print_interface_summary(ut16 idx) {//RBinJavaField *field) {\n        RBinJavaAttrInfo *attr;\n        RBinJavaCPTypeObj *class_info;\n        RListIter *iter, *iter_tmp;\n        if (field == NULL) {\n                eprintf (\"Attempting to print an invalid RBinJavaField* Interface.\\n\");\n                return;\n        }\n        eprintf (\"Interface Summary Information:\\n\");\n        eprintf (\"\tFile offset: 0x%08\"PFMT64x\"\", field->file_offset);\n        eprintf (\"\tAccess Flags: %d\\n\", field->flags);\n        eprintf (\"\tName Index: %d (%s)\\n\", field->name_idx, field->name);\n        eprintf (\"\tDescriptor Index: %d (%s)\\n\", field->descriptor_idx, field->descriptor);\n        eprintf (\"\tInterface Attributes Count: %d\\n\", field->attr_count);\n        eprintf (\"\tInterface Attributes:\\n\");\n        r_list_foreach_safe (field->attributes, iter, iter_tmp, attr) {\n                r_bin_java_print_attr_summary(attr);\n        }\n   }\n */\nR_API void r_bin_java_print_interfacemethodref_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  InterfaceMethodRef.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"InterfaceMethodRef ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tClass Index = %d\\n\", obj->info.cp_interface.class_idx);\n\teprintf (\"\tName and type Index = %d\\n\", obj->info.cp_interface.name_and_type_idx);\n}\n\nR_API char *r_bin_java_print_interfacemethodref_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_interface.class_idx, obj->info.cp_interface.name_and_type_idx);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_interface.class_idx, obj->info.cp_interface.name_and_type_idx);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_methodhandle_cp_summary(RBinJavaCPTypeObj *obj) {\n\tut8 ref_kind;\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  RBinJavaCPTypeMethodHandle.\\n\");\n\t\treturn;\n\t}\n\tref_kind = obj->info.cp_method_handle.reference_kind;\n\teprintf (\"MethodHandle ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tReference Kind = (0x%02x) %s\\n\", ref_kind, R_BIN_JAVA_REF_METAS[ref_kind].name);\n\teprintf (\"\tReference Index = %d\\n\", obj->info.cp_method_handle.reference_index);\n}\n\nR_API char *r_bin_java_print_methodhandle_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tut8 ref_kind = obj->info.cp_method_handle.reference_kind;\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%s.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tR_BIN_JAVA_REF_METAS[ref_kind].name, obj->info.cp_method_handle.reference_index);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%s.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tR_BIN_JAVA_REF_METAS[ref_kind].name, obj->info.cp_method_handle.reference_index);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_methodtype_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  RBinJavaCPTypeMethodType.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"MethodType ConstantPool Type (%d) \", obj->metas->ord);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\", obj->file_offset);\n\tEprintf (\"  Descriptor Index = 0x%02x\\n\", obj->info.cp_method_type.descriptor_index);\n}\n\nR_API char *r_bin_java_print_methodtype_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_method_type.descriptor_index);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_method_type.descriptor_index);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_invokedynamic_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  RBinJavaCPTypeInvokeDynamic.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"InvokeDynamic ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tBootstrap Method Attr Index = (0x%02x)\\n\", obj->info.cp_invoke_dynamic.bootstrap_method_attr_index);\n\teprintf (\"\tBootstrap Name and Type Index = (0x%02x)\\n\", obj->info.cp_invoke_dynamic.name_and_type_index);\n}\n\nR_API char *r_bin_java_print_invokedynamic_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_invoke_dynamic.bootstrap_method_attr_index,\n\t\t\tobj->info.cp_invoke_dynamic.name_and_type_index);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_invoke_dynamic.bootstrap_method_attr_index,\n\t\t\t\t\tobj->info.cp_invoke_dynamic.name_and_type_index);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_methodref_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  MethodRef.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"MethodRef ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tClass Index = %d\\n\", obj->info.cp_method.class_idx);\n\teprintf (\"\tName and type Index = %d\\n\", obj->info.cp_method.name_and_type_idx);\n}\n\nR_API char *r_bin_java_print_methodref_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_method.class_idx,\n\t\t\tobj->info.cp_method.name_and_type_idx);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_method.class_idx,\n\t\t\t\t\tobj->info.cp_method.name_and_type_idx);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_fieldref_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  FieldRef.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"FieldRef ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tClass Index = %d\\n\", obj->info.cp_field.class_idx);\n\teprintf (\"\tName and type Index = %d\\n\", obj->info.cp_field.name_and_type_idx);\n}\n\nR_API char *r_bin_java_print_fieldref_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_field.class_idx,\n\t\t\tobj->info.cp_field.name_and_type_idx);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_field.class_idx,\n\t\t\t\t\tobj->info.cp_field.name_and_type_idx);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_classref_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  ClassRef.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"ClassRef ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tName Index = %d\\n\", obj->info.cp_class.name_idx);\n}\n\nR_API char *r_bin_java_print_classref_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_class.name_idx);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_class.name_idx);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_string_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (!obj) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  String.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"String ConstantPool Type (%d) \", obj->metas->ord);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\", obj->file_offset);\n\tEprintf (\"  String Index = %d\\n\", obj->info.cp_string.string_idx);\n}\n\nR_API char *r_bin_java_print_string_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_string.string_idx);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset,\n\t\t\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_string.string_idx);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_integer_cp_summary(RBinJavaCPTypeObj *obj) {\n\tut8 *b = NULL;\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  Integer.\\n\");\n\t\treturn;\n\t}\n\tb = obj->info.cp_integer.bytes.raw;\n\teprintf (\"Integer ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tbytes = %02x %02x %02x %02x\\n\", b[0], b[1], b[2], b[3]);\n\teprintf (\"\tinteger = %d\\n\", R_BIN_JAVA_UINT (obj->info.cp_integer.bytes.raw, 0));\n}\n\nR_API char *r_bin_java_print_integer_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.0x%08x\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tR_BIN_JAVA_UINT (obj->info.cp_integer.bytes.raw, 0));\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.0x%08x\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tR_BIN_JAVA_UINT (obj->info.cp_integer.bytes.raw, 0));\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_float_cp_summary(RBinJavaCPTypeObj *obj) {\n\tut8 *b = NULL;\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  Double.\\n\");\n\t\treturn;\n\t}\n\tb = obj->info.cp_float.bytes.raw;\n\tEprintf (\"Float ConstantPool Type (%d) \", obj->metas->ord);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\", obj->file_offset);\n\tEprintf (\"  Bytes = %02x %02x %02x %02x\\n\", b[0], b[1], b[2], b[3]);\n\tEprintf (\"  Float = %f\\n\", R_BIN_JAVA_FLOAT (obj->info.cp_float.bytes.raw, 0));\n}\n\nR_API char *r_bin_java_print_float_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%f\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tR_BIN_JAVA_FLOAT (obj->info.cp_float.bytes.raw, 0));\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%f\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tR_BIN_JAVA_FLOAT (obj->info.cp_float.bytes.raw, 0));\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_long_cp_summary(RBinJavaCPTypeObj *obj) {\n\tut8 *b = NULL;\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  Long.\\n\");\n\t\treturn;\n\t}\n\tb = obj->info.cp_long.bytes.raw;\n\tEprintf (\"Long ConstantPool Type (%d) \", obj->metas->ord);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\", obj->file_offset);\n\tEprintf (\"  High-Bytes = %02x %02x %02x %02x\\n\", b[0], b[1], b[2], b[3]);\n\tEprintf (\"  Low-Bytes = %02x %02x %02x %02x\\n\", b[4], b[5], b[6], b[7]);\n\tEprintf (\"  Long = %08\"PFMT64x \"\\n\", r_bin_java_raw_to_long (obj->info.cp_long.bytes.raw, 0));\n}\n\nR_API char *r_bin_java_print_long_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.0x%08\"PFMT64x \"\",\n\t\t\tobj->metas->ord,\n\t\t\tobj->file_offset,\n\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tr_bin_java_raw_to_long (obj->info.cp_long.bytes.raw, 0));\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.0x%08\"PFMT64x \"\",\n\t\t\t\t\tobj->metas->ord,\n\t\t\t\t\tobj->file_offset,\n\t\t\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tr_bin_java_raw_to_long (obj->info.cp_long.bytes.raw, 0));\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_double_cp_summary(RBinJavaCPTypeObj *obj) {\n\tut8 *b = NULL;\n\tif (!obj) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  Double.\\n\");\n\t\treturn;\n\t}\n\tb = obj->info.cp_double.bytes.raw;\n\tEprintf (\"Double ConstantPool Type (%d) \", obj->metas->ord);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\", obj->file_offset);\n\tEprintf (\"  High-Bytes = %02x %02x %02x %02x\\n\", b[0], b[1], b[2], b[3]);\n\tEprintf (\"  Low-Bytes = %02x %02x %02x %02x\\n\", b[4], b[5], b[6], b[7]);\n\tEprintf (\"  Double = %f\\n\", r_bin_java_raw_to_double (obj->info.cp_double.bytes.raw, 0));\n}\n\nR_API char *r_bin_java_print_double_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%f\",\n\t\t\tobj->metas->ord,\n\t\t\tobj->file_offset,\n\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tr_bin_java_raw_to_double (obj->info.cp_double.bytes.raw, 0));\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%f\",\n\t\t\t\t\tobj->metas->ord,\n\t\t\t\t\tobj->file_offset,\n\t\t\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tr_bin_java_raw_to_double (obj->info.cp_double.bytes.raw, 0));\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_name_and_type_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  Name_And_Type.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Name_And_Type ConstantPool Type (%d) \", obj->metas->ord);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\", obj->file_offset);\n\tEprintf (\"  name_idx = (%d)\\n\", obj->info.cp_name_and_type.name_idx);\n\tEprintf (\"  descriptor_idx = (%d)\\n\", obj->info.cp_name_and_type.descriptor_idx);\n}\n\nR_API char *r_bin_java_print_name_and_type_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_name_and_type.name_idx,\n\t\t\tobj->info.cp_name_and_type.descriptor_idx);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_name_and_type.name_idx,\n\t\t\t\t\tobj->info.cp_name_and_type.descriptor_idx);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_utf8_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  Utf8.\\n\");\n\t\treturn;\n\t}\n\tchar *str = convert_string ((const char *) obj->info.cp_utf8.bytes, obj->info.cp_utf8.length);\n\teprintf (\"UTF8 ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tlength = %d\\n\", obj->info.cp_utf8.length);\n\teprintf (\"\tutf8 = %s\\n\", str);\n\tfree (str);\n}\n\nR_API char *r_bin_java_print_utf8_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *utf8_str = r_hex_bin2strdup (obj->info.cp_utf8.bytes, obj->info.cp_utf8.length);\n\tchar *value = malloc (size + strlen (utf8_str));\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%s\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_utf8.length,\n\t\t\tutf8_str);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size + strlen (utf8_str));\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%s\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_utf8.length,\n\t\t\t\t\tutf8_str);\n\t\t\t}\n\t\t}\n\t}\n\tfree (utf8_str);\n\treturn value;\n}\n\nR_API void r_bin_java_print_null_cp_summary(RBinJavaCPTypeObj *obj) {\n\teprintf (\"Unknown ConstantPool Type Tag: 0x%04x .\\n\", obj->tag);\n}\n\nR_API char *r_bin_java_print_null_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset,\n\t\t\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->name);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_unknown_cp_summary(RBinJavaCPTypeObj *obj) {\n\teprintf (\"NULL ConstantPool Type.\\n\");\n}\n\nR_API char *r_bin_java_print_unknown_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tsnprintf (value, size, \"%d.0x%04\"PFMT64x \".%s\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name);\n\t}\n\treturn value;\n}\n\nR_API RBinJavaElementValuePair *r_bin_java_element_pair_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaElementValuePair *ev_pair = NULL;\n\tut64 offset = 0;\n\tif (!buffer) {\n\t\treturn NULL;\n\t}\n\tev_pair = R_NEW0 (RBinJavaElementValuePair);\n\tif (!ev_pair) {\n\t\t// TODO eprintf ev_pair failed to allocate\n\t\treturn NULL;\n\t}\n\t// TODO: What is the signifigance of ev_pair element\n\tev_pair->element_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tev_pair->file_offset = buf_offset;\n\tev_pair->name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, ev_pair->element_name_idx);\n\tif (ev_pair->name == NULL) {\n\t\t// TODO: eprintf unable to find the name for the given index\n\t\teprintf (\"ElementValue Name is invalid.\\n\");\n\t\tev_pair->name = strdup (\"UNKNOWN\");\n\t}\n\tev_pair->value = r_bin_java_element_value_new (buffer + offset, sz - offset, buf_offset + offset);\n\toffset += ev_pair->value->size;\n\tev_pair->size = offset;\n\treturn ev_pair;\n}\n\nR_API void r_bin_java_print_element_pair_summary(RBinJavaElementValuePair *ev_pair) {\n\tif (!ev_pair) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaElementValuePair *pair.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Element Value Pair information:\\n\");\n\tEprintf (\"  EV Pair File Offset: 0x%08\"PFMT64x \"\\n\", ev_pair->file_offset);\n\tEprintf (\"  EV Pair Element Name index: 0x%02x\\n\", ev_pair->element_name_idx);\n\tEprintf (\"  EV Pair Element Name: %s\\n\", ev_pair->name);\n\tEprintf (\"  EV Pair Element Value:\\n\");\n\tr_bin_java_print_element_value_summary (ev_pair->value);\n}\n\nR_API void r_bin_java_print_element_value_summary(RBinJavaElementValue *element_value) {\n\tRBinJavaCPTypeObj *obj;\n\tRBinJavaElementValue *ev_element = NULL;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tchar *name;\n\tif (element_value == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaElementValuePair *pair.\\n\");\n\t\treturn;\n\t}\n\tname = ((RBinJavaElementValueMetas *) element_value->metas->type_info)->name;\n\teprintf (\"Element Value information:\\n\");\n\teprintf (\"   EV Pair File Offset: 0x%08\"PFMT64x \"\\n\", element_value->file_offset);\n\teprintf (\"   EV Value Type (%d): %s\\n\", element_value->tag, name);\n\tswitch (element_value->tag) {\n\tcase R_BIN_JAVA_EV_TAG_BYTE:\n\tcase R_BIN_JAVA_EV_TAG_CHAR:\n\tcase R_BIN_JAVA_EV_TAG_DOUBLE:\n\tcase R_BIN_JAVA_EV_TAG_FLOAT:\n\tcase R_BIN_JAVA_EV_TAG_INT:\n\tcase R_BIN_JAVA_EV_TAG_LONG:\n\tcase R_BIN_JAVA_EV_TAG_SHORT:\n\tcase R_BIN_JAVA_EV_TAG_BOOLEAN:\n\tcase R_BIN_JAVA_EV_TAG_STRING:\n\t\teprintf (\"   EV Value Constant Value index: 0x%02x\\n\", element_value->value.const_value.const_value_idx);\n\t\teprintf (\"   EV Value Constant Value Information:\\n\");\n\t\tobj = element_value->value.const_value.const_value_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->print_summary (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ENUM:\n\t\teprintf (\"   EV Value Enum Constant Value Const Name Index: 0x%02x\\n\", element_value->value.enum_const_value.const_name_idx);\n\t\teprintf (\"   EV Value Enum Constant Value Type Name Index: 0x%02x\\n\", element_value->value.enum_const_value.type_name_idx);\n\t\teprintf (\"   EV Value Enum Constant Value Const CP Information:\\n\");\n\t\tobj = element_value->value.enum_const_value.const_name_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->print_summary (obj);\n\t\teprintf (\"   EV Value Enum Constant Value Type CP Information:\\n\");\n\t\tobj = element_value->value.enum_const_value.type_name_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->print_summary (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_CLASS:\n\t\teprintf (\"   EV Value Class Info Index: 0x%02x\\n\", element_value->value.class_value.class_info_idx);\n\t\teprintf (\"   EV Value Class Info CP Information:\\n\");\n\t\tobj = element_value->value.class_value.class_info_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->print_summary (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ARRAY:\n\t\teprintf (\"   EV Value Array Value Number of Values: 0x%04x\\n\", element_value->value.array_value.num_values);\n\t\teprintf (\"   EV Value Array Values\\n\");\n\t\tr_list_foreach_safe (element_value->value.array_value.values, iter, iter_tmp, ev_element) {\n\t\t\tr_bin_java_print_element_value_summary (ev_element);\n\t\t}\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ANNOTATION:\n\t\teprintf (\"   EV Annotation Information:\\n\");\n\t\tr_bin_java_print_annotation_summary (&element_value->value.annotation_value);\n\t\tbreak;\n\tdefault:\n\t\t// eprintf unable to handle tag\n\t\tbreak;\n\t}\n}\n\nR_API void r_bin_java_element_pair_free(void /*RBinJavaElementValuePair*/ *e) {\n\tRBinJavaElementValuePair *ev_pair = e;\n\tif (ev_pair) {\n\t\tfree (ev_pair->name);\n\t\tr_bin_java_element_value_free (ev_pair->value);\n\t\tfree (ev_pair);\n\t}\n\tev_pair = NULL;\n}\n\nR_API void r_bin_java_element_value_free(void /*RBinJavaElementValue*/ *e) {\n\tRBinJavaElementValue *element_value = e;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaCPTypeObj *obj = NULL;\n\tRBinJavaElementValue *ev_element = NULL;\n\tif (element_value) {\n\t\tfree (element_value->metas);\n\t\telement_value->metas = NULL;\n\t\tswitch (element_value->tag) {\n\t\tcase R_BIN_JAVA_EV_TAG_BYTE:\n\t\tcase R_BIN_JAVA_EV_TAG_CHAR:\n\t\tcase R_BIN_JAVA_EV_TAG_DOUBLE:\n\t\tcase R_BIN_JAVA_EV_TAG_FLOAT:\n\t\tcase R_BIN_JAVA_EV_TAG_INT:\n\t\tcase R_BIN_JAVA_EV_TAG_LONG:\n\t\tcase R_BIN_JAVA_EV_TAG_SHORT:\n\t\tcase R_BIN_JAVA_EV_TAG_BOOLEAN:\n\t\tcase R_BIN_JAVA_EV_TAG_STRING:\n\t\t\t// Delete the CP Type Object\n\t\t\tobj = element_value->value.const_value.const_value_cp_obj;\n\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_EV_TAG_ENUM:\n\t\t\t// Delete the CP Type Objects\n\t\t\tobj = element_value->value.enum_const_value.const_name_cp_obj;\n\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\t\tobj = element_value->value.enum_const_value.type_name_cp_obj;\n\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_EV_TAG_CLASS:\n\t\t\t// Delete the CP Type Object\n\t\t\tobj = element_value->value.class_value.class_info_cp_obj;\n\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_EV_TAG_ARRAY:\n\t\t\t// Delete the Element Value array List\n\t\t\tr_list_foreach_safe (element_value->value.array_value.values, iter, iter_tmp, ev_element) {\n\t\t\t\tif (ev_element) {\n\t\t\t\t\tr_bin_java_element_value_free (ev_element);\n\t\t\t\t} else {\n\t\t\t\t\t// TODO eprintf ev_pairs value was NULL\n\t\t\t\t}\n\t\t\t\t// r_list_delete (element_value->value.array_value.values, iter);\n\t\t\t\tev_element = NULL;\n\t\t\t}\n\t\t\tr_list_free (element_value->value.array_value.values);\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_EV_TAG_ANNOTATION:\n\t\t\t// Delete the Annotations List\n\t\t\tr_list_free (element_value->value.annotation_value.element_value_pairs);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// eprintf unable to free the tag\n\t\t\tbreak;\n\t\t}\n\t\tfree (element_value);\n\t}\n}\n\nR_API ut64 r_bin_java_annotation_default_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tif (attr) {\n\t\t// attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\t\tsize += 6;\n\t\t// attr->info.annotation_default_attr.default_value = r_bin_java_element_value_new (buffer+offset, sz-offset, buf_offset+offset);\n\t\tsize += r_bin_java_element_value_calc_size (attr->info.annotation_default_attr.default_value);\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;\n\t\tattr->info.annotation_default_attr.default_value = r_bin_java_element_value_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (attr->info.annotation_default_attr.default_value) {\n\t\t\toffset += attr->info.annotation_default_attr.default_value->size;\n\t\t}\n\t}\n\tr_bin_java_print_annotation_default_attr_summary (attr);\n\treturn attr;\n}\n\nR_API void r_bin_java_annotation_default_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tRBinJavaElementValue *element_value = NULL, *ev_element = NULL;\n\tRBinJavaCPTypeObj *obj = NULL;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tif (attr == NULL || attr->type != R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR) {\n\t\treturn;\n\t}\n\telement_value = (attr->info.annotation_default_attr.default_value);\n\tswitch (element_value->tag) {\n\tcase R_BIN_JAVA_EV_TAG_BYTE:\n\tcase R_BIN_JAVA_EV_TAG_CHAR:\n\tcase R_BIN_JAVA_EV_TAG_DOUBLE:\n\tcase R_BIN_JAVA_EV_TAG_FLOAT:\n\tcase R_BIN_JAVA_EV_TAG_INT:\n\tcase R_BIN_JAVA_EV_TAG_LONG:\n\tcase R_BIN_JAVA_EV_TAG_SHORT:\n\tcase R_BIN_JAVA_EV_TAG_BOOLEAN:\n\tcase R_BIN_JAVA_EV_TAG_STRING:\n\t\t// Delete the CP Type Object\n\t\tobj = element_value->value.const_value.const_value_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ENUM:\n\t\t// Delete the CP Type Objects\n\t\tobj = element_value->value.enum_const_value.const_name_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\tobj = element_value->value.enum_const_value.type_name_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_CLASS:\n\t\t// Delete the CP Type Object\n\t\tobj = element_value->value.class_value.class_info_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ARRAY:\n\t\t// Delete the Element Value array List\n\t\tr_list_foreach_safe (element_value->value.array_value.values, iter, iter_tmp, ev_element) {\n\t\t\tr_bin_java_element_value_free (ev_element);\n\t\t\t// r_list_delete (element_value->value.array_value.values, iter);\n\t\t\tev_element = NULL;\n\t\t}\n\t\tr_list_free (element_value->value.array_value.values);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ANNOTATION:\n\t\t// Delete the Annotations List\n\t\tr_list_free (element_value->value.annotation_value.element_value_pairs);\n\t\tbreak;\n\tdefault:\n\t\t// eprintf unable to free the tag\n\t\tbreak;\n\t}\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAnnotation *annotation = NULL;\n\tRBinJavaElementValuePair *ev_pairs = NULL;\n\tut64 offset = 0;\n\tannotation = R_NEW0 (RBinJavaAnnotation);\n\tif (!annotation) {\n\t\treturn NULL;\n\t}\n\t// (ut16) read and set annotation_value.type_idx;\n\tannotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\t// (ut16) read and set annotation_value.num_element_value_pairs;\n\tannotation->num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->element_value_pairs = r_list_newf (r_bin_java_element_pair_free);\n\t// read annotation_value.num_element_value_pairs, and append to annotation_value.element_value_pairs\n\tfor (i = 0; i < annotation->num_element_value_pairs; i++) {\n\t\tif (offset > sz) {\n\t\t\tbreak;\n\t\t}\n\t\tev_pairs = r_bin_java_element_pair_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (ev_pairs) {\n\t\t\toffset += ev_pairs->size;\n\t\t\tr_list_append (annotation->element_value_pairs, (void *) ev_pairs);\n\t\t}\n\t}\n\tannotation->size = offset;\n\treturn annotation;\n}\n\nR_API ut64 r_bin_java_annotation_calc_size(RBinJavaAnnotation *annotation) {\n\tut64 sz = 0;\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaElementValuePair *ev_pairs = NULL;\n\tif (!annotation) {\n\t\t// TODO eprintf allocation fail\n\t\treturn sz;\n\t}\n\t// annotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\tsz += 2;\n\t// annotation->num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\tsz += 2;\n\tr_list_foreach_safe (annotation->element_value_pairs, iter, iter_tmp, ev_pairs) {\n\t\tif (ev_pairs) {\n\t\t\tsz += r_bin_java_element_pair_calc_size (ev_pairs);\n\t\t}\n\t}\n\treturn sz;\n}\n\nR_API void r_bin_java_annotation_free(void /*RBinJavaAnnotation*/ *a) {\n\tRBinJavaAnnotation *annotation = a;\n\tif (annotation) {\n\t\tr_list_free (annotation->element_value_pairs);\n\t\tfree (annotation);\n\t}\n}\n\nR_API void r_bin_java_print_annotation_summary(RBinJavaAnnotation *annotation) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaElementValuePair *ev_pair = NULL;\n\tif (!annotation) {\n\t\t// TODO eprintf invalid annotation\n\t\treturn;\n\t}\n\tEprintf (\"  Annotation Type Index: 0x%02x\\n\", annotation->type_idx);\n\tEprintf (\"  Annotation Number of EV Pairs: 0x%04x\\n\", annotation->num_element_value_pairs);\n\tEprintf (\"  Annotation EV Pair Values:\\n\");\n\tif (annotation->element_value_pairs) {\n\t\tr_list_foreach_safe (annotation->element_value_pairs, iter, iter_tmp, ev_pair) {\n\t\t\tr_bin_java_print_element_pair_summary (ev_pair);\n\t\t}\n\t}\n}\n\nR_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *ev_pair) {\n\tut64 sz = 0;\n\tif (ev_pair == NULL) {\n\t\treturn sz;\n\t}\n\t// ev_pair->element_name_idx = r_bin_java_read_short(bin, bin->b->cur);\n\tsz += 2;\n\t// ev_pair->value = r_bin_java_element_value_new (bin, offset+2);\n\tif (ev_pair->value) {\n\t\tsz += r_bin_java_element_value_calc_size (ev_pair->value);\n\t}\n\treturn sz;\n}\n\nR_API ut64 r_bin_java_element_value_calc_size(RBinJavaElementValue *element_value) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaElementValue *ev_element;\n\tRBinJavaElementValuePair *ev_pairs;\n\tut64 sz = 0;\n\tif (element_value == NULL) {\n\t\treturn sz;\n\t}\n\t// tag\n\tsz += 1;\n\tswitch (element_value->tag) {\n\tcase R_BIN_JAVA_EV_TAG_BYTE:\n\tcase R_BIN_JAVA_EV_TAG_CHAR:\n\tcase R_BIN_JAVA_EV_TAG_DOUBLE:\n\tcase R_BIN_JAVA_EV_TAG_FLOAT:\n\tcase R_BIN_JAVA_EV_TAG_INT:\n\tcase R_BIN_JAVA_EV_TAG_LONG:\n\tcase R_BIN_JAVA_EV_TAG_SHORT:\n\tcase R_BIN_JAVA_EV_TAG_BOOLEAN:\n\tcase R_BIN_JAVA_EV_TAG_STRING:\n\t\t// look up value in bin->cp_list\n\t\t// (ut16) read and set const_value.const_value_idx\n\t\t// element_value->value.const_value.const_value_idx = r_bin_java_read_short(bin, bin->b->cur);\n\t\tsz += 2;\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ENUM:\n\t\t// (ut16) read and set enum_const_value.type_name_idx\n\t\t// element_value->value.enum_const_value.type_name_idx = r_bin_java_read_short(bin, bin->b->cur);\n\t\tsz += 2;\n\t\t// (ut16) read and set enum_const_value.const_name_idx\n\t\t// element_value->value.enum_const_value.const_name_idx = r_bin_java_read_short(bin, bin->b->cur);\n\t\tsz += 2;\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_CLASS:\n\t\t// (ut16) read and set class_value.class_info_idx\n\t\t// element_value->value.class_value.class_info_idx = r_bin_java_read_short(bin, bin->b->cur);\n\t\tsz += 2;\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ARRAY:\n\t\t// (ut16) read and set array_value.num_values\n\t\t// element_value->value.array_value.num_values = r_bin_java_read_short(bin, bin->b->cur);\n\t\tsz += 2;\n\t\tr_list_foreach_safe (element_value->value.array_value.values, iter, iter_tmp, ev_element) {\n\t\t\tif (ev_element) {\n\t\t\t\tsz += r_bin_java_element_value_calc_size (ev_element);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ANNOTATION:\n\t\t// annotation new is not used here.\n\t\t// (ut16) read and set annotation_value.type_idx;\n\t\t// element_value->value.annotation_value.type_idx = r_bin_java_read_short(bin, bin->b->cur);\n\t\tsz += 2;\n\t\t// (ut16) read and set annotation_value.num_element_value_pairs;\n\t\t// element_value->value.annotation_value.num_element_value_pairs = r_bin_java_read_short(bin, bin->b->cur);\n\t\tsz += 2;\n\t\telement_value->value.annotation_value.element_value_pairs = r_list_newf (r_bin_java_element_pair_free);\n\t\tr_list_foreach_safe (element_value->value.annotation_value.element_value_pairs, iter, iter_tmp, ev_pairs) {\n\t\t\tif (ev_pairs) {\n\t\t\t\tsz += r_bin_java_element_pair_calc_size (ev_pairs);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t// eprintf unable to handle tag\n\t\tbreak;\n\t}\n\treturn sz;\n}\n\nR_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tRBinJavaElementValue *element_value = R_NEW0 (RBinJavaElementValue);\n\tif (!element_value) {\n\t\treturn NULL;\n\t}\n\tRBinJavaElementValuePair *ev_pairs = NULL;\n\telement_value->metas = R_NEW0 (RBinJavaMetaInfo);\n\tif (!element_value->metas) {\n\t\tR_FREE (element_value);\n\t\treturn NULL;\n\t}\n\telement_value->file_offset = buf_offset;\n\telement_value->tag = buffer[offset];\n\telement_value->size += 1;\n\toffset += 1;\n\telement_value->metas->type_info = (void *) r_bin_java_get_ev_meta_from_tag (element_value->tag);\n\tswitch (element_value->tag) {\n\tcase R_BIN_JAVA_EV_TAG_BYTE:\n\tcase R_BIN_JAVA_EV_TAG_CHAR:\n\tcase R_BIN_JAVA_EV_TAG_DOUBLE:\n\tcase R_BIN_JAVA_EV_TAG_FLOAT:\n\tcase R_BIN_JAVA_EV_TAG_INT:\n\tcase R_BIN_JAVA_EV_TAG_LONG:\n\tcase R_BIN_JAVA_EV_TAG_SHORT:\n\tcase R_BIN_JAVA_EV_TAG_BOOLEAN:\n\tcase R_BIN_JAVA_EV_TAG_STRING:\n\t\t// look up value in bin->cp_list\n\t\t// (ut16) read and set const_value.const_value_idx\n\t\telement_value->value.const_value.const_value_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// look-up, deep copy, and set const_value.const_value_cp_obj\n\t\telement_value->value.const_value.const_value_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.const_value.const_value_idx);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ENUM:\n\t\t// (ut16) read and set enum_const_value.type_name_idx\n\t\telement_value->value.enum_const_value.type_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// (ut16) read and set enum_const_value.const_name_idx\n\t\telement_value->value.enum_const_value.const_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// look up type_name_index in bin->cp_list\n\t\t// look-up, deep copy, and set enum_const_value.const_name_cp_obj\n\t\telement_value->value.enum_const_value.const_name_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.enum_const_value.const_name_idx);\n\t\t// look-up, deep copy, and set enum_const_value.type_name_cp_obj\n\t\telement_value->value.enum_const_value.type_name_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.enum_const_value.type_name_idx);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_CLASS:\n\t\t// (ut16) read and set class_value.class_info_idx\n\t\telement_value->value.class_value.class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// look up type_name_index in bin->cp_list\n\t\t// look-up, deep copy, and set class_value.class_info_cp_obj\n\t\telement_value->value.class_value.class_info_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.class_value.class_info_idx);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ARRAY:\n\t\t// (ut16) read and set array_value.num_values\n\t\telement_value->value.array_value.num_values = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\telement_value->value.array_value.values = r_list_new ();\n\t\tfor (i = 0; i < element_value->value.array_value.num_values; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaElementValue *ev_element = r_bin_java_element_value_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (ev_element) {\n\t\t\t\telement_value->size += ev_element->size;\n\t\t\t\toffset += ev_element->size;\n\t\t\t}\n\t\t\t// read array_value.num_values, and append to array_value.values\n\t\t\tr_list_append (element_value->value.array_value.values, (void *) ev_element);\n\t\t\tif (ev_element == NULL) {\n\t\t\t\t// TODO: eprintf error when reading element value\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ANNOTATION:\n\t\t// annotation new is not used here.\n\t\t// (ut16) read and set annotation_value.type_idx;\n\t\telement_value->value.annotation_value.type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// (ut16) read and set annotation_value.num_element_value_pairs;\n\t\telement_value->value.annotation_value.num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\telement_value->value.annotation_value.element_value_pairs = r_list_newf (r_bin_java_element_pair_free);\n\t\t// read annotation_value.num_element_value_pairs, and append to annotation_value.element_value_pairs\n\t\tfor (i = 0; i < element_value->value.annotation_value.num_element_value_pairs; i++) {\n\t\t\tif (offset > sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tev_pairs = r_bin_java_element_pair_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (ev_pairs) {\n\t\t\t\telement_value->size += ev_pairs->size;\n\t\t\t\toffset += ev_pairs->size;\n\t\t\t}\n\t\t\tif (ev_pairs == NULL) {\n\t\t\t\t// TODO: eprintf error when reading element pair\n\t\t\t}\n\t\t\tr_list_append (element_value->value.annotation_value.element_value_pairs, (void *) ev_pairs);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t// eprintf unable to handle tag\n\t\tbreak;\n\t}\n\treturn element_value;\n}\n\nR_API void r_bin_java_bootstrap_method_argument_free(void /*RBinJavaBootStrapArgument*/ *b) {\n\tRBinJavaBootStrapArgument *bsm_arg = b;\n\tif (bsm_arg) {\n\t\tif (bsm_arg->argument_info_cp_obj) {\n\t\t\t((RBinJavaCPTypeMetas *) bsm_arg->argument_info_cp_obj)->allocs->delete_obj (bsm_arg->argument_info_cp_obj);\n\t\t\tbsm_arg->argument_info_cp_obj = NULL;\n\t\t}\n\t\tfree (bsm_arg);\n\t}\n}\n\nR_API void r_bin_java_print_bootstrap_method_argument_summary(RBinJavaBootStrapArgument *bsm_arg) {\n\tif (bsm_arg == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaBootStrapArgument *.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"Bootstrap Method Argument Information:\\n\");\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", bsm_arg->file_offset);\n\teprintf (\"\tName_And_Type Index = (0x%02x)\\n\", bsm_arg->argument_info_idx);\n\tif (bsm_arg->argument_info_cp_obj) {\n\t\teprintf (\"\tBootstrap Method Argument Type and Name Info:\\n\");\n\t\t((RBinJavaCPTypeMetas *) bsm_arg->argument_info_cp_obj)->allocs->print_summary (bsm_arg->argument_info_cp_obj);\n\t} else {\n\t\teprintf (\"\tBootstrap Method Argument Type and Name Info: INVALID\\n\");\n\t}\n}\n\nR_API void r_bin_java_print_bootstrap_method_summary(RBinJavaBootStrapMethod *bsm) {\n\tRBinJavaBootStrapArgument *bsm_arg = NULL;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tif (bsm == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaBootStrapArgument *.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"Bootstrap Method Information:\\n\");\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", bsm->file_offset);\n\teprintf (\"\tMethod Reference Index = (0x%02x)\\n\", bsm->bootstrap_method_ref);\n\teprintf (\"\tNumber of Method Arguments = (0x%02x)\\n\", bsm->num_bootstrap_arguments);\n\tif (bsm->bootstrap_arguments) {\n\t\tr_list_foreach_safe (bsm->bootstrap_arguments, iter, iter_tmp, bsm_arg) {\n\t\t\tif (bsm_arg) {\n\t\t\t\tr_bin_java_print_bootstrap_method_argument_summary (bsm_arg);\n\t\t\t}\n\t\t}\n\t} else {\n\t\teprintf (\"\tBootstrap Method Argument: NONE \\n\");\n\t}\n}\n\nR_API RBinJavaBootStrapArgument *r_bin_java_bootstrap_method_argument_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaBootStrapArgument *bsm_arg = NULL;\n\tut64 offset = 0;\n\tbsm_arg = (RBinJavaBootStrapArgument *) malloc (sizeof (RBinJavaBootStrapArgument));\n\tif (bsm_arg == NULL) {\n\t\t// TODO eprintf failed to allocate bytes for bootstrap_method.\n\t\treturn bsm_arg;\n\t}\n\tmemset (bsm_arg, 0, sizeof (RBinJavaBootStrapArgument));\n\tbsm_arg->file_offset = buf_offset;\n\tbsm_arg->argument_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tbsm_arg->argument_info_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, bsm_arg->argument_info_idx);\n\tbsm_arg->size = offset;\n\treturn bsm_arg;\n}\n\nR_API void r_bin_java_bootstrap_method_free(void /*/RBinJavaBootStrapMethod*/ *b) {\n\tRBinJavaBootStrapMethod *bsm = b;\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaBootStrapArgument *obj = NULL;\n\tif (bsm) {\n\t\tif (bsm->bootstrap_arguments) {\n\t\t\tr_list_foreach_safe (bsm->bootstrap_arguments, iter, iter_tmp, obj) {\n\t\t\t\tif (obj) {\n\t\t\t\t\tr_bin_java_bootstrap_method_argument_free (obj);\n\t\t\t\t}\n\t\t\t\t// r_list_delete (bsm->bootstrap_arguments, iter);\n\t\t\t}\n\t\t\tr_list_free (bsm->bootstrap_arguments);\n\t\t\tbsm->bootstrap_arguments = NULL;\n\t\t}\n\t\tfree (bsm);\n\t}\n}\n\nR_API RBinJavaBootStrapMethod *r_bin_java_bootstrap_method_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tRBinJavaBootStrapArgument *bsm_arg = NULL;\n\tut32 i = 0;\n\tut64 offset = 0;\n\tbsm = (RBinJavaBootStrapMethod *) malloc (sizeof (RBinJavaBootStrapMethod));\n\tif (bsm == NULL) {\n\t\t// TODO eprintf failed to allocate bytes for bootstrap_method.\n\t\treturn bsm;\n\t}\n\tmemset (bsm, 0, sizeof (RBinJavaBootStrapMethod));\n\tbsm->file_offset = buf_offset;\n\tbsm->bootstrap_method_ref = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tbsm->num_bootstrap_arguments = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tbsm->bootstrap_arguments = r_list_new ();\n\tfor (i = 0; i < bsm->num_bootstrap_arguments; i++) {\n\t\t// bsm_arg = r_bin_java_bootstrap_method_argument_new (bin, bin->b->cur);\n\t\tbsm_arg = r_bin_java_bootstrap_method_argument_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (bsm_arg) {\n\t\t\toffset += bsm_arg->size;\n\t\t\tr_list_append (bsm->bootstrap_arguments, (void *) bsm_arg);\n\t\t} else {\n\t\t\t// TODO eprintf Failed to read the %d boot strap method.\n\t\t}\n\t}\n\tbsm->size = offset;\n\treturn bsm;\n}\n\nR_API void r_bin_java_print_bootstrap_methods_attr_summary(RBinJavaAttrInfo *attr) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaBootStrapMethod *obj = NULL;\n\tif (attr == NULL || attr->type == R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR) {\n\t\teprintf (\"Unable to print attribue summary for RBinJavaAttrInfo *RBinJavaBootstrapMethodsAttr\");\n\t\treturn;\n\t}\n\teprintf (\"Bootstrap Methods Attribute Information Information:\\n\");\n\teprintf (\"\tAttribute Offset: 0x%08\"PFMT64x\"\", attr->file_offset);\n\teprintf (\"\tLength: 0x%08x\", attr->length);\n\teprintf (\"\tNumber of Method Arguments = (0x%02x)\\n\", attr->info.bootstrap_methods_attr.num_bootstrap_methods);\n\tif (attr->info.bootstrap_methods_attr.bootstrap_methods) {\n\t\tr_list_foreach_safe (attr->info.bootstrap_methods_attr.bootstrap_methods, iter, iter_tmp, obj) {\n\t\t\tif (obj) {\n\t\t\t\tr_bin_java_print_bootstrap_method_summary (obj);\n\t\t\t}\n\t\t}\n\t} else {\n\t\teprintf (\"\tBootstrap Methods: NONE \\n\");\n\t}\n}\n\nR_API void r_bin_java_bootstrap_methods_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tr_list_free (attr->info.bootstrap_methods_attr.bootstrap_methods);\n\t\tfree (attr);\n\t}\n}\n\nR_API ut64 r_bin_java_bootstrap_methods_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 size = 0;\n\tif (attr) {\n\t\tsize += 6;\n\t\t// attr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\tr_list_foreach_safe (attr->info.bootstrap_methods_attr.bootstrap_methods, iter, iter_tmp, bsm) {\n\t\t\tif (bsm) {\n\t\t\t\tsize += r_bin_java_bootstrap_method_calc_size (bsm);\n\t\t\t} else {\n\t\t\t\t// TODO eprintf Failed to read the %d boot strap method.\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API ut64 r_bin_java_bootstrap_arg_calc_size(RBinJavaBootStrapArgument *bsm_arg) {\n\tut64 size = 0;\n\tif (bsm_arg) {\n\t\t// bsm_arg->argument_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t}\n\treturn size;\n}\n\nR_API ut64 r_bin_java_bootstrap_method_calc_size(RBinJavaBootStrapMethod *bsm) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaBootStrapArgument *bsm_arg = NULL;\n\tut64 size = 0;\n\tif (bsm) {\n\t\tsize += 6;\n\t\t// bsm->bootstrap_method_ref = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// bsm->num_bootstrap_arguments = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\tr_list_foreach_safe (bsm->bootstrap_arguments, iter, iter_tmp, bsm_arg) {\n\t\t\tif (bsm_arg) {\n\t\t\t\tsize += r_bin_java_bootstrap_arg_calc_size (bsm_arg);\n\t\t\t} else {\n\t\t\t\t// TODO eprintf Failed to read the %d boot strap method.\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n\t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);\n\t\tfor (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) {\n\t\t\t// bsm = r_bin_java_bootstrap_method_new (bin, bin->b->cur);\n\t\t\tbsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (bsm) {\n\t\t\t\toffset += bsm->size;\n\t\t\t\tr_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);\n\t\t\t} else {\n\t\t\t\t// TODO eprintf Failed to read the %d boot strap method.\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n\nR_API void r_bin_java_print_annotation_default_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR) {\n\t\teprintf (\"Annotation Default Attribute Information:\\n\");\n\t\teprintf (\"   Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\t\teprintf (\"   Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\t\teprintf (\"   Attribute Length: %d\\n\", attr->length);\n\t\tr_bin_java_print_element_value_summary ((attr->info.annotation_default_attr.default_value));\n\t} else {\n\t\t// TODO: eprintf attr is invalid\n\t}\n}\n\nR_API void r_bin_java_annotation_array_free(void /*RBinJavaAnnotationsArray*/ *a) {\n\tRBinJavaAnnotationsArray *annotation_array = a;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaAnnotation *annotation;\n\tif (annotation_array->annotations == NULL) {\n\t\t// TODO eprintf\n\t\treturn;\n\t}\n\tr_list_foreach_safe (annotation_array->annotations, iter, iter_tmp, annotation) {\n\t\tif (annotation) {\n\t\t\tr_bin_java_annotation_free (annotation);\n\t\t}\n\t\t// r_list_delete (annotation_array->annotations, iter);\n\t}\n\tr_list_free (annotation_array->annotations);\n\tfree (annotation_array);\n}\n\nR_API void r_bin_java_print_annotation_array_summary(RBinJavaAnnotationsArray *annotation_array) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaAnnotation *annotation;\n\tif (annotation_array->annotations == NULL) {\n\t\t// TODO eprintf\n\t\treturn;\n\t}\n\teprintf (\"   Annotation Array Information:\\n\");\n\teprintf (\"   Number of Annotation Array Elements: %d\\n\", annotation_array->num_annotations);\n\tr_list_foreach_safe (annotation_array->annotations, iter, iter_tmp, annotation) {\n\t\tr_bin_java_print_annotation_summary (annotation);\n\t}\n}\n\nR_API RBinJavaAnnotationsArray *r_bin_java_annotation_array_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaAnnotation *annotation;\n\tRBinJavaAnnotationsArray *annotation_array;\n\tut32 i;\n\tut64 offset = 0;\n\tannotation_array = (RBinJavaAnnotationsArray *) malloc (sizeof (RBinJavaAnnotationsArray));\n\tif (annotation_array == NULL) {\n\t\t// TODO eprintf\n\t\treturn NULL;\n\t}\n\tannotation_array->num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation_array->annotations = r_list_new ();\n\tfor (i = 0; i < annotation_array->num_annotations; i++) {\n\t\tannotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (annotation) {\n\t\t\toffset += annotation->size;\n\t\t}\n\t\tif (annotation == NULL) {\n\t\t\t// TODO eprintf\n\t\t}\n\t\tr_list_append (annotation_array->annotations, (void *) annotation);\n\t}\n\tannotation_array->size = offset;\n\treturn annotation_array;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.annotation_array.num_annotations; i++) {\n\t\t\tint len = sz - offset;\n\t\t\tif (len < 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, len, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_annotation_array_calc_size(RBinJavaAnnotationsArray *annotation_array) {\n\tut64 size = 0;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaAnnotation *annotation;\n\tif (annotation_array->annotations == NULL) {\n\t\t// TODO eprintf\n\t\treturn size;\n\t}\n\t// annotation_array->num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\tsize += 2;\n\tr_list_foreach_safe (annotation_array->annotations, iter, iter_tmp, annotation) {\n\t\tsize += r_bin_java_annotation_calc_size (annotation);\n\t}\n\treturn size;\n}\n\nR_API ut64 r_bin_java_rtv_annotations_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tif (attr == NULL) {\n\t\t// TODO eprintf allocation fail\n\t\treturn size;\n\t}\n\tsize += (6 + r_bin_java_annotation_array_calc_size (&(attr->info.annotation_array)));\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.rtv_annotations_attr.num_annotations; i++) {\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t}\n\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_rti_annotations_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tif (attr == NULL) {\n\t\t// TODO eprintf allocation fail\n\t\treturn size;\n\t}\n\tsize += (6 + r_bin_java_annotation_array_calc_size (&(attr->info.annotation_array)));\n\treturn size;\n}\n\nR_API void r_bin_java_rtv_annotations_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_ANNOTATION_ATTR) {\n\t\tr_list_free (attr->info.annotation_array.annotations);\n\t\tfree (attr->metas);\n\t\tfree (attr->name);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_rti_annotations_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR) {\n\t\tr_list_free (attr->info.annotation_array.annotations);\n\t\tfree (attr->metas);\n\t\tfree (attr->name);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_print_rtv_annotations_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_ANNOTATION_ATTR) {\n\t\tEprintf (\"Runtime Visible Annotations Attribute Information:\\n\");\n\t\tEprintf (\"   Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\t\tEprintf (\"   Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\t\tEprintf (\"   Attribute Length: %d\\n\", attr->length);\n\t\tr_bin_java_print_annotation_array_summary (&attr->info.annotation_array);\n\t}\n}\n\nR_API void r_bin_java_print_rti_annotations_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR) {\n\t\tEprintf (\"Runtime Invisible Annotations Attribute Information:\\n\");\n\t\tEprintf (\"   Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\t\tEprintf (\"   Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\t\tEprintf (\"   Attribute Length: %d\\n\", attr->length);\n\t\tr_bin_java_print_annotation_array_summary (&attr->info.annotation_array);\n\t}\n}\n\nR_API ut64 r_bin_java_rtip_annotations_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaAnnotationsArray *annotation_array;\n\tif (attr == NULL) {\n\t\t// TODO eprintf allocation fail\n\t\treturn size;\n\t}\n\t// attr->info.rtip_annotations_attr.num_parameters = buffer[offset];\n\tsize += (6 + 1);\n\tr_list_foreach_safe (attr->info.rtip_annotations_attr.parameter_annotations, iter, iter_tmp, annotation_array) {\n\t\tif (annotation_array) {\n\t\t\tsize += r_bin_java_annotation_array_calc_size (annotation_array);\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_rtip_annotations_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tRBinJavaAnnotationsArray *annotation_array;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_PARAMETER_ANNOTATION_ATTR;\n\t\tattr->info.rtip_annotations_attr.num_parameters = buffer[offset];\n\t\toffset += 1;\n\t\tattr->info.rtip_annotations_attr.parameter_annotations = r_list_newf (r_bin_java_annotation_array_free);\n\t\tfor (i = 0; i < attr->info.rtip_annotations_attr.num_parameters; i++) {\n\t\t\tannotation_array = r_bin_java_annotation_array_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation_array == NULL) {}\n\t\t\tif (annotation_array) {\n\t\t\t\toffset += annotation_array->size;\n\t\t\t}\n\t\t\tr_list_append (attr->info.rtip_annotations_attr.parameter_annotations, (void *) annotation_array);\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_rtvp_annotations_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tRBinJavaAnnotationsArray *annotation_array;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_PARAMETER_ANNOTATION_ATTR;\n\t\tattr->info.rtvp_annotations_attr.num_parameters = buffer[offset];\n\t\toffset += 1;\n\t\tattr->info.rtvp_annotations_attr.parameter_annotations = r_list_newf (r_bin_java_annotation_array_free);\n\t\tfor (i = 0; i < attr->info.rtvp_annotations_attr.num_parameters; i++) {\n\t\t\tannotation_array = r_bin_java_annotation_array_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation_array == NULL) {}\n\t\t\tif (annotation_array) {\n\t\t\t\toffset += annotation_array->size;\n\t\t\t}\n\t\t\tr_list_append (attr->info.rtvp_annotations_attr.parameter_annotations, (void *) annotation_array);\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_rtvp_annotations_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaAnnotationsArray *annotation_array;\n\tif (!attr) {\n\t\treturn size;\n\t}\n\tsize += (6 + 1);\n\tr_list_foreach_safe (attr->info.rtvp_annotations_attr.parameter_annotations,\n\t\titer, iter_tmp, annotation_array) {\n\t\tif (annotation_array) {\n\t\t\tsize += r_bin_java_annotation_array_calc_size (\n\t\t\t\tannotation_array);\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API void r_bin_java_rtvp_annotations_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tif (attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_PARAMETER_ANNOTATION_ATTR) {\n\t\t\tr_list_free (attr->info.rtvp_annotations_attr.parameter_annotations);\n\t\t}\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_rtip_annotations_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) { // && attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_PARAMETER_ANNOTATION_ATTR) {\n\t\tr_list_free (attr->info.rtip_annotations_attr.parameter_annotations);\n\t\tfree (attr->metas);\n\t\tfree (attr->name);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_print_rtvp_annotations_attr_summary(RBinJavaAttrInfo *attr) {\n\tRBinJavaAnnotationsArray *annotation_array = NULL;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_PARAMETER_ANNOTATION_ATTR) {\n\t\teprintf (\"Runtime Visible Parameter Annotations Attribute Information:\\n\");\n\t\teprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\t\teprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\t\teprintf (\"  Attribute Length: %d\\n\", attr->length);\n\t\teprintf (\"  Number of Runtime Invisible Parameters: %d\\n\", attr->info.rtvp_annotations_attr.num_parameters);\n\t\tr_list_foreach_safe (attr->info.rtvp_annotations_attr.parameter_annotations, iter, iter_tmp, annotation_array) {\n\t\t\tr_bin_java_print_annotation_array_summary (annotation_array);\n\t\t}\n\t}\n}\n\nR_API void r_bin_java_print_rtip_annotations_attr_summary(RBinJavaAttrInfo *attr) {\n\tRBinJavaAnnotationsArray *annotation_array = NULL;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_PARAMETER_ANNOTATION_ATTR) {\n\t\teprintf (\"Runtime Invisible Parameter Annotations Attribute Information:\\n\");\n\t\teprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\t\teprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\t\teprintf (\"  Attribute Length: %d\\n\", attr->length);\n\t\teprintf (\"  Number of Runtime Invisible Parameters: %d\\n\", attr->info.rtip_annotations_attr.num_parameters);\n\t\tr_list_foreach_safe (attr->info.rtip_annotations_attr.parameter_annotations, iter, iter_tmp, annotation_array) {\n\t\t\tr_bin_java_print_annotation_array_summary (annotation_array);\n\t\t}\n\t}\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_find_cp_name_and_type_info(RBinJavaObj *bin, ut16 name_idx, ut16 descriptor_idx) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaCPTypeObj *res = NULL, *obj = NULL;\n\tIFDBG eprintf(\"Looking for name_idx: %d and descriptor_idx: %d\\n\", name_idx, descriptor_idx);\n\tr_list_foreach_safe (bin->cp_list, iter, iter_tmp, obj) {\n\t\tif (obj && obj->tag == R_BIN_JAVA_CP_NAMEANDTYPE) {\n\t\t\tIFDBG eprintf(\"RBinJavaCPTypeNameAndType has name_idx: %d and descriptor_idx: %d\\n\",\n\t\t\tobj->info.cp_name_and_type.name_idx, obj->info.cp_name_and_type.descriptor_idx);\n\t\t\tif (obj->info.cp_name_and_type.name_idx == name_idx &&\n\t\t\tobj->info.cp_name_and_type.descriptor_idx == descriptor_idx) {\n\t\t\t\tres = obj;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API char *r_bin_java_resolve_cp_idx_type(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaCPTypeObj *item = NULL;\n\tchar *str = NULL;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\t// r_bin_java_new_bin(BIN_OBJ);\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\tstr = strdup (((RBinJavaCPTypeMetas *) item->metas->type_info)->name);\n\t} else {\n\t\tstr = strdup (\"INVALID\");\n\t}\n\treturn str;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_find_cp_ref_info_from_name_and_type(RBinJavaObj *bin, ut16 name_idx, ut16 descriptor_idx) {\n\tRBinJavaCPTypeObj *obj = r_bin_java_find_cp_name_and_type_info (bin, name_idx, descriptor_idx);\n\tif (obj) {\n\t\treturn r_bin_java_find_cp_ref_info (bin, obj->metas->ord);\n\t}\n\treturn NULL;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_find_cp_ref_info(RBinJavaObj *bin, ut16 name_and_type_idx) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaCPTypeObj *res = NULL, *obj = NULL;\n\tr_list_foreach_safe (bin->cp_list, iter, iter_tmp, obj) {\n\t\tif (obj->tag == R_BIN_JAVA_CP_FIELDREF &&\n\t\tobj->info.cp_field.name_and_type_idx == name_and_type_idx) {\n\t\t\tres = obj;\n\t\t\tbreak;\n\t\t} else if (obj->tag == R_BIN_JAVA_CP_METHODREF &&\n\t\tobj->info.cp_method.name_and_type_idx == name_and_type_idx) {\n\t\t\tres = obj;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API char *r_bin_java_resolve(RBinJavaObj *BIN_OBJ, int idx, ut8 space_bn_name_type) {\n\t// TODO XXX FIXME add a size parameter to the str when it is passed in\n\tRBinJavaCPTypeObj *item = NULL, *item2 = NULL;\n\tchar *class_str = NULL,\n\t*name_str = NULL,\n\t*desc_str = NULL,\n\t*string_str = NULL,\n\t*empty = \"\",\n\t*cp_name = NULL,\n\t*str = NULL;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\t// r_bin_java_new_bin(BIN_OBJ);\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\tcp_name = ((RBinJavaCPTypeMetas *) item->metas->type_info)->name;\n\t\tIFDBG eprintf(\"java_resolve Resolved: (%d) %s\\n\", idx, cp_name);\n\t} else {\n\t\tstr = malloc (512);\n\t\tif (str) {\n\t\t\tsnprintf (str, 512, \"(%d) INVALID CP_OBJ\", idx);\n\t\t}\n\t\treturn str;\n\t}\n\tcp_name = ((RBinJavaCPTypeMetas *) item->metas->type_info)->name;\n\tif (strcmp (cp_name, \"Class\") == 0) {\n\t\titem2 = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\t\t// str = r_bin_java_get_name_from_bin_cp_list (BIN_OBJ, idx-1);\n\t\tclass_str = empty;\n\t\tclass_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!class_str) {\n\t\t\tclass_str = empty;\n\t\t}\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item2);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item2);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tstr = r_str_newf (\"%s%s%s\", name_str,\n\t\t\tspace_bn_name_type ? \" \" : \"\", desc_str);\n\t\tif (class_str != empty) {\n\t\t\tfree (class_str);\n\t\t}\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else if (!strcmp (cp_name, \"MethodRef\") ||\n\t!strcmp (cp_name, \"FieldRef\") ||\n\t!strcmp (cp_name, \"InterfaceMethodRef\")) {\n\t\t/*\n\t\t*  The MethodRef, FieldRef, and InterfaceMethodRef structures\n\t\t*/\n\t\tclass_str = r_bin_java_get_name_from_bin_cp_list (BIN_OBJ, item->info.cp_method.class_idx);\n\t\tif (!class_str) {\n\t\t\tclass_str = empty;\n\t\t}\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tstr = r_str_newf (\"%s/%s%s%s\", class_str, name_str,\n\t\t\tspace_bn_name_type ? \" \" : \"\", desc_str);\n\t\tif (class_str != empty) {\n\t\t\tfree (class_str);\n\t\t}\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else if (!strcmp (cp_name, \"String\")) {\n\t\tstring_str = r_bin_java_get_utf8_from_bin_cp_list (BIN_OBJ, item->info.cp_string.string_idx);\n\t\tstr = NULL;\n\t\tIFDBG eprintf(\"java_resolve String got: (%d) %s\\n\", item->info.cp_string.string_idx, string_str);\n\t\tif (!string_str) {\n\t\t\tstring_str = empty;\n\t\t}\n\t\tstr = r_str_newf (\"\\\"%s\\\"\", string_str);\n\t\tIFDBG eprintf(\"java_resolve String return: %s\\n\", str);\n\t\tif (string_str != empty) {\n\t\t\tfree (string_str);\n\t\t}\n\n\t} else if (!strcmp (cp_name, \"Utf8\")) {\n\t\tchar *tmp_str = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);\n\t\tut32 tmp_str_len = tmp_str ? strlen (tmp_str) + 4 : 0;\n\t\tif (tmp_str) {\n\t\t\tstr = malloc (tmp_str_len + 4);\n\t\t\tsnprintf (str, tmp_str_len + 4, \"\\\"%s\\\"\", tmp_str);\n\t\t}\n\t\tfree (tmp_str);\n\t} else if (!strcmp (cp_name, \"Long\")) {\n\t\tstr = r_str_newf (\"0x%\"PFMT64x, r_bin_java_raw_to_long (item->info.cp_long.bytes.raw, 0));\n\t} else if (!strcmp (cp_name, \"Double\")) {\n\t\tstr = r_str_newf (\"%f\", r_bin_java_raw_to_double (item->info.cp_double.bytes.raw, 0));\n\t} else if (!strcmp (cp_name, \"Integer\")) {\n\t\tstr = r_str_newf (\"0x%08x\", R_BIN_JAVA_UINT (item->info.cp_integer.bytes.raw, 0));\n\t} else if (!strcmp (cp_name, \"Float\")) {\n\t\tstr = r_str_newf (\"%f\", R_BIN_JAVA_FLOAT (item->info.cp_float.bytes.raw, 0));\n\t} else if (!strcmp (cp_name, \"NameAndType\")) {\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tstr = r_str_newf (\"%s%s%s\", name_str, space_bn_name_type ? \" \" : \"\", desc_str);\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else {\n\t\tstr = strdup (\"(null)\");\n\t}\n\treturn str;\n}\n\nR_API ut8 r_bin_java_does_cp_idx_ref_method(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaField *fm_type = NULL;\n\tRListIter *iter;\n\tut8 res = 0;\n\tr_list_foreach (BIN_OBJ->methods_list, iter, fm_type) {\n\t\tif (fm_type->field_ref_cp_obj->metas->ord == idx) {\n\t\t\tres = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API ut8 r_bin_java_does_cp_idx_ref_field(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaField *fm_type = NULL;\n\tRListIter *iter;\n\tut8 res = 0;\n\tr_list_foreach (BIN_OBJ->fields_list, iter, fm_type) {\n\t\tif (fm_type->field_ref_cp_obj->metas->ord == idx) {\n\t\t\tres = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API char *r_bin_java_get_method_name(RBinJavaObj *bin_obj, ut32 idx) {\n\tchar *name = NULL;\n\tif (idx < r_list_length (bin_obj->methods_list)) {\n\t\tRBinJavaField *fm_type = r_list_get_n (bin_obj->methods_list, idx);\n\t\tname = strdup (fm_type->name);\n\t}\n\treturn name;\n}\n\nR_API RList *r_bin_java_get_method_num_name(RBinJavaObj *bin_obj) {\n\tut32 i = 0;\n\tRListIter *iter = NULL;\n\tRBinJavaField *fm_type;\n\tRList *res = r_list_newf (free);\n\tr_list_foreach (bin_obj->methods_list, iter, fm_type) {\n\t\tut32 len = strlen (fm_type->name) + 30;\n\t\tchar *str = malloc (len);\n\t\tsnprintf (str, len, \"%d %s\", i, fm_type->name);\n\t\t++i;\n\t\tr_list_append (res, str);\n\t}\n\treturn res;\n}\n\n/*\n   R_API int r_bin_java_does_cp_obj_ref_idx (RBinJavaObj *bin_obj, RBinJavaCPTypeObj *cp_obj, ut16 idx) {\n        int res = false;\n        RBinJavaCPTypeObj *t_obj = NULL;\n        if (cp_obj) {\n                switch (cp_obj->tag) {\n                        case R_BIN_JAVA_CP_NULL: break;\n                        case R_BIN_JAVA_CP_UTF8: break;\n                        case R_BIN_JAVA_CP_UNKNOWN: break;\n                        case R_BIN_JAVA_CP_INTEGER: break;\n                        case R_BIN_JAVA_CP_FLOAT: break;\n                        case R_BIN_JAVA_CP_LONG: break;\n                        case R_BIN_JAVA_CP_DOUBLE: break;\n                        case R_BIN_JAVA_CP_CLASS:\n                                res = idx == cp_obj->info.cp_class.name_idx ? true : false;\n                                break;\n                        case R_BIN_JAVA_CP_STRING:\n                                res = idx == cp_obj->info.cp_string.string_idx ? true : false;\n                                break;\n                        case R_BIN_JAVA_CP_METHODREF: break;// check if idx is referenced here\n                        case R_BIN_JAVA_CP_INTERFACEMETHOD_REF: break; // check if idx is referenced here\n                        case R_BIN_JAVA_CP_FIELDREF:\n                                t_obj = r_bin_java_get_item_from_cp (bin_obj, cp_obj->info.cp_method.class_idx);\n                                res = r_bin_java_does_cp_obj_ref_idx (bin_obj, t_obj, idx);\n                                if (res == true) break;\n                                t_obj = r_bin_java_get_item_from_cp (bin_obj, cp_obj->info.cp_method.name_and_type_idx);\n                                res = r_bin_java_does_cp_obj_ref_idx (bin_obj, t_obj, idx);\n                                break;\n                        case R_BIN_JAVA_CP_NAMEANDTYPE: break;// check if idx is referenced here\n                                obj->info.cp_name_and_type.name_idx\n                        case R_BIN_JAVA_CP_METHODHANDLE: break;// check if idx is referenced here\n                        case R_BIN_JAVA_CP_METHODTYPE: break;// check if idx is referenced here\n                        case R_BIN_JAVA_CP_INVOKEDYNAMIC: break;// check if idx is referenced here\n                }\n        }\n   }\n */\nR_API RList *r_bin_java_find_cp_const_by_val_long(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len) {\n\tRList *res = r_list_newf (free);\n\tut32 *v = NULL;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *cp_obj;\n\teprintf (\"Looking for 0x%08x\\n\", R_BIN_JAVA_UINT (bytes, 0));\n\tr_list_foreach (bin_obj->cp_list, iter, cp_obj) {\n\t\tif (cp_obj->tag == R_BIN_JAVA_CP_LONG) {\n\t\t\tif (len == 8 && r_bin_java_raw_to_long (cp_obj->info.cp_long.bytes.raw, 0) == r_bin_java_raw_to_long (bytes, 0)) {\n\t\t\t\t// TODO: we can safely store a ut32 inside the list without having to allocate it\n\t\t\t\tv = malloc (sizeof (ut32));\n\t\t\t\tif (!v) {\n\t\t\t\t\tr_list_free (res);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t*v = cp_obj->idx;\n\t\t\t\tr_list_append (res, v);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API RList *r_bin_java_find_cp_const_by_val_double(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len) {\n\tRList *res = r_list_newf (free);\n\tut32 *v = NULL;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *cp_obj;\n\teprintf (\"Looking for %f\\n\", r_bin_java_raw_to_double (bytes, 0));\n\tr_list_foreach (bin_obj->cp_list, iter, cp_obj) {\n\t\tif (cp_obj->tag == R_BIN_JAVA_CP_DOUBLE) {\n\t\t\tif (len == 8 && r_bin_java_raw_to_double (cp_obj->info.cp_long.bytes.raw, 0) == r_bin_java_raw_to_double (bytes, 0)) {\n\t\t\t\tv = malloc (sizeof (ut32));\n\t\t\t\tif (!v) {\n\t\t\t\t\tr_list_free (res);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t*v = cp_obj->idx;\n\t\t\t\tr_list_append (res, v);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API RList *r_bin_java_find_cp_const_by_val_float(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len) {\n\tRList *res = r_list_newf (free);\n\tut32 *v = NULL;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *cp_obj;\n\teprintf (\"Looking for %f\\n\", R_BIN_JAVA_FLOAT (bytes, 0));\n\tr_list_foreach (bin_obj->cp_list, iter, cp_obj) {\n\t\tif (cp_obj->tag == R_BIN_JAVA_CP_FLOAT) {\n\t\t\tif (len == 4 && R_BIN_JAVA_FLOAT (cp_obj->info.cp_long.bytes.raw, 0) == R_BIN_JAVA_FLOAT (bytes, 0)) {\n\t\t\t\tv = malloc (sizeof (ut32));\n\t\t\t\tif (!v) {\n\t\t\t\t\tr_list_free (res);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t*v = cp_obj->idx;\n\t\t\t\tr_list_append (res, v);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API RList *r_bin_java_find_cp_const_by_val(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len, const char t) {\n\tswitch (t) {\n\tcase R_BIN_JAVA_CP_UTF8: return r_bin_java_find_cp_const_by_val_utf8 (bin_obj, bytes, len);\n\tcase R_BIN_JAVA_CP_INTEGER: return r_bin_java_find_cp_const_by_val_int (bin_obj, bytes, len);\n\tcase R_BIN_JAVA_CP_FLOAT: return r_bin_java_find_cp_const_by_val_float (bin_obj, bytes, len);\n\tcase R_BIN_JAVA_CP_LONG: return r_bin_java_find_cp_const_by_val_long (bin_obj, bytes, len);\n\tcase R_BIN_JAVA_CP_DOUBLE: return r_bin_java_find_cp_const_by_val_double (bin_obj, bytes, len);\n\tcase R_BIN_JAVA_CP_UNKNOWN:\n\tdefault:\n\t\teprintf (\"Failed to perform the search for: %s\\n\", bytes);\n\t\treturn r_list_new ();\n\t}\n}\n\n// #if 0\n// Attempted to clean up these functions and remove them since they are \"unused\" but without\n// them there are some compile time warnings, because other projects actually depend on these\n// for some form of information.\nR_API void U(add_cp_objs_to_sdb)(RBinJavaObj * bin) {\n\t/*\n\tAdd Constant Pool Serialized Object to an Array\n\tthe key for this info is:\n\tKey:\n\tjava.<classname>.cp_obj\n\tEach Value varies by type:\n\tIn general its:\n\t<ordinal>.<file_offset>.<type_name>.[type specific stuff]\n\tExample:\n\tUTF-8:  <ordinal>.<file_offset>.<type_name>.<strlen>.<hexlified(str)>\n\tInteger: <ordinal>.<file_offset>.<type_name>.<abs(int)>\n\tLong: <ordinal>.<file_offset>.<type_name>.abs(long)>\n\tFieldRef/MethodRef: <ordinal>.<file_offset>.<type_name>.<class_idx>.<name_and_type_idx>\n\t*/\n\tut32 idx = 0, class_name_inheap = 1;\n\tRBinJavaCPTypeObj *cp_obj = NULL;\n\tchar *key = NULL,\n\t*value = NULL;\n\tchar str_cnt[40];\n\tchar *class_name = r_bin_java_get_this_class_name (bin);\n\tut32 key_buf_size = 0;\n\tif (class_name == NULL) {\n\t\tclass_name = \"unknown\";\n\t\tclass_name_inheap = 0;\n\t}\n\t// 4 - format, 8 number, 1 null byte, 7 \"unknown\"\n\tkey_buf_size = strlen (class_name) + 4 + 8 + 1;\n\tkey = malloc (key_buf_size);\n\tif (key == NULL) {\n\t\tif (class_name_inheap) {\n\t\t\tfree (class_name);\n\t\t}\n\t\treturn;\n\t}\n\tsnprintf (key, key_buf_size - 1, \"%s.cp_count\", class_name);\n\tkey[key_buf_size - 1] = 0;\n\tsnprintf (str_cnt, 39, \"%d\", bin->cp_count);\n\tstr_cnt[39] = 0;\n\tsdb_set (bin->kv, key, value, 0);\n\t// sdb_alist(bin->kv, key);\n\tfor (idx = 0; idx < bin->cp_count; idx++) {\n\t\tsnprintf (key, key_buf_size - 1, \"%s.cp.%d\", class_name, idx);\n\t\tkey[key_buf_size - 1] = 0;\n\t\tcp_obj = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\t\tIFDBG eprintf(\"Adding %s to the sdb.\\n\", key);\n\t\tif (cp_obj) {\n\t\t\tvalue = ((RBinJavaCPTypeMetas *)\n\t\t\tcp_obj->metas->type_info)->\n\t\t\tallocs->stringify_obj (cp_obj);\n\t\t\tsdb_set (bin->kv, key, value, 0);\n\t\t\tfree (value);\n\t\t}\n\t}\n\tif (class_name_inheap) {\n\t\tfree (class_name);\n\t}\n\tfree (key);\n}\n\nR_API void U(add_field_infos_to_sdb)(RBinJavaObj * bin) {\n\t/*\n\t*** Experimental and May Change ***\n\tAdd field information to an Array\n\tthe key for this info variable depenedent on addr, method ordinal, etc.\n\tKey 1, mapping to method key:\n\tjava.<file_offset> = <field_key>\n\tKey 3, method description\n\t<field_key>.info = [<access str>, <class_name>, <name>, <signature>]\n\tkey 4, method meta\n\t<field_key>.meta = [<file_offset>, ?]\n\t*/\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaField *fm_type;\n\tut32 key_size = 255,\n\tvalue_buffer_size = 1024,\n\tclass_name_inheap = 1;\n\tchar *field_key = NULL,\n\t*field_key_value = NULL,\n\t*value_buffer = NULL;\n\tchar *class_name = r_bin_java_get_this_class_name (bin);\n\tif (class_name == NULL) {\n\t\tclass_name = \"unknown\";\n\t\tclass_name_inheap = 0;\n\t}\n\tkey_size += strlen (class_name);\n\tvalue_buffer_size += strlen (class_name);\n\tfield_key = malloc (key_size);\n\tvalue_buffer = malloc (value_buffer_size);\n\tfield_key_value = malloc (key_size);\n\tsnprintf (field_key, key_size, \"%s.methods\", class_name);\n\tfield_key[key_size - 1] = 0;\n\tr_list_foreach_safe (bin->fields_list, iter, iter_tmp, fm_type) {\n\t\tchar number_buffer[80];\n\t\tut64 file_offset = fm_type->file_offset + bin->loadaddr;\n\t\tsnprintf (number_buffer, sizeof (number_buffer), \"0x%04\"PFMT64x, file_offset);\n\t\tIFDBG eprintf(\"Inserting: []%s = %s\\n\", field_key, number_buffer);\n\t\tsdb_array_push (bin->kv, field_key, number_buffer, 0);\n\t}\n\tr_list_foreach_safe (bin->fields_list, iter, iter_tmp, fm_type) {\n\t\tut64 field_offset = fm_type->file_offset + bin->loadaddr;\n\t\t// generate method specific key & value\n\t\tsnprintf (field_key, key_size, \"%s.0x%04\"PFMT64x, class_name, field_offset);\n\t\tfield_key[key_size - 1] = 0;\n\t\tsnprintf (field_key_value, key_size, \"%s.0x%04\"PFMT64x \".field\", class_name, field_offset);\n\t\tfield_key_value[key_size - 1] = 0;\n\t\tsdb_set (bin->kv, field_key, field_key_value, 0);\n\t\tIFDBG eprintf(\"Inserting: %s = %s\\n\", field_key, field_key_value);\n\t\t// generate info key, and place values in method info array\n\t\tsnprintf (field_key, key_size, \"%s.info\", field_key_value);\n\t\tfield_key[key_size - 1] = 0;\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->flags_str);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tsdb_array_push (bin->kv, field_key, value_buffer, 0);\n\t\tIFDBG eprintf(\"Inserting: []%s = %s\\n\", field_key, value_buffer);\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->class_name);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tsdb_array_push (bin->kv, field_key, value_buffer, 0);\n\t\tIFDBG eprintf(\"Inserting: []%s = %s\\n\", field_key, value_buffer);\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->name);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tsdb_array_push (bin->kv, field_key, value_buffer, 0);\n\t\tIFDBG eprintf(\"Inserting: []%s = %s\\n\", field_key, value_buffer);\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->descriptor);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tsdb_array_push (bin->kv, field_key, value_buffer, 0);\n\t\tIFDBG eprintf(\"Inserting: []%s = %s\\n\", field_key, value_buffer);\n\t}\n\tfree (field_key);\n\tfree (field_key_value);\n\tfree (value_buffer);\n\tif (class_name_inheap) {\n\t\tfree (class_name);\n\t}\n}\n\nR_API void U(add_method_infos_to_sdb)(RBinJavaObj * bin) {\n\t/*\n\t*** Experimental and May Change ***\n\tAdd Mehtod information to an Array\n\tthe key for this info variable depenedent on addr, method ordinal, etc.\n\tKey 1, mapping to method key:\n\tjava.<file_offset> = <method_key>\n\tKey 2, basic code information\n\t<method_key>.code = [<addr>, <size>]\n\tKey 3, method description\n\t<method_key>.info = [<access str>, <class_name>, <name>, <signature>,]\n\tkey 4, method meta\n\t<method_key>.meta = [<file_offset>, ?]\n\t// TODO in key 3 add <class_name>?\n\te.g. <access str>.<name>.<signature>\n\tNote: method name not used because of collisions with operator overloading\n\talso take note that code offset and the method offset are not the same\n\tvalues.\n\t*/\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaField *fm_type;\n\tut32 key_size = 255,\n\tvalue_buffer_size = 1024,\n\tclass_name_inheap = 1;\n\tchar *method_key = NULL,\n\t*method_key_value = NULL,\n\t*value_buffer = NULL;\n\tchar *class_name = r_bin_java_get_this_class_name (bin);\n\tut64 baddr = bin->loadaddr;\n\tif (class_name == NULL) {\n\t\tclass_name = \"unknown\";\n\t\tclass_name_inheap = 0;\n\t}\n\tkey_size += strlen (class_name);\n\tvalue_buffer_size += strlen (class_name);\n\tmethod_key = malloc (key_size);\n\tvalue_buffer = malloc (value_buffer_size);\n\tmethod_key_value = malloc (key_size);\n\tsnprintf (method_key, key_size, \"%s.methods\", class_name);\n\tmethod_key[key_size - 1] = 0;\n\tr_list_foreach_safe (bin->methods_list, iter, iter_tmp, fm_type) {\n\t\tchar number_buffer[80];\n\t\tut64 file_offset = fm_type->file_offset + baddr;\n\t\tsnprintf (number_buffer, sizeof (number_buffer), \"0x%04\"PFMT64x, file_offset);\n\t\tsdb_array_push (bin->kv, method_key, number_buffer, 0);\n\t}\n\tr_list_foreach_safe (bin->methods_list, iter, iter_tmp, fm_type) {\n\t\tut64 code_offset = r_bin_java_get_method_code_offset (fm_type) + baddr,\n\t\tcode_size = r_bin_java_get_method_code_size (fm_type),\n\t\tmethod_offset = fm_type->file_offset + baddr;\n\t\t// generate method specific key & value\n\t\tsnprintf (method_key, key_size, \"%s.0x%04\"PFMT64x, class_name, code_offset);\n\t\tmethod_key[key_size - 1] = 0;\n\t\tsnprintf (method_key_value, key_size, \"%s.0x%04\"PFMT64x \".method\", class_name, method_offset);\n\t\tmethod_key_value[key_size - 1] = 0;\n\t\tIFDBG eprintf(\"Adding %s to sdb_array: %s\\n\", method_key_value, method_key);\n\t\tsdb_set (bin->kv, method_key, method_key_value, 0);\n\t\t// generate code key and values\n\t\tsnprintf (method_key, key_size, \"%s.code\", method_key_value);\n\t\tmethod_key[key_size - 1] = 0;\n\t\tsnprintf (value_buffer, value_buffer_size, \"0x%04\"PFMT64x, code_offset);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tsdb_array_push (bin->kv, method_key, value_buffer, 0);\n\t\tsnprintf (value_buffer, value_buffer_size, \"0x%04\"PFMT64x, code_size);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tsdb_array_push (bin->kv, method_key, value_buffer, 0);\n\t\t// generate info key, and place values in method info array\n\t\tsnprintf (method_key, key_size, \"%s.info\", method_key_value);\n\t\tmethod_key[key_size - 1] = 0;\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->flags_str);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tIFDBG eprintf(\"Adding %s to sdb_array: %s\\n\", value_buffer, method_key);\n\t\tsdb_array_push (bin->kv, method_key, value_buffer, 0);\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->class_name);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tIFDBG eprintf(\"Adding %s to sdb_array: %s\\n\", value_buffer, method_key);\n\t\tsdb_array_push (bin->kv, method_key, value_buffer, 0);\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->name);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tIFDBG eprintf(\"Adding %s to sdb_array: %s\\n\", value_buffer, method_key);\n\t\tsdb_array_push (bin->kv, method_key, value_buffer, 0);\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->descriptor);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tIFDBG eprintf(\"Adding %s to sdb_array: %s\\n\", value_buffer, method_key);\n\t\tsdb_array_push (bin->kv, method_key, value_buffer, 0);\n\t}\n\tfree (method_key);\n\tfree (method_key_value);\n\tfree (value_buffer);\n\tif (class_name_inheap) {\n\t\tfree (class_name);\n\t}\n}\n\nR_API RList *U(r_bin_java_get_args_from_bin)(RBinJavaObj * bin_obj, ut64 addr) {\n\tRBinJavaField *fm_type = r_bin_java_get_method_code_attribute_with_addr (bin_obj, addr);\n\treturn fm_type ? r_bin_java_get_args (fm_type) : NULL;\n}\n\nR_API RList *U(r_bin_java_get_ret_from_bin)(RBinJavaObj * bin_obj, ut64 addr) {\n\tRBinJavaField *fm_type = r_bin_java_get_method_code_attribute_with_addr (bin_obj, addr);\n\treturn fm_type ? r_bin_java_get_ret (fm_type) : NULL;\n}\n\nR_API char *U(r_bin_java_get_fcn_name_from_bin)(RBinJavaObj * bin_obj, ut64 addr) {\n\tRBinJavaField *fm_type = r_bin_java_get_method_code_attribute_with_addr (bin_obj, addr);\n\treturn fm_type && fm_type->name ? strdup (fm_type->name) : NULL;\n}\n\nR_API int U(r_bin_java_is_method_static)(RBinJavaObj * bin_obj, ut64 addr) {\n\tRBinJavaField *fm_type = r_bin_java_get_method_code_attribute_with_addr (bin_obj, addr);\n\treturn fm_type && fm_type->flags & R_BIN_JAVA_METHOD_ACC_STATIC;\n}\n\nR_API int U(r_bin_java_is_method_private)(RBinJavaObj * bin_obj, ut64 addr) {\n\treturn r_bin_java_is_fm_type_private (r_bin_java_get_method_code_attribute_with_addr (bin_obj, addr));\n}\n\nR_API int U(r_bin_java_is_method_protected)(RBinJavaObj * bin_obj, ut64 addr) {\n\treturn r_bin_java_is_fm_type_protected (\n\t\tr_bin_java_get_method_code_attribute_with_addr (bin_obj, addr));\n}\n\nR_API int r_bin_java_print_method_idx_summary(RBinJavaObj *bin_obj, ut32 idx) {\n\tint res = false;\n\tif (idx < r_list_length (bin_obj->methods_list)) {\n\t\tRBinJavaField *fm_type = r_list_get_n (bin_obj->methods_list, idx);\n\t\tr_bin_java_print_method_summary (fm_type);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nR_API ut32 r_bin_java_get_method_count(RBinJavaObj *bin_obj) {\n\treturn r_list_length (bin_obj->methods_list);\n}\n\nR_API RList *r_bin_java_get_interface_names(RBinJavaObj *bin) {\n\tRList *interfaces_names = r_list_new ();\n\tRListIter *iter;\n\tRBinJavaInterfaceInfo *ifobj;\n\tr_list_foreach (bin->interfaces_list, iter, ifobj) {\n\t\tif (ifobj && ifobj->name) {\n\t\t\tr_list_append (interfaces_names, strdup (ifobj->name));\n\t\t}\n\t}\n\treturn interfaces_names;\n}\n\nR_API ut64 r_bin_java_get_main(RBinJavaObj *bin) {\n\tif (bin->main_code_attr) {\n\t\treturn bin->main_code_attr->info.code_attr.code_offset + bin->loadaddr;\n\t}\n\treturn 0;\n}\n\nR_API RBinJavaObj *r_bin_java_new(const char *file, ut64 loadaddr, Sdb *kv) {\n\tut8 *buf;\n\tRBinJavaObj *bin = R_NEW0 (RBinJavaObj);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tbin->file = strdup (file);\n\tif (!(buf = (ut8 *) r_file_slurp (file, &bin->size))) {\n\t\treturn r_bin_java_free (bin);\n\t}\n\tif (!r_bin_java_new_bin (bin, loadaddr, kv, buf, bin->size)) {\n\t\tr_bin_java_free (bin);\n\t\tbin = NULL;\n\t}\n\tfree (buf);\n\treturn bin;\n}\n\nR_API ut64 r_bin_java_get_class_entrypoint(RBinJavaObj *bin) {\n\tif (bin->cf2.this_class_entrypoint_code_attr) {\n\t\treturn bin->cf2.this_class_entrypoint_code_attr->info.code_attr.code_offset;\n\t}\n\treturn 0;\n}\n\nR_API RList *r_bin_java_get_method_exception_table_with_addr(RBinJavaObj *bin, ut64 addr) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaField *fm_type, *res = NULL;\n\tif (!bin && R_BIN_JAVA_GLOBAL_BIN) {\n\t\tbin = R_BIN_JAVA_GLOBAL_BIN;\n\t}\n\tif (!bin) {\n\t\teprintf (\"Attempting to analyse function when the R_BIN_JAVA_GLOBAL_BIN has not been set.\\n\");\n\t\treturn NULL;\n\t}\n\tr_list_foreach_safe (bin->methods_list, iter, iter_tmp, fm_type) {\n\t\tut64 offset = r_bin_java_get_method_code_offset (fm_type) + bin->loadaddr,\n\t\tsize = r_bin_java_get_method_code_size (fm_type);\n\t\tif (addr >= offset && addr <= size + offset) {\n\t\t\tres = fm_type;\n\t\t}\n\t}\n\tif (res) {\n\t\tRBinJavaAttrInfo *code_attr = r_bin_java_get_method_code_attribute (res);\n\t\treturn code_attr->info.code_attr.exception_table;\n\t}\n\treturn NULL;\n}\n\nR_API const RList *r_bin_java_get_methods_list(RBinJavaObj *bin) {\n\tif (bin) {\n\t\treturn bin->methods_list;\n\t}\n\tif (R_BIN_JAVA_GLOBAL_BIN) {\n\t\treturn R_BIN_JAVA_GLOBAL_BIN->methods_list;\n\t}\n\treturn NULL;\n}\n\nR_API RList *r_bin_java_get_bin_obj_list_thru_obj(RBinJavaObj *bin_obj) {\n\tRList *the_list;\n\tSdb *sdb;\n\tif (!bin_obj) {\n\t\treturn NULL;\n\t}\n\tsdb = bin_obj->AllJavaBinObjs;\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tthe_list = r_list_new ();\n\tif (!the_list) {\n\t\treturn NULL;\n\t}\n\tsdb_foreach (sdb, sdb_iterate_build_list, (void *) the_list);\n\treturn the_list;\n}\n\nR_API RList *r_bin_java_extract_all_bin_type_values(RBinJavaObj *bin_obj) {\n\tRListIter *fm_type_iter;\n\tRList *all_types = r_list_new ();\n\tRBinJavaField *fm_type;\n\t// get all field types\n\tr_list_foreach (bin_obj->fields_list, fm_type_iter, fm_type) {\n\t\tchar *desc = NULL;\n\t\tif (!extract_type_value (fm_type->descriptor, &desc)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tIFDBG eprintf(\"Adding field type: %s\\n\", desc);\n\t\tr_list_append (all_types, desc);\n\t}\n\t// get all method types\n\tr_list_foreach (bin_obj->methods_list, fm_type_iter, fm_type) {\n\t\tRList *the_list = r_bin_java_extract_type_values (fm_type->descriptor);\n\t\tRListIter *desc_iter;\n\t\tchar *str;\n\t\tr_list_foreach (the_list, desc_iter, str) {\n\t\t\tif (str && *str != '(' && *str != ')') {\n\t\t\t\tr_list_append (all_types, strdup (str));\n\t\t\t\tIFDBG eprintf(\"Adding method type: %s\\n\", str);\n\t\t\t}\n\t\t}\n\t\tr_list_free (the_list);\n\t}\n\treturn all_types;\n}\n\nR_API RList *r_bin_java_get_method_definitions(RBinJavaObj *bin) {\n\tRBinJavaField *fm_type = NULL;\n\tRList *the_list = r_list_new ();\n\tif (!the_list) {\n\t\treturn NULL;\n\t}\n\tRListIter *iter = NULL;\n\tif (!bin) {\n\t\treturn the_list;\n\t}\n\tr_list_foreach (bin->methods_list, iter, fm_type) {\n\t\tchar *method_proto = r_bin_java_get_method_definition (fm_type);\n\t\t// eprintf (\"Method prototype: %s\\n\", method_proto);\n\t\tr_list_append (the_list, method_proto);\n\t}\n\treturn the_list;\n}\n\nR_API RList *r_bin_java_get_field_definitions(RBinJavaObj *bin) {\n\tRBinJavaField *fm_type = NULL;\n\tRList *the_list = r_list_new ();\n\tif (!the_list) {\n\t\treturn NULL;\n\t}\n\tRListIter *iter = NULL;\n\tif (!bin) {\n\t\treturn the_list;\n\t}\n\tr_list_foreach (bin->fields_list, iter, fm_type) {\n\t\tchar *field_def = r_bin_java_get_field_definition (fm_type);\n\t\t// eprintf (\"Field def: %s, %s, %s, %s\\n\", fm_type->name, fm_type->descriptor, fm_type->flags_str, field_def);\n\t\tr_list_append (the_list, field_def);\n\t}\n\treturn the_list;\n}\n\nR_API RList *r_bin_java_get_import_definitions(RBinJavaObj *bin) {\n\tRList *the_list = r_bin_java_get_lib_names (bin);\n\tRListIter *iter = NULL;\n\tchar *new_str;\n\tif (!bin || !the_list) {\n\t\treturn the_list;\n\t}\n\tr_list_foreach (the_list, iter, new_str) {\n\t\twhile (*new_str) {\n\t\t\tif (*new_str == '/') {\n\t\t\t\t*new_str = '.';\n\t\t\t}\n\t\t\tnew_str++;\n\t\t}\n\t}\n\treturn the_list;\n}\n\nR_API RList *r_bin_java_get_field_offsets(RBinJavaObj *bin) {\n\tRBinJavaField *fm_type = NULL;\n\tRList *the_list = r_list_new ();\n\tif (!the_list) {\n\t\treturn NULL;\n\t}\n\tRListIter *iter = NULL;\n\tut64 *paddr = NULL;\n\tif (!bin) {\n\t\treturn the_list;\n\t}\n\tthe_list->free = free;\n\tr_list_foreach (bin->fields_list, iter, fm_type) {\n\t\tpaddr = malloc (sizeof(ut64));\n\t\tif (!paddr) {\n\t\t\tr_list_free (the_list);\n\t\t\treturn NULL;\n\t\t}\n\t\t*paddr = fm_type->file_offset + bin->loadaddr;\n\t\t// eprintf (\"Field def: %s, %s, %s, %s\\n\", fm_type->name, fm_type->descriptor, fm_type->flags_str, field_def);\n\t\tr_list_append (the_list, paddr);\n\t}\n\treturn the_list;\n}\n\nR_API RList *r_bin_java_get_method_offsets(RBinJavaObj *bin) {\n\tRBinJavaField *fm_type = NULL;\n\tRList *the_list = r_list_new ();\n\tRListIter *iter = NULL;\n\tut64 *paddr = NULL;\n\tif (!bin) {\n\t\treturn the_list;\n\t}\n\tthe_list->free = free;\n\tr_list_foreach (bin->methods_list, iter, fm_type) {\n\t\tpaddr = R_NEW0 (ut64);\n\t\t*paddr = fm_type->file_offset + bin->loadaddr;\n\t\tr_list_append (the_list, paddr);\n\t}\n\treturn the_list;\n}\n\nR_API ut16 r_bin_java_calculate_field_access_value(const char *access_flags_str) {\n\treturn calculate_access_value (access_flags_str, FIELD_ACCESS_FLAGS);\n}\n\nR_API ut16 r_bin_java_calculate_class_access_value(const char *access_flags_str) {\n\treturn calculate_access_value (access_flags_str, CLASS_ACCESS_FLAGS);\n}\n\nR_API ut16 r_bin_java_calculate_method_access_value(const char *access_flags_str) {\n\treturn calculate_access_value (access_flags_str, METHOD_ACCESS_FLAGS);\n}\n\nR_API RList *retrieve_all_method_access_string_and_value() {\n\treturn retrieve_all_access_string_and_value (METHOD_ACCESS_FLAGS);\n}\n\nR_API RList *retrieve_all_field_access_string_and_value() {\n\treturn retrieve_all_access_string_and_value (FIELD_ACCESS_FLAGS);\n}\n\nR_API RList *retrieve_all_class_access_string_and_value() {\n\treturn retrieve_all_access_string_and_value (CLASS_ACCESS_FLAGS);\n}\n\nR_API char *r_bin_java_resolve_with_space(RBinJavaObj *obj, int idx) {\n\treturn r_bin_java_resolve (obj, idx, 1);\n}\n\nR_API char *r_bin_java_resolve_without_space(RBinJavaObj *obj, int idx) {\n\treturn r_bin_java_resolve (obj, idx, 0);\n}\n\nR_API char *r_bin_java_resolve_b64_encode(RBinJavaObj *BIN_OBJ, ut16 idx) {\n\tRBinJavaCPTypeObj *item = NULL, *item2 = NULL;\n\tchar *class_str = NULL,\n\t*name_str = NULL,\n\t*desc_str = NULL,\n\t*string_str = NULL,\n\t*empty = \"\",\n\t*cp_name = NULL,\n\t*str = NULL, *out = NULL;\n\tint memory_alloc = 0;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\t// r_bin_java_new_bin(BIN_OBJ);\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\tcp_name = ((RBinJavaCPTypeMetas *) item->metas->type_info)->name;\n\t\tIFDBG eprintf(\"java_resolve Resolved: (%d) %s\\n\", idx, cp_name);\n\t} else {\n\t\treturn NULL;\n\t}\n\tcp_name = ((RBinJavaCPTypeMetas *) item->metas->type_info)->name;\n\tif (!strcmp (cp_name, \"Class\")) {\n\t\titem2 = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\t\t// str = r_bin_java_get_name_from_bin_cp_list (BIN_OBJ, idx-1);\n\t\tclass_str = empty;\n\t\tclass_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!class_str) {\n\t\t\tclass_str = empty;\n\t\t}\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item2);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item2);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tmemory_alloc = strlen (class_str) + strlen (name_str) + strlen (desc_str) + 3;\n\t\tif (memory_alloc) {\n\t\t\tstr = malloc (memory_alloc);\n\t\t\tsnprintf (str, memory_alloc, \"%s%s\", name_str, desc_str);\n\t\t\tout = (char *) malloc (memory_alloc);\n\t\t\tmemset (out, 0, memory_alloc);\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t\tif (class_str != empty) {\n\t\t\tfree (class_str);\n\t\t}\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else if (strcmp (cp_name, \"MethodRef\") == 0 ||\n\tstrcmp (cp_name, \"FieldRef\") == 0 ||\n\tstrcmp (cp_name, \"InterfaceMethodRef\") == 0) {\n\t\t/*\n\t\t*  The MethodRef, FieldRef, and InterfaceMethodRef structures\n\t\t*/\n\t\tclass_str = r_bin_java_get_name_from_bin_cp_list (BIN_OBJ, item->info.cp_method.class_idx);\n\t\tif (!class_str) {\n\t\t\tclass_str = empty;\n\t\t}\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tmemory_alloc = strlen (class_str) + strlen (name_str) + strlen (desc_str) + 3;\n\t\tif (memory_alloc) {\n\t\t\tstr = malloc (memory_alloc);\n\t\t\tsnprintf (str, memory_alloc, \"%s/%s%s\", class_str, name_str, desc_str);\n\t\t\tout = malloc (memory_alloc);\n\t\t\tmemset (out, 0, memory_alloc);\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t\tif (class_str != empty) {\n\t\t\tfree (class_str);\n\t\t}\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else if (strcmp (cp_name, \"String\") == 0) {\n\t\tut32 length = r_bin_java_get_utf8_len_from_bin_cp_list (BIN_OBJ, item->info.cp_string.string_idx);\n\t\tstring_str = r_bin_java_get_utf8_from_bin_cp_list (BIN_OBJ, item->info.cp_string.string_idx);\n\t\tstr = NULL;\n\t\tIFDBG eprintf(\"java_resolve String got: (%d) %s\\n\", item->info.cp_string.string_idx, string_str);\n\t\tif (!string_str) {\n\t\t\tstring_str = empty;\n\t\t\tlength = strlen (empty);\n\t\t}\n\t\tmemory_alloc = length + 3;\n\t\tif (memory_alloc) {\n\t\t\tstr = malloc (memory_alloc);\n\t\t\tsnprintf (str, memory_alloc, \"\\\"%s\\\"\", string_str);\n\t\t\tout = malloc (memory_alloc);\n\t\t\tmemset (out, 0, memory_alloc);\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t\tIFDBG eprintf(\"java_resolve String return: %s\\n\", str);\n\t\tif (string_str != empty) {\n\t\t\tfree (string_str);\n\t\t}\n\t} else if (strcmp (cp_name, \"Utf8\") == 0) {\n\t\tut64 sz = item->info.cp_utf8.length ? item->info.cp_utf8.length + 10 : 10;\n\t\tstr = malloc (sz);\n\t\tmemset (str, 0, sz);\n\t\tif (sz > 10) {\n\t\t\tr_base64_encode (str, item->info.cp_utf8.bytes, item->info.cp_utf8.length);\n\t\t}\n\t} else if (strcmp (cp_name, \"Long\") == 0) {\n\t\tstr = malloc (34);\n\t\tout = malloc (34);\n\t\tmemset (out, 0, 34);\n\t\tif (str) {\n\t\t\tsnprintf (str, 34, \"0x%\"PFMT64x, r_bin_java_raw_to_long (item->info.cp_long.bytes.raw, 0));\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t} else if (strcmp (cp_name, \"Double\") == 0) {\n\t\tstr = malloc (1000);\n\t\tout = malloc (1000);\n\t\tmemset (out, 0, 1000);\n\t\tif (str) {\n\t\t\tsnprintf (str, 1000, \"%f\", r_bin_java_raw_to_double (item->info.cp_double.bytes.raw, 0));\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t} else if (strcmp (cp_name, \"Integer\") == 0) {\n\t\tstr = calloc (34, 1);\n\t\tout = calloc (34, 1);\n\t\tif (str) {\n\t\t\tsnprintf (str, 34, \"0x%08x\", R_BIN_JAVA_UINT (item->info.cp_integer.bytes.raw, 0));\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t} else if (strcmp (cp_name, \"Float\") == 0) {\n\t\tstr = malloc (34);\n\t\tout = malloc (34);\n\t\tmemset (out, 0, 34);\n\t\tif (str) {\n\t\t\tsnprintf (str, 34, \"%f\", R_BIN_JAVA_FLOAT (item->info.cp_float.bytes.raw, 0));\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t} else if (!strcmp (cp_name, \"NameAndType\")) {\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tmemory_alloc = strlen (name_str) + strlen (desc_str) + 3;\n\t\tif (memory_alloc) {\n\t\t\tstr = malloc (memory_alloc);\n\t\t\tsnprintf (str, memory_alloc, \"%s %s\", name_str, desc_str);\n\t\t\tout = malloc (memory_alloc);\n\t\t\tmemset (out, 0, memory_alloc);\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else {\n\t\tstr = malloc (16);\n\t\tmemset (str, 0, 16);\n\t\tif (str) {\n\t\t\tr_base64_encode (str, (const ut8 *) \"(null)\", 6);\n\t\t}\n\t}\n\treturn str;\n}\n\nR_API ut64 r_bin_java_resolve_cp_idx_address(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaCPTypeObj *item = NULL;\n\tut64 addr = -1;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\treturn -1;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\taddr = item->file_offset + item->loadaddr;\n\t}\n\treturn addr;\n}\n\nR_API char *r_bin_java_resolve_cp_idx_to_string(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaCPTypeObj *item = NULL;\n\tchar *value = NULL;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\tvalue = ((RBinJavaCPTypeMetas *)\n\t\titem->metas->type_info)->\n\t\tallocs->stringify_obj (item);\n\t}\n\treturn value;\n}\n\nR_API int r_bin_java_resolve_cp_idx_print_summary(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaCPTypeObj *item = NULL;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\treturn false;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\t((RBinJavaCPTypeMetas *)\n\t\titem->metas->type_info)->\n\t\tallocs->print_summary (item);\n\t} else {\n\t\teprintf (\"Error: Invalid CP Object.\\n\");\n\t}\n\treturn item ? true : false;\n}\n\nR_API ConstJavaValue *U(r_bin_java_resolve_to_const_value)(RBinJavaObj * BIN_OBJ, int idx) {\n\t// TODO XXX FIXME add a size parameter to the str when it is passed in\n\tRBinJavaCPTypeObj *item = NULL, *item2 = NULL;\n\tConstJavaValue *result = R_NEW0 (ConstJavaValue);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\tchar *class_str = NULL,\n\t*name_str = NULL,\n\t*desc_str = NULL,\n\t*string_str = NULL,\n\t*empty = \"\",\n\t*cp_name = NULL;\n\tresult->type = \"unknown\";\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\t// r_bin_java_new_bin(BIN_OBJ);\n\t\treturn result;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\tcp_name = ((RBinJavaCPTypeMetas *) item->metas->type_info)->name;\n\t\tIFDBG eprintf(\"java_resolve Resolved: (%d) %s\\n\", idx, cp_name);\n\t} else {\n\t\treturn result;\n\t}\n\tcp_name = ((RBinJavaCPTypeMetas *) item->metas->type_info)->name;\n\tif (strcmp (cp_name, \"Class\") == 0) {\n\t\titem2 = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\t\t// str = r_bin_java_get_name_from_bin_cp_list (BIN_OBJ, idx-1);\n\t\tclass_str = empty;\n\t\tclass_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!class_str) {\n\t\t\tclass_str = empty;\n\t\t}\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item2);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item2);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tresult->value._ref = R_NEW0 (_JavaRef);\n\t\tresult->type = \"ref\";\n\t\tresult->value._ref->class_name = strdup (class_str);\n\t\tresult->value._ref->name = strdup (name_str);\n\t\tresult->value._ref->desc = strdup (desc_str);\n\t\tif (class_str != empty) {\n\t\t\tfree (class_str);\n\t\t}\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else if (strcmp (cp_name, \"MethodRef\") == 0 ||\n\tstrcmp (cp_name, \"FieldRef\") == 0 ||\n\tstrcmp (cp_name, \"InterfaceMethodRef\") == 0) {\n\t\t/*\n\t\t*  The MethodRef, FieldRef, and InterfaceMethodRef structures\n\t\t*/\n\t\tclass_str = r_bin_java_get_name_from_bin_cp_list (BIN_OBJ, item->info.cp_method.class_idx);\n\t\tif (!class_str) {\n\t\t\tclass_str = empty;\n\t\t}\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tresult->value._ref = R_NEW0 (_JavaRef);\n\t\tresult->type = \"ref\";\n\t\tresult->value._ref->class_name = strdup (class_str);\n\t\tresult->value._ref->name = strdup (name_str);\n\t\tresult->value._ref->desc = strdup (desc_str);\n\t\tif (class_str != empty) {\n\t\t\tfree (class_str);\n\t\t}\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else if (strcmp (cp_name, \"String\") == 0) {\n\t\tut32 length = r_bin_java_get_utf8_len_from_bin_cp_list (BIN_OBJ, item->info.cp_string.string_idx);\n\t\tstring_str = r_bin_java_get_utf8_from_bin_cp_list (BIN_OBJ, item->info.cp_string.string_idx);\n\t\tIFDBG eprintf(\"java_resolve String got: (%d) %s\\n\", item->info.cp_string.string_idx, string_str);\n\t\tif (!string_str) {\n\t\t\tstring_str = empty;\n\t\t\tlength = strlen (empty);\n\t\t}\n\t\tresult->type = \"str\";\n\t\tresult->value._str = R_NEW0 (struct  java_const_value_str_t);\n\t\tresult->value._str->len = length;\n\t\tif (length > 0) {\n\t\t\tresult->value._str->str = malloc (length);\n\t\t\tmemcpy (result->value._str->str, string_str, length);\n\t\t} else {\n\t\t\tresult->value._str->str = strdup (\"\");\n\t\t}\n\t\tif (string_str != empty) {\n\t\t\tfree (string_str);\n\t\t}\n\t} else if (strcmp (cp_name, \"Utf8\") == 0) {\n\t\tresult->type = \"str\";\n\t\tresult->value._str = R_NEW0 (struct java_const_value_str_t);\n\t\tresult->value._str->str = malloc (item->info.cp_utf8.length);\n\t\tresult->value._str->len = item->info.cp_utf8.length;\n\t\tmemcpy (result->value._str->str, item->info.cp_utf8.bytes, item->info.cp_utf8.length);\n\t} else if (strcmp (cp_name, \"Long\") == 0) {\n\t\tresult->type = \"long\";\n\t\tresult->value._long = r_bin_java_raw_to_long (item->info.cp_long.bytes.raw, 0);\n\t} else if (strcmp (cp_name, \"Double\") == 0) {\n\t\tresult->type = \"double\";\n\t\tresult->value._double = r_bin_java_raw_to_double (item->info.cp_double.bytes.raw, 0);\n\t} else if (strcmp (cp_name, \"Integer\") == 0) {\n\t\tresult->type = \"int\";\n\t\tresult->value._int = R_BIN_JAVA_UINT (item->info.cp_integer.bytes.raw, 0);\n\t} else if (strcmp (cp_name, \"Float\") == 0) {\n\t\tresult->type = \"float\";\n\t\tresult->value._float = R_BIN_JAVA_FLOAT (item->info.cp_float.bytes.raw, 0);\n\t} else if (strcmp (cp_name, \"NameAndType\") == 0) {\n\t\tresult->value._ref = R_NEW0 (struct java_const_value_ref_t);\n\t\tresult->type = \"ref\";\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tresult->value._ref->class_name = strdup (empty);\n\t\tresult->value._ref->name = strdup (name_str);\n\t\tresult->value._ref->desc = strdup (desc_str);\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t\tresult->value._ref->is_method = r_bin_java_does_cp_idx_ref_method (BIN_OBJ, idx);\n\t\tresult->value._ref->is_field = r_bin_java_does_cp_idx_ref_field (BIN_OBJ, idx);\n\t}\n\treturn result;\n}\n\nR_API void U(r_bin_java_free_const_value)(ConstJavaValue * cp_value) {\n\tchar first_char = cp_value && cp_value->type ? *cp_value->type : 0,\n\tsecond_char = cp_value && cp_value->type ? *(cp_value->type + 1) : 0;\n\tswitch (first_char) {\n\tcase 'r':\n\t\tif (cp_value && cp_value->value._ref) {\n\t\t\tfree (cp_value->value._ref->class_name);\n\t\t\tfree (cp_value->value._ref->name);\n\t\t\tfree (cp_value->value._ref->desc);\n\t\t}\n\t\tbreak;\n\tcase 's':\n\t\tif (second_char == 't' && cp_value->value._str) {\n\t\t\tfree (cp_value->value._str->str);\n\t\t}\n\t\tbreak;\n\t}\n\tfree (cp_value);\n}\n\nR_API char *r_bin_java_get_field_name(RBinJavaObj *bin_obj, ut32 idx) {\n\tchar *name = NULL;\n\tif (idx < r_list_length (bin_obj->fields_list)) {\n\t\tRBinJavaField *fm_type = r_list_get_n (bin_obj->fields_list, idx);\n\t\tname = strdup (fm_type->name);\n\t}\n\treturn name;\n}\n\nR_API int r_bin_java_print_field_idx_summary(RBinJavaObj *bin_obj, ut32 idx) {\n\tint res = false;\n\tif (idx < r_list_length (bin_obj->fields_list)) {\n\t\tRBinJavaField *fm_type = r_list_get_n (bin_obj->fields_list, idx);\n\t\tr_bin_java_print_field_summary (fm_type);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nR_API ut32 r_bin_java_get_field_count(RBinJavaObj *bin_obj) {\n\treturn r_list_length (bin_obj->fields_list);\n}\n\nR_API RList *r_bin_java_get_field_num_name(RBinJavaObj *bin_obj) {\n\tut32 i = 0;\n\tRBinJavaField *fm_type;\n\tRListIter *iter = NULL;\n\tRList *res = r_list_newf (free);\n\tr_list_foreach (bin_obj->fields_list, iter, fm_type) {\n\t\tut32 len = strlen (fm_type->name) + 30;\n\t\tchar *str = malloc (len);\n\t\tif (!str) {\n\t\t\tr_list_free (res);\n\t\t\treturn NULL;\n\t\t}\n\t\tsnprintf (str, len, \"%d %s\", i, fm_type->name);\n\t\t++i;\n\t\tr_list_append (res, str);\n\t}\n\treturn res;\n}\nR_API RList *r_bin_java_find_cp_const_by_val_utf8(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len) {\n\tRList *res = r_list_newf (free);\n\tut32 *v = NULL;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *cp_obj;\n\tIFDBG eprintf(\"In UTF-8 Looking for %s\\n\", bytes);\n\tr_list_foreach (bin_obj->cp_list, iter, cp_obj) {\n\t\tif (cp_obj->tag == R_BIN_JAVA_CP_UTF8) {\n\t\t\tIFDBG eprintf(\"In UTF-8 Looking @ %s\\n\", cp_obj->info.cp_utf8.bytes);\n\t\t\tIFDBG eprintf(\"UTF-8 len = %d and memcmp = %d\\n\", cp_obj->info.cp_utf8.length, memcmp (bytes, cp_obj->info.cp_utf8.bytes, len));\n\t\t\tif (len == cp_obj->info.cp_utf8.length && !memcmp (bytes, cp_obj->info.cp_utf8.bytes, len)) {\n\t\t\t\tv = malloc (sizeof (ut32));\n\t\t\t\tif (!v) {\n\t\t\t\t\tr_list_free (res);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t*v = cp_obj->metas->ord;\n\t\t\t\tIFDBG eprintf(\"Found a match adding idx: %d\\n\", *v);\n\t\t\t\tr_list_append (res, v);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nR_API RList *r_bin_java_find_cp_const_by_val_int(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len) {\n\tRList *res = r_list_newf (free);\n\tut32 *v = NULL;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *cp_obj;\n\teprintf (\"Looking for 0x%08x\\n\", (ut32) R_BIN_JAVA_UINT (bytes, 0));\n\tr_list_foreach (bin_obj->cp_list, iter, cp_obj) {\n\t\tif (cp_obj->tag == R_BIN_JAVA_CP_INTEGER) {\n\t\t\tif (len == 4 && R_BIN_JAVA_UINT (bytes, 0) == R_BIN_JAVA_UINT (cp_obj->info.cp_integer.bytes.raw, 0)) {\n\t\t\t\tv = malloc (sizeof (ut32));\n\t\t\t\tif (!v) {\n\t\t\t\t\tr_list_free (res);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t*v = cp_obj->idx;\n\t\t\t\tr_list_append (res, v);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API char r_bin_java_resolve_cp_idx_tag(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaCPTypeObj *item = NULL;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\t// r_bin_java_new_bin(BIN_OBJ);\n\t\treturn R_BIN_JAVA_CP_UNKNOWN;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\treturn item->tag;\n\t}\n\treturn R_BIN_JAVA_CP_UNKNOWN;\n}\n\nR_API int U(r_bin_java_integer_cp_set)(RBinJavaObj * bin, ut16 idx, ut32 val) {\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tif (!cp_obj) {\n\t\treturn false;\n\t}\n\tut8 bytes[4] = {\n\t\t0\n\t};\n\tif (cp_obj->tag != R_BIN_JAVA_CP_INTEGER && cp_obj->tag != R_BIN_JAVA_CP_FLOAT) {\n\t\teprintf (\"Not supporting the overwrite of CP Objects with one of a different size.\\n\");\n\t\treturn false;\n\t}\n\tr_bin_java_check_reset_cp_obj (cp_obj, R_BIN_JAVA_CP_INTEGER);\n\tcp_obj->tag = R_BIN_JAVA_CP_INTEGER;\n\tmemcpy (bytes, (const char *) &val, 4);\n\tval = R_BIN_JAVA_UINT (bytes, 0);\n\tmemcpy (&cp_obj->info.cp_integer.bytes.raw, (const char *) &val, 4);\n\treturn true;\n}\n\nR_API int U(r_bin_java_float_cp_set)(RBinJavaObj * bin, ut16 idx, float val) {\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tif (!cp_obj) {\n\t\treturn false;\n\t}\n\tut8 bytes[4] = {\n\t\t0\n\t};\n\tif (cp_obj->tag != R_BIN_JAVA_CP_INTEGER && cp_obj->tag != R_BIN_JAVA_CP_FLOAT) {\n\t\teprintf (\"Not supporting the overwrite of CP Objects with one of a different size.\\n\");\n\t\treturn false;\n\t}\n\tr_bin_java_check_reset_cp_obj (cp_obj, R_BIN_JAVA_CP_FLOAT);\n\tcp_obj->tag = R_BIN_JAVA_CP_FLOAT;\n\tmemcpy (bytes, (const char *) &val, 4);\n\tfloat *foo = (float*) bytes;\n\tval = *foo; //(float)R_BIN_JAVA_UINT (bytes, 0);\n\tmemcpy (&cp_obj->info.cp_float.bytes.raw, (const char *) &val, 4);\n\treturn true;\n}\n\nR_API int U(r_bin_java_long_cp_set)(RBinJavaObj * bin, ut16 idx, ut64 val) {\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tif (!cp_obj) {\n\t\treturn false;\n\t}\n\tut8 bytes[8] = {\n\t\t0\n\t};\n\tif (cp_obj->tag != R_BIN_JAVA_CP_LONG && cp_obj->tag != R_BIN_JAVA_CP_DOUBLE) {\n\t\teprintf (\"Not supporting the overwrite of CP Objects with one of a different size.\\n\");\n\t\treturn false;\n\t}\n\tr_bin_java_check_reset_cp_obj (cp_obj, R_BIN_JAVA_CP_LONG);\n\tcp_obj->tag = R_BIN_JAVA_CP_LONG;\n\tmemcpy (bytes, (const char *) &val, 8);\n\tval = r_bin_java_raw_to_long (bytes, 0);\n\tmemcpy (&cp_obj->info.cp_long.bytes.raw, (const char *) &val, 8);\n\treturn true;\n}\n\nR_API int U(r_bin_java_double_cp_set)(RBinJavaObj * bin, ut16 idx, ut32 val) {\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tif (!cp_obj) {\n\t\treturn false;\n\t}\n\tut8 bytes[8] = {\n\t\t0\n\t};\n\tif (cp_obj->tag != R_BIN_JAVA_CP_LONG && cp_obj->tag != R_BIN_JAVA_CP_DOUBLE) {\n\t\teprintf (\"Not supporting the overwrite of CP Objects with one of a different size.\\n\");\n\t\treturn false;\n\t}\n\tr_bin_java_check_reset_cp_obj (cp_obj, R_BIN_JAVA_CP_DOUBLE);\n\tcp_obj->tag = R_BIN_JAVA_CP_DOUBLE;\n\tut64 val64 = val;\n\tmemcpy (bytes, (const char *) &val64, 8);\n\tval64 = r_bin_java_raw_to_long (bytes, 0);\n\tmemcpy (&cp_obj->info.cp_double.bytes.raw, (const char *) &val64, 8);\n\treturn true;\n}\n\nR_API int U(r_bin_java_utf8_cp_set)(RBinJavaObj * bin, ut16 idx, const ut8 * buffer, ut32 len) {\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tif (!cp_obj) {\n\t\treturn false;\n\t}\n\teprintf (\"Writing %d byte(s) (%s)\\n\", len, buffer);\n\t// r_bin_java_check_reset_cp_obj(cp_obj, R_BIN_JAVA_CP_INTEGER);\n\tif (cp_obj->tag != R_BIN_JAVA_CP_UTF8) {\n\t\teprintf (\"Not supporting the overwrite of CP Objects with one of a different size.\\n\");\n\t\treturn false;\n\t}\n\tif (cp_obj->info.cp_utf8.length != len) {\n\t\teprintf (\"Not supporting the resize, rewriting utf8 string up to %d byte(s).\\n\", cp_obj->info.cp_utf8.length);\n\t\tif (cp_obj->info.cp_utf8.length > len) {\n\t\t\teprintf (\"Remaining %d byte(s) will be filled with \\\\x00.\\n\", cp_obj->info.cp_utf8.length - len);\n\t\t}\n\t}\n\tmemcpy (cp_obj->info.cp_utf8.bytes, buffer, cp_obj->info.cp_utf8.length);\n\tif (cp_obj->info.cp_utf8.length > len) {\n\t\tmemset (cp_obj->info.cp_utf8.bytes + len, 0, cp_obj->info.cp_utf8.length - len);\n\t}\n\treturn true;\n}\n\nR_API ut8 *r_bin_java_cp_get_bytes(ut8 tag, ut32 *out_sz, const ut8 *buf, const ut64 len) {\n\tif (!out_sz) {\n\t\treturn NULL;\n\t}\n\tif (out_sz) {\n\t\t*out_sz = 0;\n\t}\n\tswitch (tag) {\n\tcase R_BIN_JAVA_CP_INTEGER:\n\tcase R_BIN_JAVA_CP_FLOAT:\n\t\treturn r_bin_java_cp_get_4bytes (tag, out_sz, buf, len);\n\tcase R_BIN_JAVA_CP_LONG:\n\tcase R_BIN_JAVA_CP_DOUBLE:\n\t\treturn r_bin_java_cp_get_8bytes (tag, out_sz, buf, len);\n\tcase R_BIN_JAVA_CP_UTF8:\n\t\treturn r_bin_java_cp_get_utf8 (tag, out_sz, buf, len);\n\t}\n\treturn NULL;\n}\n\nR_API ut32 r_bin_java_cp_get_size(RBinJavaObj *bin, ut16 idx) {\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tswitch (cp_obj->tag) {\n\tcase R_BIN_JAVA_CP_INTEGER:\n\tcase R_BIN_JAVA_CP_FLOAT:\n\t\treturn 1 + 4;\n\tcase R_BIN_JAVA_CP_LONG:\n\tcase R_BIN_JAVA_CP_DOUBLE:\n\t\treturn 1 + 8;\n\tcase R_BIN_JAVA_CP_UTF8:\n\t\treturn 1 + 2 + cp_obj->info.cp_utf8.length;\n\t}\n\treturn 0;\n}\n\nR_API ut64 r_bin_java_get_method_start(RBinJavaObj *bin, RBinJavaField *fm_type) {\n\treturn r_bin_java_get_method_code_offset (fm_type) + bin->loadaddr;\n}\n\nR_API ut64 r_bin_java_get_method_end(RBinJavaObj *bin, RBinJavaField *fm_type) {\n\treturn r_bin_java_get_method_code_offset (fm_type) + bin->loadaddr +\n\t+r_bin_java_get_method_code_size (fm_type);\n}\n\nR_API ut8 *U(r_bin_java_cp_append_method_ref)(RBinJavaObj * bin, ut32 * out_sz, ut16 cn_idx, ut16 fn_idx, ut16 ft_idx) {\n\treturn r_bin_java_cp_get_fref_bytes (bin, out_sz, R_BIN_JAVA_CP_METHODREF, cn_idx, fn_idx, ft_idx);\n}\n\nR_API ut8 *U(r_bin_java_cp_append_field_ref)(RBinJavaObj * bin, ut32 * out_sz, ut16 cn_idx, ut16 fn_idx, ut16 ft_idx) {\n\treturn r_bin_java_cp_get_fref_bytes (bin, out_sz, R_BIN_JAVA_CP_FIELDREF, cn_idx, fn_idx, ft_idx);\n}\n\nR_API char *r_bin_java_unmangle_without_flags(const char *name, const char *descriptor) {\n\treturn r_bin_java_unmangle (NULL, name, descriptor);\n}\n\nR_API void U(r_bin_java_print_stack_map_append_frame_summary)(RBinJavaStackMapFrame * obj) {\n\tRListIter *iter, *iter_tmp;\n\tRList *ptrList;\n\tRBinJavaVerificationObj *ver_obj;\n\tEprintf (\"Stack Map Frame Information\\n\");\n\tEprintf (\"  Tag Value = 0x%02x Name: %s\\n\", obj->tag, ((RBinJavaStackMapFrameMetas *) obj->metas->type_info)->name);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\\n\", obj->file_offset);\n\tEprintf (\"  Local Variable Count = 0x%04x\\n\", obj->number_of_locals);\n\tEprintf (\"  Local Variables:\\n\");\n\tptrList = obj->local_items;\n\tr_list_foreach_safe (ptrList, iter, iter_tmp, ver_obj) {\n\t\tr_bin_java_print_verification_info_summary (ver_obj);\n\t}\n\tEprintf (\"  Stack Items Count = 0x%04x\\n\", obj->number_of_stack_items);\n\tEprintf (\"  Stack Items:\\n\");\n\tptrList = obj->stack_items;\n\tr_list_foreach_safe (ptrList, iter, iter_tmp, ver_obj) {\n\t\tr_bin_java_print_verification_info_summary (ver_obj);\n\t}\n}\n\nR_API void U(r_bin_java_stack_frame_default_free)(void *s) {\n\tRBinJavaStackMapFrame *stack_frame = s;\n\tif (stack_frame) {\n\t\tfree (stack_frame->metas);\n\t\tfree (stack_frame);\n\t}\n}\nR_API void U(r_bin_java_stack_frame_do_nothing_free)(void /*RBinJavaStackMapFrame*/ *stack_frame) {}\nR_API void U(r_bin_java_stack_frame_do_nothing_new)(RBinJavaObj * bin, RBinJavaStackMapFrame * stack_frame, ut64 offset) {}\nR_API RBinJavaCPTypeMetas *U(r_bin_java_get_cp_meta_from_tag)(ut8 tag) {\n\tut16 i = 0;\n\t// set default to unknown.\n\tRBinJavaCPTypeMetas *res = &R_BIN_JAVA_CP_METAS[2];\n\tfor (i = 0; i < R_BIN_JAVA_CP_METAS_SZ; i++) {\n\t\tif (tag == R_BIN_JAVA_CP_METAS[i].tag) {\n\t\t\tres = &R_BIN_JAVA_CP_METAS[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API ut8 *U(r_bin_java_cp_append_ref_cname_fname_ftype)(RBinJavaObj * bin, ut32 * out_sz, ut8 tag, const char *cname, const ut32 c_len, const char *fname, const ut32 f_len, const char *tname, const ut32 t_len) {\n\tut32 cn_len = 0, fn_len = 0, ft_len = 0, total_len;\n\tut16 cn_idx = 0, fn_idx = 0, ft_idx = 0;\n\tut8 *bytes = NULL, *cn_bytes = NULL, *fn_bytes = NULL, *ft_bytes = NULL, *cref_bytes = NULL, *fref_bytes = NULL, *fnt_bytes = NULL;\n\t*out_sz = 0;\n\tcn_bytes = r_bin_java_cp_get_utf8 (R_BIN_JAVA_CP_UTF8, &cn_len, (const ut8 *) cname, c_len);\n\tcn_idx = bin->cp_idx + 1;\n\tif (cn_bytes) {\n\t\tfn_bytes = r_bin_java_cp_get_utf8 (R_BIN_JAVA_CP_UTF8, &fn_len, (const ut8 *) fname, f_len);\n\t\tfn_idx = bin->cp_idx + 2;\n\t}\n\tif (fn_bytes) {\n\t\tft_bytes = r_bin_java_cp_get_utf8 (R_BIN_JAVA_CP_UTF8, &ft_len, (const ut8 *) tname, t_len);\n\t\tft_idx = bin->cp_idx + 3;\n\t}\n\tif (cn_bytes && fn_bytes && ft_bytes) {\n\t\tut32 cref_len = 0, fnt_len = 0, fref_len = 0;\n\t\tut32 cref_idx = 0, fnt_idx = 0;\n\t\tcref_bytes = r_bin_java_cp_get_classref (bin, &cref_len, NULL, 0, cn_idx);\n\t\tcref_idx = bin->cp_idx + 3;\n\t\tfnt_bytes = r_bin_java_cp_get_name_type (bin, &fnt_len, fn_idx, ft_idx);\n\t\tfnt_idx = bin->cp_idx + 4;\n\t\tfref_bytes = r_bin_java_cp_get_2_ut16 (bin, &fref_len, tag, cref_idx, fnt_idx);\n\t\tif (cref_bytes && fref_bytes && fnt_bytes) {\n\t\t\ttotal_len = cn_len + fn_len + ft_len + cref_len + fnt_len + fref_len + 2;\n\t\t\tif (total_len < cn_len) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbytes = calloc (1, total_len);\n\t\t\t// class name bytes\n\t\t\tif (*out_sz + cn_len >= total_len) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmemcpy (bytes, cn_bytes + *out_sz, cn_len);\n\t\t\t*out_sz += cn_len;\n\t\t\t// field name bytes\n\t\t\tif (*out_sz + fn_len >= total_len) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmemcpy (bytes, fn_bytes + *out_sz, fn_len);\n\t\t\t*out_sz += fn_len;\n\t\t\t// field type bytes\n\t\t\tif (*out_sz + ft_len >= total_len) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmemcpy (bytes, ft_bytes + *out_sz, ft_len);\n\t\t\t*out_sz += ft_len;\n\t\t\t// class ref bytes\n\t\t\tif (*out_sz + cref_len >= total_len) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmemcpy (bytes, cref_bytes + *out_sz, cref_len);\n\t\t\t*out_sz += fn_len;\n\t\t\t// field name and type bytes\n\t\t\tif (*out_sz + fnt_len >= total_len) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmemcpy (bytes, fnt_bytes + *out_sz, fnt_len);\n\t\t\t*out_sz += fnt_len;\n\t\t\t// field ref bytes\n\t\t\tif (*out_sz + fref_len >= total_len) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmemcpy (bytes, fref_bytes + *out_sz, fref_len);\n\t\t\t*out_sz += fref_len;\n\t\t}\n\t}\nbeach:\n\tfree (cn_bytes);\n\tfree (ft_bytes);\n\tfree (fn_bytes);\n\tfree (fnt_bytes);\n\tfree (fref_bytes);\n\tfree (cref_bytes);\n\treturn bytes;\n}\nR_API ut8 *U(r_bin_java_cp_get_method_ref)(RBinJavaObj * bin, ut32 * out_sz, ut16 class_idx, ut16 name_and_type_idx) {\n\treturn r_bin_java_cp_get_fm_ref (bin, out_sz, R_BIN_JAVA_CP_METHODREF, class_idx, name_and_type_idx);\n}\nR_API ut8 *U(r_bin_java_cp_get_field_ref)(RBinJavaObj * bin, ut32 * out_sz, ut16 class_idx, ut16 name_and_type_idx) {\n\treturn r_bin_java_cp_get_fm_ref (bin, out_sz, R_BIN_JAVA_CP_FIELDREF, class_idx, name_and_type_idx);\n}\n\nR_API void U(deinit_java_type_null)() {\n\tfree (R_BIN_JAVA_NULL_TYPE.metas);\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {\n\tif (i < 1 || i > bin->cf.cp_count) {\n\t\treturn &R_BIN_JAVA_NULL_TYPE;\n\t}\n\tRBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);\n\treturn obj ? obj : &R_BIN_JAVA_NULL_TYPE;\n}\n\nR_API void U(copy_type_info_to_stack_frame_list)(RList * type_list, RList * sf_list) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaVerificationObj *ver_obj, *new_ver_obj;\n\tif (type_list == NULL) {\n\t\treturn;\n\t}\n\tif (sf_list == NULL) {\n\t\treturn;\n\t}\n\tr_list_foreach_safe (type_list, iter, iter_tmp, ver_obj) {\n\t\tnew_ver_obj = (RBinJavaVerificationObj *) malloc (sizeof (RBinJavaVerificationObj));\n\t\t// FIXME: how to handle failed memory allocation?\n\t\tif (new_ver_obj && ver_obj) {\n\t\t\tmemcpy (new_ver_obj, ver_obj, sizeof (RBinJavaVerificationObj));\n\t\t\tif (!r_list_append (sf_list, (void *) new_ver_obj)) {\n\t\t\t\tR_FREE (new_ver_obj);\n\t\t\t}\n\t\t} else {\n\t\t\tR_FREE (new_ver_obj);\n\t\t}\n\t}\n}\n\nR_API void U(copy_type_info_to_stack_frame_list_up_to_idx)(RList * type_list, RList * sf_list, ut64 idx) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaVerificationObj *ver_obj, *new_ver_obj;\n\tut32 pos = 0;\n\tif (type_list == NULL) {\n\t\treturn;\n\t}\n\tif (sf_list == NULL) {\n\t\treturn;\n\t}\n\tr_list_foreach_safe (type_list, iter, iter_tmp, ver_obj) {\n\t\tnew_ver_obj = (RBinJavaVerificationObj *) malloc (sizeof (RBinJavaVerificationObj));\n\t\t// FIXME: how to handle failed memory allocation?\n\t\tif (new_ver_obj && ver_obj) {\n\t\t\tmemcpy (new_ver_obj, ver_obj, sizeof (RBinJavaVerificationObj));\n\t\t\tif (!r_list_append (sf_list, (void *) new_ver_obj)) {\n\t\t\t\tR_FREE (new_ver_obj);\n\t\t\t}\n\t\t} else {\n\t\t\tR_FREE (new_ver_obj);\n\t\t}\n\t\tpos++;\n\t\tif (pos == idx) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nR_API ut8 *r_bin_java_cp_get_idx_bytes(RBinJavaObj *bin, ut16 idx, ut32 *out_sz) {\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tif (!cp_obj || !out_sz) {\n\t\treturn NULL;\n\t}\n\tif (out_sz) {\n\t\t*out_sz = 0;\n\t}\n\tswitch (cp_obj->tag) {\n\tcase R_BIN_JAVA_CP_INTEGER:\n\tcase R_BIN_JAVA_CP_FLOAT:\n\t\treturn r_bin_java_cp_get_4bytes (cp_obj->tag, out_sz, cp_obj->info.cp_integer.bytes.raw, 5);\n\tcase R_BIN_JAVA_CP_LONG:\n\tcase R_BIN_JAVA_CP_DOUBLE:\n\t\treturn r_bin_java_cp_get_4bytes (cp_obj->tag, out_sz, cp_obj->info.cp_long.bytes.raw, 9);\n\tcase R_BIN_JAVA_CP_UTF8:\n\t\t// eprintf (\"Getting idx: %d = %p (3+0x%\"PFMT64x\")\\n\", idx, cp_obj, cp_obj->info.cp_utf8.length);\n\t\tif (cp_obj->info.cp_utf8.length > 0) {\n\t\t\treturn r_bin_java_cp_get_utf8 (cp_obj->tag, out_sz,\n\t\t\t\tcp_obj->info.cp_utf8.bytes, cp_obj->info.cp_utf8.length);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API int r_bin_java_valid_class(const ut8 *buf, ut64 buf_sz) {\n\tRBinJavaObj *bin = R_NEW0 (RBinJavaObj), *cur_bin = R_BIN_JAVA_GLOBAL_BIN;\n\tif (!bin) {\n\t\treturn false;\n\t}\n\tint res = r_bin_java_load_bin (bin, buf, buf_sz);\n\tif (bin->calc_size == buf_sz) {\n\t\tres = true;\n\t}\n\tr_bin_java_free (bin);\n\tR_BIN_JAVA_GLOBAL_BIN = cur_bin;\n\treturn res;\n}\n\nR_API ut64 r_bin_java_calc_class_size(ut8 *bytes, ut64 size) {\n\tRBinJavaObj *bin = R_NEW0 (RBinJavaObj);\n\tif (!bin) {\n\t\treturn false;\n\t}\n\tRBinJavaObj *cur_bin = R_BIN_JAVA_GLOBAL_BIN;\n\tut64 bin_size = UT64_MAX;\n\tif (bin) {\n\t\tif (r_bin_java_load_bin (bin, bytes, size)) {\n\t\t\tbin_size = bin->calc_size;\n\t\t}\n\t\tr_bin_java_free (bin);\n\t\tR_BIN_JAVA_GLOBAL_BIN = cur_bin;\n\t}\n\treturn bin_size;\n}\n\nR_API int U(r_bin_java_get_cp_idx_with_name)(RBinJavaObj * bin_obj, const char *name, ut32 len) {\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *obj;\n\tr_list_foreach (bin_obj->cp_list, iter, obj) {\n\t\tif (obj->tag == R_BIN_JAVA_CP_UTF8) {\n\t\t\tif (!strncmp (name, (const char *) obj->info.cp_utf8.bytes, len)) {\n\t\t\t\treturn obj->metas->ord;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nR_API void r_bin_java_external_printf(PrintfCallback cb) {\n\tEprintf = cb ? cb : (PrintfCallback) printf;\n}\n"], "fixing_code": ["/* Apache 2.0 - Copyright 2007-2018 - pancake and dso\n   class.c rewrite: Adam Pridgen <dso@rice.edu || adam.pridgen@thecoverofnight.com>\n */\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_bin.h>\n#include <math.h>\n#include <sdb.h>\n#include \"class.h\"\n#include \"dsojson.h\"\n\nstatic PrintfCallback Eprintf =(PrintfCallback) printf;\n#ifdef IFDBG\n#undef IFDBG\n#endif\n#define DO_THE_DBG 0\n#define IFDBG  if (DO_THE_DBG)\n#define IFINT  if (0)\n\n#define MAX_CPITEMS 8192\n\nR_API char *U(r_bin_java_unmangle_method)(const char *flags, const char *name, const char *params, const char *r_value);\nR_API int r_bin_java_is_fm_type_private(RBinJavaField *fm_type);\nR_API int r_bin_java_is_fm_type_protected(RBinJavaField *fm_type);\nR_API ut32 U(r_bin_java_swap_uint)(ut32 x);\n\n// R_API const char * r_bin_java_get_this_class_name(RBinJavaObj *bin);\nR_API void U(add_cp_objs_to_sdb)(RBinJavaObj * bin);\nR_API void U(add_field_infos_to_sdb)(RBinJavaObj * bin);\nR_API void U(add_method_infos_to_sdb)(RBinJavaObj * bin);\nR_API RList *retrieve_all_access_string_and_value(RBinJavaAccessFlags *access_flags);\nR_API char *retrieve_access_string(ut16 flags, RBinJavaAccessFlags *access_flags);\nR_API ut16 calculate_access_value(const char *access_flags_str, RBinJavaAccessFlags *access_flags);\nR_API int r_bin_java_new_bin(RBinJavaObj *bin, ut64 loadaddr, Sdb *kv, const ut8 *buf, ut64 len);\nR_API int extract_type_value(const char *arg_str, char **output);\nR_API int r_bin_java_check_reset_cp_obj(RBinJavaCPTypeObj *cp_obj, ut8 tag);\nR_API ut8 *r_bin_java_cp_get_4bytes(ut8 tag, ut32 *out_sz, const ut8 *buf, const ut64 len);\nR_API ut8 *r_bin_java_cp_get_8bytes(ut8 tag, ut32 *out_sz, const ut8 *buf, const ut64 len);\nR_API ut8 *r_bin_java_cp_get_utf8(ut8 tag, ut32 *out_sz, const ut8 *buf, const ut64 len);\n\nR_API RBinJavaCPTypeObj *r_bin_java_get_item_from_bin_cp_list(RBinJavaObj *bin, ut64 idx);\nR_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp_item_list(RList *cp_list, ut64 idx);\n// Allocs for objects\nR_API RBinJavaCPTypeObj *r_bin_java_class_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_fieldref_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_methodref_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_interfacemethodref_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_name_and_type_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_string_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_integer_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_float_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_long_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_double_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_utf8_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 offset);\nR_API RBinJavaCPTypeObj *r_bin_java_do_nothing_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz);\nR_API RBinJavaCPTypeObj *r_bin_java_clone_cp_item(RBinJavaCPTypeObj *obj);\nR_API RBinJavaCPTypeObj *r_bin_java_clone_cp_idx(RBinJavaObj *bin, ut32 idx);\nR_API RBinJavaCPTypeObj *r_bin_java_methodhandle_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz);\nR_API RBinJavaCPTypeObj *r_bin_java_methodtype_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz);\nR_API RBinJavaCPTypeObj *r_bin_java_invokedynamic_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz);\n// Deallocs for type objects\nR_API void r_bin_java_default_free(void /*RBinJavaCPTypeObj*/ *obj);\nR_API void r_bin_java_obj_free(void /*RBinJavaCPTypeObj*/ *obj);\nR_API void r_bin_java_utf8_info_free(void /*RBinJavaCPTypeObj*/ *obj);\nR_API void r_bin_java_do_nothing_free(void /*RBinJavaCPTypeObj*/ *obj);\nR_API void r_bin_java_fmtype_free(void /*RBinJavaField*/ *fm_type);\n// handle freeing the lists\n// handle the reading of the various field\nR_API RBinJavaAttrInfo *r_bin_java_read_next_attr(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len);\nR_API RBinJavaCPTypeObj *r_bin_java_read_next_constant_pool_item(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, ut64 len);\nR_API RBinJavaAttrMetas *r_bin_java_get_attr_type_by_name(const char *name);\nR_API RBinJavaCPTypeObj *r_bin_java_get_java_null_cp();\nR_API ut64 r_bin_java_read_class_file2(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, ut64 len);\nR_API RBinJavaAttrInfo *r_bin_java_get_attr_from_field(RBinJavaField *field, R_BIN_JAVA_ATTR_TYPE attr_type, ut32 pos);\nR_API RBinJavaField *r_bin_java_read_next_field(RBinJavaObj *bin, const ut64 offset, const ut8 *buffer, const ut64 len);\nR_API RBinJavaField *r_bin_java_read_next_method(RBinJavaObj *bin, const ut64 offset, const ut8 *buffer, const ut64 len);\nR_API void r_bin_java_print_utf8_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_name_and_type_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_double_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_long_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_float_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_integer_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_string_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_classref_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_fieldref_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_methodref_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_interfacemethodref_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_unknown_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_null_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_unknown_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_methodhandle_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_methodtype_cp_summary(RBinJavaCPTypeObj *obj);\nR_API void r_bin_java_print_invokedynamic_cp_summary(RBinJavaCPTypeObj *obj);\nR_API RBinJavaCPTypeObj *r_bin_java_unknown_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz);\nR_API RBinJavaInterfaceInfo *r_bin_java_interface_new(RBinJavaObj *bin, const ut8 *buf, ut64 sz);\nR_API RBinJavaInterfaceInfo *r_bin_java_read_next_interface_item(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, ut64 len);\nR_API void r_bin_java_interface_free(void /*RBinJavaInterfaceInfo*/ *obj);\nR_API void r_bin_java_stack_frame_free(void /*RBinJavaStackMapFrame*/ *obj);\nR_API void r_bin_java_stack_map_table_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_verification_info_free(void /*RBinJavaVerificationObj*/ *obj);\nR_API void r_bin_java_print_stack_map_table_attr_summary(RBinJavaAttrInfo *obj);\nR_API void r_bin_java_print_stack_map_frame_summary(RBinJavaStackMapFrame *obj);\nR_API void r_bin_java_print_verification_info_summary(RBinJavaVerificationObj *obj);\nR_API RBinJavaStackMapFrame *r_bin_java_build_stack_frame_from_local_variable_table(RBinJavaObj *bin, RBinJavaAttrInfo *attr);\nR_API void U(r_bin_java_print_stack_map_append_frame_summary)(RBinJavaStackMapFrame * obj);\nR_API void U(r_bin_java_stack_frame_default_free)(void /*RBinJavaStackMapFrame*/ *stack_frame);\nR_API void U(r_bin_java_stack_frame_do_nothing_free)(void /*RBinJavaStackMapFrame*/ *stack_frame);\nR_API void U(r_bin_java_stack_frame_do_nothing_new)(RBinJavaObj * bin, RBinJavaStackMapFrame * stack_frame, ut64 offset);\nR_API RBinJavaStackMapFrame *r_bin_java_stack_map_frame_new(ut8 *buffer, ut64 sz, RBinJavaStackMapFrame *p_frame, ut64 buf_offset);\n// R_API RBinJavaStackMapFrame* r_bin_java_stack_map_frame_new (ut8* buffer, ut64 sz, ut64 buf_offset);\nR_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset);\n// R_API RBinJavaVerificationObj* r_bin_java_read_next_verification_info_new(ut8* buffer, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset);\nR_API RBinJavaElementValuePair *r_bin_java_element_pair_new(ut8 *buffer, ut64 sz, ut64 buf_offset);\nR_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset);\n// R_API RBinJavaBootStrapArgument* r_bin_java_bootstrap_method_argument_new(ut8* buffer, ut64 sz, ut64 buf_offset);\nR_API RBinJavaBootStrapMethod *r_bin_java_bootstrap_method_new(ut8 *buffer, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAnnotationsArray *r_bin_java_annotation_array_new(ut8 *buffer, ut64 sz, ut64 buf_offset);\nR_API RBinJavaElementValueMetas *r_bin_java_get_ev_meta_from_tag(ut8 tag);\nR_API RBinJavaCPTypeMetas *U(r_bin_java_get_cp_meta_from_tag)(ut8 tag);\nR_API void r_bin_java_inner_classes_attr_entry_free(void /*RBinJavaClassesAttribute*/ *attr);\nR_API void r_bin_java_annotation_default_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_enclosing_methods_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_local_variable_type_table_attr_entry_free(void /*RBinJavaLocalVariableTypeAttribute*/ *lvattr);\nR_API void r_bin_java_local_variable_type_table_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_signature_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_source_debug_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_element_value_free(void /*RBinJavaElementValue*/ *element_value);\nR_API void r_bin_java_element_pair_free(void /*RBinJavaElementValuePair*/ *ev_pair);\nR_API void r_bin_java_annotation_free(void /*RBinJavaAnnotation*/ *annotation);\nR_API void r_bin_java_rtv_annotations_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_rti_annotations_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_annotation_array_free(void /*RBinJavaAnnotationsArray*/ *annotation_array);\nR_API void r_bin_java_bootstrap_methods_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_bootstrap_method_free(void /*RBinJavaBootStrapMethod*/ *bsm);\nR_API void r_bin_java_bootstrap_method_argument_free(void /*RBinJavaBootStrapArgument*/ *bsm_arg);\nR_API void r_bin_java_rtvp_annotations_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_rtip_annotations_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_unknown_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_code_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_constant_value_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_deprecated_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_exceptions_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_inner_classes_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_line_number_table_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_local_variable_table_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_source_code_file_attr_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_synthetic_attr_free(void /*RBinJavaAttrInfo*/ *attr);\n\nR_API void r_bin_java_print_annotation_default_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_enclosing_methods_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_local_variable_type_attr_summary(RBinJavaLocalVariableTypeAttribute *lvattr);\nR_API void r_bin_java_print_local_variable_type_table_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_signature_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_source_debug_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_element_value_summary(RBinJavaElementValue *element_value);\nR_API void r_bin_java_print_annotation_summary(RBinJavaAnnotation *annotation);\nR_API void r_bin_java_print_element_pair_summary(RBinJavaElementValuePair *ev_pair);\nR_API void r_bin_java_print_bootstrap_methods_attr_summary(RBinJavaAttrInfo *attr);\n// R_API void r_bin_java_bootstrap_method_summary(RBinJavaBootStrapMethod *bsm);\n// R_API void r_bin_java_bootstrap_method_argument_summary(RBinJavaBootStrapArgument *bsm_arg);\nR_API void r_bin_java_print_rtv_annotations_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_rti_annotations_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_annotation_array_summary(RBinJavaAnnotationsArray *annotation_array);\nR_API void r_bin_java_print_rtvp_annotations_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_rtip_annotations_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_attribute_free(void /*RBinJavaAttrInfo*/ *attr);\nR_API void r_bin_java_constant_pool(void /*RBinJavaCPTypeObj*/ *obj);\nR_API void r_bin_java_print_field_summary(RBinJavaField *field);\n// R_API void r_bin_java_print_interface_summary(RBinJavaField *field);\nR_API void r_bin_java_print_method_summary(RBinJavaField *field);\nR_API void r_bin_java_print_code_exceptions_attr_summary(RBinJavaExceptionEntry *exc_entry);\nR_API void r_bin_java_print_code_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_constant_value_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_deprecated_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_exceptions_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_classes_attr_summary(RBinJavaClassesAttribute *icattr);\nR_API void r_bin_java_print_inner_classes_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_line_number_table_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_local_variable_attr_summary(RBinJavaLocalVariableAttribute *lvattr);\nR_API void r_bin_java_print_local_variable_table_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_source_code_file_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_synthetic_attr_summary(RBinJavaAttrInfo *attr);\nR_API void r_bin_java_print_attr_summary(RBinJavaAttrInfo *attr);\nR_API RBinJavaAttrInfo *r_bin_java_read_next_attr_from_buffer(ut8 *buffer, st64 sz, st64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_unknown_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_signature_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_rtvp_annotations_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_rtip_annotations_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_code_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_deprecated_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_exceptions_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_local_variable_table_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(ut8 *buf, ut64 sz, ut64 buf_offset);\nR_API ut64 r_bin_java_unknown_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_annotation_default_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_enclosing_methods_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_local_variable_type_table_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_signature_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_source_debug_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_bootstrap_methods_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_rtv_annotations_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_rti_annotations_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_rtvp_annotations_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_rtip_annotations_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_code_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_constant_value_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_deprecated_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_exceptions_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_inner_classes_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_line_number_table_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_local_variable_table_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_source_code_file_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_stack_map_table_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_synthetic_attr_calc_size(RBinJavaAttrInfo *attr);\nR_API ut64 r_bin_java_bootstrap_method_calc_size(RBinJavaBootStrapMethod *bsm);\nR_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *ev_pair);\nR_API ut64 r_bin_java_element_value_calc_size(RBinJavaElementValue *element_value);\n\nR_API ut64 r_bin_java_unknown_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_class_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_fieldref_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_methodref_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_interfacemethodref_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_name_and_type_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_string_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_integer_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_float_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_long_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_double_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_utf8_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_do_nothing_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_methodhandle_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_methodtype_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API ut64 r_bin_java_invokedynamic_cp_calc_size(RBinJavaCPTypeObj *obj);\nR_API RBinJavaStackMapFrame *r_bin_java_default_stack_frame();\n\nR_API RList *r_bin_java_find_cp_const_by_val_float(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len);\nR_API RList *r_bin_java_find_cp_const_by_val_double(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len);\nR_API RList *r_bin_java_find_cp_const_by_val_int(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len);\nR_API RList *r_bin_java_find_cp_const_by_val_long(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len);\nR_API RList *r_bin_java_find_cp_const_by_val_utf8(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len);\nR_API ut8 *r_bin_java_cp_append_classref_and_name(RBinJavaObj *bin, ut32 *out_sz, const char *classname, const ut32 classname_len);\nR_API ut8 *U(r_bin_java_cp_append_ref_cname_fname_ftype)(RBinJavaObj * bin, ut32 * out_sz, ut8 tag, const char *cname, const ut32 c_len, const char *fname, const ut32 f_len, const char *tname, const ut32 t_len);\nR_API ut8 *r_bin_java_cp_get_classref(RBinJavaObj *bin, ut32 *out_sz, const char *classname, const ut32 classname_len, const ut16 name_idx);\nR_API ut8 *U(r_bin_java_cp_get_method_ref)(RBinJavaObj * bin, ut32 * out_sz, ut16 class_idx, ut16 name_and_type_idx);\nR_API ut8 *U(r_bin_java_cp_get_field_ref)(RBinJavaObj * bin, ut32 * out_sz, ut16 class_idx, ut16 name_and_type_idx);\nR_API ut8 *r_bin_java_cp_get_fm_ref(RBinJavaObj *bin, ut32 *out_sz, ut8 tag, ut16 class_idx, ut16 name_and_type_idx);\nR_API ut8 *r_bin_java_cp_get_2_ut16(RBinJavaObj *bin, ut32 *out_sz, ut8 tag, ut16 ut16_one, ut16 ut16_two);\nR_API ut8 *r_bin_java_cp_get_name_type(RBinJavaObj *bin, ut32 *out_sz, ut16 name_idx, ut16 type_idx);\n\nstatic char *convert_string(const char *bytes, ut32 len) {\n\tut32 idx = 0, pos = 0;\n\tut32 str_sz = 32 * len + 1;\n\tchar *cpy_buffer = len > 0 ? malloc (str_sz) : NULL;\n\tif (!cpy_buffer) {\n\t\treturn cpy_buffer;\n\t}\n\t// 4x is the increase from byte to \\xHH where HH represents hexed byte\n\tmemset (cpy_buffer, 0, str_sz);\n\twhile (idx < len && pos < len) {\n\t\tif (dso_json_char_needs_hexing (bytes[idx])) {\n\t\t\tif (pos + 2 < len) {\n\t\t\t\tfree (cpy_buffer);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tsprintf (cpy_buffer + pos, \"\\\\x%02x\", bytes[idx]);\n\t\t\tpos += 4;\n\t\t} else {\n\t\t\tcpy_buffer[pos] = bytes[idx];\n\t\t\tpos++;\n\t\t}\n\t\tidx++;\n\t}\n\treturn cpy_buffer;\n}\n\n// taken from LLVM Code Byte Swap\n// TODO: move into r_util\nR_API ut32 U(r_bin_java_swap_uint)(ut32 x) {\n\tconst ut32 Byte0 = x & 0x000000FF;\n\tconst ut32 Byte1 = x & 0x0000FF00;\n\tconst ut32 Byte2 = x & 0x00FF0000;\n\tconst ut32 Byte3 = x & 0xFF000000;\n\treturn (Byte0 << 24) | (Byte1 << 8) | (Byte2 >> 8) | (Byte3 >> 24);\n}\n\nstatic bool R_BIN_JAVA_NULL_TYPE_INITTED = false;\n// XXX - this is a global variable used while parsing the class file\n// if multi-threaded class parsing is enabled, this variable needs to\n// be guarded with a lock.\nstatic RBinJavaObj *R_BIN_JAVA_GLOBAL_BIN = NULL;\nstatic RBinJavaAccessFlags FIELD_ACCESS_FLAGS[] = {\n\t{ \"public\", R_BIN_JAVA_FIELD_ACC_PUBLIC, 6 },\n\t{ \"private\", R_BIN_JAVA_FIELD_ACC_PRIVATE, 7 },\n\t{ \"protected\", R_BIN_JAVA_FIELD_ACC_PROTECTED, 9 },\n\t{ \"static\", R_BIN_JAVA_FIELD_ACC_STATIC, 6 },\n\t{ \"final\", R_BIN_JAVA_FIELD_ACC_FINAL, 5 },\n\t{ \"undefined.0x0020\", 0x0020, 16 },\n\t{ \"volatile\", R_BIN_JAVA_FIELD_ACC_VOLATILE, 8 },\n\t{ \"transient\", R_BIN_JAVA_FIELD_ACC_TRANSIENT, 9 },\n\t{ \"undefined.0x0100\", 0x0100, 16 },\n\t{ \"undefined.0x0200\", 0x0200, 16 },\n\t{ \"undefined.0x0400\", 0x0400, 16 },\n\t{ \"undefined.0x0800\", 0x0800, 16 },\n\t{ \"synthetic\", R_BIN_JAVA_FIELD_ACC_SYNTHETIC, 9 },\n\t{ \"undefined.0x2000\", 0x2000, 16 },\n\t{ \"enum\", R_BIN_JAVA_FIELD_ACC_ENUM, 16 },\n\t{ \"undefined.0x8000\", 0x8000, 16 },\n\t{ NULL, 0, 0 }\n};\nstatic RBinJavaAccessFlags METHOD_ACCESS_FLAGS[] = {\n\t{ \"public\", R_BIN_JAVA_METHOD_ACC_PUBLIC, 6 },\n\t{ \"private\", R_BIN_JAVA_METHOD_ACC_PRIVATE, 7 },\n\t{ \"protected\", R_BIN_JAVA_METHOD_ACC_PROTECTED, 9 },\n\t{ \"static\", R_BIN_JAVA_METHOD_ACC_STATIC, 6 },\n\t{ \"final\", R_BIN_JAVA_METHOD_ACC_FINAL, 5 },\n\t{ \"synchronized\", R_BIN_JAVA_METHOD_ACC_SYNCHRONIZED, 12 },\n\t{ \"bridge\", R_BIN_JAVA_METHOD_ACC_BRIDGE, 6 },\n\t{ \"varargs\", R_BIN_JAVA_METHOD_ACC_VARARGS, 7 },\n\t{ \"native\", R_BIN_JAVA_METHOD_ACC_NATIVE, 6 },\n\t{ \"interface\", R_BIN_JAVA_METHOD_ACC_INTERFACE, 9 },\n\t{ \"abstract\", R_BIN_JAVA_METHOD_ACC_ABSTRACT, 8 },\n\t{ \"strict\", R_BIN_JAVA_METHOD_ACC_STRICT, 6 },\n\t{ \"synthetic\", R_BIN_JAVA_METHOD_ACC_SYNTHETIC, 9 },\n\t{ \"annotation\", R_BIN_JAVA_METHOD_ACC_ANNOTATION, 10 },\n\t{ \"enum\", R_BIN_JAVA_METHOD_ACC_ENUM, 4 },\n\t{ \"undefined.0x8000\", 0x8000, 16 },\n\t{ NULL, 0, 0 }\n};\n// XXX - Fix these there are some incorrect ongs\nstatic RBinJavaAccessFlags CLASS_ACCESS_FLAGS[] = {\n\t{ \"public\", R_BIN_JAVA_CLASS_ACC_PUBLIC, 6 },\n\t{ \"undefined.0x0002\", 0x0002, 16 },\n\t{ \"undefined.0x0004\", 0x0004, 16 },\n\t{ \"undefined.0x0008\", 0x0008, 16 },\n\t{ \"final\", R_BIN_JAVA_CLASS_ACC_FINAL, 5 },\n\t{ \"super\", R_BIN_JAVA_CLASS_ACC_SUPER, 5 },\n\t{ \"undefined.0x0040\", 0x0040, 16 },\n\t{ \"undefined.0x0080\", 0x0080, 16 },\n\t{ \"undefined.0x0100\", 0x0100, 16 },\n\t{ \"interface\", R_BIN_JAVA_CLASS_ACC_INTERFACE, 9 },\n\t{ \"abstract\", R_BIN_JAVA_CLASS_ACC_ABSTRACT, 8 },\n\t{ \"undefined.0x0800\", 0x0800, 16 },\n\t{ \"synthetic\", R_BIN_JAVA_CLASS_ACC_SYNTHETIC, 9 },\n\t{ \"annotation\", R_BIN_JAVA_CLASS_ACC_ANNOTATION, 10 },\n\t{ \"enum\", R_BIN_JAVA_CLASS_ACC_ENUM, 4 },\n\t{ \"undefined.0x8000\", 0x8000, 16 },\n\t{ NULL, 0, 0 }\n};\nstatic RBinJavaRefMetas R_BIN_JAVA_REF_METAS[] = {\n\t{ \"Unknown\", R_BIN_JAVA_REF_UNKNOWN },\n\t{ \"GetField\", R_BIN_JAVA_REF_GETFIELD },\n\t{ \"GetStatic\", R_BIN_JAVA_REF_GETSTATIC },\n\t{ \"PutField\", R_BIN_JAVA_REF_PUTFIELD },\n\t{ \"PutStatic\", R_BIN_JAVA_REF_PUTSTATIC },\n\t{ \"InvokeVirtual\", R_BIN_JAVA_REF_INVOKEVIRTUAL },\n\t{ \"InvokeStatic\", R_BIN_JAVA_REF_INVOKESTATIC },\n\t{ \"InvokeSpecial\", R_BIN_JAVA_REF_INVOKESPECIAL },\n\t{ \"NewInvokeSpecial\", R_BIN_JAVA_REF_NEWINVOKESPECIAL },\n\t{ \"InvokeInterface\", R_BIN_JAVA_REF_INVOKEINTERFACE }\n};\nstatic ut16 R_BIN_JAVA_ELEMENT_VALUE_METAS_SZ = 14;\nstatic RBinJavaElementValueMetas R_BIN_JAVA_ELEMENT_VALUE_METAS[] = {\n\t{ \"Byte\", R_BIN_JAVA_EV_TAG_BYTE, NULL },\n\t{ \"Char\", R_BIN_JAVA_EV_TAG_CHAR, NULL },\n\t{ \"Double\", R_BIN_JAVA_EV_TAG_DOUBLE, NULL },\n\t{ \"Float\", R_BIN_JAVA_EV_TAG_FLOAT, NULL },\n\t{ \"Integer\", R_BIN_JAVA_EV_TAG_INT, NULL },\n\t{ \"Long\", R_BIN_JAVA_EV_TAG_LONG, NULL },\n\t{ \"Short\", R_BIN_JAVA_EV_TAG_SHORT, NULL },\n\t{ \"Boolean\", R_BIN_JAVA_EV_TAG_BOOLEAN, NULL },\n\t{ \"Array of \", R_BIN_JAVA_EV_TAG_ARRAY, NULL },\n\t{ \"String\", R_BIN_JAVA_EV_TAG_STRING, NULL },\n\t{ \"Enum\", R_BIN_JAVA_EV_TAG_ENUM, NULL },\n\t{ \"Class\", R_BIN_JAVA_EV_TAG_CLASS, NULL },\n\t{ \"Annotation\", R_BIN_JAVA_EV_TAG_ANNOTATION, NULL },\n\t{ \"Unknown\", R_BIN_JAVA_EV_TAG_UNKNOWN, NULL },\n};\nstatic RBinJavaVerificationMetas R_BIN_JAVA_VERIFICATION_METAS[] = {\n\t{ \"Top\", R_BIN_JAVA_STACKMAP_TOP },\n\t{ \"Integer\", R_BIN_JAVA_STACKMAP_INTEGER },\n\t{ \"Float\", R_BIN_JAVA_STACKMAP_FLOAT },\n\t{ \"Double\", R_BIN_JAVA_STACKMAP_DOUBLE },\n\t{ \"Long\", R_BIN_JAVA_STACKMAP_LONG },\n\t{ \"NULL\", R_BIN_JAVA_STACKMAP_NULL },\n\t{ \"This\", R_BIN_JAVA_STACKMAP_THIS },\n\t{ \"Object\", R_BIN_JAVA_STACKMAP_OBJECT },\n\t{ \"Uninitialized\", R_BIN_JAVA_STACKMAP_UNINIT },\n\t{ \"Unknown\", R_BIN_JAVA_STACKMAP_UNKNOWN }\n};\nstatic RBinJavaStackMapFrameMetas R_BIN_JAVA_STACK_MAP_FRAME_METAS[] = {\n\t{ \"ImplicitStackFrame\", R_BIN_JAVA_STACK_FRAME_IMPLICIT, NULL },\n\t{ \"Same\", R_BIN_JAVA_STACK_FRAME_SAME, NULL },\n\t{ \"SameLocals1StackItem\", R_BIN_JAVA_STACK_FRAME_SAME_LOCALS_1, NULL },\n\t{ \"Chop\", R_BIN_JAVA_STACK_FRAME_CHOP, NULL },\n\t{ \"SameFrameExtended\", R_BIN_JAVA_STACK_FRAME_SAME_FRAME_EXTENDED, NULL },\n\t{ \"Append\", R_BIN_JAVA_STACK_FRAME_APPEND, NULL },\n\t{ \"FullFrame\", R_BIN_JAVA_STACK_FRAME_FULL_FRAME, NULL },\n\t{ \"Reserved\", R_BIN_JAVA_STACK_FRAME_RESERVED, NULL }\n};\n\nstatic RBinJavaCPTypeObjectAllocs R_BIN_ALLOCS_CONSTANTS[] = {\n\t{ r_bin_java_do_nothing_new, r_bin_java_do_nothing_free, r_bin_java_print_null_cp_summary, r_bin_java_do_nothing_calc_size, r_bin_java_print_null_cp_stringify },\n\t{ r_bin_java_utf8_cp_new, r_bin_java_utf8_info_free, r_bin_java_print_utf8_cp_summary, r_bin_java_utf8_cp_calc_size, r_bin_java_print_utf8_cp_stringify },\n\t{ r_bin_java_unknown_cp_new, r_bin_java_default_free, r_bin_java_print_unknown_cp_summary, r_bin_java_unknown_cp_calc_size, r_bin_java_print_unknown_cp_stringify },\n\t{ r_bin_java_integer_cp_new, r_bin_java_default_free, r_bin_java_print_integer_cp_summary, r_bin_java_integer_cp_calc_size, r_bin_java_print_integer_cp_stringify },\n\t{ r_bin_java_float_cp_new, r_bin_java_default_free, r_bin_java_print_float_cp_summary, r_bin_java_float_cp_calc_size, r_bin_java_print_float_cp_stringify },\n\t{ r_bin_java_long_cp_new, r_bin_java_default_free, r_bin_java_print_long_cp_summary, r_bin_java_long_cp_calc_size, r_bin_java_print_long_cp_stringify },\n\t{ r_bin_java_double_cp_new, r_bin_java_default_free, r_bin_java_print_double_cp_summary, r_bin_java_double_cp_calc_size, r_bin_java_print_double_cp_stringify },\n\t{ r_bin_java_class_cp_new, r_bin_java_default_free, r_bin_java_print_classref_cp_summary, r_bin_java_class_cp_calc_size, r_bin_java_print_classref_cp_stringify },\n\t{ r_bin_java_string_cp_new, r_bin_java_default_free, r_bin_java_print_string_cp_summary, r_bin_java_string_cp_calc_size, r_bin_java_print_string_cp_stringify },\n\t{ r_bin_java_fieldref_cp_new, r_bin_java_default_free, r_bin_java_print_fieldref_cp_summary, r_bin_java_fieldref_cp_calc_size, r_bin_java_print_fieldref_cp_stringify },\n\t{ r_bin_java_methodref_cp_new, r_bin_java_default_free, r_bin_java_print_methodref_cp_summary, r_bin_java_methodref_cp_calc_size, r_bin_java_print_methodref_cp_stringify },\n\t{ r_bin_java_interfacemethodref_cp_new, r_bin_java_default_free, r_bin_java_print_interfacemethodref_cp_summary, r_bin_java_interfacemethodref_cp_calc_size, r_bin_java_print_interfacemethodref_cp_stringify },\n\t{ r_bin_java_name_and_type_cp_new, r_bin_java_default_free, r_bin_java_print_name_and_type_cp_summary, r_bin_java_name_and_type_cp_calc_size, r_bin_java_print_name_and_type_cp_stringify },\n\t{ NULL, NULL, NULL, NULL, NULL },\n\t{ NULL, NULL, NULL, NULL, NULL },\n\t{ r_bin_java_methodhandle_cp_new, r_bin_java_default_free, r_bin_java_print_methodhandle_cp_summary, r_bin_java_methodhandle_cp_calc_size, r_bin_java_print_methodhandle_cp_stringify },\n\t{ r_bin_java_methodtype_cp_new, r_bin_java_default_free, r_bin_java_print_methodtype_cp_summary, r_bin_java_methodtype_cp_calc_size, r_bin_java_print_methodtype_cp_stringify },\n\t{ NULL, NULL, NULL, NULL, NULL },\n\t{ r_bin_java_invokedynamic_cp_new, r_bin_java_default_free, r_bin_java_print_invokedynamic_cp_summary, r_bin_java_invokedynamic_cp_calc_size, r_bin_java_print_invokedynamic_cp_stringify },\n};\nstatic RBinJavaCPTypeObj R_BIN_JAVA_NULL_TYPE;\nstatic ut8 R_BIN_JAVA_CP_METAS_SZ = 12;\nstatic RBinJavaCPTypeMetas R_BIN_JAVA_CP_METAS[] = {\n\t// Each field has a name pointer and a tag field\n\t{ \"NULL\", R_BIN_JAVA_CP_NULL, 0, &R_BIN_ALLOCS_CONSTANTS[0] },\n\t{ \"Utf8\", R_BIN_JAVA_CP_UTF8, 3, &R_BIN_ALLOCS_CONSTANTS[1] },  // 2 bytes = length, N bytes string (containts a pointer in the field)\n\t{ \"Unknown\", R_BIN_JAVA_CP_UNKNOWN, 0, &R_BIN_ALLOCS_CONSTANTS[2] },\n\t{ \"Integer\", R_BIN_JAVA_CP_INTEGER, 5, &R_BIN_ALLOCS_CONSTANTS[3] },  // 4 bytes\n\t{ \"Float\", R_BIN_JAVA_CP_FLOAT, 5, &R_BIN_ALLOCS_CONSTANTS[4] },  // 4 bytes\n\t{ \"Long\", R_BIN_JAVA_CP_LONG, 9, &R_BIN_ALLOCS_CONSTANTS[5] }, // 4 high 4 low\n\t{ \"Double\", R_BIN_JAVA_CP_DOUBLE, 9, &R_BIN_ALLOCS_CONSTANTS[6] }, // 4 high 4 low\n\t{ \"Class\", R_BIN_JAVA_CP_CLASS, 3, &R_BIN_ALLOCS_CONSTANTS[7] }, // 2 name_idx\n\t{ \"String\", R_BIN_JAVA_CP_STRING, 3, &R_BIN_ALLOCS_CONSTANTS[8] }, // 2 string_idx\n\t{ \"FieldRef\", R_BIN_JAVA_CP_FIELDREF, 5, &R_BIN_ALLOCS_CONSTANTS[9] }, // 2 class idx, 2 name/type_idx\n\t{ \"MethodRef\", R_BIN_JAVA_CP_METHODREF, 5, &R_BIN_ALLOCS_CONSTANTS[10] }, // 2 class idx, 2 name/type_idx\n\t{ \"InterfaceMethodRef\", R_BIN_JAVA_CP_INTERFACEMETHOD_REF, 5, &R_BIN_ALLOCS_CONSTANTS[11] },  // 2 class idx, 2 name/type_idx\n\t{ \"NameAndType\", R_BIN_JAVA_CP_NAMEANDTYPE, 5, &R_BIN_ALLOCS_CONSTANTS[12] }, // 4 high 4 low\n\t{ \"Unknown\", R_BIN_JAVA_CP_UNKNOWN, 0, &R_BIN_ALLOCS_CONSTANTS[2] },\n\t{ \"Unknown\", R_BIN_JAVA_CP_UNKNOWN, 0, &R_BIN_ALLOCS_CONSTANTS[2] },\n\t{ \"MethodHandle\", R_BIN_JAVA_CP_METHODHANDLE, 4, &R_BIN_ALLOCS_CONSTANTS[15] }, // 4 high 4 low\n\t{ \"MethodType\", R_BIN_JAVA_CP_METHODTYPE, 3, &R_BIN_ALLOCS_CONSTANTS[16] }, // 4 high 4 low\n\t{ \"Unknown\", R_BIN_JAVA_CP_UNKNOWN, 0, &R_BIN_ALLOCS_CONSTANTS[2] },\n\t{ \"InvokeDynamic\", R_BIN_JAVA_CP_INVOKEDYNAMIC, 5, &R_BIN_ALLOCS_CONSTANTS[18] }, // 4 high 4 low\n};\nstatic RBinJavaAttrInfoObjectAllocs RBIN_JAVA_ATTRS_ALLOCS[] = {\n\t{ r_bin_java_annotation_default_attr_new, r_bin_java_annotation_default_attr_free, r_bin_java_print_annotation_default_attr_summary, r_bin_java_annotation_default_attr_calc_size },\n\t{ r_bin_java_bootstrap_methods_attr_new, r_bin_java_bootstrap_methods_attr_free, r_bin_java_print_bootstrap_methods_attr_summary, r_bin_java_bootstrap_methods_attr_calc_size },\n\t{ r_bin_java_code_attr_new, r_bin_java_code_attr_free, r_bin_java_print_code_attr_summary, r_bin_java_code_attr_calc_size },\n\t{ r_bin_java_constant_value_attr_new, r_bin_java_constant_value_attr_free, r_bin_java_print_constant_value_attr_summary, r_bin_java_constant_value_attr_calc_size },\n\t{ r_bin_java_deprecated_attr_new, r_bin_java_deprecated_attr_free, r_bin_java_print_deprecated_attr_summary, r_bin_java_deprecated_attr_calc_size },\n\t{ r_bin_java_enclosing_methods_attr_new, r_bin_java_enclosing_methods_attr_free, r_bin_java_print_enclosing_methods_attr_summary, r_bin_java_enclosing_methods_attr_calc_size },\n\t{ r_bin_java_exceptions_attr_new, r_bin_java_exceptions_attr_free, r_bin_java_print_exceptions_attr_summary, r_bin_java_exceptions_attr_calc_size },\n\t{ r_bin_java_inner_classes_attr_new, r_bin_java_inner_classes_attr_free, r_bin_java_print_inner_classes_attr_summary, r_bin_java_inner_classes_attr_calc_size },\n\t{ r_bin_java_line_number_table_attr_new, r_bin_java_line_number_table_attr_free, r_bin_java_print_line_number_table_attr_summary, r_bin_java_line_number_table_attr_calc_size },\n\t{ r_bin_java_local_variable_table_attr_new, r_bin_java_local_variable_table_attr_free, r_bin_java_print_local_variable_table_attr_summary, r_bin_java_local_variable_table_attr_calc_size },\n\t{ r_bin_java_local_variable_type_table_attr_new, r_bin_java_local_variable_type_table_attr_free, r_bin_java_print_local_variable_type_table_attr_summary, r_bin_java_local_variable_type_table_attr_calc_size },\n\t{ r_bin_java_rti_annotations_attr_new, r_bin_java_rti_annotations_attr_free, r_bin_java_print_rti_annotations_attr_summary, r_bin_java_rti_annotations_attr_calc_size },\n\t{ r_bin_java_rtip_annotations_attr_new, r_bin_java_rtip_annotations_attr_free, r_bin_java_print_rtip_annotations_attr_summary, r_bin_java_rtip_annotations_attr_calc_size },\n\t{ r_bin_java_rtv_annotations_attr_new, r_bin_java_rtv_annotations_attr_free, r_bin_java_print_rtv_annotations_attr_summary, r_bin_java_rtv_annotations_attr_calc_size },\n\t{ r_bin_java_rtvp_annotations_attr_new, r_bin_java_rtvp_annotations_attr_free, r_bin_java_print_rtvp_annotations_attr_summary, r_bin_java_rtvp_annotations_attr_calc_size },\n\t{ r_bin_java_signature_attr_new, r_bin_java_signature_attr_free, r_bin_java_print_signature_attr_summary, r_bin_java_signature_attr_calc_size },\n\t{ r_bin_java_source_debug_attr_new, r_bin_java_source_debug_attr_free, r_bin_java_print_source_debug_attr_summary, r_bin_java_source_debug_attr_calc_size },\n\t{ r_bin_java_source_code_file_attr_new, r_bin_java_source_code_file_attr_free, r_bin_java_print_source_code_file_attr_summary, r_bin_java_source_code_file_attr_calc_size },\n\t{ r_bin_java_stack_map_table_attr_new, r_bin_java_stack_map_table_attr_free, r_bin_java_print_stack_map_table_attr_summary, r_bin_java_stack_map_table_attr_calc_size },\n\t{ r_bin_java_synthetic_attr_new, r_bin_java_synthetic_attr_free, r_bin_java_print_synthetic_attr_summary, r_bin_java_synthetic_attr_calc_size },\n\t{ r_bin_java_unknown_attr_new, r_bin_java_unknown_attr_free, r_bin_java_print_unknown_attr_summary, r_bin_java_unknown_attr_calc_size }\n};\n// R_API ut32 RBIN_JAVA_ATTRS_METAS_SZ = 21;\nstatic ut32 RBIN_JAVA_ATTRS_METAS_SZ = 20;\nstatic RBinJavaAttrMetas RBIN_JAVA_ATTRS_METAS[] = {\n\t{ \"AnnotationDefault\", R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[0] },\n\t{ \"BootstrapMethods\", R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[1] },\n\t{ \"Code\", R_BIN_JAVA_ATTR_TYPE_CODE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[2] },\n\t{ \"ConstantValue\", R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[3] },\n\t{ \"Deperecated\", R_BIN_JAVA_ATTR_TYPE_DEPRECATED_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[4] },\n\t{ \"EnclosingMethod\", R_BIN_JAVA_ATTR_TYPE_ENCLOSING_METHOD_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[5] },\n\t{ \"Exceptions\", R_BIN_JAVA_ATTR_TYPE_EXCEPTIONS_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[6] },\n\t{ \"InnerClasses\", R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[7] },\n\t{ \"LineNumberTable\", R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[8] },\n\t{ \"LocalVariableTable\", R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TABLE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[9] },\n\t{ \"LocalVariableTypeTable\", R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TYPE_TABLE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[10] },\n\t{ \"RuntimeInvisibleAnnotations\", R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[11] },\n\t{ \"RuntimeInvisibleParameterAnnotations\", R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_PARAMETER_ANNOTATION_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[12] },\n\t{ \"RuntimeVisibleAnnotations\", R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_ANNOTATION_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[13] },\n\t{ \"RuntimeVisibleParameterAnnotations\", R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_PARAMETER_ANNOTATION_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[14] },\n\t{ \"Signature\", R_BIN_JAVA_ATTR_TYPE_SIGNATURE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[15] },\n\t{ \"SourceDebugExtension\", R_BIN_JAVA_ATTR_TYPE_SOURCE_DEBUG_EXTENTSION_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[16] },\n\t{ \"SourceFile\", R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[17] },\n\t{ \"StackMapTable\", R_BIN_JAVA_ATTR_TYPE_STACK_MAP_TABLE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[18] },\n\t// { \"StackMap\", R_BIN_JAVA_ATTR_TYPE_STACK_MAP_TABLE_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[18]},\n\t{ \"Synthetic\", R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[19] },\n\t{ \"Unknown\", R_BIN_JAVA_ATTR_TYPE_UNKNOWN_ATTR, &RBIN_JAVA_ATTRS_ALLOCS[20] }\n};\n\nR_API void r_bin_java_reset_bin_info(RBinJavaObj *bin) {\n\tfree (bin->cf2.flags_str);\n\tfree (bin->cf2.this_class_name);\n\tr_list_free (bin->imports_list);\n\tr_list_free (bin->methods_list);\n\tr_list_free (bin->fields_list);\n\tr_list_free (bin->attrs_list);\n\tr_list_free (bin->cp_list);\n\tr_list_free (bin->interfaces_list);\n\tmemset (bin, 0, sizeof (RBinJavaObj));\n\tbin->cf2.flags_str = strdup (\"unknown\");\n\tbin->cf2.this_class_name = strdup (\"unknown\");\n\tbin->imports_list = r_list_newf (free);\n\tbin->methods_list = r_list_newf (r_bin_java_fmtype_free);\n\tbin->fields_list = r_list_newf (r_bin_java_fmtype_free);\n\tbin->attrs_list = r_list_newf (r_bin_java_attribute_free);\n\tbin->cp_list = r_list_newf (r_bin_java_constant_pool);\n\tbin->interfaces_list = r_list_newf (r_bin_java_interface_free);\n}\n\nR_API char *r_bin_java_unmangle_method(const char *flags, const char *name, const char *params, const char *r_value) {\n\tRList *the_list = params ? r_bin_java_extract_type_values (params) : r_list_new ();\n\tRListIter *iter = NULL;\n\t// second case removes leading space if no flags are given\n\tconst char *fmt = flags ? \"%s %s %s (%s)\" : \"%s%s %s (%s)\";\n\tchar *str = NULL, *f_val_str = NULL, *r_val_str = NULL, *prototype = NULL, *p_val_str = NULL;\n\tut32 params_idx = 0, params_len = 0, prototype_len = 0;\n\tif (!extract_type_value (r_value, &r_val_str)) {\n\t\tr_list_free (the_list);\n\t\treturn NULL;\n\t}\n\tif (!r_val_str) {\n\t\tr_val_str = strdup (\"UNKNOWN\");\n\t}\n\tf_val_str = strdup (flags ? flags : \"\");\n\tparams_idx = 0;\n\tr_list_foreach (the_list, iter, str) {\n\t\tparams_len += strlen (str);\n\t\tif (params_idx > 0) {\n\t\t\tparams_len += 2;\n\t\t}\n\t\tparams_idx++;\n\t}\n\tif (params_len > 0) {\n\t\tut32 offset = 0;\n\t\tparams_len += 1;\n\t\tp_val_str = malloc (params_len);\n\t\tparams_idx = 0;\n\t\tr_list_foreach (the_list, iter, str) {\n\t\t\tif (offset != 0) {\n\t\t\t\toffset += snprintf (p_val_str + offset, params_len - offset, \", %s\", str);\n\t\t\t} else {\n\t\t\t\toffset += snprintf (p_val_str + offset, params_len - offset, \"%s\", str);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tp_val_str = strdup (\"\");\n\t}\n\n\tprototype_len += (flags ? strlen (flags) + 1 : 0); // space vs no space\n\tprototype_len += strlen (name) + 1; // name + space\n\tprototype_len += strlen (r_val_str) + 1; // r_value + space\n\tprototype_len += strlen (p_val_str) + 3; // space + l_paren + params + r_paren\n\tprototype_len += 1; // null\n\tprototype = malloc (prototype_len);\n\t/// TODO enable this function and start using it to demangle strings\n\tsnprintf (prototype, prototype_len, fmt, f_val_str, r_val_str, name, p_val_str);\n\tfree (f_val_str);\n\tfree (r_val_str);\n\tfree (p_val_str);\n\tr_list_free (the_list);\n\treturn prototype;\n}\n\nR_API char *r_bin_java_unmangle(const char *flags, const char *name, const char *descriptor) {\n\tut32 l_paren_pos = -1, r_paren_pos = -1;\n\tchar *result = NULL;\n\tut32 desc_len = descriptor && *descriptor ? strlen (descriptor) : 0,\n\tname_len = name && *name ? strlen (name) : 0,\n\tflags_len = flags && *flags ? strlen (flags) : 0,\n\ti = 0;\n\tif (desc_len == 0 || name == 0) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < desc_len; i++) {\n\t\tif (descriptor[i] == '(') {\n\t\t\tl_paren_pos = i;\n\t\t} else if (l_paren_pos != (ut32) - 1 && descriptor[i] == ')') {\n\t\t\tr_paren_pos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// handle field case;\n\tif (l_paren_pos == (ut32) - 1 && r_paren_pos == (ut32) - 1) {\n\t\tchar *unmangle_field_desc = NULL;\n\t\tut32 len = extract_type_value (descriptor, &unmangle_field_desc);\n\t\tif (len == 0) {\n\t\t\teprintf (\"Warning: attempting to unmangle invalid type descriptor.\\n\");\n\t\t\tfree (unmangle_field_desc);\n\t\t\treturn result;\n\t\t}\n\t\tif (flags_len > 0) {\n\t\t\tlen += (flags_len + name_len + 5); // space and null\n\t\t\tresult = malloc (len);\n\t\t\tsnprintf (result, len, \"%s %s %s\", flags, unmangle_field_desc, name);\n\t\t} else {\n\t\t\tlen += (name_len + 5); // space and null\n\t\t\tresult = malloc (len);\n\t\t\tsnprintf (result, len, \"%s %s\", unmangle_field_desc, name);\n\t\t}\n\t\tfree (unmangle_field_desc);\n\t} else if (l_paren_pos != (ut32) - 1 &&\n\tr_paren_pos != (ut32) - 1 &&\n\tl_paren_pos < r_paren_pos) {\n\t\t// params_len account for l_paren + 1 and null\n\t\tut32 params_len = r_paren_pos - (l_paren_pos + 1) != 0 ? r_paren_pos - (l_paren_pos + 1) + 1 : 0;\n\t\tchar *params = params_len ? malloc (params_len) : NULL;\n\t\tconst char *rvalue = descriptor + r_paren_pos + 1;\n\t\tif (params) {\n\t\t\tsnprintf (params, params_len, \"%s\", descriptor + l_paren_pos + 1);\n\t\t}\n\t\tresult = r_bin_java_unmangle_method (flags, name, params, rvalue);\n\t\tfree (params);\n\t}\n\treturn result;\n}\n\nR_API DsoJsonObj *r_bin_java_get_bin_obj_json(RBinJavaObj *bin) {\n\tDsoJsonObj *imports_list = r_bin_java_get_import_json_definitions (bin);\n\tDsoJsonObj *fields_list = r_bin_java_get_field_json_definitions (bin);\n\tDsoJsonObj *methods_list = r_bin_java_get_method_json_definitions (bin);\n\t// interfaces_list = r_bin_java_get_interface_json_definitions (bin);\n\tDsoJsonObj *class_dict = r_bin_java_get_class_info_json (bin);\n\tchar *res = dso_json_obj_to_str (methods_list);\n\t// eprintf (\"Resulting methods json: \\n%s\\n\", res);\n\tfree (res);\n\tdso_json_dict_insert_str_key_obj (class_dict, \"methods\", methods_list);\n\t// dso_json_list_free (methods_list);\n\tdso_json_obj_del (methods_list);\n\n\tres = dso_json_obj_to_str (fields_list);\n\t// eprintf (\"Resulting fields json: \\n%s\\n\", res);\n\tfree (res);\n\tdso_json_dict_insert_str_key_obj (class_dict, \"fields\", fields_list);\n\t// dso_json_list_free (fields_list);\n\tdso_json_obj_del (fields_list);\n\n\tres = dso_json_obj_to_str (imports_list);\n\t// eprintf (\"Resulting imports json: \\n%s\\n\", res);\n\tfree (res);\n\tdso_json_dict_insert_str_key_obj (class_dict, \"imports\", imports_list);\n\t// dso_json_list_free (imports_list);\n\tdso_json_obj_del (imports_list);\n\n\t// res = dso_json_obj_to_str (interfaces_list);\n\t// eprintf (\"Resulting interfaces json: \\n%s\\n\", res);\n\t// free (res);\n\t// dso_json_dict_insert_str_key_obj (class_dict, \"interfaces\", interfaces_list);\n\n\tres = dso_json_obj_to_str (class_dict);\n\t// eprintf (\"Resulting class info json: \\n%s\\n\", res);\n\tfree (res);\n\t// dso_json_obj_del (class_dict);\n\treturn class_dict;\n}\n\nR_API DsoJsonObj *r_bin_java_get_import_json_definitions(RBinJavaObj *bin) {\n\tRList *the_list;\n\tDsoJsonObj *json_list = dso_json_list_new ();\n\tRListIter *iter = NULL;\n\tchar *new_str;\n\n\tif (!bin || !(the_list = r_bin_java_get_lib_names (bin))) {\n\t\treturn json_list;\n\t}\n\n\tr_list_foreach (the_list, iter, new_str) {\n\t\tchar *tmp = new_str;\n\t\t// eprintf (\"Processing string: %s\\n\", new_str);\n\t\twhile (*tmp) {\n\t\t\tif (*tmp == '/') {\n\t\t\t\t*tmp = '.';\n\t\t\t}\n\t\t\ttmp++;\n\t\t}\n\t\t// eprintf (\"adding string: %s\\n\", new_str);\n\t\tdso_json_list_append_str (json_list, new_str);\n\t}\n\tr_list_free (the_list);\n\treturn json_list;\n}\n\nR_API DsoJsonObj *r_bin_java_get_class_info_json(RBinJavaObj *bin) {\n\tRList *classes = r_bin_java_get_classes (bin);\n\tDsoJsonObj *interfaces_list = dso_json_list_new ();\n\tDsoJsonObj *class_info_dict = dso_json_dict_new ();\n\tRBinClass *class_ = r_list_get_n (classes, 0);\n\n\tif (class_) {\n\t\tint dummy = 0;\n\t\tRListIter *iter;\n\t\tRBinClass *class_v = NULL;\n\t\t// add access flags like in methods\n\t\tbool is_public = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_PUBLIC) != 0);\n\t\tbool is_final = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_FINAL) != 0);\n\t\tbool is_super = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_SUPER) != 0);\n\t\tbool is_interface = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_INTERFACE) != 0);\n\t\tbool is_abstract = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_ABSTRACT) != 0);\n\t\tbool is_synthetic = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_SYNTHETIC) != 0);\n\t\tbool is_annotation = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_ANNOTATION) != 0);\n\t\tbool is_enum = ((class_->visibility & R_BIN_JAVA_CLASS_ACC_ENUM) != 0);\n\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"access_flags\", class_->visibility);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_public\", is_public);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_final\", is_final);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_super\", is_super);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_interface\", is_interface);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_abstract\", is_abstract);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_synthetic\", is_synthetic);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_annotation\", is_annotation);\n\t\tdso_json_dict_insert_str_key_num (class_info_dict, \"is_enum\", is_enum);\n\t\tdso_json_dict_insert_str_key_str (class_info_dict, \"name\", class_->name);\n\n\t\tif (!class_->super) {\n\t\t\tDsoJsonObj *str = dso_json_str_new ();\n\t\t\tdso_json_dict_insert_str_key_obj (class_info_dict, \"super\", str);\n\t\t\tdso_json_str_free (str);\n\t\t} else {\n\t\t\tdso_json_dict_insert_str_key_str (class_info_dict, \"super\", class_->super);\n\t\t}\n\n\t\tr_list_foreach (classes, iter, class_v) {\n\t\t\tif (!dummy) {\n\t\t\t\tdummy++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// enumerate all interface classes and append them to the interfaces\n\t\t\tif ((class_v->visibility & R_BIN_JAVA_CLASS_ACC_INTERFACE) != 0) {\n\t\t\t\tdso_json_list_append_str (interfaces_list, class_v->name);\n\t\t\t}\n\t\t}\n\t}\n\tdso_json_dict_insert_str_key_obj (class_info_dict, \"interfaces\", interfaces_list);\n\tr_list_free (classes);\n\t// dso_json_list_free (interfaces_list);\n\tdso_json_obj_del (interfaces_list);\n\treturn class_info_dict;\n}\n\nR_API DsoJsonObj *r_bin_java_get_interface_json_definitions(RBinJavaObj *bin) {\n\tRList *the_list;\n\tDsoJsonObj *json_list = dso_json_list_new ();\n\tRListIter *iter = NULL;\n\tchar *new_str;\n\n\tif (!bin || !(the_list = r_bin_java_get_interface_names (bin))) {\n\t\treturn json_list;\n\t}\n\n\tr_list_foreach (the_list, iter, new_str) {\n\t\tchar *tmp = new_str;\n\t\t// eprintf (\"Processing string: %s\\n\", new_str);\n\t\twhile (*tmp) {\n\t\t\tif (*tmp == '/') {\n\t\t\t\t*tmp = '.';\n\t\t\t}\n\t\t\ttmp++;\n\t\t}\n\t\t// eprintf (\"adding string: %s\\n\", new_str);\n\t\tdso_json_list_append_str (json_list, new_str);\n\t}\n\tr_list_free (the_list);\n\treturn json_list;\n}\n\nR_API DsoJsonObj *r_bin_java_get_method_json_definitions(RBinJavaObj *bin) {\n\tRBinJavaField *fm_type = NULL;\n\tRListIter *iter = NULL;\n\tDsoJsonObj *json_list = dso_json_list_new ();\n\tif (!bin) {\n\t\treturn json_list;\n\t}\n\tr_list_foreach (bin->methods_list, iter, fm_type) {\n\t\tDsoJsonObj *method_proto = r_bin_java_get_method_json_definition (bin, fm_type);\n\t\t// eprintf (\"Method json: %s\\n\", method_proto);\n\t\tdso_json_list_append (json_list, method_proto);\n\t}\n\treturn json_list;\n}\n\nR_API DsoJsonObj *r_bin_java_get_field_json_definitions(RBinJavaObj *bin) {\n\tRBinJavaField *fm_type = NULL;\n\tRListIter *iter = NULL;\n\tDsoJsonObj *json_list = dso_json_list_new ();\n\tif (!bin) {\n\t\treturn json_list;\n\t}\n\tr_list_foreach (bin->fields_list, iter, fm_type) {\n\t\tDsoJsonObj *field_proto = r_bin_java_get_field_json_definition (bin, fm_type);\n\t\t// eprintf (\"Field json: %s\\n\", field_proto);\n\t\tdso_json_list_append (json_list, field_proto);\n\t}\n\treturn json_list;\n}\n\nR_API char *r_bin_java_create_method_fq_str(const char *klass, const char *name, const char *signature) {\n\tif (!klass) {\n\t\tklass = \"null_class\";\n\t}\n\tif (!name) {\n\t\tname = \"null_name\";\n\t}\n\tif (!signature) {\n\t\tsignature = \"null_signature\";\n\t}\n\treturn r_str_newf (\"%s.%s.%s\", klass, name, signature);\n}\n\nR_API char *r_bin_java_create_field_fq_str(const char *klass, const char *name, const char *signature) {\n\tif (!klass) {\n\t\tklass = \"null_class\";\n\t}\n\tif (!name) {\n\t\tname = \"null_name\";\n\t}\n\tif (!signature) {\n\t\tsignature = \"null_signature\";\n\t}\n\treturn r_str_newf (\"%s %s.%s\", signature, klass, name);\n}\n\nR_API DsoJsonObj *r_bin_java_get_fm_type_definition_json(RBinJavaObj *bin, RBinJavaField *fm_type, int is_method) {\n\tut64 addr = UT64_MAX;\n\tchar *prototype = NULL, *fq_name = NULL;\n\tbool is_native = ((fm_type->flags & R_BIN_JAVA_METHOD_ACC_NATIVE) != 0);\n\tbool is_static = ((fm_type->flags & R_BIN_JAVA_METHOD_ACC_STATIC) != 0);\n\tbool is_synthetic = ((fm_type->flags & R_BIN_JAVA_METHOD_ACC_SYNTHETIC) != 0);\n\tbool is_private = ((fm_type->flags & R_BIN_JAVA_METHOD_ACC_PRIVATE) != 0);\n\tbool is_public = ((fm_type->flags & R_BIN_JAVA_METHOD_ACC_PUBLIC) != 0);\n\tbool is_protected = ((fm_type->flags & R_BIN_JAVA_METHOD_ACC_PROTECTED) != 0);\n\tbool is_super = ((fm_type->flags & R_BIN_JAVA_CLASS_ACC_SUPER) != 0);\n\n\tDsoJsonObj *fm_type_dict = dso_json_dict_new ();\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"access_flags\", fm_type->flags);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_method\", is_method);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_native\", is_native);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_synthetic\", is_synthetic);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_private\", is_private);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_public\", is_public);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_static\", is_static);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_protected\", is_protected);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"is_super\", is_super);\n\n\taddr = r_bin_java_get_method_code_offset (fm_type);\n\tif (addr == 0) {\n\t\taddr = fm_type->file_offset;\n\t}\n\taddr += bin->loadaddr;\n\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"addr\", addr);\n\tdso_json_dict_insert_str_key_num (fm_type_dict, \"offset\", fm_type->file_offset + bin->loadaddr);\n\tdso_json_dict_insert_str_key_str (fm_type_dict, \"class_name\", fm_type->class_name);\n\tdso_json_dict_insert_str_key_str (fm_type_dict, \"signature\", fm_type->descriptor);\n\tdso_json_dict_insert_str_key_str (fm_type_dict, \"name\", fm_type->name);\n\n\tif (is_method) {\n\t\tfq_name = r_bin_java_create_method_fq_str (fm_type->class_name, fm_type->name, fm_type->descriptor);\n\t} else {\n\t\tfq_name = r_bin_java_create_field_fq_str (fm_type->class_name, fm_type->name, fm_type->descriptor);\n\t}\n\tdso_json_dict_insert_str_key_str (fm_type_dict, \"fq_name\", fq_name);\n\n\tprototype = r_bin_java_unmangle (fm_type->flags_str, fm_type->name, fm_type->descriptor);\n\tdso_json_dict_insert_str_key_str (fm_type_dict, \"prototype\", prototype);\n\tfree (prototype);\n\tfree (fq_name);\n\treturn fm_type_dict;\n}\n\nR_API char *r_bin_java_get_method_definition(RBinJavaField *fm_type) {\n\treturn r_bin_java_unmangle (fm_type->flags_str, fm_type->name, fm_type->descriptor);\n}\n\nR_API char *r_bin_java_get_field_definition(RBinJavaField *fm_type) {\n\treturn r_bin_java_unmangle (fm_type->flags_str, fm_type->name, fm_type->descriptor);\n}\n\nR_API DsoJsonObj *r_bin_java_get_method_json_definition(RBinJavaObj *bin, RBinJavaField *fm_type) {\n\treturn r_bin_java_get_fm_type_definition_json (bin, fm_type, 1);\n}\n\nR_API DsoJsonObj *r_bin_java_get_field_json_definition(RBinJavaObj *bin, RBinJavaField *fm_type) {\n\treturn r_bin_java_get_fm_type_definition_json (bin, fm_type, 0);\n}\n\nR_API int r_bin_java_extract_reference_name(const char *input_str, char **ref_str, ut8 array_cnt) {\n\tchar *new_str = NULL;\n\tut32 str_len = array_cnt ? (array_cnt + 1) * 2 : 0;\n\tconst char *str_pos = input_str;\n\tint consumed = 0, len = 0;\n\tif (!str_pos || *str_pos != 'L' || !*str_pos) {\n\t\treturn -1;\n\t}\n\tconsumed++;\n\tstr_pos++;\n\twhile (*str_pos && *str_pos != ';') {\n\t\tstr_pos++;\n\t\tlen++;\n\t\tconsumed++;\n\t}\n\tstr_pos = input_str + 1;\n\tfree (*ref_str);\n\tstr_len += len;\n\t*ref_str = malloc (str_len + 1);\n\tnew_str = *ref_str;\n\tmemcpy (new_str, input_str + 1, str_len);\n\tnew_str[str_len] = 0;\n\twhile (*new_str) {\n\t\tif (*new_str == '/') {\n\t\t\t*new_str = '.';\n\t\t}\n\t\tnew_str++;\n\t}\n\treturn len + 2;\n}\n\nR_API void UNUSED_FUNCTION(r_bin_java_print_prototypes)(RBinJavaObj * bin) {\n\tRList *the_list = r_bin_java_get_method_definitions (bin);\n\tRListIter *iter;\n\tchar *str;\n\tr_list_foreach (the_list, iter, str) {\n\t\teprintf (\"%s;\\n\", str);\n\t}\n\tr_list_free (the_list);\n}\n\nR_API char *get_type_value_str(const char *arg_str, ut8 array_cnt) {\n\tut32 str_len = array_cnt ? (array_cnt + 1) * 2 + strlen (arg_str) : strlen (arg_str);\n\tchar *str = malloc (str_len + 1);\n\tut32 bytes_written = snprintf (str, str_len + 1, \"%s\", arg_str);\n\twhile (array_cnt > 0) {\n\t\tbytes_written = snprintf (str + bytes_written, str_len - bytes_written, \"[]\");\n\t\tarray_cnt--;\n\t}\n\treturn str;\n}\n\nR_API int extract_type_value(const char *arg_str, char **output) {\n\tut8 found_one = 0, array_cnt = 0;\n\tut32 len = 0, consumed = 0;\n\tchar *str = NULL;\n\tif (!arg_str || !output) {\n\t\treturn 0;\n\t}\n\tif (output && *output && *output != NULL) {\n\t\tfree (*output);\n\t\t*output = NULL;\n\t}\n\twhile (arg_str && *arg_str && !found_one) {\n\t\tlen = 0;\n\t\t// handle the end of an object\n\t\tswitch (*arg_str) {\n\t\tcase 'V':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"void\", array_cnt);\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"long\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"int\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"double\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"float\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"byte\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"char\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"boolean\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tlen = 1;\n\t\t\tstr = get_type_value_str (\"short\", array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase '[': len = 1; array_cnt++; break;\n\t\tcase 'L':\n\t\t\tlen = r_bin_java_extract_reference_name (arg_str, &str, array_cnt);\n\t\t\tarray_cnt = 0;\n\t\t\tbreak;\n\t\tcase '(': len = 1; str = strdup (\"(\"); break;\n\t\tcase ')': len = 1; str = strdup (\")\"); break;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\tif (len < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tconsumed += len;\n\t\targ_str += len;\n\t\tif (str) {\n\t\t\t*output = str;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn consumed;\n}\n\nR_API RList *r_bin_java_extract_type_values(const char *arg_str) {\n\tRList *list_args = r_list_new ();\n\tif (!list_args) {\n\t\treturn NULL;\n\t}\n\tchar *str = NULL;\n\tconst char *str_cur_pos = NULL;\n\tut32 len = 0;\n\tif (!arg_str) {\n\t\treturn list_args;\n\t}\n\tstr_cur_pos = arg_str;\n\tlist_args->free = free;\n\twhile (str_cur_pos && *str_cur_pos) {\n\t\t// handle the end of an object\n\t\tlen = extract_type_value (str_cur_pos, &str);\n\t\tif (len < 1) {\n\t\t\tr_list_free (list_args);\n\t\t\treturn NULL;\n\t\t}\n\t\tstr_cur_pos += len;\n\t\tr_list_append (list_args, str);\n\t\tstr = NULL;\n\t}\n\treturn list_args;\n}\n\nR_API int r_bin_java_is_fm_type_private(RBinJavaField *fm_type) {\n\tif (fm_type && fm_type->type == R_BIN_JAVA_FIELD_TYPE_METHOD) {\n\t\treturn fm_type->flags & R_BIN_JAVA_METHOD_ACC_PRIVATE;\n\t}\n\tif (fm_type && fm_type->type == R_BIN_JAVA_FIELD_TYPE_FIELD) {\n\t\treturn fm_type->flags & R_BIN_JAVA_FIELD_ACC_PRIVATE;\n\t}\n\treturn 0;\n}\n\nR_API int r_bin_java_is_fm_type_protected(RBinJavaField *fm_type) {\n\tif (fm_type && fm_type->type == R_BIN_JAVA_FIELD_TYPE_METHOD) {\n\t\treturn fm_type->flags & R_BIN_JAVA_METHOD_ACC_PROTECTED;\n\t}\n\tif (fm_type && fm_type->type == R_BIN_JAVA_FIELD_TYPE_FIELD) {\n\t\treturn fm_type->flags & R_BIN_JAVA_FIELD_ACC_PROTECTED;\n\t}\n\treturn 0;\n}\n\nR_API RList *r_bin_java_get_args(RBinJavaField *fm_type) {\n\tRList *the_list = r_bin_java_extract_type_values (fm_type->descriptor);\n\tRList *arg_list = r_list_new ();\n\tut8 in_args = 0;\n\tRListIter *desc_iter;\n\tchar *str;\n\tr_list_foreach (the_list, desc_iter, str) {\n\t\tif (str && *str == '(') {\n\t\t\tin_args = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (str && *str == ')') {\n\t\t\tbreak;\n\t\t}\n\t\tif (in_args) {\n\t\t\tr_list_append (arg_list, strdup (str));\n\t\t}\n\t}\n\tr_list_free (the_list);\n\treturn arg_list;\n}\n\nR_API RList *r_bin_java_get_ret(RBinJavaField *fm_type) {\n\tRList *the_list = r_bin_java_extract_type_values (fm_type->descriptor);\n\tRList *ret_list = r_list_new ();\n\tut8 in_ret = 0;\n\tRListIter *desc_iter;\n\tchar *str;\n\tr_list_foreach (the_list, desc_iter, str) {\n\t\tif (str && *str != ')') {\n\t\t\tin_ret = 0;\n\t\t}\n\t\tif (in_ret) {\n\t\t\tr_list_append (ret_list, strdup (str));\n\t\t}\n\t}\n\tr_list_free (the_list);\n\treturn ret_list;\n}\n\nR_API char *r_bin_java_get_this_class_name(RBinJavaObj *bin) {\n\treturn (bin->cf2.this_class_name ? strdup (bin->cf2.this_class_name) : strdup (\"unknown\"));\n}\n\nR_API ut16 calculate_access_value(const char *access_flags_str, RBinJavaAccessFlags *access_flags) {\n\tut16 result = 0;\n\tut16 size = strlen (access_flags_str) + 1;\n\tchar *p_flags, *my_flags = malloc (size);\n\tRBinJavaAccessFlags *iter = NULL;\n\tif (size < 5 || !my_flags) {\n\t\tfree (my_flags);\n\t\treturn result;\n\t}\n\tmemcpy (my_flags, access_flags_str, size);\n\tp_flags = strtok (my_flags, \" \");\n\twhile (p_flags && access_flags) {\n\t\tint idx = 0;\n\t\tdo {\n\t\t\titer = &access_flags[idx];\n\t\t\tif (!iter || !iter->str) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (iter->len > 0 && iter->len != 16) {\n\t\t\t\tif (!strncmp (iter->str, p_flags, iter->len)) {\n\t\t\t\t\tresult |= iter->value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidx++;\n\t\t} while (access_flags[idx].str != NULL);\n\t\tp_flags = strtok (NULL, \" \");\n\t}\n\tfree (my_flags);\n\treturn result;\n}\n\nR_API RList *retrieve_all_access_string_and_value(RBinJavaAccessFlags *access_flags) {\n\tconst char *fmt = \"%s = 0x%04x\";\n\tRList *result = r_list_new ();\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\tresult->free = free;\n\tint i = 0;\n\tfor (i = 0; access_flags[i].str != NULL; i++) {\n\t\tchar *str = malloc (50);\n\t\tif (!str) {\n\t\t\tr_list_free (result);\n\t\t\treturn NULL;\n\t\t}\n\t\tsnprintf (str, 49, fmt, access_flags[i].str, access_flags[i].value);\n\t\tr_list_append (result, str);\n\t}\n\treturn result;\n}\n\nR_API char *retrieve_access_string(ut16 flags, RBinJavaAccessFlags *access_flags) {\n\tchar *outbuffer = NULL, *cur_pos = NULL;\n\tut16 i;\n\tut16 max_str_len = 0;\n\tfor (i = 0; access_flags[i].str != NULL; i++) {\n\t\tif (flags & access_flags[i].value) {\n\t\t\tmax_str_len += (strlen (access_flags[i].str) + 1);\n\t\t\tif (max_str_len < strlen (access_flags[i].str)) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\tmax_str_len++;\n\toutbuffer = (char *) malloc (max_str_len);\n\tif (outbuffer) {\n\t\tmemset (outbuffer, 0, max_str_len);\n\t\tcur_pos = outbuffer;\n\t\tfor (i = 0; access_flags[i].str != NULL; i++) {\n\t\t\tif (flags & access_flags[i].value) {\n\t\t\t\tut8 len = strlen (access_flags[i].str);\n\t\t\t\tconst char *the_string = access_flags[i].str;\n\t\t\t\tmemcpy (cur_pos, the_string, len);\n\t\t\t\tmemcpy (cur_pos + len, \" \", 1);\n\t\t\t\tcur_pos += len + 1;\n\t\t\t}\n\t\t}\n\t\tif (cur_pos != outbuffer) {\n\t\t\t*(cur_pos - 1) = 0;\n\t\t}\n\t}\n\treturn outbuffer;\n}\n\nR_API char *retrieve_method_access_string(ut16 flags) {\n\treturn retrieve_access_string (flags, METHOD_ACCESS_FLAGS);\n}\n\nR_API char *retrieve_field_access_string(ut16 flags) {\n\treturn retrieve_access_string (flags, FIELD_ACCESS_FLAGS);\n}\n\nR_API char *retrieve_class_method_access_string(ut16 flags) {\n\treturn retrieve_access_string (flags, CLASS_ACCESS_FLAGS);\n}\n\nR_API char *r_bin_java_build_obj_key(RBinJavaObj *bin) {\n\tchar *jvcname = NULL;\n\tchar *cname = r_bin_java_get_this_class_name (bin);\n\tut32 class_name_len = cname ? strlen (cname) : strlen (\"_unknown_\");\n\tjvcname = malloc (class_name_len + 8 + 30);\n\tif (cname) {\n\t\tsnprintf (jvcname, class_name_len + 30, \"%d.%s.class\", bin->id, cname);\n\t\tfree (cname);\n\t} else {\n\t\tsnprintf (jvcname, class_name_len + 30, \"%d._unknown_.class\", bin->id);\n\t}\n\treturn jvcname;\n}\n\nR_API int sdb_iterate_build_list(void *user, const char *k, const char *v) {\n\tRList *bin_objs_list = (RList *) user;\n\tsize_t value = (size_t) sdb_atoi (v);\n\tRBinJavaObj *bin_obj = NULL;\n\tIFDBG eprintf(\"Found %s == %\"PFMT64x \" bin_objs db\\n\", k, (ut64) value);\n\tif (value != 0 && value != (size_t) -1) {\n\t\tbin_obj = (RBinJavaObj *) value;\n\t\tr_list_append (bin_objs_list, bin_obj);\n\t}\n\treturn true;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_get_java_null_cp() {\n\tif (R_BIN_JAVA_NULL_TYPE_INITTED) {\n\t\treturn &R_BIN_JAVA_NULL_TYPE;\n\t}\n\tmemset (&R_BIN_JAVA_NULL_TYPE, 0, sizeof (R_BIN_JAVA_NULL_TYPE));\n\tR_BIN_JAVA_NULL_TYPE.metas = R_NEW0 (RBinJavaMetaInfo);\n\tif (!R_BIN_JAVA_NULL_TYPE.metas) {\n\t\treturn NULL;\n\t}\n\tmemset (R_BIN_JAVA_NULL_TYPE.metas, 0, sizeof (RBinJavaMetaInfo));\n\tR_BIN_JAVA_NULL_TYPE.metas->type_info = &R_BIN_JAVA_CP_METAS[0];\n\tR_BIN_JAVA_NULL_TYPE.metas->ord = 0;\n\tR_BIN_JAVA_NULL_TYPE.file_offset = 0;\n\tR_BIN_JAVA_NULL_TYPE_INITTED = true;\n\treturn &R_BIN_JAVA_NULL_TYPE;\n}\n\nR_API RBinJavaElementValueMetas *r_bin_java_get_ev_meta_from_tag(ut8 tag) {\n\tut16 i = 0;\n\tRBinJavaElementValueMetas *res = &R_BIN_JAVA_ELEMENT_VALUE_METAS[13];\n\tfor (i = 0; i < R_BIN_JAVA_ELEMENT_VALUE_METAS_SZ; i++) {\n\t\tif (tag == R_BIN_JAVA_ELEMENT_VALUE_METAS[i].tag) {\n\t\t\tres = &R_BIN_JAVA_ELEMENT_VALUE_METAS[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API ut8 r_bin_java_quick_check(ut8 expected_tag, ut8 actual_tag, ut32 actual_len, const char *name) {\n\tut8 res = 0;\n\tif (expected_tag > R_BIN_JAVA_CP_METAS_SZ) {\n\t\teprintf (\"Invalid tag '%d' expected 0x%02x for %s.\\n\", actual_tag, expected_tag, name);\n\t\tres = 1;\n\t} else if (expected_tag != actual_tag)  {\n\t\teprintf (\"Invalid tag '%d' expected 0x%02x for %s.\\n\", actual_tag, expected_tag, name);\n\t\tres = 1;\n\t} else if (actual_len < R_BIN_JAVA_CP_METAS[expected_tag].len)  {\n\t\teprintf (\"Unable to parse '%d' expected sz=0x%02x got 0x%02x for %s.\\n\",\n\t\t\tactual_tag, R_BIN_JAVA_CP_METAS[expected_tag].len, actual_len, name);\n\t\tres = 2;\n\t}\n\treturn res;\n}\n\nR_API ut64 r_bin_java_raw_to_long(const ut8 *raw, ut64 offset) {\n\treturn R_BIN_JAVA_LONG (raw, offset);\n}\n// yanked from careercup, because i am lazy:\n// 1) dont want to figure out how make radare use math library\n// 2) dont feel like figuring it out when google does it in O(1).\nR_API double my_pow(ut64 base, int exp) {\n\tut8 flag = 0;\n\tut64 res = 1;\n\tif (exp < 0) {\n\t\tflag = 1;\n\t\texp *= -1;\n\t}\n\twhile (exp) {\n\t\tif (exp & 1) {\n\t\t\tres *= base;\n\t\t}\n\t\texp >>= 1;\n\t\tbase *= base;\n\t\tIFDBG eprintf(\"Result: %\"PFMT64d \", base: %\"PFMT64d \", exp: %d\\n\", res, base, exp);\n\t}\n\tif (flag == 0) {\n\t\treturn 1.0 * res;\n\t}\n\treturn (1.0 / res);\n}\n\nR_API double r_bin_java_raw_to_double(const ut8 *raw, ut64 offset) {\n\tut64 bits = R_BIN_JAVA_LONG (raw, offset);\n\tint s = ((bits >> 63) == 0) ? 1 : -1;\n\tint e = (int) ((bits >> 52) & 0x7ffL);\n\tlong m = (e == 0) ?\n\t(bits & 0xfffffffffffffLL) << 1 :\n\t(bits & 0xfffffffffffffLL) | 0x10000000000000LL;\n\tdouble res = 0.0;\n\tIFDBG eprintf(\"Convert Long to Double: %08\"PFMT64x \"\\n\", bits);\n\tif (bits == 0x7ff0000000000000LL) {\n\t\treturn INFINITY;\n\t}\n\tif (bits == 0xfff0000000000000LL) {\n\t\treturn -INFINITY;\n\t}\n\tif (0x7ff0000000000001LL <= bits && bits <= 0x7fffffffffffffffLL) {\n\t\treturn NAN;\n\t}\n\tif (0xfff0000000000001LL <= bits && bits <= 0xffffffffffffffffLL) {\n\t\treturn NAN;\n\t}\n\tres = s * m * my_pow (2, e - 1075);// XXXX TODO Get double to work correctly here\n\tIFDBG eprintf(\"\tHigh-bytes = %02x %02x %02x %02x\\n\", raw[0], raw[1], raw[2], raw[3]);\n\tIFDBG eprintf(\"\tLow-bytes = %02x %02x %02x %02x\\n\", raw[4], raw[5], raw[6], raw[7]);\n\tIFDBG eprintf(\"Convert Long to Double s: %d, m: 0x%08lx, e: 0x%08x, res: %f\\n\", s, m, e, res);\n\treturn res;\n}\n\nR_API RBinJavaField *r_bin_java_read_next_method(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tut32 i, idx;\n\tconst ut8 *f_buf = buf + offset;\n\tut64 adv = 0;\n\tRBinJavaCPTypeObj *item = NULL;\n\tRBinJavaField *method;\n\tif (bin == NULL) {\n\t\treturn NULL;\n\t}\n\tif (offset + 8 >= len) {\n\t\treturn NULL;\n\t}\n\tmethod = (RBinJavaField *) R_NEW0 (RBinJavaField);\n\tif (method == NULL) {\n\t\teprintf (\"Unable to allocate memory for method information\\n\");\n\t\treturn NULL;\n\t}\n\tmethod->metas = (RBinJavaMetaInfo *) R_NEW0 (RBinJavaMetaInfo);\n\tif (method->metas == NULL) {\n\t\teprintf (\"Unable to allocate memory for meta information\\n\");\n\t\tfree (method);\n\t\treturn NULL;\n\t}\n\tmethod->file_offset = offset;\n\tmethod->flags = R_BIN_JAVA_USHORT (f_buf, 0);\n\tmethod->flags_str = retrieve_method_access_string (method->flags);\n\t// need to subtract 1 for the idx\n\tmethod->name_idx = R_BIN_JAVA_USHORT (f_buf, 2);\n\tmethod->descriptor_idx = R_BIN_JAVA_USHORT (f_buf, 4);\n\tmethod->attr_count = R_BIN_JAVA_USHORT (f_buf, 6);\n\tmethod->attributes = r_list_newf (r_bin_java_attribute_free);\n\tmethod->type = R_BIN_JAVA_FIELD_TYPE_METHOD;\n\tmethod->metas->ord = bin->method_idx;\n\tadv += 8;\n\tidx = method->name_idx;\n\titem = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tmethod->name = r_bin_java_get_utf8_from_bin_cp_list (bin, (ut32) (method->name_idx));\n\tIFDBG eprintf(\"Method name_idx: %d, which is: ord: %d, name: %s, value: %s\\n\", idx, item->metas->ord, ((RBinJavaCPTypeMetas *)item->metas->type_info)->name, method->name);\n\tif (method->name == NULL) {\n\t\tmethod->name = (char *) malloc (21);\n\t\tsnprintf ((char *) method->name, 20, \"sym.method_%08x\", method->metas->ord);\n\t\tIFDBG eprintf(\"r_bin_java_read_next_method: Unable to find the name for 0x%02x index.\\n\", method->name_idx);\n\t}\n\tidx = method->descriptor_idx;\n\titem = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tmethod->descriptor = r_bin_java_get_utf8_from_bin_cp_list (bin, (ut32) method->descriptor_idx);\n\tIFDBG eprintf(\"Method descriptor_idx: %d, which is: ord: %d, name: %s, value: %s\\n\", idx, item->metas->ord, ((RBinJavaCPTypeMetas *)item->metas->type_info)->name, method->descriptor);\n\tif (method->descriptor == NULL) {\n\t\tmethod->descriptor = r_str_dup (NULL, \"NULL\");\n\t\tIFDBG eprintf(\"r_bin_java_read_next_method: Unable to find the descriptor for 0x%02x index.\\n\", method->descriptor_idx);\n\t}\n\tIFDBG eprintf(\"Looking for a NameAndType CP with name_idx: %d descriptor_idx: %d\\n\", method->name_idx, method->descriptor_idx);\n\tmethod->field_ref_cp_obj = r_bin_java_find_cp_ref_info_from_name_and_type (bin, method->name_idx, method->descriptor_idx);\n\tif (method->field_ref_cp_obj) {\n\t\tIFDBG eprintf(\"Found the obj.\\n\");\n\t\titem = r_bin_java_get_item_from_bin_cp_list (bin, method->field_ref_cp_obj->info.cp_method.class_idx);\n\t\tIFDBG eprintf(\"Method class reference value: %d, which is: ord: %d, name: %s\\n\", method->field_ref_cp_obj->info.cp_method.class_idx, item->metas->ord, ((RBinJavaCPTypeMetas *)item->metas->type_info)->name);\n\t\tmethod->class_name = r_bin_java_get_item_name_from_bin_cp_list (bin, item);\n\t\tIFDBG eprintf(\"Method requesting ref_cp_obj the following which is: ord: %d, name: %s\\n\", method->field_ref_cp_obj->metas->ord, ((RBinJavaCPTypeMetas *)method->field_ref_cp_obj->metas->type_info)->name);\n\t\tIFDBG eprintf(\"MethodRef class name resolves to: %s\\n\", method->class_name);\n\t\tif (method->class_name == NULL) {\n\t\t\tmethod->class_name = r_str_dup (NULL, \"NULL\");\n\t\t}\n\t} else {\n\t\t// XXX - default to this class?\n\t\tmethod->field_ref_cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, bin->cf2.this_class);\n\t\tmethod->class_name = r_bin_java_get_item_name_from_bin_cp_list (bin, method->field_ref_cp_obj);\n\t}\n\tIFDBG eprintf(\"Parsing %s(%s)\\n\", method->name, method->descriptor);\n\tif (method->attr_count > 0) {\n\t\tmethod->attr_offset = adv + offset;\n\t\tRBinJavaAttrInfo *attr = NULL;\n\t\tfor (i = 0; i < method->attr_count; i++) {\n\t\t\tattr = r_bin_java_read_next_attr (bin, adv + offset, buf, len);\n\t\t\tif (!attr) {\n\t\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Method Attribute: %d.\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((r_bin_java_get_attr_type_by_name (attr->name))->type == R_BIN_JAVA_ATTR_TYPE_CODE_ATTR) {\n\t\t\t\t// This is necessary for determing the appropriate number of bytes when readin\n\t\t\t\t// uoffset, ustack, ulocalvar values\n\t\t\t\tbin->cur_method_code_length = attr->info.code_attr.code_length;\n\t\t\t\tbin->offset_sz = 2;// (attr->info.code_attr.code_length > 65535) ? 4 : 2;\n\t\t\t\tbin->ustack_sz = 2;// (attr->info.code_attr.max_stack > 65535) ? 4 : 2;\n\t\t\t\tbin->ulocalvar_sz = 2;// (attr->info.code_attr.max_locals > 65535) ? 4 : 2;\n\t\t\t}\n\t\t\tIFDBG eprintf(\"Parsing @ 0x%\"PFMT64x \" (%s) = 0x%\"PFMT64x \" bytes\\n\", attr->file_offset, attr->name, attr->size);\n\t\t\tr_list_append (method->attributes, attr);\n\t\t\tadv += attr->size;\n\t\t\tif (adv + offset >= len) {\n\t\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Method Attribute: %d.\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmethod->size = adv;\n\t// reset after parsing the method attributes\n\tIFDBG eprintf(\"Parsing @ 0x%\"PFMT64x \" %s(%s) = 0x%\"PFMT64x \" bytes\\n\", method->file_offset, method->name, method->descriptor, method->size);\n\treturn method;\n}\n\nR_API RBinJavaField *r_bin_java_read_next_field(RBinJavaObj *bin, const ut64 offset, const ut8 *buffer, const ut64 len) {\n\tRBinJavaAttrInfo *attr;\n\tut32 i, idx;\n\tut8 buf[8];\n\tRBinJavaCPTypeObj *item = NULL;\n\tconst ut8 *f_buf = buffer + offset;\n\tut64 adv = 0;\n\tRBinJavaField *field;\n\tif (bin == NULL) {\n\t\treturn NULL;\n\t}\n\tif (offset + 8 >= len) {\n\t\treturn NULL;\n\t}\n\tfield = (RBinJavaField *) R_NEW0 (RBinJavaField);\n\tif (field == NULL) {\n\t\teprintf (\"Unable to allocate memory for field information\\n\");\n\t\treturn NULL;\n\t}\n\tfield->metas = (RBinJavaMetaInfo *) R_NEW0 (RBinJavaMetaInfo);\n\tif (field->metas == NULL) {\n\t\teprintf (\"Unable to allocate memory for meta information\\n\");\n\t\tfree (field);\n\t\treturn NULL;\n\t}\n\tmemcpy (buf, f_buf, 8);\n\tfield->file_offset = offset;\n\tfield->flags = R_BIN_JAVA_USHORT (buf, 0);\n\tfield->flags_str = retrieve_field_access_string (field->flags);\n\tfield->name_idx = R_BIN_JAVA_USHORT (buf, 2);\n\tfield->descriptor_idx = R_BIN_JAVA_USHORT (buf, 4);\n\tfield->attr_count = R_BIN_JAVA_USHORT (buf, 6);\n\tfield->attributes = r_list_newf (r_bin_java_attribute_free);\n\tfield->type = R_BIN_JAVA_FIELD_TYPE_FIELD;\n\tadv += 8;\n\tfield->metas->ord = bin->field_idx;\n\n\tidx = field->name_idx;\n\titem = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tfield->name = r_bin_java_get_utf8_from_bin_cp_list (bin, (ut32) (field->name_idx));\n\tIFDBG eprintf(\"Field name_idx: %d, which is: ord: %d, name: %s, value: %s\\n\", idx, item->metas->ord, ((RBinJavaCPTypeMetas *)item->metas->type_info)->name, field->name);\n\tif (field->name == NULL) {\n\t\tfield->name = (char *) malloc (21);\n\t\tsnprintf ((char *) field->name, 20, \"sym.field_%08x\", field->metas->ord);\n\t\tIFDBG eprintf(\"r_bin_java_read_next_field: Unable to find the name for 0x%02x index.\\n\", field->name_idx);\n\t}\n\tidx = field->descriptor_idx;\n\titem = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tfield->descriptor = r_bin_java_get_utf8_from_bin_cp_list (bin, (ut32) field->descriptor_idx);\n\tIFDBG eprintf(\"Field descriptor_idx: %d, which is: ord: %d, name: %s, value: %s\\n\", idx, item->metas->ord, ((RBinJavaCPTypeMetas *)item->metas->type_info)->name, field->descriptor);\n\tif (field->descriptor == NULL) {\n\t\tfield->descriptor = r_str_dup (NULL, \"NULL\");\n\t\tIFDBG eprintf(\"r_bin_java_read_next_field: Unable to find the descriptor for 0x%02x index.\\n\", field->descriptor_idx);\n\t}\n\tIFDBG eprintf(\"Looking for a NameAndType CP with name_idx: %d descriptor_idx: %d\\n\", field->name_idx, field->descriptor_idx);\n\tfield->field_ref_cp_obj = r_bin_java_find_cp_ref_info_from_name_and_type (bin, field->name_idx, field->descriptor_idx);\n\tif (field->field_ref_cp_obj) {\n\t\tIFDBG eprintf(\"Found the obj.\\n\");\n\t\titem = r_bin_java_get_item_from_bin_cp_list (bin, field->field_ref_cp_obj->info.cp_field.class_idx);\n\t\tIFDBG eprintf(\"Field class reference value: %d, which is: ord: %d, name: %s\\n\", field->field_ref_cp_obj->info.cp_field.class_idx, item->metas->ord, ((RBinJavaCPTypeMetas *)item->metas->type_info)->name);\n\t\tfield->class_name = r_bin_java_get_item_name_from_bin_cp_list (bin, item);\n\t\tIFDBG eprintf(\"Field requesting ref_cp_obj the following which is: ord: %d, name: %s\\n\", field->field_ref_cp_obj->metas->ord, ((RBinJavaCPTypeMetas *)field->field_ref_cp_obj->metas->type_info)->name);\n\t\tIFDBG eprintf(\"FieldRef class name resolves to: %s\\n\", field->class_name);\n\t\tif (field->class_name == NULL) {\n\t\t\tfield->class_name = r_str_dup (NULL, \"NULL\");\n\t\t}\n\t} else {\n\t\t// XXX - default to this class?\n\t\tfield->field_ref_cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, bin->cf2.this_class);\n\t\tfield->class_name = r_bin_java_get_item_name_from_bin_cp_list (bin, field->field_ref_cp_obj);\n\t}\n\tIFDBG eprintf(\"Parsing %s(%s)\", field->name, field->descriptor);\n\tif (field->attr_count > 0) {\n\t\tfield->attr_offset = adv + offset;\n\t\tfor (i = 0; i < field->attr_count && offset + adv < len; i++) {\n\t\t\tattr = r_bin_java_read_next_attr (bin, offset + adv, buffer, len);\n\t\t\tif (!attr) {\n\t\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Field Attribute: %d.\\n\", i);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif ((r_bin_java_get_attr_type_by_name (attr->name))->type == R_BIN_JAVA_ATTR_TYPE_CODE_ATTR) {\n\t\t\t\t// This is necessary for determing the appropriate number of bytes when readin\n\t\t\t\t// uoffset, ustack, ulocalvar values\n\t\t\t\tbin->cur_method_code_length = attr->info.code_attr.code_length;\n\t\t\t\tbin->offset_sz = 2;// (attr->info.code_attr.code_length > 65535) ? 4 : 2;\n\t\t\t\tbin->ustack_sz = 2;// (attr->info.code_attr.max_stack > 65535) ? 4 : 2;\n\t\t\t\tbin->ulocalvar_sz = 2;// (attr->info.code_attr.max_locals > 65535) ? 4 : 2;\n\t\t\t}\n\t\t\tr_list_append (field->attributes, attr);\n\t\t\tadv += attr->size;\n\t\t\tif (adv + offset >= len) {\n\t\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Field Attribute: %d.\\n\", i);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\tfield->size = adv;\n\treturn field;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_clone_cp_idx(RBinJavaObj *bin, ut32 idx) {\n\tRBinJavaCPTypeObj *obj = NULL;\n\tif (bin) {\n\t\tobj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\t}\n\treturn r_bin_java_clone_cp_item (obj);\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_clone_cp_item(RBinJavaCPTypeObj *obj) {\n\tRBinJavaCPTypeObj *clone_obj = NULL;\n\tif (obj == NULL) {\n\t\treturn clone_obj;\n\t}\n\tclone_obj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (clone_obj) {\n\t\tmemcpy (clone_obj, obj, sizeof (RBinJavaCPTypeObj));\n\t\tclone_obj->metas = (RBinJavaMetaInfo *) R_NEW0 (RBinJavaMetaInfo);\n\t\tclone_obj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[clone_obj->tag];\n\t\tclone_obj->name = strdup (obj->name? obj->name: \"unk\");\n\t\tif (obj->tag == R_BIN_JAVA_CP_UTF8) {\n\t\t\tclone_obj->info.cp_utf8.bytes = (ut8 *) malloc (obj->info.cp_utf8.length + 1);\n\t\t\tif (clone_obj->info.cp_utf8.bytes) {\n\t\t\t\tmemcpy (clone_obj->info.cp_utf8.bytes, obj->info.cp_utf8.bytes, clone_obj->info.cp_utf8.length);\n\t\t\t} else {\n\t\t\t\t// TODO: eprintf allocation error\n\t\t\t}\n\t\t}\n\t}\n\treturn clone_obj;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_read_next_constant_pool_item(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, ut64 len) {\n\tRBinJavaCPTypeMetas *java_constant_info = NULL;\n\tut8 tag = 0;\n\tut64 buf_sz = 0;\n\tut8 *cp_buf = NULL;\n\tut32 str_len = 0;\n\tRBinJavaCPTypeObj *java_obj = NULL;\n\ttag = buf[offset];\n\tif (tag > R_BIN_JAVA_CP_METAS_SZ) {\n\t\teprintf (\"Invalid tag '%d' at offset 0x%08\"PFMT64x \"\\n\", tag, (ut64) offset);\n\t\treturn NULL;\n#if 0\n\t\tjava_obj = r_bin_java_unknown_cp_new (bin, &tag, 1);\n\t\tif (java_obj != NULL && java_obj->metas != NULL) {\n\t\t\tjava_obj->file_offset = offset;\n\t\t\tjava_obj->loadaddr = bin->loadaddr;\n\t\t}\n\t\treturn NULL; // early error to avoid future overflows\n\t\t// return java_obj;\n#endif\n\t}\n\tjava_constant_info = &R_BIN_JAVA_CP_METAS[tag];\n\tif (java_constant_info->tag == 0 || java_constant_info->tag == 2) {\n\t\treturn java_obj;\n\t}\n\tbuf_sz += java_constant_info->len;\n\tif (java_constant_info->tag == 1) {\n\t\tif (offset + 32 < len) {\n\t\t\tstr_len = R_BIN_JAVA_USHORT (buf, offset + 1);\n\t\t\tbuf_sz += str_len;\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tcp_buf = calloc (buf_sz, 1);\n\tif (!cp_buf) {\n\t\treturn java_obj;\n\t}\n\tif (offset + buf_sz < len) {\n\t\tmemcpy (cp_buf, (ut8 *) buf + offset, buf_sz);\n\t\tIFDBG eprintf(\"Parsed the tag '%d':%s and create object from offset 0x%08\"PFMT64x \".\\n\", tag, R_BIN_JAVA_CP_METAS[tag].name, offset);\n\t\tjava_obj = (*java_constant_info->allocs->new_obj)(bin, cp_buf, buf_sz);\n\t\tif (java_obj != NULL && java_obj->metas != NULL) {\n\t\t\tjava_obj->file_offset = offset;\n\t\t\t// IFDBG eprintf (\"java_obj->file_offset = 0x%08\"PFMT64x\".\\n\",java_obj->file_offset);\n\t\t} else if (!java_obj) {\n\t\t\teprintf (\"Unable to parse the tag '%d' and create valid object.\\n\", tag);\n\t\t} else if (!java_obj->metas) {\n\t\t\teprintf (\"Unable to parse the tag '%d' and create valid object.\\n\", tag);\n\t\t} else {\n\t\t\teprintf (\"Failed to set the java_obj->metas-file_offset for '%d' offset is(0x%08\"PFMT64x \").\\n\", tag, offset);\n\t\t}\n\t}\n\tfree (cp_buf);\n\treturn java_obj;\n}\n\nR_API RBinJavaInterfaceInfo *r_bin_java_read_next_interface_item(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tut8 idx[2] = {\n\t\t0\n\t};\n\tRBinJavaInterfaceInfo *ifobj;\n\tconst ut8 *if_buf = buf + offset;\n\tif (offset + 2 >= len) {\n\t\treturn NULL;\n\t}\n\tmemcpy (&idx, if_buf, 2);\n\tifobj = r_bin_java_interface_new (bin, if_buf, len - offset);\n\tif (ifobj) {\n\t\tifobj->file_offset = offset;\n\t}\n\treturn ifobj;\n}\n// R_API void addrow (RBinJavaObj *bin, int addr, int line) {\n// int n = bin->lines.count++;\n//// XXX. possible memleak\n// bin->lines.addr = realloc (bin->lines.addr, sizeof (int)*n+1);\n// bin->lines.addr[n] = addr;\n// bin->lines.line = realloc (bin->lines.line, sizeof (int)*n+1);\n// bin->lines.line[n] = line;\n// }\n// R_API struct r_bin_java_cp_item_t* r_bin_java_get_item_from_cp_CP(RBinJavaObj *bin, int i) {\n// return (i<0||i>bin->cf.cp_count)? &cp_null_item: &bin->cp_items[i];\n// }\n\nR_API char *r_bin_java_get_utf8_from_bin_cp_list(RBinJavaObj *bin, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: new char* for caller to free.\n\t*/\n\tif (bin == NULL) {\n\t\treturn NULL;\n\t}\n\treturn r_bin_java_get_utf8_from_cp_item_list (bin->cp_list, idx);\n}\n\nR_API ut32 r_bin_java_get_utf8_len_from_bin_cp_list(RBinJavaObj *bin, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: new char* for caller to free.\n\t*/\n\tif (bin == NULL) {\n\t\treturn 0;\n\t}\n\treturn r_bin_java_get_utf8_len_from_cp_item_list (bin->cp_list, idx);\n}\n\nR_API char *r_bin_java_get_name_from_bin_cp_list(RBinJavaObj *bin, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: new char* for caller to free.\n\t*/\n\tif (bin == NULL) {\n\t\treturn NULL;\n\t}\n\treturn r_bin_java_get_name_from_cp_item_list (bin->cp_list, idx);\n}\n\nR_API char *r_bin_java_get_desc_from_bin_cp_list(RBinJavaObj *bin, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: new char* for caller to free.\n\t*/\n\tif (bin == NULL) {\n\t\treturn NULL;\n\t}\n\treturn r_bin_java_get_desc_from_cp_item_list (bin->cp_list, idx);\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_get_item_from_bin_cp_list(RBinJavaObj *bin, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: RBinJavaObj* (user does NOT free).\n\t*/\n\tif (bin == NULL) {\n\t\treturn NULL;\n\t}\n\tif (idx > bin->cp_count || idx == 0) {\n\t\treturn r_bin_java_get_java_null_cp ();\n\t}\n\treturn r_bin_java_get_item_from_cp_item_list (bin->cp_list, idx);\n}\n\nR_API char *r_bin_java_get_item_name_from_bin_cp_list(RBinJavaObj *bin, RBinJavaCPTypeObj *obj) {\n\tchar *res = NULL;\n\t/*\n\tGiven a constant poool object Class, FieldRef, MethodRef, or InterfaceMethodRef\n\treturn the actual descriptor string.\n\t@param cp_list: RList of RBinJavaCPTypeObj *\n\t@param obj object to look up the name for\n\t@rvalue char* (user frees) or NULL\n\t*/\n\tif (bin && obj) {\n\t\tres = r_bin_java_get_item_name_from_cp_item_list (\n\t\t\tbin->cp_list, obj, MAX_CPITEMS);\n\t}\n\treturn res;\n}\n\nR_API char *r_bin_java_get_item_desc_from_bin_cp_list(RBinJavaObj *bin, RBinJavaCPTypeObj *obj) {\n\t/*\n\tGiven a constant poool object Class, FieldRef, MethodRef, or InterfaceMethodRef\n\treturn the actual descriptor string.\n\t@param cp_list: RList of RBinJavaCPTypeObj *\n\t@param obj object to look up the name for\n\t@rvalue char* (user frees) or NULL\n\t*/\n\tif (bin == NULL) {\n\t\treturn NULL;\n\t}\n\treturn r_bin_java_get_item_desc_from_cp_item_list (bin->cp_list, obj, MAX_CPITEMS);\n}\n\nR_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: new char* for caller to free.\n\t*/\n\tchar *value = NULL;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *item = NULL;\n\tif (cp_list == NULL) {\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);\n\tif (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {\n\t\tvalue = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);\n\t}\n\tif (value == NULL) {\n\t\tr_list_foreach (cp_list, iter, item) {\n\t\t\tif (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {\n\t\t\t\tvalue = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API ut32 r_bin_java_get_utf8_len_from_cp_item_list(RList *cp_list, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\tIf the idx not found by directly going to the list index,\n\tthe list will be walked and then the IDX will be checked.\n\trvalue: new ut32 .\n\t*/\n\tut32 value = -1;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *item = NULL;\n\tif (cp_list == NULL) {\n\t\treturn 0;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);\n\tif (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {\n\t\tvalue = item->info.cp_utf8.length;\n\t}\n\tif (value == -1) {\n\t\tr_list_foreach (cp_list, iter, item) {\n\t\t\tif (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {\n\t\t\t\tvalue = item->info.cp_utf8.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp_item_list(RList *cp_list, ut64 idx) {\n\t/*\n\tSearch through the Constant Pool list for the given CP Index.\n\trvalue: RBinJavaObj *\n\t*/\n\tRBinJavaCPTypeObj *item = NULL;\n\tif (cp_list == NULL) {\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);\n\treturn item;\n}\n\nR_API char *r_bin_java_get_item_name_from_cp_item_list(RList *cp_list, RBinJavaCPTypeObj *obj, int depth) {\n\t/*\n\tGiven a constant poool object Class, FieldRef, MethodRef, or InterfaceMethodRef\n\treturn the actual descriptor string.\n\t@param cp_list: RList of RBinJavaCPTypeObj *\n\t@param obj object to look up the name for\n\t@rvalue ut8* (user frees) or NULL\n\t*/\n\tif (obj == NULL || cp_list == NULL || depth < 0) {\n\t\treturn NULL;\n\t}\n\tswitch (obj->tag) {\n\tcase R_BIN_JAVA_CP_NAMEANDTYPE:\n\t\treturn r_bin_java_get_utf8_from_cp_item_list (\n\t\t\tcp_list, obj->info.cp_name_and_type.name_idx);\n\tcase R_BIN_JAVA_CP_CLASS:\n\t\treturn r_bin_java_get_utf8_from_cp_item_list (\n\t\t\tcp_list, obj->info.cp_class.name_idx);\n\t// XXX - Probably not good form, but they are the same memory structure\n\tcase R_BIN_JAVA_CP_FIELDREF:\n\tcase R_BIN_JAVA_CP_INTERFACEMETHOD_REF:\n\tcase R_BIN_JAVA_CP_METHODREF:\n\t\tobj = r_bin_java_get_item_from_cp_item_list (\n\t\t\tcp_list, obj->info.cp_method.name_and_type_idx);\n\t\treturn r_bin_java_get_item_name_from_cp_item_list (\n\t\t\tcp_list, obj, depth - 1);\n\tdefault:\n\t\treturn NULL;\n\tcase 0:\n\t\tIFDBG eprintf(\"Invalid 0 tag in the constant pool\\n\");\n\t\treturn NULL;\n\t}\n\treturn NULL;\n}\n\nR_API char *r_bin_java_get_name_from_cp_item_list(RList *cp_list, ut64 idx) {\n\t/*\n\tGiven a constant poool object Class, FieldRef, MethodRef, or InterfaceMethodRef\n\treturn the actual descriptor string.\n\t@param cp_list: RList of RBinJavaCPTypeObj *\n\t@param obj object to look up the name for\n\t@rvalue ut8* (user frees) or NULL\n\t*/\n\tRBinJavaCPTypeObj *obj = r_bin_java_get_item_from_cp_item_list (\n\t\tcp_list, idx);\n\tif (obj && cp_list) {\n\t\treturn r_bin_java_get_item_name_from_cp_item_list (\n\t\t\tcp_list, obj, MAX_CPITEMS);\n\t}\n\treturn NULL;\n}\n\nR_API char *r_bin_java_get_item_desc_from_cp_item_list(RList *cp_list, RBinJavaCPTypeObj *obj, int depth) {\n\t/*\n\tGiven a constant poool object FieldRef, MethodRef, or InterfaceMethodRef\n\treturn the actual descriptor string.\n\t@rvalue ut8* (user frees) or NULL\n\t*/\n\tif (!obj || !cp_list || depth < 0) {\n\t\treturn NULL;\n\t}\n\tswitch (obj->tag) {\n\tcase R_BIN_JAVA_CP_NAMEANDTYPE:\n\t\treturn r_bin_java_get_utf8_from_cp_item_list (cp_list,\n\t\t\tobj->info.cp_name_and_type.descriptor_idx);\n\t// XXX - Probably not good form, but they are the same memory structure\n\tcase R_BIN_JAVA_CP_FIELDREF:\n\tcase R_BIN_JAVA_CP_INTERFACEMETHOD_REF:\n\tcase R_BIN_JAVA_CP_METHODREF:\n\t\tobj = r_bin_java_get_item_from_cp_item_list (cp_list,\n\t\t\tobj->info.cp_method.name_and_type_idx);\n\t\treturn r_bin_java_get_item_desc_from_cp_item_list (\n\t\t\tcp_list, obj, depth - 1);\n\tdefault:\n\t\treturn NULL;\n\t}\n\treturn NULL;\n}\n\nR_API char *r_bin_java_get_desc_from_cp_item_list(RList *cp_list, ut64 idx) {\n\t/*\n\tGiven a constant poool object FieldRef, MethodRef, or InterfaceMethodRef\n\treturn the actual descriptor string.\n\t@rvalue ut8* (user frees) or NULL\n\t*/\n\tRBinJavaCPTypeObj *obj = r_bin_java_get_item_from_cp_item_list (cp_list, idx);\n\tif (cp_list == NULL) {\n\t\treturn NULL;\n\t}\n\treturn r_bin_java_get_item_desc_from_cp_item_list (cp_list, obj, MAX_CPITEMS);\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_get_method_code_attribute(const RBinJavaField *method) {\n\t/*\n\tSearch through a methods attributes and return the code attr.\n\trvalue: RBinJavaAttrInfo* if found otherwise NULL.\n\t*/\n\tRBinJavaAttrInfo *res = NULL, *attr = NULL;\n\tRListIter *iter;\n\tif (method) {\n\t\tr_list_foreach (method->attributes, iter, attr) {\n\t\t\tif (attr && (attr->type == R_BIN_JAVA_ATTR_TYPE_CODE_ATTR)) {\n\t\t\t\tres = attr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_get_attr_from_field(RBinJavaField *field, R_BIN_JAVA_ATTR_TYPE attr_type, ut32 pos) {\n\t/*\n\tSearch through the Attribute list for the given type starting at position pos.\n\trvalue: NULL or the first occurrence of attr_type after pos\n\t*/\n\tRBinJavaAttrInfo *attr = NULL, *item;\n\tRListIter *iter;\n\tut32 i = 0;\n\tif (field) {\n\t\tr_list_foreach (field->attributes, iter, item) {\n\t\t\t// Note the increment happens after the comparison\n\t\t\tif ((i++) >= pos) {\n\t\t\t\tif (item && (item->type == attr_type)) {\n\t\t\t\t\tattr = item;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn attr;\n}\n\nR_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tut8 *attr_buf = NULL;\n\tint pending = len - offset;\n\tconst ut8 *a_buf = offset + buf;\n\tattr_buf = (ut8 *) calloc (pending + 1, 1);\n\tif (attr_buf == NULL) {\n\t\teprintf (\"Unable to allocate enough bytes (0x%04\"PFMT64x\n\t\t\t\") to read in the attribute.\\n\", sz);\n\t\treturn attr_buf;\n\t}\n\tmemcpy (attr_buf, a_buf, pending); // sz+1);\n\treturn attr_buf;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_default_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\t// NOTE: this function receives the buffer offset in the original buffer,\n\t// but the buffer is already point to that particular offset.\n\t// XXX - all the code that relies on this function should probably be modified\n\t// so that the original buffer pointer is passed in and then the buffer+buf_offset\n\t// points to the correct location.\n\tRBinJavaAttrInfo *attr = R_NEW0 (RBinJavaAttrInfo);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrMetas *type_info = NULL;\n\tattr->metas = R_NEW0 (RBinJavaMetaInfo);\n\tif (attr->metas == NULL) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tattr->file_offset = buf_offset;\n\tattr->name_idx = R_BIN_JAVA_USHORT (buffer, 0);\n\tattr->length = R_BIN_JAVA_UINT (buffer, 2);\n\tattr->size = R_BIN_JAVA_UINT (buffer, 2) + 6;\n\tattr->name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->name_idx);\n\tif (attr->name == NULL) {\n\t\t// Something bad has happened\n\t\tattr->name = r_str_dup (NULL, \"NULL\");\n\t\teprintf (\"r_bin_java_default_attr_new: Unable to find the name for %d index.\\n\", attr->name_idx);\n\t}\n\ttype_info = r_bin_java_get_attr_type_by_name (attr->name);\n\tattr->metas->ord = (R_BIN_JAVA_GLOBAL_BIN->attr_idx++);\n\tattr->metas->type_info = (void *) type_info;\n\t// IFDBG eprintf (\"\tAddrs for type_info [tag=%d]: 0x%08\"PFMT64x\"\\n\", type_val, &attr->metas->type_info);\n\treturn attr;\n}\n\nR_API RBinJavaAttrMetas *r_bin_java_get_attr_type_by_name(const char *name) {\n\t// TODO: use sdb/hashtable here\n\tint i;\n\tfor (i = 0; i < RBIN_JAVA_ATTRS_METAS_SZ; i++) {\n\t\tif (!strcmp ((const char *) name, RBIN_JAVA_ATTRS_METAS[i].name)) {\n\t\t\treturn &RBIN_JAVA_ATTRS_METAS[i];\n\t\t}\n\t}\n\treturn &RBIN_JAVA_ATTRS_METAS[R_BIN_JAVA_ATTR_TYPE_UNKNOWN_ATTR];\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_read_next_attr(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 buf_len) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tut32 sz = 0;\n\tut8 *buffer = NULL;\n\tconst ut8 *a_buf = offset + buf;\n\tut8 attr_idx_len = 6;\n\tif (offset + 6 > buf_len) {\n\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile in Attribute offset \"\n\t\t\t\"(0x%\"PFMT64x \") > len  of remaining bytes (0x%\"PFMT64x \").\\n\", offset, buf_len);\n\t\treturn NULL;\n\t}\n\t// ut16 attr_idx, ut32 length of attr.\n\tsz = R_BIN_JAVA_UINT (a_buf, 2) + attr_idx_len; // r_bin_java_read_int (bin, buf_offset+2) + attr_idx_len;\n\tif (sz + offset > buf_len) {\n\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile in Attribute len \"\n\t\t\t\"(0x%x) + offset (0x%\"PFMT64x \") exceeds length of buffer (0x%\"PFMT64x \").\\n\",\n\t\t\tsz, offset, buf_len);\n\t\treturn NULL;\n\t}\n\t// when reading the attr bytes, need to also\n\t// include the initial 6 bytes, which\n\t// are not included in the attribute length\n\t// ,\n\t// sz, buf_offset, buf_offset+sz);\n\tbuffer = r_bin_java_get_attr_buf (bin, sz, offset, buf, buf_len);\n\t// printf (\"%d %d %d\\n\", sz, buf_len, offset);\n\tif (offset < buf_len) {\n\t\tattr = r_bin_java_read_next_attr_from_buffer (buffer, buf_len - offset, offset);\n\t\tfree (buffer);\n\n\t\tif (!attr) {\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->size = sz;\n\t} else {\n\t\teprintf (\"IS OOB\\n\");\n\t}\n\treturn attr;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_read_next_attr_from_buffer(ut8 *buffer, st64 sz, st64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tut16 name_idx;\n\tst64 nsz;\n\n\tif (!buffer || ((int) sz) < 4 || buf_offset < 0) {\n\t\teprintf (\"r_bin_Java_read_next_attr_from_buffer: invalid buffer size %d\\n\", (int) sz);\n\t\treturn NULL;\n\t}\n\tname_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tnsz = R_BIN_JAVA_UINT (buffer, offset);\n\toffset += 4;\n\n\tchar *name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, name_idx);\n\tif (!name) {\n\t\tname = strdup (\"unknown\");\n\t}\n\tIFDBG eprintf(\"r_bin_java_read_next_attr: name_idx = %d is %s\\n\", name_idx, name);\n\tRBinJavaAttrMetas *type_info = r_bin_java_get_attr_type_by_name (name);\n\tif (type_info) {\n\t\tIFDBG eprintf(\"Typeinfo: %s, was %s\\n\", type_info->name, name);\n\t\t// printf (\"SZ %d %d %d\\n\", nsz, sz, buf_offset);\n\t\tif (nsz > sz) {\n\t\t\tfree (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((attr = type_info->allocs->new_obj (buffer, nsz, buf_offset))) {\n\t\t\tattr->metas->ord = (R_BIN_JAVA_GLOBAL_BIN->attr_idx++);\n\t\t}\n\t} else {\n\t\teprintf (\"r_bin_java_read_next_attr_from_buffer: Cannot find type_info for %s\\n\", name);\n\t}\n\tfree (name);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_read_class_file2(RBinJavaObj *bin, const ut64 offset, const ut8 *obuf, ut64 len) {\n\tconst ut8 *cf2_buf = obuf + offset;\n\tRBinJavaCPTypeObj *this_class_cp_obj = NULL;\n\tIFDBG eprintf(\"\\n0x%\"PFMT64x \" Offset before reading the cf2 structure\\n\", offset);\n\t/*\n\tReading the following fields:\n\tut16 access_flags;\n\tut16 this_class;\n\tut16 super_class;\n\t*/\n\tif (cf2_buf + 6 > obuf + len) {\n\t\treturn 0;\n\t}\n\tbin->cf2.cf2_size = 6;\n\tbin->cf2.access_flags = R_BIN_JAVA_USHORT (cf2_buf, 0);\n\tbin->cf2.this_class = R_BIN_JAVA_USHORT (cf2_buf, 2);\n\tbin->cf2.super_class = R_BIN_JAVA_USHORT (cf2_buf, 4);\n\tfree (bin->cf2.flags_str);\n\tfree (bin->cf2.this_class_name);\n\tbin->cf2.flags_str = retrieve_class_method_access_string (bin->cf2.access_flags);\n\tthis_class_cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, bin->cf2.this_class);\n\tbin->cf2.this_class_name = r_bin_java_get_item_name_from_bin_cp_list (bin, this_class_cp_obj);\n\tIFDBG eprintf(\"This class flags are: %s\\n\", bin->cf2.flags_str);\n\treturn bin->cf2.cf2_size;\n}\n\nR_API ut64 r_bin_java_parse_cp_pool(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tint ord = 0;\n\tut64 adv = 0;\n\tRBinJavaCPTypeObj *obj = NULL;\n\tconst ut8 *cp_buf = buf + offset;\n\tr_list_free (bin->cp_list);\n\tbin->cp_list = r_list_newf (r_bin_java_constant_pool);\n\tbin->cp_offset = offset;\n\tmemcpy ((char *) &bin->cp_count, cp_buf, 2);\n\tbin->cp_count = R_BIN_JAVA_USHORT (cp_buf, 0) - 1;\n\tadv += 2;\n\tIFDBG eprintf(\"ConstantPoolCount %d\\n\", bin->cp_count);\n\tr_list_append (bin->cp_list, r_bin_java_get_java_null_cp ());\n\tfor (ord = 1, bin->cp_idx = 0; bin->cp_idx < bin->cp_count && adv < len; ord++, bin->cp_idx++) {\n\t\tobj = r_bin_java_read_next_constant_pool_item (bin, offset + adv, buf, len);\n\t\tif (obj) {\n\t\t\t// IFDBG eprintf (\"SUCCESS Read ConstantPoolItem %d\\n\", i);\n\t\t\tobj->metas->ord = ord;\n\t\t\tobj->idx = ord;\n\t\t\tr_list_append (bin->cp_list, obj);\n\t\t\tif (obj->tag == R_BIN_JAVA_CP_LONG || obj->tag == R_BIN_JAVA_CP_DOUBLE) {\n\t\t\t\t// i++;\n\t\t\t\tord++;\n\t\t\t\tbin->cp_idx++;\n\t\t\t\tr_list_append (bin->cp_list, &R_BIN_JAVA_NULL_TYPE);\n\t\t\t}\n\n\t\t\tIFDBG ((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->print_summary (obj);\n\t\t\tadv += ((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->calc_size (obj);\n\t\t\tif (offset + adv > len) {\n\t\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Constant Pool Object: %d.\\n\", ord);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tIFDBG eprintf(\"Failed to read ConstantPoolItem %d\\n\", bin->cp_idx);\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Update the imports\n\tr_bin_java_set_imports (bin);\n\tbin->cp_size = adv;\n\treturn bin->cp_size;\n}\n\nR_API ut64 r_bin_java_parse_interfaces(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tint i = 0;\n\tut64 adv = 0;\n\tRBinJavaInterfaceInfo *interfaces_obj;\n\tconst ut8 *if_buf = buf + offset;\n\tbin->cp_offset = offset;\n\tbin->interfaces_offset = offset;\n\tr_list_free (bin->interfaces_list);\n\tbin->interfaces_list = r_list_newf (r_bin_java_interface_free);\n\tif (offset + 2 > len) {\n\t\tbin->interfaces_size = 0;\n\t\treturn 0;\n\t}\n\tbin->interfaces_count = R_BIN_JAVA_USHORT (if_buf, 0);\n\tadv += 2;\n\tIFDBG eprintf(\"Interfaces count: %d\\n\", bin->interfaces_count);\n\tif (bin->interfaces_count > 0) {\n\t\tfor (i = 0; i < bin->interfaces_count; i++) {\n\t\t\tinterfaces_obj = r_bin_java_read_next_interface_item (bin, offset + adv, buf, len);\n\t\t\tif (interfaces_obj) {\n\t\t\t\tr_list_append (bin->interfaces_list, interfaces_obj);\n\t\t\t\tadv += interfaces_obj->size;\n\t\t\t\tif (offset + adv > len) {\n\t\t\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Interface: %d.\\n\", i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbin->interfaces_size = adv;\n\treturn adv;\n}\n\nR_API ut64 r_bin_java_parse_fields(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tint i = 0;\n\tut64 adv = 0;\n\tRBinJavaField *field;\n\tconst ut8 *fm_buf = buf + offset;\n\tr_list_free (bin->fields_list);\n\tbin->fields_list = r_list_newf (r_bin_java_fmtype_free);\n\tbin->fields_offset = offset;\n\tif (offset + 2 >= len) {\n\t\treturn UT64_MAX;\n\t}\n\tbin->fields_count = R_BIN_JAVA_USHORT (fm_buf, 0);\n\tadv += 2;\n\tIFDBG eprintf(\"Fields count: %d 0x%\"PFMT64x \"\\n\", bin->fields_count, bin->fields_offset);\n\tif (bin->fields_count > 0) {\n\t\tfor (i = 0; i < bin->fields_count; i++, bin->field_idx++) {\n\t\t\tfield = r_bin_java_read_next_field (bin, offset + adv, buf, len);\n\t\t\tif (field) {\n\t\t\t\tadv += field->size;\n\t\t\t\tr_list_append (bin->fields_list, field);\n\t\t\t\tIFDBG r_bin_java_print_field_summary(field);\n\t\t\t\tif (adv + offset > len) {\n\t\t\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Field: %d.\\n\", i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tIFDBG eprintf(\"Failed to read Field %d\\n\", i);\n\t\t\t}\n\t\t}\n\t}\n\tbin->fields_size = adv;\n\treturn adv;\n}\n\nR_API ut64 r_bin_java_parse_attrs(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tint i = 0;\n\tut64 adv = 0;\n\tconst ut8 *a_buf = buf + offset;\n\tif (offset + 2 >= len) {\n\t\t// Check if we can read that USHORT\n\t\treturn UT64_MAX;\n\t}\n\tr_list_free (bin->attrs_list);\n\tbin->attrs_list = r_list_newf (r_bin_java_attribute_free);\n\tbin->attrs_offset = offset;\n\tbin->attrs_count = R_BIN_JAVA_USHORT (a_buf, adv);\n\tadv += 2;\n\tif (bin->attrs_count > 0) {\n\t\tfor (i = 0; i < bin->attrs_count; i++, bin->attr_idx++) {\n\t\t\tRBinJavaAttrInfo *attr = r_bin_java_read_next_attr (bin, offset + adv, buf, len);\n\t\t\tif (!attr) {\n\t\t\t\t// eprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Attribute: %d.\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (bin->attrs_list, attr);\n\t\t\tadv += attr->size;\n\t\t\tif (adv + offset >= len) {\n\t\t\t\t// eprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Attribute: %d.\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbin->attrs_size = adv;\n\treturn adv;\n}\n\nR_API ut64 r_bin_java_parse_methods(RBinJavaObj *bin, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tint i = 0;\n\tut64 adv = 0;\n\tRBinJavaField *method;\n\tconst ut8 *fm_buf = buf + offset;\n\tr_list_free (bin->methods_list);\n\tbin->methods_list = r_list_newf (r_bin_java_fmtype_free);\n\n\tif (offset + 2 >= len) {\n\t\treturn 0LL;\n\t}\n\tbin->methods_offset = offset;\n\tbin->methods_count = R_BIN_JAVA_USHORT (fm_buf, 0);\n\tadv += 2;\n\tIFDBG eprintf(\"Methods count: %d 0x%\"PFMT64x \"\\n\", bin->methods_count, bin->methods_offset);\n\tbin->main = NULL;\n\tbin->entrypoint = NULL;\n\tbin->main_code_attr = NULL;\n\tbin->entrypoint_code_attr = NULL;\n\tfor (i = 0; i < bin->methods_count; i++, bin->method_idx++) {\n\t\tmethod = r_bin_java_read_next_method (bin, offset + adv, buf, len);\n\t\tif (method) {\n\t\t\tadv += method->size;\n\t\t\tr_list_append (bin->methods_list, method);\n\t\t}\n\t\t// Update Main, Init, or Class Init\n\t\tif (method && !strcmp ((const char *) method->name, \"main\")) {\n\t\t\tbin->main = method;\n\t\t\t// get main code attr\n\t\t\tbin->main_code_attr = r_bin_java_get_attr_from_field (method, R_BIN_JAVA_ATTR_TYPE_CODE_ATTR, 0);\n\t\t} else if (method && (!strcmp ((const char *) method->name, \"<init>\") || !strcmp ((const char *) method->name, \"init\")))   {\n\t\t\tIFDBG eprintf(\"FOund an init function.\\n\");\n\t\t\tbin->entrypoint = method;\n\t\t\tbin->entrypoint_code_attr = r_bin_java_get_attr_from_field (method, R_BIN_JAVA_ATTR_TYPE_CODE_ATTR, 0);\n\t\t} else if (method && (!strcmp ((const char *) method->name, \"<cinit>\") || !strcmp ((const char *) method->name, \"cinit\")))   {\n\t\t\tbin->cf2.this_class_entrypoint = method;\n\t\t\tbin->cf2.this_class_entrypoint_code_attr = r_bin_java_get_attr_from_field (method, R_BIN_JAVA_ATTR_TYPE_CODE_ATTR, 0);\n\t\t}\n\t\tif (adv + offset > len) {\n\t\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Method: %d.\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t\tIFDBG r_bin_java_print_field_summary(method);\n\t}\n\tbin->methods_size = adv;\n\treturn adv;\n}\n\nR_API int r_bin_java_new_bin(RBinJavaObj *bin, ut64 loadaddr, Sdb *kv, const ut8 *buf, ut64 len) {\n\tR_BIN_JAVA_GLOBAL_BIN = bin;\n\tbin->lines.count = 0;\n\tbin->loadaddr = loadaddr;\n\tr_bin_java_get_java_null_cp ();\n\tbin->id = r_num_rand (UT32_MAX);\n\tbin->kv = kv ? kv : sdb_new (NULL, NULL, 0);\n\tbin->AllJavaBinObjs = NULL;\n\treturn r_bin_java_load_bin (bin, buf, len);\n}\n\nR_API int r_bin_java_load_bin(RBinJavaObj *bin, const ut8 *buf, ut64 buf_sz) {\n\tut64 adv = 0;\n\tR_BIN_JAVA_GLOBAL_BIN = bin;\n\tif (!bin) {\n\t\treturn false;\n\t}\n\tr_bin_java_reset_bin_info (bin);\n\tmemcpy ((ut8 *) &bin->cf, buf, 10);\n\tif (memcmp (bin->cf.cafebabe, \"\\xCA\\xFE\\xBA\\xBE\", 4)) {\n\t\teprintf (\"r_bin_java_new_bin: Invalid header (%02x %02x %02x %02x)\\n\",\n\t\t\tbin->cf.cafebabe[0], bin->cf.cafebabe[1],\n\t\t\tbin->cf.cafebabe[2], bin->cf.cafebabe[3]);\n\t\treturn false;\n\t}\n\tif (bin->cf.major[0] == bin->cf.major[1] && bin->cf.major[0] == 0) {\n\t\teprintf (\"Java CLASS with MACH0 header?\\n\");\n\t\treturn false;\n\t}\n\tadv += 8;\n\t// -2 so that the cp_count will be parsed\n\tadv += r_bin_java_parse_cp_pool (bin, adv, buf, buf_sz);\n\tif (adv > buf_sz) {\n\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Constant Pool.\\n\");\n\t\treturn true;\n\t}\n\tadv += r_bin_java_read_class_file2 (bin, adv, buf, buf_sz);\n\tif (adv > buf_sz) {\n\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after class file info.\\n\");\n\t\treturn true;\n\t}\n\tIFDBG eprintf(\"This class: %d %s\\n\", bin->cf2.this_class, bin->cf2.this_class_name);\n\tIFDBG eprintf(\"0x%\"PFMT64x \" Access flags: 0x%04x\\n\", adv, bin->cf2.access_flags);\n\tadv += r_bin_java_parse_interfaces (bin, adv, buf, buf_sz);\n\tif (adv > buf_sz) {\n\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Interfaces.\\n\");\n\t\treturn true;\n\t}\n\tadv += r_bin_java_parse_fields (bin, adv, buf, buf_sz);\n\tif (adv > buf_sz) {\n\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Fields.\\n\");\n\t\treturn true;\n\t}\n\tadv += r_bin_java_parse_methods (bin, adv, buf, buf_sz);\n\tif (adv > buf_sz) {\n\t\teprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Methods.\\n\");\n\t\treturn true;\n\t}\n\tadv += r_bin_java_parse_attrs (bin, adv, buf, buf_sz);\n\tbin->calc_size = adv;\n\t// if (adv > buf_sz) {\n\t// eprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Attributes.\\n\");\n\t// return true;\n\t// }\n\n\t// add_cp_objs_to_sdb(bin);\n\t// add_method_infos_to_sdb(bin);\n\t// add_field_infos_to_sdb(bin);\n\treturn true;\n}\n\nR_API char *r_bin_java_get_version(RBinJavaObj *bin) {\n\treturn r_str_newf (\"0x%02x%02x 0x%02x%02x\",\n\t\tbin->cf.major[1], bin->cf.major[0],\n\t\tbin->cf.minor[1], bin->cf.minor[0]);\n}\n\nR_API RList *r_bin_java_get_entrypoints(RBinJavaObj *bin) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaField *fm_type;\n\tRList *ret = r_list_newf (free);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach_safe (bin->methods_list, iter, iter_tmp, fm_type) {\n\t\tif (!strcmp (fm_type->name, \"main\")\n\t\t|| !strcmp (fm_type->name, \"<init>\")\n\t\t|| !strcmp (fm_type->name, \"<clinit>\")\n\t\t|| strstr (fm_type->flags_str, \"static\")) {\n\t\t\tRBinAddr *addr = R_NEW0 (RBinAddr);\n\t\t\tif (addr) {\n\t\t\t\taddr->vaddr = addr->paddr = \\\n\t\t\t\t\tr_bin_java_get_method_code_offset (fm_type) + bin->loadaddr;\n\t\t\t\taddr->haddr = fm_type->file_offset;\n\t\t\t\tr_list_append (ret, addr);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nR_API RBinJavaField *r_bin_java_get_method_code_attribute_with_addr(RBinJavaObj *bin, ut64 addr) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaField *fm_type, *res = NULL;\n\tif (bin == NULL && R_BIN_JAVA_GLOBAL_BIN) {\n\t\tbin = R_BIN_JAVA_GLOBAL_BIN;\n\t} else if (bin == NULL) {\n\t\teprintf (\"Attempting to analyse function when the R_BIN_JAVA_GLOBAL_BIN has not been set.\\n\");\n\t\treturn NULL;\n\t}\n\tr_list_foreach_safe (bin->methods_list, iter, iter_tmp, fm_type) {\n\t\tut64 offset = r_bin_java_get_method_code_offset (fm_type) + bin->loadaddr,\n\t\tsize = r_bin_java_get_method_code_size (fm_type);\n\t\tif (addr >= offset && addr <= size + offset) {\n\t\t\tres = fm_type;\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API RBinAddr *r_bin_java_get_entrypoint(RBinJavaObj *bin, int sym) {\n\tRBinAddr *ret = NULL;\n\tret = R_NEW0 (RBinAddr);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->paddr = UT64_MAX;\n\tswitch (sym) {\n\tcase R_BIN_SYM_ENTRY:\n\tcase R_BIN_SYM_INIT:\n\t\tret->paddr = r_bin_java_find_method_offset (bin, \"<init>\");\n\t\tif (ret->paddr == UT64_MAX) {\n\t\t\tret->paddr = r_bin_java_find_method_offset (bin, \"<cinit>\");\n\t\t}\n\t\tbreak;\n\tcase R_BIN_SYM_FINI:\n\t\tret->paddr = UT64_MAX;\n\t\tbreak;\n\tcase R_BIN_SYM_MAIN:\n\t\tret->paddr = r_bin_java_find_method_offset (bin, \"main\");\n\t\tbreak;\n\tdefault:\n\t\tret->paddr = -1;\n\t}\n\tif (ret->paddr != -1) {\n\t\tret->paddr += bin->loadaddr;\n\t}\n\treturn ret;\n}\n\nR_API ut64 r_bin_java_get_method_code_size(RBinJavaField *fm_type) {\n\tRListIter *attr_iter = NULL, *attr_iter_tmp = NULL;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 sz = 0;\n\tr_list_foreach_safe (fm_type->attributes, attr_iter, attr_iter_tmp, attr) {\n\t\tif (attr->type == R_BIN_JAVA_ATTR_TYPE_CODE_ATTR) {\n\t\t\tsz = attr->info.code_attr.code_length;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn sz;\n}\n\nR_API ut64 r_bin_java_find_method_offset(RBinJavaObj *bin, const char *method_name) {\n\tRListIter *attr_iter = NULL, *attr_iter_tmp = NULL;\n\tRBinJavaField *method = NULL;\n\tut64 offset = -1;\n\tr_list_foreach_safe (bin->methods_list, attr_iter, attr_iter_tmp, method) {\n\t\tif (method && !strcmp ((const char *) method->name, method_name)) {\n\t\t\toffset = r_bin_java_get_method_code_offset (method) + bin->loadaddr;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn offset;\n}\n\nR_API ut64 r_bin_java_get_method_code_offset(RBinJavaField *fm_type) {\n\tRListIter *attr_iter = NULL, *attr_iter_tmp = NULL;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tr_list_foreach_safe (fm_type->attributes, attr_iter, attr_iter_tmp, attr) {\n\t\tif (attr->type == R_BIN_JAVA_ATTR_TYPE_CODE_ATTR) {\n\t\t\toffset = attr->info.code_attr.code_offset;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn offset;\n}\n\nR_API RBinField *r_bin_java_allocate_rbinfield() {\n\tRBinField *t = (RBinField *) malloc (sizeof (RBinField));\n\tif (t) {\n\t\tmemset (t, 0, sizeof (RBinField));\n\t}\n\treturn t;\n}\n\nR_API RBinField *r_bin_java_create_new_rbinfield_from_field(RBinJavaField *fm_type, ut64 baddr) {\n\tRBinField *field = r_bin_java_allocate_rbinfield ();\n\tif (field) {\n\t\tfield->name = strdup (fm_type->name);\n\t\tfield->paddr = fm_type->file_offset + baddr;\n\t\tfield->visibility = fm_type->flags;\n\t}\n\treturn field;\n}\n\nR_API RBinSymbol *r_bin_java_create_new_symbol_from_field(RBinJavaField *fm_type, ut64 baddr) {\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (fm_type == NULL || fm_type->field_ref_cp_obj == NULL || fm_type->field_ref_cp_obj == &R_BIN_JAVA_NULL_TYPE) {\n\t\tfree (sym);\n\t\tsym = NULL;\n\t}\n\tif (sym) {\n\t\tsym->name = strdup (fm_type->name);\n\t\t// strncpy (sym->type, fm_type->descriptor, R_BIN_SIZEOF_STRINGS);\n\t\tif (fm_type->type == R_BIN_JAVA_FIELD_TYPE_METHOD) {\n\t\t\tsym->type = r_str_const (R_BIN_TYPE_FUNC_STR);\n\t\t\tsym->paddr = r_bin_java_get_method_code_offset (fm_type);\n\t\t\tsym->vaddr = r_bin_java_get_method_code_offset (fm_type) + baddr;\n\t\t\tsym->size = r_bin_java_get_method_code_size (fm_type);\n\t\t} else {\n\t\t\tsym->type = r_str_const (\"FIELD\");\n\t\t\tsym->paddr = fm_type->file_offset;// r_bin_java_get_method_code_offset (fm_type);\n\t\t\tsym->vaddr = fm_type->file_offset + baddr;\n\t\t\tsym->size = fm_type->size;\n\t\t}\n\t\tif (r_bin_java_is_fm_type_protected (fm_type)) {\n\t\t\tsym->bind = r_str_const (R_BIN_BIND_LOCAL_STR);\n\t\t} else if (r_bin_java_is_fm_type_private (fm_type)) {\n\t\t\tsym->bind = r_str_const (R_BIN_BIND_LOCAL_STR);\n\t\t} else if (r_bin_java_is_fm_type_protected (fm_type)) {\n\t\t\tsym->bind = r_str_const (R_BIN_BIND_GLOBAL_STR);\n\t\t}\n\t\tsym->forwarder = r_str_const (\"NONE\");\n\t\tif (fm_type->class_name) {\n\t\t\tsym->classname = strdup (fm_type->class_name);\n\t\t} else {\n\t\t\tsym->classname = strdup (\"UNKNOWN\"); // dupped names?\n\t\t}\n\t\tsym->ordinal = fm_type->metas->ord;\n\t\tsym->visibility = fm_type->flags;\n\t\tif (fm_type->flags_str) {\n\t\t\tsym->visibility_str = strdup (fm_type->flags_str);\n\t\t}\n\t}\n\treturn sym;\n}\n\nR_API RBinSymbol *r_bin_java_create_new_symbol_from_fm_type_meta(RBinJavaField *fm_type, ut64 baddr) {\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (!sym || !fm_type || !fm_type->field_ref_cp_obj || fm_type->field_ref_cp_obj == &R_BIN_JAVA_NULL_TYPE) {\n\t\tfree (sym);\n\t\treturn NULL;\n\t}\n\t// ut32 new_name_len = strlen (fm_type->name) + strlen (\"_meta\") + 1;\n\t// char *new_name = malloc (new_name_len);\n\tsym->name = r_str_newf (\"meta_%s\", fm_type->name);\n\tif (fm_type->type == R_BIN_JAVA_FIELD_TYPE_METHOD) {\n\t\tsym->type = r_str_const (\"FUNC_META\");\n\t} else {\n\t\tsym->type = r_str_const (\"FIELD_META\");\n\t}\n\tif (r_bin_java_is_fm_type_protected (fm_type)) {\n\t\tsym->bind = r_str_const (R_BIN_BIND_LOCAL_STR);\n\t} else if (r_bin_java_is_fm_type_private (fm_type)) {\n\t\tsym->bind = r_str_const (R_BIN_BIND_LOCAL_STR);\n\t} else if (r_bin_java_is_fm_type_protected (fm_type)) {\n\t\tsym->bind = r_str_const (R_BIN_BIND_GLOBAL_STR);\n\t}\n\tsym->forwarder = r_str_const (\"NONE\");\n\tif (fm_type->class_name) {\n\t\tsym->classname = strdup (fm_type->class_name);\n\t} else {\n\t\tsym->classname = strdup (\"UNKNOWN\");\n\t}\n\tsym->paddr = fm_type->file_offset;// r_bin_java_get_method_code_offset (fm_type);\n\tsym->vaddr = fm_type->file_offset + baddr;\n\tsym->ordinal = fm_type->metas->ord;\n\tsym->size = fm_type->size;\n\tsym->visibility = fm_type->flags;\n\tif (fm_type->flags_str) {\n\t\tsym->visibility_str = strdup (fm_type->flags_str);\n\t}\n\treturn sym;\n}\n\nR_API RBinSymbol *r_bin_java_create_new_symbol_from_ref(RBinJavaCPTypeObj *obj, ut64 baddr) {\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (!sym) {\n\t\treturn NULL;\n\t}\n\tchar *class_name, *name, *type_name;\n\tif (obj == NULL || (obj->tag != R_BIN_JAVA_CP_METHODREF &&\n\tobj->tag != R_BIN_JAVA_CP_INTERFACEMETHOD_REF &&\n\tobj->tag != R_BIN_JAVA_CP_FIELDREF)) {\n\t\tfree (sym);\n\t\tsym = NULL;\n\t\treturn sym;\n\t}\n\tif (sym) {\n\t\tclass_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN,\n\t\t\tobj->info.cp_method.class_idx);\n\t\tname = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN,\n\t\t\tobj->info.cp_method.name_and_type_idx);\n\t\ttype_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN,\n\t\t\tobj->info.cp_method.name_and_type_idx);\n\t\tif (name) {\n\t\t\tsym->name = name;\n\t\t\tname = NULL;\n\t\t}\n\t\tif (type_name) {\n\t\t\tsym->type = r_str_const (type_name);\n\t\t\tR_FREE (type_name);\n\t\t}\n\t\tif (class_name) {\n\t\t\tsym->classname = strdup (class_name);\n\t\t}\n\t\tsym->paddr = obj->file_offset + baddr;\n\t\tsym->vaddr = obj->file_offset + baddr;\n\t\tsym->ordinal = obj->metas->ord;\n\t\tsym->size = 0;\n\t}\n\treturn sym;\n}\n\nR_API RList *r_bin_java_get_sections(RBinJavaObj *bin) {\n\tRBinSection *section = NULL;\n\tRList *sections = r_list_newf (free);\n\tut64 baddr = bin->loadaddr;\n\tRBinJavaField *fm_type;\n\tRListIter *iter = NULL;\n\tif (bin->cp_count > 0) {\n\t\tsection = R_NEW0 (RBinSection);\n\t\tif (section) {\n\t\t\tstrcpy (section->name, \"constant_pool\");\n\t\t\tsection->size = bin->cp_size;\n\t\t\tsection->paddr = bin->cp_offset + baddr;\n\t\t\tsection->srwx = R_BIN_SCN_READABLE;\n\t\t\tsection->add = true;\n\t\t\tr_list_append (sections, section);\n\t\t}\n\t\tsection = NULL;\n\t}\n\tif (bin->fields_count > 0) {\n\t\tsection = R_NEW0 (RBinSection);\n\t\tif (section) {\n\t\t\tstrcpy (section->name, \"fields\");\n\t\t\tsection->size = bin->fields_size;\n\t\t\tsection->paddr = bin->fields_offset + baddr;\n\t\t\tsection->srwx = R_BIN_SCN_READABLE;\n\t\t\tsection->add = true;\n\t\t\tr_list_append (sections, section);\n\t\t\tsection = NULL;\n\t\t\tr_list_foreach (bin->fields_list, iter, fm_type) {\n\t\t\t\tif (fm_type->attr_offset == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsection = R_NEW0 (RBinSection);\n\t\t\t\tif (section) {\n\t\t\t\t\tsnprintf (section->name, R_BIN_SIZEOF_STRINGS, \"attrs.%s\", fm_type->name);\n\t\t\t\t\tsection->size = fm_type->size - (fm_type->file_offset - fm_type->attr_offset);\n\t\t\t\t\tsection->paddr = fm_type->attr_offset + baddr;\n\t\t\t\t\tsection->srwx = R_BIN_SCN_READABLE;\n\t\t\t\t\tsection->add = true;\n\t\t\t\t\tr_list_append (sections, section);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (bin->methods_count > 0) {\n\t\tsection = R_NEW0 (RBinSection);\n\t\tif (section) {\n\t\t\tstrcpy (section->name, \"methods\");\n\t\t\tsection->size = bin->methods_size;\n\t\t\tsection->paddr = bin->methods_offset + baddr;\n\t\t\tsection->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_EXECUTABLE;\n\t\t\tsection->add = true;\n\t\t\tr_list_append (sections, section);\n\t\t\tsection = NULL;\n\t\t\tr_list_foreach (bin->methods_list, iter, fm_type) {\n\t\t\t\tif (fm_type->attr_offset == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsection = R_NEW0 (RBinSection);\n\t\t\t\tif (section) {\n\t\t\t\t\tsnprintf (section->name, R_BIN_SIZEOF_STRINGS, \"attrs.%s\", fm_type->name);\n\t\t\t\t\tsection->size = fm_type->size - (fm_type->file_offset - fm_type->attr_offset);\n\t\t\t\t\tsection->paddr = fm_type->attr_offset + baddr;\n\t\t\t\t\tsection->srwx = R_BIN_SCN_READABLE;\n\t\t\t\t\tsection->add = true;\n\t\t\t\t\tr_list_append (sections, section);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (bin->interfaces_count > 0) {\n\t\tsection = R_NEW0 (RBinSection);\n\t\tif (section) {\n\t\t\tstrcpy (section->name, \"interfaces\");\n\t\t\tsection->size = bin->interfaces_size;\n\t\t\tsection->paddr = bin->interfaces_offset + baddr;\n\t\t\tsection->srwx = R_BIN_SCN_READABLE;\n\t\t\tsection->add = true;\n\t\t\tr_list_append (sections, section);\n\t\t}\n\t\tsection = NULL;\n\t}\n\tif (bin->attrs_count > 0) {\n\t\tsection = R_NEW0 (RBinSection);\n\t\tif (section) {\n\t\t\tstrcpy (section->name, \"attributes\");\n\t\t\tsection->size = bin->attrs_size;\n\t\t\tsection->paddr = bin->attrs_offset + baddr;\n\t\t\tsection->srwx = R_BIN_SCN_READABLE;\n\t\t\tsection->add = true;\n\t\t\tr_list_append (sections, section);\n\t\t}\n\t\tsection = NULL;\n\t}\n\treturn sections;\n}\n\nR_API RList *r_bin_java_enum_class_methods(RBinJavaObj *bin, ut16 class_idx) {\n\tRList *methods = r_list_newf (free);\n\tRListIter *iter;\n\tRBinJavaField *field;\n\tr_list_foreach (bin->methods_list, iter, field) {\n\t\tif (field->field_ref_cp_obj && 0) {\n\t\t\tif ((field && field->field_ref_cp_obj->metas->ord == class_idx)) {\n\t\t\t\tRBinSymbol *sym = r_bin_java_create_new_symbol_from_ref (\n\t\t\t\t\t\tfield->field_ref_cp_obj, bin->loadaddr);\n\t\t\t\tif (sym) {\n\t\t\t\t\tr_list_append (methods, sym);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tsym->name = strdup (field->name);\n\t\t\t// func defintion\n\t\t\t// sym->paddr = field->file_offset + bin->loadaddr;\n\t\t\t// code implementation\n\t\t\tsym->paddr = r_bin_java_get_method_code_offset (field);\n\t\t\tsym->vaddr = sym->paddr; // + bin->loadaddr;\n\t\t\tr_list_append (methods, sym);\n\t\t}\n\t}\n\treturn methods;\n}\n\nR_API RList *r_bin_java_enum_class_fields(RBinJavaObj *bin, ut16 class_idx) {\n\tRList *fields = r_list_newf (free);\n\tRListIter *iter;\n\tRBinJavaField *fm_type;\n\tRBinField *field = NULL;\n\tr_list_foreach (bin->fields_list, iter, fm_type) {\n\t\tif (fm_type) {\n\t\t\tif (fm_type && fm_type->field_ref_cp_obj\n\t\t\t&& fm_type->field_ref_cp_obj->metas->ord == class_idx) {\n\t\t\t\tfield = r_bin_java_create_new_rbinfield_from_field (fm_type, bin->loadaddr);\n\t\t\t\tif (field) {\n\t\t\t\t\tr_list_append (fields, field);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn fields;\n}\n\nR_API int is_class_interface(RBinJavaObj *bin, RBinJavaCPTypeObj *cp_obj) {\n\tRBinJavaInterfaceInfo *ifobj;\n\tRListIter *iter;\n\tint res = false;\n\tr_list_foreach (bin->interfaces_list, iter, ifobj) {\n\t\tif (ifobj) {\n\t\t\tres = cp_obj == ifobj->cp_class;\n\t\t\tif (res) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n/*\n   R_API RList * r_bin_java_get_interface_classes(RBinJavaObj * bin) {\n        RList *interfaces_names = r_list_new();\n        RListIter *iter;\n        RBinJavaInterfaceInfo *ifobj;\n        r_list_foreach(bin->interfaces_list, iter, iinfo) {\n                RBinClass *class_ = R_NEW0 (RBinClass);\n                RBinJavaCPTypeObj *cp_obj = ;\n                if (ifobj && ifobj->name) {\n                        ut8 * name = strdup(ifobj->name);\n                        r_list_append(interfaces_names, name);\n                }\n        }\n        return interfaces_names;\n   }\n*/\n\nR_API RList *r_bin_java_get_lib_names(RBinJavaObj *bin) {\n\tRList *lib_names = r_list_newf (free);\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *cp_obj = NULL;\n\tif (!bin) {\n\t\treturn lib_names;\n\t}\n\tr_list_foreach (bin->cp_list, iter, cp_obj) {\n\t\tif (cp_obj && cp_obj->tag == R_BIN_JAVA_CP_CLASS &&\n\t\t(bin->cf2.this_class != cp_obj->info.cp_class.name_idx || !is_class_interface (bin, cp_obj))) {\n\t\t\tchar *name = r_bin_java_get_item_name_from_bin_cp_list (bin, cp_obj);\n\t\t\tr_list_append (lib_names, name);\n\t\t}\n\t}\n\treturn lib_names;\n}\n\nR_API void r_bin_java_classes_free(void /*RBinClass*/ *k) {\n\tRBinClass *klass = k;\n\tif (klass) {\n\t\tr_list_free (klass->methods);\n\t\tr_list_free (klass->fields);\n\t\tfree (klass->name);\n\t\tfree (klass->super);\n\t\tfree (klass->visibility_str);\n\t\tfree (klass);\n\t}\n}\n\nR_API RList *r_bin_java_get_classes(RBinJavaObj *bin) {\n\tRList *classes = r_list_newf (r_bin_java_classes_free);\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *cp_obj = NULL;\n\tRBinJavaCPTypeObj *this_class_cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, bin->cf2.this_class);\n\tut32 idx = 0;\n\tRBinClass *k = R_NEW0 (RBinClass);\n\tif (!k) {\n\t\tr_list_free (classes);\n\t\treturn NULL;\n\t}\n\tk->visibility = bin->cf2.access_flags;\n\tif (bin->cf2.flags_str) {\n\t\tk->visibility_str = strdup (bin->cf2.flags_str);\n\t}\n\tk->methods = r_bin_java_enum_class_methods (bin, bin->cf2.this_class);\n\tk->fields = r_bin_java_enum_class_fields (bin, bin->cf2.this_class);\n\tk->name = r_bin_java_get_this_class_name (bin);\n\tk->super = r_bin_java_get_name_from_bin_cp_list (bin, bin->cf2.super_class);\n\tk->index = (idx++);\n\tr_list_append (classes, k);\n\tr_list_foreach (bin->cp_list, iter, cp_obj) {\n\t\tif (cp_obj && cp_obj->tag == R_BIN_JAVA_CP_CLASS\n\t\t&& (this_class_cp_obj != cp_obj && is_class_interface (bin, cp_obj))) {\n\t\t\tk = R_NEW0 (RBinClass);\n\t\t\tif (!k) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk->methods = r_bin_java_enum_class_methods (bin, cp_obj->info.cp_class.name_idx);\n\t\t\tk->fields = r_bin_java_enum_class_fields (bin, cp_obj->info.cp_class.name_idx);\n\t\t\tk->index = idx;\n\t\t\tk->name = r_bin_java_get_item_name_from_bin_cp_list (bin, cp_obj);\n\t\t\tr_list_append (classes, k);\n\t\t\tidx++;\n\t\t}\n\t}\n\treturn classes;\n}\n\nR_API RBinSymbol *r_bin_java_create_new_symbol_from_invoke_dynamic(RBinJavaCPTypeObj *obj, ut64 baddr) {\n\tif (!obj || (obj->tag != R_BIN_JAVA_CP_INVOKEDYNAMIC)) {\n\t\treturn NULL;\n\t}\n\treturn r_bin_java_create_new_symbol_from_cp_idx (obj->info.cp_invoke_dynamic.name_and_type_index, baddr);\n}\n\nR_API RBinSymbol *r_bin_java_create_new_symbol_from_cp_idx(ut32 cp_idx, ut64 baddr) {\n\tRBinSymbol *sym = NULL;\n\tRBinJavaCPTypeObj *obj = r_bin_java_get_item_from_bin_cp_list (\n\t\tR_BIN_JAVA_GLOBAL_BIN, cp_idx);\n\tif (obj) {\n\t\tswitch (obj->tag) {\n\t\tcase R_BIN_JAVA_CP_METHODREF:\n\t\tcase R_BIN_JAVA_CP_FIELDREF:\n\t\tcase R_BIN_JAVA_CP_INTERFACEMETHOD_REF:\n\t\t\tsym = r_bin_java_create_new_symbol_from_ref (obj, baddr);\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_CP_INVOKEDYNAMIC:\n\t\t\tsym = r_bin_java_create_new_symbol_from_invoke_dynamic (obj, baddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn sym;\n}\n\nR_API RList *U(r_bin_java_get_fields)(RBinJavaObj * bin) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRList *fields = r_list_new ();\n\tRBinJavaField *fm_type;\n\tRBinField *field;\n\tr_list_foreach_safe (bin->fields_list, iter, iter_tmp, fm_type) {\n\t\tfield = r_bin_java_create_new_rbinfield_from_field (fm_type, bin->loadaddr);\n\t\tif (field) {\n\t\t\tr_list_append (fields, field);\n\t\t}\n\t}\n\treturn fields;\n}\n\nR_API void r_bin_add_import(RBinJavaObj *bin, RBinJavaCPTypeObj *obj, const char *type) {\n\tRBinImport *imp = R_NEW0 (RBinImport);\n\tchar *class_name = r_bin_java_get_name_from_bin_cp_list (bin, obj->info.cp_method.class_idx);\n\tchar *name = r_bin_java_get_name_from_bin_cp_list (bin, obj->info.cp_method.name_and_type_idx);\n\tchar *descriptor = r_bin_java_get_desc_from_bin_cp_list (bin, obj->info.cp_method.name_and_type_idx);\n\tclass_name = class_name ? class_name : strdup (\"INVALID CLASS NAME INDEX\");\n\tname = name ? name : strdup (\"InvalidNameIndex\");\n\tdescriptor = descriptor ? descriptor : strdup (\"INVALID DESCRIPTOR INDEX\");\n\timp->classname = class_name;\n\timp->name = name;\n\timp->bind = r_str_const (\"NONE\");\n\timp->type = r_str_const (type);\n\timp->descriptor = descriptor;\n\timp->ordinal = obj->idx;\n\tr_list_append (bin->imports_list, imp);\n}\n\nR_API void r_bin_java_set_imports(RBinJavaObj *bin) {\n\tRListIter *iter = NULL;\n\tRBinJavaCPTypeObj *obj = NULL;\n\tr_list_free (bin->imports_list);\n\tbin->imports_list = r_list_newf (free);\n\tr_list_foreach (bin->cp_list, iter, obj) {\n\t\tconst char *type = NULL;\n\t\tswitch (obj->tag) {\n\t\tcase R_BIN_JAVA_CP_METHODREF: type = \"METHOD\"; break;\n\t\tcase R_BIN_JAVA_CP_INTERFACEMETHOD_REF: type = \"FIELD\"; break;\n\t\tcase R_BIN_JAVA_CP_FIELDREF: type = \"INTERFACE_METHOD\"; break;\n\t\tdefault: type = NULL; break;\n\t\t}\n\t\tif (type) {\n\t\t\tr_bin_add_import (bin, obj, type);\n\t\t}\n\t}\n}\n\nR_API RList *r_bin_java_get_imports(RBinJavaObj *bin) {\n\tRList *ret = r_list_newf (free);\n\tRBinImport *import = NULL;\n\tRListIter *iter;\n\tr_list_foreach (bin->imports_list, iter, import) {\n\t\tRBinImport *n_import = R_NEW0 (RBinImport);\n\t\tif (!n_import) {\n\t\t\tr_list_free (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy (n_import, import, sizeof (RBinImport));\n\t\tr_list_append (ret, n_import);\n\t}\n\treturn ret;\n}\n\nR_API RList *r_bin_java_get_symbols(RBinJavaObj *bin) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRList *imports, *symbols = r_list_newf (free);\n\tRBinSymbol *sym = NULL;\n\tRBinImport *imp;\n\tRBinJavaField *fm_type;\n\tr_list_foreach_safe (bin->methods_list, iter, iter_tmp, fm_type) {\n\t\tsym = r_bin_java_create_new_symbol_from_field (fm_type, bin->loadaddr);\n\t\tif (sym) {\n\t\t\tr_list_append (symbols, (void *) sym);\n\t\t}\n\t\tsym = r_bin_java_create_new_symbol_from_fm_type_meta (fm_type, bin->loadaddr);\n\t\tif (sym) {\n\t\t\tr_list_append (symbols, (void *) sym);\n\t\t}\n\t}\n\tr_list_foreach_safe (bin->fields_list, iter, iter_tmp, fm_type) {\n\t\tsym = r_bin_java_create_new_symbol_from_field (fm_type, bin->loadaddr);\n\t\tif (sym) {\n\t\t\tr_list_append (symbols, (void *) sym);\n\t\t}\n\t\tsym = r_bin_java_create_new_symbol_from_fm_type_meta (fm_type, bin->loadaddr);\n\t\tif (sym) {\n\t\t\tr_list_append (symbols, (void *) sym);\n\t\t}\n\t}\n\tbin->lang = \"java\";\n\timports = r_bin_java_get_imports (bin);\n\tr_list_foreach (imports, iter, imp) {\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tif (imp->classname && !strncmp (imp->classname, \"kotlin/jvm\", 10)) {\n\t\t\tbin->lang = \"kotlin\";\n\t\t}\n\t\tsym->name = r_str_newf (\"imp.%s\", imp->name);\n\t\tif (!sym->name) {\n\t\t\tfree (sym);\n\t\t\tbreak;\n\t\t}\n\t\tsym->type = r_str_const (\"import\");\n\t\tif (!sym->type) {\n\t\t\tfree (sym);\n\t\t\tbreak;\n\t\t}\n\t\tsym->vaddr = sym->paddr = imp->ordinal;\n\t\tsym->ordinal = imp->ordinal;\n\t\tr_list_append (symbols, (void *) sym);\n\t}\n\tr_list_free (imports);\n\treturn symbols;\n}\n\nR_API RList *r_bin_java_get_strings(RBinJavaObj *bin) {\n\tRList *strings = r_list_newf (free);\n\tRBinString *str = NULL;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaCPTypeObj *cp_obj = NULL;\n\tr_list_foreach_safe (bin->cp_list, iter, iter_tmp, cp_obj) {\n\t\tif (cp_obj && cp_obj->tag == R_BIN_JAVA_CP_UTF8) {\n\t\t\tstr = (RBinString *) R_NEW0 (RBinString);\n\t\t\tif (str) {\n\t\t\t\tstr->paddr = cp_obj->file_offset + bin->loadaddr;\n\t\t\t\tstr->ordinal = cp_obj->metas->ord;\n\t\t\t\tstr->size = cp_obj->info.cp_utf8.length + 3;\n\t\t\t\tstr->length = cp_obj->info.cp_utf8.length;\n\t\t\t\tif (str->size > 0) {\n\t\t\t\t\tstr->string = r_str_ndup ((const char *)\n\t\t\t\t\t\tcp_obj->info.cp_utf8.bytes,\n\t\t\t\t\t\tR_BIN_JAVA_MAXSTR);\n\t\t\t\t}\n\t\t\t\tr_list_append (strings, (void *) str);\n\t\t\t}\n\t\t}\n\t}\n\treturn strings;\n}\n\nR_API void *r_bin_java_free(RBinJavaObj *bin) {\n\tchar *bin_obj_key = NULL;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\t// Delete the bin object from the data base.\n\tbin_obj_key = r_bin_java_build_obj_key (bin);\n\t// if (bin->AllJavaBinObjs && sdb_exists (bin->AllJavaBinObjs, bin_obj_key)) {\n\t// sdb_unset (bin->AllJavaBinObjs, bin_obj_key, 0);\n\t// }\n\tfree (bin_obj_key);\n\tr_list_free (bin->imports_list);\n\t// XXX - Need to remove all keys belonging to this class from\n\t// the share meta information sdb.\n\t// TODO e.g. iterate over bin->kv and delete all obj, func, etc. keys\n\t// sdb_free (bin->kv);\n\t// free up the constant pool list\n\tr_list_free (bin->cp_list);\n\t// free up the fields list\n\tr_list_free (bin->fields_list);\n\t// free up methods list\n\tr_list_free (bin->methods_list);\n\t// free up interfaces list\n\tr_list_free (bin->interfaces_list);\n\tr_list_free (bin->attrs_list);\n\t// TODO: XXX if a class list of all inner classes\n\t// are formed then this will need to be updated\n\tfree (bin->cf2.flags_str);\n\tfree (bin->cf2.this_class_name);\n\tif (bin == R_BIN_JAVA_GLOBAL_BIN) {\n\t\tR_BIN_JAVA_GLOBAL_BIN = NULL;\n\t}\n\tfree (bin->file);\n\tfree (bin);\n\treturn NULL;\n}\n\nR_API RBinJavaObj *r_bin_java_new_buf(RBuffer *buf, ut64 loadaddr, Sdb *kv) {\n\tRBinJavaObj *bin = R_NEW0 (RBinJavaObj);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (!r_bin_java_new_bin (bin, loadaddr, kv, buf->buf, buf->length)) {\n\t\treturn r_bin_java_free (bin);\n\t}\n\treturn bin;\n}\n\nR_API void r_bin_java_attribute_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tIFDBG eprintf(\"Deleting attr %s, %p\\n\", attr->name, attr);\n\t\t((RBinJavaAttrMetas *) attr->metas->type_info)->allocs->delete_obj (attr);\n\t\t// free (attr->metas);\n\t\t// free (attr);\n\t}\n}\n\nR_API void r_bin_java_constant_pool(void /*RBinJavaCPTypeObj*/ *o) {\n\tRBinJavaCPTypeObj *obj = o;\n\tif (obj != &R_BIN_JAVA_NULL_TYPE) {\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t}\n}\n\nR_API void r_bin_java_fmtype_free(void /*RBinJavaField*/ *f) {\n\tRBinJavaField *fm_type = f;\n\tif (!fm_type) {\n\t\treturn;\n\t}\n\tfree (fm_type->descriptor);\n\tfree (fm_type->name);\n\tfree (fm_type->flags_str);\n\tfree (fm_type->class_name);\n\tfree (fm_type->metas);\n\tr_list_free (fm_type->attributes);\n\tfree (fm_type);\n}\n// Start Free the various attribute types\nR_API void r_bin_java_unknown_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_local_variable_table_attr_entry_free(void /*RBinJavaLocalVariableAttribute*/ *a) {\n\tRBinJavaLocalVariableAttribute *lvattr = a;\n\tif (lvattr) {\n\t\tfree (lvattr->descriptor);\n\t\tfree (lvattr->name);\n\t\tfree (lvattr);\n\t}\n}\n\nR_API void r_bin_java_local_variable_table_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tr_list_free (attr->info.local_variable_table_attr.local_variable_table);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_local_variable_type_table_attr_entry_free(void /*RBinJavaLocalVariableTypeAttribute*/ *a) {\n\tRBinJavaLocalVariableTypeAttribute *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->signature);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_local_variable_type_table_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tr_list_free (attr->info.local_variable_type_table_attr.local_variable_table);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_deprecated_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_enclosing_methods_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr->info.enclosing_method_attr.class_name);\n\t\tfree (attr->info.enclosing_method_attr.method_name);\n\t\tfree (attr->info.enclosing_method_attr.method_descriptor);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_synthetic_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_constant_value_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_line_number_table_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tr_list_free (attr->info.line_number_table_attr.line_number_table);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_code_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\t// XXX - Intentional memory leak here.  When one of the\n\t\t// Code attributes is parsed, the code (the r_bin_java)\n\t\t// is not properly parsing the class file\n\t\tr_bin_java_stack_frame_free (attr->info.code_attr.implicit_frame);\n\t\tr_list_free (attr->info.code_attr.attributes);\n\t\tfree (attr->info.code_attr.code);\n\t\tr_list_free (attr->info.code_attr.exception_table);\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_exceptions_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr->info.exceptions_attr.exception_idx_table);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_inner_classes_attr_entry_free(void /*RBinJavaClassesAttribute*/ *a) {\n\tRBinJavaClassesAttribute *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->flags_str);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_inner_classes_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tr_list_free (attr->info.inner_classes_attr.classes);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_signature_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr->info.signature_attr.signature);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_source_debug_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr->info.debug_extensions.debug_extension);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_source_code_file_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_stack_map_table_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tr_list_free (attr->info.stack_map_table_attr.stack_map_frame_entries);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_stack_frame_free(void /*RBinJavaStackMapFrame*/ *o) {\n\tRBinJavaStackMapFrame *obj = o;\n\tif (obj) {\n\t\tr_list_free (obj->local_items);\n\t\tr_list_free (obj->stack_items);\n\t\tfree (obj->metas);\n\t\tfree (obj);\n\t}\n}\n\nR_API void r_bin_java_verification_info_free(void /*RBinJavaVerificationObj*/ *o) {\n\tRBinJavaVerificationObj *obj = o;\n\t// eprintf (\"Freeing verification object\\n\");\n\tif (obj) {\n\t\tfree (obj->name);\n\t\tfree (obj);\n\t}\n}\n\nR_API void r_bin_java_interface_free(void /*RBinJavaInterfaceInfo*/ *o) {\n\tRBinJavaInterfaceInfo *obj = o;\n\tif (obj) {\n\t\tfree (obj->name);\n\t\tfree (obj);\n\t}\n}\n// End Free the various attribute types\n// Start the various attibute types new\nR_API ut64 r_bin_java_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? ((RBinJavaAttrMetas *) attr->metas->type_info)->allocs->calc_size (attr) : 0;\n}\n\nR_API ut64 r_bin_java_unknown_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? 6 : 0;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_unknown_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\treturn r_bin_java_default_attr_new (buffer, sz, buf_offset);\n}\n\nR_API ut64 r_bin_java_code_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tRListIter *iter;\n\t// RListIter *iter_tmp;\n\tut64 size = 0;\n\tif (attr) {\n\t\t// attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\t\tsize += 6;\n\t\t// attr->info.code_attr.max_stack = R_BIN_JAVA_USHORT (buffer, 0);\n\t\tsize += 2;\n\t\t// attr->info.code_attr.max_locals = R_BIN_JAVA_USHORT (buffer, 2);\n\t\tsize += 2;\n\t\t// attr->info.code_attr.code_length = R_BIN_JAVA_UINT (buffer, 4);\n\t\tsize += 2;\n\t\tif (attr->info.code_attr.code) {\n\t\t\tsize += attr->info.code_attr.code_length;\n\t\t}\n\t\t// attr->info.code_attr.exception_table_length =  R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// RBinJavaExceptionEntry *exc_entry;\n\t\t// r_list_foreach_safe (attr->info.code_attr.exception_table, iter, iter_tmp, exc_entry) {\n\t\tr_list_foreach_iter (attr->info.code_attr.exception_table, iter) {\n\t\t\t// exc_entry->start_pc = R_BIN_JAVA_USHORT (buffer,offset);\n\t\t\tsize += 2;\n\t\t\t// exc_entry->end_pc = R_BIN_JAVA_USHORT (buffer,offset);\n\t\t\tsize += 2;\n\t\t\t// exc_entry->handler_pc = R_BIN_JAVA_USHORT (buffer,offset);\n\t\t\tsize += 2;\n\t\t\t// exc_entry->catch_type = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t}\n\t\t// attr->info.code_attr.attributes_count = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// RBinJavaAttrInfo *_attr;\n\t\tif (attr->info.code_attr.attributes_count > 0) {\n\t\t\t// r_list_foreach_safe (attr->info.code_attr.attributes, iter, iter_tmp, _attr) {\n\t\t\tr_list_foreach_iter (attr->info.code_attr.attributes, iter) {\n\t\t\t\tsize += r_bin_java_attr_calc_size (attr);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_code_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL, *_attr = NULL;\n\tut32 k = 0, curpos;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tif (sz < 16 || sz > buf_offset) {// sz > buf_offset) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_CODE_ATTR;\n\tattr->info.code_attr.max_stack = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.code_attr.max_locals = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.code_attr.code_length = R_BIN_JAVA_UINT (buffer, offset);\n\toffset += 4;\n\t// BUG: possible unsigned integer overflow here\n\tattr->info.code_attr.code_offset = buf_offset + offset;\n\tattr->info.code_attr.code = (ut8 *) malloc (attr->info.code_attr.code_length);\n\tif (!attr->info.code_attr.code) {\n\t\teprintf (\"Handling Code Attributes: Unable to allocate memory \"\n\t\t\t\"(%u bytes) for a code.\\n\", attr->info.code_attr.code_length);\n\t\treturn attr;\n\t}\n\tR_BIN_JAVA_GLOBAL_BIN->current_code_attr = attr;\n\t{\n\t\tint len = attr->info.code_attr.code_length;\n\t\tmemset (attr->info.code_attr.code, 0, len);\n\t\tif (offset + len >= sz) {\n\t\t\tlen = sz;\n\t\t\treturn attr;\n\t\t}\n\t\tmemcpy (attr->info.code_attr.code, buffer + offset, len);\n\t\toffset += len;\n\t}\n\tattr->info.code_attr.exception_table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.code_attr.exception_table = r_list_newf (free);\n\tfor (k = 0; k < attr->info.code_attr.exception_table_length; k++) {\n\t\tcurpos = buf_offset + offset;\n\t\tif (curpos + 8 > sz) {\n\t\t\treturn attr;\n\t\t}\n\t\tRBinJavaExceptionEntry *e = R_NEW0 (RBinJavaExceptionEntry);\n\t\tif (!e) {\n\t\t\tfree (attr);\n\t\t\treturn NULL;\n\t\t}\n\t\te->file_offset = curpos;\n\t\te->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\te->end_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\te->handler_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\te->catch_type = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tr_list_append (attr->info.code_attr.exception_table, e);\n\t\te->size = 8;\n\t}\n\tattr->info.code_attr.attributes_count = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\t// IFDBG eprintf (\"\tcode Attributes_count: %d\\n\", attr->info.code_attr.attributes_count);\n\t// XXX - attr->info.code_attr.attributes is not freed because one of the code attributes is improperly parsed.\n\tattr->info.code_attr.attributes = r_list_newf (r_bin_java_attribute_free);\n\tif (attr->info.code_attr.attributes_count > 0) {\n\t\tfor (k = 0; k < attr->info.code_attr.attributes_count; k++) {\n\t\t\tint size = (offset < sz) ? sz - offset : 0;\n\t\t\tif (size > sz || size <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t_attr = r_bin_java_read_next_attr_from_buffer (buffer + offset, size, buf_offset + offset);\n\t\t\tif (!_attr) {\n\t\t\t\teprintf (\"[X] r_bin_java_code_attr_new: Error unable to parse remainder of classfile after Method's Code Attribute: %d.\\n\", k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tIFDBG eprintf(\"Parsing @ 0x%\"PFMT64x \" (%s) = 0x%\"PFMT64x \" bytes, %p\\n\", _attr->file_offset, _attr->name, _attr->size, _attr);\n\t\t\toffset += _attr->size;\n\t\t\tr_list_append (attr->info.code_attr.attributes, _attr);\n\t\t\tif (_attr->type == R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TABLE_ATTR) {\n\t\t\t\tIFDBG eprintf(\"Parsed the LocalVariableTable, preparing the implicit mthod frame.\\n\");\n\t\t\t\t// r_bin_java_print_attr_summary(_attr);\n\t\t\t\tattr->info.code_attr.implicit_frame = r_bin_java_build_stack_frame_from_local_variable_table (R_BIN_JAVA_GLOBAL_BIN, _attr);\n\t\t\t\tattr->info.code_attr.implicit_frame->file_offset = buf_offset;\n\t\t\t\tIFDBG r_bin_java_print_stack_map_frame_summary(attr->info.code_attr.implicit_frame);\n\t\t\t\t// r_list_append (attr->info.code_attr.attributes, attr->info.code_attr.implicit_frame);\n\t\t\t}\n\t\t\t// if (offset > sz) {\n\t\t\t// eprintf (\"[X] r_bin_java: Error unable to parse remainder of classfile after Attribute: %d.\\n\", k);\n\t\t\t// break;\n\t\t\t// }\n\n\t\t}\n\t}\n\tif (attr->info.code_attr.implicit_frame == NULL) {\n\t\t// build a default implicit_frame\n\t\tattr->info.code_attr.implicit_frame = r_bin_java_default_stack_frame ();\n\t\t// r_list_append (attr->info.code_attr.attributes, attr->info.code_attr.implicit_frame);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;\n\t\tattr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->size = offset;\n\t}\n\t// IFDBG r_bin_java_print_constant_value_attr_summary(attr);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_constant_value_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? 8 : 0;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_deprecated_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_DEPRECATED_ATTR;\n\t\tattr->size = offset;\n\t}\n\t// IFDBG r_bin_java_print_deprecated_attr_summary(attr);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_deprecated_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? 6 : 0;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_signature_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SIGNATURE_ATTR;\n\t// attr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t// offset += 2;\n\tattr->info.signature_attr.signature_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.signature_attr.signature = r_bin_java_get_utf8_from_bin_cp_list (\n\t\tR_BIN_JAVA_GLOBAL_BIN, attr->info.signature_attr.signature_idx);\n\tif (!attr->info.signature_attr.signature) {\n\t\teprintf (\"r_bin_java_signature_attr_new: Unable to resolve the \"\n\t\t\t\"Signature UTF8 String Index: 0x%02x\\n\", attr->info.signature_attr.signature_idx);\n\t}\n\tattr->size = offset;\n\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_signature_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tif (attr == NULL) {\n\t\t// TODO eprintf allocation fail\n\t\treturn size;\n\t}\n\tsize += 6;\n\t// attr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\tsize += 2;\n\t// attr->info.signature_attr.signature_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_ENCLOSING_METHOD_ATTR;\n\tattr->info.enclosing_method_attr.class_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.enclosing_method_attr.method_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.enclosing_method_attr.class_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.class_idx);\n\tif (attr->info.enclosing_method_attr.class_name == NULL) {\n\t\teprintf (\"Could not resolve enclosing class name for the enclosed method.\\n\");\n\t}\n\tattr->info.enclosing_method_attr.method_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.method_idx);\n\tif (attr->info.enclosing_method_attr.class_name == NULL) {\n\t\teprintf (\"Could not resolve method descriptor for the enclosed method.\\n\");\n\t}\n\tattr->info.enclosing_method_attr.method_descriptor = r_bin_java_get_desc_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.method_idx);\n\tif (attr->info.enclosing_method_attr.method_name == NULL) {\n\t\teprintf (\"Could not resolve method name for the enclosed method.\\n\");\n\t}\n\tattr->size = offset;\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_enclosing_methods_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tif (attr) {\n\t\tsize += 6;\n\t\t// attr->info.enclosing_method_attr.class_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// attr->info.enclosing_method_attr.method_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_exceptions_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0, offset = 0;\n\tut64 size;\n\tRBinJavaAttrInfo *attr = NULL;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr == NULL) {\n\t\t// TODO eprintf\n\t\treturn attr;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;\n\tattr->info.exceptions_attr.number_of_exceptions = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tsize = sizeof (ut16) * attr->info.exceptions_attr.number_of_exceptions;\n\tif (size < attr->info.exceptions_attr.number_of_exceptions) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tattr->info.exceptions_attr.exception_idx_table = (ut16 *) malloc (size);\n\tif (!attr->info.exceptions_attr.exception_idx_table) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < attr->info.exceptions_attr.number_of_exceptions; i++) {\n\t\tattr->info.exceptions_attr.exception_idx_table[i] = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t}\n\tattr->size = offset;\n\t// IFDBG r_bin_java_print_exceptions_attr_summary(attr);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_exceptions_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0, i = 0;\n\tif (attr) {\n\t\tsize += 6;\n\t\tfor (i = 0; i < attr->info.exceptions_attr.number_of_exceptions; i++) {\n\t\t\t// attr->info.exceptions_attr.exception_idx_table[i] = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaClassesAttribute *icattr;\n\tRBinJavaAttrInfo *attr = NULL;\n\tRBinJavaCPTypeObj *obj;\n\tut32 i = 0;\n\tut64 offset = 0, curpos;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr == NULL) {\n\t\t// TODO eprintf\n\t\treturn attr;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n\tattr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n\tfor (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tif (offset + 8 > sz) {\n\t\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ticattr = R_NEW0 (RBinJavaClassesAttribute);\n\t\tif (!icattr) {\n\t\t\tbreak;\n\t\t}\n\t\ticattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->flags_str = retrieve_class_method_access_string (icattr->inner_class_access_flags);\n\t\ticattr->file_offset = curpos;\n\t\ticattr->size = 8;\n\n\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_name_idx);\n\t\tif (obj == NULL) {\n\t\t\teprintf (\"BINCPLIS IS HULL %d\\n\", icattr->inner_name_idx);\n\t\t}\n\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\tif (!icattr->name) {\n\t\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_class_info_idx);\n\t\t\tif (!obj) {\n\t\t\t\teprintf (\"BINCPLIST IS NULL %d\\n\", icattr->inner_class_info_idx);\n\t\t\t}\n\t\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\t\tif (!icattr->name) {\n\t\t\t\ticattr->name = r_str_dup (NULL, \"NULL\");\n\t\t\t\teprintf (\"r_bin_java_inner_classes_attr: Unable to find the name for %d index.\\n\", icattr->inner_name_idx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tIFDBG eprintf(\"r_bin_java_inner_classes_attr: Inner class name %d is %s.\\n\", icattr->inner_name_idx, icattr->name);\n\t\tr_list_append (attr->info.inner_classes_attr.classes, (void *) icattr);\n\t}\n\tattr->size = offset;\n\t// IFDBG r_bin_java_print_inner_classes_attr_summary(attr);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_inner_class_attr_calc_size(RBinJavaClassesAttribute *icattr) {\n\tut64 size = 0;\n\tif (icattr) {\n\t\t// icattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// icattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// icattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// icattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t}\n\treturn size;\n}\n\nR_API ut64 r_bin_java_inner_classes_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tRBinJavaClassesAttribute *icattr = NULL;\n\tRListIter *iter;\n\tut64 size = 6;\n\tif (!attr) {\n\t\treturn 0;\n\t}\n\tr_list_foreach (attr->info.inner_classes_attr.classes, iter, icattr) {\n\t\tsize += r_bin_java_inner_class_attr_calc_size (icattr);\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 curpos, offset = 0;\n\tRBinJavaLineNumberAttribute *lnattr;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;\n\tattr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.line_number_table_attr.line_number_table = r_list_newf (free);\n\n\tut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;\n\tRList *linenum_list = attr->info.line_number_table_attr.line_number_table;\n\tfor (i = 0; i < linenum_len; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\t// printf (\"%llx %llx \\n\", curpos, sz);\n\t\t// XXX if (curpos + 8 >= sz) break;\n\t\tlnattr = R_NEW0 (RBinJavaLineNumberAttribute);\n\t\tif (!lnattr) {\n\t\t\tbreak;\n\t\t}\n\t\t// wtf it works\n\t\tif (offset - 2 > sz) {\n\t\t\tbreak;\n\t\t}\n\t\tlnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->file_offset = curpos;\n\t\tlnattr->size = 4;\n\t\tr_list_append (linenum_list, lnattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_line_number_table_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 6;\n\t// RBinJavaLineNumberAttribute *lnattr;\n\tRListIter *iter;\n\t// RListIter *iter_tmp;\n\tif (!attr) {\n\t\treturn 0LL;\n\t}\n\t// r_list_foreach_safe (attr->info.line_number_table_attr.line_number_table, iter, iter_tmp, lnattr) {\n\tr_list_foreach_iter (attr->info.line_number_table_attr.line_number_table, iter) {\n\t\t// lnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// lnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_DEBUG_EXTENTSION_ATTR;\n\tif (attr->length == 0) {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Attempting to allocate 0 bytes for debug_extension.\\n\");\n\t\tattr->info.debug_extensions.debug_extension = NULL;\n\t\treturn attr;\n\t} else if ((attr->length + offset) > sz) {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Expected %d byte(s) got %\"\n\t\t\tPFMT64d \" bytes for debug_extension.\\n\", attr->length, (offset + sz));\n\t}\n\tattr->info.debug_extensions.debug_extension = (ut8 *) malloc (attr->length);\n\tif (attr->info.debug_extensions.debug_extension && (attr->length > (sz - offset))) {\n\t\tmemcpy (attr->info.debug_extensions.debug_extension, buffer + offset, sz - offset);\n\t} else if (attr->info.debug_extensions.debug_extension) {\n\t\tmemcpy (attr->info.debug_extensions.debug_extension, buffer + offset, attr->length);\n\t} else {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Unable to allocate the data for the debug_extension.\\n\");\n\t}\n\toffset += attr->length;\n\tattr->size = offset;\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_source_debug_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 6;\n\tif (!attr) {\n\t\treturn 0LL;\n\t}\n\tif (attr->info.debug_extensions.debug_extension) {\n\t\tsize += attr->length;\n\t}\n\treturn size;\n}\n\nR_API ut64 r_bin_java_local_variable_table_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\t// ut64 offset = 0;\n\tRListIter *iter;\n\t// RBinJavaLocalVariableAttribute *lvattr;\n\tif (!attr) {\n\t\treturn 0LL;\n\t}\n\tsize += 6;\n\t// attr->info.local_variable_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\tsize += 2;\n\t// r_list_foreach (attr->info.local_variable_table_attr.local_variable_table, iter, lvattr) {\n\tr_list_foreach_iter (attr->info.local_variable_table_attr.local_variable_table, iter) {\n\t\t// lvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// lvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// lvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// lvattr->descriptor_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// lvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_local_variable_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaLocalVariableAttribute *lvattr;\n\tut64 curpos = 0, offset = 6;\n\tRBinJavaAttrInfo *attr;\n\tut32 i = 0;\n\tif (!buffer || sz < 1) {\n\t\treturn NULL;\n\t}\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TABLE_ATTR;\n\tattr->info.local_variable_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.local_variable_table_attr.local_variable_table =\\\n\t\tr_list_newf (r_bin_java_local_variable_table_attr_entry_free);\n\tfor (i = 0; i < attr->info.local_variable_table_attr.table_length; i++) {\n\t\tif (offset + 10 > sz) {\n\t\t\tbreak;\n\t\t}\n\t\tcurpos = buf_offset + offset;\n\t\tlvattr = R_NEW0 (RBinJavaLocalVariableAttribute);\n\t\tlvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->descriptor_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->file_offset = curpos;\n\t\tlvattr->name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->name_idx);\n\t\tlvattr->size = 10;\n\t\tif (!lvattr->name) {\n\t\t\tlvattr->name = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_table_attr_new: Unable to find the name for %d index.\\n\", lvattr->name_idx);\n\t\t}\n\t\tlvattr->descriptor = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->descriptor_idx);\n\t\tif (!lvattr->descriptor) {\n\t\t\tlvattr->descriptor = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_table_attr_new: Unable to find the descriptor for %d index.\\n\", lvattr->descriptor_idx);\n\t\t}\n\t\tr_list_append (attr->info.local_variable_table_attr.local_variable_table, lvattr);\n\t}\n\tattr->size = offset;\n\t// IFDBG r_bin_java_print_local_variable_table_attr_summary(attr);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_local_variable_type_table_attr_calc_size(RBinJavaAttrInfo *attr) {\n\t// RBinJavaLocalVariableTypeAttribute *lvattr;\n\tRListIter *iter;\n\tut64 size = 0;\n\tif (attr) {\n\t\tRList *list = attr->info.local_variable_type_table_attr.local_variable_table;\n\t\tsize += 6;\n\t\t// attr->info.local_variable_type_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// r_list_foreach (list, iter, lvattr) {\n\t\tr_list_foreach_iter (list, iter) {\n\t\t\t// lvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->signature_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// lvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_local_variable_type_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaLocalVariableTypeAttribute *lvattr;\n\tut64 offset = 6;\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, 0);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TYPE_TABLE_ATTR;\n\tattr->info.local_variable_type_table_attr.table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.local_variable_type_table_attr.local_variable_table = r_list_newf (r_bin_java_local_variable_type_table_attr_entry_free);\n\tfor (i = 0; i < attr->info.local_variable_type_table_attr.table_length; i++) {\n\t\tut64 curpos = buf_offset + offset;\n\t\tlvattr = R_NEW0 (RBinJavaLocalVariableTypeAttribute);\n\t\tif (!lvattr) {\n\t\t\tperror (\"calloc\");\n\t\t\tbreak;\n\t\t}\n\t\tif (offset + 10 > sz) {\n\t\t\teprintf (\"oob\");\n\t\t\tbreak;\n\t\t}\n\t\tlvattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->length = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->signature_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->index = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlvattr->file_offset = curpos;\n\t\tlvattr->name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->name_idx);\n\t\tlvattr->size = 10;\n\t\tif (!lvattr->name) {\n\t\t\tlvattr->name = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_type_table_attr_new: Unable to find the name for %d index.\\n\", lvattr->name_idx);\n\t\t}\n\t\tlvattr->signature = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, lvattr->signature_idx);\n\t\tif (!lvattr->signature) {\n\t\t\tlvattr->signature = strdup (\"NULL\");\n\t\t\teprintf (\"r_bin_java_local_variable_type_table_attr_new: Unable to find the descriptor for %d index.\\n\", lvattr->signature_idx);\n\t\t}\n\t\tr_list_append (attr->info.local_variable_type_table_attr.local_variable_table, lvattr);\n\t}\n\t// IFDBG r_bin_java_print_local_variable_type_table_attr_summary(attr);\n\tattr->size = offset;\n\treturn attr;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tif (!sz) {\n\t\treturn NULL;\n\t}\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;\n\t// if (buffer + offset > buffer + sz) return NULL;\n\tattr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->size = offset;\n\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_source_code_file_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? 8 : 0;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n\tattr->size = offset;\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_synthetic_attr_calc_size(RBinJavaAttrInfo *attr) {\n\treturn attr ? 12 : 6;\n}\n\nR_API RBinJavaInterfaceInfo *r_bin_java_interface_new(RBinJavaObj *bin, const ut8 *buffer, ut64 sz) {\n\tRBinJavaInterfaceInfo *ifobj = NULL;\n\tifobj = R_NEW0 (RBinJavaInterfaceInfo);\n\tIFDBG eprintf(\"Parsing RBinJavaInterfaceInfo\\n\");\n\tif (ifobj) {\n\t\tif (buffer) {\n\t\t\tifobj->class_info_idx = R_BIN_JAVA_USHORT (buffer, 0);\n\t\t\tifobj->cp_class = r_bin_java_get_item_from_bin_cp_list (bin, ifobj->class_info_idx);\n\t\t\tif (ifobj->cp_class) {\n\t\t\t\tifobj->name = r_bin_java_get_item_name_from_bin_cp_list (bin, ifobj->cp_class);\n\t\t\t} else {\n\t\t\t\tifobj->name = r_str_dup (NULL, \"NULL\");\n\t\t\t}\n\t\t\tifobj->size = 2;\n\t\t} else {\n\t\t\tifobj->class_info_idx = 0;\n\t\t\tifobj->name = r_str_dup (NULL, \"NULL\");\n\t\t}\n\t}\n\treturn ifobj;\n}\n\nR_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->tag = type;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = (ut16) value;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\t/*if (bin->offset_sz == 4) {\n\t\tse->info.uninit_offset = value;\n\t\t} else {\n\t\tse->info.uninit_offset = (ut16) value;\n\t\t}*/\n\t\tse->info.uninit_offset = (ut16) value;\n\t}\n\treturn se;\n}\n\nR_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->file_offset = buf_offset;\n\tse->tag = buffer[offset];\n\toffset += 1;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tse->info.uninit_offset = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t}\n\tif (R_BIN_JAVA_STACKMAP_UNINIT < se->tag) {\n\t\tr_bin_java_verification_info_free (se);\n\t\treturn NULL;\n\t}\n\tse->size = offset;\n\treturn se;\n}\n\nR_API ut64 rbin_java_verification_info_calc_size(RBinJavaVerificationObj *se) {\n\tut64 sz = 1;\n\tif (!se) {\n\t\treturn 0;\n\t}\n\t// r_buf_read_at (bin->b, offset, (ut8*)(&se->tag), 1)\n\tswitch (se->tag) {\n\tcase R_BIN_JAVA_STACKMAP_OBJECT:\n\t\t// r_buf_read_at (bin->b, offset+1, (ut8*)buf, 2)\n\t\tsz += 2;\n\t\tbreak;\n\tcase R_BIN_JAVA_STACKMAP_UNINIT:\n\t\t// r_buf_read_at (bin->b, offset+1, (ut8*)buf, 2)\n\t\tsz += 2;\n\t\tbreak;\n\t}\n\treturn sz;\n}\n\nR_API RBinJavaStackMapFrameMetas *r_bin_java_determine_stack_frame_type(ut8 tag) {\n\tut8 type_value = 0;\n\tif (tag < 64) {\n\t\ttype_value = R_BIN_JAVA_STACK_FRAME_SAME;\n\t} else if (63 < tag && tag < 128) {\n\t\ttype_value = R_BIN_JAVA_STACK_FRAME_SAME_LOCALS_1;\n\t} else if (247 < tag && tag < 251) {\n\t\ttype_value = R_BIN_JAVA_STACK_FRAME_CHOP;\n\t} else if (tag == 251) {\n\t\ttype_value = R_BIN_JAVA_STACK_FRAME_SAME_FRAME_EXTENDED;\n\t} else if (251 < tag && tag < 255) {\n\t\ttype_value = R_BIN_JAVA_STACK_FRAME_APPEND;\n\t} else if (tag == 255) {\n\t\ttype_value = R_BIN_JAVA_STACK_FRAME_FULL_FRAME;\n\t} else {\n\t\ttype_value = R_BIN_JAVA_STACK_FRAME_RESERVED;\n\t}\n\treturn &R_BIN_JAVA_STACK_MAP_FRAME_METAS[type_value];\n}\n\nR_API ut64 r_bin_java_stack_map_frame_calc_size(RBinJavaStackMapFrame *sf) {\n\tut64 size = 0;\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaVerificationObj *se;\n\tif (sf) {\n\t\t// sf->tag = buffer[offset];\n\t\tsize += 1;\n\t\tswitch (sf->type) {\n\t\tcase R_BIN_JAVA_STACK_FRAME_SAME:\n\t\t\t// Nothing to read\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_SAME_LOCALS_1:\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_CHOP:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_SAME_FRAME_EXTENDED:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_APPEND:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_STACK_FRAME_FULL_FRAME:\n\t\t\t// sf->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\t// sf->number_of_locals = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->local_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\t// sf->number_of_stack_items = R_BIN_JAVA_USHORT (buffer, offset);\n\t\t\tsize += 2;\n\t\t\tr_list_foreach_safe (sf->stack_items, iter, iter_tmp, se) {\n\t\t\t\tsize += rbin_java_verification_info_calc_size (se);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Unknown type\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API RBinJavaStackMapFrame *r_bin_java_stack_map_frame_new(ut8 *buffer, ut64 sz, RBinJavaStackMapFrame *p_frame, ut64 buf_offset) {\n\tRBinJavaStackMapFrame *stack_frame = r_bin_java_default_stack_frame ();\n\tRBinJavaVerificationObj *se = NULL;\n\tut64 offset = 0;\n\tif (!stack_frame) {\n\t\treturn NULL;\n\t}\n\tstack_frame->tag = buffer[offset];\n\toffset += 1;\n\tstack_frame->metas->type_info = (void *) r_bin_java_determine_stack_frame_type (stack_frame->tag);\n\tstack_frame->type = ((RBinJavaStackMapFrameMetas *) stack_frame->metas->type_info)->type;\n\tstack_frame->file_offset = buf_offset;\n\tstack_frame->p_stack_frame = p_frame;\n\tswitch (stack_frame->type) {\n\tcase R_BIN_JAVA_STACK_FRAME_SAME:\n\t\t// Maybe?  1. Copy the previous frames locals and set the locals count.\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals;\n\t\t} else {\n\t\t\tIFINT eprintf(\"><?><\\n\");\n\t\t\tIFDBG eprintf(\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: TODO Stack Frame Same Locals Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_SAME_LOCALS_1:\n\t\t// 1. Read the stack type\n\t\tstack_frame->number_of_stack_items = 1;\n\t\tif (offset > sz) {\n\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\treturn NULL;\n\t\t}\n\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Parsed R_BIN_JAVA_STACK_FRAME_SAME_LOCALS_1.\\n\");\n\t\tif (se) {\n\t\t\toffset += se->size;\n\t\t} else {\n\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the Stack Items for the stack frame.\\n\");\n\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\treturn NULL;\n\t\t}\n\t\tr_list_append (stack_frame->stack_items, (void *) se);\n\t\t// Maybe?  3. Copy the previous frames locals and set the locals count.\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals;\n\t\t} else {\n\t\t\tIFDBG eprintf(\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: TODO Stack Frame Same Locals 1 Stack Element Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_CHOP:\n\t\t// 1. Calculate the max index we want to copy from the list of the\n\t\t// previous frames locals\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Parsing R_BIN_JAVA_STACK_FRAME_CHOP.\\n\");\n\t\t// ut16 k = 251 - stack_frame->tag;\n\t\t/*,\n\t\tidx = p_frame->number_of_locals - k;\n\t\t*/\n\t\t// 2.  read the uoffset value\n\t\tstack_frame->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// Maybe? 3. Copy the previous frames locals and set the locals count.\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals;\n\t\t} else {\n\t\t\tIFINT eprintf(\"><?><\\n\");\n\t\t\tIFDBG eprintf(\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: TODO Stack Frame Chop Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_SAME_FRAME_EXTENDED:\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Parsing R_BIN_JAVA_STACK_FRAME_SAME_FRAME_EXTENDED.\\n\");\n\t\t// 1. Read the uoffset\n\t\tstack_frame->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// 2. Read the stack element type\n\t\tstack_frame->number_of_stack_items = 1;\n\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (se) {\n\t\t\toffset += se->size;\n\t\t} else {\n\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the Stack Items for the stack frame.\\n\");\n\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\treturn NULL;\n\t\t}\n\t\tr_list_append (stack_frame->stack_items, (void *) se);\n\t\t// Maybe? 3. Copy the previous frames locals to the current locals\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals;\n\t\t} else {\n\t\t\tIFINT eprintf(\"><?><\\n\");\n\t\t\tIFDBG eprintf(\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: TODO Stack Frame Same Locals Frame Stack 1 Extended Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_APPEND:\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Parsing R_BIN_JAVA_STACK_FRAME_APPEND.\\n\");\n\t\t// 1. Calculate the max index we want to copy from the list of the\n\t\t// previous frames locals\n\t\tut16 k = stack_frame->tag - 251,\n\t\ti = 0;\n\t\t// 2. Read the uoffset\n\t\tstack_frame->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// Maybe? 3. Copy the previous frames locals to the current locals\n\t\t// copy_type_info_to_stack_frame_list_up_to_idx (p_frame->local_items, stack_frame->local_items, idx);\n\t\t// 4. Read off the rest of the appended locals types\n\t\tfor (i = 0; i < k; i++) {\n\t\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Parsing verifying the k'th frame: %d of %d.\\n\", i, k);\n\t\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Completed Parsing\\n\");\n\t\t\tif (se) {\n\t\t\t\toffset += se->size;\n\t\t\t} else {\n\t\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the locals for the stack frame.\\n\");\n\t\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tr_list_append (stack_frame->local_items, (void *) se);\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Breaking out of loop\");\n\t\tIFDBG eprintf(\"p_frame: %p\\n\", p_frame);\n\t\tif (p_frame) {\n\t\t\tstack_frame->number_of_locals = p_frame->number_of_locals + k;\n\t\t} else {\n\t\t\tIFINT eprintf(\"><?><\\n\");\n\t\t\tIFDBG eprintf(\"Unable to set previous stackframe with the number of locals (current info.code_attr.implicit_frame was probably not set :/)\");\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: TODO Stack Frame Same Locals Frame Stack 1 Extended Condition is untested, so there may be issues.\\n\");\n\t\tbreak;\n\tcase R_BIN_JAVA_STACK_FRAME_FULL_FRAME:\n\t\tIFDBG eprintf(\"r_bin_java_stack_map_frame_new: Parsing R_BIN_JAVA_STACK_FRAME_FULL_FRAME.\\n\");\n\t\tstack_frame->offset_delta = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// IFDBG eprintf (\"r_bin_java_stack_map_frame_new: Code Size > 65535, read(%d byte(s)), offset = 0x%08x.\\n\", var_sz, stack_frame->offset_delta);\n\t\t// Read the number of variables based on the max # local variable\n\t\tstack_frame->number_of_locals = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// IFDBG eprintf (\"r_bin_java_stack_map_frame_new: Max ulocalvar > 65535, read(%d byte(s)), number_of_locals = 0x%08x.\\n\", var_sz, stack_frame->number_of_locals);\n\t\tIFDBG r_bin_java_print_stack_map_frame_summary(stack_frame);\n\t\t// read the number of locals off the stack\n\t\tfor (i = 0; i < stack_frame->number_of_locals; i++) {\n\t\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (se) {\n\t\t\t\toffset += se->size;\n\t\t\t\t// r_list_append (stack_frame->local_items, (void *) se);\n\t\t\t} else {\n\t\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the locals for the stack frame.\\n\");\n\t\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tr_list_append (stack_frame->local_items, (void *) se);\n\t\t}\n\t\t// Read the number of stack items based on the max size of stack\n\t\tstack_frame->number_of_stack_items = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\t// IFDBG eprintf (\"r_bin_java_stack_map_frame_new: Max ustack items > 65535, read(%d byte(s)), number_of_locals = 0x%08x.\\n\", var_sz, stack_frame->number_of_stack_items);\n\t\t// read the stack items\n\t\tfor (i = 0; i < stack_frame->number_of_stack_items; i++) {\n\t\t\tse = r_bin_java_read_from_buffer_verification_info_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (se) {\n\t\t\t\toffset += se->size;\n\t\t\t\t// r_list_append (stack_frame->stack_items, (void *) se);\n\t\t\t} else {\n\t\t\t\teprintf (\"r_bin_java_stack_map_frame_new: Unable to parse the stack items for the stack frame.\\n\");\n\t\t\t\tr_bin_java_stack_frame_free (stack_frame);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tr_list_append (stack_frame->local_items, (void *) se);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"java: Unknown type\\n\");\n\t\tbreak;\n\t}\n\t// IFDBG eprintf (\"Created a stack frame at offset(0x%08\"PFMT64x\") of size: %d\\n\", buf_offset, stack_frame->size);//r_bin_java_print_stack_map_frame_summary(stack_frame);\n\tstack_frame->size = offset;\n\t// IFDBG r_bin_java_print_stack_map_frame_summary(stack_frame);\n\treturn stack_frame;\n}\n\nR_API ut16 r_bin_java_find_cp_class_ref_from_name_idx(RBinJavaObj *bin, ut16 name_idx) {\n\tut16 pos, len = (ut16) r_list_length (bin->cp_list);\n\tRBinJavaCPTypeObj *item;\n\tfor (pos = 0; pos < len; pos++) {\n\t\titem = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, pos);\n\t\tif (item && item->tag == R_BIN_JAVA_CP_CLASS && item->info.cp_class.name_idx == name_idx) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (pos != len) ? pos : 0;\n}\n\nR_API RBinJavaStackMapFrame *r_bin_java_default_stack_frame() {\n\tRBinJavaStackMapFrame *sf = R_NEW0 (RBinJavaStackMapFrame);\n\tif (!sf) {\n\t\treturn NULL;\n\t}\n\tsf->metas = R_NEW0 (RBinJavaMetaInfo);\n\tif (!sf->metas) {\n\t\tfree (sf);\n\t\treturn NULL;\n\t}\n\tsf->metas->type_info = (void *) &R_BIN_JAVA_STACK_MAP_FRAME_METAS[R_BIN_JAVA_STACK_FRAME_IMPLICIT];\n\tsf->type = ((RBinJavaStackMapFrameMetas *) sf->metas->type_info)->type;\n\tsf->local_items = r_list_newf (r_bin_java_verification_info_free);\n\tsf->stack_items = r_list_newf (r_bin_java_verification_info_free);\n\tsf->number_of_stack_items = 0;\n\tsf->number_of_locals = 0;\n\treturn sf;\n}\n\nR_API RBinJavaStackMapFrame *r_bin_java_build_stack_frame_from_local_variable_table(RBinJavaObj *bin, RBinJavaAttrInfo *attr) {\n\tRBinJavaStackMapFrame *sf = r_bin_java_default_stack_frame ();\n\tRBinJavaLocalVariableAttribute *lvattr = NULL;\n\tRBinJavaVerificationObj *type_item;\n\tRListIter *iter = NULL;\n\tut32 value_cnt = 0;\n\tut8 value;\n\tif (!sf || !bin || !attr || attr->type != R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TABLE_ATTR) {\n\t\teprintf (\"Attempting to create a stack_map frame from a bad attribute.\\n\");\n\t\treturn sf;\n\t}\n\tsf->number_of_locals = attr->info.local_variable_table_attr.table_length;\n\tr_list_foreach (attr->info.local_variable_table_attr.local_variable_table, iter, lvattr) {\n\t\tut32 pos = 0;\n\t\t// knock the array Types\n\t\twhile (lvattr->descriptor[pos] == '[') {\n\t\t\tpos++;\n\t\t}\n\t\tvalue = lvattr->descriptor[pos];\n\t\t// IFDBG eprintf (\"Found the following type value: %c at pos %d in %s\\n\", value, pos, lvattr->descriptor);\n\t\tswitch (value) {\n\t\tcase 'I':\n\t\tcase 'Z':\n\t\tcase 'S':\n\t\tcase 'B':\n\t\tcase 'C':\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_INTEGER, 0);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_FLOAT, 0);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_DOUBLE, 0);\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_LONG, 0);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\t// TODO: FIXME write something that will iterate over the CP Pool and find the\n\t\t\t// CONSTANT_Class_info referencing this\n\t\t{\n\t\t\tut16 idx = r_bin_java_find_cp_class_ref_from_name_idx (bin, lvattr->name_idx);\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_OBJECT, idx);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"r_bin_java_build_stack_frame_from_local_variable_table: \"\n\t\t\t\t\"not sure how to handle: name: %s, type: %s\\n\", lvattr->name, lvattr->descriptor);\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_NULL, 0);\n\t\t}\n\t\tif (type_item) {\n\t\t\tr_list_append (sf->local_items, (void *) type_item);\n\t\t}\n\t\tvalue_cnt++;\n\t}\n\tif (value_cnt != attr->info.local_variable_table_attr.table_length) {\n\t\tIFDBG eprintf(\"r_bin_java_build_stack_frame_from_local_variable_table: \"\n\t\t\"Number of locals not accurate.  Expected %d but got %d\",\n\t\tattr->info.local_variable_table_attr.table_length, value_cnt);\n\t}\n\treturn sf;\n}\n\nR_API ut64 r_bin_java_stack_map_table_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaStackMapFrame *sf;\n\tif (attr) {\n\t\t// attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\t\tsize += 6;\n\t\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n\t\t// Current spec does not call for variable sizes.\n\t\t// attr->info.stack_map_table_attr.number_of_entries = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\tr_list_foreach_safe (attr->info.stack_map_table_attr.stack_map_frame_entries, iter, iter_tmp, sf) {\n\t\t\tsize += r_bin_java_stack_map_frame_calc_size (sf);\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tRBinJavaStackMapFrame *stack_frame = NULL, *new_stack_frame = NULL;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tIFDBG eprintf(\"r_bin_java_stack_map_table_attr_new: New stack map allocated.\\n\");\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->info.stack_map_table_attr.stack_map_frame_entries = r_list_newf (r_bin_java_stack_frame_free);\n\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n\t// Current spec does not call for variable sizes.\n\tattr->info.stack_map_table_attr.number_of_entries = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tIFDBG eprintf(\"r_bin_java_stack_map_table_attr_new: Processing stack map, summary is:\\n\");\n\tIFDBG r_bin_java_print_stack_map_table_attr_summary(attr);\n\tfor (i = 0; i < attr->info.stack_map_table_attr.number_of_entries; i++) {\n\t\t// read next stack frame\n\t\tIFDBG eprintf(\"Reading StackMap Entry #%d @ 0x%08\"PFMT64x \"\\n\", i, buf_offset + offset);\n\t\tif (stack_frame == NULL && R_BIN_JAVA_GLOBAL_BIN && R_BIN_JAVA_GLOBAL_BIN->current_code_attr) {\n\t\t\tIFDBG eprintf(\"Setting an implicit frame at #%d @ 0x%08\"PFMT64x \"\\n\", i, buf_offset + offset);\n\t\t\tstack_frame = R_BIN_JAVA_GLOBAL_BIN->current_code_attr->info.code_attr.implicit_frame;\n\t\t}\n\t\tIFDBG eprintf(\"Reading StackMap Entry #%d @ 0x%08\"PFMT64x \", current stack_frame: %p\\n\", i, buf_offset + offset, stack_frame);\n\t\tif (offset > sz) {\n\t\t\tr_bin_java_stack_map_table_attr_free (attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_stack_frame = r_bin_java_stack_map_frame_new (buffer + offset, sz - offset, stack_frame, buf_offset + offset);\n\t\tif (new_stack_frame) {\n\t\t\toffset += new_stack_frame->size;\n\t\t\t// append stack frame to the list\n\t\t\tr_list_append (attr->info.stack_map_table_attr.stack_map_frame_entries, (void *) new_stack_frame);\n\t\t\tstack_frame = new_stack_frame;\n\t\t} else {\n\t\t\teprintf (\"r_bin_java_stack_map_table_attr_new: Unable to parse the stack frame for the stack map table.\\n\");\n\t\t\tr_bin_java_stack_map_table_attr_free (attr);\n\t\t\tattr = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (attr) {\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n// End attribute types new\n// Start new Constant Pool Types\nR_API RBinJavaCPTypeObj *r_bin_java_do_nothing_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\treturn (RBinJavaCPTypeObj *) NULL;\n}\n\nR_API ut64 r_bin_java_do_nothing_calc_size(RBinJavaCPTypeObj *obj) {\n\treturn 0;\n}\n\nR_API void r_bin_java_do_nothing_free(void /*RBinJavaCPTypeObj*/ *obj) {\n\treturn;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_unknown_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tobj = (RBinJavaCPTypeObj *) malloc (sizeof (RBinJavaCPTypeObj));\n\tif (obj) {\n\t\tmemset (obj, 0, sizeof (RBinJavaCPTypeObj));\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[R_BIN_JAVA_CP_UNKNOWN];\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_unknown_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\treturn 1LL;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_class_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tint quick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_CLASS, tag, sz, \"Class\");\n\tif (quick_check > 0) {\n\t\treturn NULL;\n\t}\n\tRBinJavaCPTypeObj *obj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (obj) {\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->info.cp_class.name_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_class_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// ut8 tag = buffer[0];\n\tsize += 1;\n\t// obj->info.cp_class.name_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_fieldref_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tint quick_check = 0;\n\tquick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_FIELDREF, tag, sz, \"FieldRef\");\n\tif (quick_check > 0) {\n\t\treturn obj;\n\t}\n\tobj = (RBinJavaCPTypeObj *) malloc (sizeof (RBinJavaCPTypeObj));\n\tif (obj) {\n\t\tmemset (obj, 0, sizeof (RBinJavaCPTypeObj));\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->info.cp_field.class_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\t\tobj->info.cp_field.name_and_type_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\n\t}\n\treturn (RBinJavaCPTypeObj *) obj;\n}\n\nR_API ut64 r_bin_java_fieldref_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_field.class_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 2;\n\t// obj->info.cp_field.name_and_type_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_methodref_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tint quick_check = 0;\n\tquick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_METHODREF, tag, sz, \"MethodRef\");\n\tif (quick_check > 0) {\n\t\treturn obj;\n\t}\n\tobj = (RBinJavaCPTypeObj *) malloc (sizeof (RBinJavaCPTypeObj));\n\tif (obj) {\n\t\tmemset (obj, 0, sizeof (RBinJavaCPTypeObj));\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->info.cp_method.class_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\t\tobj->info.cp_method.name_and_type_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_methodref_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_method.class_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 2;\n\t// obj->info.cp_method.name_and_type_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_interfacemethodref_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tint quick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_INTERFACEMETHOD_REF, tag, sz, \"InterfaceMethodRef\");\n\tif (quick_check > 0) {\n\t\treturn NULL;\n\t}\n\tRBinJavaCPTypeObj *obj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (obj) {\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);\n\t\tobj->info.cp_interface.class_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\t\tobj->info.cp_interface.name_and_type_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_interfacemethodref_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_interface.class_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 2;\n\t// obj->info.cp_interface.name_and_type_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_string_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tint quick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_STRING, tag, sz, \"String\");\n\tif (quick_check > 0) {\n\t\treturn NULL;\n\t}\n\tRBinJavaCPTypeObj *obj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (obj) {\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);\n\t\tobj->info.cp_string.string_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_string_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_string.string_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_integer_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tint quick_check = 0;\n\tquick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_INTEGER, tag, sz, \"Integer\");\n\tif (quick_check > 0) {\n\t\treturn obj;\n\t}\n\tobj = (RBinJavaCPTypeObj *) R_NEW0 (RBinJavaCPTypeObj);\n\tif (obj) {\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);\n\t\tmemset (&obj->info.cp_integer.bytes, 0, sizeof (obj->info.cp_integer.bytes));\n\t\tmemcpy (&obj->info.cp_integer.bytes.raw, buffer + 1, 4);\n\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_integer_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_string.string_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 4;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_float_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tint quick_check = 0;\n\tquick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_FLOAT, tag, sz, \"Float\");\n\tif (quick_check > 0) {\n\t\treturn obj;\n\t}\n\tobj = (RBinJavaCPTypeObj *) calloc (1, sizeof (RBinJavaCPTypeObj));\n\tif (obj) {\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);\n\t\tmemset (&obj->info.cp_float.bytes, 0, sizeof (obj->info.cp_float.bytes));\n\t\tmemcpy (&obj->info.cp_float.bytes.raw, buffer, 4);\n\t}\n\treturn (RBinJavaCPTypeObj *) obj;\n}\n\nR_API ut64 r_bin_java_float_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_string.string_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 4;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_long_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tint quick_check = 0;\n\tquick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_LONG, tag, sz, \"Long\");\n\tif (quick_check > 0) {\n\t\treturn obj;\n\t}\n\tobj = (RBinJavaCPTypeObj *) malloc (sizeof (RBinJavaCPTypeObj));\n\tif (obj) {\n\t\tmemset (obj, 0, sizeof (RBinJavaCPTypeObj));\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);\n\t\tmemset (&obj->info.cp_long.bytes, 0, sizeof (obj->info.cp_long.bytes));\n\t\tmemcpy (&(obj->info.cp_long.bytes), buffer + 1, 8);\n\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_long_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_string.string_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 8;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_double_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tint quick_check = 0;\n\tquick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_DOUBLE, tag, sz, \"Double\");\n\tif (quick_check > 0) {\n\t\treturn (RBinJavaCPTypeObj *) obj;\n\t}\n\tobj = (RBinJavaCPTypeObj *) malloc (sizeof (RBinJavaCPTypeObj));\n\tif (obj) {\n\t\tmemset (obj, 0, sizeof (RBinJavaCPTypeObj));\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);\n\t\tmemset (&obj->info.cp_double.bytes, 0, sizeof (obj->info.cp_double.bytes));\n\t\tmemcpy (&obj->info.cp_double.bytes, buffer + 1, 8);\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_double_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\t// tag\n\tsize += 1;\n\t// obj->info.cp_string.string_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 8;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_utf8_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj;\n\tint quick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_UTF8, tag, sz, \"Utf8\");\n\tif (quick_check > 0) {\n\t\treturn NULL;\n\t}\n\tif ((obj = R_NEW0 (RBinJavaCPTypeObj))) {\n\t\tmemset (obj, 0, sizeof (RBinJavaCPTypeObj));\n\t\tobj->tag = tag;\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);\n\t\tobj->info.cp_utf8.length = R_BIN_JAVA_USHORT (buffer, 1);\n\t\tobj->info.cp_utf8.bytes = (ut8 *) malloc (obj->info.cp_utf8.length + 1);\n\t\tif (obj->info.cp_utf8.bytes) {\n\t\t\tmemset (obj->info.cp_utf8.bytes, 0, obj->info.cp_utf8.length + 1);\n\t\t\tif (obj->info.cp_utf8.length < (sz - 3)) {\n\t\t\t\tmemcpy (obj->info.cp_utf8.bytes, buffer + 3, (sz - 3));\n\t\t\t\tobj->info.cp_utf8.length = sz - 3;\n\t\t\t} else {\n\t\t\t\tmemcpy (obj->info.cp_utf8.bytes, buffer + 3, obj->info.cp_utf8.length);\n\t\t\t}\n\t\t\tobj->value = obj->info.cp_utf8.bytes;\n\t\t} else {\n\t\t\tr_bin_java_obj_free (obj);\n\t\t\tobj = NULL;\n\t\t}\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_utf8_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\tsize += 1;\n\tif (obj && R_BIN_JAVA_CP_UTF8 == obj->tag) {\n\t\tsize += 2;\n\t\tsize += obj->info.cp_utf8.length;\n\t}\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_name_and_type_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj = NULL;\n\tint quick_check = 0;\n\tquick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_NAMEANDTYPE, tag, sz, \"RBinJavaCPTypeNameAndType\");\n\tif (quick_check > 0) {\n\t\treturn obj;\n\t}\n\tobj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (obj) {\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);;\n\t\tobj->tag = tag;\n\t\tobj->info.cp_name_and_type.name_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\t\tobj->info.cp_name_and_type.descriptor_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_name_and_type_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\tif (obj) {\n\t\tsize += 1;\n\t\t// obj->info.cp_name_and_type.name_idx = R_BIN_JAVA_USHORT (buffer, 1);\n\t\tsize += 2;\n\t\t// obj->info.cp_name_and_type.descriptor_idx = R_BIN_JAVA_USHORT (buffer, 3);\n\t\tsize += 2;\n\t}\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_methodtype_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tint quick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_METHODTYPE, tag, sz, \"RBinJavaCPTypeMethodType\");\n\tif (quick_check > 0) {\n\t\treturn NULL;\n\t}\n\tRBinJavaCPTypeObj *obj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (obj) {\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);;\n\t\tobj->tag = tag;\n\t\tobj->info.cp_method_type.descriptor_index = R_BIN_JAVA_USHORT (buffer, 1);\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_methodtype_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\tsize += 1;\n\t// obj->info.cp_method_type.descriptor_index = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_methodhandle_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tint quick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_METHODHANDLE, tag, sz, \"RBinJavaCPTypeMethodHandle\");\n\tif (quick_check > 0) {\n\t\treturn NULL;\n\t}\n\tRBinJavaCPTypeObj *obj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (obj) {\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);;\n\t\tobj->tag = tag;\n\t\tobj->info.cp_method_handle.reference_kind = buffer[1];\n\t\tobj->info.cp_method_handle.reference_index = R_BIN_JAVA_USHORT (buffer, 2);\n\t}\n\treturn obj;\n}\n\nR_API ut64 r_bin_java_methodhandle_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\tsize += 1;\n\t// obj->info.cp_method_handle.reference_index =  R_BIN_JAVA_USHORT (buffer, 2);\n\tsize += 2;\n\treturn size;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_invokedynamic_cp_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz) {\n\tut8 tag = buffer[0];\n\tRBinJavaCPTypeObj *obj;\n\tint quick_check = r_bin_java_quick_check (R_BIN_JAVA_CP_INVOKEDYNAMIC, tag, sz, \"RBinJavaCPTypeMethodHandle\");\n\tif (quick_check > 0) {\n\t\treturn NULL;\n\t}\n\tif ((obj = R_NEW0 (RBinJavaCPTypeObj))) {\n\t\tobj->metas = R_NEW0 (RBinJavaMetaInfo);\n\t\tobj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\tobj->name = r_str_dup (NULL, (const char *) R_BIN_JAVA_CP_METAS[tag].name);;\n\t\tobj->tag = tag;\n\t\tobj->info.cp_invoke_dynamic.bootstrap_method_attr_index = R_BIN_JAVA_USHORT (buffer, 1);\n\t\tobj->info.cp_invoke_dynamic.name_and_type_index = R_BIN_JAVA_USHORT (buffer, 3);\n\t}\n\treturn obj;\n}\n\nR_API int r_bin_java_check_reset_cp_obj(RBinJavaCPTypeObj *cp_obj, ut8 tag) {\n\tbool res = false;\n\tif (tag < R_BIN_JAVA_CP_METAS_SZ) {\n\t\tif (tag != cp_obj->tag) {\n\t\t\tif (cp_obj->tag == R_BIN_JAVA_CP_UTF8) {\n\t\t\t\tfree (cp_obj->info.cp_utf8.bytes);\n\t\t\t\tcp_obj->info.cp_utf8.bytes = NULL;\n\t\t\t\tcp_obj->info.cp_utf8.length = 0;\n\t\t\t\tfree (cp_obj->name);\n\t\t\t\tcp_obj->name = NULL;\n\t\t\t\tres = true;\n\t\t\t}\n\t\t\tcp_obj->tag = tag;\n\t\t\tcp_obj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[tag];\n\t\t\tcp_obj->name = strdup (R_BIN_JAVA_CP_METAS[tag].name);\n\t\t\tres = true;\n\t\t} else {\n\t\t\teprintf (\"Invalid tag\\n\");\n\t\t}\n\t} else {\n\t\teprintf (\"Invalid tag '%d'.\\n\", tag);\n\t}\n\treturn res;\n}\n\nR_API ut8 *r_bin_java_cp_get_4bytes(ut8 tag, ut32 *out_sz, const ut8 *buf, const ut64 len) {\n\tut8 *buffer = malloc (5);\n\tif (!buffer) {\n\t\treturn NULL;\n\t}\n\tut32 val = 0;\n\tif (!buffer || len < 4) {\n\t\tif (out_sz) {\n\t\t\t*out_sz = 0;\n\t\t}\n\t\tfree (buffer);\n\t\treturn NULL;\n\t}\n\tbuffer[0] = tag;\n\tval = R_BIN_JAVA_UINT (buf, 0);\n\tmemcpy (buffer + 1, (const char *) &val, 4);\n\t*out_sz = 5;\n\treturn buffer;\n}\n\nR_API ut8 *r_bin_java_cp_get_8bytes(ut8 tag, ut32 *out_sz, const ut8 *buf, const ut64 len) {\n\tut8 *buffer = malloc (10);\n\tif (!buffer) {\n\t\treturn NULL;\n\t}\n\tut64 val = 0;\n\tif (len < 8) {\n\t\t*out_sz = 0;\n\t\tfree (buffer);\n\t\treturn NULL;\n\t}\n\tbuffer[0] = tag;\n\tval = r_bin_java_raw_to_long (buf, 0);\n\tmemcpy (buffer + 1, (const char *) &val, 8);\n\t*out_sz = 9;\n\treturn buffer;\n}\n\nR_API ut8 *r_bin_java_cp_append_classref_and_name(RBinJavaObj *bin, ut32 *out_sz, const char *classname, const ut32 classname_len) {\n\tut16 use_name_idx = bin->cp_idx + 1;\n\tut8 *bytes = NULL, *name_bytes = NULL;\n\tname_bytes = r_bin_java_cp_get_utf8 (R_BIN_JAVA_CP_UTF8, out_sz, (const ut8 *) classname, classname_len);\n\tif (*out_sz > 0 && name_bytes) {\n\t\tut8 *idx_addr = (ut8 *) &use_name_idx;\n\t\tbytes = malloc (*out_sz + 3);\n\t\tmemcpy (bytes, name_bytes, *out_sz);\n\t\tbytes[*out_sz + 0] = R_BIN_JAVA_CP_CLASS;\n\t\tbytes[*out_sz + 1] = idx_addr[1];\n\t\tbytes[*out_sz + 2] = idx_addr[0];\n\t\t*out_sz += 3;\n\t}\n\tfree (name_bytes);\n\treturn bytes;\n}\n\nR_API ut8 *r_bin_java_cp_get_fref_bytes(RBinJavaObj *bin, ut32 *out_sz, ut8 tag, ut16 cn_idx, ut16 fn_idx, ut16 ft_idx) {\n\tut8 *bytes = NULL, *fnt_bytes = NULL;\n\tRBinJavaCPTypeObj *ref_cp_obj = NULL;\n\tut16 fnt_idx = 0, cref_idx = 0;\n\tut32 fnt_len = 0;\n\tut16 ref_cp_obj_idx = r_bin_java_find_cp_class_ref_from_name_idx (bin, cn_idx);\n\tif (!ref_cp_obj_idx) {\n\t\treturn NULL;\n\t}\n\tref_cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, ref_cp_obj_idx);\n\tif (ref_cp_obj) {\n\t\tcref_idx = ref_cp_obj->idx;\n\t}\n\tref_cp_obj = r_bin_java_find_cp_name_and_type_info (bin, fn_idx, ft_idx);\n\tif (ref_cp_obj) {\n\t\tfnt_idx = ref_cp_obj->idx;\n\t} else {\n\t\tfnt_bytes = r_bin_java_cp_get_name_type (bin, &fnt_len, fn_idx, ft_idx);\n\t\tfnt_idx = bin->cp_idx + 1;\n\t}\n\tif (cref_idx && fnt_idx) {\n\t\tbytes = r_bin_java_cp_get_fm_ref (bin, out_sz, tag, cref_idx, fnt_idx);\n\t\tif (fnt_bytes) {\n\t\t\tut8 *tbuf = malloc (fnt_len + *out_sz);\n\t\t\tif (!tbuf) {\n\t\t\t\tfree (bytes);\n\t\t\t\tfree (fnt_bytes);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t// copy the bytes to the new buffer\n\t\t\tmemcpy (tbuf, fnt_bytes, fnt_len);\n\t\t\tmemcpy (tbuf + fnt_len, bytes, *out_sz);\n\t\t\t// update the values free old buffer\n\t\t\t*out_sz += fnt_len;\n\t\t\tfree (bytes);\n\t\t\tbytes = tbuf;\n\t\t}\n\t}\n\tfree (fnt_bytes);\n\treturn bytes;\n}\n\nR_API ut8 *r_bin_java_cp_get_classref(RBinJavaObj *bin, ut32 *out_sz, const char *classname, const ut32 classname_len, const ut16 name_idx) {\n\tut16 use_name_idx = -1;\n\tut8 *bytes = NULL;\n\tif (name_idx == (ut16) - 1 && classname && *classname && classname_len > 0) {\n\t\t// find class_name_idx by class name\n\t\tRList *results = r_bin_java_find_cp_const_by_val_utf8 (bin, (const ut8 *) classname, classname_len);\n\t\tif (r_list_length (results) == 1) {\n\t\t\tuse_name_idx = (ut16) * ((ut32 *) r_list_get_n (results, 0));\n\t\t}\n\t\tr_list_free (results);\n\t} else if (name_idx != (ut16) - 1 && name_idx != 0) {\n\t\tuse_name_idx = name_idx;\n\t}\n\tif (use_name_idx == (ut16) - 1 && classname && *classname && classname_len > 0) {\n\t\tbytes = r_bin_java_cp_append_classref_and_name (bin, out_sz, classname, classname_len);\n\t} else if (use_name_idx != (ut16) - 1) {\n\t\tut8 *idx_addr = (ut8 *) &use_name_idx;\n\t\tbytes = malloc (3);\n\t\tif (!bytes) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbytes[0] = R_BIN_JAVA_CP_CLASS;\n\t\tbytes[1] = idx_addr[1];\n\t\tbytes[2] = idx_addr[0];\n\t\t*out_sz += 3;\n\t}\n\treturn bytes;\n}\n\nR_API ut8 *r_bin_java_cp_get_fm_ref(RBinJavaObj *bin, ut32 *out_sz, ut8 tag, ut16 class_idx, ut16 name_and_type_idx) {\n\treturn r_bin_java_cp_get_2_ut16 (bin, out_sz, tag, class_idx, name_and_type_idx);\n}\n\nR_API ut8 *r_bin_java_cp_get_2_ut16(RBinJavaObj *bin, ut32 *out_sz, ut8 tag, ut16 ut16_one, ut16 ut16_two) {\n\tut8 *bytes = malloc (7);\n\tif (!bytes) {\n\t\treturn NULL;\n\t}\n\tut8 *idx_addr = NULL;\n\tbytes[*out_sz] = tag;\n\t*out_sz += 1;\n\tidx_addr = (ut8 *) &ut16_one;\n\tbytes[*out_sz + 1] = idx_addr[1];\n\tbytes[*out_sz + 2] = idx_addr[0];\n\t*out_sz += 3;\n\tidx_addr = (ut8 *) &ut16_two;\n\tbytes[*out_sz + 1] = idx_addr[1];\n\tbytes[*out_sz + 2] = idx_addr[0];\n\t*out_sz += 3;\n\treturn bytes;\n}\n\nR_API ut8 *r_bin_java_cp_get_name_type(RBinJavaObj *bin, ut32 *out_sz, ut16 name_idx, ut16 type_idx) {\n\treturn r_bin_java_cp_get_2_ut16 (bin, out_sz, R_BIN_JAVA_CP_NAMEANDTYPE, name_idx, type_idx);\n}\n\nR_API ut8 *r_bin_java_cp_get_utf8(ut8 tag, ut32 *out_sz, const ut8 *buf, const ut64 len) {\n\tut8 *buffer = NULL;\n\tut16 sz = 0;\n\tut16 t = (ut16) len;\n\tif (len > 0 && len > (ut16) - 1) {\n\t\t*out_sz = 0;\n\t\treturn NULL;\n\t}\n\tsz = R_BIN_JAVA_USHORT (((ut8 *) (ut16 *) &t), 0);\n\t*out_sz = 3 + t; // tag + sz + bytes\n\tbuffer = malloc (*out_sz + 3);\n\tif (!buffer) {\n\t\treturn NULL;\n\t}\n\t// XXX - excess bytes are created to ensure null for string operations.\n\tmemset (buffer, 0, *out_sz + 3);\n\tbuffer[0] = tag;\n\tmemcpy (buffer + 1, (const char *) &sz, 2);\n\tmemcpy (buffer + 3, buf, *out_sz - 3);\n\treturn buffer;\n}\n\nR_API ut64 r_bin_java_invokedynamic_cp_calc_size(RBinJavaCPTypeObj *obj) {\n\tut64 size = 0;\n\tsize += 1;\n\t// obj->info.cp_invoke_dynamic.bootstrap_method_attr_index = R_BIN_JAVA_USHORT (buffer, 1);\n\tsize += 2;\n\t// obj->info.cp_invoke_dynamic.name_and_type_index = R_BIN_JAVA_USHORT (buffer, 3);\n\tsize += 2;\n\treturn size;\n}\n// End new Constant Pool types\n// Start free Constant Pool types\nR_API void r_bin_java_default_free(void /* RBinJavaCPTypeObj*/ *o) {\n\tRBinJavaCPTypeObj *obj = o;\n\tif (obj) {\n\t\tfree (obj->metas);\n\t\tfree (obj->name);\n\t\tfree (obj->value);\n\t\tfree (obj);\n\t}\n}\n\nR_API void r_bin_java_utf8_info_free(void /* RBinJavaCPTypeObj*/ *o) {\n\tRBinJavaCPTypeObj *obj = o;\n\tif (obj) {\n\t\tfree (obj->name);\n\t\tfree (obj->metas);\n\t\tfree (obj->info.cp_utf8.bytes);\n\t\tfree (obj);\n\t}\n}\n// Deallocs for type objects\nR_API void r_bin_java_obj_free(void /*RBinJavaCPTypeObj*/ *o) {\n\tRBinJavaCPTypeObj *obj = o;\n\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n}\n\nR_API void r_bin_java_print_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (attr == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *.\\n\");\n\t\treturn;\n\t}\n\t((RBinJavaAttrMetas *) attr->metas->type_info)->allocs->print_summary (attr);\n}\n\nR_API void r_bin_java_print_source_debug_attr_summary(RBinJavaAttrInfo *attr) {\n\tut32 i = 0;\n\tif (attr == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaSourceDebugExtensionAttr *.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Source Debug Extension Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Extension Length: %d\\n\", attr->length);\n\tEprintf (\"  Source Debug Extension value: \\n\");\n\tfor (i = 0; i < attr->length; i++) {\n\t\tEprintf (\"%c\", attr->info.debug_extensions.debug_extension[i]);\n\t}\n\tEprintf (\"\\n  Source Debug Extension End\\n\");\n}\n\nR_API void r_bin_java_print_unknown_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (attr == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *Unknown.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Unknown Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n}\n\nR_API void r_bin_java_print_code_exceptions_attr_summary(RBinJavaExceptionEntry *exc_entry) {\n\tif (exc_entry == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaExceptionEntry *.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"  Exception Table Entry Information\\n\");\n\tEprintf (\"    offset:\t0x%08\"PFMT64x\"\\n\", exc_entry->file_offset);\n\tEprintf (\"    catch_type: %d\\n\", exc_entry->catch_type);\n\tEprintf (\"    start_pc:   0x%04x\\n\", exc_entry->start_pc);\n\tEprintf (\"    end_pc:\t0x%04x\\n\", exc_entry->end_pc);\n\tEprintf (\"    handler_pc: 0x%04x\\n\", exc_entry->handler_pc);\n}\n// End free Constant Pool types\nR_API void r_bin_java_print_code_attr_summary(RBinJavaAttrInfo *attr) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaExceptionEntry *exc_entry = NULL;\n\tRBinJavaAttrInfo *_attr = NULL;\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *Code.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Code Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d, Attribute Count: %d\\n\", attr->length, attr->info.code_attr.attributes_count);\n\tEprintf (\"    Max Stack: %d\\n\", attr->info.code_attr.max_stack);\n\tEprintf (\"    Max Locals: %d\\n\", attr->info.code_attr.max_locals);\n\tEprintf (\"    Code Length: %d\\n\", attr->info.code_attr.code_length);\n\tEprintf (\"    Code At Offset: 0x%08\"PFMT64x \"\\n\", (ut64) attr->info.code_attr.code_offset);\n\tEprintf (\"Code Attribute Exception Table Information:\\n\");\n\tEprintf (\"  Exception Table Length: %d\\n\", attr->info.code_attr.exception_table_length);\n\tif (attr->info.code_attr.exception_table) {\n\t\t// Delete the attr entries\n\t\tr_list_foreach_safe (attr->info.code_attr.exception_table, iter, iter_tmp, exc_entry) {\n\t\t\tr_bin_java_print_code_exceptions_attr_summary (exc_entry);\n\t\t}\n\t}\n\tEprintf (\"  Implicit Method Stack Frame:\\n\");\n\tr_bin_java_print_stack_map_frame_summary (attr->info.code_attr.implicit_frame);\n\tEprintf (\"Code Attribute Attributes Information:\\n\");\n\tif (attr->info.code_attr.attributes && attr->info.code_attr.attributes_count > 0) {\n\t\tEprintf (\"  Code Attribute Attributes Count: %d\\n\", attr->info.code_attr.attributes_count);\n\t\tr_list_foreach_safe (attr->info.code_attr.attributes, iter, iter_tmp, _attr) {\n\t\t\tr_bin_java_print_attr_summary (_attr);\n\t\t}\n\t}\n}\n\nR_API void r_bin_java_print_constant_value_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *ConstantValue.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Constant Value Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tEprintf (\"  ConstantValue Index: %d\\n\", attr->info.constant_value_attr.constantvalue_idx);\n}\n\nR_API void r_bin_java_print_deprecated_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *Deperecated.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Deperecated Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n}\n\nR_API void r_bin_java_print_enclosing_methods_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *Deperecated.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Enclosing Method Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tEprintf (\"  Class Info Index : 0x%02x\\n\", attr->info.enclosing_method_attr.class_idx);\n\tEprintf (\"  Method Name and Type Index : 0x%02x\\n\", attr->info.enclosing_method_attr.method_idx);\n\tEprintf (\"  Class Name : %s\\n\", attr->info.enclosing_method_attr.class_name);\n\tEprintf (\"  Method Name and Desc : %s %s\\n\", attr->info.enclosing_method_attr.method_name, attr->info.enclosing_method_attr.method_descriptor);\n}\n\nR_API void r_bin_java_print_exceptions_attr_summary(RBinJavaAttrInfo *attr) {\n\tut32 i = 0;\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *Exceptions.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Exceptions Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tfor (i = 0; i < attr->info.exceptions_attr.number_of_exceptions; i++) {\n\t\tEprintf (\"  Exceptions Attribute Index[%d]: %d\\n\", i, attr->info.exceptions_attr.exception_idx_table[i]);\n\t}\n}\n\nR_API void r_bin_java_print_classes_attr_summary(RBinJavaClassesAttribute *icattr) {\n\tif (!icattr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaClassesAttribute* (InnerClasses element).\\n\");\n\t\treturn;\n\t}\n\teprintf (\"   Inner Classes Class Attribute Offset: 0x%08\"PFMT64x \"\\n\", icattr->file_offset);\n\teprintf (\"   Inner Classes Class Attribute Class Name (%d): %s\\n\", icattr->inner_name_idx, icattr->name);\n\teprintf (\"   Inner Classes Class Attribute Class inner_class_info_idx: %d\\n\", icattr->inner_class_info_idx);\n\teprintf (\"   Inner Classes Class Attribute Class inner_class_access_flags: 0x%02x %s\\n\", icattr->inner_class_access_flags, icattr->flags_str);\n\teprintf (\"   Inner Classes Class Attribute Class outer_class_info_idx: %d\\n\", icattr->outer_class_info_idx);\n\teprintf (\"   Inner Classes Class Field Information:\\n\");\n\tr_bin_java_print_field_summary (icattr->clint_field);\n\teprintf (\"   Inner Classes Class Field Information:\\n\");\n\tr_bin_java_print_field_summary (icattr->clint_field);\n\teprintf (\"   Inner Classes Class Attr Info Information:\\n\");\n\tr_bin_java_print_attr_summary (icattr->clint_attr);\n}\n\nR_API void r_bin_java_print_inner_classes_attr_summary(RBinJavaAttrInfo *attr) {\n\tRBinJavaClassesAttribute *icattr;\n\tRListIter *iter, *iter_tmp;\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *InnerClasses.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Inner Classes Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tr_list_foreach_safe (attr->info.inner_classes_attr.classes, iter, iter_tmp, icattr) {\n\t\tr_bin_java_print_classes_attr_summary (icattr);\n\t}\n}\n\nR_API void r_bin_java_print_line_number_attr_summary(RBinJavaLineNumberAttribute *lnattr) {\n\tif (!lnattr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaLineNumberAttribute *.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"  Line Number Attribute Offset: 0x%08\"PFMT64x \"\\n\", lnattr->file_offset);\n\tEprintf (\"  Line Number Attribute StartPC: %d\\n\", lnattr->start_pc);\n\tEprintf (\"  Line Number Attribute LineNumber: %d\\n\", lnattr->line_number);\n}\n\nR_API void r_bin_java_print_line_number_table_attr_summary(RBinJavaAttrInfo *attr) {\n\tRBinJavaLineNumberAttribute *lnattr;\n\tRListIter *iter, *iter_tmp;\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *LineNumberTable.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Line Number Table Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tr_list_foreach_safe (attr->info.line_number_table_attr.line_number_table, iter, iter_tmp, lnattr) {\n\t\tr_bin_java_print_line_number_attr_summary (lnattr);\n\t}\n}\n\nR_API void r_bin_java_print_local_variable_attr_summary(RBinJavaLocalVariableAttribute *lvattr) {\n\tif (!lvattr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaLocalVariableAttribute *.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"  Local Variable Attribute offset: 0x%08\"PFMT64x \"\\n\", lvattr->file_offset);\n\tEprintf (\"  Local Variable Attribute start_pc: %d\\n\", lvattr->start_pc);\n\tEprintf (\"  Local Variable Attribute Length: %d\\n\", lvattr->length);\n\tEprintf (\"  Local Variable Attribute name_idx: %d\\n\", lvattr->name_idx);\n\tEprintf (\"  Local Variable Attribute name: %s\\n\", lvattr->name);\n\tEprintf (\"  Local Variable Attribute descriptor_idx: %d\\n\", lvattr->descriptor_idx);\n\tEprintf (\"  Local Variable Attribute descriptor: %s\\n\", lvattr->descriptor);\n\tEprintf (\"  Local Variable Attribute index: %d\\n\", lvattr->index);\n}\n\nR_API void r_bin_java_print_local_variable_table_attr_summary(RBinJavaAttrInfo *attr) {\n\tRBinJavaLocalVariableAttribute *lvattr;\n\tRListIter *iter, *iter_tmp;\n\tif (attr == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *LocalVariableTable.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Local Variable Table Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tr_list_foreach_safe (attr->info.local_variable_table_attr.local_variable_table, iter, iter_tmp, lvattr) {\n\t\tr_bin_java_print_local_variable_attr_summary (lvattr);\n\t}\n}\n\nR_API void r_bin_java_print_local_variable_type_attr_summary(RBinJavaLocalVariableTypeAttribute *lvattr) {\n\tif (!lvattr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaLocalVariableTypeAttribute *.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"   Local Variable Type Attribute offset: 0x%08\"PFMT64x \"\\n\", lvattr->file_offset);\n\teprintf (\"   Local Variable Type Attribute start_pc: %d\\n\", lvattr->start_pc);\n\teprintf (\"   Local Variable Type Attribute Length: %d\\n\", lvattr->length);\n\teprintf (\"   Local Variable Type Attribute name_idx: %d\\n\", lvattr->name_idx);\n\teprintf (\"   Local Variable Type Attribute name: %s\\n\", lvattr->name);\n\teprintf (\"   Local Variable Type Attribute signature_idx: %d\\n\", lvattr->signature_idx);\n\teprintf (\"   Local Variable Type Attribute signature: %s\\n\", lvattr->signature);\n\teprintf (\"   Local Variable Type Attribute index: %d\\n\", lvattr->index);\n}\n\nR_API void r_bin_java_print_local_variable_type_table_attr_summary(RBinJavaAttrInfo *attr) {\n\tRBinJavaLocalVariableTypeAttribute *lvtattr;\n\tRListIter *iter, *iter_tmp;\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *LocalVariableTable.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"Local Variable Type Table Attribute Information:\\n\");\n\teprintf (\"   Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\teprintf (\"   Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\teprintf (\"   Attribute Length: %d\\n\", attr->length);\n\tr_list_foreach_safe (attr->info.local_variable_type_table_attr.local_variable_table, iter, iter_tmp, lvtattr) {\n\t\tr_bin_java_print_local_variable_type_attr_summary (lvtattr);\n\t}\n}\n\nR_API void r_bin_java_print_signature_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *SignatureAttr.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Signature Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tEprintf (\"  Signature UTF8 Index: %d\\n\", attr->info.signature_attr.signature_idx);\n\tEprintf (\"  Signature string: %s\\n\", attr->info.signature_attr.signature);\n}\n\nR_API void r_bin_java_print_source_code_file_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (!attr) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *SourceFile.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Source File Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tEprintf (\"  Source File Index: %d\\n\", attr->info.source_file_attr.sourcefile_idx);\n}\n\nR_API void r_bin_java_print_synthetic_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (attr == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaAttrInfo *Synthetic.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Synthetic Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tEprintf (\"  Attribute Index: %d\\n\", attr->info.source_file_attr.sourcefile_idx);\n}\n\nR_API void r_bin_java_print_stack_map_table_attr_summary(RBinJavaAttrInfo *attr) {\n\tRListIter *iter, *iter_tmp;\n\tRList *ptrList;\n\tRBinJavaStackMapFrame *frame;\n\tif (attr == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaStackMapTableAttr*  .\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"StackMapTable Attribute Information:\\n\");\n\tEprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\tEprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\tEprintf (\"  Attribute Length: %d\\n\", attr->length);\n\tEprintf (\"  StackMapTable Method Code Size: 0x%08x\\n\", attr->info.stack_map_table_attr.code_size);\n\tEprintf (\"  StackMapTable Frame Entries: 0x%08x\\n\", attr->info.stack_map_table_attr.number_of_entries);\n\tEprintf (\"  StackMapTable Frames:\\n\");\n\tptrList = attr->info.stack_map_table_attr.stack_map_frame_entries;\n\tif (ptrList) {\n\t\tr_list_foreach_safe (ptrList, iter, iter_tmp, frame) {\n\t\t\tr_bin_java_print_stack_map_frame_summary (frame);\n\t\t}\n\t}\n}\n\nR_API void r_bin_java_print_stack_map_frame_summary(RBinJavaStackMapFrame *obj) {\n\tRListIter *iter, *iter_tmp;\n\tRList *ptrList;\n\tRBinJavaVerificationObj *ver_obj;\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaStackMapFrame*  .\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Stack Map Frame Information\\n\");\n\tEprintf (\"  Tag Value = 0x%02x Name: %s\\n\", obj->tag, ((RBinJavaStackMapFrameMetas *) obj->metas->type_info)->name);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\\n\", obj->file_offset);\n\tEprintf (\"  Local Variable Count = 0x%04x\\n\", obj->number_of_locals);\n\tEprintf (\"  Stack Items Count = 0x%04x\\n\", obj->number_of_stack_items);\n\tEprintf (\"  Local Variables:\\n\");\n\tptrList = obj->local_items;\n\tr_list_foreach_safe (ptrList, iter, iter_tmp, ver_obj) {\n\t\tr_bin_java_print_verification_info_summary (ver_obj);\n\t}\n\tEprintf (\"  Stack Items:\\n\");\n\tptrList = obj->stack_items;\n\tr_list_foreach_safe (ptrList, iter, iter_tmp, ver_obj) {\n\t\tr_bin_java_print_verification_info_summary (ver_obj);\n\t}\n}\n\nR_API void r_bin_java_print_verification_info_summary(RBinJavaVerificationObj *obj) {\n\tut8 tag_value = R_BIN_JAVA_STACKMAP_UNKNOWN;\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaVerificationObj*  .\\n\");\n\t\treturn;\n\t}\n\tif (obj->tag < R_BIN_JAVA_STACKMAP_UNKNOWN) {\n\t\ttag_value = obj->tag;\n\t}\n\tEprintf (\"Verification Information\\n\");\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\", obj->file_offset);\n\tEprintf (\"  Tag Value = 0x%02x\\n\", obj->tag);\n\tEprintf (\"  Name = %s\\n\", R_BIN_JAVA_VERIFICATION_METAS[tag_value].name);\n\tif (obj->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tEprintf (\"  Object Constant Pool Index = 0x%x\\n\", obj->info.obj_val_cp_idx);\n\t} else if (obj->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tEprintf (\"  Uninitialized Object offset in code = 0x%x\\n\", obj->info.uninit_offset);\n\t}\n}\n\nR_API void r_bin_java_print_field_summary(RBinJavaField *field) {\n\tRBinJavaAttrInfo *attr;\n\tRListIter *iter, *iter_tmp;\n\tif (field) {\n\t\tif (field->type == R_BIN_JAVA_FIELD_TYPE_METHOD) {\n\t\t\tr_bin_java_print_method_summary (field);\n\t\t} else {\n#if 0\n\t\t\tr_bin_java_print_interface_summary (field);\n\t\t\treturn;\n\t\t} * /\n#endif\n\t\t\tEprintf (\"Field Summary Information:\\n\");\n\t\t\tEprintf (\"  File Offset: 0x%08\"PFMT64x \"\\n\", field->file_offset);\n\t\t\tEprintf (\"  Name Index: %d (%s)\\n\", field->name_idx, field->name);\n\t\t\tEprintf (\"  Descriptor Index: %d (%s)\\n\", field->descriptor_idx, field->descriptor);\n\t\t\tEprintf (\"  Access Flags: 0x%02x (%s)\\n\", field->flags, field->flags_str);\n\t\t\tEprintf (\"  Field Attributes Count: %d\\n\", field->attr_count);\n\t\t\tEprintf (\"  Field Attributes:\\n\");\n\t\t\tr_list_foreach_safe (field->attributes, iter, iter_tmp, attr) {\n\t\t\t\tr_bin_java_print_attr_summary (attr);\n\t\t\t}\n\t\t}\n\t} else {\n\t\teprintf (\"Attempting to print an invalid RBinJavaField* Field.\\n\");\n\t}\n}\n\nR_API void r_bin_java_print_method_summary(RBinJavaField *field) {\n\tRBinJavaAttrInfo *attr;\n\tRListIter *iter, *iter_tmp;\n\tif (field == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaField* Method.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Method Summary Information:\\n\");\n\tEprintf (\"  File Offset: 0x%08\"PFMT64x \"\\n\", field->file_offset);\n\tEprintf (\"  Name Index: %d (%s)\\n\", field->name_idx, field->name);\n\tEprintf (\"  Descriptor Index: %d (%s)\\n\", field->descriptor_idx, field->descriptor);\n\tEprintf (\"  Access Flags: 0x%02x (%s)\\n\", field->flags, field->flags_str);\n\tEprintf (\"  Method Attributes Count: %d\\n\", field->attr_count);\n\tEprintf (\"  Method Attributes:\\n\");\n\tr_list_foreach_safe (field->attributes, iter, iter_tmp, attr) {\n\t\tr_bin_java_print_attr_summary (attr);\n\t}\n}\n/*\n   R_API void r_bin_java_print_interface_summary(ut16 idx) {//RBinJavaField *field) {\n        RBinJavaAttrInfo *attr;\n        RBinJavaCPTypeObj *class_info;\n        RListIter *iter, *iter_tmp;\n        if (field == NULL) {\n                eprintf (\"Attempting to print an invalid RBinJavaField* Interface.\\n\");\n                return;\n        }\n        eprintf (\"Interface Summary Information:\\n\");\n        eprintf (\"\tFile offset: 0x%08\"PFMT64x\"\", field->file_offset);\n        eprintf (\"\tAccess Flags: %d\\n\", field->flags);\n        eprintf (\"\tName Index: %d (%s)\\n\", field->name_idx, field->name);\n        eprintf (\"\tDescriptor Index: %d (%s)\\n\", field->descriptor_idx, field->descriptor);\n        eprintf (\"\tInterface Attributes Count: %d\\n\", field->attr_count);\n        eprintf (\"\tInterface Attributes:\\n\");\n        r_list_foreach_safe (field->attributes, iter, iter_tmp, attr) {\n                r_bin_java_print_attr_summary(attr);\n        }\n   }\n */\nR_API void r_bin_java_print_interfacemethodref_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  InterfaceMethodRef.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"InterfaceMethodRef ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tClass Index = %d\\n\", obj->info.cp_interface.class_idx);\n\teprintf (\"\tName and type Index = %d\\n\", obj->info.cp_interface.name_and_type_idx);\n}\n\nR_API char *r_bin_java_print_interfacemethodref_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_interface.class_idx, obj->info.cp_interface.name_and_type_idx);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_interface.class_idx, obj->info.cp_interface.name_and_type_idx);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_methodhandle_cp_summary(RBinJavaCPTypeObj *obj) {\n\tut8 ref_kind;\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  RBinJavaCPTypeMethodHandle.\\n\");\n\t\treturn;\n\t}\n\tref_kind = obj->info.cp_method_handle.reference_kind;\n\teprintf (\"MethodHandle ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tReference Kind = (0x%02x) %s\\n\", ref_kind, R_BIN_JAVA_REF_METAS[ref_kind].name);\n\teprintf (\"\tReference Index = %d\\n\", obj->info.cp_method_handle.reference_index);\n}\n\nR_API char *r_bin_java_print_methodhandle_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tut8 ref_kind = obj->info.cp_method_handle.reference_kind;\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%s.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tR_BIN_JAVA_REF_METAS[ref_kind].name, obj->info.cp_method_handle.reference_index);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%s.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tR_BIN_JAVA_REF_METAS[ref_kind].name, obj->info.cp_method_handle.reference_index);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_methodtype_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  RBinJavaCPTypeMethodType.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"MethodType ConstantPool Type (%d) \", obj->metas->ord);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\", obj->file_offset);\n\tEprintf (\"  Descriptor Index = 0x%02x\\n\", obj->info.cp_method_type.descriptor_index);\n}\n\nR_API char *r_bin_java_print_methodtype_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_method_type.descriptor_index);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_method_type.descriptor_index);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_invokedynamic_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  RBinJavaCPTypeInvokeDynamic.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"InvokeDynamic ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tBootstrap Method Attr Index = (0x%02x)\\n\", obj->info.cp_invoke_dynamic.bootstrap_method_attr_index);\n\teprintf (\"\tBootstrap Name and Type Index = (0x%02x)\\n\", obj->info.cp_invoke_dynamic.name_and_type_index);\n}\n\nR_API char *r_bin_java_print_invokedynamic_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_invoke_dynamic.bootstrap_method_attr_index,\n\t\t\tobj->info.cp_invoke_dynamic.name_and_type_index);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_invoke_dynamic.bootstrap_method_attr_index,\n\t\t\t\t\tobj->info.cp_invoke_dynamic.name_and_type_index);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_methodref_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  MethodRef.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"MethodRef ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tClass Index = %d\\n\", obj->info.cp_method.class_idx);\n\teprintf (\"\tName and type Index = %d\\n\", obj->info.cp_method.name_and_type_idx);\n}\n\nR_API char *r_bin_java_print_methodref_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_method.class_idx,\n\t\t\tobj->info.cp_method.name_and_type_idx);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_method.class_idx,\n\t\t\t\t\tobj->info.cp_method.name_and_type_idx);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_fieldref_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  FieldRef.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"FieldRef ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tClass Index = %d\\n\", obj->info.cp_field.class_idx);\n\teprintf (\"\tName and type Index = %d\\n\", obj->info.cp_field.name_and_type_idx);\n}\n\nR_API char *r_bin_java_print_fieldref_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_field.class_idx,\n\t\t\tobj->info.cp_field.name_and_type_idx);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_field.class_idx,\n\t\t\t\t\tobj->info.cp_field.name_and_type_idx);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_classref_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  ClassRef.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"ClassRef ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tName Index = %d\\n\", obj->info.cp_class.name_idx);\n}\n\nR_API char *r_bin_java_print_classref_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_class.name_idx);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_class.name_idx);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_string_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (!obj) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  String.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"String ConstantPool Type (%d) \", obj->metas->ord);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\", obj->file_offset);\n\tEprintf (\"  String Index = %d\\n\", obj->info.cp_string.string_idx);\n}\n\nR_API char *r_bin_java_print_string_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_string.string_idx);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset,\n\t\t\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_string.string_idx);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_integer_cp_summary(RBinJavaCPTypeObj *obj) {\n\tut8 *b = NULL;\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  Integer.\\n\");\n\t\treturn;\n\t}\n\tb = obj->info.cp_integer.bytes.raw;\n\teprintf (\"Integer ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tbytes = %02x %02x %02x %02x\\n\", b[0], b[1], b[2], b[3]);\n\teprintf (\"\tinteger = %d\\n\", R_BIN_JAVA_UINT (obj->info.cp_integer.bytes.raw, 0));\n}\n\nR_API char *r_bin_java_print_integer_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.0x%08x\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tR_BIN_JAVA_UINT (obj->info.cp_integer.bytes.raw, 0));\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.0x%08x\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tR_BIN_JAVA_UINT (obj->info.cp_integer.bytes.raw, 0));\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_float_cp_summary(RBinJavaCPTypeObj *obj) {\n\tut8 *b = NULL;\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  Double.\\n\");\n\t\treturn;\n\t}\n\tb = obj->info.cp_float.bytes.raw;\n\tEprintf (\"Float ConstantPool Type (%d) \", obj->metas->ord);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\", obj->file_offset);\n\tEprintf (\"  Bytes = %02x %02x %02x %02x\\n\", b[0], b[1], b[2], b[3]);\n\tEprintf (\"  Float = %f\\n\", R_BIN_JAVA_FLOAT (obj->info.cp_float.bytes.raw, 0));\n}\n\nR_API char *r_bin_java_print_float_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%f\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tR_BIN_JAVA_FLOAT (obj->info.cp_float.bytes.raw, 0));\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%f\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tR_BIN_JAVA_FLOAT (obj->info.cp_float.bytes.raw, 0));\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_long_cp_summary(RBinJavaCPTypeObj *obj) {\n\tut8 *b = NULL;\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  Long.\\n\");\n\t\treturn;\n\t}\n\tb = obj->info.cp_long.bytes.raw;\n\tEprintf (\"Long ConstantPool Type (%d) \", obj->metas->ord);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\", obj->file_offset);\n\tEprintf (\"  High-Bytes = %02x %02x %02x %02x\\n\", b[0], b[1], b[2], b[3]);\n\tEprintf (\"  Low-Bytes = %02x %02x %02x %02x\\n\", b[4], b[5], b[6], b[7]);\n\tEprintf (\"  Long = %08\"PFMT64x \"\\n\", r_bin_java_raw_to_long (obj->info.cp_long.bytes.raw, 0));\n}\n\nR_API char *r_bin_java_print_long_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.0x%08\"PFMT64x \"\",\n\t\t\tobj->metas->ord,\n\t\t\tobj->file_offset,\n\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tr_bin_java_raw_to_long (obj->info.cp_long.bytes.raw, 0));\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.0x%08\"PFMT64x \"\",\n\t\t\t\t\tobj->metas->ord,\n\t\t\t\t\tobj->file_offset,\n\t\t\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tr_bin_java_raw_to_long (obj->info.cp_long.bytes.raw, 0));\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_double_cp_summary(RBinJavaCPTypeObj *obj) {\n\tut8 *b = NULL;\n\tif (!obj) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  Double.\\n\");\n\t\treturn;\n\t}\n\tb = obj->info.cp_double.bytes.raw;\n\tEprintf (\"Double ConstantPool Type (%d) \", obj->metas->ord);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\", obj->file_offset);\n\tEprintf (\"  High-Bytes = %02x %02x %02x %02x\\n\", b[0], b[1], b[2], b[3]);\n\tEprintf (\"  Low-Bytes = %02x %02x %02x %02x\\n\", b[4], b[5], b[6], b[7]);\n\tEprintf (\"  Double = %f\\n\", r_bin_java_raw_to_double (obj->info.cp_double.bytes.raw, 0));\n}\n\nR_API char *r_bin_java_print_double_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%f\",\n\t\t\tobj->metas->ord,\n\t\t\tobj->file_offset,\n\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tr_bin_java_raw_to_double (obj->info.cp_double.bytes.raw, 0));\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%f\",\n\t\t\t\t\tobj->metas->ord,\n\t\t\t\t\tobj->file_offset,\n\t\t\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tr_bin_java_raw_to_double (obj->info.cp_double.bytes.raw, 0));\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_name_and_type_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  Name_And_Type.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Name_And_Type ConstantPool Type (%d) \", obj->metas->ord);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\", obj->file_offset);\n\tEprintf (\"  name_idx = (%d)\\n\", obj->info.cp_name_and_type.name_idx);\n\tEprintf (\"  descriptor_idx = (%d)\\n\", obj->info.cp_name_and_type.descriptor_idx);\n}\n\nR_API char *r_bin_java_print_name_and_type_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_name_and_type.name_idx,\n\t\t\tobj->info.cp_name_and_type.descriptor_idx);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%d\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_name_and_type.name_idx,\n\t\t\t\t\tobj->info.cp_name_and_type.descriptor_idx);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_utf8_cp_summary(RBinJavaCPTypeObj *obj) {\n\tif (obj == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaCPTypeObj*  Utf8.\\n\");\n\t\treturn;\n\t}\n\tchar *str = convert_string ((const char *) obj->info.cp_utf8.bytes, obj->info.cp_utf8.length);\n\teprintf (\"UTF8 ConstantPool Type (%d) \", obj->metas->ord);\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", obj->file_offset);\n\teprintf (\"\tlength = %d\\n\", obj->info.cp_utf8.length);\n\teprintf (\"\tutf8 = %s\\n\", str);\n\tfree (str);\n}\n\nR_API char *r_bin_java_print_utf8_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *utf8_str = r_hex_bin2strdup (obj->info.cp_utf8.bytes, obj->info.cp_utf8.length);\n\tchar *value = malloc (size + strlen (utf8_str));\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%s\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\tobj->info.cp_utf8.length,\n\t\t\tutf8_str);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size + strlen (utf8_str));\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s.%d.%s\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name,\n\t\t\t\t\tobj->info.cp_utf8.length,\n\t\t\t\t\tutf8_str);\n\t\t\t}\n\t\t}\n\t}\n\tfree (utf8_str);\n\treturn value;\n}\n\nR_API void r_bin_java_print_null_cp_summary(RBinJavaCPTypeObj *obj) {\n\teprintf (\"Unknown ConstantPool Type Tag: 0x%04x .\\n\", obj->tag);\n}\n\nR_API char *r_bin_java_print_null_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255, consumed = 0;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name);\n\t\tif (consumed >= size - 1) {\n\t\t\tfree (value);\n\t\t\tsize += size >> 1;\n\t\t\tvalue = malloc (size);\n\t\t\tif (value) {\n\t\t\t\tmemset (value, 0, size);\n\t\t\t\tconsumed = snprintf (value, size, \"%d.0x%04\"PFMT64x \".%s\",\n\t\t\t\t\tobj->metas->ord, obj->file_offset,\n\t\t\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->name);\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nR_API void r_bin_java_print_unknown_cp_summary(RBinJavaCPTypeObj *obj) {\n\teprintf (\"NULL ConstantPool Type.\\n\");\n}\n\nR_API char *r_bin_java_print_unknown_cp_stringify(RBinJavaCPTypeObj *obj) {\n\tut32 size = 255;\n\tchar *value = malloc (size);\n\tif (value) {\n\t\tmemset (value, 0, size);\n\t\tsnprintf (value, size, \"%d.0x%04\"PFMT64x \".%s\",\n\t\t\tobj->metas->ord, obj->file_offset + obj->loadaddr, ((RBinJavaCPTypeMetas *) obj->metas->type_info)->name);\n\t}\n\treturn value;\n}\n\nR_API RBinJavaElementValuePair *r_bin_java_element_pair_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaElementValuePair *ev_pair = NULL;\n\tut64 offset = 0;\n\tif (!buffer) {\n\t\treturn NULL;\n\t}\n\tev_pair = R_NEW0 (RBinJavaElementValuePair);\n\tif (!ev_pair) {\n\t\t// TODO eprintf ev_pair failed to allocate\n\t\treturn NULL;\n\t}\n\t// TODO: What is the signifigance of ev_pair element\n\tev_pair->element_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tev_pair->file_offset = buf_offset;\n\tev_pair->name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, ev_pair->element_name_idx);\n\tif (ev_pair->name == NULL) {\n\t\t// TODO: eprintf unable to find the name for the given index\n\t\teprintf (\"ElementValue Name is invalid.\\n\");\n\t\tev_pair->name = strdup (\"UNKNOWN\");\n\t}\n\tev_pair->value = r_bin_java_element_value_new (buffer + offset, sz - offset, buf_offset + offset);\n\toffset += ev_pair->value->size;\n\tev_pair->size = offset;\n\treturn ev_pair;\n}\n\nR_API void r_bin_java_print_element_pair_summary(RBinJavaElementValuePair *ev_pair) {\n\tif (!ev_pair) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaElementValuePair *pair.\\n\");\n\t\treturn;\n\t}\n\tEprintf (\"Element Value Pair information:\\n\");\n\tEprintf (\"  EV Pair File Offset: 0x%08\"PFMT64x \"\\n\", ev_pair->file_offset);\n\tEprintf (\"  EV Pair Element Name index: 0x%02x\\n\", ev_pair->element_name_idx);\n\tEprintf (\"  EV Pair Element Name: %s\\n\", ev_pair->name);\n\tEprintf (\"  EV Pair Element Value:\\n\");\n\tr_bin_java_print_element_value_summary (ev_pair->value);\n}\n\nR_API void r_bin_java_print_element_value_summary(RBinJavaElementValue *element_value) {\n\tRBinJavaCPTypeObj *obj;\n\tRBinJavaElementValue *ev_element = NULL;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tchar *name;\n\tif (element_value == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaElementValuePair *pair.\\n\");\n\t\treturn;\n\t}\n\tname = ((RBinJavaElementValueMetas *) element_value->metas->type_info)->name;\n\teprintf (\"Element Value information:\\n\");\n\teprintf (\"   EV Pair File Offset: 0x%08\"PFMT64x \"\\n\", element_value->file_offset);\n\teprintf (\"   EV Value Type (%d): %s\\n\", element_value->tag, name);\n\tswitch (element_value->tag) {\n\tcase R_BIN_JAVA_EV_TAG_BYTE:\n\tcase R_BIN_JAVA_EV_TAG_CHAR:\n\tcase R_BIN_JAVA_EV_TAG_DOUBLE:\n\tcase R_BIN_JAVA_EV_TAG_FLOAT:\n\tcase R_BIN_JAVA_EV_TAG_INT:\n\tcase R_BIN_JAVA_EV_TAG_LONG:\n\tcase R_BIN_JAVA_EV_TAG_SHORT:\n\tcase R_BIN_JAVA_EV_TAG_BOOLEAN:\n\tcase R_BIN_JAVA_EV_TAG_STRING:\n\t\teprintf (\"   EV Value Constant Value index: 0x%02x\\n\", element_value->value.const_value.const_value_idx);\n\t\teprintf (\"   EV Value Constant Value Information:\\n\");\n\t\tobj = element_value->value.const_value.const_value_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->print_summary (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ENUM:\n\t\teprintf (\"   EV Value Enum Constant Value Const Name Index: 0x%02x\\n\", element_value->value.enum_const_value.const_name_idx);\n\t\teprintf (\"   EV Value Enum Constant Value Type Name Index: 0x%02x\\n\", element_value->value.enum_const_value.type_name_idx);\n\t\teprintf (\"   EV Value Enum Constant Value Const CP Information:\\n\");\n\t\tobj = element_value->value.enum_const_value.const_name_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->print_summary (obj);\n\t\teprintf (\"   EV Value Enum Constant Value Type CP Information:\\n\");\n\t\tobj = element_value->value.enum_const_value.type_name_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->print_summary (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_CLASS:\n\t\teprintf (\"   EV Value Class Info Index: 0x%02x\\n\", element_value->value.class_value.class_info_idx);\n\t\teprintf (\"   EV Value Class Info CP Information:\\n\");\n\t\tobj = element_value->value.class_value.class_info_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->print_summary (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ARRAY:\n\t\teprintf (\"   EV Value Array Value Number of Values: 0x%04x\\n\", element_value->value.array_value.num_values);\n\t\teprintf (\"   EV Value Array Values\\n\");\n\t\tr_list_foreach_safe (element_value->value.array_value.values, iter, iter_tmp, ev_element) {\n\t\t\tr_bin_java_print_element_value_summary (ev_element);\n\t\t}\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ANNOTATION:\n\t\teprintf (\"   EV Annotation Information:\\n\");\n\t\tr_bin_java_print_annotation_summary (&element_value->value.annotation_value);\n\t\tbreak;\n\tdefault:\n\t\t// eprintf unable to handle tag\n\t\tbreak;\n\t}\n}\n\nR_API void r_bin_java_element_pair_free(void /*RBinJavaElementValuePair*/ *e) {\n\tRBinJavaElementValuePair *ev_pair = e;\n\tif (ev_pair) {\n\t\tfree (ev_pair->name);\n\t\tr_bin_java_element_value_free (ev_pair->value);\n\t\tfree (ev_pair);\n\t}\n\tev_pair = NULL;\n}\n\nR_API void r_bin_java_element_value_free(void /*RBinJavaElementValue*/ *e) {\n\tRBinJavaElementValue *element_value = e;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaCPTypeObj *obj = NULL;\n\tRBinJavaElementValue *ev_element = NULL;\n\tif (element_value) {\n\t\tfree (element_value->metas);\n\t\telement_value->metas = NULL;\n\t\tswitch (element_value->tag) {\n\t\tcase R_BIN_JAVA_EV_TAG_BYTE:\n\t\tcase R_BIN_JAVA_EV_TAG_CHAR:\n\t\tcase R_BIN_JAVA_EV_TAG_DOUBLE:\n\t\tcase R_BIN_JAVA_EV_TAG_FLOAT:\n\t\tcase R_BIN_JAVA_EV_TAG_INT:\n\t\tcase R_BIN_JAVA_EV_TAG_LONG:\n\t\tcase R_BIN_JAVA_EV_TAG_SHORT:\n\t\tcase R_BIN_JAVA_EV_TAG_BOOLEAN:\n\t\tcase R_BIN_JAVA_EV_TAG_STRING:\n\t\t\t// Delete the CP Type Object\n\t\t\tobj = element_value->value.const_value.const_value_cp_obj;\n\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_EV_TAG_ENUM:\n\t\t\t// Delete the CP Type Objects\n\t\t\tobj = element_value->value.enum_const_value.const_name_cp_obj;\n\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\t\tobj = element_value->value.enum_const_value.type_name_cp_obj;\n\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_EV_TAG_CLASS:\n\t\t\t// Delete the CP Type Object\n\t\t\tobj = element_value->value.class_value.class_info_cp_obj;\n\t\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_EV_TAG_ARRAY:\n\t\t\t// Delete the Element Value array List\n\t\t\tr_list_foreach_safe (element_value->value.array_value.values, iter, iter_tmp, ev_element) {\n\t\t\t\tif (ev_element) {\n\t\t\t\t\tr_bin_java_element_value_free (ev_element);\n\t\t\t\t} else {\n\t\t\t\t\t// TODO eprintf ev_pairs value was NULL\n\t\t\t\t}\n\t\t\t\t// r_list_delete (element_value->value.array_value.values, iter);\n\t\t\t\tev_element = NULL;\n\t\t\t}\n\t\t\tr_list_free (element_value->value.array_value.values);\n\t\t\tbreak;\n\t\tcase R_BIN_JAVA_EV_TAG_ANNOTATION:\n\t\t\t// Delete the Annotations List\n\t\t\tr_list_free (element_value->value.annotation_value.element_value_pairs);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// eprintf unable to free the tag\n\t\t\tbreak;\n\t\t}\n\t\tfree (element_value);\n\t}\n}\n\nR_API ut64 r_bin_java_annotation_default_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tif (attr) {\n\t\t// attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\t\tsize += 6;\n\t\t// attr->info.annotation_default_attr.default_value = r_bin_java_element_value_new (buffer+offset, sz-offset, buf_offset+offset);\n\t\tsize += r_bin_java_element_value_calc_size (attr->info.annotation_default_attr.default_value);\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;\n\t\tattr->info.annotation_default_attr.default_value = r_bin_java_element_value_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (attr->info.annotation_default_attr.default_value) {\n\t\t\toffset += attr->info.annotation_default_attr.default_value->size;\n\t\t}\n\t}\n\tr_bin_java_print_annotation_default_attr_summary (attr);\n\treturn attr;\n}\n\nR_API void r_bin_java_annotation_default_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tRBinJavaElementValue *element_value = NULL, *ev_element = NULL;\n\tRBinJavaCPTypeObj *obj = NULL;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tif (attr == NULL || attr->type != R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR) {\n\t\treturn;\n\t}\n\telement_value = (attr->info.annotation_default_attr.default_value);\n\tswitch (element_value->tag) {\n\tcase R_BIN_JAVA_EV_TAG_BYTE:\n\tcase R_BIN_JAVA_EV_TAG_CHAR:\n\tcase R_BIN_JAVA_EV_TAG_DOUBLE:\n\tcase R_BIN_JAVA_EV_TAG_FLOAT:\n\tcase R_BIN_JAVA_EV_TAG_INT:\n\tcase R_BIN_JAVA_EV_TAG_LONG:\n\tcase R_BIN_JAVA_EV_TAG_SHORT:\n\tcase R_BIN_JAVA_EV_TAG_BOOLEAN:\n\tcase R_BIN_JAVA_EV_TAG_STRING:\n\t\t// Delete the CP Type Object\n\t\tobj = element_value->value.const_value.const_value_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ENUM:\n\t\t// Delete the CP Type Objects\n\t\tobj = element_value->value.enum_const_value.const_name_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\tobj = element_value->value.enum_const_value.type_name_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_CLASS:\n\t\t// Delete the CP Type Object\n\t\tobj = element_value->value.class_value.class_info_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->delete_obj (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ARRAY:\n\t\t// Delete the Element Value array List\n\t\tr_list_foreach_safe (element_value->value.array_value.values, iter, iter_tmp, ev_element) {\n\t\t\tr_bin_java_element_value_free (ev_element);\n\t\t\t// r_list_delete (element_value->value.array_value.values, iter);\n\t\t\tev_element = NULL;\n\t\t}\n\t\tr_list_free (element_value->value.array_value.values);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ANNOTATION:\n\t\t// Delete the Annotations List\n\t\tr_list_free (element_value->value.annotation_value.element_value_pairs);\n\t\tbreak;\n\tdefault:\n\t\t// eprintf unable to free the tag\n\t\tbreak;\n\t}\n\tif (attr) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAnnotation *annotation = NULL;\n\tRBinJavaElementValuePair *ev_pairs = NULL;\n\tut64 offset = 0;\n\tannotation = R_NEW0 (RBinJavaAnnotation);\n\tif (!annotation) {\n\t\treturn NULL;\n\t}\n\t// (ut16) read and set annotation_value.type_idx;\n\tannotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\t// (ut16) read and set annotation_value.num_element_value_pairs;\n\tannotation->num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->element_value_pairs = r_list_newf (r_bin_java_element_pair_free);\n\t// read annotation_value.num_element_value_pairs, and append to annotation_value.element_value_pairs\n\tfor (i = 0; i < annotation->num_element_value_pairs; i++) {\n\t\tif (offset > sz) {\n\t\t\tbreak;\n\t\t}\n\t\tev_pairs = r_bin_java_element_pair_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (ev_pairs) {\n\t\t\toffset += ev_pairs->size;\n\t\t\tr_list_append (annotation->element_value_pairs, (void *) ev_pairs);\n\t\t}\n\t}\n\tannotation->size = offset;\n\treturn annotation;\n}\n\nR_API ut64 r_bin_java_annotation_calc_size(RBinJavaAnnotation *annotation) {\n\tut64 sz = 0;\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaElementValuePair *ev_pairs = NULL;\n\tif (!annotation) {\n\t\t// TODO eprintf allocation fail\n\t\treturn sz;\n\t}\n\t// annotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\tsz += 2;\n\t// annotation->num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\tsz += 2;\n\tr_list_foreach_safe (annotation->element_value_pairs, iter, iter_tmp, ev_pairs) {\n\t\tif (ev_pairs) {\n\t\t\tsz += r_bin_java_element_pair_calc_size (ev_pairs);\n\t\t}\n\t}\n\treturn sz;\n}\n\nR_API void r_bin_java_annotation_free(void /*RBinJavaAnnotation*/ *a) {\n\tRBinJavaAnnotation *annotation = a;\n\tif (annotation) {\n\t\tr_list_free (annotation->element_value_pairs);\n\t\tfree (annotation);\n\t}\n}\n\nR_API void r_bin_java_print_annotation_summary(RBinJavaAnnotation *annotation) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaElementValuePair *ev_pair = NULL;\n\tif (!annotation) {\n\t\t// TODO eprintf invalid annotation\n\t\treturn;\n\t}\n\tEprintf (\"  Annotation Type Index: 0x%02x\\n\", annotation->type_idx);\n\tEprintf (\"  Annotation Number of EV Pairs: 0x%04x\\n\", annotation->num_element_value_pairs);\n\tEprintf (\"  Annotation EV Pair Values:\\n\");\n\tif (annotation->element_value_pairs) {\n\t\tr_list_foreach_safe (annotation->element_value_pairs, iter, iter_tmp, ev_pair) {\n\t\t\tr_bin_java_print_element_pair_summary (ev_pair);\n\t\t}\n\t}\n}\n\nR_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *ev_pair) {\n\tut64 sz = 0;\n\tif (ev_pair == NULL) {\n\t\treturn sz;\n\t}\n\t// ev_pair->element_name_idx = r_bin_java_read_short(bin, bin->b->cur);\n\tsz += 2;\n\t// ev_pair->value = r_bin_java_element_value_new (bin, offset+2);\n\tif (ev_pair->value) {\n\t\tsz += r_bin_java_element_value_calc_size (ev_pair->value);\n\t}\n\treturn sz;\n}\n\nR_API ut64 r_bin_java_element_value_calc_size(RBinJavaElementValue *element_value) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaElementValue *ev_element;\n\tRBinJavaElementValuePair *ev_pairs;\n\tut64 sz = 0;\n\tif (element_value == NULL) {\n\t\treturn sz;\n\t}\n\t// tag\n\tsz += 1;\n\tswitch (element_value->tag) {\n\tcase R_BIN_JAVA_EV_TAG_BYTE:\n\tcase R_BIN_JAVA_EV_TAG_CHAR:\n\tcase R_BIN_JAVA_EV_TAG_DOUBLE:\n\tcase R_BIN_JAVA_EV_TAG_FLOAT:\n\tcase R_BIN_JAVA_EV_TAG_INT:\n\tcase R_BIN_JAVA_EV_TAG_LONG:\n\tcase R_BIN_JAVA_EV_TAG_SHORT:\n\tcase R_BIN_JAVA_EV_TAG_BOOLEAN:\n\tcase R_BIN_JAVA_EV_TAG_STRING:\n\t\t// look up value in bin->cp_list\n\t\t// (ut16) read and set const_value.const_value_idx\n\t\t// element_value->value.const_value.const_value_idx = r_bin_java_read_short(bin, bin->b->cur);\n\t\tsz += 2;\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ENUM:\n\t\t// (ut16) read and set enum_const_value.type_name_idx\n\t\t// element_value->value.enum_const_value.type_name_idx = r_bin_java_read_short(bin, bin->b->cur);\n\t\tsz += 2;\n\t\t// (ut16) read and set enum_const_value.const_name_idx\n\t\t// element_value->value.enum_const_value.const_name_idx = r_bin_java_read_short(bin, bin->b->cur);\n\t\tsz += 2;\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_CLASS:\n\t\t// (ut16) read and set class_value.class_info_idx\n\t\t// element_value->value.class_value.class_info_idx = r_bin_java_read_short(bin, bin->b->cur);\n\t\tsz += 2;\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ARRAY:\n\t\t// (ut16) read and set array_value.num_values\n\t\t// element_value->value.array_value.num_values = r_bin_java_read_short(bin, bin->b->cur);\n\t\tsz += 2;\n\t\tr_list_foreach_safe (element_value->value.array_value.values, iter, iter_tmp, ev_element) {\n\t\t\tif (ev_element) {\n\t\t\t\tsz += r_bin_java_element_value_calc_size (ev_element);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ANNOTATION:\n\t\t// annotation new is not used here.\n\t\t// (ut16) read and set annotation_value.type_idx;\n\t\t// element_value->value.annotation_value.type_idx = r_bin_java_read_short(bin, bin->b->cur);\n\t\tsz += 2;\n\t\t// (ut16) read and set annotation_value.num_element_value_pairs;\n\t\t// element_value->value.annotation_value.num_element_value_pairs = r_bin_java_read_short(bin, bin->b->cur);\n\t\tsz += 2;\n\t\telement_value->value.annotation_value.element_value_pairs = r_list_newf (r_bin_java_element_pair_free);\n\t\tr_list_foreach_safe (element_value->value.annotation_value.element_value_pairs, iter, iter_tmp, ev_pairs) {\n\t\t\tif (ev_pairs) {\n\t\t\t\tsz += r_bin_java_element_pair_calc_size (ev_pairs);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t// eprintf unable to handle tag\n\t\tbreak;\n\t}\n\treturn sz;\n}\n\nR_API RBinJavaElementValue *r_bin_java_element_value_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tRBinJavaElementValue *element_value = R_NEW0 (RBinJavaElementValue);\n\tif (!element_value) {\n\t\treturn NULL;\n\t}\n\tRBinJavaElementValuePair *ev_pairs = NULL;\n\telement_value->metas = R_NEW0 (RBinJavaMetaInfo);\n\tif (!element_value->metas) {\n\t\tR_FREE (element_value);\n\t\treturn NULL;\n\t}\n\telement_value->file_offset = buf_offset;\n\telement_value->tag = buffer[offset];\n\telement_value->size += 1;\n\toffset += 1;\n\telement_value->metas->type_info = (void *) r_bin_java_get_ev_meta_from_tag (element_value->tag);\n\tswitch (element_value->tag) {\n\tcase R_BIN_JAVA_EV_TAG_BYTE:\n\tcase R_BIN_JAVA_EV_TAG_CHAR:\n\tcase R_BIN_JAVA_EV_TAG_DOUBLE:\n\tcase R_BIN_JAVA_EV_TAG_FLOAT:\n\tcase R_BIN_JAVA_EV_TAG_INT:\n\tcase R_BIN_JAVA_EV_TAG_LONG:\n\tcase R_BIN_JAVA_EV_TAG_SHORT:\n\tcase R_BIN_JAVA_EV_TAG_BOOLEAN:\n\tcase R_BIN_JAVA_EV_TAG_STRING:\n\t\t// look up value in bin->cp_list\n\t\t// (ut16) read and set const_value.const_value_idx\n\t\telement_value->value.const_value.const_value_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// look-up, deep copy, and set const_value.const_value_cp_obj\n\t\telement_value->value.const_value.const_value_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.const_value.const_value_idx);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ENUM:\n\t\t// (ut16) read and set enum_const_value.type_name_idx\n\t\telement_value->value.enum_const_value.type_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// (ut16) read and set enum_const_value.const_name_idx\n\t\telement_value->value.enum_const_value.const_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// look up type_name_index in bin->cp_list\n\t\t// look-up, deep copy, and set enum_const_value.const_name_cp_obj\n\t\telement_value->value.enum_const_value.const_name_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.enum_const_value.const_name_idx);\n\t\t// look-up, deep copy, and set enum_const_value.type_name_cp_obj\n\t\telement_value->value.enum_const_value.type_name_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.enum_const_value.type_name_idx);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_CLASS:\n\t\t// (ut16) read and set class_value.class_info_idx\n\t\telement_value->value.class_value.class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// look up type_name_index in bin->cp_list\n\t\t// look-up, deep copy, and set class_value.class_info_cp_obj\n\t\telement_value->value.class_value.class_info_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, element_value->value.class_value.class_info_idx);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ARRAY:\n\t\t// (ut16) read and set array_value.num_values\n\t\telement_value->value.array_value.num_values = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\telement_value->value.array_value.values = r_list_new ();\n\t\tfor (i = 0; i < element_value->value.array_value.num_values; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaElementValue *ev_element = r_bin_java_element_value_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (ev_element) {\n\t\t\t\telement_value->size += ev_element->size;\n\t\t\t\toffset += ev_element->size;\n\t\t\t}\n\t\t\t// read array_value.num_values, and append to array_value.values\n\t\t\tr_list_append (element_value->value.array_value.values, (void *) ev_element);\n\t\t\tif (ev_element == NULL) {\n\t\t\t\t// TODO: eprintf error when reading element value\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ANNOTATION:\n\t\t// annotation new is not used here.\n\t\t// (ut16) read and set annotation_value.type_idx;\n\t\telement_value->value.annotation_value.type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\t// (ut16) read and set annotation_value.num_element_value_pairs;\n\t\telement_value->value.annotation_value.num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\t\telement_value->size += 2;\n\t\toffset += 2;\n\t\telement_value->value.annotation_value.element_value_pairs = r_list_newf (r_bin_java_element_pair_free);\n\t\t// read annotation_value.num_element_value_pairs, and append to annotation_value.element_value_pairs\n\t\tfor (i = 0; i < element_value->value.annotation_value.num_element_value_pairs; i++) {\n\t\t\tif (offset > sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tev_pairs = r_bin_java_element_pair_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (ev_pairs) {\n\t\t\t\telement_value->size += ev_pairs->size;\n\t\t\t\toffset += ev_pairs->size;\n\t\t\t}\n\t\t\tif (ev_pairs == NULL) {\n\t\t\t\t// TODO: eprintf error when reading element pair\n\t\t\t}\n\t\t\tr_list_append (element_value->value.annotation_value.element_value_pairs, (void *) ev_pairs);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t// eprintf unable to handle tag\n\t\tbreak;\n\t}\n\treturn element_value;\n}\n\nR_API void r_bin_java_bootstrap_method_argument_free(void /*RBinJavaBootStrapArgument*/ *b) {\n\tRBinJavaBootStrapArgument *bsm_arg = b;\n\tif (bsm_arg) {\n\t\tif (bsm_arg->argument_info_cp_obj) {\n\t\t\t((RBinJavaCPTypeMetas *) bsm_arg->argument_info_cp_obj)->allocs->delete_obj (bsm_arg->argument_info_cp_obj);\n\t\t\tbsm_arg->argument_info_cp_obj = NULL;\n\t\t}\n\t\tfree (bsm_arg);\n\t}\n}\n\nR_API void r_bin_java_print_bootstrap_method_argument_summary(RBinJavaBootStrapArgument *bsm_arg) {\n\tif (bsm_arg == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaBootStrapArgument *.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"Bootstrap Method Argument Information:\\n\");\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", bsm_arg->file_offset);\n\teprintf (\"\tName_And_Type Index = (0x%02x)\\n\", bsm_arg->argument_info_idx);\n\tif (bsm_arg->argument_info_cp_obj) {\n\t\teprintf (\"\tBootstrap Method Argument Type and Name Info:\\n\");\n\t\t((RBinJavaCPTypeMetas *) bsm_arg->argument_info_cp_obj)->allocs->print_summary (bsm_arg->argument_info_cp_obj);\n\t} else {\n\t\teprintf (\"\tBootstrap Method Argument Type and Name Info: INVALID\\n\");\n\t}\n}\n\nR_API void r_bin_java_print_bootstrap_method_summary(RBinJavaBootStrapMethod *bsm) {\n\tRBinJavaBootStrapArgument *bsm_arg = NULL;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tif (bsm == NULL) {\n\t\teprintf (\"Attempting to print an invalid RBinJavaBootStrapArgument *.\\n\");\n\t\treturn;\n\t}\n\teprintf (\"Bootstrap Method Information:\\n\");\n\teprintf (\"\tOffset: 0x%08\"PFMT64x\"\", bsm->file_offset);\n\teprintf (\"\tMethod Reference Index = (0x%02x)\\n\", bsm->bootstrap_method_ref);\n\teprintf (\"\tNumber of Method Arguments = (0x%02x)\\n\", bsm->num_bootstrap_arguments);\n\tif (bsm->bootstrap_arguments) {\n\t\tr_list_foreach_safe (bsm->bootstrap_arguments, iter, iter_tmp, bsm_arg) {\n\t\t\tif (bsm_arg) {\n\t\t\t\tr_bin_java_print_bootstrap_method_argument_summary (bsm_arg);\n\t\t\t}\n\t\t}\n\t} else {\n\t\teprintf (\"\tBootstrap Method Argument: NONE \\n\");\n\t}\n}\n\nR_API RBinJavaBootStrapArgument *r_bin_java_bootstrap_method_argument_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaBootStrapArgument *bsm_arg = NULL;\n\tut64 offset = 0;\n\tbsm_arg = (RBinJavaBootStrapArgument *) malloc (sizeof (RBinJavaBootStrapArgument));\n\tif (bsm_arg == NULL) {\n\t\t// TODO eprintf failed to allocate bytes for bootstrap_method.\n\t\treturn bsm_arg;\n\t}\n\tmemset (bsm_arg, 0, sizeof (RBinJavaBootStrapArgument));\n\tbsm_arg->file_offset = buf_offset;\n\tbsm_arg->argument_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tbsm_arg->argument_info_cp_obj = r_bin_java_clone_cp_idx (R_BIN_JAVA_GLOBAL_BIN, bsm_arg->argument_info_idx);\n\tbsm_arg->size = offset;\n\treturn bsm_arg;\n}\n\nR_API void r_bin_java_bootstrap_method_free(void /*/RBinJavaBootStrapMethod*/ *b) {\n\tRBinJavaBootStrapMethod *bsm = b;\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaBootStrapArgument *obj = NULL;\n\tif (bsm) {\n\t\tif (bsm->bootstrap_arguments) {\n\t\t\tr_list_foreach_safe (bsm->bootstrap_arguments, iter, iter_tmp, obj) {\n\t\t\t\tif (obj) {\n\t\t\t\t\tr_bin_java_bootstrap_method_argument_free (obj);\n\t\t\t\t}\n\t\t\t\t// r_list_delete (bsm->bootstrap_arguments, iter);\n\t\t\t}\n\t\t\tr_list_free (bsm->bootstrap_arguments);\n\t\t\tbsm->bootstrap_arguments = NULL;\n\t\t}\n\t\tfree (bsm);\n\t}\n}\n\nR_API RBinJavaBootStrapMethod *r_bin_java_bootstrap_method_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tRBinJavaBootStrapArgument *bsm_arg = NULL;\n\tut32 i = 0;\n\tut64 offset = 0;\n\tbsm = (RBinJavaBootStrapMethod *) malloc (sizeof (RBinJavaBootStrapMethod));\n\tif (bsm == NULL) {\n\t\t// TODO eprintf failed to allocate bytes for bootstrap_method.\n\t\treturn bsm;\n\t}\n\tmemset (bsm, 0, sizeof (RBinJavaBootStrapMethod));\n\tbsm->file_offset = buf_offset;\n\tbsm->bootstrap_method_ref = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tbsm->num_bootstrap_arguments = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tbsm->bootstrap_arguments = r_list_new ();\n\tfor (i = 0; i < bsm->num_bootstrap_arguments; i++) {\n\t\t// bsm_arg = r_bin_java_bootstrap_method_argument_new (bin, bin->b->cur);\n\t\tbsm_arg = r_bin_java_bootstrap_method_argument_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (bsm_arg) {\n\t\t\toffset += bsm_arg->size;\n\t\t\tr_list_append (bsm->bootstrap_arguments, (void *) bsm_arg);\n\t\t} else {\n\t\t\t// TODO eprintf Failed to read the %d boot strap method.\n\t\t}\n\t}\n\tbsm->size = offset;\n\treturn bsm;\n}\n\nR_API void r_bin_java_print_bootstrap_methods_attr_summary(RBinJavaAttrInfo *attr) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaBootStrapMethod *obj = NULL;\n\tif (attr == NULL || attr->type == R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR) {\n\t\teprintf (\"Unable to print attribue summary for RBinJavaAttrInfo *RBinJavaBootstrapMethodsAttr\");\n\t\treturn;\n\t}\n\teprintf (\"Bootstrap Methods Attribute Information Information:\\n\");\n\teprintf (\"\tAttribute Offset: 0x%08\"PFMT64x\"\", attr->file_offset);\n\teprintf (\"\tLength: 0x%08x\", attr->length);\n\teprintf (\"\tNumber of Method Arguments = (0x%02x)\\n\", attr->info.bootstrap_methods_attr.num_bootstrap_methods);\n\tif (attr->info.bootstrap_methods_attr.bootstrap_methods) {\n\t\tr_list_foreach_safe (attr->info.bootstrap_methods_attr.bootstrap_methods, iter, iter_tmp, obj) {\n\t\t\tif (obj) {\n\t\t\t\tr_bin_java_print_bootstrap_method_summary (obj);\n\t\t\t}\n\t\t}\n\t} else {\n\t\teprintf (\"\tBootstrap Methods: NONE \\n\");\n\t}\n}\n\nR_API void r_bin_java_bootstrap_methods_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tr_list_free (attr->info.bootstrap_methods_attr.bootstrap_methods);\n\t\tfree (attr);\n\t}\n}\n\nR_API ut64 r_bin_java_bootstrap_methods_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 size = 0;\n\tif (attr) {\n\t\tsize += 6;\n\t\t// attr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\tr_list_foreach_safe (attr->info.bootstrap_methods_attr.bootstrap_methods, iter, iter_tmp, bsm) {\n\t\t\tif (bsm) {\n\t\t\t\tsize += r_bin_java_bootstrap_method_calc_size (bsm);\n\t\t\t} else {\n\t\t\t\t// TODO eprintf Failed to read the %d boot strap method.\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API ut64 r_bin_java_bootstrap_arg_calc_size(RBinJavaBootStrapArgument *bsm_arg) {\n\tut64 size = 0;\n\tif (bsm_arg) {\n\t\t// bsm_arg->argument_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t}\n\treturn size;\n}\n\nR_API ut64 r_bin_java_bootstrap_method_calc_size(RBinJavaBootStrapMethod *bsm) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaBootStrapArgument *bsm_arg = NULL;\n\tut64 size = 0;\n\tif (bsm) {\n\t\tsize += 6;\n\t\t// bsm->bootstrap_method_ref = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\t// bsm->num_bootstrap_arguments = R_BIN_JAVA_USHORT (buffer, offset);\n\t\tsize += 2;\n\t\tr_list_foreach_safe (bsm->bootstrap_arguments, iter, iter_tmp, bsm_arg) {\n\t\t\tif (bsm_arg) {\n\t\t\t\tsize += r_bin_java_bootstrap_arg_calc_size (bsm_arg);\n\t\t\t} else {\n\t\t\t\t// TODO eprintf Failed to read the %d boot strap method.\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n\t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);\n\t\tfor (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) {\n\t\t\t// bsm = r_bin_java_bootstrap_method_new (bin, bin->b->cur);\n\t\t\tbsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (bsm) {\n\t\t\t\toffset += bsm->size;\n\t\t\t\tr_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);\n\t\t\t} else {\n\t\t\t\t// TODO eprintf Failed to read the %d boot strap method.\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n\nR_API void r_bin_java_print_annotation_default_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR) {\n\t\teprintf (\"Annotation Default Attribute Information:\\n\");\n\t\teprintf (\"   Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\t\teprintf (\"   Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\t\teprintf (\"   Attribute Length: %d\\n\", attr->length);\n\t\tr_bin_java_print_element_value_summary ((attr->info.annotation_default_attr.default_value));\n\t} else {\n\t\t// TODO: eprintf attr is invalid\n\t}\n}\n\nR_API void r_bin_java_annotation_array_free(void /*RBinJavaAnnotationsArray*/ *a) {\n\tRBinJavaAnnotationsArray *annotation_array = a;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaAnnotation *annotation;\n\tif (annotation_array->annotations == NULL) {\n\t\t// TODO eprintf\n\t\treturn;\n\t}\n\tr_list_foreach_safe (annotation_array->annotations, iter, iter_tmp, annotation) {\n\t\tif (annotation) {\n\t\t\tr_bin_java_annotation_free (annotation);\n\t\t}\n\t\t// r_list_delete (annotation_array->annotations, iter);\n\t}\n\tr_list_free (annotation_array->annotations);\n\tfree (annotation_array);\n}\n\nR_API void r_bin_java_print_annotation_array_summary(RBinJavaAnnotationsArray *annotation_array) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaAnnotation *annotation;\n\tif (annotation_array->annotations == NULL) {\n\t\t// TODO eprintf\n\t\treturn;\n\t}\n\teprintf (\"   Annotation Array Information:\\n\");\n\teprintf (\"   Number of Annotation Array Elements: %d\\n\", annotation_array->num_annotations);\n\tr_list_foreach_safe (annotation_array->annotations, iter, iter_tmp, annotation) {\n\t\tr_bin_java_print_annotation_summary (annotation);\n\t}\n}\n\nR_API RBinJavaAnnotationsArray *r_bin_java_annotation_array_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaAnnotation *annotation;\n\tRBinJavaAnnotationsArray *annotation_array;\n\tut32 i;\n\tut64 offset = 0;\n\tannotation_array = (RBinJavaAnnotationsArray *) malloc (sizeof (RBinJavaAnnotationsArray));\n\tif (annotation_array == NULL) {\n\t\t// TODO eprintf\n\t\treturn NULL;\n\t}\n\tannotation_array->num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation_array->annotations = r_list_new ();\n\tfor (i = 0; i < annotation_array->num_annotations; i++) {\n\t\tannotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (annotation) {\n\t\t\toffset += annotation->size;\n\t\t}\n\t\tif (annotation == NULL) {\n\t\t\t// TODO eprintf\n\t\t}\n\t\tr_list_append (annotation_array->annotations, (void *) annotation);\n\t}\n\tannotation_array->size = offset;\n\treturn annotation_array;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.annotation_array.num_annotations; i++) {\n\t\t\tint len = sz - offset;\n\t\t\tif (len < 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, len, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_annotation_array_calc_size(RBinJavaAnnotationsArray *annotation_array) {\n\tut64 size = 0;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaAnnotation *annotation;\n\tif (annotation_array->annotations == NULL) {\n\t\t// TODO eprintf\n\t\treturn size;\n\t}\n\t// annotation_array->num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\tsize += 2;\n\tr_list_foreach_safe (annotation_array->annotations, iter, iter_tmp, annotation) {\n\t\tsize += r_bin_java_annotation_calc_size (annotation);\n\t}\n\treturn size;\n}\n\nR_API ut64 r_bin_java_rtv_annotations_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tif (attr == NULL) {\n\t\t// TODO eprintf allocation fail\n\t\treturn size;\n\t}\n\tsize += (6 + r_bin_java_annotation_array_calc_size (&(attr->info.annotation_array)));\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.rtv_annotations_attr.num_annotations; i++) {\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t}\n\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_rti_annotations_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tif (attr == NULL) {\n\t\t// TODO eprintf allocation fail\n\t\treturn size;\n\t}\n\tsize += (6 + r_bin_java_annotation_array_calc_size (&(attr->info.annotation_array)));\n\treturn size;\n}\n\nR_API void r_bin_java_rtv_annotations_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_ANNOTATION_ATTR) {\n\t\tr_list_free (attr->info.annotation_array.annotations);\n\t\tfree (attr->metas);\n\t\tfree (attr->name);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_rti_annotations_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR) {\n\t\tr_list_free (attr->info.annotation_array.annotations);\n\t\tfree (attr->metas);\n\t\tfree (attr->name);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_print_rtv_annotations_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_ANNOTATION_ATTR) {\n\t\tEprintf (\"Runtime Visible Annotations Attribute Information:\\n\");\n\t\tEprintf (\"   Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\t\tEprintf (\"   Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\t\tEprintf (\"   Attribute Length: %d\\n\", attr->length);\n\t\tr_bin_java_print_annotation_array_summary (&attr->info.annotation_array);\n\t}\n}\n\nR_API void r_bin_java_print_rti_annotations_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR) {\n\t\tEprintf (\"Runtime Invisible Annotations Attribute Information:\\n\");\n\t\tEprintf (\"   Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\t\tEprintf (\"   Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\t\tEprintf (\"   Attribute Length: %d\\n\", attr->length);\n\t\tr_bin_java_print_annotation_array_summary (&attr->info.annotation_array);\n\t}\n}\n\nR_API ut64 r_bin_java_rtip_annotations_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaAnnotationsArray *annotation_array;\n\tif (attr == NULL) {\n\t\t// TODO eprintf allocation fail\n\t\treturn size;\n\t}\n\t// attr->info.rtip_annotations_attr.num_parameters = buffer[offset];\n\tsize += (6 + 1);\n\tr_list_foreach_safe (attr->info.rtip_annotations_attr.parameter_annotations, iter, iter_tmp, annotation_array) {\n\t\tif (annotation_array) {\n\t\t\tsize += r_bin_java_annotation_array_calc_size (annotation_array);\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_rtip_annotations_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tRBinJavaAnnotationsArray *annotation_array;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_PARAMETER_ANNOTATION_ATTR;\n\t\tattr->info.rtip_annotations_attr.num_parameters = buffer[offset];\n\t\toffset += 1;\n\t\tattr->info.rtip_annotations_attr.parameter_annotations = r_list_newf (r_bin_java_annotation_array_free);\n\t\tfor (i = 0; i < attr->info.rtip_annotations_attr.num_parameters; i++) {\n\t\t\tannotation_array = r_bin_java_annotation_array_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation_array == NULL) {}\n\t\t\tif (annotation_array) {\n\t\t\t\toffset += annotation_array->size;\n\t\t\t}\n\t\t\tr_list_append (attr->info.rtip_annotations_attr.parameter_annotations, (void *) annotation_array);\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n\nR_API RBinJavaAttrInfo *r_bin_java_rtvp_annotations_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\toffset += 6;\n\tRBinJavaAnnotationsArray *annotation_array;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_PARAMETER_ANNOTATION_ATTR;\n\t\tattr->info.rtvp_annotations_attr.num_parameters = buffer[offset];\n\t\toffset += 1;\n\t\tattr->info.rtvp_annotations_attr.parameter_annotations = r_list_newf (r_bin_java_annotation_array_free);\n\t\tfor (i = 0; i < attr->info.rtvp_annotations_attr.num_parameters; i++) {\n\t\t\tannotation_array = r_bin_java_annotation_array_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation_array == NULL) {}\n\t\t\tif (annotation_array) {\n\t\t\t\toffset += annotation_array->size;\n\t\t\t}\n\t\t\tr_list_append (attr->info.rtvp_annotations_attr.parameter_annotations, (void *) annotation_array);\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}\n\nR_API ut64 r_bin_java_rtvp_annotations_attr_calc_size(RBinJavaAttrInfo *attr) {\n\tut64 size = 0;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaAnnotationsArray *annotation_array;\n\tif (!attr) {\n\t\treturn size;\n\t}\n\tsize += (6 + 1);\n\tr_list_foreach_safe (attr->info.rtvp_annotations_attr.parameter_annotations,\n\t\titer, iter_tmp, annotation_array) {\n\t\tif (annotation_array) {\n\t\t\tsize += r_bin_java_annotation_array_calc_size (\n\t\t\t\tannotation_array);\n\t\t}\n\t}\n\treturn size;\n}\n\nR_API void r_bin_java_rtvp_annotations_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) {\n\t\tif (attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_PARAMETER_ANNOTATION_ATTR) {\n\t\t\tr_list_free (attr->info.rtvp_annotations_attr.parameter_annotations);\n\t\t}\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_rtip_annotations_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr) { // && attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_PARAMETER_ANNOTATION_ATTR) {\n\t\tr_list_free (attr->info.rtip_annotations_attr.parameter_annotations);\n\t\tfree (attr->metas);\n\t\tfree (attr->name);\n\t\tfree (attr);\n\t}\n}\n\nR_API void r_bin_java_print_rtvp_annotations_attr_summary(RBinJavaAttrInfo *attr) {\n\tRBinJavaAnnotationsArray *annotation_array = NULL;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_PARAMETER_ANNOTATION_ATTR) {\n\t\teprintf (\"Runtime Visible Parameter Annotations Attribute Information:\\n\");\n\t\teprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\t\teprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\t\teprintf (\"  Attribute Length: %d\\n\", attr->length);\n\t\teprintf (\"  Number of Runtime Invisible Parameters: %d\\n\", attr->info.rtvp_annotations_attr.num_parameters);\n\t\tr_list_foreach_safe (attr->info.rtvp_annotations_attr.parameter_annotations, iter, iter_tmp, annotation_array) {\n\t\t\tr_bin_java_print_annotation_array_summary (annotation_array);\n\t\t}\n\t}\n}\n\nR_API void r_bin_java_print_rtip_annotations_attr_summary(RBinJavaAttrInfo *attr) {\n\tRBinJavaAnnotationsArray *annotation_array = NULL;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_PARAMETER_ANNOTATION_ATTR) {\n\t\teprintf (\"Runtime Invisible Parameter Annotations Attribute Information:\\n\");\n\t\teprintf (\"  Attribute Offset: 0x%08\"PFMT64x \"\\n\", attr->file_offset);\n\t\teprintf (\"  Attribute Name Index: %d (%s)\\n\", attr->name_idx, attr->name);\n\t\teprintf (\"  Attribute Length: %d\\n\", attr->length);\n\t\teprintf (\"  Number of Runtime Invisible Parameters: %d\\n\", attr->info.rtip_annotations_attr.num_parameters);\n\t\tr_list_foreach_safe (attr->info.rtip_annotations_attr.parameter_annotations, iter, iter_tmp, annotation_array) {\n\t\t\tr_bin_java_print_annotation_array_summary (annotation_array);\n\t\t}\n\t}\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_find_cp_name_and_type_info(RBinJavaObj *bin, ut16 name_idx, ut16 descriptor_idx) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaCPTypeObj *res = NULL, *obj = NULL;\n\tIFDBG eprintf(\"Looking for name_idx: %d and descriptor_idx: %d\\n\", name_idx, descriptor_idx);\n\tr_list_foreach_safe (bin->cp_list, iter, iter_tmp, obj) {\n\t\tif (obj && obj->tag == R_BIN_JAVA_CP_NAMEANDTYPE) {\n\t\t\tIFDBG eprintf(\"RBinJavaCPTypeNameAndType has name_idx: %d and descriptor_idx: %d\\n\",\n\t\t\tobj->info.cp_name_and_type.name_idx, obj->info.cp_name_and_type.descriptor_idx);\n\t\t\tif (obj->info.cp_name_and_type.name_idx == name_idx &&\n\t\t\tobj->info.cp_name_and_type.descriptor_idx == descriptor_idx) {\n\t\t\t\tres = obj;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API char *r_bin_java_resolve_cp_idx_type(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaCPTypeObj *item = NULL;\n\tchar *str = NULL;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\t// r_bin_java_new_bin(BIN_OBJ);\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\tstr = strdup (((RBinJavaCPTypeMetas *) item->metas->type_info)->name);\n\t} else {\n\t\tstr = strdup (\"INVALID\");\n\t}\n\treturn str;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_find_cp_ref_info_from_name_and_type(RBinJavaObj *bin, ut16 name_idx, ut16 descriptor_idx) {\n\tRBinJavaCPTypeObj *obj = r_bin_java_find_cp_name_and_type_info (bin, name_idx, descriptor_idx);\n\tif (obj) {\n\t\treturn r_bin_java_find_cp_ref_info (bin, obj->metas->ord);\n\t}\n\treturn NULL;\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_find_cp_ref_info(RBinJavaObj *bin, ut16 name_and_type_idx) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaCPTypeObj *res = NULL, *obj = NULL;\n\tr_list_foreach_safe (bin->cp_list, iter, iter_tmp, obj) {\n\t\tif (obj->tag == R_BIN_JAVA_CP_FIELDREF &&\n\t\tobj->info.cp_field.name_and_type_idx == name_and_type_idx) {\n\t\t\tres = obj;\n\t\t\tbreak;\n\t\t} else if (obj->tag == R_BIN_JAVA_CP_METHODREF &&\n\t\tobj->info.cp_method.name_and_type_idx == name_and_type_idx) {\n\t\t\tres = obj;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API char *r_bin_java_resolve(RBinJavaObj *BIN_OBJ, int idx, ut8 space_bn_name_type) {\n\t// TODO XXX FIXME add a size parameter to the str when it is passed in\n\tRBinJavaCPTypeObj *item = NULL, *item2 = NULL;\n\tchar *class_str = NULL,\n\t*name_str = NULL,\n\t*desc_str = NULL,\n\t*string_str = NULL,\n\t*empty = \"\",\n\t*cp_name = NULL,\n\t*str = NULL;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\t// r_bin_java_new_bin(BIN_OBJ);\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\tcp_name = ((RBinJavaCPTypeMetas *) item->metas->type_info)->name;\n\t\tIFDBG eprintf(\"java_resolve Resolved: (%d) %s\\n\", idx, cp_name);\n\t} else {\n\t\tstr = malloc (512);\n\t\tif (str) {\n\t\t\tsnprintf (str, 512, \"(%d) INVALID CP_OBJ\", idx);\n\t\t}\n\t\treturn str;\n\t}\n\tcp_name = ((RBinJavaCPTypeMetas *) item->metas->type_info)->name;\n\tif (strcmp (cp_name, \"Class\") == 0) {\n\t\titem2 = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\t\t// str = r_bin_java_get_name_from_bin_cp_list (BIN_OBJ, idx-1);\n\t\tclass_str = empty;\n\t\tclass_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!class_str) {\n\t\t\tclass_str = empty;\n\t\t}\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item2);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item2);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tstr = r_str_newf (\"%s%s%s\", name_str,\n\t\t\tspace_bn_name_type ? \" \" : \"\", desc_str);\n\t\tif (class_str != empty) {\n\t\t\tfree (class_str);\n\t\t}\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else if (!strcmp (cp_name, \"MethodRef\") ||\n\t!strcmp (cp_name, \"FieldRef\") ||\n\t!strcmp (cp_name, \"InterfaceMethodRef\")) {\n\t\t/*\n\t\t*  The MethodRef, FieldRef, and InterfaceMethodRef structures\n\t\t*/\n\t\tclass_str = r_bin_java_get_name_from_bin_cp_list (BIN_OBJ, item->info.cp_method.class_idx);\n\t\tif (!class_str) {\n\t\t\tclass_str = empty;\n\t\t}\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tstr = r_str_newf (\"%s/%s%s%s\", class_str, name_str,\n\t\t\tspace_bn_name_type ? \" \" : \"\", desc_str);\n\t\tif (class_str != empty) {\n\t\t\tfree (class_str);\n\t\t}\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else if (!strcmp (cp_name, \"String\")) {\n\t\tstring_str = r_bin_java_get_utf8_from_bin_cp_list (BIN_OBJ, item->info.cp_string.string_idx);\n\t\tstr = NULL;\n\t\tIFDBG eprintf(\"java_resolve String got: (%d) %s\\n\", item->info.cp_string.string_idx, string_str);\n\t\tif (!string_str) {\n\t\t\tstring_str = empty;\n\t\t}\n\t\tstr = r_str_newf (\"\\\"%s\\\"\", string_str);\n\t\tIFDBG eprintf(\"java_resolve String return: %s\\n\", str);\n\t\tif (string_str != empty) {\n\t\t\tfree (string_str);\n\t\t}\n\n\t} else if (!strcmp (cp_name, \"Utf8\")) {\n\t\tchar *tmp_str = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);\n\t\tut32 tmp_str_len = tmp_str ? strlen (tmp_str) + 4 : 0;\n\t\tif (tmp_str) {\n\t\t\tstr = malloc (tmp_str_len + 4);\n\t\t\tsnprintf (str, tmp_str_len + 4, \"\\\"%s\\\"\", tmp_str);\n\t\t}\n\t\tfree (tmp_str);\n\t} else if (!strcmp (cp_name, \"Long\")) {\n\t\tstr = r_str_newf (\"0x%\"PFMT64x, r_bin_java_raw_to_long (item->info.cp_long.bytes.raw, 0));\n\t} else if (!strcmp (cp_name, \"Double\")) {\n\t\tstr = r_str_newf (\"%f\", r_bin_java_raw_to_double (item->info.cp_double.bytes.raw, 0));\n\t} else if (!strcmp (cp_name, \"Integer\")) {\n\t\tstr = r_str_newf (\"0x%08x\", R_BIN_JAVA_UINT (item->info.cp_integer.bytes.raw, 0));\n\t} else if (!strcmp (cp_name, \"Float\")) {\n\t\tstr = r_str_newf (\"%f\", R_BIN_JAVA_FLOAT (item->info.cp_float.bytes.raw, 0));\n\t} else if (!strcmp (cp_name, \"NameAndType\")) {\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tstr = r_str_newf (\"%s%s%s\", name_str, space_bn_name_type ? \" \" : \"\", desc_str);\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else {\n\t\tstr = strdup (\"(null)\");\n\t}\n\treturn str;\n}\n\nR_API ut8 r_bin_java_does_cp_idx_ref_method(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaField *fm_type = NULL;\n\tRListIter *iter;\n\tut8 res = 0;\n\tr_list_foreach (BIN_OBJ->methods_list, iter, fm_type) {\n\t\tif (fm_type->field_ref_cp_obj->metas->ord == idx) {\n\t\t\tres = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API ut8 r_bin_java_does_cp_idx_ref_field(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaField *fm_type = NULL;\n\tRListIter *iter;\n\tut8 res = 0;\n\tr_list_foreach (BIN_OBJ->fields_list, iter, fm_type) {\n\t\tif (fm_type->field_ref_cp_obj->metas->ord == idx) {\n\t\t\tres = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API char *r_bin_java_get_method_name(RBinJavaObj *bin_obj, ut32 idx) {\n\tchar *name = NULL;\n\tif (idx < r_list_length (bin_obj->methods_list)) {\n\t\tRBinJavaField *fm_type = r_list_get_n (bin_obj->methods_list, idx);\n\t\tname = strdup (fm_type->name);\n\t}\n\treturn name;\n}\n\nR_API RList *r_bin_java_get_method_num_name(RBinJavaObj *bin_obj) {\n\tut32 i = 0;\n\tRListIter *iter = NULL;\n\tRBinJavaField *fm_type;\n\tRList *res = r_list_newf (free);\n\tr_list_foreach (bin_obj->methods_list, iter, fm_type) {\n\t\tut32 len = strlen (fm_type->name) + 30;\n\t\tchar *str = malloc (len);\n\t\tsnprintf (str, len, \"%d %s\", i, fm_type->name);\n\t\t++i;\n\t\tr_list_append (res, str);\n\t}\n\treturn res;\n}\n\n/*\n   R_API int r_bin_java_does_cp_obj_ref_idx (RBinJavaObj *bin_obj, RBinJavaCPTypeObj *cp_obj, ut16 idx) {\n        int res = false;\n        RBinJavaCPTypeObj *t_obj = NULL;\n        if (cp_obj) {\n                switch (cp_obj->tag) {\n                        case R_BIN_JAVA_CP_NULL: break;\n                        case R_BIN_JAVA_CP_UTF8: break;\n                        case R_BIN_JAVA_CP_UNKNOWN: break;\n                        case R_BIN_JAVA_CP_INTEGER: break;\n                        case R_BIN_JAVA_CP_FLOAT: break;\n                        case R_BIN_JAVA_CP_LONG: break;\n                        case R_BIN_JAVA_CP_DOUBLE: break;\n                        case R_BIN_JAVA_CP_CLASS:\n                                res = idx == cp_obj->info.cp_class.name_idx ? true : false;\n                                break;\n                        case R_BIN_JAVA_CP_STRING:\n                                res = idx == cp_obj->info.cp_string.string_idx ? true : false;\n                                break;\n                        case R_BIN_JAVA_CP_METHODREF: break;// check if idx is referenced here\n                        case R_BIN_JAVA_CP_INTERFACEMETHOD_REF: break; // check if idx is referenced here\n                        case R_BIN_JAVA_CP_FIELDREF:\n                                t_obj = r_bin_java_get_item_from_cp (bin_obj, cp_obj->info.cp_method.class_idx);\n                                res = r_bin_java_does_cp_obj_ref_idx (bin_obj, t_obj, idx);\n                                if (res == true) break;\n                                t_obj = r_bin_java_get_item_from_cp (bin_obj, cp_obj->info.cp_method.name_and_type_idx);\n                                res = r_bin_java_does_cp_obj_ref_idx (bin_obj, t_obj, idx);\n                                break;\n                        case R_BIN_JAVA_CP_NAMEANDTYPE: break;// check if idx is referenced here\n                                obj->info.cp_name_and_type.name_idx\n                        case R_BIN_JAVA_CP_METHODHANDLE: break;// check if idx is referenced here\n                        case R_BIN_JAVA_CP_METHODTYPE: break;// check if idx is referenced here\n                        case R_BIN_JAVA_CP_INVOKEDYNAMIC: break;// check if idx is referenced here\n                }\n        }\n   }\n */\nR_API RList *r_bin_java_find_cp_const_by_val_long(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len) {\n\tRList *res = r_list_newf (free);\n\tut32 *v = NULL;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *cp_obj;\n\teprintf (\"Looking for 0x%08x\\n\", R_BIN_JAVA_UINT (bytes, 0));\n\tr_list_foreach (bin_obj->cp_list, iter, cp_obj) {\n\t\tif (cp_obj->tag == R_BIN_JAVA_CP_LONG) {\n\t\t\tif (len == 8 && r_bin_java_raw_to_long (cp_obj->info.cp_long.bytes.raw, 0) == r_bin_java_raw_to_long (bytes, 0)) {\n\t\t\t\t// TODO: we can safely store a ut32 inside the list without having to allocate it\n\t\t\t\tv = malloc (sizeof (ut32));\n\t\t\t\tif (!v) {\n\t\t\t\t\tr_list_free (res);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t*v = cp_obj->idx;\n\t\t\t\tr_list_append (res, v);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API RList *r_bin_java_find_cp_const_by_val_double(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len) {\n\tRList *res = r_list_newf (free);\n\tut32 *v = NULL;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *cp_obj;\n\teprintf (\"Looking for %f\\n\", r_bin_java_raw_to_double (bytes, 0));\n\tr_list_foreach (bin_obj->cp_list, iter, cp_obj) {\n\t\tif (cp_obj->tag == R_BIN_JAVA_CP_DOUBLE) {\n\t\t\tif (len == 8 && r_bin_java_raw_to_double (cp_obj->info.cp_long.bytes.raw, 0) == r_bin_java_raw_to_double (bytes, 0)) {\n\t\t\t\tv = malloc (sizeof (ut32));\n\t\t\t\tif (!v) {\n\t\t\t\t\tr_list_free (res);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t*v = cp_obj->idx;\n\t\t\t\tr_list_append (res, v);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API RList *r_bin_java_find_cp_const_by_val_float(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len) {\n\tRList *res = r_list_newf (free);\n\tut32 *v = NULL;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *cp_obj;\n\teprintf (\"Looking for %f\\n\", R_BIN_JAVA_FLOAT (bytes, 0));\n\tr_list_foreach (bin_obj->cp_list, iter, cp_obj) {\n\t\tif (cp_obj->tag == R_BIN_JAVA_CP_FLOAT) {\n\t\t\tif (len == 4 && R_BIN_JAVA_FLOAT (cp_obj->info.cp_long.bytes.raw, 0) == R_BIN_JAVA_FLOAT (bytes, 0)) {\n\t\t\t\tv = malloc (sizeof (ut32));\n\t\t\t\tif (!v) {\n\t\t\t\t\tr_list_free (res);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t*v = cp_obj->idx;\n\t\t\t\tr_list_append (res, v);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API RList *r_bin_java_find_cp_const_by_val(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len, const char t) {\n\tswitch (t) {\n\tcase R_BIN_JAVA_CP_UTF8: return r_bin_java_find_cp_const_by_val_utf8 (bin_obj, bytes, len);\n\tcase R_BIN_JAVA_CP_INTEGER: return r_bin_java_find_cp_const_by_val_int (bin_obj, bytes, len);\n\tcase R_BIN_JAVA_CP_FLOAT: return r_bin_java_find_cp_const_by_val_float (bin_obj, bytes, len);\n\tcase R_BIN_JAVA_CP_LONG: return r_bin_java_find_cp_const_by_val_long (bin_obj, bytes, len);\n\tcase R_BIN_JAVA_CP_DOUBLE: return r_bin_java_find_cp_const_by_val_double (bin_obj, bytes, len);\n\tcase R_BIN_JAVA_CP_UNKNOWN:\n\tdefault:\n\t\teprintf (\"Failed to perform the search for: %s\\n\", bytes);\n\t\treturn r_list_new ();\n\t}\n}\n\n// #if 0\n// Attempted to clean up these functions and remove them since they are \"unused\" but without\n// them there are some compile time warnings, because other projects actually depend on these\n// for some form of information.\nR_API void U(add_cp_objs_to_sdb)(RBinJavaObj * bin) {\n\t/*\n\tAdd Constant Pool Serialized Object to an Array\n\tthe key for this info is:\n\tKey:\n\tjava.<classname>.cp_obj\n\tEach Value varies by type:\n\tIn general its:\n\t<ordinal>.<file_offset>.<type_name>.[type specific stuff]\n\tExample:\n\tUTF-8:  <ordinal>.<file_offset>.<type_name>.<strlen>.<hexlified(str)>\n\tInteger: <ordinal>.<file_offset>.<type_name>.<abs(int)>\n\tLong: <ordinal>.<file_offset>.<type_name>.abs(long)>\n\tFieldRef/MethodRef: <ordinal>.<file_offset>.<type_name>.<class_idx>.<name_and_type_idx>\n\t*/\n\tut32 idx = 0, class_name_inheap = 1;\n\tRBinJavaCPTypeObj *cp_obj = NULL;\n\tchar *key = NULL,\n\t*value = NULL;\n\tchar str_cnt[40];\n\tchar *class_name = r_bin_java_get_this_class_name (bin);\n\tut32 key_buf_size = 0;\n\tif (class_name == NULL) {\n\t\tclass_name = \"unknown\";\n\t\tclass_name_inheap = 0;\n\t}\n\t// 4 - format, 8 number, 1 null byte, 7 \"unknown\"\n\tkey_buf_size = strlen (class_name) + 4 + 8 + 1;\n\tkey = malloc (key_buf_size);\n\tif (key == NULL) {\n\t\tif (class_name_inheap) {\n\t\t\tfree (class_name);\n\t\t}\n\t\treturn;\n\t}\n\tsnprintf (key, key_buf_size - 1, \"%s.cp_count\", class_name);\n\tkey[key_buf_size - 1] = 0;\n\tsnprintf (str_cnt, 39, \"%d\", bin->cp_count);\n\tstr_cnt[39] = 0;\n\tsdb_set (bin->kv, key, value, 0);\n\t// sdb_alist(bin->kv, key);\n\tfor (idx = 0; idx < bin->cp_count; idx++) {\n\t\tsnprintf (key, key_buf_size - 1, \"%s.cp.%d\", class_name, idx);\n\t\tkey[key_buf_size - 1] = 0;\n\t\tcp_obj = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\t\tIFDBG eprintf(\"Adding %s to the sdb.\\n\", key);\n\t\tif (cp_obj) {\n\t\t\tvalue = ((RBinJavaCPTypeMetas *)\n\t\t\tcp_obj->metas->type_info)->\n\t\t\tallocs->stringify_obj (cp_obj);\n\t\t\tsdb_set (bin->kv, key, value, 0);\n\t\t\tfree (value);\n\t\t}\n\t}\n\tif (class_name_inheap) {\n\t\tfree (class_name);\n\t}\n\tfree (key);\n}\n\nR_API void U(add_field_infos_to_sdb)(RBinJavaObj * bin) {\n\t/*\n\t*** Experimental and May Change ***\n\tAdd field information to an Array\n\tthe key for this info variable depenedent on addr, method ordinal, etc.\n\tKey 1, mapping to method key:\n\tjava.<file_offset> = <field_key>\n\tKey 3, method description\n\t<field_key>.info = [<access str>, <class_name>, <name>, <signature>]\n\tkey 4, method meta\n\t<field_key>.meta = [<file_offset>, ?]\n\t*/\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaField *fm_type;\n\tut32 key_size = 255,\n\tvalue_buffer_size = 1024,\n\tclass_name_inheap = 1;\n\tchar *field_key = NULL,\n\t*field_key_value = NULL,\n\t*value_buffer = NULL;\n\tchar *class_name = r_bin_java_get_this_class_name (bin);\n\tif (class_name == NULL) {\n\t\tclass_name = \"unknown\";\n\t\tclass_name_inheap = 0;\n\t}\n\tkey_size += strlen (class_name);\n\tvalue_buffer_size += strlen (class_name);\n\tfield_key = malloc (key_size);\n\tvalue_buffer = malloc (value_buffer_size);\n\tfield_key_value = malloc (key_size);\n\tsnprintf (field_key, key_size, \"%s.methods\", class_name);\n\tfield_key[key_size - 1] = 0;\n\tr_list_foreach_safe (bin->fields_list, iter, iter_tmp, fm_type) {\n\t\tchar number_buffer[80];\n\t\tut64 file_offset = fm_type->file_offset + bin->loadaddr;\n\t\tsnprintf (number_buffer, sizeof (number_buffer), \"0x%04\"PFMT64x, file_offset);\n\t\tIFDBG eprintf(\"Inserting: []%s = %s\\n\", field_key, number_buffer);\n\t\tsdb_array_push (bin->kv, field_key, number_buffer, 0);\n\t}\n\tr_list_foreach_safe (bin->fields_list, iter, iter_tmp, fm_type) {\n\t\tut64 field_offset = fm_type->file_offset + bin->loadaddr;\n\t\t// generate method specific key & value\n\t\tsnprintf (field_key, key_size, \"%s.0x%04\"PFMT64x, class_name, field_offset);\n\t\tfield_key[key_size - 1] = 0;\n\t\tsnprintf (field_key_value, key_size, \"%s.0x%04\"PFMT64x \".field\", class_name, field_offset);\n\t\tfield_key_value[key_size - 1] = 0;\n\t\tsdb_set (bin->kv, field_key, field_key_value, 0);\n\t\tIFDBG eprintf(\"Inserting: %s = %s\\n\", field_key, field_key_value);\n\t\t// generate info key, and place values in method info array\n\t\tsnprintf (field_key, key_size, \"%s.info\", field_key_value);\n\t\tfield_key[key_size - 1] = 0;\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->flags_str);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tsdb_array_push (bin->kv, field_key, value_buffer, 0);\n\t\tIFDBG eprintf(\"Inserting: []%s = %s\\n\", field_key, value_buffer);\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->class_name);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tsdb_array_push (bin->kv, field_key, value_buffer, 0);\n\t\tIFDBG eprintf(\"Inserting: []%s = %s\\n\", field_key, value_buffer);\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->name);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tsdb_array_push (bin->kv, field_key, value_buffer, 0);\n\t\tIFDBG eprintf(\"Inserting: []%s = %s\\n\", field_key, value_buffer);\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->descriptor);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tsdb_array_push (bin->kv, field_key, value_buffer, 0);\n\t\tIFDBG eprintf(\"Inserting: []%s = %s\\n\", field_key, value_buffer);\n\t}\n\tfree (field_key);\n\tfree (field_key_value);\n\tfree (value_buffer);\n\tif (class_name_inheap) {\n\t\tfree (class_name);\n\t}\n}\n\nR_API void U(add_method_infos_to_sdb)(RBinJavaObj * bin) {\n\t/*\n\t*** Experimental and May Change ***\n\tAdd Mehtod information to an Array\n\tthe key for this info variable depenedent on addr, method ordinal, etc.\n\tKey 1, mapping to method key:\n\tjava.<file_offset> = <method_key>\n\tKey 2, basic code information\n\t<method_key>.code = [<addr>, <size>]\n\tKey 3, method description\n\t<method_key>.info = [<access str>, <class_name>, <name>, <signature>,]\n\tkey 4, method meta\n\t<method_key>.meta = [<file_offset>, ?]\n\t// TODO in key 3 add <class_name>?\n\te.g. <access str>.<name>.<signature>\n\tNote: method name not used because of collisions with operator overloading\n\talso take note that code offset and the method offset are not the same\n\tvalues.\n\t*/\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaField *fm_type;\n\tut32 key_size = 255,\n\tvalue_buffer_size = 1024,\n\tclass_name_inheap = 1;\n\tchar *method_key = NULL,\n\t*method_key_value = NULL,\n\t*value_buffer = NULL;\n\tchar *class_name = r_bin_java_get_this_class_name (bin);\n\tut64 baddr = bin->loadaddr;\n\tif (class_name == NULL) {\n\t\tclass_name = \"unknown\";\n\t\tclass_name_inheap = 0;\n\t}\n\tkey_size += strlen (class_name);\n\tvalue_buffer_size += strlen (class_name);\n\tmethod_key = malloc (key_size);\n\tvalue_buffer = malloc (value_buffer_size);\n\tmethod_key_value = malloc (key_size);\n\tsnprintf (method_key, key_size, \"%s.methods\", class_name);\n\tmethod_key[key_size - 1] = 0;\n\tr_list_foreach_safe (bin->methods_list, iter, iter_tmp, fm_type) {\n\t\tchar number_buffer[80];\n\t\tut64 file_offset = fm_type->file_offset + baddr;\n\t\tsnprintf (number_buffer, sizeof (number_buffer), \"0x%04\"PFMT64x, file_offset);\n\t\tsdb_array_push (bin->kv, method_key, number_buffer, 0);\n\t}\n\tr_list_foreach_safe (bin->methods_list, iter, iter_tmp, fm_type) {\n\t\tut64 code_offset = r_bin_java_get_method_code_offset (fm_type) + baddr,\n\t\tcode_size = r_bin_java_get_method_code_size (fm_type),\n\t\tmethod_offset = fm_type->file_offset + baddr;\n\t\t// generate method specific key & value\n\t\tsnprintf (method_key, key_size, \"%s.0x%04\"PFMT64x, class_name, code_offset);\n\t\tmethod_key[key_size - 1] = 0;\n\t\tsnprintf (method_key_value, key_size, \"%s.0x%04\"PFMT64x \".method\", class_name, method_offset);\n\t\tmethod_key_value[key_size - 1] = 0;\n\t\tIFDBG eprintf(\"Adding %s to sdb_array: %s\\n\", method_key_value, method_key);\n\t\tsdb_set (bin->kv, method_key, method_key_value, 0);\n\t\t// generate code key and values\n\t\tsnprintf (method_key, key_size, \"%s.code\", method_key_value);\n\t\tmethod_key[key_size - 1] = 0;\n\t\tsnprintf (value_buffer, value_buffer_size, \"0x%04\"PFMT64x, code_offset);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tsdb_array_push (bin->kv, method_key, value_buffer, 0);\n\t\tsnprintf (value_buffer, value_buffer_size, \"0x%04\"PFMT64x, code_size);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tsdb_array_push (bin->kv, method_key, value_buffer, 0);\n\t\t// generate info key, and place values in method info array\n\t\tsnprintf (method_key, key_size, \"%s.info\", method_key_value);\n\t\tmethod_key[key_size - 1] = 0;\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->flags_str);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tIFDBG eprintf(\"Adding %s to sdb_array: %s\\n\", value_buffer, method_key);\n\t\tsdb_array_push (bin->kv, method_key, value_buffer, 0);\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->class_name);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tIFDBG eprintf(\"Adding %s to sdb_array: %s\\n\", value_buffer, method_key);\n\t\tsdb_array_push (bin->kv, method_key, value_buffer, 0);\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->name);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tIFDBG eprintf(\"Adding %s to sdb_array: %s\\n\", value_buffer, method_key);\n\t\tsdb_array_push (bin->kv, method_key, value_buffer, 0);\n\t\tsnprintf (value_buffer, value_buffer_size, \"%s\", fm_type->descriptor);\n\t\tvalue_buffer[value_buffer_size - 1] = 0;\n\t\tIFDBG eprintf(\"Adding %s to sdb_array: %s\\n\", value_buffer, method_key);\n\t\tsdb_array_push (bin->kv, method_key, value_buffer, 0);\n\t}\n\tfree (method_key);\n\tfree (method_key_value);\n\tfree (value_buffer);\n\tif (class_name_inheap) {\n\t\tfree (class_name);\n\t}\n}\n\nR_API RList *U(r_bin_java_get_args_from_bin)(RBinJavaObj * bin_obj, ut64 addr) {\n\tRBinJavaField *fm_type = r_bin_java_get_method_code_attribute_with_addr (bin_obj, addr);\n\treturn fm_type ? r_bin_java_get_args (fm_type) : NULL;\n}\n\nR_API RList *U(r_bin_java_get_ret_from_bin)(RBinJavaObj * bin_obj, ut64 addr) {\n\tRBinJavaField *fm_type = r_bin_java_get_method_code_attribute_with_addr (bin_obj, addr);\n\treturn fm_type ? r_bin_java_get_ret (fm_type) : NULL;\n}\n\nR_API char *U(r_bin_java_get_fcn_name_from_bin)(RBinJavaObj * bin_obj, ut64 addr) {\n\tRBinJavaField *fm_type = r_bin_java_get_method_code_attribute_with_addr (bin_obj, addr);\n\treturn fm_type && fm_type->name ? strdup (fm_type->name) : NULL;\n}\n\nR_API int U(r_bin_java_is_method_static)(RBinJavaObj * bin_obj, ut64 addr) {\n\tRBinJavaField *fm_type = r_bin_java_get_method_code_attribute_with_addr (bin_obj, addr);\n\treturn fm_type && fm_type->flags & R_BIN_JAVA_METHOD_ACC_STATIC;\n}\n\nR_API int U(r_bin_java_is_method_private)(RBinJavaObj * bin_obj, ut64 addr) {\n\treturn r_bin_java_is_fm_type_private (r_bin_java_get_method_code_attribute_with_addr (bin_obj, addr));\n}\n\nR_API int U(r_bin_java_is_method_protected)(RBinJavaObj * bin_obj, ut64 addr) {\n\treturn r_bin_java_is_fm_type_protected (\n\t\tr_bin_java_get_method_code_attribute_with_addr (bin_obj, addr));\n}\n\nR_API int r_bin_java_print_method_idx_summary(RBinJavaObj *bin_obj, ut32 idx) {\n\tint res = false;\n\tif (idx < r_list_length (bin_obj->methods_list)) {\n\t\tRBinJavaField *fm_type = r_list_get_n (bin_obj->methods_list, idx);\n\t\tr_bin_java_print_method_summary (fm_type);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nR_API ut32 r_bin_java_get_method_count(RBinJavaObj *bin_obj) {\n\treturn r_list_length (bin_obj->methods_list);\n}\n\nR_API RList *r_bin_java_get_interface_names(RBinJavaObj *bin) {\n\tRList *interfaces_names = r_list_new ();\n\tRListIter *iter;\n\tRBinJavaInterfaceInfo *ifobj;\n\tr_list_foreach (bin->interfaces_list, iter, ifobj) {\n\t\tif (ifobj && ifobj->name) {\n\t\t\tr_list_append (interfaces_names, strdup (ifobj->name));\n\t\t}\n\t}\n\treturn interfaces_names;\n}\n\nR_API ut64 r_bin_java_get_main(RBinJavaObj *bin) {\n\tif (bin->main_code_attr) {\n\t\treturn bin->main_code_attr->info.code_attr.code_offset + bin->loadaddr;\n\t}\n\treturn 0;\n}\n\nR_API RBinJavaObj *r_bin_java_new(const char *file, ut64 loadaddr, Sdb *kv) {\n\tut8 *buf;\n\tRBinJavaObj *bin = R_NEW0 (RBinJavaObj);\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tbin->file = strdup (file);\n\tif (!(buf = (ut8 *) r_file_slurp (file, &bin->size))) {\n\t\treturn r_bin_java_free (bin);\n\t}\n\tif (!r_bin_java_new_bin (bin, loadaddr, kv, buf, bin->size)) {\n\t\tr_bin_java_free (bin);\n\t\tbin = NULL;\n\t}\n\tfree (buf);\n\treturn bin;\n}\n\nR_API ut64 r_bin_java_get_class_entrypoint(RBinJavaObj *bin) {\n\tif (bin->cf2.this_class_entrypoint_code_attr) {\n\t\treturn bin->cf2.this_class_entrypoint_code_attr->info.code_attr.code_offset;\n\t}\n\treturn 0;\n}\n\nR_API RList *r_bin_java_get_method_exception_table_with_addr(RBinJavaObj *bin, ut64 addr) {\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tRBinJavaField *fm_type, *res = NULL;\n\tif (!bin && R_BIN_JAVA_GLOBAL_BIN) {\n\t\tbin = R_BIN_JAVA_GLOBAL_BIN;\n\t}\n\tif (!bin) {\n\t\teprintf (\"Attempting to analyse function when the R_BIN_JAVA_GLOBAL_BIN has not been set.\\n\");\n\t\treturn NULL;\n\t}\n\tr_list_foreach_safe (bin->methods_list, iter, iter_tmp, fm_type) {\n\t\tut64 offset = r_bin_java_get_method_code_offset (fm_type) + bin->loadaddr,\n\t\tsize = r_bin_java_get_method_code_size (fm_type);\n\t\tif (addr >= offset && addr <= size + offset) {\n\t\t\tres = fm_type;\n\t\t}\n\t}\n\tif (res) {\n\t\tRBinJavaAttrInfo *code_attr = r_bin_java_get_method_code_attribute (res);\n\t\treturn code_attr->info.code_attr.exception_table;\n\t}\n\treturn NULL;\n}\n\nR_API const RList *r_bin_java_get_methods_list(RBinJavaObj *bin) {\n\tif (bin) {\n\t\treturn bin->methods_list;\n\t}\n\tif (R_BIN_JAVA_GLOBAL_BIN) {\n\t\treturn R_BIN_JAVA_GLOBAL_BIN->methods_list;\n\t}\n\treturn NULL;\n}\n\nR_API RList *r_bin_java_get_bin_obj_list_thru_obj(RBinJavaObj *bin_obj) {\n\tRList *the_list;\n\tSdb *sdb;\n\tif (!bin_obj) {\n\t\treturn NULL;\n\t}\n\tsdb = bin_obj->AllJavaBinObjs;\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tthe_list = r_list_new ();\n\tif (!the_list) {\n\t\treturn NULL;\n\t}\n\tsdb_foreach (sdb, sdb_iterate_build_list, (void *) the_list);\n\treturn the_list;\n}\n\nR_API RList *r_bin_java_extract_all_bin_type_values(RBinJavaObj *bin_obj) {\n\tRListIter *fm_type_iter;\n\tRList *all_types = r_list_new ();\n\tRBinJavaField *fm_type;\n\t// get all field types\n\tr_list_foreach (bin_obj->fields_list, fm_type_iter, fm_type) {\n\t\tchar *desc = NULL;\n\t\tif (!extract_type_value (fm_type->descriptor, &desc)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tIFDBG eprintf(\"Adding field type: %s\\n\", desc);\n\t\tr_list_append (all_types, desc);\n\t}\n\t// get all method types\n\tr_list_foreach (bin_obj->methods_list, fm_type_iter, fm_type) {\n\t\tRList *the_list = r_bin_java_extract_type_values (fm_type->descriptor);\n\t\tRListIter *desc_iter;\n\t\tchar *str;\n\t\tr_list_foreach (the_list, desc_iter, str) {\n\t\t\tif (str && *str != '(' && *str != ')') {\n\t\t\t\tr_list_append (all_types, strdup (str));\n\t\t\t\tIFDBG eprintf(\"Adding method type: %s\\n\", str);\n\t\t\t}\n\t\t}\n\t\tr_list_free (the_list);\n\t}\n\treturn all_types;\n}\n\nR_API RList *r_bin_java_get_method_definitions(RBinJavaObj *bin) {\n\tRBinJavaField *fm_type = NULL;\n\tRList *the_list = r_list_new ();\n\tif (!the_list) {\n\t\treturn NULL;\n\t}\n\tRListIter *iter = NULL;\n\tif (!bin) {\n\t\treturn the_list;\n\t}\n\tr_list_foreach (bin->methods_list, iter, fm_type) {\n\t\tchar *method_proto = r_bin_java_get_method_definition (fm_type);\n\t\t// eprintf (\"Method prototype: %s\\n\", method_proto);\n\t\tr_list_append (the_list, method_proto);\n\t}\n\treturn the_list;\n}\n\nR_API RList *r_bin_java_get_field_definitions(RBinJavaObj *bin) {\n\tRBinJavaField *fm_type = NULL;\n\tRList *the_list = r_list_new ();\n\tif (!the_list) {\n\t\treturn NULL;\n\t}\n\tRListIter *iter = NULL;\n\tif (!bin) {\n\t\treturn the_list;\n\t}\n\tr_list_foreach (bin->fields_list, iter, fm_type) {\n\t\tchar *field_def = r_bin_java_get_field_definition (fm_type);\n\t\t// eprintf (\"Field def: %s, %s, %s, %s\\n\", fm_type->name, fm_type->descriptor, fm_type->flags_str, field_def);\n\t\tr_list_append (the_list, field_def);\n\t}\n\treturn the_list;\n}\n\nR_API RList *r_bin_java_get_import_definitions(RBinJavaObj *bin) {\n\tRList *the_list = r_bin_java_get_lib_names (bin);\n\tRListIter *iter = NULL;\n\tchar *new_str;\n\tif (!bin || !the_list) {\n\t\treturn the_list;\n\t}\n\tr_list_foreach (the_list, iter, new_str) {\n\t\twhile (*new_str) {\n\t\t\tif (*new_str == '/') {\n\t\t\t\t*new_str = '.';\n\t\t\t}\n\t\t\tnew_str++;\n\t\t}\n\t}\n\treturn the_list;\n}\n\nR_API RList *r_bin_java_get_field_offsets(RBinJavaObj *bin) {\n\tRBinJavaField *fm_type = NULL;\n\tRList *the_list = r_list_new ();\n\tif (!the_list) {\n\t\treturn NULL;\n\t}\n\tRListIter *iter = NULL;\n\tut64 *paddr = NULL;\n\tif (!bin) {\n\t\treturn the_list;\n\t}\n\tthe_list->free = free;\n\tr_list_foreach (bin->fields_list, iter, fm_type) {\n\t\tpaddr = malloc (sizeof(ut64));\n\t\tif (!paddr) {\n\t\t\tr_list_free (the_list);\n\t\t\treturn NULL;\n\t\t}\n\t\t*paddr = fm_type->file_offset + bin->loadaddr;\n\t\t// eprintf (\"Field def: %s, %s, %s, %s\\n\", fm_type->name, fm_type->descriptor, fm_type->flags_str, field_def);\n\t\tr_list_append (the_list, paddr);\n\t}\n\treturn the_list;\n}\n\nR_API RList *r_bin_java_get_method_offsets(RBinJavaObj *bin) {\n\tRBinJavaField *fm_type = NULL;\n\tRList *the_list = r_list_new ();\n\tRListIter *iter = NULL;\n\tut64 *paddr = NULL;\n\tif (!bin) {\n\t\treturn the_list;\n\t}\n\tthe_list->free = free;\n\tr_list_foreach (bin->methods_list, iter, fm_type) {\n\t\tpaddr = R_NEW0 (ut64);\n\t\t*paddr = fm_type->file_offset + bin->loadaddr;\n\t\tr_list_append (the_list, paddr);\n\t}\n\treturn the_list;\n}\n\nR_API ut16 r_bin_java_calculate_field_access_value(const char *access_flags_str) {\n\treturn calculate_access_value (access_flags_str, FIELD_ACCESS_FLAGS);\n}\n\nR_API ut16 r_bin_java_calculate_class_access_value(const char *access_flags_str) {\n\treturn calculate_access_value (access_flags_str, CLASS_ACCESS_FLAGS);\n}\n\nR_API ut16 r_bin_java_calculate_method_access_value(const char *access_flags_str) {\n\treturn calculate_access_value (access_flags_str, METHOD_ACCESS_FLAGS);\n}\n\nR_API RList *retrieve_all_method_access_string_and_value() {\n\treturn retrieve_all_access_string_and_value (METHOD_ACCESS_FLAGS);\n}\n\nR_API RList *retrieve_all_field_access_string_and_value() {\n\treturn retrieve_all_access_string_and_value (FIELD_ACCESS_FLAGS);\n}\n\nR_API RList *retrieve_all_class_access_string_and_value() {\n\treturn retrieve_all_access_string_and_value (CLASS_ACCESS_FLAGS);\n}\n\nR_API char *r_bin_java_resolve_with_space(RBinJavaObj *obj, int idx) {\n\treturn r_bin_java_resolve (obj, idx, 1);\n}\n\nR_API char *r_bin_java_resolve_without_space(RBinJavaObj *obj, int idx) {\n\treturn r_bin_java_resolve (obj, idx, 0);\n}\n\nR_API char *r_bin_java_resolve_b64_encode(RBinJavaObj *BIN_OBJ, ut16 idx) {\n\tRBinJavaCPTypeObj *item = NULL, *item2 = NULL;\n\tchar *class_str = NULL,\n\t*name_str = NULL,\n\t*desc_str = NULL,\n\t*string_str = NULL,\n\t*empty = \"\",\n\t*cp_name = NULL,\n\t*str = NULL, *out = NULL;\n\tint memory_alloc = 0;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\t// r_bin_java_new_bin(BIN_OBJ);\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\tcp_name = ((RBinJavaCPTypeMetas *) item->metas->type_info)->name;\n\t\tIFDBG eprintf(\"java_resolve Resolved: (%d) %s\\n\", idx, cp_name);\n\t} else {\n\t\treturn NULL;\n\t}\n\tcp_name = ((RBinJavaCPTypeMetas *) item->metas->type_info)->name;\n\tif (!strcmp (cp_name, \"Class\")) {\n\t\titem2 = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\t\t// str = r_bin_java_get_name_from_bin_cp_list (BIN_OBJ, idx-1);\n\t\tclass_str = empty;\n\t\tclass_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!class_str) {\n\t\t\tclass_str = empty;\n\t\t}\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item2);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item2);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tmemory_alloc = strlen (class_str) + strlen (name_str) + strlen (desc_str) + 3;\n\t\tif (memory_alloc) {\n\t\t\tstr = malloc (memory_alloc);\n\t\t\tsnprintf (str, memory_alloc, \"%s%s\", name_str, desc_str);\n\t\t\tout = (char *) malloc (memory_alloc);\n\t\t\tmemset (out, 0, memory_alloc);\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t\tif (class_str != empty) {\n\t\t\tfree (class_str);\n\t\t}\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else if (strcmp (cp_name, \"MethodRef\") == 0 ||\n\tstrcmp (cp_name, \"FieldRef\") == 0 ||\n\tstrcmp (cp_name, \"InterfaceMethodRef\") == 0) {\n\t\t/*\n\t\t*  The MethodRef, FieldRef, and InterfaceMethodRef structures\n\t\t*/\n\t\tclass_str = r_bin_java_get_name_from_bin_cp_list (BIN_OBJ, item->info.cp_method.class_idx);\n\t\tif (!class_str) {\n\t\t\tclass_str = empty;\n\t\t}\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tmemory_alloc = strlen (class_str) + strlen (name_str) + strlen (desc_str) + 3;\n\t\tif (memory_alloc) {\n\t\t\tstr = malloc (memory_alloc);\n\t\t\tsnprintf (str, memory_alloc, \"%s/%s%s\", class_str, name_str, desc_str);\n\t\t\tout = malloc (memory_alloc);\n\t\t\tmemset (out, 0, memory_alloc);\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t\tif (class_str != empty) {\n\t\t\tfree (class_str);\n\t\t}\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else if (strcmp (cp_name, \"String\") == 0) {\n\t\tut32 length = r_bin_java_get_utf8_len_from_bin_cp_list (BIN_OBJ, item->info.cp_string.string_idx);\n\t\tstring_str = r_bin_java_get_utf8_from_bin_cp_list (BIN_OBJ, item->info.cp_string.string_idx);\n\t\tstr = NULL;\n\t\tIFDBG eprintf(\"java_resolve String got: (%d) %s\\n\", item->info.cp_string.string_idx, string_str);\n\t\tif (!string_str) {\n\t\t\tstring_str = empty;\n\t\t\tlength = strlen (empty);\n\t\t}\n\t\tmemory_alloc = length + 3;\n\t\tif (memory_alloc) {\n\t\t\tstr = malloc (memory_alloc);\n\t\t\tsnprintf (str, memory_alloc, \"\\\"%s\\\"\", string_str);\n\t\t\tout = malloc (memory_alloc);\n\t\t\tmemset (out, 0, memory_alloc);\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t\tIFDBG eprintf(\"java_resolve String return: %s\\n\", str);\n\t\tif (string_str != empty) {\n\t\t\tfree (string_str);\n\t\t}\n\t} else if (strcmp (cp_name, \"Utf8\") == 0) {\n\t\tut64 sz = item->info.cp_utf8.length ? item->info.cp_utf8.length + 10 : 10;\n\t\tstr = malloc (sz);\n\t\tmemset (str, 0, sz);\n\t\tif (sz > 10) {\n\t\t\tr_base64_encode (str, item->info.cp_utf8.bytes, item->info.cp_utf8.length);\n\t\t}\n\t} else if (strcmp (cp_name, \"Long\") == 0) {\n\t\tstr = malloc (34);\n\t\tout = malloc (34);\n\t\tmemset (out, 0, 34);\n\t\tif (str) {\n\t\t\tsnprintf (str, 34, \"0x%\"PFMT64x, r_bin_java_raw_to_long (item->info.cp_long.bytes.raw, 0));\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t} else if (strcmp (cp_name, \"Double\") == 0) {\n\t\tstr = malloc (1000);\n\t\tout = malloc (1000);\n\t\tmemset (out, 0, 1000);\n\t\tif (str) {\n\t\t\tsnprintf (str, 1000, \"%f\", r_bin_java_raw_to_double (item->info.cp_double.bytes.raw, 0));\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t} else if (strcmp (cp_name, \"Integer\") == 0) {\n\t\tstr = calloc (34, 1);\n\t\tout = calloc (34, 1);\n\t\tif (str) {\n\t\t\tsnprintf (str, 34, \"0x%08x\", R_BIN_JAVA_UINT (item->info.cp_integer.bytes.raw, 0));\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t} else if (strcmp (cp_name, \"Float\") == 0) {\n\t\tstr = malloc (34);\n\t\tout = malloc (34);\n\t\tmemset (out, 0, 34);\n\t\tif (str) {\n\t\t\tsnprintf (str, 34, \"%f\", R_BIN_JAVA_FLOAT (item->info.cp_float.bytes.raw, 0));\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t} else if (!strcmp (cp_name, \"NameAndType\")) {\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tmemory_alloc = strlen (name_str) + strlen (desc_str) + 3;\n\t\tif (memory_alloc) {\n\t\t\tstr = malloc (memory_alloc);\n\t\t\tsnprintf (str, memory_alloc, \"%s %s\", name_str, desc_str);\n\t\t\tout = malloc (memory_alloc);\n\t\t\tmemset (out, 0, memory_alloc);\n\t\t\tr_base64_encode (out, (const ut8 *) str, strlen (str));\n\t\t\tfree (str);\n\t\t\tstr = out;\n\t\t}\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else {\n\t\tstr = malloc (16);\n\t\tmemset (str, 0, 16);\n\t\tif (str) {\n\t\t\tr_base64_encode (str, (const ut8 *) \"(null)\", 6);\n\t\t}\n\t}\n\treturn str;\n}\n\nR_API ut64 r_bin_java_resolve_cp_idx_address(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaCPTypeObj *item = NULL;\n\tut64 addr = -1;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\treturn -1;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\taddr = item->file_offset + item->loadaddr;\n\t}\n\treturn addr;\n}\n\nR_API char *r_bin_java_resolve_cp_idx_to_string(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaCPTypeObj *item = NULL;\n\tchar *value = NULL;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\treturn NULL;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\tvalue = ((RBinJavaCPTypeMetas *)\n\t\titem->metas->type_info)->\n\t\tallocs->stringify_obj (item);\n\t}\n\treturn value;\n}\n\nR_API int r_bin_java_resolve_cp_idx_print_summary(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaCPTypeObj *item = NULL;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\treturn false;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\t((RBinJavaCPTypeMetas *)\n\t\titem->metas->type_info)->\n\t\tallocs->print_summary (item);\n\t} else {\n\t\teprintf (\"Error: Invalid CP Object.\\n\");\n\t}\n\treturn item ? true : false;\n}\n\nR_API ConstJavaValue *U(r_bin_java_resolve_to_const_value)(RBinJavaObj * BIN_OBJ, int idx) {\n\t// TODO XXX FIXME add a size parameter to the str when it is passed in\n\tRBinJavaCPTypeObj *item = NULL, *item2 = NULL;\n\tConstJavaValue *result = R_NEW0 (ConstJavaValue);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\tchar *class_str = NULL,\n\t*name_str = NULL,\n\t*desc_str = NULL,\n\t*string_str = NULL,\n\t*empty = \"\",\n\t*cp_name = NULL;\n\tresult->type = \"unknown\";\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\t// r_bin_java_new_bin(BIN_OBJ);\n\t\treturn result;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\tcp_name = ((RBinJavaCPTypeMetas *) item->metas->type_info)->name;\n\t\tIFDBG eprintf(\"java_resolve Resolved: (%d) %s\\n\", idx, cp_name);\n\t} else {\n\t\treturn result;\n\t}\n\tcp_name = ((RBinJavaCPTypeMetas *) item->metas->type_info)->name;\n\tif (strcmp (cp_name, \"Class\") == 0) {\n\t\titem2 = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\t\t// str = r_bin_java_get_name_from_bin_cp_list (BIN_OBJ, idx-1);\n\t\tclass_str = empty;\n\t\tclass_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!class_str) {\n\t\t\tclass_str = empty;\n\t\t}\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item2);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item2);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tresult->value._ref = R_NEW0 (_JavaRef);\n\t\tresult->type = \"ref\";\n\t\tresult->value._ref->class_name = strdup (class_str);\n\t\tresult->value._ref->name = strdup (name_str);\n\t\tresult->value._ref->desc = strdup (desc_str);\n\t\tif (class_str != empty) {\n\t\t\tfree (class_str);\n\t\t}\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else if (strcmp (cp_name, \"MethodRef\") == 0 ||\n\tstrcmp (cp_name, \"FieldRef\") == 0 ||\n\tstrcmp (cp_name, \"InterfaceMethodRef\") == 0) {\n\t\t/*\n\t\t*  The MethodRef, FieldRef, and InterfaceMethodRef structures\n\t\t*/\n\t\tclass_str = r_bin_java_get_name_from_bin_cp_list (BIN_OBJ, item->info.cp_method.class_idx);\n\t\tif (!class_str) {\n\t\t\tclass_str = empty;\n\t\t}\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tresult->value._ref = R_NEW0 (_JavaRef);\n\t\tresult->type = \"ref\";\n\t\tresult->value._ref->class_name = strdup (class_str);\n\t\tresult->value._ref->name = strdup (name_str);\n\t\tresult->value._ref->desc = strdup (desc_str);\n\t\tif (class_str != empty) {\n\t\t\tfree (class_str);\n\t\t}\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t} else if (strcmp (cp_name, \"String\") == 0) {\n\t\tut32 length = r_bin_java_get_utf8_len_from_bin_cp_list (BIN_OBJ, item->info.cp_string.string_idx);\n\t\tstring_str = r_bin_java_get_utf8_from_bin_cp_list (BIN_OBJ, item->info.cp_string.string_idx);\n\t\tIFDBG eprintf(\"java_resolve String got: (%d) %s\\n\", item->info.cp_string.string_idx, string_str);\n\t\tif (!string_str) {\n\t\t\tstring_str = empty;\n\t\t\tlength = strlen (empty);\n\t\t}\n\t\tresult->type = \"str\";\n\t\tresult->value._str = R_NEW0 (struct  java_const_value_str_t);\n\t\tresult->value._str->len = length;\n\t\tif (length > 0) {\n\t\t\tresult->value._str->str = malloc (length);\n\t\t\tmemcpy (result->value._str->str, string_str, length);\n\t\t} else {\n\t\t\tresult->value._str->str = strdup (\"\");\n\t\t}\n\t\tif (string_str != empty) {\n\t\t\tfree (string_str);\n\t\t}\n\t} else if (strcmp (cp_name, \"Utf8\") == 0) {\n\t\tresult->type = \"str\";\n\t\tresult->value._str = R_NEW0 (struct java_const_value_str_t);\n\t\tresult->value._str->str = malloc (item->info.cp_utf8.length);\n\t\tresult->value._str->len = item->info.cp_utf8.length;\n\t\tmemcpy (result->value._str->str, item->info.cp_utf8.bytes, item->info.cp_utf8.length);\n\t} else if (strcmp (cp_name, \"Long\") == 0) {\n\t\tresult->type = \"long\";\n\t\tresult->value._long = r_bin_java_raw_to_long (item->info.cp_long.bytes.raw, 0);\n\t} else if (strcmp (cp_name, \"Double\") == 0) {\n\t\tresult->type = \"double\";\n\t\tresult->value._double = r_bin_java_raw_to_double (item->info.cp_double.bytes.raw, 0);\n\t} else if (strcmp (cp_name, \"Integer\") == 0) {\n\t\tresult->type = \"int\";\n\t\tresult->value._int = R_BIN_JAVA_UINT (item->info.cp_integer.bytes.raw, 0);\n\t} else if (strcmp (cp_name, \"Float\") == 0) {\n\t\tresult->type = \"float\";\n\t\tresult->value._float = R_BIN_JAVA_FLOAT (item->info.cp_float.bytes.raw, 0);\n\t} else if (strcmp (cp_name, \"NameAndType\") == 0) {\n\t\tresult->value._ref = R_NEW0 (struct java_const_value_ref_t);\n\t\tresult->type = \"ref\";\n\t\tname_str = r_bin_java_get_item_name_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!name_str) {\n\t\t\tname_str = empty;\n\t\t}\n\t\tdesc_str = r_bin_java_get_item_desc_from_bin_cp_list (BIN_OBJ, item);\n\t\tif (!desc_str) {\n\t\t\tdesc_str = empty;\n\t\t}\n\t\tresult->value._ref->class_name = strdup (empty);\n\t\tresult->value._ref->name = strdup (name_str);\n\t\tresult->value._ref->desc = strdup (desc_str);\n\t\tif (name_str != empty) {\n\t\t\tfree (name_str);\n\t\t}\n\t\tif (desc_str != empty) {\n\t\t\tfree (desc_str);\n\t\t}\n\t\tresult->value._ref->is_method = r_bin_java_does_cp_idx_ref_method (BIN_OBJ, idx);\n\t\tresult->value._ref->is_field = r_bin_java_does_cp_idx_ref_field (BIN_OBJ, idx);\n\t}\n\treturn result;\n}\n\nR_API void U(r_bin_java_free_const_value)(ConstJavaValue * cp_value) {\n\tchar first_char = cp_value && cp_value->type ? *cp_value->type : 0,\n\tsecond_char = cp_value && cp_value->type ? *(cp_value->type + 1) : 0;\n\tswitch (first_char) {\n\tcase 'r':\n\t\tif (cp_value && cp_value->value._ref) {\n\t\t\tfree (cp_value->value._ref->class_name);\n\t\t\tfree (cp_value->value._ref->name);\n\t\t\tfree (cp_value->value._ref->desc);\n\t\t}\n\t\tbreak;\n\tcase 's':\n\t\tif (second_char == 't' && cp_value->value._str) {\n\t\t\tfree (cp_value->value._str->str);\n\t\t}\n\t\tbreak;\n\t}\n\tfree (cp_value);\n}\n\nR_API char *r_bin_java_get_field_name(RBinJavaObj *bin_obj, ut32 idx) {\n\tchar *name = NULL;\n\tif (idx < r_list_length (bin_obj->fields_list)) {\n\t\tRBinJavaField *fm_type = r_list_get_n (bin_obj->fields_list, idx);\n\t\tname = strdup (fm_type->name);\n\t}\n\treturn name;\n}\n\nR_API int r_bin_java_print_field_idx_summary(RBinJavaObj *bin_obj, ut32 idx) {\n\tint res = false;\n\tif (idx < r_list_length (bin_obj->fields_list)) {\n\t\tRBinJavaField *fm_type = r_list_get_n (bin_obj->fields_list, idx);\n\t\tr_bin_java_print_field_summary (fm_type);\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nR_API ut32 r_bin_java_get_field_count(RBinJavaObj *bin_obj) {\n\treturn r_list_length (bin_obj->fields_list);\n}\n\nR_API RList *r_bin_java_get_field_num_name(RBinJavaObj *bin_obj) {\n\tut32 i = 0;\n\tRBinJavaField *fm_type;\n\tRListIter *iter = NULL;\n\tRList *res = r_list_newf (free);\n\tr_list_foreach (bin_obj->fields_list, iter, fm_type) {\n\t\tut32 len = strlen (fm_type->name) + 30;\n\t\tchar *str = malloc (len);\n\t\tif (!str) {\n\t\t\tr_list_free (res);\n\t\t\treturn NULL;\n\t\t}\n\t\tsnprintf (str, len, \"%d %s\", i, fm_type->name);\n\t\t++i;\n\t\tr_list_append (res, str);\n\t}\n\treturn res;\n}\nR_API RList *r_bin_java_find_cp_const_by_val_utf8(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len) {\n\tRList *res = r_list_newf (free);\n\tut32 *v = NULL;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *cp_obj;\n\tIFDBG eprintf(\"In UTF-8 Looking for %s\\n\", bytes);\n\tr_list_foreach (bin_obj->cp_list, iter, cp_obj) {\n\t\tif (cp_obj->tag == R_BIN_JAVA_CP_UTF8) {\n\t\t\tIFDBG eprintf(\"In UTF-8 Looking @ %s\\n\", cp_obj->info.cp_utf8.bytes);\n\t\t\tIFDBG eprintf(\"UTF-8 len = %d and memcmp = %d\\n\", cp_obj->info.cp_utf8.length, memcmp (bytes, cp_obj->info.cp_utf8.bytes, len));\n\t\t\tif (len == cp_obj->info.cp_utf8.length && !memcmp (bytes, cp_obj->info.cp_utf8.bytes, len)) {\n\t\t\t\tv = malloc (sizeof (ut32));\n\t\t\t\tif (!v) {\n\t\t\t\t\tr_list_free (res);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t*v = cp_obj->metas->ord;\n\t\t\t\tIFDBG eprintf(\"Found a match adding idx: %d\\n\", *v);\n\t\t\t\tr_list_append (res, v);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nR_API RList *r_bin_java_find_cp_const_by_val_int(RBinJavaObj *bin_obj, const ut8 *bytes, ut32 len) {\n\tRList *res = r_list_newf (free);\n\tut32 *v = NULL;\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *cp_obj;\n\teprintf (\"Looking for 0x%08x\\n\", (ut32) R_BIN_JAVA_UINT (bytes, 0));\n\tr_list_foreach (bin_obj->cp_list, iter, cp_obj) {\n\t\tif (cp_obj->tag == R_BIN_JAVA_CP_INTEGER) {\n\t\t\tif (len == 4 && R_BIN_JAVA_UINT (bytes, 0) == R_BIN_JAVA_UINT (cp_obj->info.cp_integer.bytes.raw, 0)) {\n\t\t\t\tv = malloc (sizeof (ut32));\n\t\t\t\tif (!v) {\n\t\t\t\t\tr_list_free (res);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t*v = cp_obj->idx;\n\t\t\t\tr_list_append (res, v);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API char r_bin_java_resolve_cp_idx_tag(RBinJavaObj *BIN_OBJ, int idx) {\n\tRBinJavaCPTypeObj *item = NULL;\n\tif (BIN_OBJ && BIN_OBJ->cp_count < 1) {\n\t\t// r_bin_java_new_bin(BIN_OBJ);\n\t\treturn R_BIN_JAVA_CP_UNKNOWN;\n\t}\n\titem = (RBinJavaCPTypeObj *) r_bin_java_get_item_from_bin_cp_list (BIN_OBJ, idx);\n\tif (item) {\n\t\treturn item->tag;\n\t}\n\treturn R_BIN_JAVA_CP_UNKNOWN;\n}\n\nR_API int U(r_bin_java_integer_cp_set)(RBinJavaObj * bin, ut16 idx, ut32 val) {\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tif (!cp_obj) {\n\t\treturn false;\n\t}\n\tut8 bytes[4] = {\n\t\t0\n\t};\n\tif (cp_obj->tag != R_BIN_JAVA_CP_INTEGER && cp_obj->tag != R_BIN_JAVA_CP_FLOAT) {\n\t\teprintf (\"Not supporting the overwrite of CP Objects with one of a different size.\\n\");\n\t\treturn false;\n\t}\n\tr_bin_java_check_reset_cp_obj (cp_obj, R_BIN_JAVA_CP_INTEGER);\n\tcp_obj->tag = R_BIN_JAVA_CP_INTEGER;\n\tmemcpy (bytes, (const char *) &val, 4);\n\tval = R_BIN_JAVA_UINT (bytes, 0);\n\tmemcpy (&cp_obj->info.cp_integer.bytes.raw, (const char *) &val, 4);\n\treturn true;\n}\n\nR_API int U(r_bin_java_float_cp_set)(RBinJavaObj * bin, ut16 idx, float val) {\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tif (!cp_obj) {\n\t\treturn false;\n\t}\n\tut8 bytes[4] = {\n\t\t0\n\t};\n\tif (cp_obj->tag != R_BIN_JAVA_CP_INTEGER && cp_obj->tag != R_BIN_JAVA_CP_FLOAT) {\n\t\teprintf (\"Not supporting the overwrite of CP Objects with one of a different size.\\n\");\n\t\treturn false;\n\t}\n\tr_bin_java_check_reset_cp_obj (cp_obj, R_BIN_JAVA_CP_FLOAT);\n\tcp_obj->tag = R_BIN_JAVA_CP_FLOAT;\n\tmemcpy (bytes, (const char *) &val, 4);\n\tfloat *foo = (float*) bytes;\n\tval = *foo; //(float)R_BIN_JAVA_UINT (bytes, 0);\n\tmemcpy (&cp_obj->info.cp_float.bytes.raw, (const char *) &val, 4);\n\treturn true;\n}\n\nR_API int U(r_bin_java_long_cp_set)(RBinJavaObj * bin, ut16 idx, ut64 val) {\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tif (!cp_obj) {\n\t\treturn false;\n\t}\n\tut8 bytes[8] = {\n\t\t0\n\t};\n\tif (cp_obj->tag != R_BIN_JAVA_CP_LONG && cp_obj->tag != R_BIN_JAVA_CP_DOUBLE) {\n\t\teprintf (\"Not supporting the overwrite of CP Objects with one of a different size.\\n\");\n\t\treturn false;\n\t}\n\tr_bin_java_check_reset_cp_obj (cp_obj, R_BIN_JAVA_CP_LONG);\n\tcp_obj->tag = R_BIN_JAVA_CP_LONG;\n\tmemcpy (bytes, (const char *) &val, 8);\n\tval = r_bin_java_raw_to_long (bytes, 0);\n\tmemcpy (&cp_obj->info.cp_long.bytes.raw, (const char *) &val, 8);\n\treturn true;\n}\n\nR_API int U(r_bin_java_double_cp_set)(RBinJavaObj * bin, ut16 idx, ut32 val) {\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tif (!cp_obj) {\n\t\treturn false;\n\t}\n\tut8 bytes[8] = {\n\t\t0\n\t};\n\tif (cp_obj->tag != R_BIN_JAVA_CP_LONG && cp_obj->tag != R_BIN_JAVA_CP_DOUBLE) {\n\t\teprintf (\"Not supporting the overwrite of CP Objects with one of a different size.\\n\");\n\t\treturn false;\n\t}\n\tr_bin_java_check_reset_cp_obj (cp_obj, R_BIN_JAVA_CP_DOUBLE);\n\tcp_obj->tag = R_BIN_JAVA_CP_DOUBLE;\n\tut64 val64 = val;\n\tmemcpy (bytes, (const char *) &val64, 8);\n\tval64 = r_bin_java_raw_to_long (bytes, 0);\n\tmemcpy (&cp_obj->info.cp_double.bytes.raw, (const char *) &val64, 8);\n\treturn true;\n}\n\nR_API int U(r_bin_java_utf8_cp_set)(RBinJavaObj * bin, ut16 idx, const ut8 * buffer, ut32 len) {\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tif (!cp_obj) {\n\t\treturn false;\n\t}\n\teprintf (\"Writing %d byte(s) (%s)\\n\", len, buffer);\n\t// r_bin_java_check_reset_cp_obj(cp_obj, R_BIN_JAVA_CP_INTEGER);\n\tif (cp_obj->tag != R_BIN_JAVA_CP_UTF8) {\n\t\teprintf (\"Not supporting the overwrite of CP Objects with one of a different size.\\n\");\n\t\treturn false;\n\t}\n\tif (cp_obj->info.cp_utf8.length != len) {\n\t\teprintf (\"Not supporting the resize, rewriting utf8 string up to %d byte(s).\\n\", cp_obj->info.cp_utf8.length);\n\t\tif (cp_obj->info.cp_utf8.length > len) {\n\t\t\teprintf (\"Remaining %d byte(s) will be filled with \\\\x00.\\n\", cp_obj->info.cp_utf8.length - len);\n\t\t}\n\t}\n\tmemcpy (cp_obj->info.cp_utf8.bytes, buffer, cp_obj->info.cp_utf8.length);\n\tif (cp_obj->info.cp_utf8.length > len) {\n\t\tmemset (cp_obj->info.cp_utf8.bytes + len, 0, cp_obj->info.cp_utf8.length - len);\n\t}\n\treturn true;\n}\n\nR_API ut8 *r_bin_java_cp_get_bytes(ut8 tag, ut32 *out_sz, const ut8 *buf, const ut64 len) {\n\tif (!out_sz) {\n\t\treturn NULL;\n\t}\n\tif (out_sz) {\n\t\t*out_sz = 0;\n\t}\n\tswitch (tag) {\n\tcase R_BIN_JAVA_CP_INTEGER:\n\tcase R_BIN_JAVA_CP_FLOAT:\n\t\treturn r_bin_java_cp_get_4bytes (tag, out_sz, buf, len);\n\tcase R_BIN_JAVA_CP_LONG:\n\tcase R_BIN_JAVA_CP_DOUBLE:\n\t\treturn r_bin_java_cp_get_8bytes (tag, out_sz, buf, len);\n\tcase R_BIN_JAVA_CP_UTF8:\n\t\treturn r_bin_java_cp_get_utf8 (tag, out_sz, buf, len);\n\t}\n\treturn NULL;\n}\n\nR_API ut32 r_bin_java_cp_get_size(RBinJavaObj *bin, ut16 idx) {\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tswitch (cp_obj->tag) {\n\tcase R_BIN_JAVA_CP_INTEGER:\n\tcase R_BIN_JAVA_CP_FLOAT:\n\t\treturn 1 + 4;\n\tcase R_BIN_JAVA_CP_LONG:\n\tcase R_BIN_JAVA_CP_DOUBLE:\n\t\treturn 1 + 8;\n\tcase R_BIN_JAVA_CP_UTF8:\n\t\treturn 1 + 2 + cp_obj->info.cp_utf8.length;\n\t}\n\treturn 0;\n}\n\nR_API ut64 r_bin_java_get_method_start(RBinJavaObj *bin, RBinJavaField *fm_type) {\n\treturn r_bin_java_get_method_code_offset (fm_type) + bin->loadaddr;\n}\n\nR_API ut64 r_bin_java_get_method_end(RBinJavaObj *bin, RBinJavaField *fm_type) {\n\treturn r_bin_java_get_method_code_offset (fm_type) + bin->loadaddr +\n\t+r_bin_java_get_method_code_size (fm_type);\n}\n\nR_API ut8 *U(r_bin_java_cp_append_method_ref)(RBinJavaObj * bin, ut32 * out_sz, ut16 cn_idx, ut16 fn_idx, ut16 ft_idx) {\n\treturn r_bin_java_cp_get_fref_bytes (bin, out_sz, R_BIN_JAVA_CP_METHODREF, cn_idx, fn_idx, ft_idx);\n}\n\nR_API ut8 *U(r_bin_java_cp_append_field_ref)(RBinJavaObj * bin, ut32 * out_sz, ut16 cn_idx, ut16 fn_idx, ut16 ft_idx) {\n\treturn r_bin_java_cp_get_fref_bytes (bin, out_sz, R_BIN_JAVA_CP_FIELDREF, cn_idx, fn_idx, ft_idx);\n}\n\nR_API char *r_bin_java_unmangle_without_flags(const char *name, const char *descriptor) {\n\treturn r_bin_java_unmangle (NULL, name, descriptor);\n}\n\nR_API void U(r_bin_java_print_stack_map_append_frame_summary)(RBinJavaStackMapFrame * obj) {\n\tRListIter *iter, *iter_tmp;\n\tRList *ptrList;\n\tRBinJavaVerificationObj *ver_obj;\n\tEprintf (\"Stack Map Frame Information\\n\");\n\tEprintf (\"  Tag Value = 0x%02x Name: %s\\n\", obj->tag, ((RBinJavaStackMapFrameMetas *) obj->metas->type_info)->name);\n\tEprintf (\"  Offset: 0x%08\"PFMT64x \"\\n\", obj->file_offset);\n\tEprintf (\"  Local Variable Count = 0x%04x\\n\", obj->number_of_locals);\n\tEprintf (\"  Local Variables:\\n\");\n\tptrList = obj->local_items;\n\tr_list_foreach_safe (ptrList, iter, iter_tmp, ver_obj) {\n\t\tr_bin_java_print_verification_info_summary (ver_obj);\n\t}\n\tEprintf (\"  Stack Items Count = 0x%04x\\n\", obj->number_of_stack_items);\n\tEprintf (\"  Stack Items:\\n\");\n\tptrList = obj->stack_items;\n\tr_list_foreach_safe (ptrList, iter, iter_tmp, ver_obj) {\n\t\tr_bin_java_print_verification_info_summary (ver_obj);\n\t}\n}\n\nR_API void U(r_bin_java_stack_frame_default_free)(void *s) {\n\tRBinJavaStackMapFrame *stack_frame = s;\n\tif (stack_frame) {\n\t\tfree (stack_frame->metas);\n\t\tfree (stack_frame);\n\t}\n}\nR_API void U(r_bin_java_stack_frame_do_nothing_free)(void /*RBinJavaStackMapFrame*/ *stack_frame) {}\nR_API void U(r_bin_java_stack_frame_do_nothing_new)(RBinJavaObj * bin, RBinJavaStackMapFrame * stack_frame, ut64 offset) {}\nR_API RBinJavaCPTypeMetas *U(r_bin_java_get_cp_meta_from_tag)(ut8 tag) {\n\tut16 i = 0;\n\t// set default to unknown.\n\tRBinJavaCPTypeMetas *res = &R_BIN_JAVA_CP_METAS[2];\n\tfor (i = 0; i < R_BIN_JAVA_CP_METAS_SZ; i++) {\n\t\tif (tag == R_BIN_JAVA_CP_METAS[i].tag) {\n\t\t\tres = &R_BIN_JAVA_CP_METAS[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nR_API ut8 *U(r_bin_java_cp_append_ref_cname_fname_ftype)(RBinJavaObj * bin, ut32 * out_sz, ut8 tag, const char *cname, const ut32 c_len, const char *fname, const ut32 f_len, const char *tname, const ut32 t_len) {\n\tut32 cn_len = 0, fn_len = 0, ft_len = 0, total_len;\n\tut16 cn_idx = 0, fn_idx = 0, ft_idx = 0;\n\tut8 *bytes = NULL, *cn_bytes = NULL, *fn_bytes = NULL, *ft_bytes = NULL, *cref_bytes = NULL, *fref_bytes = NULL, *fnt_bytes = NULL;\n\t*out_sz = 0;\n\tcn_bytes = r_bin_java_cp_get_utf8 (R_BIN_JAVA_CP_UTF8, &cn_len, (const ut8 *) cname, c_len);\n\tcn_idx = bin->cp_idx + 1;\n\tif (cn_bytes) {\n\t\tfn_bytes = r_bin_java_cp_get_utf8 (R_BIN_JAVA_CP_UTF8, &fn_len, (const ut8 *) fname, f_len);\n\t\tfn_idx = bin->cp_idx + 2;\n\t}\n\tif (fn_bytes) {\n\t\tft_bytes = r_bin_java_cp_get_utf8 (R_BIN_JAVA_CP_UTF8, &ft_len, (const ut8 *) tname, t_len);\n\t\tft_idx = bin->cp_idx + 3;\n\t}\n\tif (cn_bytes && fn_bytes && ft_bytes) {\n\t\tut32 cref_len = 0, fnt_len = 0, fref_len = 0;\n\t\tut32 cref_idx = 0, fnt_idx = 0;\n\t\tcref_bytes = r_bin_java_cp_get_classref (bin, &cref_len, NULL, 0, cn_idx);\n\t\tcref_idx = bin->cp_idx + 3;\n\t\tfnt_bytes = r_bin_java_cp_get_name_type (bin, &fnt_len, fn_idx, ft_idx);\n\t\tfnt_idx = bin->cp_idx + 4;\n\t\tfref_bytes = r_bin_java_cp_get_2_ut16 (bin, &fref_len, tag, cref_idx, fnt_idx);\n\t\tif (cref_bytes && fref_bytes && fnt_bytes) {\n\t\t\ttotal_len = cn_len + fn_len + ft_len + cref_len + fnt_len + fref_len + 2;\n\t\t\tif (total_len < cn_len) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbytes = calloc (1, total_len);\n\t\t\t// class name bytes\n\t\t\tif (*out_sz + cn_len >= total_len) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmemcpy (bytes, cn_bytes + *out_sz, cn_len);\n\t\t\t*out_sz += cn_len;\n\t\t\t// field name bytes\n\t\t\tif (*out_sz + fn_len >= total_len) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmemcpy (bytes, fn_bytes + *out_sz, fn_len);\n\t\t\t*out_sz += fn_len;\n\t\t\t// field type bytes\n\t\t\tif (*out_sz + ft_len >= total_len) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmemcpy (bytes, ft_bytes + *out_sz, ft_len);\n\t\t\t*out_sz += ft_len;\n\t\t\t// class ref bytes\n\t\t\tif (*out_sz + cref_len >= total_len) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmemcpy (bytes, cref_bytes + *out_sz, cref_len);\n\t\t\t*out_sz += fn_len;\n\t\t\t// field name and type bytes\n\t\t\tif (*out_sz + fnt_len >= total_len) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmemcpy (bytes, fnt_bytes + *out_sz, fnt_len);\n\t\t\t*out_sz += fnt_len;\n\t\t\t// field ref bytes\n\t\t\tif (*out_sz + fref_len >= total_len) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tmemcpy (bytes, fref_bytes + *out_sz, fref_len);\n\t\t\t*out_sz += fref_len;\n\t\t}\n\t}\nbeach:\n\tfree (cn_bytes);\n\tfree (ft_bytes);\n\tfree (fn_bytes);\n\tfree (fnt_bytes);\n\tfree (fref_bytes);\n\tfree (cref_bytes);\n\treturn bytes;\n}\nR_API ut8 *U(r_bin_java_cp_get_method_ref)(RBinJavaObj * bin, ut32 * out_sz, ut16 class_idx, ut16 name_and_type_idx) {\n\treturn r_bin_java_cp_get_fm_ref (bin, out_sz, R_BIN_JAVA_CP_METHODREF, class_idx, name_and_type_idx);\n}\nR_API ut8 *U(r_bin_java_cp_get_field_ref)(RBinJavaObj * bin, ut32 * out_sz, ut16 class_idx, ut16 name_and_type_idx) {\n\treturn r_bin_java_cp_get_fm_ref (bin, out_sz, R_BIN_JAVA_CP_FIELDREF, class_idx, name_and_type_idx);\n}\n\nR_API void U(deinit_java_type_null)() {\n\tfree (R_BIN_JAVA_NULL_TYPE.metas);\n}\n\nR_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {\n\tif (i < 1 || i > bin->cf.cp_count) {\n\t\treturn &R_BIN_JAVA_NULL_TYPE;\n\t}\n\tRBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);\n\treturn obj ? obj : &R_BIN_JAVA_NULL_TYPE;\n}\n\nR_API void U(copy_type_info_to_stack_frame_list)(RList * type_list, RList * sf_list) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaVerificationObj *ver_obj, *new_ver_obj;\n\tif (type_list == NULL) {\n\t\treturn;\n\t}\n\tif (sf_list == NULL) {\n\t\treturn;\n\t}\n\tr_list_foreach_safe (type_list, iter, iter_tmp, ver_obj) {\n\t\tnew_ver_obj = (RBinJavaVerificationObj *) malloc (sizeof (RBinJavaVerificationObj));\n\t\t// FIXME: how to handle failed memory allocation?\n\t\tif (new_ver_obj && ver_obj) {\n\t\t\tmemcpy (new_ver_obj, ver_obj, sizeof (RBinJavaVerificationObj));\n\t\t\tif (!r_list_append (sf_list, (void *) new_ver_obj)) {\n\t\t\t\tR_FREE (new_ver_obj);\n\t\t\t}\n\t\t} else {\n\t\t\tR_FREE (new_ver_obj);\n\t\t}\n\t}\n}\n\nR_API void U(copy_type_info_to_stack_frame_list_up_to_idx)(RList * type_list, RList * sf_list, ut64 idx) {\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaVerificationObj *ver_obj, *new_ver_obj;\n\tut32 pos = 0;\n\tif (type_list == NULL) {\n\t\treturn;\n\t}\n\tif (sf_list == NULL) {\n\t\treturn;\n\t}\n\tr_list_foreach_safe (type_list, iter, iter_tmp, ver_obj) {\n\t\tnew_ver_obj = (RBinJavaVerificationObj *) malloc (sizeof (RBinJavaVerificationObj));\n\t\t// FIXME: how to handle failed memory allocation?\n\t\tif (new_ver_obj && ver_obj) {\n\t\t\tmemcpy (new_ver_obj, ver_obj, sizeof (RBinJavaVerificationObj));\n\t\t\tif (!r_list_append (sf_list, (void *) new_ver_obj)) {\n\t\t\t\tR_FREE (new_ver_obj);\n\t\t\t}\n\t\t} else {\n\t\t\tR_FREE (new_ver_obj);\n\t\t}\n\t\tpos++;\n\t\tif (pos == idx) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nR_API ut8 *r_bin_java_cp_get_idx_bytes(RBinJavaObj *bin, ut16 idx, ut32 *out_sz) {\n\tRBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (bin, idx);\n\tif (!cp_obj || !out_sz) {\n\t\treturn NULL;\n\t}\n\tif (out_sz) {\n\t\t*out_sz = 0;\n\t}\n\tswitch (cp_obj->tag) {\n\tcase R_BIN_JAVA_CP_INTEGER:\n\tcase R_BIN_JAVA_CP_FLOAT:\n\t\treturn r_bin_java_cp_get_4bytes (cp_obj->tag, out_sz, cp_obj->info.cp_integer.bytes.raw, 5);\n\tcase R_BIN_JAVA_CP_LONG:\n\tcase R_BIN_JAVA_CP_DOUBLE:\n\t\treturn r_bin_java_cp_get_4bytes (cp_obj->tag, out_sz, cp_obj->info.cp_long.bytes.raw, 9);\n\tcase R_BIN_JAVA_CP_UTF8:\n\t\t// eprintf (\"Getting idx: %d = %p (3+0x%\"PFMT64x\")\\n\", idx, cp_obj, cp_obj->info.cp_utf8.length);\n\t\tif (cp_obj->info.cp_utf8.length > 0) {\n\t\t\treturn r_bin_java_cp_get_utf8 (cp_obj->tag, out_sz,\n\t\t\t\tcp_obj->info.cp_utf8.bytes, cp_obj->info.cp_utf8.length);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API int r_bin_java_valid_class(const ut8 *buf, ut64 buf_sz) {\n\tRBinJavaObj *bin = R_NEW0 (RBinJavaObj), *cur_bin = R_BIN_JAVA_GLOBAL_BIN;\n\tif (!bin) {\n\t\treturn false;\n\t}\n\tint res = r_bin_java_load_bin (bin, buf, buf_sz);\n\tif (bin->calc_size == buf_sz) {\n\t\tres = true;\n\t}\n\tr_bin_java_free (bin);\n\tR_BIN_JAVA_GLOBAL_BIN = cur_bin;\n\treturn res;\n}\n\nR_API ut64 r_bin_java_calc_class_size(ut8 *bytes, ut64 size) {\n\tRBinJavaObj *bin = R_NEW0 (RBinJavaObj);\n\tif (!bin) {\n\t\treturn false;\n\t}\n\tRBinJavaObj *cur_bin = R_BIN_JAVA_GLOBAL_BIN;\n\tut64 bin_size = UT64_MAX;\n\tif (bin) {\n\t\tif (r_bin_java_load_bin (bin, bytes, size)) {\n\t\t\tbin_size = bin->calc_size;\n\t\t}\n\t\tr_bin_java_free (bin);\n\t\tR_BIN_JAVA_GLOBAL_BIN = cur_bin;\n\t}\n\treturn bin_size;\n}\n\nR_API int U(r_bin_java_get_cp_idx_with_name)(RBinJavaObj * bin_obj, const char *name, ut32 len) {\n\tRListIter *iter;\n\tRBinJavaCPTypeObj *obj;\n\tr_list_foreach (bin_obj->cp_list, iter, obj) {\n\t\tif (obj->tag == R_BIN_JAVA_CP_UTF8) {\n\t\t\tif (!strncmp (name, (const char *) obj->info.cp_utf8.bytes, len)) {\n\t\t\t\treturn obj->metas->ord;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nR_API void r_bin_java_external_printf(PrintfCallback cb) {\n\tEprintf = cb ? cb : (PrintfCallback) printf;\n}\n"], "buggy_code_start_loc": [2073], "buggy_code_end_loc": [3982], "fixing_code_start_loc": [2072], "fixing_code_end_loc": [3986], "type": "CWE-125", "message": "The r_bin_java_annotation_new function in shlr/java/class.c in radare2 2.7.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted .class file because of missing input validation in r_bin_java_line_number_table_attr_new.", "other": {"cve": {"id": "CVE-2018-14017", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-12T20:29:00.257", "lastModified": "2020-10-15T13:39:52.547", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The r_bin_java_annotation_new function in shlr/java/class.c in radare2 2.7.0 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted .class file because of missing input validation in r_bin_java_line_number_table_attr_new."}, {"lang": "es", "value": "La funci\u00f3n r_bin_java_annotation_new en shlr/java/class.c en radare2 2.7.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (sobrelectura de b\u00fafer basada en memoria din\u00e1mica o heap y cierre inesperado de la aplicaci\u00f3n) mediante un archivo .class manipulado debido a la falta de validaci\u00f3n de entradas en r_bin_java_line_number_table_attr_new."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "693C6349-1A2D-48F3-A861-9E3F7832D174"}]}]}], "references": [{"url": "https://github.com/radare/radare2/issues/10498", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/radareorg/radare2/commit/e9ce0d64faf19fa4e9c260250fbdf25e3c11e152", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/e9ce0d64faf19fa4e9c260250fbdf25e3c11e152"}}