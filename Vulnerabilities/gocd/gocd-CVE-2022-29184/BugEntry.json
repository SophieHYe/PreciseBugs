{"buggy_code": ["/*\n * Copyright 2022 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.thoughtworks.go.domain.materials.mercurial;\n\nimport com.thoughtworks.go.domain.materials.Modification;\nimport com.thoughtworks.go.domain.materials.Revision;\nimport com.thoughtworks.go.util.TempDirUtils;\nimport com.thoughtworks.go.util.command.*;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static com.thoughtworks.go.util.command.ProcessOutputStreamConsumer.inMemoryConsumer;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\n\npublic class HgCommandTest {\n    private File serverRepo;\n    private File clientRepo;\n\n    private HgCommand hgCommand;\n\n    private InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n    private File workingDirectory;\n    private static final String REVISION_0 = \"b61d12de515d82d3a377ae3aae6e8abe516a2651\";\n    private static final String REVISION_1 = \"35ff2159f303ecf986b3650fc4299a6ffe5a14e1\";\n    private static final String REVISION_2 = \"ca3ebb67f527c0ad7ed26b789056823d8b9af23f\";\n    private File secondBranchWorkingCopy;\n\n    @BeforeEach\n    public void setUp(@TempDir Path tempDir) throws IOException {\n        serverRepo = TempDirUtils.createTempDirectoryIn(tempDir, \"testHgServerRepo\").toFile();\n        clientRepo =  TempDirUtils.createTempDirectoryIn(tempDir, \"testHgClientRepo\").toFile();\n        secondBranchWorkingCopy =  TempDirUtils.createTempDirectoryIn(tempDir, \"second\").toFile();\n\n        setUpServerRepoFromHgBundle(serverRepo, new File(\"../common/src/test/resources/data/hgrepo.hgbundle\"));\n        workingDirectory = new File(clientRepo.getPath());\n        hgCommand = new HgCommand(null, workingDirectory, \"default\", serverRepo.getAbsolutePath(), null);\n        hgCommand.clone(outputStreamConsumer, new UrlArgument(serverRepo.getAbsolutePath()));\n    }\n\n    @Test\n    public void shouldCloneFromRemoteRepo() {\n        assertThat(clientRepo.listFiles().length > 0, is(true));\n    }\n\n    @Test\n    public void shouldGetLatestModifications() throws Exception {\n        List<Modification> actual = hgCommand.latestOneModificationAsModifications();\n        assertThat(actual.size(), is(1));\n        final Modification modification = actual.get(0);\n        assertThat(modification.getComment(), is(\"test\"));\n        assertThat(modification.getUserName(), is(\"cruise\"));\n        assertThat(modification.getModifiedFiles().size(), is(1));\n    }\n\n    @Test\n    public void shouldNotIncludeCommitFromAnotherBranchInGetLatestModifications() throws Exception {\n        Modification lastCommit = hgCommand.latestOneModificationAsModifications().get(0);\n\n        makeACommitToSecondBranch();\n        hg(workingDirectory, \"pull\").runOrBomb(null);\n        Modification actual = hgCommand.latestOneModificationAsModifications().get(0);\n        assertThat(actual, is(lastCommit));\n        assertThat(actual.getComment(), is(lastCommit.getComment()));\n    }\n\n    @Test\n    public void shouldGetModifications() throws Exception {\n        List<Modification> actual = hgCommand.modificationsSince(new StringRevision(REVISION_0));\n        assertThat(actual.size(), is(2));\n        assertThat(actual.get(0).getRevision(), is(REVISION_2));\n        assertThat(actual.get(1).getRevision(), is(REVISION_1));\n    }\n\n    @Test\n    public void shouldNotGetModificationsFromOtherBranches() throws Exception {\n        makeACommitToSecondBranch();\n        hg(workingDirectory, \"pull\").runOrBomb(null);\n\n        List<Modification> actual = hgCommand.modificationsSince(new StringRevision(REVISION_0));\n        assertThat(actual.size(), is(2));\n        assertThat(actual.get(0).getRevision(), is(REVISION_2));\n        assertThat(actual.get(1).getRevision(), is(REVISION_1));\n    }\n\n    @Test\n    public void shouldUpdateToSpecificRevision() {\n        InMemoryStreamConsumer output = ProcessOutputStreamConsumer.inMemoryConsumer();\n        assertThat(output.getStdOut(), is(\"\"));\n        File newFile = new File(clientRepo, \"test.txt\");\n        assertThat(newFile.exists(), is(false));\n        Revision revision = createNewFileAndCheckIn(serverRepo);\n        hgCommand.updateTo(revision, output);\n        assertThat(output.getStdOut(), is(not(\"\")));\n        assertThat(newFile.exists(), is(true));\n    }\n\n    @Test\n    public void shouldUpdateToSpecificRevisionOnGivenBranch() {\n        makeACommitToSecondBranch();\n\n        InMemoryStreamConsumer output = ProcessOutputStreamConsumer.inMemoryConsumer();\n        File newFile = new File(workingDirectory, \"test.txt\");\n        hgCommand.updateTo(new StringRevision(\"tip\"), output);\n        assertThat(newFile.exists(), is(false));\n    }\n\n    @Test\n    public void shouldThrowExceptionIfUpdateFails() throws Exception {\n        InMemoryStreamConsumer output =\n                ProcessOutputStreamConsumer.inMemoryConsumer();\n\n        // delete repository in order to fail the hg pull command\n        assertThat(FileUtils.deleteQuietly(serverRepo), is(true));\n\n        // now hg pull will fail and throw an exception\n        assertThatThrownBy(() -> hgCommand.updateTo(new StringRevision(\"tip\"), output))\n                .isExactlyInstanceOf(RuntimeException.class);\n    }\n\n    @Test\n    public void shouldGetWorkingUrl() {\n        String workingUrl = hgCommand.workingRepositoryUrl().outputAsString();\n\n        assertThat(workingUrl, is(serverRepo.getAbsolutePath()));\n    }\n\n    @Test\n    public void shouldThrowExceptionForBadConnection() throws Exception {\n        String url = \"http://not-exists\";\n        HgCommand hgCommand = new HgCommand(null, null, null, null, null);\n\n        assertThatThrownBy(() -> hgCommand.checkConnection(new UrlArgument(url)))\n                .isExactlyInstanceOf(CommandLineException.class);\n    }\n\n    @Test\n    public void shouldCloneOnlyTheSpecifiedBranchAndPointToIt() {\n        String branchName = \"second\";\n        HgCommand hg = new HgCommand(null, secondBranchWorkingCopy, branchName, serverRepo.getAbsolutePath(), null);\n        hg.clone(outputStreamConsumer, new UrlArgument(serverRepo.getAbsolutePath() + \"#\" + branchName));\n\n        String currentBranch = hg(secondBranchWorkingCopy, \"branch\").runOrBomb(null).outputAsString();\n        assertThat(currentBranch, is(branchName));\n\n        List<String> branches = hg(secondBranchWorkingCopy, \"branches\").runOrBomb(null).output();\n        ArrayList<String> branchNames = new ArrayList<>();\n        for (String branchDetails : branches) {\n            branchNames.add(StringUtils.split(branchDetails, \" \")[0]);\n        }\n        assertThat(branchNames.size(), is(2));\n        assertThat(branchNames.contains(branchName), is(true));\n        assertThat(branchNames.contains(\"default\"), is(true));\n    }\n\n    private CommandLine hg(File workingDir, String... arguments) {\n        CommandLine hg = CommandLine.createCommandLine(\"hg\").withArgs(arguments).withEncoding(\"utf-8\");\n        hg.setWorkingDir(workingDir);\n        return hg;\n    }\n\n    private void commit(String message, File workingDir) {\n        CommandLine hg = hg(workingDir, \"ci\", \"-u\", \"cruise-test\", \"-m\", message);\n        String[] input = new String[]{};\n        hg.runOrBomb(null, input);\n    }\n\n    private Revision latestRevisionOf() {\n        CommandLine hg = hg(serverRepo, \"log\", \"--limit\", \"1\", \"--template\", \"{node}\");\n        String[] input = new String[]{};\n        return new StringRevision(hg.runOrBomb(null, input).outputAsString());\n    }\n\n    private void addremove(File workingDir) {\n        CommandLine hg = hg(workingDir, \"addremove\");\n        String[] input = new String[]{};\n        hg.runOrBomb(null, input);\n    }\n\n    private void createNewFileAndPushUpstream(File workingDir) {\n        createNewFileAndCheckIn(workingDir);\n        String branchName = hg(workingDir, \"branch\").runOrBomb(null).outputAsString();\n        hg(workingDir, \"push\", \"--rev\", branchName).runOrBomb(null);\n    }\n\n    private Revision createNewFileAndCheckIn(File directory) {\n        try {\n            new FileOutputStream(new File(directory, \"test.txt\")).close();\n            addremove(directory);\n            commit(\"created test.txt\", directory);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return latestRevisionOf();\n    }\n\n    private void setUpServerRepoFromHgBundle(File serverRepo, File hgBundleFile) {\n        String[] input = new String[]{};\n        CommandLine.createCommandLine(\"hg\")\n                .withArgs(\"clone\", hgBundleFile.getAbsolutePath(), serverRepo.getAbsolutePath()).withEncoding(\"utf-8\").runOrBomb(null, input);\n    }\n\n    private void makeACommitToSecondBranch() {\n        HgCommand hg = new HgCommand(null, secondBranchWorkingCopy, \"second\", serverRepo.getAbsolutePath(), null);\n        hg.clone(outputStreamConsumer, new UrlArgument(serverRepo.getAbsolutePath()));\n        createNewFileAndPushUpstream(secondBranchWorkingCopy);\n    }\n}\n", "/*\n * Copyright 2022 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.thoughtworks.go.domain.materials.mercurial;\n\nimport com.thoughtworks.go.domain.materials.Modification;\nimport com.thoughtworks.go.domain.materials.Revision;\nimport com.thoughtworks.go.domain.materials.SCMCommand;\nimport com.thoughtworks.go.util.NamedProcessTag;\nimport com.thoughtworks.go.util.command.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static com.thoughtworks.go.util.ExceptionUtils.bomb;\nimport static com.thoughtworks.go.util.ExceptionUtils.bombUnless;\nimport static com.thoughtworks.go.util.command.CommandLine.createCommandLine;\nimport static com.thoughtworks.go.util.command.ProcessOutputStreamConsumer.inMemoryConsumer;\nimport static java.lang.String.format;\n\npublic class HgCommand extends SCMCommand {\n    private static final Logger LOGGER = LoggerFactory.getLogger(HgCommand.class);\n    private final File workingDir;\n    private static String templatePath;\n    private final String branch;\n    private final String url;\n    private final List<SecretString> secrets;\n\n\n    public HgCommand(String materialFingerprint, File workingDir, String branch, String url, List<SecretString> secrets) {\n        super(materialFingerprint);\n        this.workingDir = workingDir;\n        this.branch = branch;\n        this.url = url;\n        this.secrets = secrets != null ? secrets : new ArrayList<>();\n    }\n\n\n    private boolean pull(ConsoleOutputStreamConsumer outputStreamConsumer) {\n        CommandLine hg = hg(\"pull\", \"-b\", branch, \"--config\", String.format(\"paths.default=%s\", url));\n        return execute(hg, outputStreamConsumer) == 0;\n    }\n\n    public HgVersion version() {\n        CommandLine hg = createCommandLine(\"hg\").withArgs(\"version\").withEncoding(\"utf-8\");\n        String hgOut = execute(hg, new NamedProcessTag(\"hg version check\")).outputAsString();\n        return HgVersion.parse(hgOut);\n    }\n\n\n    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, UrlArgument repositoryUrl) {\n        CommandLine hg = createCommandLine(\"hg\").withArgs(\"clone\").withArg(\"-b\").withArg(branch).withArg(repositoryUrl)\n                .withArg(workingDir.getAbsolutePath()).withNonArgSecrets(secrets).withEncoding(\"utf-8\");\n        return execute(hg, outputStreamConsumer);\n    }\n\n    public void checkConnection(UrlArgument repositoryURL) {\n        execute(createCommandLine(\"hg\").withArgs(\"id\", \"--id\").withArg(repositoryURL).withNonArgSecrets(secrets).withEncoding(\"utf-8\"), new NamedProcessTag(repositoryURL.forDisplay()));\n    }\n\n    public void updateTo(Revision revision, ConsoleOutputStreamConsumer outputStreamConsumer) {\n        if (!pull(outputStreamConsumer) || !update(revision, outputStreamConsumer)) {\n            bomb(format(\"Unable to update to revision [%s]\", revision));\n        }\n    }\n\n    private boolean update(Revision revision, ConsoleOutputStreamConsumer outputStreamConsumer) {\n        CommandLine hg = hg(\"update\", \"--clean\", \"-r\", revision.getRevision());\n        return execute(hg, outputStreamConsumer) == 0;\n    }\n\n    public void add(ConsoleOutputStreamConsumer outputStreamConsumer, File file) {\n        CommandLine hg = hg(\"add\", file.getAbsolutePath());\n        execute(hg, outputStreamConsumer);\n    }\n\n    public void commit(ConsoleOutputStreamConsumer consumer, String comment, String username) {\n        CommandLine hg = hg(\"commit\", \"-m\", comment, \"-u\", username);\n        execute(hg, consumer);\n    }\n\n    public void push(ConsoleOutputStreamConsumer consumer) {\n        CommandLine hg = hg(\"push\");\n        execute(hg, consumer);\n    }\n\n    public List<Modification> latestOneModificationAsModifications() {\n        return findRecentModifications(1);\n    }\n\n    private String templatePath() {\n        if (templatePath == null) {\n            String file = HgCommand.class.getResource(\"/hg.template\").getFile();\n            try {\n                templatePath = URLDecoder.decode(new File(file).getAbsolutePath(), \"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                templatePath = URLDecoder.decode(new File(file).getAbsolutePath());\n            }\n        }\n        return templatePath;\n    }\n\n    List<Modification> findRecentModifications(int count) {\n        // Currently impossible to check modifications on a remote repository.\n        InMemoryStreamConsumer consumer = inMemoryConsumer();\n        bombUnless(pull(consumer), \"Failed to run hg pull command: \" + consumer.getAllOutput());\n        CommandLine hg = hg(\"log\", \"--limit\", String.valueOf(count), \"-b\", branch, \"--style\", templatePath());\n        return new HgModificationSplitter(execute(hg)).modifications();\n    }\n\n    public List<Modification> modificationsSince(Revision revision) {\n        InMemoryStreamConsumer consumer = inMemoryConsumer();\n        bombUnless(pull(consumer), \"Failed to run hg pull command: \" + consumer.getAllOutput());\n        CommandLine hg = hg(\"log\",\n                \"-r\", \"tip:\" + revision.getRevision(),\n                \"-b\", branch,\n                \"--style\", templatePath());\n        return new HgModificationSplitter(execute(hg)).filterOutRevision(revision);\n    }\n\n    public ConsoleResult workingRepositoryUrl() {\n        CommandLine hg = hg(\"showconfig\", \"paths.default\");\n\n        final ConsoleResult result = execute(hg);\n        LOGGER.trace(\"Current repository url of [{}]: {}\", workingDir, result.outputForDisplayAsString());\n        LOGGER.trace(\"Target repository url: {}\", url);\n        return result;\n    }\n\n    private CommandLine hg(String... arguments) {\n        return createCommandLine(\"hg\").withArgs(arguments).withNonArgSecrets(secrets).withWorkingDir(workingDir).withEncoding(\"UTF-8\");\n    }\n\n    private static ConsoleResult execute(CommandLine hgCmd, NamedProcessTag processTag) {\n        return hgCmd.runOrBomb(processTag);\n    }\n\n    private ConsoleResult execute(CommandLine hgCmd) {\n        return runOrBomb(hgCmd);\n    }\n\n    private int execute(CommandLine hgCmd, ConsoleOutputStreamConsumer outputStreamConsumer) {\n        return run(hgCmd, outputStreamConsumer);\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2022 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.thoughtworks.go.domain.materials.mercurial;\n\nimport com.thoughtworks.go.domain.materials.Modification;\nimport com.thoughtworks.go.domain.materials.Revision;\nimport com.thoughtworks.go.util.TempDirUtils;\nimport com.thoughtworks.go.util.command.*;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static com.thoughtworks.go.util.command.ProcessOutputStreamConsumer.inMemoryConsumer;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.*;\n\npublic class HgCommandTest {\n\n    private static final String REVISION_0 = \"b61d12de515d82d3a377ae3aae6e8abe516a2651\";\n    private static final String REVISION_1 = \"35ff2159f303ecf986b3650fc4299a6ffe5a14e1\";\n    private static final String REVISION_2 = \"ca3ebb67f527c0ad7ed26b789056823d8b9af23f\";\n\n    private File serverRepo;\n    private File clientRepo;\n\n    private HgCommand hgCommand;\n\n    private InMemoryStreamConsumer outputStreamConsumer = inMemoryConsumer();\n    private File workingDirectory;\n    private File secondBranchWorkingCopy;\n\n    @BeforeEach\n    public void setUp(@TempDir Path tempDir) throws IOException {\n        serverRepo = TempDirUtils.createTempDirectoryIn(tempDir, \"testHgServerRepo\").toFile();\n        clientRepo = TempDirUtils.createTempDirectoryIn(tempDir, \"testHgClientRepo\").toFile();\n        secondBranchWorkingCopy = TempDirUtils.createTempDirectoryIn(tempDir, \"second\").toFile();\n\n        setUpServerRepoFromHgBundle(serverRepo, new File(\"../common/src/test/resources/data/hgrepo.hgbundle\"));\n        workingDirectory = new File(clientRepo.getPath());\n        hgCommand = new HgCommand(null, workingDirectory, \"default\", serverRepo.getAbsolutePath(), null);\n        hgCommand.clone(outputStreamConsumer, new UrlArgument(serverRepo.getAbsolutePath()));\n    }\n\n    @Test\n    public void shouldCloneFromRemoteRepo() {\n        assertThat(clientRepo.listFiles().length, is(2));\n    }\n\n    @Test\n    public void shouldCloneWithEscapedRepoUrl() {\n        hgCommand.clone(outputStreamConsumer, new UrlArgument(echoingAliasFor(\"clone\")));\n        assertNoUnescapedEcho();\n    }\n\n    @Test\n    public void shouldCloneWithEscapedBranch() {\n        hgCommand = new HgCommand(null, workingDirectory, echoingAliasFor(\"clone\"), serverRepo.getAbsolutePath(), null);\n        hgCommand.clone(outputStreamConsumer, new UrlArgument(serverRepo.getAbsolutePath()));\n        assertNoUnescapedEcho();\n    }\n\n    private String echoingAliasFor(String command) {\n        return String.format(\"--config=alias.%s=!echo hello world\", command);\n    }\n\n    private void assertNoUnescapedEcho() {\n        assertThat(outputStreamConsumer.getAllOutput(), not(containsString(\"\\nhello world\\n\")));\n    }\n\n    @Test\n    public void shouldGetLatestModifications() {\n        List<Modification> actual = hgCommand.latestOneModificationAsModifications();\n        assertThat(actual.size(), is(1));\n        final Modification modification = actual.get(0);\n        assertThat(modification.getComment(), is(\"test\"));\n        assertThat(modification.getUserName(), is(\"cruise\"));\n        assertThat(modification.getModifiedFiles().size(), is(1));\n    }\n\n    @Test\n    public void shouldNotIncludeCommitFromAnotherBranchInGetLatestModifications() {\n        Modification lastCommit = hgCommand.latestOneModificationAsModifications().get(0);\n\n        makeACommitToSecondBranch();\n        hg(workingDirectory, \"pull\").runOrBomb(null);\n        Modification actual = hgCommand.latestOneModificationAsModifications().get(0);\n        assertThat(actual, is(lastCommit));\n        assertThat(actual.getComment(), is(lastCommit.getComment()));\n    }\n\n    @Test\n    public void shouldGetModifications() throws Exception {\n        List<Modification> actual = hgCommand.modificationsSince(new StringRevision(REVISION_0));\n        assertThat(actual.size(), is(2));\n        assertThat(actual.get(0).getRevision(), is(REVISION_2));\n        assertThat(actual.get(1).getRevision(), is(REVISION_1));\n    }\n\n    @Test\n    public void shouldNotGetModificationsFromOtherBranches() {\n        makeACommitToSecondBranch();\n        hg(workingDirectory, \"pull\").runOrBomb(null);\n\n        List<Modification> actual = hgCommand.modificationsSince(new StringRevision(REVISION_0));\n        assertThat(actual.size(), is(2));\n        assertThat(actual.get(0).getRevision(), is(REVISION_2));\n        assertThat(actual.get(1).getRevision(), is(REVISION_1));\n    }\n\n    @Test\n    public void shouldUpdateToSpecificRevision() {\n        InMemoryStreamConsumer output = ProcessOutputStreamConsumer.inMemoryConsumer();\n        assertThat(output.getStdOut(), is(\"\"));\n        File newFile = new File(clientRepo, \"test.txt\");\n        assertThat(newFile.exists(), is(false));\n        Revision revision = createNewFileAndCheckIn(serverRepo);\n        hgCommand.updateTo(revision, output);\n        assertThat(output.getStdOut(), is(not(\"\")));\n        assertThat(newFile.exists(), is(true));\n    }\n\n    @Test\n    public void shouldUpdateToSpecificRevisionOnGivenBranch() {\n        makeACommitToSecondBranch();\n\n        InMemoryStreamConsumer output = ProcessOutputStreamConsumer.inMemoryConsumer();\n        File newFile = new File(workingDirectory, \"test.txt\");\n        hgCommand.updateTo(new StringRevision(\"tip\"), output);\n        assertThat(newFile.exists(), is(false));\n    }\n\n    @Test\n    public void shouldThrowExceptionIfUpdateFails() {\n        InMemoryStreamConsumer output =\n                ProcessOutputStreamConsumer.inMemoryConsumer();\n\n        // delete repository in order to fail the hg pull command\n        assertThat(FileUtils.deleteQuietly(serverRepo), is(true));\n\n        // now hg pull will fail and throw an exception\n        assertThatThrownBy(() -> hgCommand.updateTo(new StringRevision(\"tip\"), output))\n                .isExactlyInstanceOf(RuntimeException.class)\n                .hasMessageContaining(\"Unable to update to revision [StringRevision[tip]]\");\n    }\n\n    @Test\n    public void shouldGetWorkingUrl() {\n        String workingUrl = hgCommand.workingRepositoryUrl().outputAsString();\n\n        assertThat(workingUrl, is(serverRepo.getAbsolutePath()));\n    }\n\n    @Test\n    public void shouldCheckConnection() {\n        hgCommand.checkConnection(new UrlArgument(serverRepo.getAbsolutePath()));\n    }\n\n    @Test\n    public void shouldCheckConnectionWithEscapedRepoUrl() {\n        assertThatThrownBy(() -> hgCommand.checkConnection(new UrlArgument(echoingAliasFor(\"id\"))))\n                .isExactlyInstanceOf(CommandLineException.class)\n                .hasMessageContaining(\"repository --config\")\n                .hasMessageContaining(\"not found\");\n    }\n\n    @Test\n    public void shouldThrowExceptionForBadConnection() {\n        String url = \"http://not-exists\";\n        HgCommand hgCommand = new HgCommand(null, null, null, null, null);\n\n        assertThatThrownBy(() -> hgCommand.checkConnection(new UrlArgument(url)))\n                .isExactlyInstanceOf(CommandLineException.class);\n    }\n\n    @Test\n    public void shouldCloneOnlyTheSpecifiedBranchAndPointToIt() {\n        String branchName = \"second\";\n        HgCommand hg = new HgCommand(null, secondBranchWorkingCopy, branchName, serverRepo.getAbsolutePath(), null);\n        hg.clone(outputStreamConsumer, new UrlArgument(serverRepo.getAbsolutePath() + \"#\" + branchName));\n\n        String currentBranch = hg(secondBranchWorkingCopy, \"branch\").runOrBomb(null).outputAsString();\n        assertThat(currentBranch, is(branchName));\n\n        List<String> branches = hg(secondBranchWorkingCopy, \"branches\").runOrBomb(null).output();\n        ArrayList<String> branchNames = new ArrayList<>();\n        for (String branchDetails : branches) {\n            branchNames.add(StringUtils.split(branchDetails, \" \")[0]);\n        }\n        assertThat(branchNames.size(), is(2));\n        assertThat(branchNames.contains(branchName), is(true));\n        assertThat(branchNames.contains(\"default\"), is(true));\n    }\n\n    private CommandLine hg(File workingDir, String... arguments) {\n        CommandLine hg = CommandLine.createCommandLine(\"hg\").withArgs(arguments).withEncoding(\"utf-8\");\n        hg.setWorkingDir(workingDir);\n        return hg;\n    }\n\n    private void commit(String message, File workingDir) {\n        CommandLine hg = hg(workingDir, \"ci\", \"-u\", \"cruise-test\", \"-m\", message);\n        String[] input = new String[]{};\n        hg.runOrBomb(null, input);\n    }\n\n    private Revision latestRevisionOf() {\n        CommandLine hg = hg(serverRepo, \"log\", \"--limit\", \"1\", \"--template\", \"{node}\");\n        String[] input = new String[]{};\n        return new StringRevision(hg.runOrBomb(null, input).outputAsString());\n    }\n\n    private void addremove(File workingDir) {\n        CommandLine hg = hg(workingDir, \"addremove\");\n        String[] input = new String[]{};\n        hg.runOrBomb(null, input);\n    }\n\n    private void createNewFileAndPushUpstream(File workingDir) {\n        createNewFileAndCheckIn(workingDir);\n        String branchName = hg(workingDir, \"branch\").runOrBomb(null).outputAsString();\n        hg(workingDir, \"push\", \"--rev\", branchName).runOrBomb(null);\n    }\n\n    private Revision createNewFileAndCheckIn(File directory) {\n        try {\n            new FileOutputStream(new File(directory, \"test.txt\")).close();\n            addremove(directory);\n            commit(\"created test.txt\", directory);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return latestRevisionOf();\n    }\n\n    private void setUpServerRepoFromHgBundle(File serverRepo, File hgBundleFile) {\n        String[] input = new String[]{};\n        CommandLine.createCommandLine(\"hg\")\n                .withArgs(\"clone\", hgBundleFile.getAbsolutePath(), serverRepo.getAbsolutePath()).withEncoding(\"utf-8\").runOrBomb(null, input);\n    }\n\n    private void makeACommitToSecondBranch() {\n        HgCommand hg = new HgCommand(null, secondBranchWorkingCopy, \"second\", serverRepo.getAbsolutePath(), null);\n        hg.clone(outputStreamConsumer, new UrlArgument(serverRepo.getAbsolutePath()));\n        createNewFileAndPushUpstream(secondBranchWorkingCopy);\n    }\n}\n", "/*\n * Copyright 2022 ThoughtWorks, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.thoughtworks.go.domain.materials.mercurial;\n\nimport com.thoughtworks.go.domain.materials.Modification;\nimport com.thoughtworks.go.domain.materials.Revision;\nimport com.thoughtworks.go.domain.materials.SCMCommand;\nimport com.thoughtworks.go.util.NamedProcessTag;\nimport com.thoughtworks.go.util.command.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.net.URLDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static com.thoughtworks.go.util.ExceptionUtils.bomb;\nimport static com.thoughtworks.go.util.ExceptionUtils.bombUnless;\nimport static com.thoughtworks.go.util.command.CommandLine.createCommandLine;\nimport static com.thoughtworks.go.util.command.ProcessOutputStreamConsumer.inMemoryConsumer;\nimport static java.lang.String.format;\n\npublic class HgCommand extends SCMCommand {\n    private static final Logger LOGGER = LoggerFactory.getLogger(HgCommand.class);\n    private final File workingDir;\n    private static String templatePath;\n    private final String branch;\n    private final String url;\n    private final List<SecretString> secrets;\n\n\n    public HgCommand(String materialFingerprint, File workingDir, String branch, String url, List<SecretString> secrets) {\n        super(materialFingerprint);\n        this.workingDir = workingDir;\n        this.branch = branch;\n        this.url = url;\n        this.secrets = secrets != null ? secrets : new ArrayList<>();\n    }\n\n    public HgVersion version() {\n        CommandLine hg = createCommandLine(\"hg\").withArgs(\"version\").withEncoding(\"UTF-8\");\n        String hgOut = execute(hg, new NamedProcessTag(\"hg version check\")).outputAsString();\n        return HgVersion.parse(hgOut);\n    }\n\n    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, UrlArgument repositoryUrl) {\n        CommandLine hg = createCommandLine(\"hg\")\n                .withArgs(\"clone\")\n                .withArg(branchArg())\n                .withArg(\"--\")\n                .withArg(repositoryUrl)\n                .withArg(workingDir.getAbsolutePath())\n                .withNonArgSecrets(secrets)\n                .withEncoding(\"UTF-8\");\n        return execute(hg, outputStreamConsumer);\n    }\n\n    public void checkConnection(UrlArgument repositoryURL) {\n        CommandLine hg = createCommandLine(\"hg\")\n                .withArgs(\"id\", \"--id\", \"--\")\n                .withArg(repositoryURL)\n                .withNonArgSecrets(secrets)\n                .withEncoding(\"UTF-8\");\n        execute(hg, new NamedProcessTag(repositoryURL.forDisplay()));\n    }\n\n    public void updateTo(Revision revision, ConsoleOutputStreamConsumer outputStreamConsumer) {\n        if (!pull(outputStreamConsumer) || !update(revision, outputStreamConsumer)) {\n            bomb(format(\"Unable to update to revision [%s]\", revision));\n        }\n    }\n\n    private boolean pull(ConsoleOutputStreamConsumer outputStreamConsumer) {\n        CommandLine hg = hg(\"pull\", branchArg(), \"--config\", String.format(\"paths.default=%s\", url));\n        return execute(hg, outputStreamConsumer) == 0;\n    }\n\n    private boolean update(Revision revision, ConsoleOutputStreamConsumer outputStreamConsumer) {\n        CommandLine hg = hg(\"update\", \"--clean\", \"-r\", revision.getRevision());\n        return execute(hg, outputStreamConsumer) == 0;\n    }\n\n    public void add(ConsoleOutputStreamConsumer outputStreamConsumer, File file) {\n        CommandLine hg = hg(\"add\", file.getAbsolutePath());\n        execute(hg, outputStreamConsumer);\n    }\n\n    public void commit(ConsoleOutputStreamConsumer consumer, String comment, String username) {\n        CommandLine hg = hg(\"commit\", \"-m\", comment, \"-u\", username);\n        execute(hg, consumer);\n    }\n\n    public void push(ConsoleOutputStreamConsumer consumer) {\n        CommandLine hg = hg(\"push\");\n        execute(hg, consumer);\n    }\n\n    public List<Modification> latestOneModificationAsModifications() {\n        return findRecentModifications(1);\n    }\n\n    private List<Modification> findRecentModifications(int count) {\n        // Currently impossible to check modifications on a remote repository.\n        InMemoryStreamConsumer consumer = inMemoryConsumer();\n        bombUnless(pull(consumer), \"Failed to run hg pull command: \" + consumer.getAllOutput());\n        CommandLine hg = hg(\"log\", \"--limit\", String.valueOf(count), branchArg(), \"--style\", templatePath());\n        return new HgModificationSplitter(execute(hg)).modifications();\n    }\n\n    public List<Modification> modificationsSince(Revision revision) {\n        InMemoryStreamConsumer consumer = inMemoryConsumer();\n        bombUnless(pull(consumer), \"Failed to run hg pull command: \" + consumer.getAllOutput());\n        CommandLine hg = hg(\"log\", \"-r\", \"tip:\" + revision.getRevision(), branchArg(), \"--style\", templatePath());\n        return new HgModificationSplitter(execute(hg)).filterOutRevision(revision);\n    }\n\n    private String templatePath() {\n        if (templatePath == null) {\n            String file = HgCommand.class.getResource(\"/hg.template\").getFile();\n            templatePath = URLDecoder.decode(new File(file).getAbsolutePath(), StandardCharsets.UTF_8);\n        }\n        return templatePath;\n    }\n\n    public ConsoleResult workingRepositoryUrl() {\n        CommandLine hg = hg(\"showconfig\", \"paths.default\");\n\n        final ConsoleResult result = execute(hg);\n        LOGGER.trace(\"Current repository url of [{}]: {}\", workingDir, result.outputForDisplayAsString());\n        LOGGER.trace(\"Target repository url: {}\", url);\n        return result;\n    }\n\n    private String branchArg() {\n        return \"--branch=\" + branch;\n    }\n\n    private CommandLine hg(String... arguments) {\n        return createCommandLine(\"hg\").withArgs(arguments).withNonArgSecrets(secrets).withWorkingDir(workingDir).withEncoding(\"UTF-8\");\n    }\n\n    private static ConsoleResult execute(CommandLine hgCmd, NamedProcessTag processTag) {\n        return hgCmd.runOrBomb(processTag);\n    }\n\n    private ConsoleResult execute(CommandLine hgCmd) {\n        return runOrBomb(hgCmd);\n    }\n\n    private int execute(CommandLine hgCmd, ConsoleOutputStreamConsumer outputStreamConsumer) {\n        return run(hgCmd, outputStreamConsumer);\n    }\n}\n"], "buggy_code_start_loc": [38, 27], "buggy_code_end_loc": [155, 144], "fixing_code_start_loc": [38, 26], "fixing_code_end_loc": [191, 151], "type": "CWE-77", "message": "GoCD is a continuous delivery server. In GoCD versions prior to 22.1.0, it is possible for existing authenticated users who have permissions to edit or create pipeline materials or pipeline configuration repositories to get remote code execution capability on the GoCD server via configuring a malicious branch name which abuses Mercurial hooks/aliases to exploit a command injection weakness. An attacker would require access to an account with existing GoCD administration permissions to either create/edit (`hg`-based) configuration repositories; create/edit pipelines and their (`hg`-based) materials; or, where \"pipelines-as-code\" configuration repositories are used, to commit malicious configuration to such an external repository which will be automatically parsed into a pipeline configuration and (`hg`) material definition by the GoCD server. This issue is fixed in GoCD 22.1.0. As a workaround, users who do not use/rely upon Mercurial materials can uninstall/remove the `hg`/Mercurial binary from the underlying GoCD Server operating system or Docker image.", "other": {"cve": {"id": "CVE-2022-29184", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-20T20:15:10.073", "lastModified": "2022-06-06T15:29:21.663", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GoCD is a continuous delivery server. In GoCD versions prior to 22.1.0, it is possible for existing authenticated users who have permissions to edit or create pipeline materials or pipeline configuration repositories to get remote code execution capability on the GoCD server via configuring a malicious branch name which abuses Mercurial hooks/aliases to exploit a command injection weakness. An attacker would require access to an account with existing GoCD administration permissions to either create/edit (`hg`-based) configuration repositories; create/edit pipelines and their (`hg`-based) materials; or, where \"pipelines-as-code\" configuration repositories are used, to commit malicious configuration to such an external repository which will be automatically parsed into a pipeline configuration and (`hg`) material definition by the GoCD server. This issue is fixed in GoCD 22.1.0. As a workaround, users who do not use/rely upon Mercurial materials can uninstall/remove the `hg`/Mercurial binary from the underlying GoCD Server operating system or Docker image."}, {"lang": "es", "value": "GoCD es un servidor de entrega continua. En GoCD versiones anteriores a 22.1.0, es posible que los usuarios autenticados existentes que presentan permisos para editar o crear materiales de canalizaci\u00f3n o repositorios de configuraci\u00f3n de canalizaci\u00f3n obtengan la capacidad de ejecuci\u00f3n de c\u00f3digo remota en el servidor GoCD por medio de la configuraci\u00f3n de un nombre de rama malicioso que abusa de los ganchos/aliases de Mercurial para explotar una debilidad de inyecci\u00f3n de comandos. Un atacante necesitar\u00eda acceder a una cuenta con permisos de administraci\u00f3n de GoCD para crear/editar repositorios de configuraci\u00f3n (basados en \"hg\"); crear/editar pipelines y sus materiales (basados en \"hg\"); o, cuando son usados repositorios de configuraci\u00f3n \"pipelines-as-code\", enviar una configuraci\u00f3n maliciosa a dicho repositorio externo que ser\u00e1 analizada autom\u00e1ticamente en una configuraci\u00f3n de pipeline y una definici\u00f3n de material (\"hg\") por el servidor GoCD. Este problema ha sido corregido en GoCD versi\u00f3n 22.1.0. Como mitigaci\u00f3n, los usuarios que no usan/dependen de los materiales Mercurial pueden desinstalar/eliminar el binario \"hg\"/Mercurial del sistema operativo subyacente del servidor GoCD o de la imagen Docker"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-77"}, {"lang": "en", "value": "CWE-88"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:thoughtworks:gocd:*:*:*:*:*:*:*:*", "versionEndExcluding": "22.1.0", "matchCriteriaId": "B80FC31B-2CF2-4DE9-8ADB-ADEA24124ABB"}]}]}], "references": [{"url": "https://github.com/gocd/gocd/commit/37d35115db2ada2190173f9413cfe1bc6c295ecb", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gocd/gocd/releases/tag/22.1.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/gocd/gocd/security/advisories/GHSA-vf5r-r7j2-cf2h", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.gocd.org/releases/#22-1-0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/gocd/gocd/commit/37d35115db2ada2190173f9413cfe1bc6c295ecb"}}