{"buggy_code": ["## [Unreleased]\n\n## 1.11.0 - 2020-03-13\n### Added\n\n*Nothing has been added for this version*\n\n### Removed\n- MiddlewareMixin\n- Python 3.4 support\n- Django 2.1 support\n- `mock` dependency\n\n### Changed\n- `extra_requires` are now listed in lowercase. This is to workaround a bug in `pip`.\n- Use `trimmed` option on `blocktrans` to avoid garbage newlines in translations.\n- `random_hex` from `django_otp` 0.8.0 will always return a `str`, don't try to decode it.\n\n## 1.10.0 - 2019-12-13\n### Added\n- Support for Django 3.0.\n- Optionally install full or light phonenumbers library.\n\n### Removed\n- Python 2 support.\n\n### Changed\n- Updated translations.\n\n## 1.9.1 - 2019-07-07\n### Changed\n- 1.9.0 got pushed with incorrect changelog, no other changes.\n\n## 1.9.0 - 2019-07-07\n### Added\n- Support for Django 2.2.\n- Ability to create `PhoneDevice` from Django admin.\n- Support for Python 3.7.\n\n## 1.8.0 - 2018-08-03\n### Added\n- Support for Django 2.1.\n- Support for QRcode library up to 6.\n- Translation: Romanian.\n\n### Changed\n- Replace `ValidationError` with `SuspiciousOperation` in views.\n- Change the wording in 2FA disable template.\n- Updated translations.\n\n## 1.7.0 - 2017-12-19\n### Added\n- Support for Django 2.0.\n\n### Removed\n- Django <1.11 support.\n\n### Changed\n- Do not list phone method if it is not supported (#225).\n- Pass request kwarg to authentication form (#227).\n\n## 1.6.2 - 2017-07-29\n### Fixed\n- Twilio client 6.0 usage (#211).\n\n### Changed\n- Updated translation: Russian.\n\n## 1.6.1 - 2017-05-11\n### Added\n- Support Twilio client 6.0 (#203).\n\n### Fixed\n- `redirect_to` after successful login (#204)\n\n### Changed\n- Updated translation: Norwegian Bokm\u00e5l\n\n## 1.6.0 - 2017-04-08\n### Added\n- Support for Django 1.11 (#188).\n\n### Removed\n- Django 1.9 support.\n\n### Fixed\n- Allow setting `LOGIN_REDIRECT_URL` to a URL (#192).\n- `DisableView` should also take `success_url` parameter (#187).\n\n## 1.5.0 - 2017-01-04\n### Added\n- Django 1.10\u2019s MIDDLEWARE support.\n- Allow `success_url` overrides from `urls.py`.\n- Autofocus token input during authentication.\n- Translations: Polish, Italian, Hungarian, Finnish and Danish.\n\n### Removed\n- Dropped Python 3.2 and 3.3 support.\n\n### Changed\n- Renamed `redirect_url` properties to `success_url` to be consistent with Django.\n\n### Fixed\n- Allow Firefox users to enter backup tokens (#177).\n- Allow multiple requests for QR code (#99).\n- Don't add phone number without gateway (#92).\n- Redirect to 2FA profile page after removing a phone (#159).\n", "Configuration\n=============\n\nGeneral Settings\n----------------\n\n``TWO_FACTOR_PATCH_ADMIN`` (default: ``True``)\n  Whether the Django admin is patched to use the default login view.\n\n  .. warning::\n     The admin currently does not enforce one-time passwords being set for\n     admin users.\n\n``TWO_FACTOR_CALL_GATEWAY`` (default: ``None``)\n  Which gateway to use for making phone calls. Should be set to a module or\n  object providing a ``make_call`` method. Currently two gateways are bundled:\n\n  * ``'two_factor.gateways.twilio.gateway.Twilio'`` for making real phone calls using\n    Twilio_.\n  * ``'two_factor.gateways.fake.Fake'``  for development, recording tokens to the\n    default logger.\n\n``TWO_FACTOR_SMS_GATEWAY`` (default: ``None``)\n  Which gateway to use for sending text messages. Should be set to a module or\n  object providing a ``send_sms`` method. Currently two gateways are bundled:\n\n  * ``'two_factor.gateways.twilio.gateway.Twilio'`` for sending real text messages using\n    Twilio_.\n  * ``'two_factor.gateways.fake.Fake'``  for development, recording tokens to the\n    default logger.\n\n``LOGIN_URL``\n  Should point to the login view provided by this application as described in\n  setup. This login view handles password authentication followed by a one-time\n  password exchange if enabled for that account. This can be a URL path or URL\n  name as defined in the Django documentation.\n\n  See also LOGIN_URL_.\n\n``LOGIN_REDIRECT_URL``\n  This application provides a basic page for managing one's account. This view\n  is entirely optional and could be implemented in a custom view. This can be a\n  URL path or URL name as defined in the Django documentation.\n\n  See also LOGIN_REDIRECT_URL_.\n\n``LOGOUT_REDIRECT_URL``\n  Should point to a view that the user is redirected to after loging out. It was\n  added in Django 1.10, and also adapted by this application. This can be a\n  URL path or URL name as defined in the Django documentation.\n\n  See also LOGOUT_REDIRECT_URL_.\n\n``TWO_FACTOR_QR_FACTORY``\n  The default generator for the QR code images is set to SVG. This\n  does not require any further dependencies, however it does not work\n  on IE8 and below. If you have PIL, Pillow or pyimaging installed\n  you may wish to use PNG images instead.\n\n  * ``'qrcode.image.pil.PilImage'`` may be used for PIL/Pillow\n  * ``'qrcode.image.pure.PymagingImage'`` may be used for pyimaging\n\n  For more QR factories that are available see python-qrcode_.\n\n``TWO_FACTOR_TOTP_DIGITS`` (default: ``6``)\n  The number of digits to use for TOTP tokens, can be set to 6 or 8. This\n  setting will be used for tokens delivered by phone call or text message and\n  newly configured token generators. Existing token generator devices will not\n  be affected.\n\n  .. warning::\n     The Google Authenticator app does not support 8 digit codes (see\n     `the upstream ticket`_). Don't set this option to 8 unless all of your\n     users use a 8 digit compatible token generator app.\n\n``PHONENUMBER_DEFAULT_REGION`` (default: ``None``)\n  The default region for parsing phone numbers. If your application's primary\n  audience is a certain country, setting the region to that country allows\n  entering phone numbers without that country's country code.\n\nTwilio Gateway\n--------------\nTo use the Twilio gateway, you need first to install the `Twilio client`_:\n\n.. code-block:: console\n\n    $ pip install twilio\n\nNext, add additional urls to your config:\n\n.. code-block:: python\n\n    # urls.py\n    from two_factor.gateways.twilio.urls import urlpatterns as tf_twilio_urls\n    urlpatterns = [\n        url(r'', include(tf_twilio_urls)),\n        ...\n    ]\n\nAdditionally, you need to enable the ``ThreadLocals`` middleware:\n\n.. code-block:: python\n\n    MIDDLEWARE = (\n        ...\n\n        # Always include for two-factor auth\n        'django_otp.middleware.OTPMiddleware',\n\n        # Include for twilio gateway\n        'two_factor.middleware.threadlocals.ThreadLocals',\n    )\n\n\n.. autoclass:: two_factor.gateways.twilio.gateway.Twilio\n\nFake Gateway\n------------\n.. autoclass:: two_factor.gateways.fake.Fake\n\n.. _LOGIN_URL: https://docs.djangoproject.com/en/dev/ref/settings/#login-url\n.. _LOGIN_REDIRECT_URL: https://docs.djangoproject.com/en/dev/ref/settings/#login-redirect-url\n.. _LOGOUT_REDIRECT_URL: https://docs.djangoproject.com/en/dev/ref/settings/#logout-redirect-url\n.. _Twilio: http://www.twilio.com/\n.. _`Twilio client`: https://pypi.python.org/pypi/twilio\n.. _python-qrcode: https://pypi.python.org/pypi/qrcode\n.. _`the upstream ticket`: https://code.google.com/p/google-authenticator/issues/detail?id=327\n", "from unittest import mock\n\nfrom django.conf import settings\nfrom django.shortcuts import resolve_url\nfrom django.test import TestCase\nfrom django.test.utils import override_settings\nfrom django.urls import reverse\nfrom django_otp import DEVICE_ID_SESSION_KEY\nfrom django_otp.oath import totp\n\nfrom two_factor.models import random_hex_str\n\nfrom .utils import UserMixin\n\n\nclass LoginTest(UserMixin, TestCase):\n    def _post(self, data=None):\n        return self.client.post(reverse('two_factor:login'), data=data)\n\n    def test_form(self):\n        response = self.client.get(reverse('two_factor:login'))\n        self.assertContains(response, 'Password:')\n\n    def test_invalid_login(self):\n        response = self._post({'auth-username': 'unknown',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertContains(response, 'Please enter a correct')\n        self.assertContains(response, 'and password.')\n\n    @mock.patch('two_factor.views.core.signals.user_verified.send')\n    def test_valid_login(self, mock_signal):\n        self.create_user()\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertRedirects(response, resolve_url(settings.LOGIN_REDIRECT_URL))\n\n        # No signal should be fired for non-verified user logins.\n        self.assertFalse(mock_signal.called)\n\n    def test_valid_login_with_custom_redirect(self):\n        redirect_url = reverse('two_factor:setup')\n        self.create_user()\n        response = self.client.post(\n            '%s?%s' % (reverse('two_factor:login'), 'next=' + redirect_url),\n            {'auth-username': 'bouke@example.com',\n             'auth-password': 'secret',\n             'login_view-current_step': 'auth'})\n        self.assertRedirects(response, redirect_url)\n\n    def test_valid_login_with_custom_post_redirect(self):\n        redirect_url = reverse('two_factor:setup')\n        self.create_user()\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth',\n                               'next': redirect_url})\n        self.assertRedirects(response, redirect_url)\n\n    def test_valid_login_with_redirect_field_name(self):\n        redirect_url = reverse('two_factor:setup')\n        self.create_user()\n        response = self.client.post(\n            '%s?%s' % (reverse('custom-field-name-login'), 'next_page=' + redirect_url),\n            {'auth-username': 'bouke@example.com',\n             'auth-password': 'secret',\n             'login_view-current_step': 'auth'})\n        self.assertRedirects(response, redirect_url)\n\n    def test_valid_login_with_allowed_external_redirect(self):\n        redirect_url = 'https://test.allowed-success-url.com'\n        self.create_user()\n        response = self.client.post(\n            '%s?%s' % (reverse('custom-allowed-success-url-login'), 'next=' + redirect_url),\n            {'auth-username': 'bouke@example.com',\n             'auth-password': 'secret',\n             'login_view-current_step': 'auth'})\n        self.assertRedirects(response, redirect_url, fetch_redirect_response=False)\n\n    def test_valid_login_with_disallowed_external_redirect(self):\n        redirect_url = 'https://test.disallowed-success-url.com'\n        self.create_user()\n        response = self.client.post(\n            '%s?%s' % (reverse('custom-allowed-success-url-login'), 'next=' + redirect_url),\n            {'auth-username': 'bouke@example.com',\n             'auth-password': 'secret',\n             'login_view-current_step': 'auth'})\n        self.assertRedirects(response, reverse('two_factor:profile'), fetch_redirect_response=False)\n\n\n    def test_valid_login_with_redirect_authenticated_user(self):\n        user = self.create_user()\n        response = self.client.get(\n            reverse('custom-redirect-authenticated-user-login')\n        )\n        self.assertEqual(response.status_code, 200)\n        self.client.force_login(user)\n        response = self.client.get(\n            reverse('custom-redirect-authenticated-user-login')\n        )\n        self.assertRedirects(response, reverse('two_factor:profile'))\n\n    def test_valid_login_with_redirect_authenticated_user_loop(self):\n        redirect_url = reverse('custom-redirect-authenticated-user-login')\n        user = self.create_user()\n        self.client.force_login(user)\n        with self.assertRaises(ValueError):\n            self.client.get(\n                '%s?%s' % (reverse('custom-redirect-authenticated-user-login'), 'next=' + redirect_url),\n            )\n\n    @mock.patch('two_factor.views.core.signals.user_verified.send')\n    def test_with_generator(self, mock_signal):\n        user = self.create_user()\n        device = user.totpdevice_set.create(name='default',\n                                            key=random_hex_str())\n\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertContains(response, 'Token:')\n\n        response = self._post({'token-otp_token': '123456',\n                               'login_view-current_step': 'token'})\n        self.assertEqual(response.context_data['wizard']['form'].errors,\n                         {'__all__': ['Invalid token. Please make sure you '\n                                      'have entered it correctly.']})\n\n        # reset throttle because we're not testing that\n        device.throttle_reset()\n\n        response = self._post({'token-otp_token': totp(device.bin_key),\n                               'login_view-current_step': 'token'})\n        self.assertRedirects(response, resolve_url(settings.LOGIN_REDIRECT_URL))\n\n        self.assertEqual(device.persistent_id,\n                         self.client.session.get(DEVICE_ID_SESSION_KEY))\n\n        # Check that the signal was fired.\n        mock_signal.assert_called_with(sender=mock.ANY, request=mock.ANY, user=user, device=device)\n\n    @mock.patch('two_factor.views.core.signals.user_verified.send')\n    def test_throttle_with_generator(self, mock_signal):\n        user = self.create_user()\n        device = user.totpdevice_set.create(name='default',\n                                            key=random_hex_str())\n\n        self._post({'auth-username': 'bouke@example.com',\n                    'auth-password': 'secret',\n                    'login_view-current_step': 'auth'})\n\n        # throttle device\n        device.throttle_increment()\n\n        response = self._post({'token-otp_token': totp(device.bin_key),\n                               'login_view-current_step': 'token'})\n        self.assertEqual(response.context_data['wizard']['form'].errors,\n                         {'__all__': ['Invalid token. Please make sure you '\n                                      'have entered it correctly.']})\n\n    @mock.patch('two_factor.gateways.fake.Fake')\n    @mock.patch('two_factor.views.core.signals.user_verified.send')\n    @override_settings(\n        TWO_FACTOR_SMS_GATEWAY='two_factor.gateways.fake.Fake',\n        TWO_FACTOR_CALL_GATEWAY='two_factor.gateways.fake.Fake',\n    )\n    def test_with_backup_phone(self, mock_signal, fake):\n        user = self.create_user()\n        for no_digits in (6, 8):\n            with self.settings(TWO_FACTOR_TOTP_DIGITS=no_digits):\n                user.totpdevice_set.create(name='default', key=random_hex_str(),\n                                           digits=no_digits)\n                device = user.phonedevice_set.create(name='backup', number='+31101234567',\n                                                     method='sms',\n                                                     key=random_hex_str())\n\n                # Backup phones should be listed on the login form\n                response = self._post({'auth-username': 'bouke@example.com',\n                                       'auth-password': 'secret',\n                                       'login_view-current_step': 'auth'})\n                self.assertContains(response, 'Send text message to +31 ** *** **67')\n\n                # Ask for challenge on invalid device\n                response = self._post({'auth-username': 'bouke@example.com',\n                                       'auth-password': 'secret',\n                                       'challenge_device': 'MALICIOUS/INPUT/666'})\n                self.assertContains(response, 'Send text message to +31 ** *** **67')\n\n                # Ask for SMS challenge\n                response = self._post({'auth-username': 'bouke@example.com',\n                                       'auth-password': 'secret',\n                                       'challenge_device': device.persistent_id})\n                self.assertContains(response, 'We sent you a text message')\n                fake.return_value.send_sms.assert_called_with(\n                    device=device,\n                    token=str(totp(device.bin_key, digits=no_digits)).zfill(no_digits))\n\n                # Ask for phone challenge\n                device.method = 'call'\n                device.save()\n                response = self._post({'auth-username': 'bouke@example.com',\n                                       'auth-password': 'secret',\n                                       'challenge_device': device.persistent_id})\n                self.assertContains(response, 'We are calling your phone right now')\n                fake.return_value.make_call.assert_called_with(\n                    device=device,\n                    token=str(totp(device.bin_key, digits=no_digits)).zfill(no_digits))\n\n            # Valid token should be accepted.\n            response = self._post({'token-otp_token': totp(device.bin_key),\n                                   'login_view-current_step': 'token'})\n            self.assertRedirects(response, resolve_url(settings.LOGIN_REDIRECT_URL))\n            self.assertEqual(device.persistent_id,\n                             self.client.session.get(DEVICE_ID_SESSION_KEY))\n\n            # Check that the signal was fired.\n            mock_signal.assert_called_with(sender=mock.ANY, request=mock.ANY, user=user, device=device)\n\n    @mock.patch('two_factor.views.core.signals.user_verified.send')\n    def test_with_backup_token(self, mock_signal):\n        user = self.create_user()\n        user.totpdevice_set.create(name='default', key=random_hex_str())\n        device = user.staticdevice_set.create(name='backup')\n        device.token_set.create(token='abcdef123')\n\n        # Backup phones should be listed on the login form\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertContains(response, 'Backup Token')\n\n        # Should be able to go to backup tokens step in wizard\n        response = self._post({'wizard_goto_step': 'backup'})\n        self.assertContains(response, 'backup tokens')\n\n        # Wrong codes should not be accepted\n        response = self._post({'backup-otp_token': 'WRONG',\n                               'login_view-current_step': 'backup'})\n        self.assertEqual(response.context_data['wizard']['form'].errors,\n                         {'__all__': ['Invalid token. Please make sure you '\n                                      'have entered it correctly.']})\n        # static devices are throttled\n        device.throttle_reset()\n\n        # Valid token should be accepted.\n        response = self._post({'backup-otp_token': 'abcdef123',\n                               'login_view-current_step': 'backup'})\n        self.assertRedirects(response, resolve_url(settings.LOGIN_REDIRECT_URL))\n\n        # Check that the signal was fired.\n        mock_signal.assert_called_with(sender=mock.ANY, request=mock.ANY, user=user, device=device)\n\n    @mock.patch('two_factor.views.utils.logger')\n    def test_change_password_in_between(self, mock_logger):\n        \"\"\"\n        When the password of the user is changed while trying to login, should\n        not result in errors. Refs #63.\n        \"\"\"\n        user = self.create_user()\n        self.enable_otp()\n\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertContains(response, 'Token:')\n\n        # Now, the password is changed. When the form is submitted, the\n        # credentials should be checked again. If that's the case, the\n        # login form should note that the credentials are invalid.\n        user.set_password('secret2')\n        user.save()\n        response = self._post({'login_view-current_step': 'token'})\n        self.assertContains(response, 'Please enter a correct')\n        self.assertContains(response, 'and password.')\n\n        # Check that a message was logged.\n        mock_logger.warning.assert_called_with(\n            \"Current step '%s' is no longer valid, returning to last valid \"\n            \"step in the wizard.\",\n            'token')\n\n    @mock.patch('two_factor.views.utils.logger')\n    def test_reset_wizard_state(self, mock_logger):\n        self.create_user()\n        self.enable_otp()\n\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertContains(response, 'Token:')\n\n        # A GET request resets the state of the wizard...\n        self.client.get(reverse('two_factor:login'))\n\n        # ...so there is no user in this request anymore. As the login flow\n        # depends on a user being present, this should be handled gracefully.\n        response = self._post({'token-otp_token': '123456',\n                               'login_view-current_step': 'token'})\n        self.assertContains(response, 'Password:')\n\n        # Check that a message was logged.\n        mock_logger.warning.assert_called_with(\n            \"Requested step '%s' is no longer valid, returning to last valid \"\n            \"step in the wizard.\",\n            'token')\n\n    @mock.patch('two_factor.views.utils.logger')\n    def test_login_different_user_on_existing_session(self, mock_logger):\n        \"\"\"\n        This test reproduces the issue where a user is logged in and a different user\n        attempts to login.\n        \"\"\"\n        self.create_user()\n        self.create_user(username='vedran@example.com')\n\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertRedirects(response, resolve_url(settings.LOGIN_REDIRECT_URL))\n\n        response = self._post({'auth-username': 'vedran@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertRedirects(response, resolve_url(settings.LOGIN_REDIRECT_URL))\n\n    def test_missing_management_data(self):\n        # missing management data\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret'})\n\n        # view should return HTTP 400 Bad Request\n        self.assertEqual(response.status_code, 400)\n\n\nclass BackupTokensTest(UserMixin, TestCase):\n    def setUp(self):\n        super().setUp()\n        self.create_user()\n        self.enable_otp()\n        self.login_user()\n\n    def test_empty(self):\n        response = self.client.get(reverse('two_factor:backup_tokens'))\n        self.assertContains(response, 'You don\\'t have any backup codes yet.')\n\n    def test_generate(self):\n        url = reverse('two_factor:backup_tokens')\n\n        response = self.client.post(url)\n        self.assertRedirects(response, url)\n\n        response = self.client.get(url)\n        first_set = set([token.token for token in\n                        response.context_data['device'].token_set.all()])\n        self.assertNotContains(response, 'You don\\'t have any backup codes '\n                                         'yet.')\n        self.assertEqual(10, len(first_set))\n\n        # Generating the tokens should give a fresh set\n        self.client.post(url)\n        response = self.client.get(url)\n        second_set = set([token.token for token in\n                         response.context_data['device'].token_set.all()])\n        self.assertNotEqual(first_set, second_set)\n", "import logging\nimport warnings\nfrom base64 import b32encode\nfrom binascii import unhexlify\n\nimport django_otp\nimport qrcode\nimport qrcode.image.svg\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME, login\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.forms import AuthenticationForm\nfrom django.contrib.auth.views import SuccessURLAllowedHostsMixin\nfrom django.contrib.sites.shortcuts import get_current_site\nfrom django.forms import Form\nfrom django.http import Http404, HttpResponse, HttpResponseRedirect\nfrom django.shortcuts import redirect, resolve_url\nfrom django.urls import reverse\nfrom django.utils.decorators import method_decorator\nfrom django.utils.http import is_safe_url\nfrom django.utils.module_loading import import_string\nfrom django.views.decorators.cache import never_cache\nfrom django.views.decorators.csrf import csrf_protect\nfrom django.views.decorators.debug import sensitive_post_parameters\nfrom django.views.generic import DeleteView, FormView, TemplateView\nfrom django.views.generic.base import View\nfrom django_otp.decorators import otp_required\nfrom django_otp.plugins.otp_static.models import StaticDevice, StaticToken\n\nfrom two_factor import signals\nfrom two_factor.models import get_available_methods, random_hex_str\nfrom two_factor.utils import totp_digits\n\nfrom ..forms import (\n    AuthenticationTokenForm, BackupTokenForm, DeviceValidationForm, MethodForm,\n    PhoneNumberForm, PhoneNumberMethodForm, TOTPDeviceForm, YubiKeyDeviceForm,\n)\nfrom ..models import PhoneDevice, get_available_phone_methods\nfrom ..utils import backup_phones, default_device, get_otpauth_url\nfrom .utils import IdempotentSessionWizardView, class_view_decorator\n\ntry:\n    from otp_yubikey.models import ValidationService, RemoteYubikeyDevice\nexcept ImportError:\n    ValidationService = RemoteYubikeyDevice = None\n\n\nlogger = logging.getLogger(__name__)\n\n\n@class_view_decorator(sensitive_post_parameters())\n@class_view_decorator(never_cache)\nclass LoginView(SuccessURLAllowedHostsMixin, IdempotentSessionWizardView):\n    \"\"\"\n    View for handling the login process, including OTP verification.\n\n    The login process is composed like a wizard. The first step asks for the\n    user's credentials. If the credentials are correct, the wizard proceeds to\n    the OTP verification step. If the user has a default OTP device configured,\n    that device is asked to generate a token (send sms / call phone) and the\n    user is asked to provide the generated token. The backup devices are also\n    listed, allowing the user to select a backup device for verification.\n    \"\"\"\n    template_name = 'two_factor/core/login.html'\n    form_list = (\n        ('auth', AuthenticationForm),\n        ('token', AuthenticationTokenForm),\n        ('backup', BackupTokenForm),\n    )\n    idempotent_dict = {\n        'token': False,\n        'backup': False,\n    }\n    redirect_authenticated_user = False\n\n    def has_token_step(self):\n        return default_device(self.get_user())\n\n    def has_backup_step(self):\n        return default_device(self.get_user()) and \\\n            'token' not in self.storage.validated_step_data\n\n    condition_dict = {\n        'token': has_token_step,\n        'backup': has_backup_step,\n    }\n    redirect_field_name = REDIRECT_FIELD_NAME\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.user_cache = None\n        self.device_cache = None\n\n    def post(self, *args, **kwargs):\n        \"\"\"\n        The user can select a particular device to challenge, being the backup\n        devices added to the account.\n        \"\"\"\n        # Generating a challenge doesn't require to validate the form.\n        if 'challenge_device' in self.request.POST:\n            return self.render_goto_step('token')\n\n        return super().post(*args, **kwargs)\n\n    def done(self, form_list, **kwargs):\n        \"\"\"\n        Login the user and redirect to the desired page.\n        \"\"\"\n        login(self.request, self.get_user())\n\n        redirect_to = self.get_success_url()\n\n        device = getattr(self.get_user(), 'otp_device', None)\n        if device:\n            signals.user_verified.send(sender=__name__, request=self.request,\n                                       user=self.get_user(), device=device)\n        return redirect(redirect_to)\n\n    # Copied from django.conrib.auth.views.LoginView (Branch: stable/1.11.x)\n    # https://github.com/django/django/blob/58df8aa40fe88f753ba79e091a52f236246260b3/django/contrib/auth/views.py#L63\n    def get_success_url(self):\n        url = self.get_redirect_url()\n        return url or resolve_url(settings.LOGIN_REDIRECT_URL)\n\n    # Copied from django.conrib.auth.views.LoginView (Branch: stable/1.11.x)\n    # https://github.com/django/django/blob/58df8aa40fe88f753ba79e091a52f236246260b3/django/contrib/auth/views.py#L67\n    def get_redirect_url(self):\n        \"\"\"Return the user-originating redirect URL if it's safe.\"\"\"\n        redirect_to = self.request.POST.get(\n            self.redirect_field_name,\n            self.request.GET.get(self.redirect_field_name, '')\n        )\n        url_is_safe = is_safe_url(\n            url=redirect_to,\n            allowed_hosts=self.get_success_url_allowed_hosts(),\n            require_https=self.request.is_secure(),\n        )\n        return redirect_to if url_is_safe else ''\n\n    def get_form_kwargs(self, step=None):\n        \"\"\"\n        AuthenticationTokenForm requires the user kwarg.\n        \"\"\"\n        if step == 'auth':\n            return {\n                'request': self.request\n            }\n        if step in ('token', 'backup'):\n            return {\n                'user': self.get_user(),\n                'initial_device': self.get_device(step),\n            }\n        return {}\n\n    def get_device(self, step=None):\n        \"\"\"\n        Returns the OTP device selected by the user, or his default device.\n        \"\"\"\n        if not self.device_cache:\n            challenge_device_id = self.request.POST.get('challenge_device', None)\n            if challenge_device_id:\n                for device in backup_phones(self.get_user()):\n                    if device.persistent_id == challenge_device_id:\n                        self.device_cache = device\n                        break\n            if step == 'backup':\n                try:\n                    self.device_cache = self.get_user().staticdevice_set.get(name='backup')\n                except StaticDevice.DoesNotExist:\n                    pass\n            if not self.device_cache:\n                self.device_cache = default_device(self.get_user())\n        return self.device_cache\n\n    def render(self, form=None, **kwargs):\n        \"\"\"\n        If the user selected a device, ask the device to generate a challenge;\n        either making a phone call or sending a text message.\n        \"\"\"\n        if self.steps.current == 'token':\n            self.get_device().generate_challenge()\n        return super().render(form, **kwargs)\n\n    def get_user(self):\n        \"\"\"\n        Returns the user authenticated by the AuthenticationForm. Returns False\n        if not a valid user; see also issue #65.\n        \"\"\"\n        if not self.user_cache:\n            form_obj = self.get_form(step='auth',\n                                     data=self.storage.get_step_data('auth'))\n            self.user_cache = form_obj.is_valid() and form_obj.user_cache\n        return self.user_cache\n\n    def get_context_data(self, form, **kwargs):\n        \"\"\"\n        Adds user's default and backup OTP devices to the context.\n        \"\"\"\n        context = super().get_context_data(form, **kwargs)\n        if self.steps.current == 'token':\n            context['device'] = self.get_device()\n            context['other_devices'] = [\n                phone for phone in backup_phones(self.get_user())\n                if phone != self.get_device()]\n            try:\n                context['backup_tokens'] = self.get_user().staticdevice_set\\\n                    .get(name='backup').token_set.count()\n            except StaticDevice.DoesNotExist:\n                context['backup_tokens'] = 0\n\n        if getattr(settings, 'LOGOUT_REDIRECT_URL', None):\n            context['cancel_url'] = resolve_url(settings.LOGOUT_REDIRECT_URL)\n        elif getattr(settings, 'LOGOUT_URL', None):\n            warnings.warn(\n                \"LOGOUT_URL has been replaced by LOGOUT_REDIRECT_URL, please \"\n                \"review the URL and update your settings.\",\n                DeprecationWarning)\n            context['cancel_url'] = resolve_url(settings.LOGOUT_URL)\n        return context\n\n    # Copied from django.conrib.auth.views.LoginView  (Branch: stable/1.11.x)\n    # https://github.com/django/django/blob/58df8aa40fe88f753ba79e091a52f236246260b3/django/contrib/auth/views.py#L49\n    @method_decorator(sensitive_post_parameters())\n    @method_decorator(csrf_protect)\n    @method_decorator(never_cache)\n    def dispatch(self, request, *args, **kwargs):\n        if self.redirect_authenticated_user and self.request.user.is_authenticated:\n            redirect_to = self.get_success_url()\n            if redirect_to == self.request.path:\n                raise ValueError(\n                    \"Redirection loop for authenticated user detected. Check that \"\n                    \"your LOGIN_REDIRECT_URL doesn't point to a login page.\"\n                )\n            return HttpResponseRedirect(redirect_to)\n        return super().dispatch(request, *args, **kwargs)\n\n\n@class_view_decorator(never_cache)\n@class_view_decorator(login_required)\nclass SetupView(IdempotentSessionWizardView):\n    \"\"\"\n    View for handling OTP setup using a wizard.\n\n    The first step of the wizard shows an introduction text, explaining how OTP\n    works and why it should be enabled. The user has to select the verification\n    method (generator / call / sms) in the second step. Depending on the method\n    selected, the third step configures the device. For the generator method, a\n    QR code is shown which can be scanned using a mobile phone app and the user\n    is asked to provide a generated token. For call and sms methods, the user\n    provides the phone number which is then validated in the final step.\n    \"\"\"\n    success_url = 'two_factor:setup_complete'\n    qrcode_url = 'two_factor:qr'\n    template_name = 'two_factor/core/setup.html'\n    session_key_name = 'django_two_factor-qr_secret_key'\n    initial_dict = {}\n    form_list = (\n        ('welcome', Form),\n        ('method', MethodForm),\n        ('generator', TOTPDeviceForm),\n        ('sms', PhoneNumberForm),\n        ('call', PhoneNumberForm),\n        ('validation', DeviceValidationForm),\n        ('yubikey', YubiKeyDeviceForm),\n    )\n    condition_dict = {\n        'generator': lambda self: self.get_method() == 'generator',\n        'call': lambda self: self.get_method() == 'call',\n        'sms': lambda self: self.get_method() == 'sms',\n        'validation': lambda self: self.get_method() in ('sms', 'call'),\n        'yubikey': lambda self: self.get_method() == 'yubikey',\n    }\n    idempotent_dict = {\n        'yubikey': False,\n    }\n\n    def get_method(self):\n        method_data = self.storage.validated_step_data.get('method', {})\n        return method_data.get('method', None)\n\n    def get(self, request, *args, **kwargs):\n        \"\"\"\n        Start the setup wizard. Redirect if already enabled.\n        \"\"\"\n        if default_device(self.request.user):\n            return redirect(self.success_url)\n        return super().get(request, *args, **kwargs)\n\n    def get_form_list(self):\n        \"\"\"\n        Check if there is only one method, then skip the MethodForm from form_list\n        \"\"\"\n        form_list = super().get_form_list()\n        available_methods = get_available_methods()\n        if len(available_methods) == 1:\n            form_list.pop('method', None)\n            method_key, _ = available_methods[0]\n            self.storage.validated_step_data['method'] = {'method': method_key}\n        return form_list\n\n    def render_next_step(self, form, **kwargs):\n        \"\"\"\n        In the validation step, ask the device to generate a challenge.\n        \"\"\"\n        next_step = self.steps.next\n        if next_step == 'validation':\n            try:\n                self.get_device().generate_challenge()\n                kwargs[\"challenge_succeeded\"] = True\n            except Exception:\n                logger.exception(\"Could not generate challenge\")\n                kwargs[\"challenge_succeeded\"] = False\n        return super().render_next_step(form, **kwargs)\n\n    def done(self, form_list, **kwargs):\n        \"\"\"\n        Finish the wizard. Save all forms and redirect.\n        \"\"\"\n        # Remove secret key used for QR code generation\n        try:\n            del self.request.session[self.session_key_name]\n        except KeyError:\n            pass\n\n        # TOTPDeviceForm\n        if self.get_method() == 'generator':\n            form = [form for form in form_list if isinstance(form, TOTPDeviceForm)][0]\n            device = form.save()\n\n        # PhoneNumberForm / YubiKeyDeviceForm\n        elif self.get_method() in ('call', 'sms', 'yubikey'):\n            device = self.get_device()\n            device.save()\n\n        else:\n            raise NotImplementedError(\"Unknown method '%s'\" % self.get_method())\n\n        django_otp.login(self.request, device)\n        return redirect(self.success_url)\n\n    def get_form_kwargs(self, step=None):\n        kwargs = {}\n        if step == 'generator':\n            kwargs.update({\n                'key': self.get_key(step),\n                'user': self.request.user,\n            })\n        if step in ('validation', 'yubikey'):\n            kwargs.update({\n                'device': self.get_device()\n            })\n        metadata = self.get_form_metadata(step)\n        if metadata:\n            kwargs.update({\n                'metadata': metadata,\n            })\n        return kwargs\n\n    def get_device(self, **kwargs):\n        \"\"\"\n        Uses the data from the setup step and generated key to recreate device.\n\n        Only used for call / sms -- generator uses other procedure.\n        \"\"\"\n        method = self.get_method()\n        kwargs = kwargs or {}\n        kwargs['name'] = 'default'\n        kwargs['user'] = self.request.user\n\n        if method in ('call', 'sms'):\n            kwargs['method'] = method\n            kwargs['number'] = self.storage.validated_step_data\\\n                .get(method, {}).get('number')\n            return PhoneDevice(key=self.get_key(method), **kwargs)\n\n        if method == 'yubikey':\n            kwargs['public_id'] = self.storage.validated_step_data\\\n                .get('yubikey', {}).get('token', '')[:-32]\n            try:\n                kwargs['service'] = ValidationService.objects.get(name='default')\n            except ValidationService.DoesNotExist:\n                raise KeyError(\"No ValidationService found with name 'default'\")\n            except ValidationService.MultipleObjectsReturned:\n                raise KeyError(\"Multiple ValidationService found with name 'default'\")\n            return RemoteYubikeyDevice(**kwargs)\n\n    def get_key(self, step):\n        self.storage.extra_data.setdefault('keys', {})\n        if step in self.storage.extra_data['keys']:\n            return self.storage.extra_data['keys'].get(step)\n        key = random_hex_str(20)\n        self.storage.extra_data['keys'][step] = key\n        return key\n\n    def get_context_data(self, form, **kwargs):\n        context = super().get_context_data(form, **kwargs)\n        if self.steps.current == 'generator':\n            key = self.get_key('generator')\n            rawkey = unhexlify(key.encode('ascii'))\n            b32key = b32encode(rawkey).decode('utf-8')\n            self.request.session[self.session_key_name] = b32key\n            context.update({\n                'QR_URL': reverse(self.qrcode_url)\n            })\n        elif self.steps.current == 'validation':\n            context['device'] = self.get_device()\n        context['cancel_url'] = resolve_url(settings.LOGIN_REDIRECT_URL)\n        return context\n\n    def process_step(self, form):\n        if hasattr(form, 'metadata'):\n            self.storage.extra_data.setdefault('forms', {})\n            self.storage.extra_data['forms'][self.steps.current] = form.metadata\n        return super().process_step(form)\n\n    def get_form_metadata(self, step):\n        self.storage.extra_data.setdefault('forms', {})\n        return self.storage.extra_data['forms'].get(step, None)\n\n\n@class_view_decorator(never_cache)\n@class_view_decorator(otp_required)\nclass BackupTokensView(FormView):\n    \"\"\"\n    View for listing and generating backup tokens.\n\n    A user can generate a number of static backup tokens. When the user loses\n    its phone, these backup tokens can be used for verification. These backup\n    tokens should be stored in a safe location; either in a safe or underneath\n    a pillow ;-).\n    \"\"\"\n    form_class = Form\n    success_url = 'two_factor:backup_tokens'\n    template_name = 'two_factor/core/backup_tokens.html'\n    number_of_tokens = 10\n\n    def get_device(self):\n        return self.request.user.staticdevice_set.get_or_create(name='backup')[0]\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context['device'] = self.get_device()\n        return context\n\n    def form_valid(self, form):\n        \"\"\"\n        Delete existing backup codes and generate new ones.\n        \"\"\"\n        device = self.get_device()\n        device.token_set.all().delete()\n        for n in range(self.number_of_tokens):\n            device.token_set.create(token=StaticToken.random_token())\n\n        return redirect(self.success_url)\n\n\n@class_view_decorator(never_cache)\n@class_view_decorator(otp_required)\nclass PhoneSetupView(IdempotentSessionWizardView):\n    \"\"\"\n    View for configuring a phone number for receiving tokens.\n\n    A user can have multiple backup :class:`~two_factor.models.PhoneDevice`\n    for receiving OTP tokens. If the primary phone number is not available, as\n    the battery might have drained or the phone is lost, these backup phone\n    numbers can be used for verification.\n    \"\"\"\n    template_name = 'two_factor/core/phone_register.html'\n    success_url = settings.LOGIN_REDIRECT_URL\n    form_list = (\n        ('setup', PhoneNumberMethodForm),\n        ('validation', DeviceValidationForm),\n    )\n    key_name = 'key'\n\n    def get(self, request, *args, **kwargs):\n        \"\"\"\n        Start the setup wizard. Redirect if no phone methods available.\n        \"\"\"\n        if not get_available_phone_methods():\n            return redirect(self.success_url)\n        return super().get(request, *args, **kwargs)\n\n    def done(self, form_list, **kwargs):\n        \"\"\"\n        Store the device and redirect to profile page.\n        \"\"\"\n        self.get_device(user=self.request.user, name='backup').save()\n        return redirect(self.success_url)\n\n    def render_next_step(self, form, **kwargs):\n        \"\"\"\n        In the validation step, ask the device to generate a challenge.\n        \"\"\"\n        next_step = self.steps.next\n        if next_step == 'validation':\n            self.get_device().generate_challenge()\n        return super().render_next_step(form, **kwargs)\n\n    def get_form_kwargs(self, step=None):\n        \"\"\"\n        Provide the device to the DeviceValidationForm.\n        \"\"\"\n        if step == 'validation':\n            return {'device': self.get_device()}\n        return {}\n\n    def get_device(self, **kwargs):\n        \"\"\"\n        Uses the data from the setup step and generated key to recreate device.\n        \"\"\"\n        kwargs = kwargs or {}\n        kwargs.update(self.storage.validated_step_data.get('setup', {}))\n        return PhoneDevice(key=self.get_key(), **kwargs)\n\n    def get_key(self):\n        \"\"\"\n        The key is preserved between steps and stored as ascii in the session.\n        \"\"\"\n        if self.key_name not in self.storage.extra_data:\n            key = random_hex_str(20)\n            self.storage.extra_data[self.key_name] = key\n        return self.storage.extra_data[self.key_name]\n\n    def get_context_data(self, form, **kwargs):\n        kwargs.setdefault('cancel_url', resolve_url(self.success_url))\n        return super().get_context_data(form, **kwargs)\n\n\n@class_view_decorator(never_cache)\n@class_view_decorator(otp_required)\nclass PhoneDeleteView(DeleteView):\n    \"\"\"\n    View for removing a phone number used for verification.\n    \"\"\"\n    success_url = settings.LOGIN_REDIRECT_URL\n\n    def get_queryset(self):\n        return self.request.user.phonedevice_set.filter(name='backup')\n\n    def get_success_url(self):\n        return resolve_url(self.success_url)\n\n\n@class_view_decorator(never_cache)\n@class_view_decorator(otp_required)\nclass SetupCompleteView(TemplateView):\n    \"\"\"\n    View congratulation the user when OTP setup has completed.\n    \"\"\"\n    template_name = 'two_factor/core/setup_complete.html'\n\n    def get_context_data(self):\n        return {\n            'phone_methods': get_available_phone_methods(),\n        }\n\n\n@class_view_decorator(never_cache)\n@class_view_decorator(login_required)\nclass QRGeneratorView(View):\n    \"\"\"\n    View returns an SVG image with the OTP token information\n    \"\"\"\n    http_method_names = ['get']\n    default_qr_factory = 'qrcode.image.svg.SvgPathImage'\n    session_key_name = 'django_two_factor-qr_secret_key'\n\n    # The qrcode library only supports PNG and SVG for now\n    image_content_types = {\n        'PNG': 'image/png',\n        'SVG': 'image/svg+xml; charset=utf-8',\n    }\n\n    def get_issuer(self):\n        return get_current_site(self.request).name\n\n    def get(self, request, *args, **kwargs):\n        # Get the data from the session\n        try:\n            key = self.request.session[self.session_key_name]\n        except KeyError:\n            raise Http404()\n\n        # Get data for qrcode\n        image_factory_string = getattr(settings, 'TWO_FACTOR_QR_FACTORY', self.default_qr_factory)\n        image_factory = import_string(image_factory_string)\n        content_type = self.image_content_types[image_factory.kind]\n        try:\n            username = self.request.user.get_username()\n        except AttributeError:\n            username = self.request.user.username\n\n        otpauth_url = get_otpauth_url(accountname=username,\n                                      issuer=self.get_issuer(),\n                                      secret=key,\n                                      digits=totp_digits())\n\n        # Make and return QR code\n        img = qrcode.make(otpauth_url, image_factory=image_factory)\n        resp = HttpResponse(content_type=content_type)\n        img.save(resp)\n        return resp\n", "import logging\n\nfrom django.core.exceptions import SuspiciousOperation\nfrom django.utils.decorators import method_decorator\nfrom django.utils.translation import gettext as _\nfrom formtools.wizard.forms import ManagementForm\nfrom formtools.wizard.storage.session import SessionStorage\nfrom formtools.wizard.views import SessionWizardView\n\nlogger = logging.getLogger(__name__)\n\n\nclass ExtraSessionStorage(SessionStorage):\n    \"\"\"\n    SessionStorage that includes the property `validated_step_data` for storing\n    cleaned form data per step.\n    \"\"\"\n    validated_step_data_key = 'validated_step_data'\n\n    def init_data(self):\n        super().init_data()\n        self.data[self.validated_step_data_key] = {}\n\n    def reset(self):\n        if self.prefix in self.request.session:\n            super().reset()\n        else:\n            self.init_data()\n\n    def _get_validated_step_data(self):\n        return self.data[self.validated_step_data_key]\n\n    def _set_validated_step_data(self, validated_step_data):\n        self.data[self.validated_step_data_key] = validated_step_data\n\n    validated_step_data = property(_get_validated_step_data,\n                                   _set_validated_step_data)\n\n\nclass IdempotentSessionWizardView(SessionWizardView):\n    \"\"\"\n    WizardView that allows certain steps to be marked non-idempotent, in which\n    case the form is only validated once and the cleaned values stored.\n    \"\"\"\n    storage_name = 'two_factor.views.utils.ExtraSessionStorage'\n    idempotent_dict = {}\n\n    def is_step_visible(self, step):\n        \"\"\"\n        Returns whether the given `step` should be included in the wizard; it\n        is included if either the form is idempotent or not filled in before.\n        \"\"\"\n        return self.idempotent_dict.get(step, True) or \\\n            step not in self.storage.validated_step_data\n\n    def get_prev_step(self, step=None):\n        \"\"\"\n        Returns the previous step before the given `step`. If there are no\n        steps available, None will be returned. If the `step` argument is\n        None, the current step will be determined automatically.\n        \"\"\"\n        if step is None:\n            step = self.steps.current\n        form_list = self.get_form_list()\n        keys = list(form_list.keys())\n        key = keys.index(step) - 1\n        if key >= 0:\n            for prev_step in keys[key::-1]:\n                if self.is_step_visible(prev_step):\n                    return prev_step\n        return None\n\n    def get_next_step(self, step=None):\n        \"\"\"\n        Returns the next step after the given `step`. If no more steps are\n        available, None will be returned. If the `step` argument is None, the\n        current step will be determined automatically.\n        \"\"\"\n        if step is None:\n            step = self.steps.current\n        form_list = self.get_form_list()\n        keys = list(form_list.keys())\n        key = keys.index(step) + 1\n        for next_step in keys[key:]:\n            if self.is_step_visible(next_step):\n                return next_step\n        return None\n\n    def post(self, *args, **kwargs):\n        \"\"\"\n        Check if the current step is still available. It might not be if\n        conditions have changed.\n        \"\"\"\n        if self.steps.current not in self.steps.all:\n            logger.warning(\"Current step '%s' is no longer valid, returning \"\n                           \"to last valid step in the wizard.\",\n                           self.steps.current)\n            return self.render_goto_step(self.steps.all[-1])\n\n        # -- Duplicated code from upstream\n        # Look for a wizard_goto_step element in the posted data which\n        # contains a valid step name. If one was found, render the requested\n        # form. (This makes stepping back a lot easier).\n        wizard_goto_step = self.request.POST.get('wizard_goto_step', None)\n        if wizard_goto_step and wizard_goto_step in self.get_form_list():\n            return self.render_goto_step(wizard_goto_step)\n\n        # Check if form was refreshed\n        management_form = ManagementForm(self.request.POST, prefix=self.prefix)\n        if not management_form.is_valid():\n            raise SuspiciousOperation(_('ManagementForm data is missing or has been tampered with'))\n\n        form_current_step = management_form.cleaned_data['current_step']\n        if (form_current_step != self.steps.current\n                and self.storage.current_step is not None):\n            # form refreshed, change current step\n            self.storage.current_step = form_current_step\n        # -- End duplicated code from upstream\n\n        # This is different from the first check, as this checks\n        # if the new step is available. See issue #65.\n        if self.steps.current not in self.steps.all:\n            logger.warning(\"Requested step '%s' is no longer valid, returning \"\n                           \"to last valid step in the wizard.\",\n                           self.steps.current)\n            return self.render_goto_step(self.steps.all[-1])\n\n        return super().post(*args, **kwargs)\n\n    def process_step(self, form):\n        \"\"\"\n        Stores the validated data for `form` and cleans out validated forms\n        for next steps, as those might be affected by the current step. Note\n        that this behaviour is relied upon by the `LoginView` to prevent users\n        from bypassing the `TokenForm` by going steps back and changing\n        credentials.\n        \"\"\"\n        step = self.steps.current\n\n        # If the form is not-idempotent (cannot be validated multiple times),\n        # the cleaned data should be stored; marking the form as validated.\n        self.storage.validated_step_data[step] = form.cleaned_data\n\n        # It is assumed that earlier steps affect later steps; so even though\n        # those forms might not be idempotent, we'll remove the validated data\n        # to force re-entry.\n        # form_list = self.get_form_list(idempotent=False)\n        form_list = self.get_form_list()\n        keys = list(form_list.keys())\n        key = keys.index(step) + 1\n        for next_step in keys[key:]:\n            self.storage.validated_step_data.pop(next_step, None)\n\n        return super().process_step(form)\n\n    def render_done(self, form, **kwargs):\n        \"\"\"\n        This method gets called when all forms passed. The method should also\n        re-validate all steps to prevent manipulation. If any form don't\n        validate, `render_revalidation_failure` should get called.\n        If everything is fine call `done`.\n        \"\"\"\n        final_form_list = []\n        # walk through the form list and try to validate the data again.\n        for form_key in self.get_form_list():\n            form_obj = self.get_form(step=form_key,\n                                     data=self.storage.get_step_data(form_key),\n                                     files=self.storage.get_step_files(\n                                         form_key))\n            if not (form_key in self.idempotent_dict or form_obj.is_valid()):\n                return self.render_revalidation_failure(form_key, form_obj,\n                                                        **kwargs)\n            final_form_list.append(form_obj)\n\n        # render the done view and reset the wizard before returning the\n        # response. This is needed to prevent from rendering done with the\n        # same data twice.\n        done_response = self.done(final_form_list, **kwargs)\n        self.storage.reset()\n        return done_response\n\n\ndef class_view_decorator(function_decorator):\n    \"\"\"\n    Converts a function based decorator into a class based decorator usable\n    on class based Views.\n\n    Can't subclass the `View` as it breaks inheritance (super in particular),\n    so we monkey-patch instead.\n\n    From: http://stackoverflow.com/a/8429311/58107\n    \"\"\"\n    def simple_decorator(View):\n        View.dispatch = method_decorator(function_decorator)(View.dispatch)\n        return View\n    return simple_decorator\n"], "fixing_code": ["## [Unreleased]\n### Added\n- It is possible to set a timeout between a user authenticiating in the LoginView and them needing to re-authenticate. By default this is 10 minutes.\n\n### Removed\n- The final step in the LoginView no longer re-validates a user's credentials\n\n### Changed\n- Security Fix: LoginView no longer stores credentials in plaintext in the session store\n\n## 1.11.0 - 2020-03-13\n### Added\n\n*Nothing has been added for this version*\n\n### Removed\n- MiddlewareMixin\n- Python 3.4 support\n- Django 2.1 support\n- `mock` dependency\n\n### Changed\n- `extra_requires` are now listed in lowercase. This is to workaround a bug in `pip`.\n- Use `trimmed` option on `blocktrans` to avoid garbage newlines in translations.\n- `random_hex` from `django_otp` 0.8.0 will always return a `str`, don't try to decode it.\n\n## 1.10.0 - 2019-12-13\n### Added\n- Support for Django 3.0.\n- Optionally install full or light phonenumbers library.\n\n### Removed\n- Python 2 support.\n\n### Changed\n- Updated translations.\n\n## 1.9.1 - 2019-07-07\n### Changed\n- 1.9.0 got pushed with incorrect changelog, no other changes.\n\n## 1.9.0 - 2019-07-07\n### Added\n- Support for Django 2.2.\n- Ability to create `PhoneDevice` from Django admin.\n- Support for Python 3.7.\n\n## 1.8.0 - 2018-08-03\n### Added\n- Support for Django 2.1.\n- Support for QRcode library up to 6.\n- Translation: Romanian.\n\n### Changed\n- Replace `ValidationError` with `SuspiciousOperation` in views.\n- Change the wording in 2FA disable template.\n- Updated translations.\n\n## 1.7.0 - 2017-12-19\n### Added\n- Support for Django 2.0.\n\n### Removed\n- Django <1.11 support.\n\n### Changed\n- Do not list phone method if it is not supported (#225).\n- Pass request kwarg to authentication form (#227).\n\n## 1.6.2 - 2017-07-29\n### Fixed\n- Twilio client 6.0 usage (#211).\n\n### Changed\n- Updated translation: Russian.\n\n## 1.6.1 - 2017-05-11\n### Added\n- Support Twilio client 6.0 (#203).\n\n### Fixed\n- `redirect_to` after successful login (#204)\n\n### Changed\n- Updated translation: Norwegian Bokm\u00e5l\n\n## 1.6.0 - 2017-04-08\n### Added\n- Support for Django 1.11 (#188).\n\n### Removed\n- Django 1.9 support.\n\n### Fixed\n- Allow setting `LOGIN_REDIRECT_URL` to a URL (#192).\n- `DisableView` should also take `success_url` parameter (#187).\n\n## 1.5.0 - 2017-01-04\n### Added\n- Django 1.10\u2019s MIDDLEWARE support.\n- Allow `success_url` overrides from `urls.py`.\n- Autofocus token input during authentication.\n- Translations: Polish, Italian, Hungarian, Finnish and Danish.\n\n### Removed\n- Dropped Python 3.2 and 3.3 support.\n\n### Changed\n- Renamed `redirect_url` properties to `success_url` to be consistent with Django.\n\n### Fixed\n- Allow Firefox users to enter backup tokens (#177).\n- Allow multiple requests for QR code (#99).\n- Don't add phone number without gateway (#92).\n- Redirect to 2FA profile page after removing a phone (#159).\n", "Configuration\n=============\n\nGeneral Settings\n----------------\n\n``TWO_FACTOR_PATCH_ADMIN`` (default: ``True``)\n  Whether the Django admin is patched to use the default login view.\n\n  .. warning::\n     The admin currently does not enforce one-time passwords being set for\n     admin users.\n\n``TWO_FACTOR_CALL_GATEWAY`` (default: ``None``)\n  Which gateway to use for making phone calls. Should be set to a module or\n  object providing a ``make_call`` method. Currently two gateways are bundled:\n\n  * ``'two_factor.gateways.twilio.gateway.Twilio'`` for making real phone calls using\n    Twilio_.\n  * ``'two_factor.gateways.fake.Fake'``  for development, recording tokens to the\n    default logger.\n\n``TWO_FACTOR_SMS_GATEWAY`` (default: ``None``)\n  Which gateway to use for sending text messages. Should be set to a module or\n  object providing a ``send_sms`` method. Currently two gateways are bundled:\n\n  * ``'two_factor.gateways.twilio.gateway.Twilio'`` for sending real text messages using\n    Twilio_.\n  * ``'two_factor.gateways.fake.Fake'``  for development, recording tokens to the\n    default logger.\n\n``LOGIN_URL``\n  Should point to the login view provided by this application as described in\n  setup. This login view handles password authentication followed by a one-time\n  password exchange if enabled for that account. This can be a URL path or URL\n  name as defined in the Django documentation.\n\n  See also LOGIN_URL_.\n\n``LOGIN_REDIRECT_URL``\n  This application provides a basic page for managing one's account. This view\n  is entirely optional and could be implemented in a custom view. This can be a\n  URL path or URL name as defined in the Django documentation.\n\n  See also LOGIN_REDIRECT_URL_.\n\n``LOGOUT_REDIRECT_URL``\n  Should point to a view that the user is redirected to after loging out. It was\n  added in Django 1.10, and also adapted by this application. This can be a\n  URL path or URL name as defined in the Django documentation.\n\n  See also LOGOUT_REDIRECT_URL_.\n\n``TWO_FACTOR_QR_FACTORY``\n  The default generator for the QR code images is set to SVG. This\n  does not require any further dependencies, however it does not work\n  on IE8 and below. If you have PIL, Pillow or pyimaging installed\n  you may wish to use PNG images instead.\n\n  * ``'qrcode.image.pil.PilImage'`` may be used for PIL/Pillow\n  * ``'qrcode.image.pure.PymagingImage'`` may be used for pyimaging\n\n  For more QR factories that are available see python-qrcode_.\n\n``TWO_FACTOR_TOTP_DIGITS`` (default: ``6``)\n  The number of digits to use for TOTP tokens, can be set to 6 or 8. This\n  setting will be used for tokens delivered by phone call or text message and\n  newly configured token generators. Existing token generator devices will not\n  be affected.\n\n  .. warning::\n     The Google Authenticator app does not support 8 digit codes (see\n     `the upstream ticket`_). Don't set this option to 8 unless all of your\n     users use a 8 digit compatible token generator app.\n\n``TWO_FACTOR_LOGIN_TIMEOUT`` (default ``600``)\n  The number of seconds between a user successfully passing the \"authentication\"\n  step (usually by entering a valid username and password) and them having to\n  restart the login flow and re-authenticate. This ensures that users can't sit\n  indefinately in a state of having entered their password successfully but not\n  having passed two factor authentication. Set to ``0`` to disable.\n\n``PHONENUMBER_DEFAULT_REGION`` (default: ``None``)\n  The default region for parsing phone numbers. If your application's primary\n  audience is a certain country, setting the region to that country allows\n  entering phone numbers without that country's country code.\n\nTwilio Gateway\n--------------\nTo use the Twilio gateway, you need first to install the `Twilio client`_:\n\n.. code-block:: console\n\n    $ pip install twilio\n\nNext, add additional urls to your config:\n\n.. code-block:: python\n\n    # urls.py\n    from two_factor.gateways.twilio.urls import urlpatterns as tf_twilio_urls\n    urlpatterns = [\n        url(r'', include(tf_twilio_urls)),\n        ...\n    ]\n\nAdditionally, you need to enable the ``ThreadLocals`` middleware:\n\n.. code-block:: python\n\n    MIDDLEWARE = (\n        ...\n\n        # Always include for two-factor auth\n        'django_otp.middleware.OTPMiddleware',\n\n        # Include for twilio gateway\n        'two_factor.middleware.threadlocals.ThreadLocals',\n    )\n\n\n.. autoclass:: two_factor.gateways.twilio.gateway.Twilio\n\nFake Gateway\n------------\n.. autoclass:: two_factor.gateways.fake.Fake\n\n.. _LOGIN_URL: https://docs.djangoproject.com/en/dev/ref/settings/#login-url\n.. _LOGIN_REDIRECT_URL: https://docs.djangoproject.com/en/dev/ref/settings/#login-redirect-url\n.. _LOGOUT_REDIRECT_URL: https://docs.djangoproject.com/en/dev/ref/settings/#logout-redirect-url\n.. _Twilio: http://www.twilio.com/\n.. _`Twilio client`: https://pypi.python.org/pypi/twilio\n.. _python-qrcode: https://pypi.python.org/pypi/qrcode\n.. _`the upstream ticket`: https://code.google.com/p/google-authenticator/issues/detail?id=327\n", "import json\nfrom unittest import mock\n\nfrom django.conf import settings\nfrom django.shortcuts import resolve_url\nfrom django.test import TestCase\nfrom django.test.utils import override_settings\nfrom django.urls import reverse\nfrom django_otp import DEVICE_ID_SESSION_KEY\nfrom django_otp.oath import totp\n\nfrom two_factor.models import random_hex_str\n\nfrom .utils import UserMixin\n\n\nclass LoginTest(UserMixin, TestCase):\n    def _post(self, data=None):\n        return self.client.post(reverse('two_factor:login'), data=data)\n\n    def test_form(self):\n        response = self.client.get(reverse('two_factor:login'))\n        self.assertContains(response, 'Password:')\n\n    def test_invalid_login(self):\n        response = self._post({'auth-username': 'unknown',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertContains(response, 'Please enter a correct')\n        self.assertContains(response, 'and password.')\n\n    @mock.patch('two_factor.views.core.signals.user_verified.send')\n    def test_valid_login(self, mock_signal):\n        self.create_user()\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertRedirects(response, resolve_url(settings.LOGIN_REDIRECT_URL))\n\n        # No signal should be fired for non-verified user logins.\n        self.assertFalse(mock_signal.called)\n\n    def test_valid_login_with_custom_redirect(self):\n        redirect_url = reverse('two_factor:setup')\n        self.create_user()\n        response = self.client.post(\n            '%s?%s' % (reverse('two_factor:login'), 'next=' + redirect_url),\n            {'auth-username': 'bouke@example.com',\n             'auth-password': 'secret',\n             'login_view-current_step': 'auth'})\n        self.assertRedirects(response, redirect_url)\n\n    def test_valid_login_with_custom_post_redirect(self):\n        redirect_url = reverse('two_factor:setup')\n        self.create_user()\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth',\n                               'next': redirect_url})\n        self.assertRedirects(response, redirect_url)\n\n    def test_valid_login_with_redirect_field_name(self):\n        redirect_url = reverse('two_factor:setup')\n        self.create_user()\n        response = self.client.post(\n            '%s?%s' % (reverse('custom-field-name-login'), 'next_page=' + redirect_url),\n            {'auth-username': 'bouke@example.com',\n             'auth-password': 'secret',\n             'login_view-current_step': 'auth'})\n        self.assertRedirects(response, redirect_url)\n\n    def test_valid_login_with_allowed_external_redirect(self):\n        redirect_url = 'https://test.allowed-success-url.com'\n        self.create_user()\n        response = self.client.post(\n            '%s?%s' % (reverse('custom-allowed-success-url-login'), 'next=' + redirect_url),\n            {'auth-username': 'bouke@example.com',\n             'auth-password': 'secret',\n             'login_view-current_step': 'auth'})\n        self.assertRedirects(response, redirect_url, fetch_redirect_response=False)\n\n    def test_valid_login_with_disallowed_external_redirect(self):\n        redirect_url = 'https://test.disallowed-success-url.com'\n        self.create_user()\n        response = self.client.post(\n            '%s?%s' % (reverse('custom-allowed-success-url-login'), 'next=' + redirect_url),\n            {'auth-username': 'bouke@example.com',\n             'auth-password': 'secret',\n             'login_view-current_step': 'auth'})\n        self.assertRedirects(response, reverse('two_factor:profile'), fetch_redirect_response=False)\n\n    @mock.patch('two_factor.views.core.time')\n    def test_valid_login_primary_key_stored(self, mock_time):\n        mock_time.time.return_value = 12345.12\n        user = self.create_user()\n        user.totpdevice_set.create(name='default',\n                                   key=random_hex_str())\n\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertContains(response, 'Token:')\n\n        self.assertEqual(self.client.session['wizard_login_view']['user_pk'], str(user.pk))\n        self.assertEqual(\n            self.client.session['wizard_login_view']['user_backend'],\n            'django.contrib.auth.backends.ModelBackend')\n        self.assertEqual(self.client.session['wizard_login_view']['authentication_time'], 12345)\n\n    @mock.patch('two_factor.views.core.time')\n    def test_valid_login_post_auth_session_clear_of_form_data(self, mock_time):\n        mock_time.time.return_value = 12345.12\n        user = self.create_user()\n        user.totpdevice_set.create(name='default',\n                                   key=random_hex_str())\n\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertContains(response, 'Token:')\n\n        self.assertEqual(self.client.session['wizard_login_view']['user_pk'], str(user.pk))\n        self.assertEqual(self.client.session['wizard_login_view']['step'], 'token')\n        self.assertEqual(self.client.session['wizard_login_view']['step_data'], {'auth': None})\n        self.assertEqual(self.client.session['wizard_login_view']['step_files'], {'auth': {}})\n        self.assertEqual(self.client.session['wizard_login_view']['validated_step_data'], {})\n\n    @mock.patch('two_factor.views.core.logger')\n    @mock.patch('two_factor.views.core.time')\n    def test_valid_login_expired(self, mock_time, mock_logger):\n        mock_time.time.return_value = 12345.12\n        user = self.create_user()\n        device = user.totpdevice_set.create(name='default',\n                                            key=random_hex_str())\n\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertContains(response, 'Token:')\n\n        self.assertEqual(self.client.session['wizard_login_view']['user_pk'], str(user.pk))\n        self.assertEqual(\n            self.client.session['wizard_login_view']['user_backend'],\n            'django.contrib.auth.backends.ModelBackend')\n        self.assertEqual(self.client.session['wizard_login_view']['authentication_time'], 12345)\n\n        mock_time.time.return_value = 20345.12\n\n        response = self._post({'token-otp_token': totp(device.bin_key),\n                               'login_view-current_step': 'token'})\n        self.assertEqual(response.status_code, 200)\n        self.assertNotContains(response, 'Token:')\n        self.assertContains(response, 'Password:')\n        self.assertContains(response, 'Your session has timed out. Please login again.')\n\n        # Check that a message was logged.\n        mock_logger.info.assert_called_with(\n            \"User's authentication flow has timed out. The user \"\n            \"has been redirected to the initial auth form.\")\n\n    @override_settings(TWO_FACTOR_LOGIN_TIMEOUT=0)\n    @mock.patch('two_factor.views.core.time')\n    def test_valid_login_no_timeout(self, mock_time):\n        mock_time.time.return_value = 12345.12\n        user = self.create_user()\n        device = user.totpdevice_set.create(name='default',\n                                            key=random_hex_str())\n\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertContains(response, 'Token:')\n\n        self.assertEqual(self.client.session['wizard_login_view']['user_pk'], str(user.pk))\n        self.assertEqual(\n            self.client.session['wizard_login_view']['user_backend'],\n            'django.contrib.auth.backends.ModelBackend')\n        self.assertEqual(self.client.session['wizard_login_view']['authentication_time'], 12345)\n\n        mock_time.time.return_value = 20345.12\n\n        response = self._post({'token-otp_token': totp(device.bin_key),\n                               'login_view-current_step': 'token'})\n        self.assertRedirects(response, resolve_url(settings.LOGIN_REDIRECT_URL))\n        self.assertEqual(self.client.session['_auth_user_id'], str(user.pk))\n\n    def test_valid_login_with_redirect_authenticated_user(self):\n        user = self.create_user()\n        response = self.client.get(\n            reverse('custom-redirect-authenticated-user-login')\n        )\n        self.assertEqual(response.status_code, 200)\n        self.client.force_login(user)\n        response = self.client.get(\n            reverse('custom-redirect-authenticated-user-login')\n        )\n        self.assertRedirects(response, reverse('two_factor:profile'))\n\n    def test_valid_login_with_redirect_authenticated_user_loop(self):\n        redirect_url = reverse('custom-redirect-authenticated-user-login')\n        user = self.create_user()\n        self.client.force_login(user)\n        with self.assertRaises(ValueError):\n            self.client.get(\n                '%s?%s' % (reverse('custom-redirect-authenticated-user-login'), 'next=' + redirect_url),\n            )\n\n    @mock.patch('two_factor.views.core.signals.user_verified.send')\n    def test_with_generator(self, mock_signal):\n        user = self.create_user()\n        device = user.totpdevice_set.create(name='default',\n                                            key=random_hex_str())\n\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertContains(response, 'Token:')\n\n        response = self._post({'token-otp_token': '123456',\n                               'login_view-current_step': 'token'})\n        self.assertEqual(response.context_data['wizard']['form'].errors,\n                         {'__all__': ['Invalid token. Please make sure you '\n                                      'have entered it correctly.']})\n\n        # reset throttle because we're not testing that\n        device.throttle_reset()\n\n        response = self._post({'token-otp_token': totp(device.bin_key),\n                               'login_view-current_step': 'token'})\n        self.assertRedirects(response, resolve_url(settings.LOGIN_REDIRECT_URL))\n\n        self.assertEqual(device.persistent_id,\n                         self.client.session.get(DEVICE_ID_SESSION_KEY))\n\n        # Check that the signal was fired.\n        mock_signal.assert_called_with(sender=mock.ANY, request=mock.ANY, user=user, device=device)\n\n    @mock.patch('two_factor.views.core.signals.user_verified.send')\n    def test_throttle_with_generator(self, mock_signal):\n        user = self.create_user()\n        device = user.totpdevice_set.create(name='default',\n                                            key=random_hex_str())\n\n        self._post({'auth-username': 'bouke@example.com',\n                    'auth-password': 'secret',\n                    'login_view-current_step': 'auth'})\n\n        # throttle device\n        device.throttle_increment()\n\n        response = self._post({'token-otp_token': totp(device.bin_key),\n                               'login_view-current_step': 'token'})\n        self.assertEqual(response.context_data['wizard']['form'].errors,\n                         {'__all__': ['Invalid token. Please make sure you '\n                                      'have entered it correctly.']})\n\n    @mock.patch('two_factor.gateways.fake.Fake')\n    @mock.patch('two_factor.views.core.signals.user_verified.send')\n    @override_settings(\n        TWO_FACTOR_SMS_GATEWAY='two_factor.gateways.fake.Fake',\n        TWO_FACTOR_CALL_GATEWAY='two_factor.gateways.fake.Fake',\n    )\n    def test_with_backup_phone(self, mock_signal, fake):\n        user = self.create_user()\n        for no_digits in (6, 8):\n            with self.settings(TWO_FACTOR_TOTP_DIGITS=no_digits):\n                user.totpdevice_set.create(name='default', key=random_hex_str(),\n                                           digits=no_digits)\n                device = user.phonedevice_set.create(name='backup', number='+31101234567',\n                                                     method='sms',\n                                                     key=random_hex_str())\n\n                # Backup phones should be listed on the login form\n                response = self._post({'auth-username': 'bouke@example.com',\n                                       'auth-password': 'secret',\n                                       'login_view-current_step': 'auth'})\n                self.assertContains(response, 'Send text message to +31 ** *** **67')\n\n                # Ask for challenge on invalid device\n                response = self._post({'auth-username': 'bouke@example.com',\n                                       'auth-password': 'secret',\n                                       'challenge_device': 'MALICIOUS/INPUT/666'})\n                self.assertContains(response, 'Send text message to +31 ** *** **67')\n\n                # Ask for SMS challenge\n                response = self._post({'auth-username': 'bouke@example.com',\n                                       'auth-password': 'secret',\n                                       'challenge_device': device.persistent_id})\n                self.assertContains(response, 'We sent you a text message')\n                fake.return_value.send_sms.assert_called_with(\n                    device=device,\n                    token=str(totp(device.bin_key, digits=no_digits)).zfill(no_digits))\n\n                # Ask for phone challenge\n                device.method = 'call'\n                device.save()\n                response = self._post({'auth-username': 'bouke@example.com',\n                                       'auth-password': 'secret',\n                                       'challenge_device': device.persistent_id})\n                self.assertContains(response, 'We are calling your phone right now')\n                fake.return_value.make_call.assert_called_with(\n                    device=device,\n                    token=str(totp(device.bin_key, digits=no_digits)).zfill(no_digits))\n\n            # Valid token should be accepted.\n            response = self._post({'token-otp_token': totp(device.bin_key),\n                                   'login_view-current_step': 'token'})\n            self.assertRedirects(response, resolve_url(settings.LOGIN_REDIRECT_URL))\n            self.assertEqual(device.persistent_id,\n                             self.client.session.get(DEVICE_ID_SESSION_KEY))\n\n            # Check that the signal was fired.\n            mock_signal.assert_called_with(sender=mock.ANY, request=mock.ANY, user=user, device=device)\n\n    @mock.patch('two_factor.views.core.signals.user_verified.send')\n    def test_with_backup_token(self, mock_signal):\n        user = self.create_user()\n        user.totpdevice_set.create(name='default', key=random_hex_str())\n        device = user.staticdevice_set.create(name='backup')\n        device.token_set.create(token='abcdef123')\n\n        # Backup phones should be listed on the login form\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertContains(response, 'Backup Token')\n\n        # Should be able to go to backup tokens step in wizard\n        response = self._post({'wizard_goto_step': 'backup'})\n        self.assertContains(response, 'backup tokens')\n\n        # Wrong codes should not be accepted\n        response = self._post({'backup-otp_token': 'WRONG',\n                               'login_view-current_step': 'backup'})\n        self.assertEqual(response.context_data['wizard']['form'].errors,\n                         {'__all__': ['Invalid token. Please make sure you '\n                                      'have entered it correctly.']})\n        # static devices are throttled\n        device.throttle_reset()\n\n        # Valid token should be accepted.\n        response = self._post({'backup-otp_token': 'abcdef123',\n                               'login_view-current_step': 'backup'})\n        self.assertRedirects(response, resolve_url(settings.LOGIN_REDIRECT_URL))\n\n        # Check that the signal was fired.\n        mock_signal.assert_called_with(sender=mock.ANY, request=mock.ANY, user=user, device=device)\n\n    @mock.patch('two_factor.views.utils.logger')\n    def test_reset_wizard_state(self, mock_logger):\n        self.create_user()\n        self.enable_otp()\n\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertContains(response, 'Token:')\n\n        # A GET request resets the state of the wizard...\n        self.client.get(reverse('two_factor:login'))\n\n        # ...so there is no user in this request anymore. As the login flow\n        # depends on a user being present, this should be handled gracefully.\n        response = self._post({'token-otp_token': '123456',\n                               'login_view-current_step': 'token'})\n        self.assertContains(response, 'Password:')\n\n        # Check that a message was logged.\n        mock_logger.warning.assert_called_with(\n            \"Requested step '%s' is no longer valid, returning to last valid \"\n            \"step in the wizard.\",\n            'token')\n\n    @mock.patch('two_factor.views.utils.logger')\n    def test_login_different_user_on_existing_session(self, mock_logger):\n        \"\"\"\n        This test reproduces the issue where a user is logged in and a different user\n        attempts to login.\n        \"\"\"\n        self.create_user()\n        self.create_user(username='vedran@example.com')\n\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertRedirects(response, resolve_url(settings.LOGIN_REDIRECT_URL))\n\n        response = self._post({'auth-username': 'vedran@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertRedirects(response, resolve_url(settings.LOGIN_REDIRECT_URL))\n\n    def test_missing_management_data(self):\n        # missing management data\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret'})\n\n        # view should return HTTP 400 Bad Request\n        self.assertEqual(response.status_code, 400)\n\n    def test_no_password_in_session(self):\n        self.create_user()\n        self.enable_otp()\n\n        response = self._post({'auth-username': 'bouke@example.com',\n                               'auth-password': 'secret',\n                               'login_view-current_step': 'auth'})\n        self.assertContains(response, 'Token:')\n\n        session_contents = json.dumps(list(self.client.session.items()))\n\n        self.assertNotIn('secret', session_contents)\n\n\nclass BackupTokensTest(UserMixin, TestCase):\n    def setUp(self):\n        super().setUp()\n        self.create_user()\n        self.enable_otp()\n        self.login_user()\n\n    def test_empty(self):\n        response = self.client.get(reverse('two_factor:backup_tokens'))\n        self.assertContains(response, 'You don\\'t have any backup codes yet.')\n\n    def test_generate(self):\n        url = reverse('two_factor:backup_tokens')\n\n        response = self.client.post(url)\n        self.assertRedirects(response, url)\n\n        response = self.client.get(url)\n        first_set = set([token.token for token in\n                        response.context_data['device'].token_set.all()])\n        self.assertNotContains(response, 'You don\\'t have any backup codes '\n                                         'yet.')\n        self.assertEqual(10, len(first_set))\n\n        # Generating the tokens should give a fresh set\n        self.client.post(url)\n        response = self.client.get(url)\n        second_set = set([token.token for token in\n                         response.context_data['device'].token_set.all()])\n        self.assertNotEqual(first_set, second_set)\n", "import logging\nimport warnings\nfrom base64 import b32encode\nfrom binascii import unhexlify\nimport time\n\nimport django_otp\nimport qrcode\nimport qrcode.image.svg\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME, login\nfrom django.contrib.auth.decorators import login_required\nfrom django.contrib.auth.forms import AuthenticationForm\nfrom django.contrib.auth.views import SuccessURLAllowedHostsMixin\nfrom django.contrib.sites.shortcuts import get_current_site\nfrom django.forms import Form, ValidationError\nfrom django.http import Http404, HttpResponse, HttpResponseRedirect\nfrom django.shortcuts import redirect, resolve_url\nfrom django.urls import reverse\nfrom django.utils.decorators import method_decorator\nfrom django.utils.functional import cached_property\nfrom django.utils.http import is_safe_url\nfrom django.utils.module_loading import import_string\nfrom django.utils.translation import gettext as _\nfrom django.views.decorators.cache import never_cache\nfrom django.views.decorators.csrf import csrf_protect\nfrom django.views.decorators.debug import sensitive_post_parameters\nfrom django.views.generic import DeleteView, FormView, TemplateView\nfrom django.views.generic.base import View\nfrom django_otp.decorators import otp_required\nfrom django_otp.plugins.otp_static.models import StaticDevice, StaticToken\n\nfrom two_factor import signals\nfrom two_factor.models import get_available_methods, random_hex_str\nfrom two_factor.utils import totp_digits\n\nfrom ..forms import (\n    AuthenticationTokenForm, BackupTokenForm, DeviceValidationForm, MethodForm,\n    PhoneNumberForm, PhoneNumberMethodForm, TOTPDeviceForm, YubiKeyDeviceForm,\n)\nfrom ..models import PhoneDevice, get_available_phone_methods\nfrom ..utils import backup_phones, default_device, get_otpauth_url\nfrom .utils import IdempotentSessionWizardView, class_view_decorator\n\ntry:\n    from otp_yubikey.models import ValidationService, RemoteYubikeyDevice\nexcept ImportError:\n    ValidationService = RemoteYubikeyDevice = None\n\n\nlogger = logging.getLogger(__name__)\n\n\n@class_view_decorator(sensitive_post_parameters())\n@class_view_decorator(never_cache)\nclass LoginView(SuccessURLAllowedHostsMixin, IdempotentSessionWizardView):\n    \"\"\"\n    View for handling the login process, including OTP verification.\n\n    The login process is composed like a wizard. The first step asks for the\n    user's credentials. If the credentials are correct, the wizard proceeds to\n    the OTP verification step. If the user has a default OTP device configured,\n    that device is asked to generate a token (send sms / call phone) and the\n    user is asked to provide the generated token. The backup devices are also\n    listed, allowing the user to select a backup device for verification.\n    \"\"\"\n    template_name = 'two_factor/core/login.html'\n    form_list = (\n        ('auth', AuthenticationForm),\n        ('token', AuthenticationTokenForm),\n        ('backup', BackupTokenForm),\n    )\n    idempotent_dict = {\n        'token': False,\n        'backup': False,\n    }\n    redirect_authenticated_user = False\n    storage_name = 'two_factor.views.utils.LoginStorage'\n\n    def has_token_step(self):\n        return default_device(self.get_user())\n\n    def has_backup_step(self):\n        return default_device(self.get_user()) and \\\n            'token' not in self.storage.validated_step_data\n\n    @cached_property\n    def expired(self):\n        login_timeout = getattr(settings, 'TWO_FACTOR_LOGIN_TIMEOUT', 600)\n        if login_timeout == 0:\n            return False\n        expiration_time = self.storage.data.get(\"authentication_time\", 0) + login_timeout\n        return int(time.time()) > expiration_time\n\n    condition_dict = {\n        'token': has_token_step,\n        'backup': has_backup_step,\n    }\n    redirect_field_name = REDIRECT_FIELD_NAME\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.user_cache = None\n        self.device_cache = None\n        self.show_timeout_error = False\n\n    def post(self, *args, **kwargs):\n        \"\"\"\n        The user can select a particular device to challenge, being the backup\n        devices added to the account.\n        \"\"\"\n        wizard_goto_step = self.request.POST.get('wizard_goto_step', None)\n\n        if wizard_goto_step == 'auth':\n            self.storage.reset()\n\n        if self.expired and self.steps.current != 'auth':\n            logger.info(\"User's authentication flow has timed out. The user \"\n                        \"has been redirected to the initial auth form.\")\n            self.storage.reset()\n            self.show_timeout_error = True\n            return self.render_goto_step('auth')\n\n        # Generating a challenge doesn't require to validate the form.\n        if 'challenge_device' in self.request.POST:\n            return self.render_goto_step('token')\n\n        return super().post(*args, **kwargs)\n\n    def done(self, form_list, **kwargs):\n        \"\"\"\n        Login the user and redirect to the desired page.\n        \"\"\"\n        login(self.request, self.get_user())\n\n        redirect_to = self.get_success_url()\n\n        device = getattr(self.get_user(), 'otp_device', None)\n        if device:\n            signals.user_verified.send(sender=__name__, request=self.request,\n                                       user=self.get_user(), device=device)\n        return redirect(redirect_to)\n\n    # Copied from django.conrib.auth.views.LoginView (Branch: stable/1.11.x)\n    # https://github.com/django/django/blob/58df8aa40fe88f753ba79e091a52f236246260b3/django/contrib/auth/views.py#L63\n    def get_success_url(self):\n        url = self.get_redirect_url()\n        return url or resolve_url(settings.LOGIN_REDIRECT_URL)\n\n    # Copied from django.conrib.auth.views.LoginView (Branch: stable/1.11.x)\n    # https://github.com/django/django/blob/58df8aa40fe88f753ba79e091a52f236246260b3/django/contrib/auth/views.py#L67\n    def get_redirect_url(self):\n        \"\"\"Return the user-originating redirect URL if it's safe.\"\"\"\n        redirect_to = self.request.POST.get(\n            self.redirect_field_name,\n            self.request.GET.get(self.redirect_field_name, '')\n        )\n        url_is_safe = is_safe_url(\n            url=redirect_to,\n            allowed_hosts=self.get_success_url_allowed_hosts(),\n            require_https=self.request.is_secure(),\n        )\n        return redirect_to if url_is_safe else ''\n\n    def get_form_kwargs(self, step=None):\n        \"\"\"\n        AuthenticationTokenForm requires the user kwarg.\n        \"\"\"\n        if step == 'auth':\n            return {\n                'request': self.request\n            }\n        if step in ('token', 'backup'):\n            return {\n                'user': self.get_user(),\n                'initial_device': self.get_device(step),\n            }\n        return {}\n\n    def get_done_form_list(self):\n        \"\"\"\n        Return the forms that should be processed during the final step\n        \"\"\"\n        # Intentionally do not process the auth form on the final step. We\n        # haven't stored this data, and it isn't required to login the user\n        form_list = self.get_form_list()\n        form_list.pop('auth')\n        return form_list\n\n    def process_step(self, form):\n        \"\"\"\n        Process an individual step in the flow\n        \"\"\"\n        # To prevent saving any private auth data to the session store, we\n        # validate the authentication form, determine the resulting user, then\n        # only store the minimum needed to login that user (the user's primary\n        # key and the backend used)\n        if self.steps.current == 'auth':\n            user = form.is_valid() and form.user_cache\n            self.storage.reset()\n            self.storage.authenticated_user = user\n            self.storage.data[\"authentication_time\"] = int(time.time())\n\n            # By returning None when the user clicks the \"back\" button to the\n            # auth step the form will be blank with validation warnings\n            return None\n\n        return super().process_step(form)\n\n    def process_step_files(self, form):\n        \"\"\"\n        Process the files submitted from a specific test\n        \"\"\"\n        if self.steps.current == 'auth':\n            return {}\n        return super().process_step_files(form)\n\n    def get_form(self, *args, **kwargs):\n        \"\"\"\n        Returns the form for the step\n        \"\"\"\n        form = super().get_form(*args, **kwargs)\n        if self.show_timeout_error:\n            form.cleaned_data = getattr(form, 'cleaned_data', {})\n            form.add_error(None, ValidationError(_('Your session has timed out. Please login again.')))\n        return form\n\n    def get_device(self, step=None):\n        \"\"\"\n        Returns the OTP device selected by the user, or his default device.\n        \"\"\"\n        if not self.device_cache:\n            challenge_device_id = self.request.POST.get('challenge_device', None)\n            if challenge_device_id:\n                for device in backup_phones(self.get_user()):\n                    if device.persistent_id == challenge_device_id:\n                        self.device_cache = device\n                        break\n            if step == 'backup':\n                try:\n                    self.device_cache = self.get_user().staticdevice_set.get(name='backup')\n                except StaticDevice.DoesNotExist:\n                    pass\n            if not self.device_cache:\n                self.device_cache = default_device(self.get_user())\n        return self.device_cache\n\n    def render(self, form=None, **kwargs):\n        \"\"\"\n        If the user selected a device, ask the device to generate a challenge;\n        either making a phone call or sending a text message.\n        \"\"\"\n        if self.steps.current == 'token':\n            self.get_device().generate_challenge()\n        return super().render(form, **kwargs)\n\n    def get_user(self):\n        \"\"\"\n        Returns the user authenticated by the AuthenticationForm. Returns False\n        if not a valid user; see also issue #65.\n        \"\"\"\n        if not self.user_cache:\n            self.user_cache = self.storage.authenticated_user\n        return self.user_cache\n\n    def get_context_data(self, form, **kwargs):\n        \"\"\"\n        Adds user's default and backup OTP devices to the context.\n        \"\"\"\n        context = super().get_context_data(form, **kwargs)\n        if self.steps.current == 'token':\n            context['device'] = self.get_device()\n            context['other_devices'] = [\n                phone for phone in backup_phones(self.get_user())\n                if phone != self.get_device()]\n            try:\n                context['backup_tokens'] = self.get_user().staticdevice_set\\\n                    .get(name='backup').token_set.count()\n            except StaticDevice.DoesNotExist:\n                context['backup_tokens'] = 0\n\n        if getattr(settings, 'LOGOUT_REDIRECT_URL', None):\n            context['cancel_url'] = resolve_url(settings.LOGOUT_REDIRECT_URL)\n        elif getattr(settings, 'LOGOUT_URL', None):\n            warnings.warn(\n                \"LOGOUT_URL has been replaced by LOGOUT_REDIRECT_URL, please \"\n                \"review the URL and update your settings.\",\n                DeprecationWarning)\n            context['cancel_url'] = resolve_url(settings.LOGOUT_URL)\n        return context\n\n    # Copied from django.conrib.auth.views.LoginView  (Branch: stable/1.11.x)\n    # https://github.com/django/django/blob/58df8aa40fe88f753ba79e091a52f236246260b3/django/contrib/auth/views.py#L49\n    @method_decorator(sensitive_post_parameters())\n    @method_decorator(csrf_protect)\n    @method_decorator(never_cache)\n    def dispatch(self, request, *args, **kwargs):\n        if self.redirect_authenticated_user and self.request.user.is_authenticated:\n            redirect_to = self.get_success_url()\n            if redirect_to == self.request.path:\n                raise ValueError(\n                    \"Redirection loop for authenticated user detected. Check that \"\n                    \"your LOGIN_REDIRECT_URL doesn't point to a login page.\"\n                )\n            return HttpResponseRedirect(redirect_to)\n        return super().dispatch(request, *args, **kwargs)\n\n\n@class_view_decorator(never_cache)\n@class_view_decorator(login_required)\nclass SetupView(IdempotentSessionWizardView):\n    \"\"\"\n    View for handling OTP setup using a wizard.\n\n    The first step of the wizard shows an introduction text, explaining how OTP\n    works and why it should be enabled. The user has to select the verification\n    method (generator / call / sms) in the second step. Depending on the method\n    selected, the third step configures the device. For the generator method, a\n    QR code is shown which can be scanned using a mobile phone app and the user\n    is asked to provide a generated token. For call and sms methods, the user\n    provides the phone number which is then validated in the final step.\n    \"\"\"\n    success_url = 'two_factor:setup_complete'\n    qrcode_url = 'two_factor:qr'\n    template_name = 'two_factor/core/setup.html'\n    session_key_name = 'django_two_factor-qr_secret_key'\n    initial_dict = {}\n    form_list = (\n        ('welcome', Form),\n        ('method', MethodForm),\n        ('generator', TOTPDeviceForm),\n        ('sms', PhoneNumberForm),\n        ('call', PhoneNumberForm),\n        ('validation', DeviceValidationForm),\n        ('yubikey', YubiKeyDeviceForm),\n    )\n    condition_dict = {\n        'generator': lambda self: self.get_method() == 'generator',\n        'call': lambda self: self.get_method() == 'call',\n        'sms': lambda self: self.get_method() == 'sms',\n        'validation': lambda self: self.get_method() in ('sms', 'call'),\n        'yubikey': lambda self: self.get_method() == 'yubikey',\n    }\n    idempotent_dict = {\n        'yubikey': False,\n    }\n\n    def get_method(self):\n        method_data = self.storage.validated_step_data.get('method', {})\n        return method_data.get('method', None)\n\n    def get(self, request, *args, **kwargs):\n        \"\"\"\n        Start the setup wizard. Redirect if already enabled.\n        \"\"\"\n        if default_device(self.request.user):\n            return redirect(self.success_url)\n        return super().get(request, *args, **kwargs)\n\n    def get_form_list(self):\n        \"\"\"\n        Check if there is only one method, then skip the MethodForm from form_list\n        \"\"\"\n        form_list = super().get_form_list()\n        available_methods = get_available_methods()\n        if len(available_methods) == 1:\n            form_list.pop('method', None)\n            method_key, _ = available_methods[0]\n            self.storage.validated_step_data['method'] = {'method': method_key}\n        return form_list\n\n    def render_next_step(self, form, **kwargs):\n        \"\"\"\n        In the validation step, ask the device to generate a challenge.\n        \"\"\"\n        next_step = self.steps.next\n        if next_step == 'validation':\n            try:\n                self.get_device().generate_challenge()\n                kwargs[\"challenge_succeeded\"] = True\n            except Exception:\n                logger.exception(\"Could not generate challenge\")\n                kwargs[\"challenge_succeeded\"] = False\n        return super().render_next_step(form, **kwargs)\n\n    def done(self, form_list, **kwargs):\n        \"\"\"\n        Finish the wizard. Save all forms and redirect.\n        \"\"\"\n        # Remove secret key used for QR code generation\n        try:\n            del self.request.session[self.session_key_name]\n        except KeyError:\n            pass\n\n        # TOTPDeviceForm\n        if self.get_method() == 'generator':\n            form = [form for form in form_list if isinstance(form, TOTPDeviceForm)][0]\n            device = form.save()\n\n        # PhoneNumberForm / YubiKeyDeviceForm\n        elif self.get_method() in ('call', 'sms', 'yubikey'):\n            device = self.get_device()\n            device.save()\n\n        else:\n            raise NotImplementedError(\"Unknown method '%s'\" % self.get_method())\n\n        django_otp.login(self.request, device)\n        return redirect(self.success_url)\n\n    def get_form_kwargs(self, step=None):\n        kwargs = {}\n        if step == 'generator':\n            kwargs.update({\n                'key': self.get_key(step),\n                'user': self.request.user,\n            })\n        if step in ('validation', 'yubikey'):\n            kwargs.update({\n                'device': self.get_device()\n            })\n        metadata = self.get_form_metadata(step)\n        if metadata:\n            kwargs.update({\n                'metadata': metadata,\n            })\n        return kwargs\n\n    def get_device(self, **kwargs):\n        \"\"\"\n        Uses the data from the setup step and generated key to recreate device.\n\n        Only used for call / sms -- generator uses other procedure.\n        \"\"\"\n        method = self.get_method()\n        kwargs = kwargs or {}\n        kwargs['name'] = 'default'\n        kwargs['user'] = self.request.user\n\n        if method in ('call', 'sms'):\n            kwargs['method'] = method\n            kwargs['number'] = self.storage.validated_step_data\\\n                .get(method, {}).get('number')\n            return PhoneDevice(key=self.get_key(method), **kwargs)\n\n        if method == 'yubikey':\n            kwargs['public_id'] = self.storage.validated_step_data\\\n                .get('yubikey', {}).get('token', '')[:-32]\n            try:\n                kwargs['service'] = ValidationService.objects.get(name='default')\n            except ValidationService.DoesNotExist:\n                raise KeyError(\"No ValidationService found with name 'default'\")\n            except ValidationService.MultipleObjectsReturned:\n                raise KeyError(\"Multiple ValidationService found with name 'default'\")\n            return RemoteYubikeyDevice(**kwargs)\n\n    def get_key(self, step):\n        self.storage.extra_data.setdefault('keys', {})\n        if step in self.storage.extra_data['keys']:\n            return self.storage.extra_data['keys'].get(step)\n        key = random_hex_str(20)\n        self.storage.extra_data['keys'][step] = key\n        return key\n\n    def get_context_data(self, form, **kwargs):\n        context = super().get_context_data(form, **kwargs)\n        if self.steps.current == 'generator':\n            key = self.get_key('generator')\n            rawkey = unhexlify(key.encode('ascii'))\n            b32key = b32encode(rawkey).decode('utf-8')\n            self.request.session[self.session_key_name] = b32key\n            context.update({\n                'QR_URL': reverse(self.qrcode_url)\n            })\n        elif self.steps.current == 'validation':\n            context['device'] = self.get_device()\n        context['cancel_url'] = resolve_url(settings.LOGIN_REDIRECT_URL)\n        return context\n\n    def process_step(self, form):\n        if hasattr(form, 'metadata'):\n            self.storage.extra_data.setdefault('forms', {})\n            self.storage.extra_data['forms'][self.steps.current] = form.metadata\n        return super().process_step(form)\n\n    def get_form_metadata(self, step):\n        self.storage.extra_data.setdefault('forms', {})\n        return self.storage.extra_data['forms'].get(step, None)\n\n\n@class_view_decorator(never_cache)\n@class_view_decorator(otp_required)\nclass BackupTokensView(FormView):\n    \"\"\"\n    View for listing and generating backup tokens.\n\n    A user can generate a number of static backup tokens. When the user loses\n    its phone, these backup tokens can be used for verification. These backup\n    tokens should be stored in a safe location; either in a safe or underneath\n    a pillow ;-).\n    \"\"\"\n    form_class = Form\n    success_url = 'two_factor:backup_tokens'\n    template_name = 'two_factor/core/backup_tokens.html'\n    number_of_tokens = 10\n\n    def get_device(self):\n        return self.request.user.staticdevice_set.get_or_create(name='backup')[0]\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context['device'] = self.get_device()\n        return context\n\n    def form_valid(self, form):\n        \"\"\"\n        Delete existing backup codes and generate new ones.\n        \"\"\"\n        device = self.get_device()\n        device.token_set.all().delete()\n        for n in range(self.number_of_tokens):\n            device.token_set.create(token=StaticToken.random_token())\n\n        return redirect(self.success_url)\n\n\n@class_view_decorator(never_cache)\n@class_view_decorator(otp_required)\nclass PhoneSetupView(IdempotentSessionWizardView):\n    \"\"\"\n    View for configuring a phone number for receiving tokens.\n\n    A user can have multiple backup :class:`~two_factor.models.PhoneDevice`\n    for receiving OTP tokens. If the primary phone number is not available, as\n    the battery might have drained or the phone is lost, these backup phone\n    numbers can be used for verification.\n    \"\"\"\n    template_name = 'two_factor/core/phone_register.html'\n    success_url = settings.LOGIN_REDIRECT_URL\n    form_list = (\n        ('setup', PhoneNumberMethodForm),\n        ('validation', DeviceValidationForm),\n    )\n    key_name = 'key'\n\n    def get(self, request, *args, **kwargs):\n        \"\"\"\n        Start the setup wizard. Redirect if no phone methods available.\n        \"\"\"\n        if not get_available_phone_methods():\n            return redirect(self.success_url)\n        return super().get(request, *args, **kwargs)\n\n    def done(self, form_list, **kwargs):\n        \"\"\"\n        Store the device and redirect to profile page.\n        \"\"\"\n        self.get_device(user=self.request.user, name='backup').save()\n        return redirect(self.success_url)\n\n    def render_next_step(self, form, **kwargs):\n        \"\"\"\n        In the validation step, ask the device to generate a challenge.\n        \"\"\"\n        next_step = self.steps.next\n        if next_step == 'validation':\n            self.get_device().generate_challenge()\n        return super().render_next_step(form, **kwargs)\n\n    def get_form_kwargs(self, step=None):\n        \"\"\"\n        Provide the device to the DeviceValidationForm.\n        \"\"\"\n        if step == 'validation':\n            return {'device': self.get_device()}\n        return {}\n\n    def get_device(self, **kwargs):\n        \"\"\"\n        Uses the data from the setup step and generated key to recreate device.\n        \"\"\"\n        kwargs = kwargs or {}\n        kwargs.update(self.storage.validated_step_data.get('setup', {}))\n        return PhoneDevice(key=self.get_key(), **kwargs)\n\n    def get_key(self):\n        \"\"\"\n        The key is preserved between steps and stored as ascii in the session.\n        \"\"\"\n        if self.key_name not in self.storage.extra_data:\n            key = random_hex_str(20)\n            self.storage.extra_data[self.key_name] = key\n        return self.storage.extra_data[self.key_name]\n\n    def get_context_data(self, form, **kwargs):\n        kwargs.setdefault('cancel_url', resolve_url(self.success_url))\n        return super().get_context_data(form, **kwargs)\n\n\n@class_view_decorator(never_cache)\n@class_view_decorator(otp_required)\nclass PhoneDeleteView(DeleteView):\n    \"\"\"\n    View for removing a phone number used for verification.\n    \"\"\"\n    success_url = settings.LOGIN_REDIRECT_URL\n\n    def get_queryset(self):\n        return self.request.user.phonedevice_set.filter(name='backup')\n\n    def get_success_url(self):\n        return resolve_url(self.success_url)\n\n\n@class_view_decorator(never_cache)\n@class_view_decorator(otp_required)\nclass SetupCompleteView(TemplateView):\n    \"\"\"\n    View congratulation the user when OTP setup has completed.\n    \"\"\"\n    template_name = 'two_factor/core/setup_complete.html'\n\n    def get_context_data(self):\n        return {\n            'phone_methods': get_available_phone_methods(),\n        }\n\n\n@class_view_decorator(never_cache)\n@class_view_decorator(login_required)\nclass QRGeneratorView(View):\n    \"\"\"\n    View returns an SVG image with the OTP token information\n    \"\"\"\n    http_method_names = ['get']\n    default_qr_factory = 'qrcode.image.svg.SvgPathImage'\n    session_key_name = 'django_two_factor-qr_secret_key'\n\n    # The qrcode library only supports PNG and SVG for now\n    image_content_types = {\n        'PNG': 'image/png',\n        'SVG': 'image/svg+xml; charset=utf-8',\n    }\n\n    def get_issuer(self):\n        return get_current_site(self.request).name\n\n    def get(self, request, *args, **kwargs):\n        # Get the data from the session\n        try:\n            key = self.request.session[self.session_key_name]\n        except KeyError:\n            raise Http404()\n\n        # Get data for qrcode\n        image_factory_string = getattr(settings, 'TWO_FACTOR_QR_FACTORY', self.default_qr_factory)\n        image_factory = import_string(image_factory_string)\n        content_type = self.image_content_types[image_factory.kind]\n        try:\n            username = self.request.user.get_username()\n        except AttributeError:\n            username = self.request.user.username\n\n        otpauth_url = get_otpauth_url(accountname=username,\n                                      issuer=self.get_issuer(),\n                                      secret=key,\n                                      digits=totp_digits())\n\n        # Make and return QR code\n        img = qrcode.make(otpauth_url, image_factory=image_factory)\n        resp = HttpResponse(content_type=content_type)\n        img.save(resp)\n        return resp\n", "import logging\n\nfrom django.contrib.auth import load_backend\nfrom django.core.exceptions import SuspiciousOperation\nfrom django.utils.decorators import method_decorator\nfrom django.utils.translation import gettext as _\nfrom formtools.wizard.forms import ManagementForm\nfrom formtools.wizard.storage.session import SessionStorage\nfrom formtools.wizard.views import SessionWizardView\n\nlogger = logging.getLogger(__name__)\n\n\nclass ExtraSessionStorage(SessionStorage):\n    \"\"\"\n    SessionStorage that includes the property `validated_step_data` for storing\n    cleaned form data per step.\n    \"\"\"\n    validated_step_data_key = 'validated_step_data'\n\n    def init_data(self):\n        super().init_data()\n        self.data[self.validated_step_data_key] = {}\n\n    def reset(self):\n        if self.prefix in self.request.session:\n            super().reset()\n        else:\n            self.init_data()\n\n    def _get_validated_step_data(self):\n        return self.data[self.validated_step_data_key]\n\n    def _set_validated_step_data(self, validated_step_data):\n        self.data[self.validated_step_data_key] = validated_step_data\n\n    validated_step_data = property(_get_validated_step_data,\n                                   _set_validated_step_data)\n\n\nclass LoginStorage(ExtraSessionStorage):\n    \"\"\"\n    SessionStorage that includes the property 'authenticated_user' for storing\n    backend authenticated users while logging in.\n    \"\"\"\n    def _get_authenticated_user(self):\n        # Ensure that both user_pk and user_backend exist in the session\n        if not all([self.data.get(\"user_pk\"), self.data.get(\"user_backend\")]):\n            return False\n        # Acquire the user the same way django.contrib.auth.get_user does\n        backend = load_backend(self.data[\"user_backend\"])\n        user = backend.get_user(self.data[\"user_pk\"])\n        if not user:\n            return False\n        # Set user.backend to the dotted path version of the backend for login()\n        user.backend = self.data[\"user_backend\"]\n        return user\n\n    def _set_authenticated_user(self, user):\n        # Acquire the PK the same way django's auth middleware does\n        self.data[\"user_pk\"] = user._meta.pk.value_to_string(user)\n        self.data[\"user_backend\"] = user.backend\n\n    authenticated_user = property(_get_authenticated_user,\n                                  _set_authenticated_user)\n\n\nclass IdempotentSessionWizardView(SessionWizardView):\n    \"\"\"\n    WizardView that allows certain steps to be marked non-idempotent, in which\n    case the form is only validated once and the cleaned values stored.\n    \"\"\"\n    storage_name = 'two_factor.views.utils.ExtraSessionStorage'\n    idempotent_dict = {}\n\n    def is_step_visible(self, step):\n        \"\"\"\n        Returns whether the given `step` should be included in the wizard; it\n        is included if either the form is idempotent or not filled in before.\n        \"\"\"\n        return self.idempotent_dict.get(step, True) or \\\n            step not in self.storage.validated_step_data\n\n    def get_prev_step(self, step=None):\n        \"\"\"\n        Returns the previous step before the given `step`. If there are no\n        steps available, None will be returned. If the `step` argument is\n        None, the current step will be determined automatically.\n        \"\"\"\n        if step is None:\n            step = self.steps.current\n        form_list = self.get_form_list()\n        keys = list(form_list.keys())\n        key = keys.index(step) - 1\n        if key >= 0:\n            for prev_step in keys[key::-1]:\n                if self.is_step_visible(prev_step):\n                    return prev_step\n        return None\n\n    def get_next_step(self, step=None):\n        \"\"\"\n        Returns the next step after the given `step`. If no more steps are\n        available, None will be returned. If the `step` argument is None, the\n        current step will be determined automatically.\n        \"\"\"\n        if step is None:\n            step = self.steps.current\n        form_list = self.get_form_list()\n        keys = list(form_list.keys())\n        key = keys.index(step) + 1\n        for next_step in keys[key:]:\n            if self.is_step_visible(next_step):\n                return next_step\n        return None\n\n    def post(self, *args, **kwargs):\n        \"\"\"\n        Check if the current step is still available. It might not be if\n        conditions have changed.\n        \"\"\"\n        if self.steps.current not in self.steps.all:\n            logger.warning(\"Current step '%s' is no longer valid, returning \"\n                           \"to last valid step in the wizard.\",\n                           self.steps.current)\n            return self.render_goto_step(self.steps.all[-1])\n\n        # -- Duplicated code from upstream\n        # Look for a wizard_goto_step element in the posted data which\n        # contains a valid step name. If one was found, render the requested\n        # form. (This makes stepping back a lot easier).\n        wizard_goto_step = self.request.POST.get('wizard_goto_step', None)\n        if wizard_goto_step and wizard_goto_step in self.get_form_list():\n            return self.render_goto_step(wizard_goto_step)\n\n        # Check if form was refreshed\n        management_form = ManagementForm(self.request.POST, prefix=self.prefix)\n        if not management_form.is_valid():\n            raise SuspiciousOperation(_('ManagementForm data is missing or has been tampered with'))\n\n        form_current_step = management_form.cleaned_data['current_step']\n        if (form_current_step != self.steps.current\n                and self.storage.current_step is not None):\n            # form refreshed, change current step\n            self.storage.current_step = form_current_step\n        # -- End duplicated code from upstream\n\n        # This is different from the first check, as this checks\n        # if the new step is available. See issue #65.\n        if self.steps.current not in self.steps.all:\n            logger.warning(\"Requested step '%s' is no longer valid, returning \"\n                           \"to last valid step in the wizard.\",\n                           self.steps.current)\n            return self.render_goto_step(self.steps.all[-1])\n\n        return super().post(*args, **kwargs)\n\n    def process_step(self, form):\n        \"\"\"\n        Stores the validated data for `form` and cleans out validated forms\n        for next steps, as those might be affected by the current step. Note\n        that this behaviour is relied upon by the `LoginView` to prevent users\n        from bypassing the `TokenForm` by going steps back and changing\n        credentials.\n        \"\"\"\n        step = self.steps.current\n\n        # If the form is not-idempotent (cannot be validated multiple times),\n        # the cleaned data should be stored; marking the form as validated.\n        self.storage.validated_step_data[step] = form.cleaned_data\n\n        # It is assumed that earlier steps affect later steps; so even though\n        # those forms might not be idempotent, we'll remove the validated data\n        # to force re-entry.\n        # form_list = self.get_form_list(idempotent=False)\n        form_list = self.get_form_list()\n        keys = list(form_list.keys())\n        key = keys.index(step) + 1\n        for next_step in keys[key:]:\n            self.storage.validated_step_data.pop(next_step, None)\n\n        return super().process_step(form)\n\n    def get_done_form_list(self):\n        return self.get_form_list()\n\n    def render_done(self, form, **kwargs):\n        \"\"\"\n        This method gets called when all forms passed. The method should also\n        re-validate all steps to prevent manipulation. If any form don't\n        validate, `render_revalidation_failure` should get called.\n        If everything is fine call `done`.\n        \"\"\"\n        final_form_list = []\n        # walk through the form list and try to validate the data again.\n        for form_key in self.get_done_form_list():\n            form_obj = self.get_form(step=form_key,\n                                     data=self.storage.get_step_data(form_key),\n                                     files=self.storage.get_step_files(\n                                         form_key))\n            if not (form_key in self.idempotent_dict or form_obj.is_valid()):\n                return self.render_revalidation_failure(form_key, form_obj,\n                                                        **kwargs)\n            final_form_list.append(form_obj)\n\n        # render the done view and reset the wizard before returning the\n        # response. This is needed to prevent from rendering done with the\n        # same data twice.\n        done_response = self.done(final_form_list, **kwargs)\n        self.storage.reset()\n        return done_response\n\n\ndef class_view_decorator(function_decorator):\n    \"\"\"\n    Converts a function based decorator into a class based decorator usable\n    on class based Views.\n\n    Can't subclass the `View` as it breaks inheritance (super in particular),\n    so we monkey-patch instead.\n\n    From: http://stackoverflow.com/a/8429311/58107\n    \"\"\"\n    def simple_decorator(View):\n        View.dispatch = method_decorator(function_decorator)(View.dispatch)\n        return View\n    return simple_decorator\n"], "buggy_code_start_loc": [1, 75, 0, 4, 2], "buggy_code_end_loc": [1, 75, 334, 193, 166], "fixing_code_start_loc": [2, 76, 1, 5, 3], "fixing_code_end_loc": [10, 83, 414, 264, 197], "type": "CWE-312", "message": "Django Two-Factor Authentication before 1.12, stores the user's password in clear text in the user session (base64-encoded). The password is stored in the session when the user submits their username and password, and is removed once they complete authentication by entering a two-factor authentication code. This means that the password is stored in clear text in the session for an arbitrary amount of time, and potentially forever if the user begins the login process by entering their username and password and then leaves before entering their two-factor authentication code. The severity of this issue depends on which type of session storage you have configured: in the worst case, if you're using Django's default database session storage, then users' passwords are stored in clear text in your database. In the best case, if you're using Django's signed cookie session, then users' passwords are only stored in clear text within their browser's cookie store. In the common case of using Django's cache session store, the users' passwords are stored in clear text in whatever cache storage you have configured (typically Memcached or Redis). This has been fixed in 1.12. After upgrading, users should be sure to delete any clear text passwords that have been stored. For example, if you're using the database session backend, you'll likely want to delete any session record from the database and purge that data from any database backups or replicas. In addition, affected organizations who have suffered a database breach while using an affected version should inform their users that their clear text passwords have been compromised. All organizations should encourage users whose passwords were insecurely stored to change these passwords on any sites where they were used. As a workaround, wwitching Django's session storage to use signed cookies instead of the database or cache lessens the impact of this issue, but should not be done without a thorough understanding of the security tradeoffs of using signed cookies rather than a server-side session storage. There is no way to fully mitigate the issue without upgrading.", "other": {"cve": {"id": "CVE-2020-15105", "sourceIdentifier": "security-advisories@github.com", "published": "2020-07-10T21:15:10.950", "lastModified": "2020-07-21T18:06:03.230", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Django Two-Factor Authentication before 1.12, stores the user's password in clear text in the user session (base64-encoded). The password is stored in the session when the user submits their username and password, and is removed once they complete authentication by entering a two-factor authentication code. This means that the password is stored in clear text in the session for an arbitrary amount of time, and potentially forever if the user begins the login process by entering their username and password and then leaves before entering their two-factor authentication code. The severity of this issue depends on which type of session storage you have configured: in the worst case, if you're using Django's default database session storage, then users' passwords are stored in clear text in your database. In the best case, if you're using Django's signed cookie session, then users' passwords are only stored in clear text within their browser's cookie store. In the common case of using Django's cache session store, the users' passwords are stored in clear text in whatever cache storage you have configured (typically Memcached or Redis). This has been fixed in 1.12. After upgrading, users should be sure to delete any clear text passwords that have been stored. For example, if you're using the database session backend, you'll likely want to delete any session record from the database and purge that data from any database backups or replicas. In addition, affected organizations who have suffered a database breach while using an affected version should inform their users that their clear text passwords have been compromised. All organizations should encourage users whose passwords were insecurely stored to change these passwords on any sites where they were used. As a workaround, wwitching Django's session storage to use signed cookies instead of the database or cache lessens the impact of this issue, but should not be done without a thorough understanding of the security tradeoffs of using signed cookies rather than a server-side session storage. There is no way to fully mitigate the issue without upgrading."}, {"lang": "es", "value": "Django Two-Factor Authentication versiones anteriores a 1.12, almacena la contrase\u00f1a del usuario en texto sin cifrar en la sesi\u00f3n del usuario (codificada en base64). La contrase\u00f1a es almacenada en la sesi\u00f3n cuando el usuario introduce su nombre de usuario y contrase\u00f1a, y se elimina una vez que completa la autenticaci\u00f3n al ingresar un c\u00f3digo de autenticaci\u00f3n de dos factores. Esto quiere decir que la contrase\u00f1a es almacenada en texto sin cifrar en la sesi\u00f3n durante un per\u00edodo de tiempo arbitrario, y potencialmente para siempre si el usuario comienza el proceso de inicio de sesi\u00f3n ingresando su nombre de usuario y contrase\u00f1a y luego se sale antes de ingresar su c\u00f3digo de autenticaci\u00f3n de dos factores. La gravedad de este problema depende del tipo de almacenamiento de sesi\u00f3n que haya configurado: en el peor de los casos, si est\u00e1 usando el almacenamiento de sesi\u00f3n de base de datos predeterminado de Django, las contrase\u00f1as de los usuarios son almacenadas en texto sin cifrar en su base de datos. En el mejor de los casos, si est\u00e1 utilizando la sesi\u00f3n de cookies firmada de Django, las contrase\u00f1as de los usuarios solo son almacenadas en texto sin cifrar dentro de la tienda de cookies de su navegador. En el caso com\u00fan de usar el almac\u00e9n de sesiones de cach\u00e9 de Django, las contrase\u00f1as de los usuarios son almacenadas en texto sin cifrar en cualquier almacenamiento de cach\u00e9 que haya configurado (generalmente Memcached o Redis). Esto ha sido corregido en la versi\u00f3n 1.12. Despu\u00e9s de la actualizaci\u00f3n, los usuarios deben asegurarse de eliminar las contrase\u00f1as de texto sin cifrar que hayan sido almacenadas. Por ejemplo, si est\u00e1 usando el back-end de sesi\u00f3n de la base de datos, es probable que quiera eliminar cualquier registro de sesi\u00f3n de la base de datos y purgar esos datos de cualquier copia de seguridad o r\u00e9plica de la base de datos. Adicionalmente, las organizaciones afectadas que han sufrido una violaci\u00f3n de la base de datos al usar una versi\u00f3n afectada deben reportar a sus usuarios que sus contrase\u00f1as de texto sin cifrar han sido comprometidas. Todas las organizaciones deben exhortar a los usuarios cuyas contrase\u00f1as son almacenadas de forma no segura para que cambien estas contrase\u00f1as en los sitios donde se utilizaron. Como soluci\u00f3n alternativa, cambiar el almacenamiento de sesi\u00f3n de Django para usar cookies firmadas en lugar de la base de datos o cach\u00e9 disminuye el impacto de este problema, pero no se debe hacer sin un conocimiento profundo de las compensaciones de seguridad del uso de cookies firmadas en lugar de un almacenamiento de sesi\u00f3n del lado del servidor. No existe manera de mitigar completamente el problema sin actualizar"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 4.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-312"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-312"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:django_two-factor_authentication_project:django_two-factor_authentication:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.12", "matchCriteriaId": "7D3A415A-770B-405A-9C77-72D6142C79C4"}]}]}], "references": [{"url": "https://github.com/Bouke/django-two-factor-auth/blob/master/CHANGELOG.md#112---2020-07-08", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/Bouke/django-two-factor-auth/commit/454fd9842fa6e8bb772dbf0943976bc8e3335359", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Bouke/django-two-factor-auth/security/advisories/GHSA-vhr6-pvjm-9qwf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Bouke/django-two-factor-auth/commit/454fd9842fa6e8bb772dbf0943976bc8e3335359"}}