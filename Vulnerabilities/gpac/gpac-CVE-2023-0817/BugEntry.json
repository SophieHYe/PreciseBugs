{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2020-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / MHAS reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\n\nstatic u32 USACSampleRates[] = {96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, 0, 0,\n\t57600, 51200, 40000, 38400, 34150, 28800, 25600, 20000, 19200, 17075, 14400, 12800, 9600};\n\nstatic u32 nb_usac_sr = GF_ARRAY_LENGTH(USACSampleRates);\n\n\ntypedef struct\n{\n\tu64 pos;\n\tDouble duration;\n} MHASIdx;\n\ntypedef struct\n{\n\t//filter args\n\tDouble index;\n\tBool mpha;\n\tu32 pcksync;\n\tBool nosync;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tGF_BitStream *bs;\n\tu64 file_pos, cts, prev_cts;\n\n\tGF_Fraction64 duration;\n\tDouble start_range;\n\tBool in_seek;\n\tu32 timescale;\n\tBool is_playing;\n\tBool is_file;\n\tBool initial_play_done, file_loaded;\n\n\tBool initialized;\n\n\tu8 *mhas_buffer;\n\tu32 mhas_buffer_size, mhas_buffer_alloc, resume_from;\n\tu64 byte_offset;\n\tBool buffer_too_small;\n\n\tGF_FilterPacket *src_pck;\n\n\tBool recompute_cts;\n\tMHASIdx *indexes;\n\tu32 index_alloc_size, index_size;\n\n\tu32 sample_rate, frame_len, PL;\n\ts32 cicp_layout_idx, num_speakers;\n\tu32 nb_frames;\n\n\tu32 nb_unknown_pck;\n\tu32 bitrate;\n\tBool copy_props;\n\tBool is_sync;\n} GF_MHASDmxCtx;\n\n\n\n\nGF_Err mhas_dmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_MHASDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) {\n\t\tctx->timescale = p->value.uint;\n\t\t//if stream comes from TS or other muxed source unframed, force initial sync check\n\t\tif (!ctx->ipid) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_UNFRAMED);\n\t\t\tif (p && p->value.boolean)\n\t\t\t\tctx->nosync = GF_TRUE;\n\t\t}\n\t}\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property_str(pid, \"nocts\");\n\tif (p && p->value.boolean) ctx->recompute_cts = GF_TRUE;\n\telse ctx->recompute_cts = GF_FALSE;\n\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t}\n\tif (ctx->timescale) ctx->copy_props = GF_TRUE;\n\treturn GF_OK;\n}\n\nstatic void mhas_dmx_check_dur(GF_Filter *filter, GF_MHASDmxCtx *ctx)\n{\n\tGF_Fraction64 duration;\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tu32 frame_len, cur_dur;\n\tBool mhas_sap;\n\tu64 mhas_last_cfg, rate;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<=0) {\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen_ex(p->value.string, NULL, \"rb\", GF_TRUE);\n\tif (!stream) {\n\t\tif (gf_fileio_is_main_thread(p->value.string))\n\t\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\tduration.num = duration.den = 0;\n\tframe_len = cur_dur = 0;\n\tmhas_last_cfg = 0;\n\n\twhile (gf_bs_available(bs)) {\n\t\tu32 sync_code = gf_bs_peek_bits(bs, 24, 0);\n\t\tif (sync_code == 0xC001A5) {\n\t\t\tbreak;\n\t\t}\n\t\tgf_bs_skip_bytes(bs, 1);\n\t}\n\twhile (gf_bs_available(bs)) {\n\t\tu64 mhas_pck_start, pay_start, parse_end, mhas_size;\n\t\tu32 mhas_type;\n\n\t\tmhas_pck_start = gf_bs_get_position(bs);\n\t\tmhas_type = (u32) gf_mpegh_escaped_value(bs, 3, 8, 8);\n\t\t/*mhas_label = */gf_mpegh_escaped_value(bs, 2, 8, 32);\n\t\tmhas_size = gf_mpegh_escaped_value(bs, 11, 24, 24);\n\n\t\tpay_start = (u32) gf_bs_get_position(bs);\n\n\t\tif (!gf_bs_available(bs) ) break;\n\t\tif (mhas_size > gf_bs_available(bs)) break;\n\n\t\tmhas_sap = 0;\n\t\t//frame\n\t\tif (mhas_type==2) {\n\t\t\tmhas_sap = gf_bs_read_int(bs, 1);\n\t\t\tif (!mhas_last_cfg) mhas_sap = 0;\n\t\t//config\n\t\t} else if (mhas_type==1) {\n\t\t\tu32 sr = 0;\n\t\t\t/*u32 pl = */gf_bs_read_u8(bs);\n\t\t\tu32 idx = gf_bs_read_int(bs, 5);\n\t\t\tif (idx==0x1f)\n\t\t\t\tduration.den = gf_bs_read_int(bs, 24);\n\t\t\telse if (sr < nb_usac_sr) {\n\t\t\t\tduration.den = USACSampleRates[idx];\n\t\t\t}\n\t\t\tidx = gf_bs_read_int(bs, 3);\n\t\t\tif ((idx==0) || (idx==2) ) frame_len = 768;\n\t\t\telse frame_len = 1024;\n\n\t\t\tmhas_last_cfg = mhas_pck_start;\n\t\t}\n\t\t//audio truncation\n\t\telse if (mhas_type==17) {\n\t\t\tBool isActive = gf_bs_read_int(bs, 1);\n\t\t\t/*Bool ati_reserved = */gf_bs_read_int(bs, 1);\n\t\t\tBool trunc_from_begin = gf_bs_read_int(bs, 1);\n\t\t\tu32 nb_trunc_samples = gf_bs_read_int(bs, 13);\n\t\t\tif (isActive && !trunc_from_begin) {\n\t\t\t\tduration.num -= nb_trunc_samples;\n\t\t\t}\n\t\t}\n\t\tgf_bs_align(bs);\n\t\tparse_end = (u32) gf_bs_get_position(bs) - pay_start;\n\t\t//remaining of packet payload\n\t\tgf_bs_skip_bytes(bs, mhas_size - parse_end);\n\n\t\t//mhas_sap only set for frames\n\t\tif (mhas_sap && duration.den && (cur_dur >= ctx->index * duration.den) ) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(MHASIdx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = mhas_last_cfg;\n\t\t\tctx->indexes[ctx->index_size].duration = ((Double) duration.num) / duration.den;\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\t\tif (mhas_type==2) {\n\t\t\tduration.num += frame_len;\n\t\t\tcur_dur += frame_len;\n\t\t\tmhas_last_cfg = 0;\n\t\t}\n\t}\n\n\trate = gf_bs_get_position(bs);\n\tgf_bs_del(bs);\n\tgf_fclose(stream);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * duration.den != duration.num * ctx->duration.den)) {\n\t\tctx->duration = duration;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\tif (duration.num && !gf_sys_is_test_mode() ) {\n\t\t\trate *= 8 * ctx->duration.den;\n\t\t\trate /= ctx->duration.num;\n\t\t\tctx->bitrate = (u32) rate;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n}\n\nstatic void mhas_dmx_check_pid(GF_Filter *filter, GF_MHASDmxCtx *ctx, u32 PL, u32 sample_rate, u32 frame_len, s32 CICPspeakerLayoutIdx, s32 numSpeakers, u8 *dsi, u32 dsi_size)\n{\n\tu32 nb_channels;\n\tu64 chan_layout;\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tmhas_dmx_check_dur(filter, ctx);\n\t} else {\n\t\tif ((ctx->frame_len == frame_len)\n\t\t\t&& (ctx->PL == PL)\n\t\t\t&& (ctx->sample_rate == sample_rate)\n\t\t\t&& (ctx->cicp_layout_idx == CICPspeakerLayoutIdx)\n\t\t\t&& (ctx->num_speakers == numSpeakers)\n\t\t\t&& !ctx->copy_props\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t}\n\tctx->frame_len = frame_len;\n\tctx->PL = PL;\n\tctx->sample_rate = sample_rate;\n\tctx->cicp_layout_idx = CICPspeakerLayoutIdx;\n\tctx->num_speakers = numSpeakers;\n\tctx->copy_props = GF_FALSE;\n\n\tchan_layout = 0;\n\tnb_channels = 0;\n\tif (CICPspeakerLayoutIdx>=0) {\n\t\tchan_layout = gf_audio_fmt_get_layout_from_cicp(CICPspeakerLayoutIdx);\n\t\tnb_channels = gf_audio_fmt_get_num_channels_from_layout(chan_layout);\n\t} else if (numSpeakers>=0) {\n\t\tnb_channels = numSpeakers;\n\t}\n\n\t//copy properties at init or reconfig\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT( GF_STREAM_AUDIO));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL );\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\tif (!ctx->timescale)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_TRUE ) );\n\n\tif (!ctx->timescale) gf_filter_pid_set_name(ctx->opid, \"audio\");\n\n\tif (ctx->mpha) {\n\t\tu8 *data = gf_malloc(sizeof(u8) * (dsi_size+5) );\n\t\tif (!data) return;\n\t\tdata[0] = 1;\n\t\tdata[1] = PL;\n\t\tdata[2] = CICPspeakerLayoutIdx;\n\t\tdata[3] = dsi_size>>8;\n\t\tdata[4] = dsi_size&0xFF;\n\t\tmemcpy(data+5, dsi, dsi_size);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT( GF_CODECID_MPHA ) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, & PROP_DATA_NO_COPY( data, (dsi_size+5) ) );\n\t} else {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT( GF_CODECID_MHAS ) );\n\t}\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : ctx->sample_rate));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(ctx->sample_rate));\n\tif (chan_layout)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CHANNEL_LAYOUT, & PROP_LONGUINT(chan_layout) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NUM_CHANNELS, & PROP_UINT(nb_channels) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLES_PER_FRAME, & PROP_UINT(ctx->frame_len) );\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n}\n\nstatic Bool mhas_dmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tGF_FilterEvent fevt;\n\tGF_MHASDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (evt->base.on_pid != ctx->opid) return GF_TRUE;\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t}\n\t\tif (! ctx->is_file) {\n\t\t\tif (evt->play.start_range || ctx->initial_play_done) {\n\t\t\t\tctx->mhas_buffer_size = 0;\n\t\t\t\tctx->resume_from = 0;\n\t\t\t}\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tmhas_dmx_check_dur(filter, ctx);\n\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\t\tctx->file_pos = 0;\n\t\tif (ctx->start_range) {\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif (ctx->indexes[i].duration>ctx->start_range) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].duration * ctx->sample_rate);\n\t\t\t\t\tctx->file_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!ctx->file_pos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tctx->mhas_buffer_size = 0;\n\t\tctx->resume_from = 0;\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = ctx->file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\tctx->is_playing = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = NULL;\n\t\tctx->cts = 0;\n\t\t//don't cancel event\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void mhas_dmx_update_cts(GF_MHASDmxCtx *ctx)\n{\n\tif (ctx->timescale) {\n\t\tu64 inc = ctx->frame_len;\n\t\tinc *= ctx->timescale;\n\t\tinc /= ctx->sample_rate;\n\t\tctx->cts += inc;\n\t} else {\n\t\tctx->cts += ctx->frame_len;\n\t}\n}\n\n#ifndef GPAC_DISABLE_LOG\nstatic const char *mhas_pck_name(u32 pck_type)\n{\n\tswitch (pck_type) {\n\tcase 0: return \"FILL_DATA\";\n\tcase 1: return \"MPEGH3DACFG\";\n\tcase 2: return \"MPEGH3DAFRAME\";\n\tcase 3: return \"AUDIOSCENEINFO\";\n\tcase 6: return \"SYNC\";\n\tcase 7: return \"SYNCGAP\";\n\tcase 8: return \"MARKER\";\n\tcase 9: return \"CRC16\";\n\tcase 10: return \"CRC32\";\n\tcase 11: return \"DESCRIPTOR\";\n\tcase 12: return \"USERINTERACTION\";\n\tcase 13: return \"LOUDNESS_DRC\";\n\tcase 14: return \"BUFFERINFO\";\n\tcase 15: return \"GLOBAL_CRC16\";\n\tcase 16: return \"GLOBAL_CRC32\";\n\tcase 17: return \"AUDIOTRUNCATION\";\n\tcase 18: return \"GENDATA\";\n\tcase 4:\n\tcase 5:\n\tdefault:\n\t\treturn \"ISOReserved\";\n\t}\n\treturn \"error\";\n}\n#endif\n\nGF_Err mhas_dmx_process(GF_Filter *filter)\n{\n\tGF_MHASDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *in_pck;\n\tu8 *output;\n\tu8 *start;\n\tBool final_flush=GF_FALSE;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\tu32 au_start = 0;\n\tu32 consumed = 0;\n\tu32 nb_trunc_samples = 0;\n\tBool trunc_from_begin = 0;\n\tBool has_cfg = 0;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmhas_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tin_pck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!in_pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->mhas_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t\tfinal_flush = GF_TRUE;\n\t\t} else if (!ctx->resume_from) {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->mhas_buffer_size;\n\tif (ctx->resume_from)\n\t\tin_pck = NULL;\n\n\tif (in_pck) {\n\t\tu8 *data = (u8 *) gf_filter_pck_get_data(in_pck, &pck_size);\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(in_pck);\n\t\t\tif (!ctx->mhas_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->mhas_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->mhas_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->mhas_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->mhas_buffer_size + pck_size > ctx->mhas_buffer_alloc) {\n\t\t\tctx->mhas_buffer_alloc = ctx->mhas_buffer_size + pck_size;\n\t\t\tctx->mhas_buffer = gf_realloc(ctx->mhas_buffer, ctx->mhas_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->mhas_buffer + ctx->mhas_buffer_size, data, pck_size);\n\t\tctx->mhas_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && in_pck) {\n\t\tcts = gf_filter_pck_get_cts(in_pck);\n\t\t//init cts at first packet\n\t\tif (!ctx->cts && (cts != GF_FILTER_NO_TS))\n\t\t\tctx->cts = cts;\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->mhas_buffer_size;\n\tstart = ctx->mhas_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\twhile (ctx->nosync && (remain>3)) {\n\t\t//wait till we have a frame header\n\t\tu8 *hdr_start = memchr(start, 0xC0, remain);\n\t\tif (!hdr_start) {\n\t\t\tremain=0;\n\t\t\tbreak;\n\t\t}\n\t\tif ((hdr_start[1]==0x01) && (hdr_start[2]==0xA5)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] Sync found !\\n\"));\n\t\t\tctx->nosync = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] not sync, skipping byte\\n\"));\n\t\tstart++;\n\t\tremain--;\n\t}\n\tif (ctx->nosync)\n\t\tgoto skip;\n\n\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\tctx->buffer_too_small = GF_FALSE;\n\n\t//MHAS packet\n\twhile (remain > consumed) {\n\t\tu32 pay_start, parse_end, mhas_size, mhas_label;\n\t\tBool mhas_sap = 0;\n\t\tu32 mhas_type;\n\t\tif (!ctx->is_playing && ctx->opid) {\n\t\t\tctx->resume_from = 1;\n\t\t\tconsumed = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmhas_type = (u32) gf_mpegh_escaped_value(ctx->bs, 3, 8, 8);\n\t\tmhas_label = (u32) gf_mpegh_escaped_value(ctx->bs, 2, 8, 32);\n\t\tmhas_size = (u32) gf_mpegh_escaped_value(ctx->bs, 11, 24, 24);\n\n\t\tif (ctx->buffer_too_small)\n\t\t\tbreak;\n\n\n\t\tif (mhas_type>18) {\n\t\t\tctx->nb_unknown_pck++;\n\t\t\tif (ctx->nb_unknown_pck > ctx->pcksync) {\n\t\t\t\tGF_LOG(ctx->is_sync ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] %d packets of unknown type, considering sync was lost\\n\"));\n\t\t\t\tctx->is_sync = GF_FALSE;\n\t\t\t\tconsumed = 0;\n\t\t\t\tctx->nosync = GF_TRUE;\n\t\t\t\tctx->nb_unknown_pck = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!mhas_size) {\n\t\t\tGF_LOG(ctx->is_sync ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] MHAS packet with 0 payload size, considering sync was lost\\n\"));\n\t\t\tctx->is_sync = GF_FALSE;\n\t\t\tconsumed = 0;\n\t\t\tctx->nosync = GF_TRUE;\n\t\t\tctx->nb_unknown_pck = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tpay_start = (u32) gf_bs_get_position(ctx->bs);\n\n\t\tif (ctx->buffer_too_small) break;\n\t\tif (mhas_size > gf_bs_available(ctx->bs)) {\n\t\t\t//incomplete frame, keep in buffer\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] incomplete packet type %d %s label \"LLU\" size \"LLU\" - keeping in buffer\\n\", mhas_type, mhas_pck_name(mhas_type), mhas_label, mhas_size));\n\t\t\tbreak;\n\t\t}\n\t\tctx->is_sync = GF_TRUE;\n\n\t\t//frame\n\t\tif (mhas_type==2) {\n\t\t\tmhas_sap = gf_bs_peek_bits(ctx->bs, 1, 0);\n\t\t\tctx->nb_unknown_pck = 0;\n\t\t}\n\t\t//config\n\t\telse if (mhas_type==1) {\n\t\t\ts32 CICPspeakerLayoutIdx = -1;\n\t\t\ts32 numSpeakers = -1;\n\t\t\tu32 sr = 0;\n\t\t\tu32 frame_len;\n\t\t\tu32 pl = gf_bs_read_u8(ctx->bs);\n\t\t\tu32 idx = gf_bs_read_int(ctx->bs, 5);\n\t\t\tif (idx==0x1f)\n\t\t\t\tsr = gf_bs_read_int(ctx->bs, 24);\n\t\t\telse if (sr < nb_usac_sr) {\n\t\t\t\tsr = USACSampleRates[idx];\n\t\t\t}\n\t\t\tctx->nb_unknown_pck = 0;\n\t\t\tidx = gf_bs_read_int(ctx->bs, 3);\n\t\t\tif ((idx==0) || (idx==2) ) frame_len = 768;\n\t\t\telse frame_len = 1024;\n\t\t\tgf_bs_read_int(ctx->bs, 1);\n\t\t\tgf_bs_read_int(ctx->bs, 1);\n\n\t\t\t//speaker config\n\t\t\tu32 speakerLayoutType = gf_bs_read_int(ctx->bs, 2);\n\t\t\tif (speakerLayoutType == 0) {\n\t\t\t\tCICPspeakerLayoutIdx = gf_bs_read_int(ctx->bs, 6);\n\t\t\t} else {\n\t\t\t\tnumSpeakers = (s32) gf_mpegh_escaped_value(ctx->bs, 5, 8, 16) + 1;\n\t\t\t\t//TODO ...\n\t\t\t}\n\n\t\t\tmhas_dmx_check_pid(filter, ctx, pl, sr, frame_len, CICPspeakerLayoutIdx, numSpeakers, start + pay_start, (u32) mhas_size);\n\n\t\t\thas_cfg = GF_TRUE;\n\t\t}\n\t\t//audio truncation\n\t\telse if (mhas_type==17) {\n\t\t\tBool isActive = gf_bs_read_int(ctx->bs, 1);\n\t\t\t/*Bool ati_reserved = */gf_bs_read_int(ctx->bs, 1);\n\t\t\ttrunc_from_begin = gf_bs_read_int(ctx->bs, 1);\n\t\t\tnb_trunc_samples = gf_bs_read_int(ctx->bs, 13);\n\t\t\tif (!isActive) {\n\t\t\t\tnb_trunc_samples = 0;\n\t\t\t}\n\t\t}\n\t\t//sync, syncgap\n\t\telse if ((mhas_type==6) || (mhas_type==7)) {\n\t\t\tctx->nb_unknown_pck = 0;\n\t\t}\n#if 0\n\t\t//MARKER\n\t\telse if (mhas_type==8) {\n\t\t\tu8 marker_type = gf_bs_read_u8(ctx->bs);\n\t\t\t//config reload force\n\t\t\tif (marker_type==0x01) {}\n\t\t\t//SAP\n\t\t\telse if (marker_type==0x02) {\n\t\t\t\thas_marker = GF_TRUE;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tgf_bs_align(ctx->bs);\n\t\tparse_end = (u32) gf_bs_get_position(ctx->bs) - pay_start;\n\t\t//remaining of packet payload\n\t\tgf_bs_skip_bytes(ctx->bs, mhas_size - parse_end);\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] MHAS Packet type %d %s label \"LLU\" size \"LLU\"\\n\", mhas_type, mhas_pck_name(mhas_type), mhas_label, mhas_size));\n\n\t\tif (ctx->timescale && !prev_pck_size && (cts != GF_FILTER_NO_TS) ) {\n\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\t//frame\n\t\tif ((mhas_type==2) && ctx->opid) {\n\t\t\tGF_FilterPacket *dst;\n\t\t\tu64 pck_dur = ctx->frame_len;\n\n\n\t\t\tu32 au_size;\n\t\t\tif (ctx->mpha) {\n\t\t\t\tau_start = pay_start;\n\t\t\t\tau_size = mhas_size;\n\t\t\t} else {\n\t\t\t\tau_size = (u32) gf_bs_get_position(ctx->bs) - au_start;\n\t\t\t}\n\n\t\t\tif (nb_trunc_samples) {\n\t\t\t\tif (trunc_from_begin) {\n\t\t\t\t\tif (!ctx->nb_frames) {\n\t\t\t\t\t\ts64 offset = trunc_from_begin;\n\t\t\t\t\t\tif (ctx->timescale) {\n\t\t\t\t\t\t\toffset *= ctx->timescale;\n\t\t\t\t\t\t\toffset /= ctx->sample_rate;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DELAY , &PROP_LONGSINT( -offset));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpck_dur -= nb_trunc_samples;\n\t\t\t\t}\n\t\t\t\tnb_trunc_samples = 0;\n\t\t\t}\n\n\t\t\tif (ctx->timescale) {\n\t\t\t\tpck_dur *= ctx->timescale;\n\t\t\t\tpck_dur /= ctx->sample_rate;\n\t\t\t}\n\n\t\t\tdst = gf_filter_pck_new_alloc(ctx->opid, au_size, &output);\n\t\t\tif (!dst) break;\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst);\n\n\t\t\tmemcpy(output, start + au_start, au_size);\n\t\t\tif (!has_cfg)\n\t\t\t\tmhas_sap = 0;\n\n\t\t\tif (mhas_sap) {\n\t\t\t\tgf_filter_pck_set_sap(dst, GF_FILTER_SAP_1);\n\t\t\t}\n\t\t\tgf_filter_pck_set_dts(dst, ctx->cts);\n\t\t\tgf_filter_pck_set_cts(dst, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst, (u32) pck_dur);\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tu64 offset = (u64) (start - ctx->mhas_buffer);\n\t\t\t\toffset += ctx->byte_offset + au_start;\n\t\t\t\tgf_filter_pck_set_byte_offset(dst, offset);\n\t\t\t}\n \t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] Send AU CTS \"LLU\" size %d dur %d sap %d\\n\", ctx->cts, au_size, (u32) pck_dur, mhas_sap));\n\t\t\tgf_filter_pck_send(dst);\n\n\t\t\tau_start += au_size;\n\t\t\tconsumed = au_start;\n\t\t\tctx->nb_frames ++;\n\n\t\t\tmhas_dmx_update_cts(ctx);\n\t\t\thas_cfg = 0;\n\n\t\t\tif (prev_pck_size) {\n\t\t\t\tu64 next_pos = (u64) (start + au_start - ctx->mhas_buffer);\n\t\t\t\t//next will be in new packet\n\t\t\t\tif (prev_pck_size <= next_pos) {\n\t\t\t\t\tprev_pck_size = 0;\n\t\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\t\tctx->src_pck = in_pck;\n\t\t\t\t\tif (in_pck)\n\t\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\n\t\t\t\t\tif (ctx->timescale && (cts != GF_FILTER_NO_TS) ) {\n\t\t\t\t\t\tctx->cts = cts;\n\t\t\t\t\t\tcts = GF_FILTER_NO_TS;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (remain==consumed)\n\t\t\t\tbreak;\n\n\t\t\tif (gf_filter_pid_would_block(ctx->opid)) {\n\t\t\t\tctx->resume_from = 1;\n\t\t\t\tfinal_flush = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (consumed) {\n\t\tassert(remain>=consumed);\n\t\tremain -= consumed;\n\t\tstart += consumed;\n\t}\n\nskip:\n\n\tif (remain < ctx->mhas_buffer_size) {\n\t\tmemmove(ctx->mhas_buffer, start, remain);\n\t\t//update byte offset\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += ctx->mhas_buffer_size - remain;\n\t}\n\tctx->mhas_buffer_size = remain;\n\tif (final_flush)\n\t\tctx->mhas_buffer_size = 0;\n\n\tif (!ctx->mhas_buffer_size) {\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = NULL;\n\t}\n\n\tif (in_pck)\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\treturn GF_OK;\n}\n\nstatic void mhas_buffer_too_small(void *udta)\n{\n\tGF_MHASDmxCtx *ctx = (GF_MHASDmxCtx *) udta;\n\tctx->buffer_too_small = GF_TRUE;\n}\n\nstatic GF_Err mhas_dmx_initialize(GF_Filter *filter)\n{\n\tGF_MHASDmxCtx *ctx = gf_filter_get_udta(filter);\n\tctx->bs = gf_bs_new((u8 *)ctx, 1, GF_BITSTREAM_READ);\n\tgf_bs_set_eos_callback(ctx->bs, mhas_buffer_too_small, ctx);\n\treturn GF_OK;\n}\nstatic void mhas_dmx_finalize(GF_Filter *filter)\n{\n\tGF_MHASDmxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->bs) gf_bs_del(ctx->bs);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n\tif (ctx->mhas_buffer) gf_free(ctx->mhas_buffer);\n\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n}\n\n\nstatic const char *mhas_dmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\ts32 sync_pos = -1;\n\tGF_BitStream *bs;\n\tu32 nb_mhas_cfg = 0;\n\tu32 nb_mhas_frames = 0;\n\tu32 nb_mhas_unknown = 0;\n\tconst u8 *ptr = data;\n\twhile (ptr) {\n\t\tu32 pos = (u32) (ptr - data);\n\t\tconst u8 *sync_start = memchr(ptr, 0xC0, size - pos);\n\t\tif (!sync_start) return NULL;\n\t\tif ((sync_start[1]== 0x01) && (sync_start[2]==0xA5)) {\n\t\t\tsync_pos = pos;\n\t\t\tbreak;\n\t\t}\n\t\tptr = sync_start+1;\n\t}\n\tif (sync_pos<0) return NULL;\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tgf_bs_skip_bytes(bs, sync_pos);\n\n\twhile (gf_bs_available(bs)) {\n\t\tu32 type = (u32) gf_mpegh_escaped_value(bs, 3, 8, 8);\n\t\t/*u64 label = */gf_mpegh_escaped_value(bs, 2, 8, 32);\n\t\tu64 mh_size = gf_mpegh_escaped_value(bs, 11, 24, 24);\n\t\tif (mh_size > gf_bs_available(bs))\n\t\t\tbreak;\n\t\t//MHAS config\n\t\tif (type==1) nb_mhas_cfg++;\n\t\telse if (type==2) nb_mhas_frames++;\n\t\telse if (type>18) nb_mhas_unknown++;\n\t\tgf_bs_skip_bytes(bs, mh_size);\n\t}\n\tgf_bs_del(bs);\n\tif (!nb_mhas_unknown && nb_mhas_cfg && nb_mhas_frames) {\n\t\t*score = GF_FPROBE_SUPPORTED;\n\t\treturn \"audio/mpegh\";\n\t}\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability MHASDmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"mhas\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/mpegh\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_MHAS),\n\tCAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_CODECID, GF_CODECID_MHAS),\n\tCAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n};\n\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_MHASDmxCtx, _n)\nstatic const GF_FilterArgs MHASDmxArgs[] =\n{\n\t{ OFFS(index), \"indexing window length\", GF_PROP_DOUBLE, \"1.0\", NULL, 0},\n\t{ OFFS(mpha), \"demultiplex MHAS and only forward audio frames\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(pcksync), \"number of unknown packets to tolerate before considering sync is lost\", GF_PROP_UINT, \"4\", NULL, 0},\n\t{ OFFS(nosync), \"initial sync state\", GF_PROP_BOOL, \"true\", NULL, 0},\n\n\t{0}\n};\n\n\nGF_FilterRegister MHASDmxRegister = {\n\t.name = \"rfmhas\",\n\tGF_FS_SET_DESCRIPTION(\"MPEH-H Audio Stream reframer\")\n\tGF_FS_SET_HELP(\"This filter parses MHAS files/data and outputs corresponding audio PID and frames.\\n\"\n\t\t\"By default, the filter expects a MHAS stream with SYNC packets set, otherwise tune-in will fail. Using [-nosync]()=false can help parsing bitstreams with no SYNC packets.\\n\"\n\t\t\"The default behavior is to dispatch a framed MHAS bitstream. To demultiplex into a raw MPEG-H Audio, use [-mpha]().\\n\"\n\t\t)\n\t.private_size = sizeof(GF_MHASDmxCtx),\n\t.args = MHASDmxArgs,\n\t.finalize = mhas_dmx_finalize,\n\t.initialize = mhas_dmx_initialize,\n\tSETCAPS(MHASDmxCaps),\n\t.configure_pid = mhas_dmx_configure_pid,\n\t.process = mhas_dmx_process,\n\t.probe_data = mhas_dmx_probe_data,\n\t.process_event = mhas_dmx_process_event\n};\n\n\nconst GF_FilterRegister *mhas_dmx_register(GF_FilterSession *session)\n{\n\treturn &MHASDmxRegister;\n}\n\n#else\n\nconst GF_FilterRegister *mhas_dmx_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif //#if !defined(GPAC_DISABLE_AV_PARSERS)\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2020-2022\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / MHAS reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\n\nstatic u32 USACSampleRates[] = {96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, 0, 0,\n\t57600, 51200, 40000, 38400, 34150, 28800, 25600, 20000, 19200, 17075, 14400, 12800, 9600};\n\nstatic u32 nb_usac_sr = GF_ARRAY_LENGTH(USACSampleRates);\n\n\ntypedef struct\n{\n\tu64 pos;\n\tDouble duration;\n} MHASIdx;\n\ntypedef struct\n{\n\t//filter args\n\tDouble index;\n\tBool mpha;\n\tu32 pcksync;\n\tBool nosync;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tGF_BitStream *bs;\n\tu64 file_pos, cts, prev_cts;\n\n\tGF_Fraction64 duration;\n\tDouble start_range;\n\tBool in_seek;\n\tu32 timescale;\n\tBool is_playing;\n\tBool is_file;\n\tBool initial_play_done, file_loaded;\n\n\tBool initialized;\n\n\tu8 *mhas_buffer;\n\tu32 mhas_buffer_size, mhas_buffer_alloc, resume_from;\n\tu64 byte_offset;\n\tBool buffer_too_small;\n\n\tGF_FilterPacket *src_pck;\n\n\tBool recompute_cts;\n\tMHASIdx *indexes;\n\tu32 index_alloc_size, index_size;\n\n\tu32 sample_rate, frame_len, PL;\n\ts32 cicp_layout_idx, num_speakers;\n\tu32 nb_frames;\n\n\tu32 nb_unknown_pck;\n\tu32 bitrate;\n\tBool copy_props;\n\tBool is_sync;\n} GF_MHASDmxCtx;\n\n\n\n\nGF_Err mhas_dmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_MHASDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) {\n\t\tctx->timescale = p->value.uint;\n\t\t//if stream comes from TS or other muxed source unframed, force initial sync check\n\t\tif (!ctx->ipid) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_UNFRAMED);\n\t\t\tif (p && p->value.boolean)\n\t\t\t\tctx->nosync = GF_TRUE;\n\t\t}\n\t}\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property_str(pid, \"nocts\");\n\tif (p && p->value.boolean) ctx->recompute_cts = GF_TRUE;\n\telse ctx->recompute_cts = GF_FALSE;\n\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t}\n\tif (ctx->timescale) ctx->copy_props = GF_TRUE;\n\treturn GF_OK;\n}\n\nstatic void mhas_dmx_check_dur(GF_Filter *filter, GF_MHASDmxCtx *ctx)\n{\n\tGF_Fraction64 duration;\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tu32 frame_len, cur_dur;\n\tBool mhas_sap;\n\tu64 mhas_last_cfg, rate;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<=0) {\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen_ex(p->value.string, NULL, \"rb\", GF_TRUE);\n\tif (!stream) {\n\t\tif (gf_fileio_is_main_thread(p->value.string))\n\t\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\tduration.num = duration.den = 0;\n\tframe_len = cur_dur = 0;\n\tmhas_last_cfg = 0;\n\n\twhile (gf_bs_available(bs)) {\n\t\tu32 sync_code = gf_bs_peek_bits(bs, 24, 0);\n\t\tif (sync_code == 0xC001A5) {\n\t\t\tbreak;\n\t\t}\n\t\tgf_bs_skip_bytes(bs, 1);\n\t}\n\twhile (gf_bs_available(bs)) {\n\t\tu64 mhas_pck_start, pay_start, parse_end, mhas_size;\n\t\tu32 mhas_type;\n\n\t\tmhas_pck_start = gf_bs_get_position(bs);\n\t\tmhas_type = (u32) gf_mpegh_escaped_value(bs, 3, 8, 8);\n\t\t/*mhas_label = */gf_mpegh_escaped_value(bs, 2, 8, 32);\n\t\tmhas_size = gf_mpegh_escaped_value(bs, 11, 24, 24);\n\n\t\tpay_start = (u32) gf_bs_get_position(bs);\n\n\t\tif (!gf_bs_available(bs) ) break;\n\t\tif (mhas_size > gf_bs_available(bs)) break;\n\n\t\tmhas_sap = 0;\n\t\t//frame\n\t\tif (mhas_type==2) {\n\t\t\tmhas_sap = gf_bs_read_int(bs, 1);\n\t\t\tif (!mhas_last_cfg) mhas_sap = 0;\n\t\t//config\n\t\t} else if (mhas_type==1) {\n\t\t\t/*u32 pl = */gf_bs_read_u8(bs);\n\t\t\tu32 idx = gf_bs_read_int(bs, 5);\n\t\t\tif (idx==0x1f)\n\t\t\t\tduration.den = gf_bs_read_int(bs, 24);\n\t\t\telse if (idx < nb_usac_sr) {\n\t\t\t\tduration.den = USACSampleRates[idx];\n\t\t\t}\n\t\t\tidx = gf_bs_read_int(bs, 3);\n\t\t\tif ((idx==0) || (idx==2) ) frame_len = 768;\n\t\t\telse frame_len = 1024;\n\n\t\t\tmhas_last_cfg = mhas_pck_start;\n\t\t}\n\t\t//audio truncation\n\t\telse if (mhas_type==17) {\n\t\t\tBool isActive = gf_bs_read_int(bs, 1);\n\t\t\t/*Bool ati_reserved = */gf_bs_read_int(bs, 1);\n\t\t\tBool trunc_from_begin = gf_bs_read_int(bs, 1);\n\t\t\tu32 nb_trunc_samples = gf_bs_read_int(bs, 13);\n\t\t\tif (isActive && !trunc_from_begin) {\n\t\t\t\tduration.num -= nb_trunc_samples;\n\t\t\t}\n\t\t}\n\t\tgf_bs_align(bs);\n\t\tparse_end = (u32) gf_bs_get_position(bs) - pay_start;\n\t\t//remaining of packet payload\n\t\tgf_bs_skip_bytes(bs, mhas_size - parse_end);\n\n\t\t//mhas_sap only set for frames\n\t\tif (mhas_sap && duration.den && (cur_dur >= ctx->index * duration.den) ) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(MHASIdx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = mhas_last_cfg;\n\t\t\tctx->indexes[ctx->index_size].duration = ((Double) duration.num) / duration.den;\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\t\tif (mhas_type==2) {\n\t\t\tduration.num += frame_len;\n\t\t\tcur_dur += frame_len;\n\t\t\tmhas_last_cfg = 0;\n\t\t}\n\t}\n\n\trate = gf_bs_get_position(bs);\n\tgf_bs_del(bs);\n\tgf_fclose(stream);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * duration.den != duration.num * ctx->duration.den)) {\n\t\tctx->duration = duration;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\tif (duration.num && !gf_sys_is_test_mode() ) {\n\t\t\trate *= 8 * ctx->duration.den;\n\t\t\trate /= ctx->duration.num;\n\t\t\tctx->bitrate = (u32) rate;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n}\n\nstatic void mhas_dmx_check_pid(GF_Filter *filter, GF_MHASDmxCtx *ctx, u32 PL, u32 sample_rate, u32 frame_len, s32 CICPspeakerLayoutIdx, s32 numSpeakers, u8 *dsi, u32 dsi_size)\n{\n\tu32 nb_channels;\n\tu64 chan_layout;\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tmhas_dmx_check_dur(filter, ctx);\n\t} else {\n\t\tif ((ctx->frame_len == frame_len)\n\t\t\t&& (ctx->PL == PL)\n\t\t\t&& (ctx->sample_rate == sample_rate)\n\t\t\t&& (ctx->cicp_layout_idx == CICPspeakerLayoutIdx)\n\t\t\t&& (ctx->num_speakers == numSpeakers)\n\t\t\t&& !ctx->copy_props\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t}\n\tctx->frame_len = frame_len;\n\tctx->PL = PL;\n\tctx->sample_rate = sample_rate;\n\tctx->cicp_layout_idx = CICPspeakerLayoutIdx;\n\tctx->num_speakers = numSpeakers;\n\tctx->copy_props = GF_FALSE;\n\n\tchan_layout = 0;\n\tnb_channels = 0;\n\tif (CICPspeakerLayoutIdx>=0) {\n\t\tchan_layout = gf_audio_fmt_get_layout_from_cicp(CICPspeakerLayoutIdx);\n\t\tnb_channels = gf_audio_fmt_get_num_channels_from_layout(chan_layout);\n\t} else if (numSpeakers>=0) {\n\t\tnb_channels = numSpeakers;\n\t}\n\n\t//copy properties at init or reconfig\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT( GF_STREAM_AUDIO));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL );\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\tif (!ctx->timescale)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_TRUE ) );\n\n\tif (!ctx->timescale) gf_filter_pid_set_name(ctx->opid, \"audio\");\n\n\tif (ctx->mpha) {\n\t\tu8 *data = gf_malloc(sizeof(u8) * (dsi_size+5) );\n\t\tif (!data) return;\n\t\tdata[0] = 1;\n\t\tdata[1] = PL;\n\t\tdata[2] = CICPspeakerLayoutIdx;\n\t\tdata[3] = dsi_size>>8;\n\t\tdata[4] = dsi_size&0xFF;\n\t\tmemcpy(data+5, dsi, dsi_size);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT( GF_CODECID_MPHA ) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, & PROP_DATA_NO_COPY( data, (dsi_size+5) ) );\n\t} else {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT( GF_CODECID_MHAS ) );\n\t}\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : ctx->sample_rate));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(ctx->sample_rate));\n\tif (chan_layout)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CHANNEL_LAYOUT, & PROP_LONGUINT(chan_layout) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NUM_CHANNELS, & PROP_UINT(nb_channels) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLES_PER_FRAME, & PROP_UINT(ctx->frame_len) );\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n}\n\nstatic Bool mhas_dmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tGF_FilterEvent fevt;\n\tGF_MHASDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (evt->base.on_pid != ctx->opid) return GF_TRUE;\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t}\n\t\tif (! ctx->is_file) {\n\t\t\tif (evt->play.start_range || ctx->initial_play_done) {\n\t\t\t\tctx->mhas_buffer_size = 0;\n\t\t\t\tctx->resume_from = 0;\n\t\t\t}\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tmhas_dmx_check_dur(filter, ctx);\n\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\t\tctx->file_pos = 0;\n\t\tif (ctx->start_range) {\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif (ctx->indexes[i].duration>ctx->start_range) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].duration * ctx->sample_rate);\n\t\t\t\t\tctx->file_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!ctx->file_pos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tctx->mhas_buffer_size = 0;\n\t\tctx->resume_from = 0;\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = ctx->file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\tctx->is_playing = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = NULL;\n\t\tctx->cts = 0;\n\t\t//don't cancel event\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void mhas_dmx_update_cts(GF_MHASDmxCtx *ctx)\n{\n\tif (ctx->timescale) {\n\t\tu64 inc = ctx->frame_len;\n\t\tinc *= ctx->timescale;\n\t\tinc /= ctx->sample_rate;\n\t\tctx->cts += inc;\n\t} else {\n\t\tctx->cts += ctx->frame_len;\n\t}\n}\n\n#ifndef GPAC_DISABLE_LOG\nstatic const char *mhas_pck_name(u32 pck_type)\n{\n\tswitch (pck_type) {\n\tcase 0: return \"FILL_DATA\";\n\tcase 1: return \"MPEGH3DACFG\";\n\tcase 2: return \"MPEGH3DAFRAME\";\n\tcase 3: return \"AUDIOSCENEINFO\";\n\tcase 6: return \"SYNC\";\n\tcase 7: return \"SYNCGAP\";\n\tcase 8: return \"MARKER\";\n\tcase 9: return \"CRC16\";\n\tcase 10: return \"CRC32\";\n\tcase 11: return \"DESCRIPTOR\";\n\tcase 12: return \"USERINTERACTION\";\n\tcase 13: return \"LOUDNESS_DRC\";\n\tcase 14: return \"BUFFERINFO\";\n\tcase 15: return \"GLOBAL_CRC16\";\n\tcase 16: return \"GLOBAL_CRC32\";\n\tcase 17: return \"AUDIOTRUNCATION\";\n\tcase 18: return \"GENDATA\";\n\tcase 4:\n\tcase 5:\n\tdefault:\n\t\treturn \"ISOReserved\";\n\t}\n\treturn \"error\";\n}\n#endif\n\nGF_Err mhas_dmx_process(GF_Filter *filter)\n{\n\tGF_MHASDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *in_pck;\n\tu8 *output;\n\tu8 *start;\n\tBool final_flush=GF_FALSE;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts = GF_FILTER_NO_TS;\n\tu32 au_start = 0;\n\tu32 consumed = 0;\n\tu32 nb_trunc_samples = 0;\n\tBool trunc_from_begin = 0;\n\tBool has_cfg = 0;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmhas_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tin_pck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!in_pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->mhas_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t\tfinal_flush = GF_TRUE;\n\t\t} else if (!ctx->resume_from) {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->mhas_buffer_size;\n\tif (ctx->resume_from)\n\t\tin_pck = NULL;\n\n\tif (in_pck) {\n\t\tu8 *data = (u8 *) gf_filter_pck_get_data(in_pck, &pck_size);\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(in_pck);\n\t\t\tif (!ctx->mhas_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->mhas_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->mhas_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->mhas_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->mhas_buffer_size + pck_size > ctx->mhas_buffer_alloc) {\n\t\t\tctx->mhas_buffer_alloc = ctx->mhas_buffer_size + pck_size;\n\t\t\tctx->mhas_buffer = gf_realloc(ctx->mhas_buffer, ctx->mhas_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->mhas_buffer + ctx->mhas_buffer_size, data, pck_size);\n\t\tctx->mhas_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && in_pck) {\n\t\tcts = gf_filter_pck_get_cts(in_pck);\n\t\t//init cts at first packet\n\t\tif (!ctx->cts && (cts != GF_FILTER_NO_TS))\n\t\t\tctx->cts = cts;\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->mhas_buffer_size;\n\tstart = ctx->mhas_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\twhile (ctx->nosync && (remain>3)) {\n\t\t//wait till we have a frame header\n\t\tu8 *hdr_start = memchr(start, 0xC0, remain);\n\t\tif (!hdr_start) {\n\t\t\tremain=0;\n\t\t\tbreak;\n\t\t}\n\t\tif ((hdr_start[1]==0x01) && (hdr_start[2]==0xA5)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] Sync found !\\n\"));\n\t\t\tctx->nosync = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] not sync, skipping byte\\n\"));\n\t\tstart++;\n\t\tremain--;\n\t}\n\tif (ctx->nosync)\n\t\tgoto skip;\n\n\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\tctx->buffer_too_small = GF_FALSE;\n\n\t//MHAS packet\n\twhile (remain > consumed) {\n\t\tu32 pay_start, parse_end, mhas_size, mhas_label;\n\t\tBool mhas_sap = 0;\n\t\tu32 mhas_type;\n\t\tif (!ctx->is_playing && ctx->opid) {\n\t\t\tctx->resume_from = 1;\n\t\t\tconsumed = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmhas_type = (u32) gf_mpegh_escaped_value(ctx->bs, 3, 8, 8);\n\t\tmhas_label = (u32) gf_mpegh_escaped_value(ctx->bs, 2, 8, 32);\n\t\tmhas_size = (u32) gf_mpegh_escaped_value(ctx->bs, 11, 24, 24);\n\n\t\tif (ctx->buffer_too_small)\n\t\t\tbreak;\n\n\n\t\tif (mhas_type>18) {\n\t\t\tctx->nb_unknown_pck++;\n\t\t\tif (ctx->nb_unknown_pck > ctx->pcksync) {\n\t\t\t\tGF_LOG(ctx->is_sync ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] %d packets of unknown type, considering sync was lost\\n\"));\n\t\t\t\tctx->is_sync = GF_FALSE;\n\t\t\t\tconsumed = 0;\n\t\t\t\tctx->nosync = GF_TRUE;\n\t\t\t\tctx->nb_unknown_pck = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!mhas_size) {\n\t\t\tGF_LOG(ctx->is_sync ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] MHAS packet with 0 payload size, considering sync was lost\\n\"));\n\t\t\tctx->is_sync = GF_FALSE;\n\t\t\tconsumed = 0;\n\t\t\tctx->nosync = GF_TRUE;\n\t\t\tctx->nb_unknown_pck = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tpay_start = (u32) gf_bs_get_position(ctx->bs);\n\n\t\tif (ctx->buffer_too_small) break;\n\t\tif (mhas_size > gf_bs_available(ctx->bs)) {\n\t\t\t//incomplete frame, keep in buffer\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] incomplete packet type %d %s label \"LLU\" size \"LLU\" - keeping in buffer\\n\", mhas_type, mhas_pck_name(mhas_type), mhas_label, mhas_size));\n\t\t\tbreak;\n\t\t}\n\t\tctx->is_sync = GF_TRUE;\n\n\t\t//frame\n\t\tif (mhas_type==2) {\n\t\t\tmhas_sap = gf_bs_peek_bits(ctx->bs, 1, 0);\n\t\t\tctx->nb_unknown_pck = 0;\n\t\t}\n\t\t//config\n\t\telse if (mhas_type==1) {\n\t\t\ts32 CICPspeakerLayoutIdx = -1;\n\t\t\ts32 numSpeakers = -1;\n\t\t\tu32 sr = 0;\n\t\t\tu32 frame_len;\n\t\t\tu32 pl = gf_bs_read_u8(ctx->bs);\n\t\t\tu32 idx = gf_bs_read_int(ctx->bs, 5);\n\t\t\tif (idx==0x1f)\n\t\t\t\tsr = gf_bs_read_int(ctx->bs, 24);\n\t\t\telse if (idx < nb_usac_sr) {\n\t\t\t\tsr = USACSampleRates[idx];\n\t\t\t}\n\t\t\tctx->nb_unknown_pck = 0;\n\t\t\tidx = gf_bs_read_int(ctx->bs, 3);\n\t\t\tif ((idx==0) || (idx==2) ) frame_len = 768;\n\t\t\telse frame_len = 1024;\n\t\t\tgf_bs_read_int(ctx->bs, 1);\n\t\t\tgf_bs_read_int(ctx->bs, 1);\n\n\t\t\t//speaker config\n\t\t\tu32 speakerLayoutType = gf_bs_read_int(ctx->bs, 2);\n\t\t\tif (speakerLayoutType == 0) {\n\t\t\t\tCICPspeakerLayoutIdx = gf_bs_read_int(ctx->bs, 6);\n\t\t\t} else {\n\t\t\t\tnumSpeakers = (s32) gf_mpegh_escaped_value(ctx->bs, 5, 8, 16) + 1;\n\t\t\t\t//TODO ...\n\t\t\t}\n\n\t\t\tmhas_dmx_check_pid(filter, ctx, pl, sr, frame_len, CICPspeakerLayoutIdx, numSpeakers, start + pay_start, (u32) mhas_size);\n\n\t\t\thas_cfg = GF_TRUE;\n\t\t}\n\t\t//audio truncation\n\t\telse if (mhas_type==17) {\n\t\t\tBool isActive = gf_bs_read_int(ctx->bs, 1);\n\t\t\t/*Bool ati_reserved = */gf_bs_read_int(ctx->bs, 1);\n\t\t\ttrunc_from_begin = gf_bs_read_int(ctx->bs, 1);\n\t\t\tnb_trunc_samples = gf_bs_read_int(ctx->bs, 13);\n\t\t\tif (!isActive) {\n\t\t\t\tnb_trunc_samples = 0;\n\t\t\t}\n\t\t}\n\t\t//sync, syncgap\n\t\telse if ((mhas_type==6) || (mhas_type==7)) {\n\t\t\tctx->nb_unknown_pck = 0;\n\t\t}\n#if 0\n\t\t//MARKER\n\t\telse if (mhas_type==8) {\n\t\t\tu8 marker_type = gf_bs_read_u8(ctx->bs);\n\t\t\t//config reload force\n\t\t\tif (marker_type==0x01) {}\n\t\t\t//SAP\n\t\t\telse if (marker_type==0x02) {\n\t\t\t\thas_marker = GF_TRUE;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tgf_bs_align(ctx->bs);\n\t\tparse_end = (u32) gf_bs_get_position(ctx->bs) - pay_start;\n\t\t//remaining of packet payload\n\t\tgf_bs_skip_bytes(ctx->bs, mhas_size - parse_end);\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] MHAS Packet type %d %s label \"LLU\" size \"LLU\"\\n\", mhas_type, mhas_pck_name(mhas_type), mhas_label, mhas_size));\n\n\t\tif (ctx->timescale && !prev_pck_size && (cts != GF_FILTER_NO_TS) ) {\n\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\t//frame\n\t\tif ((mhas_type==2) && ctx->opid) {\n\t\t\tGF_FilterPacket *dst;\n\t\t\tu64 pck_dur = ctx->frame_len;\n\n\n\t\t\tu32 au_size;\n\t\t\tif (ctx->mpha) {\n\t\t\t\tau_start = pay_start;\n\t\t\t\tau_size = mhas_size;\n\t\t\t} else {\n\t\t\t\tau_size = (u32) gf_bs_get_position(ctx->bs) - au_start;\n\t\t\t}\n\n\t\t\tif (nb_trunc_samples) {\n\t\t\t\tif (trunc_from_begin) {\n\t\t\t\t\tif (!ctx->nb_frames) {\n\t\t\t\t\t\ts64 offset = trunc_from_begin;\n\t\t\t\t\t\tif (ctx->timescale) {\n\t\t\t\t\t\t\toffset *= ctx->timescale;\n\t\t\t\t\t\t\toffset /= ctx->sample_rate;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DELAY , &PROP_LONGSINT( -offset));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpck_dur -= nb_trunc_samples;\n\t\t\t\t}\n\t\t\t\tnb_trunc_samples = 0;\n\t\t\t}\n\n\t\t\tif (ctx->timescale) {\n\t\t\t\tpck_dur *= ctx->timescale;\n\t\t\t\tpck_dur /= ctx->sample_rate;\n\t\t\t}\n\n\t\t\tdst = gf_filter_pck_new_alloc(ctx->opid, au_size, &output);\n\t\t\tif (!dst) break;\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst);\n\n\t\t\tmemcpy(output, start + au_start, au_size);\n\t\t\tif (!has_cfg)\n\t\t\t\tmhas_sap = 0;\n\n\t\t\tif (mhas_sap) {\n\t\t\t\tgf_filter_pck_set_sap(dst, GF_FILTER_SAP_1);\n\t\t\t}\n\t\t\tgf_filter_pck_set_dts(dst, ctx->cts);\n\t\t\tgf_filter_pck_set_cts(dst, ctx->cts);\n\t\t\tgf_filter_pck_set_duration(dst, (u32) pck_dur);\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tu64 offset = (u64) (start - ctx->mhas_buffer);\n\t\t\t\toffset += ctx->byte_offset + au_start;\n\t\t\t\tgf_filter_pck_set_byte_offset(dst, offset);\n\t\t\t}\n \t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MHASDmx] Send AU CTS \"LLU\" size %d dur %d sap %d\\n\", ctx->cts, au_size, (u32) pck_dur, mhas_sap));\n\t\t\tgf_filter_pck_send(dst);\n\n\t\t\tau_start += au_size;\n\t\t\tconsumed = au_start;\n\t\t\tctx->nb_frames ++;\n\n\t\t\tmhas_dmx_update_cts(ctx);\n\t\t\thas_cfg = 0;\n\n\t\t\tif (prev_pck_size) {\n\t\t\t\tu64 next_pos = (u64) (start + au_start - ctx->mhas_buffer);\n\t\t\t\t//next will be in new packet\n\t\t\t\tif (prev_pck_size <= next_pos) {\n\t\t\t\t\tprev_pck_size = 0;\n\t\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\t\tctx->src_pck = in_pck;\n\t\t\t\t\tif (in_pck)\n\t\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\n\t\t\t\t\tif (ctx->timescale && (cts != GF_FILTER_NO_TS) ) {\n\t\t\t\t\t\tctx->cts = cts;\n\t\t\t\t\t\tcts = GF_FILTER_NO_TS;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (remain==consumed)\n\t\t\t\tbreak;\n\n\t\t\tif (gf_filter_pid_would_block(ctx->opid)) {\n\t\t\t\tctx->resume_from = 1;\n\t\t\t\tfinal_flush = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (consumed) {\n\t\tassert(remain>=consumed);\n\t\tremain -= consumed;\n\t\tstart += consumed;\n\t}\n\nskip:\n\n\tif (remain < ctx->mhas_buffer_size) {\n\t\tmemmove(ctx->mhas_buffer, start, remain);\n\t\t//update byte offset\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += ctx->mhas_buffer_size - remain;\n\t}\n\tctx->mhas_buffer_size = remain;\n\tif (final_flush)\n\t\tctx->mhas_buffer_size = 0;\n\n\tif (!ctx->mhas_buffer_size) {\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = NULL;\n\t}\n\n\tif (in_pck)\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\treturn GF_OK;\n}\n\nstatic void mhas_buffer_too_small(void *udta)\n{\n\tGF_MHASDmxCtx *ctx = (GF_MHASDmxCtx *) udta;\n\tctx->buffer_too_small = GF_TRUE;\n}\n\nstatic GF_Err mhas_dmx_initialize(GF_Filter *filter)\n{\n\tGF_MHASDmxCtx *ctx = gf_filter_get_udta(filter);\n\tctx->bs = gf_bs_new((u8 *)ctx, 1, GF_BITSTREAM_READ);\n\tgf_bs_set_eos_callback(ctx->bs, mhas_buffer_too_small, ctx);\n\treturn GF_OK;\n}\nstatic void mhas_dmx_finalize(GF_Filter *filter)\n{\n\tGF_MHASDmxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->bs) gf_bs_del(ctx->bs);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n\tif (ctx->mhas_buffer) gf_free(ctx->mhas_buffer);\n\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n}\n\n\nstatic const char *mhas_dmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\ts32 sync_pos = -1;\n\tGF_BitStream *bs;\n\tu32 nb_mhas_cfg = 0;\n\tu32 nb_mhas_frames = 0;\n\tu32 nb_mhas_unknown = 0;\n\tconst u8 *ptr = data;\n\twhile (ptr) {\n\t\tu32 pos = (u32) (ptr - data);\n\t\tconst u8 *sync_start = memchr(ptr, 0xC0, size - pos);\n\t\tif (!sync_start) return NULL;\n\t\tif ((sync_start[1]== 0x01) && (sync_start[2]==0xA5)) {\n\t\t\tsync_pos = pos;\n\t\t\tbreak;\n\t\t}\n\t\tptr = sync_start+1;\n\t}\n\tif (sync_pos<0) return NULL;\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tgf_bs_skip_bytes(bs, sync_pos);\n\n\twhile (gf_bs_available(bs)) {\n\t\tu32 type = (u32) gf_mpegh_escaped_value(bs, 3, 8, 8);\n\t\t/*u64 label = */gf_mpegh_escaped_value(bs, 2, 8, 32);\n\t\tu64 mh_size = gf_mpegh_escaped_value(bs, 11, 24, 24);\n\t\tif (mh_size > gf_bs_available(bs))\n\t\t\tbreak;\n\t\t//MHAS config\n\t\tif (type==1) nb_mhas_cfg++;\n\t\telse if (type==2) nb_mhas_frames++;\n\t\telse if (type>18) nb_mhas_unknown++;\n\t\tgf_bs_skip_bytes(bs, mh_size);\n\t}\n\tgf_bs_del(bs);\n\tif (!nb_mhas_unknown && nb_mhas_cfg && nb_mhas_frames) {\n\t\t*score = GF_FPROBE_SUPPORTED;\n\t\treturn \"audio/mpegh\";\n\t}\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability MHASDmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"mhas\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/mpegh\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_MHAS),\n\tCAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_CODECID, GF_CODECID_MHAS),\n\tCAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n};\n\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_MHASDmxCtx, _n)\nstatic const GF_FilterArgs MHASDmxArgs[] =\n{\n\t{ OFFS(index), \"indexing window length\", GF_PROP_DOUBLE, \"1.0\", NULL, 0},\n\t{ OFFS(mpha), \"demultiplex MHAS and only forward audio frames\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(pcksync), \"number of unknown packets to tolerate before considering sync is lost\", GF_PROP_UINT, \"4\", NULL, 0},\n\t{ OFFS(nosync), \"initial sync state\", GF_PROP_BOOL, \"true\", NULL, 0},\n\n\t{0}\n};\n\n\nGF_FilterRegister MHASDmxRegister = {\n\t.name = \"rfmhas\",\n\tGF_FS_SET_DESCRIPTION(\"MPEH-H Audio Stream reframer\")\n\tGF_FS_SET_HELP(\"This filter parses MHAS files/data and outputs corresponding audio PID and frames.\\n\"\n\t\t\"By default, the filter expects a MHAS stream with SYNC packets set, otherwise tune-in will fail. Using [-nosync]()=false can help parsing bitstreams with no SYNC packets.\\n\"\n\t\t\"The default behavior is to dispatch a framed MHAS bitstream. To demultiplex into a raw MPEG-H Audio, use [-mpha]().\\n\"\n\t\t)\n\t.private_size = sizeof(GF_MHASDmxCtx),\n\t.args = MHASDmxArgs,\n\t.finalize = mhas_dmx_finalize,\n\t.initialize = mhas_dmx_initialize,\n\tSETCAPS(MHASDmxCaps),\n\t.configure_pid = mhas_dmx_configure_pid,\n\t.process = mhas_dmx_process,\n\t.probe_data = mhas_dmx_probe_data,\n\t.process_event = mhas_dmx_process_event\n};\n\n\nconst GF_FilterRegister *mhas_dmx_register(GF_FilterSession *session)\n{\n\treturn &MHASDmxRegister;\n}\n\n#else\n\nconst GF_FilterRegister *mhas_dmx_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif //#if !defined(GPAC_DISABLE_AV_PARSERS)\n"], "buggy_code_start_loc": [201], "buggy_code_end_loc": [625], "fixing_code_start_loc": [200], "fixing_code_end_loc": [624], "type": "CWE-125", "message": "Buffer Over-read in GitHub repository gpac/gpac prior to v2.3.0-DEV.", "other": {"cve": {"id": "CVE-2023-0817", "sourceIdentifier": "security@huntr.dev", "published": "2023-02-13T22:15:13.397", "lastModified": "2023-02-22T20:14:38.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer Over-read in GitHub repository gpac/gpac prior to v2.3.0-DEV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-126"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3.0-dev", "matchCriteriaId": "F3A1B96B-3E09-4DB5-B15E-249D5E6EDEDC"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/be9f8d395bbd196e3812e9cd80708f06bcc206f7", "source": "security@huntr.dev", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://huntr.dev/bounties/cb730bc5-d79c-4de6-9e57-10e8c3ce2cf3", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/be9f8d395bbd196e3812e9cd80708f06bcc206f7"}}