{"buggy_code": ["import datetime\nimport re\nimport time\nimport urllib\nfrom typing import TYPE_CHECKING, Any, Dict, List, Optional, Sequence, Union\nfrom unittest.mock import MagicMock, patch\nfrom urllib.parse import urlencode\n\nimport orjson\nfrom django.conf import settings\nfrom django.contrib.auth.views import PasswordResetConfirmView\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.exceptions import ValidationError\nfrom django.core.mail.message import EmailMultiAlternatives\nfrom django.http import HttpRequest, HttpResponse, HttpResponseBase\nfrom django.template.response import TemplateResponse\nfrom django.test import Client, override_settings\nfrom django.urls import reverse\nfrom django.utils import translation\nfrom django.utils.timezone import now as timezone_now\nfrom django.utils.translation import gettext as _\n\nfrom confirmation import settings as confirmation_settings\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyError,\n    create_confirmation_link,\n    get_object_from_key,\n    one_click_unsubscribe_link,\n)\nfrom corporate.lib.stripe import get_latest_seat_count\nfrom zerver.actions.create_realm import do_change_realm_subdomain, do_create_realm\nfrom zerver.actions.create_user import add_new_user_history, do_create_user, process_new_human_user\nfrom zerver.actions.default_streams import (\n    do_add_default_stream,\n    do_create_default_stream_group,\n    get_default_streams_for_realm,\n)\nfrom zerver.actions.invites import (\n    do_create_multiuse_invite_link,\n    do_get_invites_controlled_by_user,\n    do_invite_users,\n    do_revoke_multi_use_invite,\n)\nfrom zerver.actions.realm_settings import (\n    do_deactivate_realm,\n    do_set_realm_authentication_methods,\n    do_set_realm_property,\n    do_set_realm_user_default_setting,\n)\nfrom zerver.actions.user_settings import do_change_full_name\nfrom zerver.actions.users import change_user_is_active, do_change_user_role, do_deactivate_user\nfrom zerver.context_processors import common_context\nfrom zerver.decorator import do_two_factor_login\nfrom zerver.forms import HomepageForm, check_subdomain_available\nfrom zerver.lib.email_notifications import enqueue_welcome_emails, followup_day2_email_delay\nfrom zerver.lib.i18n import get_default_language_for_new_user\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.mobile_auth_otp import (\n    ascii_to_hex,\n    hex_to_ascii,\n    is_valid_otp,\n    otp_decrypt_api_key,\n    otp_encrypt_api_key,\n    xor_hex_strings,\n)\nfrom zerver.lib.name_restrictions import is_disposable_domain\nfrom zerver.lib.rate_limiter import add_ratelimit_rule, remove_ratelimit_rule\nfrom zerver.lib.send_email import (\n    EmailNotDeliveredError,\n    FromAddress,\n    deliver_scheduled_emails,\n    send_future_email,\n)\nfrom zerver.lib.stream_subscription import get_stream_subscriptions_for_user\nfrom zerver.lib.streams import create_stream_if_needed\nfrom zerver.lib.subdomains import is_root_domain_available\nfrom zerver.lib.test_classes import ZulipTestCase\nfrom zerver.lib.test_helpers import (\n    HostRequestMock,\n    avatar_disk_path,\n    cache_tries_captured,\n    find_key_by_email,\n    get_test_image_file,\n    load_subdomain_token,\n    message_stream_count,\n    most_recent_message,\n    most_recent_usermessage,\n    queries_captured,\n    reset_emails_in_zulip_realm,\n)\nfrom zerver.models import (\n    CustomProfileField,\n    CustomProfileFieldValue,\n    DefaultStream,\n    Message,\n    MultiuseInvite,\n    PreregistrationUser,\n    Realm,\n    RealmAuditLog,\n    RealmUserDefault,\n    Recipient,\n    ScheduledEmail,\n    Stream,\n    Subscription,\n    UserMessage,\n    UserProfile,\n    flush_per_request_caches,\n    get_realm,\n    get_stream,\n    get_system_bot,\n    get_user,\n    get_user_by_delivery_email,\n)\nfrom zerver.views.auth import redirect_and_log_into_subdomain, start_two_factor_auth\nfrom zerver.views.development.registration import confirmation_key\nfrom zerver.views.invite import INVITATION_LINK_VALIDITY_MINUTES, get_invitee_emails_set\nfrom zerver.views.registration import accounts_home\nfrom zproject.backends import ExternalAuthDataDict, ExternalAuthResult, email_auth_enabled\n\nif TYPE_CHECKING:\n    from django.test.client import _MonkeyPatchedWSGIResponse as TestHttpResponse\n\n\nclass RedirectAndLogIntoSubdomainTestCase(ZulipTestCase):\n    def test_data(self) -> None:\n        realm = get_realm(\"zulip\")\n        user_profile = self.example_user(\"hamlet\")\n        name = user_profile.full_name\n        email = user_profile.delivery_email\n        response = redirect_and_log_into_subdomain(ExternalAuthResult(user_profile=user_profile))\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\"full_name\": name, \"email\": email, \"subdomain\": realm.subdomain, \"is_signup\": False},\n        )\n\n        data_dict = ExternalAuthDataDict(is_signup=True, multiuse_object_key=\"key\")\n        response = redirect_and_log_into_subdomain(\n            ExternalAuthResult(user_profile=user_profile, data_dict=data_dict)\n        )\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\n                \"full_name\": name,\n                \"email\": email,\n                \"subdomain\": realm.subdomain,\n                # the email has an account at the subdomain,\n                # so is_signup get overridden to False:\n                \"is_signup\": False,\n                \"multiuse_object_key\": \"key\",\n            },\n        )\n\n        data_dict = ExternalAuthDataDict(\n            email=self.nonreg_email(\"alice\"),\n            full_name=\"Alice\",\n            subdomain=realm.subdomain,\n            is_signup=True,\n            full_name_validated=True,\n            multiuse_object_key=\"key\",\n        )\n        response = redirect_and_log_into_subdomain(ExternalAuthResult(data_dict=data_dict))\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\n                \"full_name\": \"Alice\",\n                \"email\": self.nonreg_email(\"alice\"),\n                \"full_name_validated\": True,\n                \"subdomain\": realm.subdomain,\n                \"is_signup\": True,\n                \"multiuse_object_key\": \"key\",\n            },\n        )\n\n\nclass DeactivationNoticeTestCase(ZulipTestCase):\n    def test_redirection_for_deactivated_realm(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        for url in (\"/register/\", \"/login/\"):\n            result = self.client_get(url)\n            self.assertRedirects(result, \"/accounts/deactivated/\", status_code=302)\n\n    def test_redirection_for_active_realm(self) -> None:\n        for url in (\"/register/\", \"/login/\"):\n            result = self.client_get(url)\n            self.assertEqual(result.status_code, 200)\n\n    def test_deactivation_notice_when_realm_is_active(self) -> None:\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertRedirects(result, \"/devlogin/\", status_code=302)\n\n    def test_deactivation_notice_when_deactivated(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_get(\"/login/\", follow=True)\n        self.assertEqual(result.redirect_chain[-1], (\"/accounts/deactivated/\", 302))\n        self.assertIn(\"Zulip Dev, has been deactivated.\", result.content.decode())\n        self.assertNotIn(\"It has moved to\", result.content.decode())\n\n    def test_deactivation_notice_when_deactivated_and_deactivated_redirect_is_set(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.deactivated_redirect = \"http://example.zulipchat.com\"\n        realm.save(update_fields=[\"deactivated\", \"deactivated_redirect\"])\n\n        result = self.client_get(\"/login/\", follow=True)\n        self.assertIn(\n            'It has moved to <a href=\"http://example.zulipchat.com\">http://example.zulipchat.com</a>.',\n            result.content.decode(),\n        )\n\n    def test_deactivation_notice_when_realm_subdomain_is_changed(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-subdomain-name\", acting_user=None)\n\n        result = self.client_get(\"/login/\", follow=True)\n        self.assertIn(\n            'It has moved to <a href=\"http://new-subdomain-name.testserver\">http://new-subdomain-name.testserver</a>.',\n            result.content.decode(),\n        )\n\n    def test_no_deactivation_notice_with_no_rediect(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(\n            realm, \"new-subdomain-name\", acting_user=None, add_deactivated_redirect=False\n        )\n\n        result = self.client_get(\"/login/\", follow=True)\n        self.assertEqual(result.status_code, 404)\n        self.assertNotIn(\n            \"new-subdomain-name\",\n            result.content.decode(),\n        )\n\n    def test_deactivated_redirect_field_of_placeholder_realms_are_modified_on_changing_subdomain_multiple_times(\n        self,\n    ) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-name-1\", acting_user=None)\n\n        result = self.client_get(\"/login/\", follow=True)\n        self.assertIn(\n            'It has moved to <a href=\"http://new-name-1.testserver\">http://new-name-1.testserver</a>.',\n            result.content.decode(),\n        )\n\n        realm = get_realm(\"new-name-1\")\n        do_change_realm_subdomain(realm, \"new-name-2\", acting_user=None)\n        result = self.client_get(\"/login/\", follow=True)\n        self.assertIn(\n            'It has moved to <a href=\"http://new-name-2.testserver\">http://new-name-2.testserver</a>.',\n            result.content.decode(),\n        )\n\n\nclass AddNewUserHistoryTest(ZulipTestCase):\n    def test_add_new_user_history_race(self) -> None:\n        \"\"\"Sends a message during user creation\"\"\"\n        # Create a user who hasn't had historical messages added\n        realm = get_realm(\"zulip\")\n        stream = Stream.objects.get(realm=realm, name=\"Denmark\")\n        DefaultStream.objects.create(stream=stream, realm=realm)\n        # Make sure at least 3 messages are sent to Denmark and it's a default stream.\n        message_id = self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 1\")\n        self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 2\")\n        self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 3\")\n\n        with patch(\"zerver.actions.create_user.add_new_user_history\"):\n            self.register(self.nonreg_email(\"test\"), \"test\")\n        user_profile = self.nonreg_user(\"test\")\n        subs = Subscription.objects.select_related(\"recipient\").filter(\n            user_profile=user_profile, recipient__type=Recipient.STREAM\n        )\n        streams = Stream.objects.filter(id__in=[sub.recipient.type_id for sub in subs])\n\n        # Sent a message afterwards to trigger a race between message\n        # sending and `add_new_user_history`.\n        race_message_id = self.send_stream_message(\n            self.example_user(\"hamlet\"), streams[0].name, \"test\"\n        )\n\n        # Overwrite ONBOARDING_UNREAD_MESSAGES to 2\n        ONBOARDING_UNREAD_MESSAGES = 2\n        with patch(\n            \"zerver.actions.create_user.ONBOARDING_UNREAD_MESSAGES\", ONBOARDING_UNREAD_MESSAGES\n        ):\n            add_new_user_history(user_profile, streams)\n\n        # Our first message is in the user's history\n        self.assertTrue(\n            UserMessage.objects.filter(user_profile=user_profile, message_id=message_id).exists()\n        )\n        # The race message is in the user's history and marked unread.\n        self.assertTrue(\n            UserMessage.objects.filter(\n                user_profile=user_profile, message_id=race_message_id\n            ).exists()\n        )\n        self.assertFalse(\n            UserMessage.objects.get(\n                user_profile=user_profile, message_id=race_message_id\n            ).flags.read.is_set\n        )\n\n        # Verify that the ONBOARDING_UNREAD_MESSAGES latest messages\n        # that weren't the race message are marked as unread.\n        latest_messages = (\n            UserMessage.objects.filter(\n                user_profile=user_profile,\n                message__recipient__type=Recipient.STREAM,\n            )\n            .exclude(message_id=race_message_id)\n            .order_by(\"-message_id\")[0:ONBOARDING_UNREAD_MESSAGES]\n        )\n        self.assert_length(latest_messages, 2)\n        for msg in latest_messages:\n            self.assertFalse(msg.flags.read.is_set)\n\n        # Verify that older messages are correctly marked as read.\n        older_messages = (\n            UserMessage.objects.filter(\n                user_profile=user_profile,\n                message__recipient__type=Recipient.STREAM,\n            )\n            .exclude(message_id=race_message_id)\n            .order_by(\"-message_id\")[ONBOARDING_UNREAD_MESSAGES : ONBOARDING_UNREAD_MESSAGES + 1]\n        )\n        self.assertGreater(len(older_messages), 0)\n        for msg in older_messages:\n            self.assertTrue(msg.flags.read.is_set)\n\n    def test_auto_subbed_to_personals(self) -> None:\n        \"\"\"\n        Newly created users are auto-subbed to the ability to receive\n        personals.\n        \"\"\"\n        test_email = self.nonreg_email(\"test\")\n        self.register(test_email, \"test\")\n        user_profile = self.nonreg_user(\"test\")\n        old_messages_count = message_stream_count(user_profile)\n        self.send_personal_message(user_profile, user_profile)\n        new_messages_count = message_stream_count(user_profile)\n        self.assertEqual(new_messages_count, old_messages_count + 1)\n\n        recipient = Recipient.objects.get(type_id=user_profile.id, type=Recipient.PERSONAL)\n        message = most_recent_message(user_profile)\n        self.assertEqual(message.recipient, recipient)\n\n        with patch(\"zerver.models.get_display_recipient\", return_value=\"recip\"):\n            self.assertEqual(\n                str(message),\n                \"<Message: recip /  / \"\n                \"<UserProfile: {} {}>>\".format(user_profile.email, user_profile.realm),\n            )\n\n            user_message = most_recent_usermessage(user_profile)\n            self.assertEqual(\n                str(user_message),\n                f\"<UserMessage: recip / {user_profile.email} ([])>\",\n            )\n\n\nclass InitialPasswordTest(ZulipTestCase):\n    def test_none_initial_password_salt(self) -> None:\n        with self.settings(INITIAL_PASSWORD_SALT=None):\n            self.assertIsNone(initial_password(\"test@test.com\"))\n\n\nclass PasswordResetTest(ZulipTestCase):\n    \"\"\"\n    Log in, reset password, log out, log in with new password.\n    \"\"\"\n\n    def get_reset_mail_body(self, subdomain: str = \"zulip\") -> str:\n        from django.core.mail import outbox\n\n        [message] = outbox\n        self.assertEqual(self.email_envelope_from(message), settings.NOREPLY_EMAIL_ADDRESS)\n        # The email might be sent in different languages for i18n testing\n        self.assertRegex(\n            self.email_display_from(message),\n            rf'^{_(\"Zulip Account Security\")} <{self.TOKENIZED_NOREPLY_REGEX}>\\Z',\n        )\n        self.assertIn(f\"{subdomain}.testserver\", message.extra_headers[\"List-Id\"])\n\n        return str(message.body)\n\n    def test_password_reset(self) -> None:\n        user = self.example_user(\"hamlet\")\n        email = user.delivery_email\n        old_password = initial_password(email)\n        assert old_password is not None\n\n        self.login_user(user)\n\n        # test password reset template\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assert_in_response(\"Reset your password\", result)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"reset your password\", body)\n\n        # Visit the password reset link.\n        password_reset_url = self.get_confirmation_url_from_outbox(\n            email, url_pattern=settings.EXTERNAL_HOST + r\"(\\S\\S+)\"\n        )\n        result = self.client_get(password_reset_url)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].endswith(f\"/{PasswordResetConfirmView.reset_url_token}/\")\n        )\n\n        final_reset_url = result[\"Location\"]\n        result = self.client_get(final_reset_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Reset your password\n        with self.settings(PASSWORD_MIN_LENGTH=3, PASSWORD_MIN_GUESSES=1000):\n            # Verify weak passwords don't work.\n            result = self.client_post(\n                final_reset_url, {\"new_password1\": \"easy\", \"new_password2\": \"easy\"}\n            )\n            self.assert_in_response(\"The password is too weak.\", result)\n\n            result = self.client_post(\n                final_reset_url, {\"new_password1\": \"f657gdGGk9\", \"new_password2\": \"f657gdGGk9\"}\n            )\n            # password reset succeeded\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\"/password/done/\"))\n\n            # log back in with new password\n            self.login_by_email(email, password=\"f657gdGGk9\")\n            user_profile = self.example_user(\"hamlet\")\n            self.assert_logged_in_user_id(user_profile.id)\n\n            # make sure old password no longer works\n            self.assert_login_failure(email, password=old_password)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_redirects_for_root_alias_when_root_domain_landing_page_is_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"alias.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True, ROOT_SUBDOMAIN_ALIASES=[\"alias\"]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                result[\"Location\"], \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\"\n            )\n\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n        ):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                result[\"Location\"], \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\"\n            )\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_redirects_for_root_domain_when_root_domain_landing_page_is_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                result[\"Location\"], \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\"\n            )\n\n        mock_get_host.return_value = \"www.zulip.example.com\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n            EXTERNAL_HOST=\"www.zulip.example.com\",\n        ):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                result[\"Location\"], \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\"\n            )\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_for_root_alias_when_root_domain_landing_page_is_not_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"alias.testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"alias\"]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"www.testserver\"\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_for_root_domain_when_root_domain_landing_page_is_not_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"testserver\"\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"www.zulip.example.com\"\n        with self.settings(EXTERNAL_HOST=\"www.zulip.example.com\", ROOT_SUBDOMAIN_ALIASES=[]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_always_for_subdomains(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"lear.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n    def test_password_reset_for_non_existent_user(self) -> None:\n        email = \"nonexisting@mars.com\"\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"You do not have an account\", body)\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"deactivated\", body)\n\n    def test_password_reset_for_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        do_deactivate_user(user_profile, acting_user=None)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"has been deactivated\", body)\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"not have an account\", body)\n\n    def test_password_reset_with_deactivated_realm(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        do_deactivate_realm(user_profile.realm, acting_user=None)\n\n        # start the password reset process by supplying an email address\n        with self.assertLogs(level=\"INFO\") as m:\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(m.output, [\"INFO:root:Realm is deactivated\"])\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(RATE_LIMITING=True)\n    def test_rate_limiting(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        from django.core.mail import outbox\n\n        add_ratelimit_rule(10, 2, domain=\"password_reset_form_by_email\")\n        start_time = time.time()\n        with patch(\"time.time\", return_value=start_time):\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assert_length(outbox, 2)\n\n            # Too many password reset emails sent to the address, we won't send more.\n            with self.assertLogs(level=\"INFO\") as info_logs:\n                self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(\n                info_logs.output,\n                [\n                    \"INFO:root:Too many password reset attempts for email hamlet@zulip.com from 127.0.0.1\"\n                ],\n            )\n            self.assert_length(outbox, 2)\n\n            # Resetting for a different address works though.\n            self.client_post(\"/accounts/password/reset/\", {\"email\": self.example_email(\"othello\")})\n            self.assert_length(outbox, 3)\n            self.client_post(\"/accounts/password/reset/\", {\"email\": self.example_email(\"othello\")})\n            self.assert_length(outbox, 4)\n\n        # After time, password reset emails can be sent again.\n        with patch(\"time.time\", return_value=start_time + 11):\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assert_length(outbox, 6)\n\n        remove_ratelimit_rule(10, 2, domain=\"password_reset_form_by_email\")\n\n    def test_wrong_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email}, subdomain=\"zephyr\")\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        body = self.get_reset_mail_body(\"zephyr\")\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"You do not have an account\", body)\n        self.assertIn(\n            \"active accounts in the following organization(s).\\nhttp://zulip.testserver\", body\n        )\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"deactivated\", body)\n\n    def test_wrong_subdomain_i18n(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n\n        # Send a password reset request with a different language to a wrong subdomain\n        result = self.client_post(\n            \"/accounts/password/reset/\",\n            {\"email\": email},\n            HTTP_ACCEPT_LANGUAGE=\"de\",\n            subdomain=\"lear\",\n        )\n        self.assertEqual(result.status_code, 302)\n\n        with translation.override(\"de\"):\n            body = self.get_reset_mail_body(\"lear\")\n            self.assertIn(\"hat ein neues Passwort\", body)\n\n    def test_invalid_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\n            \"/accounts/password/reset/\", {\"email\": email}, subdomain=\"invalid\"\n        )\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"There is no Zulip organization hosted at this subdomain.\", result)\n\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_auth_only(self) -> None:\n        \"\"\"If the email auth backend is not enabled, password reset should do nothing\"\"\"\n        email = self.example_email(\"hamlet\")\n        with self.assertLogs(level=\"INFO\") as m:\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(\n                m.output,\n                [\n                    \"INFO:root:Password reset attempted for hamlet@zulip.com even though password auth is disabled.\"\n                ],\n            )\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_and_email_auth(self) -> None:\n        \"\"\"If both email and LDAP auth backends are enabled, limit password\n        reset to users outside the LDAP domain\"\"\"\n        # If the domain matches, we don't generate an email\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            email = self.example_email(\"hamlet\")\n            with self.assertLogs(level=\"INFO\") as m:\n                result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n                self.assertEqual(\n                    m.output, [\"INFO:root:Password reset not allowed for user in LDAP domain\"]\n                )\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n        # If the domain doesn't match, we do generate an email\n        with self.settings(LDAP_APPEND_DOMAIN=\"example.com\"):\n            email = self.example_email(\"hamlet\")\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n            result = self.client_get(result[\"Location\"])\n\n        body = self.get_reset_mail_body()\n        self.assertIn(\"reset your password\", body)\n\n    def test_redirect_endpoints(self) -> None:\n        \"\"\"\n        These tests are mostly designed to give us 100% URL coverage\n        in our URL coverage reports.  Our mechanism for finding URL\n        coverage doesn't handle redirects, so we just have a few quick\n        tests here.\n        \"\"\"\n        result = self.client_get(\"/accounts/password/reset/done/\")\n        self.assert_in_success_response([\"Check your email\"], result)\n\n        result = self.client_get(\"/accounts/password/done/\")\n        self.assert_in_success_response([\"We've reset your password!\"], result)\n\n        result = self.client_get(\"/accounts/send_confirm/alice@example.com\")\n        self.assert_in_success_response([\"/accounts/home/\"], result)\n\n        result = self.client_get(\"/accounts/new/send_confirm/alice@example.com\")\n        self.assert_in_success_response([\"/new/\"], result)\n\n    def test_password_reset_for_soft_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        with self.soft_deactivate_and_check_long_term_idle(user_profile, False):\n            # start the password reset process by supplying an email address\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n            # check the redirect link telling you to check mail for password reset link\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n\n\nclass LoginTest(ZulipTestCase):\n    \"\"\"\n    Logging in, registration, and logging out.\n    \"\"\"\n\n    def test_login(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_login_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        do_deactivate_user(user_profile, acting_user=None)\n        result = self.login_with_return(user_profile.delivery_email, \"xxx\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            f\"Your account {user_profile.delivery_email} has been deactivated.\", result\n        )\n        self.assert_logged_in_user_id(None)\n\n    def test_login_deactivate_user_error(self) -> None:\n        \"\"\"\n        This is meant to test whether the error message signaled by the\n        is_deactivated is shown independently of whether the Email\n        backend is enabled.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        realm = user_profile.realm\n        self.assertTrue(email_auth_enabled(realm))\n\n        url = f\"{realm.uri}/login/?\" + urlencode({\"is_deactivated\": user_profile.delivery_email})\n        result = self.client_get(url)\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            f\"Your account {user_profile.delivery_email} has been deactivated.\", result\n        )\n\n        auth_dict = realm.authentication_methods_dict()\n        auth_dict[\"Email\"] = False\n        do_set_realm_authentication_methods(realm, auth_dict, acting_user=None)\n        result = self.client_get(url)\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            f\"Your account {user_profile.delivery_email} has been deactivated.\", result\n        )\n\n    def test_login_bad_password(self) -> None:\n        user = self.example_user(\"hamlet\")\n        password: Optional[str] = \"wrongpassword\"\n        result = self.login_with_return(user.delivery_email, password=password)\n        self.assert_in_success_response([user.delivery_email], result)\n        self.assert_logged_in_user_id(None)\n\n        # Parallel test to confirm that the right password works using the\n        # same login code, which verifies our failing test isn't broken\n        # for some other reason.\n        password = initial_password(user.delivery_email)\n        result = self.login_with_return(user.delivery_email, password=password)\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user.id)\n\n    @override_settings(RATE_LIMITING_AUTHENTICATE=True)\n    def test_login_bad_password_rate_limiter(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        add_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n        start_time = time.time()\n        with patch(\"time.time\", return_value=start_time):\n            self.login_with_return(email, password=\"wrongpassword\")\n            self.assert_logged_in_user_id(None)\n            self.login_with_return(email, password=\"wrongpassword\")\n            self.assert_logged_in_user_id(None)\n\n            # We're over the allowed limit, so the next attempt, even with the correct\n            # password, will get blocked.\n            result = self.login_with_return(email)\n            self.assert_in_success_response([\"Try again in 10 seconds\"], result)\n\n        # After time passes, we should be able to log in.\n        with patch(\"time.time\", return_value=start_time + 11):\n            self.login_with_return(email)\n            self.assert_logged_in_user_id(user_profile.id)\n\n        remove_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n    def test_login_with_old_weak_password_after_hasher_change(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"a_password_of_22_chars\"\n\n        with self.settings(PASSWORD_HASHERS=(\"django.contrib.auth.hashers.SHA1PasswordHasher\",)):\n            user_profile.set_password(password)\n            user_profile.save()\n\n        with self.settings(\n            PASSWORD_HASHERS=(\n                \"django.contrib.auth.hashers.MD5PasswordHasher\",\n                \"django.contrib.auth.hashers.SHA1PasswordHasher\",\n            ),\n            PASSWORD_MIN_LENGTH=30,\n        ), self.assertLogs(\"zulip.auth.email\", level=\"INFO\"):\n            result = self.login_with_return(self.example_email(\"hamlet\"), password)\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\n                \"Your password has been disabled because it is too weak.\", result\n            )\n            self.assert_logged_in_user_id(None)\n\n    def test_login_nonexistent_user(self) -> None:\n        result = self.login_with_return(\"xxx@zulip.com\", \"xxx\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Please enter a correct email and password\", result)\n        self.assert_logged_in_user_id(None)\n\n    def test_login_wrong_subdomain(self) -> None:\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.delivery_email\n        with self.assertLogs(\"zulip.auth.OurAuthenticationForm\", level=\"INFO\") as m:\n            result = self.login_with_return(email, \"xxx\")\n            matching_accounts_dict = {\"realm_id\": user_profile.realm_id, \"id\": user_profile.id}\n            self.assertEqual(\n                m.output,\n                [\n                    f\"INFO:zulip.auth.OurAuthenticationForm:User attempted password login to wrong subdomain zulip. Matching accounts: [{matching_accounts_dict}]\"\n                ],\n            )\n        self.assertEqual(result.status_code, 200)\n        expected_error = (\n            \"Please enter a correct email and password. Note that both fields may be case-sensitive\"\n        )\n        self.assert_in_response(expected_error, result)\n        self.assert_logged_in_user_id(None)\n\n    def test_login_invalid_subdomain(self) -> None:\n        result = self.login_with_return(self.example_email(\"hamlet\"), \"xxx\", subdomain=\"invalid\")\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"There is no Zulip organization hosted at this subdomain.\", result)\n        self.assert_logged_in_user_id(None)\n\n    def test_register(self) -> None:\n        reset_emails_in_zulip_realm()\n\n        realm = get_realm(\"zulip\")\n        hamlet = self.example_user(\"hamlet\")\n        stream_names = [f\"stream_{i}\" for i in range(40)]\n        for stream_name in stream_names:\n            stream = self.make_stream(stream_name, realm=realm)\n            DefaultStream.objects.create(stream=stream, realm=realm)\n\n        # Make sure there's at least one recent message to be mark\n        # unread.  This prevents a bug where this test would start\n        # failing the test database was generated more than\n        # ONBOARDING_RECENT_TIMEDELTA ago.\n        self.subscribe(hamlet, \"stream_0\")\n        self.send_stream_message(\n            hamlet,\n            \"stream_0\",\n            topic_name=\"test topic\",\n            content=\"test message\",\n        )\n\n        # Clear all the caches.\n        flush_per_request_caches()\n        ContentType.objects.clear_cache()\n\n        # Ensure the number of queries we make is not O(streams)\n        with self.assert_database_query_count(96), cache_tries_captured() as cache_tries:\n            with self.captureOnCommitCallbacks(execute=True):\n                self.register(self.nonreg_email(\"test\"), \"test\")\n\n        # We can probably avoid a couple cache hits here, but there doesn't\n        # seem to be any O(N) behavior.  Some of the cache hits are related\n        # to sending messages, such as getting the welcome bot, looking up\n        # the alert words for a realm, etc.\n        self.assert_length(cache_tries, 22)\n\n        user_profile = self.nonreg_user(\"test\")\n        self.assert_logged_in_user_id(user_profile.id)\n        self.assertFalse(user_profile.enable_stream_desktop_notifications)\n        self.check_user_added_in_system_group(user_profile)\n\n    def test_register_deactivated(self) -> None:\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_post(\n            \"/accounts/home/\", {\"email\": self.nonreg_email(\"test\")}, subdomain=\"zulip\"\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result[\"Location\"])\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user(\"test\")\n\n    def test_register_with_invalid_email(self) -> None:\n        \"\"\"\n        If you try to register with invalid email, you get an invalid email\n        page\n        \"\"\"\n        invalid_email = \"foo\\x00bar\"\n        result = self.client_post(\"/accounts/home/\", {\"email\": invalid_email}, subdomain=\"zulip\")\n\n        self.assertEqual(result.status_code, 200)\n        self.assertContains(result, \"Enter a valid email address\")\n\n    def test_register_deactivated_partway_through(self) -> None:\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        email = self.nonreg_email(\"test\")\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertNotIn(\"deactivated\", result[\"Location\"])\n\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.submit_reg_form_for_user(email, \"abcd1234\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result[\"Location\"])\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user(\"test\")\n\n    def test_login_deactivated_realm(self) -> None:\n        \"\"\"\n        If you try to log in to a deactivated realm, you get a clear error page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.login_with_return(self.example_email(\"hamlet\"), subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result[\"Location\"])\n\n    def test_logout(self) -> None:\n        self.login(\"hamlet\")\n        # We use the logout API, not self.logout, to make sure we test\n        # the actual logout code path.\n        self.client_post(\"/accounts/logout/\")\n        self.assert_logged_in_user_id(None)\n\n    def test_non_ascii_login(self) -> None:\n        \"\"\"\n        You can log in even if your password contain non-ASCII characters.\n        \"\"\"\n        email = self.nonreg_email(\"test\")\n        password = \"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Registering succeeds.\n        self.register(email, password)\n        user_profile = self.nonreg_user(\"test\")\n        self.assert_logged_in_user_id(user_profile.id)\n        self.logout()\n        self.assert_logged_in_user_id(None)\n\n        # Logging in succeeds.\n        self.logout()\n        self.login_by_email(email, password)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TWO_FACTOR_AUTHENTICATION_ENABLED=False)\n    def test_login_page_redirects_logged_in_user(self) -> None:\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        self.login(\"cordelia\")\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver\")\n\n    def test_options_request_to_login_page(self) -> None:\n        response = self.client_options(\"/login/\")\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(TWO_FACTOR_AUTHENTICATION_ENABLED=True)\n    def test_login_page_redirects_logged_in_user_under_2fa(self) -> None:\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        user_profile = self.example_user(\"cordelia\")\n        self.create_default_device(user_profile)\n\n        self.login(\"cordelia\")\n        self.login_2fa(user_profile)\n\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver\")\n\n    def test_start_two_factor_auth(self) -> None:\n        request = HostRequestMock()\n        with patch(\"zerver.views.auth.TwoFactorLoginView\") as mock_view:\n            mock_view.as_view.return_value = lambda *a, **k: HttpResponse()\n            response = start_two_factor_auth(request)\n            self.assertTrue(isinstance(response, HttpResponse))\n\n    def test_do_two_factor_login(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.create_default_device(user_profile)\n        request = HostRequestMock()\n        with patch(\"zerver.decorator.django_otp.login\") as mock_login:\n            do_two_factor_login(request, user_profile)\n            mock_login.assert_called_once()\n\n    def test_zulip_default_context_does_not_load_inline_previews(self) -> None:\n        realm = get_realm(\"zulip\")\n        description = \"https://www.google.com/images/srpr/logo4w.png\"\n        realm.description = description\n        realm.save(update_fields=[\"description\"])\n        response: HttpResponseBase = self.client_get(\"/login/\")\n        expected_response = \"\"\"<p><a href=\"https://www.google.com/images/srpr/logo4w.png\">\\\nhttps://www.google.com/images/srpr/logo4w.png</a></p>\"\"\"\n        assert isinstance(response, TemplateResponse)\n        assert response.context_data is not None\n        self.assertEqual(response.context_data[\"realm_description\"], expected_response)\n        self.assertEqual(response.status_code, 200)\n\n\nclass InviteUserBase(ZulipTestCase):\n    def check_sent_emails(self, correct_recipients: List[str]) -> None:\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, len(correct_recipients))\n        email_recipients = [email.recipients()[0] for email in outbox]\n        self.assertEqual(sorted(email_recipients), sorted(correct_recipients))\n        if len(outbox) == 0:\n            return\n\n        self.assertIn(\"Zulip\", self.email_display_from(outbox[0]))\n\n        self.assertEqual(self.email_envelope_from(outbox[0]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertRegex(\n            self.email_display_from(outbox[0]), rf\" <{self.TOKENIZED_NOREPLY_REGEX}>\\Z\"\n        )\n\n        self.assertEqual(outbox[0].extra_headers[\"List-Id\"], \"Zulip Dev <zulip.testserver>\")\n\n    def invite(\n        self,\n        invitee_emails: str,\n        stream_names: Sequence[str],\n        invite_expires_in_minutes: Optional[int] = INVITATION_LINK_VALIDITY_MINUTES,\n        body: str = \"\",\n        invite_as: int = PreregistrationUser.INVITE_AS[\"MEMBER\"],\n    ) -> \"TestHttpResponse\":\n        \"\"\"\n        Invites the specified users to Zulip with the specified streams.\n\n        users should be a string containing the users to invite, comma or\n            newline separated.\n\n        streams should be a list of strings.\n        \"\"\"\n        stream_ids = []\n        for stream_name in stream_names:\n            stream_ids.append(self.get_stream_id(stream_name))\n\n        invite_expires_in: Union[str, Optional[int]] = invite_expires_in_minutes\n        if invite_expires_in is None:\n            invite_expires_in = orjson.dumps(None).decode()\n\n        return self.client_post(\n            \"/json/invites\",\n            {\n                \"invitee_emails\": invitee_emails,\n                \"invite_expires_in_minutes\": invite_expires_in,\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_as\": invite_as,\n            },\n        )\n\n\nclass InviteUserTest(InviteUserBase):\n    def test_successful_invite_user(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n    def test_newbie_restrictions(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        stream_name = \"Denmark\"\n\n        self.login_user(user_profile)\n\n        result = self.invite(invitee, [stream_name])\n        self.assert_json_success(result)\n\n        user_profile.date_joined = timezone_now() - datetime.timedelta(days=10)\n        user_profile.save()\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=5):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_success(result)\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=15):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_error_contains(result, \"Your account is too new\")\n\n    def test_invite_limits(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        realm = user_profile.realm\n        stream_name = \"Denmark\"\n\n        # These constants only need to be in descending order\n        # for this test to trigger an InvitationError based\n        # on max daily counts.\n        site_max = 50\n        realm_max = 40\n        num_invitees = 30\n        max_daily_count = 20\n\n        daily_counts = [(1, max_daily_count)]\n\n        invite_emails = [f\"foo-{i:02}@zulip.com\" for i in range(num_invitees)]\n        invitees = \",\".join(invite_emails)\n\n        self.login_user(user_profile)\n\n        realm.max_invites = realm_max\n        realm.date_created = timezone_now()\n        realm.save()\n\n        def try_invite() -> \"TestHttpResponse\":\n            with self.settings(\n                OPEN_REALM_CREATION=True,\n                INVITES_DEFAULT_REALM_DAILY_MAX=site_max,\n                INVITES_NEW_REALM_LIMIT_DAYS=daily_counts,\n            ):\n                result = self.invite(invitees, [stream_name])\n                return result\n\n        result = try_invite()\n        self.assert_json_error_contains(result, \"reached the limit\")\n\n        # Next show that aggregate limits expire once the realm is old\n        # enough.\n\n        realm.date_created = timezone_now() - datetime.timedelta(days=8)\n        realm.save()\n\n        with queries_captured() as queries:\n            with cache_tries_captured() as cache_tries:\n                result = try_invite()\n\n        self.assert_json_success(result)\n\n        # TODO: Fix large query count here.\n        #\n        # TODO: There is some test OTHER than this one\n        #       that is leaking some kind of state change\n        #       that throws off the query count here.  It\n        #       is hard to investigate currently (due to\n        #       the large number of queries), so I just\n        #       use an approximate equality check.\n        actual_count = len(queries)\n        expected_count = 251\n        if abs(actual_count - expected_count) > 1:\n            raise AssertionError(\n                f\"\"\"\n                Unexpected number of queries:\n\n                expected query count: {expected_count}\n                actual: {actual_count}\n                \"\"\"\n            )\n\n        # Almost all of these cache hits are to re-fetch each one of the\n        # invitees.  These happen inside our queue processor for sending\n        # confirmation emails, so they are somewhat difficult to avoid.\n        #\n        # TODO: Mock the call to queue_json_publish, so we can measure the\n        # queue impact separately from the user-perceived impact.\n        self.assert_length(cache_tries, 32)\n\n        # Next get line coverage on bumping a realm's max_invites.\n        realm.date_created = timezone_now()\n        realm.max_invites = site_max + 10\n        realm.save()\n\n        result = try_invite()\n        self.assert_json_success(result)\n\n        # Finally get coverage on the case that OPEN_REALM_CREATION is False.\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            result = self.invite(invitees, [stream_name])\n\n        self.assert_json_success(result)\n\n    def test_invite_user_to_realm_on_manual_license_plan(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        _, ledger = self.subscribe_realm_to_monthly_plan_on_manual_license_management(\n            user.realm, 50, 50\n        )\n\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"alice\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses_at_next_renewal = 5\n        ledger.save(update_fields=[\"licenses_at_next_renewal\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses = get_latest_seat_count(user.realm) + 1\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            invitee_emails = self.nonreg_email(\"bob\") + \",\" + self.nonreg_email(\"alice\")\n            result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"Your organization does not have enough unused Zulip licenses to invite 2 users\"\n        )\n\n        ledger.licenses = get_latest_seat_count(user.realm)\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"All Zulip licenses for this organization are currently in use\"\n        )\n\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(\n                self.nonreg_email(\"bob\"),\n                [\"Denmark\"],\n                invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"],\n            )\n        self.assert_json_success(result)\n\n    def test_cross_realm_bot(self) -> None:\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        cross_realm_bot_email = \"emailgateway@zulip.com\"\n        legit_new_email = \"fred@zulip.com\"\n        invitee_emails = \",\".join([cross_realm_bot_email, legit_new_email])\n\n        result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error(\n            result,\n            \"Some of those addresses are already using Zulip,\"\n            + \" so we didn't send them an invitation.\"\n            + \" We did send invitations to everyone else!\",\n        )\n\n    def test_invite_mirror_dummy_user(self) -> None:\n        \"\"\"\n        A mirror dummy account is a temporary account\n        that we keep in our system if we are mirroring\n        data from something like Zephyr or IRC.\n\n        We want users to eventually just sign up or\n        register for Zulip, in which case we will just\n        fully \"activate\" the account.\n\n        Here we test that you can invite a person who\n        has a mirror dummy account.\n        \"\"\"\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        mirror_user = self.example_user(\"cordelia\")\n        mirror_user.is_mirror_dummy = True\n        mirror_user.save()\n        change_user_is_active(mirror_user, False)\n\n        self.assertEqual(\n            PreregistrationUser.objects.filter(email=mirror_user.email).count(),\n            0,\n        )\n\n        result = self.invite(mirror_user.email, [\"Denmark\"])\n        self.assert_json_success(result)\n\n        prereg_user = PreregistrationUser.objects.get(email=mirror_user.email)\n        assert prereg_user.referred_by is not None and inviter is not None\n        self.assertEqual(\n            prereg_user.referred_by.email,\n            inviter.email,\n        )\n\n    def test_invite_from_now_deactivated_user(self) -> None:\n        \"\"\"\n        While accepting an invitation from a user,\n        processing for a new user account will only\n        be completed if the inviter is not deactivated\n        after sending the invite.\n        \"\"\"\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n        invitee = self.nonreg_email(\"alice\")\n\n        result = self.invite(invitee, [\"Denmark\"])\n        self.assert_json_success(result)\n\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        change_user_is_active(inviter, False)\n        do_create_user(\n            invitee,\n            \"password\",\n            inviter.realm,\n            \"full name\",\n            prereg_user=prereg_user,\n            acting_user=None,\n        )\n\n    def test_successful_invite_user_as_owner_from_owner_account(self) -> None:\n        self.login(\"desdemona\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_invite_user_as_owner_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_error(response, \"Must be an organization owner\")\n\n    def test_successful_invite_user_as_admin_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_admin)\n        self.assertFalse(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_invite_user_as_admin_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_successful_invite_user_as_moderator_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_moderator)\n        self.assertFalse(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_invite_user_as_moderator_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_moderator_from_moderator_account(self) -> None:\n        self.login(\"shiva\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_invalid_type(self) -> None:\n        \"\"\"\n        Test inviting a user as invalid type of user i.e. type of invite_as\n        is not in PreregistrationUser.INVITE_AS\n        \"\"\"\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(invitee, [\"Denmark\"], invite_as=10)\n        self.assert_json_error(response, \"Invalid invite_as\")\n\n    def test_successful_invite_user_as_guest_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_successful_invite_user_as_guest_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_successful_invite_user_with_name(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.check_sent_emails([email])\n\n    def test_successful_invite_user_with_name_and_normal_one(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_successful_invite_users_with_specified_streams(self) -> None:\n        invitee = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        self.login(\"hamlet\")\n\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, realm) for stream_name in stream_names]\n        self.assert_json_success(self.invite(invitee, stream_names))\n        self.assertTrue(find_key_by_email(invitee))\n        self.submit_reg_form_for_user(invitee, \"password\")\n        self.check_user_subscribed_only_to_streams(\"alice\", streams)\n\n        invitee = self.nonreg_email(\"bob\")\n        self.assert_json_success(self.invite(invitee, []))\n        self.assertTrue(find_key_by_email(invitee))\n\n        default_streams = get_default_streams_for_realm(realm.id)\n        self.assert_length(default_streams, 1)\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        # If no streams are provided, user is not subscribed to\n        # default streams as well.\n        self.check_user_subscribed_only_to_streams(\"bob\", [])\n\n    def test_can_invite_others_to_realm(self) -> None:\n        def validation_func(user_profile: UserProfile) -> bool:\n            user_profile.refresh_from_db()\n            return user_profile.can_invite_others_to_realm()\n\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        desdemona = self.example_user(\"desdemona\")\n        self.assertFalse(validation_func(desdemona))\n\n        self.check_has_permission_policies(\"invite_to_realm_policy\", validation_func)\n\n    def test_invite_others_to_realm_setting(self) -> None:\n        \"\"\"\n        The invite_to_realm_policy realm setting works properly.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        self.login(\"desdemona\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_ADMINS_ONLY, acting_user=None\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        # Now verify an administrator can do it\n        self.login(\"iago\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n\n        self.check_sent_emails([email, email2])\n\n        from django.core import mail\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MODERATORS_ONLY, acting_user=None\n        )\n        self.login(\"hamlet\")\n        email = \"carol-test@zulip.com\"\n        email2 = \"earl-test@zulip.com\"\n        invitee = f\"Carol Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n\n        self.login(\"polonius\")\n        email = \"dave-test@zulip.com\"\n        email2 = \"mark-test@zulip.com\"\n        invitee = f\"Dave Test <{email}>, {email2}\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n\n        self.login(\"hamlet\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_FULL_MEMBERS_ONLY, acting_user=None\n        )\n        do_set_realm_property(realm, \"waiting_period_threshold\", 1000, acting_user=None)\n\n        hamlet = self.example_user(\"hamlet\")\n        hamlet.date_joined = timezone_now() - datetime.timedelta(\n            days=(realm.waiting_period_threshold - 1)\n        )\n\n        email = \"issac-test@zulip.com\"\n        email2 = \"steven-test@zulip.com\"\n        invitee = f\"Issac Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(realm, \"waiting_period_threshold\", 0, acting_user=None)\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_invite_user_signup_initial_history(self) -> None:\n        \"\"\"\n        Test that a new user invited to a stream receives some initial\n        history but only from public streams.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        private_stream_name = \"Secret\"\n        self.make_stream(private_stream_name, invite_only=True)\n        self.subscribe(user_profile, private_stream_name)\n        public_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            \"Denmark\",\n            topic_name=\"Public topic\",\n            content=\"Public message\",\n        )\n        secret_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            private_stream_name,\n            topic_name=\"Secret topic\",\n            content=\"Secret message\",\n        )\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee, [private_stream_name, \"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        invitee_msg_ids = [\n            um.message_id for um in UserMessage.objects.filter(user_profile=invitee_profile)\n        ]\n        self.assertTrue(public_msg_id in invitee_msg_ids)\n        self.assertFalse(secret_msg_id in invitee_msg_ids)\n        self.assertFalse(invitee_profile.is_realm_admin)\n\n        invitee_msg, signups_stream_msg, inviter_msg, secret_msg = Message.objects.all().order_by(\n            \"-id\"\n        )[0:4]\n\n        self.assertEqual(secret_msg.id, secret_msg_id)\n\n        self.assertEqual(inviter_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            inviter_msg.content.startswith(\n                f\"alice_zulip.com <`{invitee_profile.email}`> accepted your\",\n            )\n        )\n\n        self.assertEqual(signups_stream_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            signups_stream_msg.content.startswith(\n                f\"@_**alice_zulip.com|{invitee_profile.id}** just signed up\",\n            )\n        )\n\n        self.assertEqual(invitee_msg.sender.email, \"welcome-bot@zulip.com\")\n        self.assertTrue(invitee_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertNotIn(\"demo organization\", invitee_msg.content)\n\n    def test_multi_user_invite(self) -> None:\n        \"\"\"\n        Invites multiple users with a variety of delimiters.\n        \"\"\"\n        self.login(\"hamlet\")\n        # Intentionally use a weird string.\n        self.assert_json_success(\n            self.invite(\n                \"\"\"bob-test@zulip.com,     carol-test@zulip.com,\n            dave-test@zulip.com\n\n\nearl-test@zulip.com\"\"\",\n                [\"Denmark\"],\n            )\n        )\n        for user in (\"bob\", \"carol\", \"dave\", \"earl\"):\n            self.assertTrue(find_key_by_email(f\"{user}-test@zulip.com\"))\n        self.check_sent_emails(\n            [\n                \"bob-test@zulip.com\",\n                \"carol-test@zulip.com\",\n                \"dave-test@zulip.com\",\n                \"earl-test@zulip.com\",\n            ]\n        )\n\n    def test_max_invites_model(self) -> None:\n        realm = get_realm(\"zulip\")\n        self.assertEqual(realm.max_invites, settings.INVITES_DEFAULT_REALM_DAILY_MAX)\n        realm.max_invites = 3\n        realm.save()\n        self.assertEqual(get_realm(\"zulip\").max_invites, 3)\n        realm.max_invites = settings.INVITES_DEFAULT_REALM_DAILY_MAX\n        realm.save()\n\n    def test_invite_too_many_users(self) -> None:\n        # Only a light test of this pathway; e.g. doesn't test that\n        # the limit gets reset after 24 hours\n        self.login(\"iago\")\n        invitee_emails = \"1@zulip.com, 2@zulip.com\"\n        self.invite(invitee_emails, [\"Denmark\"])\n        invitee_emails = \", \".join(str(i) for i in range(get_realm(\"zulip\").max_invites - 1))\n        self.assert_json_error(\n            self.invite(invitee_emails, [\"Denmark\"]),\n            \"To protect users, Zulip limits the number of invitations you can send in one day. Because you have reached the limit, no invitations were sent.\",\n        )\n\n    def test_missing_or_invalid_params(self) -> None:\n        \"\"\"\n        Tests inviting with various missing or invalid parameters.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n\n        self.login(\"hamlet\")\n\n        for address in (\"noatsign.com\", \"outsideyourdomain@example.net\"):\n            self.assert_json_error(\n                self.invite(address, [\"Denmark\"]),\n                \"Some emails did not validate, so we didn't send any invitations.\",\n            )\n        self.check_sent_emails([])\n\n        self.assert_json_error(\n            self.invite(\"\", [\"Denmark\"]), \"You must specify at least one email address.\"\n        )\n        self.check_sent_emails([])\n\n    def test_guest_user_invitation(self) -> None:\n        \"\"\"\n        Guest user can't invite new users\n        \"\"\"\n        self.login(\"polonius\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n        self.assertEqual(find_key_by_email(invitee), None)\n        self.check_sent_emails([])\n\n    def test_invalid_stream(self) -> None:\n        \"\"\"\n        Tests inviting to a non-existent stream.\n        \"\"\"\n        self.login(\"hamlet\")\n        self.assert_json_error(\n            self.invite(\"iago-test@zulip.com\", [\"NotARealStream\"]),\n            f\"Stream does not exist with id: {self.INVALID_STREAM_ID}. No invites were sent.\",\n        )\n        self.check_sent_emails([])\n\n    def test_invite_existing_user(self) -> None:\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        self.login(\"hamlet\")\n\n        hamlet_email = \"hAmLeT@zUlIp.com\"\n        result = self.invite(hamlet_email, [\"Denmark\"])\n        self.assert_json_error(result, \"We weren't able to invite anyone.\")\n\n        self.assertFalse(\n            PreregistrationUser.objects.filter(email__iexact=hamlet_email).exists(),\n        )\n        self.check_sent_emails([])\n\n    def normalize_string(self, s: str) -> str:\n        s = s.strip()\n        return re.sub(r\"\\s+\", \" \", s)\n\n    def test_invite_links_in_name(self) -> None:\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        hamlet = self.example_user(\"hamlet\")\n        self.login_user(hamlet)\n        # Test we properly handle links in user full names\n        do_change_full_name(hamlet, \"</a> https://www.google.com\", hamlet)\n\n        result = self.invite(\"newuser@zulip.com\", [\"Denmark\"])\n        self.assert_json_success(result)\n        self.check_sent_emails([\"newuser@zulip.com\"])\n        from django.core.mail import outbox\n\n        assert isinstance(outbox[0], EmailMultiAlternatives)\n        assert isinstance(outbox[0].alternatives[0][0], str)\n        body = self.normalize_string(outbox[0].alternatives[0][0])\n\n        # Verify that one can't get Zulip to send invitation emails\n        # that third-party products will linkify using the full_name\n        # field, because we've included that field inside the mailto:\n        # link for the sender.\n        self.assertIn(\n            '<a href=\"mailto:hamlet@zulip.com\" style=\"color:#5f5ec7; text-decoration:underline\">&lt;/a&gt; https://www.google.com (hamlet@zulip.com)</a> wants',\n            body,\n        )\n\n        # TODO: Ideally, this test would also test the Invitation\n        # Reminder email generated, but the test setup for that is\n        # annoying.\n\n    def test_invite_some_existing_some_new(self) -> None:\n        \"\"\"\n        If you invite a mix of already existing and new users, invitations are\n        only sent to the new users.\n        \"\"\"\n        self.login(\"hamlet\")\n        existing = [self.example_email(\"hamlet\"), \"othello@zulip.com\"]\n        new = [\"foo-test@zulip.com\", \"bar-test@zulip.com\"]\n        invitee_emails = \"\\n\".join(existing + new)\n        self.assert_json_error(\n            self.invite(invitee_emails, [\"Denmark\"]),\n            \"Some of those addresses are already using Zulip, \\\nso we didn't send them an invitation. We did send invitations to everyone else!\",\n        )\n\n        # We only created accounts for the new users.\n        for email in existing:\n            self.assertRaises(\n                PreregistrationUser.DoesNotExist,\n                lambda: PreregistrationUser.objects.get(email=email),\n            )\n        for email in new:\n            self.assertTrue(PreregistrationUser.objects.get(email=email))\n\n        # We only sent emails to the new users.\n        self.check_sent_emails(new)\n\n        prereg_user = PreregistrationUser.objects.get(email=\"foo-test@zulip.com\")\n        self.assertEqual(prereg_user.email, \"foo-test@zulip.com\")\n\n    def test_invite_outside_domain_in_closed_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = True`, you can't invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_using_disposable_email(self) -> None:\n        \"\"\"\n        In a realm with `disallow_disposable_email_addresses = True`, you can't invite\n        people with a disposable domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_outside_domain_in_open_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = False`, you can invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n    def test_invite_outside_domain_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a different domain from that of the realm\n        when `emails_restricted_to_domains = False`, but `emails_restricted_to_domains` later\n        changes to true, the invitation should succeed but the invitee's signup\n        attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@example.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"only allows users with email addresses\", result)\n\n    def test_disposable_emails_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a disposable email when\n        `disallow_disposable_email_addresses = False`, but\n        later changes to true, the invitation should succeed\n        but the invitee's signup attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@mailnator.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Please sign up using a real email address.\", result)\n\n    def test_invite_with_email_containing_plus_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with an email containing plus when\n        `emails_restricted_to_domains = False`, but later change\n        `emails_restricted_to_domains = True`, the invitation should\n        succeed but the invitee's signup attempt should fail as\n        users are not allowed to sign up using email containing +\n        when the realm is restricted to domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo+label@zulip.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(external_address, \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            \"Zulip Dev, does not allow signups using emails\\n        that contains +\", result\n        )\n\n    def test_invalid_email_check_after_confirming_email(self) -> None:\n        self.login(\"hamlet\")\n        email = \"test@zulip.com\"\n\n        self.assert_json_success(self.invite(email, [\"Denmark\"]))\n\n        obj = Confirmation.objects.get(confirmation_key=find_key_by_email(email))\n        prereg_user = obj.content_object\n        assert prereg_user is not None\n        prereg_user.email = \"invalid.email\"\n        prereg_user.save()\n\n        result = self.submit_reg_form_for_user(email, \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            \"The email address you are trying to sign up with is not valid\", result\n        )\n\n    def test_invite_with_non_ascii_streams(self) -> None:\n        \"\"\"\n        Inviting someone to streams with non-ASCII characters succeeds.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n\n        stream_name = \"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Make sure we're subscribed before inviting someone.\n        self.subscribe(self.example_user(\"hamlet\"), stream_name)\n\n        self.assert_json_success(self.invite(invitee, [stream_name]))\n\n    def test_invitation_reminder_email(self) -> None:\n        from django.core.mail import outbox\n\n        # All users belong to zulip realm\n        referrer_name = \"hamlet\"\n        current_user = self.example_user(referrer_name)\n        self.login_user(current_user)\n        invitee_email = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee_email, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee_email))\n        self.check_sent_emails([invitee_email])\n\n        data = {\"email\": invitee_email, \"referrer_email\": current_user.email}\n        invitee = PreregistrationUser.objects.get(email=data[\"email\"])\n        referrer = self.example_user(referrer_name)\n        validity_in_minutes = 2 * 24 * 60\n        link = create_confirmation_link(\n            invitee, Confirmation.INVITATION, validity_in_minutes=validity_in_minutes\n        )\n        context = common_context(referrer)\n        context.update(\n            activate_url=link,\n            referrer_name=referrer.full_name,\n            referrer_email=referrer.email,\n            referrer_realm_name=referrer.realm.name,\n        )\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now()\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n        email_count = len(outbox)\n        for job in email_jobs_to_deliver:\n            deliver_scheduled_emails(job)\n        self.assert_length(outbox, email_count + 1)\n        self.assertEqual(self.email_envelope_from(outbox[-1]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertIn(FromAddress.NOREPLY, self.email_display_from(outbox[-1]))\n\n        # Now verify that signing up clears invite_reminder emails\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n\n        self.register(invitee_email, \"test\")\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 0)\n\n    def test_no_invitation_reminder_when_link_expires_quickly(self) -> None:\n        self.login(\"hamlet\")\n        # Check invitation reminder email is scheduled with 4 day link expiry\n        self.invite(\"alice@zulip.com\", [\"Denmark\"], invite_expires_in_minutes=4 * 24 * 60)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(type=ScheduledEmail.INVITATION_REMINDER).count(), 1\n        )\n        # Check invitation reminder email is not scheduled with 3 day link expiry\n        self.invite(\"bob@zulip.com\", [\"Denmark\"], invite_expires_in_minutes=3 * 24 * 60)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(type=ScheduledEmail.INVITATION_REMINDER).count(), 1\n        )\n\n    # make sure users can't take a valid confirmation key from another\n    # pathway and use it with the invitation URL route\n    def test_confirmation_key_of_wrong_type(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = url.split(\"/\")[-1]\n\n        # Mainly a test of get_object_from_key, rather than of the invitation pathway\n        with self.assertRaises(ConfirmationKeyError) as cm:\n            get_object_from_key(registration_key, [Confirmation.INVITATION], mark_object_used=True)\n        self.assertEqual(cm.exception.error_type, ConfirmationKeyError.DOES_NOT_EXIST)\n\n        # Verify that using the wrong type doesn't work in the main confirm code path\n        email_change_url = create_confirmation_link(prereg_user, Confirmation.EMAIL_CHANGE)\n        email_change_key = email_change_url.split(\"/\")[-1]\n        result = self.client_post(\"/accounts/register/\", {\"key\": email_change_key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", result\n        )\n\n    def test_confirmation_expired(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        date_sent = timezone_now() - datetime.timedelta(weeks=3)\n        with patch(\"confirmation.models.timezone_now\", return_value=date_sent):\n            url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        key = url.split(\"/\")[-1]\n        confirmation_link_path = \"/\" + url.split(\"/\", 3)[3]\n        # Both the confirmation link and submitting the key to the registration endpoint\n        # directly will return the appropriate error.\n        result = self.client_get(confirmation_link_path)\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n        result = self.client_post(\"/accounts/register/\", {\"key\": key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_never_expire_confirmation_object(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        activation_url = create_confirmation_link(\n            prereg_user, Confirmation.INVITATION, validity_in_minutes=None\n        )\n        confirmation = Confirmation.objects.last()\n        assert confirmation is not None\n        self.assertEqual(confirmation.expiry_date, None)\n        activation_key = activation_url.split(\"/\")[-1]\n        response = self.client_post(\n            \"/accounts/register/\",\n            {\"key\": activation_key, \"from_confirmation\": 1, \"full_nme\": \"alice\"},\n        )\n        self.assertEqual(response.status_code, 200)\n\n    def test_send_more_than_one_invite_to_same_user(self) -> None:\n        self.user_profile = self.example_user(\"iago\")\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, self.user_profile.realm))\n\n        invite_expires_in_minutes = 2 * 24 * 60\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        prereg_user = PreregistrationUser.objects.get(email=\"foo@zulip.com\")\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n\n        # Also send an invite from a different realm.\n        lear = get_realm(\"lear\")\n        lear_user = self.lear_user(\"cordelia\")\n        do_invite_users(\n            lear_user, [\"foo@zulip.com\"], [], invite_expires_in_minutes=invite_expires_in_minutes\n        )\n\n        invites = PreregistrationUser.objects.filter(email__iexact=\"foo@zulip.com\")\n        self.assert_length(invites, 4)\n\n        created_user = do_create_user(\n            \"foo@zulip.com\",\n            \"password\",\n            self.user_profile.realm,\n            \"full name\",\n            prereg_user=prereg_user,\n            acting_user=None,\n        )\n\n        accepted_invite = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_USED\n        )\n        revoked_invites = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_REVOKED\n        )\n        # If a user was invited more than once, when it accepts one invite and register\n        # the others must be canceled.\n        self.assert_length(accepted_invite, 1)\n        self.assertEqual(accepted_invite[0].id, prereg_user.id)\n        self.assertEqual(accepted_invite[0].created_user, created_user)\n\n        expected_revoked_invites = set(invites.exclude(id=prereg_user.id).exclude(realm=lear))\n        self.assertEqual(set(revoked_invites), expected_revoked_invites)\n\n        self.assertEqual(\n            PreregistrationUser.objects.get(email__iexact=\"foo@zulip.com\", realm=lear).status, 0\n        )\n\n        with self.assertRaises(AssertionError):\n            process_new_human_user(created_user, prereg_user)\n\n    def test_confirmation_obj_not_exist_error(self) -> None:\n        \"\"\"Since the key is a param input by the user to the registration endpoint,\n        if it inserts an invalid value, the confirmation object won't be found. This\n        tests if, in that scenario, we handle the exception by redirecting the user to\n        the link_expired page.\n        \"\"\"\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        registration_key = \"invalid_confirmation_key\"\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", response\n        )\n\n        registration_key = confirmation_link.split(\"/\")[-1]\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], response)\n        response = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(response.status_code, 302)\n\n    def test_validate_email_not_already_in_realm(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.submit_reg_form_for_user(email, password, key=registration_key)\n\n        new_prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        new_confirmation_link = create_confirmation_link(\n            new_prereg_user, Confirmation.USER_REGISTRATION\n        )\n        new_registration_key = new_confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": new_registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(\n            response[\"Location\"],\n            reverse(\"login\") + \"?\" + urlencode({\"email\": email, \"already_registered\": 1}),\n        )\n\n    def test_confirmation_key_cant_be_reused(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.submit_reg_form_for_user(email, password, key=registration_key)\n\n        prereg_user.refresh_from_db()\n        self.assertIsNotNone(prereg_user.created_user)\n\n        # Now attempt to re-use the same key.\n        result = self.client_post(\"/accounts/register/\", {\"key\": registration_key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_confirmation_link_in_manual_license_plan(self) -> None:\n        inviter = self.example_user(\"iago\")\n        realm = get_realm(\"zulip\")\n\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver/\")\n\n        # We want to simulate the organization having exactly all their licenses\n        # used, to verify that joining as a regular user is not allowed,\n        # but as a guest still works (guests are free up to a certain number).\n        current_seat_count = get_latest_seat_count(realm)\n        self.subscribe_realm_to_monthly_plan_on_manual_license_management(\n            realm, current_seat_count, current_seat_count\n        )\n\n        email = self.nonreg_email(\"bob\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"bob\"})\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assert_in_success_response(\n            [\"New members cannot join this organization because all Zulip licenses are\"], response\n        )\n\n        guest_prereg_user = PreregistrationUser.objects.create(\n            email=email,\n            referred_by=inviter,\n            realm=realm,\n            invited_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"],\n        )\n        confirmation_link = create_confirmation_link(\n            guest_prereg_user, Confirmation.USER_REGISTRATION\n        )\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver/\")\n\n\nclass InvitationsTestCase(InviteUserBase):\n    def test_do_get_invites_controlled_by_user(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        invite_expires_in_minutes = 2 * 24 * 60\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            user_profile,\n            [\"TestTwo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            hamlet,\n            [\"TestThree@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            othello,\n            [\"TestFour@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            self.mit_user(\"sipbtest\"),\n            [\"TestOne@mit.edu\"],\n            [],\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_create_multiuse_invite_link(\n            user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_minutes\n        )\n        self.assert_length(do_get_invites_controlled_by_user(user_profile), 5)\n        self.assert_length(do_get_invites_controlled_by_user(hamlet), 1)\n        self.assert_length(do_get_invites_controlled_by_user(othello), 1)\n\n    def test_successful_get_open_invitations(self) -> None:\n        \"\"\"\n        A GET call to /json/invites returns all unexpired invitations.\n        \"\"\"\n        active_value = getattr(confirmation_settings, \"STATUS_USED\", \"Wrong\")\n        self.assertNotEqual(active_value, \"Wrong\")\n\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n        self.login_user(user_profile)\n\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        invite_expires_in_minutes = 2 * 24 * 60\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n\n        with patch(\n            \"confirmation.models.timezone_now\",\n            return_value=timezone_now() - datetime.timedelta(days=3),\n        ):\n            do_invite_users(\n                user_profile,\n                [\"TestTwo@zulip.com\"],\n                streams,\n                invite_expires_in_minutes=invite_expires_in_minutes,\n            )\n            do_create_multiuse_invite_link(\n                othello, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_minutes\n            )\n\n        prereg_user_three = PreregistrationUser(\n            email=\"TestThree@zulip.com\", referred_by=user_profile, status=active_value\n        )\n        prereg_user_three.save()\n        create_confirmation_link(\n            prereg_user_three,\n            Confirmation.INVITATION,\n            validity_in_minutes=invite_expires_in_minutes,\n        )\n\n        do_create_multiuse_invite_link(\n            hamlet, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_minutes\n        )\n\n        result = self.client_get(\"/json/invites\")\n        self.assertEqual(result.status_code, 200)\n        invites = orjson.loads(result.content)[\"invites\"]\n        self.assert_length(invites, 2)\n\n        self.assertFalse(invites[0][\"is_multiuse\"])\n        self.assertEqual(invites[0][\"email\"], \"TestOne@zulip.com\")\n        self.assertTrue(invites[1][\"is_multiuse\"])\n        self.assertEqual(invites[1][\"invited_by_user_id\"], hamlet.id)\n\n    def test_get_never_expiring_invitations(self) -> None:\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        with patch(\n            \"confirmation.models.timezone_now\",\n            return_value=timezone_now() - datetime.timedelta(days=1000),\n        ):\n            # Testing the invitation with expiry date set to \"None\" exists\n            # after a large amount of days.\n            do_invite_users(\n                user_profile,\n                [\"TestOne@zulip.com\"],\n                streams,\n                invite_expires_in_minutes=None,\n            )\n            do_invite_users(\n                user_profile,\n                [\"TestTwo@zulip.com\"],\n                streams,\n                invite_expires_in_minutes=100 * 24 * 60,\n            )\n            do_create_multiuse_invite_link(\n                user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], None\n            )\n            do_create_multiuse_invite_link(\n                user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], 100\n            )\n\n        result = self.client_get(\"/json/invites\")\n        self.assertEqual(result.status_code, 200)\n        invites = orjson.loads(result.content)[\"invites\"]\n        # We only get invitations that will never expire because we have mocked time such\n        # that the other invitations are created in the deep past.\n        self.assert_length(invites, 2)\n\n        self.assertFalse(invites[0][\"is_multiuse\"])\n        self.assertEqual(invites[0][\"email\"], \"TestOne@zulip.com\")\n        self.assertEqual(invites[0][\"expiry_date\"], None)\n        self.assertTrue(invites[1][\"is_multiuse\"])\n        self.assertEqual(invites[1][\"invited_by_user_id\"], user_profile.id)\n        self.assertEqual(invites[1][\"expiry_date\"], None)\n\n    def test_successful_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        self.login(\"iago\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify that the scheduled email exists.\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_successful_member_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call from member account to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n\n        # Verify that the scheduled email exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify another non-admin can't delete\n        result = self.api_delete(\n            self.example_user(\"othello\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        # Verify that the scheduled email still exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify deletion works.\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n        owner = self.example_user(\"desdemona\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        result = self.api_delete(\n            self.example_user(\"iago\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_success(result)\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_multiuse_invite(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/multiuse<ID> should delete the\n        multiuse_invite.\n        \"\"\"\n        self.login(\"iago\")\n\n        zulip_realm = get_realm(\"zulip\")\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"hamlet\"), realm=zulip_realm\n        )\n        validity_in_minutes = 2 * 24 * 60\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_minutes=validity_in_minutes\n        )\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(\n            MultiuseInvite.objects.get(id=multiuse_invite.id).status,\n            confirmation_settings.STATUS_REVOKED,\n        )\n        # Test that trying to double-delete fails\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"Invitation has already been revoked\")\n\n        # Test deleting owner mutiuse_invite.\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"desdemona\"),\n            realm=zulip_realm,\n            invited_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"],\n        )\n        validity_in_minutes = 2\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_minutes=validity_in_minutes\n        )\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_success(result)\n        self.assertEqual(\n            MultiuseInvite.objects.get(id=multiuse_invite.id).status,\n            confirmation_settings.STATUS_REVOKED,\n        )\n\n        # Test deleting multiuse invite from another realm\n        mit_realm = get_realm(\"zephyr\")\n        multiuse_invite_in_mit = MultiuseInvite.objects.create(\n            referred_by=self.mit_user(\"sipbtest\"), realm=mit_realm\n        )\n        validity_in_minutes = 2 * 24 * 60\n        create_confirmation_link(\n            multiuse_invite_in_mit,\n            Confirmation.MULTIUSE_INVITE,\n            validity_in_minutes=validity_in_minutes,\n        )\n        error_result = self.client_delete(\n            \"/json/invites/multiuse/\" + str(multiuse_invite_in_mit.id)\n        )\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        non_existent_id = MultiuseInvite.objects.count() + 9999\n        error_result = self.client_delete(f\"/json/invites/multiuse/{non_existent_id}\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_successful_resend_invitation(self) -> None:\n        \"\"\"\n        A POST call to /json/invites/<ID>/resend should send an invitation reminder email\n        and delete any scheduled invitation reminder email.\n        \"\"\"\n        self.login(\"iago\")\n        invitee = \"resend_me@zulip.com\"\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n    def test_successful_member_resend_invitation(self) -> None:\n        \"\"\"A POST call from member a account to /json/invites/<ID>/resend\n        should send an invitation reminder email and delete any\n        scheduled invitation reminder email if they send the invite.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"resend_me@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        # Verify hamlet has only one invitation (Member can resend invitations only sent by him).\n        invitation = PreregistrationUser.objects.filter(referred_by=user_profile)\n        self.assert_length(invitation, 1)\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n        self.logout()\n        self.login(\"othello\")\n        invitee = \"TestOne@zulip.com\"\n        prereg_user_one = PreregistrationUser(email=invitee, referred_by=user_profile)\n        prereg_user_one.save()\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization administrator\")\n\n    def test_resend_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n\n        invitee = \"resend_owner@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        self.check_sent_emails([invitee])\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Test only organization owners can resend owner invitation.\n        self.login(\"iago\")\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_success(result)\n\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n    def test_resend_never_expiring_invitation(self) -> None:\n        self.login(\"iago\")\n        invitee = \"resend@zulip.com\"\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"], None))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_success(result)\n        self.check_sent_emails([invitee])\n\n    def test_accessing_invites_in_another_realm(self) -> None:\n        inviter = UserProfile.objects.exclude(realm=get_realm(\"zulip\")).first()\n        assert inviter is not None\n        prereg_user = PreregistrationUser.objects.create(\n            email=\"email\", referred_by=inviter, realm=inviter.realm\n        )\n        self.login(\"iago\")\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_prereg_user_status(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n\n        inviter = UserProfile.objects.filter(realm=realm).first()\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"key\": registration_key, \"from_confirmation\": \"1\", \"full_name\": \"alice\"},\n        )\n        self.assertEqual(result.status_code, 200)\n        confirmation = Confirmation.objects.get(confirmation_key=registration_key)\n        assert confirmation.content_object is not None\n        prereg_user = confirmation.content_object\n        self.assertEqual(prereg_user.status, 0)\n\n        result = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(result.status_code, 302)\n        prereg_user = PreregistrationUser.objects.get(email=email, referred_by=inviter, realm=realm)\n        self.assertEqual(prereg_user.status, confirmation_settings.STATUS_USED)\n        user = get_user_by_delivery_email(email, realm)\n        self.assertIsNotNone(user)\n        self.assertEqual(user.delivery_email, email)\n\n\nclass InviteeEmailsParserTests(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.email1 = \"email1@zulip.com\"\n        self.email2 = \"email2@zulip.com\"\n        self.email3 = \"email3@zulip.com\"\n\n    def test_if_emails_separated_by_commas_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1} ,{self.email2}, {self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_separated_by_newlines_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1}\\n {self.email2}\\n {self.email3} \"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_from_email_client_separated_by_newlines_are_parsed_correctly(self) -> None:\n        emails_raw = (\n            f\"Email One <{self.email1}>\\nEmailTwo<{self.email2}>\\nEmail Three<{self.email3}>\"\n        )\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_in_mixed_style_are_parsed_correctly(self) -> None:\n        emails_raw = f\"Email One <{self.email1}>,EmailTwo<{self.email2}>\\n{self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n\nclass MultiuseInviteTest(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.realm = get_realm(\"zulip\")\n        self.realm.invite_required = True\n        self.realm.save()\n\n    def generate_multiuse_invite_link(\n        self, streams: Optional[List[Stream]] = None, date_sent: Optional[datetime.datetime] = None\n    ) -> str:\n        invite = MultiuseInvite(realm=self.realm, referred_by=self.example_user(\"iago\"))\n        invite.save()\n\n        if streams is not None:\n            invite.streams.set(streams)\n\n        if date_sent is None:\n            date_sent = timezone_now()\n        validity_in_minutes = 2 * 24 * 60\n        with patch(\"confirmation.models.timezone_now\", return_value=date_sent):\n            return create_confirmation_link(\n                invite, Confirmation.MULTIUSE_INVITE, validity_in_minutes=validity_in_minutes\n            )\n\n    def check_user_able_to_register(self, email: str, invite_link: str) -> None:\n        password = \"password\"\n\n        result = self.client_post(invite_link, {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        # Verify the PreregistrationUser object was set up as expected.\n        prereg_user = PreregistrationUser.objects.last()\n        multiuse_invite = MultiuseInvite.objects.last()\n\n        assert prereg_user is not None\n        self.assertEqual(prereg_user.email, email)\n        self.assertEqual(prereg_user.multiuse_invite, multiuse_invite)\n\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n    def test_valid_multiuse_link(self) -> None:\n        email1 = self.nonreg_email(\"test\")\n        email2 = self.nonreg_email(\"test1\")\n        email3 = self.nonreg_email(\"alice\")\n\n        date_sent = timezone_now() - datetime.timedelta(days=1)\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_able_to_register(email3, invite_link)\n\n    def test_expired_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        date_sent = timezone_now() - datetime.timedelta(\n            days=settings.INVITATION_LINK_VALIDITY_DAYS + 1\n        )\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"The confirmation link has expired or been deactivated.\", result)\n\n    def test_revoked_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        invite_link = self.generate_multiuse_invite_link()\n        multiuse_invite = MultiuseInvite.objects.last()\n        assert multiuse_invite is not None\n        do_revoke_multi_use_invite(multiuse_invite)\n\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"We couldn't find your confirmation link in the system.\", result)\n\n    def test_invalid_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"Whoops. The confirmation link is malformed.\", result)\n\n    def test_invalid_multiuse_link_in_open_realm(self) -> None:\n        self.realm.invite_required = False\n        self.realm.save()\n\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n\n        with patch(\"zerver.views.registration.get_realm_from_request\", return_value=self.realm):\n            with patch(\"zerver.views.registration.get_realm\", return_value=self.realm):\n                self.check_user_able_to_register(email, invite_link)\n\n    def test_multiuse_link_with_specified_streams(self) -> None:\n        name1 = \"newuser\"\n        name2 = \"bob\"\n        name3 = \"alice\"\n        email1 = self.nonreg_email(name1)\n        email2 = self.nonreg_email(name2)\n        email3 = self.nonreg_email(name3)\n\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_subscribed_only_to_streams(name1, streams)\n\n        stream_names = [\"Rome\", \"Verona\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_subscribed_only_to_streams(name2, streams)\n\n        streams = []\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email3, invite_link)\n        # User is not subscribed to default streams as well.\n        self.assert_length(get_default_streams_for_realm(self.realm.id), 1)\n        self.check_user_subscribed_only_to_streams(name3, [])\n\n    def test_multiuse_link_different_realms(self) -> None:\n        \"\"\"\n        Verify that an invitation generated for one realm can't be used\n        to join another.\n        \"\"\"\n        lear_realm = get_realm(\"lear\")\n        self.realm = lear_realm\n        invite_link = self.generate_multiuse_invite_link(streams=[])\n        key = invite_link.split(\"/\")[-2]\n\n        result = self.client_get(f\"/join/{key}/\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", result\n        )\n\n        # Now we want to test the accounts_home function, which can't be used\n        # for the multiuse invite case via an HTTP request, but is still supposed\n        # to do its own verification that the realms match as a hardening measure\n        # against a caller that fails to do that.\n        request = HttpRequest()\n        confirmation = Confirmation.objects.get(confirmation_key=key)\n        multiuse_object = confirmation.content_object\n        with patch(\n            \"zerver.views.registration.get_subdomain\", return_value=\"zulip\"\n        ), self.assertRaises(AssertionError):\n            accounts_home(request, multiuse_object=multiuse_object)\n\n    def test_create_multiuse_link_api_call(self) -> None:\n        self.login(\"iago\")\n\n        result = self.client_post(\n            \"/json/invites/multiuse\", {\"invite_expires_in_minutes\": 2 * 24 * 60}\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_with_specified_streams_api_call(self) -> None:\n        self.login(\"iago\")\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        stream_ids = [stream.id for stream in streams]\n\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n        self.check_user_subscribed_only_to_streams(\"test\", streams)\n\n        self.login(\"iago\")\n        stream_ids = []\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"alice\"), invite_link)\n        # User is not subscribed to default streams as well.\n        self.assert_length(get_default_streams_for_realm(self.realm.id), 1)\n        self.check_user_subscribed_only_to_streams(\"alice\", [])\n\n    def test_only_admin_can_create_multiuse_link_api_call(self) -> None:\n        self.login(\"iago\")\n        # Only admins should be able to create multiuse invites even if\n        # invite_to_realm_policy is set to Realm.POLICY_MEMBERS_ONLY.\n        self.realm.invite_to_realm_policy = Realm.POLICY_MEMBERS_ONLY\n        self.realm.save()\n\n        result = self.client_post(\n            \"/json/invites/multiuse\", {\"invite_expires_in_minutes\": 2 * 24 * 60}\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n        self.login(\"hamlet\")\n        result = self.client_post(\"/json/invites/multiuse\")\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_multiuse_link_for_inviting_as_owner(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_invalid_stream_api_call(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps([54321]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Invalid stream ID 54321. No invites were sent.\")\n\n    def test_create_multiuse_link_invalid_invite_as_api_call(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"GUEST_USER\"] + 1).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Invalid invite_as\")\n\n\nclass EmailUnsubscribeTests(ZulipTestCase):\n    def test_error_unsubscribe(self) -> None:\n        # An invalid unsubscribe token \"test123\" produces an error.\n        result = self.client_get(\"/accounts/unsubscribe/missed_messages/test123\")\n        self.assert_in_response(\"Unknown email unsubscribe request\", result)\n\n        # An unknown message type \"fake\" produces an error.\n        user_profile = self.example_user(\"hamlet\")\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"fake\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assert_in_response(\"Unknown email unsubscribe request\", result)\n\n    def test_message_notification_emails_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in message notification emails\n        that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.enable_offline_email_notifications = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"missed_messages\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_offline_email_notifications)\n\n    def test_welcome_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in welcome e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        # Simulate a new user signing up, which enqueues 2 welcome e-mails.\n        enqueue_welcome_emails(user_profile)\n        self.assertEqual(2, ScheduledEmail.objects.filter(users=user_profile).count())\n\n        # Simulate unsubscribing from the welcome e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"welcome\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The welcome email jobs are no longer scheduled.\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(0, ScheduledEmail.objects.filter(users=user_profile).count())\n\n    def test_digest_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in digest e-mails that you can\n        click even when logged out to stop receiving them.\n\n        Unsubscribing from these emails also dequeues any digest email jobs that\n        have been queued.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_digest_emails)\n\n        # Enqueue a fake digest email.\n        context = {\n            \"name\": \"\",\n            \"realm_uri\": \"\",\n            \"unread_pms\": [],\n            \"hot_conversations\": [],\n            \"new_users\": [],\n            \"new_streams\": {\"plain\": []},\n            \"unsubscribe_link\": \"\",\n        }\n        send_future_email(\n            \"zerver/emails/digest\",\n            user_profile.realm,\n            to_user_ids=[user_profile.id],\n            context=context,\n        )\n\n        self.assertEqual(1, ScheduledEmail.objects.filter(users=user_profile).count())\n\n        # Simulate unsubscribing from digest e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"digest\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The setting is toggled off, and scheduled jobs have been removed.\n        self.assertEqual(result.status_code, 200)\n        # Circumvent user_profile caching.\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_digest_emails)\n        self.assertEqual(0, ScheduledEmail.objects.filter(users=user_profile).count())\n\n    def test_login_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in login\n        e-mails that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.enable_login_emails = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"login\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_login_emails)\n\n    def test_marketing_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in marketing e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_marketing_emails)\n\n        # Simulate unsubscribing from marketing e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"marketing\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assertEqual(result.status_code, 200)\n\n        # Circumvent user_profile caching.\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_marketing_emails)\n\n    def test_marketing_unsubscribe_post(self) -> None:\n        \"\"\"\n        The List-Unsubscribe-Post header lets email clients trigger an\n        automatic unsubscription request via POST (see RFC 8058), so\n        test that too.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_marketing_emails)\n\n        # Simulate unsubscribing from marketing e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"marketing\")\n        client = Client(enforce_csrf_checks=True)\n        result = client.post(\n            urllib.parse.urlparse(unsubscribe_link).path, {\"List-Unsubscribe\": \"One-Click\"}\n        )\n        self.assertEqual(result.status_code, 200)\n\n        # Circumvent user_profile caching.\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_marketing_emails)\n\n\nclass RealmCreationTest(ZulipTestCase):\n    @override_settings(OPEN_REALM_CREATION=True)\n    def check_able_to_create_realm(self, email: str, password: str = \"test\") -> None:\n        internal_realm = get_realm(settings.SYSTEM_BOT_REALM)\n        notification_bot = get_system_bot(settings.NOTIFICATION_BOT, internal_realm.id)\n        signups_stream, _ = create_stream_if_needed(notification_bot.realm, \"signups\")\n\n        string_id = \"zuliptest\"\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Check confirmation email has the correct subject and body, extract\n        # confirmation link and visit it\n        confirmation_url = self.get_confirmation_url_from_outbox(\n            email,\n            email_subject_contains=\"Create your Zulip organization\",\n            email_body_contains=\"You have requested a new Zulip organization\",\n        )\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password, realm_subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(\"http://zuliptest.testserver/accounts/login/subdomain/\")\n        )\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n\n        # Check that user is the owner.\n        self.assertEqual(user.role, UserProfile.ROLE_REALM_OWNER)\n\n        # Check defaults\n        self.assertEqual(realm.org_type, Realm.ORG_TYPES[\"business\"][\"id\"])\n        self.assertEqual(realm.emails_restricted_to_domains, False)\n        self.assertEqual(realm.invite_required, True)\n\n        # Check welcome messages\n        for stream_name, text, message_count in [\n            (Realm.DEFAULT_NOTIFICATION_STREAM_NAME, \"with the topic\", 3),\n            (Realm.INITIAL_PRIVATE_STREAM_NAME, \"private stream\", 1),\n        ]:\n            stream = get_stream(stream_name, realm)\n            recipient = stream.recipient\n            messages = Message.objects.filter(recipient=recipient).order_by(\"date_sent\")\n            self.assert_length(messages, message_count)\n            self.assertIn(text, messages[0].content)\n\n        # Check signup messages\n        recipient = signups_stream.recipient\n        messages = Message.objects.filter(recipient=recipient).order_by(\"id\")\n        self.assert_length(messages, 2)\n        self.assertIn(\"Signups enabled\", messages[0].content)\n        self.assertIn(\"signed up\", messages[1].content)\n        self.assertEqual(\"zuliptest\", messages[1].topic_name())\n\n        realm_creation_audit_log = RealmAuditLog.objects.get(\n            realm=realm, event_type=RealmAuditLog.REALM_CREATED\n        )\n        self.assertEqual(realm_creation_audit_log.acting_user, user)\n        self.assertEqual(realm_creation_audit_log.event_time, realm.date_created)\n\n        # Piggyback a little check for how we handle\n        # empty string_ids.\n        realm.string_id = \"\"\n        self.assertEqual(realm.display_subdomain, \".\")\n\n    def test_create_realm_non_existing_email(self) -> None:\n        self.check_able_to_create_realm(\"user1@test.com\")\n\n    def test_create_realm_existing_email(self) -> None:\n        self.check_able_to_create_realm(\"hamlet@zulip.com\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_create_realm_ldap_email(self) -> None:\n        self.init_default_ldap_database()\n\n        with self.settings(LDAP_EMAIL_ATTR=\"mail\"):\n            self.check_able_to_create_realm(\n                \"newuser_email@zulip.com\", self.ldap_password(\"newuser_with_email\")\n            )\n\n    def test_create_realm_as_system_bot(self) -> None:\n        result = self.client_post(\"/new/\", {\"email\": \"notification-bot@zulip.com\"})\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"notification-bot@zulip.com is reserved for system bots\", result)\n\n    def test_create_realm_no_creation_key(self) -> None:\n        \"\"\"\n        Trying to create a realm without a creation_key should fail when\n        OPEN_REALM_CREATION is false.\n        \"\"\"\n        email = \"user1@test.com\"\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            # Create new realm with the email, but no creation key.\n            result = self.client_post(\"/new/\", {\"email\": email})\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\"Organization creation link required\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_subdomain(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=string_id, realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        self.assertEqual(get_user(email, realm).realm, realm)\n\n        self.assertEqual(realm.name, realm_name)\n        self.assertEqual(realm.subdomain, string_id)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_marketing_emails_enabled(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=True,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertTrue(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True, CORPORATE_ENABLED=False)\n    def test_create_realm_without_prompting_for_marketing_emails(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Simulate the initial POST that is made by confirm-preregistration.js\n        # by triggering submit on confirm_preregistration.html.\n        payload = {\n            \"full_name\": \"\",\n            \"key\": find_key_by_email(email),\n            \"from_confirmation\": \"1\",\n        }\n        result = self.client_post(\"/accounts/register/\", payload)\n        # Assert that the form did not prompt the user for enabling\n        # marketing emails.\n        self.assert_not_in_success_response(['input id=\"id_enable_marketing_emails\"'], result)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertFalse(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_marketing_emails_disabled(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertFalse(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_regular_realm_welcome_bot_pm(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        # Make sure the correct Welcome Bot PM is sent\n        welcome_msg = Message.objects.filter(\n            sender__email=\"welcome-bot@zulip.com\", recipient__type=Recipient.PERSONAL\n        ).latest(\"id\")\n        self.assertTrue(welcome_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertNotIn(\"demo organization\", welcome_msg.content)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_demo_realm_welcome_bot_pm(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n            is_demo_organization=True,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        # Make sure the correct Welcome Bot PM is sent\n        welcome_msg = Message.objects.filter(\n            sender__email=\"welcome-bot@zulip.com\", recipient__type=Recipient.PERSONAL\n        ).latest(\"id\")\n        self.assertTrue(welcome_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertIn(\"demo organization\", welcome_msg.content)\n\n    @override_settings(OPEN_REALM_CREATION=True, FREE_TRIAL_DAYS=30)\n    def test_create_realm_during_free_trial(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=string_id, realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result[\"Location\"], \"http://zuliptest.testserver/upgrade/?onboarding=true\")\n\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assert_in_success_response([\"Not ready to start your trial?\"], result)\n\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        self.assertEqual(get_user(email, realm).realm, realm)\n\n        self.assertEqual(realm.name, realm_name)\n        self.assertEqual(realm.subdomain, string_id)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_two_realms(self) -> None:\n        \"\"\"\n        Verify correct behavior and PreregistrationUser handling when using\n        two pre-generated realm creation links to create two different realms.\n        \"\"\"\n        password = \"test\"\n        first_string_id = \"zuliptest\"\n        second_string_id = \"zuliptest2\"\n        email = \"user1@test.com\"\n        first_realm_name = \"Test\"\n        second_realm_name = \"Test\"\n\n        # Make sure the realms do not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(first_string_id)\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(second_string_id)\n\n        # Now we pre-generate two realm creation links\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        first_confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 1)\n\n        # Get a second realm creation link.\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        second_confirmation_url = self.get_confirmation_url_from_outbox(email)\n\n        self.assertNotEqual(first_confirmation_url, second_confirmation_url)\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 2)\n\n        # Create and verify the first realm\n        result = self.client_get(first_confirmation_url)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=first_string_id,\n            realm_name=first_realm_name,\n            key=first_confirmation_url.split(\"/\")[-1],\n        )\n        self.assertEqual(result.status_code, 302)\n        # Make sure the realm is created\n        realm = get_realm(first_string_id)\n        self.assertEqual(realm.string_id, first_string_id)\n        self.assertEqual(realm.name, first_realm_name)\n\n        # One of the PreregistrationUsers should have been used up:\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 1)\n\n        # Create and verify the second realm\n        result = self.client_get(second_confirmation_url)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=second_string_id,\n            realm_name=second_realm_name,\n            key=second_confirmation_url.split(\"/\")[-1],\n        )\n        self.assertEqual(result.status_code, 302)\n        # Make sure the realm is created\n        realm = get_realm(second_string_id)\n        self.assertEqual(realm.string_id, second_string_id)\n        self.assertEqual(realm.name, second_realm_name)\n\n        # The remaining PreregistrationUser should have been used up:\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 0)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_invalid_email_signup(self) -> None:\n        result = self.client_post(\"/new/\", {\"email\": \"<foo\"})\n        self.assert_in_response(\"Please use your real email address.\", result)\n\n        result = self.client_post(\"/new/\", {\"email\": \"foo\\x00bar\"})\n        self.assert_in_response(\"Please use your real email address.\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_mailinator_signup(self) -> None:\n        result = self.client_post(\"/new/\", {\"email\": \"hi@mailinator.com\"})\n        self.assert_in_response(\"Please use your real email address.\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        errors = {\n            \"id\": \"length 3 or greater\",\n            \"-id\": \"cannot start or end with a\",\n            \"string-ID\": \"lowercase letters\",\n            \"string_id\": \"lowercase letters\",\n            \"stream\": \"unavailable\",\n            \"streams\": \"unavailable\",\n            \"about\": \"unavailable\",\n            \"abouts\": \"unavailable\",\n            \"zephyr\": \"unavailable\",\n        }\n        for string_id, error_msg in errors.items():\n            result = self.submit_reg_form_for_user(\n                email, password, realm_subdomain=string_id, realm_name=realm_name\n            )\n            self.assert_in_response(error_msg, result)\n\n        # test valid subdomain\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"a-0\", realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(\"http://a-0.testserver/accounts/login/subdomain/\")\n        )\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_using_old_subdomain_of_a_realm(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-name\", acting_user=None)\n\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"zulip\", realm_name=realm_name\n        )\n        self.assert_in_response(\"Subdomain unavailable. Please choose a different one.\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(\n                email, password, realm_subdomain=\"\", realm_name=realm_name\n            )\n            self.assert_in_response(\"unavailable\", result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"\", realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(\"http://testserver/accounts/login/subdomain/\")\n        )\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain_option(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                realm_subdomain=\"abcdef\",\n                realm_in_root_domain=\"true\",\n                realm_name=realm_name,\n            )\n            self.assert_in_response(\"unavailable\", result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=\"abcdef\",\n            realm_in_root_domain=\"true\",\n            realm_name=realm_name,\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(\"http://testserver/accounts/login/subdomain/\")\n        )\n\n    def test_is_root_domain_available(self) -> None:\n        self.assertTrue(is_root_domain_available())\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            self.assertFalse(is_root_domain_available())\n        realm = get_realm(\"zulip\")\n        realm.string_id = Realm.SUBDOMAIN_FOR_ROOT_DOMAIN\n        realm.save()\n        self.assertFalse(is_root_domain_available())\n\n    def test_subdomain_check_api(self) -> None:\n        result = self.client_get(\"/json/realm/subdomain/zulip\")\n        self.assert_in_success_response(\n            [\"Subdomain unavailable. Please choose a different one.\"], result\n        )\n\n        result = self.client_get(\"/json/realm/subdomain/zu_lip\")\n        self.assert_in_success_response(\n            [\"Subdomain can only have lowercase letters, numbers, and '-'s.\"], result\n        )\n\n        with self.settings(SOCIAL_AUTH_SUBDOMAIN=\"zulipauth\"):\n            result = self.client_get(\"/json/realm/subdomain/zulipauth\")\n            self.assert_in_success_response(\n                [\"Subdomain unavailable. Please choose a different one.\"], result\n            )\n\n        result = self.client_get(\"/json/realm/subdomain/hufflepuff\")\n        self.assert_in_success_response([\"available\"], result)\n        self.assert_not_in_success_response([\"unavailable\"], result)\n\n    def test_subdomain_check_management_command(self) -> None:\n        # Short names should not work, even with the flag\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"aa\")\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"aa\", allow_reserved_subdomain=True)\n\n        # Malformed names should never work\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"-ba_d-\")\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"-ba_d-\", allow_reserved_subdomain=True)\n\n        with patch(\"zerver.lib.name_restrictions.is_reserved_subdomain\", return_value=False):\n            # Existing realms should never work even if they are not reserved keywords\n            with self.assertRaises(ValidationError):\n                check_subdomain_available(\"zulip\")\n            with self.assertRaises(ValidationError):\n                check_subdomain_available(\"zulip\", allow_reserved_subdomain=True)\n\n        # Reserved ones should only work with the flag\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"stream\")\n        check_subdomain_available(\"stream\", allow_reserved_subdomain=True)\n\n\nclass UserSignUpTest(InviteUserBase):\n    def _assert_redirected_to(self, result: \"TestHttpResponse\", url: str) -> None:\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"LOCATION\"], url)\n\n    def verify_signup(\n        self,\n        *,\n        email: str = \"newguy@zulip.com\",\n        password: Optional[str] = \"newpassword\",\n        full_name: str = \"New user's name\",\n        realm: Optional[Realm] = None,\n        subdomain: Optional[str] = None,\n    ) -> Union[UserProfile, \"TestHttpResponse\"]:\n        \"\"\"Common test function for signup tests.  It is a goal to use this\n        common function for all signup tests to avoid code duplication; doing\n        so will likely require adding new parameters.\"\"\"\n\n        if realm is None:  # nocoverage\n            realm = get_realm(\"zulip\")\n\n        client_kwargs: Dict[str, Any] = {}\n        if subdomain:\n            client_kwargs[\"subdomain\"] = subdomain\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, **client_kwargs)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"], **client_kwargs)\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, **client_kwargs)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS. This should create our\n        # account, log us in, and redirect to the app.\n        result = self.submit_reg_form_for_user(\n            email, password, full_name=full_name, **client_kwargs\n        )\n\n        if result.status_code == 200:\n            # This usually indicated an error returned when submitting the form.\n            # Return the result for the caller to deal with reacting to this, since\n            # in many tests this is expected and the caller wants to assert the content\n            # of the error.\n            return result\n\n        # Verify that we were served a redirect to the app.\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"{realm.uri}/\")\n\n        # Verify that we successfully logged in.\n        user_profile = get_user_by_delivery_email(email, realm)\n        self.assert_logged_in_user_id(user_profile.id)\n        return user_profile\n\n    def test_bad_email_configuration_for_accounts_home(self) -> None:\n        \"\"\"\n        Make sure we redirect for EmailNotDeliveredError.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n\n        smtp_mock = patch(\n            \"zerver.views.registration.send_confirm_registration_email\",\n            side_effect=EmailNotDeliveredError,\n        )\n\n        with smtp_mock, self.assertLogs(level=\"ERROR\") as m:\n            result = self.client_post(\"/accounts/home/\", {\"email\": email})\n\n        self._assert_redirected_to(result, \"/config-error/smtp\")\n        self.assertEqual(m.output, [\"ERROR:root:Error in accounts_home\"])\n\n    def test_bad_email_configuration_for_create_realm(self) -> None:\n        \"\"\"\n        Make sure we redirect for EmailNotDeliveredError.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n\n        smtp_mock = patch(\n            \"zerver.views.registration.send_confirm_registration_email\",\n            side_effect=EmailNotDeliveredError,\n        )\n\n        with smtp_mock, self.assertLogs(level=\"ERROR\") as m:\n            result = self.client_post(\"/new/\", {\"email\": email})\n\n        self._assert_redirected_to(result, \"/config-error/smtp\")\n        self.assertEqual(m.output, [\"ERROR:root:Error in create_realm\"])\n\n    def test_user_default_language_and_timezone(self) -> None:\n        \"\"\"\n        Check if the default language of new user is set using the browser locale\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        timezone = \"America/Denver\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"default_language\", \"de\", acting_user=None)\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(\n            email, password, timezone=timezone, HTTP_ACCEPT_LANGUAGE=\"fr,en;q=0.9\"\n        )\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user(\"newguy\")\n        self.assertNotEqual(user_profile.default_language, realm.default_language)\n        self.assertEqual(user_profile.default_language, \"fr\")\n        self.assertEqual(user_profile.timezone, timezone)\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n    def test_default_language_with_unsupported_browser_locale(self) -> None:\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"default_language\", \"de\", acting_user=None)\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(email, password, HTTP_ACCEPT_LANGUAGE=\"en-IND\")\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user(\"newguy\")\n        self.assertEqual(user_profile.default_language, realm.default_language)\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n    def test_default_twenty_four_hour_time(self) -> None:\n        \"\"\"\n        Check if the default twenty_four_hour_time setting of new user\n        is the default twenty_four_hour_time of the realm.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n        realm_user_default = RealmUserDefault.objects.get(realm=realm)\n        do_set_realm_user_default_setting(\n            realm_user_default, \"twenty_four_hour_time\", True, acting_user=None\n        )\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user(\"newguy\")\n        realm_user_default = RealmUserDefault.objects.get(realm=realm)\n        self.assertEqual(\n            user_profile.twenty_four_hour_time, realm_user_default.twenty_four_hour_time\n        )\n\n    def test_signup_already_active(self) -> None:\n        \"\"\"\n        Check if signing up with an active email redirects to a login page.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result[\"Location\"])\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"You've already registered\", result)\n\n    def test_signup_system_bot(self) -> None:\n        email = \"notification-bot@zulip.com\"\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=\"lear\")\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result[\"Location\"])\n        result = self.client_get(result[\"Location\"])\n\n        # This is not really the right error message, but at least it's an error.\n        self.assert_in_response(\"You've already registered\", result)\n\n    def test_signup_existing_email(self) -> None:\n        \"\"\"\n        Check if signing up with an email used in another realm succeeds.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        self.verify_signup(email=email, realm=get_realm(\"lear\"), subdomain=\"lear\")\n        self.assertEqual(UserProfile.objects.filter(delivery_email=email).count(), 2)\n\n    def test_signup_invalid_name(self) -> None:\n        \"\"\"\n        Check if an invalid name during signup is handled properly.\n        \"\"\"\n\n        result = self.verify_signup(full_name=\"<invalid>\")\n        # _WSGIPatchedWSGIResponse does not exist in Django, thus the inverted isinstance check.\n        assert not isinstance(result, UserProfile)\n        self.assert_in_success_response([\"Invalid characters in name!\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response([\"id_password\", \"id_full_name\"], result)\n\n    def test_signup_without_password(self) -> None:\n        \"\"\"\n        Check if signing up without a password works properly when\n        password_auth_enabled is False.\n        \"\"\"\n        email = self.nonreg_email(\"newuser\")\n        with patch(\"zerver.views.registration.password_auth_enabled\", return_value=False):\n            user_profile = self.verify_signup(email=email, password=None)\n\n        assert isinstance(user_profile, UserProfile)\n        # User should now be logged in.\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_signup_without_full_name(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n        result = self.verify_signup(email=email, password=password, full_name=\"\")\n        # _WSGIPatchedWSGIResponse does not exist in Django, thus the inverted isinstance check.\n        assert not isinstance(result, UserProfile)\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response([\"id_password\", \"id_full_name\"], result)\n\n    def test_signup_email_message_contains_org_header(self) -> None:\n        email = \"newguy@zulip.com\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        from django.core.mail import outbox\n\n        self.assertEqual(outbox[0].extra_headers[\"List-Id\"], \"Zulip Dev <zulip.testserver>\")\n\n    def test_signup_with_full_name(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": password,\n                \"key\": find_key_by_email(email),\n                \"terms\": True,\n                \"full_name\": \"New Guy\",\n                \"from_confirmation\": \"1\",\n            },\n        )\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n    def test_signup_with_weak_password(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        with self.settings(PASSWORD_MIN_LENGTH=6, PASSWORD_MIN_GUESSES=1000):\n            result = self.client_post(\n                \"/accounts/register/\",\n                {\n                    \"password\": \"easy\",\n                    \"key\": find_key_by_email(email),\n                    \"terms\": True,\n                    \"full_name\": \"New Guy\",\n                    \"from_confirmation\": \"1\",\n                },\n            )\n            self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n            result = self.submit_reg_form_for_user(email, \"easy\", full_name=\"New Guy\")\n            self.assert_in_success_response([\"The password is too weak.\"], result)\n            with self.assertRaises(UserProfile.DoesNotExist):\n                # Account wasn't created.\n                get_user(email, get_realm(\"zulip\"))\n\n    def test_signup_with_default_stream_group(self) -> None:\n        # Check if user is subscribed to the streams of default\n        # stream group as well as default streams.\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        default_streams = []\n\n        existing_default_streams = DefaultStream.objects.filter(realm=realm)\n        self.assert_length(existing_default_streams, 1)\n        self.assertEqual(existing_default_streams[0].stream.name, \"Verona\")\n        default_streams.append(existing_default_streams[0].stream)\n\n        for stream_name in [\"venice\", \"rome\"]:\n            stream = get_stream(stream_name, realm)\n            do_add_default_stream(stream)\n            default_streams.append(stream)\n\n        group1_streams = []\n        for stream_name in [\"scotland\", \"denmark\"]:\n            stream = get_stream(stream_name, realm)\n            group1_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 1\", \"group 1 description\", group1_streams)\n\n        result = self.submit_reg_form_for_user(email, password, default_stream_groups=[\"group 1\"])\n        self.check_user_subscribed_only_to_streams(\"newguy\", default_streams + group1_streams)\n\n    def test_signup_two_confirmation_links(self) -> None:\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n        first_confirmation_url = self.get_confirmation_url_from_outbox(email)\n        first_confirmation_key = find_key_by_email(email)\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n        second_confirmation_url = self.get_confirmation_url_from_outbox(email)\n\n        # Sanity check:\n        self.assertNotEqual(first_confirmation_url, second_confirmation_url)\n\n        # Register the account (this will use the second confirmation url):\n        result = self.submit_reg_form_for_user(\n            email, password, full_name=\"New Guy\", from_confirmation=\"1\"\n        )\n        self.assert_in_success_response(\n            [\"We just need you to do one last thing.\", \"New Guy\", email], result\n        )\n        result = self.submit_reg_form_for_user(email, password, full_name=\"New Guy\")\n        user_profile = UserProfile.objects.get(delivery_email=email)\n        self.assertEqual(user_profile.delivery_email, email)\n\n        # Now try to to register using the first confirmation url:\n        result = self.client_get(first_confirmation_url)\n        self.assertEqual(result.status_code, 404)\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": password,\n                \"key\": first_confirmation_key,\n                \"terms\": True,\n                \"full_name\": \"New Guy\",\n                \"from_confirmation\": \"1\",\n            },\n        )\n        # Error page should be displayed\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_signup_with_multiple_default_stream_groups(self) -> None:\n        # Check if user is subscribed to the streams of default\n        # stream groups as well as default streams.\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        DefaultStream.objects.filter(realm=realm).delete()\n        default_streams = []\n        for stream_name in [\"venice\", \"verona\"]:\n            stream = get_stream(stream_name, realm)\n            do_add_default_stream(stream)\n            default_streams.append(stream)\n\n        group1_streams = []\n        for stream_name in [\"scotland\", \"denmark\"]:\n            stream = get_stream(stream_name, realm)\n            group1_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 1\", \"group 1 description\", group1_streams)\n\n        group2_streams = []\n        for stream_name in [\"scotland\", \"rome\"]:\n            stream = get_stream(stream_name, realm)\n            group2_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 2\", \"group 2 description\", group2_streams)\n\n        result = self.submit_reg_form_for_user(\n            email, password, default_stream_groups=[\"group 1\", \"group 2\"]\n        )\n        self.check_user_subscribed_only_to_streams(\n            \"newguy\", list(set(default_streams + group1_streams + group2_streams))\n        )\n\n    def test_signup_without_user_settings_from_another_realm(self) -> None:\n        hamlet_in_zulip = self.example_user(\"hamlet\")\n        email = hamlet_in_zulip.delivery_email\n        password = \"newpassword\"\n        subdomain = \"lear\"\n        realm = get_realm(\"lear\")\n\n        # Make an account in the Zulip realm, but we're not copying from there.\n        hamlet_in_zulip.left_side_userlist = True\n        hamlet_in_zulip.default_language = \"de\"\n        hamlet_in_zulip.emojiset = \"twitter\"\n        hamlet_in_zulip.high_contrast_mode = True\n        hamlet_in_zulip.enter_sends = True\n        hamlet_in_zulip.tutorial_status = UserProfile.TUTORIAL_FINISHED\n        hamlet_in_zulip.save()\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=subdomain)\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"], subdomain=subdomain)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, subdomain=subdomain)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email, password, source_realm_id=\"\", HTTP_HOST=subdomain + \".testserver\"\n        )\n\n        hamlet = get_user(self.example_email(\"hamlet\"), realm)\n        self.assertEqual(hamlet.left_side_userlist, False)\n        self.assertEqual(hamlet.default_language, \"en\")\n        self.assertEqual(hamlet.emojiset, \"google\")\n        self.assertEqual(hamlet.high_contrast_mode, False)\n        self.assertEqual(hamlet.enable_stream_audible_notifications, False)\n        self.assertEqual(hamlet.enter_sends, False)\n        self.assertEqual(hamlet.tutorial_status, UserProfile.TUTORIAL_WAITING)\n\n    def test_signup_with_user_settings_from_another_realm(self) -> None:\n        hamlet_in_zulip = self.example_user(\"hamlet\")\n        email = hamlet_in_zulip.delivery_email\n        password = \"newpassword\"\n        subdomain = \"lear\"\n        lear_realm = get_realm(\"lear\")\n\n        self.login(\"hamlet\")\n        with get_test_image_file(\"img.png\") as image_file:\n            self.client_post(\"/json/users/me/avatar\", {\"file\": image_file})\n        hamlet_in_zulip.refresh_from_db()\n        hamlet_in_zulip.left_side_userlist = True\n        hamlet_in_zulip.default_language = \"de\"\n        hamlet_in_zulip.emojiset = \"twitter\"\n        hamlet_in_zulip.high_contrast_mode = True\n        hamlet_in_zulip.enter_sends = True\n        hamlet_in_zulip.tutorial_status = UserProfile.TUTORIAL_FINISHED\n        hamlet_in_zulip.save()\n\n        # Now we'll be making requests to another subdomain, so we need to logout\n        # to avoid polluting the session in the test environment by still being\n        # logged in.\n        self.logout()\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=subdomain)\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"], subdomain=subdomain)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, subdomain=subdomain)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"password\": password, \"key\": find_key_by_email(email), \"from_confirmation\": \"1\"},\n            subdomain=subdomain,\n        )\n        self.assert_in_success_response(\n            [\n                \"Import settings from existing Zulip account\",\n                \"selected >\\n                            Zulip Dev\",\n                \"We just need you to do one last thing.\",\n            ],\n            result,\n        )\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            source_realm_id=str(hamlet_in_zulip.realm.id),\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n\n        hamlet_in_lear = get_user(email, lear_realm)\n        self.assertEqual(hamlet_in_lear.left_side_userlist, True)\n        self.assertEqual(hamlet_in_lear.default_language, \"de\")\n        self.assertEqual(hamlet_in_lear.emojiset, \"twitter\")\n        self.assertEqual(hamlet_in_lear.high_contrast_mode, True)\n        self.assertEqual(hamlet_in_lear.enter_sends, True)\n        self.assertEqual(hamlet_in_lear.enable_stream_audible_notifications, False)\n        self.assertEqual(hamlet_in_lear.tutorial_status, UserProfile.TUTORIAL_FINISHED)\n\n        zulip_path_id = avatar_disk_path(hamlet_in_zulip)\n        lear_path_id = avatar_disk_path(hamlet_in_lear)\n        with open(zulip_path_id, \"rb\") as f:\n            zulip_avatar_bits = f.read()\n        with open(lear_path_id, \"rb\") as f:\n            lear_avatar_bits = f.read()\n\n        self.assertGreater(len(zulip_avatar_bits), 500)\n        self.assertEqual(zulip_avatar_bits, lear_avatar_bits)\n\n    def test_signup_invalid_subdomain(self) -> None:\n        \"\"\"\n        Check if attempting to authenticate to the wrong subdomain logs an\n        error and redirects.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        def invalid_subdomain(**kwargs: Any) -> Any:\n            return_data = kwargs.get(\"return_data\", {})\n            return_data[\"invalid_subdomain\"] = True\n\n        with patch(\"zerver.views.registration.authenticate\", side_effect=invalid_subdomain):\n            with self.assertLogs(level=\"ERROR\") as m:\n                result = self.client_post(\n                    \"/accounts/register/\",\n                    {\n                        \"password\": password,\n                        \"full_name\": \"New User\",\n                        \"key\": find_key_by_email(email),\n                        \"terms\": True,\n                    },\n                )\n                self.assertEqual(\n                    m.output,\n                    [\"ERROR:root:Subdomain mismatch in registration zulip: newuser@zulip.com\"],\n                )\n        self.assertEqual(result.status_code, 302)\n\n    def test_signup_using_invalid_subdomain_preserves_state_of_form(self) -> None:\n        \"\"\"\n        Check that when we give invalid subdomain and submit the registration form\n        all the values in the form are preserved.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n\n        password = \"test\"\n        email = self.example_email(\"iago\")\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            # Subdomain is already used, by construction.\n            realm_subdomain=realm.string_id,\n            realm_name=realm_name,\n            source_realm_id=str(realm.id),\n        )\n        self.assert_in_success_response(\n            [\n                \"Subdomain unavailable. Please choose a different one.\",\n                \"Zulip Dev\\n\",\n                'value=\"test\"',\n                'name=\"realm_name\"',\n            ],\n            result,\n        )\n\n    def test_replace_subdomain_in_confirmation_link(self) -> None:\n        \"\"\"\n        Check that manually changing the subdomain in a registration\n        confirmation link doesn't allow you to register to a different realm.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        self.client_post(\"/accounts/home/\", {\"email\": email})\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": \"password\",\n                \"key\": find_key_by_email(email),\n                \"terms\": True,\n                \"full_name\": \"New User\",\n                \"from_confirmation\": \"1\",\n            },\n            subdomain=\"zephyr\",\n        )\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"We couldn't find your confirmation link\", result)\n\n    def test_signup_to_realm_on_manual_license_plan(self) -> None:\n        realm = get_realm(\"zulip\")\n        denmark_stream = get_stream(\"Denmark\", realm)\n        realm.signup_notifications_stream = denmark_stream\n        realm.save(update_fields=[\"signup_notifications_stream\"])\n\n        _, ledger = self.subscribe_realm_to_monthly_plan_on_manual_license_management(realm, 5, 5)\n\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertIn(\n                \"New members cannot join this organization because all Zulip licenses\",\n                form.errors[\"email\"][0],\n            )\n            last_message = Message.objects.last()\n            assert last_message is not None\n            self.assertIn(\n                f\"A new member ({self.nonreg_email('test')}) was unable to join your organization because all Zulip\",\n                last_message.content,\n            )\n            self.assertEqual(last_message.recipient.type_id, denmark_stream.id)\n\n        ledger.licenses_at_next_renewal = 50\n        ledger.save(update_fields=[\"licenses_at_next_renewal\"])\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertIn(\n                \"New members cannot join this organization because all Zulip licenses\",\n                form.errors[\"email\"][0],\n            )\n\n        ledger.licenses = 50\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertEqual(form.errors, {})\n\n    def test_failed_signup_due_to_restricted_domain(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"invite_required\", False, acting_user=None)\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n\n        email = \"user@acme.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\n            f\"Your email address, {email}, is not in one of the domains\", form.errors[\"email\"][0]\n        )\n\n    def test_failed_signup_due_to_disposable_email(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.emails_restricted_to_domains = False\n        realm.disallow_disposable_email_addresses = True\n        realm.save()\n\n        email = \"abc@mailnator.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\"Please use your real email address\", form.errors[\"email\"][0])\n\n    def test_failed_signup_due_to_email_containing_plus(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.emails_restricted_to_domains = True\n        realm.save()\n\n        email = \"iago+label@zulip.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\n            \"Email addresses containing + are not allowed in this organization.\",\n            form.errors[\"email\"][0],\n        )\n\n    def test_failed_signup_due_to_invite_required(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save()\n        email = \"user@zulip.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(f\"Please request an invite for {email} from\", form.errors[\"email\"][0])\n\n    def test_failed_signup_due_to_nonexistent_realm(self) -> None:\n        email = \"user@acme.com\"\n        form = HomepageForm({\"email\": email}, realm=None)\n        self.assertIn(\n            f\"organization you are trying to join using {email} does not exist\",\n            form.errors[\"email\"][0],\n        )\n\n    def test_access_signup_page_in_root_domain_without_realm(self) -> None:\n        result = self.client_get(\"/register\", subdomain=\"\", follow=True)\n        self.assert_in_success_response([\"Find your Zulip accounts\"], result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_from_confirmation(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", str(message.body))\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # Full name should be set from LDAP\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            self.assert_in_success_response(\n                [\n                    \"We just need you to do one last thing.\",\n                    \"New LDAP fullname\",\n                    \"newuser@zulip.com\",\n                ],\n                result,\n            )\n\n            # Verify that the user is asked for name\n            self.assert_in_success_response([\"id_full_name\"], result)\n            # Verify that user is asked for its LDAP/Active Directory password.\n            self.assert_in_success_response(\n                [\"Enter your LDAP/Active Directory password.\", \"ldap-password\"], result\n            )\n            self.assert_not_in_success_response([\"id_password\"], result)\n\n            # Test the TypeError exception handler\n            with patch(\n                \"zproject.backends.ZulipLDAPAuthBackendBase.get_mapped_name\", side_effect=TypeError\n            ):\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", \"newuser@zulip.com\"], result\n            )\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipLDAPUserPopulator\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_populate_only_registration_from_confirmation(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", str(message.body))\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_BIND_PASSWORD=\"\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTH_LDAP_USER_DN_TEMPLATE=\"uid=%(user)s,ou=users,dc=zulip,dc=com\",\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # Full name should be set from LDAP\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            self.assert_in_success_response(\n                [\n                    \"We just need you to do one last thing.\",\n                    \"New LDAP fullname\",\n                    \"newuser@zulip.com\",\n                ],\n                result,\n            )\n\n            # Verify that the user is asked for name\n            self.assert_in_success_response([\"id_full_name\"], result)\n            # Verify that user is NOT asked for its LDAP/Active Directory password.\n            # LDAP is not configured for authentication in this test.\n            self.assert_not_in_success_response(\n                [\"Enter your LDAP/Active Directory password.\", \"ldap-password\"], result\n            )\n            # If we were using e.g. the SAML auth backend, there\n            # shouldn't be a password prompt, but since it uses the\n            # EmailAuthBackend, there should be password field here.\n            self.assert_in_success_response([\"id_password\"], result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_end_to_end(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n        full_name = \"New LDAP fullname\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            # Full name should be set from LDAP\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", full_name, \"newuser@zulip.com\"], result\n            )\n\n            # Submit the final form with the wrong password.\n            result = self.submit_reg_form_for_user(\n                email,\n                \"wrongpassword\",\n                full_name=full_name,\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            # Didn't create an account\n            with self.assertRaises(UserProfile.DoesNotExist):\n                user_profile = UserProfile.objects.get(delivery_email=email)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"/accounts/login/?email=newuser%40zulip.com\")\n\n            # Submit the final form with the correct password.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=full_name,\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_split_full_name_mapping(self) -> None:\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"first_name\": \"sn\", \"last_name\": \"cn\"}\n\n        subdomain = \"zulip\"\n        email = \"newuser_splitname@zulip.com\"\n        password = self.ldap_password(\"newuser_splitname\")\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            # Test split name mapping.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, \"First Last\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_auto_registration_on_login(self) -> None:\n        \"\"\"The most common way for LDAP authentication to be used is with a\n        server that doesn't have a terms-of-service required, in which\n        case we offer a complete single-sign-on experience (where the\n        user just enters their LDAP username and password, and their\n        account is created if it doesn't already exist).\n\n        This test verifies that flow.\n        \"\"\"\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\n            \"full_name\": \"cn\",\n            \"custom_profile_field__phone_number\": \"homePhone\",\n        }\n        full_name = \"New LDAP fullname\"\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n            # Test custom profile fields are properly synced.\n            phone_number_field = CustomProfileField.objects.get(\n                realm=user_profile.realm, name=\"Phone number\"\n            )\n            phone_number_field_value = CustomProfileFieldValue.objects.get(\n                user_profile=user_profile, field=phone_number_field\n            )\n            self.assertEqual(phone_number_field_value.value, \"a-new-number\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_auto_registration_on_login_invalid_email_in_directory(self) -> None:\n        password = self.ldap_password(\"newuser_with_email\")\n        username = \"newuser_with_email\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n\n        self.change_ldap_user_attr(\"newuser_with_email\", \"mail\", \"thisisnotavalidemail\")\n\n        with self.settings(\n            LDAP_EMAIL_ATTR=\"mail\",\n        ), self.assertLogs(\"zulip.auth.ldap\", \"WARNING\") as mock_log:\n            original_user_count = UserProfile.objects.count()\n            self.login_with_return(username, password, HTTP_HOST=subdomain + \".testserver\")\n            # Verify that the process failed as intended - no UserProfile is created.\n            self.assertEqual(UserProfile.objects.count(), original_user_count)\n            self.assertEqual(\n                mock_log.output,\n                [\"WARNING:zulip.auth.ldap:thisisnotavalidemail is not a valid email address.\"],\n            )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_registration_multiple_realms(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\n            \"full_name\": \"cn\",\n        }\n        do_create_realm(\"test\", \"test\", emails_restricted_to_domains=False)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            subdomain = \"zulip\"\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email, realm=get_realm(\"zulip\"))\n            self.logout()\n\n            # Test registration in another realm works.\n            subdomain = \"test\"\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email, realm=get_realm(\"test\"))\n            self.assertEqual(user_profile.delivery_email, email)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_when_names_changes_are_disabled(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link. This will 'authenticated_full_name'\n            # session variable which will be used to set the fullname of\n            # the user.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            with patch(\"zerver.views.registration.name_changes_disabled\", return_value=True):\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from LDAP session.\n            self.assertEqual(user_profile.full_name, \"New LDAP fullname\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_signup_with_ldap_and_email_enabled_using_email_with_ldap_append_domain(self) -> None:\n        password = \"nonldappassword\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # If the user's email is inside the LDAP directory and we just\n        # have a wrong password, then we refuse to create an account\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because password was wrong\n            self.assertEqual(result[\"Location\"], \"/accounts/login/?email=newuser%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n\n        # For the rest of the test we delete the user from ldap.\n        del self.mock_ldap.directory[\"uid=newuser,ou=users,dc=zulip,dc=com\"]\n\n        # If the user's email is not in the LDAP directory, but fits LDAP_APPEND_DOMAIN,\n        # we refuse to create the account.\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ), self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because emails matching LDAP_APPEND_DOMAIN,\n            # aren't allowed to create non-LDAP accounts.\n            self.assertEqual(result[\"Location\"], \"/accounts/login/?email=newuser%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: newuser. Input username: newuser@zulip.com\"\n                ],\n            )\n\n        # If the email is outside of LDAP_APPEND_DOMAIN, we successfully create a non-LDAP account,\n        # with the password managed in the Zulip database.\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"example.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(level=\"WARNING\") as m:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(result.status_code, 200)\n            self.assertEqual(\n                m.output,\n                [\"WARNING:root:New account email newuser@zulip.com could not be found in LDAP\"],\n            )\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    full_name=\"Non-LDAP Full Name\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: Email newuser@zulip.com does not match LDAP domain example.com.\"\n                ],\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver/\")\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from the POST request, not LDAP\n            self.assertEqual(user_profile.full_name, \"Non-LDAP Full Name\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_signup_with_ldap_and_email_enabled_using_email_with_ldap_email_search(self) -> None:\n        # If the user's email is inside the LDAP directory and we just\n        # have a wrong password, then we refuse to create an account\n        password = \"nonldappassword\"\n        email = \"newuser_email@zulip.com\"  # belongs to user uid=newuser_with_email in the test directory\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because password was wrong\n            self.assertEqual(result[\"Location\"], \"/accounts/login/?email=newuser_email%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n\n        # If the user's email is not in the LDAP directory , though, we\n        # successfully create an account with a password in the Zulip\n        # database.\n        password = \"nonldappassword\"\n        email = \"nonexistent@zulip.com\"\n        subdomain = \"zulip\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(level=\"WARNING\") as m:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n                self.assertEqual(result.status_code, 200)\n                self.assertEqual(\n                    m.output,\n                    [\n                        \"WARNING:root:New account email nonexistent@zulip.com could not be found in LDAP\"\n                    ],\n                )\n\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    full_name=\"Non-LDAP Full Name\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: nonexistent@zulip.com. Input username: nonexistent@zulip.com\"\n                ],\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver/\")\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from the POST request, not LDAP\n            self.assertEqual(user_profile.full_name, \"Non-LDAP Full Name\")\n\n    def ldap_invite_and_signup_as(\n        self, invite_as: int, streams: Sequence[str] = [\"Denmark\"]\n    ) -> None:\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        subdomain = \"zulip\"\n        email = \"newuser@zulip.com\"\n        password = self.ldap_password(\"newuser\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                # Invite user.\n                self.login(\"iago\")\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: iago. Input username: iago@zulip.com\"\n                ],\n            )\n            response = self.invite(\n                invitee_emails=\"newuser@zulip.com\", stream_names=streams, invite_as=invite_as\n            )\n            self.assert_json_success(response)\n            self.logout()\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_user_as_admin(self) -> None:\n        self.ldap_invite_and_signup_as(PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"])\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_realm_admin)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_user_as_guest(self) -> None:\n        self.ldap_invite_and_signup_as(PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_guest)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_streams(self) -> None:\n        stream_name = \"Rome\"\n        realm = get_realm(\"zulip\")\n        stream = get_stream(stream_name, realm)\n        default_streams = get_default_streams_for_realm(realm.id)\n        default_streams_name = [stream.name for stream in default_streams]\n        self.assertNotIn(stream_name, default_streams_name)\n\n        # Invite user.\n        self.ldap_invite_and_signup_as(\n            PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"], streams=[stream_name]\n        )\n\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_realm_admin)\n        sub = get_stream_subscriptions_for_user(user_profile).filter(recipient__type_id=stream.id)\n        self.assert_length(sub, 1)\n\n    def test_registration_when_name_changes_are_disabled(self) -> None:\n        \"\"\"\n        Test `name_changes_disabled` when we are not running under LDAP.\n        \"\"\"\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with patch(\"zerver.views.registration.name_changes_disabled\", return_value=True):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"New Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # 'New Name' comes from POST data; not from LDAP session.\n            self.assertEqual(user_profile.full_name, \"New Name\")\n\n    def test_realm_creation_through_ldap(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm_name = \"Zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", str(message.body))\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n            TERMS_OF_SERVICE_VERSION=1.0,\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            key = find_key_by_email(email)\n            confirmation = Confirmation.objects.get(confirmation_key=key)\n            prereg_user = confirmation.content_object\n            assert prereg_user is not None\n            prereg_user.realm_creation = True\n            prereg_user.save()\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                realm_name=realm_name,\n                realm_subdomain=subdomain,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", \"newuser@zulip.com\"], result\n            )\n\n    @patch(\n        \"DNS.dnslookup\",\n        return_value=[[\"sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh\"]],\n    )\n    def test_registration_of_mirror_dummy_user(self, ignored: Any) -> None:\n        password = \"test\"\n        subdomain = \"zephyr\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.delivery_email\n        user_profile.is_mirror_dummy = True\n        user_profile.save()\n        change_user_is_active(user_profile, False)\n\n        result = self.client_post(\"/register/\", {\"email\": email}, subdomain=\"zephyr\")\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"], subdomain=\"zephyr\")\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", str(message.body))\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        result = self.client_get(confirmation_url, subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 200)\n\n        # If the mirror dummy user is already active, attempting to\n        # submit the registration form should raise an AssertionError\n        # (this is an invalid state, so it's a bug we got here):\n        change_user_is_active(user_profile, True)\n\n        with self.assertRaisesRegex(\n            AssertionError, \"Mirror dummy user is already active!\"\n        ), self.assertLogs(\"django.request\", \"ERROR\") as error_log:\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n        self.assertTrue(\n            \"ERROR:django.request:Internal Server Error: /accounts/register/\" in error_log.output[0]\n        )\n        self.assertTrue(\n            'raise AssertionError(\"Mirror dummy user is already active!' in error_log.output[0]\n        )\n        self.assertTrue(\n            \"AssertionError: Mirror dummy user is already active!\" in error_log.output[0]\n        )\n\n        change_user_is_active(user_profile, False)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            from_confirmation=\"1\",\n            # Pass HTTP_HOST for the target subdomain\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            # Pass HTTP_HOST for the target subdomain\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @patch(\n        \"DNS.dnslookup\",\n        return_value=[[\"sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh\"]],\n    )\n    def test_registration_of_active_mirror_dummy_user(self, ignored: Any) -> None:\n        \"\"\"\n        Trying to activate an already-active mirror dummy user should\n        raise an AssertionError.\n        \"\"\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.delivery_email\n        user_profile.is_mirror_dummy = True\n        user_profile.save()\n        change_user_is_active(user_profile, True)\n\n        with self.assertRaisesRegex(\n            AssertionError, \"Mirror dummy user is already active!\"\n        ), self.assertLogs(\"django.request\", \"ERROR\") as error_log:\n            self.client_post(\"/register/\", {\"email\": email}, subdomain=\"zephyr\")\n        self.assertTrue(\n            \"ERROR:django.request:Internal Server Error: /register/\" in error_log.output[0]\n        )\n        self.assertTrue(\n            'raise AssertionError(\"Mirror dummy user is already active!' in error_log.output[0]\n        )\n        self.assertTrue(\n            \"AssertionError: Mirror dummy user is already active!\" in error_log.output[0]\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_dev_user_registration(self) -> None:\n        \"\"\"Verify that /devtools/register_user creates a new user, logs them\n        in, and redirects to the logged-in app.\"\"\"\n        count = UserProfile.objects.count()\n        email = f\"user-{count}@zulip.com\"\n\n        result = self.client_post(\"/devtools/register_user/\")\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(user_profile.delivery_email, email)\n        self.assertEqual(result[\"Location\"], \"http://zulip.testserver/\")\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_dev_user_registration_create_realm(self) -> None:\n        count = UserProfile.objects.count()\n        string_id = f\"realm-{count}\"\n\n        result = self.client_post(\"/devtools/register_realm/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(f\"http://{string_id}.testserver/accounts/login/subdomain\")\n        )\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"http://{string_id}.testserver\")\n\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_dev_user_registration_create_demo_realm(self) -> None:\n        result = self.client_post(\"/devtools/register_demo_realm/\")\n        self.assertEqual(result.status_code, 302)\n\n        realm = Realm.objects.latest(\"date_created\")\n        self.assertTrue(\n            result[\"Location\"].startswith(\n                f\"http://{realm.string_id}.testserver/accounts/login/subdomain\"\n            )\n        )\n        result = self.client_get(result[\"Location\"], subdomain=realm.string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"http://{realm.string_id}.testserver\")\n\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n        self.assert_logged_in_user_id(user_profile.id)\n\n        expected_deletion_date = realm.date_created + datetime.timedelta(\n            days=settings.DEMO_ORG_DEADLINE_DAYS\n        )\n        self.assertEqual(realm.demo_organization_scheduled_deletion_date, expected_deletion_date)\n\n    def test_get_default_language_for_new_user(self) -> None:\n        realm = get_realm(\"zulip\")\n        req = HostRequestMock()\n        req.META[\"HTTP_ACCEPT_LANGUAGE\"] = \"de,en\"\n        self.assertEqual(get_default_language_for_new_user(req, realm), \"de\")\n\n        do_set_realm_property(realm, \"default_language\", \"hi\", acting_user=None)\n        realm.refresh_from_db()\n        req = HostRequestMock()\n        req.META[\"HTTP_ACCEPT_LANGUAGE\"] = \"de,en\"\n        self.assertEqual(get_default_language_for_new_user(req, realm), \"de\")\n\n        req = HostRequestMock()\n        req.META[\"HTTP_ACCEPT_LANGUAGE\"] = \"\"\n        self.assertEqual(get_default_language_for_new_user(req, realm), \"hi\")\n\n\nclass DeactivateUserTest(ZulipTestCase):\n    def test_deactivate_user(self) -> None:\n        user = self.example_user(\"hamlet\")\n        email = user.email\n        self.login_user(user)\n        self.assertTrue(user.is_active)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_success(result)\n        user = self.example_user(\"hamlet\")\n        self.assertFalse(user.is_active)\n        password = initial_password(email)\n        assert password is not None\n        self.assert_login_failure(email, password=password)\n\n    def test_do_not_deactivate_final_owner(self) -> None:\n        user = self.example_user(\"desdemona\")\n        user_2 = self.example_user(\"iago\")\n        self.login_user(user)\n        self.assertTrue(user.is_active)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_error(result, \"Cannot deactivate the only organization owner.\")\n        user = self.example_user(\"desdemona\")\n        self.assertTrue(user.is_active)\n        self.assertTrue(user.is_realm_owner)\n        do_change_user_role(user_2, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n        self.assertTrue(user_2.is_realm_owner)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_success(result)\n        do_change_user_role(user, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n\n    def test_do_not_deactivate_final_user(self) -> None:\n        realm = get_realm(\"zulip\")\n        for user_profile in UserProfile.objects.filter(realm=realm).exclude(\n            role=UserProfile.ROLE_REALM_OWNER\n        ):\n            do_deactivate_user(user_profile, acting_user=None)\n        user = self.example_user(\"desdemona\")\n        self.login_user(user)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_error(result, \"Cannot deactivate the only user.\")\n\n\nclass TestLoginPage(ZulipTestCase):\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_redirects_for_root_alias(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"/accounts/go/?next=%2Fupgrade%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_redirects_for_root_domain(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"/accounts/go/?next=%2Fupgrade%2F\")\n\n        mock_get_host.return_value = \"www.zulip.example.com\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n            EXTERNAL_HOST=\"www.zulip.example.com\",\n            ROOT_SUBDOMAIN_ALIASES=[\"test\"],\n        ):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"/accounts/go/?next=%2Fupgrade%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_works_without_subdomains(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"www\"]):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"www\"]):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n    def test_login_page_registration_hint(self) -> None:\n        response = self.client_get(\"/login/\")\n        self.assert_not_in_success_response(\n            [\"Don't have an account yet? You need to be invited to join this organization.\"],\n            response,\n        )\n\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save(update_fields=[\"invite_required\"])\n        response = self.client_get(\"/login/\")\n        self.assert_in_success_response(\n            [\"Don't have an account yet? You need to be invited to join this organization.\"],\n            response,\n        )\n\n    @patch(\"django.http.HttpRequest.get_host\", return_value=\"auth.testserver\")\n    def test_social_auth_subdomain_login_page(self, mock_get_host: MagicMock) -> None:\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Authentication subdomain\", result)\n\n        zulip_realm = get_realm(\"zulip\")\n        session = self.client.session\n        session[\"subdomain\"] = \"zulip\"\n        session.save()\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], zulip_realm.uri)\n\n        session = self.client.session\n        session[\"subdomain\"] = \"invalid\"\n        session.save()\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Authentication subdomain\", result)\n\n    def test_login_page_is_deactivated_validation(self) -> None:\n        with patch(\"zerver.views.auth.logging.info\") as mock_info:\n            result = self.client_get(\"/login/?is_deactivated=invalid_email\")\n            mock_info.assert_called_once()\n            self.assert_not_in_success_response([\"invalid_email\"], result)\n\n\nclass TestFindMyTeam(ZulipTestCase):\n    def test_template(self) -> None:\n        result = self.client_get(\"/accounts/find/\")\n        self.assertIn(\"Find your Zulip accounts\", result.content.decode())\n\n    def test_result(self) -> None:\n        # We capitalize a letter in cordelia's email to test that the search is case-insensitive.\n        result = self.client_post(\n            \"/accounts/find/\", dict(emails=\"iago@zulip.com,cordeliA@zulip.com\")\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\n            result[\"Location\"], \"/accounts/find/?emails=iago%40zulip.com%2CcordeliA%40zulip.com\"\n        )\n        result = self.client_get(result[\"Location\"])\n        content = result.content.decode()\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(\"iago@zulip.com\", content)\n        self.assertIn(\"cordeliA@zulip.com\", content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 2)\n        iago_message = outbox[1]\n        cordelia_message = outbox[0]\n        self.assertIn(\"Zulip Dev\", iago_message.body)\n        self.assertNotIn(\"Lear & Co\", iago_message.body)\n        self.assertIn(\"Zulip Dev\", cordelia_message.body)\n        self.assertIn(\"Lear & Co\", cordelia_message.body)\n\n    def test_find_team_ignore_invalid_email(self) -> None:\n        result = self.client_post(\n            \"/accounts/find/\", dict(emails=\"iago@zulip.com,invalid_email@zulip.com\")\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\n            result[\"Location\"],\n            \"/accounts/find/?emails=iago%40zulip.com%2Cinvalid_email%40zulip.com\",\n        )\n        result = self.client_get(result[\"Location\"])\n        content = result.content.decode()\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(self.example_email(\"iago\"), content)\n        self.assertIn(\"invalid_email@\", content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 1)\n\n    def test_find_team_reject_invalid_email(self) -> None:\n        result = self.client_post(\"/accounts/find/\", dict(emails=\"invalid_string\"))\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(b\"Enter a valid email\", result.content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n        # Just for coverage on perhaps-unnecessary validation code.\n        result = self.client_get(\"/accounts/find/\", {\"emails\": \"invalid\"})\n        self.assertEqual(result.status_code, 200)\n\n    def test_find_team_zero_emails(self) -> None:\n        data = {\"emails\": \"\"}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertIn(\"This field is required\", result.content.decode())\n        self.assertEqual(result.status_code, 200)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_one_email(self) -> None:\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 1)\n\n    def test_find_team_deactivated_user(self) -> None:\n        do_deactivate_user(self.example_user(\"hamlet\"), acting_user=None)\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_deactivated_realm(self) -> None:\n        do_deactivate_realm(get_realm(\"zulip\"), acting_user=None)\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_bot_email(self) -> None:\n        data = {\"emails\": self.example_email(\"webhook_bot\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/accounts/find/?emails=webhook-bot%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_more_than_ten_emails(self) -> None:\n        data = {\"emails\": \",\".join(f\"hamlet-{i}@zulip.com\" for i in range(11))}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(\"Please enter at most 10\", result.content.decode())\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n\nclass ConfirmationKeyTest(ZulipTestCase):\n    def test_confirmation_key(self) -> None:\n        request = MagicMock()\n        request.session = {\n            \"confirmation_key\": {\"confirmation_key\": \"xyzzy\"},\n        }\n        result = confirmation_key(request)\n        self.assert_json_success(result)\n        self.assert_in_response(\"xyzzy\", result)\n\n\nclass MobileAuthOTPTest(ZulipTestCase):\n    def test_xor_hex_strings(self) -> None:\n        self.assertEqual(xor_hex_strings(\"1237c81ab\", \"18989fd12\"), \"0aaf57cb9\")\n        with self.assertRaises(AssertionError):\n            xor_hex_strings(\"1\", \"31\")\n\n    def test_is_valid_otp(self) -> None:\n        self.assertEqual(is_valid_otp(\"1234\"), False)\n        self.assertEqual(is_valid_otp(\"1234abcd\" * 8), True)\n        self.assertEqual(is_valid_otp(\"1234abcZ\" * 8), False)\n\n    def test_ascii_to_hex(self) -> None:\n        self.assertEqual(ascii_to_hex(\"ZcdR1234\"), \"5a63645231323334\")\n        self.assertEqual(hex_to_ascii(\"5a63645231323334\"), \"ZcdR1234\")\n\n    def test_otp_encrypt_api_key(self) -> None:\n        api_key = \"12ac\" * 8\n        otp = \"7be38894\" * 8\n        result = otp_encrypt_api_key(api_key, otp)\n        self.assertEqual(result, \"4ad1e9f7\" * 8)\n\n        decrypted = otp_decrypt_api_key(result, otp)\n        self.assertEqual(decrypted, api_key)\n\n\nclass FollowupEmailTest(ZulipTestCase):\n    def test_followup_day2_email(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        # Test date_joined == Sunday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 7, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=2, hours=-1)\n        )\n        # Test date_joined == Tuesday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 2, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=2, hours=-1)\n        )\n        # Test date_joined == Thursday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 4, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=1, hours=-1)\n        )\n        # Test date_joined == Friday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 5, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=3, hours=-1)\n        )\n\n        # Time offset of America/Phoenix is -07:00\n        user_profile.timezone = \"America/Phoenix\"\n        # Test date_joined == Friday in UTC, but Thursday in the user's time zone\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 5, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=1, hours=-1)\n        )\n\n\nclass NoReplyEmailTest(ZulipTestCase):\n    def test_noreply_email_address(self) -> None:\n        self.assertTrue(\n            re.search(self.TOKENIZED_NOREPLY_REGEX, FromAddress.tokenized_no_reply_address())\n        )\n\n        with self.settings(ADD_TOKENS_TO_NOREPLY_ADDRESS=False):\n            self.assertEqual(FromAddress.tokenized_no_reply_address(), \"noreply@testserver\")\n\n\nclass TwoFactorAuthTest(ZulipTestCase):\n    @patch(\"two_factor.plugins.phonenumber.models.totp\")\n    def test_two_factor_login(self, mock_totp: MagicMock) -> None:\n        token = 123456\n        email = self.example_email(\"hamlet\")\n        password = self.ldap_password(\"hamlet\")\n\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.set_password(password)\n        user_profile.save()\n        self.create_default_device(user_profile)\n\n        def totp(*args: Any, **kwargs: Any) -> int:\n            return token\n\n        mock_totp.side_effect = totp\n\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.EmailAuthBackend\",),\n            TWO_FACTOR_CALL_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_SMS_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_AUTHENTICATION_ENABLED=True,\n        ):\n            first_step_data = {\n                \"username\": email,\n                \"password\": password,\n                \"two_factor_login_view-current_step\": \"auth\",\n            }\n            with self.assertLogs(\"two_factor.gateways.fake\", \"INFO\") as info_logs:\n                result = self.client_post(\"/accounts/login/\", first_step_data)\n            self.assertEqual(\n                info_logs.output,\n                ['INFO:two_factor.gateways.fake:Fake SMS to +12125550100: \"Your token is: 123456\"'],\n            )\n            self.assertEqual(result.status_code, 200)\n\n            second_step_data = {\n                \"token-otp_token\": str(token),\n                \"two_factor_login_view-current_step\": \"token\",\n            }\n            result = self.client_post(\"/accounts/login/\", second_step_data)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n            # Going to login page should redirect to '/' if user is already\n            # logged in.\n            result = self.client_get(\"/accounts/login/\")\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n\nclass NameRestrictionsTest(ZulipTestCase):\n    def test_whitelisted_disposable_domains(self) -> None:\n        self.assertFalse(is_disposable_domain(\"OPayQ.com\"))\n\n\nclass RealmRedirectTest(ZulipTestCase):\n    def test_realm_redirect_without_next_param(self) -> None:\n        result = self.client_get(\"/accounts/go/\")\n        self.assert_in_success_response([\"Enter your organization's Zulip URL\"], result)\n\n        result = self.client_post(\"/accounts/go/\", {\"subdomain\": \"zephyr\"})\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://zephyr.testserver\")\n\n        result = self.client_post(\"/accounts/go/\", {\"subdomain\": \"invalid\"})\n        self.assert_in_success_response([\"We couldn&#39;t find that Zulip organization.\"], result)\n\n    def test_realm_redirect_with_next_param(self) -> None:\n        result = self.client_get(\"/accounts/go/\", {\"next\": \"billing\"})\n        self.assert_in_success_response(\n            [\"Enter your organization's Zulip URL\", 'action=\"/accounts/go/?next=billing\"'], result\n        )\n\n        result = self.client_post(\"/accounts/go/?next=billing\", {\"subdomain\": \"lear\"})\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://lear.testserver/billing\")\n", "import logging\nimport urllib\nfrom typing import Any, Dict, Iterable, List, Optional\nfrom urllib.parse import urlencode\n\nfrom django.conf import settings\nfrom django.contrib.auth import authenticate, get_backends\nfrom django.contrib.sessions.backends.base import SessionBase\nfrom django.core import validators\nfrom django.core.exceptions import ValidationError\nfrom django.db.models import Q\nfrom django.http import HttpRequest, HttpResponse, HttpResponseRedirect\nfrom django.shortcuts import redirect, render\nfrom django.urls import reverse\nfrom django.utils.translation import get_language\nfrom django_auth_ldap.backend import LDAPBackend, _LDAPUser\n\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyError,\n    RealmCreationKey,\n    create_confirmation_link,\n    get_object_from_key,\n    render_confirmation_key_error,\n    validate_key,\n)\nfrom zerver.actions.create_realm import do_create_realm\nfrom zerver.actions.create_user import do_activate_mirror_dummy_user, do_create_user\nfrom zerver.actions.default_streams import lookup_default_stream_groups\nfrom zerver.actions.user_settings import (\n    do_change_full_name,\n    do_change_password,\n    do_change_user_setting,\n)\nfrom zerver.context_processors import get_realm_from_request, login_context\nfrom zerver.decorator import do_login, require_post\nfrom zerver.forms import (\n    FindMyTeamForm,\n    HomepageForm,\n    RealmCreationForm,\n    RealmRedirectForm,\n    RegistrationForm,\n)\nfrom zerver.lib.email_validation import email_allowed_for_realm, validate_email_not_already_in_realm\nfrom zerver.lib.exceptions import RateLimitedError\nfrom zerver.lib.i18n import get_default_language_for_new_user\nfrom zerver.lib.pysa import mark_sanitized\nfrom zerver.lib.rate_limiter import rate_limit_request_by_ip\nfrom zerver.lib.request import REQ, has_request_variables\nfrom zerver.lib.send_email import EmailNotDeliveredError, FromAddress, send_email\nfrom zerver.lib.sessions import get_expirable_session_var\nfrom zerver.lib.subdomains import get_subdomain, is_root_domain_available\nfrom zerver.lib.url_encoding import append_url_query_string\nfrom zerver.lib.users import get_accounts_for_email\nfrom zerver.lib.validator import to_converted_or_fallback, to_non_negative_int, to_timezone_or_empty\nfrom zerver.lib.zephyr import compute_mit_user_fullname\nfrom zerver.models import (\n    DisposableEmailError,\n    DomainNotAllowedForRealmError,\n    EmailContainsPlusError,\n    MultiuseInvite,\n    PreregistrationUser,\n    Realm,\n    Stream,\n    UserProfile,\n    get_default_stream_groups,\n    get_realm,\n    get_source_profile,\n    get_user_by_delivery_email,\n    name_changes_disabled,\n)\nfrom zerver.views.auth import (\n    create_preregistration_user,\n    finish_desktop_flow,\n    finish_mobile_flow,\n    get_safe_redirect_to,\n    redirect_and_log_into_subdomain,\n    redirect_to_deactivation_notice,\n)\nfrom zproject.backends import (\n    ExternalAuthResult,\n    NoMatchingLDAPUserError,\n    ZulipLDAPAuthBackend,\n    email_auth_enabled,\n    email_belongs_to_ldap,\n    get_external_method_dicts,\n    ldap_auth_enabled,\n    password_auth_enabled,\n)\n\nif settings.BILLING_ENABLED:\n    from corporate.lib.registration import check_spare_licenses_available_for_registering_new_user\n    from corporate.lib.stripe import LicenseLimitError\n\n\n@has_request_variables\ndef get_prereg_key_and_redirect(\n    request: HttpRequest, confirmation_key: str, full_name: Optional[str] = REQ(default=None)\n) -> HttpResponse:\n    \"\"\"\n    The purpose of this little endpoint is primarily to take a GET\n    request to a long URL containing a confirmation key, and render\n    a page that will via JavaScript immediately do a POST request to\n    /accounts/register, so that the user can create their account on\n    a page with a cleaner URL (and with the browser security and UX\n    benefits of an HTTP POST having generated the page).\n\n    The only thing it does before rendering that page is to check\n    the validity of the confirmation link. This is redundant with a\n    similar check in accounts_register, but it provides a slightly nicer\n    user-facing error handling experience if the URL you visited is\n    displayed in the browser. (E.g. you can debug that you\n    accidentally adding an extra character after pasting).\n    \"\"\"\n    try:\n        check_prereg_key(request, confirmation_key)\n    except ConfirmationKeyError as e:\n        return render_confirmation_key_error(request, e)\n\n    return render(\n        request,\n        \"confirmation/confirm_preregistrationuser.html\",\n        context={\"key\": confirmation_key, \"full_name\": full_name},\n    )\n\n\ndef check_prereg_key(request: HttpRequest, confirmation_key: str) -> PreregistrationUser:\n    \"\"\"\n    Checks if the Confirmation key is valid, returning the PreregistrationUser object in case of success\n    and raising an appropriate ConfirmationKeyError otherwise.\n    \"\"\"\n    confirmation_types = [\n        Confirmation.USER_REGISTRATION,\n        Confirmation.INVITATION,\n        Confirmation.REALM_CREATION,\n    ]\n\n    prereg_user = get_object_from_key(confirmation_key, confirmation_types, mark_object_used=False)\n    assert isinstance(prereg_user, PreregistrationUser)\n\n    # Defensive assert to make sure no mix-up in how .status is set leading to re-use\n    # of a PreregistrationUser object.\n    assert prereg_user.created_user is None\n\n    return prereg_user\n\n\n@require_post\n@has_request_variables\ndef accounts_register(\n    request: HttpRequest,\n    key: str = REQ(default=\"\"),\n    timezone: str = REQ(default=\"\", converter=to_timezone_or_empty),\n    from_confirmation: Optional[str] = REQ(default=None),\n    form_full_name: Optional[str] = REQ(\"full_name\", default=None),\n    source_realm_id: Optional[int] = REQ(\n        default=None, converter=to_converted_or_fallback(to_non_negative_int, None)\n    ),\n) -> HttpResponse:\n    try:\n        prereg_user = check_prereg_key(request, key)\n    except ConfirmationKeyError as e:\n        return render_confirmation_key_error(request, e)\n\n    email = prereg_user.email\n    realm_creation = prereg_user.realm_creation\n    password_required = prereg_user.password_required\n\n    role = prereg_user.invited_as\n    if realm_creation:\n        role = UserProfile.ROLE_REALM_OWNER\n\n    try:\n        validators.validate_email(email)\n    except ValidationError:\n        return render(request, \"zerver/invalid_email.html\", context={\"invalid_email\": True})\n\n    if realm_creation:\n        # For creating a new realm, there is no existing realm or domain\n        realm = None\n    else:\n        assert prereg_user.realm is not None\n        if get_subdomain(request) != prereg_user.realm.string_id:\n            return render_confirmation_key_error(\n                request, ConfirmationKeyError(ConfirmationKeyError.DOES_NOT_EXIST)\n            )\n        realm = prereg_user.realm\n        try:\n            email_allowed_for_realm(email, realm)\n        except DomainNotAllowedForRealmError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"closed_domain\": True},\n            )\n        except DisposableEmailError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"disposable_emails_not_allowed\": True},\n            )\n        except EmailContainsPlusError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"email_contains_plus\": True},\n            )\n\n        if realm.deactivated:\n            # The user is trying to register for a deactivated realm. Advise them to\n            # contact support.\n            return redirect_to_deactivation_notice()\n\n        try:\n            validate_email_not_already_in_realm(realm, email)\n        except ValidationError:\n            return redirect_to_email_login_url(email)\n\n        if settings.BILLING_ENABLED:\n            try:\n                check_spare_licenses_available_for_registering_new_user(realm, email, role=role)\n            except LicenseLimitError:\n                return render(request, \"zerver/no_spare_licenses.html\")\n\n    name_validated = False\n    require_ldap_password = False\n\n    if from_confirmation:\n        try:\n            del request.session[\"authenticated_full_name\"]\n        except KeyError:\n            pass\n\n        ldap_full_name = None\n        if settings.POPULATE_PROFILE_VIA_LDAP:\n            # If the user can be found in LDAP, we'll take the full name from the directory,\n            # and further down create a form pre-filled with it.\n            for backend in get_backends():\n                if isinstance(backend, LDAPBackend):\n                    try:\n                        ldap_username = backend.django_to_ldap_username(email)\n                    except NoMatchingLDAPUserError:\n                        logging.warning(\"New account email %s could not be found in LDAP\", email)\n                        break\n\n                    # Note that this `ldap_user` object is not a\n                    # `ZulipLDAPUser` with a `Realm` attached, so\n                    # calling `.populate_user()` on it will crash.\n                    # This is OK, since we're just accessing this user\n                    # to extract its name.\n                    #\n                    # TODO: We should potentially be accessing this\n                    # user to sync its initial avatar and custom\n                    # profile fields as well, if we indeed end up\n                    # creating a user account through this flow,\n                    # rather than waiting until `manage.py\n                    # sync_ldap_user_data` runs to populate it.\n                    ldap_user = _LDAPUser(backend, ldap_username)\n\n                    try:\n                        ldap_full_name = backend.get_mapped_name(ldap_user)\n                    except TypeError:\n                        break\n\n                    # Check whether this is ZulipLDAPAuthBackend,\n                    # which is responsible for authentication and\n                    # requires that LDAP accounts enter their LDAP\n                    # password to register, or ZulipLDAPUserPopulator,\n                    # which just populates UserProfile fields (no auth).\n                    require_ldap_password = isinstance(backend, ZulipLDAPAuthBackend)\n                    break\n\n        if ldap_full_name:\n            # We don't use initial= here, because if the form is\n            # complete (that is, no additional fields need to be\n            # filled out by the user) we want the form to validate,\n            # so they can be directly registered without having to\n            # go through this interstitial.\n            form = RegistrationForm({\"full_name\": ldap_full_name}, realm_creation=realm_creation)\n            request.session[\"authenticated_full_name\"] = ldap_full_name\n            name_validated = True\n        elif realm is not None and realm.is_zephyr_mirror_realm:\n            # For MIT users, we can get an authoritative name from Hesiod.\n            # Technically we should check that this is actually an MIT\n            # realm, but we can cross that bridge if we ever get a non-MIT\n            # zephyr mirroring realm.\n            hesiod_name = compute_mit_user_fullname(email)\n            form = RegistrationForm(\n                initial={\"full_name\": hesiod_name if \"@\" not in hesiod_name else \"\"},\n                realm_creation=realm_creation,\n            )\n            name_validated = True\n        elif prereg_user.full_name:\n            if prereg_user.full_name_validated:\n                request.session[\"authenticated_full_name\"] = prereg_user.full_name\n                name_validated = True\n                form = RegistrationForm(\n                    {\"full_name\": prereg_user.full_name}, realm_creation=realm_creation\n                )\n            else:\n                form = RegistrationForm(\n                    initial={\"full_name\": prereg_user.full_name}, realm_creation=realm_creation\n                )\n        elif form_full_name is not None:\n            form = RegistrationForm(\n                initial={\"full_name\": form_full_name},\n                realm_creation=realm_creation,\n            )\n        else:\n            form = RegistrationForm(realm_creation=realm_creation)\n    else:\n        postdata = request.POST.copy()\n        if name_changes_disabled(realm):\n            # If we populate profile information via LDAP and we have a\n            # verified name from you on file, use that. Otherwise, fall\n            # back to the full name in the request.\n            try:\n                postdata.update(full_name=request.session[\"authenticated_full_name\"])\n                name_validated = True\n            except KeyError:\n                pass\n        form = RegistrationForm(postdata, realm_creation=realm_creation)\n\n    if not (password_auth_enabled(realm) and password_required):\n        form[\"password\"].field.required = False\n\n    if form.is_valid():\n        if password_auth_enabled(realm) and form[\"password\"].field.required:\n            password = form.cleaned_data[\"password\"]\n        else:\n            # If the user wasn't prompted for a password when\n            # completing the authentication form (because they're\n            # signing up with SSO and no password is required), set\n            # the password field to `None` (Which causes Django to\n            # create an unusable password).\n            password = None\n\n        if realm_creation:\n            string_id = form.cleaned_data[\"realm_subdomain\"]\n            realm_name = form.cleaned_data[\"realm_name\"]\n            realm_type = form.cleaned_data[\"realm_type\"]\n            is_demo_org = form.cleaned_data[\"is_demo_organization\"]\n            realm = do_create_realm(\n                string_id, realm_name, org_type=realm_type, is_demo_organization=is_demo_org\n            )\n        assert realm is not None\n\n        full_name = form.cleaned_data[\"full_name\"]\n        enable_marketing_emails = form.cleaned_data[\"enable_marketing_emails\"]\n        default_stream_group_names = request.POST.getlist(\"default_stream_group\")\n        default_stream_groups = lookup_default_stream_groups(default_stream_group_names, realm)\n\n        if source_realm_id is not None:\n            # Non-integer realm_id values like \"string\" are treated\n            # like the \"Do not import\" value of \"\".\n            source_profile: Optional[UserProfile] = get_source_profile(email, source_realm_id)\n        else:\n            source_profile = None\n\n        if not realm_creation:\n            try:\n                existing_user_profile: Optional[UserProfile] = get_user_by_delivery_email(\n                    email, realm\n                )\n            except UserProfile.DoesNotExist:\n                existing_user_profile = None\n        else:\n            existing_user_profile = None\n\n        user_profile: Optional[UserProfile] = None\n        return_data: Dict[str, bool] = {}\n        if ldap_auth_enabled(realm):\n            # If the user was authenticated using an external SSO\n            # mechanism like Google or GitHub auth, then authentication\n            # will have already been done before creating the\n            # PreregistrationUser object with password_required=False, and\n            # so we don't need to worry about passwords.\n            #\n            # If instead the realm is using EmailAuthBackend, we will\n            # set their password above.\n            #\n            # But if the realm is using LDAPAuthBackend, we need to verify\n            # their LDAP password (which will, as a side effect, create\n            # the user account) here using authenticate.\n            # prereg_user.realm_creation carries the information about whether\n            # we're in realm creation mode, and the ldap flow will handle\n            # that and create the user with the appropriate parameters.\n            user = authenticate(\n                request=request,\n                username=email,\n                password=password,\n                realm=realm,\n                prereg_user=prereg_user,\n                return_data=return_data,\n            )\n            if user is None:\n                can_use_different_backend = email_auth_enabled(realm) or (\n                    len(get_external_method_dicts(realm)) > 0\n                )\n                if settings.LDAP_APPEND_DOMAIN:\n                    # In LDAP_APPEND_DOMAIN configurations, we don't allow making a non-LDAP account\n                    # if the email matches the ldap domain.\n                    can_use_different_backend = can_use_different_backend and (\n                        not email_belongs_to_ldap(realm, email)\n                    )\n                if return_data.get(\"no_matching_ldap_user\") and can_use_different_backend:\n                    # If both the LDAP and Email or Social auth backends are\n                    # enabled, and there's no matching user in the LDAP\n                    # directory then the intent is to create a user in the\n                    # realm with their email outside the LDAP organization\n                    # (with e.g. a password stored in the Zulip database,\n                    # not LDAP).  So we fall through and create the new\n                    # account.\n                    pass\n                else:\n                    # TODO: This probably isn't going to give a\n                    # user-friendly error message, but it doesn't\n                    # particularly matter, because the registration form\n                    # is hidden for most users.\n                    view_url = reverse(\"login\")\n                    query = urlencode({\"email\": email})\n                    redirect_url = append_url_query_string(view_url, query)\n                    return HttpResponseRedirect(redirect_url)\n            else:\n                assert isinstance(user, UserProfile)\n                user_profile = user\n                if not realm_creation:\n                    # Since we'll have created a user, we now just log them in.\n                    return login_and_go_to_home(request, user_profile)\n                # With realm_creation=True, we're going to return further down,\n                # after finishing up the creation process.\n\n        if existing_user_profile is not None and existing_user_profile.is_mirror_dummy:\n            user_profile = existing_user_profile\n            do_activate_mirror_dummy_user(user_profile, acting_user=user_profile)\n            do_change_password(user_profile, password)\n            do_change_full_name(user_profile, full_name, user_profile)\n            do_change_user_setting(user_profile, \"timezone\", timezone, acting_user=user_profile)\n            do_change_user_setting(\n                user_profile,\n                \"default_language\",\n                get_default_language_for_new_user(request, realm),\n                acting_user=None,\n            )\n            # TODO: When we clean up the `do_activate_mirror_dummy_user` code path,\n            # make it respect invited_as_admin / is_realm_admin.\n\n        if user_profile is None:\n            user_profile = do_create_user(\n                email,\n                password,\n                realm,\n                full_name,\n                prereg_user=prereg_user,\n                role=role,\n                tos_version=settings.TERMS_OF_SERVICE_VERSION,\n                timezone=timezone,\n                default_language=get_default_language_for_new_user(request, realm),\n                default_stream_groups=default_stream_groups,\n                source_profile=source_profile,\n                realm_creation=realm_creation,\n                acting_user=None,\n                enable_marketing_emails=enable_marketing_emails,\n            )\n\n        if realm_creation:\n            # Because for realm creation, registration happens on the\n            # root domain, we need to log them into the subdomain for\n            # their new realm.\n            return redirect_and_log_into_subdomain(\n                ExternalAuthResult(user_profile=user_profile, data_dict={\"is_realm_creation\": True})\n            )\n\n        # This dummy_backend check below confirms the user is\n        # authenticating to the correct subdomain.\n        auth_result = authenticate(\n            username=user_profile.delivery_email,\n            realm=realm,\n            return_data=return_data,\n            use_dummy_backend=True,\n        )\n        if return_data.get(\"invalid_subdomain\"):\n            # By construction, this should never happen.\n            logging.error(\n                \"Subdomain mismatch in registration %s: %s\",\n                realm.subdomain,\n                user_profile.delivery_email,\n            )\n            return redirect(\"/\")\n\n        assert isinstance(auth_result, UserProfile)\n        return login_and_go_to_home(request, auth_result)\n\n    return render(\n        request,\n        \"zerver/register.html\",\n        context={\n            \"form\": form,\n            \"email\": email,\n            \"key\": key,\n            \"full_name\": request.session.get(\"authenticated_full_name\", None),\n            \"lock_name\": name_validated and name_changes_disabled(realm),\n            # password_auth_enabled is normally set via our context processor,\n            # but for the registration form, there is no logged in user yet, so\n            # we have to set it here.\n            \"creating_new_team\": realm_creation,\n            \"password_required\": password_auth_enabled(realm) and password_required,\n            \"require_ldap_password\": require_ldap_password,\n            \"password_auth_enabled\": password_auth_enabled(realm),\n            \"root_domain_available\": is_root_domain_available(),\n            \"default_stream_groups\": [] if realm is None else get_default_stream_groups(realm),\n            \"accounts\": get_accounts_for_email(email),\n            \"MAX_REALM_NAME_LENGTH\": str(Realm.MAX_REALM_NAME_LENGTH),\n            \"MAX_NAME_LENGTH\": str(UserProfile.MAX_NAME_LENGTH),\n            \"MAX_PASSWORD_LENGTH\": str(form.MAX_PASSWORD_LENGTH),\n            \"MAX_REALM_SUBDOMAIN_LENGTH\": str(Realm.MAX_REALM_SUBDOMAIN_LENGTH),\n            \"corporate_enabled\": settings.CORPORATE_ENABLED,\n            \"sorted_realm_types\": sorted(\n                Realm.ORG_TYPES.values(), key=lambda d: d[\"display_order\"]\n            ),\n        },\n    )\n\n\ndef login_and_go_to_home(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    mobile_flow_otp = get_expirable_session_var(\n        request.session, \"registration_mobile_flow_otp\", delete=True\n    )\n    desktop_flow_otp = get_expirable_session_var(\n        request.session, \"registration_desktop_flow_otp\", delete=True\n    )\n    if mobile_flow_otp is not None:\n        return finish_mobile_flow(request, user_profile, mobile_flow_otp)\n    elif desktop_flow_otp is not None:\n        return finish_desktop_flow(request, user_profile, desktop_flow_otp)\n\n    do_login(request, user_profile)\n    # Using 'mark_sanitized' to work around false positive where Pysa thinks\n    # that 'user_profile' is user-controlled\n    return HttpResponseRedirect(mark_sanitized(user_profile.realm.uri) + reverse(\"home\"))\n\n\ndef prepare_activation_url(\n    email: str,\n    session: SessionBase,\n    *,\n    realm: Optional[Realm],\n    realm_creation: bool = False,\n    streams: Optional[Iterable[Stream]] = None,\n    invited_as: Optional[int] = None,\n    multiuse_invite: Optional[MultiuseInvite] = None,\n) -> str:\n    \"\"\"\n    Send an email with a confirmation link to the provided e-mail so the user\n    can complete their registration.\n    \"\"\"\n    prereg_user = create_preregistration_user(\n        email, realm, realm_creation, multiuse_invite=multiuse_invite\n    )\n\n    if streams is not None:\n        prereg_user.streams.set(streams)\n\n    if invited_as is not None:\n        prereg_user.invited_as = invited_as\n        prereg_user.save()\n\n    confirmation_type = Confirmation.USER_REGISTRATION\n    if realm_creation:\n        confirmation_type = Confirmation.REALM_CREATION\n\n    activation_url = create_confirmation_link(prereg_user, confirmation_type)\n    if settings.DEVELOPMENT and realm_creation:\n        session[\"confirmation_key\"] = {\"confirmation_key\": activation_url.split(\"/\")[-1]}\n    return activation_url\n\n\ndef send_confirm_registration_email(\n    email: str,\n    activation_url: str,\n    *,\n    realm: Optional[Realm] = None,\n    request: Optional[HttpRequest] = None,\n) -> None:\n    send_email(\n        \"zerver/emails/confirm_registration\",\n        to_emails=[email],\n        from_address=FromAddress.tokenized_no_reply_address(),\n        language=get_language() if request is not None else None,\n        context={\n            \"create_realm\": (realm is None),\n            \"activate_url\": activation_url,\n        },\n        realm=realm,\n        request=request,\n    )\n\n\ndef redirect_to_email_login_url(email: str) -> HttpResponseRedirect:\n    login_url = reverse(\"login\")\n    redirect_url = append_url_query_string(\n        login_url, urlencode({\"email\": email, \"already_registered\": 1})\n    )\n    return HttpResponseRedirect(redirect_url)\n\n\ndef create_realm(request: HttpRequest, creation_key: Optional[str] = None) -> HttpResponse:\n    try:\n        key_record = validate_key(creation_key)\n    except RealmCreationKey.InvalidError:\n        return render(\n            request,\n            \"zerver/realm_creation_link_invalid.html\",\n        )\n    if not settings.OPEN_REALM_CREATION:\n        if key_record is None:\n            return render(\n                request,\n                \"zerver/realm_creation_disabled.html\",\n            )\n\n    # When settings.OPEN_REALM_CREATION is enabled, anyone can create a new realm,\n    # with a few restrictions on their email address.\n    if request.method == \"POST\":\n        form = RealmCreationForm(request.POST)\n        if form.is_valid():\n            try:\n                rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n            except RateLimitedError as e:\n                assert e.secs_to_freedom is not None\n                return render(\n                    request,\n                    \"zerver/rate_limit_exceeded.html\",\n                    context={\"retry_after\": int(e.secs_to_freedom)},\n                    status=429,\n                )\n\n            email = form.cleaned_data[\"email\"]\n            activation_url = prepare_activation_url(\n                email, request.session, realm=None, realm_creation=True\n            )\n            if key_record is not None and key_record.presume_email_valid:\n                # The user has a token created from the server command line;\n                # skip confirming the email is theirs, taking their word for it.\n                # This is essential on first install if the admin hasn't stopped\n                # to configure outbound email up front, or it isn't working yet.\n                key_record.delete()\n                return HttpResponseRedirect(activation_url)\n\n            try:\n                send_confirm_registration_email(email, activation_url, request=request)\n            except EmailNotDeliveredError:\n                logging.error(\"Error in create_realm\")\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            if key_record is not None:\n                key_record.delete()\n            return HttpResponseRedirect(reverse(\"new_realm_send_confirm\", kwargs={\"email\": email}))\n    else:\n        form = RealmCreationForm()\n    return render(\n        request,\n        \"zerver/create_realm.html\",\n        context={\"form\": form, \"current_url\": request.get_full_path},\n    )\n\n\ndef accounts_home(\n    request: HttpRequest,\n    multiuse_object_key: str = \"\",\n    multiuse_object: Optional[MultiuseInvite] = None,\n) -> HttpResponse:\n    try:\n        realm = get_realm(get_subdomain(request))\n    except Realm.DoesNotExist:\n        return HttpResponseRedirect(reverse(find_account))\n    if realm.deactivated:\n        return redirect_to_deactivation_notice()\n\n    from_multiuse_invite = False\n    streams_to_subscribe = None\n    invited_as = None\n\n    if multiuse_object:\n        # multiuse_object's realm should have been validated by the caller,\n        # so this code shouldn't be reachable with a multiuse_object which\n        # has its realm mismatching the realm of the request.\n        assert realm == multiuse_object.realm\n\n        streams_to_subscribe = multiuse_object.streams.all()\n        from_multiuse_invite = True\n        invited_as = multiuse_object.invited_as\n\n    if request.method == \"POST\":\n        form = HomepageForm(\n            request.POST,\n            realm=realm,\n            from_multiuse_invite=from_multiuse_invite,\n            invited_as=invited_as,\n        )\n        if form.is_valid():\n            try:\n                rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n            except RateLimitedError as e:\n                assert e.secs_to_freedom is not None\n                return render(\n                    request,\n                    \"zerver/rate_limit_exceeded.html\",\n                    context={\"retry_after\": int(e.secs_to_freedom)},\n                    status=429,\n                )\n\n            email = form.cleaned_data[\"email\"]\n\n            try:\n                validate_email_not_already_in_realm(realm, email)\n            except ValidationError:\n                return redirect_to_email_login_url(email)\n\n            activation_url = prepare_activation_url(\n                email,\n                request.session,\n                realm=realm,\n                streams=streams_to_subscribe,\n                invited_as=invited_as,\n                multiuse_invite=multiuse_object,\n            )\n            try:\n                send_confirm_registration_email(email, activation_url, request=request, realm=realm)\n            except EmailNotDeliveredError:\n                logging.error(\"Error in accounts_home\")\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            return HttpResponseRedirect(reverse(\"signup_send_confirm\", kwargs={\"email\": email}))\n\n    else:\n        form = HomepageForm(realm=realm)\n    context = login_context(request)\n    context.update(\n        form=form,\n        current_url=request.get_full_path,\n        multiuse_object_key=multiuse_object_key,\n        from_multiuse_invite=from_multiuse_invite,\n    )\n    return render(request, \"zerver/accounts_home.html\", context=context)\n\n\ndef accounts_home_from_multiuse_invite(request: HttpRequest, confirmation_key: str) -> HttpResponse:\n    realm = get_realm_from_request(request)\n    multiuse_object: Optional[MultiuseInvite] = None\n    try:\n        confirmation_obj = get_object_from_key(\n            confirmation_key, [Confirmation.MULTIUSE_INVITE], mark_object_used=False\n        )\n        assert isinstance(confirmation_obj, MultiuseInvite)\n        multiuse_object = confirmation_obj\n        if realm != multiuse_object.realm:\n            return render(request, \"confirmation/link_does_not_exist.html\", status=404)\n        # Required for OAuth 2\n    except ConfirmationKeyError as exception:\n        if realm is None or realm.invite_required:\n            return render_confirmation_key_error(request, exception)\n    return accounts_home(\n        request, multiuse_object_key=confirmation_key, multiuse_object=multiuse_object\n    )\n\n\n@has_request_variables\ndef find_account(\n    request: HttpRequest, raw_emails: Optional[str] = REQ(\"emails\", default=None)\n) -> HttpResponse:\n    url = reverse(\"find_account\")\n\n    emails: List[str] = []\n    if request.method == \"POST\":\n        form = FindMyTeamForm(request.POST)\n        if form.is_valid():\n            emails = form.cleaned_data[\"emails\"]\n            for i in range(len(emails)):\n                try:\n                    rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n                except RateLimitedError as e:\n                    assert e.secs_to_freedom is not None\n                    return render(\n                        request,\n                        \"zerver/rate_limit_exceeded.html\",\n                        context={\"retry_after\": int(e.secs_to_freedom)},\n                        status=429,\n                    )\n\n            # Django doesn't support __iexact__in lookup with EmailField, so we have\n            # to use Qs to get around that without needing to do multiple queries.\n            emails_q = Q()\n            for email in emails:\n                emails_q |= Q(delivery_email__iexact=email)\n\n            user_profiles = UserProfile.objects.filter(\n                emails_q, is_active=True, is_bot=False, realm__deactivated=False\n            )\n\n            # We organize the data in preparation for sending exactly\n            # one outgoing email per provided email address, with each\n            # email listing all of the accounts that email address has\n            # with the current Zulip server.\n            context: Dict[str, Dict[str, Any]] = {}\n            for user in user_profiles:\n                key = user.delivery_email.lower()\n                context.setdefault(key, {})\n                context[key].setdefault(\"realms\", [])\n                context[key][\"realms\"].append(user.realm)\n                context[key][\"external_host\"] = settings.EXTERNAL_HOST\n                # This value will end up being the last user ID among\n                # matching accounts; since it's only used for minor\n                # details like language, that arbitrary choice is OK.\n                context[key][\"to_user_id\"] = user.id\n\n            for delivery_email, realm_context in context.items():\n                realm_context[\"email\"] = delivery_email\n                send_email(\n                    \"zerver/emails/find_team\",\n                    to_user_ids=[realm_context[\"to_user_id\"]],\n                    context=realm_context,\n                    from_address=FromAddress.SUPPORT,\n                    request=request,\n                )\n\n            # Note: Show all the emails in the result otherwise this\n            # feature can be used to ascertain which email addresses\n            # are associated with Zulip.\n            data = urllib.parse.urlencode({\"emails\": \",\".join(emails)})\n            return redirect(append_url_query_string(url, data))\n    else:\n        form = FindMyTeamForm()\n        # The below validation is perhaps unnecessary, in that we\n        # shouldn't get able to get here with an invalid email unless\n        # the user hand-edits the URLs.\n        if raw_emails:\n            for email in raw_emails.split(\",\"):\n                try:\n                    validators.validate_email(email)\n                    emails.append(email)\n                except ValidationError:\n                    pass\n\n    return render(\n        request,\n        \"zerver/find_account.html\",\n        context={\"form\": form, \"current_url\": lambda: url, \"emails\": emails},\n    )\n\n\n@has_request_variables\ndef realm_redirect(request: HttpRequest, next: str = REQ(default=\"\")) -> HttpResponse:\n    if request.method == \"POST\":\n        form = RealmRedirectForm(request.POST)\n        if form.is_valid():\n            subdomain = form.cleaned_data[\"subdomain\"]\n            realm = get_realm(subdomain)\n            redirect_to = get_safe_redirect_to(next, realm.uri)\n            return HttpResponseRedirect(redirect_to)\n    else:\n        form = RealmRedirectForm()\n\n    return render(request, \"zerver/realm_redirect.html\", context={\"form\": form})\n"], "fixing_code": ["import datetime\nimport re\nimport time\nimport urllib\nfrom typing import TYPE_CHECKING, Any, Dict, List, Optional, Sequence, Union\nfrom unittest.mock import MagicMock, patch\nfrom urllib.parse import urlencode\n\nimport orjson\nfrom django.conf import settings\nfrom django.contrib.auth.views import PasswordResetConfirmView\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.exceptions import ValidationError\nfrom django.core.mail.message import EmailMultiAlternatives\nfrom django.http import HttpRequest, HttpResponse, HttpResponseBase\nfrom django.template.response import TemplateResponse\nfrom django.test import Client, override_settings\nfrom django.urls import reverse\nfrom django.utils import translation\nfrom django.utils.timezone import now as timezone_now\nfrom django.utils.translation import gettext as _\n\nfrom confirmation import settings as confirmation_settings\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyError,\n    create_confirmation_link,\n    get_object_from_key,\n    one_click_unsubscribe_link,\n)\nfrom corporate.lib.stripe import get_latest_seat_count\nfrom zerver.actions.create_realm import do_change_realm_subdomain, do_create_realm\nfrom zerver.actions.create_user import add_new_user_history, do_create_user, process_new_human_user\nfrom zerver.actions.default_streams import (\n    do_add_default_stream,\n    do_create_default_stream_group,\n    get_default_streams_for_realm,\n)\nfrom zerver.actions.invites import (\n    do_create_multiuse_invite_link,\n    do_get_invites_controlled_by_user,\n    do_invite_users,\n    do_revoke_multi_use_invite,\n)\nfrom zerver.actions.realm_settings import (\n    do_deactivate_realm,\n    do_set_realm_authentication_methods,\n    do_set_realm_property,\n    do_set_realm_user_default_setting,\n)\nfrom zerver.actions.user_settings import do_change_full_name\nfrom zerver.actions.users import change_user_is_active, do_change_user_role, do_deactivate_user\nfrom zerver.context_processors import common_context\nfrom zerver.decorator import do_two_factor_login\nfrom zerver.forms import HomepageForm, check_subdomain_available\nfrom zerver.lib.email_notifications import enqueue_welcome_emails, followup_day2_email_delay\nfrom zerver.lib.i18n import get_default_language_for_new_user\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.mobile_auth_otp import (\n    ascii_to_hex,\n    hex_to_ascii,\n    is_valid_otp,\n    otp_decrypt_api_key,\n    otp_encrypt_api_key,\n    xor_hex_strings,\n)\nfrom zerver.lib.name_restrictions import is_disposable_domain\nfrom zerver.lib.rate_limiter import add_ratelimit_rule, remove_ratelimit_rule\nfrom zerver.lib.send_email import (\n    EmailNotDeliveredError,\n    FromAddress,\n    deliver_scheduled_emails,\n    send_future_email,\n)\nfrom zerver.lib.stream_subscription import get_stream_subscriptions_for_user\nfrom zerver.lib.streams import create_stream_if_needed\nfrom zerver.lib.subdomains import is_root_domain_available\nfrom zerver.lib.test_classes import ZulipTestCase\nfrom zerver.lib.test_helpers import (\n    HostRequestMock,\n    avatar_disk_path,\n    cache_tries_captured,\n    find_key_by_email,\n    get_test_image_file,\n    load_subdomain_token,\n    message_stream_count,\n    most_recent_message,\n    most_recent_usermessage,\n    queries_captured,\n    reset_emails_in_zulip_realm,\n)\nfrom zerver.models import (\n    CustomProfileField,\n    CustomProfileFieldValue,\n    DefaultStream,\n    Message,\n    MultiuseInvite,\n    PreregistrationUser,\n    Realm,\n    RealmAuditLog,\n    RealmUserDefault,\n    Recipient,\n    ScheduledEmail,\n    Stream,\n    Subscription,\n    UserMessage,\n    UserProfile,\n    flush_per_request_caches,\n    get_realm,\n    get_stream,\n    get_system_bot,\n    get_user,\n    get_user_by_delivery_email,\n)\nfrom zerver.views.auth import redirect_and_log_into_subdomain, start_two_factor_auth\nfrom zerver.views.development.registration import confirmation_key\nfrom zerver.views.invite import INVITATION_LINK_VALIDITY_MINUTES, get_invitee_emails_set\nfrom zerver.views.registration import accounts_home\nfrom zproject.backends import ExternalAuthDataDict, ExternalAuthResult, email_auth_enabled\n\nif TYPE_CHECKING:\n    from django.test.client import _MonkeyPatchedWSGIResponse as TestHttpResponse\n\n\nclass RedirectAndLogIntoSubdomainTestCase(ZulipTestCase):\n    def test_data(self) -> None:\n        realm = get_realm(\"zulip\")\n        user_profile = self.example_user(\"hamlet\")\n        name = user_profile.full_name\n        email = user_profile.delivery_email\n        response = redirect_and_log_into_subdomain(ExternalAuthResult(user_profile=user_profile))\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\"full_name\": name, \"email\": email, \"subdomain\": realm.subdomain, \"is_signup\": False},\n        )\n\n        data_dict = ExternalAuthDataDict(is_signup=True, multiuse_object_key=\"key\")\n        response = redirect_and_log_into_subdomain(\n            ExternalAuthResult(user_profile=user_profile, data_dict=data_dict)\n        )\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\n                \"full_name\": name,\n                \"email\": email,\n                \"subdomain\": realm.subdomain,\n                # the email has an account at the subdomain,\n                # so is_signup get overridden to False:\n                \"is_signup\": False,\n                \"multiuse_object_key\": \"key\",\n            },\n        )\n\n        data_dict = ExternalAuthDataDict(\n            email=self.nonreg_email(\"alice\"),\n            full_name=\"Alice\",\n            subdomain=realm.subdomain,\n            is_signup=True,\n            full_name_validated=True,\n            multiuse_object_key=\"key\",\n        )\n        response = redirect_and_log_into_subdomain(ExternalAuthResult(data_dict=data_dict))\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\n                \"full_name\": \"Alice\",\n                \"email\": self.nonreg_email(\"alice\"),\n                \"full_name_validated\": True,\n                \"subdomain\": realm.subdomain,\n                \"is_signup\": True,\n                \"multiuse_object_key\": \"key\",\n            },\n        )\n\n\nclass DeactivationNoticeTestCase(ZulipTestCase):\n    def test_redirection_for_deactivated_realm(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        for url in (\"/register/\", \"/login/\"):\n            result = self.client_get(url)\n            self.assertRedirects(result, \"/accounts/deactivated/\", status_code=302)\n\n    def test_redirection_for_active_realm(self) -> None:\n        for url in (\"/register/\", \"/login/\"):\n            result = self.client_get(url)\n            self.assertEqual(result.status_code, 200)\n\n    def test_deactivation_notice_when_realm_is_active(self) -> None:\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertRedirects(result, \"/devlogin/\", status_code=302)\n\n    def test_deactivation_notice_when_deactivated(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_get(\"/login/\", follow=True)\n        self.assertEqual(result.redirect_chain[-1], (\"/accounts/deactivated/\", 302))\n        self.assertIn(\"Zulip Dev, has been deactivated.\", result.content.decode())\n        self.assertNotIn(\"It has moved to\", result.content.decode())\n\n    def test_deactivation_notice_when_deactivated_and_deactivated_redirect_is_set(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.deactivated_redirect = \"http://example.zulipchat.com\"\n        realm.save(update_fields=[\"deactivated\", \"deactivated_redirect\"])\n\n        result = self.client_get(\"/login/\", follow=True)\n        self.assertIn(\n            'It has moved to <a href=\"http://example.zulipchat.com\">http://example.zulipchat.com</a>.',\n            result.content.decode(),\n        )\n\n    def test_deactivation_notice_when_realm_subdomain_is_changed(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-subdomain-name\", acting_user=None)\n\n        result = self.client_get(\"/login/\", follow=True)\n        self.assertIn(\n            'It has moved to <a href=\"http://new-subdomain-name.testserver\">http://new-subdomain-name.testserver</a>.',\n            result.content.decode(),\n        )\n\n    def test_no_deactivation_notice_with_no_rediect(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(\n            realm, \"new-subdomain-name\", acting_user=None, add_deactivated_redirect=False\n        )\n\n        result = self.client_get(\"/login/\", follow=True)\n        self.assertEqual(result.status_code, 404)\n        self.assertNotIn(\n            \"new-subdomain-name\",\n            result.content.decode(),\n        )\n\n    def test_deactivated_redirect_field_of_placeholder_realms_are_modified_on_changing_subdomain_multiple_times(\n        self,\n    ) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-name-1\", acting_user=None)\n\n        result = self.client_get(\"/login/\", follow=True)\n        self.assertIn(\n            'It has moved to <a href=\"http://new-name-1.testserver\">http://new-name-1.testserver</a>.',\n            result.content.decode(),\n        )\n\n        realm = get_realm(\"new-name-1\")\n        do_change_realm_subdomain(realm, \"new-name-2\", acting_user=None)\n        result = self.client_get(\"/login/\", follow=True)\n        self.assertIn(\n            'It has moved to <a href=\"http://new-name-2.testserver\">http://new-name-2.testserver</a>.',\n            result.content.decode(),\n        )\n\n\nclass AddNewUserHistoryTest(ZulipTestCase):\n    def test_add_new_user_history_race(self) -> None:\n        \"\"\"Sends a message during user creation\"\"\"\n        # Create a user who hasn't had historical messages added\n        realm = get_realm(\"zulip\")\n        stream = Stream.objects.get(realm=realm, name=\"Denmark\")\n        DefaultStream.objects.create(stream=stream, realm=realm)\n        # Make sure at least 3 messages are sent to Denmark and it's a default stream.\n        message_id = self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 1\")\n        self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 2\")\n        self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 3\")\n\n        with patch(\"zerver.actions.create_user.add_new_user_history\"):\n            self.register(self.nonreg_email(\"test\"), \"test\")\n        user_profile = self.nonreg_user(\"test\")\n        subs = Subscription.objects.select_related(\"recipient\").filter(\n            user_profile=user_profile, recipient__type=Recipient.STREAM\n        )\n        streams = Stream.objects.filter(id__in=[sub.recipient.type_id for sub in subs])\n\n        # Sent a message afterwards to trigger a race between message\n        # sending and `add_new_user_history`.\n        race_message_id = self.send_stream_message(\n            self.example_user(\"hamlet\"), streams[0].name, \"test\"\n        )\n\n        # Overwrite ONBOARDING_UNREAD_MESSAGES to 2\n        ONBOARDING_UNREAD_MESSAGES = 2\n        with patch(\n            \"zerver.actions.create_user.ONBOARDING_UNREAD_MESSAGES\", ONBOARDING_UNREAD_MESSAGES\n        ):\n            add_new_user_history(user_profile, streams)\n\n        # Our first message is in the user's history\n        self.assertTrue(\n            UserMessage.objects.filter(user_profile=user_profile, message_id=message_id).exists()\n        )\n        # The race message is in the user's history and marked unread.\n        self.assertTrue(\n            UserMessage.objects.filter(\n                user_profile=user_profile, message_id=race_message_id\n            ).exists()\n        )\n        self.assertFalse(\n            UserMessage.objects.get(\n                user_profile=user_profile, message_id=race_message_id\n            ).flags.read.is_set\n        )\n\n        # Verify that the ONBOARDING_UNREAD_MESSAGES latest messages\n        # that weren't the race message are marked as unread.\n        latest_messages = (\n            UserMessage.objects.filter(\n                user_profile=user_profile,\n                message__recipient__type=Recipient.STREAM,\n            )\n            .exclude(message_id=race_message_id)\n            .order_by(\"-message_id\")[0:ONBOARDING_UNREAD_MESSAGES]\n        )\n        self.assert_length(latest_messages, 2)\n        for msg in latest_messages:\n            self.assertFalse(msg.flags.read.is_set)\n\n        # Verify that older messages are correctly marked as read.\n        older_messages = (\n            UserMessage.objects.filter(\n                user_profile=user_profile,\n                message__recipient__type=Recipient.STREAM,\n            )\n            .exclude(message_id=race_message_id)\n            .order_by(\"-message_id\")[ONBOARDING_UNREAD_MESSAGES : ONBOARDING_UNREAD_MESSAGES + 1]\n        )\n        self.assertGreater(len(older_messages), 0)\n        for msg in older_messages:\n            self.assertTrue(msg.flags.read.is_set)\n\n    def test_auto_subbed_to_personals(self) -> None:\n        \"\"\"\n        Newly created users are auto-subbed to the ability to receive\n        personals.\n        \"\"\"\n        test_email = self.nonreg_email(\"test\")\n        self.register(test_email, \"test\")\n        user_profile = self.nonreg_user(\"test\")\n        old_messages_count = message_stream_count(user_profile)\n        self.send_personal_message(user_profile, user_profile)\n        new_messages_count = message_stream_count(user_profile)\n        self.assertEqual(new_messages_count, old_messages_count + 1)\n\n        recipient = Recipient.objects.get(type_id=user_profile.id, type=Recipient.PERSONAL)\n        message = most_recent_message(user_profile)\n        self.assertEqual(message.recipient, recipient)\n\n        with patch(\"zerver.models.get_display_recipient\", return_value=\"recip\"):\n            self.assertEqual(\n                str(message),\n                \"<Message: recip /  / \"\n                \"<UserProfile: {} {}>>\".format(user_profile.email, user_profile.realm),\n            )\n\n            user_message = most_recent_usermessage(user_profile)\n            self.assertEqual(\n                str(user_message),\n                f\"<UserMessage: recip / {user_profile.email} ([])>\",\n            )\n\n\nclass InitialPasswordTest(ZulipTestCase):\n    def test_none_initial_password_salt(self) -> None:\n        with self.settings(INITIAL_PASSWORD_SALT=None):\n            self.assertIsNone(initial_password(\"test@test.com\"))\n\n\nclass PasswordResetTest(ZulipTestCase):\n    \"\"\"\n    Log in, reset password, log out, log in with new password.\n    \"\"\"\n\n    def get_reset_mail_body(self, subdomain: str = \"zulip\") -> str:\n        from django.core.mail import outbox\n\n        [message] = outbox\n        self.assertEqual(self.email_envelope_from(message), settings.NOREPLY_EMAIL_ADDRESS)\n        # The email might be sent in different languages for i18n testing\n        self.assertRegex(\n            self.email_display_from(message),\n            rf'^{_(\"Zulip Account Security\")} <{self.TOKENIZED_NOREPLY_REGEX}>\\Z',\n        )\n        self.assertIn(f\"{subdomain}.testserver\", message.extra_headers[\"List-Id\"])\n\n        return str(message.body)\n\n    def test_password_reset(self) -> None:\n        user = self.example_user(\"hamlet\")\n        email = user.delivery_email\n        old_password = initial_password(email)\n        assert old_password is not None\n\n        self.login_user(user)\n\n        # test password reset template\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assert_in_response(\"Reset your password\", result)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"reset your password\", body)\n\n        # Visit the password reset link.\n        password_reset_url = self.get_confirmation_url_from_outbox(\n            email, url_pattern=settings.EXTERNAL_HOST + r\"(\\S\\S+)\"\n        )\n        result = self.client_get(password_reset_url)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].endswith(f\"/{PasswordResetConfirmView.reset_url_token}/\")\n        )\n\n        final_reset_url = result[\"Location\"]\n        result = self.client_get(final_reset_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Reset your password\n        with self.settings(PASSWORD_MIN_LENGTH=3, PASSWORD_MIN_GUESSES=1000):\n            # Verify weak passwords don't work.\n            result = self.client_post(\n                final_reset_url, {\"new_password1\": \"easy\", \"new_password2\": \"easy\"}\n            )\n            self.assert_in_response(\"The password is too weak.\", result)\n\n            result = self.client_post(\n                final_reset_url, {\"new_password1\": \"f657gdGGk9\", \"new_password2\": \"f657gdGGk9\"}\n            )\n            # password reset succeeded\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\"/password/done/\"))\n\n            # log back in with new password\n            self.login_by_email(email, password=\"f657gdGGk9\")\n            user_profile = self.example_user(\"hamlet\")\n            self.assert_logged_in_user_id(user_profile.id)\n\n            # make sure old password no longer works\n            self.assert_login_failure(email, password=old_password)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_redirects_for_root_alias_when_root_domain_landing_page_is_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"alias.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True, ROOT_SUBDOMAIN_ALIASES=[\"alias\"]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                result[\"Location\"], \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\"\n            )\n\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n        ):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                result[\"Location\"], \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\"\n            )\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_redirects_for_root_domain_when_root_domain_landing_page_is_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                result[\"Location\"], \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\"\n            )\n\n        mock_get_host.return_value = \"www.zulip.example.com\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n            EXTERNAL_HOST=\"www.zulip.example.com\",\n        ):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                result[\"Location\"], \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\"\n            )\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_for_root_alias_when_root_domain_landing_page_is_not_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"alias.testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"alias\"]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"www.testserver\"\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_for_root_domain_when_root_domain_landing_page_is_not_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"testserver\"\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"www.zulip.example.com\"\n        with self.settings(EXTERNAL_HOST=\"www.zulip.example.com\", ROOT_SUBDOMAIN_ALIASES=[]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_always_for_subdomains(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"lear.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n    def test_password_reset_for_non_existent_user(self) -> None:\n        email = \"nonexisting@mars.com\"\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"You do not have an account\", body)\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"deactivated\", body)\n\n    def test_password_reset_for_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        do_deactivate_user(user_profile, acting_user=None)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"has been deactivated\", body)\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"not have an account\", body)\n\n    def test_password_reset_with_deactivated_realm(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        do_deactivate_realm(user_profile.realm, acting_user=None)\n\n        # start the password reset process by supplying an email address\n        with self.assertLogs(level=\"INFO\") as m:\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(m.output, [\"INFO:root:Realm is deactivated\"])\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(RATE_LIMITING=True)\n    def test_rate_limiting(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        from django.core.mail import outbox\n\n        add_ratelimit_rule(10, 2, domain=\"password_reset_form_by_email\")\n        start_time = time.time()\n        with patch(\"time.time\", return_value=start_time):\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assert_length(outbox, 2)\n\n            # Too many password reset emails sent to the address, we won't send more.\n            with self.assertLogs(level=\"INFO\") as info_logs:\n                self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(\n                info_logs.output,\n                [\n                    \"INFO:root:Too many password reset attempts for email hamlet@zulip.com from 127.0.0.1\"\n                ],\n            )\n            self.assert_length(outbox, 2)\n\n            # Resetting for a different address works though.\n            self.client_post(\"/accounts/password/reset/\", {\"email\": self.example_email(\"othello\")})\n            self.assert_length(outbox, 3)\n            self.client_post(\"/accounts/password/reset/\", {\"email\": self.example_email(\"othello\")})\n            self.assert_length(outbox, 4)\n\n        # After time, password reset emails can be sent again.\n        with patch(\"time.time\", return_value=start_time + 11):\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assert_length(outbox, 6)\n\n        remove_ratelimit_rule(10, 2, domain=\"password_reset_form_by_email\")\n\n    def test_wrong_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email}, subdomain=\"zephyr\")\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        body = self.get_reset_mail_body(\"zephyr\")\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"You do not have an account\", body)\n        self.assertIn(\n            \"active accounts in the following organization(s).\\nhttp://zulip.testserver\", body\n        )\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"deactivated\", body)\n\n    def test_wrong_subdomain_i18n(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n\n        # Send a password reset request with a different language to a wrong subdomain\n        result = self.client_post(\n            \"/accounts/password/reset/\",\n            {\"email\": email},\n            HTTP_ACCEPT_LANGUAGE=\"de\",\n            subdomain=\"lear\",\n        )\n        self.assertEqual(result.status_code, 302)\n\n        with translation.override(\"de\"):\n            body = self.get_reset_mail_body(\"lear\")\n            self.assertIn(\"hat ein neues Passwort\", body)\n\n    def test_invalid_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\n            \"/accounts/password/reset/\", {\"email\": email}, subdomain=\"invalid\"\n        )\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"There is no Zulip organization hosted at this subdomain.\", result)\n\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_auth_only(self) -> None:\n        \"\"\"If the email auth backend is not enabled, password reset should do nothing\"\"\"\n        email = self.example_email(\"hamlet\")\n        with self.assertLogs(level=\"INFO\") as m:\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(\n                m.output,\n                [\n                    \"INFO:root:Password reset attempted for hamlet@zulip.com even though password auth is disabled.\"\n                ],\n            )\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_and_email_auth(self) -> None:\n        \"\"\"If both email and LDAP auth backends are enabled, limit password\n        reset to users outside the LDAP domain\"\"\"\n        # If the domain matches, we don't generate an email\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            email = self.example_email(\"hamlet\")\n            with self.assertLogs(level=\"INFO\") as m:\n                result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n                self.assertEqual(\n                    m.output, [\"INFO:root:Password reset not allowed for user in LDAP domain\"]\n                )\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n        # If the domain doesn't match, we do generate an email\n        with self.settings(LDAP_APPEND_DOMAIN=\"example.com\"):\n            email = self.example_email(\"hamlet\")\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n            result = self.client_get(result[\"Location\"])\n\n        body = self.get_reset_mail_body()\n        self.assertIn(\"reset your password\", body)\n\n    def test_redirect_endpoints(self) -> None:\n        \"\"\"\n        These tests are mostly designed to give us 100% URL coverage\n        in our URL coverage reports.  Our mechanism for finding URL\n        coverage doesn't handle redirects, so we just have a few quick\n        tests here.\n        \"\"\"\n        result = self.client_get(\"/accounts/password/reset/done/\")\n        self.assert_in_success_response([\"Check your email\"], result)\n\n        result = self.client_get(\"/accounts/password/done/\")\n        self.assert_in_success_response([\"We've reset your password!\"], result)\n\n        result = self.client_get(\"/accounts/send_confirm/alice@example.com\")\n        self.assert_in_success_response([\"/accounts/home/\"], result)\n\n        result = self.client_get(\"/accounts/new/send_confirm/alice@example.com\")\n        self.assert_in_success_response([\"/new/\"], result)\n\n    def test_password_reset_for_soft_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        with self.soft_deactivate_and_check_long_term_idle(user_profile, False):\n            # start the password reset process by supplying an email address\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n            # check the redirect link telling you to check mail for password reset link\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n\n\nclass LoginTest(ZulipTestCase):\n    \"\"\"\n    Logging in, registration, and logging out.\n    \"\"\"\n\n    def test_login(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_login_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        do_deactivate_user(user_profile, acting_user=None)\n        result = self.login_with_return(user_profile.delivery_email, \"xxx\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            f\"Your account {user_profile.delivery_email} has been deactivated.\", result\n        )\n        self.assert_logged_in_user_id(None)\n\n    def test_login_deactivate_user_error(self) -> None:\n        \"\"\"\n        This is meant to test whether the error message signaled by the\n        is_deactivated is shown independently of whether the Email\n        backend is enabled.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        realm = user_profile.realm\n        self.assertTrue(email_auth_enabled(realm))\n\n        url = f\"{realm.uri}/login/?\" + urlencode({\"is_deactivated\": user_profile.delivery_email})\n        result = self.client_get(url)\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            f\"Your account {user_profile.delivery_email} has been deactivated.\", result\n        )\n\n        auth_dict = realm.authentication_methods_dict()\n        auth_dict[\"Email\"] = False\n        do_set_realm_authentication_methods(realm, auth_dict, acting_user=None)\n        result = self.client_get(url)\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            f\"Your account {user_profile.delivery_email} has been deactivated.\", result\n        )\n\n    def test_login_bad_password(self) -> None:\n        user = self.example_user(\"hamlet\")\n        password: Optional[str] = \"wrongpassword\"\n        result = self.login_with_return(user.delivery_email, password=password)\n        self.assert_in_success_response([user.delivery_email], result)\n        self.assert_logged_in_user_id(None)\n\n        # Parallel test to confirm that the right password works using the\n        # same login code, which verifies our failing test isn't broken\n        # for some other reason.\n        password = initial_password(user.delivery_email)\n        result = self.login_with_return(user.delivery_email, password=password)\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user.id)\n\n    @override_settings(RATE_LIMITING_AUTHENTICATE=True)\n    def test_login_bad_password_rate_limiter(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        add_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n        start_time = time.time()\n        with patch(\"time.time\", return_value=start_time):\n            self.login_with_return(email, password=\"wrongpassword\")\n            self.assert_logged_in_user_id(None)\n            self.login_with_return(email, password=\"wrongpassword\")\n            self.assert_logged_in_user_id(None)\n\n            # We're over the allowed limit, so the next attempt, even with the correct\n            # password, will get blocked.\n            result = self.login_with_return(email)\n            self.assert_in_success_response([\"Try again in 10 seconds\"], result)\n\n        # After time passes, we should be able to log in.\n        with patch(\"time.time\", return_value=start_time + 11):\n            self.login_with_return(email)\n            self.assert_logged_in_user_id(user_profile.id)\n\n        remove_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n    def test_login_with_old_weak_password_after_hasher_change(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"a_password_of_22_chars\"\n\n        with self.settings(PASSWORD_HASHERS=(\"django.contrib.auth.hashers.SHA1PasswordHasher\",)):\n            user_profile.set_password(password)\n            user_profile.save()\n\n        with self.settings(\n            PASSWORD_HASHERS=(\n                \"django.contrib.auth.hashers.MD5PasswordHasher\",\n                \"django.contrib.auth.hashers.SHA1PasswordHasher\",\n            ),\n            PASSWORD_MIN_LENGTH=30,\n        ), self.assertLogs(\"zulip.auth.email\", level=\"INFO\"):\n            result = self.login_with_return(self.example_email(\"hamlet\"), password)\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\n                \"Your password has been disabled because it is too weak.\", result\n            )\n            self.assert_logged_in_user_id(None)\n\n    def test_login_nonexistent_user(self) -> None:\n        result = self.login_with_return(\"xxx@zulip.com\", \"xxx\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Please enter a correct email and password\", result)\n        self.assert_logged_in_user_id(None)\n\n    def test_login_wrong_subdomain(self) -> None:\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.delivery_email\n        with self.assertLogs(\"zulip.auth.OurAuthenticationForm\", level=\"INFO\") as m:\n            result = self.login_with_return(email, \"xxx\")\n            matching_accounts_dict = {\"realm_id\": user_profile.realm_id, \"id\": user_profile.id}\n            self.assertEqual(\n                m.output,\n                [\n                    f\"INFO:zulip.auth.OurAuthenticationForm:User attempted password login to wrong subdomain zulip. Matching accounts: [{matching_accounts_dict}]\"\n                ],\n            )\n        self.assertEqual(result.status_code, 200)\n        expected_error = (\n            \"Please enter a correct email and password. Note that both fields may be case-sensitive\"\n        )\n        self.assert_in_response(expected_error, result)\n        self.assert_logged_in_user_id(None)\n\n    def test_login_invalid_subdomain(self) -> None:\n        result = self.login_with_return(self.example_email(\"hamlet\"), \"xxx\", subdomain=\"invalid\")\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"There is no Zulip organization hosted at this subdomain.\", result)\n        self.assert_logged_in_user_id(None)\n\n    def test_register(self) -> None:\n        reset_emails_in_zulip_realm()\n\n        realm = get_realm(\"zulip\")\n        hamlet = self.example_user(\"hamlet\")\n        stream_names = [f\"stream_{i}\" for i in range(40)]\n        for stream_name in stream_names:\n            stream = self.make_stream(stream_name, realm=realm)\n            DefaultStream.objects.create(stream=stream, realm=realm)\n\n        # Make sure there's at least one recent message to be mark\n        # unread.  This prevents a bug where this test would start\n        # failing the test database was generated more than\n        # ONBOARDING_RECENT_TIMEDELTA ago.\n        self.subscribe(hamlet, \"stream_0\")\n        self.send_stream_message(\n            hamlet,\n            \"stream_0\",\n            topic_name=\"test topic\",\n            content=\"test message\",\n        )\n\n        # Clear all the caches.\n        flush_per_request_caches()\n        ContentType.objects.clear_cache()\n\n        # Ensure the number of queries we make is not O(streams)\n        with self.assert_database_query_count(96), cache_tries_captured() as cache_tries:\n            with self.captureOnCommitCallbacks(execute=True):\n                self.register(self.nonreg_email(\"test\"), \"test\")\n\n        # We can probably avoid a couple cache hits here, but there doesn't\n        # seem to be any O(N) behavior.  Some of the cache hits are related\n        # to sending messages, such as getting the welcome bot, looking up\n        # the alert words for a realm, etc.\n        self.assert_length(cache_tries, 22)\n\n        user_profile = self.nonreg_user(\"test\")\n        self.assert_logged_in_user_id(user_profile.id)\n        self.assertFalse(user_profile.enable_stream_desktop_notifications)\n        self.check_user_added_in_system_group(user_profile)\n\n    def test_register_deactivated(self) -> None:\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_post(\n            \"/accounts/home/\", {\"email\": self.nonreg_email(\"test\")}, subdomain=\"zulip\"\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result[\"Location\"])\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user(\"test\")\n\n    def test_register_with_invalid_email(self) -> None:\n        \"\"\"\n        If you try to register with invalid email, you get an invalid email\n        page\n        \"\"\"\n        invalid_email = \"foo\\x00bar\"\n        result = self.client_post(\"/accounts/home/\", {\"email\": invalid_email}, subdomain=\"zulip\")\n\n        self.assertEqual(result.status_code, 200)\n        self.assertContains(result, \"Enter a valid email address\")\n\n    def test_register_deactivated_partway_through(self) -> None:\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        email = self.nonreg_email(\"test\")\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertNotIn(\"deactivated\", result[\"Location\"])\n\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.submit_reg_form_for_user(email, \"abcd1234\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result[\"Location\"])\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user(\"test\")\n\n    def test_login_deactivated_realm(self) -> None:\n        \"\"\"\n        If you try to log in to a deactivated realm, you get a clear error page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.login_with_return(self.example_email(\"hamlet\"), subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result[\"Location\"])\n\n    def test_logout(self) -> None:\n        self.login(\"hamlet\")\n        # We use the logout API, not self.logout, to make sure we test\n        # the actual logout code path.\n        self.client_post(\"/accounts/logout/\")\n        self.assert_logged_in_user_id(None)\n\n    def test_non_ascii_login(self) -> None:\n        \"\"\"\n        You can log in even if your password contain non-ASCII characters.\n        \"\"\"\n        email = self.nonreg_email(\"test\")\n        password = \"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Registering succeeds.\n        self.register(email, password)\n        user_profile = self.nonreg_user(\"test\")\n        self.assert_logged_in_user_id(user_profile.id)\n        self.logout()\n        self.assert_logged_in_user_id(None)\n\n        # Logging in succeeds.\n        self.logout()\n        self.login_by_email(email, password)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TWO_FACTOR_AUTHENTICATION_ENABLED=False)\n    def test_login_page_redirects_logged_in_user(self) -> None:\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        self.login(\"cordelia\")\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver\")\n\n    def test_options_request_to_login_page(self) -> None:\n        response = self.client_options(\"/login/\")\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(TWO_FACTOR_AUTHENTICATION_ENABLED=True)\n    def test_login_page_redirects_logged_in_user_under_2fa(self) -> None:\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        user_profile = self.example_user(\"cordelia\")\n        self.create_default_device(user_profile)\n\n        self.login(\"cordelia\")\n        self.login_2fa(user_profile)\n\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver\")\n\n    def test_start_two_factor_auth(self) -> None:\n        request = HostRequestMock()\n        with patch(\"zerver.views.auth.TwoFactorLoginView\") as mock_view:\n            mock_view.as_view.return_value = lambda *a, **k: HttpResponse()\n            response = start_two_factor_auth(request)\n            self.assertTrue(isinstance(response, HttpResponse))\n\n    def test_do_two_factor_login(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.create_default_device(user_profile)\n        request = HostRequestMock()\n        with patch(\"zerver.decorator.django_otp.login\") as mock_login:\n            do_two_factor_login(request, user_profile)\n            mock_login.assert_called_once()\n\n    def test_zulip_default_context_does_not_load_inline_previews(self) -> None:\n        realm = get_realm(\"zulip\")\n        description = \"https://www.google.com/images/srpr/logo4w.png\"\n        realm.description = description\n        realm.save(update_fields=[\"description\"])\n        response: HttpResponseBase = self.client_get(\"/login/\")\n        expected_response = \"\"\"<p><a href=\"https://www.google.com/images/srpr/logo4w.png\">\\\nhttps://www.google.com/images/srpr/logo4w.png</a></p>\"\"\"\n        assert isinstance(response, TemplateResponse)\n        assert response.context_data is not None\n        self.assertEqual(response.context_data[\"realm_description\"], expected_response)\n        self.assertEqual(response.status_code, 200)\n\n\nclass InviteUserBase(ZulipTestCase):\n    def check_sent_emails(self, correct_recipients: List[str]) -> None:\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, len(correct_recipients))\n        email_recipients = [email.recipients()[0] for email in outbox]\n        self.assertEqual(sorted(email_recipients), sorted(correct_recipients))\n        if len(outbox) == 0:\n            return\n\n        self.assertIn(\"Zulip\", self.email_display_from(outbox[0]))\n\n        self.assertEqual(self.email_envelope_from(outbox[0]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertRegex(\n            self.email_display_from(outbox[0]), rf\" <{self.TOKENIZED_NOREPLY_REGEX}>\\Z\"\n        )\n\n        self.assertEqual(outbox[0].extra_headers[\"List-Id\"], \"Zulip Dev <zulip.testserver>\")\n\n    def invite(\n        self,\n        invitee_emails: str,\n        stream_names: Sequence[str],\n        invite_expires_in_minutes: Optional[int] = INVITATION_LINK_VALIDITY_MINUTES,\n        body: str = \"\",\n        invite_as: int = PreregistrationUser.INVITE_AS[\"MEMBER\"],\n    ) -> \"TestHttpResponse\":\n        \"\"\"\n        Invites the specified users to Zulip with the specified streams.\n\n        users should be a string containing the users to invite, comma or\n            newline separated.\n\n        streams should be a list of strings.\n        \"\"\"\n        stream_ids = []\n        for stream_name in stream_names:\n            stream_ids.append(self.get_stream_id(stream_name))\n\n        invite_expires_in: Union[str, Optional[int]] = invite_expires_in_minutes\n        if invite_expires_in is None:\n            invite_expires_in = orjson.dumps(None).decode()\n\n        return self.client_post(\n            \"/json/invites\",\n            {\n                \"invitee_emails\": invitee_emails,\n                \"invite_expires_in_minutes\": invite_expires_in,\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_as\": invite_as,\n            },\n        )\n\n\nclass InviteUserTest(InviteUserBase):\n    def test_successful_invite_user(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n    def test_newbie_restrictions(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        stream_name = \"Denmark\"\n\n        self.login_user(user_profile)\n\n        result = self.invite(invitee, [stream_name])\n        self.assert_json_success(result)\n\n        user_profile.date_joined = timezone_now() - datetime.timedelta(days=10)\n        user_profile.save()\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=5):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_success(result)\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=15):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_error_contains(result, \"Your account is too new\")\n\n    def test_invite_limits(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        realm = user_profile.realm\n        stream_name = \"Denmark\"\n\n        # These constants only need to be in descending order\n        # for this test to trigger an InvitationError based\n        # on max daily counts.\n        site_max = 50\n        realm_max = 40\n        num_invitees = 30\n        max_daily_count = 20\n\n        daily_counts = [(1, max_daily_count)]\n\n        invite_emails = [f\"foo-{i:02}@zulip.com\" for i in range(num_invitees)]\n        invitees = \",\".join(invite_emails)\n\n        self.login_user(user_profile)\n\n        realm.max_invites = realm_max\n        realm.date_created = timezone_now()\n        realm.save()\n\n        def try_invite() -> \"TestHttpResponse\":\n            with self.settings(\n                OPEN_REALM_CREATION=True,\n                INVITES_DEFAULT_REALM_DAILY_MAX=site_max,\n                INVITES_NEW_REALM_LIMIT_DAYS=daily_counts,\n            ):\n                result = self.invite(invitees, [stream_name])\n                return result\n\n        result = try_invite()\n        self.assert_json_error_contains(result, \"reached the limit\")\n\n        # Next show that aggregate limits expire once the realm is old\n        # enough.\n\n        realm.date_created = timezone_now() - datetime.timedelta(days=8)\n        realm.save()\n\n        with queries_captured() as queries:\n            with cache_tries_captured() as cache_tries:\n                result = try_invite()\n\n        self.assert_json_success(result)\n\n        # TODO: Fix large query count here.\n        #\n        # TODO: There is some test OTHER than this one\n        #       that is leaking some kind of state change\n        #       that throws off the query count here.  It\n        #       is hard to investigate currently (due to\n        #       the large number of queries), so I just\n        #       use an approximate equality check.\n        actual_count = len(queries)\n        expected_count = 251\n        if abs(actual_count - expected_count) > 1:\n            raise AssertionError(\n                f\"\"\"\n                Unexpected number of queries:\n\n                expected query count: {expected_count}\n                actual: {actual_count}\n                \"\"\"\n            )\n\n        # Almost all of these cache hits are to re-fetch each one of the\n        # invitees.  These happen inside our queue processor for sending\n        # confirmation emails, so they are somewhat difficult to avoid.\n        #\n        # TODO: Mock the call to queue_json_publish, so we can measure the\n        # queue impact separately from the user-perceived impact.\n        self.assert_length(cache_tries, 32)\n\n        # Next get line coverage on bumping a realm's max_invites.\n        realm.date_created = timezone_now()\n        realm.max_invites = site_max + 10\n        realm.save()\n\n        result = try_invite()\n        self.assert_json_success(result)\n\n        # Finally get coverage on the case that OPEN_REALM_CREATION is False.\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            result = self.invite(invitees, [stream_name])\n\n        self.assert_json_success(result)\n\n    def test_invite_user_to_realm_on_manual_license_plan(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        _, ledger = self.subscribe_realm_to_monthly_plan_on_manual_license_management(\n            user.realm, 50, 50\n        )\n\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"alice\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses_at_next_renewal = 5\n        ledger.save(update_fields=[\"licenses_at_next_renewal\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses = get_latest_seat_count(user.realm) + 1\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            invitee_emails = self.nonreg_email(\"bob\") + \",\" + self.nonreg_email(\"alice\")\n            result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"Your organization does not have enough unused Zulip licenses to invite 2 users\"\n        )\n\n        ledger.licenses = get_latest_seat_count(user.realm)\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"All Zulip licenses for this organization are currently in use\"\n        )\n\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(\n                self.nonreg_email(\"bob\"),\n                [\"Denmark\"],\n                invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"],\n            )\n        self.assert_json_success(result)\n\n    def test_cross_realm_bot(self) -> None:\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        cross_realm_bot_email = \"emailgateway@zulip.com\"\n        legit_new_email = \"fred@zulip.com\"\n        invitee_emails = \",\".join([cross_realm_bot_email, legit_new_email])\n\n        result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error(\n            result,\n            \"Some of those addresses are already using Zulip,\"\n            + \" so we didn't send them an invitation.\"\n            + \" We did send invitations to everyone else!\",\n        )\n\n    def test_invite_mirror_dummy_user(self) -> None:\n        \"\"\"\n        A mirror dummy account is a temporary account\n        that we keep in our system if we are mirroring\n        data from something like Zephyr or IRC.\n\n        We want users to eventually just sign up or\n        register for Zulip, in which case we will just\n        fully \"activate\" the account.\n\n        Here we test that you can invite a person who\n        has a mirror dummy account.\n        \"\"\"\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        mirror_user = self.example_user(\"cordelia\")\n        mirror_user.is_mirror_dummy = True\n        mirror_user.save()\n        change_user_is_active(mirror_user, False)\n\n        self.assertEqual(\n            PreregistrationUser.objects.filter(email=mirror_user.email).count(),\n            0,\n        )\n\n        result = self.invite(mirror_user.email, [\"Denmark\"])\n        self.assert_json_success(result)\n\n        prereg_user = PreregistrationUser.objects.get(email=mirror_user.email)\n        assert prereg_user.referred_by is not None and inviter is not None\n        self.assertEqual(\n            prereg_user.referred_by.email,\n            inviter.email,\n        )\n\n    def test_invite_from_now_deactivated_user(self) -> None:\n        \"\"\"\n        While accepting an invitation from a user,\n        processing for a new user account will only\n        be completed if the inviter is not deactivated\n        after sending the invite.\n        \"\"\"\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n        invitee = self.nonreg_email(\"alice\")\n\n        result = self.invite(invitee, [\"Denmark\"])\n        self.assert_json_success(result)\n\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        change_user_is_active(inviter, False)\n        do_create_user(\n            invitee,\n            \"password\",\n            inviter.realm,\n            \"full name\",\n            prereg_user=prereg_user,\n            acting_user=None,\n        )\n\n    def test_successful_invite_user_as_owner_from_owner_account(self) -> None:\n        self.login(\"desdemona\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_invite_user_as_owner_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_error(response, \"Must be an organization owner\")\n\n    def test_successful_invite_user_as_admin_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_admin)\n        self.assertFalse(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_invite_user_as_admin_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_successful_invite_user_as_moderator_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_moderator)\n        self.assertFalse(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_invite_user_as_moderator_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_moderator_from_moderator_account(self) -> None:\n        self.login(\"shiva\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_invalid_type(self) -> None:\n        \"\"\"\n        Test inviting a user as invalid type of user i.e. type of invite_as\n        is not in PreregistrationUser.INVITE_AS\n        \"\"\"\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(invitee, [\"Denmark\"], invite_as=10)\n        self.assert_json_error(response, \"Invalid invite_as\")\n\n    def test_successful_invite_user_as_guest_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_successful_invite_user_as_guest_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_successful_invite_user_with_name(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.check_sent_emails([email])\n\n    def test_successful_invite_user_with_name_and_normal_one(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_successful_invite_users_with_specified_streams(self) -> None:\n        invitee = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        self.login(\"hamlet\")\n\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, realm) for stream_name in stream_names]\n        self.assert_json_success(self.invite(invitee, stream_names))\n        self.assertTrue(find_key_by_email(invitee))\n        self.submit_reg_form_for_user(invitee, \"password\")\n        self.check_user_subscribed_only_to_streams(\"alice\", streams)\n\n        invitee = self.nonreg_email(\"bob\")\n        self.assert_json_success(self.invite(invitee, []))\n        self.assertTrue(find_key_by_email(invitee))\n\n        default_streams = get_default_streams_for_realm(realm.id)\n        self.assert_length(default_streams, 1)\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        # If no streams are provided, user is not subscribed to\n        # default streams as well.\n        self.check_user_subscribed_only_to_streams(\"bob\", [])\n\n    def test_can_invite_others_to_realm(self) -> None:\n        def validation_func(user_profile: UserProfile) -> bool:\n            user_profile.refresh_from_db()\n            return user_profile.can_invite_others_to_realm()\n\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        desdemona = self.example_user(\"desdemona\")\n        self.assertFalse(validation_func(desdemona))\n\n        self.check_has_permission_policies(\"invite_to_realm_policy\", validation_func)\n\n    def test_invite_others_to_realm_setting(self) -> None:\n        \"\"\"\n        The invite_to_realm_policy realm setting works properly.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        self.login(\"desdemona\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_ADMINS_ONLY, acting_user=None\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        # Now verify an administrator can do it\n        self.login(\"iago\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n\n        self.check_sent_emails([email, email2])\n\n        from django.core import mail\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MODERATORS_ONLY, acting_user=None\n        )\n        self.login(\"hamlet\")\n        email = \"carol-test@zulip.com\"\n        email2 = \"earl-test@zulip.com\"\n        invitee = f\"Carol Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n\n        self.login(\"polonius\")\n        email = \"dave-test@zulip.com\"\n        email2 = \"mark-test@zulip.com\"\n        invitee = f\"Dave Test <{email}>, {email2}\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n\n        self.login(\"hamlet\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_FULL_MEMBERS_ONLY, acting_user=None\n        )\n        do_set_realm_property(realm, \"waiting_period_threshold\", 1000, acting_user=None)\n\n        hamlet = self.example_user(\"hamlet\")\n        hamlet.date_joined = timezone_now() - datetime.timedelta(\n            days=(realm.waiting_period_threshold - 1)\n        )\n\n        email = \"issac-test@zulip.com\"\n        email2 = \"steven-test@zulip.com\"\n        invitee = f\"Issac Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(realm, \"waiting_period_threshold\", 0, acting_user=None)\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_invite_user_signup_initial_history(self) -> None:\n        \"\"\"\n        Test that a new user invited to a stream receives some initial\n        history but only from public streams.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        private_stream_name = \"Secret\"\n        self.make_stream(private_stream_name, invite_only=True)\n        self.subscribe(user_profile, private_stream_name)\n        public_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            \"Denmark\",\n            topic_name=\"Public topic\",\n            content=\"Public message\",\n        )\n        secret_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            private_stream_name,\n            topic_name=\"Secret topic\",\n            content=\"Secret message\",\n        )\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee, [private_stream_name, \"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        invitee_msg_ids = [\n            um.message_id for um in UserMessage.objects.filter(user_profile=invitee_profile)\n        ]\n        self.assertTrue(public_msg_id in invitee_msg_ids)\n        self.assertFalse(secret_msg_id in invitee_msg_ids)\n        self.assertFalse(invitee_profile.is_realm_admin)\n\n        invitee_msg, signups_stream_msg, inviter_msg, secret_msg = Message.objects.all().order_by(\n            \"-id\"\n        )[0:4]\n\n        self.assertEqual(secret_msg.id, secret_msg_id)\n\n        self.assertEqual(inviter_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            inviter_msg.content.startswith(\n                f\"alice_zulip.com <`{invitee_profile.email}`> accepted your\",\n            )\n        )\n\n        self.assertEqual(signups_stream_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            signups_stream_msg.content.startswith(\n                f\"@_**alice_zulip.com|{invitee_profile.id}** just signed up\",\n            )\n        )\n\n        self.assertEqual(invitee_msg.sender.email, \"welcome-bot@zulip.com\")\n        self.assertTrue(invitee_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertNotIn(\"demo organization\", invitee_msg.content)\n\n    def test_multi_user_invite(self) -> None:\n        \"\"\"\n        Invites multiple users with a variety of delimiters.\n        \"\"\"\n        self.login(\"hamlet\")\n        # Intentionally use a weird string.\n        self.assert_json_success(\n            self.invite(\n                \"\"\"bob-test@zulip.com,     carol-test@zulip.com,\n            dave-test@zulip.com\n\n\nearl-test@zulip.com\"\"\",\n                [\"Denmark\"],\n            )\n        )\n        for user in (\"bob\", \"carol\", \"dave\", \"earl\"):\n            self.assertTrue(find_key_by_email(f\"{user}-test@zulip.com\"))\n        self.check_sent_emails(\n            [\n                \"bob-test@zulip.com\",\n                \"carol-test@zulip.com\",\n                \"dave-test@zulip.com\",\n                \"earl-test@zulip.com\",\n            ]\n        )\n\n    def test_max_invites_model(self) -> None:\n        realm = get_realm(\"zulip\")\n        self.assertEqual(realm.max_invites, settings.INVITES_DEFAULT_REALM_DAILY_MAX)\n        realm.max_invites = 3\n        realm.save()\n        self.assertEqual(get_realm(\"zulip\").max_invites, 3)\n        realm.max_invites = settings.INVITES_DEFAULT_REALM_DAILY_MAX\n        realm.save()\n\n    def test_invite_too_many_users(self) -> None:\n        # Only a light test of this pathway; e.g. doesn't test that\n        # the limit gets reset after 24 hours\n        self.login(\"iago\")\n        invitee_emails = \"1@zulip.com, 2@zulip.com\"\n        self.invite(invitee_emails, [\"Denmark\"])\n        invitee_emails = \", \".join(str(i) for i in range(get_realm(\"zulip\").max_invites - 1))\n        self.assert_json_error(\n            self.invite(invitee_emails, [\"Denmark\"]),\n            \"To protect users, Zulip limits the number of invitations you can send in one day. Because you have reached the limit, no invitations were sent.\",\n        )\n\n    def test_missing_or_invalid_params(self) -> None:\n        \"\"\"\n        Tests inviting with various missing or invalid parameters.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n\n        self.login(\"hamlet\")\n\n        for address in (\"noatsign.com\", \"outsideyourdomain@example.net\"):\n            self.assert_json_error(\n                self.invite(address, [\"Denmark\"]),\n                \"Some emails did not validate, so we didn't send any invitations.\",\n            )\n        self.check_sent_emails([])\n\n        self.assert_json_error(\n            self.invite(\"\", [\"Denmark\"]), \"You must specify at least one email address.\"\n        )\n        self.check_sent_emails([])\n\n    def test_guest_user_invitation(self) -> None:\n        \"\"\"\n        Guest user can't invite new users\n        \"\"\"\n        self.login(\"polonius\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n        self.assertEqual(find_key_by_email(invitee), None)\n        self.check_sent_emails([])\n\n    def test_invalid_stream(self) -> None:\n        \"\"\"\n        Tests inviting to a non-existent stream.\n        \"\"\"\n        self.login(\"hamlet\")\n        self.assert_json_error(\n            self.invite(\"iago-test@zulip.com\", [\"NotARealStream\"]),\n            f\"Stream does not exist with id: {self.INVALID_STREAM_ID}. No invites were sent.\",\n        )\n        self.check_sent_emails([])\n\n    def test_invite_existing_user(self) -> None:\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        self.login(\"hamlet\")\n\n        hamlet_email = \"hAmLeT@zUlIp.com\"\n        result = self.invite(hamlet_email, [\"Denmark\"])\n        self.assert_json_error(result, \"We weren't able to invite anyone.\")\n\n        self.assertFalse(\n            PreregistrationUser.objects.filter(email__iexact=hamlet_email).exists(),\n        )\n        self.check_sent_emails([])\n\n    def normalize_string(self, s: str) -> str:\n        s = s.strip()\n        return re.sub(r\"\\s+\", \" \", s)\n\n    def test_invite_links_in_name(self) -> None:\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        hamlet = self.example_user(\"hamlet\")\n        self.login_user(hamlet)\n        # Test we properly handle links in user full names\n        do_change_full_name(hamlet, \"</a> https://www.google.com\", hamlet)\n\n        result = self.invite(\"newuser@zulip.com\", [\"Denmark\"])\n        self.assert_json_success(result)\n        self.check_sent_emails([\"newuser@zulip.com\"])\n        from django.core.mail import outbox\n\n        assert isinstance(outbox[0], EmailMultiAlternatives)\n        assert isinstance(outbox[0].alternatives[0][0], str)\n        body = self.normalize_string(outbox[0].alternatives[0][0])\n\n        # Verify that one can't get Zulip to send invitation emails\n        # that third-party products will linkify using the full_name\n        # field, because we've included that field inside the mailto:\n        # link for the sender.\n        self.assertIn(\n            '<a href=\"mailto:hamlet@zulip.com\" style=\"color:#5f5ec7; text-decoration:underline\">&lt;/a&gt; https://www.google.com (hamlet@zulip.com)</a> wants',\n            body,\n        )\n\n        # TODO: Ideally, this test would also test the Invitation\n        # Reminder email generated, but the test setup for that is\n        # annoying.\n\n    def test_invite_some_existing_some_new(self) -> None:\n        \"\"\"\n        If you invite a mix of already existing and new users, invitations are\n        only sent to the new users.\n        \"\"\"\n        self.login(\"hamlet\")\n        existing = [self.example_email(\"hamlet\"), \"othello@zulip.com\"]\n        new = [\"foo-test@zulip.com\", \"bar-test@zulip.com\"]\n        invitee_emails = \"\\n\".join(existing + new)\n        self.assert_json_error(\n            self.invite(invitee_emails, [\"Denmark\"]),\n            \"Some of those addresses are already using Zulip, \\\nso we didn't send them an invitation. We did send invitations to everyone else!\",\n        )\n\n        # We only created accounts for the new users.\n        for email in existing:\n            self.assertRaises(\n                PreregistrationUser.DoesNotExist,\n                lambda: PreregistrationUser.objects.get(email=email),\n            )\n        for email in new:\n            self.assertTrue(PreregistrationUser.objects.get(email=email))\n\n        # We only sent emails to the new users.\n        self.check_sent_emails(new)\n\n        prereg_user = PreregistrationUser.objects.get(email=\"foo-test@zulip.com\")\n        self.assertEqual(prereg_user.email, \"foo-test@zulip.com\")\n\n    def test_invite_outside_domain_in_closed_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = True`, you can't invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_using_disposable_email(self) -> None:\n        \"\"\"\n        In a realm with `disallow_disposable_email_addresses = True`, you can't invite\n        people with a disposable domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_outside_domain_in_open_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = False`, you can invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n    def test_invite_outside_domain_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a different domain from that of the realm\n        when `emails_restricted_to_domains = False`, but `emails_restricted_to_domains` later\n        changes to true, the invitation should succeed but the invitee's signup\n        attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@example.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"only allows users with email addresses\", result)\n\n    def test_disposable_emails_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a disposable email when\n        `disallow_disposable_email_addresses = False`, but\n        later changes to true, the invitation should succeed\n        but the invitee's signup attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@mailnator.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Please sign up using a real email address.\", result)\n\n    def test_invite_with_email_containing_plus_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with an email containing plus when\n        `emails_restricted_to_domains = False`, but later change\n        `emails_restricted_to_domains = True`, the invitation should\n        succeed but the invitee's signup attempt should fail as\n        users are not allowed to sign up using email containing +\n        when the realm is restricted to domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo+label@zulip.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(external_address, \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            \"Zulip Dev, does not allow signups using emails\\n        that contains +\", result\n        )\n\n    def test_invalid_email_check_after_confirming_email(self) -> None:\n        self.login(\"hamlet\")\n        email = \"test@zulip.com\"\n\n        self.assert_json_success(self.invite(email, [\"Denmark\"]))\n\n        obj = Confirmation.objects.get(confirmation_key=find_key_by_email(email))\n        prereg_user = obj.content_object\n        assert prereg_user is not None\n        prereg_user.email = \"invalid.email\"\n        prereg_user.save()\n\n        result = self.submit_reg_form_for_user(email, \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            \"The email address you are trying to sign up with is not valid\", result\n        )\n\n    def test_invite_with_non_ascii_streams(self) -> None:\n        \"\"\"\n        Inviting someone to streams with non-ASCII characters succeeds.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n\n        stream_name = \"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Make sure we're subscribed before inviting someone.\n        self.subscribe(self.example_user(\"hamlet\"), stream_name)\n\n        self.assert_json_success(self.invite(invitee, [stream_name]))\n\n    def test_invitation_reminder_email(self) -> None:\n        from django.core.mail import outbox\n\n        # All users belong to zulip realm\n        referrer_name = \"hamlet\"\n        current_user = self.example_user(referrer_name)\n        self.login_user(current_user)\n        invitee_email = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee_email, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee_email))\n        self.check_sent_emails([invitee_email])\n\n        data = {\"email\": invitee_email, \"referrer_email\": current_user.email}\n        invitee = PreregistrationUser.objects.get(email=data[\"email\"])\n        referrer = self.example_user(referrer_name)\n        validity_in_minutes = 2 * 24 * 60\n        link = create_confirmation_link(\n            invitee, Confirmation.INVITATION, validity_in_minutes=validity_in_minutes\n        )\n        context = common_context(referrer)\n        context.update(\n            activate_url=link,\n            referrer_name=referrer.full_name,\n            referrer_email=referrer.email,\n            referrer_realm_name=referrer.realm.name,\n        )\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now()\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n        email_count = len(outbox)\n        for job in email_jobs_to_deliver:\n            deliver_scheduled_emails(job)\n        self.assert_length(outbox, email_count + 1)\n        self.assertEqual(self.email_envelope_from(outbox[-1]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertIn(FromAddress.NOREPLY, self.email_display_from(outbox[-1]))\n\n        # Now verify that signing up clears invite_reminder emails\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n\n        self.register(invitee_email, \"test\")\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 0)\n\n    def test_no_invitation_reminder_when_link_expires_quickly(self) -> None:\n        self.login(\"hamlet\")\n        # Check invitation reminder email is scheduled with 4 day link expiry\n        self.invite(\"alice@zulip.com\", [\"Denmark\"], invite_expires_in_minutes=4 * 24 * 60)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(type=ScheduledEmail.INVITATION_REMINDER).count(), 1\n        )\n        # Check invitation reminder email is not scheduled with 3 day link expiry\n        self.invite(\"bob@zulip.com\", [\"Denmark\"], invite_expires_in_minutes=3 * 24 * 60)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(type=ScheduledEmail.INVITATION_REMINDER).count(), 1\n        )\n\n    # make sure users can't take a valid confirmation key from another\n    # pathway and use it with the invitation URL route\n    def test_confirmation_key_of_wrong_type(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = url.split(\"/\")[-1]\n\n        # Mainly a test of get_object_from_key, rather than of the invitation pathway\n        with self.assertRaises(ConfirmationKeyError) as cm:\n            get_object_from_key(registration_key, [Confirmation.INVITATION], mark_object_used=True)\n        self.assertEqual(cm.exception.error_type, ConfirmationKeyError.DOES_NOT_EXIST)\n\n        # Verify that using the wrong type doesn't work in the main confirm code path\n        email_change_url = create_confirmation_link(prereg_user, Confirmation.EMAIL_CHANGE)\n        email_change_key = email_change_url.split(\"/\")[-1]\n        result = self.client_post(\"/accounts/register/\", {\"key\": email_change_key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", result\n        )\n\n    def test_confirmation_expired(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        date_sent = timezone_now() - datetime.timedelta(weeks=3)\n        with patch(\"confirmation.models.timezone_now\", return_value=date_sent):\n            url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        key = url.split(\"/\")[-1]\n        confirmation_link_path = \"/\" + url.split(\"/\", 3)[3]\n        # Both the confirmation link and submitting the key to the registration endpoint\n        # directly will return the appropriate error.\n        result = self.client_get(confirmation_link_path)\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n        result = self.client_post(\"/accounts/register/\", {\"key\": key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_never_expire_confirmation_object(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        activation_url = create_confirmation_link(\n            prereg_user, Confirmation.INVITATION, validity_in_minutes=None\n        )\n        confirmation = Confirmation.objects.last()\n        assert confirmation is not None\n        self.assertEqual(confirmation.expiry_date, None)\n        activation_key = activation_url.split(\"/\")[-1]\n        response = self.client_post(\n            \"/accounts/register/\",\n            {\"key\": activation_key, \"from_confirmation\": 1, \"full_nme\": \"alice\"},\n        )\n        self.assertEqual(response.status_code, 200)\n\n    def test_send_more_than_one_invite_to_same_user(self) -> None:\n        self.user_profile = self.example_user(\"iago\")\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, self.user_profile.realm))\n\n        invite_expires_in_minutes = 2 * 24 * 60\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        prereg_user = PreregistrationUser.objects.get(email=\"foo@zulip.com\")\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n\n        # Also send an invite from a different realm.\n        lear = get_realm(\"lear\")\n        lear_user = self.lear_user(\"cordelia\")\n        do_invite_users(\n            lear_user, [\"foo@zulip.com\"], [], invite_expires_in_minutes=invite_expires_in_minutes\n        )\n\n        invites = PreregistrationUser.objects.filter(email__iexact=\"foo@zulip.com\")\n        self.assert_length(invites, 4)\n\n        created_user = do_create_user(\n            \"foo@zulip.com\",\n            \"password\",\n            self.user_profile.realm,\n            \"full name\",\n            prereg_user=prereg_user,\n            acting_user=None,\n        )\n\n        accepted_invite = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_USED\n        )\n        revoked_invites = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_REVOKED\n        )\n        # If a user was invited more than once, when it accepts one invite and register\n        # the others must be canceled.\n        self.assert_length(accepted_invite, 1)\n        self.assertEqual(accepted_invite[0].id, prereg_user.id)\n        self.assertEqual(accepted_invite[0].created_user, created_user)\n\n        expected_revoked_invites = set(invites.exclude(id=prereg_user.id).exclude(realm=lear))\n        self.assertEqual(set(revoked_invites), expected_revoked_invites)\n\n        self.assertEqual(\n            PreregistrationUser.objects.get(email__iexact=\"foo@zulip.com\", realm=lear).status, 0\n        )\n\n        with self.assertRaises(AssertionError):\n            process_new_human_user(created_user, prereg_user)\n\n    def test_confirmation_obj_not_exist_error(self) -> None:\n        \"\"\"Since the key is a param input by the user to the registration endpoint,\n        if it inserts an invalid value, the confirmation object won't be found. This\n        tests if, in that scenario, we handle the exception by redirecting the user to\n        the link_expired page.\n        \"\"\"\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        registration_key = \"invalid_confirmation_key\"\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", response\n        )\n\n        registration_key = confirmation_link.split(\"/\")[-1]\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], response)\n        response = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(response.status_code, 302)\n\n    def test_validate_email_not_already_in_realm(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.submit_reg_form_for_user(email, password, key=registration_key)\n\n        new_prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        new_confirmation_link = create_confirmation_link(\n            new_prereg_user, Confirmation.USER_REGISTRATION\n        )\n        new_registration_key = new_confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": new_registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(\n            response[\"Location\"],\n            reverse(\"login\") + \"?\" + urlencode({\"email\": email, \"already_registered\": 1}),\n        )\n\n    def test_confirmation_key_cant_be_reused(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.submit_reg_form_for_user(email, password, key=registration_key)\n\n        prereg_user.refresh_from_db()\n        self.assertIsNotNone(prereg_user.created_user)\n\n        # Now attempt to re-use the same key.\n        result = self.client_post(\"/accounts/register/\", {\"key\": registration_key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_confirmation_link_in_manual_license_plan(self) -> None:\n        inviter = self.example_user(\"iago\")\n        realm = get_realm(\"zulip\")\n\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver/\")\n\n        # We want to simulate the organization having exactly all their licenses\n        # used, to verify that joining as a regular user is not allowed,\n        # but as a guest still works (guests are free up to a certain number).\n        current_seat_count = get_latest_seat_count(realm)\n        self.subscribe_realm_to_monthly_plan_on_manual_license_management(\n            realm, current_seat_count, current_seat_count\n        )\n\n        email = self.nonreg_email(\"bob\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"bob\"})\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assert_in_success_response(\n            [\"New members cannot join this organization because all Zulip licenses are\"], response\n        )\n\n        guest_prereg_user = PreregistrationUser.objects.create(\n            email=email,\n            referred_by=inviter,\n            realm=realm,\n            invited_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"],\n        )\n        confirmation_link = create_confirmation_link(\n            guest_prereg_user, Confirmation.USER_REGISTRATION\n        )\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver/\")\n\n\nclass InvitationsTestCase(InviteUserBase):\n    def test_do_get_invites_controlled_by_user(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        invite_expires_in_minutes = 2 * 24 * 60\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            user_profile,\n            [\"TestTwo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            hamlet,\n            [\"TestThree@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            othello,\n            [\"TestFour@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            self.mit_user(\"sipbtest\"),\n            [\"TestOne@mit.edu\"],\n            [],\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_create_multiuse_invite_link(\n            user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_minutes\n        )\n        self.assert_length(do_get_invites_controlled_by_user(user_profile), 5)\n        self.assert_length(do_get_invites_controlled_by_user(hamlet), 1)\n        self.assert_length(do_get_invites_controlled_by_user(othello), 1)\n\n    def test_successful_get_open_invitations(self) -> None:\n        \"\"\"\n        A GET call to /json/invites returns all unexpired invitations.\n        \"\"\"\n        active_value = getattr(confirmation_settings, \"STATUS_USED\", \"Wrong\")\n        self.assertNotEqual(active_value, \"Wrong\")\n\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n        self.login_user(user_profile)\n\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        invite_expires_in_minutes = 2 * 24 * 60\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n\n        with patch(\n            \"confirmation.models.timezone_now\",\n            return_value=timezone_now() - datetime.timedelta(days=3),\n        ):\n            do_invite_users(\n                user_profile,\n                [\"TestTwo@zulip.com\"],\n                streams,\n                invite_expires_in_minutes=invite_expires_in_minutes,\n            )\n            do_create_multiuse_invite_link(\n                othello, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_minutes\n            )\n\n        prereg_user_three = PreregistrationUser(\n            email=\"TestThree@zulip.com\", referred_by=user_profile, status=active_value\n        )\n        prereg_user_three.save()\n        create_confirmation_link(\n            prereg_user_three,\n            Confirmation.INVITATION,\n            validity_in_minutes=invite_expires_in_minutes,\n        )\n\n        do_create_multiuse_invite_link(\n            hamlet, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_minutes\n        )\n\n        result = self.client_get(\"/json/invites\")\n        self.assertEqual(result.status_code, 200)\n        invites = orjson.loads(result.content)[\"invites\"]\n        self.assert_length(invites, 2)\n\n        self.assertFalse(invites[0][\"is_multiuse\"])\n        self.assertEqual(invites[0][\"email\"], \"TestOne@zulip.com\")\n        self.assertTrue(invites[1][\"is_multiuse\"])\n        self.assertEqual(invites[1][\"invited_by_user_id\"], hamlet.id)\n\n    def test_get_never_expiring_invitations(self) -> None:\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        with patch(\n            \"confirmation.models.timezone_now\",\n            return_value=timezone_now() - datetime.timedelta(days=1000),\n        ):\n            # Testing the invitation with expiry date set to \"None\" exists\n            # after a large amount of days.\n            do_invite_users(\n                user_profile,\n                [\"TestOne@zulip.com\"],\n                streams,\n                invite_expires_in_minutes=None,\n            )\n            do_invite_users(\n                user_profile,\n                [\"TestTwo@zulip.com\"],\n                streams,\n                invite_expires_in_minutes=100 * 24 * 60,\n            )\n            do_create_multiuse_invite_link(\n                user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], None\n            )\n            do_create_multiuse_invite_link(\n                user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], 100\n            )\n\n        result = self.client_get(\"/json/invites\")\n        self.assertEqual(result.status_code, 200)\n        invites = orjson.loads(result.content)[\"invites\"]\n        # We only get invitations that will never expire because we have mocked time such\n        # that the other invitations are created in the deep past.\n        self.assert_length(invites, 2)\n\n        self.assertFalse(invites[0][\"is_multiuse\"])\n        self.assertEqual(invites[0][\"email\"], \"TestOne@zulip.com\")\n        self.assertEqual(invites[0][\"expiry_date\"], None)\n        self.assertTrue(invites[1][\"is_multiuse\"])\n        self.assertEqual(invites[1][\"invited_by_user_id\"], user_profile.id)\n        self.assertEqual(invites[1][\"expiry_date\"], None)\n\n    def test_successful_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        self.login(\"iago\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify that the scheduled email exists.\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_successful_member_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call from member account to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n\n        # Verify that the scheduled email exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify another non-admin can't delete\n        result = self.api_delete(\n            self.example_user(\"othello\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        # Verify that the scheduled email still exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify deletion works.\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n        owner = self.example_user(\"desdemona\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        result = self.api_delete(\n            self.example_user(\"iago\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_success(result)\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_multiuse_invite(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/multiuse<ID> should delete the\n        multiuse_invite.\n        \"\"\"\n        self.login(\"iago\")\n\n        zulip_realm = get_realm(\"zulip\")\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"hamlet\"), realm=zulip_realm\n        )\n        validity_in_minutes = 2 * 24 * 60\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_minutes=validity_in_minutes\n        )\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(\n            MultiuseInvite.objects.get(id=multiuse_invite.id).status,\n            confirmation_settings.STATUS_REVOKED,\n        )\n        # Test that trying to double-delete fails\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"Invitation has already been revoked\")\n\n        # Test deleting owner mutiuse_invite.\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"desdemona\"),\n            realm=zulip_realm,\n            invited_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"],\n        )\n        validity_in_minutes = 2\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_minutes=validity_in_minutes\n        )\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_success(result)\n        self.assertEqual(\n            MultiuseInvite.objects.get(id=multiuse_invite.id).status,\n            confirmation_settings.STATUS_REVOKED,\n        )\n\n        # Test deleting multiuse invite from another realm\n        mit_realm = get_realm(\"zephyr\")\n        multiuse_invite_in_mit = MultiuseInvite.objects.create(\n            referred_by=self.mit_user(\"sipbtest\"), realm=mit_realm\n        )\n        validity_in_minutes = 2 * 24 * 60\n        create_confirmation_link(\n            multiuse_invite_in_mit,\n            Confirmation.MULTIUSE_INVITE,\n            validity_in_minutes=validity_in_minutes,\n        )\n        error_result = self.client_delete(\n            \"/json/invites/multiuse/\" + str(multiuse_invite_in_mit.id)\n        )\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        non_existent_id = MultiuseInvite.objects.count() + 9999\n        error_result = self.client_delete(f\"/json/invites/multiuse/{non_existent_id}\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_successful_resend_invitation(self) -> None:\n        \"\"\"\n        A POST call to /json/invites/<ID>/resend should send an invitation reminder email\n        and delete any scheduled invitation reminder email.\n        \"\"\"\n        self.login(\"iago\")\n        invitee = \"resend_me@zulip.com\"\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n    def test_successful_member_resend_invitation(self) -> None:\n        \"\"\"A POST call from member a account to /json/invites/<ID>/resend\n        should send an invitation reminder email and delete any\n        scheduled invitation reminder email if they send the invite.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"resend_me@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        # Verify hamlet has only one invitation (Member can resend invitations only sent by him).\n        invitation = PreregistrationUser.objects.filter(referred_by=user_profile)\n        self.assert_length(invitation, 1)\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n        self.logout()\n        self.login(\"othello\")\n        invitee = \"TestOne@zulip.com\"\n        prereg_user_one = PreregistrationUser(email=invitee, referred_by=user_profile)\n        prereg_user_one.save()\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization administrator\")\n\n    def test_resend_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n\n        invitee = \"resend_owner@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        self.check_sent_emails([invitee])\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Test only organization owners can resend owner invitation.\n        self.login(\"iago\")\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_success(result)\n\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n    def test_resend_never_expiring_invitation(self) -> None:\n        self.login(\"iago\")\n        invitee = \"resend@zulip.com\"\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"], None))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_success(result)\n        self.check_sent_emails([invitee])\n\n    def test_accessing_invites_in_another_realm(self) -> None:\n        inviter = UserProfile.objects.exclude(realm=get_realm(\"zulip\")).first()\n        assert inviter is not None\n        prereg_user = PreregistrationUser.objects.create(\n            email=\"email\", referred_by=inviter, realm=inviter.realm\n        )\n        self.login(\"iago\")\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_prereg_user_status(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n\n        inviter = UserProfile.objects.filter(realm=realm).first()\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"key\": registration_key, \"from_confirmation\": \"1\", \"full_name\": \"alice\"},\n        )\n        self.assertEqual(result.status_code, 200)\n        confirmation = Confirmation.objects.get(confirmation_key=registration_key)\n        assert confirmation.content_object is not None\n        prereg_user = confirmation.content_object\n        self.assertEqual(prereg_user.status, 0)\n\n        result = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(result.status_code, 302)\n        prereg_user = PreregistrationUser.objects.get(email=email, referred_by=inviter, realm=realm)\n        self.assertEqual(prereg_user.status, confirmation_settings.STATUS_USED)\n        user = get_user_by_delivery_email(email, realm)\n        self.assertIsNotNone(user)\n        self.assertEqual(user.delivery_email, email)\n\n\nclass InviteeEmailsParserTests(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.email1 = \"email1@zulip.com\"\n        self.email2 = \"email2@zulip.com\"\n        self.email3 = \"email3@zulip.com\"\n\n    def test_if_emails_separated_by_commas_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1} ,{self.email2}, {self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_separated_by_newlines_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1}\\n {self.email2}\\n {self.email3} \"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_from_email_client_separated_by_newlines_are_parsed_correctly(self) -> None:\n        emails_raw = (\n            f\"Email One <{self.email1}>\\nEmailTwo<{self.email2}>\\nEmail Three<{self.email3}>\"\n        )\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_in_mixed_style_are_parsed_correctly(self) -> None:\n        emails_raw = f\"Email One <{self.email1}>,EmailTwo<{self.email2}>\\n{self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n\nclass MultiuseInviteTest(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.realm = get_realm(\"zulip\")\n        self.realm.invite_required = True\n        self.realm.save()\n\n    def generate_multiuse_invite_link(\n        self, streams: Optional[List[Stream]] = None, date_sent: Optional[datetime.datetime] = None\n    ) -> str:\n        invite = MultiuseInvite(realm=self.realm, referred_by=self.example_user(\"iago\"))\n        invite.save()\n\n        if streams is not None:\n            invite.streams.set(streams)\n\n        if date_sent is None:\n            date_sent = timezone_now()\n        validity_in_minutes = 2 * 24 * 60\n        with patch(\"confirmation.models.timezone_now\", return_value=date_sent):\n            return create_confirmation_link(\n                invite, Confirmation.MULTIUSE_INVITE, validity_in_minutes=validity_in_minutes\n            )\n\n    def check_user_able_to_register(self, email: str, invite_link: str) -> None:\n        password = \"password\"\n\n        result = self.client_post(invite_link, {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        # Verify the PreregistrationUser object was set up as expected.\n        prereg_user = PreregistrationUser.objects.last()\n        multiuse_invite = MultiuseInvite.objects.last()\n\n        assert prereg_user is not None\n        self.assertEqual(prereg_user.email, email)\n        self.assertEqual(prereg_user.multiuse_invite, multiuse_invite)\n\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n    def test_valid_multiuse_link(self) -> None:\n        email1 = self.nonreg_email(\"test\")\n        email2 = self.nonreg_email(\"test1\")\n        email3 = self.nonreg_email(\"alice\")\n\n        date_sent = timezone_now() - datetime.timedelta(days=1)\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_able_to_register(email3, invite_link)\n\n    def test_expired_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        date_sent = timezone_now() - datetime.timedelta(\n            days=settings.INVITATION_LINK_VALIDITY_DAYS + 1\n        )\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"The confirmation link has expired or been deactivated.\", result)\n\n    def test_revoked_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        invite_link = self.generate_multiuse_invite_link()\n        multiuse_invite = MultiuseInvite.objects.last()\n        assert multiuse_invite is not None\n        do_revoke_multi_use_invite(multiuse_invite)\n\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"We couldn't find your confirmation link in the system.\", result)\n\n    def test_invalid_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"Whoops. The confirmation link is malformed.\", result)\n\n    def test_invalid_multiuse_link_in_open_realm(self) -> None:\n        self.realm.invite_required = False\n        self.realm.save()\n\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n\n        with patch(\"zerver.views.registration.get_realm_from_request\", return_value=self.realm):\n            with patch(\"zerver.views.registration.get_realm\", return_value=self.realm):\n                self.check_user_able_to_register(email, invite_link)\n\n    def test_multiuse_link_with_specified_streams(self) -> None:\n        name1 = \"newuser\"\n        name2 = \"bob\"\n        name3 = \"alice\"\n        email1 = self.nonreg_email(name1)\n        email2 = self.nonreg_email(name2)\n        email3 = self.nonreg_email(name3)\n\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_subscribed_only_to_streams(name1, streams)\n\n        stream_names = [\"Rome\", \"Verona\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_subscribed_only_to_streams(name2, streams)\n\n        streams = []\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email3, invite_link)\n        # User is not subscribed to default streams as well.\n        self.assert_length(get_default_streams_for_realm(self.realm.id), 1)\n        self.check_user_subscribed_only_to_streams(name3, [])\n\n    def test_multiuse_link_different_realms(self) -> None:\n        \"\"\"\n        Verify that an invitation generated for one realm can't be used\n        to join another.\n        \"\"\"\n        lear_realm = get_realm(\"lear\")\n        self.realm = lear_realm\n        invite_link = self.generate_multiuse_invite_link(streams=[])\n        key = invite_link.split(\"/\")[-2]\n\n        result = self.client_get(f\"/join/{key}/\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", result\n        )\n\n        # Now we want to test the accounts_home function, which can't be used\n        # for the multiuse invite case via an HTTP request, but is still supposed\n        # to do its own verification that the realms match as a hardening measure\n        # against a caller that fails to do that.\n        request = HttpRequest()\n        confirmation = Confirmation.objects.get(confirmation_key=key)\n        multiuse_object = confirmation.content_object\n        with patch(\n            \"zerver.views.registration.get_subdomain\", return_value=\"zulip\"\n        ), self.assertRaises(AssertionError):\n            accounts_home(request, multiuse_object=multiuse_object)\n\n    def test_create_multiuse_link_api_call(self) -> None:\n        self.login(\"iago\")\n\n        result = self.client_post(\n            \"/json/invites/multiuse\", {\"invite_expires_in_minutes\": 2 * 24 * 60}\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_with_specified_streams_api_call(self) -> None:\n        self.login(\"iago\")\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        stream_ids = [stream.id for stream in streams]\n\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n        self.check_user_subscribed_only_to_streams(\"test\", streams)\n\n        self.login(\"iago\")\n        stream_ids = []\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"alice\"), invite_link)\n        # User is not subscribed to default streams as well.\n        self.assert_length(get_default_streams_for_realm(self.realm.id), 1)\n        self.check_user_subscribed_only_to_streams(\"alice\", [])\n\n    def test_only_admin_can_create_multiuse_link_api_call(self) -> None:\n        self.login(\"iago\")\n        # Only admins should be able to create multiuse invites even if\n        # invite_to_realm_policy is set to Realm.POLICY_MEMBERS_ONLY.\n        self.realm.invite_to_realm_policy = Realm.POLICY_MEMBERS_ONLY\n        self.realm.save()\n\n        result = self.client_post(\n            \"/json/invites/multiuse\", {\"invite_expires_in_minutes\": 2 * 24 * 60}\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n        self.login(\"hamlet\")\n        result = self.client_post(\"/json/invites/multiuse\")\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_multiuse_link_for_inviting_as_owner(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_invalid_stream_api_call(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps([54321]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Invalid stream ID 54321. No invites were sent.\")\n\n    def test_create_multiuse_link_invalid_invite_as_api_call(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"GUEST_USER\"] + 1).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Invalid invite_as\")\n\n\nclass EmailUnsubscribeTests(ZulipTestCase):\n    def test_error_unsubscribe(self) -> None:\n        # An invalid unsubscribe token \"test123\" produces an error.\n        result = self.client_get(\"/accounts/unsubscribe/missed_messages/test123\")\n        self.assert_in_response(\"Unknown email unsubscribe request\", result)\n\n        # An unknown message type \"fake\" produces an error.\n        user_profile = self.example_user(\"hamlet\")\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"fake\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assert_in_response(\"Unknown email unsubscribe request\", result)\n\n    def test_message_notification_emails_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in message notification emails\n        that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.enable_offline_email_notifications = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"missed_messages\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_offline_email_notifications)\n\n    def test_welcome_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in welcome e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        # Simulate a new user signing up, which enqueues 2 welcome e-mails.\n        enqueue_welcome_emails(user_profile)\n        self.assertEqual(2, ScheduledEmail.objects.filter(users=user_profile).count())\n\n        # Simulate unsubscribing from the welcome e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"welcome\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The welcome email jobs are no longer scheduled.\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(0, ScheduledEmail.objects.filter(users=user_profile).count())\n\n    def test_digest_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in digest e-mails that you can\n        click even when logged out to stop receiving them.\n\n        Unsubscribing from these emails also dequeues any digest email jobs that\n        have been queued.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_digest_emails)\n\n        # Enqueue a fake digest email.\n        context = {\n            \"name\": \"\",\n            \"realm_uri\": \"\",\n            \"unread_pms\": [],\n            \"hot_conversations\": [],\n            \"new_users\": [],\n            \"new_streams\": {\"plain\": []},\n            \"unsubscribe_link\": \"\",\n        }\n        send_future_email(\n            \"zerver/emails/digest\",\n            user_profile.realm,\n            to_user_ids=[user_profile.id],\n            context=context,\n        )\n\n        self.assertEqual(1, ScheduledEmail.objects.filter(users=user_profile).count())\n\n        # Simulate unsubscribing from digest e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"digest\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The setting is toggled off, and scheduled jobs have been removed.\n        self.assertEqual(result.status_code, 200)\n        # Circumvent user_profile caching.\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_digest_emails)\n        self.assertEqual(0, ScheduledEmail.objects.filter(users=user_profile).count())\n\n    def test_login_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in login\n        e-mails that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.enable_login_emails = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"login\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_login_emails)\n\n    def test_marketing_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in marketing e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_marketing_emails)\n\n        # Simulate unsubscribing from marketing e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"marketing\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assertEqual(result.status_code, 200)\n\n        # Circumvent user_profile caching.\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_marketing_emails)\n\n    def test_marketing_unsubscribe_post(self) -> None:\n        \"\"\"\n        The List-Unsubscribe-Post header lets email clients trigger an\n        automatic unsubscription request via POST (see RFC 8058), so\n        test that too.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_marketing_emails)\n\n        # Simulate unsubscribing from marketing e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"marketing\")\n        client = Client(enforce_csrf_checks=True)\n        result = client.post(\n            urllib.parse.urlparse(unsubscribe_link).path, {\"List-Unsubscribe\": \"One-Click\"}\n        )\n        self.assertEqual(result.status_code, 200)\n\n        # Circumvent user_profile caching.\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_marketing_emails)\n\n\nclass RealmCreationTest(ZulipTestCase):\n    @override_settings(OPEN_REALM_CREATION=True)\n    def check_able_to_create_realm(self, email: str, password: str = \"test\") -> None:\n        internal_realm = get_realm(settings.SYSTEM_BOT_REALM)\n        notification_bot = get_system_bot(settings.NOTIFICATION_BOT, internal_realm.id)\n        signups_stream, _ = create_stream_if_needed(notification_bot.realm, \"signups\")\n\n        string_id = \"zuliptest\"\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Check confirmation email has the correct subject and body, extract\n        # confirmation link and visit it\n        confirmation_url = self.get_confirmation_url_from_outbox(\n            email,\n            email_subject_contains=\"Create your Zulip organization\",\n            email_body_contains=\"You have requested a new Zulip organization\",\n        )\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password, realm_subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(\"http://zuliptest.testserver/accounts/login/subdomain/\")\n        )\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n\n        # Check that user is the owner.\n        self.assertEqual(user.role, UserProfile.ROLE_REALM_OWNER)\n\n        # Check defaults\n        self.assertEqual(realm.org_type, Realm.ORG_TYPES[\"business\"][\"id\"])\n        self.assertEqual(realm.emails_restricted_to_domains, False)\n        self.assertEqual(realm.invite_required, True)\n\n        # Check welcome messages\n        for stream_name, text, message_count in [\n            (Realm.DEFAULT_NOTIFICATION_STREAM_NAME, \"with the topic\", 3),\n            (Realm.INITIAL_PRIVATE_STREAM_NAME, \"private stream\", 1),\n        ]:\n            stream = get_stream(stream_name, realm)\n            recipient = stream.recipient\n            messages = Message.objects.filter(recipient=recipient).order_by(\"date_sent\")\n            self.assert_length(messages, message_count)\n            self.assertIn(text, messages[0].content)\n\n        # Check signup messages\n        recipient = signups_stream.recipient\n        messages = Message.objects.filter(recipient=recipient).order_by(\"id\")\n        self.assert_length(messages, 2)\n        self.assertIn(\"Signups enabled\", messages[0].content)\n        self.assertIn(\"signed up\", messages[1].content)\n        self.assertEqual(\"zuliptest\", messages[1].topic_name())\n\n        realm_creation_audit_log = RealmAuditLog.objects.get(\n            realm=realm, event_type=RealmAuditLog.REALM_CREATED\n        )\n        self.assertEqual(realm_creation_audit_log.acting_user, user)\n        self.assertEqual(realm_creation_audit_log.event_time, realm.date_created)\n\n        # Piggyback a little check for how we handle\n        # empty string_ids.\n        realm.string_id = \"\"\n        self.assertEqual(realm.display_subdomain, \".\")\n\n    def test_create_realm_non_existing_email(self) -> None:\n        self.check_able_to_create_realm(\"user1@test.com\")\n\n    def test_create_realm_existing_email(self) -> None:\n        self.check_able_to_create_realm(\"hamlet@zulip.com\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_create_realm_ldap_email(self) -> None:\n        self.init_default_ldap_database()\n\n        with self.settings(LDAP_EMAIL_ATTR=\"mail\"):\n            self.check_able_to_create_realm(\n                \"newuser_email@zulip.com\", self.ldap_password(\"newuser_with_email\")\n            )\n\n    def test_create_realm_as_system_bot(self) -> None:\n        result = self.client_post(\"/new/\", {\"email\": \"notification-bot@zulip.com\"})\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"notification-bot@zulip.com is reserved for system bots\", result)\n\n    def test_create_realm_no_creation_key(self) -> None:\n        \"\"\"\n        Trying to create a realm without a creation_key should fail when\n        OPEN_REALM_CREATION is false.\n        \"\"\"\n        email = \"user1@test.com\"\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            # Create new realm with the email, but no creation key.\n            result = self.client_post(\"/new/\", {\"email\": email})\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\"Organization creation link required\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_subdomain(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=string_id, realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        self.assertEqual(get_user(email, realm).realm, realm)\n\n        self.assertEqual(realm.name, realm_name)\n        self.assertEqual(realm.subdomain, string_id)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_marketing_emails_enabled(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=True,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertTrue(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True, CORPORATE_ENABLED=False)\n    def test_create_realm_without_prompting_for_marketing_emails(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Simulate the initial POST that is made by confirm-preregistration.js\n        # by triggering submit on confirm_preregistration.html.\n        payload = {\n            \"full_name\": \"\",\n            \"key\": find_key_by_email(email),\n            \"from_confirmation\": \"1\",\n        }\n        result = self.client_post(\"/accounts/register/\", payload)\n        # Assert that the form did not prompt the user for enabling\n        # marketing emails.\n        self.assert_not_in_success_response(['input id=\"id_enable_marketing_emails\"'], result)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertFalse(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_marketing_emails_disabled(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertFalse(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_regular_realm_welcome_bot_pm(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        # Make sure the correct Welcome Bot PM is sent\n        welcome_msg = Message.objects.filter(\n            sender__email=\"welcome-bot@zulip.com\", recipient__type=Recipient.PERSONAL\n        ).latest(\"id\")\n        self.assertTrue(welcome_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertNotIn(\"demo organization\", welcome_msg.content)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_demo_realm_welcome_bot_pm(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n            is_demo_organization=True,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        # Make sure the correct Welcome Bot PM is sent\n        welcome_msg = Message.objects.filter(\n            sender__email=\"welcome-bot@zulip.com\", recipient__type=Recipient.PERSONAL\n        ).latest(\"id\")\n        self.assertTrue(welcome_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertIn(\"demo organization\", welcome_msg.content)\n\n    @override_settings(OPEN_REALM_CREATION=True, FREE_TRIAL_DAYS=30)\n    def test_create_realm_during_free_trial(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=string_id, realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result[\"Location\"], \"http://zuliptest.testserver/upgrade/?onboarding=true\")\n\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assert_in_success_response([\"Not ready to start your trial?\"], result)\n\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        self.assertEqual(get_user(email, realm).realm, realm)\n\n        self.assertEqual(realm.name, realm_name)\n        self.assertEqual(realm.subdomain, string_id)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_two_realms(self) -> None:\n        \"\"\"\n        Verify correct behavior and PreregistrationUser handling when using\n        two pre-generated realm creation links to create two different realms.\n        \"\"\"\n        password = \"test\"\n        first_string_id = \"zuliptest\"\n        second_string_id = \"zuliptest2\"\n        email = \"user1@test.com\"\n        first_realm_name = \"Test\"\n        second_realm_name = \"Test\"\n\n        # Make sure the realms do not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(first_string_id)\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(second_string_id)\n\n        # Now we pre-generate two realm creation links\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        first_confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 1)\n\n        # Get a second realm creation link.\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        second_confirmation_url = self.get_confirmation_url_from_outbox(email)\n\n        self.assertNotEqual(first_confirmation_url, second_confirmation_url)\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 2)\n\n        # Create and verify the first realm\n        result = self.client_get(first_confirmation_url)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=first_string_id,\n            realm_name=first_realm_name,\n            key=first_confirmation_url.split(\"/\")[-1],\n        )\n        self.assertEqual(result.status_code, 302)\n        # Make sure the realm is created\n        realm = get_realm(first_string_id)\n        self.assertEqual(realm.string_id, first_string_id)\n        self.assertEqual(realm.name, first_realm_name)\n\n        # One of the PreregistrationUsers should have been used up:\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 1)\n\n        # Create and verify the second realm\n        result = self.client_get(second_confirmation_url)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=second_string_id,\n            realm_name=second_realm_name,\n            key=second_confirmation_url.split(\"/\")[-1],\n        )\n        self.assertEqual(result.status_code, 302)\n        # Make sure the realm is created\n        realm = get_realm(second_string_id)\n        self.assertEqual(realm.string_id, second_string_id)\n        self.assertEqual(realm.name, second_realm_name)\n\n        # The remaining PreregistrationUser should have been used up:\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 0)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_invalid_email_signup(self) -> None:\n        result = self.client_post(\"/new/\", {\"email\": \"<foo\"})\n        self.assert_in_response(\"Please use your real email address.\", result)\n\n        result = self.client_post(\"/new/\", {\"email\": \"foo\\x00bar\"})\n        self.assert_in_response(\"Please use your real email address.\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_mailinator_signup(self) -> None:\n        result = self.client_post(\"/new/\", {\"email\": \"hi@mailinator.com\"})\n        self.assert_in_response(\"Please use your real email address.\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        errors = {\n            \"id\": \"length 3 or greater\",\n            \"-id\": \"cannot start or end with a\",\n            \"string-ID\": \"lowercase letters\",\n            \"string_id\": \"lowercase letters\",\n            \"stream\": \"unavailable\",\n            \"streams\": \"unavailable\",\n            \"about\": \"unavailable\",\n            \"abouts\": \"unavailable\",\n            \"zephyr\": \"unavailable\",\n        }\n        for string_id, error_msg in errors.items():\n            result = self.submit_reg_form_for_user(\n                email, password, realm_subdomain=string_id, realm_name=realm_name\n            )\n            self.assert_in_response(error_msg, result)\n\n        # test valid subdomain\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"a-0\", realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(\"http://a-0.testserver/accounts/login/subdomain/\")\n        )\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_using_old_subdomain_of_a_realm(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-name\", acting_user=None)\n\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"zulip\", realm_name=realm_name\n        )\n        self.assert_in_response(\"Subdomain unavailable. Please choose a different one.\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(\n                email, password, realm_subdomain=\"\", realm_name=realm_name\n            )\n            self.assert_in_response(\"unavailable\", result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"\", realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(\"http://testserver/accounts/login/subdomain/\")\n        )\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain_option(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                realm_subdomain=\"abcdef\",\n                realm_in_root_domain=\"true\",\n                realm_name=realm_name,\n            )\n            self.assert_in_response(\"unavailable\", result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=\"abcdef\",\n            realm_in_root_domain=\"true\",\n            realm_name=realm_name,\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(\"http://testserver/accounts/login/subdomain/\")\n        )\n\n    def test_is_root_domain_available(self) -> None:\n        self.assertTrue(is_root_domain_available())\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            self.assertFalse(is_root_domain_available())\n        realm = get_realm(\"zulip\")\n        realm.string_id = Realm.SUBDOMAIN_FOR_ROOT_DOMAIN\n        realm.save()\n        self.assertFalse(is_root_domain_available())\n\n    def test_subdomain_check_api(self) -> None:\n        result = self.client_get(\"/json/realm/subdomain/zulip\")\n        self.assert_in_success_response(\n            [\"Subdomain unavailable. Please choose a different one.\"], result\n        )\n\n        result = self.client_get(\"/json/realm/subdomain/zu_lip\")\n        self.assert_in_success_response(\n            [\"Subdomain can only have lowercase letters, numbers, and '-'s.\"], result\n        )\n\n        with self.settings(SOCIAL_AUTH_SUBDOMAIN=\"zulipauth\"):\n            result = self.client_get(\"/json/realm/subdomain/zulipauth\")\n            self.assert_in_success_response(\n                [\"Subdomain unavailable. Please choose a different one.\"], result\n            )\n\n        result = self.client_get(\"/json/realm/subdomain/hufflepuff\")\n        self.assert_in_success_response([\"available\"], result)\n        self.assert_not_in_success_response([\"unavailable\"], result)\n\n    def test_subdomain_check_management_command(self) -> None:\n        # Short names should not work, even with the flag\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"aa\")\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"aa\", allow_reserved_subdomain=True)\n\n        # Malformed names should never work\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"-ba_d-\")\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"-ba_d-\", allow_reserved_subdomain=True)\n\n        with patch(\"zerver.lib.name_restrictions.is_reserved_subdomain\", return_value=False):\n            # Existing realms should never work even if they are not reserved keywords\n            with self.assertRaises(ValidationError):\n                check_subdomain_available(\"zulip\")\n            with self.assertRaises(ValidationError):\n                check_subdomain_available(\"zulip\", allow_reserved_subdomain=True)\n\n        # Reserved ones should only work with the flag\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"stream\")\n        check_subdomain_available(\"stream\", allow_reserved_subdomain=True)\n\n\nclass UserSignUpTest(InviteUserBase):\n    def _assert_redirected_to(self, result: \"TestHttpResponse\", url: str) -> None:\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"LOCATION\"], url)\n\n    def verify_signup(\n        self,\n        *,\n        email: str = \"newguy@zulip.com\",\n        password: Optional[str] = \"newpassword\",\n        full_name: str = \"New user's name\",\n        realm: Optional[Realm] = None,\n        subdomain: Optional[str] = None,\n    ) -> Union[UserProfile, \"TestHttpResponse\"]:\n        \"\"\"Common test function for signup tests.  It is a goal to use this\n        common function for all signup tests to avoid code duplication; doing\n        so will likely require adding new parameters.\"\"\"\n\n        if realm is None:  # nocoverage\n            realm = get_realm(\"zulip\")\n\n        client_kwargs: Dict[str, Any] = {}\n        if subdomain:\n            client_kwargs[\"subdomain\"] = subdomain\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, **client_kwargs)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"], **client_kwargs)\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, **client_kwargs)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS. This should create our\n        # account, log us in, and redirect to the app.\n        result = self.submit_reg_form_for_user(\n            email, password, full_name=full_name, **client_kwargs\n        )\n\n        if result.status_code == 200:\n            # This usually indicated an error returned when submitting the form.\n            # Return the result for the caller to deal with reacting to this, since\n            # in many tests this is expected and the caller wants to assert the content\n            # of the error.\n            return result\n\n        # Verify that we were served a redirect to the app.\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"{realm.uri}/\")\n\n        # Verify that we successfully logged in.\n        user_profile = get_user_by_delivery_email(email, realm)\n        self.assert_logged_in_user_id(user_profile.id)\n        return user_profile\n\n    def test_bad_email_configuration_for_accounts_home(self) -> None:\n        \"\"\"\n        Make sure we redirect for EmailNotDeliveredError.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n\n        smtp_mock = patch(\n            \"zerver.views.registration.send_confirm_registration_email\",\n            side_effect=EmailNotDeliveredError,\n        )\n\n        with smtp_mock, self.assertLogs(level=\"ERROR\") as m:\n            result = self.client_post(\"/accounts/home/\", {\"email\": email})\n\n        self._assert_redirected_to(result, \"/config-error/smtp\")\n        self.assertEqual(m.output, [\"ERROR:root:Error in accounts_home\"])\n\n    def test_bad_email_configuration_for_create_realm(self) -> None:\n        \"\"\"\n        Make sure we redirect for EmailNotDeliveredError.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n\n        smtp_mock = patch(\n            \"zerver.views.registration.send_confirm_registration_email\",\n            side_effect=EmailNotDeliveredError,\n        )\n\n        with smtp_mock, self.assertLogs(level=\"ERROR\") as m:\n            result = self.client_post(\"/new/\", {\"email\": email})\n\n        self._assert_redirected_to(result, \"/config-error/smtp\")\n        self.assertEqual(m.output, [\"ERROR:root:Error in create_realm\"])\n\n    def test_user_default_language_and_timezone(self) -> None:\n        \"\"\"\n        Check if the default language of new user is set using the browser locale\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        timezone = \"America/Denver\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"default_language\", \"de\", acting_user=None)\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(\n            email, password, timezone=timezone, HTTP_ACCEPT_LANGUAGE=\"fr,en;q=0.9\"\n        )\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user(\"newguy\")\n        self.assertNotEqual(user_profile.default_language, realm.default_language)\n        self.assertEqual(user_profile.default_language, \"fr\")\n        self.assertEqual(user_profile.timezone, timezone)\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n    def test_default_language_with_unsupported_browser_locale(self) -> None:\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"default_language\", \"de\", acting_user=None)\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(email, password, HTTP_ACCEPT_LANGUAGE=\"en-IND\")\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user(\"newguy\")\n        self.assertEqual(user_profile.default_language, realm.default_language)\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n    def test_default_twenty_four_hour_time(self) -> None:\n        \"\"\"\n        Check if the default twenty_four_hour_time setting of new user\n        is the default twenty_four_hour_time of the realm.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n        realm_user_default = RealmUserDefault.objects.get(realm=realm)\n        do_set_realm_user_default_setting(\n            realm_user_default, \"twenty_four_hour_time\", True, acting_user=None\n        )\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user(\"newguy\")\n        realm_user_default = RealmUserDefault.objects.get(realm=realm)\n        self.assertEqual(\n            user_profile.twenty_four_hour_time, realm_user_default.twenty_four_hour_time\n        )\n\n    def test_signup_already_active(self) -> None:\n        \"\"\"\n        Check if signing up with an active email redirects to a login page.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result[\"Location\"])\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"You've already registered\", result)\n\n    def test_signup_system_bot(self) -> None:\n        email = \"notification-bot@zulip.com\"\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=\"lear\")\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result[\"Location\"])\n        result = self.client_get(result[\"Location\"])\n\n        # This is not really the right error message, but at least it's an error.\n        self.assert_in_response(\"You've already registered\", result)\n\n    def test_signup_existing_email(self) -> None:\n        \"\"\"\n        Check if signing up with an email used in another realm succeeds.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        self.verify_signup(email=email, realm=get_realm(\"lear\"), subdomain=\"lear\")\n        self.assertEqual(UserProfile.objects.filter(delivery_email=email).count(), 2)\n\n    def test_signup_invalid_name(self) -> None:\n        \"\"\"\n        Check if an invalid name during signup is handled properly.\n        \"\"\"\n\n        result = self.verify_signup(full_name=\"<invalid>\")\n        # _WSGIPatchedWSGIResponse does not exist in Django, thus the inverted isinstance check.\n        assert not isinstance(result, UserProfile)\n        self.assert_in_success_response([\"Invalid characters in name!\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response([\"id_password\", \"id_full_name\"], result)\n\n    def test_signup_without_password(self) -> None:\n        \"\"\"\n        Check if signing up without a password works properly when\n        password_auth_enabled is False.\n        \"\"\"\n        email = self.nonreg_email(\"newuser\")\n        with patch(\"zerver.views.registration.password_auth_enabled\", return_value=False):\n            user_profile = self.verify_signup(email=email, password=None)\n\n        assert isinstance(user_profile, UserProfile)\n        # User should now be logged in.\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_signup_without_full_name(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n        result = self.verify_signup(email=email, password=password, full_name=\"\")\n        # _WSGIPatchedWSGIResponse does not exist in Django, thus the inverted isinstance check.\n        assert not isinstance(result, UserProfile)\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response([\"id_password\", \"id_full_name\"], result)\n\n    def test_signup_email_message_contains_org_header(self) -> None:\n        email = \"newguy@zulip.com\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        from django.core.mail import outbox\n\n        self.assertEqual(outbox[0].extra_headers[\"List-Id\"], \"Zulip Dev <zulip.testserver>\")\n\n    def test_signup_with_full_name(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": password,\n                \"key\": find_key_by_email(email),\n                \"terms\": True,\n                \"full_name\": \"New Guy\",\n                \"from_confirmation\": \"1\",\n            },\n        )\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n    def test_signup_with_weak_password(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        with self.settings(PASSWORD_MIN_LENGTH=6, PASSWORD_MIN_GUESSES=1000):\n            result = self.client_post(\n                \"/accounts/register/\",\n                {\n                    \"password\": \"easy\",\n                    \"key\": find_key_by_email(email),\n                    \"terms\": True,\n                    \"full_name\": \"New Guy\",\n                    \"from_confirmation\": \"1\",\n                },\n            )\n            self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n            result = self.submit_reg_form_for_user(email, \"easy\", full_name=\"New Guy\")\n            self.assert_in_success_response([\"The password is too weak.\"], result)\n            with self.assertRaises(UserProfile.DoesNotExist):\n                # Account wasn't created.\n                get_user(email, get_realm(\"zulip\"))\n\n    def test_signup_with_default_stream_group(self) -> None:\n        # Check if user is subscribed to the streams of default\n        # stream group as well as default streams.\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        default_streams = []\n\n        existing_default_streams = DefaultStream.objects.filter(realm=realm)\n        self.assert_length(existing_default_streams, 1)\n        self.assertEqual(existing_default_streams[0].stream.name, \"Verona\")\n        default_streams.append(existing_default_streams[0].stream)\n\n        for stream_name in [\"venice\", \"rome\"]:\n            stream = get_stream(stream_name, realm)\n            do_add_default_stream(stream)\n            default_streams.append(stream)\n\n        group1_streams = []\n        for stream_name in [\"scotland\", \"denmark\"]:\n            stream = get_stream(stream_name, realm)\n            group1_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 1\", \"group 1 description\", group1_streams)\n\n        result = self.submit_reg_form_for_user(email, password, default_stream_groups=[\"group 1\"])\n        self.check_user_subscribed_only_to_streams(\"newguy\", default_streams + group1_streams)\n\n    def test_signup_two_confirmation_links(self) -> None:\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n        first_confirmation_url = self.get_confirmation_url_from_outbox(email)\n        first_confirmation_key = find_key_by_email(email)\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n        second_confirmation_url = self.get_confirmation_url_from_outbox(email)\n\n        # Sanity check:\n        self.assertNotEqual(first_confirmation_url, second_confirmation_url)\n\n        # Register the account (this will use the second confirmation url):\n        result = self.submit_reg_form_for_user(\n            email, password, full_name=\"New Guy\", from_confirmation=\"1\"\n        )\n        self.assert_in_success_response(\n            [\"We just need you to do one last thing.\", \"New Guy\", email], result\n        )\n        result = self.submit_reg_form_for_user(email, password, full_name=\"New Guy\")\n        user_profile = UserProfile.objects.get(delivery_email=email)\n        self.assertEqual(user_profile.delivery_email, email)\n\n        # Now try to to register using the first confirmation url:\n        result = self.client_get(first_confirmation_url)\n        self.assertEqual(result.status_code, 404)\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": password,\n                \"key\": first_confirmation_key,\n                \"terms\": True,\n                \"full_name\": \"New Guy\",\n                \"from_confirmation\": \"1\",\n            },\n        )\n        # Error page should be displayed\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_signup_with_multiple_default_stream_groups(self) -> None:\n        # Check if user is subscribed to the streams of default\n        # stream groups as well as default streams.\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        DefaultStream.objects.filter(realm=realm).delete()\n        default_streams = []\n        for stream_name in [\"venice\", \"verona\"]:\n            stream = get_stream(stream_name, realm)\n            do_add_default_stream(stream)\n            default_streams.append(stream)\n\n        group1_streams = []\n        for stream_name in [\"scotland\", \"denmark\"]:\n            stream = get_stream(stream_name, realm)\n            group1_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 1\", \"group 1 description\", group1_streams)\n\n        group2_streams = []\n        for stream_name in [\"scotland\", \"rome\"]:\n            stream = get_stream(stream_name, realm)\n            group2_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 2\", \"group 2 description\", group2_streams)\n\n        result = self.submit_reg_form_for_user(\n            email, password, default_stream_groups=[\"group 1\", \"group 2\"]\n        )\n        self.check_user_subscribed_only_to_streams(\n            \"newguy\", list(set(default_streams + group1_streams + group2_streams))\n        )\n\n    def test_signup_without_user_settings_from_another_realm(self) -> None:\n        hamlet_in_zulip = self.example_user(\"hamlet\")\n        email = hamlet_in_zulip.delivery_email\n        password = \"newpassword\"\n        subdomain = \"lear\"\n        realm = get_realm(\"lear\")\n\n        # Make an account in the Zulip realm, but we're not copying from there.\n        hamlet_in_zulip.left_side_userlist = True\n        hamlet_in_zulip.default_language = \"de\"\n        hamlet_in_zulip.emojiset = \"twitter\"\n        hamlet_in_zulip.high_contrast_mode = True\n        hamlet_in_zulip.enter_sends = True\n        hamlet_in_zulip.tutorial_status = UserProfile.TUTORIAL_FINISHED\n        hamlet_in_zulip.save()\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=subdomain)\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"], subdomain=subdomain)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, subdomain=subdomain)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email, password, source_realm_id=\"\", HTTP_HOST=subdomain + \".testserver\"\n        )\n\n        hamlet = get_user(self.example_email(\"hamlet\"), realm)\n        self.assertEqual(hamlet.left_side_userlist, False)\n        self.assertEqual(hamlet.default_language, \"en\")\n        self.assertEqual(hamlet.emojiset, \"google\")\n        self.assertEqual(hamlet.high_contrast_mode, False)\n        self.assertEqual(hamlet.enable_stream_audible_notifications, False)\n        self.assertEqual(hamlet.enter_sends, False)\n        self.assertEqual(hamlet.tutorial_status, UserProfile.TUTORIAL_WAITING)\n\n    def test_signup_with_user_settings_from_another_realm(self) -> None:\n        hamlet_in_zulip = self.example_user(\"hamlet\")\n        email = hamlet_in_zulip.delivery_email\n        password = \"newpassword\"\n        subdomain = \"lear\"\n        lear_realm = get_realm(\"lear\")\n\n        self.login(\"hamlet\")\n        with get_test_image_file(\"img.png\") as image_file:\n            self.client_post(\"/json/users/me/avatar\", {\"file\": image_file})\n        hamlet_in_zulip.refresh_from_db()\n        hamlet_in_zulip.left_side_userlist = True\n        hamlet_in_zulip.default_language = \"de\"\n        hamlet_in_zulip.emojiset = \"twitter\"\n        hamlet_in_zulip.high_contrast_mode = True\n        hamlet_in_zulip.enter_sends = True\n        hamlet_in_zulip.tutorial_status = UserProfile.TUTORIAL_FINISHED\n        hamlet_in_zulip.save()\n\n        # Now we'll be making requests to another subdomain, so we need to logout\n        # to avoid polluting the session in the test environment by still being\n        # logged in.\n        self.logout()\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=subdomain)\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"], subdomain=subdomain)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, subdomain=subdomain)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"password\": password, \"key\": find_key_by_email(email), \"from_confirmation\": \"1\"},\n            subdomain=subdomain,\n        )\n        self.assert_in_success_response(\n            [\n                \"Import settings from existing Zulip account\",\n                \"selected >\\n                            Zulip Dev\",\n                \"We just need you to do one last thing.\",\n            ],\n            result,\n        )\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            source_realm_id=str(hamlet_in_zulip.realm.id),\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n\n        hamlet_in_lear = get_user(email, lear_realm)\n        self.assertEqual(hamlet_in_lear.left_side_userlist, True)\n        self.assertEqual(hamlet_in_lear.default_language, \"de\")\n        self.assertEqual(hamlet_in_lear.emojiset, \"twitter\")\n        self.assertEqual(hamlet_in_lear.high_contrast_mode, True)\n        self.assertEqual(hamlet_in_lear.enter_sends, True)\n        self.assertEqual(hamlet_in_lear.enable_stream_audible_notifications, False)\n        self.assertEqual(hamlet_in_lear.tutorial_status, UserProfile.TUTORIAL_FINISHED)\n\n        zulip_path_id = avatar_disk_path(hamlet_in_zulip)\n        lear_path_id = avatar_disk_path(hamlet_in_lear)\n        with open(zulip_path_id, \"rb\") as f:\n            zulip_avatar_bits = f.read()\n        with open(lear_path_id, \"rb\") as f:\n            lear_avatar_bits = f.read()\n\n        self.assertGreater(len(zulip_avatar_bits), 500)\n        self.assertEqual(zulip_avatar_bits, lear_avatar_bits)\n\n    def test_signup_invalid_subdomain(self) -> None:\n        \"\"\"\n        Check if attempting to authenticate to the wrong subdomain logs an\n        error and redirects.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        def invalid_subdomain(**kwargs: Any) -> Any:\n            return_data = kwargs.get(\"return_data\", {})\n            return_data[\"invalid_subdomain\"] = True\n\n        with patch(\"zerver.views.registration.authenticate\", side_effect=invalid_subdomain):\n            with self.assertLogs(level=\"ERROR\") as m:\n                result = self.client_post(\n                    \"/accounts/register/\",\n                    {\n                        \"password\": password,\n                        \"full_name\": \"New User\",\n                        \"key\": find_key_by_email(email),\n                        \"terms\": True,\n                    },\n                )\n                self.assertEqual(\n                    m.output,\n                    [\"ERROR:root:Subdomain mismatch in registration zulip: newuser@zulip.com\"],\n                )\n        self.assertEqual(result.status_code, 302)\n\n    def test_signup_using_invalid_subdomain_preserves_state_of_form(self) -> None:\n        \"\"\"\n        Check that when we give invalid subdomain and submit the registration form\n        all the values in the form are preserved.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n\n        password = \"test\"\n        email = self.example_email(\"iago\")\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            # Subdomain is already used, by construction.\n            realm_subdomain=realm.string_id,\n            realm_name=realm_name,\n            source_realm_id=str(realm.id),\n        )\n        self.assert_in_success_response(\n            [\n                \"Subdomain unavailable. Please choose a different one.\",\n                \"Zulip Dev\\n\",\n                'value=\"test\"',\n                'name=\"realm_name\"',\n            ],\n            result,\n        )\n\n    def test_replace_subdomain_in_confirmation_link(self) -> None:\n        \"\"\"\n        Check that manually changing the subdomain in a registration\n        confirmation link doesn't allow you to register to a different realm.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        self.client_post(\"/accounts/home/\", {\"email\": email})\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": \"password\",\n                \"key\": find_key_by_email(email),\n                \"terms\": True,\n                \"full_name\": \"New User\",\n                \"from_confirmation\": \"1\",\n            },\n            subdomain=\"zephyr\",\n        )\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"We couldn't find your confirmation link\", result)\n\n    def test_signup_to_realm_on_manual_license_plan(self) -> None:\n        realm = get_realm(\"zulip\")\n        denmark_stream = get_stream(\"Denmark\", realm)\n        realm.signup_notifications_stream = denmark_stream\n        realm.save(update_fields=[\"signup_notifications_stream\"])\n\n        _, ledger = self.subscribe_realm_to_monthly_plan_on_manual_license_management(realm, 5, 5)\n\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertIn(\n                \"New members cannot join this organization because all Zulip licenses\",\n                form.errors[\"email\"][0],\n            )\n            last_message = Message.objects.last()\n            assert last_message is not None\n            self.assertIn(\n                f\"A new member ({self.nonreg_email('test')}) was unable to join your organization because all Zulip\",\n                last_message.content,\n            )\n            self.assertEqual(last_message.recipient.type_id, denmark_stream.id)\n\n        ledger.licenses_at_next_renewal = 50\n        ledger.save(update_fields=[\"licenses_at_next_renewal\"])\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertIn(\n                \"New members cannot join this organization because all Zulip licenses\",\n                form.errors[\"email\"][0],\n            )\n\n        ledger.licenses = 50\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertEqual(form.errors, {})\n\n    def test_failed_signup_due_to_restricted_domain(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"invite_required\", False, acting_user=None)\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n\n        email = \"user@acme.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\n            f\"Your email address, {email}, is not in one of the domains\", form.errors[\"email\"][0]\n        )\n\n    def test_failed_signup_due_to_disposable_email(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.emails_restricted_to_domains = False\n        realm.disallow_disposable_email_addresses = True\n        realm.save()\n\n        email = \"abc@mailnator.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\"Please use your real email address\", form.errors[\"email\"][0])\n\n    def test_failed_signup_due_to_email_containing_plus(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.emails_restricted_to_domains = True\n        realm.save()\n\n        email = \"iago+label@zulip.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\n            \"Email addresses containing + are not allowed in this organization.\",\n            form.errors[\"email\"][0],\n        )\n\n    def test_failed_signup_due_to_invite_required(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save()\n        email = \"user@zulip.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(f\"Please request an invite for {email} from\", form.errors[\"email\"][0])\n\n    def test_failed_signup_due_to_nonexistent_realm(self) -> None:\n        email = \"user@acme.com\"\n        form = HomepageForm({\"email\": email}, realm=None)\n        self.assertIn(\n            f\"organization you are trying to join using {email} does not exist\",\n            form.errors[\"email\"][0],\n        )\n\n    def test_access_signup_page_in_root_domain_without_realm(self) -> None:\n        result = self.client_get(\"/register\", subdomain=\"\", follow=True)\n        self.assert_in_success_response([\"Find your Zulip accounts\"], result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_from_confirmation(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", str(message.body))\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # Full name should be set from LDAP\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            self.assert_in_success_response(\n                [\n                    \"We just need you to do one last thing.\",\n                    \"New LDAP fullname\",\n                    \"newuser@zulip.com\",\n                ],\n                result,\n            )\n\n            # Verify that the user is asked for name\n            self.assert_in_success_response([\"id_full_name\"], result)\n            # Verify that user is asked for its LDAP/Active Directory password.\n            self.assert_in_success_response(\n                [\"Enter your LDAP/Active Directory password.\", \"ldap-password\"], result\n            )\n            self.assert_not_in_success_response([\"id_password\"], result)\n\n            # Test the TypeError exception handler\n            with patch(\n                \"zproject.backends.ZulipLDAPAuthBackendBase.get_mapped_name\", side_effect=TypeError\n            ):\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", \"newuser@zulip.com\"], result\n            )\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipLDAPUserPopulator\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_populate_only_registration_from_confirmation(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", str(message.body))\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_BIND_PASSWORD=\"\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTH_LDAP_USER_DN_TEMPLATE=\"uid=%(user)s,ou=users,dc=zulip,dc=com\",\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # Full name should be set from LDAP\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            self.assert_in_success_response(\n                [\n                    \"We just need you to do one last thing.\",\n                    \"New LDAP fullname\",\n                    \"newuser@zulip.com\",\n                ],\n                result,\n            )\n\n            # Verify that the user is asked for name\n            self.assert_in_success_response([\"id_full_name\"], result)\n            # Verify that user is NOT asked for its LDAP/Active Directory password.\n            # LDAP is not configured for authentication in this test.\n            self.assert_not_in_success_response(\n                [\"Enter your LDAP/Active Directory password.\", \"ldap-password\"], result\n            )\n            # If we were using e.g. the SAML auth backend, there\n            # shouldn't be a password prompt, but since it uses the\n            # EmailAuthBackend, there should be password field here.\n            self.assert_in_success_response([\"id_password\"], result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.SAMLAuthBackend\",\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_email_backend_disabled_bypass_attempt(self) -> None:\n        \"\"\"\n        Tests for the case of LDAP + external auth backend being the ones enabled and\n        a user using the registration page to get a confirmation link and then trying\n        to use it to create a new account with their own email that's not authenticated\n        by either of the backends.\n        \"\"\"\n        email = \"no_such_user_in_ldap@example.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n        full_name = \"New LDAP fullname\"\n\n        result = self.client_post(\"/register/\", {\"email\": email}, subdomain=subdomain)\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(\n                email,\n                None,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", email], result\n            )\n\n            # Submit the final form, attempting to register the user despite\n            # no match in ldap.\n            result = self.submit_reg_form_for_user(\n                email,\n                \"newpassword\",\n                full_name=full_name,\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            # Didn't create an account\n            with self.assertRaises(UserProfile.DoesNotExist):\n                UserProfile.objects.get(delivery_email=email)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(\n                result[\"Location\"], \"/accounts/login/?email=no_such_user_in_ldap%40example.com\"\n            )\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_end_to_end(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n        full_name = \"New LDAP fullname\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            # Full name should be set from LDAP\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", full_name, \"newuser@zulip.com\"], result\n            )\n\n            # Submit the final form with the wrong password.\n            result = self.submit_reg_form_for_user(\n                email,\n                \"wrongpassword\",\n                full_name=full_name,\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            # Didn't create an account\n            with self.assertRaises(UserProfile.DoesNotExist):\n                user_profile = UserProfile.objects.get(delivery_email=email)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"/accounts/login/?email=newuser%40zulip.com\")\n\n            # Submit the final form with the correct password.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=full_name,\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_split_full_name_mapping(self) -> None:\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"first_name\": \"sn\", \"last_name\": \"cn\"}\n\n        subdomain = \"zulip\"\n        email = \"newuser_splitname@zulip.com\"\n        password = self.ldap_password(\"newuser_splitname\")\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            # Test split name mapping.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, \"First Last\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_auto_registration_on_login(self) -> None:\n        \"\"\"The most common way for LDAP authentication to be used is with a\n        server that doesn't have a terms-of-service required, in which\n        case we offer a complete single-sign-on experience (where the\n        user just enters their LDAP username and password, and their\n        account is created if it doesn't already exist).\n\n        This test verifies that flow.\n        \"\"\"\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\n            \"full_name\": \"cn\",\n            \"custom_profile_field__phone_number\": \"homePhone\",\n        }\n        full_name = \"New LDAP fullname\"\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n            # Test custom profile fields are properly synced.\n            phone_number_field = CustomProfileField.objects.get(\n                realm=user_profile.realm, name=\"Phone number\"\n            )\n            phone_number_field_value = CustomProfileFieldValue.objects.get(\n                user_profile=user_profile, field=phone_number_field\n            )\n            self.assertEqual(phone_number_field_value.value, \"a-new-number\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_auto_registration_on_login_invalid_email_in_directory(self) -> None:\n        password = self.ldap_password(\"newuser_with_email\")\n        username = \"newuser_with_email\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n\n        self.change_ldap_user_attr(\"newuser_with_email\", \"mail\", \"thisisnotavalidemail\")\n\n        with self.settings(\n            LDAP_EMAIL_ATTR=\"mail\",\n        ), self.assertLogs(\"zulip.auth.ldap\", \"WARNING\") as mock_log:\n            original_user_count = UserProfile.objects.count()\n            self.login_with_return(username, password, HTTP_HOST=subdomain + \".testserver\")\n            # Verify that the process failed as intended - no UserProfile is created.\n            self.assertEqual(UserProfile.objects.count(), original_user_count)\n            self.assertEqual(\n                mock_log.output,\n                [\"WARNING:zulip.auth.ldap:thisisnotavalidemail is not a valid email address.\"],\n            )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_registration_multiple_realms(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\n            \"full_name\": \"cn\",\n        }\n        do_create_realm(\"test\", \"test\", emails_restricted_to_domains=False)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            subdomain = \"zulip\"\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email, realm=get_realm(\"zulip\"))\n            self.logout()\n\n            # Test registration in another realm works.\n            subdomain = \"test\"\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email, realm=get_realm(\"test\"))\n            self.assertEqual(user_profile.delivery_email, email)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_when_names_changes_are_disabled(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link. This will 'authenticated_full_name'\n            # session variable which will be used to set the fullname of\n            # the user.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            with patch(\"zerver.views.registration.name_changes_disabled\", return_value=True):\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from LDAP session.\n            self.assertEqual(user_profile.full_name, \"New LDAP fullname\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_signup_with_ldap_and_email_enabled_using_email_with_ldap_append_domain(self) -> None:\n        password = \"nonldappassword\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # If the user's email is inside the LDAP directory and we just\n        # have a wrong password, then we refuse to create an account\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because password was wrong\n            self.assertEqual(result[\"Location\"], \"/accounts/login/?email=newuser%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n\n        # For the rest of the test we delete the user from ldap.\n        del self.mock_ldap.directory[\"uid=newuser,ou=users,dc=zulip,dc=com\"]\n\n        # If the user's email is not in the LDAP directory, but fits LDAP_APPEND_DOMAIN,\n        # we refuse to create the account.\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ), self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because emails matching LDAP_APPEND_DOMAIN,\n            # aren't allowed to create non-LDAP accounts.\n            self.assertEqual(result[\"Location\"], \"/accounts/login/?email=newuser%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: newuser. Input username: newuser@zulip.com\"\n                ],\n            )\n\n        # If the email is outside of LDAP_APPEND_DOMAIN, we successfully create a non-LDAP account,\n        # with the password managed in the Zulip database.\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"example.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(level=\"WARNING\") as m:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(result.status_code, 200)\n            self.assertEqual(\n                m.output,\n                [\"WARNING:root:New account email newuser@zulip.com could not be found in LDAP\"],\n            )\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    full_name=\"Non-LDAP Full Name\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: Email newuser@zulip.com does not match LDAP domain example.com.\"\n                ],\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver/\")\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from the POST request, not LDAP\n            self.assertEqual(user_profile.full_name, \"Non-LDAP Full Name\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_signup_with_ldap_and_email_enabled_using_email_with_ldap_email_search(self) -> None:\n        # If the user's email is inside the LDAP directory and we just\n        # have a wrong password, then we refuse to create an account\n        password = \"nonldappassword\"\n        email = \"newuser_email@zulip.com\"  # belongs to user uid=newuser_with_email in the test directory\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because password was wrong\n            self.assertEqual(result[\"Location\"], \"/accounts/login/?email=newuser_email%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n\n        # If the user's email is not in the LDAP directory , though, we\n        # successfully create an account with a password in the Zulip\n        # database.\n        password = \"nonldappassword\"\n        email = \"nonexistent@zulip.com\"\n        subdomain = \"zulip\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(level=\"WARNING\") as m:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n                self.assertEqual(result.status_code, 200)\n                self.assertEqual(\n                    m.output,\n                    [\n                        \"WARNING:root:New account email nonexistent@zulip.com could not be found in LDAP\"\n                    ],\n                )\n\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    full_name=\"Non-LDAP Full Name\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: nonexistent@zulip.com. Input username: nonexistent@zulip.com\"\n                ],\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver/\")\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from the POST request, not LDAP\n            self.assertEqual(user_profile.full_name, \"Non-LDAP Full Name\")\n\n    def ldap_invite_and_signup_as(\n        self, invite_as: int, streams: Sequence[str] = [\"Denmark\"]\n    ) -> None:\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        subdomain = \"zulip\"\n        email = \"newuser@zulip.com\"\n        password = self.ldap_password(\"newuser\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                # Invite user.\n                self.login(\"iago\")\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: iago. Input username: iago@zulip.com\"\n                ],\n            )\n            response = self.invite(\n                invitee_emails=\"newuser@zulip.com\", stream_names=streams, invite_as=invite_as\n            )\n            self.assert_json_success(response)\n            self.logout()\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_user_as_admin(self) -> None:\n        self.ldap_invite_and_signup_as(PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"])\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_realm_admin)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_user_as_guest(self) -> None:\n        self.ldap_invite_and_signup_as(PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_guest)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_streams(self) -> None:\n        stream_name = \"Rome\"\n        realm = get_realm(\"zulip\")\n        stream = get_stream(stream_name, realm)\n        default_streams = get_default_streams_for_realm(realm.id)\n        default_streams_name = [stream.name for stream in default_streams]\n        self.assertNotIn(stream_name, default_streams_name)\n\n        # Invite user.\n        self.ldap_invite_and_signup_as(\n            PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"], streams=[stream_name]\n        )\n\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_realm_admin)\n        sub = get_stream_subscriptions_for_user(user_profile).filter(recipient__type_id=stream.id)\n        self.assert_length(sub, 1)\n\n    def test_registration_when_name_changes_are_disabled(self) -> None:\n        \"\"\"\n        Test `name_changes_disabled` when we are not running under LDAP.\n        \"\"\"\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with patch(\"zerver.views.registration.name_changes_disabled\", return_value=True):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"New Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # 'New Name' comes from POST data; not from LDAP session.\n            self.assertEqual(user_profile.full_name, \"New Name\")\n\n    def test_realm_creation_through_ldap(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm_name = \"Zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", str(message.body))\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n            TERMS_OF_SERVICE_VERSION=1.0,\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            key = find_key_by_email(email)\n            confirmation = Confirmation.objects.get(confirmation_key=key)\n            prereg_user = confirmation.content_object\n            assert prereg_user is not None\n            prereg_user.realm_creation = True\n            prereg_user.save()\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                realm_name=realm_name,\n                realm_subdomain=subdomain,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", \"newuser@zulip.com\"], result\n            )\n\n    @patch(\n        \"DNS.dnslookup\",\n        return_value=[[\"sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh\"]],\n    )\n    def test_registration_of_mirror_dummy_user(self, ignored: Any) -> None:\n        password = \"test\"\n        subdomain = \"zephyr\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.delivery_email\n        user_profile.is_mirror_dummy = True\n        user_profile.save()\n        change_user_is_active(user_profile, False)\n\n        result = self.client_post(\"/register/\", {\"email\": email}, subdomain=\"zephyr\")\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"], subdomain=\"zephyr\")\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", str(message.body))\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        result = self.client_get(confirmation_url, subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 200)\n\n        # If the mirror dummy user is already active, attempting to\n        # submit the registration form should raise an AssertionError\n        # (this is an invalid state, so it's a bug we got here):\n        change_user_is_active(user_profile, True)\n\n        with self.assertRaisesRegex(\n            AssertionError, \"Mirror dummy user is already active!\"\n        ), self.assertLogs(\"django.request\", \"ERROR\") as error_log:\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n        self.assertTrue(\n            \"ERROR:django.request:Internal Server Error: /accounts/register/\" in error_log.output[0]\n        )\n        self.assertTrue(\n            'raise AssertionError(\"Mirror dummy user is already active!' in error_log.output[0]\n        )\n        self.assertTrue(\n            \"AssertionError: Mirror dummy user is already active!\" in error_log.output[0]\n        )\n\n        change_user_is_active(user_profile, False)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            from_confirmation=\"1\",\n            # Pass HTTP_HOST for the target subdomain\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            # Pass HTTP_HOST for the target subdomain\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @patch(\n        \"DNS.dnslookup\",\n        return_value=[[\"sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh\"]],\n    )\n    def test_registration_of_active_mirror_dummy_user(self, ignored: Any) -> None:\n        \"\"\"\n        Trying to activate an already-active mirror dummy user should\n        raise an AssertionError.\n        \"\"\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.delivery_email\n        user_profile.is_mirror_dummy = True\n        user_profile.save()\n        change_user_is_active(user_profile, True)\n\n        with self.assertRaisesRegex(\n            AssertionError, \"Mirror dummy user is already active!\"\n        ), self.assertLogs(\"django.request\", \"ERROR\") as error_log:\n            self.client_post(\"/register/\", {\"email\": email}, subdomain=\"zephyr\")\n        self.assertTrue(\n            \"ERROR:django.request:Internal Server Error: /register/\" in error_log.output[0]\n        )\n        self.assertTrue(\n            'raise AssertionError(\"Mirror dummy user is already active!' in error_log.output[0]\n        )\n        self.assertTrue(\n            \"AssertionError: Mirror dummy user is already active!\" in error_log.output[0]\n        )\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_dev_user_registration(self) -> None:\n        \"\"\"Verify that /devtools/register_user creates a new user, logs them\n        in, and redirects to the logged-in app.\"\"\"\n        count = UserProfile.objects.count()\n        email = f\"user-{count}@zulip.com\"\n\n        result = self.client_post(\"/devtools/register_user/\")\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(user_profile.delivery_email, email)\n        self.assertEqual(result[\"Location\"], \"http://zulip.testserver/\")\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_dev_user_registration_create_realm(self) -> None:\n        count = UserProfile.objects.count()\n        string_id = f\"realm-{count}\"\n\n        result = self.client_post(\"/devtools/register_realm/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(f\"http://{string_id}.testserver/accounts/login/subdomain\")\n        )\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"http://{string_id}.testserver\")\n\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TERMS_OF_SERVICE_VERSION=None)\n    def test_dev_user_registration_create_demo_realm(self) -> None:\n        result = self.client_post(\"/devtools/register_demo_realm/\")\n        self.assertEqual(result.status_code, 302)\n\n        realm = Realm.objects.latest(\"date_created\")\n        self.assertTrue(\n            result[\"Location\"].startswith(\n                f\"http://{realm.string_id}.testserver/accounts/login/subdomain\"\n            )\n        )\n        result = self.client_get(result[\"Location\"], subdomain=realm.string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"http://{realm.string_id}.testserver\")\n\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n        self.assert_logged_in_user_id(user_profile.id)\n\n        expected_deletion_date = realm.date_created + datetime.timedelta(\n            days=settings.DEMO_ORG_DEADLINE_DAYS\n        )\n        self.assertEqual(realm.demo_organization_scheduled_deletion_date, expected_deletion_date)\n\n    def test_get_default_language_for_new_user(self) -> None:\n        realm = get_realm(\"zulip\")\n        req = HostRequestMock()\n        req.META[\"HTTP_ACCEPT_LANGUAGE\"] = \"de,en\"\n        self.assertEqual(get_default_language_for_new_user(req, realm), \"de\")\n\n        do_set_realm_property(realm, \"default_language\", \"hi\", acting_user=None)\n        realm.refresh_from_db()\n        req = HostRequestMock()\n        req.META[\"HTTP_ACCEPT_LANGUAGE\"] = \"de,en\"\n        self.assertEqual(get_default_language_for_new_user(req, realm), \"de\")\n\n        req = HostRequestMock()\n        req.META[\"HTTP_ACCEPT_LANGUAGE\"] = \"\"\n        self.assertEqual(get_default_language_for_new_user(req, realm), \"hi\")\n\n\nclass DeactivateUserTest(ZulipTestCase):\n    def test_deactivate_user(self) -> None:\n        user = self.example_user(\"hamlet\")\n        email = user.email\n        self.login_user(user)\n        self.assertTrue(user.is_active)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_success(result)\n        user = self.example_user(\"hamlet\")\n        self.assertFalse(user.is_active)\n        password = initial_password(email)\n        assert password is not None\n        self.assert_login_failure(email, password=password)\n\n    def test_do_not_deactivate_final_owner(self) -> None:\n        user = self.example_user(\"desdemona\")\n        user_2 = self.example_user(\"iago\")\n        self.login_user(user)\n        self.assertTrue(user.is_active)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_error(result, \"Cannot deactivate the only organization owner.\")\n        user = self.example_user(\"desdemona\")\n        self.assertTrue(user.is_active)\n        self.assertTrue(user.is_realm_owner)\n        do_change_user_role(user_2, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n        self.assertTrue(user_2.is_realm_owner)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_success(result)\n        do_change_user_role(user, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n\n    def test_do_not_deactivate_final_user(self) -> None:\n        realm = get_realm(\"zulip\")\n        for user_profile in UserProfile.objects.filter(realm=realm).exclude(\n            role=UserProfile.ROLE_REALM_OWNER\n        ):\n            do_deactivate_user(user_profile, acting_user=None)\n        user = self.example_user(\"desdemona\")\n        self.login_user(user)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_error(result, \"Cannot deactivate the only user.\")\n\n\nclass TestLoginPage(ZulipTestCase):\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_redirects_for_root_alias(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"/accounts/go/?next=%2Fupgrade%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_redirects_for_root_domain(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"/accounts/go/?next=%2Fupgrade%2F\")\n\n        mock_get_host.return_value = \"www.zulip.example.com\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n            EXTERNAL_HOST=\"www.zulip.example.com\",\n            ROOT_SUBDOMAIN_ALIASES=[\"test\"],\n        ):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"/accounts/go/?next=%2Fupgrade%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_works_without_subdomains(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"www\"]):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"www\"]):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n    def test_login_page_registration_hint(self) -> None:\n        response = self.client_get(\"/login/\")\n        self.assert_not_in_success_response(\n            [\"Don't have an account yet? You need to be invited to join this organization.\"],\n            response,\n        )\n\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save(update_fields=[\"invite_required\"])\n        response = self.client_get(\"/login/\")\n        self.assert_in_success_response(\n            [\"Don't have an account yet? You need to be invited to join this organization.\"],\n            response,\n        )\n\n    @patch(\"django.http.HttpRequest.get_host\", return_value=\"auth.testserver\")\n    def test_social_auth_subdomain_login_page(self, mock_get_host: MagicMock) -> None:\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Authentication subdomain\", result)\n\n        zulip_realm = get_realm(\"zulip\")\n        session = self.client.session\n        session[\"subdomain\"] = \"zulip\"\n        session.save()\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], zulip_realm.uri)\n\n        session = self.client.session\n        session[\"subdomain\"] = \"invalid\"\n        session.save()\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Authentication subdomain\", result)\n\n    def test_login_page_is_deactivated_validation(self) -> None:\n        with patch(\"zerver.views.auth.logging.info\") as mock_info:\n            result = self.client_get(\"/login/?is_deactivated=invalid_email\")\n            mock_info.assert_called_once()\n            self.assert_not_in_success_response([\"invalid_email\"], result)\n\n\nclass TestFindMyTeam(ZulipTestCase):\n    def test_template(self) -> None:\n        result = self.client_get(\"/accounts/find/\")\n        self.assertIn(\"Find your Zulip accounts\", result.content.decode())\n\n    def test_result(self) -> None:\n        # We capitalize a letter in cordelia's email to test that the search is case-insensitive.\n        result = self.client_post(\n            \"/accounts/find/\", dict(emails=\"iago@zulip.com,cordeliA@zulip.com\")\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\n            result[\"Location\"], \"/accounts/find/?emails=iago%40zulip.com%2CcordeliA%40zulip.com\"\n        )\n        result = self.client_get(result[\"Location\"])\n        content = result.content.decode()\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(\"iago@zulip.com\", content)\n        self.assertIn(\"cordeliA@zulip.com\", content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 2)\n        iago_message = outbox[1]\n        cordelia_message = outbox[0]\n        self.assertIn(\"Zulip Dev\", iago_message.body)\n        self.assertNotIn(\"Lear & Co\", iago_message.body)\n        self.assertIn(\"Zulip Dev\", cordelia_message.body)\n        self.assertIn(\"Lear & Co\", cordelia_message.body)\n\n    def test_find_team_ignore_invalid_email(self) -> None:\n        result = self.client_post(\n            \"/accounts/find/\", dict(emails=\"iago@zulip.com,invalid_email@zulip.com\")\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\n            result[\"Location\"],\n            \"/accounts/find/?emails=iago%40zulip.com%2Cinvalid_email%40zulip.com\",\n        )\n        result = self.client_get(result[\"Location\"])\n        content = result.content.decode()\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(self.example_email(\"iago\"), content)\n        self.assertIn(\"invalid_email@\", content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 1)\n\n    def test_find_team_reject_invalid_email(self) -> None:\n        result = self.client_post(\"/accounts/find/\", dict(emails=\"invalid_string\"))\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(b\"Enter a valid email\", result.content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n        # Just for coverage on perhaps-unnecessary validation code.\n        result = self.client_get(\"/accounts/find/\", {\"emails\": \"invalid\"})\n        self.assertEqual(result.status_code, 200)\n\n    def test_find_team_zero_emails(self) -> None:\n        data = {\"emails\": \"\"}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertIn(\"This field is required\", result.content.decode())\n        self.assertEqual(result.status_code, 200)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_one_email(self) -> None:\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 1)\n\n    def test_find_team_deactivated_user(self) -> None:\n        do_deactivate_user(self.example_user(\"hamlet\"), acting_user=None)\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_deactivated_realm(self) -> None:\n        do_deactivate_realm(get_realm(\"zulip\"), acting_user=None)\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_bot_email(self) -> None:\n        data = {\"emails\": self.example_email(\"webhook_bot\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"/accounts/find/?emails=webhook-bot%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_more_than_ten_emails(self) -> None:\n        data = {\"emails\": \",\".join(f\"hamlet-{i}@zulip.com\" for i in range(11))}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(\"Please enter at most 10\", result.content.decode())\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n\nclass ConfirmationKeyTest(ZulipTestCase):\n    def test_confirmation_key(self) -> None:\n        request = MagicMock()\n        request.session = {\n            \"confirmation_key\": {\"confirmation_key\": \"xyzzy\"},\n        }\n        result = confirmation_key(request)\n        self.assert_json_success(result)\n        self.assert_in_response(\"xyzzy\", result)\n\n\nclass MobileAuthOTPTest(ZulipTestCase):\n    def test_xor_hex_strings(self) -> None:\n        self.assertEqual(xor_hex_strings(\"1237c81ab\", \"18989fd12\"), \"0aaf57cb9\")\n        with self.assertRaises(AssertionError):\n            xor_hex_strings(\"1\", \"31\")\n\n    def test_is_valid_otp(self) -> None:\n        self.assertEqual(is_valid_otp(\"1234\"), False)\n        self.assertEqual(is_valid_otp(\"1234abcd\" * 8), True)\n        self.assertEqual(is_valid_otp(\"1234abcZ\" * 8), False)\n\n    def test_ascii_to_hex(self) -> None:\n        self.assertEqual(ascii_to_hex(\"ZcdR1234\"), \"5a63645231323334\")\n        self.assertEqual(hex_to_ascii(\"5a63645231323334\"), \"ZcdR1234\")\n\n    def test_otp_encrypt_api_key(self) -> None:\n        api_key = \"12ac\" * 8\n        otp = \"7be38894\" * 8\n        result = otp_encrypt_api_key(api_key, otp)\n        self.assertEqual(result, \"4ad1e9f7\" * 8)\n\n        decrypted = otp_decrypt_api_key(result, otp)\n        self.assertEqual(decrypted, api_key)\n\n\nclass FollowupEmailTest(ZulipTestCase):\n    def test_followup_day2_email(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        # Test date_joined == Sunday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 7, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=2, hours=-1)\n        )\n        # Test date_joined == Tuesday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 2, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=2, hours=-1)\n        )\n        # Test date_joined == Thursday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 4, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=1, hours=-1)\n        )\n        # Test date_joined == Friday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 5, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=3, hours=-1)\n        )\n\n        # Time offset of America/Phoenix is -07:00\n        user_profile.timezone = \"America/Phoenix\"\n        # Test date_joined == Friday in UTC, but Thursday in the user's time zone\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 5, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=1, hours=-1)\n        )\n\n\nclass NoReplyEmailTest(ZulipTestCase):\n    def test_noreply_email_address(self) -> None:\n        self.assertTrue(\n            re.search(self.TOKENIZED_NOREPLY_REGEX, FromAddress.tokenized_no_reply_address())\n        )\n\n        with self.settings(ADD_TOKENS_TO_NOREPLY_ADDRESS=False):\n            self.assertEqual(FromAddress.tokenized_no_reply_address(), \"noreply@testserver\")\n\n\nclass TwoFactorAuthTest(ZulipTestCase):\n    @patch(\"two_factor.plugins.phonenumber.models.totp\")\n    def test_two_factor_login(self, mock_totp: MagicMock) -> None:\n        token = 123456\n        email = self.example_email(\"hamlet\")\n        password = self.ldap_password(\"hamlet\")\n\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.set_password(password)\n        user_profile.save()\n        self.create_default_device(user_profile)\n\n        def totp(*args: Any, **kwargs: Any) -> int:\n            return token\n\n        mock_totp.side_effect = totp\n\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.EmailAuthBackend\",),\n            TWO_FACTOR_CALL_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_SMS_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_AUTHENTICATION_ENABLED=True,\n        ):\n            first_step_data = {\n                \"username\": email,\n                \"password\": password,\n                \"two_factor_login_view-current_step\": \"auth\",\n            }\n            with self.assertLogs(\"two_factor.gateways.fake\", \"INFO\") as info_logs:\n                result = self.client_post(\"/accounts/login/\", first_step_data)\n            self.assertEqual(\n                info_logs.output,\n                ['INFO:two_factor.gateways.fake:Fake SMS to +12125550100: \"Your token is: 123456\"'],\n            )\n            self.assertEqual(result.status_code, 200)\n\n            second_step_data = {\n                \"token-otp_token\": str(token),\n                \"two_factor_login_view-current_step\": \"token\",\n            }\n            result = self.client_post(\"/accounts/login/\", second_step_data)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n            # Going to login page should redirect to '/' if user is already\n            # logged in.\n            result = self.client_get(\"/accounts/login/\")\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n\nclass NameRestrictionsTest(ZulipTestCase):\n    def test_whitelisted_disposable_domains(self) -> None:\n        self.assertFalse(is_disposable_domain(\"OPayQ.com\"))\n\n\nclass RealmRedirectTest(ZulipTestCase):\n    def test_realm_redirect_without_next_param(self) -> None:\n        result = self.client_get(\"/accounts/go/\")\n        self.assert_in_success_response([\"Enter your organization's Zulip URL\"], result)\n\n        result = self.client_post(\"/accounts/go/\", {\"subdomain\": \"zephyr\"})\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://zephyr.testserver\")\n\n        result = self.client_post(\"/accounts/go/\", {\"subdomain\": \"invalid\"})\n        self.assert_in_success_response([\"We couldn&#39;t find that Zulip organization.\"], result)\n\n    def test_realm_redirect_with_next_param(self) -> None:\n        result = self.client_get(\"/accounts/go/\", {\"next\": \"billing\"})\n        self.assert_in_success_response(\n            [\"Enter your organization's Zulip URL\", 'action=\"/accounts/go/?next=billing\"'], result\n        )\n\n        result = self.client_post(\"/accounts/go/?next=billing\", {\"subdomain\": \"lear\"})\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://lear.testserver/billing\")\n", "import logging\nimport urllib\nfrom typing import Any, Dict, Iterable, List, Optional\nfrom urllib.parse import urlencode\n\nfrom django.conf import settings\nfrom django.contrib.auth import authenticate, get_backends\nfrom django.contrib.sessions.backends.base import SessionBase\nfrom django.core import validators\nfrom django.core.exceptions import ValidationError\nfrom django.db.models import Q\nfrom django.http import HttpRequest, HttpResponse, HttpResponseRedirect\nfrom django.shortcuts import redirect, render\nfrom django.urls import reverse\nfrom django.utils.translation import get_language\nfrom django_auth_ldap.backend import LDAPBackend, _LDAPUser\n\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyError,\n    RealmCreationKey,\n    create_confirmation_link,\n    get_object_from_key,\n    render_confirmation_key_error,\n    validate_key,\n)\nfrom zerver.actions.create_realm import do_create_realm\nfrom zerver.actions.create_user import do_activate_mirror_dummy_user, do_create_user\nfrom zerver.actions.default_streams import lookup_default_stream_groups\nfrom zerver.actions.user_settings import (\n    do_change_full_name,\n    do_change_password,\n    do_change_user_setting,\n)\nfrom zerver.context_processors import get_realm_from_request, login_context\nfrom zerver.decorator import do_login, require_post\nfrom zerver.forms import (\n    FindMyTeamForm,\n    HomepageForm,\n    RealmCreationForm,\n    RealmRedirectForm,\n    RegistrationForm,\n)\nfrom zerver.lib.email_validation import email_allowed_for_realm, validate_email_not_already_in_realm\nfrom zerver.lib.exceptions import RateLimitedError\nfrom zerver.lib.i18n import get_default_language_for_new_user\nfrom zerver.lib.pysa import mark_sanitized\nfrom zerver.lib.rate_limiter import rate_limit_request_by_ip\nfrom zerver.lib.request import REQ, has_request_variables\nfrom zerver.lib.send_email import EmailNotDeliveredError, FromAddress, send_email\nfrom zerver.lib.sessions import get_expirable_session_var\nfrom zerver.lib.subdomains import get_subdomain, is_root_domain_available\nfrom zerver.lib.url_encoding import append_url_query_string\nfrom zerver.lib.users import get_accounts_for_email\nfrom zerver.lib.validator import to_converted_or_fallback, to_non_negative_int, to_timezone_or_empty\nfrom zerver.lib.zephyr import compute_mit_user_fullname\nfrom zerver.models import (\n    DisposableEmailError,\n    DomainNotAllowedForRealmError,\n    EmailContainsPlusError,\n    MultiuseInvite,\n    PreregistrationUser,\n    Realm,\n    Stream,\n    UserProfile,\n    get_default_stream_groups,\n    get_realm,\n    get_source_profile,\n    get_user_by_delivery_email,\n    name_changes_disabled,\n)\nfrom zerver.views.auth import (\n    create_preregistration_user,\n    finish_desktop_flow,\n    finish_mobile_flow,\n    get_safe_redirect_to,\n    redirect_and_log_into_subdomain,\n    redirect_to_deactivation_notice,\n)\nfrom zproject.backends import (\n    ExternalAuthResult,\n    NoMatchingLDAPUserError,\n    ZulipLDAPAuthBackend,\n    email_auth_enabled,\n    email_belongs_to_ldap,\n    get_external_method_dicts,\n    ldap_auth_enabled,\n    password_auth_enabled,\n)\n\nif settings.BILLING_ENABLED:\n    from corporate.lib.registration import check_spare_licenses_available_for_registering_new_user\n    from corporate.lib.stripe import LicenseLimitError\n\n\n@has_request_variables\ndef get_prereg_key_and_redirect(\n    request: HttpRequest, confirmation_key: str, full_name: Optional[str] = REQ(default=None)\n) -> HttpResponse:\n    \"\"\"\n    The purpose of this little endpoint is primarily to take a GET\n    request to a long URL containing a confirmation key, and render\n    a page that will via JavaScript immediately do a POST request to\n    /accounts/register, so that the user can create their account on\n    a page with a cleaner URL (and with the browser security and UX\n    benefits of an HTTP POST having generated the page).\n\n    The only thing it does before rendering that page is to check\n    the validity of the confirmation link. This is redundant with a\n    similar check in accounts_register, but it provides a slightly nicer\n    user-facing error handling experience if the URL you visited is\n    displayed in the browser. (E.g. you can debug that you\n    accidentally adding an extra character after pasting).\n    \"\"\"\n    try:\n        check_prereg_key(request, confirmation_key)\n    except ConfirmationKeyError as e:\n        return render_confirmation_key_error(request, e)\n\n    return render(\n        request,\n        \"confirmation/confirm_preregistrationuser.html\",\n        context={\"key\": confirmation_key, \"full_name\": full_name},\n    )\n\n\ndef check_prereg_key(request: HttpRequest, confirmation_key: str) -> PreregistrationUser:\n    \"\"\"\n    Checks if the Confirmation key is valid, returning the PreregistrationUser object in case of success\n    and raising an appropriate ConfirmationKeyError otherwise.\n    \"\"\"\n    confirmation_types = [\n        Confirmation.USER_REGISTRATION,\n        Confirmation.INVITATION,\n        Confirmation.REALM_CREATION,\n    ]\n\n    prereg_user = get_object_from_key(confirmation_key, confirmation_types, mark_object_used=False)\n    assert isinstance(prereg_user, PreregistrationUser)\n\n    # Defensive assert to make sure no mix-up in how .status is set leading to re-use\n    # of a PreregistrationUser object.\n    assert prereg_user.created_user is None\n\n    return prereg_user\n\n\n@require_post\n@has_request_variables\ndef accounts_register(\n    request: HttpRequest,\n    key: str = REQ(default=\"\"),\n    timezone: str = REQ(default=\"\", converter=to_timezone_or_empty),\n    from_confirmation: Optional[str] = REQ(default=None),\n    form_full_name: Optional[str] = REQ(\"full_name\", default=None),\n    source_realm_id: Optional[int] = REQ(\n        default=None, converter=to_converted_or_fallback(to_non_negative_int, None)\n    ),\n) -> HttpResponse:\n    try:\n        prereg_user = check_prereg_key(request, key)\n    except ConfirmationKeyError as e:\n        return render_confirmation_key_error(request, e)\n\n    email = prereg_user.email\n    realm_creation = prereg_user.realm_creation\n    password_required = prereg_user.password_required\n\n    role = prereg_user.invited_as\n    if realm_creation:\n        role = UserProfile.ROLE_REALM_OWNER\n\n    try:\n        validators.validate_email(email)\n    except ValidationError:\n        return render(request, \"zerver/invalid_email.html\", context={\"invalid_email\": True})\n\n    if realm_creation:\n        # For creating a new realm, there is no existing realm or domain\n        realm = None\n    else:\n        assert prereg_user.realm is not None\n        if get_subdomain(request) != prereg_user.realm.string_id:\n            return render_confirmation_key_error(\n                request, ConfirmationKeyError(ConfirmationKeyError.DOES_NOT_EXIST)\n            )\n        realm = prereg_user.realm\n        try:\n            email_allowed_for_realm(email, realm)\n        except DomainNotAllowedForRealmError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"closed_domain\": True},\n            )\n        except DisposableEmailError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"disposable_emails_not_allowed\": True},\n            )\n        except EmailContainsPlusError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"email_contains_plus\": True},\n            )\n\n        if realm.deactivated:\n            # The user is trying to register for a deactivated realm. Advise them to\n            # contact support.\n            return redirect_to_deactivation_notice()\n\n        try:\n            validate_email_not_already_in_realm(realm, email)\n        except ValidationError:\n            return redirect_to_email_login_url(email)\n\n        if settings.BILLING_ENABLED:\n            try:\n                check_spare_licenses_available_for_registering_new_user(realm, email, role=role)\n            except LicenseLimitError:\n                return render(request, \"zerver/no_spare_licenses.html\")\n\n    name_validated = False\n    require_ldap_password = False\n\n    if from_confirmation:\n        try:\n            del request.session[\"authenticated_full_name\"]\n        except KeyError:\n            pass\n\n        ldap_full_name = None\n        if settings.POPULATE_PROFILE_VIA_LDAP:\n            # If the user can be found in LDAP, we'll take the full name from the directory,\n            # and further down create a form pre-filled with it.\n            for backend in get_backends():\n                if isinstance(backend, LDAPBackend):\n                    try:\n                        ldap_username = backend.django_to_ldap_username(email)\n                    except NoMatchingLDAPUserError:\n                        logging.warning(\"New account email %s could not be found in LDAP\", email)\n                        break\n\n                    # Note that this `ldap_user` object is not a\n                    # `ZulipLDAPUser` with a `Realm` attached, so\n                    # calling `.populate_user()` on it will crash.\n                    # This is OK, since we're just accessing this user\n                    # to extract its name.\n                    #\n                    # TODO: We should potentially be accessing this\n                    # user to sync its initial avatar and custom\n                    # profile fields as well, if we indeed end up\n                    # creating a user account through this flow,\n                    # rather than waiting until `manage.py\n                    # sync_ldap_user_data` runs to populate it.\n                    ldap_user = _LDAPUser(backend, ldap_username)\n\n                    try:\n                        ldap_full_name = backend.get_mapped_name(ldap_user)\n                    except TypeError:\n                        break\n\n                    # Check whether this is ZulipLDAPAuthBackend,\n                    # which is responsible for authentication and\n                    # requires that LDAP accounts enter their LDAP\n                    # password to register, or ZulipLDAPUserPopulator,\n                    # which just populates UserProfile fields (no auth).\n                    require_ldap_password = isinstance(backend, ZulipLDAPAuthBackend)\n                    break\n\n        if ldap_full_name:\n            # We don't use initial= here, because if the form is\n            # complete (that is, no additional fields need to be\n            # filled out by the user) we want the form to validate,\n            # so they can be directly registered without having to\n            # go through this interstitial.\n            form = RegistrationForm({\"full_name\": ldap_full_name}, realm_creation=realm_creation)\n            request.session[\"authenticated_full_name\"] = ldap_full_name\n            name_validated = True\n        elif realm is not None and realm.is_zephyr_mirror_realm:\n            # For MIT users, we can get an authoritative name from Hesiod.\n            # Technically we should check that this is actually an MIT\n            # realm, but we can cross that bridge if we ever get a non-MIT\n            # zephyr mirroring realm.\n            hesiod_name = compute_mit_user_fullname(email)\n            form = RegistrationForm(\n                initial={\"full_name\": hesiod_name if \"@\" not in hesiod_name else \"\"},\n                realm_creation=realm_creation,\n            )\n            name_validated = True\n        elif prereg_user.full_name:\n            if prereg_user.full_name_validated:\n                request.session[\"authenticated_full_name\"] = prereg_user.full_name\n                name_validated = True\n                form = RegistrationForm(\n                    {\"full_name\": prereg_user.full_name}, realm_creation=realm_creation\n                )\n            else:\n                form = RegistrationForm(\n                    initial={\"full_name\": prereg_user.full_name}, realm_creation=realm_creation\n                )\n        elif form_full_name is not None:\n            form = RegistrationForm(\n                initial={\"full_name\": form_full_name},\n                realm_creation=realm_creation,\n            )\n        else:\n            form = RegistrationForm(realm_creation=realm_creation)\n    else:\n        postdata = request.POST.copy()\n        if name_changes_disabled(realm):\n            # If we populate profile information via LDAP and we have a\n            # verified name from you on file, use that. Otherwise, fall\n            # back to the full name in the request.\n            try:\n                postdata.update(full_name=request.session[\"authenticated_full_name\"])\n                name_validated = True\n            except KeyError:\n                pass\n        form = RegistrationForm(postdata, realm_creation=realm_creation)\n\n    if not (password_auth_enabled(realm) and password_required):\n        form[\"password\"].field.required = False\n\n    if form.is_valid():\n        if password_auth_enabled(realm) and form[\"password\"].field.required:\n            password = form.cleaned_data[\"password\"]\n        else:\n            # If the user wasn't prompted for a password when\n            # completing the authentication form (because they're\n            # signing up with SSO and no password is required), set\n            # the password field to `None` (Which causes Django to\n            # create an unusable password).\n            password = None\n\n        if realm_creation:\n            string_id = form.cleaned_data[\"realm_subdomain\"]\n            realm_name = form.cleaned_data[\"realm_name\"]\n            realm_type = form.cleaned_data[\"realm_type\"]\n            is_demo_org = form.cleaned_data[\"is_demo_organization\"]\n            realm = do_create_realm(\n                string_id, realm_name, org_type=realm_type, is_demo_organization=is_demo_org\n            )\n        assert realm is not None\n\n        full_name = form.cleaned_data[\"full_name\"]\n        enable_marketing_emails = form.cleaned_data[\"enable_marketing_emails\"]\n        default_stream_group_names = request.POST.getlist(\"default_stream_group\")\n        default_stream_groups = lookup_default_stream_groups(default_stream_group_names, realm)\n\n        if source_realm_id is not None:\n            # Non-integer realm_id values like \"string\" are treated\n            # like the \"Do not import\" value of \"\".\n            source_profile: Optional[UserProfile] = get_source_profile(email, source_realm_id)\n        else:\n            source_profile = None\n\n        if not realm_creation:\n            try:\n                existing_user_profile: Optional[UserProfile] = get_user_by_delivery_email(\n                    email, realm\n                )\n            except UserProfile.DoesNotExist:\n                existing_user_profile = None\n        else:\n            existing_user_profile = None\n\n        user_profile: Optional[UserProfile] = None\n        return_data: Dict[str, bool] = {}\n        if ldap_auth_enabled(realm):\n            # If the user was authenticated using an external SSO\n            # mechanism like Google or GitHub auth, then authentication\n            # will have already been done before creating the\n            # PreregistrationUser object with password_required=False, and\n            # so we don't need to worry about passwords.\n            #\n            # If instead the realm is using EmailAuthBackend, we will\n            # set their password above.\n            #\n            # But if the realm is using LDAPAuthBackend, we need to verify\n            # their LDAP password (which will, as a side effect, create\n            # the user account) here using authenticate.\n            # prereg_user.realm_creation carries the information about whether\n            # we're in realm creation mode, and the ldap flow will handle\n            # that and create the user with the appropriate parameters.\n            user = authenticate(\n                request=request,\n                username=email,\n                password=password,\n                realm=realm,\n                prereg_user=prereg_user,\n                return_data=return_data,\n            )\n            if user is None:\n                # This logic is security-sensitive. The user has NOT been successfully authenticated\n                # with LDAP and we need to carefully decide whether they should be permitted to proceed\n                # with account creation anyway or be stopped. There are three scenarios to consider:\n                #\n                # 1. EmailAuthBackend is enabled for the realm. That explicitly means that a user\n                #    with a valid confirmation link should be able to create an account, because\n                #    they were invited or organization permissions allowed sign up.\n                # 2. EmailAuthBackend is disabled - that means the organization wants to be authenticating\n                #    users with an external source (LDAP or one of the ExternalAuthMethods). If the user\n                #    came here through one of the ExternalAuthMethods, their identity can be considered\n                #    verified and account creation can proceed.\n                # 3. EmailAuthBackend is disabled and the user did not come here through an ExternalAuthMethod.\n                #    That means they came here by entering their email address on the registration page\n                #    and clicking the confirmation link received. That means their identity needs to be\n                #    verified with LDAP - and that has just failed above. Thus the account should NOT be\n                #    created.\n                #\n                if email_auth_enabled(realm):\n                    can_use_different_backend = True\n                # We can identify the user came here through an ExternalAuthMethod by password_required\n                # being set to False on the PreregistrationUser object.\n                elif len(get_external_method_dicts(realm)) > 0 and not password_required:\n                    can_use_different_backend = True\n                else:\n                    can_use_different_backend = False\n\n                if settings.LDAP_APPEND_DOMAIN:\n                    # In LDAP_APPEND_DOMAIN configurations, we don't allow making a non-LDAP account\n                    # if the email matches the ldap domain.\n                    can_use_different_backend = can_use_different_backend and (\n                        not email_belongs_to_ldap(realm, email)\n                    )\n                if return_data.get(\"no_matching_ldap_user\") and can_use_different_backend:\n                    # If both the LDAP and Email or Social auth backends are\n                    # enabled, and there's no matching user in the LDAP\n                    # directory then the intent is to create a user in the\n                    # realm with their email outside the LDAP organization\n                    # (with e.g. a password stored in the Zulip database,\n                    # not LDAP).  So we fall through and create the new\n                    # account.\n                    pass\n                else:\n                    # TODO: This probably isn't going to give a\n                    # user-friendly error message, but it doesn't\n                    # particularly matter, because the registration form\n                    # is hidden for most users.\n                    view_url = reverse(\"login\")\n                    query = urlencode({\"email\": email})\n                    redirect_url = append_url_query_string(view_url, query)\n                    return HttpResponseRedirect(redirect_url)\n            else:\n                assert isinstance(user, UserProfile)\n                user_profile = user\n                if not realm_creation:\n                    # Since we'll have created a user, we now just log them in.\n                    return login_and_go_to_home(request, user_profile)\n                # With realm_creation=True, we're going to return further down,\n                # after finishing up the creation process.\n\n        if existing_user_profile is not None and existing_user_profile.is_mirror_dummy:\n            user_profile = existing_user_profile\n            do_activate_mirror_dummy_user(user_profile, acting_user=user_profile)\n            do_change_password(user_profile, password)\n            do_change_full_name(user_profile, full_name, user_profile)\n            do_change_user_setting(user_profile, \"timezone\", timezone, acting_user=user_profile)\n            do_change_user_setting(\n                user_profile,\n                \"default_language\",\n                get_default_language_for_new_user(request, realm),\n                acting_user=None,\n            )\n            # TODO: When we clean up the `do_activate_mirror_dummy_user` code path,\n            # make it respect invited_as_admin / is_realm_admin.\n\n        if user_profile is None:\n            user_profile = do_create_user(\n                email,\n                password,\n                realm,\n                full_name,\n                prereg_user=prereg_user,\n                role=role,\n                tos_version=settings.TERMS_OF_SERVICE_VERSION,\n                timezone=timezone,\n                default_language=get_default_language_for_new_user(request, realm),\n                default_stream_groups=default_stream_groups,\n                source_profile=source_profile,\n                realm_creation=realm_creation,\n                acting_user=None,\n                enable_marketing_emails=enable_marketing_emails,\n            )\n\n        if realm_creation:\n            # Because for realm creation, registration happens on the\n            # root domain, we need to log them into the subdomain for\n            # their new realm.\n            return redirect_and_log_into_subdomain(\n                ExternalAuthResult(user_profile=user_profile, data_dict={\"is_realm_creation\": True})\n            )\n\n        # This dummy_backend check below confirms the user is\n        # authenticating to the correct subdomain.\n        auth_result = authenticate(\n            username=user_profile.delivery_email,\n            realm=realm,\n            return_data=return_data,\n            use_dummy_backend=True,\n        )\n        if return_data.get(\"invalid_subdomain\"):\n            # By construction, this should never happen.\n            logging.error(\n                \"Subdomain mismatch in registration %s: %s\",\n                realm.subdomain,\n                user_profile.delivery_email,\n            )\n            return redirect(\"/\")\n\n        assert isinstance(auth_result, UserProfile)\n        return login_and_go_to_home(request, auth_result)\n\n    return render(\n        request,\n        \"zerver/register.html\",\n        context={\n            \"form\": form,\n            \"email\": email,\n            \"key\": key,\n            \"full_name\": request.session.get(\"authenticated_full_name\", None),\n            \"lock_name\": name_validated and name_changes_disabled(realm),\n            # password_auth_enabled is normally set via our context processor,\n            # but for the registration form, there is no logged in user yet, so\n            # we have to set it here.\n            \"creating_new_team\": realm_creation,\n            \"password_required\": password_auth_enabled(realm) and password_required,\n            \"require_ldap_password\": require_ldap_password,\n            \"password_auth_enabled\": password_auth_enabled(realm),\n            \"root_domain_available\": is_root_domain_available(),\n            \"default_stream_groups\": [] if realm is None else get_default_stream_groups(realm),\n            \"accounts\": get_accounts_for_email(email),\n            \"MAX_REALM_NAME_LENGTH\": str(Realm.MAX_REALM_NAME_LENGTH),\n            \"MAX_NAME_LENGTH\": str(UserProfile.MAX_NAME_LENGTH),\n            \"MAX_PASSWORD_LENGTH\": str(form.MAX_PASSWORD_LENGTH),\n            \"MAX_REALM_SUBDOMAIN_LENGTH\": str(Realm.MAX_REALM_SUBDOMAIN_LENGTH),\n            \"corporate_enabled\": settings.CORPORATE_ENABLED,\n            \"sorted_realm_types\": sorted(\n                Realm.ORG_TYPES.values(), key=lambda d: d[\"display_order\"]\n            ),\n        },\n    )\n\n\ndef login_and_go_to_home(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    mobile_flow_otp = get_expirable_session_var(\n        request.session, \"registration_mobile_flow_otp\", delete=True\n    )\n    desktop_flow_otp = get_expirable_session_var(\n        request.session, \"registration_desktop_flow_otp\", delete=True\n    )\n    if mobile_flow_otp is not None:\n        return finish_mobile_flow(request, user_profile, mobile_flow_otp)\n    elif desktop_flow_otp is not None:\n        return finish_desktop_flow(request, user_profile, desktop_flow_otp)\n\n    do_login(request, user_profile)\n    # Using 'mark_sanitized' to work around false positive where Pysa thinks\n    # that 'user_profile' is user-controlled\n    return HttpResponseRedirect(mark_sanitized(user_profile.realm.uri) + reverse(\"home\"))\n\n\ndef prepare_activation_url(\n    email: str,\n    session: SessionBase,\n    *,\n    realm: Optional[Realm],\n    realm_creation: bool = False,\n    streams: Optional[Iterable[Stream]] = None,\n    invited_as: Optional[int] = None,\n    multiuse_invite: Optional[MultiuseInvite] = None,\n) -> str:\n    \"\"\"\n    Send an email with a confirmation link to the provided e-mail so the user\n    can complete their registration.\n    \"\"\"\n    prereg_user = create_preregistration_user(\n        email, realm, realm_creation, multiuse_invite=multiuse_invite\n    )\n\n    if streams is not None:\n        prereg_user.streams.set(streams)\n\n    if invited_as is not None:\n        prereg_user.invited_as = invited_as\n        prereg_user.save()\n\n    confirmation_type = Confirmation.USER_REGISTRATION\n    if realm_creation:\n        confirmation_type = Confirmation.REALM_CREATION\n\n    activation_url = create_confirmation_link(prereg_user, confirmation_type)\n    if settings.DEVELOPMENT and realm_creation:\n        session[\"confirmation_key\"] = {\"confirmation_key\": activation_url.split(\"/\")[-1]}\n    return activation_url\n\n\ndef send_confirm_registration_email(\n    email: str,\n    activation_url: str,\n    *,\n    realm: Optional[Realm] = None,\n    request: Optional[HttpRequest] = None,\n) -> None:\n    send_email(\n        \"zerver/emails/confirm_registration\",\n        to_emails=[email],\n        from_address=FromAddress.tokenized_no_reply_address(),\n        language=get_language() if request is not None else None,\n        context={\n            \"create_realm\": (realm is None),\n            \"activate_url\": activation_url,\n        },\n        realm=realm,\n        request=request,\n    )\n\n\ndef redirect_to_email_login_url(email: str) -> HttpResponseRedirect:\n    login_url = reverse(\"login\")\n    redirect_url = append_url_query_string(\n        login_url, urlencode({\"email\": email, \"already_registered\": 1})\n    )\n    return HttpResponseRedirect(redirect_url)\n\n\ndef create_realm(request: HttpRequest, creation_key: Optional[str] = None) -> HttpResponse:\n    try:\n        key_record = validate_key(creation_key)\n    except RealmCreationKey.InvalidError:\n        return render(\n            request,\n            \"zerver/realm_creation_link_invalid.html\",\n        )\n    if not settings.OPEN_REALM_CREATION:\n        if key_record is None:\n            return render(\n                request,\n                \"zerver/realm_creation_disabled.html\",\n            )\n\n    # When settings.OPEN_REALM_CREATION is enabled, anyone can create a new realm,\n    # with a few restrictions on their email address.\n    if request.method == \"POST\":\n        form = RealmCreationForm(request.POST)\n        if form.is_valid():\n            try:\n                rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n            except RateLimitedError as e:\n                assert e.secs_to_freedom is not None\n                return render(\n                    request,\n                    \"zerver/rate_limit_exceeded.html\",\n                    context={\"retry_after\": int(e.secs_to_freedom)},\n                    status=429,\n                )\n\n            email = form.cleaned_data[\"email\"]\n            activation_url = prepare_activation_url(\n                email, request.session, realm=None, realm_creation=True\n            )\n            if key_record is not None and key_record.presume_email_valid:\n                # The user has a token created from the server command line;\n                # skip confirming the email is theirs, taking their word for it.\n                # This is essential on first install if the admin hasn't stopped\n                # to configure outbound email up front, or it isn't working yet.\n                key_record.delete()\n                return HttpResponseRedirect(activation_url)\n\n            try:\n                send_confirm_registration_email(email, activation_url, request=request)\n            except EmailNotDeliveredError:\n                logging.error(\"Error in create_realm\")\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            if key_record is not None:\n                key_record.delete()\n            return HttpResponseRedirect(reverse(\"new_realm_send_confirm\", kwargs={\"email\": email}))\n    else:\n        form = RealmCreationForm()\n    return render(\n        request,\n        \"zerver/create_realm.html\",\n        context={\"form\": form, \"current_url\": request.get_full_path},\n    )\n\n\ndef accounts_home(\n    request: HttpRequest,\n    multiuse_object_key: str = \"\",\n    multiuse_object: Optional[MultiuseInvite] = None,\n) -> HttpResponse:\n    try:\n        realm = get_realm(get_subdomain(request))\n    except Realm.DoesNotExist:\n        return HttpResponseRedirect(reverse(find_account))\n    if realm.deactivated:\n        return redirect_to_deactivation_notice()\n\n    from_multiuse_invite = False\n    streams_to_subscribe = None\n    invited_as = None\n\n    if multiuse_object:\n        # multiuse_object's realm should have been validated by the caller,\n        # so this code shouldn't be reachable with a multiuse_object which\n        # has its realm mismatching the realm of the request.\n        assert realm == multiuse_object.realm\n\n        streams_to_subscribe = multiuse_object.streams.all()\n        from_multiuse_invite = True\n        invited_as = multiuse_object.invited_as\n\n    if request.method == \"POST\":\n        form = HomepageForm(\n            request.POST,\n            realm=realm,\n            from_multiuse_invite=from_multiuse_invite,\n            invited_as=invited_as,\n        )\n        if form.is_valid():\n            try:\n                rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n            except RateLimitedError as e:\n                assert e.secs_to_freedom is not None\n                return render(\n                    request,\n                    \"zerver/rate_limit_exceeded.html\",\n                    context={\"retry_after\": int(e.secs_to_freedom)},\n                    status=429,\n                )\n\n            email = form.cleaned_data[\"email\"]\n\n            try:\n                validate_email_not_already_in_realm(realm, email)\n            except ValidationError:\n                return redirect_to_email_login_url(email)\n\n            activation_url = prepare_activation_url(\n                email,\n                request.session,\n                realm=realm,\n                streams=streams_to_subscribe,\n                invited_as=invited_as,\n                multiuse_invite=multiuse_object,\n            )\n            try:\n                send_confirm_registration_email(email, activation_url, request=request, realm=realm)\n            except EmailNotDeliveredError:\n                logging.error(\"Error in accounts_home\")\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            return HttpResponseRedirect(reverse(\"signup_send_confirm\", kwargs={\"email\": email}))\n\n    else:\n        form = HomepageForm(realm=realm)\n    context = login_context(request)\n    context.update(\n        form=form,\n        current_url=request.get_full_path,\n        multiuse_object_key=multiuse_object_key,\n        from_multiuse_invite=from_multiuse_invite,\n    )\n    return render(request, \"zerver/accounts_home.html\", context=context)\n\n\ndef accounts_home_from_multiuse_invite(request: HttpRequest, confirmation_key: str) -> HttpResponse:\n    realm = get_realm_from_request(request)\n    multiuse_object: Optional[MultiuseInvite] = None\n    try:\n        confirmation_obj = get_object_from_key(\n            confirmation_key, [Confirmation.MULTIUSE_INVITE], mark_object_used=False\n        )\n        assert isinstance(confirmation_obj, MultiuseInvite)\n        multiuse_object = confirmation_obj\n        if realm != multiuse_object.realm:\n            return render(request, \"confirmation/link_does_not_exist.html\", status=404)\n        # Required for OAuth 2\n    except ConfirmationKeyError as exception:\n        if realm is None or realm.invite_required:\n            return render_confirmation_key_error(request, exception)\n    return accounts_home(\n        request, multiuse_object_key=confirmation_key, multiuse_object=multiuse_object\n    )\n\n\n@has_request_variables\ndef find_account(\n    request: HttpRequest, raw_emails: Optional[str] = REQ(\"emails\", default=None)\n) -> HttpResponse:\n    url = reverse(\"find_account\")\n\n    emails: List[str] = []\n    if request.method == \"POST\":\n        form = FindMyTeamForm(request.POST)\n        if form.is_valid():\n            emails = form.cleaned_data[\"emails\"]\n            for i in range(len(emails)):\n                try:\n                    rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n                except RateLimitedError as e:\n                    assert e.secs_to_freedom is not None\n                    return render(\n                        request,\n                        \"zerver/rate_limit_exceeded.html\",\n                        context={\"retry_after\": int(e.secs_to_freedom)},\n                        status=429,\n                    )\n\n            # Django doesn't support __iexact__in lookup with EmailField, so we have\n            # to use Qs to get around that without needing to do multiple queries.\n            emails_q = Q()\n            for email in emails:\n                emails_q |= Q(delivery_email__iexact=email)\n\n            user_profiles = UserProfile.objects.filter(\n                emails_q, is_active=True, is_bot=False, realm__deactivated=False\n            )\n\n            # We organize the data in preparation for sending exactly\n            # one outgoing email per provided email address, with each\n            # email listing all of the accounts that email address has\n            # with the current Zulip server.\n            context: Dict[str, Dict[str, Any]] = {}\n            for user in user_profiles:\n                key = user.delivery_email.lower()\n                context.setdefault(key, {})\n                context[key].setdefault(\"realms\", [])\n                context[key][\"realms\"].append(user.realm)\n                context[key][\"external_host\"] = settings.EXTERNAL_HOST\n                # This value will end up being the last user ID among\n                # matching accounts; since it's only used for minor\n                # details like language, that arbitrary choice is OK.\n                context[key][\"to_user_id\"] = user.id\n\n            for delivery_email, realm_context in context.items():\n                realm_context[\"email\"] = delivery_email\n                send_email(\n                    \"zerver/emails/find_team\",\n                    to_user_ids=[realm_context[\"to_user_id\"]],\n                    context=realm_context,\n                    from_address=FromAddress.SUPPORT,\n                    request=request,\n                )\n\n            # Note: Show all the emails in the result otherwise this\n            # feature can be used to ascertain which email addresses\n            # are associated with Zulip.\n            data = urllib.parse.urlencode({\"emails\": \",\".join(emails)})\n            return redirect(append_url_query_string(url, data))\n    else:\n        form = FindMyTeamForm()\n        # The below validation is perhaps unnecessary, in that we\n        # shouldn't get able to get here with an invalid email unless\n        # the user hand-edits the URLs.\n        if raw_emails:\n            for email in raw_emails.split(\",\"):\n                try:\n                    validators.validate_email(email)\n                    emails.append(email)\n                except ValidationError:\n                    pass\n\n    return render(\n        request,\n        \"zerver/find_account.html\",\n        context={\"form\": form, \"current_url\": lambda: url, \"emails\": emails},\n    )\n\n\n@has_request_variables\ndef realm_redirect(request: HttpRequest, next: str = REQ(default=\"\")) -> HttpResponse:\n    if request.method == \"POST\":\n        form = RealmRedirectForm(request.POST)\n        if form.is_valid():\n            subdomain = form.cleaned_data[\"subdomain\"]\n            realm = get_realm(subdomain)\n            redirect_to = get_safe_redirect_to(next, realm.uri)\n            return HttpResponseRedirect(redirect_to)\n    else:\n        form = RealmRedirectForm()\n\n    return render(request, \"zerver/realm_redirect.html\", context={\"form\": form})\n"], "buggy_code_start_loc": [5001, 397], "buggy_code_end_loc": [5001, 400], "fixing_code_start_loc": [5002, 397], "fixing_code_end_loc": [5066, 423], "type": "CWE-862", "message": "Zulip is an open-source team collaboration tool with unique topic-based threading. In the event that 1: `ZulipLDAPAuthBackend` and an external authentication backend (any aside of `ZulipLDAPAuthBackend` and `EmailAuthBackend`) are the only ones enabled in `AUTHENTICATION_BACKENDS` in `/etc/zulip/settings.py` and 2: The organization permissions don't require invitations to join. An attacker can create a new account in the organization with an arbitrary email address in their control that's not in the organization's LDAP directory. The impact is limited to installations which have this specific combination of authentication backends as described above in addition to having `Invitations are required for joining this organization` organization permission disabled. This issue has been addressed in version 6.2. Users are advised to upgrade. Users unable to upgrade may enable the `Invitations are required for joining this organization` organization permission to prevent this issue.", "other": {"cve": {"id": "CVE-2023-28623", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-19T22:15:09.217", "lastModified": "2023-05-26T17:25:56.600", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Zulip is an open-source team collaboration tool with unique topic-based threading. In the event that 1: `ZulipLDAPAuthBackend` and an external authentication backend (any aside of `ZulipLDAPAuthBackend` and `EmailAuthBackend`) are the only ones enabled in `AUTHENTICATION_BACKENDS` in `/etc/zulip/settings.py` and 2: The organization permissions don't require invitations to join. An attacker can create a new account in the organization with an arbitrary email address in their control that's not in the organization's LDAP directory. The impact is limited to installations which have this specific combination of authentication backends as described above in addition to having `Invitations are required for joining this organization` organization permission disabled. This issue has been addressed in version 6.2. Users are advised to upgrade. Users unable to upgrade may enable the `Invitations are required for joining this organization` organization permission to prevent this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 4.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}, {"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.2", "matchCriteriaId": "E20F9320-ECEF-463B-82A1-C943B71B5C7E"}]}]}], "references": [{"url": "https://github.com/zulip/zulip/commit/3df1b4dd7c210c21deb6f829df19412b74573f8d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/zulip/zulip/security/advisories/GHSA-7p62-pjwg-56rv", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zulip/zulip/commit/3df1b4dd7c210c21deb6f829df19412b74573f8d"}}