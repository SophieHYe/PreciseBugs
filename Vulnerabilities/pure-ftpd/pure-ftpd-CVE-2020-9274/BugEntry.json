{"buggy_code": ["/*\n\n0) alias file format.\n alternating lines of alias and dir\n (this enables embedded whitespace in dir and alias without quoting rules)\n optional blank lines\n optional lines beginning with '#' as comments\n (no you can't put a '#' just anywhere)\n\n1) data structure for alias list nodes.\ntypedef struct DirAlias_ {\n       char *alias;\n       char *dir;\n       struct DirAlias *next;\n} DirAlias;\n\n2) init routine\n A) open alias file\n B) while not EOF do\n      read line\n      parse line\n        dir must begin with \"/\"\n      allocate DirAlias and members\n      if tail is NULL then head and tail (global DirAlias_t pointers)\n       are set to member\n      else tail->next is set to member and then tail is set to member\n\n3) lookup routine\n  A) given potential alias return dir or NULL\n     (walk list starting with head looking for match)\n\n4) FTP CWD command mods\n  A) if chdir() fails try alias (use lookup routine)\n\n5) FTP SITE ALIAS command\n  A) list aliases\n\n*/\n\n#include <config.h>\n\n#ifdef WITH_DIRALIASES\n\n#include \"ftpd.h\"\n#include \"messages.h\"\n#include \"diraliases.h\"\n\n#ifdef WITH_DMALLOC\n# include <dmalloc.h>\n#endif\n\nstatic DirAlias *head, *tail;\nstatic signed char aliases_up;\n\n/* returns: 0 on success, -1 on failure */\n\nint init_aliases(void)\n{\n    FILE *fp;\n    char alias[MAXALIASLEN + 1U];\n    char dir[PATH_MAX + 1U];\n\n    if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {\n        return 0;\n    }\n    while (fgets(alias, sizeof alias, fp) != NULL) {\n        if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n            continue;\n        }\n        {\n            char * const z = alias + strlen(alias) - 1U;\n\n            if (*z != '\\n') {\n                goto bad;\n            }\n            *z = 0;\n        }\n        do {\n            if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                goto bad;\n            }\n            {\n                char * const z = dir + strlen(dir) - 1U;\n\n                if (*z == '\\n') {\n                    *z = 0;\n                }\n            }\n        } while (*dir == '#' || *dir == 0);\n        if (head == NULL) {\n            if ((head = tail = malloc(sizeof *head)) == NULL ||\n                (tail->alias = strdup(alias)) == NULL ||\n                (tail->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = NULL;\n        } else {\n            DirAlias *curr;\n\n            if ((curr = malloc(sizeof *curr)) == NULL ||\n                (curr->alias = strdup(alias)) == NULL ||\n                (curr->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = curr;\n            tail = curr;\n        }\n    }\n    fclose(fp);\n    aliases_up++;\n\n    return 0;\n\n    bad:\n    fclose(fp);\n    logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");\n\n    return -1;\n}\n\n\nchar *lookup_alias(const char *alias)\n{\n    const DirAlias *curr = head;\n\n    if (aliases_up == 0) {\n        return NULL;\n    }\n    while (curr != NULL) {\n        if (strcmp(curr->alias, alias) == 0) {\n            return curr->dir;\n        }\n        curr = curr->next;\n    }\n    return NULL;\n}\n\n\nvoid print_aliases(void)\n{\n    const DirAlias *curr = head;\n\n    if (aliases_up == 0) {\n        addreply_noformat(502, MSG_CONF_ERR);\n\n        return;\n    }\n    addreply_noformat(214, MSG_ALIASES_LIST);\n    while (curr != NULL) {\n        char line[MAXALIASLEN + PATH_MAX + 3U];\n\n        snprintf(line, sizeof line, \" %s %s\", curr->alias, curr->dir);\n        addreply_noformat(0, line);\n        curr = curr->next;\n    }\n    addreply_noformat(214, \" \");\n}\n\n#endif\n"], "fixing_code": ["/*\n\n0) alias file format.\n alternating lines of alias and dir\n (this enables embedded whitespace in dir and alias without quoting rules)\n optional blank lines\n optional lines beginning with '#' as comments\n (no you can't put a '#' just anywhere)\n\n1) data structure for alias list nodes.\ntypedef struct DirAlias_ {\n       char *alias;\n       char *dir;\n       struct DirAlias *next;\n} DirAlias;\n\n2) init routine\n A) open alias file\n B) while not EOF do\n      read line\n      parse line\n        dir must begin with \"/\"\n      allocate DirAlias and members\n      if tail is NULL then head and tail (global DirAlias_t pointers)\n       are set to member\n      else tail->next is set to member and then tail is set to member\n\n3) lookup routine\n  A) given potential alias return dir or NULL\n     (walk list starting with head looking for match)\n\n4) FTP CWD command mods\n  A) if chdir() fails try alias (use lookup routine)\n\n5) FTP SITE ALIAS command\n  A) list aliases\n\n*/\n\n#include <config.h>\n\n#ifdef WITH_DIRALIASES\n\n#include \"ftpd.h\"\n#include \"messages.h\"\n#include \"diraliases.h\"\n\n#ifdef WITH_DMALLOC\n# include <dmalloc.h>\n#endif\n\nstatic DirAlias *head, *tail;\nstatic signed char aliases_up;\n\n/* returns: 0 on success, -1 on failure */\n\nint init_aliases(void)\n{\n    FILE *fp;\n    char alias[MAXALIASLEN + 1U];\n    char dir[PATH_MAX + 1U];\n\n    if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {\n        return 0;\n    }\n    while (fgets(alias, sizeof alias, fp) != NULL) {\n        if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n            continue;\n        }\n        {\n            char * const z = alias + strlen(alias) - 1U;\n\n            if (*z != '\\n') {\n                goto bad;\n            }\n            *z = 0;\n        }\n        do {\n            if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                goto bad;\n            }\n            {\n                char * const z = dir + strlen(dir) - 1U;\n\n                if (*z == '\\n') {\n                    *z = 0;\n                }\n            }\n        } while (*dir == '#' || *dir == 0);\n        if (head == NULL) {\n            if ((head = tail = malloc(sizeof *head)) == NULL ||\n                (tail->alias = strdup(alias)) == NULL ||\n                (tail->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n        } else {\n            DirAlias *curr;\n\n            if ((curr = malloc(sizeof *curr)) == NULL ||\n                (curr->alias = strdup(alias)) == NULL ||\n                (curr->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = curr;\n            tail = curr;\n        }\n        tail->next = NULL;\n    }\n    fclose(fp);\n    aliases_up++;\n\n    return 0;\n\n    bad:\n    fclose(fp);\n    logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");\n\n    return -1;\n}\n\n\nchar *lookup_alias(const char *alias)\n{\n    const DirAlias *curr = head;\n\n    if (aliases_up == 0) {\n        return NULL;\n    }\n    while (curr != NULL) {\n        if (strcmp(curr->alias, alias) == 0) {\n            return curr->dir;\n        }\n        curr = curr->next;\n    }\n    return NULL;\n}\n\n\nvoid print_aliases(void)\n{\n    const DirAlias *curr = head;\n\n    if (aliases_up == 0) {\n        addreply_noformat(502, MSG_CONF_ERR);\n\n        return;\n    }\n    addreply_noformat(214, MSG_ALIASES_LIST);\n    while (curr != NULL) {\n        char line[MAXALIASLEN + PATH_MAX + 3U];\n\n        snprintf(line, sizeof line, \" %s %s\", curr->alias, curr->dir);\n        addreply_noformat(0, line);\n        curr = curr->next;\n    }\n    addreply_noformat(214, \" \");\n}\n\n#endif\n"], "buggy_code_start_loc": [96], "buggy_code_end_loc": [107], "fixing_code_start_loc": [95], "fixing_code_end_loc": [108], "type": "CWE-824", "message": "An issue was discovered in Pure-FTPd 1.0.49. An uninitialized pointer vulnerability has been detected in the diraliases linked list. When the *lookup_alias(const char alias) or print_aliases(void) function is called, they fail to correctly detect the end of the linked list and try to access a non-existent list member. This is related to init_aliases in diraliases.c.", "other": {"cve": {"id": "CVE-2020-9274", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-26T16:15:19.847", "lastModified": "2022-10-07T12:44:36.623", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Pure-FTPd 1.0.49. An uninitialized pointer vulnerability has been detected in the diraliases linked list. When the *lookup_alias(const char alias) or print_aliases(void) function is called, they fail to correctly detect the end of the linked list and try to access a non-existent list member. This is related to init_aliases in diraliases.c."}, {"lang": "es", "value": "Se detect\u00f3 un problema en Pure-FTPd versi\u00f3n 1.0.49. Se ha detectado una vulnerabilidad de puntero no inicializado en la lista vinculada diraliases. Cuando es llamada la funci\u00f3n  *lookup_alias(const char alias) o print_aliases(void), no pueden detectar correctamente el final de la lista vinculada e intentan acceder a un miembro de la lista no existente. Esto est\u00e1 relacionado con la funci\u00f3n init_aliases en el archivo diraliases.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-824"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.50", "matchCriteriaId": "75A7494B-4517-44A4-9AAD-2D7D2BA66776"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fedoraproject:extra_packages_for_enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "3D9C7598-4BB4-442A-86DF-EEDE041A4CC7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fedoraproject:extra_packages_for_enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "BB176AC3-3CDA-4DDA-9089-C67B2F73AA62"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}]}]}], "references": [{"url": "https://github.com/jedisct1/pure-ftpd/commit/8d0d42542e2cb7a56d645fbe4d0ef436e38bcefa", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/02/msg00029.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/22P44PECZWNDP7CMBL7NRBMNFS73C5Z2/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/B5NSUDWXZVWUCL6R2PTX3KBB42Z62CA5/", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U5DBVHJCXWRSJPNJQCJQCKZF6ZDPZCKA/", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202003-54", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4515-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.pureftpd.org/project/pure-ftpd/news/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jedisct1/pure-ftpd/commit/8d0d42542e2cb7a56d645fbe4d0ef436e38bcefa"}}