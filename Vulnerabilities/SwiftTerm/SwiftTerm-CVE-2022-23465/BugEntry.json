{"buggy_code": ["//\n//  Terminal.swift\n//  SwiftTerm\n//\n//  Created by Miguel de Icaza on 3/27/19.\n//  Copyright \u00a9 2019 Miguel de Icaza. All rights reserved.\n//\n// TODO: review every place that sets cursor to use setCursor\n// TODO: audit every location to use restrictCursor\n\nimport Foundation\n\n/**\n * The terminal delegate is a protocol that must be implemented by a class\n * that would provide a user interface for the terminal, and it is used by the\n * `Terminal` to notify of important changes on the underlying terminal\n */\npublic protocol TerminalDelegate: AnyObject {\n    /**\n     * Invoked to request that the cursor be shown\n     */\n    func showCursor (source: Terminal)\n\n    /**\n     * Invoked to request that the cursor be shown\n     */\n    func hideCursor (source: Terminal)\n\n    /**\n     * This method is invoked when the terminal needs to set the title for the window,\n     * a UI toolkit would react by setting the terminal title in the window or any other\n     * user visible element.\n     *\n     * The default implementation does nothing.\n     */\n    func setTerminalTitle (source: Terminal, title: String)\n\n    /**\n     * This method is invoked when the terminal needs to set the title for the minimized icon,\n     * a UI toolkit would react by setting the terminal title in the icon or any other\n     * user visible element\n     *\n     * The default implementation does nothing.\n     */\n    func setTerminalIconTitle (source: Terminal, title: String)\n\n    /**\n     * These are various commands that are sent by the client.  They are rare,\n     * and if you do not know what to return, just return nil, the terminal\n     * will return a suitable value.\n     *\n     * The response string needs to be suitable for the Xterm CSI Ps ; Ps ; Ps t command\n     * see the WindowManipulationCommand enumeration for those that need to return values\n     *\n     * The default implementation does nothing.\n     */\n    @discardableResult\n    func windowCommand (source: Terminal, command: Terminal.WindowManipulationCommand) -> [UInt8]?\n    \n    /**\n     * This method is invoked when the terminal dimensions have changed in response\n     * to an escape sequence that triggers a terminal resize, the user interface toolkit\n     * should attempt to accomodate the new window size\n     *\n     * TODO: This is not wired up\n     *\n     * The default implementation does nothing.\n     */\n    func sizeChanged (source: Terminal)\n    \n    /**\n     * Sends the byte data to the client connected to the terminal (in terminal emulation\n     * documentation, this is the \"host\")\n     */\n    func send (source: Terminal, data: ArraySlice<UInt8>)\n    \n    // callbacks\n    \n    /// Callback - the window was scrolled, new yDisplay passed\n    /// The default implementation does nothing.\n    func scrolled (source: Terminal, yDisp: Int)\n    \n    /// Callback a newline was generated\n    /// The default implementation does nothing.\n    func linefeed (source: Terminal)\n    \n    /// This method is invoked when the buffer changes from Normal to Alternate, or Alternate to Normal\n    /// The default implementation does nothing.\n    func bufferActivated (source: Terminal)\n    \n    /// Should raise the bell\n    /// The default implementation does nothing.\n    func bell (source: Terminal)\n    \n    /**\n     * This is invoked when the selection has changed, or has been turned on.   The status is\n     * available in `terminal.selection.active`, and the range relative to the buffer is\n     * in `terminal.selection.start` and `terminal.selection.end`\n     *\n     * The default implementation does nothing.\n     */\n    func selectionChanged (source: Terminal)\n    \n    /**\n     * This method should return `true` if operations that can read the buffer back should be allowed,\n     * otherwise, return false.   This is useful to run some applications that attempt to checksum the\n     * contents of the screen (unit tests)\n     *\n     * The default implementation returns `true`\n     */\n    func isProcessTrusted (source: Terminal) -> Bool\n    \n    /**\n     * This method is invoked when the `mouseMode` property has changed, and gives the UI\n     * a chance to update any tracking capabilities that are required in the toolkit or no longer\n     * required to provide the events.\n     *\n     * The default implementation ignores the mouse change\n     */\n    func mouseModeChanged (source: Terminal)\n    \n    /**\n     * This method is invoked when a request to change the cursor style has been issued\n     * by client application.\n     */\n    func cursorStyleChanged (source: Terminal, newStyle: CursorStyle)\n    \n    /**\n     * This method is invoked when the client application has issued a command to report\n     * its current working directory (this is done with the OSC 7 command).   The value can be\n     * read by accessing the `hostCurrentDirectory` property.\n     *\n     * The default implementaiton does nothing.\n     */\n    func hostCurrentDirectoryUpdated (source: Terminal)\n    \n    /**\n     * This method is invoked when the client application has issued a command to report\n     * its current document (this is done with the OSC 6 command).   The value can be\n     * read by accessing the `hostCurrentDocument` property.\n     *\n     * The default implementaiton does nothing.\n     */\n    func hostCurrentDocumentUpdated (source: Terminal)\n    \n    /**\n     * This method is invoked when a color in the 0..255 palette has been redefined, if the\n     * front-end keeps a cache or uses indexed rendering, it should update the color\n     * with the new values.   If the value of idx is nil, this means all the ansi colors changed\n     */\n    func colorChanged (source: Terminal, idx: Int?)\n    \n    /**\n     * The view should try to set the foreground color to the provided color\n     */\n    func setForegroundColor (source: Terminal, color: Color)\n    \n    /**\n     * The view should try to set the background color to the provided color\n     */\n    func setBackgroundColor (source: Terminal, color: Color)\n    \n    /**\n     * The view should try to set the cursor color to the provided color.   If color is nil, the view can use a default.\n     */\n    func setCursorColor (source: Terminal, color: Color?)\n    \n    /**\n     * This should return the current foreground and background colors to\n     * report.\n     */\n    func getColors (source: Terminal) -> (foreground: Color, background: Color)\n    \n    /**\n     * This method is invoked when the client application (iTerm2) has issued a OSC 1337 and\n     * SwiftTerm did not handle a handler for it.\n     *\n     * The default implementaiton does nothing.\n     */\n    func iTermContent (source: Terminal, content: ArraySlice<UInt8>)\n    \n    /**\n     * This method is invoked when the client application has issued a OSC 52\n     * to put data on the clipboard.\n     *\n     * - Parameters:\n     *  - source: identifies the instance of the terminal that sent this request\n     *  - content: the data to place on the clipboard\n     * The default implementation does nothing.\n     */\n    func clipboardCopy(source: Terminal, content: Data)\n    \n    /**\n     * Invoked when client application issues OSC 777 to show notification.\n     *\n     * The default implementation does nothing.\n     * - Parameters:\n     *  - source: identifies the instance of the terminal that sent this request\n     *  - title: the title to show for the notification\n     *  - body: the body of the notification\n     */\n    func notify(source: Terminal, title: String, body: String)\n    \n    /**\n     * Invoked to create an image from an RGBA buffer at the current cursor position\n     *\n     * The default implementation does nothing.\n     * - Parameters:\n     *  - source: identifies the instance of the terminal that sent this request\n     *  - bytes: Image buffer in RGBA format, using 8 bits per channel.\n     *  - width: the width in pixels of the image\n     *  - height: the height in pixels of the image\n     */\n    func createImageFromBitmap (source: Terminal, bytes: inout [UInt8], width: Int, height: Int)\n    \n    /**\n     * Invoked to create an image from a byte blob that might be encoded in one of the various\n     * compressed file formats (unlike the other option that gets an RGBA buffer already decoded).\n     * It also included requests for the desired dimensions.\n     * - Parameters:\n     *  - source: identifies the instance of the terminal that sent this request\n     *  - data: Binary blob containing the image data, which is typically encoded as a PNG or JPEG file\n     *  - widthRequest: the width requested, it contains an enumeration describing what the request was\n     *  - height: the height requested, it contains an enumeration describing what the request was\n     *  - preserveAspectRatio: if set, one of the dimensions will track the hardcoded setting set for the other.\n     */\n    func createImage (source: Terminal, data: Data, width: ImageSizeRequest, height: ImageSizeRequest, preserveAspectRatio: Bool)\n}\n\n/// Enumeration passed to the TerminalDelegate.createImage to configure\n/// the desired values for width and height.\npublic enum ImageSizeRequest {\n    /// Make the best decision based on the image data\n    case auto\n    /// Occupy exactly the number of cells\n    case cells(Int)\n    /// Occupy exactly the pixels listed\n    case pixels(Int)\n    /// Occupy a percentange size relative to the dimension of the visible region\n    case percent(Int)\n}\n\npublic protocol TerminalImage {\n    /// The width of the image in pixels\n    var pixelWidth: Int { get }\n    /// The height of the image in pixels\n    var pixelHeight: Int { get }\n    \n    /// Column where the image was attached\n    var col: Int { get set }\n}\n\n/**\n * The `Terminal` class provides the terminal emulation engine, and can be used to feed data to the\n * terminal emulator.   Typically users will intereact with a higher-level implementation that provides a\n * UI toolkit-specific rendering and connects the input to the UI toolkit.\n *\n * A front-end would draw the contents of the terminal, and take input from the user, which is in turn\n * either mapped to one of the public APIs here, or if it is user input is passed to the `feed`  methods here.\n *\n * The terminal is also connected to a backend that is conneted to the client, and data from this\n * client is fed into the emulator by calling the `sendResponse method`\n *\n * The behavior of the terminal is configured by implementing the `TerminalDelegate` protocol\n * that is provided in the constructor call.\n */\nopen class Terminal {\n    let MINIMUM_COLS = 2\n    let MINIMUM_ROWS = 1\n    \n    /// The current terminal columns (counting from 1)\n    public private(set) var cols: Int = 80\n    \n    /// The current terminal rows (counting from 1)\n    public private(set) var rows: Int = 25\n    var tabStopWidth : Int = 8\n    var options: TerminalOptions\n    \n    // The current buffers\n    var buffers : BufferSet!\n    \n    // Whether the terminal is operating in application keypad mode\n    var applicationKeypad : Bool = false\n    \n    // Whether the terminal is operating in application cursor mode\n    public var applicationCursor : Bool = false\n    \n    // You can ignore most of the defaults set here, the function\n    // reset() will do that again\n    var sendFocus: Bool = false\n    var cursorHidden : Bool = false\n    \n    /// Controls the origin mode (DECOM), when set, the screen is limited to the top and bottom margins\n    var originMode: Bool = false\n    \n    /// Controls whether it is possible to set left and right margin modes\n    var marginMode: Bool = false\n    \n    var insertMode: Bool = false\n    \n    /// Indicates that the application has toggled bracketed paste mode, which means that when content is pasted into\n    /// the terminal, the content will be wrapped in \"ESC [ 200 ~\" to start, and \"ESC [ 201 ~\" to end.\n    public private(set) var bracketedPasteMode: Bool = false\n    \n    var charset: [UInt8:String]? = nil\n    var gcharset: Int = 0\n    var wraparound: Bool = false\n    var reverseWraparound: Bool = false\n    weak var tdel: TerminalDelegate?\n    var curAttr: Attribute = CharData.defaultAttr\n    var gLevel: UInt8 = 0\n    var cursorBlink: Bool = false\n    \n    var allow80To132 = true\n    \n    var parser: EscapeSequenceParser\n    \n    var refreshStart = Int.max\n    var refreshEnd = -1\n    var scrollInvariantRefreshStart = Int.max\n    var scrollInvariantRefreshEnd = -1\n    var userScrolling = false\n    var lineFeedMode = false\n    \n    // We do not implement smooth scrolling here, dubious value, but\n    // makes a test bass\n    var smoothScroll = false\n    \n    // Installed colors are the 16 values that can be changed dynamically by the host\n    var installedColors: [Color]\n    // The blueprint for the colors, computed based on the installed colors\n    var defaultAnsiColors: [Color]\n    // The active set of colors (based on the blueprint)\n    var ansiColors: [Color]\n    \n    // Control codes provides an API to send either 8bit sequences or 7bit sequences for C0 and C1 depending on the terminal state\n    var cc: CC\n    \n    /// This variable if set, contains an URI representing the host and directory of the process running in the terminal\n    /// it is often used by applciations to track the working directory.   It might be nil, or might not be correct, the\n    /// contents are entirely under the control of the remote application, and require the terminal to be trusted\n    /// (see the `isProcessTrusted` method in the `TerminalDelegate`).  When this is set the\n    /// `hostCurrentDirectoryUpdated` method on the delegate is invoked.\n    public private(set) var hostCurrentDirectory: String? = nil\n    \n    /// This variable if set, contains an URI representing the host and current document of the process\n    /// running in the terminal.   It might be nil, or might not be correct, the\n    /// contents are entirely under the control of the remote application, and require the terminal to be trusted\n    /// (see the `isProcessTrusted` method in the `TerminalDelegate`).  When this is set the\n    /// `hostCurrentDocumentUpdated` method on the delegate is invoked.\n    public private(set) var hostCurrentDocument: String? = nil\n    \n    /// The current attribute used by the terminal by default\n    public var currentAttribute: Attribute {\n        get { return curAttr }\n    }\n    // The requested conformance from DECSCL command\n    enum TerminalConformance {\n        case vt100\n        case vt200\n        case vt300\n        case vt400\n        case vt500\n    }\n    \n    // The mouse coordinates can be encoded in a number of ways, and obey to historical\n    // upgrades to the protocol, but also attempts at fixing limitations of the different\n    // encodings.\n    enum MouseProtocolEncoding {\n        // The default x10 mode is limited to coordinates up to 223.\n        // (255-32).   The other modes solve this limitaion\n        case x10\n        \n        // Extends the range of a coordinate to 2015 by using UTF-8 encoding of the\n        // coordinate value.   This encoding is troublesome for applications that\n        // do not support utf8 input.\n        case utf8\n        \n        // The response uses CSI < ButtonValue ; Px ; Py [Mm]\n        case sgr\n\n        // Different response style, with possible ambiguities, not recommended\n        case urxvt\n    }\n    \n    // The protocol encoding for the terminal\n    private var mouseProtocol: MouseProtocolEncoding = .x10\n\n    // This is used to track if we are setting the colors, to prevent a\n    // recursive invocation (nativeForegroundColor sets the terminal\n    // color, which in turn broadcasts the request for a change)\n    var settingFgColor = false, settingBgColor = false, settingCursorColor = false\n\n    /// This tracks the current foreground color for the application.\n    public var foregroundColor: Color = Color.defaultForeground {\n        didSet {\n            if settingFgColor {\n                return\n            }\n            settingFgColor = true\n            tdel?.setForegroundColor(source: self, color: foregroundColor)\n            settingFgColor = false\n        }\n    }\n    /// This tracks the current background color for the application.\n    public var backgroundColor: Color = Color.defaultBackground {\n        didSet {\n            if settingBgColor {\n                return\n            }\n            settingBgColor = true\n            tdel?.setBackgroundColor(source: self, color: backgroundColor)\n            settingBgColor = false\n        }\n    }\n    \n    // This tracks the requested cursor color or nil to use a view-default\n    public var cursorColor: Color? = nil {\n        didSet {\n            if settingCursorColor {\n                return\n            }\n            settingCursorColor = true\n            tdel?.setCursorColor(source: self, color: cursorColor)\n            settingCursorColor = false\n        }\n    }\n    \n    ///\n    /// Represents the mouse operation mode that the terminal is currently using and higher level\n    /// implementations should use the functions in this enumeration to determine what events to\n    /// send\n    public enum MouseMode {\n        /// No mouse events are reported\n        case off\n        \n        /// X10 Compatibility mode - only sends events in button press\n        case x10\n        \n        /// VT200, also known as Normal Tracking Mode - sends both press and release events\n        case vt200\n        \n        /// ButtonEventTracking - In addition to sending button press and release events, it sends motion events when the button is pressed\n        case buttonEventTracking\n        \n        /// Sends button presses, button releases, and motion events regardless of the button state\n        case anyEvent\n        \n        // Unsupported modes:\n        // - vt200Highlight, this can deadlock the terminal\n        // - declocator, rarely used\n        \n        /// Returns true if you should send a button press event (separate from release)\n        func sendButtonPress () -> Bool\n        {\n            self == .vt200 || self == .buttonEventTracking || self == .anyEvent\n        }\n        \n        /// Returns true if you should send the button release event\n        func sendButtonRelease () -> Bool\n        {\n            self != .off\n        }\n        \n        /// Returns true if you should send a motion event when a button is pressed\n        func sendButtonTracking () -> Bool\n        {\n            self == .buttonEventTracking || self == .anyEvent\n        }\n        \n        /// Returns true if you should send a motion event, regardless of button state\n        public func sendMotionEvent () -> Bool\n        {\n            self == .anyEvent\n        }\n        \n        /// Returns true if the modifiers should be encoded\n        public func sendsModifiers() -> Bool {\n            self == .vt200 || self == .buttonEventTracking || self == .anyEvent\n        }\n    }\n    \n    public private(set) var mouseMode: MouseMode = .off {\n        didSet {\n            tdel?.mouseModeChanged (source: self)\n        }\n    }\n\n    // The next four variables determine whether setting/querying should be done using utf8 or latin1\n    // and whether the values should be set or queried using hex digits, rather than actual byte streams\n    var xtermTitleSetUtf = false\n    var xtermTitleSetHex = false\n    var xtermTitleQueryUtf = false\n    var xtermTitleQueryHex = false\n    \n    var conformance: TerminalConformance = .vt500\n    \n    /**\n     * Returns true if we should respect the left/right margins, which is based on the originMode and marginMode setting\n     */\n    func usingMargins() ->Bool\n    {\n        return originMode && marginMode\n    }\n    \n    /// Returns the terminal dimensions 1-based values\n    public func getDims () -> (cols: Int,rows: Int)\n    {\n        return (cols, rows)\n    }\n    \n    public init (delegate : TerminalDelegate, options: TerminalOptions = TerminalOptions.default)\n    {\n        installedColors = Color.defaultInstalledColors\n        defaultAnsiColors = Color.setupDefaultAnsiColors (initialColors: installedColors)\n        ansiColors = defaultAnsiColors\n        tdel = delegate\n        self.options = options\n        // This duplicates the setup above, but\n        parser = EscapeSequenceParser ()\n        cc = CC(send8bit: false)\n        configureParser (parser)\n        setup ()\n    }\n\n    /// Installs the new colors as the default colors and recomputes the\n    /// current and ansi palette.   This will not change the UI layer, for that it is better\n    /// to call the `installColors` method on `TerminalView`, which will\n    /// both call this method, and update the display appropriately.\n    ///\n    /// - Parameter colors: this should be an array of 16 values that correspond to the 16 ANSI colors,\n    /// if the array does not contain 16 elements, it will not do anything\n    public func installPalette (colors: [Color])\n    {\n        if colors.count != 16 {\n            return\n        }\n        installedColors = colors\n        defaultAnsiColors = Color.setupDefaultAnsiColors (initialColors: installedColors)\n        ansiColors = defaultAnsiColors\n    }\n    \n    /**\n     * Returns the active buffer (either the normal buffer or the alternative buffer)\n     */\n    var buffer: Buffer {\n        get {\n            buffers!.active\n        }\n    }\n\n    /// Returns the CharData at the specified column and row from the visible portion of the buffer, these are zero-based\n    ///\n    /// - Parameter col: column to retrieve, starts at 0\n    /// - Parameter row: row to retrieve, starts at 0\n    /// - Returns: nil if the col or row are out of bounds, or the CharData contained in that cell otherwise\n    ///\n    public func getCharData (col: Int, row: Int) -> CharData?\n    {\n        if col < 0 || col >= cols {\n            return nil\n        }\n        if let l = getLine (row: row) {\n            return l [col]\n        }\n        return nil\n    }\n\n    /// Returns the contents of a line as a BufferLine, or nil if the requested line is out of range\n    ///\n    /// The line is counted  from start of scroll back, not what the terminal has visible right now.\n    /// - Parameter row: the row to retrieve, relative to the scroll buffer, not the visible display\n    /// - Returns: nil if the col or row are out of bounds, or the BufferLine  otherwise\n    public func getLine (row: Int) -> BufferLine? {\n        if row < 0 || row >= rows {\n            return nil\n        }\n        return buffer.lines [row + buffer.yDisp]\n    }\n\n    /// Returns the contents of a line as a BufferLine counting from the begging of the scroll buffer.\n    ///\n    /// The line is counted  from start of scroll back, not what the terminal has visible right now.\n    /// - Parameter row: the row to retrieve, relative to the scroll buffer, not the visible display\n    /// - Returns: nil if the col or row are out of bounds, or the BufferLine  otherwise\n    public func getScrollInvariantLine (row: Int) -> BufferLine? {\n        if row < buffer.linesTop || row >= buffer.lines.count + buffer.linesTop {\n            return nil\n        }\n        return buffer.lines [row-buffer.linesTop]\n    }\n\n    /// Returns the character at the specified column and row, these are zero-based\n    /// - Parameter col: column to retrieve, starts at 0\n    /// - Parameter row: row to retrieve, starts at 0\n    /// - Returns: nil if the col or row are out of bounds, or the Character contained in that cell otherwise\n    \n    public func getCharacter (col: Int, row: Int) -> Character?\n    {\n        return getCharData(col: col, row: row)?.getCharacter()\n    }\n    \n    func setup (isReset: Bool = false)\n    {\n        // Sadly a duplicate of much of what lives in init() due to Swift not allowing me to\n        // call this\n        cols = max (options.cols, MINIMUM_COLS)\n        rows = max (options.rows, MINIMUM_ROWS)\n        if buffers != nil && isReset {\n            buffers.resetNormal ()\n            buffers.activateNormalBuffer(clearAlt: false)\n        } else if buffers == nil {\n            buffers = BufferSet(self)\n        }\n        cursorHidden = false\n        \n        // modes\n        applicationKeypad = false\n        applicationCursor = false\n        originMode = false\n        \n        marginMode = false\n        insertMode = false\n        wraparound = true\n        bracketedPasteMode = false\n        \n        // charset'\n        charset = nil\n        gcharset = 0\n        gLevel = 0\n        curAttr = CharData.defaultAttr\n        \n        mouseMode = .off\n        \n        buffer.scrollTop = 0\n        buffer.scrollBottom = rows-1\n        buffer.marginLeft = 0\n        buffer.marginRight = cols-1\n        \n        cc.send8bit = false\n        conformance = .vt500\n        \n        allow80To132 = true\n        \n        xtermTitleSetUtf = false\n        xtermTitleQueryUtf = false\n        \n        xtermTitleSetHex = false\n        xtermTitleQueryHex = false\n        \n        hyperLinkTracking = nil\n        cursorBlink = false\n        hostCurrentDirectory = nil\n        lineFeedMode = options.convertEol\n    }\n    \n    // DCS $ q Pt ST\n    // DECRQSS (https://vt100.net/docs/vt510-rm/DECRQSS.html)\n    //   Request Status String (DECRQSS), VT420 and up.\n    // Response: DECRPSS (https://vt100.net/docs/vt510-rm/DECRPSS.html)\n    class DECRQSS : DcsHandler {\n        var data: [UInt8]\n        unowned var terminal: Terminal\n\n        public init (terminal: Terminal)\n        {\n            self.terminal = terminal\n            data = []\n        }\n\n        func hook (collect: cstring, parameters: [Int],  flag: UInt8)\n        {\n            data = []\n        }\n        \n        func put (data : ArraySlice<UInt8>)\n        {\n            for x in data {\n                self.data.append(x)\n            }\n        }\n        \n        func unhook ()\n        {\n            let newData = String (bytes: data, encoding: .ascii)\n            var ok = 1 // 0 means the request is valid according to docs, but tests expect 0?\n            var result: String\n            switch (newData) {\n            case \"\\\"q\": // DECCSA - Set Character Attribute\n                result = \"\\\"q\"\n            case \"\\\"p\": // DECSCL - conformance level\n                result = \"65;1\\\"p\"\n            case \"r\": // DECSTBM - the top and bottom margins\n                result = \"\\(terminal.buffer.scrollTop + 1);\\(terminal.buffer.scrollBottom + 1)r\"\n            case \"m\": // SGR - the set graphic rendition\n                // TODO: report real settings instead of 0m\n                result = terminal.curAttr.toSgr ()\n            case \"s\": // DECSLRM - the current left and right margins\n                result = \"\\(terminal.buffer.marginLeft+1);\\(terminal.buffer.marginRight+1)s\"\n            case \" q\": // DECSCUSR - the set cursor style\n                // TODO this should send a number for the current cursor style 2 for block, 4 for underline and 6 for bar\n                let style = \"2\" // block\n                result = \"\\(style) q\"\n            default:\n                ok = 0 // this means the request is not valid, report that to the host.\n                // invalid: DCS 0 $ r Pt ST (xterm)\n                terminal.log (\"Unknown DCS + \\(newData!)\")\n                result = newData ?? \"\"\n\n            }\n            terminal.sendResponse (terminal.cc.DCS, \"\\(ok)$r\\(result)\", terminal.cc.ST)\n        }\n    }\n\n    // Configures the EscapeSequenceParser\n    func configureParser (_ parser: EscapeSequenceParser)\n    {\n        parser.csiHandlerFallback = { [unowned self] (pars: [Int], collect: cstring, code: UInt8) -> () in\n            let ch = Character(UnicodeScalar(code))\n            self.log (\"Unknown CSI Code (collect=\\(collect) code=\\(ch) pars=\\(pars))\")\n        }\n        parser.escHandlerFallback = { [unowned self] (txt: cstring, flag: UInt8) in\n            self.log (\"Unknown ESC Code: ESC + \\(Character(Unicode.Scalar (flag))) txt=\\(txt)\")\n        }\n        parser.executeHandlerFallback = { [unowned self] in\n            self.log (\"Unknown EXECUTE code\")\n        }\n        parser.oscHandlerFallback = { [unowned self] (code: Int) in\n            self.log (\"Unknown OSC code: \\(code)\")\n        }\n        parser.printHandler = { [unowned self] slice in handlePrint (slice) }\n        parser.printStateReset = { [unowned self] in printStateReset() }\n        \n        // CSI handler\n        parser.csiHandlers [UInt8 (ascii: \"@\")] = { [unowned self] pars, collect in cmdInsertChars (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"A\")] = { [unowned self] pars, collect in cmdCursorUp (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"B\")] = { [unowned self] pars, collect in cmdCursorDown (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"C\")] = { [unowned self] pars, collect in cmdCursorForward (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"D\")] = { [unowned self] pars, collect in cmdCursorBackward (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"E\")] = { [unowned self] pars, collect in cmdCursorNextLine (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"F\")] = { [unowned self] pars, collect in cmdCursorPrecedingLine (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"G\")] = { [unowned self] pars, collect in cmdCursorCharAbsolute (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"H\")] = { [unowned self] pars, collect in cmdCursorPosition (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"I\")] = { [unowned self] pars, collect in cmdCursorForwardTab (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"J\")] = { [unowned self] pars, collect in cmdEraseInDisplay (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"K\")] = { [unowned self] pars, collect in cmdEraseInLine (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"L\")] = { [unowned self] pars, collect in cmdInsertLines (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"M\")] = { [unowned self] pars, collect in cmdDeleteLines (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"P\")] = { [unowned self] pars, collect in cmdDeleteChars (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"S\")] = { [unowned self] pars, collect in cmdScrollUp (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"T\")] = { [unowned self] pars, collect in csiT (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"X\")] = { [unowned self] pars, collect in cmdEraseChars (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"Z\")] = { [unowned self] pars, collect in cmdCursorBackwardTab (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"`\")] = { [unowned self] pars, collect in cmdCharPosAbsolute (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"a\")] = { [unowned self] pars, collect in cmdHPositionRelative (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"b\")] = { [unowned self] pars, collect in cmdRepeatPrecedingCharacter (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"c\")] = { [unowned self] pars, collect in cmdSendDeviceAttributes (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"d\")] = { [unowned self] pars, collect in cmdLinePosAbsolute (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"e\")] = { [unowned self] pars, collect in cmdVPositionRelative (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"f\")] = { [unowned self] pars, collect in cmdHVPosition (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"g\")] = { [unowned self] pars, collect in cmdTabClear (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"h\")] = { [unowned self] pars, collect in cmdSetMode (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"l\")] = { [unowned self] pars, collect in cmdResetMode (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"m\")] = { [unowned self] pars, collect in cmdCharAttributes (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"n\")] = { [unowned self] pars, collect in cmdDeviceStatus (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"p\")] = { [unowned self] pars, collect in csiPHandler (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"q\")] = { [unowned self] pars, collect in cmdSetCursorStyle (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"r\")] = { [unowned self] pars, collect in cmdSetScrollRegion (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"s\")] = { [unowned self] args, cstring in\n            // \"CSI s\" is overloaded, can mean save cursor, but also set the margins with DECSLRM\n            if self.marginMode {\n                self.cmdSetMargins (args, cstring)\n            } else {\n                self.cmdSaveCursor (args, cstring)\n            }\n        }\n        parser.csiHandlers [UInt8 (ascii: \"t\")] = { [unowned self] pars, collect in csit (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"u\")] = { [unowned self] pars, collect in cmdRestoreCursor (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"v\")] = { [unowned self] pars, collect in csiCopyRectangularArea (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"x\")] = { [unowned self] pars, collect in csiX (pars, collect) } /* x DECFRA - could be overloaded */\n        parser.csiHandlers [UInt8 (ascii: \"y\")] = { [unowned self] pars, collect in cmdDECRQCRA (pars, collect) } /* y - Checksum Region */\n        parser.csiHandlers [UInt8 (ascii: \"z\")] = { [unowned self] pars, collect in csiZ (pars, collect) } /* DECERA */\n        parser.csiHandlers [UInt8 (ascii: \"{\")] = { [unowned self] pars, collect in csiOpenBrace (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"}\")] = { [unowned self] pars, collect in csiCloseBrace (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"~\")] = { [unowned self] pars, collect in cmdDeleteColumns (pars, collect) }\n\n        parser.executeHandlers [7]  = { [unowned self] in self.tdel?.bell (source: self) }\n        parser.executeHandlers [10] = { [unowned self] in cmdLineFeed () }\n        parser.executeHandlers [11] = { [unowned self] in cmdLineFeedBasic () }  // VT Vertical Tab - ignores auto-new-line behavior in ConvertEOL\n        parser.executeHandlers [12] = { [unowned self] in cmdLineFeedBasic () }\n        parser.executeHandlers [13] = { [unowned self] in cmdCarriageReturn () }\n        parser.executeHandlers [8]  = { [unowned self] in cmdBackspace () }\n        parser.executeHandlers [9]  = { [unowned self] in cmdTab () }\n        parser.executeHandlers [14] = { [unowned self] in cmdShiftOut () }\n        parser.executeHandlers [15] = { [unowned self] in cmdShiftIn () }\n        \n        parser.executeHandlers [0x84] = { [unowned self] in cmdIndex () }\n        parser.executeHandlers [0x85] = { [unowned self] in cmdNextLine () }\n        parser.executeHandlers [0x88] = {  [unowned self] in cmdTabSet () }\n\n        //\n        // OSC handler\n        //\n        //   0 - icon name + title\n        parser.oscHandlers [0] = { [unowned self] data in self.setTitle(text: String (bytes: data, encoding: .utf8) ?? \"\")}\n        //   1 - icon name\n        parser.oscHandlers [1] = { [unowned self] data in self.setIconTitle(text: String (bytes: data, encoding: .utf8) ?? \"\") }\n        //   2 - title\n        parser.oscHandlers [2] = { [unowned self] data in self.setTitle(text: String (bytes: data, encoding: .utf8) ?? \"\")}\n        //   3 - set property X in the form \"prop=value\"\n        //   4 - Change Color Number()\n        parser.oscHandlers [4] = { [unowned self] data in oscChangeOrQueryColorIndex (data) }\n        \n        //   5 - Change Special Color Number\n        //   6 - Enable/disable Special Color Number c\n\n        //   6 - current document:\n        parser.oscHandlers [6] = { [unowned self] data in oscSetCurrentDocument (data) }\n\n        //   7 - current directory? (not in xterm spec, see https://gitlab.com/gnachman/iterm2/issues/3939)\n        parser.oscHandlers [7] = { [unowned self] data in oscSetCurrentDirectory (data) }\n        \n        parser.oscHandlers [8] = { [unowned self] data in oscHyperlink (data) }\n        //  10 - Change VT100 text foreground color to Pt.\n        parser.oscHandlers [10] = { [unowned self] data in oscSetTextForeground (data) }\n        //  11 - Change VT100 text background color to Pt.\n        parser.oscHandlers [11] = { [unowned self] data in oscSetTextBackground (data) }\n        //  12 - Change text cursor color to Pt.\n        parser.oscHandlers [12] = { [unowned self] data in oscSetCursorColor (data) }\n        \n        //  13 - Change mouse foreground color to Pt.\n        //  14 - Change mouse background color to Pt.\n        //  15 - Change Tektronix foreground color to Pt.\n        //  16 - Change Tektronix background color to Pt.\n        //  17 - Change highlight background color to Pt.\n        //  18 - Change Tektronix cursor color to Pt.\n        //  19 - Change highlight foreground color to Pt.\n        //  46 - Change Log File to Pt.\n        //  50 - Set Font to Pt.\n        //  51 - reserved for Emacs shell.\n        //  52 - Clipboard operations\n        parser.oscHandlers [52] = { [unowned self] data in oscClipboard (data) }\n        // 104 ; c - Reset Color Number c.\n        parser.oscHandlers [104] = { [unowned self] data in oscResetColor (data) }\n        \n        // 105 ; c - Reset Special Color Number c.\n        // 106 ; c; f - Enable/disable Special Color Number c.\n        // 110 - Reset VT100 text foreground color.\n        // 111 - Reset VT100 text background color.\n        // 112 - Reset text cursor color.\n        // 113 - Reset mouse foreground color.\n        // 114 - Reset mouse background color.\n        // 115 - Reset Tektronix foreground color.\n        // 116 - Reset Tektronix background color.\n        parser.oscHandlers [777] = { [unowned self] data in oscNotification (data) }\n        parser.oscHandlers [1337] = { [unowned self] data in osciTerm2 (data) }\n\n        //\n        // ESC handlers\n        //\n        parser.setEscHandler(\"6\",   { [unowned self] collect, flag in self.columnIndex (back: true) })\n        parser.setEscHandler (\"7\",  { [unowned self] collect, flag in self.cmdSaveCursor ([], []) })\n        parser.setEscHandler (\"8\",  { [unowned self] collect, flag in self.cmdRestoreCursor ([], []) })\n        parser.setEscHandler (\"9\",  { [unowned self] collect, flag in self.columnIndex(back: false) })\n        parser.setEscHandler (\"D\",  { [unowned self] collect, flag in self.cmdIndex() })\n        parser.setEscHandler (\"E\",  { [unowned self] collect, flag in self.cmdNextLine () })\n        parser.setEscHandler (\"H\",  { [unowned self] collect, flag in self.cmdTabSet ()})\n        parser.setEscHandler (\"M\",  { [unowned self] collect, flag in self.reverseIndex() })\n        parser.setEscHandler (\"=\",  { [unowned self] collect, flag in self.cmdKeypadApplicationMode ()})\n        parser.setEscHandler (\">\",  { [unowned self] collect, flag in self.cmdKeypadNumericMode ()})\n        parser.setEscHandler (\"c\",  { [unowned self] collect, flag in self.cmdReset () })\n        parser.setEscHandler (\"n\",  { [unowned self] collect, flag in self.setgLevel (2) })\n        parser.setEscHandler (\"o\",  { [unowned self] collect, flag in self.setgLevel (3) })\n        parser.setEscHandler (\"|\",  { [unowned self] collect, flag in self.setgLevel (3) })\n        parser.setEscHandler (\"}\",  { [unowned self] collect, flag in self.setgLevel (2) })\n        parser.setEscHandler (\"~\",  { [unowned self] collect, flag in self.setgLevel (1) })\n        parser.setEscHandler (\"%@\", { [unowned self] collect, flag in self.cmdSelectDefaultCharset () })\n        parser.setEscHandler (\"%G\", { [unowned self] collect, flag in self.cmdSelectDefaultCharset () })\n        parser.setEscHandler (\"#3\", { [unowned self] collect, flag in self.cmdSetDoubleHeightTop() })\n        parser.setEscHandler (\"#4\", { [unowned self] collect, flag in self.cmdSetDoubleHeightBottom() })\n        parser.setEscHandler (\"#6\", { [unowned self] collect, flag in self.cmdDoubleWidthSingleHeight () })\n        parser.setEscHandler (\"#8\", { [unowned self] collect, flag in self.cmdScreenAlignmentPattern () })\n        parser.setEscHandler (\" G\") { [unowned self] collect, flag in self.cmdSet8BitControls () }\n        parser.setEscHandler (\" F\") { [unowned self] collect, flag in self.cmdSet7BitControls () }\n        \n        for bflag in CharSets.all.keys {\n            let flag = String (UnicodeScalar (bflag))\n            \n            parser.setEscHandler (\"(\" + flag, { [unowned self] code, f in self.selectCharset ([UInt8 (ascii: \"(\")] + [f]) })\n            parser.setEscHandler (\")\" + flag, { [unowned self] code, f in self.selectCharset ([UInt8 (ascii: \")\")] + [f]) })\n            parser.setEscHandler (\"*\" + flag, { [unowned self] code, f in self.selectCharset ([UInt8 (ascii: \"*\")] + [f]) })\n            parser.setEscHandler (\"+\" + flag, { [unowned self] code, f in self.selectCharset ([UInt8 (ascii: \"+\")] + [f]) })\n            parser.setEscHandler (\"-\" + flag, { [unowned self] code, f in self.selectCharset ([UInt8 (ascii: \"-\")] + [f]) })\n            parser.setEscHandler (\".\" + flag, { [unowned self] code, f in self.selectCharset ([UInt8 (ascii: \".\")] + [f]) })\n            parser.setEscHandler (\"/\" + flag, { [unowned self] code, f in self.selectCharset ([UInt8 (ascii: \"/\")] + [f]) })\n        }\n\n        // Error handler\n        parser.errorHandler = { [unowned self] state in\n            self.log (\"Parsing error, state: \\(state)\")\n            return state\n        }\n\n        // DCS Handler\n        parser.setDcsHandler (\"$q\", DECRQSS (terminal: self))\n        parser.setDcsHandler (\"q\", SixelDcsHandler (terminal: self))\n        parser.dscHandlerFallback = { code, parameters in }\n    }\n    \n    /// This allows users of the terminal to register a handler for an OSC code.\n    /// - Parameters:\n    ///  - code: the code for the OSC handler to register, no checks are made that this overrides an existing handler\n    ///  - handler: the code to invoke when the OSC handler is received.\n    public func registerOscHandler (code: Int, handler: @escaping (ArraySlice<UInt8>) -> ())\n    {\n        parser.oscHandlers [code] = handler\n    }\n    \n    func cmdSet8BitControls ()\n    {\n        cc.send8bit = true\n    }\n\n    func cmdSet7BitControls ()\n    {\n        cc.send8bit = false\n    }\n\n    func emitScroll (_ x: Int)\n    {\n        // In the original code, it is mediocre accessibility, so likely will remove this\n    }\n    \n    func emitChar (_ ch: Character)\n    {\n        // In the original code, it is mediocre accessibility, so likely will remove this\n    }\n\n    //\n    // Because data might not be complete, we need to put back data that we read to process on\n    // a future read.  To prepare for reading, on every call to parse, the prepare method is\n    // given the new ArraySlice to read from.\n    //\n    // the `hasNext` describes whether there is more data left on the buffer, and `bytesLeft`\n    // returnes the number of bytes left.   The `getNext` method fetches either the next\n    // value from the putback buffer, or when it is empty, it returns it from the buffer that\n    // was passed during prepare.\n    //\n    // Additionally, the terminal parser needs to reset the parser state on demand, and\n    // that is surfaced via reset\n    //\n    struct ReadingBuffer {\n        var putbackBuffer: [UInt8] = []\n        var rest:ArraySlice<UInt8> = [][...]\n        var idx = 0\n        var count:Int = 0\n        \n        // Invoke this method at the beginning of parse\n        mutating func prepare (_ data: ArraySlice<UInt8>)\n        {\n            assert (rest.count == 0)\n            rest = data\n            count = putbackBuffer.count + data.count\n            idx = 0\n        }\n        \n        func hasNext () -> Bool {\n            idx < count\n        }\n        \n        func bytesLeft () -> Int\n        {\n            count-idx\n        }\n        \n        mutating func getNext () -> UInt8\n        {\n            if idx < putbackBuffer.count {\n                let v = putbackBuffer [idx]\n                idx += 1\n                return v\n            }\n            let v = rest [idx-putbackBuffer.count+rest.startIndex]\n            idx += 1\n            return v\n        }\n        \n        // Puts back the code, and everything that was pending\n        mutating func putback (_ code: UInt8)\n        {\n            var newPutback: [UInt8] = [code]\n            let left = bytesLeft()\n            for _ in 0..<left {\n                newPutback.append (getNext ())\n            }\n            putbackBuffer = newPutback\n            rest = [][...]\n        }\n        \n        mutating func done  ()\n        {\n            if idx < putbackBuffer.count {\n                putbackBuffer.removeFirst(idx)\n            } else {\n                putbackBuffer = []\n            }\n            rest = [][...]\n        }\n        \n        mutating func reset ()\n        {\n            putbackBuffer = []\n            idx = 0\n        }\n    }\n    \n    var readingBuffer = ReadingBuffer ()\n    \n    func printStateReset ()\n    {\n        readingBuffer.reset ()\n    }\n    \n    // This variable holds the last location that we poked a Character on.   This is required\n    // because combining unicode characters come after the character, so we need to poke back\n    // at this location.   We track the buffer (so we can distinguish Alt/Normal), the buffer line\n    // that we fetched, and the column.\n    var lastBufferStorage: (buffer: Buffer, y: Int, x: Int, cols: Int, rows: Int)? = nil\n    \n    var lastBufferCol: Int = 0\n    \n    func handlePrint (_ data: ArraySlice<UInt8>)\n    {\n        let buffer = self.buffer\n        readingBuffer.prepare(data)\n\n        updateRange (buffer.y)\n        while readingBuffer.hasNext() {\n            var ch: Character = \" \"\n            var chWidth: Int = 0\n            let code = readingBuffer.getNext()\n            \n            let n = UnicodeUtil.expectedSizeFromFirstByte(code)\n\n            if n == -1 || n == 1 {\n                // n == -1 means an Invalid UTF-8 sequence, client sent us some junk, happens if we run\n                // with the wrong locale set for example if LANG=en, still we handle it here\n\n                // get charset replacement character\n                // charset are only defined for ASCII, therefore we only\n                // search for an replacement char if code < 127\n                var chSet = false\n                if code < 127 && charset != nil {\n                    \n                    // Notice that the charset mapping can contain the dutch unicode sequence for \"ij\",\n                    // so it is not a simple byte, it is a Character\n                    if let str = charset! [UInt8 (code)] {\n                        ch = str.first!\n                        \n                        // Every single mapping in the charset only takes one slot\n                        chWidth = 1\n                        chSet = true\n                    }\n                }\n                \n                if chSet == false {\n                    let rune = UnicodeScalar (code)\n                    chWidth = UnicodeUtil.columnWidth(rune: rune)\n                    ch = Character (rune)\n                }\n            } else if readingBuffer.bytesLeft() >= (n-1) {\n                var x : [UInt8] = [code]\n                for _ in 1..<n {\n                    x.append (readingBuffer.getNext())\n                }\n                x.append(0)\n                x.withUnsafeBytes { ptr in\n                    let unsafeBound = ptr.bindMemory(to: UInt8.self)\n                    let unsafePointer = unsafeBound.baseAddress!\n                    \n                    let s = String (cString: unsafePointer)\n                    ch = s.first ?? Character (\" \")\n\n                    // Now the challenge is that we have a character, not a rune, and we want to compute\n                    // the width of it.\n                    if ch.unicodeScalars.count == 1 {\n                        chWidth = UnicodeUtil.columnWidth(rune: ch.unicodeScalars.first!)\n                    } else {\n                        chWidth = 0\n                        for scalar in ch.unicodeScalars {\n                            chWidth = max (chWidth, UnicodeUtil.columnWidth(rune: scalar))\n                        }\n                    }\n                }\n            } else {\n                readingBuffer.putback (code)\n                return\n            }\n\n            if let firstScalar = ch.unicodeScalars.first {\n                // If this is a Unicode combining character\n                if firstScalar.properties.canonicalCombiningClass != .notReordered {\n                    // Determine if the last time we poked at a character is still valid\n                    if let last = lastBufferStorage {\n                        if last.buffer === buffers.active && last.cols == cols && last.rows == rows {\n                            \n                            // Fetch the old character, and attempt to combine it:\n                            let existingLine = buffer.lines [last.y]\n                            let lastx = last.x >= cols ? cols-1 : last.x\n                            var cd = existingLine [lastx]\n                            \n                            // Attemp the combination\n                            let newStr = String ([cd.getCharacter (), ch])\n                            \n                            // If the resulting string is 1 grapheme cluster, then it combined properly\n                            if newStr.count == 1 {\n                                if let newCh = newStr.first {\n                                    cd.setValue(char: newCh, size: Int32 (cd.width))\n                                    existingLine [lastx] = cd\n                                    updateRange (last.y)\n                                    continue\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            // The accessibility stack might not need this\n            //let screenReaderMode = options.screenReaderMode\n            //if screenReaderMode {\n            //    emitChar (ch)\n            //}\n            let charData = CharData (attribute: curAttr, char: ch, size: Int8 (chWidth))\n            insertCharacter (charData)\n        }\n        updateRange (buffer.y)\n        readingBuffer.done ()\n    }\n    \n    // Inserts the specified character with the computed width into the next cell, following\n    // the rules for wrapping around, scrolling and overflow expected in the terminal.\n    func insertCharacter (_ charData: CharData)\n    {\n        let buffer = self.buffer\n        var chWidth = Int (charData.width)\n        var bufferRow = buffer.lines [buffer.y + buffer.yBase]\n\n        let right = marginMode ? buffer.marginRight : cols - 1\n        // goto next line if ch would overflow\n        // TODO: needs a global min terminal width of 2\n        // FIXME: additionally ensure chWidth fits into a line\n        //   -->  maybe forbid cols<xy at higher level as it would\n        //        introduce a bad runtime penalty here\n        if buffer.x + chWidth - 1 > right {\n            // autowrap - DECAWM\n            // automatically wraps to the beginning of the next line\n            if wraparound {\n                buffer.x = marginMode ? buffer.marginLeft : 0\n\n                if buffer.y >= buffer.scrollBottom {\n                    scroll (isWrapped: true)\n                } else {\n                    // The line already exists (eg. the initial viewport), mark it as a\n                    // wrapped line\n                    buffer.y += 1\n                    buffer.lines [buffer.y].isWrapped = true\n                }\n                // row changed, get it again\n                bufferRow = buffer.lines [buffer.y + buffer.yBase]\n            } else {\n                if (chWidth == 2) {\n                    // FIXME: check for xterm behavior\n                    // What to do here? We got a wide char that does not fit into last cell\n                    return\n                }\n                // FIXME: Do we have to set buffer.x to cols - 1, if not wrapping?\n                buffer.x = right\n            }\n        }\n\n        var empty = CharData.Null\n        empty.attribute = curAttr\n        // insert mode: move characters to right\n        if insertMode {\n            // right shift cells according to the width\n            bufferRow.insertCells (pos: buffer.x, n: chWidth, rightMargin: marginMode ? buffer.marginRight : cols-1, fillData: empty)\n            // test last cell - since the last cell has only room for\n            // a halfwidth char any fullwidth shifted there is lost\n            // and will be set to eraseChar\n            let lastCell = bufferRow [cols - 1]\n            if lastCell.width == 2 {\n                bufferRow [cols - 1] = empty\n            }\n        }\n\n        // write current char to buffer and advance cursor\n        lastBufferStorage = (buffer, buffer.y + buffer.yBase, buffer.x, cols, rows)\n        if buffer.x >= cols {\n            buffer.x = cols-1\n        }\n        bufferRow [buffer.x] = charData\n        buffer.x += 1\n\n        // fullwidth char - also set next cell to placeholder stub and advance cursor\n        // for graphemes bigger than fullwidth we can simply loop to zero\n        // we already made sure above, that buffer.x + chWidth will not overflow right\n        if chWidth > 0 {\n            chWidth -= 1\n            while chWidth != 0 && buffer.x < buffer.cols {\n                bufferRow [buffer.x] = empty\n                buffer.x += 1\n                chWidth -= 1\n            }\n        }\n    }\n\n    func cmdLineFeed ()\n    {\n        cmdLineFeedBasic ()\n    }\n    \n    func cmdLineFeedBasic ()\n    {\n        let buffer = self.buffer\n        let by = buffer.y\n        \n        let canScroll = buffer.x >= buffer.marginLeft && buffer.x <= buffer.marginRight\n        \n        if by == buffer.scrollBottom {\n            if canScroll {\n                scroll(isWrapped: false)\n            }\n        } else if by == rows - 1 {\n        } else {\n                buffer.y = by + 1\n        }\n        \n        // If the end of the line is hit, prevent this action from wrapping around to the next line.\n        if buffer.x >= cols {\n            buffer.x -= 1\n        }\n        \n        // This event is emitted whenever the terminal outputs a LF or NL.\n        emitLineFeed()\n        if lineFeedMode {\n            buffer.x = usingMargins() ? buffer.marginLeft : 0\n        }\n    }\n    \n    //\n    // Backspace handler (Control-h)\n    //\n    func cmdBackspace ()\n    {\n        let buffer = self.buffer\n        restrictCursor(!reverseWraparound)\n        \n        let left = marginMode ? buffer.marginLeft : 0\n        let right = marginMode ? buffer.marginRight : buffer.cols-1\n\n        if buffer.x > left {\n            buffer.x -= 1\n        } else if reverseWraparound {\n            if buffer.x <= left {\n                if buffer.y > buffer.scrollTop && buffer.y <= buffer.scrollBottom && (buffer.lines [buffer.y + buffer.yBase].isWrapped || marginMode) {\n                    if !marginMode {\n                        buffer.lines [buffer.y + buffer.yBase].isWrapped = false\n                    }\n                    \n                    buffer.y -= 1\n                    buffer.x = right\n                // TODO: find actual last cell based on width used\n                } else if buffer.y == buffer.scrollTop {\n                    buffer.x = right\n                    buffer.y = buffer.scrollBottom\n                } else if buffer.y > 0 {\n                    buffer.x = right\n                    buffer.y -= 1\n                }\n            }\n        } else {\n            if buffer.x < left && buffer.x > 0 {\n                // This compensates for the scenario where backspace is supposed to move one step\n                // backwards if the \"x\" position is behind the left margin.\n                // Test BS_MovesLeftWhenLeftOfLeftMargin\n                buffer.x -= 1\n            } else if buffer.x > left {\n                // If we have not reached the limit, we can go back, otherwise stop at the margin\n                // Test BS_StopsAtLeftMargin\n                buffer.x -= 1\n            \n            }\n        }\n    }\n    \n    func cmdCarriageReturn ()\n    {\n        let buffer = self.buffer\n        if marginMode {\n            if buffer.x < buffer.marginLeft {\n                buffer.x = 0\n            } else {\n                buffer.x = buffer.marginLeft\n            }\n        } else {\n            buffer.x = 0\n        }\n    }\n    \n    //\n    // Horizontal tab (control-i)\n    //\n    func cmdTab ()\n    {\n        buffer.x = buffer.nextTabStop ()\n    }\n\n    // SO\n    // ShiftOut (Control-N) Switch to alternate character set.  This invokes the G1 character set\n    func cmdShiftOut ()\n    {\n        setgLevel (1)\n    }\n    \n    // SI\n    // ShiftIn (Control-O) Switch to standard character set.  This invokes the G0 character set\n    func cmdShiftIn ()\n    {\n        setgLevel(0)\n    }\n    \n    // Operating System Commands (OSC)\n    \n    func resetAllColors ()\n    {\n        ansiColors = defaultAnsiColors\n        tdel?.colorChanged (source: self, idx: nil)\n    }\n    \n    func resetColor (_ number: Int)\n    {\n        if number > 255 {\n            return\n        }\n        ansiColors [number] = defaultAnsiColors [number]\n        tdel?.colorChanged(source: self, idx: number)\n    }\n    \n    func oscResetColor (_ data: ArraySlice<UInt8>)\n    {\n        if data == [] {\n            resetAllColors()\n        } else {\n            if let param = String (bytes: data, encoding: .ascii) {\n                let colors = param.split(separator: \";\")\n                for color in colors {\n                    resetColor (Int (color) ?? 0)\n                }\n            }\n        }\n    }\n    \n    // Implements OSC 7 ; URL which records the current working directory\n    func oscSetCurrentDirectory (_ data: ArraySlice<UInt8>)\n    {\n        if !(tdel?.isProcessTrusted(source: self) ?? false) {\n            return\n        }\n        var s = String (bytes:data, encoding: .utf8)\n        if s == nil {\n            s = String (bytes:data, encoding: .ascii)\n        }\n        if let txt = s {\n            hostCurrentDirectory = txt\n            tdel?.hostCurrentDirectoryUpdated (source: self)\n        }\n    }\n    \n    // Implements OSC 6 ; URL which records the current document\n    func oscSetCurrentDocument (_ data: ArraySlice<UInt8>)\n    {\n        if !(tdel?.isProcessTrusted(source: self) ?? false) {\n            return\n        }\n        var s = String (bytes:data, encoding: .utf8)\n        if s == nil {\n            s = String (bytes:data, encoding: .ascii)\n        }\n        if let txt = s {\n            hostCurrentDocument = txt\n            tdel?.hostCurrentDocumentUpdated (source: self)\n        }\n    }\n\n    var hyperLinkTracking: (start: Position, payload: String)? = nil\n    \n    func oscHyperlink (_ data: ArraySlice<UInt8>)\n    {\n        let buffer = self.buffer\n        if data.count == 1 && data [data.startIndex] == UInt8 (ascii: \";\") {\n            // We only had the terminator, so we can close \";\"\n            if let hlt = hyperLinkTracking {\n                let str = hlt.payload\n                if let urlToken = TinyAtom.lookup (value: str) {\n                    //print (\"Setting the text from \\(hlt.start) to \\(buffer.x) on line \\(buffer.y+buffer.yBase) to \\(str)\")\n                    \n                    // Between the time the flag was set, and now `y` might have changed negatively,\n                    // in that case, we do not flag any sequence as a hyperlink\n                    if hlt.start.row <= buffer.y+buffer.yBase {\n                        for y in hlt.start.row...(buffer.y+buffer.yBase) {\n                            let line = buffer.lines [y]\n                            let startCol = y == hlt.start.row ? min (hlt.start.col, cols-1) : 0\n                            let endCol = y == buffer.y ? min (buffer.x, cols-1) : (marginMode ? buffer.marginRight : cols-1)\n                            if endCol > startCol {\n                                for x in startCol...endCol {\n                                    var cd = line [x]\n                                    cd.setPayload(atom: urlToken)\n                                    line [x] = cd\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            hyperLinkTracking = nil\n        } else {\n            hyperLinkTracking = (start: Position(col: buffer.x, row: buffer.y+buffer.yBase), payload: String (bytes:data, encoding: .ascii) ?? \"\")\n        }\n    }\n    \n    // Copy to clipboard with sequence on the form:\n    //    ESC ] 52 ; c ; [base64 data] \\a\n    // where c is for copy and the only thing supported.\n    func oscClipboard (_ data: ArraySlice<UInt8>) {\n        // we require data to start with c; followed by base64 content\n        guard data.count >= 2,\n              data[data.startIndex] == UInt8(ascii: \"c\"),\n              data[data.startIndex+1] == UInt8(ascii: \";\") else {\n            return\n        }\n        \n        let base64 = Data(data[(data.startIndex+2)...])\n        guard let content = Data(base64Encoded: base64) else {\n            return\n        }\n        \n        tdel?.clipboardCopy(source: self, content: content)\n    }\n    \n    // Notifications:\n    //    ESC ] 777 ; notify ; [title] ; [body] \\a\n    func oscNotification(_ data: ArraySlice<UInt8>) {\n        guard let text = String(bytes: data, encoding: .utf8) else {\n            return\n        }\n        \n        let parts = text.components(separatedBy: \";\")\n        guard parts.count >= 3,\n              parts[0] == \"notify\" else {\n            return\n        }\n        \n        let title = parts[1]\n        let body = parts[2...].joined(separator: \";\")\n        tdel?.notify(source: self, title: title, body: body)\n    }\n\n    // OSC 1337 is used by iTerm2 for imgcat and other things:\n    //  https://iterm2.com/documentation-images.html\n    // ESC ] 1337 ; key = value ^G\n    //\n    // Options\n    // ESC ] 1337 ; File = [arguments] : base-64 encoded file contents ^G\n    //\n    func osciTerm2 (_ data: ArraySlice<UInt8>) {\n        // Parses the key-value pairs separated by \";\"\n        func parseKeyValues (_ data: ArraySlice<UInt8>) -> [String:String] {\n            var kv: [String:String] = [:]\n            var current = data.startIndex\n            repeat {\n                let next = data [current..<data.endIndex].firstIndex(where: { b in b == UInt8 (ascii: \";\")}) ?? data.endIndex\n                guard let equalIdx = data [current..<next].firstIndex(where: { b in b == UInt8 (ascii: \"=\")}) else {\n                    break\n                }\n                guard let key = String (bytes: data[current..<equalIdx], encoding: .utf8) else {\n                    break\n                }\n                guard let value = String (bytes: data[equalIdx+1..<next], encoding: .utf8) else {\n                    break\n                }\n                kv [key] = value\n                current = next == data.endIndex ? next : next+1\n            } while current < data.endIndex\n            return kv\n        }\n        \n        /// Parses the dimension specification (\"auto\", \"N%\", \"Npx\" or \"N\") and returns the enum value for it\n        /// puts some artificial limits, to prevent bloat or attacks\n        func parseDimension(_ kv: [String:String], key: String) -> ImageSizeRequest {\n            let artificialDimensionSizeLimit = 1024*4\n            let artificialColumnLimit = 200\n            \n            guard let v = kv [key] else {\n                return .auto\n            }\n            if v == \"auto\" { return .auto }\n            if v.hasSuffix (\"%\") {\n                if let n = Int (v.dropLast(1)), n > 0, n <= 100 { return .percent (n) }\n                return .auto\n            }\n            if v.hasSuffix(\"px\") {\n                if let n = Int (v.dropLast(2)), n > 0, n < artificialDimensionSizeLimit { return .pixels (n) }\n                return .auto\n            }\n            if let n = Int (v), n > 0, n < artificialColumnLimit { return .cells(n) }\n            return .auto\n        }\n        \n        guard let equalIdx = data.firstIndex (where: { b in b == UInt8(ascii: \"=\") }) else {\n            return\n        }\n        \n        guard let key = String(bytes: data[data.startIndex..<equalIdx], encoding: .utf8) else {\n            return\n        }\n        switch key {\n        case \"File\":\n            guard let colonIdx = data [equalIdx...].firstIndex(where: { b in b == UInt8 (ascii: \":\")}) else {\n                return\n            }\n            let kv = parseKeyValues (data [equalIdx+1..<colonIdx])\n            // inline == 1 means to display the image inline, the option == 0 downloads the provided file\n            // into the file system, and I do not think it is a good idea to download data from untrusted\n            // sources like this and potentially override existing files.   So let us just not bother\n            // supporting that\n            if kv[\"inline\"] != \"1\" {\n                return\n            }\n            \n            guard let imgData = Data(base64Encoded: Data(data [colonIdx+1..<data.endIndex])) else {\n                return\n            }\n            let width = parseDimension (kv, key: \"width\")\n            let height = parseDimension (kv, key: \"height\")\n\n            tdel?.createImage(source: self, data: imgData, width: width, height: height, preserveAspectRatio: (kv [\"preserveAspectRatio\"] ?? \"1\" ) == \"1\")\n        default:\n            break\n        }\n        \n        tdel?.iTermContent(source: self, content: data)\n    }\n    \n    // OSC 4\n    func oscChangeOrQueryColorIndex (_ data: ArraySlice<UInt8>)\n    {\n        var parsePos = data.startIndex\n        while parsePos <= data.endIndex {\n            guard let p = data [parsePos...].firstIndex(of: UInt8 (ascii: \";\")) else {\n                return\n            }\n            let color = EscapeSequenceParser.parseInt(data [parsePos..<p])\n            guard color < 256 else {\n                return\n            }\n        \n            // If the request is a query, reply with the current color definition\n            if p+1 < data.endIndex && data [p+1] == UInt8 (ascii: \"?\") {\n                sendResponse (cc.OSC, \"4;\\(color);\\(ansiColors [color].formatAsXcolor())\", cc.ST)\n                parsePos = p+2\n                if parsePos < data.endIndex && data [parsePos] == UInt8(ascii: \";\"){\n                    parsePos += 1\n                }\n                continue\n            }\n    \n            //let str = String (bytes:data, encoding: .ascii) ?? \"\"\n            //print (\"Parsing color definition \\(str)\")\n\n            parsePos = p + 1\n        \n            let end = data [parsePos...].firstIndex(of: UInt8(ascii: \";\")) ?? data.endIndex\n            \n            if let newColor = Color.parseColor (data [parsePos..<end]) {\n                ansiColors [color] = newColor\n                tdel?.colorChanged (source: self, idx: color)\n            }\n            parsePos = end+1\n        }\n        \n        //log (\"Attempt to set the text Foreground color \\(str)\")\n    }\n    \n    func reportColor (oscCode: Int, color: Color) {\n        sendResponse(cc.OSC, \"\\(oscCode);\\(color.formatAsXcolor ())\", cc.ST)\n    }\n    \n    // This handles both setting the foreground, but spill into background and cursor color\n    // if more parameters are provided (ie, sending OSC 10 with #ffffff,#000000,#ff0000\n    // sets the foreground to #ffffff, background to #000000 and cursor to ff0000\n    func oscSetTextForeground (_ data: ArraySlice<UInt8>)\n    {\n        let groups = data.split(separator: UInt8 (ascii: \";\"))\n        var next = 0\n        while next < groups.count {\n            defer { next += 1 }\n            let text = groups [next]\n            \n            if text.first == UInt8 (ascii: \"?\") {\n                switch next {\n                case 0:\n                    reportColor (oscCode: 10, color: foregroundColor)\n                case 1:\n                    reportColor (oscCode: 11, color: backgroundColor)\n                default:\n                    break\n                }\n                \n                continue\n            }\n\n            guard let color = Color.parseColor(text) else {\n                continue\n            }\n            switch next {\n            case 0:\n                foregroundColor = color\n                tdel?.setForegroundColor(source: self, color: color)\n            case 1:\n                backgroundColor = color\n                tdel?.setBackgroundColor(source: self, color: color)\n            case 2:\n                cursorColor = color\n                tdel?.setCursorColor(source: self, color: color)\n                break\n            default:\n                break\n            }\n        }\n    }\n\n    func oscSetTextBackground (_ data: ArraySlice<UInt8>)\n    {\n        if data.first == UInt8 (ascii: \"?\") {\n            reportColor (oscCode: 11, color: backgroundColor)\n            return\n        }\n\n        if let background = Color.parseColor(data) {\n            backgroundColor = background\n            tdel?.setBackgroundColor(source: self, color: background)\n        }\n    }\n\n    func oscSetCursorColor (_ data: ArraySlice<UInt8>)\n    {\n        if let cursorColor = Color.parseColor(data) {\n            self.cursorColor = cursorColor\n            tdel?.setCursorColor(source: self, color: cursorColor)\n        }\n    }\n\n    //\n    // ESC E\n    // C1.NEL\n    //   DEC mnemonic: NEL (https://vt100.net/docs/vt510-rm/NEL)\n    //   Moves cursor to first position on next line.\n    //\n    func cmdNextLine ()\n    {\n        buffer.x = usingMargins () ? buffer.marginLeft : 0\n        cmdIndex ()\n    }\n\n    /**\n     * ESC H\n     * C1.HTS\n     *   DEC mnemonic: HTS (https://vt100.net/docs/vt510-rm/HTS.html)\n     *   Sets a horizontal tab stop at the column position indicated by\n     *   the value of the active column when the terminal receives an HTS.\n     *\n     * @vt: #Y   C1    HTS   \"Horizontal Tabulation Set\" \"\\x88\"    \"Places a tab stop at the current cursor position.\"\n     * @vt: #Y   ESC   HTS   \"Horizontal Tabulation Set\" \"ESC H\"   \"Places a tab stop at the current cursor position.\"\n     */\n    func cmdTabSet ()\n    {\n        buffer.tabSet (pos: buffer.x)\n    }\n    \n    //\n    // CSI Ps @\n    // Insert Ps (Blank) Character(s) (default = 1) (ICH).\n    //\n    func cmdInsertChars (_ pars: [Int], _ collect: cstring)\n    {\n        // Do nothing if we are outside the margin\n        if marginMode && (buffer.x < buffer.marginLeft || buffer.x > buffer.marginRight) {\n            return\n        }\n        let cd = CharData (attribute: eraseAttr ())\n        let buffer = self.buffer\n        \n        buffer.lines [buffer.y + buffer.yBase].insertCells (pos: buffer.x, n: pars.count > 0 ? max (pars [0], 1) : 1, rightMargin: marginMode ? buffer.marginRight : cols-1, fillData: cd)\n\n        updateRange (buffer.y)\n    }\n    \n    //\n    // CSI Ps A\n    // Cursor Up Ps Times (default = 1) (CUU).\n    //\n    func cmdCursorUp (_ pars: [Int], _ collect: cstring)\n    {\n        let param = max (pars.count > 0 ? pars [0] : 1, 1)\n        let buffer = self.buffer\n        var top = buffer.scrollTop\n        \n        if buffer.y < top {\n            top = 0\n        }\n        if (buffer.y - param < top) {\n            buffer.y = top\n        } else {\n            buffer.y -= param\n        }\n    }\n    \n    //\n    // CSI Ps B\n    // Cursor Down Ps Times (default = 1) (CUD).\n    //\n    func cmdCursorDown (_ pars: [Int], _ collect: cstring)\n    {\n        let buffer = self.buffer\n        let param = max (pars.count > 0 ? pars [0] : 1, 1)\n        \n        var bottom = buffer.scrollBottom\n        // When the cursor starts below the scroll region, CUD moves it down to the\n        // bottom of the screen.\n        if buffer.y > bottom {\n            bottom = buffer.rows-1\n        }\n        let newY = buffer.y + param\n\n        if newY >= bottom {\n                buffer.y = bottom\n        } else {\n                buffer.y = newY\n        }\n        // If the end of the line is hit, prevent this action from wrapping around to the next line.\n        if buffer.x >= cols {\n                buffer.x -= 1\n        }\n    }\n    \n    //\n    // CSI Ps B\n    // Cursor Forward Ps Times (default = 1) (CUF).\n    //\n    func cmdCursorForward (_ pars: [Int], _ collect: cstring)\n    {\n        cursorForward(count: pars.count > 0 ? pars [0] : 1)\n    }\n    \n    func cursorForward (count: Int)\n    {\n        var right = marginMode ? buffer.marginRight : cols-1\n        \n        // When the cursor starts after the right margin, CUF moves to the full width\n        if buffer.x > right {\n            right = buffer.cols - 1\n        }\n        buffer.x += (max (count, 1))\n        if buffer.x > right {\n            buffer.x = right\n        }\n    }\n\n    //\n    // CSI Ps D\n    // Cursor Backward Ps Times (default = 1) (CUB).\n    //\n    func cmdCursorBackward (_ pars: [Int], _ collect: cstring)\n    {\n        cursorBackward(count: pars.count > 0 ? pars [0] : 1)\n    }\n    \n    func cursorBackward (count: Int)\n    {\n        let buffer = self.buffer\n        \n        // What is our left margin - depending on the settings.\n        var left = marginMode ? buffer.marginLeft : 0\n        \n        // If the cursor is positioned before the margin, we can go backwards to the first column\n        if buffer.x < left {\n            left = 0\n        }\n        let newX = buffer.x - max (1, count)\n        if newX < left {\n            buffer.x = left\n        } else {\n            buffer.x = newX\n        }\n    }\n\n    //\n    // CSI Ps I\n    //   Cursor Forward Tabulation Ps tab stops (default = 1) (CHT).\n    //\n    func cmdCursorForwardTab (_ pars: [Int], _ collect: cstring)\n    {\n        let param = min (cols-1, max (pars.count > 0 ? pars [0] : 1, 1))\n        for _ in 0..<param {\n            buffer.x = buffer.nextTabStop ()\n        }\n    }\n    \n    /**\n     * Restrict cursor to viewport size / scroll margin (origin mode)\n     * - Parameter limitCols: by default it is true, but the reverseWraparound mechanism in Backspace needs `x` to go beyond.\n     */\n    func restrictCursor(_ limitCols: Bool = true)\n    {\n        buffer.x = min (cols - (limitCols ? 1 : 0), max (0, buffer.x))\n        buffer.y = originMode\n            ? min (buffer.scrollBottom, max (buffer.scrollTop, buffer.y))\n            : min (rows - 1, max (0, buffer.y))\n        \n        updateRange(buffer.y)\n    }\n\n    //\n    // CSI Ps ; Ps H\n    // Cursor Position [row;column] (default = [1,1]) (CUP).\n    //\n    func cmdCursorPosition (_ pars: [Int], _ collect: cstring)\n    {\n        setCursor (col: pars.count >= 2 ? (max (1, pars [1])-1) : 0, row: pars.count >= 1 ? (max (1, pars [0]) - 1) : 0)\n    }\n    \n    func setCursor (col: Int, row: Int)\n    {\n        updateRange(buffer.y)\n        if originMode {\n            buffer.x = col + (usingMargins () ? buffer.marginLeft : 0)\n            buffer.y = buffer.scrollTop + row\n        } else {\n            buffer.x = col\n            buffer.y = row\n        }\n        restrictCursor ()\n    }\n\n    //\n    // CSI Ps E\n    // Cursor Next Line Ps Times (default = 1) (CNL).\n    // same as CSI Ps B?\n    //\n    func cmdCursorNextLine (_ pars: [Int], _ collect: cstring)\n    {\n        cmdCursorDown(pars, collect)\n        buffer.x = buffer.marginLeft\n\n        //return\n        //let buffer = self.buffer\n        //let param = max (pars.count > 0 ? pars [0] : 1, 1)\n        //\n        //var bottom = buffer.scrollBottom\n        //// When the cursor starts below the scroll region, CUD moves it down to the\n        //// bottom of the screen.\n        //if buffer.y > bottom {\n        //    bottom = buffer.rows-1\n        //}\n        //let newY = buffer.y + param\n        //\n        //if newY >= bottom {\n        //        buffer.y = bottom\n        //} else {\n        //        buffer.y = newY\n        //}\n        //// If the end of the line is hit, prevent this action from wrapping around to the next line.\n        //if buffer.x >= cols {\n        //        buffer.x -= 1\n        //}\n        //buffer.x = buffer.marginLeft\n    }\n\n    //\n    // CSI Ps F\n    // Cursor Preceding Line Ps Times (default = 1) (CPL).\n    // reuse CSI Ps A ?\n    //\n    func cmdCursorPrecedingLine (_ pars: [Int], _ collect: cstring)\n    {\n        cmdCursorUp(pars, collect)\n        buffer.x = buffer.marginLeft\n        \n        //let param = max (pars.count > 0 ? pars [0] : 1, 1)\n        //let buffer = self.buffer\n        //var top = buffer.scrollTop\n        //\n        //if buffer.y < top {\n        //    top = 0\n        //}\n        //if (buffer.y - param < top) {\n        //    buffer.y = top\n        //} else {\n        //    buffer.y -= param\n        //}\n        //buffer.x = buffer.marginLeft\n    }\n\n    //\n    // CSI Ps G\n    // Cursor Character Absolute  [column] (default = [row,1]) (CHA).\n    //\n    func cmdCursorCharAbsolute (_ pars: [Int], _ collect: cstring)\n    {\n        let buffer = self.buffer\n        let param = max (pars.count > 0 ? pars [0] : 1, 1)\n\n        buffer.x = (usingMargins() ? buffer.marginLeft : 0) + min (param - 1, cols - 1)\n    }\n\n    //\n    // CSI Ps K  Erase in Line (EL).\n    //     Ps = 0  -> Erase to Right (default).\n    //     Ps = 1  -> Erase to Left.\n    //     Ps = 2  -> Erase All.\n    // CSI ? Ps K\n    //   Erase in Line (DECSEL).\n    //     Ps = 0  -> Selective Erase to Right (default).\n    //     Ps = 1  -> Selective Erase to Left.\n    //     Ps = 2  -> Selective Erase All.\n    //\n    func cmdEraseInLine (_ pars: [Int], _ collect: cstring)\n    {\n        let p = pars.count == 0 ? 0 : pars [0]\n        \n        switch p {\n        case 0:\n            eraseInBufferLine (y: buffer.y, start: buffer.x, end: cols)\n        case 1:\n            eraseInBufferLine (y: buffer.y, start: 0, end: buffer.x + 1)\n        case 2:\n            eraseInBufferLine (y: buffer.y, start: 0, end: cols)\n        default:\n            break\n        }\n        updateRange (buffer.y)\n    }\n\n    //\n    // CSI Ps J  Erase in Display (ED).\n    //     Ps = 0  -> Erase Below (default).\n    //     Ps = 1  -> Erase Above.\n    //     Ps = 2  -> Erase All.\n    //     Ps = 3  -> Erase Saved Lines (xterm).\n    // CSI ? Ps J\n    //   Erase in Display (DECSED).\n    //     Ps = 0  -> Selective Erase Below (default).\n    //     Ps = 1  -> Selective Erase Above.\n    //     Ps = 2  -> Selective Erase All.\n    //\n    func cmdEraseInDisplay (_ pars: [Int], _ collect: cstring)\n    {\n        let p = pars.count == 0 ? 0 : pars [0]\n        var j: Int\n        switch p {\n        case 0:\n            j = buffer.y\n            updateRange (j)\n            eraseInBufferLine (y: j, start: buffer.x, end: cols, clearWrap: buffer.x == 0)\n            j += 1\n            while j < rows {\n                resetBufferLine (y: j)\n                j += 1\n            }\n            updateRange (j - 1)\n            \n        case 1:\n            j = buffer.y\n            updateRange (j)\n            // Deleted front part of line and everything before. This line will no longer be wrapped.\n            eraseInBufferLine (y: j, start: 0, end: buffer.x + 1, clearWrap: true)\n            if buffer.x + 1 >= cols {\n                // Deleted entire previous line. This next line can no longer be wrapped.\n                buffer.lines [j + 1].isWrapped = false\n            }\n            while (j != 0) {\n                j -= 1\n                resetBufferLine (y: j)\n            }\n            updateRange (0)\n        case 2:\n            j = rows\n            updateRange (j - 1)\n            while (j != 0) {\n                j -= 1\n                resetBufferLine (y: j)\n            }\n            updateRange (0)\n        case 3:\n            // Clear scrollback (everything not in viewport)\n            let scrollBackSize = buffer.lines.count - rows\n            if scrollBackSize > 0 {\n                buffer.lines.trimStart (count: scrollBackSize)\n                buffer.linesTop = 0\n                buffer.yBase = max (buffer.yBase - scrollBackSize, 0)\n                buffer.yDisp = max (buffer.yDisp - scrollBackSize, 0)\n            }\n            break;\n        default:\n            break\n        }\n    }\n\n    //\n    // Helper method to erase cells in a terminal row.\n    // The cell gets replaced with the eraseChar of the terminal.\n    // - Parameter y: row index\n    // - Parameter start: first cell index to be erased\n    // - Parameter end:   end - 1 is last erased cell\n    //\n    func eraseInBufferLine (y: Int, start: Int, end: Int, clearWrap: Bool = false, clearRenderMode: Bool = false)\n    {\n        let line = buffer.lines [buffer.yBase + y]\n        line.images = nil\n        let cd = CharData (attribute: eraseAttr ())\n        line.replaceCells (start: start, end: end, fillData: cd)\n        if clearWrap {\n            line.isWrapped = false\n        }\n        if clearRenderMode {\n            line.renderMode = .single\n        }\n    }\n    \n    //\n    // CSI Ps L\n    // Insert Ps Line(s) (default = 1) (IL).\n    //\n    func cmdInsertLines (_ pars: [Int], _ collect: cstring)\n    {\n        let buffer = self.buffer\n        if buffer.y < buffer.scrollTop || buffer.y > buffer.scrollBottom {\n            return\n        }\n        // to prevent a Denial of Service\n        let maxLines = buffer._lines.maxLength * 2\n        var p = min (maxLines, max (pars.count == 0 ? 1 : pars [0], 1))\n        let row = buffer.y + buffer.yBase\n        \n        let scrollBottomRowsOffset = rows - 1 - buffer.scrollBottom\n        let scrollBottomAbsolute = rows - 1 + buffer.yBase - scrollBottomRowsOffset + 1\n        \n        let ea = eraseAttr ()\n        if marginMode {\n            if buffer.x >= buffer.marginLeft && buffer.x <= buffer.marginRight {\n                let columnCount = buffer.marginRight-buffer.marginLeft+1\n                let rowCount = buffer.scrollBottom-buffer.scrollTop\n                for _ in 0..<p {\n                    for i in (0..<rowCount).reversed() {\n                        let src = buffer.lines [row+i]\n                        let dst = buffer.lines [row+i+1]\n                        \n                        dst.copyFrom(src, srcCol: buffer.marginLeft, dstCol: buffer.marginLeft, len: columnCount)\n                    }\n                    \n                    let last = buffer.lines [row]\n                    last.fill (with: CharData (attribute: ea), atCol: buffer.marginLeft, len: columnCount)\n                }\n            }\n        } else {\n            for _ in 0..<p {\n                p -= 1\n                // test: echo -e '\\e[44m\\e[1L\\e[0m'\n                // blankLine(true) - xterm/linux behavior\n                buffer.lines.splice (start: scrollBottomAbsolute - 1, deleteCount: 1, items: [],\n                                     change: { line in updateRange (line) })\n                let newLine = buffer.getBlankLine (attribute: ea)\n                buffer.lines.splice (start: row, deleteCount: 0, items: [newLine], change: { line in updateRange (line) })\n            }\n        }\n        // this.maxRange();\n        updateRange (startLine: buffer.y, endLine: buffer.scrollBottom)\n    }\n    \n    //\n    // ESC ( C\n    //   Designate G0 Character Set, VT100, ISO 2022.\n    // ESC ) C\n    //   Designate G1 Character Set (ISO 2022, VT100).\n    // ESC * C\n    //   Designate G2 Character Set (ISO 2022, VT220).\n    // ESC + C\n    //   Designate G3 Character Set (ISO 2022, VT220).\n    // ESC - C\n    //   Designate G1 Character Set (VT300).\n    // ESC . C\n    //   Designate G2 Character Set (VT300).\n    // ESC / C\n    //   Designate G3 Character Set (VT300). C = A  -> ISO Latin-1 Supplemental. - Supported?\n    //\n    func selectCharset (_ p: ArraySlice<UInt8>)\n    {\n        if p.count == 2 {\n            // print (\"Settin charset to \\(p[1])\")\n        }\n        \n        if (p.count != 2) {\n            cmdSelectDefaultCharset ()\n            return\n        }\n        var ch: UInt8\n        var charset: [UInt8:String]?\n        \n        if CharSets.all.keys.contains(p [1]){\n            charset = CharSets.all [p [1]]!\n        } else {\n            charset = nil\n        }\n        \n        switch p [0] {\n        case UInt8 (ascii: \"(\"):\n            ch = 0\n        case UInt8 (ascii: \")\"):\n            ch = 1\n        case UInt8 (ascii: \"-\"):\n            ch = 1\n        case UInt8 (ascii: \"*\"):\n            ch = 2\n        case UInt8 (ascii: \".\"):\n            ch = 2\n        case UInt8 (ascii: \"+\"):\n            ch = 3\n        case UInt8 (ascii: \"/\"):\n            ch = 3\n        default:\n            return;\n        }\n        setgCharset (ch, charset: charset)\n    }\n\n    func setLineRenderMode (to: BufferLine.RenderLineMode) {\n        buffer.lines [buffer.y + buffer.yBase].renderMode = to\n        updateRange (buffer.y)\n    }\n    \n    //\n    // ESC #6\n    //\n    func cmdDoubleWidthSingleHeight ()\n    {\n        setLineRenderMode(to: .doubleWidth)\n    }\n    \n    //\n    // dhtop\n    //\n    func cmdSetDoubleHeightTop ()\n    {\n        setLineRenderMode(to: .doubledTop)\n    }\n    \n    // dhbot\n    func cmdSetDoubleHeightBottom ()\n    {\n        setLineRenderMode(to: .doubledDown)\n    }\n    \n    //\n    // swsh\n    //\n    func cmdSingleWidthSingleHeight ()\n    {\n        setLineRenderMode(to: .single)\n    }\n    \n    // ESC # 8\n    func cmdScreenAlignmentPattern ()\n    {\n        let cell = CharData(attribute: curAttr.justColor(), char: \"E\")\n\n        setCursor (col: 0, row: 0)\n        for yOffset in 0..<rows {\n            let rowN = buffer.y + buffer.yBase + yOffset\n            buffer.lines [rowN].fill(with: cell)\n            buffer.lines [rowN].isWrapped = false\n        }\n        updateFullScreen()\n        setCursor(col: 0, row: 0)\n    }\n\n    func cmdRestoreCursor (_ pars: [Int], _ collect: cstring)\n    {\n        buffer.x = buffer.savedX\n        buffer.y = buffer.savedY\n        curAttr = buffer.savedAttr\n        charset = buffer.savedCharset\n        originMode = buffer.savedOriginMode\n        marginMode = buffer.savedMarginMode\n        wraparound = buffer.savedWraparound\n        reverseWraparound = buffer.savedReverseWraparound\n    }\n\n    //\n    // Validates optional arguments for top, left, bottom, right sent by various\n    // escape sequences and returns validated top, left, bottom, right in our 0-based\n    // internal coordinates\n    //\n    func getRectangleFromRequest (_ pars: ArraySlice<Int>) -> (top: Int, left: Int, bottom: Int, right: Int)?\n    {\n        let buffer = self.buffer\n        let b = pars.startIndex\n        var top = max (1, pars.count > 0 ? pars [b] : 1)\n        var left = max (pars.count > 1 ? pars [b+1] : 1, 1)\n        var bottom = pars.count > 2 ? pars [b+2] : -1\n        var right = pars.count > 3 ? pars [b+3] : -1\n\n        if bottom < 0 {\n            bottom = rows\n        }\n        if right < 0 {\n            right = cols\n        }\n        if right > cols {\n            right = cols\n        }\n        if bottom > rows {\n            bottom = rows\n        }\n        if originMode {\n            top += buffer.scrollTop\n            bottom += buffer.scrollTop\n            left += buffer.marginLeft\n            right += buffer.marginLeft\n        }\n        if top > bottom || left > right {\n            return nil\n        }\n        //top = min (top, bottom)\n        //left = min (left, right)\n        let rowBound = rows-1\n        let colBound = cols-1\n        return (min (rowBound, top-1), min (colBound, left-1), min (rowBound, bottom-1), min (colBound, right-1))\n    }\n    \n    //\n    // Copy Rectangular Area (DECCRA), VT400 and up.\n    // CSI Pts ; Pls ; Pbs ; Prs ; Pps ; Ptd ; Pld ; Ppd $ v\n    //  Pts ; Pls ; Pbs ; Prs denotes the source rectangle.\n    //  Pps denotes the source page.\n    //  Ptd ; Pld denotes the target location.\n    //  Ppd denotes the target page.\n    func csiCopyRectangularArea (_ ipars: [Int], _ collect: cstring)\n    {\n        if collect.count > 0 && collect == [36] {\n            var pars: [Int] = []\n            pars.append (ipars.count > 1 && ipars [0] != 0 ? ipars [0] : 1) // Pts default 1\n            pars.append (ipars.count > 2 && ipars [1] != 0 ? ipars [1]: 1) // Pls default 1\n            pars.append (ipars.count > 3 && ipars [2] != 0 ? ipars [2]: rows-1) // Pbs default to last line of page\n            pars.append (ipars.count > 4 && ipars [3] != 0 ? ipars [3]: cols-1) // Prs defaults to last column\n            pars.append (ipars.count > 5 && ipars [4] != 0 ? ipars [4]: 1) // Pps page source = 1\n            pars.append (ipars.count > 6 && ipars [5] != 0 ? ipars [5]: 1) // Ptd default is 1\n            pars.append (ipars.count > 7 && ipars [6] != 0 ? ipars [6]: 1) // Pld default is 1\n            pars.append (ipars.count > 8 && ipars [7] != 0 ? ipars [7]: 1) // Ppd default is 1\n            \n            // We only support copying on the same page, and the page being 1\n            if pars [4] == pars [7] && pars [4] == 1 {\n                if let (top, left, bottom, right) = getRectangleFromRequest(pars [0...3]) {\n                    let rowTarget = min (rows-1, pars [5]-1)\n                    let colTarget = min (cols-1, pars [6]-1)\n                    \n                    // Block size\n                    let columns = right-left+1\n                    \n                    let cright = min (cols-1, left + min (columns, cols-colTarget))\n                    \n                    var lines: [[CharData]] = []\n                    for row in top...bottom {\n                        let line = buffer.lines [row+buffer.yBase]\n                        var lineCopy: [CharData] = []\n                        for col in left...cright {\n                            lineCopy.append(line [col])\n                        }\n                        lines.append(lineCopy)\n                    }\n                    \n                    for row in 0...(bottom-top) {\n                        if row+rowTarget >= buffer.rows {\n                            break\n                        }\n                        let line = buffer.lines [row+rowTarget+buffer.yBase]\n                        let lr = lines [row]\n                        for col in 0..<(cright-left) {\n                            if col >= buffer.cols {\n                                break\n                            }\n                            line [colTarget+col] = lr [col]\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // CSI Ps x  Request Terminal Parameters (DECREQTPARM).\n    // CSI Ps * x Select Attribute Change Extent (DECSACE), VT420 and up.\n    // CSI Pc ; Pt ; Pl ; Pb ; Pr $ x Fill Rectangular Area (DECFRA), VT420 and up.\n    func csiX (_ pars: [Int], _ collect: cstring)\n    {\n        if collect.count > 0 && collect == [UInt8 (ascii: \"$\")] {\n            // DECFRA\n            if let (top, left, bottom, right) = getRectangleFromRequest(pars [1...]) {\n                for row in top...bottom {\n                    let line = buffer.lines [row+buffer.yBase]\n                    for col in left...right {\n                        line [col] = CharData(attribute: curAttr, char: Character (UnicodeScalar (pars [0]) ?? \" \"))\n                    }\n                }\n            }\n        } else {\n            log (\"Not implemented CSI x with collect: collect=\\(collect) and pars=\\(pars)\")\n        }\n    }\n\n    //\n    // CSI # }   Pop video attributes from stack (XTPOPSGR), xterm.  Popping\n    //           restores the video-attributes which were saved using XTPUSHSGR\n    //           to their previous state.\n    //\n    // CSI Pm ' }\n    //           Insert Ps Column(s) (default = 1) (DECIC), VT420 and up.\n    //\n    func csiCloseBrace (_ pars: [Int], _ collect: cstring)\n    {\n        if collect.count > 0 && collect == [39 /* ' */] {\n             // DECIC - Insert Column\n            let n = pars.count > 0 ? max (pars [0],1) : 1\n            let buffer = self.buffer\n            \n            if marginMode && buffer.x < buffer.marginLeft || buffer.x > buffer.marginRight {\n                return\n            }\n            \n            for row in buffer.scrollTop...buffer.scrollBottom {\n                let line = buffer.lines [row+buffer.yBase]\n                line.insertCells(pos: buffer.x, n: n, rightMargin: marginMode ? buffer.marginRight : cols-1, fillData: buffer.getNullCell())\n                line.isWrapped = false\n            }\n            return\n        } else {\n            log (\"CSI # } not implemented- XTPOPSGR with \\(pars)\")\n        }\n    }\n    \n    // Required by the test suite\n    // CSI Pi ; Pg ; Pt ; Pl ; Pb ; Pr * y\n    // Request Checksum of Rectangular Area (DECRQCRA), VT420 and up.\n    // Response is\n    // DCS Pi ! ~ x x x x ST\n    //   Pi is the request id.\n    //   Pg is the page number.\n    //   Pt ; Pl ; Pb ; Pr denotes the rectangle.\n    //   The x's are hexadecimal digits 0-9 and A-F.\n    func cmdDECRQCRA (_ pars: [Int], _ collect: cstring)\n    {\n        var checksum: UInt32 = 0\n        let rid = pars.count > 0 ? pars [0] : 1\n        let _ = pars.count > 1 ? pars [1] : 0\n        var result = \"0000\"\n        if (tdel?.isProcessTrusted(source: self) ?? false) && pars.count > 2 {\n            if let (top, left, bottom, right) = getRectangleFromRequest(pars [2...]) {\n                for row in top...bottom {\n                    let line = buffer.lines [row+buffer.yBase]\n                    for col in left...right {\n                        let cd = line [col]\n                        let ch = cd.code == 0 ? \" \" : cd.getCharacter()\n                        \n                        for scalar in ch.unicodeScalars {\n                            checksum += scalar.value\n                        }\n                    }\n                }\n            }\n            result = String(format: \"%04x\", checksum)\n        }\n        sendResponse (cc.DCS, \"\\(rid)!~\\(result)\", cc.ST)\n    }\n\n    // Dispatcher for CSI .* z commands\n    func csiZ (_ pars: [Int], _ collect: cstring)\n    {\n        switch collect {\n        case [UInt8 (ascii: \"$\")]:\n            cmdDECERA (pars)\n        case [UInt8 (ascii: \"'\")]:\n            // Enable Locator Reporting (DECELR).\n            // Valid values for the first parameter:\n            //   Ps = 0  \u21d2  Locator disabled (default).\n            //   Ps = 1  \u21d2  Locator enabled.\n            //   Ps = 2  \u21d2  Locator enabled for one report, then disabled.\n            // The second parameter specifies the coordinate unit for locator\n            // reports.\n            // Valid values for the second parameter:\n            //   Pu = 0  or omitted \u21d2  default to character cells.\n            //   Pu = 1  \u21d0  device physical pixels.\n            //   Pu = 2  \u21d0  character cells.\n            print (\"TODO: Enable Locator Reporting (DECELR)\")\n        default:\n            break\n        }\n    }\n    \n    // DECERA - Erase Rectangular Area\n    // CSI Pt ; Pl ; Pb ; Pr ; $ z\n    func cmdDECERA (_ pars: [Int])\n    {\n        if let (top, left, bottom, right) = getRectangleFromRequest(pars [0...]) {\n            for row in top...bottom {\n                let line = buffer.lines [row+buffer.yBase]\n                for col in left...right {\n                    line [col] = CharData(attribute: curAttr, char: \" \", size: 1)\n                }\n            }\n        }\n    }\n\n    // Dispatches to DECSERA or XTPUSHSGR\n    func csiOpenBrace (_ pars: [Int], _ collect: cstring)\n    {\n        if collect.count > 0 && collect == [UInt8 (ascii: \"$\")] {\n            cmdSelectiveEraseRectangularArea (pars)\n        } else {\n            log (\"CSI # { not implemented - XTPUSHSGR with \\(pars)\")\n        }\n    }\n    \n    // Push video attributes onto stack (XTPUSHSGR), xterm.\n    func cmdPushSg (_ pars: [Int])\n    {\n        \n    }\n    \n    // DECSERA - Selective Erase Rectangular Area\n    // CSI Pt ; Pl ; Pb ; Pr ; $ {\n    func cmdSelectiveEraseRectangularArea (_ pars: [Int])\n    {\n        if let (top, left, bottom, right) = getRectangleFromRequest(pars [0...]) {\n            for row in top...bottom {\n                let line = buffer.lines [row+buffer.yBase]\n                for col in left...right {\n                    var cd = line [col]\n                    cd.setValue(char: \" \", size: 1)\n                    line [col] = cd\n                }\n            }\n        }\n    }\n    /**\n     * Commands send to the `windowCommand` delegate for the front-end to implement capabilities\n     * on behalf of the client.  The expected return strings in some of these enumeration values is documented\n     * below.   Returns are only expected for the enum values that start with the prefix `report`\n     */\n    public enum WindowManipulationCommand {\n        /// Raised when the backend should deiconify a window, no return expected\n        case deiconifyWindow\n        /// Raised when the backend should iconify  a window, no return expected\n        case iconifyWindow\n        /// Raised when the client would like the window to be moved to the x,y position int he screen, not return expected\n        case moveWindowTo(x: Int, y: Int)\n        /// Raised when the client would like the window to be resized to the specified widht and heigh in pixels, not return expected\n        case resizeWindowTo(width: Int, height: Int)\n        /// Raised to bring the terminal to the front\n        case bringToFront\n        /// Send the terminal to the back if possible\n        case sendToBack\n        /// Trigger a terminal refresh\n        case refreshWindow\n        /// Request that the size of the terminal be changed to the specified cols and rows\n        case resizeTo(cols: Int, rows: Int)\n        case restoreMaximizedWindow\n        /// Attempt to maximize the window\n        case maximizeWindow\n        /// Attempt to maximize the window vertically\n        case maximizeWindowVertically\n        /// Attempt to maximize the window horizontally\n        case maximizeWindowHorizontally\n        case undoFullScreen\n        case switchToFullScreen\n        case toggleFullScreen\n        case reportTerminalState\n        case reportTerminalPosition\n        case reportTextAreaPosition\n        case reporttextAreaPixelDimension\n        case reportSizeOfScreenInPixels\n        case reportCellSizeInPixels\n        case reportTextAreaCharacters\n        case reportScreenSizeCharacters\n        case reportIconLabel\n        case reportWindowTitle\n        case resizeTo (lines: Int)\n    }\n\n    // Dispatches to\n    func csit (_ pars: [Int], _ collect: cstring)\n    {\n        switch collect {\n        case []:\n            cmdWindowOptions(pars)\n        case [UInt8 (ascii: \">\")]:\n            cmdXtermTitleModeSet(pars)\n        default:\n            log (\"Unhandled csiT \\(collect)\")\n        }\n    }\n    \n    func cmdXtermTitleModeSet (_ pars: [Int])\n    {\n        // Use the windowTextEncoding type\n        for par in pars {\n            switch par {\n            case 0:\n                // Set window/icon labels using hexadecimal.\n                xtermTitleSetHex = true\n                break\n            case 1:\n                // Query window/icon labels using hexadecimal.\n                xtermTitleQueryHex = true\n                break\n            case 2:\n                // Set window/icon labels using UTF-8.\n                xtermTitleSetUtf = true\n                break\n            case 3:\n                // Query window/icon labels using UTF-8.\n                xtermTitleQueryUtf = true\n                break\n            default:\n                break\n            }\n        }\n    }\n    \n    func cmdXtermTitleModeReset (_ pars: [Int])\n    {\n        // Use the windowTextEncoding type\n        for par in pars {\n            switch par {\n            case 0:\n                // Do not set window/icon labels using hexadecimal.\n                xtermTitleSetHex = false\n                break\n            case 1:\n                // Do not query window/icon labels using hexadecimal\n                xtermTitleQueryHex = false\n                break\n            case 2:\n                // Do not set window/icon labels using UTF-8.\n                xtermTitleSetUtf = false\n                break\n            case 3:\n                // Do not query window/icon labels using UTF-8.\n                xtermTitleQueryUtf = false\n                break\n            default:\n                break\n            }\n        }\n    }\n\n    //\n    // CSI Ps ; Ps ; Ps t - Various window manipulations and reports (xterm)\n    // See https://invisible-island.net/xterm/ctlseqs/ctlseqs.html for a full\n    // list of commans for this escape sequence\n    func cmdWindowOptions (_ pars: [Int])\n    {\n        guard let tdel = self.tdel else {\n            return\n        }\n        switch pars {\n        case [1]:\n            tdel.windowCommand(source: self, command: .deiconifyWindow)\n        case [2]:\n            tdel.windowCommand(source: self, command: .iconifyWindow)\n        case _ where pars.count == 3 && pars.first == 3:\n            tdel.windowCommand(source: self, command: .moveWindowTo(x: pars [1], y: pars[2]))\n        case _ where pars.count == 3 && pars.first == 4:\n            tdel.windowCommand(source: self, command: .moveWindowTo(x: pars [1], y: pars[2]))\n        case [5]:\n            tdel.windowCommand(source: self, command: .bringToFront)\n        case [6]:\n            tdel.windowCommand(source: self, command: .sendToBack)\n        case [7]:\n            tdel.windowCommand(source: self, command: .refreshWindow)\n        case _ where pars.count == 3 && pars.first == 8:\n            tdel.windowCommand(source: self, command: .resizeTo(cols: pars [1], rows: pars [2]))\n        case [9, 0]:\n            tdel.windowCommand(source: self, command: .restoreMaximizedWindow)\n        case [9, 1]:\n            tdel.windowCommand(source: self, command: .maximizeWindow)\n        case [9, 2]:\n            tdel.windowCommand(source: self, command: .maximizeWindowVertically)\n        case [9, 3]:\n            tdel.windowCommand(source: self, command: .maximizeWindowHorizontally)\n        case [10, 0]:\n            tdel.windowCommand(source: self, command: .undoFullScreen)\n        case [10, 1]:\n            tdel.windowCommand(source: self, command: .switchToFullScreen)\n        case [10, 2]:\n            tdel.windowCommand(source: self, command: .toggleFullScreen)\n        case [15]: // Report size in pixels\n            if let r = tdel.windowCommand(source: self, command: .reportSizeOfScreenInPixels) {\n                sendResponse(r)\n            } else {\n                sendResponse (cc.CSI, \"5;768;1024t\")\n            }\n        case [16]: // Report cell size in pixels\n            // If no value is returned send 16x10\n            // TODO: should surface that to the UI, should not do this here\n            if let r = tdel.windowCommand(source: self, command: .reportCellSizeInPixels) {\n                sendResponse(r)\n            } else {\n                sendResponse (cc.CSI, \"6;16;10t\")\n            }\n        case [18]:\n            if let r = tdel.windowCommand(source: self, command: .reportCellSizeInPixels) {\n                sendResponse(r)\n            } else {\n                sendResponse(cc.CSI, \"8;\\(rows);\\(cols)t\")\n            }\n        case [19]:\n            if let r = tdel.windowCommand(source: self, command: .reportScreenSizeCharacters) {\n                sendResponse(r)\n            } else {\n                sendResponse(cc.CSI, \"9;\\(rows);\\(cols)t\")\n            }\n        case [20]:\n            let it = iconTitle.replacingOccurrences(of: \"\\\\\", with: \"\")\n            sendResponse (cc.OSC, \"L\\(it)\", cc.ST)\n        case [21]:\n            let tt = terminalTitle.replacingOccurrences(of: \"\\\\\", with: \"\")\n            sendResponse (cc.OSC, \"l\\(tt)\", cc.ST)\n        case [22, 0]:\n            terminalTitleStack = terminalTitleStack + [terminalTitle]\n            terminalIconStack = terminalIconStack + [iconTitle]\n        case [22, 1]:\n            terminalIconStack = terminalIconStack + [iconTitle]\n        case [22, 2]:\n            terminalTitleStack = terminalTitleStack + [terminalTitle]\n        case [23, 0]:\n            if let nt = terminalTitleStack.last {\n                terminalTitleStack = terminalTitleStack.dropLast()\n                setTitle(text: nt)\n            }\n            if let nt = terminalIconStack.last {\n                terminalIconStack = terminalIconStack.dropLast()\n                setIconTitle(text: nt)\n            }\n        case [23, 1]:\n            if let nt = terminalTitleStack.last {\n                terminalTitleStack = terminalTitleStack.dropLast()\n                setTitle(text: nt)\n            }\n        case [23, 2]:\n            if let nt = terminalIconStack.last {\n                terminalIconStack = terminalIconStack.dropLast()\n                setIconTitle(text: nt)\n            }\n\n        default:\n            log (\"Unhandled Window command: \\(pars)\")\n            break\n        }\n    }\n\n    func cmdSetMargins (_ pars: [Int], _ collect: cstring)\n    {\n        var left = min (cols-1, max (0, (pars.count > 0 ? pars[0] : 1) - 1))\n        let right = min (cols-1, max (0, (pars.count > 1 ? pars [1] : cols) - 1))\n        \n        left = min (left, right)\n        buffer.marginLeft = left\n        buffer.marginRight = right\n    }\n    \n    //\n    //  CSI s (sometimes, if the margin mode is false)\n    //  ESC 7\n    //   Save cursor (ANSI.SYS).\n    //\n    func cmdSaveCursor (_ pars: [Int], _ collect: cstring)\n    {\n        buffer.savedX = buffer.x\n        buffer.savedY = buffer.y\n        buffer.savedAttr = curAttr\n        buffer.savedCharset = charset\n        buffer.savedWraparound = wraparound\n        buffer.savedOriginMode = originMode\n        buffer.savedMarginMode = marginMode\n        buffer.savedReverseWraparound = reverseWraparound\n    }\n\n    //\n    // CSI Ps ; Ps r\n    //   Set Scrolling Region [top;bottom] (default = full size of window) (DECSTBM).\n    // CSI ? Pm r\n    //\n    func cmdSetScrollRegion (_ pars: [Int], _ collect: cstring)\n    {\n        if collect != [] {\n            return\n        }\n        let buffer = self.buffer\n        let top = pars.count > 0 ? max (pars [0] - 1, 0) : 0\n        var bottom = rows\n        if pars.count > 1 {\n            // bottom = 0 means \"bottom of the screen\"\n            let p = pars [1]\n            if p != 0 {\n                bottom = min (pars [1], rows)\n            }\n        }\n        // normalize\n        bottom -= 1\n        \n        // only set the scroll region if top < bottom\n        if top < bottom {\n            buffer.scrollBottom = bottom\n            buffer.scrollTop = top\n        }\n        setCursor(col: 0, row: 0)\n    }\n\n    public func setCursorStyle (_ style: CursorStyle)\n    {\n        if options.cursorStyle != style {\n            tdel?.cursorStyleChanged(source: self, newStyle: style)\n            options.cursorStyle = style\n        }\n    }\n    \n    //\n    // CSI Ps SP q  Set cursor style (DECSCUSR, VT520).\n    //   Ps = 0  -> blinking block.\n    //   Ps = 1  -> blinking block (default).\n    //   Ps = 2  -> steady block.\n    //   Ps = 3  -> blinking underline.\n    //   Ps = 4  -> steady underline.\n    //   Ps = 5  -> blinking bar (xterm).\n    //   Ps = 6  -> steady bar (xterm).\n    //\n    func cmdSetCursorStyle (_ pars: [Int], _ collect: cstring)\n    {\n        if collect.count == 0 || collect != [32] { /* space */\n            return\n        }\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n        switch (p) {\n        case 1, 0:\n            setCursorStyle (.blinkBlock)\n        case 2:\n            setCursorStyle (.steadyBlock)\n        case 3:\n            setCursorStyle (.blinkUnderline)\n        case 4:\n            setCursorStyle (.steadyUnderline)\n        case 5:\n            setCursorStyle (.blinkBar)\n        case 6:\n            setCursorStyle (.steadyBar)\n        default:\n            break;\n        }\n    }\n\n    func cmdDecRqm (_ pars: [Int], decMode: Bool) {\n        let modeUnknown = 0\n        let modeSet = 1\n        let modeReset = 2\n        //let modeAlwaysSet = 3\n        let modeAlwaysReset = 4\n        \n        // Same as reset for now, but it is something that should change if the companion setting is ever implemented\n        let modeCouldBeImplementedButReset = 2\n        let modeCouldBeImplementedButSet = 1\n        \n        guard let mode = pars.first else {\n            sendResponse (cc.CSI, \";0$y\")\n            return\n        }\n        var res = modeUnknown\n        if decMode {\n            switch mode {\n            case 1: // DECCKM\n                res = applicationCursor ? modeSet : modeReset\n            case 2: // DECCKM - reserved for VT52 emulation\n                res = modeSet\n            case 3: // DECCOLM - 132 Column Mode\n                res = buffer.cols == 132 ? modeSet : modeReset\n            case 4: // DECSCLM - Smooth/jump scroll, we dont implement\n                res = smoothScroll ? modeSet : modeReset\n            case 5: // DECSCNM - Reverse Display Colors\n                res = curAttr == CharData.invertedAttr ? modeSet : modeReset\n            case 6: // DECOM - cursor origin\n                res = originMode ? modeSet : modeReset\n            case 7: // DECAWM - Wraparound Mode\n                res = wraparound ? modeSet : modeReset\n            case 8: // DECARM - Autorepeat mode\n                res = modeCouldBeImplementedButSet\n            case 9:\n                res = mouseMode == .x10 ? modeSet : modeReset\n            case 10:\n                res = modeAlwaysReset\n            case 12: // ATT610_BLINK\n                res = cursorBlink ? modeSet : modeReset\n            case 13: // user cursor blink setting\n                res = modeCouldBeImplementedButReset\n            case 14: // cursor blink xor\n                res = modeCouldBeImplementedButReset\n            case 18: // DECPFF - Print screen with form feed\n                res = modeCouldBeImplementedButSet\n            case 19: // DECPEX - print region limitation\n                res = modeCouldBeImplementedButSet\n            case 25: // DECTCEM cursor visbiolity\n                res = cursorHidden ? modeReset : modeSet\n            case 30: // RXVT show scrollbar\n                res = modeCouldBeImplementedButReset\n            case 40: // Enable 80 to 132 transition\n                res = allow80To132 ? modeSet : modeReset\n            case 41: // xterm tab workaround in \"more(1)\" command\n                res = modeReset\n            case 42: // DECNRCM - national character set\n                res = modeAlwaysReset\n            case 44: // MARGIN_BELL\n                res = modeAlwaysReset\n            case 45: // REVERSEWRAP\n                res = reverseWraparound ? modeSet : modeReset\n            case 46: // allow logging\n                res = modeAlwaysReset\n            case 47: // ALTBUF - alternate screen buffer\n                res = buffers.isAlternateBuffer ? modeSet : modeReset\n            case 66: // DECNKCM\n                res = applicationKeypad ? modeSet : modeReset\n            case 67: // backspace sends delete\n                res = modeAlwaysReset\n            case 69: // DECLRMM - mmargins\n                res = marginMode ? modeSet : modeReset\n            case 80: // DECSDM - Sixel scrolling\n                res = modeAlwaysReset\n            case 95: // DECNCSM - clear on DECCOLM changes\n                res = modeCouldBeImplementedButSet\n            case 1000:\n                res = mouseMode == .vt200 ? modeSet : modeReset\n            case 1001:\n                res = modeCouldBeImplementedButReset\n            case 1002:\n                res = mouseMode == .buttonEventTracking ? modeSet : modeReset\n            case 1003:\n                res = mouseMode == .anyEvent ? modeSet : modeReset\n            case 1004:\n                res = sendFocus ? modeSet : modeReset\n            case 1005:\n                res = mouseProtocol == .utf8 ? modeSet : modeReset\n            case 1006:\n                res = mouseProtocol == .sgr ? modeSet : modeReset\n            case 1015:\n                res = mouseProtocol == .urxvt ? modeSet : modeReset\n            case 1034:\n                // This is the esc+key toggles top bit, in this UTF world, I dont think it is worth support it ever.\n                res = modeAlwaysReset\n                // 1035, 1036, 1037, 1039, 1040, 1042, 1043, 1046\n                // 1047 - what does this even do?\n                // 1048, 1049,\n                // keyboard emulation mode: 1050, 1051, 1052, 1053, 1060, 1061\n            case 2004:\n                res = bracketedPasteMode ? modeSet : modeReset\n            default:\n                break\n            }\n        } else {\n            switch mode {\n            case 1: // GATM - guarded area transfer\n                res = modeAlwaysReset\n            case 2: // Disable keyboard input KAM\n                // If implemented elsewhere, this can be added here, but I have reservations about this\n                res = modeCouldBeImplementedButReset\n            case 3: // CRM - Display control characters\n                res = modeCouldBeImplementedButReset\n            case 4: // IRM Insert mode\n                res = insertMode ? modeSet : modeReset\n            case 5: // SRTM Status reporting transfer\n                res = modeAlwaysReset\n            case 7: // VEM vertical editing\n                res = modeAlwaysReset\n            case 10: // HEM horizontal editing\n                res = modeAlwaysReset\n            case 11: // PUM positioning unit\n                res = modeAlwaysReset\n            case 12: // SRM send-receive mode, update when we implement\n                res = modeCouldBeImplementedButSet\n            case 13: // FEAM Format effector action\n                res = modeAlwaysReset\n            case 14: // FETM Format effector transfer\n                res = modeAlwaysReset\n            case 15: // MATM Multiple area transfer\n                res = modeAlwaysReset\n            case 16: // TTM transfer termination\n                res = modeAlwaysReset\n            case 17: // SATM selected area transfer\n                res = modeAlwaysReset\n            case 18: // TSM tabulation stop\n                res = modeAlwaysReset\n            case 19: // EBM Editing Boundary\n                res = modeAlwaysReset\n            case 20: // LNM Line feed/newline\n                res = lineFeedMode ? modeSet : modeReset\n            default:\n                break\n            }\n        }\n        sendResponse (cc.CSI, \"\\(mode);\\(res)$y\")\n    }\n    \n    //\n    // Proxy for various CSI .* p commands\n    func csiPHandler (_ pars: [Int], _ collect: cstring)\n    {\n        switch collect {\n        case [UInt8 (ascii: \"!\")]:\n            cmdSoftReset ()\n        case [UInt8 (ascii: \"\\\"\")]:\n            cmdSetConformanceLevel (pars, collect)\n            \n            // DECRQM - CSI ? Pa $ p\n            // Request DEC mode\n        case [63, 36]:\n            cmdDecRqm (pars, decMode: true);\n        \n            // DECRQM - CSI Pa $ p\n            // Request ANSI mode\n        case [36]:\n            cmdDecRqm (pars, decMode: false);\n        default:\n            log (\"Unhandled CSI \\(String (cString: collect)) with pars=\\(pars)\")\n        }\n    }\n    \n    // CSI Pl ; Pc \" p\n    // Set conformance level (DECSCL), VT220 and up\n    func cmdSetConformanceLevel (_ pars: [Int], _ collect: cstring)\n    {\n        if pars.count > 0 {\n            let level = pars [0]\n            switch level {\n            case 61:\n                conformance = .vt100\n                cc.send8bit = false\n            case 62:\n                conformance = .vt200\n            case 63:\n                conformance = .vt300\n            case 64:\n                conformance = .vt400\n            case 65:\n                conformance = .vt500\n            default:\n                conformance = .vt500\n            }\n        }\n        if pars.count > 1 && conformance != .vt100 {\n            switch pars [1] {\n            case 0:\n                cc.send8bit = true\n            case 2:\n                cc.send8bit = true\n            default:\n                cc.send8bit = false\n            }\n        }\n    }\n    \n    //\n    // http://vt100.net/docs/vt220-rm/table4-10.html\n    //\n    /* ! - CSI ! p   Soft terminal reset (DECSTR). */\n    func cmdSoftReset ()\n    {\n        cursorHidden = false\n        insertMode = false\n        originMode = false\n\n        reverseWraparound = false\n        \n        wraparound = true  // defaults: xterm - true, vt100 - false\n        applicationKeypad = false\n        syncScrollArea ()\n        applicationCursor = false\n        buffer.scrollTop = 0\n        buffer.scrollBottom = rows - 1\n        curAttr = CharData.defaultAttr\n        buffer.softReset ()\n\n        charset = nil\n        setgLevel (0)\n        conformance = .vt500\n        hyperLinkTracking = nil\n        lineFeedMode = options.convertEol\n        resetAllColors()\n        tdel?.showCursor(source: self)\n        // MIGUEL TODO:\n        // TODO: audit any new variables, those in setup might be useful\n    }\n\n    /// Performs a terminal soft-reset, the equivalent of the DECSTR sequence\n    /// For a full reset see `resetToInitialState`\n    public func softReset ()\n    {\n        cmdSoftReset()\n    }\n    \n    //\n    // CSI Ps n  Device Status Report (DSR).\n    //     Ps = 5  -> Status Report.  Result (``OK'') is\n    //   CSI 0 n\n    //     Ps = 6  -> Report Cursor Position (CPR) [row;column].\n    //   Result is\n    //   CSI r ; c R\n    // CSI ? Ps n\n    //   Device Status Report (DSR, DEC-specific).\n    //     Ps = 6  -> Report Cursor Position (CPR) [row;column] as CSI\n    //     ? r ; c R (assumes page is zero).\n    //     Ps = 1 5  -> Report Printer status as CSI ? 1 0  n  (ready).\n    //     or CSI ? 1 1  n  (not ready).\n    //     Ps = 2 5  -> Report UDK status as CSI ? 2 0  n  (unlocked)\n    //     or CSI ? 2 1  n  (locked).\n    //     Ps = 2 6  -> Report Keyboard status as\n    //   CSI ? 2 7  ;  1  ;  0  ;  0  n  (North American).\n    //   The last two parameters apply to VT400 & up, and denote key-\n    //   board ready and LK01 respectively.\n    //     Ps = 5 3  -> Report Locator status as\n    //   CSI ? 5 3  n  Locator available, if compiled-in, or\n    //   CSI ? 5 0  n  No Locator, if not.\n    //\n    func cmdDeviceStatus (_ pars: [Int], _ collect: cstring)\n    {\n        let buffer = self.buffer\n        if collect.count == 0 {\n            switch (pars [0]) {\n            case 5:\n                // status report\n                sendResponse (cc.CSI, \"0n\")\n            case 6:\n                // cursor position\n                let y = max (1, buffer.y + 1 - (originMode ? buffer.scrollTop : 0))\n                \n                // Need the max, because the cursor could be before the leftMargin\n                let x = max (1, buffer.x + 1 - (originMode ? buffer.marginLeft : 0))\n                sendResponse (cc.CSI, \"\\(y);\\(x)R\")\n            default:\n                break;\n            }\n        } else if (collect == [UInt8 (ascii: \"?\")]) {\n            // modern xterm doesnt seem to\n            // respond to any of these except ?6, 6, and 5\n            switch pars [0] {\n            case 6:\n                // cursor position\n                let y = buffer.y + 1 - (originMode ? buffer.scrollTop : 0)\n                // Need the max, because the cursor could be before the leftMargin\n                let x = max (1, buffer.x + 1  - (usingMargins () ? buffer.marginLeft : 0))\n                sendResponse (cc.CSI, \"?\\(y);\\(x);1R\")\n            case 15:\n                // Request printer status report, we respond \"We are ready\"\n                sendResponse(cc.CSI, \"?10n\")\n                break;\n            case 25:\n                // We respond \"User defined keys are locked\"\n                sendResponse(cc.CSI, \"?21n\")\n                break;\n            case 26:\n                // Requests keyboard type\n                // We respond \"American keyboard\", TODO: worth plugging something else?  Mac perhaps?\n                sendResponse(cc.CSI, \"?27;1;0;0n\")\n    \n                break;\n            case 53:\n                // TODO: no dec locator/mouse\n                // this.handler(C0.ESC + '[?50n');\n                break;\n            case 55:\n                // Request locator status\n                sendResponse(cc.CSI, \"?53n\")\n            case 56:\n                // What kind of locator we have, we reply mouse, but perhaps on iOS we should respond something else\n                sendResponse(cc.CSI, \"?57;1n\")\n            case 62:\n                // Macro space report\n                sendResponse(cc.CSI, \"0*{\")\n            case 63:\n                // Requests checksum of macros, we return 0\n                let id = pars.count > 1 ? pars [1] : 0\n                sendResponse(cc.DCS, \"\\(id)!~0000\", cc.ST)\n            case 75:\n                // Data integrity report, no issues:\n                sendResponse (cc.CSI, \"?70n\")\n            case 85:\n                // Multiple session status, we reply single session\n                sendResponse (cc.CSI, \"?83n\")\n            default:\n                break\n            }\n        }\n    }\n\n    //\n    // CSI Pm m  Character Attributes (SGR).\n    //     Ps = 0  -> Normal (default).\n    //     Ps = 1  -> Bold.\n    //     Ps = 2  -> Faint, decreased intensity (ISO 6429).\n    //     Ps = 4  -> Underlined.\n    //     Ps = 5  -> Blink (appears as Bold).\n    //     Ps = 7  -> Inverse.\n    //     Ps = 8  -> Invisible, i.e., hidden (VT300).\n    //     Ps = 9  -> Crossed out character\n    //     Ps = 2 2  -> Normal (neither bold nor faint).\n    //     Ps = 2 4  -> Not underlined.\n    //     Ps = 2 5  -> Steady (not blinking).\n    //     Ps = 2 7  -> Positive (not inverse).\n    //     Ps = 2 8  -> Visible, i.e., not hidden (VT300).\n    //     Ps = 2 9  -> Not crossed out\n    //     Ps = 3 0  -> Set foreground color to Black.\n    //     Ps = 3 1  -> Set foreground color to Red.\n    //     Ps = 3 2  -> Set foreground color to Green.\n    //     Ps = 3 3  -> Set foreground color to Yellow.\n    //     Ps = 3 4  -> Set foreground color to Blue.\n    //     Ps = 3 5  -> Set foreground color to Magenta.\n    //     Ps = 3 6  -> Set foreground color to Cyan.\n    //     Ps = 3 7  -> Set foreground color to White.\n    //     Ps = 3 9  -> Set foreground color to default (original).\n    //     Ps = 4 0  -> Set background color to Black.\n    //     Ps = 4 1  -> Set background color to Red.\n    //     Ps = 4 2  -> Set background color to Green.\n    //     Ps = 4 3  -> Set background color to Yellow.\n    //     Ps = 4 4  -> Set background color to Blue.\n    //     Ps = 4 5  -> Set background color to Magenta.\n    //     Ps = 4 6  -> Set background color to Cyan.\n    //     Ps = 4 7  -> Set background color to White.\n    //     Ps = 4 9  -> Set background color to default (original).\n    //\n    //   If 16-color support is compiled, the following apply.  Assume\n    //   that xterm's resources are set so that the ISO color codes are\n    //   the first 8 of a set of 16.  Then the aixterm colors are the\n    //   bright versions of the ISO colors:\n    //     Ps = 9 0  -> Set foreground color to Black.\n    //     Ps = 9 1  -> Set foreground color to Red.\n    //     Ps = 9 2  -> Set foreground color to Green.\n    //     Ps = 9 3  -> Set foreground color to Yellow.\n    //     Ps = 9 4  -> Set foreground color to Blue.\n    //     Ps = 9 5  -> Set foreground color to Magenta.\n    //     Ps = 9 6  -> Set foreground color to Cyan.\n    //     Ps = 9 7  -> Set foreground color to White.\n    //     Ps = 1 0 0  -> Set background color to Black.\n    //     Ps = 1 0 1  -> Set background color to Red.\n    //     Ps = 1 0 2  -> Set background color to Green.\n    //     Ps = 1 0 3  -> Set background color to Yellow.\n    //     Ps = 1 0 4  -> Set background color to Blue.\n    //     Ps = 1 0 5  -> Set background color to Magenta.\n    //     Ps = 1 0 6  -> Set background color to Cyan.\n    //     Ps = 1 0 7  -> Set background color to White.\n    //\n    //   If xterm is compiled with the 16-color support disabled, it\n    //   supports the following, from rxvt:\n    //     Ps = 1 0 0  -> Set foreground and background color to\n    //     default.\n    //\n    //   If 88- or 256-color support is compiled, the following apply.\n    //     Ps = 3 8  ; 5  ; Ps -> Set foreground color to the second\n    //     Ps.\n    //     Ps = 4 8  ; 5  ; Ps -> Set background color to the second\n    //     Ps.\n    //\n    func cmdCharAttributes (_ pars: [Int], _ collect: cstring)\n    {\n        // Optimize a single SGR0.\n        if pars.count == 1 && pars [0] == 0 {\n            curAttr = CharData.defaultAttr\n            return;\n        }\n\n        let parCount = pars.count\n        //let empty = CharacterStyle (attribute: 0)\n        var style = curAttr.style\n        var fg = curAttr.fg\n        var bg = curAttr.bg\n        let def = CharData.defaultAttr\n\n        var i = 0\n        \n        // Extended Colors\n        //\n        // There is an ambiguity here that is troublesome, to support extended\n        // colors and colorspaces, two competing systems exists, one uses for example:\n        // 38;2;R;G;B;NEXT - foreground true color\n        // 38:2:ColorSpace:R:G:B:REST;NEXT - second style for the same\n        //\n        // The former apparently was a mistake, but we need to disambiguate the meaning\n        // of pars, based on whether the above uses \":\" or \";\" we need that, because\n        // the SGR is a collection of attributes, so after our parameter values, we\n        // need to continue processing\n        //\n        //\n        func parseExtendedColor () -> Attribute.Color? {\n            var color: Attribute.Color? = nil\n            let v = parser._parsTxt\n            \n            // If this is the new style\n            if v.count > 2 && v [2] == UInt8(ascii: \":\") {\n                switch pars [i] {\n                case 2: // RGB color\n                    i += 1\n                    // Color style, we ignore \"ColorSpace\"\n\n                    if i+3 < parCount {\n                        color = Attribute.Color.trueColor(\n                              red: UInt8(min (pars [i+1], 255)),\n                            green: UInt8(min (pars [i+2], 255)),\n                             blue: UInt8(min (pars [i+3], 255)))\n                        i += 4\n                    }\n                default:\n                    break\n                }\n            } else {\n                switch pars [i] {\n                case 2: // RGB color\n                    i += 1\n                    if i+2 < parCount {\n                        color = Attribute.Color.trueColor(\n                              red: UInt8(min (pars [i], 255)),\n                            green: UInt8(min (pars [i+1], 255)),\n                             blue: UInt8(min (pars [i+2], 255)))\n                        i += 3\n                    }\n                    \n                case 3: // CMY color - not supported\n                    break\n                    \n                case 4: // CMYK color - not supported\n                    break\n                    \n                case 5: // indexed color\n                    if i+1 < parCount {\n                        color = Attribute.Color.ansi256(code: UInt8 (min (255, pars [i+1])))\n                        i += 1\n                    }\n                    i += 1\n\n                default:\n                    break\n                }\n            }\n            return color\n        }\n        \n        while i < parCount {\n            var p = pars [i]\n            switch p {\n            case 0:\n                // default\n                style = def.style\n                fg = def.fg\n                bg = def.bg\n            case 1:\n                // bold text\n                style = [style, .bold]\n            case 2:\n                // dimmed text\n                style = [style, .dim]\n            case 3:\n                // italic text\n                style = [style, .italic]\n            case 4:\n                // underlined text\n                style = [style, .underline]\n            case 5:\n                // blink\n                style = [style, .blink]\n            case 7:\n                // inverse and positive\n                // test with: echo -e '\\e[31m\\e[42mhello\\e[7mworld\\e[27mhi\\e[m'\n                style = [style, .inverse]\n            case 8:\n                // invisible\n                style = [style, .invisible]\n            case 9:\n                style = [style, .crossedOut]\n            case 21:\n                // double underline\n                break\n            case 22:\n                // not bold nor faint\n                style.remove (.bold)\n                style.remove (.dim)\n            case 23:\n                // not italic\n                style.remove (.italic)\n            case 24:\n                // not underlined\n                style.remove (.underline)\n            case 25:\n                // not blink\n                style.remove (.blink)\n            case 27:\n                // not inverse\n                style.remove (.inverse)\n            case 28:\n                // not invisible\n                style.remove (.invisible)\n            case 29:\n                // not crossed out\n                style.remove (.crossedOut)\n            case 30...37:\n                // fg color 8\n                fg = Attribute.Color.ansi256(code: UInt8(p - 30))\n            case 38:\n                i += 1\n                if let parsed = parseExtendedColor () {\n                    fg = parsed\n                }\n                continue\n            case 39:\n                // reset fg\n                fg = CharData.defaultAttr.fg\n            case 40...47:\n                // bg color 8\n                bg = Attribute.Color.ansi256(code: UInt8(p - 40))\n            case 48:\n                i += 1\n                if let parsed = parseExtendedColor() {\n                    bg = parsed\n                }\n                continue\n                \n            case 49:\n                // reset bg\n                bg = CharData.defaultAttr.bg\n            case 90...97:\n                // fg color 16\n                p += 8\n                fg = Attribute.Color.ansi256(code: UInt8(p - 90))\n            case 100...107:\n                // bg color 16\n                p += 8;\n                bg = Attribute.Color.ansi256(code: UInt8(p - 100))\n            default:\n                log (\"Unknown SGR attribute: \\(p) \\(pars)\")\n            }\n            i += 1\n        }\n        curAttr = Attribute(fg: fg, bg: bg, style: style)\n    }\n\n    //\n    //CSI Pm l  Reset Mode (RM).\n    //    Ps = 2  -> Keyboard Action Mode (AM).\n    //    Ps = 4  -> Replace Mode (IRM).\n    //    Ps = 1 2  -> Send/receive (SRM).\n    //    Ps = 2 0  -> Normal Linefeed (LNM).\n    //CSI ? Pm l\n    //  DEC Private Mode Reset (DECRST).\n    //    Ps = 1  -> Normal Cursor Keys (DECCKM).\n    //    Ps = 2  -> Designate VT52 mode (DECANM).\n    //    Ps = 3  -> 80 Column Mode (DECCOLM).\n    //    Ps = 4  -> Jump (Fast) Scroll (DECSCLM).\n    //    Ps = 5  -> Normal Video (DECSCNM).\n    //    Ps = 6  -> Normal Cursor Mode (DECOM).\n    //    Ps = 7  -> No Wraparound Mode (DECAWM).\n    //    Ps = 8  -> No Auto-repeat Keys (DECARM).\n    //    Ps = 9  -> Don't send Mouse X & Y on button press.\n    //    Ps = 1 0  -> Hide toolbar (rxvt).\n    //    Ps = 1 2  -> Stop Blinking Cursor (att610).\n    //    Ps = 1 8  -> Don't print form feed (DECPFF).\n    //    Ps = 1 9  -> Limit print to scrolling region (DECPEX).\n    //    Ps = 2 5  -> Hide Cursor (DECTCEM).\n    //    Ps = 3 0  -> Don't show scrollbar (rxvt).\n    //    Ps = 3 5  -> Disable font-shifting functions (rxvt).\n    //    Ps = 4 0  -> Disallow 80 -> 132 Mode.\n    //    Ps = 4 1  -> No more(1) fix (see curses resource).\n    //    Ps = 4 2  -> Disable Nation Replacement Character sets (DEC-\n    //    NRCM).\n    //    Ps = 4 4  -> Turn Off Margin Bell.\n    //    Ps = 4 5  -> No Reverse-wraparound Mode.\n    //    Ps = 4 6  -> Stop Logging.  (This is normally disabled by a\n    //    compile-time option).\n    //    Ps = 4 7  -> Use Normal Screen Buffer.\n    //    Ps = 6 6  -> Numeric keypad (DECNKM).\n    //    Ps = 6 7  -> Backarrow key sends delete (DECBKM).\n    //    Ps = 1 0 0 0  -> Don't send Mouse X & Y on button press and\n    //    release.  See the section Mouse Tracking.\n    //    Ps = 1 0 0 1  -> Don't use Hilite Mouse Tracking.\n    //    Ps = 1 0 0 2  -> Don't use Cell Motion Mouse Tracking.\n    //    Ps = 1 0 0 3  -> Don't use All Motion Mouse Tracking.\n    //    Ps = 1 0 0 4  -> Don't send FocusIn/FocusOut events.\n    //    Ps = 1 0 0 5  -> Disable Extended Mouse Mode.\n    //    Ps = 1 0 1 0  -> Don't scroll to bottom on tty output\n    //    (rxvt).\n    //    Ps = 1 0 1 1  -> Don't scroll to bottom on key press (rxvt).\n    //    Ps = 1 0 3 4  -> Don't interpret \"meta\" key.  (This disables\n    //    the eightBitInput resource).\n    //    Ps = 1 0 3 5  -> Disable special modifiers for Alt and Num-\n    //    Lock keys.  (This disables the numLock resource).\n    //    Ps = 1 0 3 6  -> Don't send ESC  when Meta modifies a key.\n    //    (This disables the metaSendsEscape resource).\n    //    Ps = 1 0 3 7  -> Send VT220 Remove from the editing-keypad\n    //    Delete key.\n    //    Ps = 1 0 3 9  -> Don't send ESC  when Alt modifies a key.\n    //    (This disables the altSendsEscape resource).\n    //    Ps = 1 0 4 0  -> Do not keep selection when not highlighted.\n    //    (This disables the keepSelection resource).\n    //    Ps = 1 0 4 1  -> Use the PRIMARY selection.  (This disables\n    //    the selectToClipboard resource).\n    //    Ps = 1 0 4 2  -> Disable Urgency window manager hint when\n    //    Control-G is received.  (This disables the bellIsUrgent\n    //    resource).\n    //    Ps = 1 0 4 3  -> Disable raising of the window when Control-\n    //    G is received.  (This disables the popOnBell resource).\n    //    Ps = 1 0 4 7  -> Use Normal Screen Buffer, clearing screen\n    //    first if in the Alternate Screen.  (This may be disabled by\n    //    the titeInhibit resource).\n    //    Ps = 1 0 4 8  -> Restore cursor as in DECRC.  (This may be\n    //    disabled by the titeInhibit resource).\n    //    Ps = 1 0 4 9  -> Use Normal Screen Buffer and restore cursor\n    //    as in DECRC.  (This may be disabled by the titeInhibit\n    //    resource).  This combines the effects of the 1 0 4 7  and 1 0\n    //    4 8  modes.  Use this with terminfo-based applications rather\n    //    than the 4 7  mode.\n    //    Ps = 1 0 5 0  -> Reset terminfo/termcap function-key mode.\n    //    Ps = 1 0 5 1  -> Reset Sun function-key mode.\n    //    Ps = 1 0 5 2  -> Reset HP function-key mode.\n    //    Ps = 1 0 5 3  -> Reset SCO function-key mode.\n    //    Ps = 1 0 6 0  -> Reset legacy keyboard emulation (X11R6).\n    //    Ps = 1 0 6 1  -> Reset keyboard emulation to Sun/PC style.\n    //    Ps = 2 0 0 4  -> Reset bracketed paste mode.\n    //\n    func cmdResetMode (_ pars: [Int], _ collect: cstring)\n    {\n        if pars.count == 0 {\n            return\n        }\n\n        if pars.count > 1 {\n            for i in 0..<pars.count {\n                resetMode (pars [i], collect)\n            }\n            return\n        }\n        resetMode (pars [0], collect)\n    }\n\n    func resetMode (_ par: Int, _ collect: cstring)\n    {\n        if collect == [] {\n            switch (par) {\n            case 2:\n                // KAM mode - unlocks the keyboard, not supported\n                break\n            case 4:\n                // IRM Insert/Replace Mode\n                insertMode = false\n            case 20:\n                // LNM\u2014Line Feed/New Line Mode\n                lineFeedMode = false\n                break\n            default:\n                break\n            }\n        } else if collect == [UInt8 (ascii: \"?\")] {\n            switch (par) {\n            case 1:\n                applicationCursor = false\n            case 3:\n                if allow80To132 {\n                    // DECCOLM\n                    resize (cols: 80, rows: rows)\n                    tdel?.sizeChanged(source: self)\n                    resetToInitialState()\n                }\n            case 4: // DECSCLM - Jump scroll mode\n                smoothScroll = false\n                break\n            case 5:\n                // Reset default color\n                curAttr = CharData.defaultAttr\n            case 6:\n                // DECOM Reset\n                originMode = false\n            case 7:\n                wraparound = false\n            case 12:\n                cursorBlink = false\n            case 40:\n                allow80To132 = false\n            case 41:\n                // Workaround not implemented \n                break\n            case 45:\n                reverseWraparound = false\n            case 66:\n                log (\"Switching back to normal keypad.\");\n                applicationKeypad = false\n                syncScrollArea ()\n            case 69:\n                // DECSLRM\n                marginMode = false\n            case 9: // X10 Mouse\n                mouseMode = .off\n            case 1000: // vt200 mouse\n                mouseMode = .off\n            case 95: // DECNCSM - clear on DECCOLM changes\n                // unsupported\n                break\n            case 1002: // button event mouse\n                mouseMode = .off\n            case 1003: // any event mouse\n                mouseMode = .off\n            case 1004: // send focusin/focusout events\n                sendFocus = false\n            case 1005: // utf8 ext mode mouse\n                mouseProtocol = .x10\n            case 1006: // sgr ext mode mouse\n                mouseProtocol = .x10\n            case 1015: // urxvt ext mode mouse\n                mouseProtocol = .x10\n            case 25: // hide cursor\n                hideCursor ()\n            case 1048: // alt screen cursor\n                cmdRestoreCursor ([], [])\n            case 1034:\n                // Terminal.app ignores this request, and keeps sending ESC+letter\n                break\n            case 1049: // alt screen buffer cursor\n                fallthrough\n            case 47: // normal screen buffer\n                fallthrough\n            case 1047: // normal screen buffer - clearing it first\n                   // Ensure the selection manager has the correct buffer\n                buffers!.activateNormalBuffer (clearAlt: par == 1047 || par == 1049)\n                if (par == 1049){\n                    cmdRestoreCursor ([], [])\n                }\n                refresh (startRow: 0, endRow: rows - 1)\n                syncScrollArea ()\n                showCursor ()\n                tdel?.bufferActivated(source: self)\n                \n            case 2004: // bracketed paste mode (https://cirw.in/blog/bracketed-paste)\n                bracketedPasteMode = false\n                break\n            default:\n                log (\"Unhandled DEC Private Mode Reset (DECRST) with \\(par)\")\n                break\n            }\n        }\n    }\n\n    //\n    // CSI Pm h  Set Mode (SM).\n    //     Ps = 2  -> Keyboard Action Mode (AM).\n    //     Ps = 4  -> Insert Mode (IRM).\n    //     Ps = 1 2  -> Send/receive (SRM).\n    //     Ps = 2 0  -> Automatic Newline (LNM).\n    // CSI ? Pm h\n    //   DEC Private Mode Set (DECSET).\n    //     Ps = 1  -> Application Cursor Keys (DECCKM).\n    //     Ps = 2  -> Designate USASCII for character sets G0-G3\n    //     (DECANM), and set VT100 mode.\n    //     Ps = 3  -> 132 Column Mode (DECCOLM).\n    //     Ps = 4  -> Smooth (Slow) Scroll (DECSCLM).\n    //     Ps = 5  -> Reverse Video (DECSCNM).\n    //     Ps = 6  -> Origin Mode (DECOM).\n    //     Ps = 7  -> Wraparound Mode (DECAWM).\n    //     Ps = 8  -> Auto-repeat Keys (DECARM).\n    //     Ps = 9  -> Send Mouse X & Y on button press.  See the sec-\n    //     tion Mouse Tracking.\n    //     Ps = 1 0  -> Show toolbar (rxvt).\n    //     Ps = 1 2  -> Start Blinking Cursor (att610).\n    //     Ps = 1 8  -> Print form feed (DECPFF).\n    //     Ps = 1 9  -> Set print extent to full screen (DECPEX).\n    //     Ps = 2 5  -> Show Cursor (DECTCEM).\n    //     Ps = 3 0  -> Show scrollbar (rxvt).\n    //     Ps = 3 5  -> Enable font-shifting functions (rxvt).\n    //     Ps = 3 8  -> Enter Tektronix Mode (DECTEK).\n    //     Ps = 4 0  -> Allow 80 -> 132 Mode.\n    //     Ps = 4 1  -> more(1) fix (see curses resource).\n    //     Ps = 4 2  -> Enable Nation Replacement Character sets (DECN-\n    //     RCM).\n    //     Ps = 4 4  -> Turn On Margin Bell.\n    //     Ps = 4 5  -> Reverse-wraparound Mode.\n    //     Ps = 4 6  -> Start Logging.  This is normally disabled by a\n    //     compile-time option.\n    //     Ps = 4 7  -> Use Alternate Screen Buffer.  (This may be dis-\n    //     abled by the titeInhibit resource).\n    //     Ps = 6 6  -> Application keypad (DECNKM).\n    //     Ps = 6 7  -> Backarrow key sends backspace (DECBKM).\n    //     Ps = 1 0 0 0  -> Send Mouse X & Y on button press and\n    //     release.  See the section Mouse Tracking.\n    //     Ps = 1 0 0 1  -> Use Hilite Mouse Tracking.\n    //     Ps = 1 0 0 2  -> Use Cell Motion Mouse Tracking.\n    //     Ps = 1 0 0 3  -> Use All Motion Mouse Tracking.\n    //     Ps = 1 0 0 4  -> Send FocusIn/FocusOut events.\n    //     Ps = 1 0 0 5  -> Enable Extended Mouse Mode.\n    //     Ps = 1 0 1 0  -> Scroll to bottom on tty output (rxvt).\n    //     Ps = 1 0 1 1  -> Scroll to bottom on key press (rxvt).\n    //     Ps = 1 0 3 4  -> Interpret \"meta\" key, sets eighth bit.\n    //     (enables the eightBitInput resource).\n    //     Ps = 1 0 3 5  -> Enable special modifiers for Alt and Num-\n    //     Lock keys.  (This enables the numLock resource).\n    //     Ps = 1 0 3 6  -> Send ESC   when Meta modifies a key.  (This\n    //     enables the metaSendsEscape resource).\n    //     Ps = 1 0 3 7  -> Send DEL from the editing-keypad Delete\n    //     key.\n    //     Ps = 1 0 3 9  -> Send ESC  when Alt modifies a key.  (This\n    //     enables the altSendsEscape resource).\n    //     Ps = 1 0 4 0  -> Keep selection even if not highlighted.\n    //     (This enables the keepSelection resource).\n    //     Ps = 1 0 4 1  -> Use the CLIPBOARD selection.  (This enables\n    //     the selectToClipboard resource).\n    //     Ps = 1 0 4 2  -> Enable Urgency window manager hint when\n    //     Control-G is received.  (This enables the bellIsUrgent\n    //     resource).\n    //     Ps = 1 0 4 3  -> Enable raising of the window when Control-G\n    //     is received.  (enables the popOnBell resource).\n    //     Ps = 1 0 4 7  -> Use Alternate Screen Buffer.  (This may be\n    //     disabled by the titeInhibit resource).\n    //     Ps = 1 0 4 8  -> Save cursor as in DECSC.  (This may be dis-\n    //     abled by the titeInhibit resource).\n    //     Ps = 1 0 4 9  -> Save cursor as in DECSC and use Alternate\n    //     Screen Buffer, clearing it first.  (This may be disabled by\n    //     the titeInhibit resource).  This combines the effects of the 1\n    //     0 4 7  and 1 0 4 8  modes.  Use this with terminfo-based\n    //     applications rather than the 4 7  mode.\n    //     Ps = 1 0 5 0  -> Set terminfo/termcap function-key mode.\n    //     Ps = 1 0 5 1  -> Set Sun function-key mode.\n    //     Ps = 1 0 5 2  -> Set HP function-key mode.\n    //     Ps = 1 0 5 3  -> Set SCO function-key mode.\n    //     Ps = 1 0 6 0  -> Set legacy keyboard emulation (X11R6).\n    //     Ps = 1 0 6 1  -> Set VT220 keyboard emulation.\n    //     Ps = 2 0 0 4  -> Set bracketed paste mode.\n    // Modes:\n    //   http: *vt100.net/docs/vt220-rm/chapter4.html\n    //\n    func cmdSetMode (_ pars: [Int], _ collect: cstring)\n    {\n        if pars.count == 0 {\n            return\n        }\n\n        if pars.count > 1 {\n            for i in 0..<pars.count {\n                setMode (pars [i], collect)\n            }\n            return\n        }\n        setMode (pars [0], collect)\n    }\n\n    func setMode (_ par: Int, _ collect: cstring)\n    {\n        if (collect == []) {\n            switch par {\n            case 2:\n                // KAM mode - unlocks the keyboard, I do not want to support it\n                break\n            case 4:\n                // IRM Insert/Replace Mode\n                // https://vt100.net/docs/vt510-rm/IRM.html\n                insertMode = true\n//            case 12:\n//                 SRM\u2014Local Echo: Send/Receive Mode\n//                 When implemented, hook up cmdDecRqm\n//                break\n            case 20:\n                // Automatic New Line (LNM)\n                lineFeedMode = true\n                break;\n            default:\n                log (\"Unhandled verbatim setMode with \\(par) and \\(collect)\")\n                break\n            }\n        } else if collect == [UInt8 (ascii: \"?\")] {\n            switch par {\n            case 1:\n                applicationCursor = true\n            case 2:\n                setgCharset (0, charset: CharSets.defaultCharset)\n                setgCharset (1, charset: CharSets.defaultCharset)\n                setgCharset (2, charset: CharSets.defaultCharset)\n                setgCharset (3, charset: CharSets.defaultCharset)\n                // set VT100 mode here\n                \n            case 3: // DECCOLM - go to 132 col mode\n                if allow80To132 {\n                    resize (cols: 132, rows: rows)\n                    resetToInitialState()\n                    tdel?.sizeChanged(source: self)\n                }\n            case 4: // Smooth scroll mode\n                smoothScroll = true\n                break\n            case 5:\n                // Inverted colors\n                curAttr = CharData.invertedAttr\n            case 6:\n                // DECOM Set\n                originMode = true\n            case 7:\n                wraparound = true\n            case 12:\n                cursorBlink = true\n                break;\n            case 40:\n                allow80To132 = true\n            case 66:\n                log (\"Serial port requested application keypad.\")\n                applicationKeypad = true\n                syncScrollArea ()\n            case 9:\n                // X10 Mouse\n                mouseMode = .x10\n            case 45: // Xterm Reverse Wrap-around\n                // reverse wraparound can only be enabled if Auto-wrap is enabled (DECAWM)\n                if wraparound {\n                    reverseWraparound = true\n                }\n            case 69:\n                // Enable left and right margin mode (DECLRMM),\n                marginMode = true\n            case 95: // DECNCSM - clear on DECCOLM changes\n                // unsupported\n                break\n            case 1000:\n                // SET_VT200_HIGHLIGHT_MOUSE\n                mouseMode = .vt200\n            case 1002:\n                // SET_BTN_EVENT_MOUSE\n                mouseMode = .buttonEventTracking\n\n            case 1003:\n                // SET_ANY_EVENT_MOUSE\n                mouseMode = .anyEvent\n\n            case 1004: // send focusin/focusout events\n                   // focusin: ^[[I\n                   // focusout: ^[[O\n                sendFocus = true\n            case 1005:\n                // utf8 ext mode mouse\n                mouseProtocol = .utf8\n                break;\n            case 1006: // sgr ext mode mouse\n                mouseProtocol = .sgr\n            case 1015: // urxvt ext mode mouse\n                mouseProtocol = .urxvt\n            case 25: // show cursor\n                showCursor()\n            case 63:\n                // DECRLM - Cursor Right to Left Mode, not supported\n                break\n            case 1034:\n                // Terminal.app ignores this request, and keeps sending ESC+letter\n                // Given our UTF8 world, I do not think this is a worth encoding\n                break\n            case 1048: // alt screen cursor\n                cmdSaveCursor ([], [])\n            case 1049: // alt screen buffer cursor\n                cmdSaveCursor ([], [])\n                // FALL-THROUGH\n                fallthrough\n            case 47: // alt screen buffer\n                fallthrough\n            case 1047: // alt screen buffer\n                buffers!.activateAltBuffer (fillAttr: nil)\n                refresh (startRow: 0, endRow: rows - 1)\n                syncScrollArea ()\n                showCursor ()\n                tdel?.bufferActivated(source: self)\n                \n            case 2004: // bracketed paste mode (https://cirw.in/blog/bracketed-paste)\n                // TODO: must implement bracketed paste mode\n                bracketedPasteMode = true\n            default:\n                log (\"Unhandled DEC Private Mode Set (DECSET) with \\(par)\")\n                break;\n            }\n        } else {\n            log (\"Unhandled setMode (SM) with \\(par) and \\(collect)\")\n        }\n        \n    }\n\n\n    //\n    // CSI Ps g  Tab Clear (TBC).\n    //     Ps = 0  -> Clear Current Column (default).\n    //     Ps = 3  -> Clear All.\n    // Potentially:\n    //   Ps = 2  -> Clear Stops on Line.\n    //   http://vt100.net/annarbor/aaa-ug/section6.html\n    //\n    func cmdTabClear (_ pars: [Int], _ collect: cstring)\n    {\n        let p = pars.count == 0 ? 0 : pars [0]\n        if p == 0 {\n            buffer.tabClear(pos: buffer.x)\n        } else if (p == 3) {\n            buffer.clearTabStops ()\n        }\n    }\n\n\n    //\n    // CSI Ps ; Ps f\n    //   Horizontal and Vertical Position [row;column] (default =\n    //   [1,1]) (HVP).\n    //\n    func cmdHVPosition (_ pars: [Int], _ collect: cstring)\n    {\n        var p = 1\n        var q = 1\n        if pars.count > 0 {\n            p = max (pars [0], 1)\n            if (pars.count > 1){\n                q = max (pars [1], 1)\n            }\n        }\n        \n        buffer.y = p - 1 + (originMode ? buffer.scrollTop : 0)\n        if buffer.y >= rows {\n            buffer.y = rows - 1\n        }\n        \n        buffer.x = q - 1 + (originMode && marginMode ? buffer.marginLeft : 0)\n        if buffer.x >= cols {\n            buffer.x = cols - 1\n        }\n    }\n\n    //\n    // CSI Pm e  Vertical Position Relative (VPR)\n    //   [rows] (default = [row+1,column])\n    // reuse CSI Ps B ?\n    //\n    func cmdVPositionRelative (_ pars: [Int], _ collect: cstring)\n    {\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n        let newY = buffer.y + p\n\n        if newY >= rows {\n            buffer.y = rows - 1\n        } else {\n            buffer.y = newY\n        }\n\n        // If the end of the line is hit, prevent this action from wrapping around to the next line.\n        if buffer.x >= cols {\n            buffer.x -= 1\n        }\n    }\n\n\n    //\n    // CSI Pm d  Vertical Position Absolute (VPA)\n    //   [row] (default = [1,column])\n    //\n    func cmdLinePosAbsolute (_ pars: [Int], _ collect: cstring)\n    {\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n\n        if (p - 1 >= rows) {\n            buffer.y = rows - 1\n        } else {\n            buffer.y = p - 1\n        }\n    }\n\n    //\n    // CSI Ps c  Send Device Attributes (Primary DA).\n    //     Ps = 0  or omitted -> request attributes from terminal.  The\n    //     response depends on the decTerminalID resource setting.\n    //     -> CSI ? 1 ; 2 c  (``VT100 with Advanced Video Option'')\n    //     -> CSI ? 1 ; 0 c  (``VT101 with No Options'')\n    //     -> CSI ? 6 c  (``VT102'')\n    //     -> CSI ? 6 0 ; 1 ; 2 ; 6 ; 8 ; 9 ; 1 5 ; c  (``VT220'')\n    //   The VT100-style response parameters do not mean anything by\n    //   themselves.  VT220 parameters do, telling the host what fea-\n    //   tures the terminal supports:\n    //     Ps = 1  -> 132-columns.\n    //     Ps = 2  -> Printer.\n    //     Ps = 4  -> Sixel graphics\n    //     Ps = 6  -> Selective erase.\n    //     Ps = 8  -> User-defined keys.\n    //     Ps = 9  -> National replacement character sets.\n    //     Ps = 1 5  -> Technical characters.\n    //     Ps = 2 2  -> ANSI color, e.g., VT525.\n    //     Ps = 2 9  -> ANSI text locator (i.e., DEC Locator mode).\n    // CSI > Ps c\n    //   Send Device Attributes (Secondary DA).\n    //     Ps = 0  or omitted -> request the terminal's identification\n    //     code.  The response depends on the decTerminalID resource set-\n    //     ting.  It should apply only to VT220 and up, but xterm extends\n    //     this to VT100.\n    //     -> CSI  > Pp ; Pv ; Pc c\n    //   where Pp denotes the terminal type\n    //     Pp = 0  -> ``VT100''.\n    //     Pp = 1  -> ``VT220''.\n    //   and Pv is the firmware version (for xterm, this was originally\n    //   the XFree86 patch number, starting with 95).  In a DEC termi-\n    //   nal, Pc indicates the ROM cartridge registration number and is\n    //   always zero.\n    // More information:\n    //   xterm/charproc.c - line 2012, for more information.\n    //   vim responds with ^[[?0c or ^[[?1c after the terminal's response (?)\n    //\n    func cmdSendDeviceAttributes (_ pars: [Int], _ collect: cstring)\n    {\n        if pars.count > 0 && pars [0] > 0 {\n            var safe = collect\n            safe.append(0)\n            log (\"SendDeviceAttributes got \\(pars) and \\(String(cString: safe))\")\n            return\n        }\n\n        if collect == [UInt8 (ascii: \">\")] || collect == [UInt8 (ascii: \">\"), UInt8 (ascii: \"0\")] {\n            // DA2 Secondary Device Attributes\n            if pars.count == 0 || pars [0] == 0 {\n                let vt525 = 65 // we identified as a vt525\n                let kbd = 1 // PC-style keyboard\n                sendResponse(cc.CSI, \">\\(vt525);20;\\(kbd)c\")\n                return\n            }\n            log (\"Got a CSI > c with an unknown set of argument\")\n            return\n        }\n        \n        // We should use a terminal emulation level, and not rely on the TERM name\n        // for now, \"xterm\" as a part of the name surfaces all the capabilities.\n        let name = options.termName\n        if collect == [] {\n            let termVt525 = 65\n            let sixel = options.enableSixelReported ? \";6\" : \"\"\n            let cols132 = 1\n            let printer = 2\n            let decsera = 6\n            let horizontalScrolling = 21\n            let ansiColor = 22\n            \n            // Send Device Attributes (Primary DA).1\n            if name.hasPrefix(\"xterm\") {\n                sendResponse (cc.CSI, \"?\\(termVt525)\\(sixel);\\(cols132);\\(printer);\\(decsera);\\(horizontalScrolling);\\(ansiColor)c\")\n            } else if name.hasPrefix(\"screen\") || name.hasPrefix (\"rxvt-unicode\") {\n                sendResponse (cc.CSI, \"?\\(cols132);\\(printer)c\")\n            } else if name.hasPrefix (\"linux\") {\n                sendResponse (cc.CSI, \"?\\(decsera)c\")\n            }\n        } else if collect.count == 1 && collect [0] == UInt8 (ascii: \">\") {\n            // xterm and urxvt\n            // seem to spit this\n            // out around ~370 times (?).\n            if name.hasPrefix (\"xterm\") {\n                sendResponse (cc.CSI, \">0;276;0c\")\n            } else if name.hasPrefix (\"rxvt-unicode\") {\n                sendResponse (cc.CSI, \">85;95;0c\")\n            } else if name.hasPrefix (\"linux\") {\n                // not supported by linux console.\n                // linux console echoes parameters.\n                sendResponse (\"\\(pars[0])c\")\n            } else if name.hasPrefix (\"screen\") {\n                sendResponse (cc.CSI, \">83;40003;0c\")\n            }\n        }\n    }\n\n\n    //\n    // CSI Ps b  Repeat the preceding graphic character Ps times (REP).\n    //\n    func cmdRepeatPrecedingCharacter (_ pars: [Int], _ collect: cstring)\n    {\n        // Maximum repeat, to avoid a denial of service\n        let maxRepeat = cols*rows*2\n        let p = min (maxRepeat, max (pars.count == 0 ? 1 : pars [0], 1))\n        let line = buffer.lines [buffer.yBase + buffer.y]\n        let chData = buffer.x - 1 < 0 ? CharData (attribute: CharData.defaultAttr) : line [buffer.x - 1]\n        \n        for _ in 0..<p {\n            insertCharacter(chData)\n        }\n    }\n\n    //\n    //CSI Pm a  Character Position Relative\n    //  [columns] (default = [row,col+1]) (HPR)\n    //reuse CSI Ps C ?\n    //\n    func cmdHPositionRelative (_ pars: [Int], _ collect: cstring)\n    {\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n        \n        buffer.x += p\n        if buffer.x >= cols {\n            buffer.x = cols - 1\n        }\n    }\n\n    //\n    // CSI Pm `  Character Position Absolute\n    //   [column] (default = [row,1]) (HPA).\n    //\n    func cmdCharPosAbsolute (_ pars: [Int], _ collect: cstring)\n    {\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n\n        buffer.x = p - 1\n        if buffer.x >= cols {\n            buffer.x = cols - 1\n        }\n    }\n\n    //\n    //CSI Ps Z  Cursor Backward Tabulation Ps tab stops (default = 1) (CBT).\n    //\n    func cmdCursorBackwardTab (_ pars: [Int], _ collect: cstring)\n    {\n        if buffer.x > cols {\n            return\n        }\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n\n        for _ in 0..<p {\n            buffer.x = buffer.previousTabStop ()\n        }\n    }\n\n    //\n    // CSI Ps X\n    // Erase Ps Character(s) (default = 1) (ECH).\n    //\n    func cmdEraseChars (_ pars: [Int], _ collect: cstring)\n    {\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n\n        buffer.lines [buffer.y + buffer.yBase].replaceCells (\n            start: buffer.x,\n            end: buffer.x + p,\n            fillData: CharData (attribute:  eraseAttr ()))\n    }\n\n    func csiT (_ pars: [Int], _ collect: cstring)\n    {\n        if collect.count == 0 {\n            cmdScrollDown(pars)\n        } else if collect == [UInt8 (ascii: \">\")] {\n            cmdXtermTitleModeReset(pars)\n        }\n    }\n    //\n    // CSI Ps T  Scroll down Ps lines (default = 1) (SD).\n    //\n    func cmdScrollDown (_ pars: [Int])\n    {\n        let p = min (max (pars.count == 0 ? 1 : pars [0], 1), rows)\n        let da = CharData.defaultAttr\n\n        let row = buffer.scrollTop + buffer.yBase\n\n        let columnCount = buffer.marginRight-buffer.marginLeft+1\n        let rowCount = buffer.scrollBottom-buffer.scrollTop\n        for _ in 0..<p {\n            for i in (0..<rowCount).reversed() {\n                let src = buffer.lines [row+i]\n                let dst = buffer.lines [row+i+1]\n                \n                dst.copyFrom(src, srcCol: buffer.marginLeft, dstCol: buffer.marginLeft, len: columnCount)\n            }\n            let last = buffer.lines [row]\n            last.fill (with: CharData (attribute: da), atCol: buffer.marginLeft, len: columnCount)\n        }\n        // this.maxRange();\n        updateRange (startLine: buffer.scrollTop, endLine: buffer.scrollBottom)\n    }\n\n    //\n    // CSI Ps S  Scroll up Ps lines (default = 1) (SU).\n    //\n    func cmdScrollUp (_ pars: [Int], _ collect: cstring)\n    {\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n        let da = CharData.defaultAttr\n\n        if marginMode {\n            let row = buffer.scrollTop + buffer.yBase\n\n            let columnCount = buffer.marginRight-buffer.marginLeft+1\n            let rowCount = buffer.scrollBottom-buffer.scrollTop\n            for _ in 0..<p {\n                for i in 0..<(rowCount) {\n                    let src = buffer.lines [row+i+1]\n                    let dst = buffer.lines [row+i]\n                    \n                    dst.copyFrom(src, srcCol: buffer.marginLeft, dstCol: buffer.marginLeft, len: columnCount)\n                }\n                let last = buffer.lines [row+rowCount]\n                last.fill (with: CharData (attribute: da), atCol: buffer.marginLeft, len: columnCount)\n            }\n        } else {\n            for _ in 0..<p {\n                buffer.lines.splice (start: buffer.yBase + buffer.scrollTop, deleteCount: 1,\n                                     items: [], change: { line in updateRange (line)})\n                buffer.lines.splice (start: buffer.yBase + buffer.scrollBottom, deleteCount: 0,\n                                     items: [buffer.getBlankLine (attribute: da)],\n                                     change: { line in updateRange (line) })\n            }\n        }\n        // this.maxRange();\n        updateRange (startLine: buffer.scrollTop, endLine: buffer.scrollBottom)\n    }\n\n    //\n    // CSI Ps P\n    // Delete Ps Character(s) (default = 1) (DCH).\n    //\n    func cmdDeleteChars (_ pars: [Int], _ collect: cstring)\n    {\n        let buffer = self.buffer\n        var p = max (pars.count == 0 ? 1 : pars [0], 1)\n        \n        if marginMode {\n            if buffer.x < buffer.marginLeft || buffer.x > buffer.marginRight {\n                return\n            }\n            if buffer.x + p > buffer.marginRight {\n                p = buffer.marginRight - buffer.x + 1\n            }\n        }\n        // buffer.x = buffer.cols is a special case on the edge, we do not delete columns in that boundary\n        if buffer.x == buffer.cols {\n            return\n        }\n        buffer.lines [buffer.y + buffer.yBase].deleteCells (\n            pos: buffer.x, n: p, rightMargin: marginMode ? buffer.marginRight : cols-1, fillData: CharData (attribute: eraseAttr ()))\n        \n        updateRange (buffer.y)\n    }\n\n    //\n    // CSI Ps M\n    // Delete Ps Line(s) (default = 1) (DL).\n    //\n    func cmdDeleteLines (_ pars: [Int], _ collect: cstring)\n    {\n        restrictCursor()\n        let buffer = self.buffer\n        // No point deleting more lines than the available rows, prevents\n        // a denial of service caused by very large numbers passed here\n        let p = min (buffer.rows+1, max (pars.count == 0 ? 1 : pars [0], 1))\n        let row = buffer.y + buffer.yBase\n        var j = rows - 1 - buffer.scrollBottom\n        j = rows - 1 + buffer.yBase - j\n        let ea = eraseAttr ()\n        \n        if marginMode {\n            if buffer.x >= buffer.marginLeft && buffer.x <= buffer.marginRight {\n                let columnCount = buffer.marginRight-buffer.marginLeft+1\n                let rowCount = buffer.scrollBottom-buffer.scrollTop\n                for _ in 0..<p {\n                    for i in 0..<(rowCount) {\n                        let src = buffer.lines [row+i+1]\n                        let dst = buffer.lines [row+i]\n                        \n                        dst.copyFrom(src, srcCol: buffer.marginLeft, dstCol: buffer.marginLeft, len: columnCount)\n                    }\n                    \n                    let last = buffer.lines [row+rowCount]\n                    last.fill (with: CharData (attribute: ea), atCol: buffer.marginLeft, len: columnCount)\n                }\n            }\n        } else {\n            if buffer.y >= buffer.scrollTop && buffer.y <= buffer.scrollBottom {\n                for _ in 0..<p {\n                    // test: echo -e '\\e[44m\\e[1M\\e[0m'\n                    // blankLine(true) - xterm/linux behavior\n                    buffer.lines.splice (start: row, deleteCount: 1, items: [], change: { line in updateRange (line)})\n                    buffer.lines.splice (start: j, deleteCount: 0,\n                                         items: [buffer.getBlankLine (attribute: ea)],\n                                         change: { line in updateRange (line)})\n                }\n            }\n        }\n        \n        // this.maxRange();\n        updateRange (startLine: buffer.y, endLine: buffer.scrollBottom)\n    }\n\n    //\n    // CSI Ps ' ~\n    // Delete Ps Column(s) (default = 1) (DECDC), VT420 and up.\n    //\n    // @vt: #Y CSI DECDC \"Delete Columns\"  \"CSI Ps ' ~\"  \"Delete `Ps` columns at cursor position.\"\n    // DECDC deletes `Ps` times columns at the cursor position for all lines with the scroll margins,\n    // moving content to the left. Blank columns are added at the right margin.\n    // DECDC has no effect outside the scrolling margins.\n\n    func cmdDeleteColumns (_ pars: [Int], _ collect: cstring)\n    {\n        let buffer = self.buffer\n        if buffer.y > buffer.scrollBottom || buffer.y < buffer.scrollTop {\n            return\n        }\n        // buffer.x = buffer.cols is a special case on the edge, we do not delete columns in that boundary\n        if buffer.x == buffer.cols {\n            return\n        }\n        if marginMode {\n            if buffer.x < buffer.marginLeft || buffer.x > buffer.marginRight {\n                return\n            }\n        }\n\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n        \n        for y in buffer.scrollTop...buffer.scrollBottom {\n            let line = buffer.lines [buffer.yBase + y]\n            line.deleteCells(pos: buffer.x, n: p, rightMargin: marginMode ? buffer.marginRight : cols-1, fillData: buffer.getNullCell(attribute: eraseAttr()))\n            line.isWrapped = false\n        }\n        updateRange (startLine: buffer.scrollTop, endLine: buffer.scrollBottom)\n    }\n\n\n    //\n    // Helper method to reset cells in a terminal row.\n    // The cell gets replaced with the eraseChar of the terminal and the isWrapped property is set to false.\n    // @param y row index\n    //\n    func resetBufferLine (y: Int)\n    {\n        eraseInBufferLine (y: y, start: 0, end: cols, clearWrap: true, clearRenderMode: true)\n        updateRange(y)\n    }\n\n    /**\n     * Sends the provided text to the connected backend\n     */\n    public func sendResponse (text: String)\n    {\n        tdel?.send (source: self, data: ([UInt8] (text.utf8))[...])\n    }\n    \n    /**\n     * Sends the provided text to the connected backend, takes a variable list of arguments\n     * that could be either [UInt8], Strings, or a single UInt8 value.\n     */\n    public func sendResponse (_ items: Any ...)\n    {\n        var buffer: [UInt8] = []\n        \n        for item in items {\n            if let arr = item as? [UInt8] {\n                buffer.append(contentsOf: arr)\n            } else if let str = item as? String {\n                buffer.append (contentsOf: [UInt8] (str.utf8))\n            } else if let c = item as? UInt8 {\n                buffer.append (c)\n            } else {\n                log (\"Do not know how to handle type \\(item)\")\n            }\n        }\n        tdel?.send (source: self, data: buffer[...])\n    }\n    \n#if DEBUG\n    public var silentLog = false\n#else\n    public var silentLog = true\n#endif\n    \n    func error (_ text: String)\n    {\n        if !silentLog {\n            print(\"Error: \\(text)\")\n        }\n    }\n    \n    func log (_ text: String)\n    {\n        if !silentLog {\n            print(\"Info: \\(text)\")\n        }\n    }\n    \n    /**\n     * Processes the provided byte-array coming from the host, interprets them and\n     * updates the screen state accordingly.\n     */\n    public func feed (byteArray: [UInt8])\n    {\n        parse (buffer: byteArray[...])\n    }\n    \n    /**\n     * Processes the provided byte-array coming from the host, interprets them and\n     * updates the screen state accordingly.\n     */\n    public func feed (text: String)\n    {\n        parse (buffer: ([UInt8] (text.utf8))[...])\n    }\n\n    /**\n     * Processes the provided byte-array coming from the host, interprets them and\n     * updates the screen state accordingly.\n     */\n    public func feed (buffer: ArraySlice<UInt8>)\n    {\n        parse (buffer: buffer)\n    }\n\n    /**\n     * Processes the provided byte-array coming from the host, interprets them and\n     * updates the screen state accordingly.\n     */\n    public func parse (buffer: ArraySlice<UInt8>)\n    {\n        parser.parse(data: buffer)\n    }\n \n    var dirtyLines: Set<Int> = Set<Int>()\n    \n    /**\n     * Registers the given line as requiring to be updated by the front-end engine\n     *\n     * The front-end engine should call `getUpdateRange` to\n     * determine which region in the screen needs to be redrawn.   This method adds the specified\n     * line to the range of modified lines\n     *\n     * Scrolling tells if this was just issued as part of scrolling which we don't register for the\n     * scroll-invariant update ranges.\n     */\n    func updateRange (_ y: Int, scrolling: Bool = false, updateDirtySet: Bool = true)\n    {        \n        if !scrolling {\n            let effectiveY = buffer.yDisp + y\n            if effectiveY >= 0 {\n                if effectiveY < scrollInvariantRefreshStart {\n                    scrollInvariantRefreshStart = effectiveY\n                }\n                if effectiveY > scrollInvariantRefreshEnd {\n                    scrollInvariantRefreshEnd = effectiveY\n                }\n            }\n        }\n        \n        if y >= 0 {\n            if y < refreshStart {\n                refreshStart = y\n            }\n            if y > refreshEnd {\n                refreshEnd = y\n            }\n        }\n        if updateDirtySet {\n            dirtyLines.insert (y)\n        }\n    }\n    \n    func updateRange (startLine: Int, endLine: Int, scrolling: Bool = false)\n    {\n        updateRange (startLine, scrolling: scrolling, updateDirtySet: false)\n        updateRange (endLine, scrolling: scrolling, updateDirtySet: false)\n        \n        for line in min(startLine,endLine)...max(startLine,endLine) {\n            dirtyLines.insert (line)\n        }\n    }\n    \n    public func updateFullScreen ()\n    {\n        refreshStart = 0\n        refreshEnd = rows\n        \n        scrollInvariantRefreshStart = buffer.yDisp\n        scrollInvariantRefreshEnd = buffer.yDisp + rows\n        \n        for line in 0...rows {\n            dirtyLines.insert (line)\n        }\n\n    }\n    \n    /**\n     * Returns the starting and ending lines that need to be redrawn, or nil\n     * if no part of the screen needs to be updated.   Alternatively, you can\n     * get a Set<Int> with the changed lines by calling `changedLines()`.\n     *\n     * UI toolkits should call `clearUpdateRange` to reset these changes\n     * after they have used this information, so that new changes only reflect\n     * the actual changes.\n     */\n    public func getUpdateRange () -> (startY: Int, endY: Int)?\n    {\n        if refreshEnd == -1 && refreshStart == Int.max {\n            //print (\"Emtpy update range\")\n            return nil\n        }\n        //print (\"Update: \\(refreshStart) \\(refreshEnd)\")\n        return (refreshStart, refreshEnd)\n    }\n    \n    /**\n     * Returns a set containing the lines that have been modified, the\n     * returned set is not sorted.\n     *\n     * UI toolkits should call `clearUpdateRange` to reset these changes\n     * after they have used this information, so that new changes only reflect\n     * the actual changes.\n     */\n   public func changedLines () -> Set<Int>\n   {\n       return dirtyLines\n   }\n   \n\n    /**\n     * Check for payload identifiers that are not in use and stop retaining their payload,\n     * to avoid accumulting memory for images and URLs that are no longer visible or\n     * available by scrolling.\n     */\n    public func garbageCollectPayload() {\n        // stop right away if there is nothing to collect\n        if TinyAtom.lastCollected == TinyAtom.lastUsed {\n            return\n        }\n        \n        // check all atoms used in both buffers\n        var used = Set<UInt16>()\n        for buffer in [buffers.normal, buffers.alt] {\n            for line in buffer._lines.array {\n                if let array = line?.data {\n                    for data in array {\n                        let code = data.payload.code\n                        if code > 0 {\n                            used.insert(code)\n                        }\n                    }\n                }\n            }\n        }\n        \n        // since we create atoms in order we expect them to run out of use\n        // in order as well and stop with first atom that is still in use\n        for code in UInt16(TinyAtom.lastCollected + 1)...UInt16(TinyAtom.lastUsed) {\n            if used.contains(code) {\n                // code still in use\n                break\n            }\n            \n            TinyAtom.lastCollected = Int(code)\n            TinyAtom.release(code: code)\n        }\n    }\n    \n    /**\n     * Returns the starting and ending lines that need to be redrawn, or nil\n     * if no part of the screen needs to be updated.\n     *\n     * This is different from getUpdateRange() in that lines are from start of scroll back,\n     * not what the terminal has visible right now.\n     */\n    public func getScrollInvariantUpdateRange () -> (startY: Int, endY: Int)?\n    {\n        if scrollInvariantRefreshEnd == -1 && scrollInvariantRefreshStart == Int.max {\n            //print (\"Emtpy update range\")\n            return nil\n        }\n        //print (\"Update: \\(scrollInvariantRefreshStart) \\(scrollInvariantRefreshEnd)\")\n        return (scrollInvariantRefreshStart, scrollInvariantRefreshEnd)\n    }\n    \n    /**\n     * Clears the state of the pending display redraw region as well as the dirtyLines set.\n     */\n    public func clearUpdateRange ()\n    {\n        refreshStart = Int.max\n        refreshEnd = -1\n        \n        scrollInvariantRefreshStart = Int.max\n        scrollInvariantRefreshEnd = -1\n        \n        dirtyLines.removeAll()\n    }\n    \n    /**\n     * Zero-based (row, column) of cursor location relative to visible part of display.\n     * Returns: a tuple, where the first element contains the column (x) and the second the row (y) where the cursor is.\n     */\n    public func getCursorLocation() -> (x: Int, y: Int) {\n        return (buffer.x, buffer.y)\n    }\n    \n    /**\n     * Returns the uppermost visible row on the terminal buffer\n     */\n    public func getTopVisibleRow() -> Int {\n        return buffer.yDisp\n    }\n    \n    // ESC c Full Reset (RIS)\n    /// This performs a full reset of the terminal, like a soft reset, but additionally resets the buffer conents and scroll area.\n    /// for a soft reset see `softReset`\n    public func resetToInitialState ()\n    {\n        options.rows = rows\n        options.cols = cols\n        let savedCursorHidden = cursorHidden\n        setup (isReset: true)\n        cursorHidden = savedCursorHidden\n        refresh (startRow: 0, endRow: rows-1)\n        syncScrollArea ()\n    }\n\n    // Support for:\n    // ESC 6 Back Index (DECBI) and\n    // ESC 9 Forward Index (DECFI)\n    func columnIndex (back: Bool)\n    {\n        let buffer = self.buffer\n        let x = buffer.x\n        let leftMargin = buffer.marginLeft\n        if back {\n            if x == leftMargin {\n                columnScroll (back: back, at: x)\n            } else {\n                cursorBackward(count: 1)\n            }\n        } else {\n            let rightMargin = buffer.marginRight\n            if x == rightMargin  {\n                columnScroll (back: back, at: leftMargin)\n            } else if x == buffer.cols {\n                // on the boundaries, we ignore, test_DECFI_WholeScreenScrolls\n            } else {\n                cursorForward(count: 1)\n            }\n        }\n    }\n    \n    func columnScroll (back: Bool, at: Int)\n    {\n        if buffer.y < buffer.scrollTop || buffer.y > buffer.scrollBottom || buffer.x < buffer.marginLeft || buffer.x > buffer.marginRight {\n            return\n        }\n        for y in buffer.scrollTop...buffer.scrollBottom {\n            let line = buffer.lines [buffer.yBase + y]\n            if back {\n                line.insertCells(pos: at, n: 1, rightMargin: marginMode ? buffer.marginRight : cols-1, fillData: buffer.getNullCell())\n            } else {\n                line.deleteCells(pos: at, n: 1, rightMargin: marginMode ? buffer.marginRight : cols-1, fillData: buffer.getNullCell(attribute: eraseAttr()))\n            }\n            //line.isWrapped = false\n        }\n        updateRange (buffer.scrollTop)\n        updateRange (buffer.scrollBottom)\n    }\n    \n    // ESC D Index (Index is 0x84) - IND\n    func cmdIndex ()\n    {\n        restrictCursor()\n        \n        let buffer = self.buffer\n        let newY = buffer.y + 1\n        if newY > buffer.scrollBottom {\n            scroll ()\n        } else {\n            buffer.y = newY\n        }\n        // If the end of the line is hit, prevent this action from wrapping around to the next line\n        if buffer.x > cols {\n            buffer.x -= 1\n        }\n    }\n    \n    var blankLine: BufferLine = BufferLine(cols: 0)\n    \n    public func scroll (isWrapped: Bool = false)\n    {\n        let buffer = self.buffer\n        var newLine = blankLine\n        if newLine.count != cols || newLine [0].attribute != eraseAttr () {\n            newLine = buffer.getBlankLine (attribute: eraseAttr (), isWrapped: isWrapped)\n            blankLine = newLine\n        }\n        newLine.isWrapped = isWrapped\n\n        let topRow = buffer.yBase + buffer.scrollTop\n        let bottomRow = buffer.yBase + buffer.scrollBottom\n\n        if buffer.scrollTop == 0 {\n            // Determine whether the buffer is going to be trimmed after insertion.\n            let willBufferBeTrimmed = buffer.lines.isFull\n\n            // Insert the line using the fastest method\n            if bottomRow == buffer.lines.count - 1 {\n                if willBufferBeTrimmed {\n                    buffer.lines.recycle ()\n                } else {\n                    buffer.lines.push (BufferLine (from: newLine))\n                }\n            } else {\n                buffer.lines.splice (start: bottomRow + 1, deleteCount: 0,\n                                     items: [BufferLine (from: newLine)],\n                                     change: { line in updateRange (line)})\n            }\n\n            // Only adjust ybase and ydisp when the buffer is not trimmed\n            if !willBufferBeTrimmed {\n                buffer.yBase += 1\n                // Only scroll the ydisp with ybase if the user has not scrolled up\n                if !userScrolling {\n                    buffer.yDisp += 1\n                }\n            } else {\n                if buffer.hasScrollback {\n                    buffer.linesTop += 1\n                }\n                \n                // When the buffer is full and the user has scrolled up, keep the text\n                // stable unless ydisp is right at the top\n                if userScrolling {\n                    buffer.yDisp = max (buffer.yDisp - 1, 0)\n                }\n            }\n        } else {\n            // scrollTop is non-zero which means no line will be going to the\n            // scrollback, instead we can just shift them in-place.\n            let scrollRegionHeight = bottomRow - topRow + 1 /*as it's zero-based*/\n            if scrollRegionHeight > 1 {\n                buffer.lines.shiftElements (start: topRow + 1, count: scrollRegionHeight - 1, offset: -1)\n            }\n            buffer.lines [bottomRow] = BufferLine (from: newLine)\n        }\n\n        // Move the viewport to the bottom of the buffer unless the user is\n        // scrolling.\n        if !userScrolling {\n            buffer.yDisp = buffer.yBase\n        }\n\n        //buffer.dump ()\n        // Flag rows that need updating\n        updateRange (buffer.scrollTop, scrolling: true)\n        updateRange (buffer.scrollBottom, scrolling: true)\n        \n        if !buffer.hasScrollback {\n            updateRange(startLine: buffer.scrollTop, endLine: buffer.scrollBottom)\n        }\n\n        /**\n         * This event is emitted whenever the terminal is scrolled.\n         * The one parameter passed is the new y display position.\n         *\n         * @event scroll\n         */\n        tdel?.scrolled(source: self, yDisp: buffer.yDisp)\n    }\n        \n    public func emitLineFeed ()\n    {\n        tdel?.linefeed(source: self)\n    }\n    \n    //\n    // ESC n\n    // ESC o\n    // ESC |\n    // ESC }\n    // ESC ~\n    //   DEC mnemonic: LS (https://vt100.net/docs/vt510-rm/LS.html)\n    //   When you use a locking shift, the character set remains in GL or GR until\n    //   you use another locking shift. (partly supported)\n    //\n    func setgLevel (_ v: UInt8)\n    {\n        gLevel = v\n        if let cs = CharSets.all [v] {\n            charset = cs\n        } else {\n            charset = nil\n        }\n    }\n    \n    //\n    // ESC % @\n    // ESC % G\n    //   Select default character set. UTF-8 is not supported (string are unicode anyways)\n    //   therefore ESC % G does the same.\n    //\n    func cmdSelectDefaultCharset ()\n    {\n        setgLevel (0)\n        setgCharset (0, charset: CharSets.defaultCharset)\n    }\n\n    //\n    // ESC c\n    //   DEC mnemonic: RIS (https://vt100.net/docs/vt510-rm/RIS.html)\n    //   Reset to initial state.\n    //\n    func cmdReset ()\n    {\n            parser.reset ()\n            resetToInitialState ()\n    }\n            \n    //\n    // ESC >\n    //   DEC mnemonic: DECKPNM (https://vt100.net/docs/vt510-rm/DECKPNM.html)\n    //   Enables the keypad to send numeric characters to the host.\n    //\n    func cmdKeypadNumericMode ()\n    {\n            applicationKeypad = false\n            syncScrollArea ()\n    }\n                    \n    //\n    // ESC =\n    //   DEC mnemonic: DECKPAM (https://vt100.net/docs/vt510-rm/DECKPAM.html)\n    //   Enables the numeric keypad to send application sequences to the host.\n    //\n    func cmdKeypadApplicationMode ()\n    {\n            applicationKeypad = true\n            syncScrollArea ()\n    }\n\n    func eraseAttr () -> Attribute\n    {\n        Attribute (fg: CharData.defaultAttr.fg, bg: curAttr.bg, style: CharData.defaultAttr.style)\n    }\n    \n    func setgCharset (_ v: UInt8, charset: [UInt8: String]?)\n    {\n        CharSets.all [v] = charset\n        if gLevel == v {\n            self.charset = charset\n        }\n    }\n    \n    public func resize (cols: Int, rows: Int)\n    {\n        let newCols = max (cols, MINIMUM_COLS)\n        let newRows = max (rows, MINIMUM_ROWS)\n        if newCols == self.cols && newRows == self.rows {\n            return\n        }\n        let oldCols = self.cols\n        buffers.resize(newColumns: newCols, newRows: newRows)\n        self.cols = newCols\n        self.rows = newRows\n        options.cols = newCols\n        options.rows = newRows\n        buffers.normal.setupTabStops (index: oldCols)\n        buffers.alt.setupTabStops (index: oldCols)\n        refresh (startRow: 0, endRow: self.rows - 1)\n    }\n    \n    func syncScrollArea ()\n    {\n        // This should call the viewport sync-scroll-area\n    }\n\n    /**\n     * Registers that the region between startRow and endRow was modified and needs to be updated by the\n     */\n    public func refresh (startRow: Int, endRow: Int)\n    {\n        // TO BE HONEST - This probably should not be called directly,\n        // instead the view shoudl after feeding data, determine if there is a need\n        // to refresh based on the parameters provided for refresh ranges, and then\n        // update, to avoid the backend rtiggering this multiple times.\n\n        updateRange (startLine: startRow, endLine: endRow)\n    }\n    \n    public func showCursor ()\n    {\n        if cursorHidden == false {\n            return\n        }\n        cursorHidden = false\n        //refresh (startRow: buffer.y, endRow: buffer.y)\n        tdel?.showCursor (source: self)\n    }\n    \n    public func hideCursor ()\n    {\n        if cursorHidden {\n            return\n        }\n        cursorHidden = true\n        tdel?.hideCursor(source: self)\n    }\n\n    // Encode button and position to characters\n    func encodeMouseUtf (data: inout [UInt8], ch: Int)\n    {\n        if ch == 2047 {\n            data.append(0)\n            return\n        }\n        if ch < 127 {\n            data.append (UInt8(ch))\n        } else {\n            let rc = ch > 2047 ? 2047 : ch\n            data.append (0xc0 | (UInt8 (rc >> 6)))\n            data.append (0x80 | (UInt8 (rc & 0x3f)))\n        }\n    }\n    \n    /**\n     * Encodes the button action in the format expected by the client\n     * - Parameter button: The button to encode\n     * - Parameter release: `true` if this is a mouse release event\n     * - Parameter shift: `true` if the shift key is pressed\n     * - Parameter meta: `true` if the meta/alt key is pressed\n     * - Parameter control: `true` if the control key is pressed\n     * - Returns: the encoded value\n     */\n    public func encodeButton (button: Int, release: Bool, shift: Bool, meta: Bool, control: Bool) -> Int\n    {\n        var value: Int\n\n        if release {\n            value = 3\n        } else {\n            switch (button) {\n            case 0:\n                value = 0\n            case 1:\n                value = 1\n            case 2:\n                value = 2\n            case 4:\n                value = 64\n            case 5:\n                value = 65\n            default:\n                value = 0\n            }\n        }\n        if mouseMode.sendsModifiers() {\n            if shift {\n                value |= 4\n            }\n            if meta {\n                value |= 8\n            }\n            if control {\n                value |= 16\n            }\n        }\n        return value\n    }\n    \n    /**\n     * Sends a mouse event for a specific button at the specific location\n     * - Parameter buttonFlags: Button flags encoded in Cb mode.\n     * - Parameter x: X coordinate for the event\n     * - Parameter y: Y coordinate for the event\n     */\n    public func sendEvent (buttonFlags: Int, x: Int, y: Int)\n    {\n        //print (\"got \\(mouseProtocol)\")\n        switch mouseProtocol {\n        case .x10:\n            sendResponse(cc.CSI, \"M\", [UInt8(buttonFlags+32), min (UInt8(255), UInt8(32 + x+1)), min (UInt8(255), UInt8(32+y+1))])\n        case .sgr:\n            let bflags : Int = ((buttonFlags & 3) == 3) ? (buttonFlags & ~3) : buttonFlags\n            let m = ((buttonFlags & 3) == 3) ? \"m\" : \"M\"\n            sendResponse(cc.CSI, \"<\\(bflags);\\(x+1);\\(y+1)\\(m)\")\n        case .urxvt:\n            sendResponse(cc.CSI, \"\\(buttonFlags+32);\\(x+1);\\(y+1)M\");\n        case .utf8:\n            var buffer: [UInt8] = [UInt8 (ascii: \"M\")]\n            encodeMouseUtf(data: &buffer, ch: buttonFlags+32)\n            encodeMouseUtf (data: &buffer, ch: x+33)\n            encodeMouseUtf (data: &buffer, ch: y+33)\n            sendResponse(cc.CSI, buffer)\n        }\n    }\n    \n    /**\n     * Sends a mouse motion event for a specific button at the specific location\n     * - Parameter buttonFlags: Button flags encoded in Cb mode.\n     * - Parameter x: X coordinate for the event\n     * - Parameter y: Y coordinate for the event\n     */\n    public func sendMotion (buttonFlags: Int, x: Int, y: Int)\n    {\n        sendEvent(buttonFlags: buttonFlags+32, x: x, y: y)\n    }\n    \n    static var matchColorCache : [Int:Int] = [:]\n    func matchColor (_ r1: Int, _ g1: Int, _ b1: Int) -> Int32\n    {\n        // TODO\n        abort ()\n    }\n    \n    var terminalTitle: String = \"\"              // The Xterm terminal title\n    var iconTitle: String = \"\"                  // The Xterm minimized window title\n    var terminalTitleStack: [String] = []\n    var terminalIconStack: [String] = []\n    \n    public func setTitle (text: String)\n    {\n        terminalTitle = text\n        tdel?.setTerminalTitle(source: self, title: text)\n    }\n\n    public func setIconTitle (text: String)\n    {\n        iconTitle = text\n        tdel?.setTerminalIconTitle(source: self, title: text)\n    }\n\n    func reverseIndex ()\n    {\n        restrictCursor()\n        if buffer.y == buffer.scrollTop {\n            // possibly move the code below to term.reverseScroll()\n            // test: echo -ne '\\e[1;1H\\e[44m\\eM\\e[0m'\n            // blankLine(true) is xterm/linux behavior\n            let scrollRegionHeight = buffer.scrollBottom - buffer.scrollTop\n            buffer.lines.shiftElements (start: buffer.y + buffer.yBase, count: scrollRegionHeight, offset: 1)\n            buffer.lines [buffer.y + buffer.yBase] = buffer.getBlankLine (attribute: eraseAttr ())\n            updateRange (startLine: buffer.scrollTop, endLine: buffer.scrollBottom)\n        } else if buffer.y > 0 {\n            buffer.y -= 1\n        }\n    }\n    \n    /**\n     * Provides a baseline set of environment variables that would be useful to run the terminal,\n     * you can customzie these accordingly.\n     * - Parameters:\n     *  - termName: desired name for the terminal, if set to nil (the default), it sets it to xterm-256color\n     *  - trueColor: if set to true, sets the COLORTERM variable to truecolor,\n     * - Returns: an array of default environment variables that include TERM set to the specified value, or xterm-256color,\n     * and if trueColor is true, COLORTERM=truecolor, the LANG=en_US.UTF-8 and it mirrors the currently set values\n     * for LOGNAME, USER, DISPLAY, LC_TYPE, USER and HOME.\n     */\n    public static func getEnvironmentVariables (termName: String? = nil, trueColor: Bool = true) -> [String]\n    {\n        var l : [String] = []\n        let t = termName == nil ? \"xterm-256color\" : termName!\n        l.append (\"TERM=\\(t)\")\n        if trueColor {\n            l.append (\"COLORTERM=truecolor\")\n        }\n        \n        // Without this, tools like \"vi\" produce sequences that are not UTF-8 friendly\n        l.append (\"LANG=en_US.UTF-8\")\n        let env = ProcessInfo.processInfo.environment\n        for x in [\"LOGNAME\", \"USER\", \"DISPLAY\", \"LC_TYPE\", \"USER\", \"HOME\" /* \"PATH\" */ ] {\n            if env.keys.contains(x) {\n                l.append (\"\\(x)=\\(env[x]!)\")\n            }\n        }\n        return l\n    }\n    \n    /// Specified the kind of buffer is being requested from the terminal\n    public enum BufferKind {\n        /// The currently active buffer (can be either normal or alt)\n        case active\n        /// The normal buffer, regardless of which buffer is active\n        case normal\n        /// The alternate buffer, regardless of which buffer is active\n        case alt\n    }\n    \n    func bufferFromKind (kind: BufferKind) -> Buffer\n    {\n        switch kind {\n        case .active:\n            return buffers.active\n        case .normal:\n            return buffers.normal\n        case .alt:\n            return buffers.alt\n        }\n    }\n    \n    /// Returns the contents of the specified terminal buffer encoded as UTF8 in the provided Data buffer\n    /// - Parameter kind: which buffer to retrive the data for\n    /// - Parameter encoding: which encoding to use for the returned value, defaults to utf8\n    public func getBufferAsData (kind: BufferKind = .active, encoding: String.Encoding = .utf8) -> Data\n    {\n        var result = Data()\n        \n        let b = bufferFromKind(kind: kind)\n        let newLine = Data([10])\n        for row in 0..<b.lines.count {\n            let bufferLine = b.lines [row]\n            let str = bufferLine.translateToString(trimRight: true)\n            if let encoded = str.data(using: encoding) {\n                result.append (encoded)\n                result.append (newLine)\n            }\n        }\n        return result\n    }\n    \n    /// Returns the text between the specified range\n    ///\n    public func getText (start: Position, end: Position) -> String\n    {\n        let lines = getSelectedLines(p1: start, p2: end)\n        if lines.count == 0 {\n            return \"\"\n        }\n        var r = \"\"\n        for line in lines {\n            r += line.toString()\n        }\n        return r\n    }\n\n    // This version validates the input parameters\n    func getSelectedLines(p1: Position, p2: Position) -> [Line]\n    {\n        var start = p1\n        var end = p2\n        let b = buffer\n        \n        switch Position.compare (start, end) {\n        case .equal:\n            return []\n        case .after:\n            let tmp = start\n            start = end\n            end = tmp\n        case .before:\n            break\n        }\n        if start.row < 0 || start.row > b.lines.count {\n            return []\n        }\n        \n        if end.row >= b.lines.count {\n            end.row = b.lines.count-1\n        }\n        return _getSelectedLines(start, end)\n    }\n    \n    func _getSelectedLines(_ start: Position, _ end: Position) -> [Line]\n    {\n        var lines: [Line] = []\n        let buf = buffer\n        var str = \"\"\n        var currentLine = Line ()\n        lines.append(currentLine)\n        \n        // keep a list of blank lines that we see. if we see content after a group\n        // of blanks, add those blanks but skip all remaining / trailing blanks\n        // these will be blank lines in the selected text output\n        var blanks: [LineFragment] = []\n        \n        func addBlanks () {\n            var lastLine = -1;\n            for b in blanks {\n                if lastLine != -1 && b.line != lastLine {\n                    currentLine = Line ()\n                    lines.append(currentLine)\n                }\n                \n                lastLine = b.line\n                currentLine.add(fragment: b)\n            }\n            blanks = []\n        };\n        \n        // get the first line\n        var bufferLine = buf.lines [start.row]\n        if bufferLine.hasAnyContent() {\n            let str: String = translateBufferLineToString (buffer: buf, line: start.row, start: start.col, end: start.row < end.row ? -1 : end.col)\n            \n            let fragment = LineFragment (text: str, line: start.row, location: start.col, length: str.count)\n            currentLine.add (fragment: fragment)\n        }\n        \n        // get the middle rows\n        var line = start.row + 1\n        var isWrapped = false\n        while line < end.row {\n            bufferLine = buffer.lines [line]\n            isWrapped = bufferLine.isWrapped\n            \n            str = translateBufferLineToString (buffer: buf, line: line, start: 0, end: -1)\n            \n            if bufferLine.hasAnyContent () {\n                // add previously gathered blank fragments\n                addBlanks ()\n                \n                if !isWrapped {\n                    // this line is not a wrapped line, so the\n                    // prior line has a hard linefeed\n                    // add a fragment to that line\n                    currentLine.add (fragment: LineFragment.newLine (line: line - 1))\n                    \n                    // start a new line\n                    currentLine = Line ()\n                    lines.append(currentLine)\n                }\n                \n                // add the text we found to the current line\n                currentLine.add (fragment: LineFragment (text: str, line: line, location: 0, length: str.count))\n            } else {\n                // this line has no content, which means that it's a blank line inserted\n                // somehow, or one of the trailing blank lines after the last actual content\n                // make a note of the line\n                // check that this line is a wrapped line, if so, add a line feed fragment\n                if !isWrapped {\n                    blanks.append (LineFragment.newLine (line: line - 1))\n                }\n                \n                blanks.append(LineFragment (text: str, line: line, location: 0, length: str.count))\n            }\n            \n            line += 1\n        }\n        \n        // get the last row\n        if end.row != start.row {\n            bufferLine = buffer.lines [end.row]\n            if bufferLine.hasAnyContent () {\n                addBlanks ()\n                \n                isWrapped = bufferLine.isWrapped\n                str = translateBufferLineToString (buffer: buf, line: end.row, start: 0, end: end.col)\n                if !isWrapped {\n                    currentLine.add(fragment: LineFragment.newLine (line: line - 1))\n                    currentLine = Line ()\n                    lines.append(currentLine)\n                }\n                \n                currentLine.add (fragment: LineFragment (text: str, line: line, location: 0, length: str.count))\n            }\n        }\n        return lines\n    }\n    \n    func translateBufferLineToString (buffer: Buffer, line: Int, start: Int, end: Int) -> String\n    {\n        buffer.translateBufferLineToString(lineIndex: line, trimRight: true, startCol: start, endCol: end).replacingOccurrences(of: \"\\u{0}\", with: \" \")\n    }\n}\n\n// Default implementations\npublic extension TerminalDelegate {\n    func cursorStyleChanged (source: Terminal, newStyle: CursorStyle)\n    {\n        // Do nothing\n    }\n    \n    func setTerminalTitle (source: Terminal, title: String) {\n        // Do nothing\n    }\n\n    func setTerminalIconTitle (source: Terminal, title: String) {\n        // nothing\n    }\n    \n    func scrolled(source: Terminal, yDisp: Int) {\n        // nothing\n    }\n    \n    func linefeed(source: Terminal) {\n        // nothing\n    }\n    \n    func bufferActivated(source: Terminal) {\n        // nothing\n    }\n    \n    func windowCommand(source: Terminal, command: Terminal.WindowManipulationCommand) -> [UInt8]? {\n        // no special handling\n        return nil\n    }\n    \n    func sizeChanged(source: Terminal) {\n        // nothing\n    }\n    \n    func bell (source: Terminal){\n        // nothing\n    }\n    \n    func isProcessTrusted (source: Terminal) -> Bool {\n        return true\n    }\n    \n    func selectionChanged (source: Terminal){\n        // nothing\n    }\n    \n    func showCursor(source: Terminal) {\n        // nothing\n    }\n\n    func hideCursor(source: Terminal) {\n        // nothing\n    }\n\n    func mouseModeChanged(source: Terminal) {\n    }\n    \n    func hostCurrentDirectoryUpdated (source: Terminal) {\n    }\n    \n    func hostCurrentDocumentUpdated (source: Terminal) {\n    }\n    \n    func colorChanged (source: Terminal, idx: Int?) {\n        \n    }\n    \n    func getColors (source: Terminal) -> (foreground: Color, background: Color)\n    {\n        return (source.foregroundColor, source.backgroundColor)\n    }\n    \n    func setForegroundColor (source: Terminal, color: Color)\n    {\n        source.foregroundColor = color\n    }\n    \n    func setBackgroundColor (source: Terminal, color: Color)\n    {\n        source.backgroundColor = color\n    }\n    \n    func setCursorColor (source: Terminal, color: Color?)\n    {\n        source.cursorColor = color\n    }\n    \n    func iTermContent (source: Terminal, content: ArraySlice<UInt8>) {\n    }\n    \n    func clipboardCopy(source: Terminal, content: Data) {\n    }\n    \n    func notify(source: Terminal, title: String, body: String) {\n    }\n    \n    func createImageFromBitmap (source: Terminal, bytes: inout [UInt8], width: Int, height: Int){\n    }\n\n    func createImage (source: Terminal, data: Data, width: ImageSizeRequest, height: ImageSizeRequest, preserveAspectRatio: Bool) {\n    }    \n}\n"], "fixing_code": ["//\n//  Terminal.swift\n//  SwiftTerm\n//\n//  Created by Miguel de Icaza on 3/27/19.\n//  Copyright \u00a9 2019 Miguel de Icaza. All rights reserved.\n//\n// TODO: review every place that sets cursor to use setCursor\n// TODO: audit every location to use restrictCursor\n\nimport Foundation\n\n/**\n * The terminal delegate is a protocol that must be implemented by a class\n * that would provide a user interface for the terminal, and it is used by the\n * `Terminal` to notify of important changes on the underlying terminal\n */\npublic protocol TerminalDelegate: AnyObject {\n    /**\n     * Invoked to request that the cursor be shown\n     */\n    func showCursor (source: Terminal)\n\n    /**\n     * Invoked to request that the cursor be shown\n     */\n    func hideCursor (source: Terminal)\n\n    /**\n     * This method is invoked when the terminal needs to set the title for the window,\n     * a UI toolkit would react by setting the terminal title in the window or any other\n     * user visible element.\n     *\n     * The default implementation does nothing.\n     */\n    func setTerminalTitle (source: Terminal, title: String)\n\n    /**\n     * This method is invoked when the terminal needs to set the title for the minimized icon,\n     * a UI toolkit would react by setting the terminal title in the icon or any other\n     * user visible element\n     *\n     * The default implementation does nothing.\n     */\n    func setTerminalIconTitle (source: Terminal, title: String)\n\n    /**\n     * These are various commands that are sent by the client.  They are rare,\n     * and if you do not know what to return, just return nil, the terminal\n     * will return a suitable value.\n     *\n     * The response string needs to be suitable for the Xterm CSI Ps ; Ps ; Ps t command\n     * see the WindowManipulationCommand enumeration for those that need to return values\n     *\n     * The default implementation does nothing.\n     */\n    @discardableResult\n    func windowCommand (source: Terminal, command: Terminal.WindowManipulationCommand) -> [UInt8]?\n    \n    /**\n     * This method is invoked when the terminal dimensions have changed in response\n     * to an escape sequence that triggers a terminal resize, the user interface toolkit\n     * should attempt to accomodate the new window size\n     *\n     * TODO: This is not wired up\n     *\n     * The default implementation does nothing.\n     */\n    func sizeChanged (source: Terminal)\n    \n    /**\n     * Sends the byte data to the client connected to the terminal (in terminal emulation\n     * documentation, this is the \"host\")\n     */\n    func send (source: Terminal, data: ArraySlice<UInt8>)\n    \n    // callbacks\n    \n    /// Callback - the window was scrolled, new yDisplay passed\n    /// The default implementation does nothing.\n    func scrolled (source: Terminal, yDisp: Int)\n    \n    /// Callback a newline was generated\n    /// The default implementation does nothing.\n    func linefeed (source: Terminal)\n    \n    /// This method is invoked when the buffer changes from Normal to Alternate, or Alternate to Normal\n    /// The default implementation does nothing.\n    func bufferActivated (source: Terminal)\n    \n    /// Should raise the bell\n    /// The default implementation does nothing.\n    func bell (source: Terminal)\n    \n    /**\n     * This is invoked when the selection has changed, or has been turned on.   The status is\n     * available in `terminal.selection.active`, and the range relative to the buffer is\n     * in `terminal.selection.start` and `terminal.selection.end`\n     *\n     * The default implementation does nothing.\n     */\n    func selectionChanged (source: Terminal)\n    \n    /**\n     * This method should return `true` if operations that can read the buffer back should be allowed,\n     * otherwise, return false.   This is useful to run some applications that attempt to checksum the\n     * contents of the screen (unit tests)\n     *\n     * The default implementation returns `true`\n     */\n    func isProcessTrusted (source: Terminal) -> Bool\n    \n    /**\n     * This method is invoked when the `mouseMode` property has changed, and gives the UI\n     * a chance to update any tracking capabilities that are required in the toolkit or no longer\n     * required to provide the events.\n     *\n     * The default implementation ignores the mouse change\n     */\n    func mouseModeChanged (source: Terminal)\n    \n    /**\n     * This method is invoked when a request to change the cursor style has been issued\n     * by client application.\n     */\n    func cursorStyleChanged (source: Terminal, newStyle: CursorStyle)\n    \n    /**\n     * This method is invoked when the client application has issued a command to report\n     * its current working directory (this is done with the OSC 7 command).   The value can be\n     * read by accessing the `hostCurrentDirectory` property.\n     *\n     * The default implementaiton does nothing.\n     */\n    func hostCurrentDirectoryUpdated (source: Terminal)\n    \n    /**\n     * This method is invoked when the client application has issued a command to report\n     * its current document (this is done with the OSC 6 command).   The value can be\n     * read by accessing the `hostCurrentDocument` property.\n     *\n     * The default implementaiton does nothing.\n     */\n    func hostCurrentDocumentUpdated (source: Terminal)\n    \n    /**\n     * This method is invoked when a color in the 0..255 palette has been redefined, if the\n     * front-end keeps a cache or uses indexed rendering, it should update the color\n     * with the new values.   If the value of idx is nil, this means all the ansi colors changed\n     */\n    func colorChanged (source: Terminal, idx: Int?)\n    \n    /**\n     * The view should try to set the foreground color to the provided color\n     */\n    func setForegroundColor (source: Terminal, color: Color)\n    \n    /**\n     * The view should try to set the background color to the provided color\n     */\n    func setBackgroundColor (source: Terminal, color: Color)\n    \n    /**\n     * The view should try to set the cursor color to the provided color.   If color is nil, the view can use a default.\n     */\n    func setCursorColor (source: Terminal, color: Color?)\n    \n    /**\n     * This should return the current foreground and background colors to\n     * report.\n     */\n    func getColors (source: Terminal) -> (foreground: Color, background: Color)\n    \n    /**\n     * This method is invoked when the client application (iTerm2) has issued a OSC 1337 and\n     * SwiftTerm did not handle a handler for it.\n     *\n     * The default implementaiton does nothing.\n     */\n    func iTermContent (source: Terminal, content: ArraySlice<UInt8>)\n    \n    /**\n     * This method is invoked when the client application has issued a OSC 52\n     * to put data on the clipboard.\n     *\n     * - Parameters:\n     *  - source: identifies the instance of the terminal that sent this request\n     *  - content: the data to place on the clipboard\n     * The default implementation does nothing.\n     */\n    func clipboardCopy(source: Terminal, content: Data)\n    \n    /**\n     * Invoked when client application issues OSC 777 to show notification.\n     *\n     * The default implementation does nothing.\n     * - Parameters:\n     *  - source: identifies the instance of the terminal that sent this request\n     *  - title: the title to show for the notification\n     *  - body: the body of the notification\n     */\n    func notify(source: Terminal, title: String, body: String)\n    \n    /**\n     * Invoked to create an image from an RGBA buffer at the current cursor position\n     *\n     * The default implementation does nothing.\n     * - Parameters:\n     *  - source: identifies the instance of the terminal that sent this request\n     *  - bytes: Image buffer in RGBA format, using 8 bits per channel.\n     *  - width: the width in pixels of the image\n     *  - height: the height in pixels of the image\n     */\n    func createImageFromBitmap (source: Terminal, bytes: inout [UInt8], width: Int, height: Int)\n    \n    /**\n     * Invoked to create an image from a byte blob that might be encoded in one of the various\n     * compressed file formats (unlike the other option that gets an RGBA buffer already decoded).\n     * It also included requests for the desired dimensions.\n     * - Parameters:\n     *  - source: identifies the instance of the terminal that sent this request\n     *  - data: Binary blob containing the image data, which is typically encoded as a PNG or JPEG file\n     *  - widthRequest: the width requested, it contains an enumeration describing what the request was\n     *  - height: the height requested, it contains an enumeration describing what the request was\n     *  - preserveAspectRatio: if set, one of the dimensions will track the hardcoded setting set for the other.\n     */\n    func createImage (source: Terminal, data: Data, width: ImageSizeRequest, height: ImageSizeRequest, preserveAspectRatio: Bool)\n}\n\n/// Enumeration passed to the TerminalDelegate.createImage to configure\n/// the desired values for width and height.\npublic enum ImageSizeRequest {\n    /// Make the best decision based on the image data\n    case auto\n    /// Occupy exactly the number of cells\n    case cells(Int)\n    /// Occupy exactly the pixels listed\n    case pixels(Int)\n    /// Occupy a percentange size relative to the dimension of the visible region\n    case percent(Int)\n}\n\npublic protocol TerminalImage {\n    /// The width of the image in pixels\n    var pixelWidth: Int { get }\n    /// The height of the image in pixels\n    var pixelHeight: Int { get }\n    \n    /// Column where the image was attached\n    var col: Int { get set }\n}\n\n/**\n * The `Terminal` class provides the terminal emulation engine, and can be used to feed data to the\n * terminal emulator.   Typically users will intereact with a higher-level implementation that provides a\n * UI toolkit-specific rendering and connects the input to the UI toolkit.\n *\n * A front-end would draw the contents of the terminal, and take input from the user, which is in turn\n * either mapped to one of the public APIs here, or if it is user input is passed to the `feed`  methods here.\n *\n * The terminal is also connected to a backend that is conneted to the client, and data from this\n * client is fed into the emulator by calling the `sendResponse method`\n *\n * The behavior of the terminal is configured by implementing the `TerminalDelegate` protocol\n * that is provided in the constructor call.\n */\nopen class Terminal {\n    let MINIMUM_COLS = 2\n    let MINIMUM_ROWS = 1\n    \n    /// The current terminal columns (counting from 1)\n    public private(set) var cols: Int = 80\n    \n    /// The current terminal rows (counting from 1)\n    public private(set) var rows: Int = 25\n    var tabStopWidth : Int = 8\n    var options: TerminalOptions\n    \n    // The current buffers\n    var buffers : BufferSet!\n    \n    // Whether the terminal is operating in application keypad mode\n    var applicationKeypad : Bool = false\n    \n    // Whether the terminal is operating in application cursor mode\n    public var applicationCursor : Bool = false\n    \n    // You can ignore most of the defaults set here, the function\n    // reset() will do that again\n    var sendFocus: Bool = false\n    var cursorHidden : Bool = false\n    \n    /// Controls the origin mode (DECOM), when set, the screen is limited to the top and bottom margins\n    var originMode: Bool = false\n    \n    /// Controls whether it is possible to set left and right margin modes\n    var marginMode: Bool = false\n    \n    var insertMode: Bool = false\n    \n    /// Indicates that the application has toggled bracketed paste mode, which means that when content is pasted into\n    /// the terminal, the content will be wrapped in \"ESC [ 200 ~\" to start, and \"ESC [ 201 ~\" to end.\n    public private(set) var bracketedPasteMode: Bool = false\n    \n    var charset: [UInt8:String]? = nil\n    var gcharset: Int = 0\n    var wraparound: Bool = false\n    var reverseWraparound: Bool = false\n    weak var tdel: TerminalDelegate?\n    var curAttr: Attribute = CharData.defaultAttr\n    var gLevel: UInt8 = 0\n    var cursorBlink: Bool = false\n    \n    var allow80To132 = true\n    \n    var parser: EscapeSequenceParser\n    \n    var refreshStart = Int.max\n    var refreshEnd = -1\n    var scrollInvariantRefreshStart = Int.max\n    var scrollInvariantRefreshEnd = -1\n    var userScrolling = false\n    var lineFeedMode = false\n    \n    // We do not implement smooth scrolling here, dubious value, but\n    // makes a test bass\n    var smoothScroll = false\n    \n    // Installed colors are the 16 values that can be changed dynamically by the host\n    var installedColors: [Color]\n    // The blueprint for the colors, computed based on the installed colors\n    var defaultAnsiColors: [Color]\n    // The active set of colors (based on the blueprint)\n    var ansiColors: [Color]\n    \n    // Control codes provides an API to send either 8bit sequences or 7bit sequences for C0 and C1 depending on the terminal state\n    var cc: CC\n    \n    /// This variable if set, contains an URI representing the host and directory of the process running in the terminal\n    /// it is often used by applciations to track the working directory.   It might be nil, or might not be correct, the\n    /// contents are entirely under the control of the remote application, and require the terminal to be trusted\n    /// (see the `isProcessTrusted` method in the `TerminalDelegate`).  When this is set the\n    /// `hostCurrentDirectoryUpdated` method on the delegate is invoked.\n    public private(set) var hostCurrentDirectory: String? = nil\n    \n    /// This variable if set, contains an URI representing the host and current document of the process\n    /// running in the terminal.   It might be nil, or might not be correct, the\n    /// contents are entirely under the control of the remote application, and require the terminal to be trusted\n    /// (see the `isProcessTrusted` method in the `TerminalDelegate`).  When this is set the\n    /// `hostCurrentDocumentUpdated` method on the delegate is invoked.\n    public private(set) var hostCurrentDocument: String? = nil\n    \n    /// The current attribute used by the terminal by default\n    public var currentAttribute: Attribute {\n        get { return curAttr }\n    }\n    // The requested conformance from DECSCL command\n    enum TerminalConformance {\n        case vt100\n        case vt200\n        case vt300\n        case vt400\n        case vt500\n    }\n    \n    // The mouse coordinates can be encoded in a number of ways, and obey to historical\n    // upgrades to the protocol, but also attempts at fixing limitations of the different\n    // encodings.\n    enum MouseProtocolEncoding {\n        // The default x10 mode is limited to coordinates up to 223.\n        // (255-32).   The other modes solve this limitaion\n        case x10\n        \n        // Extends the range of a coordinate to 2015 by using UTF-8 encoding of the\n        // coordinate value.   This encoding is troublesome for applications that\n        // do not support utf8 input.\n        case utf8\n        \n        // The response uses CSI < ButtonValue ; Px ; Py [Mm]\n        case sgr\n\n        // Different response style, with possible ambiguities, not recommended\n        case urxvt\n    }\n    \n    // The protocol encoding for the terminal\n    private var mouseProtocol: MouseProtocolEncoding = .x10\n\n    // This is used to track if we are setting the colors, to prevent a\n    // recursive invocation (nativeForegroundColor sets the terminal\n    // color, which in turn broadcasts the request for a change)\n    var settingFgColor = false, settingBgColor = false, settingCursorColor = false\n\n    /// This tracks the current foreground color for the application.\n    public var foregroundColor: Color = Color.defaultForeground {\n        didSet {\n            if settingFgColor {\n                return\n            }\n            settingFgColor = true\n            tdel?.setForegroundColor(source: self, color: foregroundColor)\n            settingFgColor = false\n        }\n    }\n    /// This tracks the current background color for the application.\n    public var backgroundColor: Color = Color.defaultBackground {\n        didSet {\n            if settingBgColor {\n                return\n            }\n            settingBgColor = true\n            tdel?.setBackgroundColor(source: self, color: backgroundColor)\n            settingBgColor = false\n        }\n    }\n    \n    // This tracks the requested cursor color or nil to use a view-default\n    public var cursorColor: Color? = nil {\n        didSet {\n            if settingCursorColor {\n                return\n            }\n            settingCursorColor = true\n            tdel?.setCursorColor(source: self, color: cursorColor)\n            settingCursorColor = false\n        }\n    }\n    \n    ///\n    /// Represents the mouse operation mode that the terminal is currently using and higher level\n    /// implementations should use the functions in this enumeration to determine what events to\n    /// send\n    public enum MouseMode {\n        /// No mouse events are reported\n        case off\n        \n        /// X10 Compatibility mode - only sends events in button press\n        case x10\n        \n        /// VT200, also known as Normal Tracking Mode - sends both press and release events\n        case vt200\n        \n        /// ButtonEventTracking - In addition to sending button press and release events, it sends motion events when the button is pressed\n        case buttonEventTracking\n        \n        /// Sends button presses, button releases, and motion events regardless of the button state\n        case anyEvent\n        \n        // Unsupported modes:\n        // - vt200Highlight, this can deadlock the terminal\n        // - declocator, rarely used\n        \n        /// Returns true if you should send a button press event (separate from release)\n        func sendButtonPress () -> Bool\n        {\n            self == .vt200 || self == .buttonEventTracking || self == .anyEvent\n        }\n        \n        /// Returns true if you should send the button release event\n        func sendButtonRelease () -> Bool\n        {\n            self != .off\n        }\n        \n        /// Returns true if you should send a motion event when a button is pressed\n        func sendButtonTracking () -> Bool\n        {\n            self == .buttonEventTracking || self == .anyEvent\n        }\n        \n        /// Returns true if you should send a motion event, regardless of button state\n        public func sendMotionEvent () -> Bool\n        {\n            self == .anyEvent\n        }\n        \n        /// Returns true if the modifiers should be encoded\n        public func sendsModifiers() -> Bool {\n            self == .vt200 || self == .buttonEventTracking || self == .anyEvent\n        }\n    }\n    \n    public private(set) var mouseMode: MouseMode = .off {\n        didSet {\n            tdel?.mouseModeChanged (source: self)\n        }\n    }\n\n    // The next four variables determine whether setting/querying should be done using utf8 or latin1\n    // and whether the values should be set or queried using hex digits, rather than actual byte streams\n    var xtermTitleSetUtf = false\n    var xtermTitleSetHex = false\n    var xtermTitleQueryUtf = false\n    var xtermTitleQueryHex = false\n    \n    var conformance: TerminalConformance = .vt500\n    \n    /**\n     * Returns true if we should respect the left/right margins, which is based on the originMode and marginMode setting\n     */\n    func usingMargins() ->Bool\n    {\n        return originMode && marginMode\n    }\n    \n    /// Returns the terminal dimensions 1-based values\n    public func getDims () -> (cols: Int,rows: Int)\n    {\n        return (cols, rows)\n    }\n    \n    public init (delegate : TerminalDelegate, options: TerminalOptions = TerminalOptions.default)\n    {\n        installedColors = Color.defaultInstalledColors\n        defaultAnsiColors = Color.setupDefaultAnsiColors (initialColors: installedColors)\n        ansiColors = defaultAnsiColors\n        tdel = delegate\n        self.options = options\n        // This duplicates the setup above, but\n        parser = EscapeSequenceParser ()\n        cc = CC(send8bit: false)\n        configureParser (parser)\n        setup ()\n    }\n\n    /// Installs the new colors as the default colors and recomputes the\n    /// current and ansi palette.   This will not change the UI layer, for that it is better\n    /// to call the `installColors` method on `TerminalView`, which will\n    /// both call this method, and update the display appropriately.\n    ///\n    /// - Parameter colors: this should be an array of 16 values that correspond to the 16 ANSI colors,\n    /// if the array does not contain 16 elements, it will not do anything\n    public func installPalette (colors: [Color])\n    {\n        if colors.count != 16 {\n            return\n        }\n        installedColors = colors\n        defaultAnsiColors = Color.setupDefaultAnsiColors (initialColors: installedColors)\n        ansiColors = defaultAnsiColors\n    }\n    \n    /**\n     * Returns the active buffer (either the normal buffer or the alternative buffer)\n     */\n    var buffer: Buffer {\n        get {\n            buffers!.active\n        }\n    }\n\n    /// Returns the CharData at the specified column and row from the visible portion of the buffer, these are zero-based\n    ///\n    /// - Parameter col: column to retrieve, starts at 0\n    /// - Parameter row: row to retrieve, starts at 0\n    /// - Returns: nil if the col or row are out of bounds, or the CharData contained in that cell otherwise\n    ///\n    public func getCharData (col: Int, row: Int) -> CharData?\n    {\n        if col < 0 || col >= cols {\n            return nil\n        }\n        if let l = getLine (row: row) {\n            return l [col]\n        }\n        return nil\n    }\n\n    /// Returns the contents of a line as a BufferLine, or nil if the requested line is out of range\n    ///\n    /// The line is counted  from start of scroll back, not what the terminal has visible right now.\n    /// - Parameter row: the row to retrieve, relative to the scroll buffer, not the visible display\n    /// - Returns: nil if the col or row are out of bounds, or the BufferLine  otherwise\n    public func getLine (row: Int) -> BufferLine? {\n        if row < 0 || row >= rows {\n            return nil\n        }\n        return buffer.lines [row + buffer.yDisp]\n    }\n\n    /// Returns the contents of a line as a BufferLine counting from the begging of the scroll buffer.\n    ///\n    /// The line is counted  from start of scroll back, not what the terminal has visible right now.\n    /// - Parameter row: the row to retrieve, relative to the scroll buffer, not the visible display\n    /// - Returns: nil if the col or row are out of bounds, or the BufferLine  otherwise\n    public func getScrollInvariantLine (row: Int) -> BufferLine? {\n        if row < buffer.linesTop || row >= buffer.lines.count + buffer.linesTop {\n            return nil\n        }\n        return buffer.lines [row-buffer.linesTop]\n    }\n\n    /// Returns the character at the specified column and row, these are zero-based\n    /// - Parameter col: column to retrieve, starts at 0\n    /// - Parameter row: row to retrieve, starts at 0\n    /// - Returns: nil if the col or row are out of bounds, or the Character contained in that cell otherwise\n    \n    public func getCharacter (col: Int, row: Int) -> Character?\n    {\n        return getCharData(col: col, row: row)?.getCharacter()\n    }\n    \n    func setup (isReset: Bool = false)\n    {\n        // Sadly a duplicate of much of what lives in init() due to Swift not allowing me to\n        // call this\n        cols = max (options.cols, MINIMUM_COLS)\n        rows = max (options.rows, MINIMUM_ROWS)\n        if buffers != nil && isReset {\n            buffers.resetNormal ()\n            buffers.activateNormalBuffer(clearAlt: false)\n        } else if buffers == nil {\n            buffers = BufferSet(self)\n        }\n        cursorHidden = false\n        \n        // modes\n        applicationKeypad = false\n        applicationCursor = false\n        originMode = false\n        \n        marginMode = false\n        insertMode = false\n        wraparound = true\n        bracketedPasteMode = false\n        \n        // charset'\n        charset = nil\n        gcharset = 0\n        gLevel = 0\n        curAttr = CharData.defaultAttr\n        \n        mouseMode = .off\n        \n        buffer.scrollTop = 0\n        buffer.scrollBottom = rows-1\n        buffer.marginLeft = 0\n        buffer.marginRight = cols-1\n        \n        cc.send8bit = false\n        conformance = .vt500\n        \n        allow80To132 = true\n        \n        xtermTitleSetUtf = false\n        xtermTitleQueryUtf = false\n        \n        xtermTitleSetHex = false\n        xtermTitleQueryHex = false\n        \n        hyperLinkTracking = nil\n        cursorBlink = false\n        hostCurrentDirectory = nil\n        lineFeedMode = options.convertEol\n    }\n    \n    // DCS $ q Pt ST\n    // DECRQSS (https://vt100.net/docs/vt510-rm/DECRQSS.html)\n    //   Request Status String (DECRQSS), VT420 and up.\n    // Response: DECRPSS (https://vt100.net/docs/vt510-rm/DECRPSS.html)\n    class DECRQSS : DcsHandler {\n        var data: [UInt8]\n        unowned var terminal: Terminal\n\n        public init (terminal: Terminal)\n        {\n            self.terminal = terminal\n            data = []\n        }\n\n        func hook (collect: cstring, parameters: [Int],  flag: UInt8)\n        {\n            data = []\n        }\n        \n        func put (data : ArraySlice<UInt8>)\n        {\n            for x in data {\n                self.data.append(x)\n            }\n        }\n        \n        func unhook ()\n        {\n            let newData = String (bytes: data, encoding: .ascii)\n            var ok = 1 // 0 means the request is valid according to docs, but tests expect 0?\n            var result: String\n            switch (newData) {\n            case \"\\\"q\": // DECCSA - Set Character Attribute\n                result = \"\\\"q\"\n            case \"\\\"p\": // DECSCL - conformance level\n                result = \"65;1\\\"p\"\n            case \"r\": // DECSTBM - the top and bottom margins\n                result = \"\\(terminal.buffer.scrollTop + 1);\\(terminal.buffer.scrollBottom + 1)r\"\n            case \"m\": // SGR - the set graphic rendition\n                // TODO: report real settings instead of 0m\n                result = terminal.curAttr.toSgr ()\n            case \"s\": // DECSLRM - the current left and right margins\n                result = \"\\(terminal.buffer.marginLeft+1);\\(terminal.buffer.marginRight+1)s\"\n            case \" q\": // DECSCUSR - the set cursor style\n                // TODO this should send a number for the current cursor style 2 for block, 4 for underline and 6 for bar\n                let style = \"2\" // block\n                result = \"\\(style) q\"\n            default:\n                ok = 0 // this means the request is not valid, report that to the host.\n                // invalid: DCS 0 $ r Pt ST (xterm)\n                terminal.log (\"Unknown DCS + \\(newData!)\")\n                // Do not report 'newData', because it can be exploited\n                // see https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=510030\n                result = \"\"\n\n            }\n            terminal.sendResponse (terminal.cc.DCS, \"\\(ok)$r\\(result)\", terminal.cc.ST)\n        }\n    }\n\n    // Configures the EscapeSequenceParser\n    func configureParser (_ parser: EscapeSequenceParser)\n    {\n        parser.csiHandlerFallback = { [unowned self] (pars: [Int], collect: cstring, code: UInt8) -> () in\n            let ch = Character(UnicodeScalar(code))\n            self.log (\"Unknown CSI Code (collect=\\(collect) code=\\(ch) pars=\\(pars))\")\n        }\n        parser.escHandlerFallback = { [unowned self] (txt: cstring, flag: UInt8) in\n            self.log (\"Unknown ESC Code: ESC + \\(Character(Unicode.Scalar (flag))) txt=\\(txt)\")\n        }\n        parser.executeHandlerFallback = { [unowned self] in\n            self.log (\"Unknown EXECUTE code\")\n        }\n        parser.oscHandlerFallback = { [unowned self] (code: Int) in\n            self.log (\"Unknown OSC code: \\(code)\")\n        }\n        parser.printHandler = { [unowned self] slice in handlePrint (slice) }\n        parser.printStateReset = { [unowned self] in printStateReset() }\n        \n        // CSI handler\n        parser.csiHandlers [UInt8 (ascii: \"@\")] = { [unowned self] pars, collect in cmdInsertChars (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"A\")] = { [unowned self] pars, collect in cmdCursorUp (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"B\")] = { [unowned self] pars, collect in cmdCursorDown (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"C\")] = { [unowned self] pars, collect in cmdCursorForward (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"D\")] = { [unowned self] pars, collect in cmdCursorBackward (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"E\")] = { [unowned self] pars, collect in cmdCursorNextLine (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"F\")] = { [unowned self] pars, collect in cmdCursorPrecedingLine (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"G\")] = { [unowned self] pars, collect in cmdCursorCharAbsolute (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"H\")] = { [unowned self] pars, collect in cmdCursorPosition (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"I\")] = { [unowned self] pars, collect in cmdCursorForwardTab (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"J\")] = { [unowned self] pars, collect in cmdEraseInDisplay (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"K\")] = { [unowned self] pars, collect in cmdEraseInLine (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"L\")] = { [unowned self] pars, collect in cmdInsertLines (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"M\")] = { [unowned self] pars, collect in cmdDeleteLines (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"P\")] = { [unowned self] pars, collect in cmdDeleteChars (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"S\")] = { [unowned self] pars, collect in cmdScrollUp (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"T\")] = { [unowned self] pars, collect in csiT (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"X\")] = { [unowned self] pars, collect in cmdEraseChars (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"Z\")] = { [unowned self] pars, collect in cmdCursorBackwardTab (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"`\")] = { [unowned self] pars, collect in cmdCharPosAbsolute (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"a\")] = { [unowned self] pars, collect in cmdHPositionRelative (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"b\")] = { [unowned self] pars, collect in cmdRepeatPrecedingCharacter (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"c\")] = { [unowned self] pars, collect in cmdSendDeviceAttributes (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"d\")] = { [unowned self] pars, collect in cmdLinePosAbsolute (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"e\")] = { [unowned self] pars, collect in cmdVPositionRelative (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"f\")] = { [unowned self] pars, collect in cmdHVPosition (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"g\")] = { [unowned self] pars, collect in cmdTabClear (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"h\")] = { [unowned self] pars, collect in cmdSetMode (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"l\")] = { [unowned self] pars, collect in cmdResetMode (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"m\")] = { [unowned self] pars, collect in cmdCharAttributes (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"n\")] = { [unowned self] pars, collect in cmdDeviceStatus (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"p\")] = { [unowned self] pars, collect in csiPHandler (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"q\")] = { [unowned self] pars, collect in cmdSetCursorStyle (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"r\")] = { [unowned self] pars, collect in cmdSetScrollRegion (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"s\")] = { [unowned self] args, cstring in\n            // \"CSI s\" is overloaded, can mean save cursor, but also set the margins with DECSLRM\n            if self.marginMode {\n                self.cmdSetMargins (args, cstring)\n            } else {\n                self.cmdSaveCursor (args, cstring)\n            }\n        }\n        parser.csiHandlers [UInt8 (ascii: \"t\")] = { [unowned self] pars, collect in csit (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"u\")] = { [unowned self] pars, collect in cmdRestoreCursor (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"v\")] = { [unowned self] pars, collect in csiCopyRectangularArea (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"x\")] = { [unowned self] pars, collect in csiX (pars, collect) } /* x DECFRA - could be overloaded */\n        parser.csiHandlers [UInt8 (ascii: \"y\")] = { [unowned self] pars, collect in cmdDECRQCRA (pars, collect) } /* y - Checksum Region */\n        parser.csiHandlers [UInt8 (ascii: \"z\")] = { [unowned self] pars, collect in csiZ (pars, collect) } /* DECERA */\n        parser.csiHandlers [UInt8 (ascii: \"{\")] = { [unowned self] pars, collect in csiOpenBrace (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"}\")] = { [unowned self] pars, collect in csiCloseBrace (pars, collect) }\n        parser.csiHandlers [UInt8 (ascii: \"~\")] = { [unowned self] pars, collect in cmdDeleteColumns (pars, collect) }\n\n        parser.executeHandlers [7]  = { [unowned self] in self.tdel?.bell (source: self) }\n        parser.executeHandlers [10] = { [unowned self] in cmdLineFeed () }\n        parser.executeHandlers [11] = { [unowned self] in cmdLineFeedBasic () }  // VT Vertical Tab - ignores auto-new-line behavior in ConvertEOL\n        parser.executeHandlers [12] = { [unowned self] in cmdLineFeedBasic () }\n        parser.executeHandlers [13] = { [unowned self] in cmdCarriageReturn () }\n        parser.executeHandlers [8]  = { [unowned self] in cmdBackspace () }\n        parser.executeHandlers [9]  = { [unowned self] in cmdTab () }\n        parser.executeHandlers [14] = { [unowned self] in cmdShiftOut () }\n        parser.executeHandlers [15] = { [unowned self] in cmdShiftIn () }\n        \n        parser.executeHandlers [0x84] = { [unowned self] in cmdIndex () }\n        parser.executeHandlers [0x85] = { [unowned self] in cmdNextLine () }\n        parser.executeHandlers [0x88] = {  [unowned self] in cmdTabSet () }\n\n        //\n        // OSC handler\n        //\n        //   0 - icon name + title\n        parser.oscHandlers [0] = { [unowned self] data in self.setTitle(text: String (bytes: data, encoding: .utf8) ?? \"\")}\n        //   1 - icon name\n        parser.oscHandlers [1] = { [unowned self] data in self.setIconTitle(text: String (bytes: data, encoding: .utf8) ?? \"\") }\n        //   2 - title\n        parser.oscHandlers [2] = { [unowned self] data in self.setTitle(text: String (bytes: data, encoding: .utf8) ?? \"\")}\n        //   3 - set property X in the form \"prop=value\"\n        //   4 - Change Color Number()\n        parser.oscHandlers [4] = { [unowned self] data in oscChangeOrQueryColorIndex (data) }\n        \n        //   5 - Change Special Color Number\n        //   6 - Enable/disable Special Color Number c\n\n        //   6 - current document:\n        parser.oscHandlers [6] = { [unowned self] data in oscSetCurrentDocument (data) }\n\n        //   7 - current directory? (not in xterm spec, see https://gitlab.com/gnachman/iterm2/issues/3939)\n        parser.oscHandlers [7] = { [unowned self] data in oscSetCurrentDirectory (data) }\n        \n        parser.oscHandlers [8] = { [unowned self] data in oscHyperlink (data) }\n        //  10 - Change VT100 text foreground color to Pt.\n        parser.oscHandlers [10] = { [unowned self] data in oscSetTextForeground (data) }\n        //  11 - Change VT100 text background color to Pt.\n        parser.oscHandlers [11] = { [unowned self] data in oscSetTextBackground (data) }\n        //  12 - Change text cursor color to Pt.\n        parser.oscHandlers [12] = { [unowned self] data in oscSetCursorColor (data) }\n        \n        //  13 - Change mouse foreground color to Pt.\n        //  14 - Change mouse background color to Pt.\n        //  15 - Change Tektronix foreground color to Pt.\n        //  16 - Change Tektronix background color to Pt.\n        //  17 - Change highlight background color to Pt.\n        //  18 - Change Tektronix cursor color to Pt.\n        //  19 - Change highlight foreground color to Pt.\n        //  46 - Change Log File to Pt.\n        //  50 - Set Font to Pt.\n        //  51 - reserved for Emacs shell.\n        //  52 - Clipboard operations\n        parser.oscHandlers [52] = { [unowned self] data in oscClipboard (data) }\n        // 104 ; c - Reset Color Number c.\n        parser.oscHandlers [104] = { [unowned self] data in oscResetColor (data) }\n        \n        // 105 ; c - Reset Special Color Number c.\n        // 106 ; c; f - Enable/disable Special Color Number c.\n        // 110 - Reset VT100 text foreground color.\n        // 111 - Reset VT100 text background color.\n        // 112 - Reset text cursor color.\n        // 113 - Reset mouse foreground color.\n        // 114 - Reset mouse background color.\n        // 115 - Reset Tektronix foreground color.\n        // 116 - Reset Tektronix background color.\n        parser.oscHandlers [777] = { [unowned self] data in oscNotification (data) }\n        parser.oscHandlers [1337] = { [unowned self] data in osciTerm2 (data) }\n\n        //\n        // ESC handlers\n        //\n        parser.setEscHandler(\"6\",   { [unowned self] collect, flag in self.columnIndex (back: true) })\n        parser.setEscHandler (\"7\",  { [unowned self] collect, flag in self.cmdSaveCursor ([], []) })\n        parser.setEscHandler (\"8\",  { [unowned self] collect, flag in self.cmdRestoreCursor ([], []) })\n        parser.setEscHandler (\"9\",  { [unowned self] collect, flag in self.columnIndex(back: false) })\n        parser.setEscHandler (\"D\",  { [unowned self] collect, flag in self.cmdIndex() })\n        parser.setEscHandler (\"E\",  { [unowned self] collect, flag in self.cmdNextLine () })\n        parser.setEscHandler (\"H\",  { [unowned self] collect, flag in self.cmdTabSet ()})\n        parser.setEscHandler (\"M\",  { [unowned self] collect, flag in self.reverseIndex() })\n        parser.setEscHandler (\"=\",  { [unowned self] collect, flag in self.cmdKeypadApplicationMode ()})\n        parser.setEscHandler (\">\",  { [unowned self] collect, flag in self.cmdKeypadNumericMode ()})\n        parser.setEscHandler (\"c\",  { [unowned self] collect, flag in self.cmdReset () })\n        parser.setEscHandler (\"n\",  { [unowned self] collect, flag in self.setgLevel (2) })\n        parser.setEscHandler (\"o\",  { [unowned self] collect, flag in self.setgLevel (3) })\n        parser.setEscHandler (\"|\",  { [unowned self] collect, flag in self.setgLevel (3) })\n        parser.setEscHandler (\"}\",  { [unowned self] collect, flag in self.setgLevel (2) })\n        parser.setEscHandler (\"~\",  { [unowned self] collect, flag in self.setgLevel (1) })\n        parser.setEscHandler (\"%@\", { [unowned self] collect, flag in self.cmdSelectDefaultCharset () })\n        parser.setEscHandler (\"%G\", { [unowned self] collect, flag in self.cmdSelectDefaultCharset () })\n        parser.setEscHandler (\"#3\", { [unowned self] collect, flag in self.cmdSetDoubleHeightTop() })\n        parser.setEscHandler (\"#4\", { [unowned self] collect, flag in self.cmdSetDoubleHeightBottom() })\n        parser.setEscHandler (\"#6\", { [unowned self] collect, flag in self.cmdDoubleWidthSingleHeight () })\n        parser.setEscHandler (\"#8\", { [unowned self] collect, flag in self.cmdScreenAlignmentPattern () })\n        parser.setEscHandler (\" G\") { [unowned self] collect, flag in self.cmdSet8BitControls () }\n        parser.setEscHandler (\" F\") { [unowned self] collect, flag in self.cmdSet7BitControls () }\n        \n        for bflag in CharSets.all.keys {\n            let flag = String (UnicodeScalar (bflag))\n            \n            parser.setEscHandler (\"(\" + flag, { [unowned self] code, f in self.selectCharset ([UInt8 (ascii: \"(\")] + [f]) })\n            parser.setEscHandler (\")\" + flag, { [unowned self] code, f in self.selectCharset ([UInt8 (ascii: \")\")] + [f]) })\n            parser.setEscHandler (\"*\" + flag, { [unowned self] code, f in self.selectCharset ([UInt8 (ascii: \"*\")] + [f]) })\n            parser.setEscHandler (\"+\" + flag, { [unowned self] code, f in self.selectCharset ([UInt8 (ascii: \"+\")] + [f]) })\n            parser.setEscHandler (\"-\" + flag, { [unowned self] code, f in self.selectCharset ([UInt8 (ascii: \"-\")] + [f]) })\n            parser.setEscHandler (\".\" + flag, { [unowned self] code, f in self.selectCharset ([UInt8 (ascii: \".\")] + [f]) })\n            parser.setEscHandler (\"/\" + flag, { [unowned self] code, f in self.selectCharset ([UInt8 (ascii: \"/\")] + [f]) })\n        }\n\n        // Error handler\n        parser.errorHandler = { [unowned self] state in\n            self.log (\"Parsing error, state: \\(state)\")\n            return state\n        }\n\n        // DCS Handler\n        parser.setDcsHandler (\"$q\", DECRQSS (terminal: self))\n        parser.setDcsHandler (\"q\", SixelDcsHandler (terminal: self))\n        parser.dscHandlerFallback = { code, parameters in }\n    }\n    \n    /// This allows users of the terminal to register a handler for an OSC code.\n    /// - Parameters:\n    ///  - code: the code for the OSC handler to register, no checks are made that this overrides an existing handler\n    ///  - handler: the code to invoke when the OSC handler is received.\n    public func registerOscHandler (code: Int, handler: @escaping (ArraySlice<UInt8>) -> ())\n    {\n        parser.oscHandlers [code] = handler\n    }\n    \n    func cmdSet8BitControls ()\n    {\n        cc.send8bit = true\n    }\n\n    func cmdSet7BitControls ()\n    {\n        cc.send8bit = false\n    }\n\n    func emitScroll (_ x: Int)\n    {\n        // In the original code, it is mediocre accessibility, so likely will remove this\n    }\n    \n    func emitChar (_ ch: Character)\n    {\n        // In the original code, it is mediocre accessibility, so likely will remove this\n    }\n\n    //\n    // Because data might not be complete, we need to put back data that we read to process on\n    // a future read.  To prepare for reading, on every call to parse, the prepare method is\n    // given the new ArraySlice to read from.\n    //\n    // the `hasNext` describes whether there is more data left on the buffer, and `bytesLeft`\n    // returnes the number of bytes left.   The `getNext` method fetches either the next\n    // value from the putback buffer, or when it is empty, it returns it from the buffer that\n    // was passed during prepare.\n    //\n    // Additionally, the terminal parser needs to reset the parser state on demand, and\n    // that is surfaced via reset\n    //\n    struct ReadingBuffer {\n        var putbackBuffer: [UInt8] = []\n        var rest:ArraySlice<UInt8> = [][...]\n        var idx = 0\n        var count:Int = 0\n        \n        // Invoke this method at the beginning of parse\n        mutating func prepare (_ data: ArraySlice<UInt8>)\n        {\n            assert (rest.count == 0)\n            rest = data\n            count = putbackBuffer.count + data.count\n            idx = 0\n        }\n        \n        func hasNext () -> Bool {\n            idx < count\n        }\n        \n        func bytesLeft () -> Int\n        {\n            count-idx\n        }\n        \n        mutating func getNext () -> UInt8\n        {\n            if idx < putbackBuffer.count {\n                let v = putbackBuffer [idx]\n                idx += 1\n                return v\n            }\n            let v = rest [idx-putbackBuffer.count+rest.startIndex]\n            idx += 1\n            return v\n        }\n        \n        // Puts back the code, and everything that was pending\n        mutating func putback (_ code: UInt8)\n        {\n            var newPutback: [UInt8] = [code]\n            let left = bytesLeft()\n            for _ in 0..<left {\n                newPutback.append (getNext ())\n            }\n            putbackBuffer = newPutback\n            rest = [][...]\n        }\n        \n        mutating func done  ()\n        {\n            if idx < putbackBuffer.count {\n                putbackBuffer.removeFirst(idx)\n            } else {\n                putbackBuffer = []\n            }\n            rest = [][...]\n        }\n        \n        mutating func reset ()\n        {\n            putbackBuffer = []\n            idx = 0\n        }\n    }\n    \n    var readingBuffer = ReadingBuffer ()\n    \n    func printStateReset ()\n    {\n        readingBuffer.reset ()\n    }\n    \n    // This variable holds the last location that we poked a Character on.   This is required\n    // because combining unicode characters come after the character, so we need to poke back\n    // at this location.   We track the buffer (so we can distinguish Alt/Normal), the buffer line\n    // that we fetched, and the column.\n    var lastBufferStorage: (buffer: Buffer, y: Int, x: Int, cols: Int, rows: Int)? = nil\n    \n    var lastBufferCol: Int = 0\n    \n    func handlePrint (_ data: ArraySlice<UInt8>)\n    {\n        let buffer = self.buffer\n        readingBuffer.prepare(data)\n\n        updateRange (buffer.y)\n        while readingBuffer.hasNext() {\n            var ch: Character = \" \"\n            var chWidth: Int = 0\n            let code = readingBuffer.getNext()\n            \n            let n = UnicodeUtil.expectedSizeFromFirstByte(code)\n\n            if n == -1 || n == 1 {\n                // n == -1 means an Invalid UTF-8 sequence, client sent us some junk, happens if we run\n                // with the wrong locale set for example if LANG=en, still we handle it here\n\n                // get charset replacement character\n                // charset are only defined for ASCII, therefore we only\n                // search for an replacement char if code < 127\n                var chSet = false\n                if code < 127 && charset != nil {\n                    \n                    // Notice that the charset mapping can contain the dutch unicode sequence for \"ij\",\n                    // so it is not a simple byte, it is a Character\n                    if let str = charset! [UInt8 (code)] {\n                        ch = str.first!\n                        \n                        // Every single mapping in the charset only takes one slot\n                        chWidth = 1\n                        chSet = true\n                    }\n                }\n                \n                if chSet == false {\n                    let rune = UnicodeScalar (code)\n                    chWidth = UnicodeUtil.columnWidth(rune: rune)\n                    ch = Character (rune)\n                }\n            } else if readingBuffer.bytesLeft() >= (n-1) {\n                var x : [UInt8] = [code]\n                for _ in 1..<n {\n                    x.append (readingBuffer.getNext())\n                }\n                x.append(0)\n                x.withUnsafeBytes { ptr in\n                    let unsafeBound = ptr.bindMemory(to: UInt8.self)\n                    let unsafePointer = unsafeBound.baseAddress!\n                    \n                    let s = String (cString: unsafePointer)\n                    ch = s.first ?? Character (\" \")\n\n                    // Now the challenge is that we have a character, not a rune, and we want to compute\n                    // the width of it.\n                    if ch.unicodeScalars.count == 1 {\n                        chWidth = UnicodeUtil.columnWidth(rune: ch.unicodeScalars.first!)\n                    } else {\n                        chWidth = 0\n                        for scalar in ch.unicodeScalars {\n                            chWidth = max (chWidth, UnicodeUtil.columnWidth(rune: scalar))\n                        }\n                    }\n                }\n            } else {\n                readingBuffer.putback (code)\n                return\n            }\n\n            if let firstScalar = ch.unicodeScalars.first {\n                // If this is a Unicode combining character\n                if firstScalar.properties.canonicalCombiningClass != .notReordered {\n                    // Determine if the last time we poked at a character is still valid\n                    if let last = lastBufferStorage {\n                        if last.buffer === buffers.active && last.cols == cols && last.rows == rows {\n                            \n                            // Fetch the old character, and attempt to combine it:\n                            let existingLine = buffer.lines [last.y]\n                            let lastx = last.x >= cols ? cols-1 : last.x\n                            var cd = existingLine [lastx]\n                            \n                            // Attemp the combination\n                            let newStr = String ([cd.getCharacter (), ch])\n                            \n                            // If the resulting string is 1 grapheme cluster, then it combined properly\n                            if newStr.count == 1 {\n                                if let newCh = newStr.first {\n                                    cd.setValue(char: newCh, size: Int32 (cd.width))\n                                    existingLine [lastx] = cd\n                                    updateRange (last.y)\n                                    continue\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            // The accessibility stack might not need this\n            //let screenReaderMode = options.screenReaderMode\n            //if screenReaderMode {\n            //    emitChar (ch)\n            //}\n            let charData = CharData (attribute: curAttr, char: ch, size: Int8 (chWidth))\n            insertCharacter (charData)\n        }\n        updateRange (buffer.y)\n        readingBuffer.done ()\n    }\n    \n    // Inserts the specified character with the computed width into the next cell, following\n    // the rules for wrapping around, scrolling and overflow expected in the terminal.\n    func insertCharacter (_ charData: CharData)\n    {\n        let buffer = self.buffer\n        var chWidth = Int (charData.width)\n        var bufferRow = buffer.lines [buffer.y + buffer.yBase]\n\n        let right = marginMode ? buffer.marginRight : cols - 1\n        // goto next line if ch would overflow\n        // TODO: needs a global min terminal width of 2\n        // FIXME: additionally ensure chWidth fits into a line\n        //   -->  maybe forbid cols<xy at higher level as it would\n        //        introduce a bad runtime penalty here\n        if buffer.x + chWidth - 1 > right {\n            // autowrap - DECAWM\n            // automatically wraps to the beginning of the next line\n            if wraparound {\n                buffer.x = marginMode ? buffer.marginLeft : 0\n\n                if buffer.y >= buffer.scrollBottom {\n                    scroll (isWrapped: true)\n                } else {\n                    // The line already exists (eg. the initial viewport), mark it as a\n                    // wrapped line\n                    buffer.y += 1\n                    buffer.lines [buffer.y].isWrapped = true\n                }\n                // row changed, get it again\n                bufferRow = buffer.lines [buffer.y + buffer.yBase]\n            } else {\n                if (chWidth == 2) {\n                    // FIXME: check for xterm behavior\n                    // What to do here? We got a wide char that does not fit into last cell\n                    return\n                }\n                // FIXME: Do we have to set buffer.x to cols - 1, if not wrapping?\n                buffer.x = right\n            }\n        }\n\n        var empty = CharData.Null\n        empty.attribute = curAttr\n        // insert mode: move characters to right\n        if insertMode {\n            // right shift cells according to the width\n            bufferRow.insertCells (pos: buffer.x, n: chWidth, rightMargin: marginMode ? buffer.marginRight : cols-1, fillData: empty)\n            // test last cell - since the last cell has only room for\n            // a halfwidth char any fullwidth shifted there is lost\n            // and will be set to eraseChar\n            let lastCell = bufferRow [cols - 1]\n            if lastCell.width == 2 {\n                bufferRow [cols - 1] = empty\n            }\n        }\n\n        // write current char to buffer and advance cursor\n        lastBufferStorage = (buffer, buffer.y + buffer.yBase, buffer.x, cols, rows)\n        if buffer.x >= cols {\n            buffer.x = cols-1\n        }\n        bufferRow [buffer.x] = charData\n        buffer.x += 1\n\n        // fullwidth char - also set next cell to placeholder stub and advance cursor\n        // for graphemes bigger than fullwidth we can simply loop to zero\n        // we already made sure above, that buffer.x + chWidth will not overflow right\n        if chWidth > 0 {\n            chWidth -= 1\n            while chWidth != 0 && buffer.x < buffer.cols {\n                bufferRow [buffer.x] = empty\n                buffer.x += 1\n                chWidth -= 1\n            }\n        }\n    }\n\n    func cmdLineFeed ()\n    {\n        cmdLineFeedBasic ()\n    }\n    \n    func cmdLineFeedBasic ()\n    {\n        let buffer = self.buffer\n        let by = buffer.y\n        \n        let canScroll = buffer.x >= buffer.marginLeft && buffer.x <= buffer.marginRight\n        \n        if by == buffer.scrollBottom {\n            if canScroll {\n                scroll(isWrapped: false)\n            }\n        } else if by == rows - 1 {\n        } else {\n                buffer.y = by + 1\n        }\n        \n        // If the end of the line is hit, prevent this action from wrapping around to the next line.\n        if buffer.x >= cols {\n            buffer.x -= 1\n        }\n        \n        // This event is emitted whenever the terminal outputs a LF or NL.\n        emitLineFeed()\n        if lineFeedMode {\n            buffer.x = usingMargins() ? buffer.marginLeft : 0\n        }\n    }\n    \n    //\n    // Backspace handler (Control-h)\n    //\n    func cmdBackspace ()\n    {\n        let buffer = self.buffer\n        restrictCursor(!reverseWraparound)\n        \n        let left = marginMode ? buffer.marginLeft : 0\n        let right = marginMode ? buffer.marginRight : buffer.cols-1\n\n        if buffer.x > left {\n            buffer.x -= 1\n        } else if reverseWraparound {\n            if buffer.x <= left {\n                if buffer.y > buffer.scrollTop && buffer.y <= buffer.scrollBottom && (buffer.lines [buffer.y + buffer.yBase].isWrapped || marginMode) {\n                    if !marginMode {\n                        buffer.lines [buffer.y + buffer.yBase].isWrapped = false\n                    }\n                    \n                    buffer.y -= 1\n                    buffer.x = right\n                // TODO: find actual last cell based on width used\n                } else if buffer.y == buffer.scrollTop {\n                    buffer.x = right\n                    buffer.y = buffer.scrollBottom\n                } else if buffer.y > 0 {\n                    buffer.x = right\n                    buffer.y -= 1\n                }\n            }\n        } else {\n            if buffer.x < left && buffer.x > 0 {\n                // This compensates for the scenario where backspace is supposed to move one step\n                // backwards if the \"x\" position is behind the left margin.\n                // Test BS_MovesLeftWhenLeftOfLeftMargin\n                buffer.x -= 1\n            } else if buffer.x > left {\n                // If we have not reached the limit, we can go back, otherwise stop at the margin\n                // Test BS_StopsAtLeftMargin\n                buffer.x -= 1\n            \n            }\n        }\n    }\n    \n    func cmdCarriageReturn ()\n    {\n        let buffer = self.buffer\n        if marginMode {\n            if buffer.x < buffer.marginLeft {\n                buffer.x = 0\n            } else {\n                buffer.x = buffer.marginLeft\n            }\n        } else {\n            buffer.x = 0\n        }\n    }\n    \n    //\n    // Horizontal tab (control-i)\n    //\n    func cmdTab ()\n    {\n        buffer.x = buffer.nextTabStop ()\n    }\n\n    // SO\n    // ShiftOut (Control-N) Switch to alternate character set.  This invokes the G1 character set\n    func cmdShiftOut ()\n    {\n        setgLevel (1)\n    }\n    \n    // SI\n    // ShiftIn (Control-O) Switch to standard character set.  This invokes the G0 character set\n    func cmdShiftIn ()\n    {\n        setgLevel(0)\n    }\n    \n    // Operating System Commands (OSC)\n    \n    func resetAllColors ()\n    {\n        ansiColors = defaultAnsiColors\n        tdel?.colorChanged (source: self, idx: nil)\n    }\n    \n    func resetColor (_ number: Int)\n    {\n        if number > 255 {\n            return\n        }\n        ansiColors [number] = defaultAnsiColors [number]\n        tdel?.colorChanged(source: self, idx: number)\n    }\n    \n    func oscResetColor (_ data: ArraySlice<UInt8>)\n    {\n        if data == [] {\n            resetAllColors()\n        } else {\n            if let param = String (bytes: data, encoding: .ascii) {\n                let colors = param.split(separator: \";\")\n                for color in colors {\n                    resetColor (Int (color) ?? 0)\n                }\n            }\n        }\n    }\n    \n    // Implements OSC 7 ; URL which records the current working directory\n    func oscSetCurrentDirectory (_ data: ArraySlice<UInt8>)\n    {\n        if !(tdel?.isProcessTrusted(source: self) ?? false) {\n            return\n        }\n        var s = String (bytes:data, encoding: .utf8)\n        if s == nil {\n            s = String (bytes:data, encoding: .ascii)\n        }\n        if let txt = s {\n            hostCurrentDirectory = txt\n            tdel?.hostCurrentDirectoryUpdated (source: self)\n        }\n    }\n    \n    // Implements OSC 6 ; URL which records the current document\n    func oscSetCurrentDocument (_ data: ArraySlice<UInt8>)\n    {\n        if !(tdel?.isProcessTrusted(source: self) ?? false) {\n            return\n        }\n        var s = String (bytes:data, encoding: .utf8)\n        if s == nil {\n            s = String (bytes:data, encoding: .ascii)\n        }\n        if let txt = s {\n            hostCurrentDocument = txt\n            tdel?.hostCurrentDocumentUpdated (source: self)\n        }\n    }\n\n    var hyperLinkTracking: (start: Position, payload: String)? = nil\n    \n    func oscHyperlink (_ data: ArraySlice<UInt8>)\n    {\n        let buffer = self.buffer\n        if data.count == 1 && data [data.startIndex] == UInt8 (ascii: \";\") {\n            // We only had the terminator, so we can close \";\"\n            if let hlt = hyperLinkTracking {\n                let str = hlt.payload\n                if let urlToken = TinyAtom.lookup (value: str) {\n                    //print (\"Setting the text from \\(hlt.start) to \\(buffer.x) on line \\(buffer.y+buffer.yBase) to \\(str)\")\n                    \n                    // Between the time the flag was set, and now `y` might have changed negatively,\n                    // in that case, we do not flag any sequence as a hyperlink\n                    if hlt.start.row <= buffer.y+buffer.yBase {\n                        for y in hlt.start.row...(buffer.y+buffer.yBase) {\n                            let line = buffer.lines [y]\n                            let startCol = y == hlt.start.row ? min (hlt.start.col, cols-1) : 0\n                            let endCol = y == buffer.y ? min (buffer.x, cols-1) : (marginMode ? buffer.marginRight : cols-1)\n                            if endCol > startCol {\n                                for x in startCol...endCol {\n                                    var cd = line [x]\n                                    cd.setPayload(atom: urlToken)\n                                    line [x] = cd\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            hyperLinkTracking = nil\n        } else {\n            hyperLinkTracking = (start: Position(col: buffer.x, row: buffer.y+buffer.yBase), payload: String (bytes:data, encoding: .ascii) ?? \"\")\n        }\n    }\n    \n    // Copy to clipboard with sequence on the form:\n    //    ESC ] 52 ; c ; [base64 data] \\a\n    // where c is for copy and the only thing supported.\n    func oscClipboard (_ data: ArraySlice<UInt8>) {\n        // we require data to start with c; followed by base64 content\n        guard data.count >= 2,\n              data[data.startIndex] == UInt8(ascii: \"c\"),\n              data[data.startIndex+1] == UInt8(ascii: \";\") else {\n            return\n        }\n        \n        let base64 = Data(data[(data.startIndex+2)...])\n        guard let content = Data(base64Encoded: base64) else {\n            return\n        }\n        \n        tdel?.clipboardCopy(source: self, content: content)\n    }\n    \n    // Notifications:\n    //    ESC ] 777 ; notify ; [title] ; [body] \\a\n    func oscNotification(_ data: ArraySlice<UInt8>) {\n        guard let text = String(bytes: data, encoding: .utf8) else {\n            return\n        }\n        \n        let parts = text.components(separatedBy: \";\")\n        guard parts.count >= 3,\n              parts[0] == \"notify\" else {\n            return\n        }\n        \n        let title = parts[1]\n        let body = parts[2...].joined(separator: \";\")\n        tdel?.notify(source: self, title: title, body: body)\n    }\n\n    // OSC 1337 is used by iTerm2 for imgcat and other things:\n    //  https://iterm2.com/documentation-images.html\n    // ESC ] 1337 ; key = value ^G\n    //\n    // Options\n    // ESC ] 1337 ; File = [arguments] : base-64 encoded file contents ^G\n    //\n    func osciTerm2 (_ data: ArraySlice<UInt8>) {\n        // Parses the key-value pairs separated by \";\"\n        func parseKeyValues (_ data: ArraySlice<UInt8>) -> [String:String] {\n            var kv: [String:String] = [:]\n            var current = data.startIndex\n            repeat {\n                let next = data [current..<data.endIndex].firstIndex(where: { b in b == UInt8 (ascii: \";\")}) ?? data.endIndex\n                guard let equalIdx = data [current..<next].firstIndex(where: { b in b == UInt8 (ascii: \"=\")}) else {\n                    break\n                }\n                guard let key = String (bytes: data[current..<equalIdx], encoding: .utf8) else {\n                    break\n                }\n                guard let value = String (bytes: data[equalIdx+1..<next], encoding: .utf8) else {\n                    break\n                }\n                kv [key] = value\n                current = next == data.endIndex ? next : next+1\n            } while current < data.endIndex\n            return kv\n        }\n        \n        /// Parses the dimension specification (\"auto\", \"N%\", \"Npx\" or \"N\") and returns the enum value for it\n        /// puts some artificial limits, to prevent bloat or attacks\n        func parseDimension(_ kv: [String:String], key: String) -> ImageSizeRequest {\n            let artificialDimensionSizeLimit = 1024*4\n            let artificialColumnLimit = 200\n            \n            guard let v = kv [key] else {\n                return .auto\n            }\n            if v == \"auto\" { return .auto }\n            if v.hasSuffix (\"%\") {\n                if let n = Int (v.dropLast(1)), n > 0, n <= 100 { return .percent (n) }\n                return .auto\n            }\n            if v.hasSuffix(\"px\") {\n                if let n = Int (v.dropLast(2)), n > 0, n < artificialDimensionSizeLimit { return .pixels (n) }\n                return .auto\n            }\n            if let n = Int (v), n > 0, n < artificialColumnLimit { return .cells(n) }\n            return .auto\n        }\n        \n        guard let equalIdx = data.firstIndex (where: { b in b == UInt8(ascii: \"=\") }) else {\n            return\n        }\n        \n        guard let key = String(bytes: data[data.startIndex..<equalIdx], encoding: .utf8) else {\n            return\n        }\n        switch key {\n        case \"File\":\n            guard let colonIdx = data [equalIdx...].firstIndex(where: { b in b == UInt8 (ascii: \":\")}) else {\n                return\n            }\n            let kv = parseKeyValues (data [equalIdx+1..<colonIdx])\n            // inline == 1 means to display the image inline, the option == 0 downloads the provided file\n            // into the file system, and I do not think it is a good idea to download data from untrusted\n            // sources like this and potentially override existing files.   So let us just not bother\n            // supporting that\n            if kv[\"inline\"] != \"1\" {\n                return\n            }\n            \n            guard let imgData = Data(base64Encoded: Data(data [colonIdx+1..<data.endIndex])) else {\n                return\n            }\n            let width = parseDimension (kv, key: \"width\")\n            let height = parseDimension (kv, key: \"height\")\n\n            tdel?.createImage(source: self, data: imgData, width: width, height: height, preserveAspectRatio: (kv [\"preserveAspectRatio\"] ?? \"1\" ) == \"1\")\n        default:\n            break\n        }\n        \n        tdel?.iTermContent(source: self, content: data)\n    }\n    \n    // OSC 4\n    func oscChangeOrQueryColorIndex (_ data: ArraySlice<UInt8>)\n    {\n        var parsePos = data.startIndex\n        while parsePos <= data.endIndex {\n            guard let p = data [parsePos...].firstIndex(of: UInt8 (ascii: \";\")) else {\n                return\n            }\n            let color = EscapeSequenceParser.parseInt(data [parsePos..<p])\n            guard color < 256 else {\n                return\n            }\n        \n            // If the request is a query, reply with the current color definition\n            if p+1 < data.endIndex && data [p+1] == UInt8 (ascii: \"?\") {\n                sendResponse (cc.OSC, \"4;\\(color);\\(ansiColors [color].formatAsXcolor())\", cc.ST)\n                parsePos = p+2\n                if parsePos < data.endIndex && data [parsePos] == UInt8(ascii: \";\"){\n                    parsePos += 1\n                }\n                continue\n            }\n    \n            //let str = String (bytes:data, encoding: .ascii) ?? \"\"\n            //print (\"Parsing color definition \\(str)\")\n\n            parsePos = p + 1\n        \n            let end = data [parsePos...].firstIndex(of: UInt8(ascii: \";\")) ?? data.endIndex\n            \n            if let newColor = Color.parseColor (data [parsePos..<end]) {\n                ansiColors [color] = newColor\n                tdel?.colorChanged (source: self, idx: color)\n            }\n            parsePos = end+1\n        }\n        \n        //log (\"Attempt to set the text Foreground color \\(str)\")\n    }\n    \n    func reportColor (oscCode: Int, color: Color) {\n        sendResponse(cc.OSC, \"\\(oscCode);\\(color.formatAsXcolor ())\", cc.ST)\n    }\n    \n    // This handles both setting the foreground, but spill into background and cursor color\n    // if more parameters are provided (ie, sending OSC 10 with #ffffff,#000000,#ff0000\n    // sets the foreground to #ffffff, background to #000000 and cursor to ff0000\n    func oscSetTextForeground (_ data: ArraySlice<UInt8>)\n    {\n        let groups = data.split(separator: UInt8 (ascii: \";\"))\n        var next = 0\n        while next < groups.count {\n            defer { next += 1 }\n            let text = groups [next]\n            \n            if text.first == UInt8 (ascii: \"?\") {\n                switch next {\n                case 0:\n                    reportColor (oscCode: 10, color: foregroundColor)\n                case 1:\n                    reportColor (oscCode: 11, color: backgroundColor)\n                default:\n                    break\n                }\n                \n                continue\n            }\n\n            guard let color = Color.parseColor(text) else {\n                continue\n            }\n            switch next {\n            case 0:\n                foregroundColor = color\n                tdel?.setForegroundColor(source: self, color: color)\n            case 1:\n                backgroundColor = color\n                tdel?.setBackgroundColor(source: self, color: color)\n            case 2:\n                cursorColor = color\n                tdel?.setCursorColor(source: self, color: color)\n                break\n            default:\n                break\n            }\n        }\n    }\n\n    func oscSetTextBackground (_ data: ArraySlice<UInt8>)\n    {\n        if data.first == UInt8 (ascii: \"?\") {\n            reportColor (oscCode: 11, color: backgroundColor)\n            return\n        }\n\n        if let background = Color.parseColor(data) {\n            backgroundColor = background\n            tdel?.setBackgroundColor(source: self, color: background)\n        }\n    }\n\n    func oscSetCursorColor (_ data: ArraySlice<UInt8>)\n    {\n        if let cursorColor = Color.parseColor(data) {\n            self.cursorColor = cursorColor\n            tdel?.setCursorColor(source: self, color: cursorColor)\n        }\n    }\n\n    //\n    // ESC E\n    // C1.NEL\n    //   DEC mnemonic: NEL (https://vt100.net/docs/vt510-rm/NEL)\n    //   Moves cursor to first position on next line.\n    //\n    func cmdNextLine ()\n    {\n        buffer.x = usingMargins () ? buffer.marginLeft : 0\n        cmdIndex ()\n    }\n\n    /**\n     * ESC H\n     * C1.HTS\n     *   DEC mnemonic: HTS (https://vt100.net/docs/vt510-rm/HTS.html)\n     *   Sets a horizontal tab stop at the column position indicated by\n     *   the value of the active column when the terminal receives an HTS.\n     *\n     * @vt: #Y   C1    HTS   \"Horizontal Tabulation Set\" \"\\x88\"    \"Places a tab stop at the current cursor position.\"\n     * @vt: #Y   ESC   HTS   \"Horizontal Tabulation Set\" \"ESC H\"   \"Places a tab stop at the current cursor position.\"\n     */\n    func cmdTabSet ()\n    {\n        buffer.tabSet (pos: buffer.x)\n    }\n    \n    //\n    // CSI Ps @\n    // Insert Ps (Blank) Character(s) (default = 1) (ICH).\n    //\n    func cmdInsertChars (_ pars: [Int], _ collect: cstring)\n    {\n        // Do nothing if we are outside the margin\n        if marginMode && (buffer.x < buffer.marginLeft || buffer.x > buffer.marginRight) {\n            return\n        }\n        let cd = CharData (attribute: eraseAttr ())\n        let buffer = self.buffer\n        \n        buffer.lines [buffer.y + buffer.yBase].insertCells (pos: buffer.x, n: pars.count > 0 ? max (pars [0], 1) : 1, rightMargin: marginMode ? buffer.marginRight : cols-1, fillData: cd)\n\n        updateRange (buffer.y)\n    }\n    \n    //\n    // CSI Ps A\n    // Cursor Up Ps Times (default = 1) (CUU).\n    //\n    func cmdCursorUp (_ pars: [Int], _ collect: cstring)\n    {\n        let param = max (pars.count > 0 ? pars [0] : 1, 1)\n        let buffer = self.buffer\n        var top = buffer.scrollTop\n        \n        if buffer.y < top {\n            top = 0\n        }\n        if (buffer.y - param < top) {\n            buffer.y = top\n        } else {\n            buffer.y -= param\n        }\n    }\n    \n    //\n    // CSI Ps B\n    // Cursor Down Ps Times (default = 1) (CUD).\n    //\n    func cmdCursorDown (_ pars: [Int], _ collect: cstring)\n    {\n        let buffer = self.buffer\n        let param = max (pars.count > 0 ? pars [0] : 1, 1)\n        \n        var bottom = buffer.scrollBottom\n        // When the cursor starts below the scroll region, CUD moves it down to the\n        // bottom of the screen.\n        if buffer.y > bottom {\n            bottom = buffer.rows-1\n        }\n        let newY = buffer.y + param\n\n        if newY >= bottom {\n                buffer.y = bottom\n        } else {\n                buffer.y = newY\n        }\n        // If the end of the line is hit, prevent this action from wrapping around to the next line.\n        if buffer.x >= cols {\n                buffer.x -= 1\n        }\n    }\n    \n    //\n    // CSI Ps B\n    // Cursor Forward Ps Times (default = 1) (CUF).\n    //\n    func cmdCursorForward (_ pars: [Int], _ collect: cstring)\n    {\n        cursorForward(count: pars.count > 0 ? pars [0] : 1)\n    }\n    \n    func cursorForward (count: Int)\n    {\n        var right = marginMode ? buffer.marginRight : cols-1\n        \n        // When the cursor starts after the right margin, CUF moves to the full width\n        if buffer.x > right {\n            right = buffer.cols - 1\n        }\n        buffer.x += (max (count, 1))\n        if buffer.x > right {\n            buffer.x = right\n        }\n    }\n\n    //\n    // CSI Ps D\n    // Cursor Backward Ps Times (default = 1) (CUB).\n    //\n    func cmdCursorBackward (_ pars: [Int], _ collect: cstring)\n    {\n        cursorBackward(count: pars.count > 0 ? pars [0] : 1)\n    }\n    \n    func cursorBackward (count: Int)\n    {\n        let buffer = self.buffer\n        \n        // What is our left margin - depending on the settings.\n        var left = marginMode ? buffer.marginLeft : 0\n        \n        // If the cursor is positioned before the margin, we can go backwards to the first column\n        if buffer.x < left {\n            left = 0\n        }\n        let newX = buffer.x - max (1, count)\n        if newX < left {\n            buffer.x = left\n        } else {\n            buffer.x = newX\n        }\n    }\n\n    //\n    // CSI Ps I\n    //   Cursor Forward Tabulation Ps tab stops (default = 1) (CHT).\n    //\n    func cmdCursorForwardTab (_ pars: [Int], _ collect: cstring)\n    {\n        let param = min (cols-1, max (pars.count > 0 ? pars [0] : 1, 1))\n        for _ in 0..<param {\n            buffer.x = buffer.nextTabStop ()\n        }\n    }\n    \n    /**\n     * Restrict cursor to viewport size / scroll margin (origin mode)\n     * - Parameter limitCols: by default it is true, but the reverseWraparound mechanism in Backspace needs `x` to go beyond.\n     */\n    func restrictCursor(_ limitCols: Bool = true)\n    {\n        buffer.x = min (cols - (limitCols ? 1 : 0), max (0, buffer.x))\n        buffer.y = originMode\n            ? min (buffer.scrollBottom, max (buffer.scrollTop, buffer.y))\n            : min (rows - 1, max (0, buffer.y))\n        \n        updateRange(buffer.y)\n    }\n\n    //\n    // CSI Ps ; Ps H\n    // Cursor Position [row;column] (default = [1,1]) (CUP).\n    //\n    func cmdCursorPosition (_ pars: [Int], _ collect: cstring)\n    {\n        setCursor (col: pars.count >= 2 ? (max (1, pars [1])-1) : 0, row: pars.count >= 1 ? (max (1, pars [0]) - 1) : 0)\n    }\n    \n    func setCursor (col: Int, row: Int)\n    {\n        updateRange(buffer.y)\n        if originMode {\n            buffer.x = col + (usingMargins () ? buffer.marginLeft : 0)\n            buffer.y = buffer.scrollTop + row\n        } else {\n            buffer.x = col\n            buffer.y = row\n        }\n        restrictCursor ()\n    }\n\n    //\n    // CSI Ps E\n    // Cursor Next Line Ps Times (default = 1) (CNL).\n    // same as CSI Ps B?\n    //\n    func cmdCursorNextLine (_ pars: [Int], _ collect: cstring)\n    {\n        cmdCursorDown(pars, collect)\n        buffer.x = buffer.marginLeft\n\n        //return\n        //let buffer = self.buffer\n        //let param = max (pars.count > 0 ? pars [0] : 1, 1)\n        //\n        //var bottom = buffer.scrollBottom\n        //// When the cursor starts below the scroll region, CUD moves it down to the\n        //// bottom of the screen.\n        //if buffer.y > bottom {\n        //    bottom = buffer.rows-1\n        //}\n        //let newY = buffer.y + param\n        //\n        //if newY >= bottom {\n        //        buffer.y = bottom\n        //} else {\n        //        buffer.y = newY\n        //}\n        //// If the end of the line is hit, prevent this action from wrapping around to the next line.\n        //if buffer.x >= cols {\n        //        buffer.x -= 1\n        //}\n        //buffer.x = buffer.marginLeft\n    }\n\n    //\n    // CSI Ps F\n    // Cursor Preceding Line Ps Times (default = 1) (CPL).\n    // reuse CSI Ps A ?\n    //\n    func cmdCursorPrecedingLine (_ pars: [Int], _ collect: cstring)\n    {\n        cmdCursorUp(pars, collect)\n        buffer.x = buffer.marginLeft\n        \n        //let param = max (pars.count > 0 ? pars [0] : 1, 1)\n        //let buffer = self.buffer\n        //var top = buffer.scrollTop\n        //\n        //if buffer.y < top {\n        //    top = 0\n        //}\n        //if (buffer.y - param < top) {\n        //    buffer.y = top\n        //} else {\n        //    buffer.y -= param\n        //}\n        //buffer.x = buffer.marginLeft\n    }\n\n    //\n    // CSI Ps G\n    // Cursor Character Absolute  [column] (default = [row,1]) (CHA).\n    //\n    func cmdCursorCharAbsolute (_ pars: [Int], _ collect: cstring)\n    {\n        let buffer = self.buffer\n        let param = max (pars.count > 0 ? pars [0] : 1, 1)\n\n        buffer.x = (usingMargins() ? buffer.marginLeft : 0) + min (param - 1, cols - 1)\n    }\n\n    //\n    // CSI Ps K  Erase in Line (EL).\n    //     Ps = 0  -> Erase to Right (default).\n    //     Ps = 1  -> Erase to Left.\n    //     Ps = 2  -> Erase All.\n    // CSI ? Ps K\n    //   Erase in Line (DECSEL).\n    //     Ps = 0  -> Selective Erase to Right (default).\n    //     Ps = 1  -> Selective Erase to Left.\n    //     Ps = 2  -> Selective Erase All.\n    //\n    func cmdEraseInLine (_ pars: [Int], _ collect: cstring)\n    {\n        let p = pars.count == 0 ? 0 : pars [0]\n        \n        switch p {\n        case 0:\n            eraseInBufferLine (y: buffer.y, start: buffer.x, end: cols)\n        case 1:\n            eraseInBufferLine (y: buffer.y, start: 0, end: buffer.x + 1)\n        case 2:\n            eraseInBufferLine (y: buffer.y, start: 0, end: cols)\n        default:\n            break\n        }\n        updateRange (buffer.y)\n    }\n\n    //\n    // CSI Ps J  Erase in Display (ED).\n    //     Ps = 0  -> Erase Below (default).\n    //     Ps = 1  -> Erase Above.\n    //     Ps = 2  -> Erase All.\n    //     Ps = 3  -> Erase Saved Lines (xterm).\n    // CSI ? Ps J\n    //   Erase in Display (DECSED).\n    //     Ps = 0  -> Selective Erase Below (default).\n    //     Ps = 1  -> Selective Erase Above.\n    //     Ps = 2  -> Selective Erase All.\n    //\n    func cmdEraseInDisplay (_ pars: [Int], _ collect: cstring)\n    {\n        let p = pars.count == 0 ? 0 : pars [0]\n        var j: Int\n        switch p {\n        case 0:\n            j = buffer.y\n            updateRange (j)\n            eraseInBufferLine (y: j, start: buffer.x, end: cols, clearWrap: buffer.x == 0)\n            j += 1\n            while j < rows {\n                resetBufferLine (y: j)\n                j += 1\n            }\n            updateRange (j - 1)\n            \n        case 1:\n            j = buffer.y\n            updateRange (j)\n            // Deleted front part of line and everything before. This line will no longer be wrapped.\n            eraseInBufferLine (y: j, start: 0, end: buffer.x + 1, clearWrap: true)\n            if buffer.x + 1 >= cols {\n                // Deleted entire previous line. This next line can no longer be wrapped.\n                buffer.lines [j + 1].isWrapped = false\n            }\n            while (j != 0) {\n                j -= 1\n                resetBufferLine (y: j)\n            }\n            updateRange (0)\n        case 2:\n            j = rows\n            updateRange (j - 1)\n            while (j != 0) {\n                j -= 1\n                resetBufferLine (y: j)\n            }\n            updateRange (0)\n        case 3:\n            // Clear scrollback (everything not in viewport)\n            let scrollBackSize = buffer.lines.count - rows\n            if scrollBackSize > 0 {\n                buffer.lines.trimStart (count: scrollBackSize)\n                buffer.linesTop = 0\n                buffer.yBase = max (buffer.yBase - scrollBackSize, 0)\n                buffer.yDisp = max (buffer.yDisp - scrollBackSize, 0)\n            }\n            break;\n        default:\n            break\n        }\n    }\n\n    //\n    // Helper method to erase cells in a terminal row.\n    // The cell gets replaced with the eraseChar of the terminal.\n    // - Parameter y: row index\n    // - Parameter start: first cell index to be erased\n    // - Parameter end:   end - 1 is last erased cell\n    //\n    func eraseInBufferLine (y: Int, start: Int, end: Int, clearWrap: Bool = false, clearRenderMode: Bool = false)\n    {\n        let line = buffer.lines [buffer.yBase + y]\n        line.images = nil\n        let cd = CharData (attribute: eraseAttr ())\n        line.replaceCells (start: start, end: end, fillData: cd)\n        if clearWrap {\n            line.isWrapped = false\n        }\n        if clearRenderMode {\n            line.renderMode = .single\n        }\n    }\n    \n    //\n    // CSI Ps L\n    // Insert Ps Line(s) (default = 1) (IL).\n    //\n    func cmdInsertLines (_ pars: [Int], _ collect: cstring)\n    {\n        let buffer = self.buffer\n        if buffer.y < buffer.scrollTop || buffer.y > buffer.scrollBottom {\n            return\n        }\n        // to prevent a Denial of Service\n        let maxLines = buffer._lines.maxLength * 2\n        var p = min (maxLines, max (pars.count == 0 ? 1 : pars [0], 1))\n        let row = buffer.y + buffer.yBase\n        \n        let scrollBottomRowsOffset = rows - 1 - buffer.scrollBottom\n        let scrollBottomAbsolute = rows - 1 + buffer.yBase - scrollBottomRowsOffset + 1\n        \n        let ea = eraseAttr ()\n        if marginMode {\n            if buffer.x >= buffer.marginLeft && buffer.x <= buffer.marginRight {\n                let columnCount = buffer.marginRight-buffer.marginLeft+1\n                let rowCount = buffer.scrollBottom-buffer.scrollTop\n                for _ in 0..<p {\n                    for i in (0..<rowCount).reversed() {\n                        let src = buffer.lines [row+i]\n                        let dst = buffer.lines [row+i+1]\n                        \n                        dst.copyFrom(src, srcCol: buffer.marginLeft, dstCol: buffer.marginLeft, len: columnCount)\n                    }\n                    \n                    let last = buffer.lines [row]\n                    last.fill (with: CharData (attribute: ea), atCol: buffer.marginLeft, len: columnCount)\n                }\n            }\n        } else {\n            for _ in 0..<p {\n                p -= 1\n                // test: echo -e '\\e[44m\\e[1L\\e[0m'\n                // blankLine(true) - xterm/linux behavior\n                buffer.lines.splice (start: scrollBottomAbsolute - 1, deleteCount: 1, items: [],\n                                     change: { line in updateRange (line) })\n                let newLine = buffer.getBlankLine (attribute: ea)\n                buffer.lines.splice (start: row, deleteCount: 0, items: [newLine], change: { line in updateRange (line) })\n            }\n        }\n        // this.maxRange();\n        updateRange (startLine: buffer.y, endLine: buffer.scrollBottom)\n    }\n    \n    //\n    // ESC ( C\n    //   Designate G0 Character Set, VT100, ISO 2022.\n    // ESC ) C\n    //   Designate G1 Character Set (ISO 2022, VT100).\n    // ESC * C\n    //   Designate G2 Character Set (ISO 2022, VT220).\n    // ESC + C\n    //   Designate G3 Character Set (ISO 2022, VT220).\n    // ESC - C\n    //   Designate G1 Character Set (VT300).\n    // ESC . C\n    //   Designate G2 Character Set (VT300).\n    // ESC / C\n    //   Designate G3 Character Set (VT300). C = A  -> ISO Latin-1 Supplemental. - Supported?\n    //\n    func selectCharset (_ p: ArraySlice<UInt8>)\n    {\n        if p.count == 2 {\n            // print (\"Settin charset to \\(p[1])\")\n        }\n        \n        if (p.count != 2) {\n            cmdSelectDefaultCharset ()\n            return\n        }\n        var ch: UInt8\n        var charset: [UInt8:String]?\n        \n        if CharSets.all.keys.contains(p [1]){\n            charset = CharSets.all [p [1]]!\n        } else {\n            charset = nil\n        }\n        \n        switch p [0] {\n        case UInt8 (ascii: \"(\"):\n            ch = 0\n        case UInt8 (ascii: \")\"):\n            ch = 1\n        case UInt8 (ascii: \"-\"):\n            ch = 1\n        case UInt8 (ascii: \"*\"):\n            ch = 2\n        case UInt8 (ascii: \".\"):\n            ch = 2\n        case UInt8 (ascii: \"+\"):\n            ch = 3\n        case UInt8 (ascii: \"/\"):\n            ch = 3\n        default:\n            return;\n        }\n        setgCharset (ch, charset: charset)\n    }\n\n    func setLineRenderMode (to: BufferLine.RenderLineMode) {\n        buffer.lines [buffer.y + buffer.yBase].renderMode = to\n        updateRange (buffer.y)\n    }\n    \n    //\n    // ESC #6\n    //\n    func cmdDoubleWidthSingleHeight ()\n    {\n        setLineRenderMode(to: .doubleWidth)\n    }\n    \n    //\n    // dhtop\n    //\n    func cmdSetDoubleHeightTop ()\n    {\n        setLineRenderMode(to: .doubledTop)\n    }\n    \n    // dhbot\n    func cmdSetDoubleHeightBottom ()\n    {\n        setLineRenderMode(to: .doubledDown)\n    }\n    \n    //\n    // swsh\n    //\n    func cmdSingleWidthSingleHeight ()\n    {\n        setLineRenderMode(to: .single)\n    }\n    \n    // ESC # 8\n    func cmdScreenAlignmentPattern ()\n    {\n        let cell = CharData(attribute: curAttr.justColor(), char: \"E\")\n\n        setCursor (col: 0, row: 0)\n        for yOffset in 0..<rows {\n            let rowN = buffer.y + buffer.yBase + yOffset\n            buffer.lines [rowN].fill(with: cell)\n            buffer.lines [rowN].isWrapped = false\n        }\n        updateFullScreen()\n        setCursor(col: 0, row: 0)\n    }\n\n    func cmdRestoreCursor (_ pars: [Int], _ collect: cstring)\n    {\n        buffer.x = buffer.savedX\n        buffer.y = buffer.savedY\n        curAttr = buffer.savedAttr\n        charset = buffer.savedCharset\n        originMode = buffer.savedOriginMode\n        marginMode = buffer.savedMarginMode\n        wraparound = buffer.savedWraparound\n        reverseWraparound = buffer.savedReverseWraparound\n    }\n\n    //\n    // Validates optional arguments for top, left, bottom, right sent by various\n    // escape sequences and returns validated top, left, bottom, right in our 0-based\n    // internal coordinates\n    //\n    func getRectangleFromRequest (_ pars: ArraySlice<Int>) -> (top: Int, left: Int, bottom: Int, right: Int)?\n    {\n        let buffer = self.buffer\n        let b = pars.startIndex\n        var top = max (1, pars.count > 0 ? pars [b] : 1)\n        var left = max (pars.count > 1 ? pars [b+1] : 1, 1)\n        var bottom = pars.count > 2 ? pars [b+2] : -1\n        var right = pars.count > 3 ? pars [b+3] : -1\n\n        if bottom < 0 {\n            bottom = rows\n        }\n        if right < 0 {\n            right = cols\n        }\n        if right > cols {\n            right = cols\n        }\n        if bottom > rows {\n            bottom = rows\n        }\n        if originMode {\n            top += buffer.scrollTop\n            bottom += buffer.scrollTop\n            left += buffer.marginLeft\n            right += buffer.marginLeft\n        }\n        if top > bottom || left > right {\n            return nil\n        }\n        //top = min (top, bottom)\n        //left = min (left, right)\n        let rowBound = rows-1\n        let colBound = cols-1\n        return (min (rowBound, top-1), min (colBound, left-1), min (rowBound, bottom-1), min (colBound, right-1))\n    }\n    \n    //\n    // Copy Rectangular Area (DECCRA), VT400 and up.\n    // CSI Pts ; Pls ; Pbs ; Prs ; Pps ; Ptd ; Pld ; Ppd $ v\n    //  Pts ; Pls ; Pbs ; Prs denotes the source rectangle.\n    //  Pps denotes the source page.\n    //  Ptd ; Pld denotes the target location.\n    //  Ppd denotes the target page.\n    func csiCopyRectangularArea (_ ipars: [Int], _ collect: cstring)\n    {\n        if collect.count > 0 && collect == [36] {\n            var pars: [Int] = []\n            pars.append (ipars.count > 1 && ipars [0] != 0 ? ipars [0] : 1) // Pts default 1\n            pars.append (ipars.count > 2 && ipars [1] != 0 ? ipars [1]: 1) // Pls default 1\n            pars.append (ipars.count > 3 && ipars [2] != 0 ? ipars [2]: rows-1) // Pbs default to last line of page\n            pars.append (ipars.count > 4 && ipars [3] != 0 ? ipars [3]: cols-1) // Prs defaults to last column\n            pars.append (ipars.count > 5 && ipars [4] != 0 ? ipars [4]: 1) // Pps page source = 1\n            pars.append (ipars.count > 6 && ipars [5] != 0 ? ipars [5]: 1) // Ptd default is 1\n            pars.append (ipars.count > 7 && ipars [6] != 0 ? ipars [6]: 1) // Pld default is 1\n            pars.append (ipars.count > 8 && ipars [7] != 0 ? ipars [7]: 1) // Ppd default is 1\n            \n            // We only support copying on the same page, and the page being 1\n            if pars [4] == pars [7] && pars [4] == 1 {\n                if let (top, left, bottom, right) = getRectangleFromRequest(pars [0...3]) {\n                    let rowTarget = min (rows-1, pars [5]-1)\n                    let colTarget = min (cols-1, pars [6]-1)\n                    \n                    // Block size\n                    let columns = right-left+1\n                    \n                    let cright = min (cols-1, left + min (columns, cols-colTarget))\n                    \n                    var lines: [[CharData]] = []\n                    for row in top...bottom {\n                        let line = buffer.lines [row+buffer.yBase]\n                        var lineCopy: [CharData] = []\n                        for col in left...cright {\n                            lineCopy.append(line [col])\n                        }\n                        lines.append(lineCopy)\n                    }\n                    \n                    for row in 0...(bottom-top) {\n                        if row+rowTarget >= buffer.rows {\n                            break\n                        }\n                        let line = buffer.lines [row+rowTarget+buffer.yBase]\n                        let lr = lines [row]\n                        for col in 0..<(cright-left) {\n                            if col >= buffer.cols {\n                                break\n                            }\n                            line [colTarget+col] = lr [col]\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // CSI Ps x  Request Terminal Parameters (DECREQTPARM).\n    // CSI Ps * x Select Attribute Change Extent (DECSACE), VT420 and up.\n    // CSI Pc ; Pt ; Pl ; Pb ; Pr $ x Fill Rectangular Area (DECFRA), VT420 and up.\n    func csiX (_ pars: [Int], _ collect: cstring)\n    {\n        if collect.count > 0 && collect == [UInt8 (ascii: \"$\")] {\n            // DECFRA\n            if let (top, left, bottom, right) = getRectangleFromRequest(pars [1...]) {\n                for row in top...bottom {\n                    let line = buffer.lines [row+buffer.yBase]\n                    for col in left...right {\n                        line [col] = CharData(attribute: curAttr, char: Character (UnicodeScalar (pars [0]) ?? \" \"))\n                    }\n                }\n            }\n        } else {\n            log (\"Not implemented CSI x with collect: collect=\\(collect) and pars=\\(pars)\")\n        }\n    }\n\n    //\n    // CSI # }   Pop video attributes from stack (XTPOPSGR), xterm.  Popping\n    //           restores the video-attributes which were saved using XTPUSHSGR\n    //           to their previous state.\n    //\n    // CSI Pm ' }\n    //           Insert Ps Column(s) (default = 1) (DECIC), VT420 and up.\n    //\n    func csiCloseBrace (_ pars: [Int], _ collect: cstring)\n    {\n        if collect.count > 0 && collect == [39 /* ' */] {\n             // DECIC - Insert Column\n            let n = pars.count > 0 ? max (pars [0],1) : 1\n            let buffer = self.buffer\n            \n            if marginMode && buffer.x < buffer.marginLeft || buffer.x > buffer.marginRight {\n                return\n            }\n            \n            for row in buffer.scrollTop...buffer.scrollBottom {\n                let line = buffer.lines [row+buffer.yBase]\n                line.insertCells(pos: buffer.x, n: n, rightMargin: marginMode ? buffer.marginRight : cols-1, fillData: buffer.getNullCell())\n                line.isWrapped = false\n            }\n            return\n        } else {\n            log (\"CSI # } not implemented- XTPOPSGR with \\(pars)\")\n        }\n    }\n    \n    // Required by the test suite\n    // CSI Pi ; Pg ; Pt ; Pl ; Pb ; Pr * y\n    // Request Checksum of Rectangular Area (DECRQCRA), VT420 and up.\n    // Response is\n    // DCS Pi ! ~ x x x x ST\n    //   Pi is the request id.\n    //   Pg is the page number.\n    //   Pt ; Pl ; Pb ; Pr denotes the rectangle.\n    //   The x's are hexadecimal digits 0-9 and A-F.\n    func cmdDECRQCRA (_ pars: [Int], _ collect: cstring)\n    {\n        var checksum: UInt32 = 0\n        let rid = pars.count > 0 ? pars [0] : 1\n        let _ = pars.count > 1 ? pars [1] : 0\n        var result = \"0000\"\n        if (tdel?.isProcessTrusted(source: self) ?? false) && pars.count > 2 {\n            if let (top, left, bottom, right) = getRectangleFromRequest(pars [2...]) {\n                for row in top...bottom {\n                    let line = buffer.lines [row+buffer.yBase]\n                    for col in left...right {\n                        let cd = line [col]\n                        let ch = cd.code == 0 ? \" \" : cd.getCharacter()\n                        \n                        for scalar in ch.unicodeScalars {\n                            checksum += scalar.value\n                        }\n                    }\n                }\n            }\n            result = String(format: \"%04x\", checksum)\n        }\n        sendResponse (cc.DCS, \"\\(rid)!~\\(result)\", cc.ST)\n    }\n\n    // Dispatcher for CSI .* z commands\n    func csiZ (_ pars: [Int], _ collect: cstring)\n    {\n        switch collect {\n        case [UInt8 (ascii: \"$\")]:\n            cmdDECERA (pars)\n        case [UInt8 (ascii: \"'\")]:\n            // Enable Locator Reporting (DECELR).\n            // Valid values for the first parameter:\n            //   Ps = 0  \u21d2  Locator disabled (default).\n            //   Ps = 1  \u21d2  Locator enabled.\n            //   Ps = 2  \u21d2  Locator enabled for one report, then disabled.\n            // The second parameter specifies the coordinate unit for locator\n            // reports.\n            // Valid values for the second parameter:\n            //   Pu = 0  or omitted \u21d2  default to character cells.\n            //   Pu = 1  \u21d0  device physical pixels.\n            //   Pu = 2  \u21d0  character cells.\n            print (\"TODO: Enable Locator Reporting (DECELR)\")\n        default:\n            break\n        }\n    }\n    \n    // DECERA - Erase Rectangular Area\n    // CSI Pt ; Pl ; Pb ; Pr ; $ z\n    func cmdDECERA (_ pars: [Int])\n    {\n        if let (top, left, bottom, right) = getRectangleFromRequest(pars [0...]) {\n            for row in top...bottom {\n                let line = buffer.lines [row+buffer.yBase]\n                for col in left...right {\n                    line [col] = CharData(attribute: curAttr, char: \" \", size: 1)\n                }\n            }\n        }\n    }\n\n    // Dispatches to DECSERA or XTPUSHSGR\n    func csiOpenBrace (_ pars: [Int], _ collect: cstring)\n    {\n        if collect.count > 0 && collect == [UInt8 (ascii: \"$\")] {\n            cmdSelectiveEraseRectangularArea (pars)\n        } else {\n            log (\"CSI # { not implemented - XTPUSHSGR with \\(pars)\")\n        }\n    }\n    \n    // Push video attributes onto stack (XTPUSHSGR), xterm.\n    func cmdPushSg (_ pars: [Int])\n    {\n        \n    }\n    \n    // DECSERA - Selective Erase Rectangular Area\n    // CSI Pt ; Pl ; Pb ; Pr ; $ {\n    func cmdSelectiveEraseRectangularArea (_ pars: [Int])\n    {\n        if let (top, left, bottom, right) = getRectangleFromRequest(pars [0...]) {\n            for row in top...bottom {\n                let line = buffer.lines [row+buffer.yBase]\n                for col in left...right {\n                    var cd = line [col]\n                    cd.setValue(char: \" \", size: 1)\n                    line [col] = cd\n                }\n            }\n        }\n    }\n    /**\n     * Commands send to the `windowCommand` delegate for the front-end to implement capabilities\n     * on behalf of the client.  The expected return strings in some of these enumeration values is documented\n     * below.   Returns are only expected for the enum values that start with the prefix `report`\n     */\n    public enum WindowManipulationCommand {\n        /// Raised when the backend should deiconify a window, no return expected\n        case deiconifyWindow\n        /// Raised when the backend should iconify  a window, no return expected\n        case iconifyWindow\n        /// Raised when the client would like the window to be moved to the x,y position int he screen, not return expected\n        case moveWindowTo(x: Int, y: Int)\n        /// Raised when the client would like the window to be resized to the specified widht and heigh in pixels, not return expected\n        case resizeWindowTo(width: Int, height: Int)\n        /// Raised to bring the terminal to the front\n        case bringToFront\n        /// Send the terminal to the back if possible\n        case sendToBack\n        /// Trigger a terminal refresh\n        case refreshWindow\n        /// Request that the size of the terminal be changed to the specified cols and rows\n        case resizeTo(cols: Int, rows: Int)\n        case restoreMaximizedWindow\n        /// Attempt to maximize the window\n        case maximizeWindow\n        /// Attempt to maximize the window vertically\n        case maximizeWindowVertically\n        /// Attempt to maximize the window horizontally\n        case maximizeWindowHorizontally\n        case undoFullScreen\n        case switchToFullScreen\n        case toggleFullScreen\n        case reportTerminalState\n        case reportTerminalPosition\n        case reportTextAreaPosition\n        case reporttextAreaPixelDimension\n        case reportSizeOfScreenInPixels\n        case reportCellSizeInPixels\n        case reportTextAreaCharacters\n        case reportScreenSizeCharacters\n        case reportIconLabel\n        case reportWindowTitle\n        case resizeTo (lines: Int)\n    }\n\n    // Dispatches to\n    func csit (_ pars: [Int], _ collect: cstring)\n    {\n        switch collect {\n        case []:\n            cmdWindowOptions(pars)\n        case [UInt8 (ascii: \">\")]:\n            cmdXtermTitleModeSet(pars)\n        default:\n            log (\"Unhandled csiT \\(collect)\")\n        }\n    }\n    \n    func cmdXtermTitleModeSet (_ pars: [Int])\n    {\n        // Use the windowTextEncoding type\n        for par in pars {\n            switch par {\n            case 0:\n                // Set window/icon labels using hexadecimal.\n                xtermTitleSetHex = true\n                break\n            case 1:\n                // Query window/icon labels using hexadecimal.\n                xtermTitleQueryHex = true\n                break\n            case 2:\n                // Set window/icon labels using UTF-8.\n                xtermTitleSetUtf = true\n                break\n            case 3:\n                // Query window/icon labels using UTF-8.\n                xtermTitleQueryUtf = true\n                break\n            default:\n                break\n            }\n        }\n    }\n    \n    func cmdXtermTitleModeReset (_ pars: [Int])\n    {\n        // Use the windowTextEncoding type\n        for par in pars {\n            switch par {\n            case 0:\n                // Do not set window/icon labels using hexadecimal.\n                xtermTitleSetHex = false\n                break\n            case 1:\n                // Do not query window/icon labels using hexadecimal\n                xtermTitleQueryHex = false\n                break\n            case 2:\n                // Do not set window/icon labels using UTF-8.\n                xtermTitleSetUtf = false\n                break\n            case 3:\n                // Do not query window/icon labels using UTF-8.\n                xtermTitleQueryUtf = false\n                break\n            default:\n                break\n            }\n        }\n    }\n\n    //\n    // CSI Ps ; Ps ; Ps t - Various window manipulations and reports (xterm)\n    // See https://invisible-island.net/xterm/ctlseqs/ctlseqs.html for a full\n    // list of commans for this escape sequence\n    func cmdWindowOptions (_ pars: [Int])\n    {\n        guard let tdel = self.tdel else {\n            return\n        }\n        switch pars {\n        case [1]:\n            tdel.windowCommand(source: self, command: .deiconifyWindow)\n        case [2]:\n            tdel.windowCommand(source: self, command: .iconifyWindow)\n        case _ where pars.count == 3 && pars.first == 3:\n            tdel.windowCommand(source: self, command: .moveWindowTo(x: pars [1], y: pars[2]))\n        case _ where pars.count == 3 && pars.first == 4:\n            tdel.windowCommand(source: self, command: .moveWindowTo(x: pars [1], y: pars[2]))\n        case [5]:\n            tdel.windowCommand(source: self, command: .bringToFront)\n        case [6]:\n            tdel.windowCommand(source: self, command: .sendToBack)\n        case [7]:\n            tdel.windowCommand(source: self, command: .refreshWindow)\n        case _ where pars.count == 3 && pars.first == 8:\n            tdel.windowCommand(source: self, command: .resizeTo(cols: pars [1], rows: pars [2]))\n        case [9, 0]:\n            tdel.windowCommand(source: self, command: .restoreMaximizedWindow)\n        case [9, 1]:\n            tdel.windowCommand(source: self, command: .maximizeWindow)\n        case [9, 2]:\n            tdel.windowCommand(source: self, command: .maximizeWindowVertically)\n        case [9, 3]:\n            tdel.windowCommand(source: self, command: .maximizeWindowHorizontally)\n        case [10, 0]:\n            tdel.windowCommand(source: self, command: .undoFullScreen)\n        case [10, 1]:\n            tdel.windowCommand(source: self, command: .switchToFullScreen)\n        case [10, 2]:\n            tdel.windowCommand(source: self, command: .toggleFullScreen)\n        case [15]: // Report size in pixels\n            if let r = tdel.windowCommand(source: self, command: .reportSizeOfScreenInPixels) {\n                sendResponse(r)\n            } else {\n                sendResponse (cc.CSI, \"5;768;1024t\")\n            }\n        case [16]: // Report cell size in pixels\n            // If no value is returned send 16x10\n            // TODO: should surface that to the UI, should not do this here\n            if let r = tdel.windowCommand(source: self, command: .reportCellSizeInPixels) {\n                sendResponse(r)\n            } else {\n                sendResponse (cc.CSI, \"6;16;10t\")\n            }\n        case [18]:\n            if let r = tdel.windowCommand(source: self, command: .reportCellSizeInPixels) {\n                sendResponse(r)\n            } else {\n                sendResponse(cc.CSI, \"8;\\(rows);\\(cols)t\")\n            }\n        case [19]:\n            if let r = tdel.windowCommand(source: self, command: .reportScreenSizeCharacters) {\n                sendResponse(r)\n            } else {\n                sendResponse(cc.CSI, \"9;\\(rows);\\(cols)t\")\n            }\n        case [20]:\n            // Do not report the actual title back, as it can be exploited,\n            // https://marc.info/?l=bugtraq&m=104612710031920&w=2\n            sendResponse (cc.OSC, \"L\", cc.ST)\n        case [21]:\n            // Do not report the actual content of the title back, as it can be exploited,\n            // https://marc.info/?l=bugtraq&m=104612710031920&w=2\n            sendResponse (cc.OSC, \"l\", cc.ST)\n        case [22, 0]:\n            terminalTitleStack = terminalTitleStack + [terminalTitle]\n            terminalIconStack = terminalIconStack + [iconTitle]\n        case [22, 1]:\n            terminalIconStack = terminalIconStack + [iconTitle]\n        case [22, 2]:\n            terminalTitleStack = terminalTitleStack + [terminalTitle]\n        case [23, 0]:\n            if let nt = terminalTitleStack.last {\n                terminalTitleStack = terminalTitleStack.dropLast()\n                setTitle(text: nt)\n            }\n            if let nt = terminalIconStack.last {\n                terminalIconStack = terminalIconStack.dropLast()\n                setIconTitle(text: nt)\n            }\n        case [23, 1]:\n            if let nt = terminalTitleStack.last {\n                terminalTitleStack = terminalTitleStack.dropLast()\n                setTitle(text: nt)\n            }\n        case [23, 2]:\n            if let nt = terminalIconStack.last {\n                terminalIconStack = terminalIconStack.dropLast()\n                setIconTitle(text: nt)\n            }\n\n        default:\n            log (\"Unhandled Window command: \\(pars)\")\n            break\n        }\n    }\n\n    func cmdSetMargins (_ pars: [Int], _ collect: cstring)\n    {\n        var left = min (cols-1, max (0, (pars.count > 0 ? pars[0] : 1) - 1))\n        let right = min (cols-1, max (0, (pars.count > 1 ? pars [1] : cols) - 1))\n        \n        left = min (left, right)\n        buffer.marginLeft = left\n        buffer.marginRight = right\n    }\n    \n    //\n    //  CSI s (sometimes, if the margin mode is false)\n    //  ESC 7\n    //   Save cursor (ANSI.SYS).\n    //\n    func cmdSaveCursor (_ pars: [Int], _ collect: cstring)\n    {\n        buffer.savedX = buffer.x\n        buffer.savedY = buffer.y\n        buffer.savedAttr = curAttr\n        buffer.savedCharset = charset\n        buffer.savedWraparound = wraparound\n        buffer.savedOriginMode = originMode\n        buffer.savedMarginMode = marginMode\n        buffer.savedReverseWraparound = reverseWraparound\n    }\n\n    //\n    // CSI Ps ; Ps r\n    //   Set Scrolling Region [top;bottom] (default = full size of window) (DECSTBM).\n    // CSI ? Pm r\n    //\n    func cmdSetScrollRegion (_ pars: [Int], _ collect: cstring)\n    {\n        if collect != [] {\n            return\n        }\n        let buffer = self.buffer\n        let top = pars.count > 0 ? max (pars [0] - 1, 0) : 0\n        var bottom = rows\n        if pars.count > 1 {\n            // bottom = 0 means \"bottom of the screen\"\n            let p = pars [1]\n            if p != 0 {\n                bottom = min (pars [1], rows)\n            }\n        }\n        // normalize\n        bottom -= 1\n        \n        // only set the scroll region if top < bottom\n        if top < bottom {\n            buffer.scrollBottom = bottom\n            buffer.scrollTop = top\n        }\n        setCursor(col: 0, row: 0)\n    }\n\n    public func setCursorStyle (_ style: CursorStyle)\n    {\n        if options.cursorStyle != style {\n            tdel?.cursorStyleChanged(source: self, newStyle: style)\n            options.cursorStyle = style\n        }\n    }\n    \n    //\n    // CSI Ps SP q  Set cursor style (DECSCUSR, VT520).\n    //   Ps = 0  -> blinking block.\n    //   Ps = 1  -> blinking block (default).\n    //   Ps = 2  -> steady block.\n    //   Ps = 3  -> blinking underline.\n    //   Ps = 4  -> steady underline.\n    //   Ps = 5  -> blinking bar (xterm).\n    //   Ps = 6  -> steady bar (xterm).\n    //\n    func cmdSetCursorStyle (_ pars: [Int], _ collect: cstring)\n    {\n        if collect.count == 0 || collect != [32] { /* space */\n            return\n        }\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n        switch (p) {\n        case 1, 0:\n            setCursorStyle (.blinkBlock)\n        case 2:\n            setCursorStyle (.steadyBlock)\n        case 3:\n            setCursorStyle (.blinkUnderline)\n        case 4:\n            setCursorStyle (.steadyUnderline)\n        case 5:\n            setCursorStyle (.blinkBar)\n        case 6:\n            setCursorStyle (.steadyBar)\n        default:\n            break;\n        }\n    }\n\n    func cmdDecRqm (_ pars: [Int], decMode: Bool) {\n        let modeUnknown = 0\n        let modeSet = 1\n        let modeReset = 2\n        //let modeAlwaysSet = 3\n        let modeAlwaysReset = 4\n        \n        // Same as reset for now, but it is something that should change if the companion setting is ever implemented\n        let modeCouldBeImplementedButReset = 2\n        let modeCouldBeImplementedButSet = 1\n        \n        guard let mode = pars.first else {\n            sendResponse (cc.CSI, \";0$y\")\n            return\n        }\n        var res = modeUnknown\n        if decMode {\n            switch mode {\n            case 1: // DECCKM\n                res = applicationCursor ? modeSet : modeReset\n            case 2: // DECCKM - reserved for VT52 emulation\n                res = modeSet\n            case 3: // DECCOLM - 132 Column Mode\n                res = buffer.cols == 132 ? modeSet : modeReset\n            case 4: // DECSCLM - Smooth/jump scroll, we dont implement\n                res = smoothScroll ? modeSet : modeReset\n            case 5: // DECSCNM - Reverse Display Colors\n                res = curAttr == CharData.invertedAttr ? modeSet : modeReset\n            case 6: // DECOM - cursor origin\n                res = originMode ? modeSet : modeReset\n            case 7: // DECAWM - Wraparound Mode\n                res = wraparound ? modeSet : modeReset\n            case 8: // DECARM - Autorepeat mode\n                res = modeCouldBeImplementedButSet\n            case 9:\n                res = mouseMode == .x10 ? modeSet : modeReset\n            case 10:\n                res = modeAlwaysReset\n            case 12: // ATT610_BLINK\n                res = cursorBlink ? modeSet : modeReset\n            case 13: // user cursor blink setting\n                res = modeCouldBeImplementedButReset\n            case 14: // cursor blink xor\n                res = modeCouldBeImplementedButReset\n            case 18: // DECPFF - Print screen with form feed\n                res = modeCouldBeImplementedButSet\n            case 19: // DECPEX - print region limitation\n                res = modeCouldBeImplementedButSet\n            case 25: // DECTCEM cursor visbiolity\n                res = cursorHidden ? modeReset : modeSet\n            case 30: // RXVT show scrollbar\n                res = modeCouldBeImplementedButReset\n            case 40: // Enable 80 to 132 transition\n                res = allow80To132 ? modeSet : modeReset\n            case 41: // xterm tab workaround in \"more(1)\" command\n                res = modeReset\n            case 42: // DECNRCM - national character set\n                res = modeAlwaysReset\n            case 44: // MARGIN_BELL\n                res = modeAlwaysReset\n            case 45: // REVERSEWRAP\n                res = reverseWraparound ? modeSet : modeReset\n            case 46: // allow logging\n                res = modeAlwaysReset\n            case 47: // ALTBUF - alternate screen buffer\n                res = buffers.isAlternateBuffer ? modeSet : modeReset\n            case 66: // DECNKCM\n                res = applicationKeypad ? modeSet : modeReset\n            case 67: // backspace sends delete\n                res = modeAlwaysReset\n            case 69: // DECLRMM - mmargins\n                res = marginMode ? modeSet : modeReset\n            case 80: // DECSDM - Sixel scrolling\n                res = modeAlwaysReset\n            case 95: // DECNCSM - clear on DECCOLM changes\n                res = modeCouldBeImplementedButSet\n            case 1000:\n                res = mouseMode == .vt200 ? modeSet : modeReset\n            case 1001:\n                res = modeCouldBeImplementedButReset\n            case 1002:\n                res = mouseMode == .buttonEventTracking ? modeSet : modeReset\n            case 1003:\n                res = mouseMode == .anyEvent ? modeSet : modeReset\n            case 1004:\n                res = sendFocus ? modeSet : modeReset\n            case 1005:\n                res = mouseProtocol == .utf8 ? modeSet : modeReset\n            case 1006:\n                res = mouseProtocol == .sgr ? modeSet : modeReset\n            case 1015:\n                res = mouseProtocol == .urxvt ? modeSet : modeReset\n            case 1034:\n                // This is the esc+key toggles top bit, in this UTF world, I dont think it is worth support it ever.\n                res = modeAlwaysReset\n                // 1035, 1036, 1037, 1039, 1040, 1042, 1043, 1046\n                // 1047 - what does this even do?\n                // 1048, 1049,\n                // keyboard emulation mode: 1050, 1051, 1052, 1053, 1060, 1061\n            case 2004:\n                res = bracketedPasteMode ? modeSet : modeReset\n            default:\n                break\n            }\n        } else {\n            switch mode {\n            case 1: // GATM - guarded area transfer\n                res = modeAlwaysReset\n            case 2: // Disable keyboard input KAM\n                // If implemented elsewhere, this can be added here, but I have reservations about this\n                res = modeCouldBeImplementedButReset\n            case 3: // CRM - Display control characters\n                res = modeCouldBeImplementedButReset\n            case 4: // IRM Insert mode\n                res = insertMode ? modeSet : modeReset\n            case 5: // SRTM Status reporting transfer\n                res = modeAlwaysReset\n            case 7: // VEM vertical editing\n                res = modeAlwaysReset\n            case 10: // HEM horizontal editing\n                res = modeAlwaysReset\n            case 11: // PUM positioning unit\n                res = modeAlwaysReset\n            case 12: // SRM send-receive mode, update when we implement\n                res = modeCouldBeImplementedButSet\n            case 13: // FEAM Format effector action\n                res = modeAlwaysReset\n            case 14: // FETM Format effector transfer\n                res = modeAlwaysReset\n            case 15: // MATM Multiple area transfer\n                res = modeAlwaysReset\n            case 16: // TTM transfer termination\n                res = modeAlwaysReset\n            case 17: // SATM selected area transfer\n                res = modeAlwaysReset\n            case 18: // TSM tabulation stop\n                res = modeAlwaysReset\n            case 19: // EBM Editing Boundary\n                res = modeAlwaysReset\n            case 20: // LNM Line feed/newline\n                res = lineFeedMode ? modeSet : modeReset\n            default:\n                break\n            }\n        }\n        sendResponse (cc.CSI, \"\\(mode);\\(res)$y\")\n    }\n    \n    //\n    // Proxy for various CSI .* p commands\n    func csiPHandler (_ pars: [Int], _ collect: cstring)\n    {\n        switch collect {\n        case [UInt8 (ascii: \"!\")]:\n            cmdSoftReset ()\n        case [UInt8 (ascii: \"\\\"\")]:\n            cmdSetConformanceLevel (pars, collect)\n            \n            // DECRQM - CSI ? Pa $ p\n            // Request DEC mode\n        case [63, 36]:\n            cmdDecRqm (pars, decMode: true);\n        \n            // DECRQM - CSI Pa $ p\n            // Request ANSI mode\n        case [36]:\n            cmdDecRqm (pars, decMode: false);\n        default:\n            log (\"Unhandled CSI \\(String (cString: collect)) with pars=\\(pars)\")\n        }\n    }\n    \n    // CSI Pl ; Pc \" p\n    // Set conformance level (DECSCL), VT220 and up\n    func cmdSetConformanceLevel (_ pars: [Int], _ collect: cstring)\n    {\n        if pars.count > 0 {\n            let level = pars [0]\n            switch level {\n            case 61:\n                conformance = .vt100\n                cc.send8bit = false\n            case 62:\n                conformance = .vt200\n            case 63:\n                conformance = .vt300\n            case 64:\n                conformance = .vt400\n            case 65:\n                conformance = .vt500\n            default:\n                conformance = .vt500\n            }\n        }\n        if pars.count > 1 && conformance != .vt100 {\n            switch pars [1] {\n            case 0:\n                cc.send8bit = true\n            case 2:\n                cc.send8bit = true\n            default:\n                cc.send8bit = false\n            }\n        }\n    }\n    \n    //\n    // http://vt100.net/docs/vt220-rm/table4-10.html\n    //\n    /* ! - CSI ! p   Soft terminal reset (DECSTR). */\n    func cmdSoftReset ()\n    {\n        cursorHidden = false\n        insertMode = false\n        originMode = false\n\n        reverseWraparound = false\n        \n        wraparound = true  // defaults: xterm - true, vt100 - false\n        applicationKeypad = false\n        syncScrollArea ()\n        applicationCursor = false\n        buffer.scrollTop = 0\n        buffer.scrollBottom = rows - 1\n        curAttr = CharData.defaultAttr\n        buffer.softReset ()\n\n        charset = nil\n        setgLevel (0)\n        conformance = .vt500\n        hyperLinkTracking = nil\n        lineFeedMode = options.convertEol\n        resetAllColors()\n        tdel?.showCursor(source: self)\n        // MIGUEL TODO:\n        // TODO: audit any new variables, those in setup might be useful\n    }\n\n    /// Performs a terminal soft-reset, the equivalent of the DECSTR sequence\n    /// For a full reset see `resetToInitialState`\n    public func softReset ()\n    {\n        cmdSoftReset()\n    }\n    \n    //\n    // CSI Ps n  Device Status Report (DSR).\n    //     Ps = 5  -> Status Report.  Result (``OK'') is\n    //   CSI 0 n\n    //     Ps = 6  -> Report Cursor Position (CPR) [row;column].\n    //   Result is\n    //   CSI r ; c R\n    // CSI ? Ps n\n    //   Device Status Report (DSR, DEC-specific).\n    //     Ps = 6  -> Report Cursor Position (CPR) [row;column] as CSI\n    //     ? r ; c R (assumes page is zero).\n    //     Ps = 1 5  -> Report Printer status as CSI ? 1 0  n  (ready).\n    //     or CSI ? 1 1  n  (not ready).\n    //     Ps = 2 5  -> Report UDK status as CSI ? 2 0  n  (unlocked)\n    //     or CSI ? 2 1  n  (locked).\n    //     Ps = 2 6  -> Report Keyboard status as\n    //   CSI ? 2 7  ;  1  ;  0  ;  0  n  (North American).\n    //   The last two parameters apply to VT400 & up, and denote key-\n    //   board ready and LK01 respectively.\n    //     Ps = 5 3  -> Report Locator status as\n    //   CSI ? 5 3  n  Locator available, if compiled-in, or\n    //   CSI ? 5 0  n  No Locator, if not.\n    //\n    func cmdDeviceStatus (_ pars: [Int], _ collect: cstring)\n    {\n        let buffer = self.buffer\n        if collect.count == 0 {\n            switch (pars [0]) {\n            case 5:\n                // status report\n                sendResponse (cc.CSI, \"0n\")\n            case 6:\n                // cursor position\n                let y = max (1, buffer.y + 1 - (originMode ? buffer.scrollTop : 0))\n                \n                // Need the max, because the cursor could be before the leftMargin\n                let x = max (1, buffer.x + 1 - (originMode ? buffer.marginLeft : 0))\n                sendResponse (cc.CSI, \"\\(y);\\(x)R\")\n            default:\n                break;\n            }\n        } else if (collect == [UInt8 (ascii: \"?\")]) {\n            // modern xterm doesnt seem to\n            // respond to any of these except ?6, 6, and 5\n            switch pars [0] {\n            case 6:\n                // cursor position\n                let y = buffer.y + 1 - (originMode ? buffer.scrollTop : 0)\n                // Need the max, because the cursor could be before the leftMargin\n                let x = max (1, buffer.x + 1  - (usingMargins () ? buffer.marginLeft : 0))\n                sendResponse (cc.CSI, \"?\\(y);\\(x);1R\")\n            case 15:\n                // Request printer status report, we respond \"We are ready\"\n                sendResponse(cc.CSI, \"?10n\")\n                break;\n            case 25:\n                // We respond \"User defined keys are locked\"\n                sendResponse(cc.CSI, \"?21n\")\n                break;\n            case 26:\n                // Requests keyboard type\n                // We respond \"American keyboard\", TODO: worth plugging something else?  Mac perhaps?\n                sendResponse(cc.CSI, \"?27;1;0;0n\")\n    \n                break;\n            case 53:\n                // TODO: no dec locator/mouse\n                // this.handler(C0.ESC + '[?50n');\n                break;\n            case 55:\n                // Request locator status\n                sendResponse(cc.CSI, \"?53n\")\n            case 56:\n                // What kind of locator we have, we reply mouse, but perhaps on iOS we should respond something else\n                sendResponse(cc.CSI, \"?57;1n\")\n            case 62:\n                // Macro space report\n                sendResponse(cc.CSI, \"0*{\")\n            case 63:\n                // Requests checksum of macros, we return 0\n                let id = pars.count > 1 ? pars [1] : 0\n                sendResponse(cc.DCS, \"\\(id)!~0000\", cc.ST)\n            case 75:\n                // Data integrity report, no issues:\n                sendResponse (cc.CSI, \"?70n\")\n            case 85:\n                // Multiple session status, we reply single session\n                sendResponse (cc.CSI, \"?83n\")\n            default:\n                break\n            }\n        }\n    }\n\n    //\n    // CSI Pm m  Character Attributes (SGR).\n    //     Ps = 0  -> Normal (default).\n    //     Ps = 1  -> Bold.\n    //     Ps = 2  -> Faint, decreased intensity (ISO 6429).\n    //     Ps = 4  -> Underlined.\n    //     Ps = 5  -> Blink (appears as Bold).\n    //     Ps = 7  -> Inverse.\n    //     Ps = 8  -> Invisible, i.e., hidden (VT300).\n    //     Ps = 9  -> Crossed out character\n    //     Ps = 2 2  -> Normal (neither bold nor faint).\n    //     Ps = 2 4  -> Not underlined.\n    //     Ps = 2 5  -> Steady (not blinking).\n    //     Ps = 2 7  -> Positive (not inverse).\n    //     Ps = 2 8  -> Visible, i.e., not hidden (VT300).\n    //     Ps = 2 9  -> Not crossed out\n    //     Ps = 3 0  -> Set foreground color to Black.\n    //     Ps = 3 1  -> Set foreground color to Red.\n    //     Ps = 3 2  -> Set foreground color to Green.\n    //     Ps = 3 3  -> Set foreground color to Yellow.\n    //     Ps = 3 4  -> Set foreground color to Blue.\n    //     Ps = 3 5  -> Set foreground color to Magenta.\n    //     Ps = 3 6  -> Set foreground color to Cyan.\n    //     Ps = 3 7  -> Set foreground color to White.\n    //     Ps = 3 9  -> Set foreground color to default (original).\n    //     Ps = 4 0  -> Set background color to Black.\n    //     Ps = 4 1  -> Set background color to Red.\n    //     Ps = 4 2  -> Set background color to Green.\n    //     Ps = 4 3  -> Set background color to Yellow.\n    //     Ps = 4 4  -> Set background color to Blue.\n    //     Ps = 4 5  -> Set background color to Magenta.\n    //     Ps = 4 6  -> Set background color to Cyan.\n    //     Ps = 4 7  -> Set background color to White.\n    //     Ps = 4 9  -> Set background color to default (original).\n    //\n    //   If 16-color support is compiled, the following apply.  Assume\n    //   that xterm's resources are set so that the ISO color codes are\n    //   the first 8 of a set of 16.  Then the aixterm colors are the\n    //   bright versions of the ISO colors:\n    //     Ps = 9 0  -> Set foreground color to Black.\n    //     Ps = 9 1  -> Set foreground color to Red.\n    //     Ps = 9 2  -> Set foreground color to Green.\n    //     Ps = 9 3  -> Set foreground color to Yellow.\n    //     Ps = 9 4  -> Set foreground color to Blue.\n    //     Ps = 9 5  -> Set foreground color to Magenta.\n    //     Ps = 9 6  -> Set foreground color to Cyan.\n    //     Ps = 9 7  -> Set foreground color to White.\n    //     Ps = 1 0 0  -> Set background color to Black.\n    //     Ps = 1 0 1  -> Set background color to Red.\n    //     Ps = 1 0 2  -> Set background color to Green.\n    //     Ps = 1 0 3  -> Set background color to Yellow.\n    //     Ps = 1 0 4  -> Set background color to Blue.\n    //     Ps = 1 0 5  -> Set background color to Magenta.\n    //     Ps = 1 0 6  -> Set background color to Cyan.\n    //     Ps = 1 0 7  -> Set background color to White.\n    //\n    //   If xterm is compiled with the 16-color support disabled, it\n    //   supports the following, from rxvt:\n    //     Ps = 1 0 0  -> Set foreground and background color to\n    //     default.\n    //\n    //   If 88- or 256-color support is compiled, the following apply.\n    //     Ps = 3 8  ; 5  ; Ps -> Set foreground color to the second\n    //     Ps.\n    //     Ps = 4 8  ; 5  ; Ps -> Set background color to the second\n    //     Ps.\n    //\n    func cmdCharAttributes (_ pars: [Int], _ collect: cstring)\n    {\n        // Optimize a single SGR0.\n        if pars.count == 1 && pars [0] == 0 {\n            curAttr = CharData.defaultAttr\n            return;\n        }\n\n        let parCount = pars.count\n        //let empty = CharacterStyle (attribute: 0)\n        var style = curAttr.style\n        var fg = curAttr.fg\n        var bg = curAttr.bg\n        let def = CharData.defaultAttr\n\n        var i = 0\n        \n        // Extended Colors\n        //\n        // There is an ambiguity here that is troublesome, to support extended\n        // colors and colorspaces, two competing systems exists, one uses for example:\n        // 38;2;R;G;B;NEXT - foreground true color\n        // 38:2:ColorSpace:R:G:B:REST;NEXT - second style for the same\n        //\n        // The former apparently was a mistake, but we need to disambiguate the meaning\n        // of pars, based on whether the above uses \":\" or \";\" we need that, because\n        // the SGR is a collection of attributes, so after our parameter values, we\n        // need to continue processing\n        //\n        //\n        func parseExtendedColor () -> Attribute.Color? {\n            var color: Attribute.Color? = nil\n            let v = parser._parsTxt\n            \n            // If this is the new style\n            if v.count > 2 && v [2] == UInt8(ascii: \":\") {\n                switch pars [i] {\n                case 2: // RGB color\n                    i += 1\n                    // Color style, we ignore \"ColorSpace\"\n\n                    if i+3 < parCount {\n                        color = Attribute.Color.trueColor(\n                              red: UInt8(min (pars [i+1], 255)),\n                            green: UInt8(min (pars [i+2], 255)),\n                             blue: UInt8(min (pars [i+3], 255)))\n                        i += 4\n                    }\n                default:\n                    break\n                }\n            } else {\n                switch pars [i] {\n                case 2: // RGB color\n                    i += 1\n                    if i+2 < parCount {\n                        color = Attribute.Color.trueColor(\n                              red: UInt8(min (pars [i], 255)),\n                            green: UInt8(min (pars [i+1], 255)),\n                             blue: UInt8(min (pars [i+2], 255)))\n                        i += 3\n                    }\n                    \n                case 3: // CMY color - not supported\n                    break\n                    \n                case 4: // CMYK color - not supported\n                    break\n                    \n                case 5: // indexed color\n                    if i+1 < parCount {\n                        color = Attribute.Color.ansi256(code: UInt8 (min (255, pars [i+1])))\n                        i += 1\n                    }\n                    i += 1\n\n                default:\n                    break\n                }\n            }\n            return color\n        }\n        \n        while i < parCount {\n            var p = pars [i]\n            switch p {\n            case 0:\n                // default\n                style = def.style\n                fg = def.fg\n                bg = def.bg\n            case 1:\n                // bold text\n                style = [style, .bold]\n            case 2:\n                // dimmed text\n                style = [style, .dim]\n            case 3:\n                // italic text\n                style = [style, .italic]\n            case 4:\n                // underlined text\n                style = [style, .underline]\n            case 5:\n                // blink\n                style = [style, .blink]\n            case 7:\n                // inverse and positive\n                // test with: echo -e '\\e[31m\\e[42mhello\\e[7mworld\\e[27mhi\\e[m'\n                style = [style, .inverse]\n            case 8:\n                // invisible\n                style = [style, .invisible]\n            case 9:\n                style = [style, .crossedOut]\n            case 21:\n                // double underline\n                break\n            case 22:\n                // not bold nor faint\n                style.remove (.bold)\n                style.remove (.dim)\n            case 23:\n                // not italic\n                style.remove (.italic)\n            case 24:\n                // not underlined\n                style.remove (.underline)\n            case 25:\n                // not blink\n                style.remove (.blink)\n            case 27:\n                // not inverse\n                style.remove (.inverse)\n            case 28:\n                // not invisible\n                style.remove (.invisible)\n            case 29:\n                // not crossed out\n                style.remove (.crossedOut)\n            case 30...37:\n                // fg color 8\n                fg = Attribute.Color.ansi256(code: UInt8(p - 30))\n            case 38:\n                i += 1\n                if let parsed = parseExtendedColor () {\n                    fg = parsed\n                }\n                continue\n            case 39:\n                // reset fg\n                fg = CharData.defaultAttr.fg\n            case 40...47:\n                // bg color 8\n                bg = Attribute.Color.ansi256(code: UInt8(p - 40))\n            case 48:\n                i += 1\n                if let parsed = parseExtendedColor() {\n                    bg = parsed\n                }\n                continue\n                \n            case 49:\n                // reset bg\n                bg = CharData.defaultAttr.bg\n            case 90...97:\n                // fg color 16\n                p += 8\n                fg = Attribute.Color.ansi256(code: UInt8(p - 90))\n            case 100...107:\n                // bg color 16\n                p += 8;\n                bg = Attribute.Color.ansi256(code: UInt8(p - 100))\n            default:\n                log (\"Unknown SGR attribute: \\(p) \\(pars)\")\n            }\n            i += 1\n        }\n        curAttr = Attribute(fg: fg, bg: bg, style: style)\n    }\n\n    //\n    //CSI Pm l  Reset Mode (RM).\n    //    Ps = 2  -> Keyboard Action Mode (AM).\n    //    Ps = 4  -> Replace Mode (IRM).\n    //    Ps = 1 2  -> Send/receive (SRM).\n    //    Ps = 2 0  -> Normal Linefeed (LNM).\n    //CSI ? Pm l\n    //  DEC Private Mode Reset (DECRST).\n    //    Ps = 1  -> Normal Cursor Keys (DECCKM).\n    //    Ps = 2  -> Designate VT52 mode (DECANM).\n    //    Ps = 3  -> 80 Column Mode (DECCOLM).\n    //    Ps = 4  -> Jump (Fast) Scroll (DECSCLM).\n    //    Ps = 5  -> Normal Video (DECSCNM).\n    //    Ps = 6  -> Normal Cursor Mode (DECOM).\n    //    Ps = 7  -> No Wraparound Mode (DECAWM).\n    //    Ps = 8  -> No Auto-repeat Keys (DECARM).\n    //    Ps = 9  -> Don't send Mouse X & Y on button press.\n    //    Ps = 1 0  -> Hide toolbar (rxvt).\n    //    Ps = 1 2  -> Stop Blinking Cursor (att610).\n    //    Ps = 1 8  -> Don't print form feed (DECPFF).\n    //    Ps = 1 9  -> Limit print to scrolling region (DECPEX).\n    //    Ps = 2 5  -> Hide Cursor (DECTCEM).\n    //    Ps = 3 0  -> Don't show scrollbar (rxvt).\n    //    Ps = 3 5  -> Disable font-shifting functions (rxvt).\n    //    Ps = 4 0  -> Disallow 80 -> 132 Mode.\n    //    Ps = 4 1  -> No more(1) fix (see curses resource).\n    //    Ps = 4 2  -> Disable Nation Replacement Character sets (DEC-\n    //    NRCM).\n    //    Ps = 4 4  -> Turn Off Margin Bell.\n    //    Ps = 4 5  -> No Reverse-wraparound Mode.\n    //    Ps = 4 6  -> Stop Logging.  (This is normally disabled by a\n    //    compile-time option).\n    //    Ps = 4 7  -> Use Normal Screen Buffer.\n    //    Ps = 6 6  -> Numeric keypad (DECNKM).\n    //    Ps = 6 7  -> Backarrow key sends delete (DECBKM).\n    //    Ps = 1 0 0 0  -> Don't send Mouse X & Y on button press and\n    //    release.  See the section Mouse Tracking.\n    //    Ps = 1 0 0 1  -> Don't use Hilite Mouse Tracking.\n    //    Ps = 1 0 0 2  -> Don't use Cell Motion Mouse Tracking.\n    //    Ps = 1 0 0 3  -> Don't use All Motion Mouse Tracking.\n    //    Ps = 1 0 0 4  -> Don't send FocusIn/FocusOut events.\n    //    Ps = 1 0 0 5  -> Disable Extended Mouse Mode.\n    //    Ps = 1 0 1 0  -> Don't scroll to bottom on tty output\n    //    (rxvt).\n    //    Ps = 1 0 1 1  -> Don't scroll to bottom on key press (rxvt).\n    //    Ps = 1 0 3 4  -> Don't interpret \"meta\" key.  (This disables\n    //    the eightBitInput resource).\n    //    Ps = 1 0 3 5  -> Disable special modifiers for Alt and Num-\n    //    Lock keys.  (This disables the numLock resource).\n    //    Ps = 1 0 3 6  -> Don't send ESC  when Meta modifies a key.\n    //    (This disables the metaSendsEscape resource).\n    //    Ps = 1 0 3 7  -> Send VT220 Remove from the editing-keypad\n    //    Delete key.\n    //    Ps = 1 0 3 9  -> Don't send ESC  when Alt modifies a key.\n    //    (This disables the altSendsEscape resource).\n    //    Ps = 1 0 4 0  -> Do not keep selection when not highlighted.\n    //    (This disables the keepSelection resource).\n    //    Ps = 1 0 4 1  -> Use the PRIMARY selection.  (This disables\n    //    the selectToClipboard resource).\n    //    Ps = 1 0 4 2  -> Disable Urgency window manager hint when\n    //    Control-G is received.  (This disables the bellIsUrgent\n    //    resource).\n    //    Ps = 1 0 4 3  -> Disable raising of the window when Control-\n    //    G is received.  (This disables the popOnBell resource).\n    //    Ps = 1 0 4 7  -> Use Normal Screen Buffer, clearing screen\n    //    first if in the Alternate Screen.  (This may be disabled by\n    //    the titeInhibit resource).\n    //    Ps = 1 0 4 8  -> Restore cursor as in DECRC.  (This may be\n    //    disabled by the titeInhibit resource).\n    //    Ps = 1 0 4 9  -> Use Normal Screen Buffer and restore cursor\n    //    as in DECRC.  (This may be disabled by the titeInhibit\n    //    resource).  This combines the effects of the 1 0 4 7  and 1 0\n    //    4 8  modes.  Use this with terminfo-based applications rather\n    //    than the 4 7  mode.\n    //    Ps = 1 0 5 0  -> Reset terminfo/termcap function-key mode.\n    //    Ps = 1 0 5 1  -> Reset Sun function-key mode.\n    //    Ps = 1 0 5 2  -> Reset HP function-key mode.\n    //    Ps = 1 0 5 3  -> Reset SCO function-key mode.\n    //    Ps = 1 0 6 0  -> Reset legacy keyboard emulation (X11R6).\n    //    Ps = 1 0 6 1  -> Reset keyboard emulation to Sun/PC style.\n    //    Ps = 2 0 0 4  -> Reset bracketed paste mode.\n    //\n    func cmdResetMode (_ pars: [Int], _ collect: cstring)\n    {\n        if pars.count == 0 {\n            return\n        }\n\n        if pars.count > 1 {\n            for i in 0..<pars.count {\n                resetMode (pars [i], collect)\n            }\n            return\n        }\n        resetMode (pars [0], collect)\n    }\n\n    func resetMode (_ par: Int, _ collect: cstring)\n    {\n        if collect == [] {\n            switch (par) {\n            case 2:\n                // KAM mode - unlocks the keyboard, not supported\n                break\n            case 4:\n                // IRM Insert/Replace Mode\n                insertMode = false\n            case 20:\n                // LNM\u2014Line Feed/New Line Mode\n                lineFeedMode = false\n                break\n            default:\n                break\n            }\n        } else if collect == [UInt8 (ascii: \"?\")] {\n            switch (par) {\n            case 1:\n                applicationCursor = false\n            case 3:\n                if allow80To132 {\n                    // DECCOLM\n                    resize (cols: 80, rows: rows)\n                    tdel?.sizeChanged(source: self)\n                    resetToInitialState()\n                }\n            case 4: // DECSCLM - Jump scroll mode\n                smoothScroll = false\n                break\n            case 5:\n                // Reset default color\n                curAttr = CharData.defaultAttr\n            case 6:\n                // DECOM Reset\n                originMode = false\n            case 7:\n                wraparound = false\n            case 12:\n                cursorBlink = false\n            case 40:\n                allow80To132 = false\n            case 41:\n                // Workaround not implemented \n                break\n            case 45:\n                reverseWraparound = false\n            case 66:\n                log (\"Switching back to normal keypad.\");\n                applicationKeypad = false\n                syncScrollArea ()\n            case 69:\n                // DECSLRM\n                marginMode = false\n            case 9: // X10 Mouse\n                mouseMode = .off\n            case 1000: // vt200 mouse\n                mouseMode = .off\n            case 95: // DECNCSM - clear on DECCOLM changes\n                // unsupported\n                break\n            case 1002: // button event mouse\n                mouseMode = .off\n            case 1003: // any event mouse\n                mouseMode = .off\n            case 1004: // send focusin/focusout events\n                sendFocus = false\n            case 1005: // utf8 ext mode mouse\n                mouseProtocol = .x10\n            case 1006: // sgr ext mode mouse\n                mouseProtocol = .x10\n            case 1015: // urxvt ext mode mouse\n                mouseProtocol = .x10\n            case 25: // hide cursor\n                hideCursor ()\n            case 1048: // alt screen cursor\n                cmdRestoreCursor ([], [])\n            case 1034:\n                // Terminal.app ignores this request, and keeps sending ESC+letter\n                break\n            case 1049: // alt screen buffer cursor\n                fallthrough\n            case 47: // normal screen buffer\n                fallthrough\n            case 1047: // normal screen buffer - clearing it first\n                   // Ensure the selection manager has the correct buffer\n                buffers!.activateNormalBuffer (clearAlt: par == 1047 || par == 1049)\n                if (par == 1049){\n                    cmdRestoreCursor ([], [])\n                }\n                refresh (startRow: 0, endRow: rows - 1)\n                syncScrollArea ()\n                showCursor ()\n                tdel?.bufferActivated(source: self)\n                \n            case 2004: // bracketed paste mode (https://cirw.in/blog/bracketed-paste)\n                bracketedPasteMode = false\n                break\n            default:\n                log (\"Unhandled DEC Private Mode Reset (DECRST) with \\(par)\")\n                break\n            }\n        }\n    }\n\n    //\n    // CSI Pm h  Set Mode (SM).\n    //     Ps = 2  -> Keyboard Action Mode (AM).\n    //     Ps = 4  -> Insert Mode (IRM).\n    //     Ps = 1 2  -> Send/receive (SRM).\n    //     Ps = 2 0  -> Automatic Newline (LNM).\n    // CSI ? Pm h\n    //   DEC Private Mode Set (DECSET).\n    //     Ps = 1  -> Application Cursor Keys (DECCKM).\n    //     Ps = 2  -> Designate USASCII for character sets G0-G3\n    //     (DECANM), and set VT100 mode.\n    //     Ps = 3  -> 132 Column Mode (DECCOLM).\n    //     Ps = 4  -> Smooth (Slow) Scroll (DECSCLM).\n    //     Ps = 5  -> Reverse Video (DECSCNM).\n    //     Ps = 6  -> Origin Mode (DECOM).\n    //     Ps = 7  -> Wraparound Mode (DECAWM).\n    //     Ps = 8  -> Auto-repeat Keys (DECARM).\n    //     Ps = 9  -> Send Mouse X & Y on button press.  See the sec-\n    //     tion Mouse Tracking.\n    //     Ps = 1 0  -> Show toolbar (rxvt).\n    //     Ps = 1 2  -> Start Blinking Cursor (att610).\n    //     Ps = 1 8  -> Print form feed (DECPFF).\n    //     Ps = 1 9  -> Set print extent to full screen (DECPEX).\n    //     Ps = 2 5  -> Show Cursor (DECTCEM).\n    //     Ps = 3 0  -> Show scrollbar (rxvt).\n    //     Ps = 3 5  -> Enable font-shifting functions (rxvt).\n    //     Ps = 3 8  -> Enter Tektronix Mode (DECTEK).\n    //     Ps = 4 0  -> Allow 80 -> 132 Mode.\n    //     Ps = 4 1  -> more(1) fix (see curses resource).\n    //     Ps = 4 2  -> Enable Nation Replacement Character sets (DECN-\n    //     RCM).\n    //     Ps = 4 4  -> Turn On Margin Bell.\n    //     Ps = 4 5  -> Reverse-wraparound Mode.\n    //     Ps = 4 6  -> Start Logging.  This is normally disabled by a\n    //     compile-time option.\n    //     Ps = 4 7  -> Use Alternate Screen Buffer.  (This may be dis-\n    //     abled by the titeInhibit resource).\n    //     Ps = 6 6  -> Application keypad (DECNKM).\n    //     Ps = 6 7  -> Backarrow key sends backspace (DECBKM).\n    //     Ps = 1 0 0 0  -> Send Mouse X & Y on button press and\n    //     release.  See the section Mouse Tracking.\n    //     Ps = 1 0 0 1  -> Use Hilite Mouse Tracking.\n    //     Ps = 1 0 0 2  -> Use Cell Motion Mouse Tracking.\n    //     Ps = 1 0 0 3  -> Use All Motion Mouse Tracking.\n    //     Ps = 1 0 0 4  -> Send FocusIn/FocusOut events.\n    //     Ps = 1 0 0 5  -> Enable Extended Mouse Mode.\n    //     Ps = 1 0 1 0  -> Scroll to bottom on tty output (rxvt).\n    //     Ps = 1 0 1 1  -> Scroll to bottom on key press (rxvt).\n    //     Ps = 1 0 3 4  -> Interpret \"meta\" key, sets eighth bit.\n    //     (enables the eightBitInput resource).\n    //     Ps = 1 0 3 5  -> Enable special modifiers for Alt and Num-\n    //     Lock keys.  (This enables the numLock resource).\n    //     Ps = 1 0 3 6  -> Send ESC   when Meta modifies a key.  (This\n    //     enables the metaSendsEscape resource).\n    //     Ps = 1 0 3 7  -> Send DEL from the editing-keypad Delete\n    //     key.\n    //     Ps = 1 0 3 9  -> Send ESC  when Alt modifies a key.  (This\n    //     enables the altSendsEscape resource).\n    //     Ps = 1 0 4 0  -> Keep selection even if not highlighted.\n    //     (This enables the keepSelection resource).\n    //     Ps = 1 0 4 1  -> Use the CLIPBOARD selection.  (This enables\n    //     the selectToClipboard resource).\n    //     Ps = 1 0 4 2  -> Enable Urgency window manager hint when\n    //     Control-G is received.  (This enables the bellIsUrgent\n    //     resource).\n    //     Ps = 1 0 4 3  -> Enable raising of the window when Control-G\n    //     is received.  (enables the popOnBell resource).\n    //     Ps = 1 0 4 7  -> Use Alternate Screen Buffer.  (This may be\n    //     disabled by the titeInhibit resource).\n    //     Ps = 1 0 4 8  -> Save cursor as in DECSC.  (This may be dis-\n    //     abled by the titeInhibit resource).\n    //     Ps = 1 0 4 9  -> Save cursor as in DECSC and use Alternate\n    //     Screen Buffer, clearing it first.  (This may be disabled by\n    //     the titeInhibit resource).  This combines the effects of the 1\n    //     0 4 7  and 1 0 4 8  modes.  Use this with terminfo-based\n    //     applications rather than the 4 7  mode.\n    //     Ps = 1 0 5 0  -> Set terminfo/termcap function-key mode.\n    //     Ps = 1 0 5 1  -> Set Sun function-key mode.\n    //     Ps = 1 0 5 2  -> Set HP function-key mode.\n    //     Ps = 1 0 5 3  -> Set SCO function-key mode.\n    //     Ps = 1 0 6 0  -> Set legacy keyboard emulation (X11R6).\n    //     Ps = 1 0 6 1  -> Set VT220 keyboard emulation.\n    //     Ps = 2 0 0 4  -> Set bracketed paste mode.\n    // Modes:\n    //   http: *vt100.net/docs/vt220-rm/chapter4.html\n    //\n    func cmdSetMode (_ pars: [Int], _ collect: cstring)\n    {\n        if pars.count == 0 {\n            return\n        }\n\n        if pars.count > 1 {\n            for i in 0..<pars.count {\n                setMode (pars [i], collect)\n            }\n            return\n        }\n        setMode (pars [0], collect)\n    }\n\n    func setMode (_ par: Int, _ collect: cstring)\n    {\n        if (collect == []) {\n            switch par {\n            case 2:\n                // KAM mode - unlocks the keyboard, I do not want to support it\n                break\n            case 4:\n                // IRM Insert/Replace Mode\n                // https://vt100.net/docs/vt510-rm/IRM.html\n                insertMode = true\n//            case 12:\n//                 SRM\u2014Local Echo: Send/Receive Mode\n//                 When implemented, hook up cmdDecRqm\n//                break\n            case 20:\n                // Automatic New Line (LNM)\n                lineFeedMode = true\n                break;\n            default:\n                log (\"Unhandled verbatim setMode with \\(par) and \\(collect)\")\n                break\n            }\n        } else if collect == [UInt8 (ascii: \"?\")] {\n            switch par {\n            case 1:\n                applicationCursor = true\n            case 2:\n                setgCharset (0, charset: CharSets.defaultCharset)\n                setgCharset (1, charset: CharSets.defaultCharset)\n                setgCharset (2, charset: CharSets.defaultCharset)\n                setgCharset (3, charset: CharSets.defaultCharset)\n                // set VT100 mode here\n                \n            case 3: // DECCOLM - go to 132 col mode\n                if allow80To132 {\n                    resize (cols: 132, rows: rows)\n                    resetToInitialState()\n                    tdel?.sizeChanged(source: self)\n                }\n            case 4: // Smooth scroll mode\n                smoothScroll = true\n                break\n            case 5:\n                // Inverted colors\n                curAttr = CharData.invertedAttr\n            case 6:\n                // DECOM Set\n                originMode = true\n            case 7:\n                wraparound = true\n            case 12:\n                cursorBlink = true\n                break;\n            case 40:\n                allow80To132 = true\n            case 66:\n                log (\"Serial port requested application keypad.\")\n                applicationKeypad = true\n                syncScrollArea ()\n            case 9:\n                // X10 Mouse\n                mouseMode = .x10\n            case 45: // Xterm Reverse Wrap-around\n                // reverse wraparound can only be enabled if Auto-wrap is enabled (DECAWM)\n                if wraparound {\n                    reverseWraparound = true\n                }\n            case 69:\n                // Enable left and right margin mode (DECLRMM),\n                marginMode = true\n            case 95: // DECNCSM - clear on DECCOLM changes\n                // unsupported\n                break\n            case 1000:\n                // SET_VT200_HIGHLIGHT_MOUSE\n                mouseMode = .vt200\n            case 1002:\n                // SET_BTN_EVENT_MOUSE\n                mouseMode = .buttonEventTracking\n\n            case 1003:\n                // SET_ANY_EVENT_MOUSE\n                mouseMode = .anyEvent\n\n            case 1004: // send focusin/focusout events\n                   // focusin: ^[[I\n                   // focusout: ^[[O\n                sendFocus = true\n            case 1005:\n                // utf8 ext mode mouse\n                mouseProtocol = .utf8\n                break;\n            case 1006: // sgr ext mode mouse\n                mouseProtocol = .sgr\n            case 1015: // urxvt ext mode mouse\n                mouseProtocol = .urxvt\n            case 25: // show cursor\n                showCursor()\n            case 63:\n                // DECRLM - Cursor Right to Left Mode, not supported\n                break\n            case 1034:\n                // Terminal.app ignores this request, and keeps sending ESC+letter\n                // Given our UTF8 world, I do not think this is a worth encoding\n                break\n            case 1048: // alt screen cursor\n                cmdSaveCursor ([], [])\n            case 1049: // alt screen buffer cursor\n                cmdSaveCursor ([], [])\n                // FALL-THROUGH\n                fallthrough\n            case 47: // alt screen buffer\n                fallthrough\n            case 1047: // alt screen buffer\n                buffers!.activateAltBuffer (fillAttr: nil)\n                refresh (startRow: 0, endRow: rows - 1)\n                syncScrollArea ()\n                showCursor ()\n                tdel?.bufferActivated(source: self)\n                \n            case 2004: // bracketed paste mode (https://cirw.in/blog/bracketed-paste)\n                // TODO: must implement bracketed paste mode\n                bracketedPasteMode = true\n            default:\n                log (\"Unhandled DEC Private Mode Set (DECSET) with \\(par)\")\n                break;\n            }\n        } else {\n            log (\"Unhandled setMode (SM) with \\(par) and \\(collect)\")\n        }\n        \n    }\n\n\n    //\n    // CSI Ps g  Tab Clear (TBC).\n    //     Ps = 0  -> Clear Current Column (default).\n    //     Ps = 3  -> Clear All.\n    // Potentially:\n    //   Ps = 2  -> Clear Stops on Line.\n    //   http://vt100.net/annarbor/aaa-ug/section6.html\n    //\n    func cmdTabClear (_ pars: [Int], _ collect: cstring)\n    {\n        let p = pars.count == 0 ? 0 : pars [0]\n        if p == 0 {\n            buffer.tabClear(pos: buffer.x)\n        } else if (p == 3) {\n            buffer.clearTabStops ()\n        }\n    }\n\n\n    //\n    // CSI Ps ; Ps f\n    //   Horizontal and Vertical Position [row;column] (default =\n    //   [1,1]) (HVP).\n    //\n    func cmdHVPosition (_ pars: [Int], _ collect: cstring)\n    {\n        var p = 1\n        var q = 1\n        if pars.count > 0 {\n            p = max (pars [0], 1)\n            if (pars.count > 1){\n                q = max (pars [1], 1)\n            }\n        }\n        \n        buffer.y = p - 1 + (originMode ? buffer.scrollTop : 0)\n        if buffer.y >= rows {\n            buffer.y = rows - 1\n        }\n        \n        buffer.x = q - 1 + (originMode && marginMode ? buffer.marginLeft : 0)\n        if buffer.x >= cols {\n            buffer.x = cols - 1\n        }\n    }\n\n    //\n    // CSI Pm e  Vertical Position Relative (VPR)\n    //   [rows] (default = [row+1,column])\n    // reuse CSI Ps B ?\n    //\n    func cmdVPositionRelative (_ pars: [Int], _ collect: cstring)\n    {\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n        let newY = buffer.y + p\n\n        if newY >= rows {\n            buffer.y = rows - 1\n        } else {\n            buffer.y = newY\n        }\n\n        // If the end of the line is hit, prevent this action from wrapping around to the next line.\n        if buffer.x >= cols {\n            buffer.x -= 1\n        }\n    }\n\n\n    //\n    // CSI Pm d  Vertical Position Absolute (VPA)\n    //   [row] (default = [1,column])\n    //\n    func cmdLinePosAbsolute (_ pars: [Int], _ collect: cstring)\n    {\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n\n        if (p - 1 >= rows) {\n            buffer.y = rows - 1\n        } else {\n            buffer.y = p - 1\n        }\n    }\n\n    //\n    // CSI Ps c  Send Device Attributes (Primary DA).\n    //     Ps = 0  or omitted -> request attributes from terminal.  The\n    //     response depends on the decTerminalID resource setting.\n    //     -> CSI ? 1 ; 2 c  (``VT100 with Advanced Video Option'')\n    //     -> CSI ? 1 ; 0 c  (``VT101 with No Options'')\n    //     -> CSI ? 6 c  (``VT102'')\n    //     -> CSI ? 6 0 ; 1 ; 2 ; 6 ; 8 ; 9 ; 1 5 ; c  (``VT220'')\n    //   The VT100-style response parameters do not mean anything by\n    //   themselves.  VT220 parameters do, telling the host what fea-\n    //   tures the terminal supports:\n    //     Ps = 1  -> 132-columns.\n    //     Ps = 2  -> Printer.\n    //     Ps = 4  -> Sixel graphics\n    //     Ps = 6  -> Selective erase.\n    //     Ps = 8  -> User-defined keys.\n    //     Ps = 9  -> National replacement character sets.\n    //     Ps = 1 5  -> Technical characters.\n    //     Ps = 2 2  -> ANSI color, e.g., VT525.\n    //     Ps = 2 9  -> ANSI text locator (i.e., DEC Locator mode).\n    // CSI > Ps c\n    //   Send Device Attributes (Secondary DA).\n    //     Ps = 0  or omitted -> request the terminal's identification\n    //     code.  The response depends on the decTerminalID resource set-\n    //     ting.  It should apply only to VT220 and up, but xterm extends\n    //     this to VT100.\n    //     -> CSI  > Pp ; Pv ; Pc c\n    //   where Pp denotes the terminal type\n    //     Pp = 0  -> ``VT100''.\n    //     Pp = 1  -> ``VT220''.\n    //   and Pv is the firmware version (for xterm, this was originally\n    //   the XFree86 patch number, starting with 95).  In a DEC termi-\n    //   nal, Pc indicates the ROM cartridge registration number and is\n    //   always zero.\n    // More information:\n    //   xterm/charproc.c - line 2012, for more information.\n    //   vim responds with ^[[?0c or ^[[?1c after the terminal's response (?)\n    //\n    func cmdSendDeviceAttributes (_ pars: [Int], _ collect: cstring)\n    {\n        if pars.count > 0 && pars [0] > 0 {\n            var safe = collect\n            safe.append(0)\n            log (\"SendDeviceAttributes got \\(pars) and \\(String(cString: safe))\")\n            return\n        }\n\n        if collect == [UInt8 (ascii: \">\")] || collect == [UInt8 (ascii: \">\"), UInt8 (ascii: \"0\")] {\n            // DA2 Secondary Device Attributes\n            if pars.count == 0 || pars [0] == 0 {\n                let vt525 = 65 // we identified as a vt525\n                let kbd = 1 // PC-style keyboard\n                sendResponse(cc.CSI, \">\\(vt525);20;\\(kbd)c\")\n                return\n            }\n            log (\"Got a CSI > c with an unknown set of argument\")\n            return\n        }\n        \n        // We should use a terminal emulation level, and not rely on the TERM name\n        // for now, \"xterm\" as a part of the name surfaces all the capabilities.\n        let name = options.termName\n        if collect == [] {\n            let termVt525 = 65\n            let sixel = options.enableSixelReported ? \";6\" : \"\"\n            let cols132 = 1\n            let printer = 2\n            let decsera = 6\n            let horizontalScrolling = 21\n            let ansiColor = 22\n            \n            // Send Device Attributes (Primary DA).1\n            if name.hasPrefix(\"xterm\") {\n                sendResponse (cc.CSI, \"?\\(termVt525)\\(sixel);\\(cols132);\\(printer);\\(decsera);\\(horizontalScrolling);\\(ansiColor)c\")\n            } else if name.hasPrefix(\"screen\") || name.hasPrefix (\"rxvt-unicode\") {\n                sendResponse (cc.CSI, \"?\\(cols132);\\(printer)c\")\n            } else if name.hasPrefix (\"linux\") {\n                sendResponse (cc.CSI, \"?\\(decsera)c\")\n            }\n        } else if collect.count == 1 && collect [0] == UInt8 (ascii: \">\") {\n            // xterm and urxvt\n            // seem to spit this\n            // out around ~370 times (?).\n            if name.hasPrefix (\"xterm\") {\n                sendResponse (cc.CSI, \">0;276;0c\")\n            } else if name.hasPrefix (\"rxvt-unicode\") {\n                sendResponse (cc.CSI, \">85;95;0c\")\n            } else if name.hasPrefix (\"linux\") {\n                // not supported by linux console.\n                // linux console echoes parameters.\n                sendResponse (\"\\(pars[0])c\")\n            } else if name.hasPrefix (\"screen\") {\n                sendResponse (cc.CSI, \">83;40003;0c\")\n            }\n        }\n    }\n\n\n    //\n    // CSI Ps b  Repeat the preceding graphic character Ps times (REP).\n    //\n    func cmdRepeatPrecedingCharacter (_ pars: [Int], _ collect: cstring)\n    {\n        // Maximum repeat, to avoid a denial of service\n        let maxRepeat = cols*rows*2\n        let p = min (maxRepeat, max (pars.count == 0 ? 1 : pars [0], 1))\n        let line = buffer.lines [buffer.yBase + buffer.y]\n        let chData = buffer.x - 1 < 0 ? CharData (attribute: CharData.defaultAttr) : line [buffer.x - 1]\n        \n        for _ in 0..<p {\n            insertCharacter(chData)\n        }\n    }\n\n    //\n    //CSI Pm a  Character Position Relative\n    //  [columns] (default = [row,col+1]) (HPR)\n    //reuse CSI Ps C ?\n    //\n    func cmdHPositionRelative (_ pars: [Int], _ collect: cstring)\n    {\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n        \n        buffer.x += p\n        if buffer.x >= cols {\n            buffer.x = cols - 1\n        }\n    }\n\n    //\n    // CSI Pm `  Character Position Absolute\n    //   [column] (default = [row,1]) (HPA).\n    //\n    func cmdCharPosAbsolute (_ pars: [Int], _ collect: cstring)\n    {\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n\n        buffer.x = p - 1\n        if buffer.x >= cols {\n            buffer.x = cols - 1\n        }\n    }\n\n    //\n    //CSI Ps Z  Cursor Backward Tabulation Ps tab stops (default = 1) (CBT).\n    //\n    func cmdCursorBackwardTab (_ pars: [Int], _ collect: cstring)\n    {\n        if buffer.x > cols {\n            return\n        }\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n\n        for _ in 0..<p {\n            buffer.x = buffer.previousTabStop ()\n        }\n    }\n\n    //\n    // CSI Ps X\n    // Erase Ps Character(s) (default = 1) (ECH).\n    //\n    func cmdEraseChars (_ pars: [Int], _ collect: cstring)\n    {\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n\n        buffer.lines [buffer.y + buffer.yBase].replaceCells (\n            start: buffer.x,\n            end: buffer.x + p,\n            fillData: CharData (attribute:  eraseAttr ()))\n    }\n\n    func csiT (_ pars: [Int], _ collect: cstring)\n    {\n        if collect.count == 0 {\n            cmdScrollDown(pars)\n        } else if collect == [UInt8 (ascii: \">\")] {\n            cmdXtermTitleModeReset(pars)\n        }\n    }\n    //\n    // CSI Ps T  Scroll down Ps lines (default = 1) (SD).\n    //\n    func cmdScrollDown (_ pars: [Int])\n    {\n        let p = min (max (pars.count == 0 ? 1 : pars [0], 1), rows)\n        let da = CharData.defaultAttr\n\n        let row = buffer.scrollTop + buffer.yBase\n\n        let columnCount = buffer.marginRight-buffer.marginLeft+1\n        let rowCount = buffer.scrollBottom-buffer.scrollTop\n        for _ in 0..<p {\n            for i in (0..<rowCount).reversed() {\n                let src = buffer.lines [row+i]\n                let dst = buffer.lines [row+i+1]\n                \n                dst.copyFrom(src, srcCol: buffer.marginLeft, dstCol: buffer.marginLeft, len: columnCount)\n            }\n            let last = buffer.lines [row]\n            last.fill (with: CharData (attribute: da), atCol: buffer.marginLeft, len: columnCount)\n        }\n        // this.maxRange();\n        updateRange (startLine: buffer.scrollTop, endLine: buffer.scrollBottom)\n    }\n\n    //\n    // CSI Ps S  Scroll up Ps lines (default = 1) (SU).\n    //\n    func cmdScrollUp (_ pars: [Int], _ collect: cstring)\n    {\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n        let da = CharData.defaultAttr\n\n        if marginMode {\n            let row = buffer.scrollTop + buffer.yBase\n\n            let columnCount = buffer.marginRight-buffer.marginLeft+1\n            let rowCount = buffer.scrollBottom-buffer.scrollTop\n            for _ in 0..<p {\n                for i in 0..<(rowCount) {\n                    let src = buffer.lines [row+i+1]\n                    let dst = buffer.lines [row+i]\n                    \n                    dst.copyFrom(src, srcCol: buffer.marginLeft, dstCol: buffer.marginLeft, len: columnCount)\n                }\n                let last = buffer.lines [row+rowCount]\n                last.fill (with: CharData (attribute: da), atCol: buffer.marginLeft, len: columnCount)\n            }\n        } else {\n            for _ in 0..<p {\n                buffer.lines.splice (start: buffer.yBase + buffer.scrollTop, deleteCount: 1,\n                                     items: [], change: { line in updateRange (line)})\n                buffer.lines.splice (start: buffer.yBase + buffer.scrollBottom, deleteCount: 0,\n                                     items: [buffer.getBlankLine (attribute: da)],\n                                     change: { line in updateRange (line) })\n            }\n        }\n        // this.maxRange();\n        updateRange (startLine: buffer.scrollTop, endLine: buffer.scrollBottom)\n    }\n\n    //\n    // CSI Ps P\n    // Delete Ps Character(s) (default = 1) (DCH).\n    //\n    func cmdDeleteChars (_ pars: [Int], _ collect: cstring)\n    {\n        let buffer = self.buffer\n        var p = max (pars.count == 0 ? 1 : pars [0], 1)\n        \n        if marginMode {\n            if buffer.x < buffer.marginLeft || buffer.x > buffer.marginRight {\n                return\n            }\n            if buffer.x + p > buffer.marginRight {\n                p = buffer.marginRight - buffer.x + 1\n            }\n        }\n        // buffer.x = buffer.cols is a special case on the edge, we do not delete columns in that boundary\n        if buffer.x == buffer.cols {\n            return\n        }\n        buffer.lines [buffer.y + buffer.yBase].deleteCells (\n            pos: buffer.x, n: p, rightMargin: marginMode ? buffer.marginRight : cols-1, fillData: CharData (attribute: eraseAttr ()))\n        \n        updateRange (buffer.y)\n    }\n\n    //\n    // CSI Ps M\n    // Delete Ps Line(s) (default = 1) (DL).\n    //\n    func cmdDeleteLines (_ pars: [Int], _ collect: cstring)\n    {\n        restrictCursor()\n        let buffer = self.buffer\n        // No point deleting more lines than the available rows, prevents\n        // a denial of service caused by very large numbers passed here\n        let p = min (buffer.rows+1, max (pars.count == 0 ? 1 : pars [0], 1))\n        let row = buffer.y + buffer.yBase\n        var j = rows - 1 - buffer.scrollBottom\n        j = rows - 1 + buffer.yBase - j\n        let ea = eraseAttr ()\n        \n        if marginMode {\n            if buffer.x >= buffer.marginLeft && buffer.x <= buffer.marginRight {\n                let columnCount = buffer.marginRight-buffer.marginLeft+1\n                let rowCount = buffer.scrollBottom-buffer.scrollTop\n                for _ in 0..<p {\n                    for i in 0..<(rowCount) {\n                        let src = buffer.lines [row+i+1]\n                        let dst = buffer.lines [row+i]\n                        \n                        dst.copyFrom(src, srcCol: buffer.marginLeft, dstCol: buffer.marginLeft, len: columnCount)\n                    }\n                    \n                    let last = buffer.lines [row+rowCount]\n                    last.fill (with: CharData (attribute: ea), atCol: buffer.marginLeft, len: columnCount)\n                }\n            }\n        } else {\n            if buffer.y >= buffer.scrollTop && buffer.y <= buffer.scrollBottom {\n                for _ in 0..<p {\n                    // test: echo -e '\\e[44m\\e[1M\\e[0m'\n                    // blankLine(true) - xterm/linux behavior\n                    buffer.lines.splice (start: row, deleteCount: 1, items: [], change: { line in updateRange (line)})\n                    buffer.lines.splice (start: j, deleteCount: 0,\n                                         items: [buffer.getBlankLine (attribute: ea)],\n                                         change: { line in updateRange (line)})\n                }\n            }\n        }\n        \n        // this.maxRange();\n        updateRange (startLine: buffer.y, endLine: buffer.scrollBottom)\n    }\n\n    //\n    // CSI Ps ' ~\n    // Delete Ps Column(s) (default = 1) (DECDC), VT420 and up.\n    //\n    // @vt: #Y CSI DECDC \"Delete Columns\"  \"CSI Ps ' ~\"  \"Delete `Ps` columns at cursor position.\"\n    // DECDC deletes `Ps` times columns at the cursor position for all lines with the scroll margins,\n    // moving content to the left. Blank columns are added at the right margin.\n    // DECDC has no effect outside the scrolling margins.\n\n    func cmdDeleteColumns (_ pars: [Int], _ collect: cstring)\n    {\n        let buffer = self.buffer\n        if buffer.y > buffer.scrollBottom || buffer.y < buffer.scrollTop {\n            return\n        }\n        // buffer.x = buffer.cols is a special case on the edge, we do not delete columns in that boundary\n        if buffer.x == buffer.cols {\n            return\n        }\n        if marginMode {\n            if buffer.x < buffer.marginLeft || buffer.x > buffer.marginRight {\n                return\n            }\n        }\n\n        let p = max (pars.count == 0 ? 1 : pars [0], 1)\n        \n        for y in buffer.scrollTop...buffer.scrollBottom {\n            let line = buffer.lines [buffer.yBase + y]\n            line.deleteCells(pos: buffer.x, n: p, rightMargin: marginMode ? buffer.marginRight : cols-1, fillData: buffer.getNullCell(attribute: eraseAttr()))\n            line.isWrapped = false\n        }\n        updateRange (startLine: buffer.scrollTop, endLine: buffer.scrollBottom)\n    }\n\n\n    //\n    // Helper method to reset cells in a terminal row.\n    // The cell gets replaced with the eraseChar of the terminal and the isWrapped property is set to false.\n    // @param y row index\n    //\n    func resetBufferLine (y: Int)\n    {\n        eraseInBufferLine (y: y, start: 0, end: cols, clearWrap: true, clearRenderMode: true)\n        updateRange(y)\n    }\n\n    /**\n     * Sends the provided text to the connected backend\n     */\n    public func sendResponse (text: String)\n    {\n        tdel?.send (source: self, data: ([UInt8] (text.utf8))[...])\n    }\n    \n    /**\n     * Sends the provided text to the connected backend, takes a variable list of arguments\n     * that could be either [UInt8], Strings, or a single UInt8 value.\n     */\n    public func sendResponse (_ items: Any ...)\n    {\n        var buffer: [UInt8] = []\n        \n        for item in items {\n            if let arr = item as? [UInt8] {\n                buffer.append(contentsOf: arr)\n            } else if let str = item as? String {\n                buffer.append (contentsOf: [UInt8] (str.utf8))\n            } else if let c = item as? UInt8 {\n                buffer.append (c)\n            } else {\n                log (\"Do not know how to handle type \\(item)\")\n            }\n        }\n        tdel?.send (source: self, data: buffer[...])\n    }\n    \n#if DEBUG\n    public var silentLog = false\n#else\n    public var silentLog = true\n#endif\n    \n    func error (_ text: String)\n    {\n        if !silentLog {\n            print(\"Error: \\(text)\")\n        }\n    }\n    \n    func log (_ text: String)\n    {\n        if !silentLog {\n            print(\"Info: \\(text)\")\n        }\n    }\n    \n    /**\n     * Processes the provided byte-array coming from the host, interprets them and\n     * updates the screen state accordingly.\n     */\n    public func feed (byteArray: [UInt8])\n    {\n        parse (buffer: byteArray[...])\n    }\n    \n    /**\n     * Processes the provided byte-array coming from the host, interprets them and\n     * updates the screen state accordingly.\n     */\n    public func feed (text: String)\n    {\n        parse (buffer: ([UInt8] (text.utf8))[...])\n    }\n\n    /**\n     * Processes the provided byte-array coming from the host, interprets them and\n     * updates the screen state accordingly.\n     */\n    public func feed (buffer: ArraySlice<UInt8>)\n    {\n        parse (buffer: buffer)\n    }\n\n    /**\n     * Processes the provided byte-array coming from the host, interprets them and\n     * updates the screen state accordingly.\n     */\n    public func parse (buffer: ArraySlice<UInt8>)\n    {\n        parser.parse(data: buffer)\n    }\n \n    var dirtyLines: Set<Int> = Set<Int>()\n    \n    /**\n     * Registers the given line as requiring to be updated by the front-end engine\n     *\n     * The front-end engine should call `getUpdateRange` to\n     * determine which region in the screen needs to be redrawn.   This method adds the specified\n     * line to the range of modified lines\n     *\n     * Scrolling tells if this was just issued as part of scrolling which we don't register for the\n     * scroll-invariant update ranges.\n     */\n    func updateRange (_ y: Int, scrolling: Bool = false, updateDirtySet: Bool = true)\n    {        \n        if !scrolling {\n            let effectiveY = buffer.yDisp + y\n            if effectiveY >= 0 {\n                if effectiveY < scrollInvariantRefreshStart {\n                    scrollInvariantRefreshStart = effectiveY\n                }\n                if effectiveY > scrollInvariantRefreshEnd {\n                    scrollInvariantRefreshEnd = effectiveY\n                }\n            }\n        }\n        \n        if y >= 0 {\n            if y < refreshStart {\n                refreshStart = y\n            }\n            if y > refreshEnd {\n                refreshEnd = y\n            }\n        }\n        if updateDirtySet {\n            dirtyLines.insert (y)\n        }\n    }\n    \n    func updateRange (startLine: Int, endLine: Int, scrolling: Bool = false)\n    {\n        updateRange (startLine, scrolling: scrolling, updateDirtySet: false)\n        updateRange (endLine, scrolling: scrolling, updateDirtySet: false)\n        \n        for line in min(startLine,endLine)...max(startLine,endLine) {\n            dirtyLines.insert (line)\n        }\n    }\n    \n    public func updateFullScreen ()\n    {\n        refreshStart = 0\n        refreshEnd = rows\n        \n        scrollInvariantRefreshStart = buffer.yDisp\n        scrollInvariantRefreshEnd = buffer.yDisp + rows\n        \n        for line in 0...rows {\n            dirtyLines.insert (line)\n        }\n\n    }\n    \n    /**\n     * Returns the starting and ending lines that need to be redrawn, or nil\n     * if no part of the screen needs to be updated.   Alternatively, you can\n     * get a Set<Int> with the changed lines by calling `changedLines()`.\n     *\n     * UI toolkits should call `clearUpdateRange` to reset these changes\n     * after they have used this information, so that new changes only reflect\n     * the actual changes.\n     */\n    public func getUpdateRange () -> (startY: Int, endY: Int)?\n    {\n        if refreshEnd == -1 && refreshStart == Int.max {\n            //print (\"Emtpy update range\")\n            return nil\n        }\n        //print (\"Update: \\(refreshStart) \\(refreshEnd)\")\n        return (refreshStart, refreshEnd)\n    }\n    \n    /**\n     * Returns a set containing the lines that have been modified, the\n     * returned set is not sorted.\n     *\n     * UI toolkits should call `clearUpdateRange` to reset these changes\n     * after they have used this information, so that new changes only reflect\n     * the actual changes.\n     */\n   public func changedLines () -> Set<Int>\n   {\n       return dirtyLines\n   }\n   \n\n    /**\n     * Check for payload identifiers that are not in use and stop retaining their payload,\n     * to avoid accumulting memory for images and URLs that are no longer visible or\n     * available by scrolling.\n     */\n    public func garbageCollectPayload() {\n        // stop right away if there is nothing to collect\n        if TinyAtom.lastCollected == TinyAtom.lastUsed {\n            return\n        }\n        \n        // check all atoms used in both buffers\n        var used = Set<UInt16>()\n        for buffer in [buffers.normal, buffers.alt] {\n            for line in buffer._lines.array {\n                if let array = line?.data {\n                    for data in array {\n                        let code = data.payload.code\n                        if code > 0 {\n                            used.insert(code)\n                        }\n                    }\n                }\n            }\n        }\n        \n        // since we create atoms in order we expect them to run out of use\n        // in order as well and stop with first atom that is still in use\n        for code in UInt16(TinyAtom.lastCollected + 1)...UInt16(TinyAtom.lastUsed) {\n            if used.contains(code) {\n                // code still in use\n                break\n            }\n            \n            TinyAtom.lastCollected = Int(code)\n            TinyAtom.release(code: code)\n        }\n    }\n    \n    /**\n     * Returns the starting and ending lines that need to be redrawn, or nil\n     * if no part of the screen needs to be updated.\n     *\n     * This is different from getUpdateRange() in that lines are from start of scroll back,\n     * not what the terminal has visible right now.\n     */\n    public func getScrollInvariantUpdateRange () -> (startY: Int, endY: Int)?\n    {\n        if scrollInvariantRefreshEnd == -1 && scrollInvariantRefreshStart == Int.max {\n            //print (\"Emtpy update range\")\n            return nil\n        }\n        //print (\"Update: \\(scrollInvariantRefreshStart) \\(scrollInvariantRefreshEnd)\")\n        return (scrollInvariantRefreshStart, scrollInvariantRefreshEnd)\n    }\n    \n    /**\n     * Clears the state of the pending display redraw region as well as the dirtyLines set.\n     */\n    public func clearUpdateRange ()\n    {\n        refreshStart = Int.max\n        refreshEnd = -1\n        \n        scrollInvariantRefreshStart = Int.max\n        scrollInvariantRefreshEnd = -1\n        \n        dirtyLines.removeAll()\n    }\n    \n    /**\n     * Zero-based (row, column) of cursor location relative to visible part of display.\n     * Returns: a tuple, where the first element contains the column (x) and the second the row (y) where the cursor is.\n     */\n    public func getCursorLocation() -> (x: Int, y: Int) {\n        return (buffer.x, buffer.y)\n    }\n    \n    /**\n     * Returns the uppermost visible row on the terminal buffer\n     */\n    public func getTopVisibleRow() -> Int {\n        return buffer.yDisp\n    }\n    \n    // ESC c Full Reset (RIS)\n    /// This performs a full reset of the terminal, like a soft reset, but additionally resets the buffer conents and scroll area.\n    /// for a soft reset see `softReset`\n    public func resetToInitialState ()\n    {\n        options.rows = rows\n        options.cols = cols\n        let savedCursorHidden = cursorHidden\n        setup (isReset: true)\n        cursorHidden = savedCursorHidden\n        refresh (startRow: 0, endRow: rows-1)\n        syncScrollArea ()\n    }\n\n    // Support for:\n    // ESC 6 Back Index (DECBI) and\n    // ESC 9 Forward Index (DECFI)\n    func columnIndex (back: Bool)\n    {\n        let buffer = self.buffer\n        let x = buffer.x\n        let leftMargin = buffer.marginLeft\n        if back {\n            if x == leftMargin {\n                columnScroll (back: back, at: x)\n            } else {\n                cursorBackward(count: 1)\n            }\n        } else {\n            let rightMargin = buffer.marginRight\n            if x == rightMargin  {\n                columnScroll (back: back, at: leftMargin)\n            } else if x == buffer.cols {\n                // on the boundaries, we ignore, test_DECFI_WholeScreenScrolls\n            } else {\n                cursorForward(count: 1)\n            }\n        }\n    }\n    \n    func columnScroll (back: Bool, at: Int)\n    {\n        if buffer.y < buffer.scrollTop || buffer.y > buffer.scrollBottom || buffer.x < buffer.marginLeft || buffer.x > buffer.marginRight {\n            return\n        }\n        for y in buffer.scrollTop...buffer.scrollBottom {\n            let line = buffer.lines [buffer.yBase + y]\n            if back {\n                line.insertCells(pos: at, n: 1, rightMargin: marginMode ? buffer.marginRight : cols-1, fillData: buffer.getNullCell())\n            } else {\n                line.deleteCells(pos: at, n: 1, rightMargin: marginMode ? buffer.marginRight : cols-1, fillData: buffer.getNullCell(attribute: eraseAttr()))\n            }\n            //line.isWrapped = false\n        }\n        updateRange (buffer.scrollTop)\n        updateRange (buffer.scrollBottom)\n    }\n    \n    // ESC D Index (Index is 0x84) - IND\n    func cmdIndex ()\n    {\n        restrictCursor()\n        \n        let buffer = self.buffer\n        let newY = buffer.y + 1\n        if newY > buffer.scrollBottom {\n            scroll ()\n        } else {\n            buffer.y = newY\n        }\n        // If the end of the line is hit, prevent this action from wrapping around to the next line\n        if buffer.x > cols {\n            buffer.x -= 1\n        }\n    }\n    \n    var blankLine: BufferLine = BufferLine(cols: 0)\n    \n    public func scroll (isWrapped: Bool = false)\n    {\n        let buffer = self.buffer\n        var newLine = blankLine\n        if newLine.count != cols || newLine [0].attribute != eraseAttr () {\n            newLine = buffer.getBlankLine (attribute: eraseAttr (), isWrapped: isWrapped)\n            blankLine = newLine\n        }\n        newLine.isWrapped = isWrapped\n\n        let topRow = buffer.yBase + buffer.scrollTop\n        let bottomRow = buffer.yBase + buffer.scrollBottom\n\n        if buffer.scrollTop == 0 {\n            // Determine whether the buffer is going to be trimmed after insertion.\n            let willBufferBeTrimmed = buffer.lines.isFull\n\n            // Insert the line using the fastest method\n            if bottomRow == buffer.lines.count - 1 {\n                if willBufferBeTrimmed {\n                    buffer.lines.recycle ()\n                } else {\n                    buffer.lines.push (BufferLine (from: newLine))\n                }\n            } else {\n                buffer.lines.splice (start: bottomRow + 1, deleteCount: 0,\n                                     items: [BufferLine (from: newLine)],\n                                     change: { line in updateRange (line)})\n            }\n\n            // Only adjust ybase and ydisp when the buffer is not trimmed\n            if !willBufferBeTrimmed {\n                buffer.yBase += 1\n                // Only scroll the ydisp with ybase if the user has not scrolled up\n                if !userScrolling {\n                    buffer.yDisp += 1\n                }\n            } else {\n                if buffer.hasScrollback {\n                    buffer.linesTop += 1\n                }\n                \n                // When the buffer is full and the user has scrolled up, keep the text\n                // stable unless ydisp is right at the top\n                if userScrolling {\n                    buffer.yDisp = max (buffer.yDisp - 1, 0)\n                }\n            }\n        } else {\n            // scrollTop is non-zero which means no line will be going to the\n            // scrollback, instead we can just shift them in-place.\n            let scrollRegionHeight = bottomRow - topRow + 1 /*as it's zero-based*/\n            if scrollRegionHeight > 1 {\n                buffer.lines.shiftElements (start: topRow + 1, count: scrollRegionHeight - 1, offset: -1)\n            }\n            buffer.lines [bottomRow] = BufferLine (from: newLine)\n        }\n\n        // Move the viewport to the bottom of the buffer unless the user is\n        // scrolling.\n        if !userScrolling {\n            buffer.yDisp = buffer.yBase\n        }\n\n        //buffer.dump ()\n        // Flag rows that need updating\n        updateRange (buffer.scrollTop, scrolling: true)\n        updateRange (buffer.scrollBottom, scrolling: true)\n        \n        if !buffer.hasScrollback {\n            updateRange(startLine: buffer.scrollTop, endLine: buffer.scrollBottom)\n        }\n\n        /**\n         * This event is emitted whenever the terminal is scrolled.\n         * The one parameter passed is the new y display position.\n         *\n         * @event scroll\n         */\n        tdel?.scrolled(source: self, yDisp: buffer.yDisp)\n    }\n        \n    public func emitLineFeed ()\n    {\n        tdel?.linefeed(source: self)\n    }\n    \n    //\n    // ESC n\n    // ESC o\n    // ESC |\n    // ESC }\n    // ESC ~\n    //   DEC mnemonic: LS (https://vt100.net/docs/vt510-rm/LS.html)\n    //   When you use a locking shift, the character set remains in GL or GR until\n    //   you use another locking shift. (partly supported)\n    //\n    func setgLevel (_ v: UInt8)\n    {\n        gLevel = v\n        if let cs = CharSets.all [v] {\n            charset = cs\n        } else {\n            charset = nil\n        }\n    }\n    \n    //\n    // ESC % @\n    // ESC % G\n    //   Select default character set. UTF-8 is not supported (string are unicode anyways)\n    //   therefore ESC % G does the same.\n    //\n    func cmdSelectDefaultCharset ()\n    {\n        setgLevel (0)\n        setgCharset (0, charset: CharSets.defaultCharset)\n    }\n\n    //\n    // ESC c\n    //   DEC mnemonic: RIS (https://vt100.net/docs/vt510-rm/RIS.html)\n    //   Reset to initial state.\n    //\n    func cmdReset ()\n    {\n            parser.reset ()\n            resetToInitialState ()\n    }\n            \n    //\n    // ESC >\n    //   DEC mnemonic: DECKPNM (https://vt100.net/docs/vt510-rm/DECKPNM.html)\n    //   Enables the keypad to send numeric characters to the host.\n    //\n    func cmdKeypadNumericMode ()\n    {\n            applicationKeypad = false\n            syncScrollArea ()\n    }\n                    \n    //\n    // ESC =\n    //   DEC mnemonic: DECKPAM (https://vt100.net/docs/vt510-rm/DECKPAM.html)\n    //   Enables the numeric keypad to send application sequences to the host.\n    //\n    func cmdKeypadApplicationMode ()\n    {\n            applicationKeypad = true\n            syncScrollArea ()\n    }\n\n    func eraseAttr () -> Attribute\n    {\n        Attribute (fg: CharData.defaultAttr.fg, bg: curAttr.bg, style: CharData.defaultAttr.style)\n    }\n    \n    func setgCharset (_ v: UInt8, charset: [UInt8: String]?)\n    {\n        CharSets.all [v] = charset\n        if gLevel == v {\n            self.charset = charset\n        }\n    }\n    \n    public func resize (cols: Int, rows: Int)\n    {\n        let newCols = max (cols, MINIMUM_COLS)\n        let newRows = max (rows, MINIMUM_ROWS)\n        if newCols == self.cols && newRows == self.rows {\n            return\n        }\n        let oldCols = self.cols\n        buffers.resize(newColumns: newCols, newRows: newRows)\n        self.cols = newCols\n        self.rows = newRows\n        options.cols = newCols\n        options.rows = newRows\n        buffers.normal.setupTabStops (index: oldCols)\n        buffers.alt.setupTabStops (index: oldCols)\n        refresh (startRow: 0, endRow: self.rows - 1)\n    }\n    \n    func syncScrollArea ()\n    {\n        // This should call the viewport sync-scroll-area\n    }\n\n    /**\n     * Registers that the region between startRow and endRow was modified and needs to be updated by the\n     */\n    public func refresh (startRow: Int, endRow: Int)\n    {\n        // TO BE HONEST - This probably should not be called directly,\n        // instead the view shoudl after feeding data, determine if there is a need\n        // to refresh based on the parameters provided for refresh ranges, and then\n        // update, to avoid the backend rtiggering this multiple times.\n\n        updateRange (startLine: startRow, endLine: endRow)\n    }\n    \n    public func showCursor ()\n    {\n        if cursorHidden == false {\n            return\n        }\n        cursorHidden = false\n        //refresh (startRow: buffer.y, endRow: buffer.y)\n        tdel?.showCursor (source: self)\n    }\n    \n    public func hideCursor ()\n    {\n        if cursorHidden {\n            return\n        }\n        cursorHidden = true\n        tdel?.hideCursor(source: self)\n    }\n\n    // Encode button and position to characters\n    func encodeMouseUtf (data: inout [UInt8], ch: Int)\n    {\n        if ch == 2047 {\n            data.append(0)\n            return\n        }\n        if ch < 127 {\n            data.append (UInt8(ch))\n        } else {\n            let rc = ch > 2047 ? 2047 : ch\n            data.append (0xc0 | (UInt8 (rc >> 6)))\n            data.append (0x80 | (UInt8 (rc & 0x3f)))\n        }\n    }\n    \n    /**\n     * Encodes the button action in the format expected by the client\n     * - Parameter button: The button to encode\n     * - Parameter release: `true` if this is a mouse release event\n     * - Parameter shift: `true` if the shift key is pressed\n     * - Parameter meta: `true` if the meta/alt key is pressed\n     * - Parameter control: `true` if the control key is pressed\n     * - Returns: the encoded value\n     */\n    public func encodeButton (button: Int, release: Bool, shift: Bool, meta: Bool, control: Bool) -> Int\n    {\n        var value: Int\n\n        if release {\n            value = 3\n        } else {\n            switch (button) {\n            case 0:\n                value = 0\n            case 1:\n                value = 1\n            case 2:\n                value = 2\n            case 4:\n                value = 64\n            case 5:\n                value = 65\n            default:\n                value = 0\n            }\n        }\n        if mouseMode.sendsModifiers() {\n            if shift {\n                value |= 4\n            }\n            if meta {\n                value |= 8\n            }\n            if control {\n                value |= 16\n            }\n        }\n        return value\n    }\n    \n    /**\n     * Sends a mouse event for a specific button at the specific location\n     * - Parameter buttonFlags: Button flags encoded in Cb mode.\n     * - Parameter x: X coordinate for the event\n     * - Parameter y: Y coordinate for the event\n     */\n    public func sendEvent (buttonFlags: Int, x: Int, y: Int)\n    {\n        //print (\"got \\(mouseProtocol)\")\n        switch mouseProtocol {\n        case .x10:\n            sendResponse(cc.CSI, \"M\", [UInt8(buttonFlags+32), min (UInt8(255), UInt8(32 + x+1)), min (UInt8(255), UInt8(32+y+1))])\n        case .sgr:\n            let bflags : Int = ((buttonFlags & 3) == 3) ? (buttonFlags & ~3) : buttonFlags\n            let m = ((buttonFlags & 3) == 3) ? \"m\" : \"M\"\n            sendResponse(cc.CSI, \"<\\(bflags);\\(x+1);\\(y+1)\\(m)\")\n        case .urxvt:\n            sendResponse(cc.CSI, \"\\(buttonFlags+32);\\(x+1);\\(y+1)M\");\n        case .utf8:\n            var buffer: [UInt8] = [UInt8 (ascii: \"M\")]\n            encodeMouseUtf(data: &buffer, ch: buttonFlags+32)\n            encodeMouseUtf (data: &buffer, ch: x+33)\n            encodeMouseUtf (data: &buffer, ch: y+33)\n            sendResponse(cc.CSI, buffer)\n        }\n    }\n    \n    /**\n     * Sends a mouse motion event for a specific button at the specific location\n     * - Parameter buttonFlags: Button flags encoded in Cb mode.\n     * - Parameter x: X coordinate for the event\n     * - Parameter y: Y coordinate for the event\n     */\n    public func sendMotion (buttonFlags: Int, x: Int, y: Int)\n    {\n        sendEvent(buttonFlags: buttonFlags+32, x: x, y: y)\n    }\n    \n    static var matchColorCache : [Int:Int] = [:]\n    func matchColor (_ r1: Int, _ g1: Int, _ b1: Int) -> Int32\n    {\n        // TODO\n        abort ()\n    }\n    \n    var terminalTitle: String = \"\"              // The Xterm terminal title\n    var iconTitle: String = \"\"                  // The Xterm minimized window title\n    var terminalTitleStack: [String] = []\n    var terminalIconStack: [String] = []\n    \n    public func setTitle (text: String)\n    {\n        terminalTitle = text\n        tdel?.setTerminalTitle(source: self, title: text)\n    }\n\n    public func setIconTitle (text: String)\n    {\n        iconTitle = text\n        tdel?.setTerminalIconTitle(source: self, title: text)\n    }\n\n    func reverseIndex ()\n    {\n        restrictCursor()\n        if buffer.y == buffer.scrollTop {\n            // possibly move the code below to term.reverseScroll()\n            // test: echo -ne '\\e[1;1H\\e[44m\\eM\\e[0m'\n            // blankLine(true) is xterm/linux behavior\n            let scrollRegionHeight = buffer.scrollBottom - buffer.scrollTop\n            buffer.lines.shiftElements (start: buffer.y + buffer.yBase, count: scrollRegionHeight, offset: 1)\n            buffer.lines [buffer.y + buffer.yBase] = buffer.getBlankLine (attribute: eraseAttr ())\n            updateRange (startLine: buffer.scrollTop, endLine: buffer.scrollBottom)\n        } else if buffer.y > 0 {\n            buffer.y -= 1\n        }\n    }\n    \n    /**\n     * Provides a baseline set of environment variables that would be useful to run the terminal,\n     * you can customzie these accordingly.\n     * - Parameters:\n     *  - termName: desired name for the terminal, if set to nil (the default), it sets it to xterm-256color\n     *  - trueColor: if set to true, sets the COLORTERM variable to truecolor,\n     * - Returns: an array of default environment variables that include TERM set to the specified value, or xterm-256color,\n     * and if trueColor is true, COLORTERM=truecolor, the LANG=en_US.UTF-8 and it mirrors the currently set values\n     * for LOGNAME, USER, DISPLAY, LC_TYPE, USER and HOME.\n     */\n    public static func getEnvironmentVariables (termName: String? = nil, trueColor: Bool = true) -> [String]\n    {\n        var l : [String] = []\n        let t = termName == nil ? \"xterm-256color\" : termName!\n        l.append (\"TERM=\\(t)\")\n        if trueColor {\n            l.append (\"COLORTERM=truecolor\")\n        }\n        \n        // Without this, tools like \"vi\" produce sequences that are not UTF-8 friendly\n        l.append (\"LANG=en_US.UTF-8\")\n        let env = ProcessInfo.processInfo.environment\n        for x in [\"LOGNAME\", \"USER\", \"DISPLAY\", \"LC_TYPE\", \"USER\", \"HOME\" /* \"PATH\" */ ] {\n            if env.keys.contains(x) {\n                l.append (\"\\(x)=\\(env[x]!)\")\n            }\n        }\n        return l\n    }\n    \n    /// Specified the kind of buffer is being requested from the terminal\n    public enum BufferKind {\n        /// The currently active buffer (can be either normal or alt)\n        case active\n        /// The normal buffer, regardless of which buffer is active\n        case normal\n        /// The alternate buffer, regardless of which buffer is active\n        case alt\n    }\n    \n    func bufferFromKind (kind: BufferKind) -> Buffer\n    {\n        switch kind {\n        case .active:\n            return buffers.active\n        case .normal:\n            return buffers.normal\n        case .alt:\n            return buffers.alt\n        }\n    }\n    \n    /// Returns the contents of the specified terminal buffer encoded as UTF8 in the provided Data buffer\n    /// - Parameter kind: which buffer to retrive the data for\n    /// - Parameter encoding: which encoding to use for the returned value, defaults to utf8\n    public func getBufferAsData (kind: BufferKind = .active, encoding: String.Encoding = .utf8) -> Data\n    {\n        var result = Data()\n        \n        let b = bufferFromKind(kind: kind)\n        let newLine = Data([10])\n        for row in 0..<b.lines.count {\n            let bufferLine = b.lines [row]\n            let str = bufferLine.translateToString(trimRight: true)\n            if let encoded = str.data(using: encoding) {\n                result.append (encoded)\n                result.append (newLine)\n            }\n        }\n        return result\n    }\n    \n    /// Returns the text between the specified range\n    ///\n    public func getText (start: Position, end: Position) -> String\n    {\n        let lines = getSelectedLines(p1: start, p2: end)\n        if lines.count == 0 {\n            return \"\"\n        }\n        var r = \"\"\n        for line in lines {\n            r += line.toString()\n        }\n        return r\n    }\n\n    // This version validates the input parameters\n    func getSelectedLines(p1: Position, p2: Position) -> [Line]\n    {\n        var start = p1\n        var end = p2\n        let b = buffer\n        \n        switch Position.compare (start, end) {\n        case .equal:\n            return []\n        case .after:\n            let tmp = start\n            start = end\n            end = tmp\n        case .before:\n            break\n        }\n        if start.row < 0 || start.row > b.lines.count {\n            return []\n        }\n        \n        if end.row >= b.lines.count {\n            end.row = b.lines.count-1\n        }\n        return _getSelectedLines(start, end)\n    }\n    \n    func _getSelectedLines(_ start: Position, _ end: Position) -> [Line]\n    {\n        var lines: [Line] = []\n        let buf = buffer\n        var str = \"\"\n        var currentLine = Line ()\n        lines.append(currentLine)\n        \n        // keep a list of blank lines that we see. if we see content after a group\n        // of blanks, add those blanks but skip all remaining / trailing blanks\n        // these will be blank lines in the selected text output\n        var blanks: [LineFragment] = []\n        \n        func addBlanks () {\n            var lastLine = -1;\n            for b in blanks {\n                if lastLine != -1 && b.line != lastLine {\n                    currentLine = Line ()\n                    lines.append(currentLine)\n                }\n                \n                lastLine = b.line\n                currentLine.add(fragment: b)\n            }\n            blanks = []\n        };\n        \n        // get the first line\n        var bufferLine = buf.lines [start.row]\n        if bufferLine.hasAnyContent() {\n            let str: String = translateBufferLineToString (buffer: buf, line: start.row, start: start.col, end: start.row < end.row ? -1 : end.col)\n            \n            let fragment = LineFragment (text: str, line: start.row, location: start.col, length: str.count)\n            currentLine.add (fragment: fragment)\n        }\n        \n        // get the middle rows\n        var line = start.row + 1\n        var isWrapped = false\n        while line < end.row {\n            bufferLine = buffer.lines [line]\n            isWrapped = bufferLine.isWrapped\n            \n            str = translateBufferLineToString (buffer: buf, line: line, start: 0, end: -1)\n            \n            if bufferLine.hasAnyContent () {\n                // add previously gathered blank fragments\n                addBlanks ()\n                \n                if !isWrapped {\n                    // this line is not a wrapped line, so the\n                    // prior line has a hard linefeed\n                    // add a fragment to that line\n                    currentLine.add (fragment: LineFragment.newLine (line: line - 1))\n                    \n                    // start a new line\n                    currentLine = Line ()\n                    lines.append(currentLine)\n                }\n                \n                // add the text we found to the current line\n                currentLine.add (fragment: LineFragment (text: str, line: line, location: 0, length: str.count))\n            } else {\n                // this line has no content, which means that it's a blank line inserted\n                // somehow, or one of the trailing blank lines after the last actual content\n                // make a note of the line\n                // check that this line is a wrapped line, if so, add a line feed fragment\n                if !isWrapped {\n                    blanks.append (LineFragment.newLine (line: line - 1))\n                }\n                \n                blanks.append(LineFragment (text: str, line: line, location: 0, length: str.count))\n            }\n            \n            line += 1\n        }\n        \n        // get the last row\n        if end.row != start.row {\n            bufferLine = buffer.lines [end.row]\n            if bufferLine.hasAnyContent () {\n                addBlanks ()\n                \n                isWrapped = bufferLine.isWrapped\n                str = translateBufferLineToString (buffer: buf, line: end.row, start: 0, end: end.col)\n                if !isWrapped {\n                    currentLine.add(fragment: LineFragment.newLine (line: line - 1))\n                    currentLine = Line ()\n                    lines.append(currentLine)\n                }\n                \n                currentLine.add (fragment: LineFragment (text: str, line: line, location: 0, length: str.count))\n            }\n        }\n        return lines\n    }\n    \n    func translateBufferLineToString (buffer: Buffer, line: Int, start: Int, end: Int) -> String\n    {\n        buffer.translateBufferLineToString(lineIndex: line, trimRight: true, startCol: start, endCol: end).replacingOccurrences(of: \"\\u{0}\", with: \" \")\n    }\n}\n\n// Default implementations\npublic extension TerminalDelegate {\n    func cursorStyleChanged (source: Terminal, newStyle: CursorStyle)\n    {\n        // Do nothing\n    }\n    \n    func setTerminalTitle (source: Terminal, title: String) {\n        // Do nothing\n    }\n\n    func setTerminalIconTitle (source: Terminal, title: String) {\n        // nothing\n    }\n    \n    func scrolled(source: Terminal, yDisp: Int) {\n        // nothing\n    }\n    \n    func linefeed(source: Terminal) {\n        // nothing\n    }\n    \n    func bufferActivated(source: Terminal) {\n        // nothing\n    }\n    \n    func windowCommand(source: Terminal, command: Terminal.WindowManipulationCommand) -> [UInt8]? {\n        // no special handling\n        return nil\n    }\n    \n    func sizeChanged(source: Terminal) {\n        // nothing\n    }\n    \n    func bell (source: Terminal){\n        // nothing\n    }\n    \n    func isProcessTrusted (source: Terminal) -> Bool {\n        return true\n    }\n    \n    func selectionChanged (source: Terminal){\n        // nothing\n    }\n    \n    func showCursor(source: Terminal) {\n        // nothing\n    }\n\n    func hideCursor(source: Terminal) {\n        // nothing\n    }\n\n    func mouseModeChanged(source: Terminal) {\n    }\n    \n    func hostCurrentDirectoryUpdated (source: Terminal) {\n    }\n    \n    func hostCurrentDocumentUpdated (source: Terminal) {\n    }\n    \n    func colorChanged (source: Terminal, idx: Int?) {\n        \n    }\n    \n    func getColors (source: Terminal) -> (foreground: Color, background: Color)\n    {\n        return (source.foregroundColor, source.backgroundColor)\n    }\n    \n    func setForegroundColor (source: Terminal, color: Color)\n    {\n        source.foregroundColor = color\n    }\n    \n    func setBackgroundColor (source: Terminal, color: Color)\n    {\n        source.backgroundColor = color\n    }\n    \n    func setCursorColor (source: Terminal, color: Color?)\n    {\n        source.cursorColor = color\n    }\n    \n    func iTermContent (source: Terminal, content: ArraySlice<UInt8>) {\n    }\n    \n    func clipboardCopy(source: Terminal, content: Data) {\n    }\n    \n    func notify(source: Terminal, title: String, body: String) {\n    }\n    \n    func createImageFromBitmap (source: Terminal, bytes: inout [UInt8], width: Int, height: Int){\n    }\n\n    func createImage (source: Terminal, data: Data, width: ImageSizeRequest, height: ImageSizeRequest, preserveAspectRatio: Bool) {\n    }    \n}\n"], "buggy_code_start_loc": [708], "buggy_code_end_loc": [2646], "fixing_code_start_loc": [708], "fixing_code_end_loc": [2650], "type": "CWE-94", "message": "SwiftTerm is a Xterm/VT100 Terminal emulator. Prior to commit a94e6b24d24ce9680ad79884992e1dff8e150a31, an attacker could modify the window title via a certain character escape sequence and then insert it back to the command line in the user's terminal, e.g. when the user views a file containing the malicious sequence, which could allow the attacker to execute arbitrary commands. Version a94e6b24d24ce9680ad79884992e1dff8e150a31 contains a patch for this issue. There are no known workarounds available.", "other": {"cve": {"id": "CVE-2022-23465", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-02T23:15:16.617", "lastModified": "2022-12-06T19:48:27.053", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SwiftTerm is a Xterm/VT100 Terminal emulator. Prior to commit a94e6b24d24ce9680ad79884992e1dff8e150a31, an attacker could modify the window title via a certain character escape sequence and then insert it back to the command line in the user's terminal, e.g. when the user views a file containing the malicious sequence, which could allow the attacker to execute arbitrary commands. Version a94e6b24d24ce9680ad79884992e1dff8e150a31 contains a patch for this issue. There are no known workarounds available."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:swiftterm_project:swiftterm:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-12-02", "matchCriteriaId": "BD45629F-297F-4CBD-B140-E2C2045BF815"}]}]}], "references": [{"url": "https://github.com/migueldeicaza/SwiftTerm/commit/a94e6b24d24ce9680ad79884992e1dff8e150a31", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/migueldeicaza/SwiftTerm/security/advisories/GHSA-jq43-q8mx-r7mq", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/migueldeicaza/SwiftTerm/commit/a94e6b24d24ce9680ad79884992e1dff8e150a31"}}