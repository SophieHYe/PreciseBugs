{"buggy_code": ["<?php\n\n##################################################\n#\n# Copyright (c) 2004-2016 OIC Group, Inc.\n#\n# This file is part of Exponent\n#\n# Exponent is free software; you can redistribute\n# it and/or modify it under the terms of the GNU\n# General Public License as published by the Free\n# Software Foundation; either version 2 of the\n# License, or (at your option) any later version.\n#\n# GPL: http://www.gnu.org/licenses/gpl.txt\n#\n##################################################\n/**\n * @subpackage Controllers\n * @package    Modules\n */\nclass navigationController extends expController {\n    public $basemodel_name = 'section';\n    public $useractions = array(\n        'showall' => 'Show Navigation',\n        'breadcrumb' => 'Breadcrumb',\n    );\n//    protected $remove_permissions = array(\n//        'configure',\n//        'create',\n//        'delete',\n//        'edit'\n//    );\n    protected $add_permissions = array(\n        'manage'    => 'Manage',\n        'view'      => \"View Page\"\n    );\n    protected $manage_permissions = array(\n        'move'      => 'Move Page',\n        'remove'    => 'Remove Page',\n        'reparent'    => 'Reparent Page',\n    );\n    public $remove_configs = array(\n        'aggregation',\n        'categories',\n        'comments',\n        'ealerts',\n        'facebook',\n        'files',\n        'pagination',\n        'rss',\n        'tags',\n        'twitter',\n    );  // all options: ('aggregation','categories','comments','ealerts','facebook','files','pagination','rss','tags','twitter',)\n\n    static function displayname() { return gt(\"Navigation\"); }\n\n    static function description() { return gt(\"Places navigation links/menus on the page.\"); }\n\n    static function isSearchable() { return true; }\n\n    function searchName() { return gt('Webpage'); }\n\n    /**\n     * @param null $src\n     * @param array $params\n     *\n     */\n    function __construct($src = null, $params = array())\n    {\n        parent::__construct($src, $params);\n        if (!empty($params['id']))  // we normally throw out the $loc->int EXCEPT with navigation pages\n            $this->loc = expCore::makeLocation($this->baseclassname, $src, $params['id']);\n    }\n\n    public function showall() {\n        global $user, $sectionObj, $sections;\n\n        expHistory::set('viewable', $this->params);\n        $id      = $sectionObj->id;\n        $current = null;\n        // all we need to do is determine the current section\n        $navsections = $sections;\n        if ($sectionObj->parent == -1) {\n            $current = $sectionObj;\n        } else {\n            foreach ($navsections as $section) {\n                if ($section->id == $id) {\n                    $current = $section;\n                    break;\n                }\n            }\n        }\n        assign_to_template(array(\n            'sections'     => $navsections,\n            'current'      => $current,\n            'canManage'    => ((isset($user->is_acting_admin) && $user->is_acting_admin == 1) ? 1 : 0),\n        ));\n    }\n\n    public function breadcrumb() {\n        global $sectionObj;\n\n        expHistory::set('viewable', $this->params);\n        $id      = $sectionObj->id;\n        $current = null;\n        // Show not only the location of a page in the hierarchy but also the location of a standalone page\n        $current = new section($id);\n        if ($current->parent == -1) {  // standalone page\n            $navsections = section::levelTemplate(-1, 0);\n            foreach ($navsections as $section) {\n                if ($section->id == $id) {\n                    $current = $section;\n                    break;\n                }\n            }\n        } else {\n            $navsections = section::levelTemplate(0, 0);\n            foreach ($navsections as $section) {\n                if ($section->id == $id) {\n                    $current = $section;\n                    break;\n                }\n            }\n        }\n        assign_to_template(array(\n            'sections'     => $navsections,\n            'current'      => $current,\n        ));\n    }\n\n    /**\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function navhierarchy($notyui=false) {\n        global $sections;\n\n        $json_array = array();\n        for ($i = 0, $iMax = count($sections); $i < $iMax; $i++) {\n            if ($sections[$i]->depth == 0) {\n                $obj = new stdClass();\n//   \t\t\t\t$obj->id = $sections[$i]->name.$sections[$i]->id;\n                $obj->id   = $sections[$i]->id;\n                $obj->text = $sections[$i]->name;\n                $obj->title = $sections[$i]->page_title;\n                $obj->description = $sections[$i]->description;\n                $obj->new_window = $sections[$i]->new_window;\n                $obj->expFile = $sections[$i]->expFile;\n                $obj->glyph = $sections[$i]->glyph;\n                $obj->glyph_only = $sections[$i]->glyph_only;\n                $obj->type = $sections[$i]->alias_type;\n                if ($sections[$i]->active == 1) {\n                    $obj->url = $sections[$i]->link;\n                    if ($obj->type == 1 && substr($obj->url, 0, 4) != 'http') {\n                        $obj->url = 'http://' . $obj->url;\n                    }\n                } else {\n                    $obj->url     = \"#\";\n                    $obj->onclick = \"onclick: { fn: return false }\";\n                }\n                if ($obj->type == 3) {  // mostly a hack instead of adding more table fields\n                    $obj->width = $sections[$i]->internal_id;\n                    $obj->class = $sections[$i]->external_link;\n                }\n                /*if ($sections[$i]->active == 1) {\n                    $obj->disabled = false;\n                } else {\n                    $obj->disabled = true;\n                }*/\n                //$obj->disabled = true;\n                $obj->itemdata = self::getChildren($i,$notyui);\n                $obj->maxitems = count($obj->itemdata);\n                $obj->maxdepth = 0;\n                foreach ($obj->itemdata as $menu) {\n                    if ($menu->maxdepth > $obj->maxdepth) $obj->maxdepth = $menu->maxdepth;\n                }\n            }\n            $json_array[] = $obj;\n        }\n        return $json_array;\n    }\n\n    /**\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function navtojson() {\n        return json_encode(self::navhierarchy());\n    }\n\n    /**\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function getChildren(&$i, $notyui=false) {\n        global $sections;\n\n        //\t\techo \"i=\".$i.\"<br>\";\n        if ($i + 1 == count($sections)) { // last entry\n            return array();\n        } elseif ($sections[$i]->depth == $sections[$i + 1]->depth) {\n            return array();\n        } else {\n            $ret_depth = $sections[$i]->depth;\n            $i++;\n            $ret_array = array();\n            for ($iMax = count($sections); $i < $iMax; $i++) {\n                // start setting up the objects to return\n                $obj       = new stdClass();\n                $obj->id   = $sections[$i]->id;\n                $obj->text = $sections[$i]->name;\n                $obj->title = $sections[$i]->page_title;\n                $obj->description = $sections[$i]->description;\n                $obj->new_window = $sections[$i]->new_window;\n                $obj->expFile = $sections[$i]->expFile;\n                $obj->glyph = $sections[$i]->glyph;\n                $obj->glyph_only = $sections[$i]->glyph_only;\n                $obj->depth = $sections[$i]->depth;\n                if ($sections[$i]->active == 1) {\n                    $obj->url = $sections[$i]->link;\n                    if ($sections[$i]->alias_type == 1 && substr($obj->url, 0, 4) != 'http') {\n                        $obj->url = 'http://' . $obj->url;\n                    }\n                } else {\n                    $obj->url     = \"#\";\n                    $obj->onclick = \"onclick: { fn: return false }\";\n                }\n                //echo \"i=\".$i.\"<br>\";\n                if (self::hasChildren($i)) {\n                    if ($notyui) {\n                        $obj->itemdata = self::getChildren($i,$notyui);\n                        $obj->maxitems = count($obj->itemdata);\n                        $obj->maxdepth = 0;\n                        foreach ($obj->itemdata as $menu) {\n                            if (!empty($menu->maxdepth)) {\n                                if ($menu->maxdepth > $obj->maxdepth) $obj->maxdepth = $menu->maxdepth;\n                            } else {\n                                if ($menu->depth > $obj->maxdepth) $obj->maxdepth = $menu->depth;\n                            }\n                        }\n                    } else {\n                        $obj->submenu     = new stdClass();\n                        $obj->submenu->id = $sections[$i]->name . $sections[$i]->id;\n                        //echo \"getting children of \".$sections[$i]->name;\n                        $obj->submenu->itemdata = self::getChildren($i,$notyui);\n                        $obj->maxitems = count($obj->submenu->itemdata);\n                        $obj->maxdepth = 0;\n                        foreach ($obj->submenu->itemdata as $menu) {\n                            if (!empty($menu->maxdepth)) {\n                                if ($menu->maxdepth > $obj->maxdepth) $obj->maxdepth = $menu->maxdepth;\n                            } else {\n                                if ($menu->depth > $obj->maxdepth) $obj->maxdepth = $menu->depth;\n                            }\n                        }\n                    }\n                    $ret_array[]            = $obj;\n                } else {\n                    $obj->maxdepth = $obj->depth;\n                    $ret_array[] = $obj;\n                }\n                if (($i + 1) >= count($sections) || $sections[$i + 1]->depth <= $ret_depth) {\n                    return $ret_array;\n                }\n            }\n            return array();\n        }\n    }\n\n    /**\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function hasChildren($i) {\n        global $sections;\n\n        if (($i + 1) >= count($sections)) return false;\n        return ($sections[$i]->depth < $sections[$i + 1]->depth) ? true : false;\n    }\n\n    /** exdoc\n     * Creates a location object, based off of the three arguments passed, and returns it.\n     *\n     * @return array\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function initializeNavigation() {\n        $sections = section::levelTemplate(0, 0);\n        return $sections;\n    }\n\n    /**\n     * returns all the section's children\n     *\n     * @static\n     *\n     * @param int   $parent top level parent id\n     * @param int   $depth  variable to hold level of recursion\n     * @param array $parents\n     *\n     * @return array\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function levelTemplate($parent, $depth = 0, $parents = array()) {\n        global $user;\n\n        if ($parent != 0) $parents[] = $parent;\n        $nodes = array();\n        $cache = expSession::getCacheValue('navigation');\n        $sect = new section();\n        if (!isset($cache['kids'][$parent])) {\n            $kids = $sect->find('all','parent=' . $parent);\n            $cache['kids'][$parent] = $kids;\n            expSession::setCacheValue('navigation', $cache);\n        } else {\n            $kids = $cache['kids'][$parent];\n        }\n        $kids = expSorter::sort(array('array' => $kids, 'sortby' => 'rank', 'order' => 'ASC'));\n        for ($i = 0, $iMax = count($kids); $i < $iMax; $i++) {\n            $child = $kids[$i];\n            //foreach ($kids as $child) {\n            if ($child->public == 1 || expPermissions::check('view', expCore::makeLocation('navigation', '', $child->id))) {\n                $child->numParents    = count($parents);\n                $child->depth         = $depth;\n                $child->first         = ($i == 0 ? 1 : 0);\n                $child->last          = ($i == count($kids) - 1 ? 1 : 0);\n                $child->parents       = $parents;\n                $child->canManage     = (isset($user->is_acting_admin) && $user->is_acting_admin == 1 ? 1 : 0);\n                $child->canManageRank = $child->canManage;\n                if (!isset($child->sef_name)) {\n                    $child->sef_name = '';\n                }\n                // Generate the link attribute base on alias type.\n                if ($child->alias_type == 1) {\n                    // External link.  Set the link to the configured website URL.\n                    // This is guaranteed to be a full URL because of the\n                    // section::updateExternalAlias() method in models-1/section.php\n                    $child->link = $child->external_link;\n                } else if ($child->alias_type == 2) {\n                    // Internal link.\n                    // Need to check and see if the internal_id is pointing at an external link.\n//                    $dest = $db->selectObject('section', 'id=' . $child->internal_id);\n                    $dest = $sect->find('first','id=' . $child->internal_id);\n                    if (!empty($dest->alias_type) && $dest->alias_type == 1) {\n                        // This internal alias is pointing at an external alias.\n                        // Use the external_link of the destination section for the link\n                        $child->link = $dest->external_link;\n                    } else {\n                        // Pointing at a regular section.  This is guaranteed to be\n                        // a regular section because aliases cannot be turned into sections,\n                        // (and vice-versa) and because the section::updateInternalLink\n                        // does 'alias to alias' dereferencing before the section is saved\n                        // (see models-1/section.php)\n                        //added by Tyler to pull the descriptions through for the children view\n                        $child->description = !empty($dest->description) ? $dest->description : '';\n                        $child->link        = expCore::makeLink(array('section' => $child->internal_id));\n                    }\n                } else {\n                    // Normal link, alias_type == 0.  Just create the URL from the section's id.\n                    $child->link = expCore::makeLink(array('section' => $child->id), '', $child->sef_name);\n                }\n                //$child->numChildren = $db->countObjects('section','parent='.$child->id);\n                $nodes[] = $child;\n                $nodes   = array_merge($nodes, section::levelTemplate($child->id, $depth + 1, $parents));\n            }\n        }\n        return $nodes;\n    }\n\n    /**\n     * Returns a flat representation of the full site hierarchy.\n     *\n     * @param int    $parent         top level parent id\n     * @param int    $depth          variable to hold level of recursion\n     * @param array  $ignore_ids     array of pages to ignore\n     * @param bool   $full           include a 'top' level entry\n     * @param string $perm           permission level to build list\n     * @param bool   $addstandalones should we add the stand-alone pages also\n     * @param bool   $addinternalalias\n     *\n     * @return array\n     * @deprecated 2.3.4 moved to section model, HOWEVER still used in theme config\n     */\n    public static function levelDropdownControlArray($parent, $depth = 0, $ignore_ids = array(), $full = false, $perm = 'view', $addstandalones = false, $addinternalalias = true) {\n        global $db;\n\n        $ar = array();\n        if ($parent == 0 && $full) {\n            $ar[0] = '&lt;' . gt('Top of Hierarchy') . '&gt;';\n        }\n        if ($addinternalalias) {\n            $intalias = '';\n        } else {\n            $intalias = ' AND alias_type != 2';\n        }\n        $nodes = $db->selectObjects('section', 'parent=' . $parent . $intalias, 'rank');\n        foreach ($nodes as $node) {\n            if ((($perm == 'view' && $node->public == 1) || expPermissions::check($perm, expCore::makeLocation('navigation', '', $node->id))) && !in_array($node->id, $ignore_ids)) {\n                if ($node->active == 1) {\n                    $text = str_pad('', ($depth + ($full ? 1 : 0)) * 3, '.', STR_PAD_LEFT) . $node->name;\n                } else {\n                    $text = str_pad('', ($depth + ($full ? 1 : 0)) * 3, '.', STR_PAD_LEFT) . '(' . $node->name . ')';\n                }\n                $ar[$node->id] = $text;\n                foreach (self::levelDropdownControlArray($node->id, $depth + 1, $ignore_ids, $full, $perm, $addstandalones, $addinternalalias) as $id => $text) {\n                    $ar[$id] = $text;\n                }\n            }\n        }\n        if ($addstandalones && $parent == 0) {\n            $sections = $db->selectObjects('section', 'parent=-1');\n            foreach ($sections as $node) {\n                if ((($perm == 'view' && $node->public == 1) || expPermissions::check($perm, expCore::makeLocation('navigation', '', $node->id))) && !in_array($node->id, $ignore_ids)) {\n                    if ($node->active == 1) {\n                        $text = str_pad('', ($depth + ($full ? 1 : 0)) * 3, '.', STR_PAD_LEFT) . $node->name;\n                    } else {\n                        $text = str_pad('', ($depth + ($full ? 1 : 0)) * 3, '.', STR_PAD_LEFT) . '(' . $node->name . ')';\n                    }\n                    $ar[$node->id] = '(' . gt('Standalone') . ') ' . $text;\n                }\n            }\n//            $ar = array_merge($ar,$sections);\n        }\n        return $ar;\n    }\n\n    /**\n     * add all module items to search index\n     *\n     * @return int\n     */\n    function addContentToSearch() {\n        global $db;\n\n        //global $sections;\n        //\t\tglobal $router;\n//        $db->delete('search', \"ref_module='navigation' AND ref_type='section'\");\n        $db->delete('search', \"ref_module='\".$this->baseclassname.\"' AND ref_type='section'\");\n        // this now ensures we get internal pages, instead of relying on the global $sections, which does not.\n        $sections = $db->selectObjects('section', 'active=1');\n        foreach ($sections as $section) {\n            $search_record = new stdClass();\n//            $search_record->category = 'Webpages';\n//            $search_record->ref_module = 'navigationController';\n//            $search_record->ref_type = 'section';\n//            $search_record->ref_module  = $this->classname;\n            $search_record->ref_module  = $this->baseclassname;\n            $search_record->category    = $this->searchName();\n            $search_record->ref_type    = $this->searchCategory();\n            $search_record->original_id = $section->id;\n            $search_record->title       = $section->name;\n            //$search_record->view_link = $router->buildUrlByPageId($section->id);\n            $link = str_replace(URL_FULL, '', makeLink(array('section' => $section->id)));\n            if ($link . '/' == URL_FULL) $link = '';\n            $search_record->view_link = $link;\n            $search_record->body      = $section->description;\n            $search_record->keywords  = $section->keywords;\n            // now we're going to grab all the textmodules on this page and build the body for the page based off the content\n            // of all the text module added together.\n            $loc = expCore::makeLocation('text');\n            $controllername = 'text';\n            foreach ($db->selectObjects('sectionref', \"module='\" . $controllername . \"' AND section=\" . $section->id) as $module) {\n                $loc->src   = $module->source;\n//                $controller = new $controllername();\n                $controller = expModules::getController($controllername);\n                $textitems  = $db->selectObjects($controller->model_table, \"location_data='\" . serialize($loc) . \"'\");\n                foreach ($textitems as $textitem) {\n                    if (!empty($textitem)) {\n                        $search_record->body .= ' ' . search::removeHTML($textitem->body) . ' ';\n                        $search_record->keywords .= \" \" . $textitem->title;\n                    }\n                }\n            }\n            $db->insertObject($search_record, 'search');\n        }\n        return count($sections);\n    }\n\n    /**\n     * Retrieve either the entire hierarchy, or a subset of the hierarchy, as an array suitable for use\n     * in a dropdowncontrol.  This is used primarily by the section datatype for moving and adding\n     * sections to specific parts of the site hierarchy.\n     *\n     * @param int   $parent     The id of the subtree parent.  If passed as 0 (the default), the entire subtree is parsed.\n     * @param int   $depth\n     * @param int   $default\n     * @param array $ignore_ids a value-array of IDs to be ignored when generating the list.  This is used\n     *                          when moving a section, since a section cannot be made a subsection of itself or any of its subsections.\n     *\n     * @return string\n     */\n    function levelShowDropdown($parent, $depth = 0, $default = 0, $ignore_ids = array()) {\n        global $db;\n\n        $html = '';\n        $nodes = $db->selectObjects('section', 'parent=' . $parent, 'rank');\n//\t\t$nodes = expSorter::sort(array('array'=>$nodes,'sortby'=>'rank', 'order'=>'ASC'));\n        foreach ($nodes as $node) {\n            if (($node->public == 1 || expPermissions::check('view', expCore::makeLocation('navigation', '', $node->id))) && !in_array($node->id, $ignore_ids)) {\n                $html .= '<option value=\"' . $node->id . '\" ';\n                if ($default == $node->id) $html .= 'selected';\n                $html .= '>';\n                if ($node->active == 1) {\n                    $html .= str_pad('', $depth * 3, '.', STR_PAD_LEFT) . $node->name;\n                } else {\n                    $html .= str_pad('', $depth * 3, '.', STR_PAD_LEFT) . '(' . $node->name . ')';\n                }\n                $html .= '</option>';\n                $html .= self::levelShowDropdown($node->id, $depth + 1, $default, $ignore_ids);\n            }\n        }\n        return $html;\n    }\n\n    /**\n     * recursively lists the template hierarchy\n     *\n     * @static\n     *\n     * @param int $parent top level parent id\n     * @param int $depth  variable to hold level of recursion\n     *\n     * @return array\n     * @deprecated 2.0.0 this only for deprecated templates\n     */\n    public static function getTemplateHierarchyFlat($parent, $depth = 1) {\n        global $db;\n\n        $arr  = array();\n        $kids = $db->selectObjects('section_template', 'parent=' . $parent, 'rank');\n//\t\t$kids = expSorter::sort(array('array'=>$kids,'sortby'=>'rank', 'order'=>'ASC'));\n        for ($i = 0, $iMax = count($kids); $i < $iMax; $i++) {\n            $page        = $kids[$i];\n            $page->depth = $depth;\n            $page->first = ($i == 0 ? 1 : 0);\n            $page->last  = ($i == count($kids) - 1 ? 1 : 0);\n            $arr[]       = $page;\n            $arr         = array_merge($arr, self::getTemplateHierarchyFlat($page->id, $depth + 1));\n        }\n        return $arr;\n    }\n\n    /**\n     * @deprecated 2.0.0 this only for deprecated templates\n     */\n    public static function process_section($section, $template) {\n        global $db;\n\n        if (!is_object($template)) {\n            $template          = $db->selectObject('section_template', 'id=' . $template);\n            $section->subtheme = $template->subtheme;\n            $db->updateObject($section, 'section');\n        }\n        $prefix = '@st' . $template->id;\n        $refs   = $db->selectObjects('sectionref', \"source LIKE '$prefix%'\");\n        // Copy all modules and content for this section\n        foreach ($refs as $ref) {\n            $src = substr($ref->source, strlen($prefix)) . $section->id;\n            if (call_user_func(array($ref->module, 'hasContent'))) {\n                $oloc = expCore::makeLocation($ref->module, $ref->source);\n                $nloc = expCore::makeLocation($ref->module, $src);\n                if ($ref->module != \"container\") {\n                    call_user_func(array($ref->module, 'copyContent'), $oloc, $nloc);\n                } else {\n                    call_user_func(array($ref->module, 'copyContent'), $oloc, $nloc, $section->id);\n                }\n            }\n        }\n        // Grab sub pages\n        foreach ($db->selectObjects('section_template', 'parent=' . $template->id) as $t) {\n            self::process_subsections($section, $t);\n        }\n\n    }\n\n    /**\n     * @deprecated 2.0.0 this only for deprecated templates\n     */\n    function process_subsections($parent_section, $subtpl) {\n        global $db, $router;\n\n        $section              = new stdClass();\n        $section->parent      = $parent_section->id;\n        $section->name        = $subtpl->name;\n        $section->sef_name    = $router->encode($section->name);\n        $section->subtheme    = $subtpl->subtheme;\n        $section->active      = $subtpl->active;\n        $section->public      = $subtpl->public;\n        $section->rank        = $subtpl->rank;\n        $section->page_title  = $subtpl->page_title;\n        $section->keywords    = $subtpl->keywords;\n        $section->description = $subtpl->description;\n        $section->id          = $db->insertObject($section, 'section');\n        self::process_section($section, $subtpl);\n    }\n\n    /**\n     * Delete page and send its contents to the recycle bin\n     *\n     * @param $parent\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function deleteLevel($parent) {\n        global $db;\n\n        $kids = $db->selectObjects('section', 'parent=' . $parent);\n        foreach ($kids as $kid) {\n            self::deleteLevel($kid->id);\n        }\n        $secrefs = $db->selectObjects('sectionref', 'section=' . $parent);\n        foreach ($secrefs as $secref) {\n            $loc = expCore::makeLocation($secref->module, $secref->source, $secref->internal);\n            recyclebin::sendToRecycleBin($loc, $parent);\n            //FIXME if we delete the module & sectionref the module completely disappears\n//            if (class_exists($secref->module)) {\n//                $modclass = $secref->module;\n//                //FIXME: more module/controller glue code\n//                if (expModules::controllerExists($modclass)) {\n//                    $modclass = expModules::getControllerClassName($modclass);\n//                    $mod = new $modclass($loc->src);\n//                    $mod->delete_instance();\n//                } else {\n//                    $mod = new $modclass();\n//                    $mod->deleteIn($loc);\n//                }\n//            }\n        }\n//        $db->delete('sectionref', 'section=' . $parent);\n        $db->delete('section', 'parent=' . $parent);\n    }\n\n    /**\n     * Move content page and its children to stand-alones\n     *\n     * @param $parent\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function removeLevel($parent) {\n        global $db;\n\n        $kids = $db->selectObjects('section', 'parent=' . $parent);\n        foreach ($kids as $kid) {\n            $kid->parent = -1;\n            $db->updateObject($kid, 'section');\n            self::removeLevel($kid->id);\n        }\n    }\n\n    /**\n     * Check for cascading page view permission, esp. if not public\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function canView($section) {\n        global $db;\n\n        if ($section == null) {\n            return false;\n        }\n        if ($section->public == 0) {\n            // Not a public section.  Check permissions.\n            return expPermissions::check('view', expCore::makeLocation('navigation', '', $section->id));\n        } else { // Is public.  check parents.\n            if ($section->parent <= 0) {\n                // Out of parents, and since we are still checking, we haven't hit a private section.\n                return true;\n            } else {\n                $s = $db->selectObject('section', 'id=' . $section->parent);\n                return self::canView($s);\n            }\n        }\n    }\n\n    /**\n     * Check to see if page is public with cascading\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function isPublic($s) {\n        if ($s == null) {\n            return false;\n        }\n        while ($s->public && $s->parent > 0) {\n            $s = new section($s->parent);\n        }\n        $lineage = (($s->public) ? 1 : 0);\n        return $lineage;\n    }\n\n    public static function canManageStandalones() {\n        global $user;\n\n        if ($user->isAdmin()) return true;\n        $standalones = section::levelTemplate(-1, 0);\n        //\t\t$canmanage = false;\n        foreach ($standalones as $standalone) {\n            $loc = expCore::makeLocation('navigation', '', $standalone->id);\n            if (expPermissions::check('manage', $loc)) return true;\n        }\n        return false;\n    }\n\n    /**\n     * Reassign permissions based on a check/change in menu/page hierarchy\n     *\n     * @static\n     *\n     * @param $id\n     */\n    public static function checkForSectionalAdmins($id) {\n        global $db;\n\n        $section = $db->selectObject('section', 'id=' . $id);\n        $branch  = section::levelTemplate($id, 0);\n        array_unshift($branch, $section);\n        $allusers  = array();\n        $allgroups = array();\n        while ($section->parent > 0) {\n            //\t\t\t$ploc = expCore::makeLocation('navigationController', null, $section);\n            $allusers  = array_merge($allusers, $db->selectColumn('userpermission', 'uid', \"permission='manage' AND module='navigation' AND internal=\" . $section->parent));\n            $allgroups = array_merge($allgroups, $db->selectColumn('grouppermission', 'gid', \"permission='manage' AND module='navigation' AND internal=\" . $section->parent));\n            $section   = $db->selectObject('section', 'id=' . $section->parent);\n        }\n        foreach ($branch as $section) {\n            $sloc = expCore::makeLocation('navigation', null, $section->id);\n            // remove any manage permissions for this page and it's children\n            // $db->delete('userpermission', \"module='navigationController' AND internal=\".$section->id);\n            // $db->delete('grouppermission', \"module='navigationController' AND internal=\".$section->id);\n            foreach ($allusers as $uid) {\n                $u = user::getUserById($uid);\n                expPermissions::grant($u, 'manage', $sloc);\n            }\n            foreach ($allgroups as $gid) {\n                $g = group::getGroupById($gid);\n                expPermissions::grantGroup($g, 'manage', $sloc);\n            }\n        }\n    }\n\n    function manage() {\n        global $db, $router, $user;\n\n        expHistory::set('manageable', $router->params);\n        assign_to_template(array(\n            'canManageStandalones' => self::canManageStandalones(),\n            'sasections'           => $db->selectObjects('section', 'parent=-1'),\n            'user'                 => $user,\n//            'canManagePagesets'    => $user->isAdmin(),\n//            'templates'            => $db->selectObjects('section_template', 'parent=0'),\n        ));\n    }\n\n    public function manage_sitemap() {\n        global $db, $user, $sectionObj, $sections;\n\n        expHistory::set('viewable', $this->params);\n        $id      = $sectionObj->id;\n        $current = null;\n        // all we need to do is determine the current section\n        $navsections = $sections;\n        if ($sectionObj->parent == -1) {\n            $current = $sectionObj;\n        } else {\n            foreach ($navsections as $section) {\n                if ($section->id == $id) {\n                    $current = $section;\n                    break;\n                }\n            }\n        }\n        assign_to_template(array(\n            'sasections'   => $db->selectObjects('section', 'parent=-1'),\n            'sections'     => $navsections,\n            'current'      => $current,\n            'canManage'    => ((isset($user->is_acting_admin) && $user->is_acting_admin == 1) ? 1 : 0),\n        ));\n    }\n\n    /**\n     * Ajax request for specific pages as json date to yui tree\n     */\n    public static function returnChildrenAsJSON() {\n        global $db;\n\n        //$nav = section::levelTemplate(intval($_REQUEST['id'], 0));\n        $id         = isset($_REQUEST['id']) ? intval($_REQUEST['id']) : 0;\n        $nav        = $db->selectObjects('section', 'parent=' . $id, 'rank');\n        //FIXME $manage_all is moot w/ cascading perms now?\n        $manage_all = false;\n        if (expPermissions::check('manage', expCore::makeLocation('navigation', '', $id))) {\n            $manage_all = true;\n        }\n        //FIXME recode to use foreach $key=>$value\n        $navcount = count($nav);\n        for ($i = 0; $i < $navcount; $i++) {\n            if ($manage_all || expPermissions::check('manage', expCore::makeLocation('navigation', '', $nav[$i]->id))) {\n                $nav[$i]->manage = 1;\n                $view = true;\n            } else {\n                $nav[$i]->manage = 0;\n                $view = $nav[$i]->public ? true : expPermissions::check('view', expCore::makeLocation('navigation', '', $nav[$i]->id));\n            }\n            $nav[$i]->link = expCore::makeLink(array('section' => $nav[$i]->id), '', $nav[$i]->sef_name);\n            if (!$view) unset($nav[$i]);\n        }\n        $nav= array_values($nav);\n//        $nav[$navcount - 1]->last = true;\n        if (count($nav)) $nav[count($nav) - 1]->last = true;\n//        echo expJavascript::ajaxReply(201, '', $nav);\n        $ar = new expAjaxReply(201, '', $nav);\n        $ar->send();\n    }\n\n    /**\n     * Ajax request for all pages as json date to jstree\n     */\n    public static function returnChildrenAsJSON2() {\n        global $db;\n\n        $icons = array(\n            0 => 'addpage',\n            1 => 'addextpage',\n            2 => 'addintpage',\n            3 => 'addfreeform',\n        );\n\n        $navs        = $db->selectObjects('section', 'parent!=-1', 'rank');\n        foreach ($navs as $i=>$nav) {\n            $navs[$i]->parent = $nav->parent?$nav->parent:'#';\n            $navs[$i]->text = $nav->name;\n            $navs[$i]->icon = $icons[$nav->alias_type];\n            if (!$nav->active) {\n                $navs[$i]->icon .= ' inactive';\n                $attr = new stdClass();\n                $attr->class = 'inactive';  // class to obscure elements\n                $navs[$i]->a_attr = $attr;\n            }\n            if (expPermissions::check('manage', expCore::makeLocation('navigation', '', $navs[$i]->id))) {\n                $navs[$i]->manage = 1;\n                $view = true;\n            } else {\n                $navs[$i]->manage = 0;\n                $navs[$i]->state->disabled = true;\n                $view = $navs[$i]->public ? true : expPermissions::check('view', expCore::makeLocation('navigation', '', $navs[$i]->id));\n            }\n            $navs[$i]->link = expCore::makeLink(array('section' => $navs[$i]->id), '', $navs[$i]->sef_name);\n            if (!$view) {\n//                unset($navs[$i]);  //FIXME this breaks jstree if we remove a parent and not the child\n                $attr = new stdClass();\n                $attr->class = 'hidden';  // bs3 class to hide elements\n                $navs[$i]->li_attr = $attr;\n            }\n        }\n        $navs= array_values($navs);\n//        header('Content-Type: application/json; charset=utf8');\n\t\techo json_encode($navs);\n//        echo expJavascript::ajaxReply(201, '', $navs);\n        exit;\n    }\n\n    /**\n     * Ajax function to reorder page hierarchy from yui tree control\n     */\n    public static function DragnDropReRank() {\n        global $db, $router;\n\n        $move   = $router->params['move'];\n        $target = $router->params['target'];\n        $type   = $router->params['type'];\n        $targSec = $db->selectObject(\"section\",\"id=\".$target);\n//        $targSec  = new section($target);\n        $check_id = $targSec->parent;\n        $moveSec = $db->selectObject(\"section\",\"id=\".$move);\n//        $moveSec = new section($move);\n\n        // dropped on top of page\n        if ($type == \"append\") {\n            //save the old parent in case we are changing the depth of the moving section\n            $oldParent = $moveSec->parent;\n            //assign the parent of the moving section to the ID of the target section\n            $moveSec->parent = $targSec->id;\n            //set the rank of the moving section to 0 since it will appear first in the new order\n            $moveSec->rank = 1;\n            //select all children currently of the parent we're about to append to\n            $targSecChildren = $db->selectObjects(\"section\", \"parent=\" . $targSec->id . \" ORDER BY rank\");\n            //update the ranks of the children to +1 higher to accommodate our new rank 0 section being moved in.\n            $newrank = 1;\n            foreach ($targSecChildren as $value) {\n                if ($value->id != $moveSec->id) {\n                    $value->rank = $newrank;\n                    $db->updateObject($value, 'section');\n                    $newrank++;\n                }\n            }\n            $db->updateObject($moveSec, 'section');\n            if ($oldParent != $moveSec->parent) {\n                //we need to re-rank the children of the parent that the miving section has just left\n                $childOfLastMove = $db->selectObjects(\"section\", \"parent=\" . $oldParent . \" ORDER BY rank\");\n                for ($i = 0, $iMax = count($childOfLastMove); $i < $iMax; $i++) {\n                    $childOfLastMove[$i]->rank = $i;\n                    $db->updateObject($childOfLastMove[$i], 'section');\n                }\n\n            }\n//            echo $moveSec->name . \" was appended to \" . $targSec->name;\n\n        } elseif ($type == \"after\") {  // dropped between (after) pages\n            if ($targSec->parent == $moveSec->parent) {\n                //are we moving up...\n                if ($targSec->rank < $moveSec->rank) {\n                    $moveSec->rank    = $targSec->rank + 1;\n                    $moveNextSiblings = $db->selectObjects(\"section\", \"id!=\" . $moveSec->id . \" AND parent=\" . $targSec->parent . \" AND rank>\" . $targSec->rank . \" ORDER BY rank\");\n                    $rerank           = $moveSec->rank + 1;\n                    foreach ($moveNextSiblings as $value) {\n                        if ($value->id != $moveSec->id) {\n                            $value->rank = $rerank;\n                            $db->updateObject($value, 'section');\n                            $rerank++;\n                        }\n                    }\n                    $db->updateObject($targSec, 'section');\n//                    $targSec->update();\n                    $db->updateObject($moveSec, 'section');\n//                    $moveSec->update();\n                    //or are we moving down...\n                } else {\n                    $targSec->rank        = $targSec->rank - 1;\n                    $moveSec->rank        = $targSec->rank + 1;\n                    $movePreviousSiblings = $db->selectObjects(\"section\", \"id!=\" . $moveSec->id . \" AND parent=\" . $targSec->parent . \" AND rank<=\" . $targSec->rank . \" ORDER BY rank\");\n                    $rerank               = 1;\n                    foreach ($movePreviousSiblings as $value) {\n                        if ($value->id != $moveSec->id) {\n                            $value->rank = $rerank;\n                            $db->updateObject($value, 'section');\n                            $rerank++;\n                        }\n                    }\n                    $db->updateObject($targSec, 'section');\n//                    $targSec->update();\n                    $db->updateObject($moveSec, 'section');\n//                    $moveSec->update();\n                }\n            } else {  // 'before', is this used?\n                //store ranks from the depth we're moving from.  Used to re-rank the level depth the moving section is moving from.\n                $oldRank   = $moveSec->rank;\n                $oldParent = $moveSec->parent;\n                //select all children of the target sections parent with a rank higher than it's own\n                $moveNextSiblings = $db->selectObjects(\"section\", \"parent=\" . $targSec->parent . \" AND rank>\" . $targSec->rank . \" ORDER BY rank\");\n                //update moving sections rank and parent\n                $moveSec->rank   = $targSec->rank + 1;\n                $moveSec->parent = $targSec->parent;\n                //$rerank=$moveSec->rank+1;\n                foreach ($moveNextSiblings as $value) {\n                    $value->rank = $value->rank + 1;\n                    $db->updateObject($value, 'section');\n                }\n                $db->updateObject($moveSec, 'section');\n                //handle re-ranking of previous parent\n                $oldSiblings = $db->selectObjects(\"section\", \"parent=\" . $oldParent . \" AND rank>\" . $oldRank . \" ORDER BY rank\");\n                $rerank      = 1;\n                foreach ($oldSiblings as $value) {\n                    if ($value->id != $moveSec->id) {\n                        $value->rank = $rerank;\n                        $db->updateObject($value, 'section');\n                        $rerank++;\n                    }\n                }\n                if ($oldParent != $moveSec->parent) {\n                    //we need to re-rank the children of the parent that the moving section has just left\n                    $childOfLastMove = $db->selectObjects(\"section\", \"parent=\" . $oldParent . \" ORDER BY rank\");\n                    for ($i = 0, $iMax = count($childOfLastMove); $i < $iMax; $i++) {\n                        $childOfLastMove[$i]->rank = $i;\n                        $db->updateObject($childOfLastMove[$i], 'section');\n                    }\n                }\n            }\n        }\n        self::checkForSectionalAdmins($move);\n        expSession::clearAllUsersSessionCache('navigation');\n    }\n\n    /**\n     * Ajax function to reorder page hierarchy from jstree control\n     */\n    public static function DragnDropReRank2() {\n        global $router, $db;\n\n        $id = $router->params['id'];\n        $page = new section($id);\n        $old_rank = $page->rank;\n        $old_parent = $page->parent;\n        $new_rank = $router->params['position'] + 1;  // rank\n        $new_parent = intval($router->params['parent']);\n\n        $db->decrement($page->tablename, 'rank', 1, 'rank>' . $old_rank . ' AND parent=' . $old_parent);  // close in hole\n        $db->increment($page->tablename, 'rank', 1, 'rank>=' . $new_rank . ' AND parent=' . $new_parent);  // make room\n\n        $params = array();\n        $params['parent'] = $new_parent;\n        $params['rank'] = $new_rank;\n        $page->update($params);\n\n        self::checkForSectionalAdmins($id);\n        expSession::clearAllUsersSessionCache('navigation');\n    }\n\n    function edit_section() {\n        global $db, $user;\n\n        $parent = new section($this->params['parent']);\n        if (empty($parent->id)) $parent->id = 0;\n        assign_to_template(array(\n            'haveStandalone'  => ($db->countObjects('section', 'parent=-1') && $parent->id >= 0),\n            'parent'          => $parent,\n            'isAdministrator' => $user->isAdmin(),\n        ));\n    }\n\n    function edit_contentpage() {\n        //FIXME we come here for new/edit content/standalone pages\n        // FIXME: Allow non-administrative users to manage certain parts of the section hierarchy.\n        //if ($user->is_acting_admin == 1 /*TODO: section admin*/) {\n//        $section = null;\n        $section = new stdClass();\n        if (isset($this->params['id'])) {\n            // Check to see if an id was passed in get.  If so, retrieve that section from\n            // the database, and perform an edit on it.\n            $section  = $this->section->find($this->params['id']);\n        } elseif (isset($this->params['parent'])) {\n            // The isset check is merely a precaution.  This action should\n            // ALWAYS be invoked with a parent or id value.\n            $section  = new section($this->params);\n        } else {\n            notfoundController::handle_not_found();\n            exit;\n        }\n        if (!empty($section->id)) {\n            $check_id = $section->id;\n        } else {\n            $check_id = $section->parent;\n        }\n        if (expPermissions::check('manage', expCore::makeLocation('navigation', '', $check_id))) {\n            if (empty($section->id)) {\n                $section->active = 1;\n                $section->public = 1;\n                if (!isset($section->parent)) {\n                    // This is another precaution.  The parent attribute\n                    // should ALWAYS be set by the caller.\n                    //FJD - if that's the case, then we should die.\n                    notfoundController::handle_not_authorized();\n                    exit;\n                    //$section->parent = 0;\n                }\n            }\n            assign_to_template(array(\n                'section' => $section,\n                'glyphs' => self::get_glyphs(),\n            ));\n        } else {  // User does not have permission to manage sections.  Throw a 403\n            notfoundController::handle_not_authorized();\n        }\n    }\n\n    private static function get_glyphs() {\n        if (bs()) {\n            require_once(BASE . 'external/font-awesome.class.php');\n            $fa = new Smk_FontAwesome;\n            if (bs3()) {\n                $icons = $fa->getArray(BASE . 'external/font-awesome4/css/font-awesome.css');\n                $icons = $fa->sortByName($icons);\n                return $fa->nameGlyph($icons);\n            } elseif (bs2()) {\n                expCSS::auto_compile_less(\n                    'external/font-awesome/less/font-awesome.less',\n                    'external/font-awesome/css/font-awesome.css'\n                ); // font-awesome is included within bootstrap2, but not as a separate .css file\n                $icons = $fa->getArray(BASE . 'external/font-awesome/css/font-awesome.css', 'icon-');\n                return $fa->nameGlyph($icons, 'icon-');\n            }\n        } else {\n            return array();\n        }\n    }\n\n    function edit_internalalias() {\n        $section = isset($this->params['id']) ? $this->section->find($this->params['id']) : new section($this->params);\n        if ($section->parent == -1) {\n            notfoundController::handle_not_found();\n            exit;\n        } // doesn't work for standalone pages\n        if (empty($section->id)) {\n            $section->public = 1;\n            if (!isset($section->parent)) {\n                // This is another precaution.  The parent attribute\n                // should ALWAYS be set by the caller.\n                //FJD - if that's the case, then we should die.\n                notfoundController::handle_not_authorized();\n                exit;\n                //$section->parent = 0;\n            }\n        }\n        assign_to_template(array(\n            'section' => $section,\n            'glyphs' => self::get_glyphs(),\n        ));\n    }\n\n    function edit_freeform() {\n        $section = isset($this->params['id']) ? $this->section->find($this->params['id']) : new section($this->params);\n        if ($section->parent == -1) {\n            notfoundController::handle_not_found();\n            exit;\n        } // doesn't work for standalone pages\n        if (empty($section->id)) {\n            $section->public = 1;\n            if (!isset($section->parent)) {\n                // This is another precaution.  The parent attribute\n                // should ALWAYS be set by the caller.\n                //FJD - if that's the case, then we should die.\n                notfoundController::handle_not_authorized();\n                exit;\n                //$section->parent = 0;\n            }\n        }\n        assign_to_template(array(\n            'section' => $section,\n            'glyphs' => self::get_glyphs(),\n        ));\n    }\n\n    function edit_externalalias() {\n        $section = isset($this->params['id']) ? $this->section->find($this->params['id']) : new section($this->params);\n        if ($section->parent == -1) {\n            notfoundController::handle_not_found();\n            exit;\n        } // doesn't work for standalone pages\n        if (empty($section->id)) {\n            $section->public = 1;\n            if (!isset($section->parent)) {\n                // This is another precaution.  The parent attribute\n                // should ALWAYS be set by the caller.\n                //FJD - if that's the case, then we should die.\n                notfoundController::handle_not_authorized();\n                exit;\n                //$section->parent = 0;\n            }\n        }\n        assign_to_template(array(\n            'section' => $section,\n            'glyphs' => self::get_glyphs(),\n        ));\n    }\n\n    function update() {\n        parent::update();\n        expSession::clearAllUsersSessionCache('navigation');\n    }\n\n    function move_standalone() {\n        expSession::clearAllUsersSessionCache('navigation');\n        assign_to_template(array(\n            'parent' => $this->params['parent'],\n        ));\n    }\n\n    /**\n     * Move standalone back to hierarchy\n     *\n     */\n    function reparent_standalone() {\n        $standalone = $this->section->find($this->params['page']);\n        if ($standalone) {\n            $standalone->parent = $this->params['parent'];\n            $standalone->update();\n            expSession::clearAllUsersSessionCache('navigation');\n            expHistory::back();\n        } else {\n            notfoundController::handle_not_found();\n        }\n    }\n\n    /**\n     * Move content page to standalones\n     *\n     */\n    function remove() {\n        global $db;\n\n        $section = $db->selectObject('section', 'id=' . $this->params['id']);\n        if ($section) {\n            section::removeLevel($section->id);\n            $db->decrement('section', 'rank', 1, 'rank > ' . $section->rank . ' AND parent=' . $section->parent);\n            $section->parent = -1;\n            $db->updateObject($section, 'section');\n            expSession::clearAllUsersSessionCache('navigation');\n            expHistory::back();\n        } else {\n            notfoundController::handle_not_authorized();\n        }\n    }\n\n    function delete_standalones() {\n        if (!empty($this->params['deleteit'])) {\n            foreach ($this->params['deleteit'] as $page) {\n                $section = new section(intval($page));\n                if ($section) {\n//                    self::deleteLevel($section->id);\n                    $section->delete();\n                }\n            }\n        }\n        expSession::clearAllUsersSessionCache('navigation');\n        expHistory::back();\n    }\n\n    /**\n     * permission functions to aggregate a module's visible permissions based on add/remove permissions\n     *\n     * @return array\n     */\n    public function permissions() {\n        //set the permissions array\n        return $this->add_permissions;\n    }\n\n    // create a psuedo global manage pages permission\n    public static function checkPermissions($permission,$location) {\n        global $exponent_permissions_r, $router;\n\n        // only applies to the 'manage' method\n        if (empty($location->src) && empty($location->int) && ((!empty($router->params['action']) && $router->params['action'] == 'manage') || strpos($router->current_url, 'action=manage') !== false)) {\n            if (!empty($exponent_permissions_r['navigation'])) foreach ($exponent_permissions_r['navigation'] as $page) {\n                foreach ($page as $pageperm) {\n                    if (!empty($pageperm['manage'])) return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Rebuild the sectionref table as a list of modules on a page\n     * @deprecated 2.3.4 moved to sectionref model\n     */\n    public static function rebuild_sectionrefs() {\n        global $db;\n\n        // recursive run though all the nested containers\n        function scan_container($container_id, $page_id) {\n            global $db;\n\n            $containers = $db->selectObjects('container',\"external='\" . $container_id . \"'\");\n            $ret = '';\n            foreach ($containers as $container) {\n                $iLoc = expUnserialize($container->internal);\n                $newret = recyclebin::restoreFromRecycleBin($iLoc, $page_id);\n                if (!empty($newret)) $ret .= $newret . '<br>';\n                if ($iLoc->mod == 'container') {\n                    $ret .= scan_container($container->internal, $page_id);\n                }\n            }\n            return $ret;\n        }\n\n        // recursive run through all the nested pages\n        function scan_page($parent_id) {\n            global $db;\n\n            $sections = $db->selectObjects('section','parent=' . $parent_id);\n            $ret = '';\n            foreach ($sections as $page) {\n                $cLoc = serialize(expCore::makeLocation('container','@section' . $page->id));\n                $ret .= scan_container($cLoc, $page->id);\n                $ret .= scan_page($page->id);\n            }\n            return $ret;\n        }\n\n        // first remove duplicate records\n        $db->sql('DELETE FROM ' . $db->prefix . 'sectionref WHERE id NOT IN (SELECT * FROM (SELECT MIN(n.id) FROM ' . $db->prefix . 'sectionref n GROUP BY n.module, n.source) x)');\n        $ret = scan_page(0);  // the page hierarchy\n        $ret .= scan_page(-1);  // now the stand alone pages\n\n        // we need to get the non-main containers such as sidebars, footers, etc...\n        $hardcodedmods = $db->selectObjects('sectionref',\"refcount=1000 AND source NOT LIKE '%@section%' AND source NOT LIKE '%@random%'\");\n        foreach ($hardcodedmods as $hardcodedmod) {\n            if ($hardcodedmod->module == 'container') {\n                $page_id = intval(preg_replace('/\\D/', '', $hardcodedmod->source));\n                if (empty($page_id)) {\n                    $page_id = SITE_DEFAULT_SECTION;  // we'll default to the home page\n                }\n                $ret .= scan_container(serialize(expCore::makeLocation($hardcodedmod->module, $hardcodedmod->source)), $page_id);\n            } else {\n                $hardcodedmod->section = 0;  // this is a hard-coded non-container module\n                $db->updateObject($hardcodedmod, 'sectionref');\n            }\n        }\n\n        // mark modules in the recycle bin as section 0\n        $db->columnUpdate('sectionref', 'section', 0, \"refcount=0\");\n//        $recycledmods = $db->selectObjects('sectionref',\"refcount=0\");\n//        foreach ($recycledmods as $recycledmod) {\n//            $recycledmod->section = 0;  // this is a module in the recycle bin\n//            $db->updateObject($recycledmod, 'sectionref');\n//        }\n        return $ret;\n    }\n\n}\n\n?>\n"], "fixing_code": ["<?php\n\n##################################################\n#\n# Copyright (c) 2004-2016 OIC Group, Inc.\n#\n# This file is part of Exponent\n#\n# Exponent is free software; you can redistribute\n# it and/or modify it under the terms of the GNU\n# General Public License as published by the Free\n# Software Foundation; either version 2 of the\n# License, or (at your option) any later version.\n#\n# GPL: http://www.gnu.org/licenses/gpl.txt\n#\n##################################################\n/**\n * @subpackage Controllers\n * @package    Modules\n */\nclass navigationController extends expController {\n    public $basemodel_name = 'section';\n    public $useractions = array(\n        'showall' => 'Show Navigation',\n        'breadcrumb' => 'Breadcrumb',\n    );\n//    protected $remove_permissions = array(\n//        'configure',\n//        'create',\n//        'delete',\n//        'edit'\n//    );\n    protected $add_permissions = array(\n        'manage'    => 'Manage',\n        'view'      => \"View Page\"\n    );\n    protected $manage_permissions = array(\n        'move'      => 'Move Page',\n        'remove'    => 'Remove Page',\n        'reparent'    => 'Reparent Page',\n        'dragndroprerank'    => 'Rerank Page',\n        'dragndroprerank2'    => 'Rerank Page',\n    );\n    public $remove_configs = array(\n        'aggregation',\n        'categories',\n        'comments',\n        'ealerts',\n        'facebook',\n        'files',\n        'pagination',\n        'rss',\n        'tags',\n        'twitter',\n    );  // all options: ('aggregation','categories','comments','ealerts','facebook','files','pagination','rss','tags','twitter',)\n\n    static function displayname() { return gt(\"Navigation\"); }\n\n    static function description() { return gt(\"Places navigation links/menus on the page.\"); }\n\n    static function isSearchable() { return true; }\n\n    function searchName() { return gt('Webpage'); }\n\n    /**\n     * @param null $src\n     * @param array $params\n     *\n     */\n    function __construct($src = null, $params = array())\n    {\n        parent::__construct($src, $params);\n        if (!empty($params['id']))  // we normally throw out the $loc->int EXCEPT with navigation pages\n            $this->loc = expCore::makeLocation($this->baseclassname, $src, $params['id']);\n    }\n\n    public function showall() {\n        global $user, $sectionObj, $sections;\n\n        expHistory::set('viewable', $this->params);\n        $id      = $sectionObj->id;\n        $current = null;\n        // all we need to do is determine the current section\n        $navsections = $sections;\n        if ($sectionObj->parent == -1) {\n            $current = $sectionObj;\n        } else {\n            foreach ($navsections as $section) {\n                if ($section->id == $id) {\n                    $current = $section;\n                    break;\n                }\n            }\n        }\n        assign_to_template(array(\n            'sections'     => $navsections,\n            'current'      => $current,\n            'canManage'    => ((isset($user->is_acting_admin) && $user->is_acting_admin == 1) ? 1 : 0),\n        ));\n    }\n\n    public function breadcrumb() {\n        global $sectionObj;\n\n        expHistory::set('viewable', $this->params);\n        $id      = $sectionObj->id;\n        $current = null;\n        // Show not only the location of a page in the hierarchy but also the location of a standalone page\n        $current = new section($id);\n        if ($current->parent == -1) {  // standalone page\n            $navsections = section::levelTemplate(-1, 0);\n            foreach ($navsections as $section) {\n                if ($section->id == $id) {\n                    $current = $section;\n                    break;\n                }\n            }\n        } else {\n            $navsections = section::levelTemplate(0, 0);\n            foreach ($navsections as $section) {\n                if ($section->id == $id) {\n                    $current = $section;\n                    break;\n                }\n            }\n        }\n        assign_to_template(array(\n            'sections'     => $navsections,\n            'current'      => $current,\n        ));\n    }\n\n    /**\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function navhierarchy($notyui=false) {\n        global $sections;\n\n        $json_array = array();\n        for ($i = 0, $iMax = count($sections); $i < $iMax; $i++) {\n            if ($sections[$i]->depth == 0) {\n                $obj = new stdClass();\n//   \t\t\t\t$obj->id = $sections[$i]->name.$sections[$i]->id;\n                $obj->id   = $sections[$i]->id;\n                $obj->text = $sections[$i]->name;\n                $obj->title = $sections[$i]->page_title;\n                $obj->description = $sections[$i]->description;\n                $obj->new_window = $sections[$i]->new_window;\n                $obj->expFile = $sections[$i]->expFile;\n                $obj->glyph = $sections[$i]->glyph;\n                $obj->glyph_only = $sections[$i]->glyph_only;\n                $obj->type = $sections[$i]->alias_type;\n                if ($sections[$i]->active == 1) {\n                    $obj->url = $sections[$i]->link;\n                    if ($obj->type == 1 && substr($obj->url, 0, 4) != 'http') {\n                        $obj->url = 'http://' . $obj->url;\n                    }\n                } else {\n                    $obj->url     = \"#\";\n                    $obj->onclick = \"onclick: { fn: return false }\";\n                }\n                if ($obj->type == 3) {  // mostly a hack instead of adding more table fields\n                    $obj->width = $sections[$i]->internal_id;\n                    $obj->class = $sections[$i]->external_link;\n                }\n                /*if ($sections[$i]->active == 1) {\n                    $obj->disabled = false;\n                } else {\n                    $obj->disabled = true;\n                }*/\n                //$obj->disabled = true;\n                $obj->itemdata = self::getChildren($i,$notyui);\n                $obj->maxitems = count($obj->itemdata);\n                $obj->maxdepth = 0;\n                foreach ($obj->itemdata as $menu) {\n                    if ($menu->maxdepth > $obj->maxdepth) $obj->maxdepth = $menu->maxdepth;\n                }\n            }\n            $json_array[] = $obj;\n        }\n        return $json_array;\n    }\n\n    /**\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function navtojson() {\n        return json_encode(self::navhierarchy());\n    }\n\n    /**\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function getChildren(&$i, $notyui=false) {\n        global $sections;\n\n        //\t\techo \"i=\".$i.\"<br>\";\n        if ($i + 1 == count($sections)) { // last entry\n            return array();\n        } elseif ($sections[$i]->depth == $sections[$i + 1]->depth) {\n            return array();\n        } else {\n            $ret_depth = $sections[$i]->depth;\n            $i++;\n            $ret_array = array();\n            for ($iMax = count($sections); $i < $iMax; $i++) {\n                // start setting up the objects to return\n                $obj       = new stdClass();\n                $obj->id   = $sections[$i]->id;\n                $obj->text = $sections[$i]->name;\n                $obj->title = $sections[$i]->page_title;\n                $obj->description = $sections[$i]->description;\n                $obj->new_window = $sections[$i]->new_window;\n                $obj->expFile = $sections[$i]->expFile;\n                $obj->glyph = $sections[$i]->glyph;\n                $obj->glyph_only = $sections[$i]->glyph_only;\n                $obj->depth = $sections[$i]->depth;\n                if ($sections[$i]->active == 1) {\n                    $obj->url = $sections[$i]->link;\n                    if ($sections[$i]->alias_type == 1 && substr($obj->url, 0, 4) != 'http') {\n                        $obj->url = 'http://' . $obj->url;\n                    }\n                } else {\n                    $obj->url     = \"#\";\n                    $obj->onclick = \"onclick: { fn: return false }\";\n                }\n                //echo \"i=\".$i.\"<br>\";\n                if (self::hasChildren($i)) {\n                    if ($notyui) {\n                        $obj->itemdata = self::getChildren($i,$notyui);\n                        $obj->maxitems = count($obj->itemdata);\n                        $obj->maxdepth = 0;\n                        foreach ($obj->itemdata as $menu) {\n                            if (!empty($menu->maxdepth)) {\n                                if ($menu->maxdepth > $obj->maxdepth) $obj->maxdepth = $menu->maxdepth;\n                            } else {\n                                if ($menu->depth > $obj->maxdepth) $obj->maxdepth = $menu->depth;\n                            }\n                        }\n                    } else {\n                        $obj->submenu     = new stdClass();\n                        $obj->submenu->id = $sections[$i]->name . $sections[$i]->id;\n                        //echo \"getting children of \".$sections[$i]->name;\n                        $obj->submenu->itemdata = self::getChildren($i,$notyui);\n                        $obj->maxitems = count($obj->submenu->itemdata);\n                        $obj->maxdepth = 0;\n                        foreach ($obj->submenu->itemdata as $menu) {\n                            if (!empty($menu->maxdepth)) {\n                                if ($menu->maxdepth > $obj->maxdepth) $obj->maxdepth = $menu->maxdepth;\n                            } else {\n                                if ($menu->depth > $obj->maxdepth) $obj->maxdepth = $menu->depth;\n                            }\n                        }\n                    }\n                    $ret_array[]            = $obj;\n                } else {\n                    $obj->maxdepth = $obj->depth;\n                    $ret_array[] = $obj;\n                }\n                if (($i + 1) >= count($sections) || $sections[$i + 1]->depth <= $ret_depth) {\n                    return $ret_array;\n                }\n            }\n            return array();\n        }\n    }\n\n    /**\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function hasChildren($i) {\n        global $sections;\n\n        if (($i + 1) >= count($sections)) return false;\n        return ($sections[$i]->depth < $sections[$i + 1]->depth) ? true : false;\n    }\n\n    /** exdoc\n     * Creates a location object, based off of the three arguments passed, and returns it.\n     *\n     * @return array\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function initializeNavigation() {\n        $sections = section::levelTemplate(0, 0);\n        return $sections;\n    }\n\n    /**\n     * returns all the section's children\n     *\n     * @static\n     *\n     * @param int   $parent top level parent id\n     * @param int   $depth  variable to hold level of recursion\n     * @param array $parents\n     *\n     * @return array\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function levelTemplate($parent, $depth = 0, $parents = array()) {\n        global $user;\n\n        if ($parent != 0) $parents[] = $parent;\n        $nodes = array();\n        $cache = expSession::getCacheValue('navigation');\n        $sect = new section();\n        if (!isset($cache['kids'][$parent])) {\n            $kids = $sect->find('all','parent=' . $parent);\n            $cache['kids'][$parent] = $kids;\n            expSession::setCacheValue('navigation', $cache);\n        } else {\n            $kids = $cache['kids'][$parent];\n        }\n        $kids = expSorter::sort(array('array' => $kids, 'sortby' => 'rank', 'order' => 'ASC'));\n        for ($i = 0, $iMax = count($kids); $i < $iMax; $i++) {\n            $child = $kids[$i];\n            //foreach ($kids as $child) {\n            if ($child->public == 1 || expPermissions::check('view', expCore::makeLocation('navigation', '', $child->id))) {\n                $child->numParents    = count($parents);\n                $child->depth         = $depth;\n                $child->first         = ($i == 0 ? 1 : 0);\n                $child->last          = ($i == count($kids) - 1 ? 1 : 0);\n                $child->parents       = $parents;\n                $child->canManage     = (isset($user->is_acting_admin) && $user->is_acting_admin == 1 ? 1 : 0);\n                $child->canManageRank = $child->canManage;\n                if (!isset($child->sef_name)) {\n                    $child->sef_name = '';\n                }\n                // Generate the link attribute base on alias type.\n                if ($child->alias_type == 1) {\n                    // External link.  Set the link to the configured website URL.\n                    // This is guaranteed to be a full URL because of the\n                    // section::updateExternalAlias() method in models-1/section.php\n                    $child->link = $child->external_link;\n                } else if ($child->alias_type == 2) {\n                    // Internal link.\n                    // Need to check and see if the internal_id is pointing at an external link.\n//                    $dest = $db->selectObject('section', 'id=' . $child->internal_id);\n                    $dest = $sect->find('first','id=' . $child->internal_id);\n                    if (!empty($dest->alias_type) && $dest->alias_type == 1) {\n                        // This internal alias is pointing at an external alias.\n                        // Use the external_link of the destination section for the link\n                        $child->link = $dest->external_link;\n                    } else {\n                        // Pointing at a regular section.  This is guaranteed to be\n                        // a regular section because aliases cannot be turned into sections,\n                        // (and vice-versa) and because the section::updateInternalLink\n                        // does 'alias to alias' dereferencing before the section is saved\n                        // (see models-1/section.php)\n                        //added by Tyler to pull the descriptions through for the children view\n                        $child->description = !empty($dest->description) ? $dest->description : '';\n                        $child->link        = expCore::makeLink(array('section' => $child->internal_id));\n                    }\n                } else {\n                    // Normal link, alias_type == 0.  Just create the URL from the section's id.\n                    $child->link = expCore::makeLink(array('section' => $child->id), '', $child->sef_name);\n                }\n                //$child->numChildren = $db->countObjects('section','parent='.$child->id);\n                $nodes[] = $child;\n                $nodes   = array_merge($nodes, section::levelTemplate($child->id, $depth + 1, $parents));\n            }\n        }\n        return $nodes;\n    }\n\n    /**\n     * Returns a flat representation of the full site hierarchy.\n     *\n     * @param int    $parent         top level parent id\n     * @param int    $depth          variable to hold level of recursion\n     * @param array  $ignore_ids     array of pages to ignore\n     * @param bool   $full           include a 'top' level entry\n     * @param string $perm           permission level to build list\n     * @param bool   $addstandalones should we add the stand-alone pages also\n     * @param bool   $addinternalalias\n     *\n     * @return array\n     * @deprecated 2.3.4 moved to section model, HOWEVER still used in theme config\n     */\n    public static function levelDropdownControlArray($parent, $depth = 0, $ignore_ids = array(), $full = false, $perm = 'view', $addstandalones = false, $addinternalalias = true) {\n        global $db;\n\n        $ar = array();\n        if ($parent == 0 && $full) {\n            $ar[0] = '&lt;' . gt('Top of Hierarchy') . '&gt;';\n        }\n        if ($addinternalalias) {\n            $intalias = '';\n        } else {\n            $intalias = ' AND alias_type != 2';\n        }\n        $nodes = $db->selectObjects('section', 'parent=' . $parent . $intalias, 'rank');\n        foreach ($nodes as $node) {\n            if ((($perm == 'view' && $node->public == 1) || expPermissions::check($perm, expCore::makeLocation('navigation', '', $node->id))) && !in_array($node->id, $ignore_ids)) {\n                if ($node->active == 1) {\n                    $text = str_pad('', ($depth + ($full ? 1 : 0)) * 3, '.', STR_PAD_LEFT) . $node->name;\n                } else {\n                    $text = str_pad('', ($depth + ($full ? 1 : 0)) * 3, '.', STR_PAD_LEFT) . '(' . $node->name . ')';\n                }\n                $ar[$node->id] = $text;\n                foreach (self::levelDropdownControlArray($node->id, $depth + 1, $ignore_ids, $full, $perm, $addstandalones, $addinternalalias) as $id => $text) {\n                    $ar[$id] = $text;\n                }\n            }\n        }\n        if ($addstandalones && $parent == 0) {\n            $sections = $db->selectObjects('section', 'parent=-1');\n            foreach ($sections as $node) {\n                if ((($perm == 'view' && $node->public == 1) || expPermissions::check($perm, expCore::makeLocation('navigation', '', $node->id))) && !in_array($node->id, $ignore_ids)) {\n                    if ($node->active == 1) {\n                        $text = str_pad('', ($depth + ($full ? 1 : 0)) * 3, '.', STR_PAD_LEFT) . $node->name;\n                    } else {\n                        $text = str_pad('', ($depth + ($full ? 1 : 0)) * 3, '.', STR_PAD_LEFT) . '(' . $node->name . ')';\n                    }\n                    $ar[$node->id] = '(' . gt('Standalone') . ') ' . $text;\n                }\n            }\n//            $ar = array_merge($ar,$sections);\n        }\n        return $ar;\n    }\n\n    /**\n     * add all module items to search index\n     *\n     * @return int\n     */\n    function addContentToSearch() {\n        global $db;\n\n        //global $sections;\n        //\t\tglobal $router;\n//        $db->delete('search', \"ref_module='navigation' AND ref_type='section'\");\n        $db->delete('search', \"ref_module='\".$this->baseclassname.\"' AND ref_type='section'\");\n        // this now ensures we get internal pages, instead of relying on the global $sections, which does not.\n        $sections = $db->selectObjects('section', 'active=1');\n        foreach ($sections as $section) {\n            $search_record = new stdClass();\n//            $search_record->category = 'Webpages';\n//            $search_record->ref_module = 'navigationController';\n//            $search_record->ref_type = 'section';\n//            $search_record->ref_module  = $this->classname;\n            $search_record->ref_module  = $this->baseclassname;\n            $search_record->category    = $this->searchName();\n            $search_record->ref_type    = $this->searchCategory();\n            $search_record->original_id = $section->id;\n            $search_record->title       = $section->name;\n            //$search_record->view_link = $router->buildUrlByPageId($section->id);\n            $link = str_replace(URL_FULL, '', makeLink(array('section' => $section->id)));\n            if ($link . '/' == URL_FULL) $link = '';\n            $search_record->view_link = $link;\n            $search_record->body      = $section->description;\n            $search_record->keywords  = $section->keywords;\n            // now we're going to grab all the textmodules on this page and build the body for the page based off the content\n            // of all the text module added together.\n            $loc = expCore::makeLocation('text');\n            $controllername = 'text';\n            foreach ($db->selectObjects('sectionref', \"module='\" . $controllername . \"' AND section=\" . $section->id) as $module) {\n                $loc->src   = $module->source;\n//                $controller = new $controllername();\n                $controller = expModules::getController($controllername);\n                $textitems  = $db->selectObjects($controller->model_table, \"location_data='\" . serialize($loc) . \"'\");\n                foreach ($textitems as $textitem) {\n                    if (!empty($textitem)) {\n                        $search_record->body .= ' ' . search::removeHTML($textitem->body) . ' ';\n                        $search_record->keywords .= \" \" . $textitem->title;\n                    }\n                }\n            }\n            $db->insertObject($search_record, 'search');\n        }\n        return count($sections);\n    }\n\n    /**\n     * Retrieve either the entire hierarchy, or a subset of the hierarchy, as an array suitable for use\n     * in a dropdowncontrol.  This is used primarily by the section datatype for moving and adding\n     * sections to specific parts of the site hierarchy.\n     *\n     * @param int   $parent     The id of the subtree parent.  If passed as 0 (the default), the entire subtree is parsed.\n     * @param int   $depth\n     * @param int   $default\n     * @param array $ignore_ids a value-array of IDs to be ignored when generating the list.  This is used\n     *                          when moving a section, since a section cannot be made a subsection of itself or any of its subsections.\n     *\n     * @return string\n     */\n    function levelShowDropdown($parent, $depth = 0, $default = 0, $ignore_ids = array()) {\n        global $db;\n\n        $html = '';\n        $nodes = $db->selectObjects('section', 'parent=' . $parent, 'rank');\n//\t\t$nodes = expSorter::sort(array('array'=>$nodes,'sortby'=>'rank', 'order'=>'ASC'));\n        foreach ($nodes as $node) {\n            if (($node->public == 1 || expPermissions::check('view', expCore::makeLocation('navigation', '', $node->id))) && !in_array($node->id, $ignore_ids)) {\n                $html .= '<option value=\"' . $node->id . '\" ';\n                if ($default == $node->id) $html .= 'selected';\n                $html .= '>';\n                if ($node->active == 1) {\n                    $html .= str_pad('', $depth * 3, '.', STR_PAD_LEFT) . $node->name;\n                } else {\n                    $html .= str_pad('', $depth * 3, '.', STR_PAD_LEFT) . '(' . $node->name . ')';\n                }\n                $html .= '</option>';\n                $html .= self::levelShowDropdown($node->id, $depth + 1, $default, $ignore_ids);\n            }\n        }\n        return $html;\n    }\n\n    /**\n     * recursively lists the template hierarchy\n     *\n     * @static\n     *\n     * @param int $parent top level parent id\n     * @param int $depth  variable to hold level of recursion\n     *\n     * @return array\n     * @deprecated 2.0.0 this only for deprecated templates\n     */\n    public static function getTemplateHierarchyFlat($parent, $depth = 1) {\n        global $db;\n\n        $arr  = array();\n        $kids = $db->selectObjects('section_template', 'parent=' . $parent, 'rank');\n//\t\t$kids = expSorter::sort(array('array'=>$kids,'sortby'=>'rank', 'order'=>'ASC'));\n        for ($i = 0, $iMax = count($kids); $i < $iMax; $i++) {\n            $page        = $kids[$i];\n            $page->depth = $depth;\n            $page->first = ($i == 0 ? 1 : 0);\n            $page->last  = ($i == count($kids) - 1 ? 1 : 0);\n            $arr[]       = $page;\n            $arr         = array_merge($arr, self::getTemplateHierarchyFlat($page->id, $depth + 1));\n        }\n        return $arr;\n    }\n\n    /**\n     * @deprecated 2.0.0 this only for deprecated templates\n     */\n    public static function process_section($section, $template) {\n        global $db;\n\n        if (!is_object($template)) {\n            $template          = $db->selectObject('section_template', 'id=' . $template);\n            $section->subtheme = $template->subtheme;\n            $db->updateObject($section, 'section');\n        }\n        $prefix = '@st' . $template->id;\n        $refs   = $db->selectObjects('sectionref', \"source LIKE '$prefix%'\");\n        // Copy all modules and content for this section\n        foreach ($refs as $ref) {\n            $src = substr($ref->source, strlen($prefix)) . $section->id;\n            if (call_user_func(array($ref->module, 'hasContent'))) {\n                $oloc = expCore::makeLocation($ref->module, $ref->source);\n                $nloc = expCore::makeLocation($ref->module, $src);\n                if ($ref->module != \"container\") {\n                    call_user_func(array($ref->module, 'copyContent'), $oloc, $nloc);\n                } else {\n                    call_user_func(array($ref->module, 'copyContent'), $oloc, $nloc, $section->id);\n                }\n            }\n        }\n        // Grab sub pages\n        foreach ($db->selectObjects('section_template', 'parent=' . $template->id) as $t) {\n            self::process_subsections($section, $t);\n        }\n\n    }\n\n    /**\n     * @deprecated 2.0.0 this only for deprecated templates\n     */\n    function process_subsections($parent_section, $subtpl) {\n        global $db, $router;\n\n        $section              = new stdClass();\n        $section->parent      = $parent_section->id;\n        $section->name        = $subtpl->name;\n        $section->sef_name    = $router->encode($section->name);\n        $section->subtheme    = $subtpl->subtheme;\n        $section->active      = $subtpl->active;\n        $section->public      = $subtpl->public;\n        $section->rank        = $subtpl->rank;\n        $section->page_title  = $subtpl->page_title;\n        $section->keywords    = $subtpl->keywords;\n        $section->description = $subtpl->description;\n        $section->id          = $db->insertObject($section, 'section');\n        self::process_section($section, $subtpl);\n    }\n\n    /**\n     * Delete page and send its contents to the recycle bin\n     *\n     * @param $parent\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function deleteLevel($parent) {\n        global $db;\n\n        $kids = $db->selectObjects('section', 'parent=' . $parent);\n        foreach ($kids as $kid) {\n            self::deleteLevel($kid->id);\n        }\n        $secrefs = $db->selectObjects('sectionref', 'section=' . $parent);\n        foreach ($secrefs as $secref) {\n            $loc = expCore::makeLocation($secref->module, $secref->source, $secref->internal);\n            recyclebin::sendToRecycleBin($loc, $parent);\n            //FIXME if we delete the module & sectionref the module completely disappears\n//            if (class_exists($secref->module)) {\n//                $modclass = $secref->module;\n//                //FIXME: more module/controller glue code\n//                if (expModules::controllerExists($modclass)) {\n//                    $modclass = expModules::getControllerClassName($modclass);\n//                    $mod = new $modclass($loc->src);\n//                    $mod->delete_instance();\n//                } else {\n//                    $mod = new $modclass();\n//                    $mod->deleteIn($loc);\n//                }\n//            }\n        }\n//        $db->delete('sectionref', 'section=' . $parent);\n        $db->delete('section', 'parent=' . $parent);\n    }\n\n    /**\n     * Move content page and its children to stand-alones\n     *\n     * @param $parent\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function removeLevel($parent) {\n        global $db;\n\n        $kids = $db->selectObjects('section', 'parent=' . $parent);\n        foreach ($kids as $kid) {\n            $kid->parent = -1;\n            $db->updateObject($kid, 'section');\n            self::removeLevel($kid->id);\n        }\n    }\n\n    /**\n     * Check for cascading page view permission, esp. if not public\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function canView($section) {\n        global $db;\n\n        if ($section == null) {\n            return false;\n        }\n        if ($section->public == 0) {\n            // Not a public section.  Check permissions.\n            return expPermissions::check('view', expCore::makeLocation('navigation', '', $section->id));\n        } else { // Is public.  check parents.\n            if ($section->parent <= 0) {\n                // Out of parents, and since we are still checking, we haven't hit a private section.\n                return true;\n            } else {\n                $s = $db->selectObject('section', 'id=' . $section->parent);\n                return self::canView($s);\n            }\n        }\n    }\n\n    /**\n     * Check to see if page is public with cascading\n     * @deprecated 2.3.4 moved to section model\n     */\n    public static function isPublic($s) {\n        if ($s == null) {\n            return false;\n        }\n        while ($s->public && $s->parent > 0) {\n            $s = new section($s->parent);\n        }\n        $lineage = (($s->public) ? 1 : 0);\n        return $lineage;\n    }\n\n    public static function canManageStandalones() {\n        global $user;\n\n        if ($user->isAdmin()) return true;\n        $standalones = section::levelTemplate(-1, 0);\n        //\t\t$canmanage = false;\n        foreach ($standalones as $standalone) {\n            $loc = expCore::makeLocation('navigation', '', $standalone->id);\n            if (expPermissions::check('manage', $loc)) return true;\n        }\n        return false;\n    }\n\n    /**\n     * Reassign permissions based on a check/change in menu/page hierarchy\n     *\n     * @static\n     *\n     * @param $id\n     */\n    public static function checkForSectionalAdmins($id) {\n        global $db;\n\n        $section = $db->selectObject('section', 'id=' . $id);\n        $branch  = section::levelTemplate($id, 0);\n        array_unshift($branch, $section);\n        $allusers  = array();\n        $allgroups = array();\n        while ($section->parent > 0) {\n            //\t\t\t$ploc = expCore::makeLocation('navigationController', null, $section);\n            $allusers  = array_merge($allusers, $db->selectColumn('userpermission', 'uid', \"permission='manage' AND module='navigation' AND internal=\" . $section->parent));\n            $allgroups = array_merge($allgroups, $db->selectColumn('grouppermission', 'gid', \"permission='manage' AND module='navigation' AND internal=\" . $section->parent));\n            $section   = $db->selectObject('section', 'id=' . $section->parent);\n        }\n        foreach ($branch as $section) {\n            $sloc = expCore::makeLocation('navigation', null, $section->id);\n            // remove any manage permissions for this page and it's children\n            // $db->delete('userpermission', \"module='navigationController' AND internal=\".$section->id);\n            // $db->delete('grouppermission', \"module='navigationController' AND internal=\".$section->id);\n            foreach ($allusers as $uid) {\n                $u = user::getUserById($uid);\n                expPermissions::grant($u, 'manage', $sloc);\n            }\n            foreach ($allgroups as $gid) {\n                $g = group::getGroupById($gid);\n                expPermissions::grantGroup($g, 'manage', $sloc);\n            }\n        }\n    }\n\n    function manage() {\n        global $db, $router, $user;\n\n        expHistory::set('manageable', $router->params);\n        assign_to_template(array(\n            'canManageStandalones' => self::canManageStandalones(),\n            'sasections'           => $db->selectObjects('section', 'parent=-1'),\n            'user'                 => $user,\n//            'canManagePagesets'    => $user->isAdmin(),\n//            'templates'            => $db->selectObjects('section_template', 'parent=0'),\n        ));\n    }\n\n    public function manage_sitemap() {\n        global $db, $user, $sectionObj, $sections;\n\n        expHistory::set('viewable', $this->params);\n        $id      = $sectionObj->id;\n        $current = null;\n        // all we need to do is determine the current section\n        $navsections = $sections;\n        if ($sectionObj->parent == -1) {\n            $current = $sectionObj;\n        } else {\n            foreach ($navsections as $section) {\n                if ($section->id == $id) {\n                    $current = $section;\n                    break;\n                }\n            }\n        }\n        assign_to_template(array(\n            'sasections'   => $db->selectObjects('section', 'parent=-1'),\n            'sections'     => $navsections,\n            'current'      => $current,\n            'canManage'    => ((isset($user->is_acting_admin) && $user->is_acting_admin == 1) ? 1 : 0),\n        ));\n    }\n\n    /**\n     * Ajax request for specific pages as json date to yui tree\n     */\n    public static function returnChildrenAsJSON() {\n        global $db;\n\n        //$nav = section::levelTemplate(intval($_REQUEST['id'], 0));\n        $id         = isset($_REQUEST['id']) ? intval($_REQUEST['id']) : 0;\n        $nav        = $db->selectObjects('section', 'parent=' . $id, 'rank');\n        //FIXME $manage_all is moot w/ cascading perms now?\n        $manage_all = false;\n        if (expPermissions::check('manage', expCore::makeLocation('navigation', '', $id))) {\n            $manage_all = true;\n        }\n        //FIXME recode to use foreach $key=>$value\n        $navcount = count($nav);\n        for ($i = 0; $i < $navcount; $i++) {\n            if ($manage_all || expPermissions::check('manage', expCore::makeLocation('navigation', '', $nav[$i]->id))) {\n                $nav[$i]->manage = 1;\n                $view = true;\n            } else {\n                $nav[$i]->manage = 0;\n                $view = $nav[$i]->public ? true : expPermissions::check('view', expCore::makeLocation('navigation', '', $nav[$i]->id));\n            }\n            $nav[$i]->link = expCore::makeLink(array('section' => $nav[$i]->id), '', $nav[$i]->sef_name);\n            if (!$view) unset($nav[$i]);\n        }\n        $nav= array_values($nav);\n//        $nav[$navcount - 1]->last = true;\n        if (count($nav)) $nav[count($nav) - 1]->last = true;\n//        echo expJavascript::ajaxReply(201, '', $nav);\n        $ar = new expAjaxReply(201, '', $nav);\n        $ar->send();\n    }\n\n    /**\n     * Ajax request for all pages as json date to jstree\n     */\n    public static function returnChildrenAsJSON2() {\n        global $db;\n\n        $icons = array(\n            0 => 'addpage',\n            1 => 'addextpage',\n            2 => 'addintpage',\n            3 => 'addfreeform',\n        );\n\n        $navs        = $db->selectObjects('section', 'parent!=-1', 'rank');\n        foreach ($navs as $i=>$nav) {\n            $navs[$i]->parent = $nav->parent?$nav->parent:'#';\n            $navs[$i]->text = $nav->name;\n            $navs[$i]->icon = $icons[$nav->alias_type];\n            if (!$nav->active) {\n                $navs[$i]->icon .= ' inactive';\n                $attr = new stdClass();\n                $attr->class = 'inactive';  // class to obscure elements\n                $navs[$i]->a_attr = $attr;\n            }\n            if (expPermissions::check('manage', expCore::makeLocation('navigation', '', $navs[$i]->id))) {\n                $navs[$i]->manage = 1;\n                $view = true;\n            } else {\n                $navs[$i]->manage = 0;\n                $navs[$i]->state->disabled = true;\n                $view = $navs[$i]->public ? true : expPermissions::check('view', expCore::makeLocation('navigation', '', $navs[$i]->id));\n            }\n            $navs[$i]->link = expCore::makeLink(array('section' => $navs[$i]->id), '', $navs[$i]->sef_name);\n            if (!$view) {\n//                unset($navs[$i]);  //FIXME this breaks jstree if we remove a parent and not the child\n                $attr = new stdClass();\n                $attr->class = 'hidden';  // bs3 class to hide elements\n                $navs[$i]->li_attr = $attr;\n            }\n        }\n        $navs= array_values($navs);\n//        header('Content-Type: application/json; charset=utf8');\n\t\techo json_encode($navs);\n//        echo expJavascript::ajaxReply(201, '', $navs);\n        exit;\n    }\n\n    /**\n     * Ajax function to reorder page hierarchy from yui tree control\n     */\n    public static function DragnDropReRank() {\n        global $db, $router;\n\n        $move   = intval($router->params['move']);\n        $target = intval($router->params['target']);\n        $type   = $router->params['type'];\n        $targSec = $db->selectObject(\"section\",\"id=\".$target);\n//        $targSec  = new section($target);\n        $check_id = $targSec->parent;\n        $moveSec = $db->selectObject(\"section\",\"id=\".$move);\n//        $moveSec = new section($move);\n\n        // dropped on top of page\n        if ($type == \"append\") {\n            //save the old parent in case we are changing the depth of the moving section\n            $oldParent = $moveSec->parent;\n            //assign the parent of the moving section to the ID of the target section\n            $moveSec->parent = $targSec->id;\n            //set the rank of the moving section to 0 since it will appear first in the new order\n            $moveSec->rank = 1;\n            //select all children currently of the parent we're about to append to\n            $targSecChildren = $db->selectObjects(\"section\", \"parent=\" . $targSec->id . \" ORDER BY rank\");\n            //update the ranks of the children to +1 higher to accommodate our new rank 0 section being moved in.\n            $newrank = 1;\n            foreach ($targSecChildren as $value) {\n                if ($value->id != $moveSec->id) {\n                    $value->rank = $newrank;\n                    $db->updateObject($value, 'section');\n                    $newrank++;\n                }\n            }\n            $db->updateObject($moveSec, 'section');\n            if ($oldParent != $moveSec->parent) {\n                //we need to re-rank the children of the parent that the miving section has just left\n                $childOfLastMove = $db->selectObjects(\"section\", \"parent=\" . $oldParent . \" ORDER BY rank\");\n                for ($i = 0, $iMax = count($childOfLastMove); $i < $iMax; $i++) {\n                    $childOfLastMove[$i]->rank = $i;\n                    $db->updateObject($childOfLastMove[$i], 'section');\n                }\n\n            }\n//            echo $moveSec->name . \" was appended to \" . $targSec->name;\n\n        } elseif ($type == \"after\") {  // dropped between (after) pages\n            if ($targSec->parent == $moveSec->parent) {\n                //are we moving up...\n                if ($targSec->rank < $moveSec->rank) {\n                    $moveSec->rank    = $targSec->rank + 1;\n                    $moveNextSiblings = $db->selectObjects(\"section\", \"id!=\" . $moveSec->id . \" AND parent=\" . $targSec->parent . \" AND rank>\" . $targSec->rank . \" ORDER BY rank\");\n                    $rerank           = $moveSec->rank + 1;\n                    foreach ($moveNextSiblings as $value) {\n                        if ($value->id != $moveSec->id) {\n                            $value->rank = $rerank;\n                            $db->updateObject($value, 'section');\n                            $rerank++;\n                        }\n                    }\n                    $db->updateObject($targSec, 'section');\n//                    $targSec->update();\n                    $db->updateObject($moveSec, 'section');\n//                    $moveSec->update();\n                    //or are we moving down...\n                } else {\n                    $targSec->rank        = $targSec->rank - 1;\n                    $moveSec->rank        = $targSec->rank + 1;\n                    $movePreviousSiblings = $db->selectObjects(\"section\", \"id!=\" . $moveSec->id . \" AND parent=\" . $targSec->parent . \" AND rank<=\" . $targSec->rank . \" ORDER BY rank\");\n                    $rerank               = 1;\n                    foreach ($movePreviousSiblings as $value) {\n                        if ($value->id != $moveSec->id) {\n                            $value->rank = $rerank;\n                            $db->updateObject($value, 'section');\n                            $rerank++;\n                        }\n                    }\n                    $db->updateObject($targSec, 'section');\n//                    $targSec->update();\n                    $db->updateObject($moveSec, 'section');\n//                    $moveSec->update();\n                }\n            } else {  // 'before', is this used?\n                //store ranks from the depth we're moving from.  Used to re-rank the level depth the moving section is moving from.\n                $oldRank   = $moveSec->rank;\n                $oldParent = $moveSec->parent;\n                //select all children of the target sections parent with a rank higher than it's own\n                $moveNextSiblings = $db->selectObjects(\"section\", \"parent=\" . $targSec->parent . \" AND rank>\" . $targSec->rank . \" ORDER BY rank\");\n                //update moving sections rank and parent\n                $moveSec->rank   = $targSec->rank + 1;\n                $moveSec->parent = $targSec->parent;\n                //$rerank=$moveSec->rank+1;\n                foreach ($moveNextSiblings as $value) {\n                    $value->rank = $value->rank + 1;\n                    $db->updateObject($value, 'section');\n                }\n                $db->updateObject($moveSec, 'section');\n                //handle re-ranking of previous parent\n                $oldSiblings = $db->selectObjects(\"section\", \"parent=\" . $oldParent . \" AND rank>\" . $oldRank . \" ORDER BY rank\");\n                $rerank      = 1;\n                foreach ($oldSiblings as $value) {\n                    if ($value->id != $moveSec->id) {\n                        $value->rank = $rerank;\n                        $db->updateObject($value, 'section');\n                        $rerank++;\n                    }\n                }\n                if ($oldParent != $moveSec->parent) {\n                    //we need to re-rank the children of the parent that the moving section has just left\n                    $childOfLastMove = $db->selectObjects(\"section\", \"parent=\" . $oldParent . \" ORDER BY rank\");\n                    for ($i = 0, $iMax = count($childOfLastMove); $i < $iMax; $i++) {\n                        $childOfLastMove[$i]->rank = $i;\n                        $db->updateObject($childOfLastMove[$i], 'section');\n                    }\n                }\n            }\n        }\n        self::checkForSectionalAdmins($move);\n        expSession::clearAllUsersSessionCache('navigation');\n    }\n\n    /**\n     * Ajax function to reorder page hierarchy from jstree control\n     */\n    public static function DragnDropReRank2() {\n        global $router, $db;\n\n        $id = $router->params['id'];\n        $page = new section($id);\n        $old_rank = $page->rank;\n        $old_parent = $page->parent;\n        $new_rank = $router->params['position'] + 1;  // rank\n        $new_parent = intval($router->params['parent']);\n\n        $db->decrement($page->tablename, 'rank', 1, 'rank>' . $old_rank . ' AND parent=' . $old_parent);  // close in hole\n        $db->increment($page->tablename, 'rank', 1, 'rank>=' . $new_rank . ' AND parent=' . $new_parent);  // make room\n\n        $params = array();\n        $params['parent'] = $new_parent;\n        $params['rank'] = $new_rank;\n        $page->update($params);\n\n        self::checkForSectionalAdmins($id);\n        expSession::clearAllUsersSessionCache('navigation');\n    }\n\n    function edit_section() {\n        global $db, $user;\n\n        $parent = new section($this->params['parent']);\n        if (empty($parent->id)) $parent->id = 0;\n        assign_to_template(array(\n            'haveStandalone'  => ($db->countObjects('section', 'parent=-1') && $parent->id >= 0),\n            'parent'          => $parent,\n            'isAdministrator' => $user->isAdmin(),\n        ));\n    }\n\n    function edit_contentpage() {\n        //FIXME we come here for new/edit content/standalone pages\n        // FIXME: Allow non-administrative users to manage certain parts of the section hierarchy.\n        //if ($user->is_acting_admin == 1 /*TODO: section admin*/) {\n//        $section = null;\n        $section = new stdClass();\n        if (isset($this->params['id'])) {\n            // Check to see if an id was passed in get.  If so, retrieve that section from\n            // the database, and perform an edit on it.\n            $section  = $this->section->find($this->params['id']);\n        } elseif (isset($this->params['parent'])) {\n            // The isset check is merely a precaution.  This action should\n            // ALWAYS be invoked with a parent or id value.\n            $section  = new section($this->params);\n        } else {\n            notfoundController::handle_not_found();\n            exit;\n        }\n        if (!empty($section->id)) {\n            $check_id = $section->id;\n        } else {\n            $check_id = $section->parent;\n        }\n        if (expPermissions::check('manage', expCore::makeLocation('navigation', '', $check_id))) {\n            if (empty($section->id)) {\n                $section->active = 1;\n                $section->public = 1;\n                if (!isset($section->parent)) {\n                    // This is another precaution.  The parent attribute\n                    // should ALWAYS be set by the caller.\n                    //FJD - if that's the case, then we should die.\n                    notfoundController::handle_not_authorized();\n                    exit;\n                    //$section->parent = 0;\n                }\n            }\n            assign_to_template(array(\n                'section' => $section,\n                'glyphs' => self::get_glyphs(),\n            ));\n        } else {  // User does not have permission to manage sections.  Throw a 403\n            notfoundController::handle_not_authorized();\n        }\n    }\n\n    private static function get_glyphs() {\n        if (bs()) {\n            require_once(BASE . 'external/font-awesome.class.php');\n            $fa = new Smk_FontAwesome;\n            if (bs3()) {\n                $icons = $fa->getArray(BASE . 'external/font-awesome4/css/font-awesome.css');\n                $icons = $fa->sortByName($icons);\n                return $fa->nameGlyph($icons);\n            } elseif (bs2()) {\n                expCSS::auto_compile_less(\n                    'external/font-awesome/less/font-awesome.less',\n                    'external/font-awesome/css/font-awesome.css'\n                ); // font-awesome is included within bootstrap2, but not as a separate .css file\n                $icons = $fa->getArray(BASE . 'external/font-awesome/css/font-awesome.css', 'icon-');\n                return $fa->nameGlyph($icons, 'icon-');\n            }\n        } else {\n            return array();\n        }\n    }\n\n    function edit_internalalias() {\n        $section = isset($this->params['id']) ? $this->section->find($this->params['id']) : new section($this->params);\n        if ($section->parent == -1) {\n            notfoundController::handle_not_found();\n            exit;\n        } // doesn't work for standalone pages\n        if (empty($section->id)) {\n            $section->public = 1;\n            if (!isset($section->parent)) {\n                // This is another precaution.  The parent attribute\n                // should ALWAYS be set by the caller.\n                //FJD - if that's the case, then we should die.\n                notfoundController::handle_not_authorized();\n                exit;\n                //$section->parent = 0;\n            }\n        }\n        assign_to_template(array(\n            'section' => $section,\n            'glyphs' => self::get_glyphs(),\n        ));\n    }\n\n    function edit_freeform() {\n        $section = isset($this->params['id']) ? $this->section->find($this->params['id']) : new section($this->params);\n        if ($section->parent == -1) {\n            notfoundController::handle_not_found();\n            exit;\n        } // doesn't work for standalone pages\n        if (empty($section->id)) {\n            $section->public = 1;\n            if (!isset($section->parent)) {\n                // This is another precaution.  The parent attribute\n                // should ALWAYS be set by the caller.\n                //FJD - if that's the case, then we should die.\n                notfoundController::handle_not_authorized();\n                exit;\n                //$section->parent = 0;\n            }\n        }\n        assign_to_template(array(\n            'section' => $section,\n            'glyphs' => self::get_glyphs(),\n        ));\n    }\n\n    function edit_externalalias() {\n        $section = isset($this->params['id']) ? $this->section->find($this->params['id']) : new section($this->params);\n        if ($section->parent == -1) {\n            notfoundController::handle_not_found();\n            exit;\n        } // doesn't work for standalone pages\n        if (empty($section->id)) {\n            $section->public = 1;\n            if (!isset($section->parent)) {\n                // This is another precaution.  The parent attribute\n                // should ALWAYS be set by the caller.\n                //FJD - if that's the case, then we should die.\n                notfoundController::handle_not_authorized();\n                exit;\n                //$section->parent = 0;\n            }\n        }\n        assign_to_template(array(\n            'section' => $section,\n            'glyphs' => self::get_glyphs(),\n        ));\n    }\n\n    function update() {\n        parent::update();\n        expSession::clearAllUsersSessionCache('navigation');\n    }\n\n    function move_standalone() {\n        expSession::clearAllUsersSessionCache('navigation');\n        assign_to_template(array(\n            'parent' => $this->params['parent'],\n        ));\n    }\n\n    /**\n     * Move standalone back to hierarchy\n     *\n     */\n    function reparent_standalone() {\n        $standalone = $this->section->find($this->params['page']);\n        if ($standalone) {\n            $standalone->parent = $this->params['parent'];\n            $standalone->update();\n            expSession::clearAllUsersSessionCache('navigation');\n            expHistory::back();\n        } else {\n            notfoundController::handle_not_found();\n        }\n    }\n\n    /**\n     * Move content page to standalones\n     *\n     */\n    function remove() {\n        global $db;\n\n        $section = $db->selectObject('section', 'id=' . $this->params['id']);\n        if ($section) {\n            section::removeLevel($section->id);\n            $db->decrement('section', 'rank', 1, 'rank > ' . $section->rank . ' AND parent=' . $section->parent);\n            $section->parent = -1;\n            $db->updateObject($section, 'section');\n            expSession::clearAllUsersSessionCache('navigation');\n            expHistory::back();\n        } else {\n            notfoundController::handle_not_authorized();\n        }\n    }\n\n    function delete_standalones() {\n        if (!empty($this->params['deleteit'])) {\n            foreach ($this->params['deleteit'] as $page) {\n                $section = new section(intval($page));\n                if ($section) {\n//                    self::deleteLevel($section->id);\n                    $section->delete();\n                }\n            }\n        }\n        expSession::clearAllUsersSessionCache('navigation');\n        expHistory::back();\n    }\n\n    /**\n     * permission functions to aggregate a module's visible permissions based on add/remove permissions\n     *\n     * @return array\n     */\n    public function permissions() {\n        //set the permissions array\n        return $this->add_permissions;\n    }\n\n    // create a psuedo global manage pages permission\n    public static function checkPermissions($permission,$location) {\n        global $exponent_permissions_r, $router;\n\n        // only applies to the 'manage' method\n        if (empty($location->src) && empty($location->int) && ((!empty($router->params['action']) && $router->params['action'] == 'manage') || strpos($router->current_url, 'action=manage') !== false)) {\n            if (!empty($exponent_permissions_r['navigation'])) foreach ($exponent_permissions_r['navigation'] as $page) {\n                foreach ($page as $pageperm) {\n                    if (!empty($pageperm['manage'])) return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Rebuild the sectionref table as a list of modules on a page\n     * @deprecated 2.3.4 moved to sectionref model\n     */\n    public static function rebuild_sectionrefs() {\n        global $db;\n\n        // recursive run though all the nested containers\n        function scan_container($container_id, $page_id) {\n            global $db;\n\n            $containers = $db->selectObjects('container',\"external='\" . $container_id . \"'\");\n            $ret = '';\n            foreach ($containers as $container) {\n                $iLoc = expUnserialize($container->internal);\n                $newret = recyclebin::restoreFromRecycleBin($iLoc, $page_id);\n                if (!empty($newret)) $ret .= $newret . '<br>';\n                if ($iLoc->mod == 'container') {\n                    $ret .= scan_container($container->internal, $page_id);\n                }\n            }\n            return $ret;\n        }\n\n        // recursive run through all the nested pages\n        function scan_page($parent_id) {\n            global $db;\n\n            $sections = $db->selectObjects('section','parent=' . $parent_id);\n            $ret = '';\n            foreach ($sections as $page) {\n                $cLoc = serialize(expCore::makeLocation('container','@section' . $page->id));\n                $ret .= scan_container($cLoc, $page->id);\n                $ret .= scan_page($page->id);\n            }\n            return $ret;\n        }\n\n        // first remove duplicate records\n        $db->sql('DELETE FROM ' . $db->prefix . 'sectionref WHERE id NOT IN (SELECT * FROM (SELECT MIN(n.id) FROM ' . $db->prefix . 'sectionref n GROUP BY n.module, n.source) x)');\n        $ret = scan_page(0);  // the page hierarchy\n        $ret .= scan_page(-1);  // now the stand alone pages\n\n        // we need to get the non-main containers such as sidebars, footers, etc...\n        $hardcodedmods = $db->selectObjects('sectionref',\"refcount=1000 AND source NOT LIKE '%@section%' AND source NOT LIKE '%@random%'\");\n        foreach ($hardcodedmods as $hardcodedmod) {\n            if ($hardcodedmod->module == 'container') {\n                $page_id = intval(preg_replace('/\\D/', '', $hardcodedmod->source));\n                if (empty($page_id)) {\n                    $page_id = SITE_DEFAULT_SECTION;  // we'll default to the home page\n                }\n                $ret .= scan_container(serialize(expCore::makeLocation($hardcodedmod->module, $hardcodedmod->source)), $page_id);\n            } else {\n                $hardcodedmod->section = 0;  // this is a hard-coded non-container module\n                $db->updateObject($hardcodedmod, 'sectionref');\n            }\n        }\n\n        // mark modules in the recycle bin as section 0\n        $db->columnUpdate('sectionref', 'section', 0, \"refcount=0\");\n//        $recycledmods = $db->selectObjects('sectionref',\"refcount=0\");\n//        foreach ($recycledmods as $recycledmod) {\n//            $recycledmod->section = 0;  // this is a module in the recycle bin\n//            $db->updateObject($recycledmod, 'sectionref');\n//        }\n        return $ret;\n    }\n\n}\n\n?>\n"], "buggy_code_start_loc": [41], "buggy_code_end_loc": [863], "fixing_code_start_loc": [42], "fixing_code_end_loc": [865], "type": "CWE-89", "message": "In framework/modules/navigation/controllers/navigationController.php in Exponent CMS v2.4.0 or older, the parameter \"target\" of function \"DragnDropReRank\" is directly used without any filtration which caused SQL injection. The payload can be used like this: /navigation/DragnDropReRank/target/1.", "other": {"cve": {"id": "CVE-2016-9288", "sourceIdentifier": "cve@mitre.org", "published": "2016-11-11T23:59:00.160", "lastModified": "2017-07-28T01:29:08.313", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In framework/modules/navigation/controllers/navigationController.php in Exponent CMS v2.4.0 or older, the parameter \"target\" of function \"DragnDropReRank\" is directly used without any filtration which caused SQL injection. The payload can be used like this: /navigation/DragnDropReRank/target/1."}, {"lang": "es", "value": "En framework/modules/navigation/controllers/navigationController.php en Exponent CMS v2.4.0 o versiones m\u00e1s antiguas, el par\u00e1metro \"target\" de la funci\u00f3n \"DragnDropReRank\" es usado directamente sin ning\u00fan filtrado lo que produce un inyecci\u00f3n SQL. La carga puede ser usada como esto: /navigation/DragnDropReRank/target/1."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:exponentcms:exponent_cms:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.4.0", "matchCriteriaId": "3563BB54-8589-4588-B4AE-5CE7EA36AF45"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/94296", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037280", "source": "cve@mitre.org"}, {"url": "https://github.com/exponentcms/exponent-cms/commit/2ddffb2e7eafe4830e3483a4b437873022c461ba", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/exponentcms/exponent-cms/commit/2ddffb2e7eafe4830e3483a4b437873022c461ba"}}