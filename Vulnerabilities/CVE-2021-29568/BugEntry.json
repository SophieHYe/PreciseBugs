{"buggy_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/random_ops.cc.\n// NOTE: If the algorithm is changed, please run the test\n// .../python/kernel_tests:parameterized_truncated_normal_op_test\n// commenting out the \"tf.set_random_seed(seed)\" lines, and using the\n// \"--runs-per-test=1000\" flag. This tests the statistical correctness of the\n// op results.\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/kernels/parameterized_truncated_normal_op.h\"\n\n#include <algorithm>\n#include <cmath>\n#include <memory>\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/kernels/stateless_random_ops.h\"\n#include \"tensorflow/core/lib/random/random_distributions.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/util/guarded_philox_random.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\nnamespace functor {\nusing random::PhiloxRandom;\n\nstatic constexpr int kMaxIterations = 1000;\n\ntemplate <typename T>\nstruct TruncatedNormalFunctor<CPUDevice, T> {\n  void operator()(OpKernelContext* ctx, const CPUDevice& d, int64 num_batches,\n                  int64 samples_per_batch, int64 num_elements,\n                  typename TTypes<T>::ConstFlat means,\n                  typename TTypes<T>::ConstFlat stddevs,\n                  typename TTypes<T>::ConstFlat minvals,\n                  typename TTypes<T>::ConstFlat maxvals,\n                  const random::PhiloxRandom& gen,\n                  typename TTypes<T>::Flat output) {\n    // The randn rejection sampling is used when the mean and at least this many\n    // standard deviations are inside the bounds.\n    // The uniform proposal samplers become less efficient as the bounds are\n    // further from the mean, the reverse is true for the randn sampler.\n    // This number was chosen by empirical benchmarking. If modified, the\n    // benchmarks in parameterized_truncated_normal_op_test should also be\n    // changed.\n    const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3);\n    auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads());\n\n    auto do_work = [samples_per_batch, num_elements, &ctx, &means, &stddevs,\n                    &minvals, &maxvals, &gen, &output,\n                    kStdDevsInsideBoundsToUseRandnSampler](int64 start_batch,\n                                                           int64 limit_batch) {\n      // Capturing \"gen\" by-value would only make a copy for the _shared_\n      // lambda.  Since we want to let each worker have its own copy, we pass\n      // \"gen\" by reference and explicitly do a copy assignment here.\n      random::PhiloxRandom gen_copy = gen;\n      // Skip takes units of 128 bytes.  +3 is so rounding doesn't lead to\n      // us using the same state in different batches.\n      // The sample from each iteration uses 2 random numbers.\n      gen_copy.Skip(start_batch * 2 * kMaxIterations * (samples_per_batch + 3) /\n                    4);\n      using Uniform = random::UniformDistribution<random::PhiloxRandom, T>;\n      Uniform dist;\n      using Normal = random::NormalDistribution<random::PhiloxRandom, T>;\n      Normal normal_dist;\n\n      // Vectorized intermediate calculations for uniform rejection sampling.\n      // We always generate at most 4 samples.\n      Eigen::array<T, 4> z;\n      Eigen::array<T, 4> g;\n\n      for (int64 b = start_batch; b < limit_batch; ++b) {\n        // We are passed a flat array for each of the parameter tensors.\n        // The input is either a scalar broadcasted to all batches or a vector\n        // with length num_batches, but the scalar becomes an array of length 1.\n        T mean = means((means.dimension(0) == 1) ? 0 : b);\n        T stddev = stddevs((stddevs.dimension(0) == 1) ? 0 : b);\n        T minval = minvals((minvals.dimension(0) == 1) ? 0 : b);\n        T maxval = maxvals((maxvals.dimension(0) == 1) ? 0 : b);\n\n        // The last batch can be short, if we adjusted num_batches and\n        // samples_per_batch.\n        const int64 limit_sample =\n            std::min((b + 1) * samples_per_batch, num_elements);\n        int64 sample = b * samples_per_batch;\n\n        // On GPU, this check will just fill samples with NAN if it fails.\n        OP_REQUIRES(ctx,\n                    stddev > T(0) && minval < maxval &&\n                        (Eigen::numext::isfinite(minval) ||\n                         Eigen::numext::isfinite(maxval)),\n                    errors::InvalidArgument(\"Invalid parameters\"));\n\n        int num_iterations = 0;\n\n        // If possible, make one-sided bound be the lower bound, or make both\n        // bounds positive. Otherwise, the bounds are on either side of the\n        // mean.\n        if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) {\n          // Reverse all calculations. normMin and normMax will be flipped.\n          std::swap(minval, maxval);\n          stddev = -stddev;\n        }\n\n        // Calculate normalized samples, then convert them.\n        const T normMin = (minval - mean) / stddev;\n        const T normMax = (maxval - mean) / stddev;\n\n        // Determine the method to use.\n        const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4));\n        const T cutoff =\n            T(2) *\n            Eigen::numext::exp(T(0.5) +\n                               (normMin * (normMin - sqrtFactor)) / T(4)) /\n            (normMin + sqrtFactor);\n        const T diff = normMax - normMin;\n\n        if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMax >= T(0.))) ||\n            ((normMax > kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMin <= T(0.)))) {\n          // If the bounds are a least 3 standard deviations from the mean\n          // on at least one side then we rejection sample by sampling\n          // from the normal distribution and rejecting samples outside\n          // the bounds.\n          // Under this condition the acceptance rate per iteration should\n          // always be ~ 50%. This sampler is more efficient (and more\n          // numerically stable when one or both bounds is far from the mean).\n\n          while (sample < limit_sample) {\n            const auto randn_sample = normal_dist(&gen_copy);\n            const int size = randn_sample.size();\n\n            for (int i = 0; i < size; i++) {\n              if ((randn_sample[i] >= normMin) &&\n                  (randn_sample[i] <= normMax)) {\n                output(sample) = randn_sample[i] * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n                if (num_iterations > kMaxIterations) {\n                  // This should never occur because this sampler should\n                  // (by the selection criteria above) be used if at least 3\n                  // standard deviations of one side of the distribution\n                  // is within the limits (so acceptance probability per\n                  // iterations >~ 1/2 per iteration).\n                  LOG(ERROR) << \"TruncatedNormal randn rejection sampler \"\n                             << \"exceeded maximum iterations for \"\n                             << \"normMin=\" << normMin << \" normMax=\" << normMax\n                             << \" kMaxIterations=\" << kMaxIterations;\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal randn rejection sampler failed to accept\"\n                      \" a sample.\"));\n                  return;\n                }\n              }\n            }\n          }\n        } else if (diff < cutoff) {\n          // Sample from a uniform distribution on [normMin, normMax].\n\n          const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin;\n\n          while (sample < limit_sample) {\n            const auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            // NOTE(ringwalt): These loops seem to only generate packed AVX\n            // instructions for float32.\n            for (int i = 0; i < size; i++) {\n              z[i] = rand[i] * diff + normMin;\n            }\n            for (int i = 0; i < size; i++) {\n              g[i] = (plusFactor - z[i] * z[i]) / T(2.0);\n            }\n\n            const auto u = dist(&gen_copy);\n            for (int i = 0; i < size; i++) {\n              auto accept = u[i] <= Eigen::numext::exp(g[i]);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                // Accept the sample z.\n                // If we run out of iterations, just use the current uniform\n                // sample, but emit a warning.\n                // TODO(jjhunt) For small entropies (relative to the bounds),\n                // this sampler is poor and may take many iterations since\n                // the proposal distribution is the uniform distribution\n                // U(lower_bound, upper_bound).\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal uniform rejection sampler \"\n                             << \"exceeded max iterations. Sample may contain \"\n                             << \"outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal uniform rejection sampler failed to \"\n                      \" accept a sample.\"));\n                  return;\n                }\n                output(sample) = z[i] * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        } else {\n          // Sample from an exponential distribution with alpha maximizing\n          // acceptance probability, offset by normMin from the origin.\n          // Accept only if less than normMax.\n          const T alpha =\n              (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) /\n              T(2);\n          while (sample < limit_sample) {\n            auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            int i = 0;\n            while (i < size) {\n              const T z = -Eigen::numext::log(rand[i]) / alpha + normMin;\n              i++;\n              const T x = normMin < alpha ? alpha - z : normMin - alpha;\n              const T g = Eigen::numext::exp(-x * x / T(2.0));\n              const T u = rand[i];\n              i++;\n              auto accept = (u <= g && z < normMax);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal exponential distribution \"\n                             << \"rejection sampler exceeds max iterations. \"\n                             << \"Sample may contain outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal exponential distribution rejection\"\n                      \" sampler failed to accept a sample.\"));\n                  return;\n                }\n                output(sample) = z * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        }\n      }\n    };\n    // The cost of the initial calculations for the batch.\n    const int64 batchInitCost =\n        // normMin, normMax\n        (Eigen::TensorOpCost::AddCost<T>() +\n         Eigen::TensorOpCost::MulCost<T>()) *\n            2\n        // sqrtFactor\n        + Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_sqrt_op<T>>::Cost\n        // cutoff\n        + Eigen::TensorOpCost::MulCost<T>() * 4 +\n        Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost\n        // diff\n        + Eigen::TensorOpCost::AddCost<T>();\n    const int64 uniformSampleCost =\n        random::PhiloxRandom::kElementCost +\n        random::UniformDistribution<random::PhiloxRandom, T>::kElementCost;\n    // The cost of a single uniform sampling round.\n    const int64 uniformRejectionSamplingCost =\n        uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() * 2 +\n        Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_exp_op<T>>::Cost +\n        Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>();\n    // Estimate the cost for an entire batch.\n    // Assume we use uniform sampling, and accept the 2nd sample on average.\n    const int64 batchCost =\n        batchInitCost + uniformRejectionSamplingCost * 2 * samples_per_batch;\n    Shard(worker_threads.num_threads, worker_threads.workers, num_batches,\n          batchCost, do_work);\n  }\n};\n\ntemplate <typename T>\nstruct TruncatedNormalFunctorV2<CPUDevice, T> {\n  void operator()(OpKernelContext* ctx, const CPUDevice& d, int64 num_batches,\n                  int64 samples_per_batch, int64 num_elements,\n                  const BCastList<4>& bcast,\n                  typename TTypes<T>::ConstFlat means,\n                  typename TTypes<T>::ConstFlat stddevs,\n                  typename TTypes<T>::ConstFlat minvals,\n                  typename TTypes<T>::ConstFlat maxvals,\n                  const random::PhiloxRandom& gen,\n                  typename TTypes<T>::Flat output) {\n    // The randn rejection sampling is used when the mean and at least this many\n    // standard deviations are inside the bounds.\n    // The uniform proposal samplers become less efficient as the bounds are\n    // further from the mean, the reverse is true for the randn sampler.\n    // This number was chosen by empirical benchmarking. If modified, the\n    // benchmarks in parameterized_truncated_normal_op_test should also be\n    // changed.\n    const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3);\n    auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads());\n\n    auto do_work = [num_batches, samples_per_batch, &ctx, &bcast, &means,\n                    &stddevs, &minvals, &maxvals, &gen, &output,\n                    kStdDevsInsideBoundsToUseRandnSampler](int64 start_output,\n                                                           int64 limit_output) {\n      // Capturing \"gen\" by-value would only make a copy for the _shared_\n      // lambda.  Since we want to let each worker have its own copy, we pass\n      // \"gen\" by reference and explicitly do a copy assignment here.\n      random::PhiloxRandom gen_copy = gen;\n      using Uniform = random::UniformDistribution<random::PhiloxRandom, T>;\n      Uniform dist;\n      using Normal = random::NormalDistribution<random::PhiloxRandom, T>;\n      Normal normal_dist;\n      // Skip takes units of 128 bits. The Uniform::kResultElementCount - 1\n      // is so rounding doesn't lead to\n      // us using the same state in different workloads.\n      // The sample from each iteration uses 2 random numbers.\n      gen_copy.Skip((start_output * 2 * kMaxIterations +\n                     Uniform::kResultElementCount - 1) /\n                    Uniform::kResultElementCount);\n\n      // Vectorized intermediate calculations for uniform rejection sampling.\n      // We always generate at most 4 samples.\n      Eigen::array<T, Uniform::kResultElementCount> z;\n      Eigen::array<T, Uniform::kResultElementCount> g;\n\n      const bool should_bcast = bcast.IsBroadcastingRequired();\n      const auto& means_batch_indices = bcast.batch_indices(0);\n      const auto& stddevs_batch_indices = bcast.batch_indices(1);\n      const auto& minvals_batch_indices = bcast.batch_indices(2);\n      const auto& maxvals_batch_indices = bcast.batch_indices(3);\n      auto output_flat = output.data();\n\n      // We partition work across batches and then across samples\n      // per batch member, to avoid extra work.\n      for (int64 output_idx = start_output; output_idx < limit_output;\n           // output_idx is incremented with the inner loops below.\n      ) {\n        int64 batch_idx = output_idx / samples_per_batch;\n        // The output layout is [samples_per_batch, num_batches]. Thus\n        // the output address is sample_idx * num_batches + batch_idx.\n        // Below, code will index at output_batch_offset[sample_idx *\n        // num_batches] matching this.\n        T* const output_batch_offset = output_flat + batch_idx;\n        // Generate batch counts from BCast, as it has the right indices to loop\n        // over.\n        T mean, stddev, minval, maxval;\n        if (should_bcast) {\n          mean = means(means_batch_indices[batch_idx]);\n          stddev = stddevs(stddevs_batch_indices[batch_idx]);\n          minval = minvals(minvals_batch_indices[batch_idx]);\n          maxval = maxvals(maxvals_batch_indices[batch_idx]);\n        } else {\n          mean = means(batch_idx);\n          stddev = stddevs(batch_idx);\n          minval = minvals(batch_idx);\n          maxval = maxvals(batch_idx);\n        }\n\n        // On GPU, this check will just fill samples with NAN if it fails.\n        OP_REQUIRES(ctx,\n                    stddev > T(0) && minval < maxval &&\n                        (Eigen::numext::isfinite(minval) ||\n                         Eigen::numext::isfinite(maxval)),\n                    errors::InvalidArgument(\"Invalid parameters\"));\n\n        int num_iterations = 0;\n\n        // If possible, make one-sided bound be the lower bound, or make both\n        // bounds positive. Otherwise, the bounds are on either side of the\n        // mean.\n        if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) {\n          // Reverse all calculations. normMin and normMax will be flipped.\n          std::swap(minval, maxval);\n          stddev = -stddev;\n        }\n\n        // Calculate normalized samples, then convert them.\n        const T normMin = (minval - mean) / stddev;\n        const T normMax = (maxval - mean) / stddev;\n\n        // Determine the method to use.\n        const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4));\n        const T cutoff =\n            T(2) *\n            Eigen::numext::exp(T(0.5) +\n                               (normMin * (normMin - sqrtFactor)) / T(4)) /\n            (normMin + sqrtFactor);\n        const T diff = normMax - normMin;\n\n        if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMax >= T(0.))) ||\n            ((normMax > kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMin <= T(0.)))) {\n          // If the bounds are a least 3 standard deviations from the mean\n          // on at least one side then we rejection sample by sampling\n          // from the normal distribution and rejecting samples outside\n          // the bounds.\n          // Under this condition the acceptance rate per iteration should\n          // always be ~ 50%. This sampler is more efficient (and more\n          // numerically stable when one or both bounds is far from the mean).\n          for (int64 sample_idx = output_idx % samples_per_batch;\n               sample_idx < samples_per_batch && output_idx < limit_output;) {\n            const auto randn_sample = normal_dist(&gen_copy);\n            const int size = randn_sample.size();\n            for (int i = 0; i < size; ++i) {\n              if ((randn_sample[i] >= normMin) &&\n                  (randn_sample[i] <= normMax)) {\n                output_batch_offset[sample_idx * num_batches] =\n                    randn_sample[i] * stddev + mean;\n                ++sample_idx;\n                ++output_idx;\n                if (sample_idx >= samples_per_batch ||\n                    output_idx >= limit_output) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                ++num_iterations;\n                if (num_iterations > kMaxIterations) {\n                  // This should never occur because this sampler should\n                  // (by the selection criteria above) be used if at least 3\n                  // standard deviations of one side of the distribution\n                  // is within the limits (so acceptance probability per\n                  // iterations >~ 1/2 per iteration).\n                  LOG(ERROR) << \"TruncatedNormal randn rejection sampler \"\n                             << \"exceeded maximum iterations for \"\n                             << \"normMin=\" << normMin << \" normMax=\" << normMax\n                             << \" kMaxIterations=\" << kMaxIterations;\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal randn rejection sampler failed to accept\"\n                      \" a sample.\"));\n                  return;\n                }\n              }\n            }\n          }\n        } else if (diff < cutoff) {\n          // Sample from a uniform distribution on [normMin, normMax].\n\n          const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin;\n\n          for (int64 sample_idx = output_idx % samples_per_batch;\n               sample_idx < samples_per_batch && output_idx < limit_output;) {\n            const auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            // NOTE(ringwalt): These loops seem to only generate packed AVX\n            // instructions for float32.\n            for (int i = 0; i < size; i++) {\n              z[i] = rand[i] * diff + normMin;\n              g[i] = (plusFactor - z[i] * z[i]) / T(2.0);\n            }\n\n            const auto u = dist(&gen_copy);\n            for (int i = 0; i < size; i++) {\n              auto accept = u[i] <= Eigen::numext::exp(g[i]);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                // Accept the sample z.\n                // If we run out of iterations, just use the current uniform\n                // sample, but emit a warning.\n                // TODO(jjhunt) For small entropies (relative to the bounds),\n                // this sampler is poor and may take many iterations since\n                // the proposal distribution is the uniform distribution\n                // U(lower_bound, upper_bound).\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal uniform rejection sampler \"\n                             << \"exceeded max iterations. Sample may contain \"\n                             << \"outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal uniform rejection sampler failed to \"\n                      \" accept a sample.\"));\n                  return;\n                }\n                output_batch_offset[sample_idx * num_batches] =\n                    z[i] * stddev + mean;\n                ++sample_idx;\n                ++output_idx;\n                if (sample_idx >= samples_per_batch ||\n                    output_idx >= limit_output) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        } else {\n          // Sample from an exponential distribution with alpha maximizing\n          // acceptance probability, offset by normMin from the origin.\n          // Accept only if less than normMax.\n          const T alpha =\n              (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) /\n              T(2);\n          for (int64 sample_idx = output_idx % samples_per_batch;\n               sample_idx < samples_per_batch && output_idx < limit_output;) {\n            auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            int i = 0;\n            while (i < size) {\n              const T z = -Eigen::numext::log(rand[i]) / alpha + normMin;\n              i++;\n              const T x = normMin < alpha ? alpha - z : normMin - alpha;\n              const T g = Eigen::numext::exp(-x * x / T(2.0));\n              const T u = rand[i];\n              i++;\n              auto accept = (u <= g && z < normMax);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal exponential distribution \"\n                             << \"rejection sampler exceeds max iterations. \"\n                             << \"Sample may contain outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal exponential distribution rejection\"\n                      \" sampler failed to accept a sample.\"));\n                  return;\n                }\n                output_batch_offset[sample_idx * num_batches] =\n                    z * stddev + mean;\n                ++sample_idx;\n                ++output_idx;\n                if (sample_idx >= samples_per_batch ||\n                    output_idx >= limit_output) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        }\n      }\n    };\n    // The cost of the initial calculations for the batch.\n    const int64 batchInitCost =\n        // normMin, normMax\n        (Eigen::TensorOpCost::AddCost<T>() +\n         Eigen::TensorOpCost::MulCost<T>()) *\n            2\n        // sqrtFactor\n        + Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_sqrt_op<T>>::Cost\n        // cutoff\n        + Eigen::TensorOpCost::MulCost<T>() * 4 +\n        Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost\n        // diff\n        + Eigen::TensorOpCost::AddCost<T>();\n    const int64 uniformSampleCost =\n        random::PhiloxRandom::kElementCost +\n        random::UniformDistribution<random::PhiloxRandom, T>::kElementCost;\n    // The cost of a single uniform sampling round.\n    const int64 uniformRejectionSamplingCost =\n        uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() * 2 +\n        Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_exp_op<T>>::Cost +\n        Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>();\n    // Estimate the cost for an entire batch.\n    // Assume we use uniform sampling, and accept the 2nd sample on average.\n    const int64 batchCost = batchInitCost + uniformRejectionSamplingCost * 2;\n    Shard(worker_threads.num_threads, worker_threads.workers, num_elements,\n          batchCost, do_work);\n  }\n};\n\n}  // namespace functor\n\nnamespace {\n\n// Samples from a truncated normal distribution, using the given parameters.\ntemplate <typename Device, typename T>\nclass ParameterizedTruncatedNormalOp : public OpKernel {\n  // Reshape batches so each batch is this size if possible.\n  static constexpr int32 kDesiredBatchSize = 100;\n\n public:\n  explicit ParameterizedTruncatedNormalOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, generator_.Init(context));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& shape_tensor = ctx->input(0);\n    const Tensor& means_tensor = ctx->input(1);\n    const Tensor& stddevs_tensor = ctx->input(2);\n    const Tensor& minvals_tensor = ctx->input(3);\n    const Tensor& maxvals_tensor = ctx->input(4);\n\n    OP_REQUIRES(\n        ctx, TensorShapeUtils::IsVector(shape_tensor.shape()),\n        errors::InvalidArgument(\"Input shape should be a vector, got shape: \",\n                                shape_tensor.shape().DebugString()));\n    int32 num_batches = shape_tensor.flat<int32>()(0);\n\n    int32 samples_per_batch = 1;\n    const int32 num_dims = shape_tensor.dim_size(0);\n    for (int32 i = 1; i < num_dims; i++) {\n      samples_per_batch *= shape_tensor.flat<int32>()(i);\n    }\n    const int32 num_elements = num_batches * samples_per_batch;\n\n    // Allocate the output before fudging num_batches and samples_per_batch.\n    auto shape_vec = shape_tensor.flat<int32>();\n    TensorShape tensor_shape;\n    OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(\n                            shape_vec.data(), shape_vec.size(), &tensor_shape));\n    Tensor* samples_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, tensor_shape, &samples_tensor));\n\n    // Parameters must be 0-d or 1-d.\n    OP_REQUIRES(ctx, means_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input means should be a scalar or vector, got shape: \",\n                    means_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, stddevs_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input stddevs should be a scalar or vector, got shape: \",\n                    stddevs_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, minvals_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input minvals should be a scalar or vector, got shape: \",\n                    minvals_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, maxvals_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input maxvals should be a scalar or vector, got shape: \",\n                    maxvals_tensor.shape().DebugString()));\n\n    if ((means_tensor.dims() == 0 || means_tensor.dim_size(0) == 1) &&\n        (stddevs_tensor.dims() == 0 || stddevs_tensor.dim_size(0) == 1) &&\n        minvals_tensor.dims() == 0 && maxvals_tensor.dims() == 0) {\n      // All batches have the same parameters, so we can update the batch size\n      // to a reasonable value to improve parallelism (ensure enough batches,\n      // and no very small batches which have high overhead).\n      int32 size = num_batches * samples_per_batch;\n      int32 adjusted_samples = kDesiredBatchSize;\n      // Ensure adjusted_batches * adjusted_samples >= size.\n      int32 adjusted_batches = Eigen::divup(size, adjusted_samples);\n      num_batches = adjusted_batches;\n      samples_per_batch = adjusted_samples;\n    } else {\n      // Parameters must be broadcastable to the shape [num_batches].\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(means_tensor.shape()) ||\n              means_tensor.dim_size(0) == 1 ||\n              means_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input means should have length 1 or shape[0], got shape: \",\n              means_tensor.shape().DebugString()));\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(stddevs_tensor.shape()) ||\n              stddevs_tensor.dim_size(0) == 1 ||\n              stddevs_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input stddevs should have length 1 or shape[0], got shape: \",\n              stddevs_tensor.shape().DebugString()));\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(minvals_tensor.shape()) ||\n              minvals_tensor.dim_size(0) == 1 ||\n              minvals_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input minvals should have length 1 or shape[0], got shape: \",\n              minvals_tensor.shape().DebugString()));\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(maxvals_tensor.shape()) ||\n              maxvals_tensor.dim_size(0) == 1 ||\n              maxvals_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input maxvals should have length 1 or shape[0], got shape: \",\n              maxvals_tensor.shape().DebugString()));\n    }\n\n    auto truncFunctor = functor::TruncatedNormalFunctor<Device, T>();\n    // Each worker has the fudge factor for samples_per_batch, so use it here.\n    random::PhiloxRandom rng =\n        generator_.ReserveSamples128(num_batches * 2 * functor::kMaxIterations *\n                                     (samples_per_batch + 3) / 4);\n    truncFunctor(ctx, ctx->eigen_device<Device>(), num_batches,\n                 samples_per_batch, num_elements, means_tensor.flat<T>(),\n                 stddevs_tensor.flat<T>(), minvals_tensor.flat<T>(),\n                 maxvals_tensor.flat<T>(), rng, samples_tensor->flat<T>());\n  }\n\n private:\n  GuardedPhiloxRandom generator_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(ParameterizedTruncatedNormalOp);\n};\n\n// Samples from a truncated normal distribution, using the given parameters.\ntemplate <typename Device, typename T>\nclass StatelessParameterizedTruncatedNormal : public OpKernel {\n  // Reshape batches so each batch is this size if possible.\n  static const int32 kDesiredBatchSize = 100;\n\n public:\n  explicit StatelessParameterizedTruncatedNormal(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& shape_tensor = ctx->input(0);\n    const Tensor& seed_tensor = ctx->input(1);\n    const Tensor& means_tensor = ctx->input(2);\n    const Tensor& stddevs_tensor = ctx->input(3);\n    const Tensor& minvals_tensor = ctx->input(4);\n    const Tensor& maxvals_tensor = ctx->input(5);\n\n    OP_REQUIRES(ctx, seed_tensor.dims() == 1 && seed_tensor.dim_size(0) == 2,\n                errors::InvalidArgument(\"seed must have shape [2], not \",\n                                        seed_tensor.shape().DebugString()));\n\n    tensorflow::BCastList<4> bcast(\n        {means_tensor.shape().dim_sizes(), stddevs_tensor.shape().dim_sizes(),\n         minvals_tensor.shape().dim_sizes(),\n         maxvals_tensor.shape().dim_sizes()},\n        /*fewer_dims_optimization=*/false,\n        /*return_flattened_batch_indices=*/true);\n\n    OP_REQUIRES(ctx, bcast.IsValid(),\n                errors::InvalidArgument(\n                    \"means, stddevs, minvals, maxvals must have compatible \"\n                    \"batch dimensions: \",\n                    means_tensor.shape().DebugString(), \" vs. \",\n                    stddevs_tensor.shape().DebugString(), \" vs. \",\n                    minvals_tensor.shape().DebugString(), \" vs. \",\n                    maxvals_tensor.shape().DebugString()));\n\n    // Let's check that the shape tensor dominates the broadcasted tensor.\n    TensorShape bcast_shape = BCast::ToShape(bcast.output_shape());\n    OP_REQUIRES(\n        ctx, TensorShapeUtils::IsVector(shape_tensor.shape()),\n        errors::InvalidArgument(\"Input shape should be a vector, got shape: \",\n                                shape_tensor.shape().DebugString()));\n    TensorShape output_shape;\n    if (shape_tensor.dtype() == DataType::DT_INT32) {\n      OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(shape_tensor.vec<int32>(),\n                                                      &output_shape));\n    } else {\n      OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(shape_tensor.vec<int64>(),\n                                                      &output_shape));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::EndsWith(output_shape, bcast_shape),\n                errors::InvalidArgument(\n                    \"Shape passed in must end with broadcasted shape.\"));\n\n    int64 samples_per_batch = 1;\n    const int64 num_sample_dims =\n        (shape_tensor.dim_size(0) - bcast.output_shape().size());\n    for (int64 i = 0; i < num_sample_dims; ++i) {\n      samples_per_batch *= output_shape.dim_size(i);\n    }\n    int64 num_batches = 1;\n    for (int64 i = num_sample_dims; i < shape_tensor.dim_size(0); ++i) {\n      num_batches *= output_shape.dim_size(i);\n    }\n    const int64 num_elements = num_batches * samples_per_batch;\n\n    Tensor* samples_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, output_shape, &samples_tensor));\n\n    auto truncFunctor = functor::TruncatedNormalFunctorV2<Device, T>();\n    // Each worker has the same fudge factor, so use it here.\n    random::PhiloxRandom::Key key;\n    random::PhiloxRandom::ResultType counter;\n    OP_REQUIRES_OK(ctx, GenerateKey(seed_tensor, &key, &counter));\n\n    auto philox = random::PhiloxRandom(counter, key);\n\n    truncFunctor(ctx, ctx->eigen_device<Device>(), num_batches,\n                 samples_per_batch, num_elements, bcast, means_tensor.flat<T>(),\n                 stddevs_tensor.flat<T>(), minvals_tensor.flat<T>(),\n                 maxvals_tensor.flat<T>(), philox, samples_tensor->flat<T>());\n  }\n\n private:\n  TF_DISALLOW_COPY_AND_ASSIGN(StatelessParameterizedTruncatedNormal);\n};\n\n}  // namespace\n\n#define REGISTER(TYPE)                                                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"ParameterizedTruncatedNormal\")             \\\n                              .Device(DEVICE_CPU)                          \\\n                              .TypeConstraint<TYPE>(\"dtype\"),              \\\n                          ParameterizedTruncatedNormalOp<CPUDevice, TYPE>) \\\n  REGISTER_KERNEL_BUILDER(                                                 \\\n      Name(\"StatelessParameterizedTruncatedNormal\")                        \\\n          .HostMemory(\"shape\")                                             \\\n          .HostMemory(\"seed\")                                              \\\n          .HostMemory(\"means\")                                             \\\n          .HostMemory(\"stddevs\")                                           \\\n          .HostMemory(\"minvals\")                                           \\\n          .HostMemory(\"maxvals\")                                           \\\n          .Device(DEVICE_CPU)                                              \\\n          .TypeConstraint<TYPE>(\"dtype\"),                                  \\\n      StatelessParameterizedTruncatedNormal<CPUDevice, TYPE>)\n\nTF_CALL_half(REGISTER);\nTF_CALL_float(REGISTER);\nTF_CALL_double(REGISTER);\n\n#undef REGISTER\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#define REGISTER(TYPE)                                         \\\n  REGISTER_KERNEL_BUILDER(Name(\"ParameterizedTruncatedNormal\") \\\n                              .Device(DEVICE_GPU)              \\\n                              .HostMemory(\"shape\")             \\\n                              .TypeConstraint<TYPE>(\"dtype\"),  \\\n                          ParameterizedTruncatedNormalOp<GPUDevice, TYPE>)\n\nTF_CALL_half(REGISTER);\nTF_CALL_float(REGISTER);\nTF_CALL_double(REGISTER);\n\n#undef REGISTER\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // end namespace tensorflow\n"], "fixing_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/random_ops.cc.\n// NOTE: If the algorithm is changed, please run the test\n// .../python/kernel_tests:parameterized_truncated_normal_op_test\n// commenting out the \"tf.set_random_seed(seed)\" lines, and using the\n// \"--runs-per-test=1000\" flag. This tests the statistical correctness of the\n// op results.\n\n#define EIGEN_USE_THREADS\n\n#include \"tensorflow/core/kernels/parameterized_truncated_normal_op.h\"\n\n#include <algorithm>\n#include <cmath>\n#include <memory>\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/kernels/stateless_random_ops.h\"\n#include \"tensorflow/core/lib/random/random_distributions.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/util/guarded_philox_random.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\nnamespace functor {\nusing random::PhiloxRandom;\n\nstatic constexpr int kMaxIterations = 1000;\n\ntemplate <typename T>\nstruct TruncatedNormalFunctor<CPUDevice, T> {\n  void operator()(OpKernelContext* ctx, const CPUDevice& d, int64 num_batches,\n                  int64 samples_per_batch, int64 num_elements,\n                  typename TTypes<T>::ConstFlat means,\n                  typename TTypes<T>::ConstFlat stddevs,\n                  typename TTypes<T>::ConstFlat minvals,\n                  typename TTypes<T>::ConstFlat maxvals,\n                  const random::PhiloxRandom& gen,\n                  typename TTypes<T>::Flat output) {\n    // The randn rejection sampling is used when the mean and at least this many\n    // standard deviations are inside the bounds.\n    // The uniform proposal samplers become less efficient as the bounds are\n    // further from the mean, the reverse is true for the randn sampler.\n    // This number was chosen by empirical benchmarking. If modified, the\n    // benchmarks in parameterized_truncated_normal_op_test should also be\n    // changed.\n    const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3);\n    auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads());\n\n    auto do_work = [samples_per_batch, num_elements, &ctx, &means, &stddevs,\n                    &minvals, &maxvals, &gen, &output,\n                    kStdDevsInsideBoundsToUseRandnSampler](int64 start_batch,\n                                                           int64 limit_batch) {\n      // Capturing \"gen\" by-value would only make a copy for the _shared_\n      // lambda.  Since we want to let each worker have its own copy, we pass\n      // \"gen\" by reference and explicitly do a copy assignment here.\n      random::PhiloxRandom gen_copy = gen;\n      // Skip takes units of 128 bytes.  +3 is so rounding doesn't lead to\n      // us using the same state in different batches.\n      // The sample from each iteration uses 2 random numbers.\n      gen_copy.Skip(start_batch * 2 * kMaxIterations * (samples_per_batch + 3) /\n                    4);\n      using Uniform = random::UniformDistribution<random::PhiloxRandom, T>;\n      Uniform dist;\n      using Normal = random::NormalDistribution<random::PhiloxRandom, T>;\n      Normal normal_dist;\n\n      // Vectorized intermediate calculations for uniform rejection sampling.\n      // We always generate at most 4 samples.\n      Eigen::array<T, 4> z;\n      Eigen::array<T, 4> g;\n\n      for (int64 b = start_batch; b < limit_batch; ++b) {\n        // We are passed a flat array for each of the parameter tensors.\n        // The input is either a scalar broadcasted to all batches or a vector\n        // with length num_batches, but the scalar becomes an array of length 1.\n        T mean = means((means.dimension(0) == 1) ? 0 : b);\n        T stddev = stddevs((stddevs.dimension(0) == 1) ? 0 : b);\n        T minval = minvals((minvals.dimension(0) == 1) ? 0 : b);\n        T maxval = maxvals((maxvals.dimension(0) == 1) ? 0 : b);\n\n        // The last batch can be short, if we adjusted num_batches and\n        // samples_per_batch.\n        const int64 limit_sample =\n            std::min((b + 1) * samples_per_batch, num_elements);\n        int64 sample = b * samples_per_batch;\n\n        // On GPU, this check will just fill samples with NAN if it fails.\n        OP_REQUIRES(ctx,\n                    stddev > T(0) && minval < maxval &&\n                        (Eigen::numext::isfinite(minval) ||\n                         Eigen::numext::isfinite(maxval)),\n                    errors::InvalidArgument(\"Invalid parameters\"));\n\n        int num_iterations = 0;\n\n        // If possible, make one-sided bound be the lower bound, or make both\n        // bounds positive. Otherwise, the bounds are on either side of the\n        // mean.\n        if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) {\n          // Reverse all calculations. normMin and normMax will be flipped.\n          std::swap(minval, maxval);\n          stddev = -stddev;\n        }\n\n        // Calculate normalized samples, then convert them.\n        const T normMin = (minval - mean) / stddev;\n        const T normMax = (maxval - mean) / stddev;\n\n        // Determine the method to use.\n        const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4));\n        const T cutoff =\n            T(2) *\n            Eigen::numext::exp(T(0.5) +\n                               (normMin * (normMin - sqrtFactor)) / T(4)) /\n            (normMin + sqrtFactor);\n        const T diff = normMax - normMin;\n\n        if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMax >= T(0.))) ||\n            ((normMax > kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMin <= T(0.)))) {\n          // If the bounds are a least 3 standard deviations from the mean\n          // on at least one side then we rejection sample by sampling\n          // from the normal distribution and rejecting samples outside\n          // the bounds.\n          // Under this condition the acceptance rate per iteration should\n          // always be ~ 50%. This sampler is more efficient (and more\n          // numerically stable when one or both bounds is far from the mean).\n\n          while (sample < limit_sample) {\n            const auto randn_sample = normal_dist(&gen_copy);\n            const int size = randn_sample.size();\n\n            for (int i = 0; i < size; i++) {\n              if ((randn_sample[i] >= normMin) &&\n                  (randn_sample[i] <= normMax)) {\n                output(sample) = randn_sample[i] * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n                if (num_iterations > kMaxIterations) {\n                  // This should never occur because this sampler should\n                  // (by the selection criteria above) be used if at least 3\n                  // standard deviations of one side of the distribution\n                  // is within the limits (so acceptance probability per\n                  // iterations >~ 1/2 per iteration).\n                  LOG(ERROR) << \"TruncatedNormal randn rejection sampler \"\n                             << \"exceeded maximum iterations for \"\n                             << \"normMin=\" << normMin << \" normMax=\" << normMax\n                             << \" kMaxIterations=\" << kMaxIterations;\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal randn rejection sampler failed to accept\"\n                      \" a sample.\"));\n                  return;\n                }\n              }\n            }\n          }\n        } else if (diff < cutoff) {\n          // Sample from a uniform distribution on [normMin, normMax].\n\n          const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin;\n\n          while (sample < limit_sample) {\n            const auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            // NOTE(ringwalt): These loops seem to only generate packed AVX\n            // instructions for float32.\n            for (int i = 0; i < size; i++) {\n              z[i] = rand[i] * diff + normMin;\n            }\n            for (int i = 0; i < size; i++) {\n              g[i] = (plusFactor - z[i] * z[i]) / T(2.0);\n            }\n\n            const auto u = dist(&gen_copy);\n            for (int i = 0; i < size; i++) {\n              auto accept = u[i] <= Eigen::numext::exp(g[i]);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                // Accept the sample z.\n                // If we run out of iterations, just use the current uniform\n                // sample, but emit a warning.\n                // TODO(jjhunt) For small entropies (relative to the bounds),\n                // this sampler is poor and may take many iterations since\n                // the proposal distribution is the uniform distribution\n                // U(lower_bound, upper_bound).\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal uniform rejection sampler \"\n                             << \"exceeded max iterations. Sample may contain \"\n                             << \"outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal uniform rejection sampler failed to \"\n                      \" accept a sample.\"));\n                  return;\n                }\n                output(sample) = z[i] * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        } else {\n          // Sample from an exponential distribution with alpha maximizing\n          // acceptance probability, offset by normMin from the origin.\n          // Accept only if less than normMax.\n          const T alpha =\n              (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) /\n              T(2);\n          while (sample < limit_sample) {\n            auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            int i = 0;\n            while (i < size) {\n              const T z = -Eigen::numext::log(rand[i]) / alpha + normMin;\n              i++;\n              const T x = normMin < alpha ? alpha - z : normMin - alpha;\n              const T g = Eigen::numext::exp(-x * x / T(2.0));\n              const T u = rand[i];\n              i++;\n              auto accept = (u <= g && z < normMax);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal exponential distribution \"\n                             << \"rejection sampler exceeds max iterations. \"\n                             << \"Sample may contain outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal exponential distribution rejection\"\n                      \" sampler failed to accept a sample.\"));\n                  return;\n                }\n                output(sample) = z * stddev + mean;\n                sample++;\n                if (sample >= limit_sample) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        }\n      }\n    };\n    // The cost of the initial calculations for the batch.\n    const int64 batchInitCost =\n        // normMin, normMax\n        (Eigen::TensorOpCost::AddCost<T>() +\n         Eigen::TensorOpCost::MulCost<T>()) *\n            2\n        // sqrtFactor\n        + Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_sqrt_op<T>>::Cost\n        // cutoff\n        + Eigen::TensorOpCost::MulCost<T>() * 4 +\n        Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost\n        // diff\n        + Eigen::TensorOpCost::AddCost<T>();\n    const int64 uniformSampleCost =\n        random::PhiloxRandom::kElementCost +\n        random::UniformDistribution<random::PhiloxRandom, T>::kElementCost;\n    // The cost of a single uniform sampling round.\n    const int64 uniformRejectionSamplingCost =\n        uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() * 2 +\n        Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_exp_op<T>>::Cost +\n        Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>();\n    // Estimate the cost for an entire batch.\n    // Assume we use uniform sampling, and accept the 2nd sample on average.\n    const int64 batchCost =\n        batchInitCost + uniformRejectionSamplingCost * 2 * samples_per_batch;\n    Shard(worker_threads.num_threads, worker_threads.workers, num_batches,\n          batchCost, do_work);\n  }\n};\n\ntemplate <typename T>\nstruct TruncatedNormalFunctorV2<CPUDevice, T> {\n  void operator()(OpKernelContext* ctx, const CPUDevice& d, int64 num_batches,\n                  int64 samples_per_batch, int64 num_elements,\n                  const BCastList<4>& bcast,\n                  typename TTypes<T>::ConstFlat means,\n                  typename TTypes<T>::ConstFlat stddevs,\n                  typename TTypes<T>::ConstFlat minvals,\n                  typename TTypes<T>::ConstFlat maxvals,\n                  const random::PhiloxRandom& gen,\n                  typename TTypes<T>::Flat output) {\n    // The randn rejection sampling is used when the mean and at least this many\n    // standard deviations are inside the bounds.\n    // The uniform proposal samplers become less efficient as the bounds are\n    // further from the mean, the reverse is true for the randn sampler.\n    // This number was chosen by empirical benchmarking. If modified, the\n    // benchmarks in parameterized_truncated_normal_op_test should also be\n    // changed.\n    const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3);\n    auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads());\n\n    auto do_work = [num_batches, samples_per_batch, &ctx, &bcast, &means,\n                    &stddevs, &minvals, &maxvals, &gen, &output,\n                    kStdDevsInsideBoundsToUseRandnSampler](int64 start_output,\n                                                           int64 limit_output) {\n      // Capturing \"gen\" by-value would only make a copy for the _shared_\n      // lambda.  Since we want to let each worker have its own copy, we pass\n      // \"gen\" by reference and explicitly do a copy assignment here.\n      random::PhiloxRandom gen_copy = gen;\n      using Uniform = random::UniformDistribution<random::PhiloxRandom, T>;\n      Uniform dist;\n      using Normal = random::NormalDistribution<random::PhiloxRandom, T>;\n      Normal normal_dist;\n      // Skip takes units of 128 bits. The Uniform::kResultElementCount - 1\n      // is so rounding doesn't lead to\n      // us using the same state in different workloads.\n      // The sample from each iteration uses 2 random numbers.\n      gen_copy.Skip((start_output * 2 * kMaxIterations +\n                     Uniform::kResultElementCount - 1) /\n                    Uniform::kResultElementCount);\n\n      // Vectorized intermediate calculations for uniform rejection sampling.\n      // We always generate at most 4 samples.\n      Eigen::array<T, Uniform::kResultElementCount> z;\n      Eigen::array<T, Uniform::kResultElementCount> g;\n\n      const bool should_bcast = bcast.IsBroadcastingRequired();\n      const auto& means_batch_indices = bcast.batch_indices(0);\n      const auto& stddevs_batch_indices = bcast.batch_indices(1);\n      const auto& minvals_batch_indices = bcast.batch_indices(2);\n      const auto& maxvals_batch_indices = bcast.batch_indices(3);\n      auto output_flat = output.data();\n\n      // We partition work across batches and then across samples\n      // per batch member, to avoid extra work.\n      for (int64 output_idx = start_output; output_idx < limit_output;\n           // output_idx is incremented with the inner loops below.\n      ) {\n        int64 batch_idx = output_idx / samples_per_batch;\n        // The output layout is [samples_per_batch, num_batches]. Thus\n        // the output address is sample_idx * num_batches + batch_idx.\n        // Below, code will index at output_batch_offset[sample_idx *\n        // num_batches] matching this.\n        T* const output_batch_offset = output_flat + batch_idx;\n        // Generate batch counts from BCast, as it has the right indices to loop\n        // over.\n        T mean, stddev, minval, maxval;\n        if (should_bcast) {\n          mean = means(means_batch_indices[batch_idx]);\n          stddev = stddevs(stddevs_batch_indices[batch_idx]);\n          minval = minvals(minvals_batch_indices[batch_idx]);\n          maxval = maxvals(maxvals_batch_indices[batch_idx]);\n        } else {\n          mean = means(batch_idx);\n          stddev = stddevs(batch_idx);\n          minval = minvals(batch_idx);\n          maxval = maxvals(batch_idx);\n        }\n\n        // On GPU, this check will just fill samples with NAN if it fails.\n        OP_REQUIRES(ctx,\n                    stddev > T(0) && minval < maxval &&\n                        (Eigen::numext::isfinite(minval) ||\n                         Eigen::numext::isfinite(maxval)),\n                    errors::InvalidArgument(\"Invalid parameters\"));\n\n        int num_iterations = 0;\n\n        // If possible, make one-sided bound be the lower bound, or make both\n        // bounds positive. Otherwise, the bounds are on either side of the\n        // mean.\n        if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) {\n          // Reverse all calculations. normMin and normMax will be flipped.\n          std::swap(minval, maxval);\n          stddev = -stddev;\n        }\n\n        // Calculate normalized samples, then convert them.\n        const T normMin = (minval - mean) / stddev;\n        const T normMax = (maxval - mean) / stddev;\n\n        // Determine the method to use.\n        const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4));\n        const T cutoff =\n            T(2) *\n            Eigen::numext::exp(T(0.5) +\n                               (normMin * (normMin - sqrtFactor)) / T(4)) /\n            (normMin + sqrtFactor);\n        const T diff = normMax - normMin;\n\n        if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMax >= T(0.))) ||\n            ((normMax > kStdDevsInsideBoundsToUseRandnSampler) &&\n             (normMin <= T(0.)))) {\n          // If the bounds are a least 3 standard deviations from the mean\n          // on at least one side then we rejection sample by sampling\n          // from the normal distribution and rejecting samples outside\n          // the bounds.\n          // Under this condition the acceptance rate per iteration should\n          // always be ~ 50%. This sampler is more efficient (and more\n          // numerically stable when one or both bounds is far from the mean).\n          for (int64 sample_idx = output_idx % samples_per_batch;\n               sample_idx < samples_per_batch && output_idx < limit_output;) {\n            const auto randn_sample = normal_dist(&gen_copy);\n            const int size = randn_sample.size();\n            for (int i = 0; i < size; ++i) {\n              if ((randn_sample[i] >= normMin) &&\n                  (randn_sample[i] <= normMax)) {\n                output_batch_offset[sample_idx * num_batches] =\n                    randn_sample[i] * stddev + mean;\n                ++sample_idx;\n                ++output_idx;\n                if (sample_idx >= samples_per_batch ||\n                    output_idx >= limit_output) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                ++num_iterations;\n                if (num_iterations > kMaxIterations) {\n                  // This should never occur because this sampler should\n                  // (by the selection criteria above) be used if at least 3\n                  // standard deviations of one side of the distribution\n                  // is within the limits (so acceptance probability per\n                  // iterations >~ 1/2 per iteration).\n                  LOG(ERROR) << \"TruncatedNormal randn rejection sampler \"\n                             << \"exceeded maximum iterations for \"\n                             << \"normMin=\" << normMin << \" normMax=\" << normMax\n                             << \" kMaxIterations=\" << kMaxIterations;\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal randn rejection sampler failed to accept\"\n                      \" a sample.\"));\n                  return;\n                }\n              }\n            }\n          }\n        } else if (diff < cutoff) {\n          // Sample from a uniform distribution on [normMin, normMax].\n\n          const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin;\n\n          for (int64 sample_idx = output_idx % samples_per_batch;\n               sample_idx < samples_per_batch && output_idx < limit_output;) {\n            const auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            // NOTE(ringwalt): These loops seem to only generate packed AVX\n            // instructions for float32.\n            for (int i = 0; i < size; i++) {\n              z[i] = rand[i] * diff + normMin;\n              g[i] = (plusFactor - z[i] * z[i]) / T(2.0);\n            }\n\n            const auto u = dist(&gen_copy);\n            for (int i = 0; i < size; i++) {\n              auto accept = u[i] <= Eigen::numext::exp(g[i]);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                // Accept the sample z.\n                // If we run out of iterations, just use the current uniform\n                // sample, but emit a warning.\n                // TODO(jjhunt) For small entropies (relative to the bounds),\n                // this sampler is poor and may take many iterations since\n                // the proposal distribution is the uniform distribution\n                // U(lower_bound, upper_bound).\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal uniform rejection sampler \"\n                             << \"exceeded max iterations. Sample may contain \"\n                             << \"outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal uniform rejection sampler failed to \"\n                      \" accept a sample.\"));\n                  return;\n                }\n                output_batch_offset[sample_idx * num_batches] =\n                    z[i] * stddev + mean;\n                ++sample_idx;\n                ++output_idx;\n                if (sample_idx >= samples_per_batch ||\n                    output_idx >= limit_output) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        } else {\n          // Sample from an exponential distribution with alpha maximizing\n          // acceptance probability, offset by normMin from the origin.\n          // Accept only if less than normMax.\n          const T alpha =\n              (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) /\n              T(2);\n          for (int64 sample_idx = output_idx % samples_per_batch;\n               sample_idx < samples_per_batch && output_idx < limit_output;) {\n            auto rand = dist(&gen_copy);\n            const int size = rand.size();\n            int i = 0;\n            while (i < size) {\n              const T z = -Eigen::numext::log(rand[i]) / alpha + normMin;\n              i++;\n              const T x = normMin < alpha ? alpha - z : normMin - alpha;\n              const T g = Eigen::numext::exp(-x * x / T(2.0));\n              const T u = rand[i];\n              i++;\n              auto accept = (u <= g && z < normMax);\n              if (accept || num_iterations + 1 >= kMaxIterations) {\n                if (!accept) {\n                  LOG(ERROR) << \"TruncatedNormal exponential distribution \"\n                             << \"rejection sampler exceeds max iterations. \"\n                             << \"Sample may contain outliers.\";\n                  ctx->SetStatus(errors::Internal(\n                      \"TruncatedNormal exponential distribution rejection\"\n                      \" sampler failed to accept a sample.\"));\n                  return;\n                }\n                output_batch_offset[sample_idx * num_batches] =\n                    z * stddev + mean;\n                ++sample_idx;\n                ++output_idx;\n                if (sample_idx >= samples_per_batch ||\n                    output_idx >= limit_output) {\n                  break;\n                }\n                num_iterations = 0;\n              } else {\n                num_iterations++;\n              }\n            }\n          }\n        }\n      }\n    };\n    // The cost of the initial calculations for the batch.\n    const int64 batchInitCost =\n        // normMin, normMax\n        (Eigen::TensorOpCost::AddCost<T>() +\n         Eigen::TensorOpCost::MulCost<T>()) *\n            2\n        // sqrtFactor\n        + Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_sqrt_op<T>>::Cost\n        // cutoff\n        + Eigen::TensorOpCost::MulCost<T>() * 4 +\n        Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost\n        // diff\n        + Eigen::TensorOpCost::AddCost<T>();\n    const int64 uniformSampleCost =\n        random::PhiloxRandom::kElementCost +\n        random::UniformDistribution<random::PhiloxRandom, T>::kElementCost;\n    // The cost of a single uniform sampling round.\n    const int64 uniformRejectionSamplingCost =\n        uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() +\n        Eigen::TensorOpCost::AddCost<T>() +\n        Eigen::TensorOpCost::MulCost<T>() * 2 +\n        Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost +\n        Eigen::internal::functor_traits<\n            Eigen::internal::scalar_exp_op<T>>::Cost +\n        Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>();\n    // Estimate the cost for an entire batch.\n    // Assume we use uniform sampling, and accept the 2nd sample on average.\n    const int64 batchCost = batchInitCost + uniformRejectionSamplingCost * 2;\n    Shard(worker_threads.num_threads, worker_threads.workers, num_elements,\n          batchCost, do_work);\n  }\n};\n\n}  // namespace functor\n\nnamespace {\n\n// Samples from a truncated normal distribution, using the given parameters.\ntemplate <typename Device, typename T>\nclass ParameterizedTruncatedNormalOp : public OpKernel {\n  // Reshape batches so each batch is this size if possible.\n  static constexpr int32 kDesiredBatchSize = 100;\n\n public:\n  explicit ParameterizedTruncatedNormalOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, generator_.Init(context));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& shape_tensor = ctx->input(0);\n    const Tensor& means_tensor = ctx->input(1);\n    const Tensor& stddevs_tensor = ctx->input(2);\n    const Tensor& minvals_tensor = ctx->input(3);\n    const Tensor& maxvals_tensor = ctx->input(4);\n\n    OP_REQUIRES(\n        ctx, TensorShapeUtils::IsVector(shape_tensor.shape()),\n        errors::InvalidArgument(\"Input shape should be a vector, got shape: \",\n                                shape_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, shape_tensor.NumElements() > 0,\n                errors::InvalidArgument(\"Shape tensor must not be empty, got \",\n                                        shape_tensor.DebugString()));\n    int32 num_batches = shape_tensor.flat<int32>()(0);\n\n    int32 samples_per_batch = 1;\n    const int32 num_dims = shape_tensor.dim_size(0);\n    for (int32 i = 1; i < num_dims; i++) {\n      samples_per_batch *= shape_tensor.flat<int32>()(i);\n    }\n    const int32 num_elements = num_batches * samples_per_batch;\n\n    // Allocate the output before fudging num_batches and samples_per_batch.\n    auto shape_vec = shape_tensor.flat<int32>();\n    TensorShape tensor_shape;\n    OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(\n                            shape_vec.data(), shape_vec.size(), &tensor_shape));\n    Tensor* samples_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, tensor_shape, &samples_tensor));\n\n    // Parameters must be 0-d or 1-d.\n    OP_REQUIRES(ctx, means_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input means should be a scalar or vector, got shape: \",\n                    means_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, stddevs_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input stddevs should be a scalar or vector, got shape: \",\n                    stddevs_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, minvals_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input minvals should be a scalar or vector, got shape: \",\n                    minvals_tensor.shape().DebugString()));\n    OP_REQUIRES(ctx, maxvals_tensor.dims() <= 1,\n                errors::InvalidArgument(\n                    \"Input maxvals should be a scalar or vector, got shape: \",\n                    maxvals_tensor.shape().DebugString()));\n\n    if ((means_tensor.dims() == 0 || means_tensor.dim_size(0) == 1) &&\n        (stddevs_tensor.dims() == 0 || stddevs_tensor.dim_size(0) == 1) &&\n        minvals_tensor.dims() == 0 && maxvals_tensor.dims() == 0) {\n      // All batches have the same parameters, so we can update the batch size\n      // to a reasonable value to improve parallelism (ensure enough batches,\n      // and no very small batches which have high overhead).\n      int32 size = num_batches * samples_per_batch;\n      int32 adjusted_samples = kDesiredBatchSize;\n      // Ensure adjusted_batches * adjusted_samples >= size.\n      int32 adjusted_batches = Eigen::divup(size, adjusted_samples);\n      num_batches = adjusted_batches;\n      samples_per_batch = adjusted_samples;\n    } else {\n      // Parameters must be broadcastable to the shape [num_batches].\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(means_tensor.shape()) ||\n              means_tensor.dim_size(0) == 1 ||\n              means_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input means should have length 1 or shape[0], got shape: \",\n              means_tensor.shape().DebugString()));\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(stddevs_tensor.shape()) ||\n              stddevs_tensor.dim_size(0) == 1 ||\n              stddevs_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input stddevs should have length 1 or shape[0], got shape: \",\n              stddevs_tensor.shape().DebugString()));\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(minvals_tensor.shape()) ||\n              minvals_tensor.dim_size(0) == 1 ||\n              minvals_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input minvals should have length 1 or shape[0], got shape: \",\n              minvals_tensor.shape().DebugString()));\n      OP_REQUIRES(\n          ctx,\n          TensorShapeUtils::IsScalar(maxvals_tensor.shape()) ||\n              maxvals_tensor.dim_size(0) == 1 ||\n              maxvals_tensor.dim_size(0) == num_batches,\n          errors::InvalidArgument(\n              \"Input maxvals should have length 1 or shape[0], got shape: \",\n              maxvals_tensor.shape().DebugString()));\n    }\n\n    auto truncFunctor = functor::TruncatedNormalFunctor<Device, T>();\n    // Each worker has the fudge factor for samples_per_batch, so use it here.\n    random::PhiloxRandom rng =\n        generator_.ReserveSamples128(num_batches * 2 * functor::kMaxIterations *\n                                     (samples_per_batch + 3) / 4);\n    truncFunctor(ctx, ctx->eigen_device<Device>(), num_batches,\n                 samples_per_batch, num_elements, means_tensor.flat<T>(),\n                 stddevs_tensor.flat<T>(), minvals_tensor.flat<T>(),\n                 maxvals_tensor.flat<T>(), rng, samples_tensor->flat<T>());\n  }\n\n private:\n  GuardedPhiloxRandom generator_;\n\n  TF_DISALLOW_COPY_AND_ASSIGN(ParameterizedTruncatedNormalOp);\n};\n\n// Samples from a truncated normal distribution, using the given parameters.\ntemplate <typename Device, typename T>\nclass StatelessParameterizedTruncatedNormal : public OpKernel {\n  // Reshape batches so each batch is this size if possible.\n  static const int32 kDesiredBatchSize = 100;\n\n public:\n  explicit StatelessParameterizedTruncatedNormal(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& shape_tensor = ctx->input(0);\n    const Tensor& seed_tensor = ctx->input(1);\n    const Tensor& means_tensor = ctx->input(2);\n    const Tensor& stddevs_tensor = ctx->input(3);\n    const Tensor& minvals_tensor = ctx->input(4);\n    const Tensor& maxvals_tensor = ctx->input(5);\n\n    OP_REQUIRES(ctx, seed_tensor.dims() == 1 && seed_tensor.dim_size(0) == 2,\n                errors::InvalidArgument(\"seed must have shape [2], not \",\n                                        seed_tensor.shape().DebugString()));\n\n    tensorflow::BCastList<4> bcast(\n        {means_tensor.shape().dim_sizes(), stddevs_tensor.shape().dim_sizes(),\n         minvals_tensor.shape().dim_sizes(),\n         maxvals_tensor.shape().dim_sizes()},\n        /*fewer_dims_optimization=*/false,\n        /*return_flattened_batch_indices=*/true);\n\n    OP_REQUIRES(ctx, bcast.IsValid(),\n                errors::InvalidArgument(\n                    \"means, stddevs, minvals, maxvals must have compatible \"\n                    \"batch dimensions: \",\n                    means_tensor.shape().DebugString(), \" vs. \",\n                    stddevs_tensor.shape().DebugString(), \" vs. \",\n                    minvals_tensor.shape().DebugString(), \" vs. \",\n                    maxvals_tensor.shape().DebugString()));\n\n    // Let's check that the shape tensor dominates the broadcasted tensor.\n    TensorShape bcast_shape = BCast::ToShape(bcast.output_shape());\n    OP_REQUIRES(\n        ctx, TensorShapeUtils::IsVector(shape_tensor.shape()),\n        errors::InvalidArgument(\"Input shape should be a vector, got shape: \",\n                                shape_tensor.shape().DebugString()));\n    TensorShape output_shape;\n    if (shape_tensor.dtype() == DataType::DT_INT32) {\n      OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(shape_tensor.vec<int32>(),\n                                                      &output_shape));\n    } else {\n      OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(shape_tensor.vec<int64>(),\n                                                      &output_shape));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::EndsWith(output_shape, bcast_shape),\n                errors::InvalidArgument(\n                    \"Shape passed in must end with broadcasted shape.\"));\n\n    int64 samples_per_batch = 1;\n    const int64 num_sample_dims =\n        (shape_tensor.dim_size(0) - bcast.output_shape().size());\n    for (int64 i = 0; i < num_sample_dims; ++i) {\n      samples_per_batch *= output_shape.dim_size(i);\n    }\n    int64 num_batches = 1;\n    for (int64 i = num_sample_dims; i < shape_tensor.dim_size(0); ++i) {\n      num_batches *= output_shape.dim_size(i);\n    }\n    const int64 num_elements = num_batches * samples_per_batch;\n\n    Tensor* samples_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, output_shape, &samples_tensor));\n\n    auto truncFunctor = functor::TruncatedNormalFunctorV2<Device, T>();\n    // Each worker has the same fudge factor, so use it here.\n    random::PhiloxRandom::Key key;\n    random::PhiloxRandom::ResultType counter;\n    OP_REQUIRES_OK(ctx, GenerateKey(seed_tensor, &key, &counter));\n\n    auto philox = random::PhiloxRandom(counter, key);\n\n    truncFunctor(ctx, ctx->eigen_device<Device>(), num_batches,\n                 samples_per_batch, num_elements, bcast, means_tensor.flat<T>(),\n                 stddevs_tensor.flat<T>(), minvals_tensor.flat<T>(),\n                 maxvals_tensor.flat<T>(), philox, samples_tensor->flat<T>());\n  }\n\n private:\n  TF_DISALLOW_COPY_AND_ASSIGN(StatelessParameterizedTruncatedNormal);\n};\n\n}  // namespace\n\n#define REGISTER(TYPE)                                                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"ParameterizedTruncatedNormal\")             \\\n                              .Device(DEVICE_CPU)                          \\\n                              .TypeConstraint<TYPE>(\"dtype\"),              \\\n                          ParameterizedTruncatedNormalOp<CPUDevice, TYPE>) \\\n  REGISTER_KERNEL_BUILDER(                                                 \\\n      Name(\"StatelessParameterizedTruncatedNormal\")                        \\\n          .HostMemory(\"shape\")                                             \\\n          .HostMemory(\"seed\")                                              \\\n          .HostMemory(\"means\")                                             \\\n          .HostMemory(\"stddevs\")                                           \\\n          .HostMemory(\"minvals\")                                           \\\n          .HostMemory(\"maxvals\")                                           \\\n          .Device(DEVICE_CPU)                                              \\\n          .TypeConstraint<TYPE>(\"dtype\"),                                  \\\n      StatelessParameterizedTruncatedNormal<CPUDevice, TYPE>)\n\nTF_CALL_half(REGISTER);\nTF_CALL_float(REGISTER);\nTF_CALL_double(REGISTER);\n\n#undef REGISTER\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#define REGISTER(TYPE)                                         \\\n  REGISTER_KERNEL_BUILDER(Name(\"ParameterizedTruncatedNormal\") \\\n                              .Device(DEVICE_GPU)              \\\n                              .HostMemory(\"shape\")             \\\n                              .TypeConstraint<TYPE>(\"dtype\"),  \\\n                          ParameterizedTruncatedNormalOp<GPUDevice, TYPE>)\n\nTF_CALL_half(REGISTER);\nTF_CALL_float(REGISTER);\nTF_CALL_double(REGISTER);\n\n#undef REGISTER\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // end namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/parameterized_truncated_normal_op.cc"], "buggy_code_start_loc": [629], "buggy_code_end_loc": [629], "fixing_code_start_loc": [630], "fixing_code_end_loc": [633], "type": "CWE-824", "message": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger undefined behavior by binding to null pointer in `tf.raw_ops.ParameterizedTruncatedNormal`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3f6fe4dfef6f57e768260b48166c27d148f3015f/tensorflow/core/kernels/parameterized_truncated_normal_op.cc#L630) does not validate input arguments before accessing the first element of `shape`. If `shape` argument is empty, then `shape_tensor.flat<T>()` is an empty array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-29568", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-14T20:15:13.743", "lastModified": "2021-07-26T16:08:39.037", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger undefined behavior by binding to null pointer in `tf.raw_ops.ParameterizedTruncatedNormal`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3f6fe4dfef6f57e768260b48166c27d148f3015f/tensorflow/core/kernels/parameterized_truncated_normal_op.cc#L630) does not validate input arguments before accessing the first element of `shape`. If `shape` argument is empty, then `shape_tensor.flat<T>()` is an empty array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico.&#xa0;Un atacante puede desencadenar un comportamiento indefinido al vincularse a un puntero null en \"tf.raw_ops.ParameterizedTruncatedNormal\".&#xa0;Esto es debido a que la implementaci\u00f3n (https://github.com/tensorflow/tensorflow/blob/3f6fe4dfef6f57e768260b48166c27d148f3015f/tensorflow/core/kernels/parameterized_truncated_normal_op.cc#L630) no comprueba los argumentos de entrada versiones anteriores a acceder al primer elemento de \"shape\".&#xa0;Si el argumento \"shape\" est\u00e1 vac\u00edo, entonces\" shape_tensor.flat (T) () \"es una matriz vac\u00eda.&#xa0;La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.5.0.&#xa0;Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.4.2, TensorFlow versi\u00f3n 2.3.3, TensorFlow versi\u00f3n 2.2.3 y TensorFlow versi\u00f3n 2.1.4, ya que estos tambi\u00e9n est\u00e1n afectados y a\u00fan est\u00e1n en el rango admitido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.0, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-824"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.4", "matchCriteriaId": "323ABCCE-24EB-47CC-87F6-48C101477587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.3", "matchCriteriaId": "64ABA90C-0649-4BB0-89C9-83C14BBDCC0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.3", "matchCriteriaId": "0F83E0CF-CBF6-4C24-8683-3E7A5DC95BA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.2", "matchCriteriaId": "8259531B-A8AC-4F8B-B60F-B69DE4767C03"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/5e52ef5a461570cfb68f3bdbbebfe972cb4e0fd8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-4p4p-www8-8fv9", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/5e52ef5a461570cfb68f3bdbbebfe972cb4e0fd8"}}