{"buggy_code": ["using System;\r\nusing System.Collections;\r\nusing System.Collections.Concurrent;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n// ReSharper disable RedundantTypeArgumentsOfMethod\r\n#pragma warning disable IDE0034 // Simplify 'default' expression\r\n\r\n\r\nnamespace EnumStringValues\r\n{\r\n  ///==========================================================================\r\n  /// Class : EnumExtensions\r\n  ///\r\n  /// <summary>\r\n  ///   Contains Enum Extension methods.\r\n  /// </summary>\r\n  ///==========================================================================\r\n  public static class EnumExtensions\r\n  {\r\n    ///==========================================================================\r\n    /// Class : EnumExtensions.Behaviour\r\n    ///\r\n    /// <summary>\r\n    ///   Static class containing Behaviour configuration for EnumExtensions.\r\n    /// </summary>\r\n    ///==========================================================================\r\n    public static class Behaviour\r\n    {\r\n      /// <summary>\r\n      /// Enum to list possible behaviours\r\n      /// </summary>\r\n      public enum UnderlyingNameUsed\r\n      {\r\n  #pragma warning disable CS1591 // Missing XML comment for publicly visible type or member\r\n        Never,\r\n        IfNoOverrideGiven,\r\n        Always,\r\n  #pragma warning restore CS1591 // Missing XML comment for publicly visible type or member\r\n      }\r\n\r\n      /// <summary>\r\n      /// Controls whether Caching should be used. Defaults to false.\r\n      /// </summary>\r\n      public static UnderlyingNameUsed ShouldIncludeUnderlyingName\r\n      {\r\n        get => shouldIncludeUnderlyingName;\r\n        set { shouldIncludeUnderlyingName = value; if(UseCaching) { ResetCaches(); } }\r\n      }\r\n      private static UnderlyingNameUsed shouldIncludeUnderlyingName = UnderlyingNameUsed.Always;\r\n\r\n\r\n      /// <summary>\r\n      /// Controls whether Caching should be used. Defaults to false.\r\n      /// </summary>\r\n      public static bool UseCaching\r\n      {\r\n        get => useCaching;\r\n        set { useCaching = value; if (value) { ResetCaches(); } }\r\n      }\r\n      private static bool useCaching = true;\r\n\r\n\r\n      static Behaviour()\r\n      {\r\n        ResetCaches();\r\n      }\r\n\r\n      /// <summary>\r\n      /// Method for use in testing.\r\n      /// Needs to be public to be used in the test project.\r\n      /// Not a problem to expose to the user, but never valuable (as long as the tests pass :) )\r\n      /// So won't be documented and will be hidden from Intellisense.\r\n      /// </summary>\r\n      [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\r\n      public static void ResetCaches()\r\n      {\r\n        enumValuesDictionary = new ConcurrentDictionary<Type, IEnumerable>();\r\n        enumStringValuesDictionary = new ConcurrentDictionary<Enum, List<StringValueAttribute>>();\r\n        parsedEnumStringsDictionaryByType = new ConcurrentDictionary<Type, ConcurrentDictionary<string, Enum>>();\r\n      }\r\n    }\r\n\r\n    /// <summary> Cache for <see cref=\"EnumerateValues{TEnumType}\"/> </summary>\r\n    private static ConcurrentDictionary<Type, IEnumerable> enumValuesDictionary;\r\n\r\n    /// <summary> Returns an IEnumerable{T} of the possible values in the enum </summary>\r\n    public static IEnumerable<TEnumType> EnumerateValues<TEnumType>() where TEnumType : System.Enum\r\n    {\r\n      var enumTypeObject = typeof(TEnumType);\r\n      IEnumerable values;\r\n\r\n      if (Behaviour.UseCaching)\r\n      {\r\n        values = enumValuesDictionary.GetOrAdd(enumTypeObject, Enum.GetValues);\r\n      }\r\n      else\r\n      {\r\n        values = Enum.GetValues(enumTypeObject);\r\n      }\r\n\r\n      return values.Cast<TEnumType>();\r\n    }\r\n\r\n    ///==========================================================================\r\n    /// Public Method : GetStringValue\r\n    /// \r\n    /// <summary>\r\n    ///   Retrieves a Single StringValue associated with the enum.\r\n    ///   Returns the preferred StringValue if multiple are defined.\r\n    /// \r\n    ///   If no preferred value is specified, or if multiple preferred values are\r\n    ///   specified, returns any arbitrary one of the values (selected from the \r\n    ///   preferred values in the latter case.\r\n    ///   \r\n    ///   Returns the Enum name, if no StringValue was specified at all.\r\n    /// </summary>\r\n    ///==========================================================================\r\n    public static string GetStringValue(this Enum enumValue)\r\n    {\r\n      return\r\n        enumValue\r\n          .GetStringValuesWithPreferences()\r\n          .OrderBy(attribute => attribute.Preference)\r\n          .Select(attribute => attribute.StringValue)\r\n          .FirstOrDefault();\r\n    }\r\n\r\n    ///==========================================================================\r\n    /// Public Method : GetAllStringValues\r\n    /// \r\n    /// <summary>\r\n    ///   Retrieves the full Collection of StringValues associated with the\r\n    ///   particular enum (including the Enum's name)\r\n    ///   If no StringValues are specified, then returns ONLY the Enum's name.\r\n    /// </summary>\r\n    ///==========================================================================\r\n    public static IEnumerable<string> GetAllStringValues(this Enum value)\r\n    {\r\n      var valuesPreferencePairs = value.GetStringValuesWithPreferences();\r\n\r\n      return valuesPreferencePairs.Select(pair => pair.StringValue);\r\n    }\r\n\r\n    ///==========================================================================\r\n    /// Method : GetStringValuesWithPreferences\r\n    /// \r\n    /// <summary>\r\n    ///   Retrieves the StringValueAttributes associated with the enum.\r\n    ///   If no StringValues are specified, defaults to treating the EnumName as\r\n    ///   the implicit StringValue.\r\n    /// </summary>\r\n    ///==========================================================================\r\n    private static IEnumerable<StringValueAttribute> GetStringValuesWithPreferences(this Enum enumValue)\r\n    {\r\n      if (Behaviour.UseCaching)\r\n      {\r\n        return enumStringValuesDictionary.GetOrAdd(enumValue, GetStringValuesWithPreferences_Uncached);\r\n      }\r\n      else\r\n      {\r\n        return GetStringValuesWithPreferences_Uncached(enumValue);\r\n      }\r\n    }\r\n\r\n    private static List<StringValueAttribute> GetStringValuesWithPreferences_Uncached(this Enum enumValue)\r\n    {\r\n      List<StringValueAttribute> stringValueAttributes =\r\n        enumValue\r\n          .GetType()\r\n          .GetField(enumValue.ToString())\r\n          .GetCustomAttributes(typeof(StringValueAttribute), false)\r\n          .Cast<StringValueAttribute>()\r\n          .ToList();\r\n\r\n      if (\r\n        Behaviour.ShouldIncludeUnderlyingName == Behaviour.UnderlyingNameUsed.Always ||\r\n        (!stringValueAttributes.Any() && Behaviour.ShouldIncludeUnderlyingName != Behaviour.UnderlyingNameUsed.Never)\r\n      )\r\n      {\r\n        stringValueAttributes.Add(new StringValueAttribute(enumValue.ToString(), PreferenceLevel.Low));\r\n      }\r\n\r\n      return stringValueAttributes;\r\n    }\r\n\r\n    /// <summary> Cache for <see cref=\"GetStringValuesWithPreferences\"/> </summary>\r\n    private static ConcurrentDictionary<Enum, List<StringValueAttribute>> enumStringValuesDictionary;\r\n\r\n    ///==========================================================================\r\n    /// Public Extension Method on System.String: ParseToEnum\r\n    /// \r\n    /// <summary>\r\n    ///   Retrieves the Enum matching the string passed in.\r\n    ///   Throws if no match was found.\r\n    /// </summary>\r\n    /// <remarks>\r\n    ///   \"TEnumType : struct, IConvertible\" is the closest you can get to\r\n    ///   \"TEnumType : Enum\"\r\n    /// \r\n    ///   This should minimise the chances of run-time errors by catching most of\r\n    ///   them at compile time.\r\n    /// </remarks>\r\n    ///==========================================================================\r\n    public static TEnumType ParseToEnum<TEnumType>(this string stringValue) where TEnumType : System.Enum\r\n    {\r\n      // ReSharper disable once RedundantTypeArgumentsOfMethod\r\n      if (TryParseStringValueToEnum<TEnumType>(stringValue, out TEnumType lRet))\r\n      {\r\n        return lRet;\r\n      }\r\n      throw new UnmatchedStringValueException(stringValue, typeof(TEnumType));\r\n    }\r\n\r\n    ///==========================================================================\r\n    /// Public Extension Method on List{String}: ParseToEnumList\r\n    /// \r\n    /// <summary>\r\n    ///   Iterates over the collection of string, calling ParseToEnum on each one.\r\n    /// </summary>\r\n    /// <remarks>\r\n    ///   Will throw if ANY of the values are unmatchable.\r\n    ///  \r\n    ///   Calls ToList() to force immediate instantiation and thus immediate\r\n    ///   failure if any values aren't matched.\r\n    /// </remarks>\r\n    ///==========================================================================\r\n    public static List<TEnumType> ParseToEnumList<TEnumType>(this IEnumerable<string> stringValueCollection) where TEnumType : System.Enum\r\n    {\r\n      return stringValueCollection.Select(ParseToEnum<TEnumType>).ToList();\r\n    }\r\n\r\n    ///==========================================================================\r\n    /// Public Method : TryParseStringValueToEnum\r\n    /// \r\n    /// <summary>\r\n    ///   Retrieves the Enum matching the string passed in.\r\n    ///   Returns true or false according to whether a match was found.\r\n    /// </summary>\r\n    /// <remarks>\r\n    ///   \"TEnumType : struct, IConvertible\" is the closest you can get to\r\n    ///   \"TEnumType : Enum\"\r\n    /// \r\n    ///   This should minimise the chances of run-time errors by catching most of\r\n    ///   them at compile time.\r\n    /// </remarks>\r\n    ///==========================================================================\r\n    public static bool TryParseStringValueToEnum<TEnumType>(this string stringValue, out TEnumType parsedValue) where TEnumType : System.Enum\r\n    {\r\n      if (stringValue == null)\r\n      {\r\n        throw new ArgumentNullException(nameof(stringValue), \"Input string may not be null.\");\r\n      }\r\n\r\n      var lowerStringValue = stringValue.ToLower();\r\n      if (!Behaviour.UseCaching)\r\n      {\r\n        return TryParseStringValueToEnum_Uncached(lowerStringValue, out parsedValue);\r\n      }\r\n\r\n      return TryParseStringValueToEnum_ViaCache(lowerStringValue, out parsedValue);\r\n    }\r\n\r\n    /// <remarks>\r\n    /// This is a little more complex than one might hope, because we also need to cache the knowledge of whether the parse succeeded or not.\r\n    /// We're doing that by storing `null`, if the answer is 'No'. And decoding that, specifically.\r\n    /// </remarks>\r\n    private static bool TryParseStringValueToEnum_ViaCache<TEnumType>(string lowerStringValue, out TEnumType parsedValue) where TEnumType : System.Enum\r\n    {\r\n      var enumTypeObject = typeof(TEnumType);\r\n\r\n      var typeAppropriateDictionary = parsedEnumStringsDictionaryByType.GetOrAdd(enumTypeObject, (x) => new ConcurrentDictionary<string, Enum>());\r\n\r\n      var cachedValue = typeAppropriateDictionary.GetOrAdd(lowerStringValue, (str) =>\r\n      {\r\n        var parseSucceededForDictionary = TryParseStringValueToEnum_Uncached<TEnumType>(lowerStringValue, out var parsedValueForDictionary);\r\n        return parseSucceededForDictionary ? (Enum) parsedValueForDictionary : null;\r\n      });\r\n\r\n      if (cachedValue != null)\r\n      {\r\n        parsedValue = (TEnumType)cachedValue;\r\n        return true;\r\n      }\r\n      else\r\n      {\r\n        parsedValue = default(TEnumType);\r\n        return false;\r\n      }\r\n    }\r\n\r\n    /// <summary> Cache for <see cref=\"TryParseStringValueToEnum{TEnumType}\"/> </summary>\r\n    private static ConcurrentDictionary<Type, ConcurrentDictionary<string, Enum>> parsedEnumStringsDictionaryByType;\r\n\r\n    private static bool TryParseStringValueToEnum_Uncached<TEnumType>(this string lowerStringValue, out TEnumType parsedValue) where TEnumType : System.Enum\r\n    {\r\n      foreach (var enumValue in EnumerateValues<TEnumType>())\r\n      {\r\n        var enumStrings = GetStringValues<TEnumType>(enumValue).Select(text => text.ToLower());\r\n\r\n        if (enumStrings.Contains(lowerStringValue))\r\n        {\r\n          parsedValue = enumValue;\r\n          return true;\r\n        }\r\n      }\r\n      parsedValue = default(TEnumType);\r\n      return false;\r\n    }\r\n\r\n\r\n    ///==========================================================================\r\n    /// Method : GetStringValues\r\n    /// \r\n    /// <summary>\r\n    ///   Retrieves the StringValues associated with the particular Enum provided.\r\n    ///   Returns an empty collection if none are specified.\r\n    /// </summary>\r\n    /// <remarks>\r\n    ///   \"TEnumType : struct, IConvertible\" is the closest you can get to\r\n    ///   \"TEnumType : Enum\"\r\n    /// \r\n    ///   This should minimise the chances of run-time errors by catching most of\r\n    ///   them at compile time.\r\n    /// </remarks>\r\n    ///==========================================================================\r\n    private static IEnumerable<string> GetStringValues<TEnumType>(TEnumType enumValue) where TEnumType : System.Enum\r\n    {\r\n      return (enumValue as Enum).GetAllStringValues();\r\n    }\r\n  }\r\n}\r\n#pragma warning restore IDE0034 // Simplify 'default' expression\r\n"], "fixing_code": ["using System;\r\nusing System.Collections;\r\nusing System.Collections.Concurrent;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\n// ReSharper disable RedundantTypeArgumentsOfMethod\r\n#pragma warning disable IDE0034 // Simplify 'default' expression\r\n\r\n\r\nnamespace EnumStringValues\r\n{\r\n  ///==========================================================================\r\n  /// Class : EnumExtensions\r\n  ///\r\n  /// <summary>\r\n  ///   Contains Enum Extension methods.\r\n  /// </summary>\r\n  ///==========================================================================\r\n  public static class EnumExtensions\r\n  {\r\n    ///==========================================================================\r\n    /// Class : EnumExtensions.Behaviour\r\n    ///\r\n    /// <summary>\r\n    ///   Static class containing Behaviour configuration for EnumExtensions.\r\n    /// </summary>\r\n    ///==========================================================================\r\n    public static class Behaviour\r\n    {\r\n      /// <summary>\r\n      /// Enum to list possible behaviours\r\n      /// </summary>\r\n      public enum UnderlyingNameUsed\r\n      {\r\n  #pragma warning disable CS1591 // Missing XML comment for publicly visible type or member\r\n        Never,\r\n        IfNoOverrideGiven,\r\n        Always,\r\n  #pragma warning restore CS1591 // Missing XML comment for publicly visible type or member\r\n      }\r\n\r\n      /// <summary>\r\n      /// Controls whether Caching should be used. Defaults to false.\r\n      /// </summary>\r\n      public static UnderlyingNameUsed ShouldIncludeUnderlyingName\r\n      {\r\n        get => shouldIncludeUnderlyingName;\r\n        set { shouldIncludeUnderlyingName = value; if(UseCaching) { ResetCaches(); } }\r\n      }\r\n      private static UnderlyingNameUsed shouldIncludeUnderlyingName = UnderlyingNameUsed.Always;\r\n\r\n\r\n      /// <summary>\r\n      /// Controls whether Caching should be used. Defaults to false.\r\n      /// </summary>\r\n      public static bool UseCaching\r\n      {\r\n        get => useCaching;\r\n        set { useCaching = value; if (value) { ResetCaches(); } }\r\n      }\r\n      private static bool useCaching = true;\r\n\r\n\r\n      static Behaviour()\r\n      {\r\n        ResetCaches();\r\n      }\r\n\r\n      /// <summary>\r\n      /// Method for use in testing.\r\n      /// Needs to be public to be used in the test project.\r\n      /// Not a problem to expose to the user, but never valuable (as long as the tests pass :) )\r\n      /// So won't be documented and will be hidden from Intellisense.\r\n      /// </summary>\r\n      [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\r\n      public static void ResetCaches()\r\n      {\r\n        enumValuesDictionary = new ConcurrentDictionary<Type, IEnumerable>();\r\n        enumStringValuesDictionary = new ConcurrentDictionary<Enum, List<StringValueAttribute>>();\r\n        parsedEnumStringsDictionaryByType = new ConcurrentDictionary<Type, ConcurrentDictionary<string, Enum>>();\r\n      }\r\n    }\r\n\r\n    /// <summary> Cache for <see cref=\"EnumerateValues{TEnumType}\"/> </summary>\r\n    private static ConcurrentDictionary<Type, IEnumerable> enumValuesDictionary;\r\n\r\n    /// <summary> Returns an IEnumerable{T} of the possible values in the enum </summary>\r\n    public static IEnumerable<TEnumType> EnumerateValues<TEnumType>() where TEnumType : System.Enum\r\n    {\r\n      var enumTypeObject = typeof(TEnumType);\r\n      IEnumerable values;\r\n\r\n      if (Behaviour.UseCaching)\r\n      {\r\n        values = enumValuesDictionary.GetOrAdd(enumTypeObject, Enum.GetValues);\r\n      }\r\n      else\r\n      {\r\n        values = Enum.GetValues(enumTypeObject);\r\n      }\r\n\r\n      return values.Cast<TEnumType>();\r\n    }\r\n\r\n    ///==========================================================================\r\n    /// Public Method : GetStringValue\r\n    /// \r\n    /// <summary>\r\n    ///   Retrieves a Single StringValue associated with the enum.\r\n    ///   Returns the preferred StringValue if multiple are defined.\r\n    /// \r\n    ///   If no preferred value is specified, or if multiple preferred values are\r\n    ///   specified, returns any arbitrary one of the values (selected from the \r\n    ///   preferred values in the latter case.\r\n    ///   \r\n    ///   Returns the Enum name, if no StringValue was specified at all.\r\n    /// </summary>\r\n    ///==========================================================================\r\n    public static string GetStringValue(this Enum enumValue)\r\n    {\r\n      return\r\n        enumValue\r\n          .GetStringValuesWithPreferences()\r\n          .OrderBy(attribute => attribute.Preference)\r\n          .Select(attribute => attribute.StringValue)\r\n          .FirstOrDefault();\r\n    }\r\n\r\n    ///==========================================================================\r\n    /// Public Method : GetAllStringValues\r\n    /// \r\n    /// <summary>\r\n    ///   Retrieves the full Collection of StringValues associated with the\r\n    ///   particular enum (including the Enum's name)\r\n    ///   If no StringValues are specified, then returns ONLY the Enum's name.\r\n    /// </summary>\r\n    ///==========================================================================\r\n    public static IEnumerable<string> GetAllStringValues(this Enum value)\r\n    {\r\n      var valuesPreferencePairs = value.GetStringValuesWithPreferences();\r\n\r\n      return valuesPreferencePairs.Select(pair => pair.StringValue);\r\n    }\r\n\r\n    ///==========================================================================\r\n    /// Method : GetStringValuesWithPreferences\r\n    /// \r\n    /// <summary>\r\n    ///   Retrieves the StringValueAttributes associated with the enum.\r\n    ///   If no StringValues are specified, defaults to treating the EnumName as\r\n    ///   the implicit StringValue.\r\n    /// </summary>\r\n    ///==========================================================================\r\n    private static IEnumerable<StringValueAttribute> GetStringValuesWithPreferences(this Enum enumValue)\r\n    {\r\n      if (Behaviour.UseCaching)\r\n      {\r\n        return enumStringValuesDictionary.GetOrAdd(enumValue, GetStringValuesWithPreferences_Uncached);\r\n      }\r\n      else\r\n      {\r\n        return GetStringValuesWithPreferences_Uncached(enumValue);\r\n      }\r\n    }\r\n\r\n    private static List<StringValueAttribute> GetStringValuesWithPreferences_Uncached(this Enum enumValue)\r\n    {\r\n      List<StringValueAttribute> stringValueAttributes =\r\n        enumValue\r\n          .GetType()\r\n          .GetField(enumValue.ToString())\r\n          .GetCustomAttributes(typeof(StringValueAttribute), false)\r\n          .Cast<StringValueAttribute>()\r\n          .ToList();\r\n\r\n      if (\r\n        Behaviour.ShouldIncludeUnderlyingName == Behaviour.UnderlyingNameUsed.Always ||\r\n        (!stringValueAttributes.Any() && Behaviour.ShouldIncludeUnderlyingName != Behaviour.UnderlyingNameUsed.Never)\r\n      )\r\n      {\r\n        stringValueAttributes.Add(new StringValueAttribute(enumValue.ToString(), PreferenceLevel.Low));\r\n      }\r\n\r\n      return stringValueAttributes;\r\n    }\r\n\r\n    /// <summary> Cache for <see cref=\"GetStringValuesWithPreferences\"/> </summary>\r\n    private static ConcurrentDictionary<Enum, List<StringValueAttribute>> enumStringValuesDictionary;\r\n\r\n    ///==========================================================================\r\n    /// Public Extension Method on System.String: ParseToEnum\r\n    /// \r\n    /// <summary>\r\n    ///   Retrieves the Enum matching the string passed in.\r\n    ///   Throws if no match was found.\r\n    /// </summary>\r\n    /// <remarks>\r\n    ///   \"TEnumType : struct, IConvertible\" is the closest you can get to\r\n    ///   \"TEnumType : Enum\"\r\n    /// \r\n    ///   This should minimise the chances of run-time errors by catching most of\r\n    ///   them at compile time.\r\n    /// </remarks>\r\n    ///==========================================================================\r\n    public static TEnumType ParseToEnum<TEnumType>(this string stringValue) where TEnumType : System.Enum\r\n    {\r\n      // ReSharper disable once RedundantTypeArgumentsOfMethod\r\n      if (TryParseStringValueToEnum<TEnumType>(stringValue, out TEnumType lRet))\r\n      {\r\n        return lRet;\r\n      }\r\n      throw new UnmatchedStringValueException(stringValue, typeof(TEnumType));\r\n    }\r\n\r\n    ///==========================================================================\r\n    /// Public Extension Method on List{String}: ParseToEnumList\r\n    /// \r\n    /// <summary>\r\n    ///   Iterates over the collection of string, calling ParseToEnum on each one.\r\n    /// </summary>\r\n    /// <remarks>\r\n    ///   Will throw if ANY of the values are unmatchable.\r\n    ///  \r\n    ///   Calls ToList() to force immediate instantiation and thus immediate\r\n    ///   failure if any values aren't matched.\r\n    /// </remarks>\r\n    ///==========================================================================\r\n    public static List<TEnumType> ParseToEnumList<TEnumType>(this IEnumerable<string> stringValueCollection) where TEnumType : System.Enum\r\n    {\r\n      return stringValueCollection.Select(ParseToEnum<TEnumType>).ToList();\r\n    }\r\n\r\n    ///==========================================================================\r\n    /// Public Method : TryParseStringValueToEnum\r\n    /// \r\n    /// <summary>\r\n    ///   Retrieves the Enum matching the string passed in.\r\n    ///   Returns true or false according to whether a match was found.\r\n    /// </summary>\r\n    /// <remarks>\r\n    ///   \"TEnumType : struct, IConvertible\" is the closest you can get to\r\n    ///   \"TEnumType : Enum\"\r\n    /// \r\n    ///   This should minimise the chances of run-time errors by catching most of\r\n    ///   them at compile time.\r\n    /// </remarks>\r\n    ///==========================================================================\r\n    public static bool TryParseStringValueToEnum<TEnumType>(this string stringValue, out TEnumType parsedValue) where TEnumType : System.Enum\r\n    {\r\n      if (stringValue == null)\r\n      {\r\n        throw new ArgumentNullException(nameof(stringValue), \"Input string may not be null.\");\r\n      }\r\n\r\n      var lowerStringValue = stringValue.ToLower();\r\n      if (!Behaviour.UseCaching)\r\n      {\r\n        return TryParseStringValueToEnum_Uncached(lowerStringValue, out parsedValue);\r\n      }\r\n\r\n      return TryParseStringValueToEnum_ViaCache(lowerStringValue, out parsedValue);\r\n    }\r\n\r\n    /// <remarks>\r\n    /// This is a little more complex than one might hope, because we also need to cache the knowledge of whether the parse succeeded or not.\r\n    /// We're doing that by storing `null`, if the answer is 'No'. And decoding that, specifically.\r\n    /// </remarks>\r\n    private static bool TryParseStringValueToEnum_ViaCache<TEnumType>(string lowerStringValue, out TEnumType parsedValue) where TEnumType : System.Enum\r\n    {\r\n      var enumTypeObject = typeof(TEnumType);\r\n\r\n      var typeAppropriateDictionary = parsedEnumStringsDictionaryByType.GetOrAdd(\r\n        enumTypeObject, \r\n        (x) => BuildCacheDictionaryForParseStringValue<TEnumType>()\r\n      );\r\n\r\n      if (typeAppropriateDictionary.TryGetValue(lowerStringValue, out var cachedValue))\r\n      {\r\n        parsedValue = (TEnumType)cachedValue;\r\n        return true;\r\n      }\r\n      else\r\n      {\r\n        parsedValue = default(TEnumType);\r\n        return false;\r\n      }\r\n    }\r\n\r\n    /// <summary> Cache for <see cref=\"TryParseStringValueToEnum{TEnumType}\"/> </summary>\r\n    private static ConcurrentDictionary<Type, ConcurrentDictionary<string, Enum>> parsedEnumStringsDictionaryByType;\r\n\r\n\r\n    private static ConcurrentDictionary<string, Enum> BuildCacheDictionaryForParseStringValue<TEnumType>() where TEnumType : System.Enum\r\n    {\r\n      var dict = new ConcurrentDictionary<string, Enum>();\r\n\r\n      foreach (var enumValue in EnumerateValues<TEnumType>())\r\n      {\r\n        foreach (var enumString in GetStringValues<TEnumType>(enumValue))\r\n        {\r\n            // Add to the dictionary, just overwriting if the string is already present.\r\n            // This overwrite is legitimate, because we've declared parsing a duplicate string definition to be `undefined behaviour`.\r\n            dict.AddOrUpdate(enumString.ToLower(), enumValue, ((repeatedString, previousEnumValue) => enumValue));\r\n        }\r\n      }\r\n\r\n      return dict;\r\n    }\r\n\r\n\r\n    private static bool TryParseStringValueToEnum_Uncached<TEnumType>(this string lowerStringValue, out TEnumType parsedValue) where TEnumType : System.Enum\r\n    {\r\n      foreach (var enumValue in EnumerateValues<TEnumType>())\r\n      {\r\n        var enumStrings = GetStringValues<TEnumType>(enumValue).Select(text => text.ToLower());\r\n\r\n        if (enumStrings.Contains(lowerStringValue))\r\n        {\r\n          parsedValue = enumValue;\r\n          return true;\r\n        }\r\n      }\r\n      parsedValue = default(TEnumType);\r\n      return false;\r\n    }\r\n\r\n\r\n    ///==========================================================================\r\n    /// Method : GetStringValues\r\n    /// \r\n    /// <summary>\r\n    ///   Retrieves the StringValues associated with the particular Enum provided.\r\n    ///   Returns an empty collection if none are specified.\r\n    /// </summary>\r\n    /// <remarks>\r\n    ///   \"TEnumType : struct, IConvertible\" is the closest you can get to\r\n    ///   \"TEnumType : Enum\"\r\n    /// \r\n    ///   This should minimise the chances of run-time errors by catching most of\r\n    ///   them at compile time.\r\n    /// </remarks>\r\n    ///==========================================================================\r\n    private static IEnumerable<string> GetStringValues<TEnumType>(TEnumType enumValue) where TEnumType : System.Enum\r\n    {\r\n      return (enumValue as Enum).GetAllStringValues();\r\n    }\r\n  }\r\n}\r\n#pragma warning restore IDE0034 // Simplify 'default' expression\r\n"], "buggy_code_start_loc": [272], "buggy_code_end_loc": [293], "fixing_code_start_loc": [272], "fixing_code_end_loc": [310], "type": "CWE-400", "message": "A vulnerability was found in Brondahl EnumStringValues up to 4.0.0. It has been declared as problematic. This vulnerability affects the function GetStringValuesWithPreferences_Uncache of the file EnumStringValues/EnumExtensions.cs. The manipulation leads to resource consumption. Upgrading to version 4.0.1 is able to address this issue. The name of the patch is c0fc7806beb24883cc2f9543ebc50c0820297307. It is recommended to upgrade the affected component. VDB-216466 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2020-36620", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-21T19:15:11.753", "lastModified": "2022-12-28T18:42:45.770", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Brondahl EnumStringValues up to 4.0.0. It has been declared as problematic. This vulnerability affects the function GetStringValuesWithPreferences_Uncache of the file EnumStringValues/EnumExtensions.cs. The manipulation leads to resource consumption. Upgrading to version 4.0.1 is able to address this issue. The name of the patch is c0fc7806beb24883cc2f9543ebc50c0820297307. It is recommended to upgrade the affected component. VDB-216466 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:enumstringvalues_project:enumstringvalues:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.0.1", "matchCriteriaId": "F9B08BC8-1C82-486D-B046-354F363607C1"}]}]}], "references": [{"url": "https://github.com/Brondahl/EnumStringValues/commit/c0fc7806beb24883cc2f9543ebc50c0820297307", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Brondahl/EnumStringValues/releases/tag/4.0.1", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216466", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/Brondahl/EnumStringValues/commit/c0fc7806beb24883cc2f9543ebc50c0820297307"}}