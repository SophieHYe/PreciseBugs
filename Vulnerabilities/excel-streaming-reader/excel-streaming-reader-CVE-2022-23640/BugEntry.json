{"buggy_code": ["[![Run Status](https://api.shippable.com/projects/55cfbb00edd7f2c052a980a5/badge?branch=master)](https://app.shippable.com/projects/55cfbb00edd7f2c052a980a5)\n\n# Excel Streaming Reader\n\nIf you've used [Apache POI](http://poi.apache.org) in the past to read in Excel files, you probably noticed that it's not very memory efficient. Reading in an entire workbook will cause a severe memory usage spike, which can wreak havoc on a server. \n\nThere are plenty of good reasons for why Apache has to read in the whole workbook, but most of them have to do with the fact that the library allows you to read and write with random addresses. If (and only if) you just want to read the contents of an Excel file in a fast and memory effecient way, you probably don't need this ability. Unfortunately, the only thing in the POI library for reading a streaming workbook requires your code to use a SAX-like parser. All of the friendly classes like `Row` and `Cell` are missing from that API.\n\nThis library serves as a wrapper around that streaming API while preserving the syntax of the standard POI API. Read on to see if it's right for you.\n\n# Important! Read first!\n\nThe latest versions of this library (2.x) have dropped support for Java 7. This is due to POI 4.0 requiring Java 8; as that is a core dependency of this library, it cannot support older versions of Java. The older 1.x and 0.x versions will no longer be maintained.\n\n# Include\n\nThis library is available from from Maven Central, and you can optionally install it yourself. The Maven installation instructions can be found on the [release](https://github.com/monitorjbl/excel-streaming-reader/releases) page.\n\nTo use it, add this to your POM:\n\n```\n<dependencies>\n  <dependency>\n    <groupId>com.monitorjbl</groupId>\n    <artifactId>xlsx-streamer</artifactId>\n    <version>2.0.0</version>\n  </dependency>\n</dependencies>  \n```\n\n# Usage\n\nThis library is very specific in how it is meant to be used. You should initialize it like so:\n\n```java\nimport com.monitorjbl.xlsx.StreamingReader;\n\nInputStream is = new FileInputStream(new File(\"/path/to/workbook.xlsx\"));\nWorkbook workbook = StreamingReader.builder()\n        .rowCacheSize(100)    // number of rows to keep in memory (defaults to 10)\n        .bufferSize(4096)     // buffer size to use when reading InputStream to file (defaults to 1024)\n        .open(is);            // InputStream or File for XLSX file (required)\n```\n\nOnce you've done this, you can then iterate through the rows and cells like so:\n\n```java\nfor (Sheet sheet : workbook){\n  System.out.println(sheet.getSheetName());\n  for (Row r : sheet) {\n    for (Cell c : r) {\n      System.out.println(c.getStringCellValue());\n    }\n  }\n}\n```\n\nOr open a sheet by name or index:\n\n```java\nSheet sheet = workbook.getSheet(\"My Sheet\")\n```\n\nThe StreamingWorkbook is an autoclosable resource, and it's important that you close it to free the filesystem resource it consumed. With Java 7, you can do this:\n\n```java\ntry (\n  InputStream is = new FileInputStream(new File(\"/path/to/workbook.xlsx\"));\n  Workbook workbook = StreamingReader.builder()\n          .rowCacheSize(100)\n          .bufferSize(4096)\n          .open(is)) {\n  for (Sheet sheet : workbook){\n    System.out.println(sheet.getSheetName());\n    for (Row r : sheet) {\n      for (Cell c : r) {\n        System.out.println(c.getStringCellValue());\n      }\n    }\n  }\n}\n```\n\nYou may access cells randomly within a row, as the entire row is cached. **However**, there is no way to randomly access rows. As this is a streaming implementation, only a small number of rows are kept in memory at any given time.\n\n# Supported Methods\n\nNot all POI Cell and Row functions are supported. The most basic ones are (`Cell.getStringCellValue()`, `Cell.getColumnIndex()`, etc.), but don't be surprised if you get a `NotSupportedException` on the more advanced ones.\n\nI'll try to add more support as time goes on, but some items simply can't be read in a streaming fashion. Methods that require dependent values will not have said dependencies available at the point in the stream in which they are read.\n\nThis is a brief and very generalized list of things that are not supported for reads:\n\n* Functions\n* Macros\n* Styled cells (the styles are kept at the end of the ZIP file)\n\n# Logging\n\nThis library uses SLF4j logging. This is a rare use case, but you can plug in your logging provider and get some potentially useful output. Below is an example of doing this with log4j:\n\n**pom.xml**\n\n```\n<dependencies>\n  <dependency>\n    <groupId>com.monitorjbl</groupId>\n    <artifactId>xlsx-streamer</artifactId>\n    <version>2.0.0</version>\n  </dependency>\n  <dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>slf4j-log4j12</artifactId>\n    <version>1.7.6</version>\n  </dependency>\n  <dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n  </dependency>\n</dependencies>\n```\n\n**log4j.properties**\n\n```\nlog4j.rootLogger=DEBUG, A1\nlog4j.appender.A1=org.apache.log4j.ConsoleAppender\nlog4j.appender.A1.layout=org.apache.log4j.PatternLayout\nlog4j.appender.A1.layout.ConversionPattern=%d{ISO8601} [%c] %p: %m%n\n\nlog4j.category.com.monitorjbl=DEBUG\n```\n\n# Implementation Details\n\nThis library will take a provided `InputStream` and output it to the file system. The stream is piped safely through a configurable-sized buffer to prevent large usage of memory. Once the file is created, it is then streamed into memory from the file system.\n\nThe reason for needing the stream being outputted in this manner has to do with how ZIP files work. Because the XLSX file format is basically a ZIP file, it's not possible to find all of the entries without reading the entire InputStream.\n\nThis is a problem that can't really be gotten around for POI, as it needs a complete list of ZIP entries. The default implementation of reading from an `InputStream` in POI is to read the entire stream directly into memory. This library works by reading out the stream into a temporary file. As part of the auto-close action, the temporary file is deleted.\n\nIf you need more control over how the file is created/disposed of, there is an option to initialize the library with a `java.io.File`. This file will not be written to or removed:\n\n```java\nFile f = new File(\"/path/to/workbook.xlsx\");\nWorkbook workbook = StreamingReader.builder()\n        .rowCacheSize(100)    \n        .bufferSize(4096)     \n        .open(f);\n```\n\nThis library will ONLY work with XLSX files. The older XLS format is not capable of being streamed.\n"], "fixing_code": ["[![Run Status](https://api.shippable.com/projects/55cfbb00edd7f2c052a980a5/badge?branch=master)](https://app.shippable.com/projects/55cfbb00edd7f2c052a980a5)\n\n# !!! Security Alert !!!\n\nUpdate to the latest version (2.1.0) **as soon as possible** to fix a critical vulnerability. The Xerxes XML parsing library that Excel Streaming Reader uses defaulted to allowing [entity expansion](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet), which could be exploited by an attacker to read arbitrary data from your system. The latest versions of Excel Streaming Reader do not allow this and will throw a `ParsingException` if a workbook contains an XML document with an entity declaration.\n\n# Excel Streaming Reader\n\nIf you've used [Apache POI](http://poi.apache.org) in the past to read in Excel files, you probably noticed that it's not very memory efficient. Reading in an entire workbook will cause a severe memory usage spike, which can wreak havoc on a server. \n\nThere are plenty of good reasons for why Apache has to read in the whole workbook, but most of them have to do with the fact that the library allows you to read and write with random addresses. If (and only if) you just want to read the contents of an Excel file in a fast and memory effecient way, you probably don't need this ability. Unfortunately, the only thing in the POI library for reading a streaming workbook requires your code to use a SAX-like parser. All of the friendly classes like `Row` and `Cell` are missing from that API.\n\nThis library serves as a wrapper around that streaming API while preserving the syntax of the standard POI API. Read on to see if it's right for you.\n\n# Important! Read first!\n\nThe latest versions of this library (2.x) have dropped support for Java 7. This is due to POI 4.0 requiring Java 8; as that is a core dependency of this library, it cannot support older versions of Java. The older 1.x and 0.x versions will no longer be maintained.\n\n# Include\n\nThis library is available from from Maven Central, and you can optionally install it yourself. The Maven installation instructions can be found on the [release](https://github.com/monitorjbl/excel-streaming-reader/releases) page.\n\nTo use it, add this to your POM:\n\n```\n<dependencies>\n  <dependency>\n    <groupId>com.monitorjbl</groupId>\n    <artifactId>xlsx-streamer</artifactId>\n    <version>2.1.0</version>\n  </dependency>\n</dependencies>  \n```\n\n# Usage\n\nThis library is very specific in how it is meant to be used. You should initialize it like so:\n\n```java\nimport com.monitorjbl.xlsx.StreamingReader;\n\nInputStream is = new FileInputStream(new File(\"/path/to/workbook.xlsx\"));\nWorkbook workbook = StreamingReader.builder()\n        .rowCacheSize(100)    // number of rows to keep in memory (defaults to 10)\n        .bufferSize(4096)     // buffer size to use when reading InputStream to file (defaults to 1024)\n        .open(is);            // InputStream or File for XLSX file (required)\n```\n\nOnce you've done this, you can then iterate through the rows and cells like so:\n\n```java\nfor (Sheet sheet : workbook){\n  System.out.println(sheet.getSheetName());\n  for (Row r : sheet) {\n    for (Cell c : r) {\n      System.out.println(c.getStringCellValue());\n    }\n  }\n}\n```\n\nOr open a sheet by name or index:\n\n```java\nSheet sheet = workbook.getSheet(\"My Sheet\")\n```\n\nThe StreamingWorkbook is an autoclosable resource, and it's important that you close it to free the filesystem resource it consumed. With Java 7, you can do this:\n\n```java\ntry (\n  InputStream is = new FileInputStream(new File(\"/path/to/workbook.xlsx\"));\n  Workbook workbook = StreamingReader.builder()\n          .rowCacheSize(100)\n          .bufferSize(4096)\n          .open(is)) {\n  for (Sheet sheet : workbook){\n    System.out.println(sheet.getSheetName());\n    for (Row r : sheet) {\n      for (Cell c : r) {\n        System.out.println(c.getStringCellValue());\n      }\n    }\n  }\n}\n```\n\nYou may access cells randomly within a row, as the entire row is cached. **However**, there is no way to randomly access rows. As this is a streaming implementation, only a small number of rows are kept in memory at any given time.\n\n# Supported Methods\n\nNot all POI Cell and Row functions are supported. The most basic ones are (`Cell.getStringCellValue()`, `Cell.getColumnIndex()`, etc.), but don't be surprised if you get a `NotSupportedException` on the more advanced ones.\n\nI'll try to add more support as time goes on, but some items simply can't be read in a streaming fashion. Methods that require dependent values will not have said dependencies available at the point in the stream in which they are read.\n\nThis is a brief and very generalized list of things that are not supported for reads:\n\n* Functions\n* Macros\n* Styled cells (the styles are kept at the end of the ZIP file)\n\n# Logging\n\nThis library uses SLF4j logging. This is a rare use case, but you can plug in your logging provider and get some potentially useful output. Below is an example of doing this with log4j:\n\n**pom.xml**\n\n```\n<dependencies>\n  <dependency>\n    <groupId>com.monitorjbl</groupId>\n    <artifactId>xlsx-streamer</artifactId>\n    <version>2.1.0</version>\n  </dependency>\n  <dependency>\n    <groupId>org.slf4j</groupId>\n    <artifactId>slf4j-log4j12</artifactId>\n    <version>1.7.6</version>\n  </dependency>\n  <dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n  </dependency>\n</dependencies>\n```\n\n**log4j.properties**\n\n```\nlog4j.rootLogger=DEBUG, A1\nlog4j.appender.A1=org.apache.log4j.ConsoleAppender\nlog4j.appender.A1.layout=org.apache.log4j.PatternLayout\nlog4j.appender.A1.layout.ConversionPattern=%d{ISO8601} [%c] %p: %m%n\n\nlog4j.category.com.monitorjbl=DEBUG\n```\n\n# Implementation Details\n\nThis library will take a provided `InputStream` and output it to the file system. The stream is piped safely through a configurable-sized buffer to prevent large usage of memory. Once the file is created, it is then streamed into memory from the file system.\n\nThe reason for needing the stream being outputted in this manner has to do with how ZIP files work. Because the XLSX file format is basically a ZIP file, it's not possible to find all of the entries without reading the entire InputStream.\n\nThis is a problem that can't really be gotten around for POI, as it needs a complete list of ZIP entries. The default implementation of reading from an `InputStream` in POI is to read the entire stream directly into memory. This library works by reading out the stream into a temporary file. As part of the auto-close action, the temporary file is deleted.\n\nIf you need more control over how the file is created/disposed of, there is an option to initialize the library with a `java.io.File`. This file will not be written to or removed:\n\n```java\nFile f = new File(\"/path/to/workbook.xlsx\");\nWorkbook workbook = StreamingReader.builder()\n        .rowCacheSize(100)    \n        .bufferSize(4096)     \n        .open(f);\n```\n\nThis library will ONLY work with XLSX files. The older XLS format is not capable of being streamed.\n"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [110], "fixing_code_start_loc": [2], "fixing_code_end_loc": [114], "type": "CWE-611", "message": "Excel-Streaming-Reader is an easy-to-use implementation of a streaming Excel reader using Apache POI. Prior to xlsx-streamer 2.1.0, the XML parser that was used did apply all the necessary settings to prevent XML Entity Expansion issues. Upgrade to version 2.1.0 to receive a patch. There is no known workaround.", "other": {"cve": {"id": "CVE-2022-23640", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-02T20:15:07.837", "lastModified": "2022-03-09T18:01:23.530", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Excel-Streaming-Reader is an easy-to-use implementation of a streaming Excel reader using Apache POI. Prior to xlsx-streamer 2.1.0, the XML parser that was used did apply all the necessary settings to prevent XML Entity Expansion issues. Upgrade to version 2.1.0 to receive a patch. There is no known workaround."}, {"lang": "es", "value": "Excel-Streaming-Reader es una implementaci\u00f3n f\u00e1cil de usar de un lector de Excel en streaming usando Apache POI. En versiones anteriores a 2.1.0 de xlsx-streamer, el analizador XML usado aplicaba todos los ajustes necesarios para evitar problemas de expansi\u00f3n de entidades XML. Actualice a versi\u00f3n 2.1.0 para recibir un parche. No se presentan medidas de mitigaci\u00f3n conocidas\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:excel_streaming_reader_project:excel_streaming_reader:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.0", "matchCriteriaId": "BD90DB1F-03FF-4A8A-8D42-FD840053289B"}]}]}], "references": [{"url": "https://github.com/monitorjbl/excel-streaming-reader/commit/0749c7b9709db078ccdeada16d46a34bc2910c73", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/monitorjbl/excel-streaming-reader/security/advisories/GHSA-xvm2-9xvc-hx7f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/monitorjbl/excel-streaming-reader/commit/0749c7b9709db078ccdeada16d46a34bc2910c73"}}