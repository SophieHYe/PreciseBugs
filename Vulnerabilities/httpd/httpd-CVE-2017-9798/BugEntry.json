{"buggy_code": ["                                                         -*- coding: utf-8 -*-\nChanges with Apache 2.5.0\n\n  *) mod_md: v0.9.1:\n     - various fixes in MDRenewWindow handling when specifying percent. Serialization changed. If \n       someone already used percent configurations, it is advised to change these to a new value,\n       reload and change back to the wanted ones.\n     - various fixes in handling of MDPrivateKeys when specifying 2048 bits (the default) explicitly.\n     - mod_md version removed from top level md_store.json file. The store has its own format version\n       to facilitate upgrades.\n    [Stefan Eissing]\n\n  *) mod_http2: DoS flow control protection is less agressive as long as active tasks stay\n     below worker capacity. Intended to fix problems with media streaming. [Stefan Eissing]\n     \n  *) mod_md: v0.9.0:\n     Certificate provisioning from Let's Encrypt (and other ACME CAs) for mod_ssl virtual hosts.\n     [Stefan Eissing]\n  \n  *) mod_proxy: loadfactor parameter can now be a decimal number (eg: 1.25).\n     [Jim Jagielski]\n\n  *) mod_watchdog/mod_proxy_hcheck: Time intervals can now be spefified\n     down to the millisecond. Supports 'mi' (minute), 'ms' (millisecond),\n     's' (second) and 'hr' (hour!) time suffixes. [Jim Jagielski]\n\n  *) mod_ssl: add SSLPolicy (define/use) and SSLProxyPolicy directives plus documentation. Add\n     core definitions for policies 'modern', 'intermediate' and 'old', as defined by Mozilla\n     in <https://wiki.mozilla.org/Security/Server_Side_TLS>. [Stefan Eissing]\n     \n  *) mod_proxy: Fix ProxyAddHeaders merging.  [Joe Orton]\n\n  *) mod_md: new module for managing domains across VirtualHosts with ACME protocol \n     implementation for automated certificate signup and renewal. Default CA is\n     the test area of Let's Encrypt right now, so certificates root will not be valid.\n     Will be switched to the real service endpoint rather soon. If you need it now,\n     configure 'MDCertificateAuthority https://acme-v01.api.letsencrypt.org/directory'.\n     [Stefan Eissing] \n     \n  *) mod_ssl, ab: Fix compatibility with LibreSSL.  PR 61184.\n     [Bernard Spil <brnrd freebsd.org>, Yann Ylavic]\n\n  *) event: Avoid possible blocking in the listener thread when shutting down\n     connections. PR 60956.  [Yann Ylavic]\n\n  *) mod_proxy_fcgi: Add the support for mod_proxy's flushpackets and flushwait\n     parameters. [Luca Toscano, Ruediger Pluem, Yann Ylavic]\n\n  *) mod_proxy_wstunnel: Fix detection of unresponded request which could have\n     led to spurious HTTP 502 error messages sent on upgrade connections.\n     PR 61283.  [Yann Ylavic]\n\n  *) mod_http2: Simplify ready queue, less memory and better performance. Update\n     mod_http2 version to 1.10.7. [Stefan Eissing]\n  \n  *) htpasswd / htdigest: Do not apply the strict permissions of the temporary\n     passwd file to a possibly existing passwd file. PR 61240. [Ruediger Pluem]\n\n  *) mod_rewrite: Add 'RewriteOptions LongURLOptimization' to free memory\n     from each set of unmatched rewrite conditions.\n     [Eric Covener]\n\n  *) Allow the argument to <IfFile>, <IfDefine>, <IfSection>, <IfDirective>, \n     and <IfModule> to be quoted.  This is primarily for the benefit of\n     <IfFile>. [Eric Covener]\n\n  *) Introduce request taint checking framework to prevent privilege\n     hijacking through .htaccess. [Nick Kew]\n\n  *) core: Disallow multiple Listen on the same IP:port when listener buckets\n     are configured (ListenCoresBucketsRatio > 0), consistently with the single\n     bucket case (default), thus avoiding the leak of the corresponding socket\n     descriptors on graceful restart.  [Yann Ylavic]\n\n  *) Add <IfDirective> and <IfSection> directives.  [Joe Orton]\n\n  *) mod_syslog: Support use of optional \"tag\" in syslog entries.\n     PR 60525. [Ben Rubson <ben.rubson gmail.com>, Jim Jagielski]\n\n  *) When using mod_status with the Event MPM, report the number of requests\n     associated with an active connection in the \"ACC\" field. Previously\n     zero was always reported with this MPM.  PR60647. [Eric Covener]\n\n  *) mod_remoteip: Add support for PROXY protocol (code donated by Cloudzilla).\n     Add ability for PROXY protocol processing to be optional to donated code.\n     See also: http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt\n     [Cloudzilla/roadrunner2@GitHub, Jim Jagielski, Daniel Ruggeri]\n\n  *) mod_remoteip: When overriding the useragent address from X-Forwarded-For,\n     zero out what had been initialized as the connection-level port.  PR59931.\n     [Hank Ibell <hwibell gmail.com>]\n\n  *) mod_proxy_wstunnel: Reliably run before mod_proxy_http.\n     [Eric Covener]\n\n  *) mod_proxy_protocol: Add server-side, front-end support for PROXY PROTOCOL\n     (http://blog.haproxy.com/haproxy/proxy-protocol/).  [roadrunner2]\n     \n  *) http: Allow unknown response status' lines returned in the form of\n     \"HTTP/x.x xxx Status xxx\".  [Yann Ylavic]\n\n  *) core: Add <IfFile> configuration section to allow any file on disk to be\n     used as a conditional.  [Edward Lu, Eric Covener]\n\n  *) event: Avoid listener periodic wake ups by using the pollset wake-ability\n     when available.  PR 57399.  [Yann Ylavic, Luca Toscano]\n\n  *) mod_crypto: Add the all purpose crypto filters with support for HLS.\n     [Graham Leggett]\n\n  *) core: Drop an invalid Last-Modified header value coming\n     from a FCGI/CGI script instead of replacing it with Unix epoch.\n     Warn the users about Last-Modified header value replacements\n     and violations of the RFC.\n     [Yann Ylavic, Luca Toscano, William Rowe, Jacob Champion]\n\n  *) mod_dav: Allow other modules to become providers and add ACLs\n     to the DAV response.\n     [Jari Urpalainen <jari.urpalainen nokia.com>, Graham Leggett]\n\n  *) mod_dav: Add dav_begin_multistatus, dav_send_one_response,\n     dav_finish_multistatus, dav_send_multistatus, dav_handle_err,\n     dav_failed_proppatch, dav_success_proppatch to mod_dav.h.\n     [Jari Urpalainen <jari.urpalainen nokia.com>, Graham Leggett]\n\n  *) mod_proxy, mod_ssl: Handle SSLProxy* directives in <Proxy> sections,\n     allowing per backend TLS configuration.  [Yann Ylavic]\n\n  *) core: explicitly exclude 'h2' from protocols announced via an Upgrade: \n     header as commanded by http-wg. [Stefan Eissing]\n\n  *) mod_proxy_ajp: Add \"secret\" parameter to proxy workers to implement legacy\n     AJP13 authentication.  PR 53098.  [Dmitry A. Bakshaev <dab1818 gmail com>]\n\n  *) mpm: Generalise the ap_mpm_register_socket functions to accept pipes\n     or sockets. [Graham Leggett]\n\n  *) core: Extend support for setting aside data from the network input filter\n     to any connection or request input filter. [Graham Leggett]\n\n  *) core: Split ap_create_request() from ap_read_request(). [Graham Leggett]\n\n  *) mod_auth_digest: Fix compatibility with expression-based Authname. PR59039.\n     [Eric Covener]\n\n  *) mpm: Add a complete_connection hook that confirms whether an MPM is allowed\n     to leave the WRITE_COMPLETION phase. Move filter code out of the MPMs.\n     [Graham Leggett]\n\n  *) core: Added support for HTTP code 451. PR58985.\n     [Yehuda Katz <yehuda ymkatz.net>, Jim Jagielski]\n\n  *) mod_filter: Fix AddOutputFilterByType with non-content-level filters.\n     PR58856 [Micha Lenk <micha lenk.info>]\n\n  *) mod_cache: Consider Cache-Control: s-maxage in expiration\n     calculations.  [Eric Covener]\n\n  *) mod_cache: Allow caching of responses with an Expires header\n     in the past that also has Cache-Control: max-age or s-maxage.\n     PR55156. [Eric Covener]\n\n  *) Added many log numbers to log statements that had none.\n\n  *) mod_session: Introduce SessionExpiryUpdateInterval which allows to\n     configure the session/cookie expiry's update interval. PR 57300.\n     [Paul Spangler <paul.spangler ni.com>]\n\n  *) core: Extend support for asynchronous write completion from the\n     network filter to any connection or request filter. [Graham Leggett]\n\n  *) mod_auth_digest: remove AuthDigestEnableQueryStringHack which is no\n     more documented since dec 2012 (r1415960). [Christophe Jaillet]\n\n  *) mod_charset_lite: On EBCDIC platforms, make sure mod_charset_lite runs\n     after other resource-level filters. [Eric Covener]\n\n  *) http: Don't remove the Content-Length of zero from a HEAD response if\n     it comes from an origin server, module or script.  [Yann Ylavic]\n\n  *) http: Add support for RFC2324/RFC7168. [Graham Leggett]\n\n  *) mod_rewrite: Add support for starting External Rewriting Programs\n     as non-root user on UNIX systems by specifying username and group name\n     as third argument of RewriteMap directive. [Jan Kaluza]\n\n  *) mod_authn_core: Add expression support to AuthName and AuthType.\n     [Graham Leggett]\n\n  *) suexec: Filter out the HTTP_PROXY environment variable because it is\n     treated as alias for http_proxy by some programs. [Stefan Fritsch]\n\n  *) mod_proxy_http: Don't establish or reuse a backend connection before pre-\n     fetching the request body, so to minimize the delay between it is supposed\n     to be alive and the first bytes sent: this is a best effort to prevent the\n     backend from closing because of idle or keepalive timeout in the meantime.\n     Also, handle a new \"proxy-flushall\" environment variable which allows to\n     flush any forwarded body data immediately. PR 56541+37920. [Yann Ylavic]\n\n  *) core: Define and UnDefine are no longer permitted in\n     directory context. Previously they would always be evaulated\n     as the configuration was read without regard for the directory\n     context. [Eric Covener]\n\n  *) config: For directives that do not expect any arguments, enforce\n     that none are specified in the configuration file. \n     [Joachim Zobel <jzobel heute-morgen.de>, Eric Covener]\n\n  *) mod_rewrite: Improve 'bad flag delimeters' startup error by showing\n     how the input was tokenized.  PR 56528. [Edward Lu <Chaosed0 gmail.com>]\n\n  *) mod_proxy: Don't put non balancer-member workers in error state by\n     default for connection or 500/503 errors, and honor status=+I for\n     any error.  PR 48388.  [Yann Ylavic]\n\n  *) mod_socache_memcache: Pass expiration time through to memcached. PR 55445.\n     [Faidon Liambotis <paravoid debian.org>, Joe Orton]\n\n  *) ap_expr: Add filemod function for checking file modification dates\n     [Daniel Gruno]\n\n  *) mod_authnz_ldap: Resolve crashes with LDAP authz and non-LDAP authn since \n     r1608202. [Eric Covener]\n\n  *) apreq: Content-Length header should be always interpreted as a decimal.\n     Leading 0 could be erroneously considered as an octal value. PR 56598.\n     [Chris Card <ctcard hotmail com>]\n\n  *) mod_proxy: Now allow for 191 character worker names, with non-fatal\n     errors if name is truncated. PR53218. [Jim Jagielski]\n\n  *) mod_ssl: Add optional function \"ssl_get_tls_cb\" to allow support\n     for channel bindings.  [Simo Sorce <simo redhat.com>]\n\n  *) mod_proxy_wstunnel: Concurrent websockets messages could be \n     lost or delayed with ProxyWebsocketAsync enabled.  \n     [Edward Lu <Chaosed0 gmail.com>]\n\n  *) core, mod_info: Add compiled and loaded PCRE versions to version\n     number display.  [Rainer Jung]\n\n  *) mod_authnz_ldap: Return LDAP connections to the pool before the handler\n     is run, instead of waiting until the end of the request. [Eric Covener]\n\n  *) mod_proxy_html: support automatic detection of doctype and processing\n     of FPIs.  PR56285 [Micha Lenk <micha lenk info>, Nick Kew]\n\n  *) mod_proxy_html: skip documents shorter than 4 bytes\n     PR 56286 [Micha Lenk <micha lenk info>]\n\n  *) mod_proxy_fdpass: Fix computation of the size of 'struct sockaddr_un'\n     when passed to 'connect()'.\n     [Graham Dumpleton <grahamd apache org>]\n\n  *) core: Add ap_mpm_resume_suspended() API to allow a suspended connection\n     to resume. PR56333 \n     [Artem <artemciy gmail.com>, Edward Lu <Chaosed0 gmail.com>]\n\n  *) core: Add ap_mpm_register_socket_callback_timeout() API. [Eric Covener]\n\n  *) mod_proxy_wstunnel: Honor ProxyWebsocketIdleTimeout in asynchronous\n     processing mode. [Eric Covener]\n\n  *) mod_authnz_ldap: Fail explicitly when the filter is too long. Remove\n     unnecessary apr_pstrdup() and strlen(). [Graham Leggett]\n\n  *) Add the ldap-search option to mod_authnz_ldap, allowing authorization\n     to be based on arbitrary expressions that do not include the username.\n     [Graham Leggett]\n\n  *) Add the ldap function to the expression API, allowing LDAP filters and\n     distinguished names based on expressions to be escaped correctly to\n     guard against LDAP injection. [Graham Leggett]\n\n  *) Add module mod_ssl_ct, which provides an implementation of Certificate\n     Transparency (RFC 6962) for httpd.  [Jeff Trawick]\n\n  *) mod_proxy_wstunnel: Avoid sending error responses down an upgraded\n     websockets connection as it is being close down. [Eric Covener]\n\n  *) mod_proxy_wstunnel: Allow the administrator to cap the amount\n     of time a synchronous websockets connection stays idle with \n     ProxyWebsocketIdleTimeout. [Eric Covener]\n\n  *) mod_proxy_wstunnel: Change to opt-in for asynchronous support, adding \n     directives ProxyWebsocketAsync and ProxyWebsocketAsyncDelay. \n     [Eric Covener]\n\n  *) mod_proxy_wstunnel: Stop leaking websockets backend connections under\n     event MPM (trunk-only). [Eric Covener]\n\n  *) mod_proxy_http: Add detach_backend hook (potentially usable\n     in other proxy scheme handlers).  [Jeff Trawick]\n\n  *) mod_deflate: Add DeflateAlterETag to control how the ETag\n     is modified. The 'NoChange' parameter mimics 2.2.x behavior.\n     PR 45023, PR 39727. [Eric Covener]\n\n  *) mod_rewrite: Add 'BNF' (backreferences-no-plus) flag to RewriteRule to \n     allow spaces in backreferences to be encoded as %20 instead of '+'.\n     [Eric Covener]\n\n  *) mod_rewrite: Support an optional list of characters to escape in the \n     argument for the 'B' (escape backreferences) flag. [Eric Covener]\n\n  *) mod_dir: Default to 2.2-like behavior and skip execution when method is\n     neither GET nor POST, such as for DAV requests. PR 54914. [Chris Darroch]\n\n  *) mod_rewrite: Rename the handler that does per-directory internal \n     redirects to \"rewrite-redirect-handler\" from \"redirect-handler\" so\n     it is less ambiguous and less likely to be reused. [Eric Covener]\n\n  *) mod_rewrite: Protect against looping with the [N] flag by enforcing a \n     default limit of 10000 iterations, and allowing each rule to change its\n     limit. [Eric Covener]\n\n  *) mod_ssl: Fix config merging of SSLOCSPEnable and SSLOCSPOverrideResponder.\n     [Jeff Trawick]\n\n  *) Add HttpContentLengthHeadZero and HttpExpectStrict directives.\n     [Yehuda Sadeh <yehuda inktank com>, Justin Erenkrantz]\n\n  *) mod_ssl: Add -t -DDUMP_CA_CERTS option which dumps the filenames of all\n     configured SSL CA certificates to stdout the same way as DUMP_CERTS does.\n     [Jan Kaluza]\n\n  *) mod_ssl: Don't flush when an EOS is received. Prepares mod_ssl\n     to support write completion. [Graham Leggett]\n\n  *) core: Add parse_errorlog_arg callback to ap_errorlog_provider\n     to allow providers to check the ErrorLog argument. [Jan Kaluza]\n\n  *) mod_cgid: Use the servers Timeout for each read from a CGI script,\n     allow override with new CGIDRequestTimeout directive. PR43494\n     [Eric Covener, Toshikuni Fukaya <toshikuni-fukaya cybozu co jp>]\n\n  *) core: ensure any abnormal exit is reported to stderr if it's a tty.\n     PR 55670 [Nick Kew]\n\n  *) mod_lua: Let the Inter-VM get/set functions work with a global \n     shared memory pool instead of a per-process pool. [Daniel Gruno]\n\n  *) ldap: Support ldaps when using the Microsoft LDAP SDK.\n     PR 54626. [Jean-Frederic Clere]\n\n  *) mod_authnz_ldap: Change default value of AuthLDAPMaxSubGroupDepth to 0\n     to avoid performance problems when subgroups aren't in use. [Eric Covener]\n\n  *) mod_syslog: New module implementing syslog ap_error_log provider.\n     Previously, this code was part of core, now it's in separate module.\n     [Jan Kaluza]\n\n  *) core: Add ap_errorlog_provider to make ErrorLog logging modular. Move\n     syslog support from core to new mod_syslog. [Jan Kaluza]\n\n  *) mod_status, mod_echo: Fix the display of client addresses.\n     They were truncated to 31 characters which is not enough for IPv6 addresses.\n     PR 54848 [Bernhard Schmidt <berni birkenwald de>]\n\n  *) mod_unique_id: Use output of the PRNG rather than IP address and\n     pid, avoiding sleep() call and possible DNS issues at startup,\n     plus improving randomness for IPv6-only hosts.\n     [Jan Kaluza <jkaluza redhat.com>]\n\n  *) mod_file_cache: mod_file_cache should be able to serve files that\n     haven't had a Content-Type set via e.g. mod_mime. [Eric Covener]\n\n  *) core: merge AllowEncodedSlashes from the base configuration into\n     virtual hosts. [Eric Covener]\n\n  *) AIX: Install DSO's with \"cp\" instead of \"install\" in instdso.sh\n     [Eric Covener]\n\n  *) mod_ldap: Don't keep retrying if a new LDAP connection times out.\n     [Eric Covener]\n\n  *) mod_deflate: permit compilation of mod_deflate against a zlib that has\n     been configured with -D Z_PREFIX, which redefines the token \"deflate\".\n     [Eric Covener]\n\n  *) mod_auth_digest: Use the secret when generating nonces in all cases and\n     not only when AuthName is used in .htaccess files (this change may cause\n     problems if used with round robin load balancers). Don't regenerate the\n     secret on graceful restarts. PR 54637  [Stefan Fritsch]\n\n  *) core: Remove apr_brigade_flatten(), buffering and duplicated code\n     from the HTTP_IN filter, parse chunks in a single pass with zero copy.\n     Reduce memory usage by 48 bytes per request. [Graham Leggett]\n\n  *) core: Stop the HTTP_IN filter from attempting to write error buckets\n     to the output filters, which is bogus in the proxy case. Create a\n     clean mapping from APR codes to HTTP status codes, and use it where\n     needed. [Graham Leggett]\n\n  *) mod_proxy: Ensure network errors detected by the proxy are returned as\n     504 Gateway Timout as opposed to 502 Bad Gateway, in order to be\n     compliant with RFC2616 14.9.4 Cache Revalidation and Reload Controls.\n\n  *) mod_dav: mod_dav overrides dav_fs response on PUT failure. PR 35981\n     [Basant Kumar Kukreja <basant.kukreja sun.com>, Alejandro Alvarez\n     <alejandro.alvarez.ayllon cern.ch>]\n\n  *) mod_ldap: LDAP connections used for authentication were not respecting\n     LDAPConnectionPoolTimeout.  PR 54587\n\n  *) core: ap_rgetline_core now pulls from r->proto_input_filters.\n\n  *) mod_proxy_html: process parsed comments immediately. \n     Fixes bug where parsed comments may be lost. [Nick Kew]\n\n  *) mod_proxy_html: introduce doctype for HTML 5 [Nick Kew]\n\n  *) mod_proxy_html: fix typo-bug processing \"strict\" vs \"transitional\"\n     HTML/XHTML [Nick Kew]\n\n  *) core: Add option to add valgrind support. Use it to reduce false positive\n     warnings in mod_ssl. [Stefan Fritsch]\n\n  *) mod_authn_file, mod_authn_dbd, mod_authn_dbm, mod_authn_socache:\n     Cache the result of the most recent password hash verification for every\n     keep-alive connection. This saves some expensive calculations.\n     [Stefan Fritsch]\n\n  *) http: Remove support for Request-Range header sent by Navigator 2-3 and\n     MSIE 3. [Stefan Fritsch]\n\n  *) core, http: Extend HttpProtocol with an option to enforce stricter HTTP\n     conformance or to only log the found problems. [Stefan Fritsch]\n\n  *) core: Correctly parse an IPv6 literal host specification in an absolute\n     URL in the request line. [Stefan Fritsch]\n\n  *) EventOpt MPM\n\n  *) core: Add LogLevelOverride directive that allows to override the\n     loglevel for clients from certain IPs. This also works for things\n     like the SSL handshake where <If> LogLevel ... </If> is evaluated\n     too late. [Stefan Fritsch]\n\n  *) core: Add new directive Warning to issue warnings from a configuration\n     file. Both Warning and Error now generate a timestamped log message.\n     [Fabien Coelho] \n\n  *) ap_expr: Add SERVER_PROTOCOL_VERSION, ..._MAJOR, and ..._MINOR\n     variables. [Stefan Fritsch]\n\n  *) core: New directive RegisterHttpMethod for registering non-standard\n     HTTP methods. [Stefan Fritsch]\n\n  *) core: New directive HttpProtocol which allows to disable HTTP/0.9\n     support. [Stefan Fritsch]\n\n  *) mod_allowhandlers: New module to forbid specific handlers for specific\n     directories. [Stefan Fritsch]\n\n  *) mod_systemd: New module, for integration with systemd on Linux.\n     [Jan Kaluza <jkaluza redhat.com>]\n\n  *) WinNT MPM: Store pid and generation for each thread in scoreboard\n     to allow tracking of threads from exiting children via mod_status\n     or other such mechanisms.  [Jeff Trawick]\n\n  *) The following now respect DefaultRuntimeDir/DEFAULT_REL_RUNTIMEDIR:\n     - APIs: ap_log_pid(), ap_remove_pid, ap_read_pid()\n     - mod_cache: thundering herd lock directory\n     - mod_lbmethod_heartbeat, mod_heartmonitor: heartbeat storage file\n     - mod_ldap: shared memory cache\n     - mod_socache_shmcb, mod_socache_dbm: shared memory or dbm for cache\n     [Jeff Trawick]\n\n  *) suexec: Add --enable-suexec-capabilites support on Linux, to use\n     setuid/setgid capability bits rather than a setuid root binary.\n     [Joe Orton]\n\n  *) suexec: Add support for logging to syslog as an alternative to logging\n     to a file; configure --without-suexec-logfile --with-suexec-syslog.  \n     [Joe Orton]\n\n  *) mod_ssl: Add support for TLS Next Protocol Negotiation.  PR 52210.\n     [Matthew Steele <mdsteele google.com>]\n\n  *) cross-compile: allow to provide CC_FOR_BUILD so that gen_test_char will\n     be compiled by the build compiler instead of the host compiler.\n     Also set CC_FOR_BUILD to 'cc' when cross-compilation is detected.\n     PR 51257. [Guenter Knauf]\n\n  *) core: In maintainer mode, replace apr_palloc with a version that\n     initializes the allocated memory with non-zero values, except if\n     AP_DEBUG_NO_ALLOC_POISON is defined. [Stefan Fritsch]\n\n  *) mod_policy: Add a new testing module to help server administrators\n     enforce a configurable level of protocol compliance on their\n     servers and application servers behind theirs. [Graham Leggett]\n\n  *) mod_firehose: Add a new debugging module able to record traffic\n     passing through the server in such a way that connections and/or\n     requests be reconstructed and replayed. [Graham Leggett]\n\n  *) mod_noloris\n\n  *) APREQ\n\n  *) Simple MPM\n\n  *) mod_serf\n\n  [Apache 2.5.0-dev includes those bug fixes and changes with the\n   Apache 2.4.xx tree as documented below, except as noted.]\n\nChanges with Apache 2.4.x and later:\n\n  *) http://svn.apache.org/viewvc/httpd/httpd/branches/2.4.x/CHANGES?view=markup\n\nChanges with Apache 2.2.x and later:\n\n  *) http://svn.apache.org/viewvc/httpd/httpd/branches/2.2.x/CHANGES?view=markup\n\nChanges with Apache 2.0.x and later:\n\n  *) http://svn.apache.org/viewvc/httpd/httpd/branches/2.0.x/CHANGES?view=markup\n\n", "/* Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"apr.h\"\n#include \"apr_strings.h\"\n#include \"apr_lib.h\"\n#include \"apr_fnmatch.h\"\n#include \"apr_hash.h\"\n#include \"apr_thread_proc.h\"    /* for RLIMIT stuff */\n#include \"apr_random.h\"\n\n#define APR_WANT_IOVEC\n#define APR_WANT_STRFUNC\n#define APR_WANT_MEMFUNC\n#include \"apr_want.h\"\n\n#include \"ap_config.h\"\n#include \"httpd.h\"\n#include \"http_config.h\"\n#include \"http_core.h\"\n#include \"http_protocol.h\" /* For index_of_response().  Grump. */\n#include \"http_request.h\"\n#include \"http_vhost.h\"\n#include \"http_main.h\"     /* For the default_handler below... */\n#include \"http_log.h\"\n#include \"util_md5.h\"\n#include \"http_connection.h\"\n#include \"apr_buckets.h\"\n#include \"util_filter.h\"\n#include \"util_ebcdic.h\"\n#include \"util_mutex.h\"\n#include \"util_time.h\"\n#include \"mpm_common.h\"\n#include \"scoreboard.h\"\n#include \"mod_core.h\"\n#include \"mod_proxy.h\"\n#include \"ap_listen.h\"\n#include \"ap_provider.h\"\n\n#include \"mod_so.h\" /* for ap_find_loaded_module_symbol */\n\n#if defined(RLIMIT_CPU) || defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS) || defined (RLIMIT_NPROC)\n#include \"unixd.h\"\n#endif\n#if APR_HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n/* LimitRequestBody handling */\n#define AP_LIMIT_REQ_BODY_UNSET         ((apr_off_t) -1)\n#define AP_DEFAULT_LIMIT_REQ_BODY       ((apr_off_t) 0)\n\n/* LimitXMLRequestBody handling */\n#define AP_LIMIT_UNSET                  ((long) -1)\n#define AP_DEFAULT_LIMIT_XML_BODY       ((apr_size_t)1000000)\n\n#define AP_MIN_SENDFILE_BYTES           (256)\n\n/* maximum include nesting level */\n#ifndef AP_MAX_INCLUDE_DEPTH\n#define AP_MAX_INCLUDE_DEPTH            (128)\n#endif\n\n/* valid in core-conf, but not in runtime r->used_path_info */\n#define AP_ACCEPT_PATHINFO_UNSET 3\n\n#define AP_CONTENT_MD5_OFF   0\n#define AP_CONTENT_MD5_ON    1\n#define AP_CONTENT_MD5_UNSET 2\n\nAPR_HOOK_STRUCT(\n    APR_HOOK_LINK(get_mgmt_items)\n    APR_HOOK_LINK(insert_network_bucket)\n)\n\nAP_IMPLEMENT_HOOK_RUN_ALL(int, get_mgmt_items,\n                          (apr_pool_t *p, const char *val, apr_hash_t *ht),\n                          (p, val, ht), OK, DECLINED)\n\nAP_IMPLEMENT_HOOK_RUN_FIRST(apr_status_t, insert_network_bucket,\n                            (conn_rec *c, apr_bucket_brigade *bb,\n                             apr_socket_t *socket),\n                            (c, bb, socket), AP_DECLINED)\n\n/* Server core module... This module provides support for really basic\n * server operations, including options and commands which control the\n * operation of other modules.  Consider this the bureaucracy module.\n *\n * The core module also defines handlers, etc., to handle just enough\n * to allow a server with the core module ONLY to actually serve documents.\n *\n * This file could almost be mod_core.c, except for the stuff which affects\n * the http_conf_globals.\n */\n\n/* we know core's module_index is 0 */\n#undef APLOG_MODULE_INDEX\n#define APLOG_MODULE_INDEX AP_CORE_MODULE_INDEX\n\n/* Handles for core filters */\nAP_DECLARE_DATA ap_filter_rec_t *ap_subreq_core_filter_handle;\nAP_DECLARE_DATA ap_filter_rec_t *ap_request_core_filter_handle;\nAP_DECLARE_DATA ap_filter_rec_t *ap_core_output_filter_handle;\nAP_DECLARE_DATA ap_filter_rec_t *ap_content_length_filter_handle;\nAP_DECLARE_DATA ap_filter_rec_t *ap_core_input_filter_handle;\n\n/* Provide ap_document_root_check storage and default value = true */\nAP_DECLARE_DATA int ap_document_root_check = 1;\n\n/* magic pointer for ErrorDocument xxx \"default\" */\nstatic char errordocument_default;\n\nstatic apr_array_header_t *saved_server_config_defines = NULL;\nstatic apr_table_t *server_config_defined_vars = NULL;\n\nAP_DECLARE_DATA int ap_main_state = AP_SQ_MS_INITIAL_STARTUP;\nAP_DECLARE_DATA int ap_run_mode = AP_SQ_RM_UNKNOWN;\nAP_DECLARE_DATA int ap_config_generation = 0;\n\ntypedef struct {\n    apr_ipsubnet_t *subnet;\n    struct ap_logconf log;\n} conn_log_config;\n\nstatic void *create_core_dir_config(apr_pool_t *a, char *dir)\n{\n    core_dir_config *conf;\n\n    conf = (core_dir_config *)apr_pcalloc(a, sizeof(core_dir_config));\n\n    /* conf->r and conf->d[_*] are initialized by dirsection() or left NULL */\n\n    conf->opts = dir ? OPT_UNSET : OPT_UNSET|OPT_SYM_LINKS;\n    conf->opts_add = conf->opts_remove = OPT_NONE;\n    conf->override = OR_UNSET|OR_NONE;\n    conf->override_opts = OPT_UNSET | OPT_ALL | OPT_SYM_OWNER | OPT_MULTI;\n\n    conf->content_md5 = AP_CONTENT_MD5_UNSET;\n    conf->accept_path_info = AP_ACCEPT_PATHINFO_UNSET;\n\n    conf->use_canonical_name = USE_CANONICAL_NAME_UNSET;\n    conf->use_canonical_phys_port = USE_CANONICAL_PHYS_PORT_UNSET;\n\n    conf->hostname_lookups = HOSTNAME_LOOKUP_UNSET;\n\n    /*\n     * left as NULL (we use apr_pcalloc):\n     * conf->limit_cpu = NULL;\n     * conf->limit_mem = NULL;\n     * conf->limit_nproc = NULL;\n     * conf->sec_file = NULL;\n     * conf->sec_if   = NULL;\n     */\n\n    conf->limit_req_body = AP_LIMIT_REQ_BODY_UNSET;\n    conf->limit_xml_body = AP_LIMIT_UNSET;\n\n    conf->server_signature = srv_sig_unset;\n\n    conf->add_default_charset = ADD_DEFAULT_CHARSET_UNSET;\n    conf->add_default_charset_name = DEFAULT_ADD_DEFAULT_CHARSET_NAME;\n\n    /* Overriding all negotiation\n     * Set NULL by apr_pcalloc:\n     * conf->mime_type = NULL;\n     * conf->handler = NULL;\n     * conf->output_filters = NULL;\n     * conf->input_filters = NULL;\n     */\n\n    /*\n     * Flag for use of inodes in ETags.\n     */\n    conf->etag_bits = ETAG_UNSET;\n    conf->etag_add = ETAG_UNSET;\n    conf->etag_remove = ETAG_UNSET;\n\n    conf->enable_mmap = ENABLE_MMAP_UNSET;\n    conf->enable_sendfile = ENABLE_SENDFILE_UNSET;\n    conf->allow_encoded_slashes = 0;\n    conf->decode_encoded_slashes = 0;\n\n    conf->max_ranges = AP_MAXRANGES_UNSET;\n    conf->max_overlaps = AP_MAXRANGES_UNSET;\n    conf->max_reversals = AP_MAXRANGES_UNSET;\n\n    conf->cgi_pass_auth = AP_CGI_PASS_AUTH_UNSET;\n    conf->qualify_redirect_url = AP_CORE_CONFIG_UNSET; \n\n    return (void *)conf;\n}\n\nstatic void *merge_core_dir_configs(apr_pool_t *a, void *basev, void *newv)\n{\n    core_dir_config *base = (core_dir_config *)basev;\n    core_dir_config *new = (core_dir_config *)newv;\n    core_dir_config *conf;\n\n    /* Create this conf by duplicating the base, replacing elements\n     * (or creating copies for merging) where new-> values exist.\n     */\n    conf = (core_dir_config *)apr_pmemdup(a, base, sizeof(core_dir_config));\n\n    conf->d = new->d;\n    conf->d_is_fnmatch = new->d_is_fnmatch;\n    conf->d_components = new->d_components;\n    conf->r = new->r;\n    conf->refs = new->refs;\n    conf->condition = new->condition;\n\n    if (new->opts & OPT_UNSET) {\n        /* there was no explicit setting of new->opts, so we merge\n         * preserve the invariant (opts_add & opts_remove) == 0\n         */\n        conf->opts_add = (conf->opts_add & ~new->opts_remove) | new->opts_add;\n        conf->opts_remove = (conf->opts_remove & ~new->opts_add)\n                            | new->opts_remove;\n        conf->opts = (conf->opts & ~conf->opts_remove) | conf->opts_add;\n\n        /* If Includes was enabled with exec in the base config, but\n         * was enabled without exec in the new config, then disable\n         * exec in the merged set. */\n        if (((base->opts & (OPT_INCLUDES|OPT_INC_WITH_EXEC))\n             == (OPT_INCLUDES|OPT_INC_WITH_EXEC))\n            && ((new->opts & (OPT_INCLUDES|OPT_INC_WITH_EXEC))\n                == OPT_INCLUDES)) {\n            conf->opts &= ~OPT_INC_WITH_EXEC;\n        }\n    }\n    else {\n        /* otherwise we just copy, because an explicit opts setting\n         * overrides all earlier +/- modifiers\n         */\n        conf->opts = new->opts;\n        conf->opts_add = new->opts_add;\n        conf->opts_remove = new->opts_remove;\n    }\n\n    if (!(new->override & OR_UNSET)) {\n        conf->override = new->override;\n    }\n\n    if (!(new->override_opts & OPT_UNSET)) {\n        conf->override_opts = new->override_opts;\n    }\n\n    if (new->override_list != NULL) {\n        conf->override_list = new->override_list;\n    }\n\n    if (conf->response_code_exprs == NULL) {\n        conf->response_code_exprs = new->response_code_exprs;\n    }\n    else if (new->response_code_exprs != NULL) {\n        conf->response_code_exprs = apr_hash_overlay(a,\n                new->response_code_exprs, conf->response_code_exprs);\n    }\n    /* Otherwise we simply use the base->response_code_exprs array\n     */\n\n    if (new->hostname_lookups != HOSTNAME_LOOKUP_UNSET) {\n        conf->hostname_lookups = new->hostname_lookups;\n    }\n\n    if (new->content_md5 != AP_CONTENT_MD5_UNSET) {\n        conf->content_md5 = new->content_md5;\n    }\n\n    if (new->accept_path_info != AP_ACCEPT_PATHINFO_UNSET) {\n        conf->accept_path_info = new->accept_path_info;\n    }\n\n    if (new->use_canonical_name != USE_CANONICAL_NAME_UNSET) {\n        conf->use_canonical_name = new->use_canonical_name;\n    }\n\n    if (new->use_canonical_phys_port != USE_CANONICAL_PHYS_PORT_UNSET) {\n        conf->use_canonical_phys_port = new->use_canonical_phys_port;\n    }\n\n#ifdef RLIMIT_CPU\n    if (new->limit_cpu) {\n        conf->limit_cpu = new->limit_cpu;\n    }\n#endif\n\n#if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)\n    if (new->limit_mem) {\n        conf->limit_mem = new->limit_mem;\n    }\n#endif\n\n#ifdef RLIMIT_NPROC\n    if (new->limit_nproc) {\n        conf->limit_nproc = new->limit_nproc;\n    }\n#endif\n\n    if (new->limit_req_body != AP_LIMIT_REQ_BODY_UNSET) {\n        conf->limit_req_body = new->limit_req_body;\n    }\n\n    if (new->limit_xml_body != AP_LIMIT_UNSET)\n        conf->limit_xml_body = new->limit_xml_body;\n\n    if (!conf->sec_file) {\n        conf->sec_file = new->sec_file;\n    }\n    else if (new->sec_file) {\n        /* If we merge, the merge-result must have its own array\n         */\n        conf->sec_file = apr_array_append(a, base->sec_file, new->sec_file);\n    }\n    /* Otherwise we simply use the base->sec_file array\n     */\n\n    if (!conf->sec_if) {\n        conf->sec_if = new->sec_if;\n    }\n    else if (new->sec_if) {\n        /* If we merge, the merge-result must have its own array\n         */\n        conf->sec_if = apr_array_append(a, base->sec_if, new->sec_if);\n    }\n    /* Otherwise we simply use the base->sec_if array\n     */\n\n    if (new->server_signature != srv_sig_unset) {\n        conf->server_signature = new->server_signature;\n    }\n\n    if (new->add_default_charset != ADD_DEFAULT_CHARSET_UNSET) {\n        conf->add_default_charset = new->add_default_charset;\n        conf->add_default_charset_name = new->add_default_charset_name;\n    }\n\n    /* Overriding all negotiation\n     */\n    if (new->mime_type) {\n        conf->mime_type = new->mime_type;\n    }\n\n    if (new->handler) {\n        conf->handler = new->handler;\n    }\n    if (new->expr_handler) {\n        conf->expr_handler = new->expr_handler;\n    }\n\n    if (new->output_filters) {\n        conf->output_filters = new->output_filters;\n    }\n\n    if (new->input_filters) {\n        conf->input_filters = new->input_filters;\n    }\n\n    /*\n     * Now merge the setting of the FileETag directive.\n     */\n    if (new->etag_bits == ETAG_UNSET) {\n        conf->etag_add =\n            (conf->etag_add & (~ new->etag_remove)) | new->etag_add;\n        conf->etag_remove =\n            (conf->etag_remove & (~ new->etag_add)) | new->etag_remove;\n        conf->etag_bits =\n            (conf->etag_bits & (~ conf->etag_remove)) | conf->etag_add;\n    }\n    else {\n        conf->etag_bits = new->etag_bits;\n        conf->etag_add = new->etag_add;\n        conf->etag_remove = new->etag_remove;\n    }\n\n    if (conf->etag_bits != ETAG_NONE) {\n        conf->etag_bits &= (~ ETAG_NONE);\n    }\n\n    if (new->enable_mmap != ENABLE_MMAP_UNSET) {\n        conf->enable_mmap = new->enable_mmap;\n    }\n\n    if (new->enable_sendfile != ENABLE_SENDFILE_UNSET) {\n        conf->enable_sendfile = new->enable_sendfile;\n    }\n\n    if (new->allow_encoded_slashes_set) {\n        conf->allow_encoded_slashes = new->allow_encoded_slashes;\n    }\n    if (new->decode_encoded_slashes_set) {\n        conf->decode_encoded_slashes = new->decode_encoded_slashes;\n    }\n\n    if (new->log) {\n        if (!conf->log) {\n            conf->log = new->log;\n        }\n        else {\n            conf->log = ap_new_log_config(a, new->log);\n            ap_merge_log_config(base->log, conf->log);\n        }\n    }\n\n    conf->max_ranges = new->max_ranges != AP_MAXRANGES_UNSET ? new->max_ranges : base->max_ranges;\n    conf->max_overlaps = new->max_overlaps != AP_MAXRANGES_UNSET ? new->max_overlaps : base->max_overlaps;\n    conf->max_reversals = new->max_reversals != AP_MAXRANGES_UNSET ? new->max_reversals : base->max_reversals;\n\n    conf->cgi_pass_auth = new->cgi_pass_auth != AP_CGI_PASS_AUTH_UNSET ? new->cgi_pass_auth : base->cgi_pass_auth;\n\n    if (new->cgi_var_rules) {\n        if (!conf->cgi_var_rules) {\n            conf->cgi_var_rules = new->cgi_var_rules;\n        }\n        else {\n            conf->cgi_var_rules = apr_hash_overlay(a, new->cgi_var_rules, conf->cgi_var_rules);\n        }\n    }\n\n    AP_CORE_MERGE_FLAG(qualify_redirect_url, conf, base, new);\n\n    return (void*)conf;\n}\n\n#if APR_HAS_SO_ACCEPTFILTER\n#ifndef ACCEPT_FILTER_NAME\n#define ACCEPT_FILTER_NAME \"httpready\"\n#ifdef __FreeBSD_version\n#if __FreeBSD_version < 411000 /* httpready broken before 4.1.1 */\n#undef ACCEPT_FILTER_NAME\n#define ACCEPT_FILTER_NAME \"dataready\"\n#endif\n#endif\n#endif\n#endif\n\nstatic void *create_core_server_config(apr_pool_t *a, server_rec *s)\n{\n    core_server_config *conf;\n    int is_virtual = s->is_virtual;\n\n    conf = (core_server_config *)apr_pcalloc(a, sizeof(core_server_config));\n\n    /* global-default / global-only settings */\n\n    if (!is_virtual) {\n        conf->ap_document_root = DOCUMENT_LOCATION;\n        conf->access_name = DEFAULT_ACCESS_FNAME;\n\n        /* A mapping only makes sense in the global context */\n        conf->accf_map = apr_table_make(a, 5);\n#if APR_HAS_SO_ACCEPTFILTER\n        apr_table_setn(conf->accf_map, \"http\", ACCEPT_FILTER_NAME);\n        apr_table_setn(conf->accf_map, \"https\", \"dataready\");\n#elif defined(WIN32)\n        /* 'data' is disabled on Windows due to a DoS vuln (PR 59970) */\n        apr_table_setn(conf->accf_map, \"http\", \"connect\");\n        apr_table_setn(conf->accf_map, \"https\", \"connect\");\n#else\n        apr_table_setn(conf->accf_map, \"http\", \"data\");\n        apr_table_setn(conf->accf_map, \"https\", \"data\");\n#endif\n    }\n    /* pcalloc'ed - we have NULL's/0's\n    else ** is_virtual ** {\n        conf->ap_document_root = NULL;\n        conf->access_name = NULL;\n        conf->accf_map = NULL;\n    }\n     */\n\n    /* initialization, no special case for global context */\n\n    conf->sec_dir = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));\n    conf->sec_url = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));\n\n    /* pcalloc'ed - we have NULL's/0's\n    conf->gprof_dir = NULL;\n\n    ** recursion stopper; 0 == unset\n    conf->redirect_limit = 0;\n    conf->subreq_limit = 0;\n\n    conf->protocol = NULL;\n     */\n\n    conf->trace_enable = AP_TRACE_UNSET;\n\n    conf->protocols = apr_array_make(a, 5, sizeof(const char *));\n    conf->protocols_honor_order = -1;\n    conf->async_filter = 0;\n\n    return (void *)conf;\n}\n\nstatic void *merge_core_server_configs(apr_pool_t *p, void *basev, void *virtv)\n{\n    core_server_config *base = (core_server_config *)basev;\n    core_server_config *virt = (core_server_config *)virtv;\n    core_server_config *conf = (core_server_config *)\n                               apr_pmemdup(p, base, sizeof(core_server_config));\n\n    if (virt->ap_document_root)\n        conf->ap_document_root = virt->ap_document_root;\n\n    if (virt->access_name)\n        conf->access_name = virt->access_name;\n\n    /* XXX optimize to keep base->sec_ pointers if virt->sec_ array is empty */\n    conf->sec_dir = apr_array_append(p, base->sec_dir, virt->sec_dir);\n    conf->sec_url = apr_array_append(p, base->sec_url, virt->sec_url);\n\n    if (virt->redirect_limit)\n        conf->redirect_limit = virt->redirect_limit;\n\n    if (virt->subreq_limit)\n        conf->subreq_limit = virt->subreq_limit;\n\n    if (virt->trace_enable != AP_TRACE_UNSET)\n        conf->trace_enable = virt->trace_enable;\n\n    if (virt->http09_enable != AP_HTTP09_UNSET)\n        conf->http09_enable = virt->http09_enable;\n\n    if (virt->http_conformance != AP_HTTP_CONFORMANCE_UNSET)\n        conf->http_conformance = virt->http_conformance;\n\n    if (virt->http_methods != AP_HTTP_METHODS_UNSET)\n        conf->http_methods = virt->http_methods;\n\n    if (virt->http_cl_head_zero != AP_HTTP_CL_HEAD_ZERO_UNSET)\n        conf->http_cl_head_zero = virt->http_cl_head_zero;\n\n    if (virt->http_expect_strict != AP_HTTP_EXPECT_STRICT_UNSET)\n        conf->http_expect_strict = virt->http_expect_strict;\n\n    /* no action for virt->accf_map, not allowed per-vhost */\n\n    if (virt->protocol)\n        conf->protocol = virt->protocol;\n\n    if (virt->gprof_dir)\n        conf->gprof_dir = virt->gprof_dir;\n\n    if (virt->error_log_format)\n        conf->error_log_format = virt->error_log_format;\n\n    if (virt->error_log_conn)\n        conf->error_log_conn = virt->error_log_conn;\n\n    if (virt->error_log_req)\n        conf->error_log_req = virt->error_log_req;\n\n    if (virt->conn_log_level) {\n        if (!conf->conn_log_level) {\n            conf->conn_log_level = virt->conn_log_level;\n        }\n        else {\n            /* apr_array_append actually creates a new array */\n            conf->conn_log_level = apr_array_append(p, conf->conn_log_level,\n                                                    virt->conn_log_level);\n        }\n    }\n\n    conf->merge_trailers = (virt->merge_trailers != AP_MERGE_TRAILERS_UNSET)\n                           ? virt->merge_trailers\n                           : base->merge_trailers;\n\n    conf->protocols = ((virt->protocols->nelts > 0) ?\n                       virt->protocols : base->protocols);\n    conf->protocols_honor_order = ((virt->protocols_honor_order < 0) ?\n                                       base->protocols_honor_order :\n                                       virt->protocols_honor_order);\n    conf->async_filter = ((virt->async_filter_set) ?\n                                       virt->async_filter :\n                                       base->async_filter);\n    conf->async_filter_set = base->async_filter_set || virt->async_filter_set;\n\n    return conf;\n}\n\n/* Add per-directory configuration entry (for <directory> section);\n * these are part of the core server config.\n */\n\nAP_CORE_DECLARE(void) ap_add_per_dir_conf(server_rec *s, void *dir_config)\n{\n    core_server_config *sconf = ap_get_core_module_config(s->module_config);\n    void **new_space = (void **)apr_array_push(sconf->sec_dir);\n\n    *new_space = dir_config;\n}\n\nAP_CORE_DECLARE(void) ap_add_per_url_conf(server_rec *s, void *url_config)\n{\n    core_server_config *sconf = ap_get_core_module_config(s->module_config);\n    void **new_space = (void **)apr_array_push(sconf->sec_url);\n\n    *new_space = url_config;\n}\n\nAP_CORE_DECLARE(void) ap_add_file_conf(apr_pool_t *p, core_dir_config *conf,\n                                       void *url_config)\n{\n    void **new_space;\n\n    if (!conf->sec_file)\n        conf->sec_file = apr_array_make(p, 2, sizeof(ap_conf_vector_t *));\n\n    new_space = (void **)apr_array_push(conf->sec_file);\n    *new_space = url_config;\n}\n\nAP_CORE_DECLARE(const char *) ap_add_if_conf(apr_pool_t *p,\n                                             core_dir_config *conf,\n                                             void *if_config)\n{\n    void **new_space;\n    core_dir_config *new = ap_get_module_config(if_config, &core_module);\n\n    if (!conf->sec_if) {\n        conf->sec_if = apr_array_make(p, 2, sizeof(ap_conf_vector_t *));\n    }\n    if (new->condition_ifelse & AP_CONDITION_ELSE) {\n        int have_if = 0;\n        if (conf->sec_if->nelts > 0) {\n            core_dir_config *last;\n            ap_conf_vector_t *lastelt = APR_ARRAY_IDX(conf->sec_if,\n                                                      conf->sec_if->nelts - 1,\n                                                      ap_conf_vector_t *);\n            last = ap_get_module_config(lastelt, &core_module);\n            if (last->condition_ifelse & AP_CONDITION_IF)\n                have_if = 1;\n        }\n        if (!have_if)\n            return \"<Else> or <ElseIf> section without previous <If> or \"\n                   \"<ElseIf> section in same scope\";\n    }\n\n    new_space = (void **)apr_array_push(conf->sec_if);\n    *new_space = if_config;\n    return NULL;\n}\n\n\n/* We need to do a stable sort, qsort isn't stable.  So to make it stable\n * we'll be maintaining the original index into the list, and using it\n * as the minor key during sorting.  The major key is the number of\n * components (where the root component is zero).\n */\nstruct reorder_sort_rec {\n    ap_conf_vector_t *elt;\n    int orig_index;\n};\n\nstatic int reorder_sorter(const void *va, const void *vb)\n{\n    const struct reorder_sort_rec *a = va;\n    const struct reorder_sort_rec *b = vb;\n    core_dir_config *core_a;\n    core_dir_config *core_b;\n\n    core_a = ap_get_core_module_config(a->elt);\n    core_b = ap_get_core_module_config(b->elt);\n\n    /* a regex always sorts after a non-regex\n     */\n    if (!core_a->r && core_b->r) {\n        return -1;\n    }\n    else if (core_a->r && !core_b->r) {\n        return 1;\n    }\n\n    /* we always sort next by the number of components\n     */\n    if (core_a->d_components < core_b->d_components) {\n        return -1;\n    }\n    else if (core_a->d_components > core_b->d_components) {\n        return 1;\n    }\n\n    /* They have the same number of components, we now have to compare\n     * the minor key to maintain the original order (from the config.)\n     */\n    return a->orig_index - b->orig_index;\n}\n\nvoid ap_core_reorder_directories(apr_pool_t *p, server_rec *s)\n{\n    core_server_config *sconf;\n    apr_array_header_t *sec_dir;\n    struct reorder_sort_rec *sortbin;\n    int nelts;\n    ap_conf_vector_t **elts;\n    int i;\n    apr_pool_t *tmp;\n\n    sconf = ap_get_core_module_config(s->module_config);\n    sec_dir = sconf->sec_dir;\n    nelts = sec_dir->nelts;\n    elts = (ap_conf_vector_t **)sec_dir->elts;\n\n    if (!nelts) {\n        /* simple case of already being sorted... */\n        /* We're not checking this condition to be fast... we're checking\n         * it to avoid trying to palloc zero bytes, which can trigger some\n         * memory debuggers to barf\n         */\n        return;\n    }\n\n    /* we have to allocate tmp space to do a stable sort */\n    apr_pool_create(&tmp, p);\n    sortbin = apr_palloc(tmp, sec_dir->nelts * sizeof(*sortbin));\n    for (i = 0; i < nelts; ++i) {\n        sortbin[i].orig_index = i;\n        sortbin[i].elt = elts[i];\n    }\n\n    qsort(sortbin, nelts, sizeof(*sortbin), reorder_sorter);\n\n    /* and now copy back to the original array */\n    for (i = 0; i < nelts; ++i) {\n        elts[i] = sortbin[i].elt;\n    }\n\n    apr_pool_destroy(tmp);\n}\n\n/*****************************************************************\n *\n * There are some elements of the core config structures in which\n * other modules have a legitimate interest (this is ugly, but necessary\n * to preserve NCSA back-compatibility).  So, we have a bunch of accessors\n * here...\n */\n\nAP_DECLARE(int) ap_allow_options(request_rec *r)\n{\n    core_dir_config *conf =\n      (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n\n    return conf->opts;\n}\n\nAP_DECLARE(int) ap_allow_overrides(request_rec *r)\n{\n    core_dir_config *conf;\n    conf = (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n\n    return conf->override;\n}\n\n/*\n * Optional function coming from mod_authn_core, used for\n * retrieving the type of autorization\n */\nstatic APR_OPTIONAL_FN_TYPE(authn_ap_auth_type) *authn_ap_auth_type;\n\nAP_DECLARE(const char *) ap_auth_type(request_rec *r)\n{\n    if (authn_ap_auth_type) {\n        return authn_ap_auth_type(r);\n    }\n    return NULL;\n}\n\n/*\n * Optional function coming from mod_authn_core, used for\n * retrieving the authorization realm\n */\nstatic APR_OPTIONAL_FN_TYPE(authn_ap_auth_name) *authn_ap_auth_name;\n\nAP_DECLARE(const char *) ap_auth_name(request_rec *r)\n{\n    if (authn_ap_auth_name) {\n        return authn_ap_auth_name(r);\n    }\n    return NULL;\n}\n\n/*\n * Optional function coming from mod_access_compat, used to determine how\n   access control interacts with authentication/authorization\n */\nstatic APR_OPTIONAL_FN_TYPE(access_compat_ap_satisfies) *access_compat_ap_satisfies;\n\nAP_DECLARE(int) ap_satisfies(request_rec *r)\n{\n    if (access_compat_ap_satisfies) {\n        return access_compat_ap_satisfies(r);\n    }\n    return SATISFY_NOSPEC;\n}\n\nAP_DECLARE(const char *) ap_document_root(request_rec *r) /* Don't use this! */\n{\n    core_server_config *sconf;\n    core_request_config *rconf = ap_get_core_module_config(r->request_config);\n    if (rconf->document_root)\n        return rconf->document_root;\n    sconf = ap_get_core_module_config(r->server->module_config);\n    return sconf->ap_document_root;\n}\n\nAP_DECLARE(const char *) ap_context_prefix(request_rec *r)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    if (conf->context_prefix)\n        return conf->context_prefix;\n    else\n        return \"\";\n}\n\nAP_DECLARE(const char *) ap_context_document_root(request_rec *r)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    if (conf->context_document_root)\n        return conf->context_document_root;\n    else\n        return ap_document_root(r);\n}\n\nAP_DECLARE(void) ap_set_document_root(request_rec *r, const char *document_root)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    conf->document_root = document_root;\n}\n\nAP_DECLARE(void) ap_set_context_info(request_rec *r, const char *context_prefix,\n                                     const char *context_document_root)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    if (context_prefix)\n        conf->context_prefix = context_prefix;\n    if (context_document_root)\n        conf->context_document_root = context_document_root;\n}\n\n/* Should probably just get rid of this... the only code that cares is\n * part of the core anyway (and in fact, it isn't publicised to other\n * modules).\n */\n\nchar *ap_response_code_string(request_rec *r, int error_index)\n{\n    core_dir_config *dirconf;\n    core_request_config *reqconf = ap_get_core_module_config(r->request_config);\n    const char *err;\n    const char *response;\n    ap_expr_info_t *expr;\n\n    /* check for string registered via ap_custom_response() first */\n    if (reqconf->response_code_strings != NULL\n            && reqconf->response_code_strings[error_index] != NULL) {\n        return reqconf->response_code_strings[error_index];\n    }\n\n    /* check for string specified via ErrorDocument */\n    dirconf = ap_get_core_module_config(r->per_dir_config);\n\n    if (!dirconf->response_code_exprs) {\n        return NULL;\n    }\n\n    expr = apr_hash_get(dirconf->response_code_exprs, &error_index,\n            sizeof(error_index));\n    if (!expr) {\n        return NULL;\n    }\n\n    /* special token to indicate revert back to default */\n    if ((char *) expr == &errordocument_default) {\n        return NULL;\n    }\n\n    err = NULL;\n    response = ap_expr_str_exec(r, expr, &err);\n    if (err) {\n        ap_log_rerror(\n                APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02841) \"core: ErrorDocument: can't \"\n                \"evaluate require expression: %s\", err);\n        return NULL;\n    }\n\n    /* alas, duplication required as we return not-const */\n    return apr_pstrdup(r->pool, response);\n}\n\n\n/* Code from Harald Hanche-Olsen <hanche@imf.unit.no> */\nstatic APR_INLINE int do_double_reverse (int double_reverse,\n                                         const char *remote_host,\n                                         apr_sockaddr_t *client_addr,\n                                         apr_pool_t *pool)\n{\n    apr_sockaddr_t *sa;\n    apr_status_t rv;\n\n    if (double_reverse) {\n        /* already done */\n        return double_reverse;\n    }\n\n    if (remote_host == NULL || remote_host[0] == '\\0') {\n        /* single reverse failed, so don't bother */\n        return -1;\n    }\n\n    rv = apr_sockaddr_info_get(&sa, remote_host, APR_UNSPEC, 0, 0, pool);\n    if (rv == APR_SUCCESS) {\n        while (sa) {\n            if (apr_sockaddr_equal(sa, client_addr)) {\n                return 1;\n            }\n\n            sa = sa->next;\n        }\n    }\n\n    return -1;\n}\n\nAP_DECLARE(const char *) ap_get_remote_host(conn_rec *conn, void *dir_config,\n                                            int type, int *str_is_ip)\n{\n    int hostname_lookups;\n    int ignored_str_is_ip;\n\n    if (!str_is_ip) { /* caller doesn't want to know */\n        str_is_ip = &ignored_str_is_ip;\n    }\n    *str_is_ip = 0;\n\n    /* If we haven't checked the host name, and we want to */\n    if (dir_config) {\n        hostname_lookups = ((core_dir_config *)ap_get_core_module_config(dir_config))\n                           ->hostname_lookups;\n\n        if (hostname_lookups == HOSTNAME_LOOKUP_UNSET) {\n            hostname_lookups = HOSTNAME_LOOKUP_OFF;\n        }\n    }\n    else {\n        /* the default */\n        hostname_lookups = HOSTNAME_LOOKUP_OFF;\n    }\n\n    if (type != REMOTE_NOLOOKUP\n        && conn->remote_host == NULL\n        && (type == REMOTE_DOUBLE_REV\n        || hostname_lookups != HOSTNAME_LOOKUP_OFF)) {\n\n        if (apr_getnameinfo(&conn->remote_host, conn->client_addr, 0)\n            == APR_SUCCESS) {\n            ap_str_tolower(conn->remote_host);\n\n            if (hostname_lookups == HOSTNAME_LOOKUP_DOUBLE) {\n                conn->double_reverse = do_double_reverse(conn->double_reverse,\n                                                         conn->remote_host,\n                                                         conn->client_addr,\n                                                         conn->pool);\n                if (conn->double_reverse != 1) {\n                    conn->remote_host = NULL;\n                }\n            }\n        }\n\n        /* if failed, set it to the NULL string to indicate error */\n        if (conn->remote_host == NULL) {\n            conn->remote_host = \"\";\n        }\n    }\n\n    if (type == REMOTE_DOUBLE_REV) {\n        conn->double_reverse = do_double_reverse(conn->double_reverse,\n                                                 conn->remote_host,\n                                                 conn->client_addr, conn->pool);\n        if (conn->double_reverse == -1) {\n            return NULL;\n        }\n    }\n\n    /*\n     * Return the desired information; either the remote DNS name, if found,\n     * or either NULL (if the hostname was requested) or the IP address\n     * (if any identifier was requested).\n     */\n    if (conn->remote_host != NULL && conn->remote_host[0] != '\\0') {\n        return conn->remote_host;\n    }\n    else {\n        if (type == REMOTE_HOST || type == REMOTE_DOUBLE_REV) {\n            return NULL;\n        }\n        else {\n            *str_is_ip = 1;\n            return conn->client_ip;\n        }\n    }\n}\n\nAP_DECLARE(const char *) ap_get_useragent_host(request_rec *r,\n                                               int type, int *str_is_ip)\n{\n    conn_rec *conn = r->connection;\n    int hostname_lookups;\n    int ignored_str_is_ip;\n\n    /* Guard here when examining the host before the read_request hook\n     * has populated an r->useragent_addr\n     */\n    if (!r->useragent_addr || (r->useragent_addr == conn->client_addr)) {\n        return ap_get_remote_host(conn, r->per_dir_config, type, str_is_ip);\n    }\n\n    if (!str_is_ip) { /* caller doesn't want to know */\n        str_is_ip = &ignored_str_is_ip;\n    }\n    *str_is_ip = 0;\n\n    hostname_lookups = ((core_dir_config *)\n                        ap_get_core_module_config(r->per_dir_config))\n                            ->hostname_lookups;\n    if (hostname_lookups == HOSTNAME_LOOKUP_UNSET) {\n        hostname_lookups = HOSTNAME_LOOKUP_OFF;\n    }\n\n    if (type != REMOTE_NOLOOKUP\n        && r->useragent_host == NULL\n        && (type == REMOTE_DOUBLE_REV\n        || hostname_lookups != HOSTNAME_LOOKUP_OFF)) {\n\n        if (apr_getnameinfo(&r->useragent_host, r->useragent_addr, 0)\n            == APR_SUCCESS) {\n            ap_str_tolower(r->useragent_host);\n\n            if (hostname_lookups == HOSTNAME_LOOKUP_DOUBLE) {\n                r->double_reverse = do_double_reverse(r->double_reverse,\n                                                      r->useragent_host,\n                                                      r->useragent_addr,\n                                                      r->pool);\n                if (r->double_reverse != 1) {\n                    r->useragent_host = NULL;\n                }\n            }\n        }\n\n        /* if failed, set it to the NULL string to indicate error */\n        if (r->useragent_host == NULL) {\n            r->useragent_host = \"\";\n        }\n    }\n\n    if (type == REMOTE_DOUBLE_REV) {\n        r->double_reverse = do_double_reverse(r->double_reverse,\n                                              r->useragent_host,\n                                              r->useragent_addr, r->pool);\n        if (r->double_reverse == -1) {\n            return NULL;\n        }\n    }\n\n    /*\n     * Return the desired information; either the remote DNS name, if found,\n     * or either NULL (if the hostname was requested) or the IP address\n     * (if any identifier was requested).\n     */\n    if (r->useragent_host != NULL && r->useragent_host[0] != '\\0') {\n        return r->useragent_host;\n    }\n    else {\n        if (type == REMOTE_HOST || type == REMOTE_DOUBLE_REV) {\n            return NULL;\n        }\n        else {\n            *str_is_ip = 1;\n            return r->useragent_ip;\n        }\n    }\n}\n\n/*\n * Optional function coming from mod_ident, used for looking up ident user\n */\nstatic APR_OPTIONAL_FN_TYPE(ap_ident_lookup) *ident_lookup;\n\nAP_DECLARE(const char *) ap_get_remote_logname(request_rec *r)\n{\n    if (r->connection->remote_logname != NULL) {\n        return r->connection->remote_logname;\n    }\n\n    if (ident_lookup) {\n        return ident_lookup(r);\n    }\n\n    return NULL;\n}\n\n/* There are two options regarding what the \"name\" of a server is.  The\n * \"canonical\" name as defined by ServerName and Port, or the \"client's\n * name\" as supplied by a possible Host: header or full URI.\n *\n * The DNS option to UseCanonicalName causes this routine to do a\n * reverse lookup on the local IP address of the connection and use\n * that for the ServerName. This makes its value more reliable while\n * at the same time allowing Demon's magic virtual hosting to work.\n * The assumption is that DNS lookups are sufficiently quick...\n * -- fanf 1998-10-03\n */\nAP_DECLARE(const char *) ap_get_server_name(request_rec *r)\n{\n    conn_rec *conn = r->connection;\n    core_dir_config *d;\n    const char *retval;\n\n    d = (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n\n    switch (d->use_canonical_name) {\n        case USE_CANONICAL_NAME_ON:\n            retval = r->server->server_hostname;\n            break;\n        case USE_CANONICAL_NAME_DNS:\n            if (conn->local_host == NULL) {\n                if (apr_getnameinfo(&conn->local_host,\n                                conn->local_addr, 0) != APR_SUCCESS)\n                    conn->local_host = apr_pstrdup(conn->pool,\n                                               r->server->server_hostname);\n                else {\n                    ap_str_tolower(conn->local_host);\n                }\n            }\n            retval = conn->local_host;\n            break;\n        case USE_CANONICAL_NAME_OFF:\n        case USE_CANONICAL_NAME_UNSET:\n            retval = r->hostname ? r->hostname : r->server->server_hostname;\n            break;\n        default:\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00109)\n                         \"ap_get_server_name: Invalid UCN Option somehow\");\n            retval = \"localhost\";\n            break;\n    }\n    return retval;\n}\n\n/*\n * Get the current server name from the request for the purposes\n * of using in a URL.  If the server name is an IPv6 literal\n * address, it will be returned in URL format (e.g., \"[fe80::1]\").\n */\nAP_DECLARE(const char *) ap_get_server_name_for_url(request_rec *r)\n{\n    const char *plain_server_name = ap_get_server_name(r);\n\n#if APR_HAVE_IPV6\n    if (ap_strchr_c(plain_server_name, ':')) { /* IPv6 literal? */\n        return apr_pstrcat(r->pool, \"[\", plain_server_name, \"]\", NULL);\n    }\n#endif\n    return plain_server_name;\n}\n\nAP_DECLARE(apr_port_t) ap_get_server_port(const request_rec *r)\n{\n    apr_port_t port;\n    core_dir_config *d =\n      (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n\n    switch (d->use_canonical_name) {\n        case USE_CANONICAL_NAME_OFF:\n        case USE_CANONICAL_NAME_DNS:\n        case USE_CANONICAL_NAME_UNSET:\n            if (d->use_canonical_phys_port == USE_CANONICAL_PHYS_PORT_ON)\n                port = r->parsed_uri.port_str ? r->parsed_uri.port :\n                       r->connection->local_addr->port ? r->connection->local_addr->port :\n                       r->server->port ? r->server->port :\n                       ap_default_port(r);\n            else /* USE_CANONICAL_PHYS_PORT_OFF or USE_CANONICAL_PHYS_PORT_UNSET */\n                port = r->parsed_uri.port_str ? r->parsed_uri.port :\n                       r->server->port ? r->server->port :\n                       ap_default_port(r);\n            break;\n        case USE_CANONICAL_NAME_ON:\n            /* With UseCanonicalName on (and in all versions prior to 1.3)\n             * Apache will use the hostname and port specified in the\n             * ServerName directive to construct a canonical name for the\n             * server. (If no port was specified in the ServerName\n             * directive, Apache uses the port supplied by the client if\n             * any is supplied, and finally the default port for the protocol\n             * used.\n             */\n            if (d->use_canonical_phys_port == USE_CANONICAL_PHYS_PORT_ON)\n                port = r->server->port ? r->server->port :\n                       r->connection->local_addr->port ? r->connection->local_addr->port :\n                       ap_default_port(r);\n            else /* USE_CANONICAL_PHYS_PORT_OFF or USE_CANONICAL_PHYS_PORT_UNSET */\n                port = r->server->port ? r->server->port :\n                       ap_default_port(r);\n            break;\n        default:\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00110)\n                         \"ap_get_server_port: Invalid UCN Option somehow\");\n            port = ap_default_port(r);\n            break;\n    }\n\n    return port;\n}\n\nAP_DECLARE(char *) ap_construct_url(apr_pool_t *p, const char *uri,\n                                    request_rec *r)\n{\n    unsigned port = ap_get_server_port(r);\n    const char *host = ap_get_server_name_for_url(r);\n\n    if (ap_is_default_port(port, r)) {\n        return apr_pstrcat(p, ap_http_scheme(r), \"://\", host, uri, NULL);\n    }\n\n    return apr_psprintf(p, \"%s://%s:%u%s\", ap_http_scheme(r), host, port, uri);\n}\n\nAP_DECLARE(apr_off_t) ap_get_limit_req_body(const request_rec *r)\n{\n    core_dir_config *d =\n      (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n\n    if (d->limit_req_body == AP_LIMIT_REQ_BODY_UNSET) {\n        return AP_DEFAULT_LIMIT_REQ_BODY;\n    }\n\n    return d->limit_req_body;\n}\n\n\n/*****************************************************************\n *\n * Commands... this module handles almost all of the NCSA httpd.conf\n * commands, but most of the old srm.conf is in the modules.\n */\n\n\n/* returns a parent if it matches the given directive */\nstatic const ap_directive_t * find_parent(const ap_directive_t *dirp,\n                                          const char *what)\n{\n    while (dirp->parent != NULL) {\n        dirp = dirp->parent;\n\n        /* ### it would be nice to have atom-ized directives */\n        if (ap_cstr_casecmp(dirp->directive, what) == 0)\n            return dirp;\n    }\n\n    return NULL;\n}\n\nAP_DECLARE(const char *) ap_check_cmd_context(cmd_parms *cmd,\n                                              unsigned forbidden)\n{\n    const char *gt = (cmd->cmd->name[0] == '<'\n                      && cmd->cmd->name[strlen(cmd->cmd->name)-1] != '>')\n                         ? \">\" : \"\";\n    const ap_directive_t *found;\n\n    if ((forbidden & NOT_IN_VIRTUALHOST) && cmd->server->is_virtual) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,\n                           \" cannot occur within <VirtualHost> section\", NULL);\n    }\n\n    if ((forbidden & (NOT_IN_LIMIT | NOT_IN_DIR_LOC_FILE))\n        && cmd->limited != -1) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,\n                           \" cannot occur within <Limit> or <LimitExcept> \"\n                           \"section\", NULL);\n    }\n\n    if ((forbidden & NOT_IN_HTACCESS) && (cmd->pool == cmd->temp_pool)) {\n         return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,\n                            \" cannot occur within htaccess files\", NULL);\n    }\n\n    if ((forbidden & NOT_IN_DIR_LOC_FILE) == NOT_IN_DIR_LOC_FILE) {\n        if (cmd->path != NULL) {\n            return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,\n                            \" cannot occur within <Directory/Location/Files> \"\n                            \"section\", NULL);\n        }\n        if (cmd->cmd->req_override & EXEC_ON_READ) {\n            /* EXEC_ON_READ must be NOT_IN_DIR_LOC_FILE, if not, it will\n             * (deliberately) segfault below in the individual tests...\n             */\n            return NULL;\n        }\n    }\n\n    if (((forbidden & NOT_IN_DIRECTORY)\n         && ((found = find_parent(cmd->directive, \"<Directory\"))\n             || (found = find_parent(cmd->directive, \"<DirectoryMatch\"))))\n        || ((forbidden & NOT_IN_LOCATION)\n            && ((found = find_parent(cmd->directive, \"<Location\"))\n                || (found = find_parent(cmd->directive, \"<LocationMatch\"))))\n        || ((forbidden & NOT_IN_FILES)\n            && ((found = find_parent(cmd->directive, \"<Files\"))\n                || (found = find_parent(cmd->directive, \"<FilesMatch\"))\n                || (found = find_parent(cmd->directive, \"<If\"))\n                || (found = find_parent(cmd->directive, \"<ElseIf\"))\n                || (found = find_parent(cmd->directive, \"<Else\"))))\n        || ((forbidden & NOT_IN_PROXY)\n            && ((found = find_parent(cmd->directive, \"<Proxy\"))\n                || (found = find_parent(cmd->directive, \"<ProxyMatch\"))))) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,\n                           \" cannot occur within \", found->directive,\n                           \"> section\", NULL);\n    }\n\n    return NULL;\n}\n\nstatic const char *set_access_name(cmd_parms *cmd, void *dummy,\n                                   const char *arg)\n{\n    void *sconf = cmd->server->module_config;\n    core_server_config *conf = ap_get_core_module_config(sconf);\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    if (err != NULL) {\n        return err;\n    }\n\n    conf->access_name = apr_pstrdup(cmd->pool, arg);\n    return NULL;\n}\n\nAP_DECLARE(const char *) ap_resolve_env(apr_pool_t *p, const char * word)\n{\n# define SMALL_EXPANSION 5\n    struct sll {\n        struct sll *next;\n        const char *string;\n        apr_size_t len;\n    } *result, *current, sresult[SMALL_EXPANSION];\n    char *res_buf, *cp;\n    const char *s, *e, *ep;\n    unsigned spc;\n    apr_size_t outlen;\n\n    s = ap_strchr_c(word, '$');\n    if (!s) {\n        return word;\n    }\n\n    /* well, actually something to do */\n    ep = word + strlen(word);\n    spc = 0;\n    result = current = &(sresult[spc++]);\n    current->next = NULL;\n    current->string = word;\n    current->len = s - word;\n    outlen = current->len;\n\n    do {\n        /* prepare next entry */\n        if (current->len) {\n            current->next = (spc < SMALL_EXPANSION)\n                            ? &(sresult[spc++])\n                            : (struct sll *)apr_palloc(p,\n                                                       sizeof(*current->next));\n            current = current->next;\n            current->next = NULL;\n            current->len = 0;\n        }\n\n        if (*s == '$') {\n            if (s[1] == '{' && (e = ap_strchr_c(s+2, '}'))) {\n                char *name = apr_pstrmemdup(p, s+2, e-s-2);\n                word = NULL;\n                if (server_config_defined_vars)\n                    word = apr_table_get(server_config_defined_vars, name);\n                if (!word)\n                    word = getenv(name);\n                if (word) {\n                    current->string = word;\n                    current->len = strlen(word);\n                    outlen += current->len;\n                }\n                else {\n                    if (ap_strchr(name, ':') == 0)\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL, APLOGNO(00111)\n                                     \"Config variable ${%s} is not defined\",\n                                     name);\n                    current->string = s;\n                    current->len = e - s + 1;\n                    outlen += current->len;\n                }\n                s = e + 1;\n            }\n            else {\n                current->string = s++;\n                current->len = 1;\n                ++outlen;\n            }\n        }\n        else {\n            word = s;\n            s = ap_strchr_c(s, '$');\n            current->string = word;\n            current->len = s ? s - word : ep - word;\n            outlen += current->len;\n        }\n    } while (s && *s);\n\n    /* assemble result */\n    res_buf = cp = apr_palloc(p, outlen + 1);\n    do {\n        if (result->len) {\n            memcpy(cp, result->string, result->len);\n            cp += result->len;\n        }\n        result = result->next;\n    } while (result);\n    res_buf[outlen] = '\\0';\n\n    return res_buf;\n}\n\nstatic int reset_config_defines(void *dummy)\n{\n    ap_server_config_defines = saved_server_config_defines;\n    saved_server_config_defines = NULL;\n    server_config_defined_vars = NULL;\n    return OK;\n}\n\n/*\n * Make sure we can revert the effects of Define/UnDefine when restarting.\n * This function must be called once per loading of the config, before\n * ap_server_config_defines is changed. This may be during reading of the\n * config, which is even before the pre_config hook is run (due to\n * EXEC_ON_READ for Define/UnDefine).\n */\nstatic void init_config_defines(apr_pool_t *pconf)\n{\n    saved_server_config_defines = ap_server_config_defines;\n    /* Use apr_array_copy instead of apr_array_copy_hdr because it does not\n     * protect from the way unset_define removes entries.\n     */\n    ap_server_config_defines = apr_array_copy(pconf, ap_server_config_defines);\n}\n\nstatic const char *set_define(cmd_parms *cmd, void *dummy,\n                              const char *name, const char *value)\n{\n    if (cmd->parent && ap_cstr_casecmp(cmd->parent->directive, \"<VirtualHost\")) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name, \" is not valid in \",\n                                      cmd->parent->directive, \" context\", NULL);\n    }\n\n    if (ap_strchr_c(name, ':') != NULL) {\n        return \"Variable name must not contain ':'\";\n    }\n\n    if (!saved_server_config_defines) {\n        init_config_defines(cmd->pool);\n    }\n    if (!ap_exists_config_define(name)) {\n        *(const char **)apr_array_push(ap_server_config_defines) = name;\n    }\n    if (value) {\n        if (!server_config_defined_vars) {\n            server_config_defined_vars = apr_table_make(cmd->pool, 5);\n        }\n        apr_table_setn(server_config_defined_vars, name, value);\n    }\n\n    return NULL;\n}\n\nstatic const char *unset_define(cmd_parms *cmd, void *dummy,\n                                const char *name)\n{\n    int i;\n    const char **defines;\n    if (cmd->parent && ap_cstr_casecmp(cmd->parent->directive, \"<VirtualHost\")) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name, \" is not valid in \",\n                                      cmd->parent->directive, \" context\", NULL);\n    }\n\n    if (ap_strchr_c(name, ':') != NULL) {\n        return \"Variable name must not contain ':'\";\n    }\n\n    if (!saved_server_config_defines) {\n        init_config_defines(cmd->pool);\n    }\n\n    defines = (const char **)ap_server_config_defines->elts;\n    for (i = 0; i < ap_server_config_defines->nelts; i++) {\n        if (strcmp(defines[i], name) == 0) {\n            defines[i] = *(const char **)apr_array_pop(ap_server_config_defines);\n            break;\n        }\n    }\n\n    if (server_config_defined_vars) {\n        apr_table_unset(server_config_defined_vars, name);\n    }\n\n    return NULL;\n}\n\nstatic const char *generate_message(cmd_parms *cmd, void *dummy,\n                                    const char *arg)\n{\n    /* cast with 64-bit warning avoidance */\n    int level = (cmd->info==(void*)APLOG_ERR)? APLOG_ERR: APLOG_WARNING;\n    char * msg;\n\n    /* get position information from wherever we can? */\n    ap_configfile_t * cf = cmd->config_file;\n    ap_directive_t const * ed1 = cmd->directive;\n    ap_directive_t const * ed2 = cmd->err_directive;\n\n    /* expect an argument */\n    if (!arg || !*arg) {\n        return \"The Error or Warning directive was used with no message.\";\n    }\n\n    /* set message, strip off quotes if necessary */\n    msg = (char *)arg;\n    if (*arg == '\"' || *arg == '\\'') {\n        apr_size_t len = strlen(arg);\n        char last = *(arg + len - 1);\n\n        if (*arg == last) {\n            msg = apr_pstrndup(cmd->pool, arg + 1, len - 2);\n        }\n    }\n\n    /* generate error or warning with a configuration file position.\n     * the log is displayed on the terminal as no log file is opened yet.\n     */\n    ap_log_error(APLOG_MARK, level, 0, NULL,\n                 \"%s on line %d of %s\", msg,\n                 cf? cf->line_number:\n                   ed1? ed1->line_num:\n                     ed2? ed2->line_num: -1,\n                 cf? cf->name:\n                   ed1? ed1->filename:\n                     ed2? ed2->filename: \"<UNKNOWN>\");\n\n    /* message displayed above, return will stop configuration processing */\n    return level==APLOG_ERR?\n        \"Configuration processing stopped by Error directive\": NULL;\n}\n\n#ifdef GPROF\nstatic const char *set_gprof_dir(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    void *sconf = cmd->server->module_config;\n    core_server_config *conf = ap_get_core_module_config(sconf);\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    if (err != NULL) {\n        return err;\n    }\n\n    conf->gprof_dir = arg;\n    return NULL;\n}\n#endif /*GPROF*/\n\nstatic const char *set_add_default_charset(cmd_parms *cmd,\n                                           void *d_, const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (!ap_cstr_casecmp(arg, \"Off\")) {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_OFF;\n    }\n    else if (!ap_cstr_casecmp(arg, \"On\")) {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_ON;\n       d->add_default_charset_name = DEFAULT_ADD_DEFAULT_CHARSET_NAME;\n    }\n    else {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_ON;\n       d->add_default_charset_name = arg;\n    }\n\n    return NULL;\n}\n\nstatic const char *set_document_root(cmd_parms *cmd, void *dummy,\n                                     const char *arg)\n{\n    void *sconf = cmd->server->module_config;\n    core_server_config *conf = ap_get_core_module_config(sconf);\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    if (err != NULL) {\n        return err;\n    }\n\n    /* When ap_document_root_check is false; skip all the stuff below */\n    if (!ap_document_root_check) {\n       conf->ap_document_root = arg;\n       return NULL;\n    }\n\n    /* Make it absolute, relative to ServerRoot */\n    arg = ap_server_root_relative(cmd->pool, arg);\n    if (arg == NULL) {\n        return \"DocumentRoot must be a directory\";\n    }\n\n    if (apr_filepath_merge((char**)&conf->ap_document_root, NULL, arg,\n                           APR_FILEPATH_TRUENAME, cmd->pool) != APR_SUCCESS\n        || !ap_is_directory(cmd->temp_pool, arg)) {\n        if (cmd->server->is_virtual) {\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0,\n                          cmd->pool, APLOGNO(00112)\n                          \"Warning: DocumentRoot [%s] does not exist\",\n                          arg);\n            conf->ap_document_root = arg;\n        }\n        else {\n            return apr_psprintf(cmd->pool, \n                                \"DocumentRoot '%s' is not a directory, or is not readable\",\n                                arg);\n        }\n    }\n    return NULL;\n}\n\nAP_DECLARE(void) ap_custom_response(request_rec *r, int status,\n                                    const char *string)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    int idx;\n\n    if (conf->response_code_strings == NULL) {\n        conf->response_code_strings =\n            apr_pcalloc(r->pool,\n                        sizeof(*conf->response_code_strings) * RESPONSE_CODES);\n    }\n\n    idx = ap_index_of_response(status);\n\n    conf->response_code_strings[idx] =\n       ((ap_is_url(string) || (*string == '/')) && (*string != '\"')) ?\n       apr_pstrdup(r->pool, string) : apr_pstrcat(r->pool, \"\\\"\", string, NULL);\n}\n\nstatic const char *set_error_document(cmd_parms *cmd, void *conf_,\n                                      const char *errno_str, const char *msg)\n{\n    core_dir_config *conf = conf_;\n    int error_number, index_number, idx500;\n    enum { MSG, LOCAL_PATH, REMOTE_PATH } what = MSG;\n\n    /* 1st parameter should be a 3 digit number, which we recognize;\n     * convert it into an array index\n     */\n    error_number = atoi(errno_str);\n    idx500 = ap_index_of_response(HTTP_INTERNAL_SERVER_ERROR);\n\n    if (error_number == HTTP_INTERNAL_SERVER_ERROR) {\n        index_number = idx500;\n    }\n    else if ((index_number = ap_index_of_response(error_number)) == idx500) {\n        return apr_pstrcat(cmd->pool, \"Unsupported HTTP response code \",\n                           errno_str, NULL);\n    }\n\n    /* Heuristic to determine second argument. */\n    if (ap_strchr_c(msg,' '))\n        what = MSG;\n    else if (msg[0] == '/')\n        what = LOCAL_PATH;\n    else if (ap_is_url(msg))\n        what = REMOTE_PATH;\n    else\n        what = MSG;\n\n    /* The entry should be ignored if it is a full URL for a 401 error */\n\n    if (error_number == 401 && what == REMOTE_PATH) {\n        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, cmd->server, APLOGNO(00113)\n                     \"%s:%d cannot use a full URL in a 401 ErrorDocument \"\n                     \"directive --- ignoring!\", cmd->directive->filename, cmd->directive->line_num);\n    }\n    else { /* Store it... */\n        if (conf->response_code_exprs == NULL) {\n            conf->response_code_exprs = apr_hash_make(cmd->pool);\n        }\n\n        if (ap_cstr_casecmp(msg, \"default\") == 0) {\n            /* special case: ErrorDocument 404 default restores the\n             * canned server error response\n             */\n            apr_hash_set(conf->response_code_exprs,\n                    apr_pmemdup(cmd->pool, &index_number, sizeof(index_number)),\n                    sizeof(index_number), &errordocument_default);\n        }\n        else {\n            ap_expr_info_t *expr;\n            const char *expr_err = NULL;\n\n            /* hack. Prefix a \" if it is a msg; as that is what\n             * http_protocol.c relies on to distinguish between\n             * a msg and a (local) path.\n             */\n            const char *response =\n                    (what == MSG) ? apr_pstrcat(cmd->pool, \"\\\"\", msg, NULL) :\n                            apr_pstrdup(cmd->pool, msg);\n\n            expr = ap_expr_parse_cmd(cmd, response, AP_EXPR_FLAG_STRING_RESULT,\n                    &expr_err, NULL);\n\n            if (expr_err) {\n                return apr_pstrcat(cmd->temp_pool,\n                                   \"Cannot parse expression in ErrorDocument: \",\n                                   expr_err, NULL);\n            }\n\n            apr_hash_set(conf->response_code_exprs,\n                    apr_pmemdup(cmd->pool, &index_number, sizeof(index_number)),\n                    sizeof(index_number), expr);\n\n        }\n    }\n\n    return NULL;\n}\n\nstatic const char *set_allow_opts(cmd_parms *cmd, allow_options_t *opts,\n                                  const char *l)\n{\n    allow_options_t opt;\n    int first = 1;\n\n    char *w, *p = (char *) l;\n    char *tok_state;\n\n    while ((w = apr_strtok(p, \",\", &tok_state)) != NULL) {\n\n        if (first) {\n            p = NULL;\n            *opts = OPT_NONE;\n            first = 0;\n        }\n\n        if (!ap_cstr_casecmp(w, \"Indexes\")) {\n            opt = OPT_INDEXES;\n        }\n        else if (!ap_cstr_casecmp(w, \"Includes\")) {\n            /* If Includes is permitted, both Includes and\n             * IncludesNOEXEC may be changed. */\n            opt = (OPT_INCLUDES | OPT_INC_WITH_EXEC);\n        }\n        else if (!ap_cstr_casecmp(w, \"IncludesNOEXEC\")) {\n            opt = OPT_INCLUDES;\n        }\n        else if (!ap_cstr_casecmp(w, \"FollowSymLinks\")) {\n            opt = OPT_SYM_LINKS;\n        }\n        else if (!ap_cstr_casecmp(w, \"SymLinksIfOwnerMatch\")) {\n            opt = OPT_SYM_OWNER;\n        }\n        else if (!ap_cstr_casecmp(w, \"ExecCGI\")) {\n            opt = OPT_EXECCGI;\n        }\n        else if (!ap_cstr_casecmp(w, \"MultiViews\")) {\n            opt = OPT_MULTI;\n        }\n        else if (!ap_cstr_casecmp(w, \"RunScripts\")) { /* AI backcompat. Yuck */\n            opt = OPT_MULTI|OPT_EXECCGI;\n        }\n        else if (!ap_cstr_casecmp(w, \"None\")) {\n            opt = OPT_NONE;\n        }\n        else if (!ap_cstr_casecmp(w, \"All\")) {\n            opt = OPT_ALL;\n        }\n        else {\n            return apr_pstrcat(cmd->pool, \"Illegal option \", w, NULL);\n        }\n\n        *opts |= opt;\n    }\n\n    (*opts) &= (~OPT_UNSET);\n\n    return NULL;\n}\n\nstatic const char *set_override(cmd_parms *cmd, void *d_, const char *l)\n{\n    core_dir_config *d = d_;\n    char *w;\n    char *k, *v;\n    const char *err;\n\n    /* Throw a warning if we're in <Location> or <Files> */\n    if (ap_check_cmd_context(cmd, NOT_IN_LOCATION | NOT_IN_FILES)) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00114)\n                     \"Useless use of AllowOverride in line %d of %s.\",\n                     cmd->directive->line_num, cmd->directive->filename);\n    }\n    if ((err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS)) != NULL)\n        return err;\n\n    d->override = OR_NONE;\n    while (l[0]) {\n        w = ap_getword_conf(cmd->temp_pool, &l);\n\n        k = w;\n        v = strchr(k, '=');\n        if (v) {\n                *v++ = '\\0';\n        }\n\n        if (!ap_cstr_casecmp(w, \"Limit\")) {\n            d->override |= OR_LIMIT;\n        }\n        else if (!ap_cstr_casecmp(k, \"Options\")) {\n            d->override |= OR_OPTIONS;\n            if (v)\n                set_allow_opts(cmd, &(d->override_opts), v);\n            else\n                d->override_opts = OPT_ALL;\n        }\n        else if (!ap_cstr_casecmp(w, \"FileInfo\")) {\n            d->override |= OR_FILEINFO;\n        }\n        else if (!ap_cstr_casecmp(w, \"AuthConfig\")) {\n            d->override |= OR_AUTHCFG;\n        }\n        else if (!ap_cstr_casecmp(w, \"Indexes\")) {\n            d->override |= OR_INDEXES;\n        }\n        else if (!ap_cstr_casecmp(w, \"Nonfatal\")) {\n            if (!ap_cstr_casecmp(v, \"Override\")) {\n                d->override |= NONFATAL_OVERRIDE;\n            }\n            else if (!ap_cstr_casecmp(v, \"Unknown\")) {\n                d->override |= NONFATAL_UNKNOWN;\n            }\n            else if (!ap_cstr_casecmp(v, \"All\")) {\n                d->override |= NONFATAL_ALL;\n            }\n        }\n        else if (!ap_cstr_casecmp(w, \"None\")) {\n            d->override = OR_NONE;\n        }\n        else if (!ap_cstr_casecmp(w, \"All\")) {\n            d->override = OR_ALL;\n        }\n        else {\n            return apr_pstrcat(cmd->pool, \"Illegal override option \", w, NULL);\n        }\n\n        d->override &= ~OR_UNSET;\n    }\n\n    return NULL;\n}\n\nstatic const char *set_cgi_pass_auth(cmd_parms *cmd, void *d_, int flag)\n{\n    core_dir_config *d = d_;\n\n    d->cgi_pass_auth = flag ? AP_CGI_PASS_AUTH_ON : AP_CGI_PASS_AUTH_OFF;\n\n    return NULL;\n}\n\nstatic const char *set_cgi_var(cmd_parms *cmd, void *d_,\n                               const char *var, const char *rule_)\n{\n    core_dir_config *d = d_;\n    char *rule = apr_pstrdup(cmd->pool, rule_);\n\n    ap_str_tolower(rule);\n\n    if (!strcmp(var, \"REQUEST_URI\")) {\n        if (strcmp(rule, \"current-uri\") && strcmp(rule, \"original-uri\")) {\n            return \"Valid rules for REQUEST_URI are 'current-uri' and 'original-uri'\";\n        }\n    }\n    else {\n        return apr_pstrcat(cmd->pool, \"Unrecognized CGI variable: \\\"\",\n                           var, \"\\\"\", NULL);\n    }\n\n    if (!d->cgi_var_rules) {\n        d->cgi_var_rules = apr_hash_make(cmd->pool);\n    }\n    apr_hash_set(d->cgi_var_rules, var, APR_HASH_KEY_STRING, rule);\n    return NULL;\n}\n\nstatic const char *set_qualify_redirect_url(cmd_parms *cmd, void *d_, int flag)\n{\n    core_dir_config *d = d_;\n\n    d->qualify_redirect_url = flag ? AP_CORE_CONFIG_ON : AP_CORE_CONFIG_OFF;\n\n    return NULL;\n}\n\nstatic const char *set_override_list(cmd_parms *cmd, void *d_, int argc, char *const argv[])\n{\n    core_dir_config *d = d_;\n    int i;\n    const char *err;\n\n    /* Throw a warning if we're in <Location> or <Files> */\n    if (ap_check_cmd_context(cmd, NOT_IN_LOCATION | NOT_IN_FILES)) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00115)\n                     \"Useless use of AllowOverrideList at %s:%d\",\n                     cmd->directive->filename, cmd->directive->line_num);\n    }\n    if ((err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS)) != NULL)\n        return err;\n\n    d->override_list = apr_table_make(cmd->pool, argc);\n\n    for (i = 0; i < argc; i++) {\n        if (!ap_cstr_casecmp(argv[i], \"None\")) {\n            if (argc != 1) {\n                return \"'None' not allowed with other directives in \"\n                       \"AllowOverrideList\";\n            }\n            return NULL;\n        }\n        else {\n            const command_rec *result = NULL;\n            module *mod = ap_top_module;\n\n            result = ap_find_command_in_modules(argv[i], &mod);\n            if (result == NULL) {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,\n                             APLOGNO(00116) \"Discarding unrecognized \"\n                             \"directive `%s' in AllowOverrideList at %s:%d\",\n                             argv[i], cmd->directive->filename,\n                             cmd->directive->line_num);\n                continue;\n            }\n            else if ((result->req_override & (OR_ALL|ACCESS_CONF)) == 0) {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,\n                             APLOGNO(02304) \"Discarding directive `%s' not \"\n                             \"allowed in AllowOverrideList at %s:%d\",\n                             argv[i], cmd->directive->filename,\n                             cmd->directive->line_num);\n                continue;\n            }\n            else {\n                apr_table_setn(d->override_list, argv[i], \"1\");\n            }\n        }\n    }\n\n    return NULL;\n}\n\nstatic const char *set_options(cmd_parms *cmd, void *d_, const char *l)\n{\n    core_dir_config *d = d_;\n    allow_options_t opt;\n    int first = 1;\n    int merge = 0;\n    int all_none = 0;\n    char action;\n\n    while (l[0]) {\n        char *w = ap_getword_conf(cmd->temp_pool, &l);\n        action = '\\0';\n\n        if (*w == '+' || *w == '-') {\n            action = *(w++);\n            if (!merge && !first && !all_none) {\n                return \"Either all Options must start with + or -, or no Option may.\";\n            }\n            merge = 1;\n        }\n        else if (first) {\n            d->opts = OPT_NONE;\n        }\n        else if (merge) {\n            return \"Either all Options must start with + or -, or no Option may.\";\n        }\n\n        if (!ap_cstr_casecmp(w, \"Indexes\")) {\n            opt = OPT_INDEXES;\n        }\n        else if (!ap_cstr_casecmp(w, \"Includes\")) {\n            opt = (OPT_INCLUDES | OPT_INC_WITH_EXEC);\n        }\n        else if (!ap_cstr_casecmp(w, \"IncludesNOEXEC\")) {\n            opt = OPT_INCLUDES;\n        }\n        else if (!ap_cstr_casecmp(w, \"FollowSymLinks\")) {\n            opt = OPT_SYM_LINKS;\n        }\n        else if (!ap_cstr_casecmp(w, \"SymLinksIfOwnerMatch\")) {\n            opt = OPT_SYM_OWNER;\n        }\n        else if (!ap_cstr_casecmp(w, \"ExecCGI\")) {\n            opt = OPT_EXECCGI;\n        }\n        else if (!ap_cstr_casecmp(w, \"MultiViews\")) {\n            opt = OPT_MULTI;\n        }\n        else if (!ap_cstr_casecmp(w, \"RunScripts\")) { /* AI backcompat. Yuck */\n            opt = OPT_MULTI|OPT_EXECCGI;\n        }\n        else if (!ap_cstr_casecmp(w, \"None\")) {\n            if (!first) {\n                return \"'Options None' must be the first Option given.\";\n            }\n            else if (merge) { /* Only works since None may not follow any other option. */\n                return \"You may not use 'Options +None' or 'Options -None'.\";\n            }\n            opt = OPT_NONE;\n            all_none = 1;\n        }\n        else if (!ap_cstr_casecmp(w, \"All\")) {\n            if (!first) {\n                return \"'Options All' must be the first option given.\";\n            }\n            else if (merge) { /* Only works since All may not follow any other option. */\n                return \"You may not use 'Options +All' or 'Options -All'.\";\n            }\n            opt = OPT_ALL;\n            all_none = 1;\n        }\n        else {\n            return apr_pstrcat(cmd->pool, \"Illegal option \", w, NULL);\n        }\n\n        if ( (cmd->override_opts & opt) != opt ) {\n            return apr_pstrcat(cmd->pool, \"Option \", w, \" not allowed here\", NULL);\n        }\n        else if (action == '-') {\n            /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */\n            d->opts_remove |= opt;\n            d->opts_add &= ~opt;\n            d->opts &= ~opt;\n        }\n        else if (action == '+') {\n            d->opts_add |= opt;\n            d->opts_remove &= ~opt;\n            d->opts |= opt;\n        }\n        else {\n            d->opts |= opt;\n        }\n\n        first = 0;\n    }\n\n    return NULL;\n}\n\nstatic const char *set_default_type(cmd_parms *cmd, void *d_,\n                                   const char *arg)\n{\n    if (ap_cstr_casecmp(arg, \"off\") != 0 && ap_cstr_casecmp(arg, \"none\") != 0) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00117)\n              \"Ignoring deprecated use of DefaultType in line %d of %s.\",\n                     cmd->directive->line_num, cmd->directive->filename);\n    }\n\n    return NULL;\n}\n\nstatic const char *set_sethandler(cmd_parms *cmd,\n                                     void *d_,\n                                     const char *arg_)\n{\n    core_dir_config *dirconf = d_;\n    const char *err;\n    dirconf->expr_handler = ap_expr_parse_cmd(cmd, arg_,\n                                          AP_EXPR_FLAG_STRING_RESULT,\n                                          &err, NULL);\n    if (err) {\n        return apr_pstrcat(cmd->pool,\n                \"Can't parse expression : \", err, NULL);\n    }\n    return NULL;\n}\n\n/*\n * Note what data should be used when forming file ETag values.\n * It would be nicer to do this as an ITERATE, but then we couldn't\n * remember the +/- state properly.\n */\nstatic const char *set_etag_bits(cmd_parms *cmd, void *mconfig,\n                                 const char *args_p)\n{\n    core_dir_config *cfg;\n    etag_components_t bit;\n    char action;\n    char *token;\n    const char *args;\n    int valid;\n    int first;\n    int explicit;\n\n    cfg = (core_dir_config *)mconfig;\n\n    args = args_p;\n    first = 1;\n    explicit = 0;\n    while (args[0] != '\\0') {\n        action = '*';\n        bit = ETAG_UNSET;\n        valid = 1;\n        token = ap_getword_conf(cmd->temp_pool, &args);\n        if ((*token == '+') || (*token == '-')) {\n            action = *token;\n            token++;\n        }\n        else {\n            /*\n             * The occurrence of an absolute setting wipes\n             * out any previous relative ones.  The first such\n             * occurrence forgets any inherited ones, too.\n             */\n            if (first) {\n                cfg->etag_bits = ETAG_UNSET;\n                cfg->etag_add = ETAG_UNSET;\n                cfg->etag_remove = ETAG_UNSET;\n                first = 0;\n            }\n        }\n\n        if (ap_cstr_casecmp(token, \"None\") == 0) {\n            if (action != '*') {\n                valid = 0;\n            }\n            else {\n                cfg->etag_bits = bit = ETAG_NONE;\n                explicit = 1;\n            }\n        }\n        else if (ap_cstr_casecmp(token, \"All\") == 0) {\n            if (action != '*') {\n                valid = 0;\n            }\n            else {\n                explicit = 1;\n                cfg->etag_bits = bit = ETAG_ALL;\n            }\n        }\n        else if (ap_cstr_casecmp(token, \"Size\") == 0) {\n            bit = ETAG_SIZE;\n        }\n        else if ((ap_cstr_casecmp(token, \"LMTime\") == 0)\n                 || (ap_cstr_casecmp(token, \"MTime\") == 0)\n                 || (ap_cstr_casecmp(token, \"LastModified\") == 0)) {\n            bit = ETAG_MTIME;\n        }\n        else if (ap_cstr_casecmp(token, \"INode\") == 0) {\n            bit = ETAG_INODE;\n        }\n        else {\n            return apr_pstrcat(cmd->pool, \"Unknown keyword '\",\n                               token, \"' for \", cmd->cmd->name,\n                               \" directive\", NULL);\n        }\n\n        if (! valid) {\n            return apr_pstrcat(cmd->pool, cmd->cmd->name, \" keyword '\",\n                               token, \"' cannot be used with '+' or '-'\",\n                               NULL);\n        }\n\n        if (action == '+') {\n            /*\n             * Make sure it's in the 'add' list and absent from the\n             * 'subtract' list.\n             */\n            cfg->etag_add |= bit;\n            cfg->etag_remove &= (~ bit);\n        }\n        else if (action == '-') {\n            cfg->etag_remove |= bit;\n            cfg->etag_add &= (~ bit);\n        }\n        else {\n            /*\n             * Non-relative values wipe out any + or - values\n             * accumulated so far.\n             */\n            cfg->etag_bits |= bit;\n            cfg->etag_add = ETAG_UNSET;\n            cfg->etag_remove = ETAG_UNSET;\n            explicit = 1;\n        }\n    }\n\n    /*\n     * Any setting at all will clear the 'None' and 'Unset' bits.\n     */\n\n    if (cfg->etag_add != ETAG_UNSET) {\n        cfg->etag_add &= (~ ETAG_UNSET);\n    }\n\n    if (cfg->etag_remove != ETAG_UNSET) {\n        cfg->etag_remove &= (~ ETAG_UNSET);\n    }\n\n    if (explicit) {\n        cfg->etag_bits &= (~ ETAG_UNSET);\n\n        if ((cfg->etag_bits & ETAG_NONE) != ETAG_NONE) {\n            cfg->etag_bits &= (~ ETAG_NONE);\n        }\n    }\n\n    return NULL;\n}\n\nstatic const char *set_enable_mmap(cmd_parms *cmd, void *d_,\n                                   const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        d->enable_mmap = ENABLE_MMAP_ON;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        d->enable_mmap = ENABLE_MMAP_OFF;\n    }\n    else {\n        return \"parameter must be 'on' or 'off'\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_enable_sendfile(cmd_parms *cmd, void *d_,\n                                   const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        d->enable_sendfile = ENABLE_SENDFILE_ON;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        d->enable_sendfile = ENABLE_SENDFILE_OFF;\n    }\n    else {\n        return \"parameter must be 'on' or 'off'\";\n    }\n\n    return NULL;\n}\n\n\n/*\n * Report a missing-'>' syntax error.\n */\nstatic char *unclosed_directive(cmd_parms *cmd)\n{\n    return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                       \"> directive missing closing '>'\", NULL);\n}\n\n/*\n * Report a missing args in '<Foo >' syntax error.\n */\nstatic char *missing_container_arg(cmd_parms *cmd)\n{\n    return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                       \"> directive requires additional arguments\", NULL);\n}\n\nAP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n\n        /* check for builtin or module registered method number */\n        methnum = ap_method_number_of(method);\n\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n            /* method has not been registered yet, but resource restriction\n             * is always checked before method handling, so register it.\n             */\n            methnum = ap_method_register(cmd->pool,\n                                         apr_pstrdup(cmd->pool, method));\n        }\n\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n\n    /* Killing two features with one function,\n     * if (tog == NULL) <Limit>, else <LimitExcept>\n     */\n    limited = tog ? ~limited : limited;\n\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n\n    cmd->limited &= limited;\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n\n    cmd->limited = old_limited;\n\n    return errmsg;\n}\n\n/* XXX: Bogus - need to do this differently (at least OS2/Netware suffer\n * the same problem!!!\n * We use this in <DirectoryMatch> and <FilesMatch>, to ensure that\n * people don't get bitten by wrong-cased regex matches\n */\n\n#ifdef WIN32\n#define USE_ICASE AP_REG_ICASE\n#else\n#define USE_ICASE 0\n#endif\n\nstatic const char *dirsection(cmd_parms *cmd, void *mconfig, const char *arg)\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    core_dir_config *conf;\n    ap_conf_vector_t *new_dir_conf = ap_create_per_dir_config(cmd->pool);\n    ap_regex_t *r = NULL;\n    const command_rec *thiscmd = cmd->cmd;\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    cmd->path = ap_getword_conf(cmd->pool, &arg);\n    cmd->override = OR_ALL|ACCESS_CONF;\n\n    if (!strcmp(cmd->path, \"~\")) {\n        cmd->path = ap_getword_conf(cmd->pool, &arg);\n        if (!cmd->path)\n            return \"<Directory ~ > block must specify a path\";\n        r = ap_pregcomp(cmd->pool, cmd->path, AP_REG_EXTENDED|USE_ICASE);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n    }\n    else if (thiscmd->cmd_data) { /* <DirectoryMatch> */\n        r = ap_pregcomp(cmd->pool, cmd->path, AP_REG_EXTENDED|USE_ICASE);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n    }\n    else if (strcmp(cmd->path, \"/\") != 0)\n    {\n        char *newpath;\n\n        /*\n         * Ensure that the pathname is canonical, and append the trailing /\n         */\n        apr_status_t rv = apr_filepath_merge(&newpath, NULL, cmd->path,\n                                             APR_FILEPATH_TRUENAME, cmd->pool);\n        if (rv != APR_SUCCESS && rv != APR_EPATHWILD) {\n            return apr_pstrcat(cmd->pool, \"<Directory \\\"\", cmd->path,\n                               \"\\\"> path is invalid.\", NULL);\n        }\n\n        cmd->path = newpath;\n        if (cmd->path[strlen(cmd->path) - 1] != '/')\n            cmd->path = apr_pstrcat(cmd->pool, cmd->path, \"/\", NULL);\n    }\n\n    /* initialize our config and fetch it */\n    conf = ap_set_config_vectors(cmd->server, new_dir_conf, cmd->path,\n                                 &core_module, cmd->pool);\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_dir_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    conf->r = r;\n    conf->d = cmd->path;\n    conf->d_is_fnmatch = (apr_fnmatch_test(conf->d) != 0);\n\n    if (r) {\n        conf->refs = apr_array_make(cmd->pool, 8, sizeof(char *));\n        ap_regname(r, conf->refs, AP_REG_MATCH, 1);\n    }\n\n    /* Make this explicit - the \"/\" root has 0 elements, that is, we\n     * will always merge it, and it will always sort and merge first.\n     * All others are sorted and tested by the number of slashes.\n     */\n    if (strcmp(conf->d, \"/\") == 0)\n        conf->d_components = 0;\n    else\n        conf->d_components = ap_count_dirs(conf->d);\n\n    ap_add_per_dir_conf(cmd->server, new_dir_conf);\n\n    if (*arg != '\\0') {\n        return apr_pstrcat(cmd->pool, \"Multiple \", thiscmd->name,\n                           \"> arguments not (yet) supported.\", NULL);\n    }\n\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n\n    return NULL;\n}\n\nstatic const char *urlsection(cmd_parms *cmd, void *mconfig, const char *arg)\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    core_dir_config *conf;\n    ap_regex_t *r = NULL;\n    const command_rec *thiscmd = cmd->cmd;\n    ap_conf_vector_t *new_url_conf = ap_create_per_dir_config(cmd->pool);\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    cmd->path = ap_getword_conf(cmd->pool, &arg);\n    cmd->override = OR_ALL|ACCESS_CONF;\n\n    if (thiscmd->cmd_data) { /* <LocationMatch> */\n        r = ap_pregcomp(cmd->pool, cmd->path, AP_REG_EXTENDED);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n    }\n    else if (!strcmp(cmd->path, \"~\")) {\n        cmd->path = ap_getword_conf(cmd->pool, &arg);\n        r = ap_pregcomp(cmd->pool, cmd->path, AP_REG_EXTENDED);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n    }\n\n    /* initialize our config and fetch it */\n    conf = ap_set_config_vectors(cmd->server, new_url_conf, cmd->path,\n                                 &core_module, cmd->pool);\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_url_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    conf->d = apr_pstrdup(cmd->pool, cmd->path);     /* No mangling, please */\n    conf->d_is_fnmatch = apr_fnmatch_test(conf->d) != 0;\n    conf->r = r;\n\n    if (r) {\n        conf->refs = apr_array_make(cmd->pool, 8, sizeof(char *));\n        ap_regname(r, conf->refs, AP_REG_MATCH, 1);\n    }\n\n    ap_add_per_url_conf(cmd->server, new_url_conf);\n\n    if (*arg != '\\0') {\n        return apr_pstrcat(cmd->pool, \"Multiple \", thiscmd->name,\n                           \"> arguments not (yet) supported.\", NULL);\n    }\n\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n\n    return NULL;\n}\n\nstatic const char *filesection(cmd_parms *cmd, void *mconfig, const char *arg)\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    core_dir_config *conf;\n    ap_regex_t *r = NULL;\n    const command_rec *thiscmd = cmd->cmd;\n    ap_conf_vector_t *new_file_conf = ap_create_per_dir_config(cmd->pool);\n    const char *err = ap_check_cmd_context(cmd,\n                                           NOT_IN_LOCATION | NOT_IN_LIMIT);\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    cmd->path = ap_getword_conf(cmd->pool, &arg);\n    /* Only if not an .htaccess file */\n    if (!old_path) {\n        cmd->override = OR_ALL|ACCESS_CONF;\n    }\n\n    if (thiscmd->cmd_data) { /* <FilesMatch> */\n        r = ap_pregcomp(cmd->pool, cmd->path, AP_REG_EXTENDED|USE_ICASE);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n    }\n    else if (!strcmp(cmd->path, \"~\")) {\n        cmd->path = ap_getword_conf(cmd->pool, &arg);\n        r = ap_pregcomp(cmd->pool, cmd->path, AP_REG_EXTENDED|USE_ICASE);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n    }\n    else {\n        char *newpath;\n        /* Ensure that the pathname is canonical, but we\n         * can't test the case/aliases without a fixed path */\n        if (apr_filepath_merge(&newpath, \"\", cmd->path,\n                               0, cmd->pool) != APR_SUCCESS)\n                return apr_pstrcat(cmd->pool, \"<Files \\\"\", cmd->path,\n                               \"\\\"> is invalid.\", NULL);\n        cmd->path = newpath;\n    }\n\n    /* initialize our config and fetch it */\n    conf = ap_set_config_vectors(cmd->server, new_file_conf, cmd->path,\n                                 &core_module, cmd->pool);\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_file_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    conf->d = cmd->path;\n    conf->d_is_fnmatch = apr_fnmatch_test(conf->d) != 0;\n    conf->r = r;\n\n    if (r) {\n        conf->refs = apr_array_make(cmd->pool, 8, sizeof(char *));\n        ap_regname(r, conf->refs, AP_REG_MATCH, 1);\n    }\n\n    ap_add_file_conf(cmd->pool, (core_dir_config *)mconfig, new_file_conf);\n\n    if (*arg != '\\0') {\n        return apr_pstrcat(cmd->pool, \"Multiple \", thiscmd->name,\n                           \"> arguments not (yet) supported.\", NULL);\n    }\n\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n\n    return NULL;\n}\n\n#define COND_IF      ((void *)1)\n#define COND_ELSE    ((void *)2)\n#define COND_ELSEIF  ((void *)3)\n\nstatic const char *ifsection(cmd_parms *cmd, void *mconfig, const char *arg)\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    core_dir_config *conf;\n    const command_rec *thiscmd = cmd->cmd;\n    ap_conf_vector_t *new_if_conf = ap_create_per_dir_config(cmd->pool);\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);\n    const char *condition;\n    const char *expr_err;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n\n    /*\n     * Set a dummy value so that other directives notice that they are inside\n     * a config section.\n     */\n    cmd->path = \"*If\";\n    /* Only if not an .htaccess file */\n    if (!old_path) {\n        cmd->override = OR_ALL|ACCESS_CONF;\n    }\n\n    /* initialize our config and fetch it */\n    conf = ap_set_config_vectors(cmd->server, new_if_conf, cmd->path,\n                                 &core_module, cmd->pool);\n\n    if (cmd->cmd->cmd_data == COND_IF)\n        conf->condition_ifelse = AP_CONDITION_IF;\n    else if (cmd->cmd->cmd_data == COND_ELSEIF)\n        conf->condition_ifelse = AP_CONDITION_ELSEIF;\n    else if (cmd->cmd->cmd_data == COND_ELSE)\n        conf->condition_ifelse = AP_CONDITION_ELSE;\n    else\n        ap_assert(0);\n\n    if (conf->condition_ifelse == AP_CONDITION_ELSE) {\n        if (arg[0])\n            return \"<Else> does not take an argument\";\n    }\n    else {\n        if (!arg[0])\n            return missing_container_arg(cmd);\n        condition = ap_getword_conf(cmd->pool, &arg);\n        conf->condition = ap_expr_parse_cmd(cmd, condition, 0, &expr_err, NULL);\n        if (expr_err)\n            return apr_psprintf(cmd->pool, \"Cannot parse condition clause: %s\",\n                                expr_err);\n    }\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_if_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    conf->d = cmd->path;\n    conf->d_is_fnmatch = 0;\n    conf->r = NULL;\n\n    errmsg = ap_add_if_conf(cmd->pool, (core_dir_config *)mconfig, new_if_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    if (*arg != '\\0') {\n        return apr_pstrcat(cmd->pool, \"Multiple \", thiscmd->name,\n                           \"> arguments not supported.\", NULL);\n    }\n\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n\n    return NULL;\n}\n\nstatic module *find_module(server_rec *s, const char *name)\n{\n    module *found = ap_find_linked_module(name);\n\n    /* search prelinked stuff */\n    if (!found) {\n        ap_module_symbol_t *current = ap_prelinked_module_symbols;\n\n        for (; current->name; ++current) {\n            if (!strcmp(current->name, name)) {\n                found = current->modp;\n                break;\n            }\n        }\n    }\n\n    /* search dynamic stuff */\n    if (!found) {\n        APR_OPTIONAL_FN_TYPE(ap_find_loaded_module_symbol) *check_symbol =\n            APR_RETRIEVE_OPTIONAL_FN(ap_find_loaded_module_symbol);\n\n        if (check_symbol) {\n            /*\n             * There are two phases where calling ap_find_loaded_module_symbol\n             * is problematic:\n             *\n             * During reading of the config, ap_server_conf is invalid but s\n             * points to the main server config, if passed from cmd->server\n             * of an EXEC_ON_READ directive.\n             *\n             * During config parsing, s may be a virtual host that would cause\n             * a segfault in mod_so if passed to ap_find_loaded_module_symbol,\n             * because mod_so's server config for vhosts is initialized later.\n             * But ap_server_conf is already set at this time.\n             *\n             * Therefore we use s if it is not virtual and ap_server_conf if\n             * s is virtual.\n             */\n            found = check_symbol(s->is_virtual ? ap_server_conf : s, name);\n        }\n    }\n\n    return found;\n}\n\n/* Callback function type used by start_cond_section. */\ntypedef int (*test_cond_section_fn)(cmd_parms *cmd, const char *arg);\n\n/* Implementation of <IfXXXXX>-style conditional sections.  Callback\n * to test condition must be in cmd->info, matching function type\n * test_cond_section_fn. */\nstatic const char *start_cond_section(cmd_parms *cmd, void *mconfig, const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    int result, not = (arg[0] == '!');\n    test_cond_section_fn testfn = (test_cond_section_fn)cmd->info;\n    const char *arg1;\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n\n    if (not) {\n        arg++;\n    }\n\n    arg1 = ap_getword_conf(cmd->temp_pool, &arg);\n\n    if (!arg1[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    result = testfn(cmd, arg1);\n\n    if ((!not && result) || (not && !result)) {\n        ap_directive_t *parent = NULL;\n        ap_directive_t *current = NULL;\n        const char *retval;\n\n        retval = ap_build_cont_config(cmd->pool, cmd->temp_pool, cmd,\n                                      &current, &parent, cmd->cmd->name);\n        *(ap_directive_t **)mconfig = current;\n        return retval;\n    }\n    else {\n        *(ap_directive_t **)mconfig = NULL;\n        return ap_soak_end_container(cmd, cmd->cmd->name);\n    }\n}\n\n/* Callback to implement <IfModule> test for start_cond_section. */\nstatic int test_ifmod_section(cmd_parms *cmd, const char *arg)\n{\n    return find_module(cmd->server, arg) != NULL;\n}\n\nAP_DECLARE(int) ap_exists_config_define(const char *name)\n{\n    return ap_array_str_contains(ap_server_config_defines, name);\n}\n\nstatic int test_ifdefine_section(cmd_parms *cmd, const char *arg)\n{\n    return ap_exists_config_define(arg);\n}\n\nstatic int test_iffile_section(cmd_parms *cmd, const char *arg)\n{\n    const char *relative;\n    apr_finfo_t sb;\n\n    relative = ap_server_root_relative(cmd->temp_pool, arg);\n    return (apr_stat(&sb, relative, 0, cmd->pool) == APR_SUCCESS);\n}\n\nstatic int test_ifdirective_section(cmd_parms *cmd, const char *arg)\n{\n    return ap_exists_directive(cmd->temp_pool, arg);\n}\n\nstatic int test_ifsection_section(cmd_parms *cmd, const char *arg)\n{\n    const char *name = apr_pstrcat(cmd->temp_pool, \"<\", arg, NULL);\n    return ap_exists_directive(cmd->temp_pool, name);\n}\n\n/* httpd.conf commands... beginning with the <VirtualHost> business */\n\nstatic const char *virtualhost_section(cmd_parms *cmd, void *dummy,\n                                       const char *arg)\n{\n    server_rec *main_server = cmd->server, *s;\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    apr_pool_t *p = cmd->pool;\n\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    /* FIXME: There's another feature waiting to happen here -- since you\n        can now put multiple addresses/names on a single <VirtualHost>\n        you might want to use it to group common definitions and then\n        define other \"subhosts\" with their individual differences.  But\n        personally I'd rather just do it with a macro preprocessor. -djg */\n    if (main_server->is_virtual) {\n        return \"<VirtualHost> doesn't nest!\";\n    }\n\n    errmsg = ap_init_virtual_host(p, arg, main_server, &s);\n    if (errmsg) {\n        return errmsg;\n    }\n\n    s->next = main_server->next;\n    main_server->next = s;\n\n    s->defn_name = cmd->directive->filename;\n    s->defn_line_number = cmd->directive->line_num;\n\n    cmd->server = s;\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd,\n                            s->lookup_defaults);\n\n    cmd->server = main_server;\n\n    return errmsg;\n}\n\nstatic const char *set_server_alias(cmd_parms *cmd, void *dummy,\n                                    const char *arg)\n{\n    if (!cmd->server->names) {\n        return \"ServerAlias only used in <VirtualHost>\";\n    }\n\n    while (*arg) {\n        char **item, *name = ap_getword_conf(cmd->pool, &arg);\n\n        if (ap_is_matchexp(name)) {\n            item = (char **)apr_array_push(cmd->server->wild_names);\n        }\n        else {\n            item = (char **)apr_array_push(cmd->server->names);\n        }\n\n        *item = name;\n    }\n\n    return NULL;\n}\n\nstatic const char *set_accf_map(cmd_parms *cmd, void *dummy,\n                                const char *iproto, const char* iaccf)\n{\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n    char* proto;\n    char* accf;\n    if (err != NULL) {\n        return err;\n    }\n\n    proto = apr_pstrdup(cmd->pool, iproto);\n    ap_str_tolower(proto);\n    accf = apr_pstrdup(cmd->pool, iaccf);\n    ap_str_tolower(accf);\n    apr_table_setn(conf->accf_map, proto, accf);\n\n    return NULL;\n}\n\nAP_DECLARE(const char*) ap_get_server_protocol(server_rec* s)\n{\n    core_server_config *conf = ap_get_core_module_config(s->module_config);\n    return conf->protocol;\n}\n\nAP_DECLARE(void) ap_set_server_protocol(server_rec* s, const char* proto)\n{\n    core_server_config *conf = ap_get_core_module_config(s->module_config);\n    conf->protocol = proto;\n}\n\nstatic const char *set_protocol(cmd_parms *cmd, void *dummy,\n                                const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n    char* proto;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    proto = apr_pstrdup(cmd->pool, arg);\n    ap_str_tolower(proto);\n    conf->protocol = proto;\n\n    return NULL;\n}\n\nstatic const char *set_server_string_slot(cmd_parms *cmd, void *dummy,\n                                          const char *arg)\n{\n    /* This one's pretty generic... */\n\n    int offset = (int)(long)cmd->info;\n    char *struct_ptr = (char *)cmd->server;\n\n    const char *err = ap_check_cmd_context(cmd,\n                                           NOT_IN_DIR_LOC_FILE);\n    if (err != NULL) {\n        return err;\n    }\n\n    *(const char **)(struct_ptr + offset) = arg;\n    return NULL;\n}\n\n/*\n * The ServerName directive takes one argument with format\n * [scheme://]fully-qualified-domain-name[:port], for instance\n * ServerName www.example.com\n * ServerName www.example.com:80\n * ServerName https://www.example.com:443\n */\n\nstatic const char *server_hostname_port(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    const char *portstr, *part;\n    char *scheme;\n    int port;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if (apr_fnmatch_test(arg))\n        return apr_pstrcat(cmd->temp_pool, \"Invalid ServerName \\\"\", arg,\n                \"\\\" use ServerAlias to set multiple server names.\", NULL);\n\n    part = ap_strstr_c(arg, \"://\");\n\n    if (part) {\n      scheme = apr_pstrndup(cmd->pool, arg, part - arg);\n      ap_str_tolower(scheme);\n      cmd->server->server_scheme = (const char *)scheme;\n      part += 3;\n    } else {\n      part = arg;\n    }\n\n    portstr = ap_strchr_c(part, ':');\n    if (portstr) {\n        cmd->server->server_hostname = apr_pstrndup(cmd->pool, part,\n                                                    portstr - part);\n        portstr++;\n        port = atoi(portstr);\n        if (port <= 0 || port >= 65536) { /* 65536 == 1<<16 */\n            return apr_pstrcat(cmd->temp_pool, \"The port number \\\"\", arg,\n                          \"\\\" is outside the appropriate range \"\n                          \"(i.e., 1..65535).\", NULL);\n        }\n    }\n    else {\n        cmd->server->server_hostname = apr_pstrdup(cmd->pool, part);\n        port = 0;\n    }\n\n    cmd->server->port = port;\n    return NULL;\n}\n\nstatic const char *set_signature_flag(cmd_parms *cmd, void *d_,\n                                      const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (ap_cstr_casecmp(arg, \"On\") == 0) {\n        d->server_signature = srv_sig_on;\n    }\n    else if (ap_cstr_casecmp(arg, \"Off\") == 0) {\n        d->server_signature = srv_sig_off;\n    }\n    else if (ap_cstr_casecmp(arg, \"EMail\") == 0) {\n        d->server_signature = srv_sig_withmail;\n    }\n    else {\n        return \"ServerSignature: use one of: off | on | email\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_server_root(cmd_parms *cmd, void *dummy,\n                                   const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if ((apr_filepath_merge((char**)&ap_server_root, NULL, arg,\n                            APR_FILEPATH_TRUENAME, cmd->pool) != APR_SUCCESS)\n        || !ap_is_directory(cmd->temp_pool, ap_server_root)) {\n        return \"ServerRoot must be a valid directory\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_runtime_dir(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if ((apr_filepath_merge((char**)&ap_runtime_dir, NULL,\n                            ap_server_root_relative(cmd->temp_pool, arg),\n                            APR_FILEPATH_TRUENAME, cmd->pool) != APR_SUCCESS)\n        || !ap_is_directory(cmd->temp_pool, ap_runtime_dir)) {\n        return \"DefaultRuntimeDir must be a valid directory, absolute or relative to ServerRoot\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_timeout(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n\n    if (err != NULL) {\n        return err;\n    }\n\n    cmd->server->timeout = apr_time_from_sec(atoi(arg));\n    return NULL;\n}\n\nstatic const char *set_allow2f(cmd_parms *cmd, void *d_, const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (0 == ap_cstr_casecmp(arg, \"on\")) {\n        d->allow_encoded_slashes = 1;\n        d->decode_encoded_slashes = 1; /* for compatibility with 2.0 & 2.2 */\n    } else if (0 == ap_cstr_casecmp(arg, \"off\")) {\n        d->allow_encoded_slashes = 0;\n        d->decode_encoded_slashes = 0;\n    } else if (0 == ap_cstr_casecmp(arg, \"nodecode\")) {\n        d->allow_encoded_slashes = 1;\n        d->decode_encoded_slashes = 0;\n    } else {\n        return apr_pstrcat(cmd->pool,\n                           cmd->cmd->name, \" must be On, Off, or NoDecode\",\n                           NULL);\n    }\n\n    d->allow_encoded_slashes_set = 1;\n    d->decode_encoded_slashes_set = 1;\n\n    return NULL;\n}\n\nstatic const char *set_hostname_lookups(cmd_parms *cmd, void *d_,\n                                        const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (!ap_cstr_casecmp(arg, \"on\")) {\n        d->hostname_lookups = HOSTNAME_LOOKUP_ON;\n    }\n    else if (!ap_cstr_casecmp(arg, \"off\")) {\n        d->hostname_lookups = HOSTNAME_LOOKUP_OFF;\n    }\n    else if (!ap_cstr_casecmp(arg, \"double\")) {\n        d->hostname_lookups = HOSTNAME_LOOKUP_DOUBLE;\n    }\n    else {\n        return \"parameter must be 'on', 'off', or 'double'\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_serverpath(cmd_parms *cmd, void *dummy,\n                                  const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n\n    if (err != NULL) {\n        return err;\n    }\n\n    cmd->server->path = arg;\n    cmd->server->pathlen = (int)strlen(arg);\n    return NULL;\n}\n\nstatic const char *set_content_md5(cmd_parms *cmd, void *d_, int arg)\n{\n    core_dir_config *d = d_;\n\n    d->content_md5 = arg ? AP_CONTENT_MD5_ON : AP_CONTENT_MD5_OFF;\n    return NULL;\n}\n\nstatic const char *set_accept_path_info(cmd_parms *cmd, void *d_, const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        d->accept_path_info = AP_REQ_ACCEPT_PATH_INFO;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        d->accept_path_info = AP_REQ_REJECT_PATH_INFO;\n    }\n    else if (ap_cstr_casecmp(arg, \"default\") == 0) {\n        d->accept_path_info = AP_REQ_DEFAULT_PATH_INFO;\n    }\n    else {\n        return \"AcceptPathInfo must be set to on, off or default\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_use_canonical_name(cmd_parms *cmd, void *d_,\n                                          const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        d->use_canonical_name = USE_CANONICAL_NAME_ON;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        d->use_canonical_name = USE_CANONICAL_NAME_OFF;\n    }\n    else if (ap_cstr_casecmp(arg, \"dns\") == 0) {\n        d->use_canonical_name = USE_CANONICAL_NAME_DNS;\n    }\n    else {\n        return \"parameter must be 'on', 'off', or 'dns'\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_use_canonical_phys_port(cmd_parms *cmd, void *d_,\n                                          const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        d->use_canonical_phys_port = USE_CANONICAL_PHYS_PORT_ON;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        d->use_canonical_phys_port = USE_CANONICAL_PHYS_PORT_OFF;\n    }\n    else {\n        return \"parameter must be 'on' or 'off'\";\n    }\n\n    return NULL;\n}\n\nstatic const char *include_config (cmd_parms *cmd, void *dummy,\n                                   const char *name)\n{\n    ap_directive_t *conftree = NULL;\n    const char *conffile, *error;\n    unsigned *recursion;\n    int optional = cmd->cmd->cmd_data ? 1 : 0;\n    void *data;\n\n    /* NOTE: ap_include_sentinel is also used by ap_process_resource_config()\n     * during DUMP_INCLUDES; don't change its type or remove it without updating\n     * the other.\n     */\n    apr_pool_userdata_get(&data, \"ap_include_sentinel\", cmd->pool);\n    if (data) {\n        recursion = data;\n    }\n    else {\n        data = recursion = apr_palloc(cmd->pool, sizeof(*recursion));\n        *recursion = 0;\n        apr_pool_userdata_setn(data, \"ap_include_sentinel\", NULL, cmd->pool);\n    }\n\n    if (++*recursion > AP_MAX_INCLUDE_DEPTH) {\n        *recursion = 0;\n        return apr_psprintf(cmd->pool, \"Exceeded maximum include depth of %u, \"\n                            \"There appears to be a recursion.\",\n                            AP_MAX_INCLUDE_DEPTH);\n    }\n\n    conffile = ap_server_root_relative(cmd->pool, name);\n    if (!conffile) {\n        *recursion = 0;\n        return apr_pstrcat(cmd->pool, \"Invalid Include path \",\n                           name, NULL);\n    }\n\n    if (ap_exists_config_define(\"DUMP_INCLUDES\")) {\n        unsigned *line_number;\n\n        /* NOTE: ap_include_lineno is used by ap_process_resource_config()\n         * during DUMP_INCLUDES; don't change its type or remove it without\n         * updating the other.\n         */\n        apr_pool_userdata_get(&data, \"ap_include_lineno\", cmd->pool);\n        if (data) {\n            line_number = data;\n        } else {\n            data = line_number = apr_palloc(cmd->pool, sizeof(*line_number));\n            apr_pool_userdata_setn(data, \"ap_include_lineno\", NULL, cmd->pool);\n        }\n\n        *line_number = cmd->config_file->line_number;\n    }\n\n    error = ap_process_fnmatch_configs(cmd->server, conffile, &conftree,\n                                       cmd->pool, cmd->temp_pool,\n                                       optional);\n    if (error) {\n        *recursion = 0;\n        return error;\n    }\n\n    *(ap_directive_t **)dummy = conftree;\n\n    /* recursion level done */\n    if (*recursion) {\n        --*recursion;\n    }\n\n    return NULL;\n}\n\nstatic const char *update_loglevel(cmd_parms *cmd, struct ap_logconf *log,\n                                   const char *arg)\n{\n    const char *level_str, *err;\n    module *module;\n    int level;\n\n    level_str = ap_strrchr_c(arg, ':');\n\n    if (level_str == NULL) {\n        err = ap_parse_log_level(arg, &log->level);\n        if (err != NULL)\n            return err;\n        ap_reset_module_loglevels(log, APLOG_NO_MODULE);\n        ap_log_error(APLOG_MARK, APLOG_TRACE3, 0, cmd->server,\n                     \"Setting %s for all modules to %s\", cmd->cmd->name, arg);\n        return NULL;\n    }\n\n    arg = apr_pstrmemdup(cmd->temp_pool, arg, level_str - arg);\n    level_str++;\n    if (!*level_str) {\n        return apr_psprintf(cmd->temp_pool, \"Module specifier '%s' must be \"\n                            \"followed by a log level keyword\", arg);\n    }\n\n    err = ap_parse_log_level(level_str, &level);\n    if (err != NULL)\n        return apr_psprintf(cmd->temp_pool, \"%s:%s: %s\", arg, level_str, err);\n\n    if ((module = find_module(cmd->server, arg)) == NULL) {\n        char *name = apr_psprintf(cmd->temp_pool, \"%s_module\", arg);\n        ap_log_error(APLOG_MARK, APLOG_TRACE6, 0, cmd->server,\n                     \"Cannot find module '%s', trying '%s'\", arg, name);\n        module = find_module(cmd->server, name);\n    }\n\n    if (module == NULL) {\n        return apr_psprintf(cmd->temp_pool, \"Cannot find module %s\", arg);\n    }\n\n    ap_set_module_loglevel(cmd->pool, log, module->module_index, level);\n    ap_log_error(APLOG_MARK, APLOG_TRACE3, 0, cmd->server,\n                 \"Setting %s for module %s to %s\", cmd->cmd->name,\n                 module->name, level_str);\n\n    return NULL;\n}\n\nstatic const char *set_loglevel(cmd_parms *cmd, void *config_, const char *arg)\n{\n    struct ap_logconf *log;\n\n    if (cmd->path) {\n        core_dir_config *dconf = config_;\n        if (!dconf->log) {\n            dconf->log = ap_new_log_config(cmd->pool, NULL);\n        }\n        log = dconf->log;\n    }\n    else {\n        log = &cmd->server->log;\n    }\n\n    if (arg == NULL)\n        return \"LogLevel requires level keyword or module loglevel specifier\";\n\n    return update_loglevel(cmd, log, arg);\n}\n\nstatic const char *set_loglevel_override(cmd_parms *cmd, void *d_, int argc,\n                                         char *const argv[])\n{\n    core_server_config *sconf;\n    conn_log_config *entry;\n    int ret, i;\n    const char *addr, *mask, *err;\n\n    if (argc < 2)\n        return \"LogLevelOverride requires at least two arguments\";\n\n    entry = apr_pcalloc(cmd->pool, sizeof(conn_log_config));\n    sconf = ap_get_core_module_config(cmd->server->module_config);\n    if (!sconf->conn_log_level)\n        sconf->conn_log_level = apr_array_make(cmd->pool, 4, sizeof(entry));\n    APR_ARRAY_PUSH(sconf->conn_log_level, conn_log_config *) = entry;\n\n    addr = argv[0];\n    mask = ap_strchr_c(addr, '/');\n    if (mask) {\n        addr = apr_pstrmemdup(cmd->temp_pool, addr, mask - addr);\n        mask++;\n    }\n    ret = apr_ipsubnet_create(&entry->subnet, addr, mask, cmd->pool);\n    if (ret != APR_SUCCESS)\n        return \"parsing of subnet/netmask failed\";\n\n    for (i = 1; i < argc; i++) {\n        if ((err = update_loglevel(cmd, &entry->log, argv[i])) != NULL)\n            return err;\n    }\n    return NULL;\n}\n\nAP_DECLARE(const char *) ap_psignature(const char *prefix, request_rec *r)\n{\n    char sport[20];\n    core_dir_config *conf;\n\n    conf = (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n    if ((conf->server_signature == srv_sig_off)\n            || (conf->server_signature == srv_sig_unset)) {\n        return \"\";\n    }\n\n    apr_snprintf(sport, sizeof sport, \"%u\", (unsigned) ap_get_server_port(r));\n\n    if (conf->server_signature == srv_sig_withmail) {\n        return apr_pstrcat(r->pool, prefix, \"<address>\",\n                           ap_get_server_banner(),\n                           \" Server at <a href=\\\"\",\n                           ap_is_url(r->server->server_admin) ? \"\" : \"mailto:\",\n                           ap_escape_html(r->pool, r->server->server_admin),\n                           \"\\\">\",\n                           ap_escape_html(r->pool, ap_get_server_name(r)),\n                           \"</a> Port \", sport,\n                           \"</address>\\n\", NULL);\n    }\n\n    return apr_pstrcat(r->pool, prefix, \"<address>\", ap_get_server_banner(),\n                       \" Server at \",\n                       ap_escape_html(r->pool, ap_get_server_name(r)),\n                       \" Port \", sport,\n                       \"</address>\\n\", NULL);\n}\n\n/*\n * Handle a request to include the server's OS platform in the Server\n * response header field (the ServerTokens directive).  Unfortunately\n * this requires a new global in order to communicate the setting back to\n * http_main so it can insert the information in the right place in the\n * string.\n */\n\nstatic char *server_banner = NULL;\nstatic int banner_locked = 0;\nstatic const char *server_description = NULL;\n\nenum server_token_type {\n    SrvTk_MAJOR,         /* eg: Apache/2 */\n    SrvTk_MINOR,         /* eg. Apache/2.0 */\n    SrvTk_MINIMAL,       /* eg: Apache/2.0.41 */\n    SrvTk_OS,            /* eg: Apache/2.0.41 (UNIX) */\n    SrvTk_FULL,          /* eg: Apache/2.0.41 (UNIX) PHP/4.2.2 FooBar/1.2b */\n    SrvTk_PRODUCT_ONLY   /* eg: Apache */\n};\nstatic enum server_token_type ap_server_tokens = SrvTk_FULL;\n\nstatic apr_status_t reset_banner(void *dummy)\n{\n    banner_locked = 0;\n    ap_server_tokens = SrvTk_FULL;\n    server_banner = NULL;\n    server_description = NULL;\n    return APR_SUCCESS;\n}\n\nAP_DECLARE(void) ap_get_server_revision(ap_version_t *version)\n{\n    version->major = AP_SERVER_MAJORVERSION_NUMBER;\n    version->minor = AP_SERVER_MINORVERSION_NUMBER;\n    version->patch = AP_SERVER_PATCHLEVEL_NUMBER;\n    version->add_string = AP_SERVER_ADD_STRING;\n}\n\nAP_DECLARE(const char *) ap_get_server_description(void)\n{\n    return server_description ? server_description :\n        AP_SERVER_BASEVERSION \" (\" PLATFORM \")\";\n}\n\nAP_DECLARE(const char *) ap_get_server_banner(void)\n{\n    return server_banner ? server_banner : AP_SERVER_BASEVERSION;\n}\n\nAP_DECLARE(void) ap_add_version_component(apr_pool_t *pconf, const char *component)\n{\n    if (! banner_locked) {\n        /*\n         * If the version string is null, register our cleanup to reset the\n         * pointer on pool destruction. We also know that, if NULL,\n         * we are adding the original SERVER_BASEVERSION string.\n         */\n        if (server_banner == NULL) {\n            apr_pool_cleanup_register(pconf, NULL, reset_banner,\n                                      apr_pool_cleanup_null);\n            server_banner = apr_pstrdup(pconf, component);\n        }\n        else {\n            /*\n             * Tack the given component identifier to the end of\n             * the existing string.\n             */\n            server_banner = apr_pstrcat(pconf, server_banner, \" \",\n                                        component, NULL);\n        }\n    }\n    server_description = apr_pstrcat(pconf, server_description, \" \",\n                                     component, NULL);\n}\n\n/*\n * This routine adds the real server base identity to the banner string,\n * and then locks out changes until the next reconfig.\n */\nstatic void set_banner(apr_pool_t *pconf)\n{\n    if (ap_server_tokens == SrvTk_PRODUCT_ONLY) {\n        ap_add_version_component(pconf, AP_SERVER_BASEPRODUCT);\n    }\n    else if (ap_server_tokens == SrvTk_MINIMAL) {\n        ap_add_version_component(pconf, AP_SERVER_BASEVERSION);\n    }\n    else if (ap_server_tokens == SrvTk_MINOR) {\n        ap_add_version_component(pconf, AP_SERVER_BASEPRODUCT \"/\" AP_SERVER_MINORREVISION);\n    }\n    else if (ap_server_tokens == SrvTk_MAJOR) {\n        ap_add_version_component(pconf, AP_SERVER_BASEPRODUCT \"/\" AP_SERVER_MAJORVERSION);\n    }\n    else {\n        ap_add_version_component(pconf, AP_SERVER_BASEVERSION \" (\" PLATFORM \")\");\n    }\n\n    /*\n     * Lock the server_banner string if we're not displaying\n     * the full set of tokens\n     */\n    if (ap_server_tokens != SrvTk_FULL) {\n        banner_locked++;\n    }\n    server_description = AP_SERVER_BASEVERSION \" (\" PLATFORM \")\";\n}\n\nstatic const char *set_serv_tokens(cmd_parms *cmd, void *dummy,\n                                   const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if (!ap_cstr_casecmp(arg, \"OS\")) {\n        ap_server_tokens = SrvTk_OS;\n    }\n    else if (!ap_cstr_casecmp(arg, \"Min\") || !ap_cstr_casecmp(arg, \"Minimal\")) {\n        ap_server_tokens = SrvTk_MINIMAL;\n    }\n    else if (!ap_cstr_casecmp(arg, \"Major\")) {\n        ap_server_tokens = SrvTk_MAJOR;\n    }\n    else if (!ap_cstr_casecmp(arg, \"Minor\") ) {\n        ap_server_tokens = SrvTk_MINOR;\n    }\n    else if (!ap_cstr_casecmp(arg, \"Prod\") || !ap_cstr_casecmp(arg, \"ProductOnly\")) {\n        ap_server_tokens = SrvTk_PRODUCT_ONLY;\n    }\n    else if (!ap_cstr_casecmp(arg, \"Full\")) {\n        ap_server_tokens = SrvTk_FULL;\n    }\n    else {\n        return \"ServerTokens takes 1 argument: 'Prod(uctOnly)', 'Major', 'Minor', 'Min(imal)', 'OS', or 'Full'\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_limit_req_line(cmd_parms *cmd, void *dummy,\n                                      const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    int lim;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    lim = atoi(arg);\n    if (lim < 0) {\n        return apr_pstrcat(cmd->temp_pool, \"LimitRequestLine \\\"\", arg,\n                           \"\\\" must be a non-negative integer\", NULL);\n    }\n\n    cmd->server->limit_req_line = lim;\n    return NULL;\n}\n\nstatic const char *set_limit_req_fieldsize(cmd_parms *cmd, void *dummy,\n                                           const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    int lim;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    lim = atoi(arg);\n    if (lim < 0) {\n        return apr_pstrcat(cmd->temp_pool, \"LimitRequestFieldsize \\\"\", arg,\n                          \"\\\" must be a non-negative integer\",\n                          NULL);\n    }\n\n    cmd->server->limit_req_fieldsize = lim;\n    return NULL;\n}\n\nstatic const char *set_limit_req_fields(cmd_parms *cmd, void *dummy,\n                                        const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    int lim;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    lim = atoi(arg);\n    if (lim < 0) {\n        return apr_pstrcat(cmd->temp_pool, \"LimitRequestFields \\\"\", arg,\n                           \"\\\" must be a non-negative integer (0 = no limit)\",\n                           NULL);\n    }\n\n    cmd->server->limit_req_fields = lim;\n    return NULL;\n}\n\nstatic const char *set_limit_req_body(cmd_parms *cmd, void *conf_,\n                                      const char *arg)\n{\n    core_dir_config *conf = conf_;\n    char *errp;\n\n    if (APR_SUCCESS != apr_strtoff(&conf->limit_req_body, arg, &errp, 10)) {\n        return \"LimitRequestBody argument is not parsable.\";\n    }\n    if (*errp || conf->limit_req_body < 0) {\n        return \"LimitRequestBody requires a non-negative integer.\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_limit_xml_req_body(cmd_parms *cmd, void *conf_,\n                                          const char *arg)\n{\n    core_dir_config *conf = conf_;\n\n    conf->limit_xml_body = atol(arg);\n    if (conf->limit_xml_body < 0)\n        return \"LimitXMLRequestBody requires a non-negative integer.\";\n\n    return NULL;\n}\n\nstatic const char *set_max_ranges(cmd_parms *cmd, void *conf_, const char *arg)\n{\n    core_dir_config *conf = conf_;\n    int val = 0;\n\n    if (!ap_cstr_casecmp(arg, \"none\")) {\n        val = AP_MAXRANGES_NORANGES;\n    }\n    else if (!ap_cstr_casecmp(arg, \"default\")) {\n        val = AP_MAXRANGES_DEFAULT;\n    }\n    else if (!ap_cstr_casecmp(arg, \"unlimited\")) {\n        val = AP_MAXRANGES_UNLIMITED;\n    }\n    else {\n        val = atoi(arg);\n        if (val <= 0)\n            return \"MaxRanges requires 'none', 'default', 'unlimited' or \"\n                   \"a positive integer\";\n    }\n\n    conf->max_ranges = val;\n\n    return NULL;\n}\n\nstatic const char *set_max_overlaps(cmd_parms *cmd, void *conf_, const char *arg)\n{\n    core_dir_config *conf = conf_;\n    int val = 0;\n\n    if (!ap_cstr_casecmp(arg, \"none\")) {\n        val = AP_MAXRANGES_NORANGES;\n    }\n    else if (!ap_cstr_casecmp(arg, \"default\")) {\n        val = AP_MAXRANGES_DEFAULT;\n    }\n    else if (!ap_cstr_casecmp(arg, \"unlimited\")) {\n        val = AP_MAXRANGES_UNLIMITED;\n    }\n    else {\n        val = atoi(arg);\n        if (val <= 0)\n            return \"MaxRangeOverlaps requires 'none', 'default', 'unlimited' or \"\n            \"a positive integer\";\n    }\n\n    conf->max_overlaps = val;\n\n    return NULL;\n}\n\nstatic const char *set_max_reversals(cmd_parms *cmd, void *conf_, const char *arg)\n{\n    core_dir_config *conf = conf_;\n    int val = 0;\n\n    if (!ap_cstr_casecmp(arg, \"none\")) {\n        val = AP_MAXRANGES_NORANGES;\n    }\n    else if (!ap_cstr_casecmp(arg, \"default\")) {\n        val = AP_MAXRANGES_DEFAULT;\n    }\n    else if (!ap_cstr_casecmp(arg, \"unlimited\")) {\n        val = AP_MAXRANGES_UNLIMITED;\n    }\n    else {\n        val = atoi(arg);\n        if (val <= 0)\n            return \"MaxRangeReversals requires 'none', 'default', 'unlimited' or \"\n            \"a positive integer\";\n    }\n\n    conf->max_reversals = val;\n\n    return NULL;\n}\n\nAP_DECLARE(apr_size_t) ap_get_limit_xml_body(const request_rec *r)\n{\n    core_dir_config *conf;\n\n    conf = ap_get_core_module_config(r->per_dir_config);\n    if (conf->limit_xml_body == AP_LIMIT_UNSET)\n        return AP_DEFAULT_LIMIT_XML_BODY;\n\n    return (apr_size_t)conf->limit_xml_body;\n}\n\n#if !defined (RLIMIT_CPU) || !(defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS)) || !defined (RLIMIT_NPROC)\nstatic const char *no_set_limit(cmd_parms *cmd, void *conf_,\n                                const char *arg, const char *arg2)\n{\n    ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server, APLOGNO(00118)\n                \"%s not supported on this platform\", cmd->cmd->name);\n\n    return NULL;\n}\n#endif\n\n#ifdef RLIMIT_CPU\nstatic const char *set_limit_cpu(cmd_parms *cmd, void *conf_,\n                                 const char *arg, const char *arg2)\n{\n    core_dir_config *conf = conf_;\n\n    ap_unixd_set_rlimit(cmd, &conf->limit_cpu, arg, arg2, RLIMIT_CPU);\n    return NULL;\n}\n#endif\n\n#if defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS)\nstatic const char *set_limit_mem(cmd_parms *cmd, void *conf_,\n                                 const char *arg, const char * arg2)\n{\n    core_dir_config *conf = conf_;\n\n#if defined(RLIMIT_AS)\n    ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2 ,RLIMIT_AS);\n#elif defined(RLIMIT_DATA)\n    ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_DATA);\n#elif defined(RLIMIT_VMEM)\n    ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_VMEM);\n#endif\n\n    return NULL;\n}\n#endif\n\n#ifdef RLIMIT_NPROC\nstatic const char *set_limit_nproc(cmd_parms *cmd, void *conf_,\n                                   const char *arg, const char * arg2)\n{\n    core_dir_config *conf = conf_;\n\n    ap_unixd_set_rlimit(cmd, &conf->limit_nproc, arg, arg2, RLIMIT_NPROC);\n    return NULL;\n}\n#endif\n\nstatic const char *set_recursion_limit(cmd_parms *cmd, void *dummy,\n                                       const char *arg1, const char *arg2)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n    int limit = atoi(arg1);\n\n    if (limit <= 0) {\n        return \"The recursion limit must be greater than zero.\";\n    }\n    if (limit < 4) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00119)\n                     \"Limiting internal redirects to very low numbers may \"\n                     \"cause normal requests to fail.\");\n    }\n\n    conf->redirect_limit = limit;\n\n    if (arg2) {\n        limit = atoi(arg2);\n\n        if (limit <= 0) {\n            return \"The recursion limit must be greater than zero.\";\n        }\n        if (limit < 4) {\n            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00120)\n                         \"Limiting the subrequest depth to a very low level may\"\n                         \" cause normal requests to fail.\");\n        }\n    }\n\n    conf->subreq_limit = limit;\n\n    return NULL;\n}\n\nstatic void log_backtrace(const request_rec *r)\n{\n    const request_rec *top = r;\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00121)\n                  \"r->uri = %s\", r->uri ? r->uri : \"(unexpectedly NULL)\");\n\n    while (top && (top->prev || top->main)) {\n        if (top->prev) {\n            top = top->prev;\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00122)\n                          \"redirected from r->uri = %s\",\n                          top->uri ? top->uri : \"(unexpectedly NULL)\");\n        }\n\n        if (!top->prev && top->main) {\n            top = top->main;\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00123)\n                          \"subrequested from r->uri = %s\",\n                          top->uri ? top->uri : \"(unexpectedly NULL)\");\n        }\n    }\n}\n\n/*\n * check whether redirect limit is reached\n */\nAP_DECLARE(int) ap_is_recursion_limit_exceeded(const request_rec *r)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(r->server->module_config);\n    const request_rec *top = r;\n    int redirects = 0, subreqs = 0;\n    int rlimit = conf->redirect_limit\n                 ? conf->redirect_limit\n                 : AP_DEFAULT_MAX_INTERNAL_REDIRECTS;\n    int slimit = conf->subreq_limit\n                 ? conf->subreq_limit\n                 : AP_DEFAULT_MAX_SUBREQ_DEPTH;\n\n\n    while (top->prev || top->main) {\n        if (top->prev) {\n            if (++redirects >= rlimit) {\n                /* uuh, too much. */\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00124)\n                              \"Request exceeded the limit of %d internal \"\n                              \"redirects due to probable configuration error. \"\n                              \"Use 'LimitInternalRecursion' to increase the \"\n                              \"limit if necessary. Use 'LogLevel debug' to get \"\n                              \"a backtrace.\", rlimit);\n\n                /* post backtrace */\n                log_backtrace(r);\n\n                /* return failure */\n                return 1;\n            }\n\n            top = top->prev;\n        }\n\n        if (!top->prev && top->main) {\n            if (++subreqs >= slimit) {\n                /* uuh, too much. */\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00125)\n                              \"Request exceeded the limit of %d subrequest \"\n                              \"nesting levels due to probable configuration \"\n                              \"error. Use 'LimitInternalRecursion' to increase \"\n                              \"the limit if necessary. Use 'LogLevel debug' to \"\n                              \"get a backtrace.\", slimit);\n\n                /* post backtrace */\n                log_backtrace(r);\n\n                /* return failure */\n                return 1;\n            }\n\n            top = top->main;\n        }\n    }\n\n    /* recursion state: ok */\n    return 0;\n}\n\nstatic const char *set_trace_enable(cmd_parms *cmd, void *dummy,\n                                    const char *arg1)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n\n    if (ap_cstr_casecmp(arg1, \"on\") == 0) {\n        conf->trace_enable = AP_TRACE_ENABLE;\n    }\n    else if (ap_cstr_casecmp(arg1, \"off\") == 0) {\n        conf->trace_enable = AP_TRACE_DISABLE;\n    }\n    else if (ap_cstr_casecmp(arg1, \"extended\") == 0) {\n        conf->trace_enable = AP_TRACE_EXTENDED;\n    }\n    else {\n        return \"TraceEnable must be one of 'on', 'off', or 'extended'\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_protocols(cmd_parms *cmd, void *dummy,\n                                 const char *arg)\n{\n    core_server_config *conf =\n    ap_get_core_module_config(cmd->server->module_config);\n    const char **np;\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n\n    if (err) {\n        return err;\n    }\n    \n    np = (const char **)apr_array_push(conf->protocols);\n    *np = arg;\n\n    return NULL;\n}\n\nstatic const char *set_protocols_honor_order(cmd_parms *cmd, void *dummy,\n                                             const char *arg)\n{\n    core_server_config *conf =\n    ap_get_core_module_config(cmd->server->module_config);\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    \n    if (err) {\n        return err;\n    }\n    \n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        conf->protocols_honor_order = 1;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        conf->protocols_honor_order = 0;\n    }\n    else {\n        return \"ProtocolsHonorOrder must be 'on' or 'off'\";\n    }\n    \n    return NULL;\n}\n\nstatic const char *set_http_protocol_options(cmd_parms *cmd, void *dummy,\n                                             const char *arg)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n\n    if (strcasecmp(arg, \"allow0.9\") == 0)\n        conf->http09_enable |= AP_HTTP09_ENABLE;\n    else if (strcasecmp(arg, \"require1.0\") == 0)\n        conf->http09_enable |= AP_HTTP09_DISABLE;\n    else if (strcasecmp(arg, \"strict\") == 0)\n        conf->http_conformance |= AP_HTTP_CONFORMANCE_STRICT;\n    else if (strcasecmp(arg, \"unsafe\") == 0)\n        conf->http_conformance |= AP_HTTP_CONFORMANCE_UNSAFE;\n    else if (strcasecmp(arg, \"registeredmethods\") == 0)\n        conf->http_methods |= AP_HTTP_METHODS_REGISTERED;\n    else if (strcasecmp(arg, \"lenientmethods\") == 0)\n        conf->http_methods |= AP_HTTP_METHODS_LENIENT;\n    else\n        return \"HttpProtocolOptions accepts \"\n               \"'Unsafe' or 'Strict' (default), \"\n               \"'RegisteredMethods' or 'LenientMethods' (default), and \"\n               \"'Require1.0' or 'Allow0.9' (default)\";\n\n    if ((conf->http09_enable & AP_HTTP09_ENABLE)\n            && (conf->http09_enable & AP_HTTP09_DISABLE))\n        return \"HttpProtocolOptions 'Allow0.9' and 'Require1.0'\"\n               \" are mutually exclusive\";\n\n    if ((conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT)\n            && (conf->http_conformance & AP_HTTP_CONFORMANCE_UNSAFE))\n        return \"HttpProtocolOptions 'Strict' and 'Unsafe'\"\n               \" are mutually exclusive\";\n\n    if ((conf->http_methods & AP_HTTP_METHODS_REGISTERED)\n            && (conf->http_methods & AP_HTTP_METHODS_LENIENT))\n        return \"HttpProtocolOptions 'RegisteredMethods' and 'LenientMethods'\"\n               \" are mutually exclusive\";\n\n    return NULL;\n}\n\nstatic const char *set_async_filter(cmd_parms *cmd, void *dummy,\n                                             const char *arg)\n{\n    core_server_config *conf =\n    ap_get_core_module_config(cmd->server->module_config);\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n\n    if (err) {\n        return err;\n    }\n\n    if (ap_cstr_casecmp(arg, \"network\") == 0) {\n        conf->async_filter = AP_FTYPE_NETWORK;\n    }\n    else if (ap_cstr_casecmp(arg, \"connection\") == 0) {\n        conf->async_filter = AP_FTYPE_CONNECTION;\n    }\n    else if (ap_cstr_casecmp(arg, \"request\") == 0) {\n        conf->async_filter = 0;\n    }\n    else {\n        return \"AsyncFilter must be 'network', 'connection' or 'request'\";\n    }\n    conf->async_filter_set = 1;\n\n    return NULL;\n}\n\nstatic const char *set_http_method(cmd_parms *cmd, void *conf, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    if (err != NULL)\n        return err;\n    ap_method_register(cmd->pool, arg);\n    return NULL;\n}\n\nstatic const char *set_cl_head_zero(cmd_parms *cmd, void *dummy, int arg)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n\n    if (arg) {\n        conf->http_cl_head_zero = AP_HTTP_CL_HEAD_ZERO_ENABLE;\n    } else {\n        conf->http_cl_head_zero = AP_HTTP_CL_HEAD_ZERO_DISABLE;\n    }\n    return NULL;\n}\n\nstatic const char *set_expect_strict(cmd_parms *cmd, void *dummy, int arg)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n\n    if (arg) {\n        conf->http_expect_strict = AP_HTTP_EXPECT_STRICT_ENABLE;\n    } else {\n        conf->http_expect_strict = AP_HTTP_EXPECT_STRICT_DISABLE;\n    }\n    return NULL;\n}\n\nstatic apr_hash_t *errorlog_hash;\n\nstatic int log_constant_item(const ap_errorlog_info *info, const char *arg,\n                             char *buf, int buflen)\n{\n    char *end = apr_cpystrn(buf, arg, buflen);\n    return end - buf;\n}\n\nstatic char *parse_errorlog_misc_string(apr_pool_t *p,\n                                        ap_errorlog_format_item *it,\n                                        const char **sa)\n{\n    const char *s;\n    char scratch[MAX_STRING_LEN];\n    char *d = scratch;\n    /*\n     * non-leading white space terminates this string to allow the next field\n     * separator to be inserted\n     */\n    int at_start = 1;\n\n    it->func = log_constant_item;\n    s = *sa;\n\n    while (*s && *s != '%' && (*s != ' ' || at_start) && d < scratch + MAX_STRING_LEN) {\n        if (*s != '\\\\') {\n            if (*s != ' ') {\n                at_start = 0;\n            }\n            *d++ = *s++;\n        }\n        else {\n            s++;\n            switch (*s) {\n            case 'r':\n                *d++ = '\\r';\n                s++;\n                break;\n            case 'n':\n                *d++ = '\\n';\n                s++;\n                break;\n            case 't':\n                *d++ = '\\t';\n                s++;\n                break;\n            case '\\0':\n                /* handle end of string */\n                *d++ = '\\\\';\n                break;\n            default:\n                /* copy next char verbatim */\n                *d++ = *s++;\n                break;\n            }\n        }\n    }\n    *d = '\\0';\n    it->arg = apr_pstrdup(p, scratch);\n\n    *sa = s;\n    return NULL;\n}\n\nstatic char *parse_errorlog_item(apr_pool_t *p, ap_errorlog_format_item *it,\n                                 const char **sa)\n{\n    const char *s = *sa;\n    ap_errorlog_handler *handler;\n    int i;\n\n    if (*s != '%') {\n        if (*s == ' ') {\n            it->flags |= AP_ERRORLOG_FLAG_FIELD_SEP;\n        }\n        return parse_errorlog_misc_string(p, it, sa);\n    }\n\n    ++s;\n\n    if (*s == ' ') {\n        /* percent-space (% ) is a field separator */\n        it->flags |= AP_ERRORLOG_FLAG_FIELD_SEP;\n        *sa = ++s;\n        /* recurse */\n        return parse_errorlog_item(p, it, sa);\n    }\n    else if (*s == '%') {\n        it->arg = \"%\";\n        it->func = log_constant_item;\n        *sa = ++s;\n        return NULL;\n    }\n\n    while (*s) {\n        switch (*s) {\n        case '{':\n            ++s;\n            it->arg = ap_getword(p, &s, '}');\n            break;\n        case '+':\n            ++s;\n            it->flags |= AP_ERRORLOG_FLAG_REQUIRED;\n            break;\n        case '-':\n            ++s;\n            it->flags |= AP_ERRORLOG_FLAG_NULL_AS_HYPHEN;\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            i = *s - '0';\n            while (apr_isdigit(*++s))\n                i = i * 10 + (*s) - '0';\n            it->min_loglevel = i;\n            break;\n        case 'M':\n            it->func = NULL;\n            it->flags |= AP_ERRORLOG_FLAG_MESSAGE;\n            *sa = ++s;\n            return NULL;\n        default:\n            handler = (ap_errorlog_handler *)apr_hash_get(errorlog_hash, s, 1);\n            if (!handler) {\n                char dummy[2];\n\n                dummy[0] = *s;\n                dummy[1] = '\\0';\n                return apr_pstrcat(p, \"Unrecognized error log format directive %\",\n                               dummy, NULL);\n            }\n            it->func = handler->func;\n            *sa = ++s;\n            return NULL;\n        }\n    }\n\n    return \"Ran off end of error log format parsing args to some directive\";\n}\n\nstatic apr_array_header_t *parse_errorlog_string(apr_pool_t *p,\n                                                 const char *s,\n                                                 const char **err,\n                                                 int is_main_fmt)\n{\n    apr_array_header_t *a = apr_array_make(p, 30,\n                                           sizeof(ap_errorlog_format_item));\n    char *res;\n    int seen_msg_fmt = 0;\n\n    while (s && *s) {\n        ap_errorlog_format_item *item =\n            (ap_errorlog_format_item *)apr_array_push(a);\n        memset(item, 0, sizeof(*item));\n        res = parse_errorlog_item(p, item, &s);\n        if (res) {\n            *err = res;\n            return NULL;\n        }\n        if (item->flags & AP_ERRORLOG_FLAG_MESSAGE) {\n            if (!is_main_fmt) {\n                *err = \"%M cannot be used in once-per-request or \"\n                       \"once-per-connection formats\";\n                return NULL;\n            }\n            seen_msg_fmt = 1;\n        }\n        if (is_main_fmt && item->flags & AP_ERRORLOG_FLAG_REQUIRED) {\n            *err = \"The '+' flag cannot be used in the main error log format\";\n            return NULL;\n        }\n        if (!is_main_fmt && item->min_loglevel) {\n            *err = \"The loglevel cannot be used as a condition in \"\n                   \"once-per-request or once-per-connection formats\";\n            return NULL;\n        }\n        if (item->min_loglevel > APLOG_TRACE8) {\n            *err = \"The specified loglevel modifier is out of range\";\n            return NULL;\n        }\n    }\n\n    if (is_main_fmt && !seen_msg_fmt) {\n        *err = \"main ErrorLogFormat must contain message format string '%M'\";\n        return NULL;\n    }\n\n    return a;\n}\n\nstatic const char *set_errorlog(cmd_parms *cmd, void *dummy, const char *arg1,\n                                const char *arg2)\n{\n    ap_errorlog_provider *provider;\n    const char *err;\n    cmd->server->errorlog_provider = NULL;\n\n    if (!arg2) {\n        /* Stay backward compatible and check for \"syslog\" */\n        if (strncmp(\"syslog\", arg1, 6) == 0) {\n            arg2 = arg1 + 7; /* skip the ':' if any */\n            arg1 = \"syslog\";\n        }\n        else {\n            /* Admin can define only \"ErrorLog provider\" and we should \n             * still handle that using the defined provider, but with empty\n             * error_fname. */\n            provider = ap_lookup_provider(AP_ERRORLOG_PROVIDER_GROUP, arg1,\n                                          AP_ERRORLOG_PROVIDER_VERSION);\n            if (provider) {\n                arg2 = \"\";\n            }\n            else {\n                return set_server_string_slot(cmd, dummy, arg1);\n            }\n        }\n    }\n\n    if (strcmp(\"file\", arg1) == 0) {\n        return set_server_string_slot(cmd, dummy, arg2);\n    }\n\n    provider = ap_lookup_provider(AP_ERRORLOG_PROVIDER_GROUP, arg1,\n                                    AP_ERRORLOG_PROVIDER_VERSION);\n    if (!provider) {\n        return apr_psprintf(cmd->pool,\n                            \"Unknown ErrorLog provider: %s\",\n                            arg1);\n    }\n\n    err = provider->parse_errorlog_arg(cmd, arg2);\n    if (err) {\n        return err;\n    }\n\n    cmd->server->errorlog_provider = provider;\n    return set_server_string_slot(cmd, dummy, arg2);\n}\n\nstatic const char *set_errorlog_format(cmd_parms *cmd, void *dummy,\n                                       const char *arg1, const char *arg2)\n{\n    const char *err_string = NULL;\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n\n    if (!arg2) {\n        conf->error_log_format = parse_errorlog_string(cmd->pool, arg1,\n                                                       &err_string, 1);\n    }\n    else if (!ap_cstr_casecmp(arg1, \"connection\")) {\n        if (!conf->error_log_conn) {\n            conf->error_log_conn = apr_array_make(cmd->pool, 5,\n                                                  sizeof(apr_array_header_t *));\n        }\n\n        if (*arg2) {\n            apr_array_header_t **e;\n            e = (apr_array_header_t **) apr_array_push(conf->error_log_conn);\n            *e = parse_errorlog_string(cmd->pool, arg2, &err_string, 0);\n        }\n    }\n    else if (!ap_cstr_casecmp(arg1, \"request\")) {\n        if (!conf->error_log_req) {\n            conf->error_log_req = apr_array_make(cmd->pool, 5,\n                                                 sizeof(apr_array_header_t *));\n        }\n\n        if (*arg2) {\n            apr_array_header_t **e;\n            e = (apr_array_header_t **) apr_array_push(conf->error_log_req);\n            *e = parse_errorlog_string(cmd->pool, arg2, &err_string, 0);\n        }\n    }\n    else {\n        err_string = \"ErrorLogFormat type must be one of request, connection\";\n    }\n\n    return err_string;\n}\n\nAP_DECLARE(void) ap_register_errorlog_handler(apr_pool_t *p, char *tag,\n                                              ap_errorlog_handler_fn_t *handler,\n                                              int flags)\n{\n    ap_errorlog_handler *log_struct = apr_palloc(p, sizeof(*log_struct));\n    log_struct->func = handler;\n    log_struct->flags = flags;\n\n    apr_hash_set(errorlog_hash, tag, 1, (const void *)log_struct);\n}\n\n\nstatic const char *set_merge_trailers(cmd_parms *cmd, void *dummy, int arg)\n{\n    core_server_config *conf = ap_get_module_config(cmd->server->module_config,\n                                                    &core_module);\n    conf->merge_trailers = (arg ? AP_MERGE_TRAILERS_ENABLE :\n            AP_MERGE_TRAILERS_DISABLE);\n\n    return NULL;\n}\n\n/* Note --- ErrorDocument will now work from .htaccess files.\n * The AllowOverride of Fileinfo allows webmasters to turn it off\n */\n\nstatic const command_rec core_cmds[] = {\n\n/* Old access config file commands */\n\nAP_INIT_RAW_ARGS(\"<Directory\", dirsection, NULL, RSRC_CONF,\n  \"Container for directives affecting resources located in the specified \"\n  \"directories\"),\nAP_INIT_RAW_ARGS(\"<Location\", urlsection, NULL, RSRC_CONF,\n  \"Container for directives affecting resources accessed through the \"\n  \"specified URL paths\"),\nAP_INIT_RAW_ARGS(\"<VirtualHost\", virtualhost_section, NULL, RSRC_CONF,\n  \"Container to map directives to a particular virtual host, takes one or \"\n  \"more host addresses\"),\nAP_INIT_RAW_ARGS(\"<Files\", filesection, NULL, OR_ALL,\n  \"Container for directives affecting files matching specified patterns\"),\nAP_INIT_RAW_ARGS(\"<Limit\", ap_limit_section, NULL, OR_LIMIT | OR_AUTHCFG,\n  \"Container for authentication directives when accessed using specified HTTP \"\n  \"methods\"),\nAP_INIT_RAW_ARGS(\"<LimitExcept\", ap_limit_section, (void*)1,\n                 OR_LIMIT | OR_AUTHCFG,\n  \"Container for authentication directives to be applied when any HTTP \"\n  \"method other than those specified is used to access the resource\"),\nAP_INIT_RAW_ARGS(\"<IfModule\", start_cond_section, (void *)test_ifmod_section,\n              EXEC_ON_READ | OR_ALL,\n  \"Container for directives based on existence of specified modules\"),\nAP_INIT_RAW_ARGS(\"<IfDefine\", start_cond_section, (void *)test_ifdefine_section,\n              EXEC_ON_READ | OR_ALL,\n  \"Container for directives based on existence of command line defines\"),\nAP_INIT_RAW_ARGS(\"<IfFile\", start_cond_section, (void *)test_iffile_section,\n              EXEC_ON_READ | OR_ALL,\n  \"Container for directives based on existence of files on disk\"),\nAP_INIT_RAW_ARGS(\"<IfDirective\", start_cond_section, (void *)test_ifdirective_section,\n              EXEC_ON_READ | OR_ALL,\n  \"Container for directives based on existence of named directive\"),\nAP_INIT_RAW_ARGS(\"<IfSection\", start_cond_section, (void *)test_ifsection_section,\n              EXEC_ON_READ | OR_ALL,\n  \"Container for directives based on existence of named section\"),\nAP_INIT_RAW_ARGS(\"<DirectoryMatch\", dirsection, (void*)1, RSRC_CONF,\n  \"Container for directives affecting resources located in the \"\n  \"specified directories\"),\nAP_INIT_RAW_ARGS(\"<LocationMatch\", urlsection, (void*)1, RSRC_CONF,\n  \"Container for directives affecting resources accessed through the \"\n  \"specified URL paths\"),\nAP_INIT_RAW_ARGS(\"<FilesMatch\", filesection, (void*)1, OR_ALL,\n  \"Container for directives affecting files matching specified patterns\"),\n#ifdef GPROF\nAP_INIT_TAKE1(\"GprofDir\", set_gprof_dir, NULL, RSRC_CONF,\n  \"Directory to plop gmon.out files\"),\n#endif\nAP_INIT_TAKE1(\"AddDefaultCharset\", set_add_default_charset, NULL, OR_FILEINFO,\n  \"The name of the default charset to add to any Content-Type without one or 'Off' to disable\"),\nAP_INIT_TAKE1(\"AcceptPathInfo\", set_accept_path_info, NULL, OR_FILEINFO,\n  \"Set to on or off for PATH_INFO to be accepted by handlers, or default for the per-handler preference\"),\nAP_INIT_TAKE12(\"Define\", set_define, NULL, EXEC_ON_READ|RSRC_CONF,\n              \"Define a variable, optionally to a value.  Same as passing -D to the command line.\"),\nAP_INIT_TAKE1(\"UnDefine\", unset_define, NULL, EXEC_ON_READ|RSRC_CONF,\n              \"Undefine the existence of a variable. Undo a Define.\"),\nAP_INIT_RAW_ARGS(\"Error\", generate_message, (void*) APLOG_ERR, OR_ALL,\n                 \"Generate error message from within configuration.\"),\nAP_INIT_RAW_ARGS(\"Warning\", generate_message, (void*) APLOG_WARNING, OR_ALL,\n                 \"Generate warning message from within configuration.\"),\nAP_INIT_RAW_ARGS(\"<If\", ifsection, COND_IF, OR_ALL,\n  \"Container for directives to be conditionally applied\"),\nAP_INIT_RAW_ARGS(\"<ElseIf\", ifsection, COND_ELSEIF, OR_ALL,\n  \"Container for directives to be conditionally applied\"),\nAP_INIT_RAW_ARGS(\"<Else\", ifsection, COND_ELSE, OR_ALL,\n  \"Container for directives to be conditionally applied\"),\n\n/* Old resource config file commands */\n\nAP_INIT_RAW_ARGS(\"AccessFileName\", set_access_name, NULL, RSRC_CONF,\n  \"Name(s) of per-directory config files (default: .htaccess)\"),\nAP_INIT_TAKE1(\"DocumentRoot\", set_document_root, NULL, RSRC_CONF,\n  \"Root directory of the document tree\"),\nAP_INIT_TAKE2(\"ErrorDocument\", set_error_document, NULL, OR_FILEINFO,\n  \"Change responses for HTTP errors\"),\nAP_INIT_RAW_ARGS(\"AllowOverride\", set_override, NULL, ACCESS_CONF,\n  \"Controls what groups of directives can be configured by per-directory \"\n  \"config files\"),\nAP_INIT_TAKE_ARGV(\"AllowOverrideList\", set_override_list, NULL, ACCESS_CONF,\n  \"Controls what individual directives can be configured by per-directory \"\n  \"config files\"),\nAP_INIT_RAW_ARGS(\"Options\", set_options, NULL, OR_OPTIONS,\n  \"Set a number of attributes for a given directory\"),\nAP_INIT_TAKE1(\"DefaultType\", set_default_type, NULL, OR_FILEINFO,\n  \"the default media type for otherwise untyped files (DEPRECATED)\"),\nAP_INIT_RAW_ARGS(\"FileETag\", set_etag_bits, NULL, OR_FILEINFO,\n  \"Specify components used to construct a file's ETag\"),\nAP_INIT_TAKE1(\"EnableMMAP\", set_enable_mmap, NULL, OR_FILEINFO,\n  \"Controls whether memory-mapping may be used to read files\"),\nAP_INIT_TAKE1(\"EnableSendfile\", set_enable_sendfile, NULL, OR_FILEINFO,\n  \"Controls whether sendfile may be used to transmit files\"),\n\n/* Old server config file commands */\n\nAP_INIT_TAKE1(\"Protocol\", set_protocol, NULL, RSRC_CONF,\n  \"Set the Protocol for httpd to use.\"),\nAP_INIT_TAKE2(\"AcceptFilter\", set_accf_map, NULL, RSRC_CONF,\n  \"Set the Accept Filter to use for a protocol\"),\nAP_INIT_TAKE1(\"Port\", ap_set_deprecated, NULL, RSRC_CONF,\n  \"Port was replaced with Listen in Apache 2.0\"),\nAP_INIT_TAKE1(\"HostnameLookups\", set_hostname_lookups, NULL,\n  ACCESS_CONF|RSRC_CONF,\n  \"\\\"on\\\" to enable, \\\"off\\\" to disable reverse DNS lookups, or \\\"double\\\" to \"\n  \"enable double-reverse DNS lookups\"),\nAP_INIT_TAKE1(\"ServerAdmin\", set_server_string_slot,\n  (void *)APR_OFFSETOF(server_rec, server_admin), RSRC_CONF,\n  \"The email address of the server administrator\"),\nAP_INIT_TAKE1(\"ServerName\", server_hostname_port, NULL, RSRC_CONF,\n  \"The hostname and port of the server\"),\nAP_INIT_TAKE1(\"ServerSignature\", set_signature_flag, NULL, OR_ALL,\n  \"En-/disable server signature (on|off|email)\"),\nAP_INIT_TAKE1(\"ServerRoot\", set_server_root, NULL, RSRC_CONF | EXEC_ON_READ,\n  \"Common directory of server-related files (logs, confs, etc.)\"),\nAP_INIT_TAKE1(\"DefaultRuntimeDir\", set_runtime_dir, NULL, RSRC_CONF | EXEC_ON_READ,\n  \"Common directory for run-time files (shared memory, locks, etc.)\"),\nAP_INIT_TAKE12(\"ErrorLog\", set_errorlog,\n  (void *)APR_OFFSETOF(server_rec, error_fname), RSRC_CONF,\n  \"The filename of the error log\"),\nAP_INIT_TAKE12(\"ErrorLogFormat\", set_errorlog_format, NULL, RSRC_CONF,\n  \"Format string for the ErrorLog\"),\nAP_INIT_RAW_ARGS(\"ServerAlias\", set_server_alias, NULL, RSRC_CONF,\n  \"A name or names alternately used to access the server\"),\nAP_INIT_TAKE1(\"ServerPath\", set_serverpath, NULL, RSRC_CONF,\n  \"The pathname the server can be reached at\"),\nAP_INIT_TAKE1(\"Timeout\", set_timeout, NULL, RSRC_CONF,\n  \"Timeout duration (sec)\"),\nAP_INIT_FLAG(\"ContentDigest\", set_content_md5, NULL, OR_OPTIONS,\n  \"whether or not to send a Content-MD5 header with each request\"),\nAP_INIT_TAKE1(\"UseCanonicalName\", set_use_canonical_name, NULL,\n  RSRC_CONF|ACCESS_CONF,\n  \"How to work out the ServerName : Port when constructing URLs\"),\nAP_INIT_TAKE1(\"UseCanonicalPhysicalPort\", set_use_canonical_phys_port, NULL,\n  RSRC_CONF|ACCESS_CONF,\n  \"Whether to use the physical Port when constructing URLs\"),\n/* TODO: RlimitFoo should all be part of mod_cgi, not in the core */\n/* TODO: ListenBacklog in MPM */\nAP_INIT_TAKE1(\"Include\", include_config, NULL,\n  (RSRC_CONF | ACCESS_CONF | EXEC_ON_READ),\n  \"Name(s) of the config file(s) to be included; fails if the wildcard does \"\n  \"not match at least one file\"),\nAP_INIT_TAKE1(\"IncludeOptional\", include_config, (void*)1,\n  (RSRC_CONF | ACCESS_CONF | EXEC_ON_READ),\n  \"Name or pattern of the config file(s) to be included; ignored if the file \"\n  \"does not exist or the pattern does not match any files\"),\nAP_INIT_ITERATE(\"LogLevel\", set_loglevel, NULL, RSRC_CONF|ACCESS_CONF,\n  \"Level of verbosity in error logging\"),\nAP_INIT_TAKE_ARGV(\"LogLevelOverride\", set_loglevel_override, NULL, RSRC_CONF,\n  \"Override LogLevel for clients with certain IPs\"),\nAP_INIT_TAKE1(\"NameVirtualHost\", ap_set_name_virtual_host, NULL, RSRC_CONF,\n  \"A numeric IP address:port, or the name of a host\"),\nAP_INIT_TAKE1(\"ServerTokens\", set_serv_tokens, NULL, RSRC_CONF,\n  \"Determine tokens displayed in the Server: header - Min(imal), \"\n  \"Major, Minor, Prod(uctOnly), OS, or Full\"),\nAP_INIT_TAKE1(\"LimitRequestLine\", set_limit_req_line, NULL, RSRC_CONF,\n  \"Limit on maximum size of an HTTP request line\"),\nAP_INIT_TAKE1(\"LimitRequestFieldsize\", set_limit_req_fieldsize, NULL,\n  RSRC_CONF,\n  \"Limit on maximum size of an HTTP request header field\"),\nAP_INIT_TAKE1(\"LimitRequestFields\", set_limit_req_fields, NULL, RSRC_CONF,\n  \"Limit (0 = unlimited) on max number of header fields in a request message\"),\nAP_INIT_TAKE1(\"LimitRequestBody\", set_limit_req_body,\n  (void*)APR_OFFSETOF(core_dir_config, limit_req_body), OR_ALL,\n  \"Limit (in bytes) on maximum size of request message body\"),\nAP_INIT_TAKE1(\"LimitXMLRequestBody\", set_limit_xml_req_body, NULL, OR_ALL,\n              \"Limit (in bytes) on maximum size of an XML-based request \"\n              \"body\"),\nAP_INIT_RAW_ARGS(\"Mutex\", ap_set_mutex, NULL, RSRC_CONF,\n                 \"mutex (or \\\"default\\\") and mechanism\"),\n\nAP_INIT_TAKE1(\"MaxRanges\", set_max_ranges, NULL, RSRC_CONF|ACCESS_CONF,\n              \"Maximum number of Ranges in a request before returning the entire \"\n              \"resource, or 0 for unlimited\"),\nAP_INIT_TAKE1(\"MaxRangeOverlaps\", set_max_overlaps, NULL, RSRC_CONF|ACCESS_CONF,\n              \"Maximum number of overlaps in Ranges in a request before returning the entire \"\n              \"resource, or 0 for unlimited\"),\nAP_INIT_TAKE1(\"MaxRangeReversals\", set_max_reversals, NULL, RSRC_CONF|ACCESS_CONF,\n              \"Maximum number of reversals in Ranges in a request before returning the entire \"\n              \"resource, or 0 for unlimited\"),\n/* System Resource Controls */\n#ifdef RLIMIT_CPU\nAP_INIT_TAKE12(\"RLimitCPU\", set_limit_cpu,\n  (void*)APR_OFFSETOF(core_dir_config, limit_cpu),\n  OR_ALL, \"Soft/hard limits for max CPU usage in seconds\"),\n#else\nAP_INIT_TAKE12(\"RLimitCPU\", no_set_limit, NULL,\n  OR_ALL, \"Soft/hard limits for max CPU usage in seconds\"),\n#endif\n#if defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined (RLIMIT_AS)\nAP_INIT_TAKE12(\"RLimitMEM\", set_limit_mem,\n  (void*)APR_OFFSETOF(core_dir_config, limit_mem),\n  OR_ALL, \"Soft/hard limits for max memory usage per process\"),\n#else\nAP_INIT_TAKE12(\"RLimitMEM\", no_set_limit, NULL,\n  OR_ALL, \"Soft/hard limits for max memory usage per process\"),\n#endif\n#ifdef RLIMIT_NPROC\nAP_INIT_TAKE12(\"RLimitNPROC\", set_limit_nproc,\n  (void*)APR_OFFSETOF(core_dir_config, limit_nproc),\n  OR_ALL, \"soft/hard limits for max number of processes per uid\"),\n#else\nAP_INIT_TAKE12(\"RLimitNPROC\", no_set_limit, NULL,\n   OR_ALL, \"soft/hard limits for max number of processes per uid\"),\n#endif\n\n/* internal recursion stopper */\nAP_INIT_TAKE12(\"LimitInternalRecursion\", set_recursion_limit, NULL, RSRC_CONF,\n              \"maximum recursion depth of internal redirects and subrequests\"),\n\nAP_INIT_FLAG(\"CGIPassAuth\", set_cgi_pass_auth, NULL, OR_AUTHCFG,\n             \"Controls whether HTTP authorization headers, normally hidden, will \"\n             \"be passed to scripts\"),\nAP_INIT_TAKE2(\"CGIVar\", set_cgi_var, NULL, OR_FILEINFO,\n              \"Controls how some CGI variables are set\"),\nAP_INIT_FLAG(\"QualifyRedirectURL\", set_qualify_redirect_url, NULL, OR_FILEINFO,\n             \"Controls whether the REDIRECT_URL environment variable is fully \"\n             \"qualified\"),\n\nAP_INIT_TAKE1(\"ForceType\", ap_set_string_slot_lower,\n       (void *)APR_OFFSETOF(core_dir_config, mime_type), OR_FILEINFO,\n     \"a mime type that overrides other configured type\"),\nAP_INIT_TAKE1(\"SetHandler\", set_sethandler, NULL, OR_FILEINFO,\n   \"a handler name that overrides any other configured handler\"),\nAP_INIT_TAKE1(\"SetOutputFilter\", ap_set_string_slot,\n       (void *)APR_OFFSETOF(core_dir_config, output_filters), OR_FILEINFO,\n   \"filter (or ; delimited list of filters) to be run on the request content\"),\nAP_INIT_TAKE1(\"SetInputFilter\", ap_set_string_slot,\n       (void *)APR_OFFSETOF(core_dir_config, input_filters), OR_FILEINFO,\n   \"filter (or ; delimited list of filters) to be run on the request body\"),\nAP_INIT_TAKE1(\"AllowEncodedSlashes\", set_allow2f, NULL, RSRC_CONF,\n             \"Allow URLs containing '/' encoded as '%2F'\"),\n\n/* scoreboard.c directives */\nAP_INIT_TAKE1(\"ScoreBoardFile\", ap_set_scoreboard, NULL, RSRC_CONF,\n              \"A file for Apache to maintain runtime process management information\"),\nAP_INIT_FLAG(\"ExtendedStatus\", ap_set_extended_status, NULL, RSRC_CONF,\n             \"\\\"On\\\" to track extended status information, \\\"Off\\\" to disable\"),\nAP_INIT_FLAG(\"SeeRequestTail\", ap_set_reqtail, NULL, RSRC_CONF,\n             \"For extended status, \\\"On\\\" to see the last 63 chars of \"\n             \"the request line, \\\"Off\\\" (default) to see the first 63\"),\n\n/*\n * These are default configuration directives that mpms can/should\n * pay attention to.\n * XXX These are not for all platforms, and even some Unix MPMs might not want\n * some directives.\n */\nAP_INIT_TAKE1(\"PidFile\",  ap_mpm_set_pidfile, NULL, RSRC_CONF,\n              \"A file for logging the server process ID\"),\nAP_INIT_TAKE1(\"MaxRequestsPerChild\", ap_mpm_set_max_requests, NULL, RSRC_CONF,\n              \"Maximum number of connections a particular child serves before \"\n              \"dying. (DEPRECATED, use MaxConnectionsPerChild)\"),\nAP_INIT_TAKE1(\"MaxConnectionsPerChild\", ap_mpm_set_max_requests, NULL, RSRC_CONF,\n              \"Maximum number of connections a particular child serves before dying.\"),\nAP_INIT_TAKE1(\"CoreDumpDirectory\", ap_mpm_set_coredumpdir, NULL, RSRC_CONF,\n              \"The location of the directory Apache changes to before dumping core\"),\nAP_INIT_TAKE1(\"MaxMemFree\", ap_mpm_set_max_mem_free, NULL, RSRC_CONF,\n              \"Maximum number of 1k blocks a particular child's allocator may hold.\"),\nAP_INIT_TAKE1(\"ThreadStackSize\", ap_mpm_set_thread_stacksize, NULL, RSRC_CONF,\n              \"Size in bytes of stack used by threads handling client connections\"),\n#if AP_ENABLE_EXCEPTION_HOOK\nAP_INIT_TAKE1(\"EnableExceptionHook\", ap_mpm_set_exception_hook, NULL, RSRC_CONF,\n              \"Controls whether exception hook may be called after a crash\"),\n#endif\nAP_INIT_TAKE1(\"TraceEnable\", set_trace_enable, NULL, RSRC_CONF,\n              \"'on' (default), 'off' or 'extended' to trace request body content\"),\nAP_INIT_FLAG(\"MergeTrailers\", set_merge_trailers, NULL, RSRC_CONF,\n              \"merge request trailers into request headers or not\"),\nAP_INIT_ITERATE(\"HttpProtocolOptions\", set_http_protocol_options, NULL, RSRC_CONF,\n                \"'Allow0.9' or 'Require1.0' (default); \"\n                \"'RegisteredMethods' or 'LenientMethods' (default); \"\n                \"'Unsafe' or 'Strict' (default). Sets HTTP acceptance rules\"),\nAP_INIT_ITERATE(\"RegisterHttpMethod\", set_http_method, NULL, RSRC_CONF,\n                \"Registers non-standard HTTP methods\"),\nAP_INIT_FLAG(\"HttpContentLengthHeadZero\", set_cl_head_zero, NULL, OR_OPTIONS,\n  \"whether to permit Content-Length of 0 responses to HEAD requests\"),\nAP_INIT_FLAG(\"HttpExpectStrict\", set_expect_strict, NULL, OR_OPTIONS,\n  \"whether to return a 417 if a client doesn't send 100-Continue\"),\nAP_INIT_ITERATE(\"Protocols\", set_protocols, NULL, RSRC_CONF,\n                \"Controls which protocols are allowed\"),\nAP_INIT_TAKE1(\"ProtocolsHonorOrder\", set_protocols_honor_order, NULL, RSRC_CONF,\n              \"'off' (default) or 'on' to respect given order of protocols, \"\n              \"by default the client specified order determines selection\"),\nAP_INIT_TAKE1(\"AsyncFilter\", set_async_filter, NULL, RSRC_CONF,\n              \"'network', 'connection' (default) or 'request' to limit the \"\n              \"types of filters that support asynchronous handling\"),\n{ NULL }\n};\n\n/*****************************************************************\n *\n * Core handlers for various phases of server operation...\n */\n\nAP_DECLARE_NONSTD(int) ap_core_translate(request_rec *r)\n{\n    apr_status_t rv;\n    char *path;\n\n    /* XXX this seems too specific, this should probably become\n     * some general-case test\n     */\n    if (r->proxyreq) {\n        return HTTP_FORBIDDEN;\n    }\n    if (!r->uri || ((r->uri[0] != '/') && strcmp(r->uri, \"*\"))) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00126)\n                     \"Invalid URI in request '%s' '%s'\", r->uri, r->the_request);\n        return HTTP_BAD_REQUEST;\n    }\n\n    if (r->server->path\n        && !strncmp(r->uri, r->server->path, r->server->pathlen)\n        && (r->server->path[r->server->pathlen - 1] == '/'\n            || r->uri[r->server->pathlen] == '/'\n            || r->uri[r->server->pathlen] == '\\0'))\n    {\n        path = r->uri + r->server->pathlen;\n    }\n    else {\n        path = r->uri;\n    }\n    /*\n     * Make sure that we do not mess up the translation by adding two\n     * /'s in a row.  This happens under windows when the document\n     * root ends with a /\n     */\n    /* skip all leading /'s (e.g. http://localhost///foo)\n     * so we are looking at only the relative path.\n     */\n    while (*path == '/') {\n        ++path;\n    }\n    if ((rv = apr_filepath_merge(&r->filename, ap_document_root(r), path,\n                                 APR_FILEPATH_TRUENAME\n                               | APR_FILEPATH_SECUREROOT, r->pool))\n                != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00127)\n                     \"Cannot map %s to file\", r->the_request);\n        return HTTP_FORBIDDEN;\n    }\n    r->canonical_filename = r->filename;\n\n    return OK;\n}\n\n/*****************************************************************\n *\n * Test the filesystem name through directory_walk and file_walk\n */\nstatic int core_map_to_storage(request_rec *r)\n{\n    int access_status;\n\n    if ((access_status = ap_directory_walk(r))) {\n        return access_status;\n    }\n\n    if ((access_status = ap_file_walk(r))) {\n        return access_status;\n    }\n\n    return OK;\n}\n\n\nstatic int do_nothing(request_rec *r) { return OK; }\n\nstatic int core_override_type(request_rec *r)\n{\n    core_dir_config *conf =\n        (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n\n    /* Check for overrides with ForceType / SetHandler\n     */\n    if (conf->mime_type && strcmp(conf->mime_type, \"none\"))\n        ap_set_content_type(r, (char*) conf->mime_type);\n\n    if (conf->expr_handler) { \n        const char *err;\n        const char *val;\n        val = ap_expr_str_exec(r, conf->expr_handler, &err);\n        if (err) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(03154)\n                          \"Can't evaluate handler expression: %s\", err);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        if (val != ap_strstr_c(val, \"proxy:unix\")) { \n            /* Retained for compatibility --  but not for UDS */\n            char *tmp = apr_pstrdup(r->pool, val);\n            ap_str_tolower(tmp);\n            val = tmp;\n        }\n\n        if (strcmp(val, \"none\")) { \n            r->handler = val;\n        }\n    }\n    else if (conf->handler && strcmp(conf->handler, \"none\")) { \n        r->handler = conf->handler;\n    }\n\n    /* Deal with the poor soul who is trying to force path_info to be\n     * accepted within the core_handler, where they will let the subreq\n     * address its contents.  This is toggled by the user in the very\n     * beginning of the fixup phase (here!), so modules should override the user's\n     * discretion in their own module fixup phase.  It is tristate, if\n     * the user doesn't specify, the result is AP_REQ_DEFAULT_PATH_INFO.\n     * (which the module may interpret to its own customary behavior.)\n     * It won't be touched if the value is no longer AP_ACCEPT_PATHINFO_UNSET,\n     * so any module changing the value prior to the fixup phase\n     * OVERRIDES the user's choice.\n     */\n    if ((r->used_path_info == AP_REQ_DEFAULT_PATH_INFO)\n        && (conf->accept_path_info != AP_ACCEPT_PATHINFO_UNSET)) {\n        /* No module knew better, and the user coded AcceptPathInfo */\n        r->used_path_info = conf->accept_path_info;\n    }\n\n    return OK;\n}\n\nstatic int default_handler(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    apr_bucket_brigade *bb;\n    apr_bucket *e;\n    core_dir_config *d;\n    int errstatus;\n    apr_file_t *fd = NULL;\n    apr_status_t status;\n    /* XXX if/when somebody writes a content-md5 filter we either need to\n     *     remove this support or coordinate when to use the filter vs.\n     *     when to use this code\n     *     The current choice of when to compute the md5 here matches the 1.3\n     *     support fairly closely (unlike 1.3, we don't handle computing md5\n     *     when the charset is translated).\n     */\n    int bld_content_md5;\n\n    d = (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n    bld_content_md5 = (d->content_md5 == AP_CONTENT_MD5_ON)\n                      && r->output_filters->frec->ftype != AP_FTYPE_RESOURCE;\n\n    ap_allow_standard_methods(r, MERGE_ALLOW, M_GET, M_OPTIONS, M_POST, -1);\n\n    /* If filters intend to consume the request body, they must\n     * register an InputFilter to slurp the contents of the POST\n     * data from the POST input stream.  It no longer exists when\n     * the output filters are invoked by the default handler.\n     */\n    if ((errstatus = ap_discard_request_body(r)) != OK) {\n        return errstatus;\n    }\n\n    if (r->method_number == M_GET || r->method_number == M_POST) {\n        if (r->finfo.filetype == APR_NOFILE) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00128)\n                          \"File does not exist: %s\",\n                          apr_pstrcat(r->pool, r->filename, r->path_info, NULL));\n            return HTTP_NOT_FOUND;\n        }\n\n        /* Don't try to serve a dir.  Some OSs do weird things with\n         * raw I/O on a dir.\n         */\n        if (r->finfo.filetype == APR_DIR) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00129)\n                          \"Attempt to serve directory: %s\", r->filename);\n            return HTTP_NOT_FOUND;\n        }\n\n        if ((r->used_path_info != AP_REQ_ACCEPT_PATH_INFO) &&\n            r->path_info && *r->path_info)\n        {\n            /* default to reject */\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00130)\n                          \"File does not exist: %s\",\n                          apr_pstrcat(r->pool, r->filename, r->path_info, NULL));\n            return HTTP_NOT_FOUND;\n        }\n\n        /* We understood the (non-GET) method, but it might not be legal for\n           this particular resource. Check to see if the 'deliver_script'\n           flag is set. If so, then we go ahead and deliver the file since\n           it isn't really content (only GET normally returns content).\n\n           Note: based on logic further above, the only possible non-GET\n           method at this point is POST. In the future, we should enable\n           script delivery for all methods.  */\n        if (r->method_number != M_GET) {\n            core_request_config *req_cfg;\n\n            req_cfg = ap_get_core_module_config(r->request_config);\n            if (!req_cfg->deliver_script) {\n                /* The flag hasn't been set for this request. Punt. */\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00131)\n                              \"This resource does not accept the %s method.\",\n                              r->method);\n                return HTTP_METHOD_NOT_ALLOWED;\n            }\n        }\n\n\n        if ((status = apr_file_open(&fd, r->filename, APR_READ | APR_BINARY\n#if APR_HAS_SENDFILE\n                            | AP_SENDFILE_ENABLED(d->enable_sendfile)\n#endif\n                                    , 0, r->pool)) != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00132)\n                          \"file permissions deny server access: %s\", r->filename);\n            return HTTP_FORBIDDEN;\n        }\n\n        ap_update_mtime(r, r->finfo.mtime);\n        ap_set_last_modified(r);\n        ap_set_etag(r);\n        ap_set_accept_ranges(r);\n        ap_set_content_length(r, r->finfo.size);\n        if (bld_content_md5) {\n            apr_table_setn(r->headers_out, \"Content-MD5\",\n                           ap_md5digest(r->pool, fd));\n        }\n\n        bb = apr_brigade_create(r->pool, c->bucket_alloc);\n\n        if ((errstatus = ap_meets_conditions(r)) != OK) {\n            apr_file_close(fd);\n            r->status = errstatus;\n        }\n        else {\n            e = apr_brigade_insert_file(bb, fd, 0, r->finfo.size, r->pool);\n\n#if APR_HAS_MMAP\n            if (d->enable_mmap == ENABLE_MMAP_OFF) {\n                (void)apr_bucket_file_enable_mmap(e, 0);\n            }\n#endif\n        }\n\n        e = apr_bucket_eos_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n\n        status = ap_pass_brigade(r->output_filters, bb);\n        apr_brigade_cleanup(bb);\n\n        if (status == APR_SUCCESS\n            || r->status != HTTP_OK\n            || c->aborted) {\n            return OK;\n        }\n        else {\n            /* no way to know what type of error occurred */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00133)\n                          \"default_handler: ap_pass_brigade returned %i\",\n                          status);\n            return AP_FILTER_ERROR;\n        }\n    }\n    else {              /* unusual method (not GET or POST) */\n        if (r->method_number == M_INVALID) {\n            /* See if this looks like an undecrypted SSL handshake attempt.\n             * It's safe to look a couple bytes into the_request if it exists, as it's\n             * always allocated at least MIN_LINE_ALLOC (80) bytes.\n             */\n            if (r->the_request\n                && r->the_request[0] == 0x16\n                && (r->the_request[1] == 0x2 || r->the_request[1] == 0x3)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00134)\n                              \"Invalid method in request %s - possible attempt to establish SSL connection on non-SSL port\", r->the_request);\n            } else {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00135)\n                              \"Invalid method in request %s\", r->the_request);\n            }\n            return HTTP_NOT_IMPLEMENTED;\n        }\n\n        if (r->method_number == M_OPTIONS) {\n            return ap_send_http_options(r);\n        }\n        return HTTP_METHOD_NOT_ALLOWED;\n    }\n}\n\n/* Optional function coming from mod_logio, used for logging of output\n * traffic\n */\nAPR_OPTIONAL_FN_TYPE(ap_logio_add_bytes_out) *ap__logio_add_bytes_out;\nAPR_OPTIONAL_FN_TYPE(authz_some_auth_required) *ap__authz_ap_some_auth_required;\n\n/* Insist that at least one module will undertake to provide system\n * security by dropping startup privileges.\n */\nstatic int sys_privileges = 0;\nAP_DECLARE(int) ap_sys_privileges_handlers(int inc)\n{\n    sys_privileges += inc;\n    return sys_privileges;\n}\n\nstatic int check_errorlog_dir(apr_pool_t *p, server_rec *s)\n{\n    if (!s->error_fname || s->error_fname[0] == '|'\n        || s->errorlog_provider != NULL) {\n        return APR_SUCCESS;\n    }\n    else {\n        char *abs = ap_server_root_relative(p, s->error_fname);\n        char *dir = ap_make_dirstr_parent(p, abs);\n        apr_finfo_t finfo;\n        apr_status_t rv = apr_stat(&finfo, dir, APR_FINFO_TYPE, p);\n        if (rv == APR_SUCCESS && finfo.filetype != APR_DIR)\n            rv = APR_ENOTDIR;\n        if (rv != APR_SUCCESS) {\n            const char *desc = \"main error log\";\n            if (s->defn_name)\n                desc = apr_psprintf(p, \"error log of vhost defined at %s:%d\",\n                                    s->defn_name, s->defn_line_number);\n            ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_EMERG, rv,\n                          ap_server_conf, APLOGNO(02291)\n                         \"Cannot access directory '%s' for %s\", dir, desc);\n            return !OK;\n        }\n    }\n    return OK;\n}\n\nstatic int core_check_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)\n{\n    int rv = OK;\n    while (s) {\n        if (check_errorlog_dir(ptemp, s) != OK)\n            rv = !OK;\n        s = s->next;\n    }\n    return rv;\n}\n\n\nstatic int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)\n{\n    ap_mutex_init(pconf);\n\n    if (!saved_server_config_defines)\n        init_config_defines(pconf);\n    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,\n                              apr_pool_cleanup_null);\n\n    mpm_common_pre_config(pconf);\n\n    return OK;\n}\n\nstatic int core_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)\n{\n    ap__logio_add_bytes_out = APR_RETRIEVE_OPTIONAL_FN(ap_logio_add_bytes_out);\n    ident_lookup = APR_RETRIEVE_OPTIONAL_FN(ap_ident_lookup);\n    ap__authz_ap_some_auth_required = APR_RETRIEVE_OPTIONAL_FN(authz_some_auth_required);\n    authn_ap_auth_type = APR_RETRIEVE_OPTIONAL_FN(authn_ap_auth_type);\n    authn_ap_auth_name = APR_RETRIEVE_OPTIONAL_FN(authn_ap_auth_name);\n    access_compat_ap_satisfies = APR_RETRIEVE_OPTIONAL_FN(access_compat_ap_satisfies);\n\n    set_banner(pconf);\n    ap_setup_make_content_type(pconf);\n    ap_setup_auth_internal(ptemp);\n    if (!sys_privileges) {\n        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, NULL, APLOGNO(00136)\n                     \"Server MUST relinquish startup privileges before \"\n                     \"accepting connections.  Please ensure mod_unixd \"\n                     \"or other system security module is loaded.\");\n        return !OK;\n    }\n    apr_pool_cleanup_register(pconf, NULL, ap_mpm_end_gen_helper,\n                              apr_pool_cleanup_null);\n    return OK;\n}\n\nstatic void core_insert_filter(request_rec *r)\n{\n    core_dir_config *conf = (core_dir_config *)\n                            ap_get_core_module_config(r->per_dir_config);\n    const char *filter, *filters = conf->output_filters;\n\n    if (filters) {\n        while (*filters && (filter = ap_getword(r->pool, &filters, ';'))) {\n            ap_add_output_filter(filter, NULL, r, r->connection);\n        }\n    }\n\n    filters = conf->input_filters;\n    if (filters) {\n        while (*filters && (filter = ap_getword(r->pool, &filters, ';'))) {\n            ap_add_input_filter(filter, NULL, r, r->connection);\n        }\n    }\n}\n\nstatic apr_size_t num_request_notes = AP_NUM_STD_NOTES;\n\nstatic apr_status_t reset_request_notes(void *dummy)\n{\n    num_request_notes = AP_NUM_STD_NOTES;\n    return APR_SUCCESS;\n}\n\nAP_DECLARE(apr_size_t) ap_register_request_note(void)\n{\n    apr_pool_cleanup_register(apr_hook_global_pool, NULL, reset_request_notes,\n                              apr_pool_cleanup_null);\n    return num_request_notes++;\n}\n\nAP_DECLARE(void **) ap_get_request_note(request_rec *r, apr_size_t note_num)\n{\n    core_request_config *req_cfg;\n\n    if (note_num >= num_request_notes) {\n        return NULL;\n    }\n\n    req_cfg = (core_request_config *)\n        ap_get_core_module_config(r->request_config);\n\n    if (!req_cfg) {\n        return NULL;\n    }\n\n    return &(req_cfg->notes[note_num]);\n}\n\nAP_DECLARE(apr_socket_t *) ap_get_conn_socket(conn_rec *c)\n{\n    return ap_get_core_module_config(c->conn_config);\n}\n\nstatic int core_create_req(request_rec *r)\n{\n    /* Alloc the config struct and the array of request notes in\n     * a single block for efficiency\n     */\n    core_request_config *req_cfg;\n\n    req_cfg = apr_pcalloc(r->pool, sizeof(core_request_config) +\n                          sizeof(void *) * num_request_notes);\n    req_cfg->notes = (void **)((char *)req_cfg + sizeof(core_request_config));\n\n    /* ### temporarily enable script delivery as the default */\n    req_cfg->deliver_script = 1;\n\n    if (r->main) {\n        core_request_config *main_req_cfg = (core_request_config *)\n            ap_get_core_module_config(r->main->request_config);\n        req_cfg->bb = main_req_cfg->bb;\n    }\n    else {\n        req_cfg->bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    }\n\n    ap_set_core_module_config(r->request_config, req_cfg);\n\n    return OK;\n}\n\nstatic int core_create_proxy_req(request_rec *r, request_rec *pr)\n{\n    return core_create_req(pr);\n}\n\nstatic conn_rec *core_create_conn(apr_pool_t *ptrans, server_rec *s,\n                                  apr_socket_t *csd, long id, void *sbh,\n                                  apr_bucket_alloc_t *alloc)\n{\n    apr_status_t rv;\n    apr_pool_t *pool;\n    conn_rec *c = (conn_rec *) apr_pcalloc(ptrans, sizeof(conn_rec));\n    core_server_config *sconf = ap_get_core_module_config(s->module_config);\n\n    c->sbh = sbh;\n    ap_update_child_status(c->sbh, SERVER_BUSY_READ, NULL);\n\n    /* Got a connection structure, so initialize what fields we can\n     * (the rest are zeroed out by pcalloc).\n     */\n    apr_pool_create(&pool, ptrans);\n    apr_pool_tag(pool, \"master_conn\");\n    c->pool = pool;\n\n    c->conn_config = ap_create_conn_config(c->pool);\n    c->notes = apr_table_make(c->pool, 5);\n    c->slaves = apr_array_make(c->pool, 20, sizeof(conn_slave_rec *));\n    c->requests = apr_array_make(c->pool, 20, sizeof(request_rec *));\n\n\n    if ((rv = apr_socket_addr_get(&c->local_addr, APR_LOCAL, csd))\n        != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_INFO, rv, s, APLOGNO(00137)\n                     \"apr_socket_addr_get(APR_LOCAL)\");\n        apr_socket_close(csd);\n        return NULL;\n    }\n\n    apr_sockaddr_ip_get(&c->local_ip, c->local_addr);\n    if ((rv = apr_socket_addr_get(&c->client_addr, APR_REMOTE, csd))\n        != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_INFO, rv, s, APLOGNO(00138)\n                     \"apr_socket_addr_get(APR_REMOTE)\");\n        apr_socket_close(csd);\n        return NULL;\n    }\n\n    apr_sockaddr_ip_get(&c->client_ip, c->client_addr);\n    c->base_server = s;\n\n    c->id = id;\n    c->bucket_alloc = alloc;\n    c->empty = apr_brigade_create(c->pool, c->bucket_alloc);\n    c->filters = apr_hash_make(c->pool);\n    c->async_filter = sconf->async_filter;\n\n    c->clogging_input_filters = 0;\n\n    if (sconf->conn_log_level) {\n        int i;\n        conn_log_config *conf;\n        const struct ap_logconf *log = NULL;\n        struct ap_logconf *merged;\n\n        for (i = 0; i < sconf->conn_log_level->nelts; i++) {\n            conf = APR_ARRAY_IDX(sconf->conn_log_level, i, conn_log_config *);\n            if (apr_ipsubnet_test(conf->subnet, c->client_addr))\n                log = &conf->log;\n        }\n        if (log) {\n            merged = ap_new_log_config(c->pool, log);\n            ap_merge_log_config(&s->log, merged);\n            c->log = merged;\n        }\n    }\n\n    return c;\n}\n\nstatic int core_pre_connection(conn_rec *c, void *csd)\n{\n    core_net_rec *net;\n    apr_status_t rv;\n\n    if (c->master) {\n        return DONE;\n    }\n    \n    net = apr_palloc(c->pool, sizeof(*net));\n    /* The Nagle algorithm says that we should delay sending partial\n     * packets in hopes of getting more data.  We don't want to do\n     * this; we are not telnet.  There are bad interactions between\n     * persistent connections and Nagle's algorithm that have very severe\n     * performance penalties.  (Failing to disable Nagle is not much of a\n     * problem with simple HTTP.)\n     */\n    rv = apr_socket_opt_set(csd, APR_TCP_NODELAY, 1);\n    if (rv != APR_SUCCESS && rv != APR_ENOTIMPL) {\n        /* expected cause is that the client disconnected already,\n         * hence the debug level\n         */\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(00139)\n                      \"apr_socket_opt_set(APR_TCP_NODELAY)\");\n    }\n\n    /* The core filter requires the timeout mode to be set, which\n     * incidentally sets the socket to be nonblocking.  If this\n     * is not initialized correctly, Linux - for example - will\n     * be initially blocking, while Solaris will be non blocking\n     * and any initial read will fail.\n     */\n    rv = apr_socket_timeout_set(csd, c->base_server->timeout);\n    if (rv != APR_SUCCESS) {\n        /* expected cause is that the client disconnected already */\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(00140)\n                      \"apr_socket_timeout_set\");\n    }\n\n    net->c = c;\n    net->in_ctx = NULL;\n    net->out_ctx = NULL;\n    net->client_socket = csd;\n\n    ap_set_core_module_config(net->c->conn_config, csd);\n    /* only the master connection talks to the network */\n    if (c->master == NULL) {\n        ap_add_input_filter_handle(ap_core_input_filter_handle, net, NULL,\n                                   net->c);\n        ap_add_output_filter_handle(ap_core_output_filter_handle, net, NULL,\n                                    net->c);\n    }\n    return DONE;\n}\n\nAP_CORE_DECLARE(conn_rec *) ap_create_slave_connection(conn_rec *c)\n{\n    apr_pool_t *pool;\n    conn_slave_rec *new;\n    conn_rec *sc = (conn_rec *) apr_palloc(c->pool, sizeof(conn_rec));\n\n    apr_pool_create(&pool, c->pool);\n    apr_pool_tag(pool, \"slave_conn\");\n    memcpy(sc, c, sizeof(conn_rec));\n    sc->slaves = NULL;\n    sc->master = c;\n    sc->input_filters = NULL;\n    sc->output_filters = NULL;\n    sc->pool = pool;\n    new = apr_array_push(c->slaves);\n    new->c = sc;\n    return sc;\n}\n\nAP_DECLARE(int) ap_state_query(int query)\n{\n    switch (query) {\n    case AP_SQ_MAIN_STATE:\n        return ap_main_state;\n    case AP_SQ_RUN_MODE:\n        return ap_run_mode;\n    case AP_SQ_CONFIG_GEN:\n        return ap_config_generation;\n    default:\n        return AP_SQ_NOT_SUPPORTED;\n    }\n}\n\nstatic apr_random_t *rng = NULL;\n#if APR_HAS_THREADS\nstatic apr_thread_mutex_t *rng_mutex = NULL;\n#endif\n\nstatic void core_child_init(apr_pool_t *pchild, server_rec *s)\n{\n    apr_proc_t proc;\n#if APR_HAS_THREADS\n    int threaded_mpm;\n    if (ap_mpm_query(AP_MPMQ_IS_THREADED, &threaded_mpm) == APR_SUCCESS\n        && threaded_mpm)\n    {\n        apr_thread_mutex_create(&rng_mutex, APR_THREAD_MUTEX_DEFAULT, pchild);\n    }\n#endif\n    /* The MPMs use plain fork() and not apr_proc_fork(), so we have to call\n     * apr_random_after_fork() manually in the child\n     */\n    proc.pid = getpid();\n    apr_random_after_fork(&proc);\n}\n\nstatic void core_optional_fn_retrieve(void)\n{\n    ap_init_scoreboard(NULL);\n}\n\nAP_CORE_DECLARE(void) ap_random_parent_after_fork(void)\n{\n    /*\n     * To ensure that the RNG state in the parent changes after the fork, we\n     * pull some data from the RNG and discard it. This ensures that the RNG\n     * states in the children are different even after the pid wraps around.\n     * As we only use apr_random for insecure random bytes, pulling 2 bytes\n     * should be enough.\n     * XXX: APR should probably have some dedicated API to do this, but it\n     * XXX: currently doesn't.\n     */\n    apr_uint16_t data;\n    apr_random_insecure_bytes(rng, &data, sizeof(data));\n}\n\nAP_CORE_DECLARE(void) ap_init_rng(apr_pool_t *p)\n{\n    unsigned char seed[8];\n    apr_status_t rv;\n    rng = apr_random_standard_new(p);\n    do {\n        rv = apr_generate_random_bytes(seed, sizeof(seed));\n        if (rv != APR_SUCCESS)\n            goto error;\n        apr_random_add_entropy(rng, seed, sizeof(seed));\n        rv = apr_random_insecure_ready(rng);\n    } while (rv == APR_ENOTENOUGHENTROPY);\n    if (rv == APR_SUCCESS)\n        return;\nerror:\n    ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00141)\n                 \"Could not initialize random number generator\");\n    exit(1);\n}\n\nAP_DECLARE(void) ap_random_insecure_bytes(void *buf, apr_size_t size)\n{\n#if APR_HAS_THREADS\n    if (rng_mutex)\n        apr_thread_mutex_lock(rng_mutex);\n#endif\n    /* apr_random_insecure_bytes can only fail with APR_ENOTENOUGHENTROPY,\n     * and we have ruled that out during initialization. Therefore we don't\n     * need to check the return code.\n     */\n    apr_random_insecure_bytes(rng, buf, size);\n#if APR_HAS_THREADS\n    if (rng_mutex)\n        apr_thread_mutex_unlock(rng_mutex);\n#endif\n}\n\n/*\n * Finding a random number in a range.\n *      n' = a + n(b-a+1)/(M+1)\n * where:\n *      n' = random number in range\n *      a  = low end of range\n *      b  = high end of range\n *      n  = random number of 0..M\n *      M  = maxint\n * Algorithm 'borrowed' from PHP's rand() function.\n */\n#define RAND_RANGE(__n, __min, __max, __tmax) \\\n(__n) = (__min) + (long) ((double) ((__max) - (__min) + 1.0) * ((__n) / ((__tmax) + 1.0)))\nAP_DECLARE(apr_uint32_t) ap_random_pick(apr_uint32_t min, apr_uint32_t max)\n{\n    apr_uint32_t number;\n#if (!__GNUC__ || __GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8) || \\\n     !__sparc__ || APR_SIZEOF_VOIDP != 8)\n    /* This triggers a gcc bug on sparc/64bit with gcc < 4.8, PR 52900 */\n    if (max < 16384) {\n        apr_uint16_t num16;\n        ap_random_insecure_bytes(&num16, sizeof(num16));\n        RAND_RANGE(num16, min, max, APR_UINT16_MAX);\n        number = num16;\n    }\n    else\n#endif\n    {\n        ap_random_insecure_bytes(&number, sizeof(number));\n        RAND_RANGE(number, min, max, APR_UINT32_MAX);\n    }\n    return number;\n}\n\nstatic apr_status_t core_insert_network_bucket(conn_rec *c,\n                                               apr_bucket_brigade *bb,\n                                               apr_socket_t *socket)\n{\n    apr_bucket *e = apr_bucket_socket_create(socket, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, e);\n    return APR_SUCCESS;\n}\n\nstatic apr_status_t core_dirwalk_stat(apr_finfo_t *finfo, request_rec *r,\n                                      apr_int32_t wanted) \n{\n    return apr_stat(finfo, r->filename, wanted, r->pool);\n}\n\nstatic void core_dump_config(apr_pool_t *p, server_rec *s)\n{\n    core_server_config *sconf = ap_get_core_module_config(s->module_config);\n    apr_file_t *out = NULL;\n    const char *tmp;\n    const char **defines;\n    int i;\n    if (!ap_exists_config_define(\"DUMP_RUN_CFG\"))\n        return;\n\n    apr_file_open_stdout(&out, p);\n    apr_file_printf(out, \"ServerRoot: \\\"%s\\\"\\n\", ap_server_root);\n    tmp = ap_server_root_relative(p, sconf->ap_document_root);\n    apr_file_printf(out, \"Main DocumentRoot: \\\"%s\\\"\\n\", tmp);\n    if (s->error_fname[0] != '|' && s->errorlog_provider == NULL)\n        tmp = ap_server_root_relative(p, s->error_fname);\n    else\n        tmp = s->error_fname;\n    apr_file_printf(out, \"Main ErrorLog: \\\"%s\\\"\\n\", tmp);\n    if (ap_scoreboard_fname) {\n        tmp = ap_runtime_dir_relative(p, ap_scoreboard_fname);\n        apr_file_printf(out, \"ScoreBoardFile: \\\"%s\\\"\\n\", tmp);\n    }\n    ap_dump_mutexes(p, s, out);\n    ap_mpm_dump_pidfile(p, out);\n\n    defines = (const char **)ap_server_config_defines->elts;\n    for (i = 0; i < ap_server_config_defines->nelts; i++) {\n        const char *name = defines[i];\n        const char *val = NULL;\n        if (server_config_defined_vars)\n           val = apr_table_get(server_config_defined_vars, name);\n        if (val)\n            apr_file_printf(out, \"Define: %s=%s\\n\", name, val);\n        else\n            apr_file_printf(out, \"Define: %s\\n\", name);\n    }\n}\n\nstatic int core_upgrade_handler(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    const char *upgrade;\n\n    if (c->master) {\n        /* Not possible to perform an HTTP/1.1 upgrade from a slave\n         * connection. */\n        return DECLINED;\n    }\n    \n    upgrade = apr_table_get(r->headers_in, \"Upgrade\");\n    if (upgrade && *upgrade) {\n        const char *conn = apr_table_get(r->headers_in, \"Connection\");\n        if (ap_find_token(r->pool, conn, \"upgrade\")) {\n            apr_array_header_t *offers = NULL;\n            const char *err;\n            \n            err = ap_parse_token_list_strict(r->pool, upgrade, &offers, 0);\n            if (err) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02910)\n                              \"parsing Upgrade header: %s\", err);\n                return DECLINED;\n            }\n            \n            if (offers && offers->nelts > 0) {\n                const char *protocol = ap_select_protocol(c, r, NULL, offers);\n                if (protocol && strcmp(protocol, ap_get_protocol(c))) {\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02909)\n                                  \"Upgrade selects '%s'\", protocol);\n                    /* Let the client know what we are upgrading to. */\n                    apr_table_clear(r->headers_out);\n                    apr_table_setn(r->headers_out, \"Upgrade\", protocol);\n                    apr_table_setn(r->headers_out, \"Connection\", \"Upgrade\");\n                    \n                    r->status = HTTP_SWITCHING_PROTOCOLS;\n                    r->status_line = ap_get_status_line(r->status);\n                    ap_send_interim_response(r, 1);\n\n                    ap_switch_protocol(c, r, r->server, protocol);\n\n                    /* make sure httpd closes the connection after this */\n                    c->keepalive = AP_CONN_CLOSE;\n                    return DONE;\n                }\n            }\n        }\n    }\n    else if (!c->keepalives) {\n        /* first request on a master connection, if we have protocols other\n         * than the current one enabled here, announce them to the\n         * client. If the client is already talking a protocol with requests\n         * on slave connections, leave it be. */\n        const apr_array_header_t *upgrades;\n        ap_get_protocol_upgrades(c, r, NULL, 0, &upgrades);\n        if (upgrades && upgrades->nelts > 0) {\n            char *protocols = apr_array_pstrcat(r->pool, upgrades, ',');\n            apr_table_setn(r->headers_out, \"Upgrade\", protocols);\n            apr_table_setn(r->headers_out, \"Connection\", \"Upgrade\");\n        }\n    }\n    \n    return DECLINED;\n}\n\nstatic int core_upgrade_storage(request_rec *r)\n{\n    if ((r->method_number == M_OPTIONS) && r->uri && (r->uri[0] == '*') &&\n        (r->uri[1] == '\\0')) {\n        return core_upgrade_handler(r);\n    }\n    return DECLINED;\n}\n\nstatic void register_hooks(apr_pool_t *p)\n{\n    errorlog_hash = apr_hash_make(p);\n    ap_register_log_hooks(p);\n    ap_register_config_hooks(p);\n    ap_expr_init(p);\n\n    /* create_connection and pre_connection should always be hooked\n     * APR_HOOK_REALLY_LAST by core to give other modules the opportunity\n     * to install alternate network transports and stop other functions\n     * from being run.\n     */\n    ap_hook_create_connection(core_create_conn, NULL, NULL,\n                              APR_HOOK_REALLY_LAST);\n    ap_hook_pre_connection(core_pre_connection, NULL, NULL,\n                           APR_HOOK_REALLY_LAST);\n\n    ap_hook_pre_config(core_pre_config, NULL, NULL, APR_HOOK_REALLY_FIRST);\n    ap_hook_post_config(core_post_config,NULL,NULL,APR_HOOK_REALLY_FIRST);\n    ap_hook_check_config(core_check_config,NULL,NULL,APR_HOOK_FIRST);\n    ap_hook_test_config(core_dump_config,NULL,NULL,APR_HOOK_FIRST);\n    ap_hook_translate_name(ap_core_translate,NULL,NULL,APR_HOOK_REALLY_LAST);\n    ap_hook_map_to_storage(core_upgrade_storage,NULL,NULL,APR_HOOK_REALLY_FIRST);\n    ap_hook_map_to_storage(core_map_to_storage,NULL,NULL,APR_HOOK_REALLY_LAST);\n    ap_hook_open_logs(ap_open_logs,NULL,NULL,APR_HOOK_REALLY_FIRST);\n    ap_hook_child_init(core_child_init,NULL,NULL,APR_HOOK_REALLY_FIRST);\n    ap_hook_child_init(ap_logs_child_init,NULL,NULL,APR_HOOK_MIDDLE);\n    ap_hook_handler(core_upgrade_handler,NULL,NULL,APR_HOOK_REALLY_FIRST);\n    ap_hook_handler(default_handler,NULL,NULL,APR_HOOK_REALLY_LAST);\n    /* FIXME: I suspect we can eliminate the need for these do_nothings - Ben */\n    ap_hook_type_checker(do_nothing,NULL,NULL,APR_HOOK_REALLY_LAST);\n    ap_hook_fixups(core_override_type,NULL,NULL,APR_HOOK_REALLY_FIRST);\n    ap_hook_create_request(core_create_req, NULL, NULL, APR_HOOK_MIDDLE);\n    APR_OPTIONAL_HOOK(proxy, create_req, core_create_proxy_req, NULL, NULL,\n                      APR_HOOK_MIDDLE);\n    ap_hook_pre_mpm(ap_create_scoreboard, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_child_status(ap_core_child_status, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_insert_network_bucket(core_insert_network_bucket, NULL, NULL,\n                                  APR_HOOK_REALLY_LAST);\n    ap_hook_dirwalk_stat(core_dirwalk_stat, NULL, NULL, APR_HOOK_REALLY_LAST);\n    ap_hook_open_htaccess(ap_open_htaccess, NULL, NULL, APR_HOOK_REALLY_LAST);\n    ap_hook_optional_fn_retrieve(core_optional_fn_retrieve, NULL, NULL,\n                                 APR_HOOK_MIDDLE);\n    ap_hook_output_pending(ap_filter_output_pending, NULL, NULL,\n            APR_HOOK_MIDDLE);\n\n    /* register the core's insert_filter hook and register core-provided\n     * filters\n     */\n    ap_hook_insert_filter(core_insert_filter, NULL, NULL, APR_HOOK_MIDDLE);\n\n    ap_core_input_filter_handle =\n        ap_register_input_filter(\"CORE_IN\", ap_core_input_filter,\n                                 NULL, AP_FTYPE_NETWORK);\n    ap_content_length_filter_handle =\n        ap_register_output_filter(\"CONTENT_LENGTH\", ap_content_length_filter,\n                                  NULL, AP_FTYPE_PROTOCOL);\n    ap_core_output_filter_handle =\n        ap_register_output_filter(\"CORE\", ap_core_output_filter,\n                                  NULL, AP_FTYPE_NETWORK);\n    ap_request_core_filter_handle =\n        ap_register_output_filter(\"REQ_CORE\", ap_request_core_filter,\n                                  NULL, AP_FTYPE_TRANSCODE);\n    ap_subreq_core_filter_handle =\n        ap_register_output_filter(\"SUBREQ_CORE\", ap_sub_req_output_filter,\n                                  NULL, AP_FTYPE_CONTENT_SET);\n    ap_old_write_func =\n        ap_register_output_filter(\"OLD_WRITE\", ap_old_write_filter,\n                                  NULL, AP_FTYPE_RESOURCE - 10);\n}\n\nAP_DECLARE_MODULE(core) = {\n    MPM20_MODULE_STUFF,\n    AP_PLATFORM_REWRITE_ARGS_HOOK, /* hook to run before apache parses args */\n    create_core_dir_config,       /* create per-directory config structure */\n    merge_core_dir_configs,       /* merge per-directory config structures */\n    create_core_server_config,    /* create per-server config structure */\n    merge_core_server_configs,    /* merge per-server config structures */\n    core_cmds,                    /* command apr_table_t */\n    register_hooks                /* register hooks */\n};\n\n"], "fixing_code": ["                                                         -*- coding: utf-8 -*-\nChanges with Apache 2.5.0\n\n  *) core: Disallow Methods' registration at runtime (.htaccess), they may be\n     used only if registered at init time (httpd.conf).  [Yann Ylavic]\n\n  *) mod_md: v0.9.1:\n     - various fixes in MDRenewWindow handling when specifying percent. Serialization changed. If \n       someone already used percent configurations, it is advised to change these to a new value,\n       reload and change back to the wanted ones.\n     - various fixes in handling of MDPrivateKeys when specifying 2048 bits (the default) explicitly.\n     - mod_md version removed from top level md_store.json file. The store has its own format version\n       to facilitate upgrades.\n    [Stefan Eissing]\n\n  *) mod_http2: DoS flow control protection is less agressive as long as active tasks stay\n     below worker capacity. Intended to fix problems with media streaming. [Stefan Eissing]\n     \n  *) mod_md: v0.9.0:\n     Certificate provisioning from Let's Encrypt (and other ACME CAs) for mod_ssl virtual hosts.\n     [Stefan Eissing]\n  \n  *) mod_proxy: loadfactor parameter can now be a decimal number (eg: 1.25).\n     [Jim Jagielski]\n\n  *) mod_watchdog/mod_proxy_hcheck: Time intervals can now be spefified\n     down to the millisecond. Supports 'mi' (minute), 'ms' (millisecond),\n     's' (second) and 'hr' (hour!) time suffixes. [Jim Jagielski]\n\n  *) mod_ssl: add SSLPolicy (define/use) and SSLProxyPolicy directives plus documentation. Add\n     core definitions for policies 'modern', 'intermediate' and 'old', as defined by Mozilla\n     in <https://wiki.mozilla.org/Security/Server_Side_TLS>. [Stefan Eissing]\n     \n  *) mod_proxy: Fix ProxyAddHeaders merging.  [Joe Orton]\n\n  *) mod_md: new module for managing domains across VirtualHosts with ACME protocol \n     implementation for automated certificate signup and renewal. Default CA is\n     the test area of Let's Encrypt right now, so certificates root will not be valid.\n     Will be switched to the real service endpoint rather soon. If you need it now,\n     configure 'MDCertificateAuthority https://acme-v01.api.letsencrypt.org/directory'.\n     [Stefan Eissing] \n     \n  *) mod_ssl, ab: Fix compatibility with LibreSSL.  PR 61184.\n     [Bernard Spil <brnrd freebsd.org>, Yann Ylavic]\n\n  *) event: Avoid possible blocking in the listener thread when shutting down\n     connections. PR 60956.  [Yann Ylavic]\n\n  *) mod_proxy_fcgi: Add the support for mod_proxy's flushpackets and flushwait\n     parameters. [Luca Toscano, Ruediger Pluem, Yann Ylavic]\n\n  *) mod_proxy_wstunnel: Fix detection of unresponded request which could have\n     led to spurious HTTP 502 error messages sent on upgrade connections.\n     PR 61283.  [Yann Ylavic]\n\n  *) mod_http2: Simplify ready queue, less memory and better performance. Update\n     mod_http2 version to 1.10.7. [Stefan Eissing]\n  \n  *) htpasswd / htdigest: Do not apply the strict permissions of the temporary\n     passwd file to a possibly existing passwd file. PR 61240. [Ruediger Pluem]\n\n  *) mod_rewrite: Add 'RewriteOptions LongURLOptimization' to free memory\n     from each set of unmatched rewrite conditions.\n     [Eric Covener]\n\n  *) Allow the argument to <IfFile>, <IfDefine>, <IfSection>, <IfDirective>, \n     and <IfModule> to be quoted.  This is primarily for the benefit of\n     <IfFile>. [Eric Covener]\n\n  *) Introduce request taint checking framework to prevent privilege\n     hijacking through .htaccess. [Nick Kew]\n\n  *) core: Disallow multiple Listen on the same IP:port when listener buckets\n     are configured (ListenCoresBucketsRatio > 0), consistently with the single\n     bucket case (default), thus avoiding the leak of the corresponding socket\n     descriptors on graceful restart.  [Yann Ylavic]\n\n  *) Add <IfDirective> and <IfSection> directives.  [Joe Orton]\n\n  *) mod_syslog: Support use of optional \"tag\" in syslog entries.\n     PR 60525. [Ben Rubson <ben.rubson gmail.com>, Jim Jagielski]\n\n  *) When using mod_status with the Event MPM, report the number of requests\n     associated with an active connection in the \"ACC\" field. Previously\n     zero was always reported with this MPM.  PR60647. [Eric Covener]\n\n  *) mod_remoteip: Add support for PROXY protocol (code donated by Cloudzilla).\n     Add ability for PROXY protocol processing to be optional to donated code.\n     See also: http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt\n     [Cloudzilla/roadrunner2@GitHub, Jim Jagielski, Daniel Ruggeri]\n\n  *) mod_remoteip: When overriding the useragent address from X-Forwarded-For,\n     zero out what had been initialized as the connection-level port.  PR59931.\n     [Hank Ibell <hwibell gmail.com>]\n\n  *) mod_proxy_wstunnel: Reliably run before mod_proxy_http.\n     [Eric Covener]\n\n  *) mod_proxy_protocol: Add server-side, front-end support for PROXY PROTOCOL\n     (http://blog.haproxy.com/haproxy/proxy-protocol/).  [roadrunner2]\n     \n  *) http: Allow unknown response status' lines returned in the form of\n     \"HTTP/x.x xxx Status xxx\".  [Yann Ylavic]\n\n  *) core: Add <IfFile> configuration section to allow any file on disk to be\n     used as a conditional.  [Edward Lu, Eric Covener]\n\n  *) event: Avoid listener periodic wake ups by using the pollset wake-ability\n     when available.  PR 57399.  [Yann Ylavic, Luca Toscano]\n\n  *) mod_crypto: Add the all purpose crypto filters with support for HLS.\n     [Graham Leggett]\n\n  *) core: Drop an invalid Last-Modified header value coming\n     from a FCGI/CGI script instead of replacing it with Unix epoch.\n     Warn the users about Last-Modified header value replacements\n     and violations of the RFC.\n     [Yann Ylavic, Luca Toscano, William Rowe, Jacob Champion]\n\n  *) mod_dav: Allow other modules to become providers and add ACLs\n     to the DAV response.\n     [Jari Urpalainen <jari.urpalainen nokia.com>, Graham Leggett]\n\n  *) mod_dav: Add dav_begin_multistatus, dav_send_one_response,\n     dav_finish_multistatus, dav_send_multistatus, dav_handle_err,\n     dav_failed_proppatch, dav_success_proppatch to mod_dav.h.\n     [Jari Urpalainen <jari.urpalainen nokia.com>, Graham Leggett]\n\n  *) mod_proxy, mod_ssl: Handle SSLProxy* directives in <Proxy> sections,\n     allowing per backend TLS configuration.  [Yann Ylavic]\n\n  *) core: explicitly exclude 'h2' from protocols announced via an Upgrade: \n     header as commanded by http-wg. [Stefan Eissing]\n\n  *) mod_proxy_ajp: Add \"secret\" parameter to proxy workers to implement legacy\n     AJP13 authentication.  PR 53098.  [Dmitry A. Bakshaev <dab1818 gmail com>]\n\n  *) mpm: Generalise the ap_mpm_register_socket functions to accept pipes\n     or sockets. [Graham Leggett]\n\n  *) core: Extend support for setting aside data from the network input filter\n     to any connection or request input filter. [Graham Leggett]\n\n  *) core: Split ap_create_request() from ap_read_request(). [Graham Leggett]\n\n  *) mod_auth_digest: Fix compatibility with expression-based Authname. PR59039.\n     [Eric Covener]\n\n  *) mpm: Add a complete_connection hook that confirms whether an MPM is allowed\n     to leave the WRITE_COMPLETION phase. Move filter code out of the MPMs.\n     [Graham Leggett]\n\n  *) core: Added support for HTTP code 451. PR58985.\n     [Yehuda Katz <yehuda ymkatz.net>, Jim Jagielski]\n\n  *) mod_filter: Fix AddOutputFilterByType with non-content-level filters.\n     PR58856 [Micha Lenk <micha lenk.info>]\n\n  *) mod_cache: Consider Cache-Control: s-maxage in expiration\n     calculations.  [Eric Covener]\n\n  *) mod_cache: Allow caching of responses with an Expires header\n     in the past that also has Cache-Control: max-age or s-maxage.\n     PR55156. [Eric Covener]\n\n  *) Added many log numbers to log statements that had none.\n\n  *) mod_session: Introduce SessionExpiryUpdateInterval which allows to\n     configure the session/cookie expiry's update interval. PR 57300.\n     [Paul Spangler <paul.spangler ni.com>]\n\n  *) core: Extend support for asynchronous write completion from the\n     network filter to any connection or request filter. [Graham Leggett]\n\n  *) mod_auth_digest: remove AuthDigestEnableQueryStringHack which is no\n     more documented since dec 2012 (r1415960). [Christophe Jaillet]\n\n  *) mod_charset_lite: On EBCDIC platforms, make sure mod_charset_lite runs\n     after other resource-level filters. [Eric Covener]\n\n  *) http: Don't remove the Content-Length of zero from a HEAD response if\n     it comes from an origin server, module or script.  [Yann Ylavic]\n\n  *) http: Add support for RFC2324/RFC7168. [Graham Leggett]\n\n  *) mod_rewrite: Add support for starting External Rewriting Programs\n     as non-root user on UNIX systems by specifying username and group name\n     as third argument of RewriteMap directive. [Jan Kaluza]\n\n  *) mod_authn_core: Add expression support to AuthName and AuthType.\n     [Graham Leggett]\n\n  *) suexec: Filter out the HTTP_PROXY environment variable because it is\n     treated as alias for http_proxy by some programs. [Stefan Fritsch]\n\n  *) mod_proxy_http: Don't establish or reuse a backend connection before pre-\n     fetching the request body, so to minimize the delay between it is supposed\n     to be alive and the first bytes sent: this is a best effort to prevent the\n     backend from closing because of idle or keepalive timeout in the meantime.\n     Also, handle a new \"proxy-flushall\" environment variable which allows to\n     flush any forwarded body data immediately. PR 56541+37920. [Yann Ylavic]\n\n  *) core: Define and UnDefine are no longer permitted in\n     directory context. Previously they would always be evaulated\n     as the configuration was read without regard for the directory\n     context. [Eric Covener]\n\n  *) config: For directives that do not expect any arguments, enforce\n     that none are specified in the configuration file. \n     [Joachim Zobel <jzobel heute-morgen.de>, Eric Covener]\n\n  *) mod_rewrite: Improve 'bad flag delimeters' startup error by showing\n     how the input was tokenized.  PR 56528. [Edward Lu <Chaosed0 gmail.com>]\n\n  *) mod_proxy: Don't put non balancer-member workers in error state by\n     default for connection or 500/503 errors, and honor status=+I for\n     any error.  PR 48388.  [Yann Ylavic]\n\n  *) mod_socache_memcache: Pass expiration time through to memcached. PR 55445.\n     [Faidon Liambotis <paravoid debian.org>, Joe Orton]\n\n  *) ap_expr: Add filemod function for checking file modification dates\n     [Daniel Gruno]\n\n  *) mod_authnz_ldap: Resolve crashes with LDAP authz and non-LDAP authn since \n     r1608202. [Eric Covener]\n\n  *) apreq: Content-Length header should be always interpreted as a decimal.\n     Leading 0 could be erroneously considered as an octal value. PR 56598.\n     [Chris Card <ctcard hotmail com>]\n\n  *) mod_proxy: Now allow for 191 character worker names, with non-fatal\n     errors if name is truncated. PR53218. [Jim Jagielski]\n\n  *) mod_ssl: Add optional function \"ssl_get_tls_cb\" to allow support\n     for channel bindings.  [Simo Sorce <simo redhat.com>]\n\n  *) mod_proxy_wstunnel: Concurrent websockets messages could be \n     lost or delayed with ProxyWebsocketAsync enabled.  \n     [Edward Lu <Chaosed0 gmail.com>]\n\n  *) core, mod_info: Add compiled and loaded PCRE versions to version\n     number display.  [Rainer Jung]\n\n  *) mod_authnz_ldap: Return LDAP connections to the pool before the handler\n     is run, instead of waiting until the end of the request. [Eric Covener]\n\n  *) mod_proxy_html: support automatic detection of doctype and processing\n     of FPIs.  PR56285 [Micha Lenk <micha lenk info>, Nick Kew]\n\n  *) mod_proxy_html: skip documents shorter than 4 bytes\n     PR 56286 [Micha Lenk <micha lenk info>]\n\n  *) mod_proxy_fdpass: Fix computation of the size of 'struct sockaddr_un'\n     when passed to 'connect()'.\n     [Graham Dumpleton <grahamd apache org>]\n\n  *) core: Add ap_mpm_resume_suspended() API to allow a suspended connection\n     to resume. PR56333 \n     [Artem <artemciy gmail.com>, Edward Lu <Chaosed0 gmail.com>]\n\n  *) core: Add ap_mpm_register_socket_callback_timeout() API. [Eric Covener]\n\n  *) mod_proxy_wstunnel: Honor ProxyWebsocketIdleTimeout in asynchronous\n     processing mode. [Eric Covener]\n\n  *) mod_authnz_ldap: Fail explicitly when the filter is too long. Remove\n     unnecessary apr_pstrdup() and strlen(). [Graham Leggett]\n\n  *) Add the ldap-search option to mod_authnz_ldap, allowing authorization\n     to be based on arbitrary expressions that do not include the username.\n     [Graham Leggett]\n\n  *) Add the ldap function to the expression API, allowing LDAP filters and\n     distinguished names based on expressions to be escaped correctly to\n     guard against LDAP injection. [Graham Leggett]\n\n  *) Add module mod_ssl_ct, which provides an implementation of Certificate\n     Transparency (RFC 6962) for httpd.  [Jeff Trawick]\n\n  *) mod_proxy_wstunnel: Avoid sending error responses down an upgraded\n     websockets connection as it is being close down. [Eric Covener]\n\n  *) mod_proxy_wstunnel: Allow the administrator to cap the amount\n     of time a synchronous websockets connection stays idle with \n     ProxyWebsocketIdleTimeout. [Eric Covener]\n\n  *) mod_proxy_wstunnel: Change to opt-in for asynchronous support, adding \n     directives ProxyWebsocketAsync and ProxyWebsocketAsyncDelay. \n     [Eric Covener]\n\n  *) mod_proxy_wstunnel: Stop leaking websockets backend connections under\n     event MPM (trunk-only). [Eric Covener]\n\n  *) mod_proxy_http: Add detach_backend hook (potentially usable\n     in other proxy scheme handlers).  [Jeff Trawick]\n\n  *) mod_deflate: Add DeflateAlterETag to control how the ETag\n     is modified. The 'NoChange' parameter mimics 2.2.x behavior.\n     PR 45023, PR 39727. [Eric Covener]\n\n  *) mod_rewrite: Add 'BNF' (backreferences-no-plus) flag to RewriteRule to \n     allow spaces in backreferences to be encoded as %20 instead of '+'.\n     [Eric Covener]\n\n  *) mod_rewrite: Support an optional list of characters to escape in the \n     argument for the 'B' (escape backreferences) flag. [Eric Covener]\n\n  *) mod_dir: Default to 2.2-like behavior and skip execution when method is\n     neither GET nor POST, such as for DAV requests. PR 54914. [Chris Darroch]\n\n  *) mod_rewrite: Rename the handler that does per-directory internal \n     redirects to \"rewrite-redirect-handler\" from \"redirect-handler\" so\n     it is less ambiguous and less likely to be reused. [Eric Covener]\n\n  *) mod_rewrite: Protect against looping with the [N] flag by enforcing a \n     default limit of 10000 iterations, and allowing each rule to change its\n     limit. [Eric Covener]\n\n  *) mod_ssl: Fix config merging of SSLOCSPEnable and SSLOCSPOverrideResponder.\n     [Jeff Trawick]\n\n  *) Add HttpContentLengthHeadZero and HttpExpectStrict directives.\n     [Yehuda Sadeh <yehuda inktank com>, Justin Erenkrantz]\n\n  *) mod_ssl: Add -t -DDUMP_CA_CERTS option which dumps the filenames of all\n     configured SSL CA certificates to stdout the same way as DUMP_CERTS does.\n     [Jan Kaluza]\n\n  *) mod_ssl: Don't flush when an EOS is received. Prepares mod_ssl\n     to support write completion. [Graham Leggett]\n\n  *) core: Add parse_errorlog_arg callback to ap_errorlog_provider\n     to allow providers to check the ErrorLog argument. [Jan Kaluza]\n\n  *) mod_cgid: Use the servers Timeout for each read from a CGI script,\n     allow override with new CGIDRequestTimeout directive. PR43494\n     [Eric Covener, Toshikuni Fukaya <toshikuni-fukaya cybozu co jp>]\n\n  *) core: ensure any abnormal exit is reported to stderr if it's a tty.\n     PR 55670 [Nick Kew]\n\n  *) mod_lua: Let the Inter-VM get/set functions work with a global \n     shared memory pool instead of a per-process pool. [Daniel Gruno]\n\n  *) ldap: Support ldaps when using the Microsoft LDAP SDK.\n     PR 54626. [Jean-Frederic Clere]\n\n  *) mod_authnz_ldap: Change default value of AuthLDAPMaxSubGroupDepth to 0\n     to avoid performance problems when subgroups aren't in use. [Eric Covener]\n\n  *) mod_syslog: New module implementing syslog ap_error_log provider.\n     Previously, this code was part of core, now it's in separate module.\n     [Jan Kaluza]\n\n  *) core: Add ap_errorlog_provider to make ErrorLog logging modular. Move\n     syslog support from core to new mod_syslog. [Jan Kaluza]\n\n  *) mod_status, mod_echo: Fix the display of client addresses.\n     They were truncated to 31 characters which is not enough for IPv6 addresses.\n     PR 54848 [Bernhard Schmidt <berni birkenwald de>]\n\n  *) mod_unique_id: Use output of the PRNG rather than IP address and\n     pid, avoiding sleep() call and possible DNS issues at startup,\n     plus improving randomness for IPv6-only hosts.\n     [Jan Kaluza <jkaluza redhat.com>]\n\n  *) mod_file_cache: mod_file_cache should be able to serve files that\n     haven't had a Content-Type set via e.g. mod_mime. [Eric Covener]\n\n  *) core: merge AllowEncodedSlashes from the base configuration into\n     virtual hosts. [Eric Covener]\n\n  *) AIX: Install DSO's with \"cp\" instead of \"install\" in instdso.sh\n     [Eric Covener]\n\n  *) mod_ldap: Don't keep retrying if a new LDAP connection times out.\n     [Eric Covener]\n\n  *) mod_deflate: permit compilation of mod_deflate against a zlib that has\n     been configured with -D Z_PREFIX, which redefines the token \"deflate\".\n     [Eric Covener]\n\n  *) mod_auth_digest: Use the secret when generating nonces in all cases and\n     not only when AuthName is used in .htaccess files (this change may cause\n     problems if used with round robin load balancers). Don't regenerate the\n     secret on graceful restarts. PR 54637  [Stefan Fritsch]\n\n  *) core: Remove apr_brigade_flatten(), buffering and duplicated code\n     from the HTTP_IN filter, parse chunks in a single pass with zero copy.\n     Reduce memory usage by 48 bytes per request. [Graham Leggett]\n\n  *) core: Stop the HTTP_IN filter from attempting to write error buckets\n     to the output filters, which is bogus in the proxy case. Create a\n     clean mapping from APR codes to HTTP status codes, and use it where\n     needed. [Graham Leggett]\n\n  *) mod_proxy: Ensure network errors detected by the proxy are returned as\n     504 Gateway Timout as opposed to 502 Bad Gateway, in order to be\n     compliant with RFC2616 14.9.4 Cache Revalidation and Reload Controls.\n\n  *) mod_dav: mod_dav overrides dav_fs response on PUT failure. PR 35981\n     [Basant Kumar Kukreja <basant.kukreja sun.com>, Alejandro Alvarez\n     <alejandro.alvarez.ayllon cern.ch>]\n\n  *) mod_ldap: LDAP connections used for authentication were not respecting\n     LDAPConnectionPoolTimeout.  PR 54587\n\n  *) core: ap_rgetline_core now pulls from r->proto_input_filters.\n\n  *) mod_proxy_html: process parsed comments immediately. \n     Fixes bug where parsed comments may be lost. [Nick Kew]\n\n  *) mod_proxy_html: introduce doctype for HTML 5 [Nick Kew]\n\n  *) mod_proxy_html: fix typo-bug processing \"strict\" vs \"transitional\"\n     HTML/XHTML [Nick Kew]\n\n  *) core: Add option to add valgrind support. Use it to reduce false positive\n     warnings in mod_ssl. [Stefan Fritsch]\n\n  *) mod_authn_file, mod_authn_dbd, mod_authn_dbm, mod_authn_socache:\n     Cache the result of the most recent password hash verification for every\n     keep-alive connection. This saves some expensive calculations.\n     [Stefan Fritsch]\n\n  *) http: Remove support for Request-Range header sent by Navigator 2-3 and\n     MSIE 3. [Stefan Fritsch]\n\n  *) core, http: Extend HttpProtocol with an option to enforce stricter HTTP\n     conformance or to only log the found problems. [Stefan Fritsch]\n\n  *) core: Correctly parse an IPv6 literal host specification in an absolute\n     URL in the request line. [Stefan Fritsch]\n\n  *) EventOpt MPM\n\n  *) core: Add LogLevelOverride directive that allows to override the\n     loglevel for clients from certain IPs. This also works for things\n     like the SSL handshake where <If> LogLevel ... </If> is evaluated\n     too late. [Stefan Fritsch]\n\n  *) core: Add new directive Warning to issue warnings from a configuration\n     file. Both Warning and Error now generate a timestamped log message.\n     [Fabien Coelho] \n\n  *) ap_expr: Add SERVER_PROTOCOL_VERSION, ..._MAJOR, and ..._MINOR\n     variables. [Stefan Fritsch]\n\n  *) core: New directive RegisterHttpMethod for registering non-standard\n     HTTP methods. [Stefan Fritsch]\n\n  *) core: New directive HttpProtocol which allows to disable HTTP/0.9\n     support. [Stefan Fritsch]\n\n  *) mod_allowhandlers: New module to forbid specific handlers for specific\n     directories. [Stefan Fritsch]\n\n  *) mod_systemd: New module, for integration with systemd on Linux.\n     [Jan Kaluza <jkaluza redhat.com>]\n\n  *) WinNT MPM: Store pid and generation for each thread in scoreboard\n     to allow tracking of threads from exiting children via mod_status\n     or other such mechanisms.  [Jeff Trawick]\n\n  *) The following now respect DefaultRuntimeDir/DEFAULT_REL_RUNTIMEDIR:\n     - APIs: ap_log_pid(), ap_remove_pid, ap_read_pid()\n     - mod_cache: thundering herd lock directory\n     - mod_lbmethod_heartbeat, mod_heartmonitor: heartbeat storage file\n     - mod_ldap: shared memory cache\n     - mod_socache_shmcb, mod_socache_dbm: shared memory or dbm for cache\n     [Jeff Trawick]\n\n  *) suexec: Add --enable-suexec-capabilites support on Linux, to use\n     setuid/setgid capability bits rather than a setuid root binary.\n     [Joe Orton]\n\n  *) suexec: Add support for logging to syslog as an alternative to logging\n     to a file; configure --without-suexec-logfile --with-suexec-syslog.  \n     [Joe Orton]\n\n  *) mod_ssl: Add support for TLS Next Protocol Negotiation.  PR 52210.\n     [Matthew Steele <mdsteele google.com>]\n\n  *) cross-compile: allow to provide CC_FOR_BUILD so that gen_test_char will\n     be compiled by the build compiler instead of the host compiler.\n     Also set CC_FOR_BUILD to 'cc' when cross-compilation is detected.\n     PR 51257. [Guenter Knauf]\n\n  *) core: In maintainer mode, replace apr_palloc with a version that\n     initializes the allocated memory with non-zero values, except if\n     AP_DEBUG_NO_ALLOC_POISON is defined. [Stefan Fritsch]\n\n  *) mod_policy: Add a new testing module to help server administrators\n     enforce a configurable level of protocol compliance on their\n     servers and application servers behind theirs. [Graham Leggett]\n\n  *) mod_firehose: Add a new debugging module able to record traffic\n     passing through the server in such a way that connections and/or\n     requests be reconstructed and replayed. [Graham Leggett]\n\n  *) mod_noloris\n\n  *) APREQ\n\n  *) Simple MPM\n\n  *) mod_serf\n\n  [Apache 2.5.0-dev includes those bug fixes and changes with the\n   Apache 2.4.xx tree as documented below, except as noted.]\n\nChanges with Apache 2.4.x and later:\n\n  *) http://svn.apache.org/viewvc/httpd/httpd/branches/2.4.x/CHANGES?view=markup\n\nChanges with Apache 2.2.x and later:\n\n  *) http://svn.apache.org/viewvc/httpd/httpd/branches/2.2.x/CHANGES?view=markup\n\nChanges with Apache 2.0.x and later:\n\n  *) http://svn.apache.org/viewvc/httpd/httpd/branches/2.0.x/CHANGES?view=markup\n\n", "/* Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"apr.h\"\n#include \"apr_strings.h\"\n#include \"apr_lib.h\"\n#include \"apr_fnmatch.h\"\n#include \"apr_hash.h\"\n#include \"apr_thread_proc.h\"    /* for RLIMIT stuff */\n#include \"apr_random.h\"\n\n#define APR_WANT_IOVEC\n#define APR_WANT_STRFUNC\n#define APR_WANT_MEMFUNC\n#include \"apr_want.h\"\n\n#include \"ap_config.h\"\n#include \"httpd.h\"\n#include \"http_config.h\"\n#include \"http_core.h\"\n#include \"http_protocol.h\" /* For index_of_response().  Grump. */\n#include \"http_request.h\"\n#include \"http_vhost.h\"\n#include \"http_main.h\"     /* For the default_handler below... */\n#include \"http_log.h\"\n#include \"util_md5.h\"\n#include \"http_connection.h\"\n#include \"apr_buckets.h\"\n#include \"util_filter.h\"\n#include \"util_ebcdic.h\"\n#include \"util_mutex.h\"\n#include \"util_time.h\"\n#include \"mpm_common.h\"\n#include \"scoreboard.h\"\n#include \"mod_core.h\"\n#include \"mod_proxy.h\"\n#include \"ap_listen.h\"\n#include \"ap_provider.h\"\n\n#include \"mod_so.h\" /* for ap_find_loaded_module_symbol */\n\n#if defined(RLIMIT_CPU) || defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS) || defined (RLIMIT_NPROC)\n#include \"unixd.h\"\n#endif\n#if APR_HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n/* LimitRequestBody handling */\n#define AP_LIMIT_REQ_BODY_UNSET         ((apr_off_t) -1)\n#define AP_DEFAULT_LIMIT_REQ_BODY       ((apr_off_t) 0)\n\n/* LimitXMLRequestBody handling */\n#define AP_LIMIT_UNSET                  ((long) -1)\n#define AP_DEFAULT_LIMIT_XML_BODY       ((apr_size_t)1000000)\n\n#define AP_MIN_SENDFILE_BYTES           (256)\n\n/* maximum include nesting level */\n#ifndef AP_MAX_INCLUDE_DEPTH\n#define AP_MAX_INCLUDE_DEPTH            (128)\n#endif\n\n/* valid in core-conf, but not in runtime r->used_path_info */\n#define AP_ACCEPT_PATHINFO_UNSET 3\n\n#define AP_CONTENT_MD5_OFF   0\n#define AP_CONTENT_MD5_ON    1\n#define AP_CONTENT_MD5_UNSET 2\n\nAPR_HOOK_STRUCT(\n    APR_HOOK_LINK(get_mgmt_items)\n    APR_HOOK_LINK(insert_network_bucket)\n)\n\nAP_IMPLEMENT_HOOK_RUN_ALL(int, get_mgmt_items,\n                          (apr_pool_t *p, const char *val, apr_hash_t *ht),\n                          (p, val, ht), OK, DECLINED)\n\nAP_IMPLEMENT_HOOK_RUN_FIRST(apr_status_t, insert_network_bucket,\n                            (conn_rec *c, apr_bucket_brigade *bb,\n                             apr_socket_t *socket),\n                            (c, bb, socket), AP_DECLINED)\n\n/* Server core module... This module provides support for really basic\n * server operations, including options and commands which control the\n * operation of other modules.  Consider this the bureaucracy module.\n *\n * The core module also defines handlers, etc., to handle just enough\n * to allow a server with the core module ONLY to actually serve documents.\n *\n * This file could almost be mod_core.c, except for the stuff which affects\n * the http_conf_globals.\n */\n\n/* we know core's module_index is 0 */\n#undef APLOG_MODULE_INDEX\n#define APLOG_MODULE_INDEX AP_CORE_MODULE_INDEX\n\n/* Handles for core filters */\nAP_DECLARE_DATA ap_filter_rec_t *ap_subreq_core_filter_handle;\nAP_DECLARE_DATA ap_filter_rec_t *ap_request_core_filter_handle;\nAP_DECLARE_DATA ap_filter_rec_t *ap_core_output_filter_handle;\nAP_DECLARE_DATA ap_filter_rec_t *ap_content_length_filter_handle;\nAP_DECLARE_DATA ap_filter_rec_t *ap_core_input_filter_handle;\n\n/* Provide ap_document_root_check storage and default value = true */\nAP_DECLARE_DATA int ap_document_root_check = 1;\n\n/* magic pointer for ErrorDocument xxx \"default\" */\nstatic char errordocument_default;\n\nstatic apr_array_header_t *saved_server_config_defines = NULL;\nstatic apr_table_t *server_config_defined_vars = NULL;\n\nAP_DECLARE_DATA int ap_main_state = AP_SQ_MS_INITIAL_STARTUP;\nAP_DECLARE_DATA int ap_run_mode = AP_SQ_RM_UNKNOWN;\nAP_DECLARE_DATA int ap_config_generation = 0;\n\ntypedef struct {\n    apr_ipsubnet_t *subnet;\n    struct ap_logconf log;\n} conn_log_config;\n\nstatic void *create_core_dir_config(apr_pool_t *a, char *dir)\n{\n    core_dir_config *conf;\n\n    conf = (core_dir_config *)apr_pcalloc(a, sizeof(core_dir_config));\n\n    /* conf->r and conf->d[_*] are initialized by dirsection() or left NULL */\n\n    conf->opts = dir ? OPT_UNSET : OPT_UNSET|OPT_SYM_LINKS;\n    conf->opts_add = conf->opts_remove = OPT_NONE;\n    conf->override = OR_UNSET|OR_NONE;\n    conf->override_opts = OPT_UNSET | OPT_ALL | OPT_SYM_OWNER | OPT_MULTI;\n\n    conf->content_md5 = AP_CONTENT_MD5_UNSET;\n    conf->accept_path_info = AP_ACCEPT_PATHINFO_UNSET;\n\n    conf->use_canonical_name = USE_CANONICAL_NAME_UNSET;\n    conf->use_canonical_phys_port = USE_CANONICAL_PHYS_PORT_UNSET;\n\n    conf->hostname_lookups = HOSTNAME_LOOKUP_UNSET;\n\n    /*\n     * left as NULL (we use apr_pcalloc):\n     * conf->limit_cpu = NULL;\n     * conf->limit_mem = NULL;\n     * conf->limit_nproc = NULL;\n     * conf->sec_file = NULL;\n     * conf->sec_if   = NULL;\n     */\n\n    conf->limit_req_body = AP_LIMIT_REQ_BODY_UNSET;\n    conf->limit_xml_body = AP_LIMIT_UNSET;\n\n    conf->server_signature = srv_sig_unset;\n\n    conf->add_default_charset = ADD_DEFAULT_CHARSET_UNSET;\n    conf->add_default_charset_name = DEFAULT_ADD_DEFAULT_CHARSET_NAME;\n\n    /* Overriding all negotiation\n     * Set NULL by apr_pcalloc:\n     * conf->mime_type = NULL;\n     * conf->handler = NULL;\n     * conf->output_filters = NULL;\n     * conf->input_filters = NULL;\n     */\n\n    /*\n     * Flag for use of inodes in ETags.\n     */\n    conf->etag_bits = ETAG_UNSET;\n    conf->etag_add = ETAG_UNSET;\n    conf->etag_remove = ETAG_UNSET;\n\n    conf->enable_mmap = ENABLE_MMAP_UNSET;\n    conf->enable_sendfile = ENABLE_SENDFILE_UNSET;\n    conf->allow_encoded_slashes = 0;\n    conf->decode_encoded_slashes = 0;\n\n    conf->max_ranges = AP_MAXRANGES_UNSET;\n    conf->max_overlaps = AP_MAXRANGES_UNSET;\n    conf->max_reversals = AP_MAXRANGES_UNSET;\n\n    conf->cgi_pass_auth = AP_CGI_PASS_AUTH_UNSET;\n    conf->qualify_redirect_url = AP_CORE_CONFIG_UNSET; \n\n    return (void *)conf;\n}\n\nstatic void *merge_core_dir_configs(apr_pool_t *a, void *basev, void *newv)\n{\n    core_dir_config *base = (core_dir_config *)basev;\n    core_dir_config *new = (core_dir_config *)newv;\n    core_dir_config *conf;\n\n    /* Create this conf by duplicating the base, replacing elements\n     * (or creating copies for merging) where new-> values exist.\n     */\n    conf = (core_dir_config *)apr_pmemdup(a, base, sizeof(core_dir_config));\n\n    conf->d = new->d;\n    conf->d_is_fnmatch = new->d_is_fnmatch;\n    conf->d_components = new->d_components;\n    conf->r = new->r;\n    conf->refs = new->refs;\n    conf->condition = new->condition;\n\n    if (new->opts & OPT_UNSET) {\n        /* there was no explicit setting of new->opts, so we merge\n         * preserve the invariant (opts_add & opts_remove) == 0\n         */\n        conf->opts_add = (conf->opts_add & ~new->opts_remove) | new->opts_add;\n        conf->opts_remove = (conf->opts_remove & ~new->opts_add)\n                            | new->opts_remove;\n        conf->opts = (conf->opts & ~conf->opts_remove) | conf->opts_add;\n\n        /* If Includes was enabled with exec in the base config, but\n         * was enabled without exec in the new config, then disable\n         * exec in the merged set. */\n        if (((base->opts & (OPT_INCLUDES|OPT_INC_WITH_EXEC))\n             == (OPT_INCLUDES|OPT_INC_WITH_EXEC))\n            && ((new->opts & (OPT_INCLUDES|OPT_INC_WITH_EXEC))\n                == OPT_INCLUDES)) {\n            conf->opts &= ~OPT_INC_WITH_EXEC;\n        }\n    }\n    else {\n        /* otherwise we just copy, because an explicit opts setting\n         * overrides all earlier +/- modifiers\n         */\n        conf->opts = new->opts;\n        conf->opts_add = new->opts_add;\n        conf->opts_remove = new->opts_remove;\n    }\n\n    if (!(new->override & OR_UNSET)) {\n        conf->override = new->override;\n    }\n\n    if (!(new->override_opts & OPT_UNSET)) {\n        conf->override_opts = new->override_opts;\n    }\n\n    if (new->override_list != NULL) {\n        conf->override_list = new->override_list;\n    }\n\n    if (conf->response_code_exprs == NULL) {\n        conf->response_code_exprs = new->response_code_exprs;\n    }\n    else if (new->response_code_exprs != NULL) {\n        conf->response_code_exprs = apr_hash_overlay(a,\n                new->response_code_exprs, conf->response_code_exprs);\n    }\n    /* Otherwise we simply use the base->response_code_exprs array\n     */\n\n    if (new->hostname_lookups != HOSTNAME_LOOKUP_UNSET) {\n        conf->hostname_lookups = new->hostname_lookups;\n    }\n\n    if (new->content_md5 != AP_CONTENT_MD5_UNSET) {\n        conf->content_md5 = new->content_md5;\n    }\n\n    if (new->accept_path_info != AP_ACCEPT_PATHINFO_UNSET) {\n        conf->accept_path_info = new->accept_path_info;\n    }\n\n    if (new->use_canonical_name != USE_CANONICAL_NAME_UNSET) {\n        conf->use_canonical_name = new->use_canonical_name;\n    }\n\n    if (new->use_canonical_phys_port != USE_CANONICAL_PHYS_PORT_UNSET) {\n        conf->use_canonical_phys_port = new->use_canonical_phys_port;\n    }\n\n#ifdef RLIMIT_CPU\n    if (new->limit_cpu) {\n        conf->limit_cpu = new->limit_cpu;\n    }\n#endif\n\n#if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)\n    if (new->limit_mem) {\n        conf->limit_mem = new->limit_mem;\n    }\n#endif\n\n#ifdef RLIMIT_NPROC\n    if (new->limit_nproc) {\n        conf->limit_nproc = new->limit_nproc;\n    }\n#endif\n\n    if (new->limit_req_body != AP_LIMIT_REQ_BODY_UNSET) {\n        conf->limit_req_body = new->limit_req_body;\n    }\n\n    if (new->limit_xml_body != AP_LIMIT_UNSET)\n        conf->limit_xml_body = new->limit_xml_body;\n\n    if (!conf->sec_file) {\n        conf->sec_file = new->sec_file;\n    }\n    else if (new->sec_file) {\n        /* If we merge, the merge-result must have its own array\n         */\n        conf->sec_file = apr_array_append(a, base->sec_file, new->sec_file);\n    }\n    /* Otherwise we simply use the base->sec_file array\n     */\n\n    if (!conf->sec_if) {\n        conf->sec_if = new->sec_if;\n    }\n    else if (new->sec_if) {\n        /* If we merge, the merge-result must have its own array\n         */\n        conf->sec_if = apr_array_append(a, base->sec_if, new->sec_if);\n    }\n    /* Otherwise we simply use the base->sec_if array\n     */\n\n    if (new->server_signature != srv_sig_unset) {\n        conf->server_signature = new->server_signature;\n    }\n\n    if (new->add_default_charset != ADD_DEFAULT_CHARSET_UNSET) {\n        conf->add_default_charset = new->add_default_charset;\n        conf->add_default_charset_name = new->add_default_charset_name;\n    }\n\n    /* Overriding all negotiation\n     */\n    if (new->mime_type) {\n        conf->mime_type = new->mime_type;\n    }\n\n    if (new->handler) {\n        conf->handler = new->handler;\n    }\n    if (new->expr_handler) {\n        conf->expr_handler = new->expr_handler;\n    }\n\n    if (new->output_filters) {\n        conf->output_filters = new->output_filters;\n    }\n\n    if (new->input_filters) {\n        conf->input_filters = new->input_filters;\n    }\n\n    /*\n     * Now merge the setting of the FileETag directive.\n     */\n    if (new->etag_bits == ETAG_UNSET) {\n        conf->etag_add =\n            (conf->etag_add & (~ new->etag_remove)) | new->etag_add;\n        conf->etag_remove =\n            (conf->etag_remove & (~ new->etag_add)) | new->etag_remove;\n        conf->etag_bits =\n            (conf->etag_bits & (~ conf->etag_remove)) | conf->etag_add;\n    }\n    else {\n        conf->etag_bits = new->etag_bits;\n        conf->etag_add = new->etag_add;\n        conf->etag_remove = new->etag_remove;\n    }\n\n    if (conf->etag_bits != ETAG_NONE) {\n        conf->etag_bits &= (~ ETAG_NONE);\n    }\n\n    if (new->enable_mmap != ENABLE_MMAP_UNSET) {\n        conf->enable_mmap = new->enable_mmap;\n    }\n\n    if (new->enable_sendfile != ENABLE_SENDFILE_UNSET) {\n        conf->enable_sendfile = new->enable_sendfile;\n    }\n\n    if (new->allow_encoded_slashes_set) {\n        conf->allow_encoded_slashes = new->allow_encoded_slashes;\n    }\n    if (new->decode_encoded_slashes_set) {\n        conf->decode_encoded_slashes = new->decode_encoded_slashes;\n    }\n\n    if (new->log) {\n        if (!conf->log) {\n            conf->log = new->log;\n        }\n        else {\n            conf->log = ap_new_log_config(a, new->log);\n            ap_merge_log_config(base->log, conf->log);\n        }\n    }\n\n    conf->max_ranges = new->max_ranges != AP_MAXRANGES_UNSET ? new->max_ranges : base->max_ranges;\n    conf->max_overlaps = new->max_overlaps != AP_MAXRANGES_UNSET ? new->max_overlaps : base->max_overlaps;\n    conf->max_reversals = new->max_reversals != AP_MAXRANGES_UNSET ? new->max_reversals : base->max_reversals;\n\n    conf->cgi_pass_auth = new->cgi_pass_auth != AP_CGI_PASS_AUTH_UNSET ? new->cgi_pass_auth : base->cgi_pass_auth;\n\n    if (new->cgi_var_rules) {\n        if (!conf->cgi_var_rules) {\n            conf->cgi_var_rules = new->cgi_var_rules;\n        }\n        else {\n            conf->cgi_var_rules = apr_hash_overlay(a, new->cgi_var_rules, conf->cgi_var_rules);\n        }\n    }\n\n    AP_CORE_MERGE_FLAG(qualify_redirect_url, conf, base, new);\n\n    return (void*)conf;\n}\n\n#if APR_HAS_SO_ACCEPTFILTER\n#ifndef ACCEPT_FILTER_NAME\n#define ACCEPT_FILTER_NAME \"httpready\"\n#ifdef __FreeBSD_version\n#if __FreeBSD_version < 411000 /* httpready broken before 4.1.1 */\n#undef ACCEPT_FILTER_NAME\n#define ACCEPT_FILTER_NAME \"dataready\"\n#endif\n#endif\n#endif\n#endif\n\nstatic void *create_core_server_config(apr_pool_t *a, server_rec *s)\n{\n    core_server_config *conf;\n    int is_virtual = s->is_virtual;\n\n    conf = (core_server_config *)apr_pcalloc(a, sizeof(core_server_config));\n\n    /* global-default / global-only settings */\n\n    if (!is_virtual) {\n        conf->ap_document_root = DOCUMENT_LOCATION;\n        conf->access_name = DEFAULT_ACCESS_FNAME;\n\n        /* A mapping only makes sense in the global context */\n        conf->accf_map = apr_table_make(a, 5);\n#if APR_HAS_SO_ACCEPTFILTER\n        apr_table_setn(conf->accf_map, \"http\", ACCEPT_FILTER_NAME);\n        apr_table_setn(conf->accf_map, \"https\", \"dataready\");\n#elif defined(WIN32)\n        /* 'data' is disabled on Windows due to a DoS vuln (PR 59970) */\n        apr_table_setn(conf->accf_map, \"http\", \"connect\");\n        apr_table_setn(conf->accf_map, \"https\", \"connect\");\n#else\n        apr_table_setn(conf->accf_map, \"http\", \"data\");\n        apr_table_setn(conf->accf_map, \"https\", \"data\");\n#endif\n    }\n    /* pcalloc'ed - we have NULL's/0's\n    else ** is_virtual ** {\n        conf->ap_document_root = NULL;\n        conf->access_name = NULL;\n        conf->accf_map = NULL;\n    }\n     */\n\n    /* initialization, no special case for global context */\n\n    conf->sec_dir = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));\n    conf->sec_url = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));\n\n    /* pcalloc'ed - we have NULL's/0's\n    conf->gprof_dir = NULL;\n\n    ** recursion stopper; 0 == unset\n    conf->redirect_limit = 0;\n    conf->subreq_limit = 0;\n\n    conf->protocol = NULL;\n     */\n\n    conf->trace_enable = AP_TRACE_UNSET;\n\n    conf->protocols = apr_array_make(a, 5, sizeof(const char *));\n    conf->protocols_honor_order = -1;\n    conf->async_filter = 0;\n\n    return (void *)conf;\n}\n\nstatic void *merge_core_server_configs(apr_pool_t *p, void *basev, void *virtv)\n{\n    core_server_config *base = (core_server_config *)basev;\n    core_server_config *virt = (core_server_config *)virtv;\n    core_server_config *conf = (core_server_config *)\n                               apr_pmemdup(p, base, sizeof(core_server_config));\n\n    if (virt->ap_document_root)\n        conf->ap_document_root = virt->ap_document_root;\n\n    if (virt->access_name)\n        conf->access_name = virt->access_name;\n\n    /* XXX optimize to keep base->sec_ pointers if virt->sec_ array is empty */\n    conf->sec_dir = apr_array_append(p, base->sec_dir, virt->sec_dir);\n    conf->sec_url = apr_array_append(p, base->sec_url, virt->sec_url);\n\n    if (virt->redirect_limit)\n        conf->redirect_limit = virt->redirect_limit;\n\n    if (virt->subreq_limit)\n        conf->subreq_limit = virt->subreq_limit;\n\n    if (virt->trace_enable != AP_TRACE_UNSET)\n        conf->trace_enable = virt->trace_enable;\n\n    if (virt->http09_enable != AP_HTTP09_UNSET)\n        conf->http09_enable = virt->http09_enable;\n\n    if (virt->http_conformance != AP_HTTP_CONFORMANCE_UNSET)\n        conf->http_conformance = virt->http_conformance;\n\n    if (virt->http_methods != AP_HTTP_METHODS_UNSET)\n        conf->http_methods = virt->http_methods;\n\n    if (virt->http_cl_head_zero != AP_HTTP_CL_HEAD_ZERO_UNSET)\n        conf->http_cl_head_zero = virt->http_cl_head_zero;\n\n    if (virt->http_expect_strict != AP_HTTP_EXPECT_STRICT_UNSET)\n        conf->http_expect_strict = virt->http_expect_strict;\n\n    /* no action for virt->accf_map, not allowed per-vhost */\n\n    if (virt->protocol)\n        conf->protocol = virt->protocol;\n\n    if (virt->gprof_dir)\n        conf->gprof_dir = virt->gprof_dir;\n\n    if (virt->error_log_format)\n        conf->error_log_format = virt->error_log_format;\n\n    if (virt->error_log_conn)\n        conf->error_log_conn = virt->error_log_conn;\n\n    if (virt->error_log_req)\n        conf->error_log_req = virt->error_log_req;\n\n    if (virt->conn_log_level) {\n        if (!conf->conn_log_level) {\n            conf->conn_log_level = virt->conn_log_level;\n        }\n        else {\n            /* apr_array_append actually creates a new array */\n            conf->conn_log_level = apr_array_append(p, conf->conn_log_level,\n                                                    virt->conn_log_level);\n        }\n    }\n\n    conf->merge_trailers = (virt->merge_trailers != AP_MERGE_TRAILERS_UNSET)\n                           ? virt->merge_trailers\n                           : base->merge_trailers;\n\n    conf->protocols = ((virt->protocols->nelts > 0) ?\n                       virt->protocols : base->protocols);\n    conf->protocols_honor_order = ((virt->protocols_honor_order < 0) ?\n                                       base->protocols_honor_order :\n                                       virt->protocols_honor_order);\n    conf->async_filter = ((virt->async_filter_set) ?\n                                       virt->async_filter :\n                                       base->async_filter);\n    conf->async_filter_set = base->async_filter_set || virt->async_filter_set;\n\n    return conf;\n}\n\n/* Add per-directory configuration entry (for <directory> section);\n * these are part of the core server config.\n */\n\nAP_CORE_DECLARE(void) ap_add_per_dir_conf(server_rec *s, void *dir_config)\n{\n    core_server_config *sconf = ap_get_core_module_config(s->module_config);\n    void **new_space = (void **)apr_array_push(sconf->sec_dir);\n\n    *new_space = dir_config;\n}\n\nAP_CORE_DECLARE(void) ap_add_per_url_conf(server_rec *s, void *url_config)\n{\n    core_server_config *sconf = ap_get_core_module_config(s->module_config);\n    void **new_space = (void **)apr_array_push(sconf->sec_url);\n\n    *new_space = url_config;\n}\n\nAP_CORE_DECLARE(void) ap_add_file_conf(apr_pool_t *p, core_dir_config *conf,\n                                       void *url_config)\n{\n    void **new_space;\n\n    if (!conf->sec_file)\n        conf->sec_file = apr_array_make(p, 2, sizeof(ap_conf_vector_t *));\n\n    new_space = (void **)apr_array_push(conf->sec_file);\n    *new_space = url_config;\n}\n\nAP_CORE_DECLARE(const char *) ap_add_if_conf(apr_pool_t *p,\n                                             core_dir_config *conf,\n                                             void *if_config)\n{\n    void **new_space;\n    core_dir_config *new = ap_get_module_config(if_config, &core_module);\n\n    if (!conf->sec_if) {\n        conf->sec_if = apr_array_make(p, 2, sizeof(ap_conf_vector_t *));\n    }\n    if (new->condition_ifelse & AP_CONDITION_ELSE) {\n        int have_if = 0;\n        if (conf->sec_if->nelts > 0) {\n            core_dir_config *last;\n            ap_conf_vector_t *lastelt = APR_ARRAY_IDX(conf->sec_if,\n                                                      conf->sec_if->nelts - 1,\n                                                      ap_conf_vector_t *);\n            last = ap_get_module_config(lastelt, &core_module);\n            if (last->condition_ifelse & AP_CONDITION_IF)\n                have_if = 1;\n        }\n        if (!have_if)\n            return \"<Else> or <ElseIf> section without previous <If> or \"\n                   \"<ElseIf> section in same scope\";\n    }\n\n    new_space = (void **)apr_array_push(conf->sec_if);\n    *new_space = if_config;\n    return NULL;\n}\n\n\n/* We need to do a stable sort, qsort isn't stable.  So to make it stable\n * we'll be maintaining the original index into the list, and using it\n * as the minor key during sorting.  The major key is the number of\n * components (where the root component is zero).\n */\nstruct reorder_sort_rec {\n    ap_conf_vector_t *elt;\n    int orig_index;\n};\n\nstatic int reorder_sorter(const void *va, const void *vb)\n{\n    const struct reorder_sort_rec *a = va;\n    const struct reorder_sort_rec *b = vb;\n    core_dir_config *core_a;\n    core_dir_config *core_b;\n\n    core_a = ap_get_core_module_config(a->elt);\n    core_b = ap_get_core_module_config(b->elt);\n\n    /* a regex always sorts after a non-regex\n     */\n    if (!core_a->r && core_b->r) {\n        return -1;\n    }\n    else if (core_a->r && !core_b->r) {\n        return 1;\n    }\n\n    /* we always sort next by the number of components\n     */\n    if (core_a->d_components < core_b->d_components) {\n        return -1;\n    }\n    else if (core_a->d_components > core_b->d_components) {\n        return 1;\n    }\n\n    /* They have the same number of components, we now have to compare\n     * the minor key to maintain the original order (from the config.)\n     */\n    return a->orig_index - b->orig_index;\n}\n\nvoid ap_core_reorder_directories(apr_pool_t *p, server_rec *s)\n{\n    core_server_config *sconf;\n    apr_array_header_t *sec_dir;\n    struct reorder_sort_rec *sortbin;\n    int nelts;\n    ap_conf_vector_t **elts;\n    int i;\n    apr_pool_t *tmp;\n\n    sconf = ap_get_core_module_config(s->module_config);\n    sec_dir = sconf->sec_dir;\n    nelts = sec_dir->nelts;\n    elts = (ap_conf_vector_t **)sec_dir->elts;\n\n    if (!nelts) {\n        /* simple case of already being sorted... */\n        /* We're not checking this condition to be fast... we're checking\n         * it to avoid trying to palloc zero bytes, which can trigger some\n         * memory debuggers to barf\n         */\n        return;\n    }\n\n    /* we have to allocate tmp space to do a stable sort */\n    apr_pool_create(&tmp, p);\n    sortbin = apr_palloc(tmp, sec_dir->nelts * sizeof(*sortbin));\n    for (i = 0; i < nelts; ++i) {\n        sortbin[i].orig_index = i;\n        sortbin[i].elt = elts[i];\n    }\n\n    qsort(sortbin, nelts, sizeof(*sortbin), reorder_sorter);\n\n    /* and now copy back to the original array */\n    for (i = 0; i < nelts; ++i) {\n        elts[i] = sortbin[i].elt;\n    }\n\n    apr_pool_destroy(tmp);\n}\n\n/*****************************************************************\n *\n * There are some elements of the core config structures in which\n * other modules have a legitimate interest (this is ugly, but necessary\n * to preserve NCSA back-compatibility).  So, we have a bunch of accessors\n * here...\n */\n\nAP_DECLARE(int) ap_allow_options(request_rec *r)\n{\n    core_dir_config *conf =\n      (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n\n    return conf->opts;\n}\n\nAP_DECLARE(int) ap_allow_overrides(request_rec *r)\n{\n    core_dir_config *conf;\n    conf = (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n\n    return conf->override;\n}\n\n/*\n * Optional function coming from mod_authn_core, used for\n * retrieving the type of autorization\n */\nstatic APR_OPTIONAL_FN_TYPE(authn_ap_auth_type) *authn_ap_auth_type;\n\nAP_DECLARE(const char *) ap_auth_type(request_rec *r)\n{\n    if (authn_ap_auth_type) {\n        return authn_ap_auth_type(r);\n    }\n    return NULL;\n}\n\n/*\n * Optional function coming from mod_authn_core, used for\n * retrieving the authorization realm\n */\nstatic APR_OPTIONAL_FN_TYPE(authn_ap_auth_name) *authn_ap_auth_name;\n\nAP_DECLARE(const char *) ap_auth_name(request_rec *r)\n{\n    if (authn_ap_auth_name) {\n        return authn_ap_auth_name(r);\n    }\n    return NULL;\n}\n\n/*\n * Optional function coming from mod_access_compat, used to determine how\n   access control interacts with authentication/authorization\n */\nstatic APR_OPTIONAL_FN_TYPE(access_compat_ap_satisfies) *access_compat_ap_satisfies;\n\nAP_DECLARE(int) ap_satisfies(request_rec *r)\n{\n    if (access_compat_ap_satisfies) {\n        return access_compat_ap_satisfies(r);\n    }\n    return SATISFY_NOSPEC;\n}\n\nAP_DECLARE(const char *) ap_document_root(request_rec *r) /* Don't use this! */\n{\n    core_server_config *sconf;\n    core_request_config *rconf = ap_get_core_module_config(r->request_config);\n    if (rconf->document_root)\n        return rconf->document_root;\n    sconf = ap_get_core_module_config(r->server->module_config);\n    return sconf->ap_document_root;\n}\n\nAP_DECLARE(const char *) ap_context_prefix(request_rec *r)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    if (conf->context_prefix)\n        return conf->context_prefix;\n    else\n        return \"\";\n}\n\nAP_DECLARE(const char *) ap_context_document_root(request_rec *r)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    if (conf->context_document_root)\n        return conf->context_document_root;\n    else\n        return ap_document_root(r);\n}\n\nAP_DECLARE(void) ap_set_document_root(request_rec *r, const char *document_root)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    conf->document_root = document_root;\n}\n\nAP_DECLARE(void) ap_set_context_info(request_rec *r, const char *context_prefix,\n                                     const char *context_document_root)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    if (context_prefix)\n        conf->context_prefix = context_prefix;\n    if (context_document_root)\n        conf->context_document_root = context_document_root;\n}\n\n/* Should probably just get rid of this... the only code that cares is\n * part of the core anyway (and in fact, it isn't publicised to other\n * modules).\n */\n\nchar *ap_response_code_string(request_rec *r, int error_index)\n{\n    core_dir_config *dirconf;\n    core_request_config *reqconf = ap_get_core_module_config(r->request_config);\n    const char *err;\n    const char *response;\n    ap_expr_info_t *expr;\n\n    /* check for string registered via ap_custom_response() first */\n    if (reqconf->response_code_strings != NULL\n            && reqconf->response_code_strings[error_index] != NULL) {\n        return reqconf->response_code_strings[error_index];\n    }\n\n    /* check for string specified via ErrorDocument */\n    dirconf = ap_get_core_module_config(r->per_dir_config);\n\n    if (!dirconf->response_code_exprs) {\n        return NULL;\n    }\n\n    expr = apr_hash_get(dirconf->response_code_exprs, &error_index,\n            sizeof(error_index));\n    if (!expr) {\n        return NULL;\n    }\n\n    /* special token to indicate revert back to default */\n    if ((char *) expr == &errordocument_default) {\n        return NULL;\n    }\n\n    err = NULL;\n    response = ap_expr_str_exec(r, expr, &err);\n    if (err) {\n        ap_log_rerror(\n                APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02841) \"core: ErrorDocument: can't \"\n                \"evaluate require expression: %s\", err);\n        return NULL;\n    }\n\n    /* alas, duplication required as we return not-const */\n    return apr_pstrdup(r->pool, response);\n}\n\n\n/* Code from Harald Hanche-Olsen <hanche@imf.unit.no> */\nstatic APR_INLINE int do_double_reverse (int double_reverse,\n                                         const char *remote_host,\n                                         apr_sockaddr_t *client_addr,\n                                         apr_pool_t *pool)\n{\n    apr_sockaddr_t *sa;\n    apr_status_t rv;\n\n    if (double_reverse) {\n        /* already done */\n        return double_reverse;\n    }\n\n    if (remote_host == NULL || remote_host[0] == '\\0') {\n        /* single reverse failed, so don't bother */\n        return -1;\n    }\n\n    rv = apr_sockaddr_info_get(&sa, remote_host, APR_UNSPEC, 0, 0, pool);\n    if (rv == APR_SUCCESS) {\n        while (sa) {\n            if (apr_sockaddr_equal(sa, client_addr)) {\n                return 1;\n            }\n\n            sa = sa->next;\n        }\n    }\n\n    return -1;\n}\n\nAP_DECLARE(const char *) ap_get_remote_host(conn_rec *conn, void *dir_config,\n                                            int type, int *str_is_ip)\n{\n    int hostname_lookups;\n    int ignored_str_is_ip;\n\n    if (!str_is_ip) { /* caller doesn't want to know */\n        str_is_ip = &ignored_str_is_ip;\n    }\n    *str_is_ip = 0;\n\n    /* If we haven't checked the host name, and we want to */\n    if (dir_config) {\n        hostname_lookups = ((core_dir_config *)ap_get_core_module_config(dir_config))\n                           ->hostname_lookups;\n\n        if (hostname_lookups == HOSTNAME_LOOKUP_UNSET) {\n            hostname_lookups = HOSTNAME_LOOKUP_OFF;\n        }\n    }\n    else {\n        /* the default */\n        hostname_lookups = HOSTNAME_LOOKUP_OFF;\n    }\n\n    if (type != REMOTE_NOLOOKUP\n        && conn->remote_host == NULL\n        && (type == REMOTE_DOUBLE_REV\n        || hostname_lookups != HOSTNAME_LOOKUP_OFF)) {\n\n        if (apr_getnameinfo(&conn->remote_host, conn->client_addr, 0)\n            == APR_SUCCESS) {\n            ap_str_tolower(conn->remote_host);\n\n            if (hostname_lookups == HOSTNAME_LOOKUP_DOUBLE) {\n                conn->double_reverse = do_double_reverse(conn->double_reverse,\n                                                         conn->remote_host,\n                                                         conn->client_addr,\n                                                         conn->pool);\n                if (conn->double_reverse != 1) {\n                    conn->remote_host = NULL;\n                }\n            }\n        }\n\n        /* if failed, set it to the NULL string to indicate error */\n        if (conn->remote_host == NULL) {\n            conn->remote_host = \"\";\n        }\n    }\n\n    if (type == REMOTE_DOUBLE_REV) {\n        conn->double_reverse = do_double_reverse(conn->double_reverse,\n                                                 conn->remote_host,\n                                                 conn->client_addr, conn->pool);\n        if (conn->double_reverse == -1) {\n            return NULL;\n        }\n    }\n\n    /*\n     * Return the desired information; either the remote DNS name, if found,\n     * or either NULL (if the hostname was requested) or the IP address\n     * (if any identifier was requested).\n     */\n    if (conn->remote_host != NULL && conn->remote_host[0] != '\\0') {\n        return conn->remote_host;\n    }\n    else {\n        if (type == REMOTE_HOST || type == REMOTE_DOUBLE_REV) {\n            return NULL;\n        }\n        else {\n            *str_is_ip = 1;\n            return conn->client_ip;\n        }\n    }\n}\n\nAP_DECLARE(const char *) ap_get_useragent_host(request_rec *r,\n                                               int type, int *str_is_ip)\n{\n    conn_rec *conn = r->connection;\n    int hostname_lookups;\n    int ignored_str_is_ip;\n\n    /* Guard here when examining the host before the read_request hook\n     * has populated an r->useragent_addr\n     */\n    if (!r->useragent_addr || (r->useragent_addr == conn->client_addr)) {\n        return ap_get_remote_host(conn, r->per_dir_config, type, str_is_ip);\n    }\n\n    if (!str_is_ip) { /* caller doesn't want to know */\n        str_is_ip = &ignored_str_is_ip;\n    }\n    *str_is_ip = 0;\n\n    hostname_lookups = ((core_dir_config *)\n                        ap_get_core_module_config(r->per_dir_config))\n                            ->hostname_lookups;\n    if (hostname_lookups == HOSTNAME_LOOKUP_UNSET) {\n        hostname_lookups = HOSTNAME_LOOKUP_OFF;\n    }\n\n    if (type != REMOTE_NOLOOKUP\n        && r->useragent_host == NULL\n        && (type == REMOTE_DOUBLE_REV\n        || hostname_lookups != HOSTNAME_LOOKUP_OFF)) {\n\n        if (apr_getnameinfo(&r->useragent_host, r->useragent_addr, 0)\n            == APR_SUCCESS) {\n            ap_str_tolower(r->useragent_host);\n\n            if (hostname_lookups == HOSTNAME_LOOKUP_DOUBLE) {\n                r->double_reverse = do_double_reverse(r->double_reverse,\n                                                      r->useragent_host,\n                                                      r->useragent_addr,\n                                                      r->pool);\n                if (r->double_reverse != 1) {\n                    r->useragent_host = NULL;\n                }\n            }\n        }\n\n        /* if failed, set it to the NULL string to indicate error */\n        if (r->useragent_host == NULL) {\n            r->useragent_host = \"\";\n        }\n    }\n\n    if (type == REMOTE_DOUBLE_REV) {\n        r->double_reverse = do_double_reverse(r->double_reverse,\n                                              r->useragent_host,\n                                              r->useragent_addr, r->pool);\n        if (r->double_reverse == -1) {\n            return NULL;\n        }\n    }\n\n    /*\n     * Return the desired information; either the remote DNS name, if found,\n     * or either NULL (if the hostname was requested) or the IP address\n     * (if any identifier was requested).\n     */\n    if (r->useragent_host != NULL && r->useragent_host[0] != '\\0') {\n        return r->useragent_host;\n    }\n    else {\n        if (type == REMOTE_HOST || type == REMOTE_DOUBLE_REV) {\n            return NULL;\n        }\n        else {\n            *str_is_ip = 1;\n            return r->useragent_ip;\n        }\n    }\n}\n\n/*\n * Optional function coming from mod_ident, used for looking up ident user\n */\nstatic APR_OPTIONAL_FN_TYPE(ap_ident_lookup) *ident_lookup;\n\nAP_DECLARE(const char *) ap_get_remote_logname(request_rec *r)\n{\n    if (r->connection->remote_logname != NULL) {\n        return r->connection->remote_logname;\n    }\n\n    if (ident_lookup) {\n        return ident_lookup(r);\n    }\n\n    return NULL;\n}\n\n/* There are two options regarding what the \"name\" of a server is.  The\n * \"canonical\" name as defined by ServerName and Port, or the \"client's\n * name\" as supplied by a possible Host: header or full URI.\n *\n * The DNS option to UseCanonicalName causes this routine to do a\n * reverse lookup on the local IP address of the connection and use\n * that for the ServerName. This makes its value more reliable while\n * at the same time allowing Demon's magic virtual hosting to work.\n * The assumption is that DNS lookups are sufficiently quick...\n * -- fanf 1998-10-03\n */\nAP_DECLARE(const char *) ap_get_server_name(request_rec *r)\n{\n    conn_rec *conn = r->connection;\n    core_dir_config *d;\n    const char *retval;\n\n    d = (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n\n    switch (d->use_canonical_name) {\n        case USE_CANONICAL_NAME_ON:\n            retval = r->server->server_hostname;\n            break;\n        case USE_CANONICAL_NAME_DNS:\n            if (conn->local_host == NULL) {\n                if (apr_getnameinfo(&conn->local_host,\n                                conn->local_addr, 0) != APR_SUCCESS)\n                    conn->local_host = apr_pstrdup(conn->pool,\n                                               r->server->server_hostname);\n                else {\n                    ap_str_tolower(conn->local_host);\n                }\n            }\n            retval = conn->local_host;\n            break;\n        case USE_CANONICAL_NAME_OFF:\n        case USE_CANONICAL_NAME_UNSET:\n            retval = r->hostname ? r->hostname : r->server->server_hostname;\n            break;\n        default:\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00109)\n                         \"ap_get_server_name: Invalid UCN Option somehow\");\n            retval = \"localhost\";\n            break;\n    }\n    return retval;\n}\n\n/*\n * Get the current server name from the request for the purposes\n * of using in a URL.  If the server name is an IPv6 literal\n * address, it will be returned in URL format (e.g., \"[fe80::1]\").\n */\nAP_DECLARE(const char *) ap_get_server_name_for_url(request_rec *r)\n{\n    const char *plain_server_name = ap_get_server_name(r);\n\n#if APR_HAVE_IPV6\n    if (ap_strchr_c(plain_server_name, ':')) { /* IPv6 literal? */\n        return apr_pstrcat(r->pool, \"[\", plain_server_name, \"]\", NULL);\n    }\n#endif\n    return plain_server_name;\n}\n\nAP_DECLARE(apr_port_t) ap_get_server_port(const request_rec *r)\n{\n    apr_port_t port;\n    core_dir_config *d =\n      (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n\n    switch (d->use_canonical_name) {\n        case USE_CANONICAL_NAME_OFF:\n        case USE_CANONICAL_NAME_DNS:\n        case USE_CANONICAL_NAME_UNSET:\n            if (d->use_canonical_phys_port == USE_CANONICAL_PHYS_PORT_ON)\n                port = r->parsed_uri.port_str ? r->parsed_uri.port :\n                       r->connection->local_addr->port ? r->connection->local_addr->port :\n                       r->server->port ? r->server->port :\n                       ap_default_port(r);\n            else /* USE_CANONICAL_PHYS_PORT_OFF or USE_CANONICAL_PHYS_PORT_UNSET */\n                port = r->parsed_uri.port_str ? r->parsed_uri.port :\n                       r->server->port ? r->server->port :\n                       ap_default_port(r);\n            break;\n        case USE_CANONICAL_NAME_ON:\n            /* With UseCanonicalName on (and in all versions prior to 1.3)\n             * Apache will use the hostname and port specified in the\n             * ServerName directive to construct a canonical name for the\n             * server. (If no port was specified in the ServerName\n             * directive, Apache uses the port supplied by the client if\n             * any is supplied, and finally the default port for the protocol\n             * used.\n             */\n            if (d->use_canonical_phys_port == USE_CANONICAL_PHYS_PORT_ON)\n                port = r->server->port ? r->server->port :\n                       r->connection->local_addr->port ? r->connection->local_addr->port :\n                       ap_default_port(r);\n            else /* USE_CANONICAL_PHYS_PORT_OFF or USE_CANONICAL_PHYS_PORT_UNSET */\n                port = r->server->port ? r->server->port :\n                       ap_default_port(r);\n            break;\n        default:\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00110)\n                         \"ap_get_server_port: Invalid UCN Option somehow\");\n            port = ap_default_port(r);\n            break;\n    }\n\n    return port;\n}\n\nAP_DECLARE(char *) ap_construct_url(apr_pool_t *p, const char *uri,\n                                    request_rec *r)\n{\n    unsigned port = ap_get_server_port(r);\n    const char *host = ap_get_server_name_for_url(r);\n\n    if (ap_is_default_port(port, r)) {\n        return apr_pstrcat(p, ap_http_scheme(r), \"://\", host, uri, NULL);\n    }\n\n    return apr_psprintf(p, \"%s://%s:%u%s\", ap_http_scheme(r), host, port, uri);\n}\n\nAP_DECLARE(apr_off_t) ap_get_limit_req_body(const request_rec *r)\n{\n    core_dir_config *d =\n      (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n\n    if (d->limit_req_body == AP_LIMIT_REQ_BODY_UNSET) {\n        return AP_DEFAULT_LIMIT_REQ_BODY;\n    }\n\n    return d->limit_req_body;\n}\n\n\n/*****************************************************************\n *\n * Commands... this module handles almost all of the NCSA httpd.conf\n * commands, but most of the old srm.conf is in the modules.\n */\n\n\n/* returns a parent if it matches the given directive */\nstatic const ap_directive_t * find_parent(const ap_directive_t *dirp,\n                                          const char *what)\n{\n    while (dirp->parent != NULL) {\n        dirp = dirp->parent;\n\n        /* ### it would be nice to have atom-ized directives */\n        if (ap_cstr_casecmp(dirp->directive, what) == 0)\n            return dirp;\n    }\n\n    return NULL;\n}\n\nAP_DECLARE(const char *) ap_check_cmd_context(cmd_parms *cmd,\n                                              unsigned forbidden)\n{\n    const char *gt = (cmd->cmd->name[0] == '<'\n                      && cmd->cmd->name[strlen(cmd->cmd->name)-1] != '>')\n                         ? \">\" : \"\";\n    const ap_directive_t *found;\n\n    if ((forbidden & NOT_IN_VIRTUALHOST) && cmd->server->is_virtual) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,\n                           \" cannot occur within <VirtualHost> section\", NULL);\n    }\n\n    if ((forbidden & (NOT_IN_LIMIT | NOT_IN_DIR_LOC_FILE))\n        && cmd->limited != -1) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,\n                           \" cannot occur within <Limit> or <LimitExcept> \"\n                           \"section\", NULL);\n    }\n\n    if ((forbidden & NOT_IN_HTACCESS) && (cmd->pool == cmd->temp_pool)) {\n         return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,\n                            \" cannot occur within htaccess files\", NULL);\n    }\n\n    if ((forbidden & NOT_IN_DIR_LOC_FILE) == NOT_IN_DIR_LOC_FILE) {\n        if (cmd->path != NULL) {\n            return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,\n                            \" cannot occur within <Directory/Location/Files> \"\n                            \"section\", NULL);\n        }\n        if (cmd->cmd->req_override & EXEC_ON_READ) {\n            /* EXEC_ON_READ must be NOT_IN_DIR_LOC_FILE, if not, it will\n             * (deliberately) segfault below in the individual tests...\n             */\n            return NULL;\n        }\n    }\n\n    if (((forbidden & NOT_IN_DIRECTORY)\n         && ((found = find_parent(cmd->directive, \"<Directory\"))\n             || (found = find_parent(cmd->directive, \"<DirectoryMatch\"))))\n        || ((forbidden & NOT_IN_LOCATION)\n            && ((found = find_parent(cmd->directive, \"<Location\"))\n                || (found = find_parent(cmd->directive, \"<LocationMatch\"))))\n        || ((forbidden & NOT_IN_FILES)\n            && ((found = find_parent(cmd->directive, \"<Files\"))\n                || (found = find_parent(cmd->directive, \"<FilesMatch\"))\n                || (found = find_parent(cmd->directive, \"<If\"))\n                || (found = find_parent(cmd->directive, \"<ElseIf\"))\n                || (found = find_parent(cmd->directive, \"<Else\"))))\n        || ((forbidden & NOT_IN_PROXY)\n            && ((found = find_parent(cmd->directive, \"<Proxy\"))\n                || (found = find_parent(cmd->directive, \"<ProxyMatch\"))))) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name, gt,\n                           \" cannot occur within \", found->directive,\n                           \"> section\", NULL);\n    }\n\n    return NULL;\n}\n\nstatic const char *set_access_name(cmd_parms *cmd, void *dummy,\n                                   const char *arg)\n{\n    void *sconf = cmd->server->module_config;\n    core_server_config *conf = ap_get_core_module_config(sconf);\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    if (err != NULL) {\n        return err;\n    }\n\n    conf->access_name = apr_pstrdup(cmd->pool, arg);\n    return NULL;\n}\n\nAP_DECLARE(const char *) ap_resolve_env(apr_pool_t *p, const char * word)\n{\n# define SMALL_EXPANSION 5\n    struct sll {\n        struct sll *next;\n        const char *string;\n        apr_size_t len;\n    } *result, *current, sresult[SMALL_EXPANSION];\n    char *res_buf, *cp;\n    const char *s, *e, *ep;\n    unsigned spc;\n    apr_size_t outlen;\n\n    s = ap_strchr_c(word, '$');\n    if (!s) {\n        return word;\n    }\n\n    /* well, actually something to do */\n    ep = word + strlen(word);\n    spc = 0;\n    result = current = &(sresult[spc++]);\n    current->next = NULL;\n    current->string = word;\n    current->len = s - word;\n    outlen = current->len;\n\n    do {\n        /* prepare next entry */\n        if (current->len) {\n            current->next = (spc < SMALL_EXPANSION)\n                            ? &(sresult[spc++])\n                            : (struct sll *)apr_palloc(p,\n                                                       sizeof(*current->next));\n            current = current->next;\n            current->next = NULL;\n            current->len = 0;\n        }\n\n        if (*s == '$') {\n            if (s[1] == '{' && (e = ap_strchr_c(s+2, '}'))) {\n                char *name = apr_pstrmemdup(p, s+2, e-s-2);\n                word = NULL;\n                if (server_config_defined_vars)\n                    word = apr_table_get(server_config_defined_vars, name);\n                if (!word)\n                    word = getenv(name);\n                if (word) {\n                    current->string = word;\n                    current->len = strlen(word);\n                    outlen += current->len;\n                }\n                else {\n                    if (ap_strchr(name, ':') == 0)\n                        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL, APLOGNO(00111)\n                                     \"Config variable ${%s} is not defined\",\n                                     name);\n                    current->string = s;\n                    current->len = e - s + 1;\n                    outlen += current->len;\n                }\n                s = e + 1;\n            }\n            else {\n                current->string = s++;\n                current->len = 1;\n                ++outlen;\n            }\n        }\n        else {\n            word = s;\n            s = ap_strchr_c(s, '$');\n            current->string = word;\n            current->len = s ? s - word : ep - word;\n            outlen += current->len;\n        }\n    } while (s && *s);\n\n    /* assemble result */\n    res_buf = cp = apr_palloc(p, outlen + 1);\n    do {\n        if (result->len) {\n            memcpy(cp, result->string, result->len);\n            cp += result->len;\n        }\n        result = result->next;\n    } while (result);\n    res_buf[outlen] = '\\0';\n\n    return res_buf;\n}\n\nstatic int reset_config_defines(void *dummy)\n{\n    ap_server_config_defines = saved_server_config_defines;\n    saved_server_config_defines = NULL;\n    server_config_defined_vars = NULL;\n    return OK;\n}\n\n/*\n * Make sure we can revert the effects of Define/UnDefine when restarting.\n * This function must be called once per loading of the config, before\n * ap_server_config_defines is changed. This may be during reading of the\n * config, which is even before the pre_config hook is run (due to\n * EXEC_ON_READ for Define/UnDefine).\n */\nstatic void init_config_defines(apr_pool_t *pconf)\n{\n    saved_server_config_defines = ap_server_config_defines;\n    /* Use apr_array_copy instead of apr_array_copy_hdr because it does not\n     * protect from the way unset_define removes entries.\n     */\n    ap_server_config_defines = apr_array_copy(pconf, ap_server_config_defines);\n}\n\nstatic const char *set_define(cmd_parms *cmd, void *dummy,\n                              const char *name, const char *value)\n{\n    if (cmd->parent && ap_cstr_casecmp(cmd->parent->directive, \"<VirtualHost\")) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name, \" is not valid in \",\n                                      cmd->parent->directive, \" context\", NULL);\n    }\n\n    if (ap_strchr_c(name, ':') != NULL) {\n        return \"Variable name must not contain ':'\";\n    }\n\n    if (!saved_server_config_defines) {\n        init_config_defines(cmd->pool);\n    }\n    if (!ap_exists_config_define(name)) {\n        *(const char **)apr_array_push(ap_server_config_defines) = name;\n    }\n    if (value) {\n        if (!server_config_defined_vars) {\n            server_config_defined_vars = apr_table_make(cmd->pool, 5);\n        }\n        apr_table_setn(server_config_defined_vars, name, value);\n    }\n\n    return NULL;\n}\n\nstatic const char *unset_define(cmd_parms *cmd, void *dummy,\n                                const char *name)\n{\n    int i;\n    const char **defines;\n    if (cmd->parent && ap_cstr_casecmp(cmd->parent->directive, \"<VirtualHost\")) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name, \" is not valid in \",\n                                      cmd->parent->directive, \" context\", NULL);\n    }\n\n    if (ap_strchr_c(name, ':') != NULL) {\n        return \"Variable name must not contain ':'\";\n    }\n\n    if (!saved_server_config_defines) {\n        init_config_defines(cmd->pool);\n    }\n\n    defines = (const char **)ap_server_config_defines->elts;\n    for (i = 0; i < ap_server_config_defines->nelts; i++) {\n        if (strcmp(defines[i], name) == 0) {\n            defines[i] = *(const char **)apr_array_pop(ap_server_config_defines);\n            break;\n        }\n    }\n\n    if (server_config_defined_vars) {\n        apr_table_unset(server_config_defined_vars, name);\n    }\n\n    return NULL;\n}\n\nstatic const char *generate_message(cmd_parms *cmd, void *dummy,\n                                    const char *arg)\n{\n    /* cast with 64-bit warning avoidance */\n    int level = (cmd->info==(void*)APLOG_ERR)? APLOG_ERR: APLOG_WARNING;\n    char * msg;\n\n    /* get position information from wherever we can? */\n    ap_configfile_t * cf = cmd->config_file;\n    ap_directive_t const * ed1 = cmd->directive;\n    ap_directive_t const * ed2 = cmd->err_directive;\n\n    /* expect an argument */\n    if (!arg || !*arg) {\n        return \"The Error or Warning directive was used with no message.\";\n    }\n\n    /* set message, strip off quotes if necessary */\n    msg = (char *)arg;\n    if (*arg == '\"' || *arg == '\\'') {\n        apr_size_t len = strlen(arg);\n        char last = *(arg + len - 1);\n\n        if (*arg == last) {\n            msg = apr_pstrndup(cmd->pool, arg + 1, len - 2);\n        }\n    }\n\n    /* generate error or warning with a configuration file position.\n     * the log is displayed on the terminal as no log file is opened yet.\n     */\n    ap_log_error(APLOG_MARK, level, 0, NULL,\n                 \"%s on line %d of %s\", msg,\n                 cf? cf->line_number:\n                   ed1? ed1->line_num:\n                     ed2? ed2->line_num: -1,\n                 cf? cf->name:\n                   ed1? ed1->filename:\n                     ed2? ed2->filename: \"<UNKNOWN>\");\n\n    /* message displayed above, return will stop configuration processing */\n    return level==APLOG_ERR?\n        \"Configuration processing stopped by Error directive\": NULL;\n}\n\n#ifdef GPROF\nstatic const char *set_gprof_dir(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    void *sconf = cmd->server->module_config;\n    core_server_config *conf = ap_get_core_module_config(sconf);\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    if (err != NULL) {\n        return err;\n    }\n\n    conf->gprof_dir = arg;\n    return NULL;\n}\n#endif /*GPROF*/\n\nstatic const char *set_add_default_charset(cmd_parms *cmd,\n                                           void *d_, const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (!ap_cstr_casecmp(arg, \"Off\")) {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_OFF;\n    }\n    else if (!ap_cstr_casecmp(arg, \"On\")) {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_ON;\n       d->add_default_charset_name = DEFAULT_ADD_DEFAULT_CHARSET_NAME;\n    }\n    else {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_ON;\n       d->add_default_charset_name = arg;\n    }\n\n    return NULL;\n}\n\nstatic const char *set_document_root(cmd_parms *cmd, void *dummy,\n                                     const char *arg)\n{\n    void *sconf = cmd->server->module_config;\n    core_server_config *conf = ap_get_core_module_config(sconf);\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    if (err != NULL) {\n        return err;\n    }\n\n    /* When ap_document_root_check is false; skip all the stuff below */\n    if (!ap_document_root_check) {\n       conf->ap_document_root = arg;\n       return NULL;\n    }\n\n    /* Make it absolute, relative to ServerRoot */\n    arg = ap_server_root_relative(cmd->pool, arg);\n    if (arg == NULL) {\n        return \"DocumentRoot must be a directory\";\n    }\n\n    if (apr_filepath_merge((char**)&conf->ap_document_root, NULL, arg,\n                           APR_FILEPATH_TRUENAME, cmd->pool) != APR_SUCCESS\n        || !ap_is_directory(cmd->temp_pool, arg)) {\n        if (cmd->server->is_virtual) {\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0,\n                          cmd->pool, APLOGNO(00112)\n                          \"Warning: DocumentRoot [%s] does not exist\",\n                          arg);\n            conf->ap_document_root = arg;\n        }\n        else {\n            return apr_psprintf(cmd->pool, \n                                \"DocumentRoot '%s' is not a directory, or is not readable\",\n                                arg);\n        }\n    }\n    return NULL;\n}\n\nAP_DECLARE(void) ap_custom_response(request_rec *r, int status,\n                                    const char *string)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    int idx;\n\n    if (conf->response_code_strings == NULL) {\n        conf->response_code_strings =\n            apr_pcalloc(r->pool,\n                        sizeof(*conf->response_code_strings) * RESPONSE_CODES);\n    }\n\n    idx = ap_index_of_response(status);\n\n    conf->response_code_strings[idx] =\n       ((ap_is_url(string) || (*string == '/')) && (*string != '\"')) ?\n       apr_pstrdup(r->pool, string) : apr_pstrcat(r->pool, \"\\\"\", string, NULL);\n}\n\nstatic const char *set_error_document(cmd_parms *cmd, void *conf_,\n                                      const char *errno_str, const char *msg)\n{\n    core_dir_config *conf = conf_;\n    int error_number, index_number, idx500;\n    enum { MSG, LOCAL_PATH, REMOTE_PATH } what = MSG;\n\n    /* 1st parameter should be a 3 digit number, which we recognize;\n     * convert it into an array index\n     */\n    error_number = atoi(errno_str);\n    idx500 = ap_index_of_response(HTTP_INTERNAL_SERVER_ERROR);\n\n    if (error_number == HTTP_INTERNAL_SERVER_ERROR) {\n        index_number = idx500;\n    }\n    else if ((index_number = ap_index_of_response(error_number)) == idx500) {\n        return apr_pstrcat(cmd->pool, \"Unsupported HTTP response code \",\n                           errno_str, NULL);\n    }\n\n    /* Heuristic to determine second argument. */\n    if (ap_strchr_c(msg,' '))\n        what = MSG;\n    else if (msg[0] == '/')\n        what = LOCAL_PATH;\n    else if (ap_is_url(msg))\n        what = REMOTE_PATH;\n    else\n        what = MSG;\n\n    /* The entry should be ignored if it is a full URL for a 401 error */\n\n    if (error_number == 401 && what == REMOTE_PATH) {\n        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, cmd->server, APLOGNO(00113)\n                     \"%s:%d cannot use a full URL in a 401 ErrorDocument \"\n                     \"directive --- ignoring!\", cmd->directive->filename, cmd->directive->line_num);\n    }\n    else { /* Store it... */\n        if (conf->response_code_exprs == NULL) {\n            conf->response_code_exprs = apr_hash_make(cmd->pool);\n        }\n\n        if (ap_cstr_casecmp(msg, \"default\") == 0) {\n            /* special case: ErrorDocument 404 default restores the\n             * canned server error response\n             */\n            apr_hash_set(conf->response_code_exprs,\n                    apr_pmemdup(cmd->pool, &index_number, sizeof(index_number)),\n                    sizeof(index_number), &errordocument_default);\n        }\n        else {\n            ap_expr_info_t *expr;\n            const char *expr_err = NULL;\n\n            /* hack. Prefix a \" if it is a msg; as that is what\n             * http_protocol.c relies on to distinguish between\n             * a msg and a (local) path.\n             */\n            const char *response =\n                    (what == MSG) ? apr_pstrcat(cmd->pool, \"\\\"\", msg, NULL) :\n                            apr_pstrdup(cmd->pool, msg);\n\n            expr = ap_expr_parse_cmd(cmd, response, AP_EXPR_FLAG_STRING_RESULT,\n                    &expr_err, NULL);\n\n            if (expr_err) {\n                return apr_pstrcat(cmd->temp_pool,\n                                   \"Cannot parse expression in ErrorDocument: \",\n                                   expr_err, NULL);\n            }\n\n            apr_hash_set(conf->response_code_exprs,\n                    apr_pmemdup(cmd->pool, &index_number, sizeof(index_number)),\n                    sizeof(index_number), expr);\n\n        }\n    }\n\n    return NULL;\n}\n\nstatic const char *set_allow_opts(cmd_parms *cmd, allow_options_t *opts,\n                                  const char *l)\n{\n    allow_options_t opt;\n    int first = 1;\n\n    char *w, *p = (char *) l;\n    char *tok_state;\n\n    while ((w = apr_strtok(p, \",\", &tok_state)) != NULL) {\n\n        if (first) {\n            p = NULL;\n            *opts = OPT_NONE;\n            first = 0;\n        }\n\n        if (!ap_cstr_casecmp(w, \"Indexes\")) {\n            opt = OPT_INDEXES;\n        }\n        else if (!ap_cstr_casecmp(w, \"Includes\")) {\n            /* If Includes is permitted, both Includes and\n             * IncludesNOEXEC may be changed. */\n            opt = (OPT_INCLUDES | OPT_INC_WITH_EXEC);\n        }\n        else if (!ap_cstr_casecmp(w, \"IncludesNOEXEC\")) {\n            opt = OPT_INCLUDES;\n        }\n        else if (!ap_cstr_casecmp(w, \"FollowSymLinks\")) {\n            opt = OPT_SYM_LINKS;\n        }\n        else if (!ap_cstr_casecmp(w, \"SymLinksIfOwnerMatch\")) {\n            opt = OPT_SYM_OWNER;\n        }\n        else if (!ap_cstr_casecmp(w, \"ExecCGI\")) {\n            opt = OPT_EXECCGI;\n        }\n        else if (!ap_cstr_casecmp(w, \"MultiViews\")) {\n            opt = OPT_MULTI;\n        }\n        else if (!ap_cstr_casecmp(w, \"RunScripts\")) { /* AI backcompat. Yuck */\n            opt = OPT_MULTI|OPT_EXECCGI;\n        }\n        else if (!ap_cstr_casecmp(w, \"None\")) {\n            opt = OPT_NONE;\n        }\n        else if (!ap_cstr_casecmp(w, \"All\")) {\n            opt = OPT_ALL;\n        }\n        else {\n            return apr_pstrcat(cmd->pool, \"Illegal option \", w, NULL);\n        }\n\n        *opts |= opt;\n    }\n\n    (*opts) &= (~OPT_UNSET);\n\n    return NULL;\n}\n\nstatic const char *set_override(cmd_parms *cmd, void *d_, const char *l)\n{\n    core_dir_config *d = d_;\n    char *w;\n    char *k, *v;\n    const char *err;\n\n    /* Throw a warning if we're in <Location> or <Files> */\n    if (ap_check_cmd_context(cmd, NOT_IN_LOCATION | NOT_IN_FILES)) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00114)\n                     \"Useless use of AllowOverride in line %d of %s.\",\n                     cmd->directive->line_num, cmd->directive->filename);\n    }\n    if ((err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS)) != NULL)\n        return err;\n\n    d->override = OR_NONE;\n    while (l[0]) {\n        w = ap_getword_conf(cmd->temp_pool, &l);\n\n        k = w;\n        v = strchr(k, '=');\n        if (v) {\n                *v++ = '\\0';\n        }\n\n        if (!ap_cstr_casecmp(w, \"Limit\")) {\n            d->override |= OR_LIMIT;\n        }\n        else if (!ap_cstr_casecmp(k, \"Options\")) {\n            d->override |= OR_OPTIONS;\n            if (v)\n                set_allow_opts(cmd, &(d->override_opts), v);\n            else\n                d->override_opts = OPT_ALL;\n        }\n        else if (!ap_cstr_casecmp(w, \"FileInfo\")) {\n            d->override |= OR_FILEINFO;\n        }\n        else if (!ap_cstr_casecmp(w, \"AuthConfig\")) {\n            d->override |= OR_AUTHCFG;\n        }\n        else if (!ap_cstr_casecmp(w, \"Indexes\")) {\n            d->override |= OR_INDEXES;\n        }\n        else if (!ap_cstr_casecmp(w, \"Nonfatal\")) {\n            if (!ap_cstr_casecmp(v, \"Override\")) {\n                d->override |= NONFATAL_OVERRIDE;\n            }\n            else if (!ap_cstr_casecmp(v, \"Unknown\")) {\n                d->override |= NONFATAL_UNKNOWN;\n            }\n            else if (!ap_cstr_casecmp(v, \"All\")) {\n                d->override |= NONFATAL_ALL;\n            }\n        }\n        else if (!ap_cstr_casecmp(w, \"None\")) {\n            d->override = OR_NONE;\n        }\n        else if (!ap_cstr_casecmp(w, \"All\")) {\n            d->override = OR_ALL;\n        }\n        else {\n            return apr_pstrcat(cmd->pool, \"Illegal override option \", w, NULL);\n        }\n\n        d->override &= ~OR_UNSET;\n    }\n\n    return NULL;\n}\n\nstatic const char *set_cgi_pass_auth(cmd_parms *cmd, void *d_, int flag)\n{\n    core_dir_config *d = d_;\n\n    d->cgi_pass_auth = flag ? AP_CGI_PASS_AUTH_ON : AP_CGI_PASS_AUTH_OFF;\n\n    return NULL;\n}\n\nstatic const char *set_cgi_var(cmd_parms *cmd, void *d_,\n                               const char *var, const char *rule_)\n{\n    core_dir_config *d = d_;\n    char *rule = apr_pstrdup(cmd->pool, rule_);\n\n    ap_str_tolower(rule);\n\n    if (!strcmp(var, \"REQUEST_URI\")) {\n        if (strcmp(rule, \"current-uri\") && strcmp(rule, \"original-uri\")) {\n            return \"Valid rules for REQUEST_URI are 'current-uri' and 'original-uri'\";\n        }\n    }\n    else {\n        return apr_pstrcat(cmd->pool, \"Unrecognized CGI variable: \\\"\",\n                           var, \"\\\"\", NULL);\n    }\n\n    if (!d->cgi_var_rules) {\n        d->cgi_var_rules = apr_hash_make(cmd->pool);\n    }\n    apr_hash_set(d->cgi_var_rules, var, APR_HASH_KEY_STRING, rule);\n    return NULL;\n}\n\nstatic const char *set_qualify_redirect_url(cmd_parms *cmd, void *d_, int flag)\n{\n    core_dir_config *d = d_;\n\n    d->qualify_redirect_url = flag ? AP_CORE_CONFIG_ON : AP_CORE_CONFIG_OFF;\n\n    return NULL;\n}\n\nstatic const char *set_override_list(cmd_parms *cmd, void *d_, int argc, char *const argv[])\n{\n    core_dir_config *d = d_;\n    int i;\n    const char *err;\n\n    /* Throw a warning if we're in <Location> or <Files> */\n    if (ap_check_cmd_context(cmd, NOT_IN_LOCATION | NOT_IN_FILES)) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00115)\n                     \"Useless use of AllowOverrideList at %s:%d\",\n                     cmd->directive->filename, cmd->directive->line_num);\n    }\n    if ((err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS)) != NULL)\n        return err;\n\n    d->override_list = apr_table_make(cmd->pool, argc);\n\n    for (i = 0; i < argc; i++) {\n        if (!ap_cstr_casecmp(argv[i], \"None\")) {\n            if (argc != 1) {\n                return \"'None' not allowed with other directives in \"\n                       \"AllowOverrideList\";\n            }\n            return NULL;\n        }\n        else {\n            const command_rec *result = NULL;\n            module *mod = ap_top_module;\n\n            result = ap_find_command_in_modules(argv[i], &mod);\n            if (result == NULL) {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,\n                             APLOGNO(00116) \"Discarding unrecognized \"\n                             \"directive `%s' in AllowOverrideList at %s:%d\",\n                             argv[i], cmd->directive->filename,\n                             cmd->directive->line_num);\n                continue;\n            }\n            else if ((result->req_override & (OR_ALL|ACCESS_CONF)) == 0) {\n                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server,\n                             APLOGNO(02304) \"Discarding directive `%s' not \"\n                             \"allowed in AllowOverrideList at %s:%d\",\n                             argv[i], cmd->directive->filename,\n                             cmd->directive->line_num);\n                continue;\n            }\n            else {\n                apr_table_setn(d->override_list, argv[i], \"1\");\n            }\n        }\n    }\n\n    return NULL;\n}\n\nstatic const char *set_options(cmd_parms *cmd, void *d_, const char *l)\n{\n    core_dir_config *d = d_;\n    allow_options_t opt;\n    int first = 1;\n    int merge = 0;\n    int all_none = 0;\n    char action;\n\n    while (l[0]) {\n        char *w = ap_getword_conf(cmd->temp_pool, &l);\n        action = '\\0';\n\n        if (*w == '+' || *w == '-') {\n            action = *(w++);\n            if (!merge && !first && !all_none) {\n                return \"Either all Options must start with + or -, or no Option may.\";\n            }\n            merge = 1;\n        }\n        else if (first) {\n            d->opts = OPT_NONE;\n        }\n        else if (merge) {\n            return \"Either all Options must start with + or -, or no Option may.\";\n        }\n\n        if (!ap_cstr_casecmp(w, \"Indexes\")) {\n            opt = OPT_INDEXES;\n        }\n        else if (!ap_cstr_casecmp(w, \"Includes\")) {\n            opt = (OPT_INCLUDES | OPT_INC_WITH_EXEC);\n        }\n        else if (!ap_cstr_casecmp(w, \"IncludesNOEXEC\")) {\n            opt = OPT_INCLUDES;\n        }\n        else if (!ap_cstr_casecmp(w, \"FollowSymLinks\")) {\n            opt = OPT_SYM_LINKS;\n        }\n        else if (!ap_cstr_casecmp(w, \"SymLinksIfOwnerMatch\")) {\n            opt = OPT_SYM_OWNER;\n        }\n        else if (!ap_cstr_casecmp(w, \"ExecCGI\")) {\n            opt = OPT_EXECCGI;\n        }\n        else if (!ap_cstr_casecmp(w, \"MultiViews\")) {\n            opt = OPT_MULTI;\n        }\n        else if (!ap_cstr_casecmp(w, \"RunScripts\")) { /* AI backcompat. Yuck */\n            opt = OPT_MULTI|OPT_EXECCGI;\n        }\n        else if (!ap_cstr_casecmp(w, \"None\")) {\n            if (!first) {\n                return \"'Options None' must be the first Option given.\";\n            }\n            else if (merge) { /* Only works since None may not follow any other option. */\n                return \"You may not use 'Options +None' or 'Options -None'.\";\n            }\n            opt = OPT_NONE;\n            all_none = 1;\n        }\n        else if (!ap_cstr_casecmp(w, \"All\")) {\n            if (!first) {\n                return \"'Options All' must be the first option given.\";\n            }\n            else if (merge) { /* Only works since All may not follow any other option. */\n                return \"You may not use 'Options +All' or 'Options -All'.\";\n            }\n            opt = OPT_ALL;\n            all_none = 1;\n        }\n        else {\n            return apr_pstrcat(cmd->pool, \"Illegal option \", w, NULL);\n        }\n\n        if ( (cmd->override_opts & opt) != opt ) {\n            return apr_pstrcat(cmd->pool, \"Option \", w, \" not allowed here\", NULL);\n        }\n        else if (action == '-') {\n            /* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */\n            d->opts_remove |= opt;\n            d->opts_add &= ~opt;\n            d->opts &= ~opt;\n        }\n        else if (action == '+') {\n            d->opts_add |= opt;\n            d->opts_remove &= ~opt;\n            d->opts |= opt;\n        }\n        else {\n            d->opts |= opt;\n        }\n\n        first = 0;\n    }\n\n    return NULL;\n}\n\nstatic const char *set_default_type(cmd_parms *cmd, void *d_,\n                                   const char *arg)\n{\n    if (ap_cstr_casecmp(arg, \"off\") != 0 && ap_cstr_casecmp(arg, \"none\") != 0) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00117)\n              \"Ignoring deprecated use of DefaultType in line %d of %s.\",\n                     cmd->directive->line_num, cmd->directive->filename);\n    }\n\n    return NULL;\n}\n\nstatic const char *set_sethandler(cmd_parms *cmd,\n                                     void *d_,\n                                     const char *arg_)\n{\n    core_dir_config *dirconf = d_;\n    const char *err;\n    dirconf->expr_handler = ap_expr_parse_cmd(cmd, arg_,\n                                          AP_EXPR_FLAG_STRING_RESULT,\n                                          &err, NULL);\n    if (err) {\n        return apr_pstrcat(cmd->pool,\n                \"Can't parse expression : \", err, NULL);\n    }\n    return NULL;\n}\n\n/*\n * Note what data should be used when forming file ETag values.\n * It would be nicer to do this as an ITERATE, but then we couldn't\n * remember the +/- state properly.\n */\nstatic const char *set_etag_bits(cmd_parms *cmd, void *mconfig,\n                                 const char *args_p)\n{\n    core_dir_config *cfg;\n    etag_components_t bit;\n    char action;\n    char *token;\n    const char *args;\n    int valid;\n    int first;\n    int explicit;\n\n    cfg = (core_dir_config *)mconfig;\n\n    args = args_p;\n    first = 1;\n    explicit = 0;\n    while (args[0] != '\\0') {\n        action = '*';\n        bit = ETAG_UNSET;\n        valid = 1;\n        token = ap_getword_conf(cmd->temp_pool, &args);\n        if ((*token == '+') || (*token == '-')) {\n            action = *token;\n            token++;\n        }\n        else {\n            /*\n             * The occurrence of an absolute setting wipes\n             * out any previous relative ones.  The first such\n             * occurrence forgets any inherited ones, too.\n             */\n            if (first) {\n                cfg->etag_bits = ETAG_UNSET;\n                cfg->etag_add = ETAG_UNSET;\n                cfg->etag_remove = ETAG_UNSET;\n                first = 0;\n            }\n        }\n\n        if (ap_cstr_casecmp(token, \"None\") == 0) {\n            if (action != '*') {\n                valid = 0;\n            }\n            else {\n                cfg->etag_bits = bit = ETAG_NONE;\n                explicit = 1;\n            }\n        }\n        else if (ap_cstr_casecmp(token, \"All\") == 0) {\n            if (action != '*') {\n                valid = 0;\n            }\n            else {\n                explicit = 1;\n                cfg->etag_bits = bit = ETAG_ALL;\n            }\n        }\n        else if (ap_cstr_casecmp(token, \"Size\") == 0) {\n            bit = ETAG_SIZE;\n        }\n        else if ((ap_cstr_casecmp(token, \"LMTime\") == 0)\n                 || (ap_cstr_casecmp(token, \"MTime\") == 0)\n                 || (ap_cstr_casecmp(token, \"LastModified\") == 0)) {\n            bit = ETAG_MTIME;\n        }\n        else if (ap_cstr_casecmp(token, \"INode\") == 0) {\n            bit = ETAG_INODE;\n        }\n        else {\n            return apr_pstrcat(cmd->pool, \"Unknown keyword '\",\n                               token, \"' for \", cmd->cmd->name,\n                               \" directive\", NULL);\n        }\n\n        if (! valid) {\n            return apr_pstrcat(cmd->pool, cmd->cmd->name, \" keyword '\",\n                               token, \"' cannot be used with '+' or '-'\",\n                               NULL);\n        }\n\n        if (action == '+') {\n            /*\n             * Make sure it's in the 'add' list and absent from the\n             * 'subtract' list.\n             */\n            cfg->etag_add |= bit;\n            cfg->etag_remove &= (~ bit);\n        }\n        else if (action == '-') {\n            cfg->etag_remove |= bit;\n            cfg->etag_add &= (~ bit);\n        }\n        else {\n            /*\n             * Non-relative values wipe out any + or - values\n             * accumulated so far.\n             */\n            cfg->etag_bits |= bit;\n            cfg->etag_add = ETAG_UNSET;\n            cfg->etag_remove = ETAG_UNSET;\n            explicit = 1;\n        }\n    }\n\n    /*\n     * Any setting at all will clear the 'None' and 'Unset' bits.\n     */\n\n    if (cfg->etag_add != ETAG_UNSET) {\n        cfg->etag_add &= (~ ETAG_UNSET);\n    }\n\n    if (cfg->etag_remove != ETAG_UNSET) {\n        cfg->etag_remove &= (~ ETAG_UNSET);\n    }\n\n    if (explicit) {\n        cfg->etag_bits &= (~ ETAG_UNSET);\n\n        if ((cfg->etag_bits & ETAG_NONE) != ETAG_NONE) {\n            cfg->etag_bits &= (~ ETAG_NONE);\n        }\n    }\n\n    return NULL;\n}\n\nstatic const char *set_enable_mmap(cmd_parms *cmd, void *d_,\n                                   const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        d->enable_mmap = ENABLE_MMAP_ON;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        d->enable_mmap = ENABLE_MMAP_OFF;\n    }\n    else {\n        return \"parameter must be 'on' or 'off'\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_enable_sendfile(cmd_parms *cmd, void *d_,\n                                   const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        d->enable_sendfile = ENABLE_SENDFILE_ON;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        d->enable_sendfile = ENABLE_SENDFILE_OFF;\n    }\n    else {\n        return \"parameter must be 'on' or 'off'\";\n    }\n\n    return NULL;\n}\n\n\n/*\n * Report a missing-'>' syntax error.\n */\nstatic char *unclosed_directive(cmd_parms *cmd)\n{\n    return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                       \"> directive missing closing '>'\", NULL);\n}\n\n/*\n * Report a missing args in '<Foo >' syntax error.\n */\nstatic char *missing_container_arg(cmd_parms *cmd)\n{\n    return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                       \"> directive requires additional arguments\", NULL);\n}\n\nAP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n\n        /* check for builtin or module registered method number */\n        methnum = ap_method_number_of(method);\n\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n            /* method has not been registered yet, but resource restriction\n             * is always checked before method handling, so register it.\n             */\n            if (cmd->pool == cmd->temp_pool) {\n                /* In .htaccess, we can't globally register new methods. */\n                return apr_psprintf(cmd->pool, \"Could not register method '%s' \"\n                                   \"for %s from .htaccess configuration\",\n                                    method, cmd->cmd->name);\n            }\n            methnum = ap_method_register(cmd->pool,\n                                         apr_pstrdup(cmd->pool, method));\n        }\n\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n\n    /* Killing two features with one function,\n     * if (tog == NULL) <Limit>, else <LimitExcept>\n     */\n    limited = tog ? ~limited : limited;\n\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n\n    cmd->limited &= limited;\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n\n    cmd->limited = old_limited;\n\n    return errmsg;\n}\n\n/* XXX: Bogus - need to do this differently (at least OS2/Netware suffer\n * the same problem!!!\n * We use this in <DirectoryMatch> and <FilesMatch>, to ensure that\n * people don't get bitten by wrong-cased regex matches\n */\n\n#ifdef WIN32\n#define USE_ICASE AP_REG_ICASE\n#else\n#define USE_ICASE 0\n#endif\n\nstatic const char *dirsection(cmd_parms *cmd, void *mconfig, const char *arg)\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    core_dir_config *conf;\n    ap_conf_vector_t *new_dir_conf = ap_create_per_dir_config(cmd->pool);\n    ap_regex_t *r = NULL;\n    const command_rec *thiscmd = cmd->cmd;\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    cmd->path = ap_getword_conf(cmd->pool, &arg);\n    cmd->override = OR_ALL|ACCESS_CONF;\n\n    if (!strcmp(cmd->path, \"~\")) {\n        cmd->path = ap_getword_conf(cmd->pool, &arg);\n        if (!cmd->path)\n            return \"<Directory ~ > block must specify a path\";\n        r = ap_pregcomp(cmd->pool, cmd->path, AP_REG_EXTENDED|USE_ICASE);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n    }\n    else if (thiscmd->cmd_data) { /* <DirectoryMatch> */\n        r = ap_pregcomp(cmd->pool, cmd->path, AP_REG_EXTENDED|USE_ICASE);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n    }\n    else if (strcmp(cmd->path, \"/\") != 0)\n    {\n        char *newpath;\n\n        /*\n         * Ensure that the pathname is canonical, and append the trailing /\n         */\n        apr_status_t rv = apr_filepath_merge(&newpath, NULL, cmd->path,\n                                             APR_FILEPATH_TRUENAME, cmd->pool);\n        if (rv != APR_SUCCESS && rv != APR_EPATHWILD) {\n            return apr_pstrcat(cmd->pool, \"<Directory \\\"\", cmd->path,\n                               \"\\\"> path is invalid.\", NULL);\n        }\n\n        cmd->path = newpath;\n        if (cmd->path[strlen(cmd->path) - 1] != '/')\n            cmd->path = apr_pstrcat(cmd->pool, cmd->path, \"/\", NULL);\n    }\n\n    /* initialize our config and fetch it */\n    conf = ap_set_config_vectors(cmd->server, new_dir_conf, cmd->path,\n                                 &core_module, cmd->pool);\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_dir_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    conf->r = r;\n    conf->d = cmd->path;\n    conf->d_is_fnmatch = (apr_fnmatch_test(conf->d) != 0);\n\n    if (r) {\n        conf->refs = apr_array_make(cmd->pool, 8, sizeof(char *));\n        ap_regname(r, conf->refs, AP_REG_MATCH, 1);\n    }\n\n    /* Make this explicit - the \"/\" root has 0 elements, that is, we\n     * will always merge it, and it will always sort and merge first.\n     * All others are sorted and tested by the number of slashes.\n     */\n    if (strcmp(conf->d, \"/\") == 0)\n        conf->d_components = 0;\n    else\n        conf->d_components = ap_count_dirs(conf->d);\n\n    ap_add_per_dir_conf(cmd->server, new_dir_conf);\n\n    if (*arg != '\\0') {\n        return apr_pstrcat(cmd->pool, \"Multiple \", thiscmd->name,\n                           \"> arguments not (yet) supported.\", NULL);\n    }\n\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n\n    return NULL;\n}\n\nstatic const char *urlsection(cmd_parms *cmd, void *mconfig, const char *arg)\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    core_dir_config *conf;\n    ap_regex_t *r = NULL;\n    const command_rec *thiscmd = cmd->cmd;\n    ap_conf_vector_t *new_url_conf = ap_create_per_dir_config(cmd->pool);\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    cmd->path = ap_getword_conf(cmd->pool, &arg);\n    cmd->override = OR_ALL|ACCESS_CONF;\n\n    if (thiscmd->cmd_data) { /* <LocationMatch> */\n        r = ap_pregcomp(cmd->pool, cmd->path, AP_REG_EXTENDED);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n    }\n    else if (!strcmp(cmd->path, \"~\")) {\n        cmd->path = ap_getword_conf(cmd->pool, &arg);\n        r = ap_pregcomp(cmd->pool, cmd->path, AP_REG_EXTENDED);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n    }\n\n    /* initialize our config and fetch it */\n    conf = ap_set_config_vectors(cmd->server, new_url_conf, cmd->path,\n                                 &core_module, cmd->pool);\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_url_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    conf->d = apr_pstrdup(cmd->pool, cmd->path);     /* No mangling, please */\n    conf->d_is_fnmatch = apr_fnmatch_test(conf->d) != 0;\n    conf->r = r;\n\n    if (r) {\n        conf->refs = apr_array_make(cmd->pool, 8, sizeof(char *));\n        ap_regname(r, conf->refs, AP_REG_MATCH, 1);\n    }\n\n    ap_add_per_url_conf(cmd->server, new_url_conf);\n\n    if (*arg != '\\0') {\n        return apr_pstrcat(cmd->pool, \"Multiple \", thiscmd->name,\n                           \"> arguments not (yet) supported.\", NULL);\n    }\n\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n\n    return NULL;\n}\n\nstatic const char *filesection(cmd_parms *cmd, void *mconfig, const char *arg)\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    core_dir_config *conf;\n    ap_regex_t *r = NULL;\n    const command_rec *thiscmd = cmd->cmd;\n    ap_conf_vector_t *new_file_conf = ap_create_per_dir_config(cmd->pool);\n    const char *err = ap_check_cmd_context(cmd,\n                                           NOT_IN_LOCATION | NOT_IN_LIMIT);\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    cmd->path = ap_getword_conf(cmd->pool, &arg);\n    /* Only if not an .htaccess file */\n    if (!old_path) {\n        cmd->override = OR_ALL|ACCESS_CONF;\n    }\n\n    if (thiscmd->cmd_data) { /* <FilesMatch> */\n        r = ap_pregcomp(cmd->pool, cmd->path, AP_REG_EXTENDED|USE_ICASE);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n    }\n    else if (!strcmp(cmd->path, \"~\")) {\n        cmd->path = ap_getword_conf(cmd->pool, &arg);\n        r = ap_pregcomp(cmd->pool, cmd->path, AP_REG_EXTENDED|USE_ICASE);\n        if (!r) {\n            return \"Regex could not be compiled\";\n        }\n    }\n    else {\n        char *newpath;\n        /* Ensure that the pathname is canonical, but we\n         * can't test the case/aliases without a fixed path */\n        if (apr_filepath_merge(&newpath, \"\", cmd->path,\n                               0, cmd->pool) != APR_SUCCESS)\n                return apr_pstrcat(cmd->pool, \"<Files \\\"\", cmd->path,\n                               \"\\\"> is invalid.\", NULL);\n        cmd->path = newpath;\n    }\n\n    /* initialize our config and fetch it */\n    conf = ap_set_config_vectors(cmd->server, new_file_conf, cmd->path,\n                                 &core_module, cmd->pool);\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_file_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    conf->d = cmd->path;\n    conf->d_is_fnmatch = apr_fnmatch_test(conf->d) != 0;\n    conf->r = r;\n\n    if (r) {\n        conf->refs = apr_array_make(cmd->pool, 8, sizeof(char *));\n        ap_regname(r, conf->refs, AP_REG_MATCH, 1);\n    }\n\n    ap_add_file_conf(cmd->pool, (core_dir_config *)mconfig, new_file_conf);\n\n    if (*arg != '\\0') {\n        return apr_pstrcat(cmd->pool, \"Multiple \", thiscmd->name,\n                           \"> arguments not (yet) supported.\", NULL);\n    }\n\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n\n    return NULL;\n}\n\n#define COND_IF      ((void *)1)\n#define COND_ELSE    ((void *)2)\n#define COND_ELSEIF  ((void *)3)\n\nstatic const char *ifsection(cmd_parms *cmd, void *mconfig, const char *arg)\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    core_dir_config *conf;\n    const command_rec *thiscmd = cmd->cmd;\n    ap_conf_vector_t *new_if_conf = ap_create_per_dir_config(cmd->pool);\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);\n    const char *condition;\n    const char *expr_err;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n\n    /*\n     * Set a dummy value so that other directives notice that they are inside\n     * a config section.\n     */\n    cmd->path = \"*If\";\n    /* Only if not an .htaccess file */\n    if (!old_path) {\n        cmd->override = OR_ALL|ACCESS_CONF;\n    }\n\n    /* initialize our config and fetch it */\n    conf = ap_set_config_vectors(cmd->server, new_if_conf, cmd->path,\n                                 &core_module, cmd->pool);\n\n    if (cmd->cmd->cmd_data == COND_IF)\n        conf->condition_ifelse = AP_CONDITION_IF;\n    else if (cmd->cmd->cmd_data == COND_ELSEIF)\n        conf->condition_ifelse = AP_CONDITION_ELSEIF;\n    else if (cmd->cmd->cmd_data == COND_ELSE)\n        conf->condition_ifelse = AP_CONDITION_ELSE;\n    else\n        ap_assert(0);\n\n    if (conf->condition_ifelse == AP_CONDITION_ELSE) {\n        if (arg[0])\n            return \"<Else> does not take an argument\";\n    }\n    else {\n        if (!arg[0])\n            return missing_container_arg(cmd);\n        condition = ap_getword_conf(cmd->pool, &arg);\n        conf->condition = ap_expr_parse_cmd(cmd, condition, 0, &expr_err, NULL);\n        if (expr_err)\n            return apr_psprintf(cmd->pool, \"Cannot parse condition clause: %s\",\n                                expr_err);\n    }\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_if_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    conf->d = cmd->path;\n    conf->d_is_fnmatch = 0;\n    conf->r = NULL;\n\n    errmsg = ap_add_if_conf(cmd->pool, (core_dir_config *)mconfig, new_if_conf);\n    if (errmsg != NULL)\n        return errmsg;\n\n    if (*arg != '\\0') {\n        return apr_pstrcat(cmd->pool, \"Multiple \", thiscmd->name,\n                           \"> arguments not supported.\", NULL);\n    }\n\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n\n    return NULL;\n}\n\nstatic module *find_module(server_rec *s, const char *name)\n{\n    module *found = ap_find_linked_module(name);\n\n    /* search prelinked stuff */\n    if (!found) {\n        ap_module_symbol_t *current = ap_prelinked_module_symbols;\n\n        for (; current->name; ++current) {\n            if (!strcmp(current->name, name)) {\n                found = current->modp;\n                break;\n            }\n        }\n    }\n\n    /* search dynamic stuff */\n    if (!found) {\n        APR_OPTIONAL_FN_TYPE(ap_find_loaded_module_symbol) *check_symbol =\n            APR_RETRIEVE_OPTIONAL_FN(ap_find_loaded_module_symbol);\n\n        if (check_symbol) {\n            /*\n             * There are two phases where calling ap_find_loaded_module_symbol\n             * is problematic:\n             *\n             * During reading of the config, ap_server_conf is invalid but s\n             * points to the main server config, if passed from cmd->server\n             * of an EXEC_ON_READ directive.\n             *\n             * During config parsing, s may be a virtual host that would cause\n             * a segfault in mod_so if passed to ap_find_loaded_module_symbol,\n             * because mod_so's server config for vhosts is initialized later.\n             * But ap_server_conf is already set at this time.\n             *\n             * Therefore we use s if it is not virtual and ap_server_conf if\n             * s is virtual.\n             */\n            found = check_symbol(s->is_virtual ? ap_server_conf : s, name);\n        }\n    }\n\n    return found;\n}\n\n/* Callback function type used by start_cond_section. */\ntypedef int (*test_cond_section_fn)(cmd_parms *cmd, const char *arg);\n\n/* Implementation of <IfXXXXX>-style conditional sections.  Callback\n * to test condition must be in cmd->info, matching function type\n * test_cond_section_fn. */\nstatic const char *start_cond_section(cmd_parms *cmd, void *mconfig, const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    int result, not = (arg[0] == '!');\n    test_cond_section_fn testfn = (test_cond_section_fn)cmd->info;\n    const char *arg1;\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n\n    if (not) {\n        arg++;\n    }\n\n    arg1 = ap_getword_conf(cmd->temp_pool, &arg);\n\n    if (!arg1[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    result = testfn(cmd, arg1);\n\n    if ((!not && result) || (not && !result)) {\n        ap_directive_t *parent = NULL;\n        ap_directive_t *current = NULL;\n        const char *retval;\n\n        retval = ap_build_cont_config(cmd->pool, cmd->temp_pool, cmd,\n                                      &current, &parent, cmd->cmd->name);\n        *(ap_directive_t **)mconfig = current;\n        return retval;\n    }\n    else {\n        *(ap_directive_t **)mconfig = NULL;\n        return ap_soak_end_container(cmd, cmd->cmd->name);\n    }\n}\n\n/* Callback to implement <IfModule> test for start_cond_section. */\nstatic int test_ifmod_section(cmd_parms *cmd, const char *arg)\n{\n    return find_module(cmd->server, arg) != NULL;\n}\n\nAP_DECLARE(int) ap_exists_config_define(const char *name)\n{\n    return ap_array_str_contains(ap_server_config_defines, name);\n}\n\nstatic int test_ifdefine_section(cmd_parms *cmd, const char *arg)\n{\n    return ap_exists_config_define(arg);\n}\n\nstatic int test_iffile_section(cmd_parms *cmd, const char *arg)\n{\n    const char *relative;\n    apr_finfo_t sb;\n\n    relative = ap_server_root_relative(cmd->temp_pool, arg);\n    return (apr_stat(&sb, relative, 0, cmd->pool) == APR_SUCCESS);\n}\n\nstatic int test_ifdirective_section(cmd_parms *cmd, const char *arg)\n{\n    return ap_exists_directive(cmd->temp_pool, arg);\n}\n\nstatic int test_ifsection_section(cmd_parms *cmd, const char *arg)\n{\n    const char *name = apr_pstrcat(cmd->temp_pool, \"<\", arg, NULL);\n    return ap_exists_directive(cmd->temp_pool, name);\n}\n\n/* httpd.conf commands... beginning with the <VirtualHost> business */\n\nstatic const char *virtualhost_section(cmd_parms *cmd, void *dummy,\n                                       const char *arg)\n{\n    server_rec *main_server = cmd->server, *s;\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    apr_pool_t *p = cmd->pool;\n\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    if (err != NULL) {\n        return err;\n    }\n\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n\n    /* FIXME: There's another feature waiting to happen here -- since you\n        can now put multiple addresses/names on a single <VirtualHost>\n        you might want to use it to group common definitions and then\n        define other \"subhosts\" with their individual differences.  But\n        personally I'd rather just do it with a macro preprocessor. -djg */\n    if (main_server->is_virtual) {\n        return \"<VirtualHost> doesn't nest!\";\n    }\n\n    errmsg = ap_init_virtual_host(p, arg, main_server, &s);\n    if (errmsg) {\n        return errmsg;\n    }\n\n    s->next = main_server->next;\n    main_server->next = s;\n\n    s->defn_name = cmd->directive->filename;\n    s->defn_line_number = cmd->directive->line_num;\n\n    cmd->server = s;\n\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd,\n                            s->lookup_defaults);\n\n    cmd->server = main_server;\n\n    return errmsg;\n}\n\nstatic const char *set_server_alias(cmd_parms *cmd, void *dummy,\n                                    const char *arg)\n{\n    if (!cmd->server->names) {\n        return \"ServerAlias only used in <VirtualHost>\";\n    }\n\n    while (*arg) {\n        char **item, *name = ap_getword_conf(cmd->pool, &arg);\n\n        if (ap_is_matchexp(name)) {\n            item = (char **)apr_array_push(cmd->server->wild_names);\n        }\n        else {\n            item = (char **)apr_array_push(cmd->server->names);\n        }\n\n        *item = name;\n    }\n\n    return NULL;\n}\n\nstatic const char *set_accf_map(cmd_parms *cmd, void *dummy,\n                                const char *iproto, const char* iaccf)\n{\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n    char* proto;\n    char* accf;\n    if (err != NULL) {\n        return err;\n    }\n\n    proto = apr_pstrdup(cmd->pool, iproto);\n    ap_str_tolower(proto);\n    accf = apr_pstrdup(cmd->pool, iaccf);\n    ap_str_tolower(accf);\n    apr_table_setn(conf->accf_map, proto, accf);\n\n    return NULL;\n}\n\nAP_DECLARE(const char*) ap_get_server_protocol(server_rec* s)\n{\n    core_server_config *conf = ap_get_core_module_config(s->module_config);\n    return conf->protocol;\n}\n\nAP_DECLARE(void) ap_set_server_protocol(server_rec* s, const char* proto)\n{\n    core_server_config *conf = ap_get_core_module_config(s->module_config);\n    conf->protocol = proto;\n}\n\nstatic const char *set_protocol(cmd_parms *cmd, void *dummy,\n                                const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n    char* proto;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    proto = apr_pstrdup(cmd->pool, arg);\n    ap_str_tolower(proto);\n    conf->protocol = proto;\n\n    return NULL;\n}\n\nstatic const char *set_server_string_slot(cmd_parms *cmd, void *dummy,\n                                          const char *arg)\n{\n    /* This one's pretty generic... */\n\n    int offset = (int)(long)cmd->info;\n    char *struct_ptr = (char *)cmd->server;\n\n    const char *err = ap_check_cmd_context(cmd,\n                                           NOT_IN_DIR_LOC_FILE);\n    if (err != NULL) {\n        return err;\n    }\n\n    *(const char **)(struct_ptr + offset) = arg;\n    return NULL;\n}\n\n/*\n * The ServerName directive takes one argument with format\n * [scheme://]fully-qualified-domain-name[:port], for instance\n * ServerName www.example.com\n * ServerName www.example.com:80\n * ServerName https://www.example.com:443\n */\n\nstatic const char *server_hostname_port(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    const char *portstr, *part;\n    char *scheme;\n    int port;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if (apr_fnmatch_test(arg))\n        return apr_pstrcat(cmd->temp_pool, \"Invalid ServerName \\\"\", arg,\n                \"\\\" use ServerAlias to set multiple server names.\", NULL);\n\n    part = ap_strstr_c(arg, \"://\");\n\n    if (part) {\n      scheme = apr_pstrndup(cmd->pool, arg, part - arg);\n      ap_str_tolower(scheme);\n      cmd->server->server_scheme = (const char *)scheme;\n      part += 3;\n    } else {\n      part = arg;\n    }\n\n    portstr = ap_strchr_c(part, ':');\n    if (portstr) {\n        cmd->server->server_hostname = apr_pstrndup(cmd->pool, part,\n                                                    portstr - part);\n        portstr++;\n        port = atoi(portstr);\n        if (port <= 0 || port >= 65536) { /* 65536 == 1<<16 */\n            return apr_pstrcat(cmd->temp_pool, \"The port number \\\"\", arg,\n                          \"\\\" is outside the appropriate range \"\n                          \"(i.e., 1..65535).\", NULL);\n        }\n    }\n    else {\n        cmd->server->server_hostname = apr_pstrdup(cmd->pool, part);\n        port = 0;\n    }\n\n    cmd->server->port = port;\n    return NULL;\n}\n\nstatic const char *set_signature_flag(cmd_parms *cmd, void *d_,\n                                      const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (ap_cstr_casecmp(arg, \"On\") == 0) {\n        d->server_signature = srv_sig_on;\n    }\n    else if (ap_cstr_casecmp(arg, \"Off\") == 0) {\n        d->server_signature = srv_sig_off;\n    }\n    else if (ap_cstr_casecmp(arg, \"EMail\") == 0) {\n        d->server_signature = srv_sig_withmail;\n    }\n    else {\n        return \"ServerSignature: use one of: off | on | email\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_server_root(cmd_parms *cmd, void *dummy,\n                                   const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if ((apr_filepath_merge((char**)&ap_server_root, NULL, arg,\n                            APR_FILEPATH_TRUENAME, cmd->pool) != APR_SUCCESS)\n        || !ap_is_directory(cmd->temp_pool, ap_server_root)) {\n        return \"ServerRoot must be a valid directory\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_runtime_dir(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if ((apr_filepath_merge((char**)&ap_runtime_dir, NULL,\n                            ap_server_root_relative(cmd->temp_pool, arg),\n                            APR_FILEPATH_TRUENAME, cmd->pool) != APR_SUCCESS)\n        || !ap_is_directory(cmd->temp_pool, ap_runtime_dir)) {\n        return \"DefaultRuntimeDir must be a valid directory, absolute or relative to ServerRoot\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_timeout(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n\n    if (err != NULL) {\n        return err;\n    }\n\n    cmd->server->timeout = apr_time_from_sec(atoi(arg));\n    return NULL;\n}\n\nstatic const char *set_allow2f(cmd_parms *cmd, void *d_, const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (0 == ap_cstr_casecmp(arg, \"on\")) {\n        d->allow_encoded_slashes = 1;\n        d->decode_encoded_slashes = 1; /* for compatibility with 2.0 & 2.2 */\n    } else if (0 == ap_cstr_casecmp(arg, \"off\")) {\n        d->allow_encoded_slashes = 0;\n        d->decode_encoded_slashes = 0;\n    } else if (0 == ap_cstr_casecmp(arg, \"nodecode\")) {\n        d->allow_encoded_slashes = 1;\n        d->decode_encoded_slashes = 0;\n    } else {\n        return apr_pstrcat(cmd->pool,\n                           cmd->cmd->name, \" must be On, Off, or NoDecode\",\n                           NULL);\n    }\n\n    d->allow_encoded_slashes_set = 1;\n    d->decode_encoded_slashes_set = 1;\n\n    return NULL;\n}\n\nstatic const char *set_hostname_lookups(cmd_parms *cmd, void *d_,\n                                        const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (!ap_cstr_casecmp(arg, \"on\")) {\n        d->hostname_lookups = HOSTNAME_LOOKUP_ON;\n    }\n    else if (!ap_cstr_casecmp(arg, \"off\")) {\n        d->hostname_lookups = HOSTNAME_LOOKUP_OFF;\n    }\n    else if (!ap_cstr_casecmp(arg, \"double\")) {\n        d->hostname_lookups = HOSTNAME_LOOKUP_DOUBLE;\n    }\n    else {\n        return \"parameter must be 'on', 'off', or 'double'\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_serverpath(cmd_parms *cmd, void *dummy,\n                                  const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n\n    if (err != NULL) {\n        return err;\n    }\n\n    cmd->server->path = arg;\n    cmd->server->pathlen = (int)strlen(arg);\n    return NULL;\n}\n\nstatic const char *set_content_md5(cmd_parms *cmd, void *d_, int arg)\n{\n    core_dir_config *d = d_;\n\n    d->content_md5 = arg ? AP_CONTENT_MD5_ON : AP_CONTENT_MD5_OFF;\n    return NULL;\n}\n\nstatic const char *set_accept_path_info(cmd_parms *cmd, void *d_, const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        d->accept_path_info = AP_REQ_ACCEPT_PATH_INFO;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        d->accept_path_info = AP_REQ_REJECT_PATH_INFO;\n    }\n    else if (ap_cstr_casecmp(arg, \"default\") == 0) {\n        d->accept_path_info = AP_REQ_DEFAULT_PATH_INFO;\n    }\n    else {\n        return \"AcceptPathInfo must be set to on, off or default\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_use_canonical_name(cmd_parms *cmd, void *d_,\n                                          const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        d->use_canonical_name = USE_CANONICAL_NAME_ON;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        d->use_canonical_name = USE_CANONICAL_NAME_OFF;\n    }\n    else if (ap_cstr_casecmp(arg, \"dns\") == 0) {\n        d->use_canonical_name = USE_CANONICAL_NAME_DNS;\n    }\n    else {\n        return \"parameter must be 'on', 'off', or 'dns'\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_use_canonical_phys_port(cmd_parms *cmd, void *d_,\n                                          const char *arg)\n{\n    core_dir_config *d = d_;\n\n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        d->use_canonical_phys_port = USE_CANONICAL_PHYS_PORT_ON;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        d->use_canonical_phys_port = USE_CANONICAL_PHYS_PORT_OFF;\n    }\n    else {\n        return \"parameter must be 'on' or 'off'\";\n    }\n\n    return NULL;\n}\n\nstatic const char *include_config (cmd_parms *cmd, void *dummy,\n                                   const char *name)\n{\n    ap_directive_t *conftree = NULL;\n    const char *conffile, *error;\n    unsigned *recursion;\n    int optional = cmd->cmd->cmd_data ? 1 : 0;\n    void *data;\n\n    /* NOTE: ap_include_sentinel is also used by ap_process_resource_config()\n     * during DUMP_INCLUDES; don't change its type or remove it without updating\n     * the other.\n     */\n    apr_pool_userdata_get(&data, \"ap_include_sentinel\", cmd->pool);\n    if (data) {\n        recursion = data;\n    }\n    else {\n        data = recursion = apr_palloc(cmd->pool, sizeof(*recursion));\n        *recursion = 0;\n        apr_pool_userdata_setn(data, \"ap_include_sentinel\", NULL, cmd->pool);\n    }\n\n    if (++*recursion > AP_MAX_INCLUDE_DEPTH) {\n        *recursion = 0;\n        return apr_psprintf(cmd->pool, \"Exceeded maximum include depth of %u, \"\n                            \"There appears to be a recursion.\",\n                            AP_MAX_INCLUDE_DEPTH);\n    }\n\n    conffile = ap_server_root_relative(cmd->pool, name);\n    if (!conffile) {\n        *recursion = 0;\n        return apr_pstrcat(cmd->pool, \"Invalid Include path \",\n                           name, NULL);\n    }\n\n    if (ap_exists_config_define(\"DUMP_INCLUDES\")) {\n        unsigned *line_number;\n\n        /* NOTE: ap_include_lineno is used by ap_process_resource_config()\n         * during DUMP_INCLUDES; don't change its type or remove it without\n         * updating the other.\n         */\n        apr_pool_userdata_get(&data, \"ap_include_lineno\", cmd->pool);\n        if (data) {\n            line_number = data;\n        } else {\n            data = line_number = apr_palloc(cmd->pool, sizeof(*line_number));\n            apr_pool_userdata_setn(data, \"ap_include_lineno\", NULL, cmd->pool);\n        }\n\n        *line_number = cmd->config_file->line_number;\n    }\n\n    error = ap_process_fnmatch_configs(cmd->server, conffile, &conftree,\n                                       cmd->pool, cmd->temp_pool,\n                                       optional);\n    if (error) {\n        *recursion = 0;\n        return error;\n    }\n\n    *(ap_directive_t **)dummy = conftree;\n\n    /* recursion level done */\n    if (*recursion) {\n        --*recursion;\n    }\n\n    return NULL;\n}\n\nstatic const char *update_loglevel(cmd_parms *cmd, struct ap_logconf *log,\n                                   const char *arg)\n{\n    const char *level_str, *err;\n    module *module;\n    int level;\n\n    level_str = ap_strrchr_c(arg, ':');\n\n    if (level_str == NULL) {\n        err = ap_parse_log_level(arg, &log->level);\n        if (err != NULL)\n            return err;\n        ap_reset_module_loglevels(log, APLOG_NO_MODULE);\n        ap_log_error(APLOG_MARK, APLOG_TRACE3, 0, cmd->server,\n                     \"Setting %s for all modules to %s\", cmd->cmd->name, arg);\n        return NULL;\n    }\n\n    arg = apr_pstrmemdup(cmd->temp_pool, arg, level_str - arg);\n    level_str++;\n    if (!*level_str) {\n        return apr_psprintf(cmd->temp_pool, \"Module specifier '%s' must be \"\n                            \"followed by a log level keyword\", arg);\n    }\n\n    err = ap_parse_log_level(level_str, &level);\n    if (err != NULL)\n        return apr_psprintf(cmd->temp_pool, \"%s:%s: %s\", arg, level_str, err);\n\n    if ((module = find_module(cmd->server, arg)) == NULL) {\n        char *name = apr_psprintf(cmd->temp_pool, \"%s_module\", arg);\n        ap_log_error(APLOG_MARK, APLOG_TRACE6, 0, cmd->server,\n                     \"Cannot find module '%s', trying '%s'\", arg, name);\n        module = find_module(cmd->server, name);\n    }\n\n    if (module == NULL) {\n        return apr_psprintf(cmd->temp_pool, \"Cannot find module %s\", arg);\n    }\n\n    ap_set_module_loglevel(cmd->pool, log, module->module_index, level);\n    ap_log_error(APLOG_MARK, APLOG_TRACE3, 0, cmd->server,\n                 \"Setting %s for module %s to %s\", cmd->cmd->name,\n                 module->name, level_str);\n\n    return NULL;\n}\n\nstatic const char *set_loglevel(cmd_parms *cmd, void *config_, const char *arg)\n{\n    struct ap_logconf *log;\n\n    if (cmd->path) {\n        core_dir_config *dconf = config_;\n        if (!dconf->log) {\n            dconf->log = ap_new_log_config(cmd->pool, NULL);\n        }\n        log = dconf->log;\n    }\n    else {\n        log = &cmd->server->log;\n    }\n\n    if (arg == NULL)\n        return \"LogLevel requires level keyword or module loglevel specifier\";\n\n    return update_loglevel(cmd, log, arg);\n}\n\nstatic const char *set_loglevel_override(cmd_parms *cmd, void *d_, int argc,\n                                         char *const argv[])\n{\n    core_server_config *sconf;\n    conn_log_config *entry;\n    int ret, i;\n    const char *addr, *mask, *err;\n\n    if (argc < 2)\n        return \"LogLevelOverride requires at least two arguments\";\n\n    entry = apr_pcalloc(cmd->pool, sizeof(conn_log_config));\n    sconf = ap_get_core_module_config(cmd->server->module_config);\n    if (!sconf->conn_log_level)\n        sconf->conn_log_level = apr_array_make(cmd->pool, 4, sizeof(entry));\n    APR_ARRAY_PUSH(sconf->conn_log_level, conn_log_config *) = entry;\n\n    addr = argv[0];\n    mask = ap_strchr_c(addr, '/');\n    if (mask) {\n        addr = apr_pstrmemdup(cmd->temp_pool, addr, mask - addr);\n        mask++;\n    }\n    ret = apr_ipsubnet_create(&entry->subnet, addr, mask, cmd->pool);\n    if (ret != APR_SUCCESS)\n        return \"parsing of subnet/netmask failed\";\n\n    for (i = 1; i < argc; i++) {\n        if ((err = update_loglevel(cmd, &entry->log, argv[i])) != NULL)\n            return err;\n    }\n    return NULL;\n}\n\nAP_DECLARE(const char *) ap_psignature(const char *prefix, request_rec *r)\n{\n    char sport[20];\n    core_dir_config *conf;\n\n    conf = (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n    if ((conf->server_signature == srv_sig_off)\n            || (conf->server_signature == srv_sig_unset)) {\n        return \"\";\n    }\n\n    apr_snprintf(sport, sizeof sport, \"%u\", (unsigned) ap_get_server_port(r));\n\n    if (conf->server_signature == srv_sig_withmail) {\n        return apr_pstrcat(r->pool, prefix, \"<address>\",\n                           ap_get_server_banner(),\n                           \" Server at <a href=\\\"\",\n                           ap_is_url(r->server->server_admin) ? \"\" : \"mailto:\",\n                           ap_escape_html(r->pool, r->server->server_admin),\n                           \"\\\">\",\n                           ap_escape_html(r->pool, ap_get_server_name(r)),\n                           \"</a> Port \", sport,\n                           \"</address>\\n\", NULL);\n    }\n\n    return apr_pstrcat(r->pool, prefix, \"<address>\", ap_get_server_banner(),\n                       \" Server at \",\n                       ap_escape_html(r->pool, ap_get_server_name(r)),\n                       \" Port \", sport,\n                       \"</address>\\n\", NULL);\n}\n\n/*\n * Handle a request to include the server's OS platform in the Server\n * response header field (the ServerTokens directive).  Unfortunately\n * this requires a new global in order to communicate the setting back to\n * http_main so it can insert the information in the right place in the\n * string.\n */\n\nstatic char *server_banner = NULL;\nstatic int banner_locked = 0;\nstatic const char *server_description = NULL;\n\nenum server_token_type {\n    SrvTk_MAJOR,         /* eg: Apache/2 */\n    SrvTk_MINOR,         /* eg. Apache/2.0 */\n    SrvTk_MINIMAL,       /* eg: Apache/2.0.41 */\n    SrvTk_OS,            /* eg: Apache/2.0.41 (UNIX) */\n    SrvTk_FULL,          /* eg: Apache/2.0.41 (UNIX) PHP/4.2.2 FooBar/1.2b */\n    SrvTk_PRODUCT_ONLY   /* eg: Apache */\n};\nstatic enum server_token_type ap_server_tokens = SrvTk_FULL;\n\nstatic apr_status_t reset_banner(void *dummy)\n{\n    banner_locked = 0;\n    ap_server_tokens = SrvTk_FULL;\n    server_banner = NULL;\n    server_description = NULL;\n    return APR_SUCCESS;\n}\n\nAP_DECLARE(void) ap_get_server_revision(ap_version_t *version)\n{\n    version->major = AP_SERVER_MAJORVERSION_NUMBER;\n    version->minor = AP_SERVER_MINORVERSION_NUMBER;\n    version->patch = AP_SERVER_PATCHLEVEL_NUMBER;\n    version->add_string = AP_SERVER_ADD_STRING;\n}\n\nAP_DECLARE(const char *) ap_get_server_description(void)\n{\n    return server_description ? server_description :\n        AP_SERVER_BASEVERSION \" (\" PLATFORM \")\";\n}\n\nAP_DECLARE(const char *) ap_get_server_banner(void)\n{\n    return server_banner ? server_banner : AP_SERVER_BASEVERSION;\n}\n\nAP_DECLARE(void) ap_add_version_component(apr_pool_t *pconf, const char *component)\n{\n    if (! banner_locked) {\n        /*\n         * If the version string is null, register our cleanup to reset the\n         * pointer on pool destruction. We also know that, if NULL,\n         * we are adding the original SERVER_BASEVERSION string.\n         */\n        if (server_banner == NULL) {\n            apr_pool_cleanup_register(pconf, NULL, reset_banner,\n                                      apr_pool_cleanup_null);\n            server_banner = apr_pstrdup(pconf, component);\n        }\n        else {\n            /*\n             * Tack the given component identifier to the end of\n             * the existing string.\n             */\n            server_banner = apr_pstrcat(pconf, server_banner, \" \",\n                                        component, NULL);\n        }\n    }\n    server_description = apr_pstrcat(pconf, server_description, \" \",\n                                     component, NULL);\n}\n\n/*\n * This routine adds the real server base identity to the banner string,\n * and then locks out changes until the next reconfig.\n */\nstatic void set_banner(apr_pool_t *pconf)\n{\n    if (ap_server_tokens == SrvTk_PRODUCT_ONLY) {\n        ap_add_version_component(pconf, AP_SERVER_BASEPRODUCT);\n    }\n    else if (ap_server_tokens == SrvTk_MINIMAL) {\n        ap_add_version_component(pconf, AP_SERVER_BASEVERSION);\n    }\n    else if (ap_server_tokens == SrvTk_MINOR) {\n        ap_add_version_component(pconf, AP_SERVER_BASEPRODUCT \"/\" AP_SERVER_MINORREVISION);\n    }\n    else if (ap_server_tokens == SrvTk_MAJOR) {\n        ap_add_version_component(pconf, AP_SERVER_BASEPRODUCT \"/\" AP_SERVER_MAJORVERSION);\n    }\n    else {\n        ap_add_version_component(pconf, AP_SERVER_BASEVERSION \" (\" PLATFORM \")\");\n    }\n\n    /*\n     * Lock the server_banner string if we're not displaying\n     * the full set of tokens\n     */\n    if (ap_server_tokens != SrvTk_FULL) {\n        banner_locked++;\n    }\n    server_description = AP_SERVER_BASEVERSION \" (\" PLATFORM \")\";\n}\n\nstatic const char *set_serv_tokens(cmd_parms *cmd, void *dummy,\n                                   const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n\n    if (err != NULL) {\n        return err;\n    }\n\n    if (!ap_cstr_casecmp(arg, \"OS\")) {\n        ap_server_tokens = SrvTk_OS;\n    }\n    else if (!ap_cstr_casecmp(arg, \"Min\") || !ap_cstr_casecmp(arg, \"Minimal\")) {\n        ap_server_tokens = SrvTk_MINIMAL;\n    }\n    else if (!ap_cstr_casecmp(arg, \"Major\")) {\n        ap_server_tokens = SrvTk_MAJOR;\n    }\n    else if (!ap_cstr_casecmp(arg, \"Minor\") ) {\n        ap_server_tokens = SrvTk_MINOR;\n    }\n    else if (!ap_cstr_casecmp(arg, \"Prod\") || !ap_cstr_casecmp(arg, \"ProductOnly\")) {\n        ap_server_tokens = SrvTk_PRODUCT_ONLY;\n    }\n    else if (!ap_cstr_casecmp(arg, \"Full\")) {\n        ap_server_tokens = SrvTk_FULL;\n    }\n    else {\n        return \"ServerTokens takes 1 argument: 'Prod(uctOnly)', 'Major', 'Minor', 'Min(imal)', 'OS', or 'Full'\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_limit_req_line(cmd_parms *cmd, void *dummy,\n                                      const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    int lim;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    lim = atoi(arg);\n    if (lim < 0) {\n        return apr_pstrcat(cmd->temp_pool, \"LimitRequestLine \\\"\", arg,\n                           \"\\\" must be a non-negative integer\", NULL);\n    }\n\n    cmd->server->limit_req_line = lim;\n    return NULL;\n}\n\nstatic const char *set_limit_req_fieldsize(cmd_parms *cmd, void *dummy,\n                                           const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    int lim;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    lim = atoi(arg);\n    if (lim < 0) {\n        return apr_pstrcat(cmd->temp_pool, \"LimitRequestFieldsize \\\"\", arg,\n                          \"\\\" must be a non-negative integer\",\n                          NULL);\n    }\n\n    cmd->server->limit_req_fieldsize = lim;\n    return NULL;\n}\n\nstatic const char *set_limit_req_fields(cmd_parms *cmd, void *dummy,\n                                        const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    int lim;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    lim = atoi(arg);\n    if (lim < 0) {\n        return apr_pstrcat(cmd->temp_pool, \"LimitRequestFields \\\"\", arg,\n                           \"\\\" must be a non-negative integer (0 = no limit)\",\n                           NULL);\n    }\n\n    cmd->server->limit_req_fields = lim;\n    return NULL;\n}\n\nstatic const char *set_limit_req_body(cmd_parms *cmd, void *conf_,\n                                      const char *arg)\n{\n    core_dir_config *conf = conf_;\n    char *errp;\n\n    if (APR_SUCCESS != apr_strtoff(&conf->limit_req_body, arg, &errp, 10)) {\n        return \"LimitRequestBody argument is not parsable.\";\n    }\n    if (*errp || conf->limit_req_body < 0) {\n        return \"LimitRequestBody requires a non-negative integer.\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_limit_xml_req_body(cmd_parms *cmd, void *conf_,\n                                          const char *arg)\n{\n    core_dir_config *conf = conf_;\n\n    conf->limit_xml_body = atol(arg);\n    if (conf->limit_xml_body < 0)\n        return \"LimitXMLRequestBody requires a non-negative integer.\";\n\n    return NULL;\n}\n\nstatic const char *set_max_ranges(cmd_parms *cmd, void *conf_, const char *arg)\n{\n    core_dir_config *conf = conf_;\n    int val = 0;\n\n    if (!ap_cstr_casecmp(arg, \"none\")) {\n        val = AP_MAXRANGES_NORANGES;\n    }\n    else if (!ap_cstr_casecmp(arg, \"default\")) {\n        val = AP_MAXRANGES_DEFAULT;\n    }\n    else if (!ap_cstr_casecmp(arg, \"unlimited\")) {\n        val = AP_MAXRANGES_UNLIMITED;\n    }\n    else {\n        val = atoi(arg);\n        if (val <= 0)\n            return \"MaxRanges requires 'none', 'default', 'unlimited' or \"\n                   \"a positive integer\";\n    }\n\n    conf->max_ranges = val;\n\n    return NULL;\n}\n\nstatic const char *set_max_overlaps(cmd_parms *cmd, void *conf_, const char *arg)\n{\n    core_dir_config *conf = conf_;\n    int val = 0;\n\n    if (!ap_cstr_casecmp(arg, \"none\")) {\n        val = AP_MAXRANGES_NORANGES;\n    }\n    else if (!ap_cstr_casecmp(arg, \"default\")) {\n        val = AP_MAXRANGES_DEFAULT;\n    }\n    else if (!ap_cstr_casecmp(arg, \"unlimited\")) {\n        val = AP_MAXRANGES_UNLIMITED;\n    }\n    else {\n        val = atoi(arg);\n        if (val <= 0)\n            return \"MaxRangeOverlaps requires 'none', 'default', 'unlimited' or \"\n            \"a positive integer\";\n    }\n\n    conf->max_overlaps = val;\n\n    return NULL;\n}\n\nstatic const char *set_max_reversals(cmd_parms *cmd, void *conf_, const char *arg)\n{\n    core_dir_config *conf = conf_;\n    int val = 0;\n\n    if (!ap_cstr_casecmp(arg, \"none\")) {\n        val = AP_MAXRANGES_NORANGES;\n    }\n    else if (!ap_cstr_casecmp(arg, \"default\")) {\n        val = AP_MAXRANGES_DEFAULT;\n    }\n    else if (!ap_cstr_casecmp(arg, \"unlimited\")) {\n        val = AP_MAXRANGES_UNLIMITED;\n    }\n    else {\n        val = atoi(arg);\n        if (val <= 0)\n            return \"MaxRangeReversals requires 'none', 'default', 'unlimited' or \"\n            \"a positive integer\";\n    }\n\n    conf->max_reversals = val;\n\n    return NULL;\n}\n\nAP_DECLARE(apr_size_t) ap_get_limit_xml_body(const request_rec *r)\n{\n    core_dir_config *conf;\n\n    conf = ap_get_core_module_config(r->per_dir_config);\n    if (conf->limit_xml_body == AP_LIMIT_UNSET)\n        return AP_DEFAULT_LIMIT_XML_BODY;\n\n    return (apr_size_t)conf->limit_xml_body;\n}\n\n#if !defined (RLIMIT_CPU) || !(defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS)) || !defined (RLIMIT_NPROC)\nstatic const char *no_set_limit(cmd_parms *cmd, void *conf_,\n                                const char *arg, const char *arg2)\n{\n    ap_log_error(APLOG_MARK, APLOG_ERR, 0, cmd->server, APLOGNO(00118)\n                \"%s not supported on this platform\", cmd->cmd->name);\n\n    return NULL;\n}\n#endif\n\n#ifdef RLIMIT_CPU\nstatic const char *set_limit_cpu(cmd_parms *cmd, void *conf_,\n                                 const char *arg, const char *arg2)\n{\n    core_dir_config *conf = conf_;\n\n    ap_unixd_set_rlimit(cmd, &conf->limit_cpu, arg, arg2, RLIMIT_CPU);\n    return NULL;\n}\n#endif\n\n#if defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS)\nstatic const char *set_limit_mem(cmd_parms *cmd, void *conf_,\n                                 const char *arg, const char * arg2)\n{\n    core_dir_config *conf = conf_;\n\n#if defined(RLIMIT_AS)\n    ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2 ,RLIMIT_AS);\n#elif defined(RLIMIT_DATA)\n    ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_DATA);\n#elif defined(RLIMIT_VMEM)\n    ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_VMEM);\n#endif\n\n    return NULL;\n}\n#endif\n\n#ifdef RLIMIT_NPROC\nstatic const char *set_limit_nproc(cmd_parms *cmd, void *conf_,\n                                   const char *arg, const char * arg2)\n{\n    core_dir_config *conf = conf_;\n\n    ap_unixd_set_rlimit(cmd, &conf->limit_nproc, arg, arg2, RLIMIT_NPROC);\n    return NULL;\n}\n#endif\n\nstatic const char *set_recursion_limit(cmd_parms *cmd, void *dummy,\n                                       const char *arg1, const char *arg2)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n    int limit = atoi(arg1);\n\n    if (limit <= 0) {\n        return \"The recursion limit must be greater than zero.\";\n    }\n    if (limit < 4) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00119)\n                     \"Limiting internal redirects to very low numbers may \"\n                     \"cause normal requests to fail.\");\n    }\n\n    conf->redirect_limit = limit;\n\n    if (arg2) {\n        limit = atoi(arg2);\n\n        if (limit <= 0) {\n            return \"The recursion limit must be greater than zero.\";\n        }\n        if (limit < 4) {\n            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00120)\n                         \"Limiting the subrequest depth to a very low level may\"\n                         \" cause normal requests to fail.\");\n        }\n    }\n\n    conf->subreq_limit = limit;\n\n    return NULL;\n}\n\nstatic void log_backtrace(const request_rec *r)\n{\n    const request_rec *top = r;\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00121)\n                  \"r->uri = %s\", r->uri ? r->uri : \"(unexpectedly NULL)\");\n\n    while (top && (top->prev || top->main)) {\n        if (top->prev) {\n            top = top->prev;\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00122)\n                          \"redirected from r->uri = %s\",\n                          top->uri ? top->uri : \"(unexpectedly NULL)\");\n        }\n\n        if (!top->prev && top->main) {\n            top = top->main;\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00123)\n                          \"subrequested from r->uri = %s\",\n                          top->uri ? top->uri : \"(unexpectedly NULL)\");\n        }\n    }\n}\n\n/*\n * check whether redirect limit is reached\n */\nAP_DECLARE(int) ap_is_recursion_limit_exceeded(const request_rec *r)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(r->server->module_config);\n    const request_rec *top = r;\n    int redirects = 0, subreqs = 0;\n    int rlimit = conf->redirect_limit\n                 ? conf->redirect_limit\n                 : AP_DEFAULT_MAX_INTERNAL_REDIRECTS;\n    int slimit = conf->subreq_limit\n                 ? conf->subreq_limit\n                 : AP_DEFAULT_MAX_SUBREQ_DEPTH;\n\n\n    while (top->prev || top->main) {\n        if (top->prev) {\n            if (++redirects >= rlimit) {\n                /* uuh, too much. */\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00124)\n                              \"Request exceeded the limit of %d internal \"\n                              \"redirects due to probable configuration error. \"\n                              \"Use 'LimitInternalRecursion' to increase the \"\n                              \"limit if necessary. Use 'LogLevel debug' to get \"\n                              \"a backtrace.\", rlimit);\n\n                /* post backtrace */\n                log_backtrace(r);\n\n                /* return failure */\n                return 1;\n            }\n\n            top = top->prev;\n        }\n\n        if (!top->prev && top->main) {\n            if (++subreqs >= slimit) {\n                /* uuh, too much. */\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00125)\n                              \"Request exceeded the limit of %d subrequest \"\n                              \"nesting levels due to probable configuration \"\n                              \"error. Use 'LimitInternalRecursion' to increase \"\n                              \"the limit if necessary. Use 'LogLevel debug' to \"\n                              \"get a backtrace.\", slimit);\n\n                /* post backtrace */\n                log_backtrace(r);\n\n                /* return failure */\n                return 1;\n            }\n\n            top = top->main;\n        }\n    }\n\n    /* recursion state: ok */\n    return 0;\n}\n\nstatic const char *set_trace_enable(cmd_parms *cmd, void *dummy,\n                                    const char *arg1)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n\n    if (ap_cstr_casecmp(arg1, \"on\") == 0) {\n        conf->trace_enable = AP_TRACE_ENABLE;\n    }\n    else if (ap_cstr_casecmp(arg1, \"off\") == 0) {\n        conf->trace_enable = AP_TRACE_DISABLE;\n    }\n    else if (ap_cstr_casecmp(arg1, \"extended\") == 0) {\n        conf->trace_enable = AP_TRACE_EXTENDED;\n    }\n    else {\n        return \"TraceEnable must be one of 'on', 'off', or 'extended'\";\n    }\n\n    return NULL;\n}\n\nstatic const char *set_protocols(cmd_parms *cmd, void *dummy,\n                                 const char *arg)\n{\n    core_server_config *conf =\n    ap_get_core_module_config(cmd->server->module_config);\n    const char **np;\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n\n    if (err) {\n        return err;\n    }\n    \n    np = (const char **)apr_array_push(conf->protocols);\n    *np = arg;\n\n    return NULL;\n}\n\nstatic const char *set_protocols_honor_order(cmd_parms *cmd, void *dummy,\n                                             const char *arg)\n{\n    core_server_config *conf =\n    ap_get_core_module_config(cmd->server->module_config);\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    \n    if (err) {\n        return err;\n    }\n    \n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        conf->protocols_honor_order = 1;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        conf->protocols_honor_order = 0;\n    }\n    else {\n        return \"ProtocolsHonorOrder must be 'on' or 'off'\";\n    }\n    \n    return NULL;\n}\n\nstatic const char *set_http_protocol_options(cmd_parms *cmd, void *dummy,\n                                             const char *arg)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n\n    if (strcasecmp(arg, \"allow0.9\") == 0)\n        conf->http09_enable |= AP_HTTP09_ENABLE;\n    else if (strcasecmp(arg, \"require1.0\") == 0)\n        conf->http09_enable |= AP_HTTP09_DISABLE;\n    else if (strcasecmp(arg, \"strict\") == 0)\n        conf->http_conformance |= AP_HTTP_CONFORMANCE_STRICT;\n    else if (strcasecmp(arg, \"unsafe\") == 0)\n        conf->http_conformance |= AP_HTTP_CONFORMANCE_UNSAFE;\n    else if (strcasecmp(arg, \"registeredmethods\") == 0)\n        conf->http_methods |= AP_HTTP_METHODS_REGISTERED;\n    else if (strcasecmp(arg, \"lenientmethods\") == 0)\n        conf->http_methods |= AP_HTTP_METHODS_LENIENT;\n    else\n        return \"HttpProtocolOptions accepts \"\n               \"'Unsafe' or 'Strict' (default), \"\n               \"'RegisteredMethods' or 'LenientMethods' (default), and \"\n               \"'Require1.0' or 'Allow0.9' (default)\";\n\n    if ((conf->http09_enable & AP_HTTP09_ENABLE)\n            && (conf->http09_enable & AP_HTTP09_DISABLE))\n        return \"HttpProtocolOptions 'Allow0.9' and 'Require1.0'\"\n               \" are mutually exclusive\";\n\n    if ((conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT)\n            && (conf->http_conformance & AP_HTTP_CONFORMANCE_UNSAFE))\n        return \"HttpProtocolOptions 'Strict' and 'Unsafe'\"\n               \" are mutually exclusive\";\n\n    if ((conf->http_methods & AP_HTTP_METHODS_REGISTERED)\n            && (conf->http_methods & AP_HTTP_METHODS_LENIENT))\n        return \"HttpProtocolOptions 'RegisteredMethods' and 'LenientMethods'\"\n               \" are mutually exclusive\";\n\n    return NULL;\n}\n\nstatic const char *set_async_filter(cmd_parms *cmd, void *dummy,\n                                             const char *arg)\n{\n    core_server_config *conf =\n    ap_get_core_module_config(cmd->server->module_config);\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n\n    if (err) {\n        return err;\n    }\n\n    if (ap_cstr_casecmp(arg, \"network\") == 0) {\n        conf->async_filter = AP_FTYPE_NETWORK;\n    }\n    else if (ap_cstr_casecmp(arg, \"connection\") == 0) {\n        conf->async_filter = AP_FTYPE_CONNECTION;\n    }\n    else if (ap_cstr_casecmp(arg, \"request\") == 0) {\n        conf->async_filter = 0;\n    }\n    else {\n        return \"AsyncFilter must be 'network', 'connection' or 'request'\";\n    }\n    conf->async_filter_set = 1;\n\n    return NULL;\n}\n\nstatic const char *set_http_method(cmd_parms *cmd, void *conf, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    if (err != NULL)\n        return err;\n    ap_method_register(cmd->pool, arg);\n    return NULL;\n}\n\nstatic const char *set_cl_head_zero(cmd_parms *cmd, void *dummy, int arg)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n\n    if (arg) {\n        conf->http_cl_head_zero = AP_HTTP_CL_HEAD_ZERO_ENABLE;\n    } else {\n        conf->http_cl_head_zero = AP_HTTP_CL_HEAD_ZERO_DISABLE;\n    }\n    return NULL;\n}\n\nstatic const char *set_expect_strict(cmd_parms *cmd, void *dummy, int arg)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n\n    if (arg) {\n        conf->http_expect_strict = AP_HTTP_EXPECT_STRICT_ENABLE;\n    } else {\n        conf->http_expect_strict = AP_HTTP_EXPECT_STRICT_DISABLE;\n    }\n    return NULL;\n}\n\nstatic apr_hash_t *errorlog_hash;\n\nstatic int log_constant_item(const ap_errorlog_info *info, const char *arg,\n                             char *buf, int buflen)\n{\n    char *end = apr_cpystrn(buf, arg, buflen);\n    return end - buf;\n}\n\nstatic char *parse_errorlog_misc_string(apr_pool_t *p,\n                                        ap_errorlog_format_item *it,\n                                        const char **sa)\n{\n    const char *s;\n    char scratch[MAX_STRING_LEN];\n    char *d = scratch;\n    /*\n     * non-leading white space terminates this string to allow the next field\n     * separator to be inserted\n     */\n    int at_start = 1;\n\n    it->func = log_constant_item;\n    s = *sa;\n\n    while (*s && *s != '%' && (*s != ' ' || at_start) && d < scratch + MAX_STRING_LEN) {\n        if (*s != '\\\\') {\n            if (*s != ' ') {\n                at_start = 0;\n            }\n            *d++ = *s++;\n        }\n        else {\n            s++;\n            switch (*s) {\n            case 'r':\n                *d++ = '\\r';\n                s++;\n                break;\n            case 'n':\n                *d++ = '\\n';\n                s++;\n                break;\n            case 't':\n                *d++ = '\\t';\n                s++;\n                break;\n            case '\\0':\n                /* handle end of string */\n                *d++ = '\\\\';\n                break;\n            default:\n                /* copy next char verbatim */\n                *d++ = *s++;\n                break;\n            }\n        }\n    }\n    *d = '\\0';\n    it->arg = apr_pstrdup(p, scratch);\n\n    *sa = s;\n    return NULL;\n}\n\nstatic char *parse_errorlog_item(apr_pool_t *p, ap_errorlog_format_item *it,\n                                 const char **sa)\n{\n    const char *s = *sa;\n    ap_errorlog_handler *handler;\n    int i;\n\n    if (*s != '%') {\n        if (*s == ' ') {\n            it->flags |= AP_ERRORLOG_FLAG_FIELD_SEP;\n        }\n        return parse_errorlog_misc_string(p, it, sa);\n    }\n\n    ++s;\n\n    if (*s == ' ') {\n        /* percent-space (% ) is a field separator */\n        it->flags |= AP_ERRORLOG_FLAG_FIELD_SEP;\n        *sa = ++s;\n        /* recurse */\n        return parse_errorlog_item(p, it, sa);\n    }\n    else if (*s == '%') {\n        it->arg = \"%\";\n        it->func = log_constant_item;\n        *sa = ++s;\n        return NULL;\n    }\n\n    while (*s) {\n        switch (*s) {\n        case '{':\n            ++s;\n            it->arg = ap_getword(p, &s, '}');\n            break;\n        case '+':\n            ++s;\n            it->flags |= AP_ERRORLOG_FLAG_REQUIRED;\n            break;\n        case '-':\n            ++s;\n            it->flags |= AP_ERRORLOG_FLAG_NULL_AS_HYPHEN;\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            i = *s - '0';\n            while (apr_isdigit(*++s))\n                i = i * 10 + (*s) - '0';\n            it->min_loglevel = i;\n            break;\n        case 'M':\n            it->func = NULL;\n            it->flags |= AP_ERRORLOG_FLAG_MESSAGE;\n            *sa = ++s;\n            return NULL;\n        default:\n            handler = (ap_errorlog_handler *)apr_hash_get(errorlog_hash, s, 1);\n            if (!handler) {\n                char dummy[2];\n\n                dummy[0] = *s;\n                dummy[1] = '\\0';\n                return apr_pstrcat(p, \"Unrecognized error log format directive %\",\n                               dummy, NULL);\n            }\n            it->func = handler->func;\n            *sa = ++s;\n            return NULL;\n        }\n    }\n\n    return \"Ran off end of error log format parsing args to some directive\";\n}\n\nstatic apr_array_header_t *parse_errorlog_string(apr_pool_t *p,\n                                                 const char *s,\n                                                 const char **err,\n                                                 int is_main_fmt)\n{\n    apr_array_header_t *a = apr_array_make(p, 30,\n                                           sizeof(ap_errorlog_format_item));\n    char *res;\n    int seen_msg_fmt = 0;\n\n    while (s && *s) {\n        ap_errorlog_format_item *item =\n            (ap_errorlog_format_item *)apr_array_push(a);\n        memset(item, 0, sizeof(*item));\n        res = parse_errorlog_item(p, item, &s);\n        if (res) {\n            *err = res;\n            return NULL;\n        }\n        if (item->flags & AP_ERRORLOG_FLAG_MESSAGE) {\n            if (!is_main_fmt) {\n                *err = \"%M cannot be used in once-per-request or \"\n                       \"once-per-connection formats\";\n                return NULL;\n            }\n            seen_msg_fmt = 1;\n        }\n        if (is_main_fmt && item->flags & AP_ERRORLOG_FLAG_REQUIRED) {\n            *err = \"The '+' flag cannot be used in the main error log format\";\n            return NULL;\n        }\n        if (!is_main_fmt && item->min_loglevel) {\n            *err = \"The loglevel cannot be used as a condition in \"\n                   \"once-per-request or once-per-connection formats\";\n            return NULL;\n        }\n        if (item->min_loglevel > APLOG_TRACE8) {\n            *err = \"The specified loglevel modifier is out of range\";\n            return NULL;\n        }\n    }\n\n    if (is_main_fmt && !seen_msg_fmt) {\n        *err = \"main ErrorLogFormat must contain message format string '%M'\";\n        return NULL;\n    }\n\n    return a;\n}\n\nstatic const char *set_errorlog(cmd_parms *cmd, void *dummy, const char *arg1,\n                                const char *arg2)\n{\n    ap_errorlog_provider *provider;\n    const char *err;\n    cmd->server->errorlog_provider = NULL;\n\n    if (!arg2) {\n        /* Stay backward compatible and check for \"syslog\" */\n        if (strncmp(\"syslog\", arg1, 6) == 0) {\n            arg2 = arg1 + 7; /* skip the ':' if any */\n            arg1 = \"syslog\";\n        }\n        else {\n            /* Admin can define only \"ErrorLog provider\" and we should \n             * still handle that using the defined provider, but with empty\n             * error_fname. */\n            provider = ap_lookup_provider(AP_ERRORLOG_PROVIDER_GROUP, arg1,\n                                          AP_ERRORLOG_PROVIDER_VERSION);\n            if (provider) {\n                arg2 = \"\";\n            }\n            else {\n                return set_server_string_slot(cmd, dummy, arg1);\n            }\n        }\n    }\n\n    if (strcmp(\"file\", arg1) == 0) {\n        return set_server_string_slot(cmd, dummy, arg2);\n    }\n\n    provider = ap_lookup_provider(AP_ERRORLOG_PROVIDER_GROUP, arg1,\n                                    AP_ERRORLOG_PROVIDER_VERSION);\n    if (!provider) {\n        return apr_psprintf(cmd->pool,\n                            \"Unknown ErrorLog provider: %s\",\n                            arg1);\n    }\n\n    err = provider->parse_errorlog_arg(cmd, arg2);\n    if (err) {\n        return err;\n    }\n\n    cmd->server->errorlog_provider = provider;\n    return set_server_string_slot(cmd, dummy, arg2);\n}\n\nstatic const char *set_errorlog_format(cmd_parms *cmd, void *dummy,\n                                       const char *arg1, const char *arg2)\n{\n    const char *err_string = NULL;\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n\n    if (!arg2) {\n        conf->error_log_format = parse_errorlog_string(cmd->pool, arg1,\n                                                       &err_string, 1);\n    }\n    else if (!ap_cstr_casecmp(arg1, \"connection\")) {\n        if (!conf->error_log_conn) {\n            conf->error_log_conn = apr_array_make(cmd->pool, 5,\n                                                  sizeof(apr_array_header_t *));\n        }\n\n        if (*arg2) {\n            apr_array_header_t **e;\n            e = (apr_array_header_t **) apr_array_push(conf->error_log_conn);\n            *e = parse_errorlog_string(cmd->pool, arg2, &err_string, 0);\n        }\n    }\n    else if (!ap_cstr_casecmp(arg1, \"request\")) {\n        if (!conf->error_log_req) {\n            conf->error_log_req = apr_array_make(cmd->pool, 5,\n                                                 sizeof(apr_array_header_t *));\n        }\n\n        if (*arg2) {\n            apr_array_header_t **e;\n            e = (apr_array_header_t **) apr_array_push(conf->error_log_req);\n            *e = parse_errorlog_string(cmd->pool, arg2, &err_string, 0);\n        }\n    }\n    else {\n        err_string = \"ErrorLogFormat type must be one of request, connection\";\n    }\n\n    return err_string;\n}\n\nAP_DECLARE(void) ap_register_errorlog_handler(apr_pool_t *p, char *tag,\n                                              ap_errorlog_handler_fn_t *handler,\n                                              int flags)\n{\n    ap_errorlog_handler *log_struct = apr_palloc(p, sizeof(*log_struct));\n    log_struct->func = handler;\n    log_struct->flags = flags;\n\n    apr_hash_set(errorlog_hash, tag, 1, (const void *)log_struct);\n}\n\n\nstatic const char *set_merge_trailers(cmd_parms *cmd, void *dummy, int arg)\n{\n    core_server_config *conf = ap_get_module_config(cmd->server->module_config,\n                                                    &core_module);\n    conf->merge_trailers = (arg ? AP_MERGE_TRAILERS_ENABLE :\n            AP_MERGE_TRAILERS_DISABLE);\n\n    return NULL;\n}\n\n/* Note --- ErrorDocument will now work from .htaccess files.\n * The AllowOverride of Fileinfo allows webmasters to turn it off\n */\n\nstatic const command_rec core_cmds[] = {\n\n/* Old access config file commands */\n\nAP_INIT_RAW_ARGS(\"<Directory\", dirsection, NULL, RSRC_CONF,\n  \"Container for directives affecting resources located in the specified \"\n  \"directories\"),\nAP_INIT_RAW_ARGS(\"<Location\", urlsection, NULL, RSRC_CONF,\n  \"Container for directives affecting resources accessed through the \"\n  \"specified URL paths\"),\nAP_INIT_RAW_ARGS(\"<VirtualHost\", virtualhost_section, NULL, RSRC_CONF,\n  \"Container to map directives to a particular virtual host, takes one or \"\n  \"more host addresses\"),\nAP_INIT_RAW_ARGS(\"<Files\", filesection, NULL, OR_ALL,\n  \"Container for directives affecting files matching specified patterns\"),\nAP_INIT_RAW_ARGS(\"<Limit\", ap_limit_section, NULL, OR_LIMIT | OR_AUTHCFG,\n  \"Container for authentication directives when accessed using specified HTTP \"\n  \"methods\"),\nAP_INIT_RAW_ARGS(\"<LimitExcept\", ap_limit_section, (void*)1,\n                 OR_LIMIT | OR_AUTHCFG,\n  \"Container for authentication directives to be applied when any HTTP \"\n  \"method other than those specified is used to access the resource\"),\nAP_INIT_RAW_ARGS(\"<IfModule\", start_cond_section, (void *)test_ifmod_section,\n              EXEC_ON_READ | OR_ALL,\n  \"Container for directives based on existence of specified modules\"),\nAP_INIT_RAW_ARGS(\"<IfDefine\", start_cond_section, (void *)test_ifdefine_section,\n              EXEC_ON_READ | OR_ALL,\n  \"Container for directives based on existence of command line defines\"),\nAP_INIT_RAW_ARGS(\"<IfFile\", start_cond_section, (void *)test_iffile_section,\n              EXEC_ON_READ | OR_ALL,\n  \"Container for directives based on existence of files on disk\"),\nAP_INIT_RAW_ARGS(\"<IfDirective\", start_cond_section, (void *)test_ifdirective_section,\n              EXEC_ON_READ | OR_ALL,\n  \"Container for directives based on existence of named directive\"),\nAP_INIT_RAW_ARGS(\"<IfSection\", start_cond_section, (void *)test_ifsection_section,\n              EXEC_ON_READ | OR_ALL,\n  \"Container for directives based on existence of named section\"),\nAP_INIT_RAW_ARGS(\"<DirectoryMatch\", dirsection, (void*)1, RSRC_CONF,\n  \"Container for directives affecting resources located in the \"\n  \"specified directories\"),\nAP_INIT_RAW_ARGS(\"<LocationMatch\", urlsection, (void*)1, RSRC_CONF,\n  \"Container for directives affecting resources accessed through the \"\n  \"specified URL paths\"),\nAP_INIT_RAW_ARGS(\"<FilesMatch\", filesection, (void*)1, OR_ALL,\n  \"Container for directives affecting files matching specified patterns\"),\n#ifdef GPROF\nAP_INIT_TAKE1(\"GprofDir\", set_gprof_dir, NULL, RSRC_CONF,\n  \"Directory to plop gmon.out files\"),\n#endif\nAP_INIT_TAKE1(\"AddDefaultCharset\", set_add_default_charset, NULL, OR_FILEINFO,\n  \"The name of the default charset to add to any Content-Type without one or 'Off' to disable\"),\nAP_INIT_TAKE1(\"AcceptPathInfo\", set_accept_path_info, NULL, OR_FILEINFO,\n  \"Set to on or off for PATH_INFO to be accepted by handlers, or default for the per-handler preference\"),\nAP_INIT_TAKE12(\"Define\", set_define, NULL, EXEC_ON_READ|RSRC_CONF,\n              \"Define a variable, optionally to a value.  Same as passing -D to the command line.\"),\nAP_INIT_TAKE1(\"UnDefine\", unset_define, NULL, EXEC_ON_READ|RSRC_CONF,\n              \"Undefine the existence of a variable. Undo a Define.\"),\nAP_INIT_RAW_ARGS(\"Error\", generate_message, (void*) APLOG_ERR, OR_ALL,\n                 \"Generate error message from within configuration.\"),\nAP_INIT_RAW_ARGS(\"Warning\", generate_message, (void*) APLOG_WARNING, OR_ALL,\n                 \"Generate warning message from within configuration.\"),\nAP_INIT_RAW_ARGS(\"<If\", ifsection, COND_IF, OR_ALL,\n  \"Container for directives to be conditionally applied\"),\nAP_INIT_RAW_ARGS(\"<ElseIf\", ifsection, COND_ELSEIF, OR_ALL,\n  \"Container for directives to be conditionally applied\"),\nAP_INIT_RAW_ARGS(\"<Else\", ifsection, COND_ELSE, OR_ALL,\n  \"Container for directives to be conditionally applied\"),\n\n/* Old resource config file commands */\n\nAP_INIT_RAW_ARGS(\"AccessFileName\", set_access_name, NULL, RSRC_CONF,\n  \"Name(s) of per-directory config files (default: .htaccess)\"),\nAP_INIT_TAKE1(\"DocumentRoot\", set_document_root, NULL, RSRC_CONF,\n  \"Root directory of the document tree\"),\nAP_INIT_TAKE2(\"ErrorDocument\", set_error_document, NULL, OR_FILEINFO,\n  \"Change responses for HTTP errors\"),\nAP_INIT_RAW_ARGS(\"AllowOverride\", set_override, NULL, ACCESS_CONF,\n  \"Controls what groups of directives can be configured by per-directory \"\n  \"config files\"),\nAP_INIT_TAKE_ARGV(\"AllowOverrideList\", set_override_list, NULL, ACCESS_CONF,\n  \"Controls what individual directives can be configured by per-directory \"\n  \"config files\"),\nAP_INIT_RAW_ARGS(\"Options\", set_options, NULL, OR_OPTIONS,\n  \"Set a number of attributes for a given directory\"),\nAP_INIT_TAKE1(\"DefaultType\", set_default_type, NULL, OR_FILEINFO,\n  \"the default media type for otherwise untyped files (DEPRECATED)\"),\nAP_INIT_RAW_ARGS(\"FileETag\", set_etag_bits, NULL, OR_FILEINFO,\n  \"Specify components used to construct a file's ETag\"),\nAP_INIT_TAKE1(\"EnableMMAP\", set_enable_mmap, NULL, OR_FILEINFO,\n  \"Controls whether memory-mapping may be used to read files\"),\nAP_INIT_TAKE1(\"EnableSendfile\", set_enable_sendfile, NULL, OR_FILEINFO,\n  \"Controls whether sendfile may be used to transmit files\"),\n\n/* Old server config file commands */\n\nAP_INIT_TAKE1(\"Protocol\", set_protocol, NULL, RSRC_CONF,\n  \"Set the Protocol for httpd to use.\"),\nAP_INIT_TAKE2(\"AcceptFilter\", set_accf_map, NULL, RSRC_CONF,\n  \"Set the Accept Filter to use for a protocol\"),\nAP_INIT_TAKE1(\"Port\", ap_set_deprecated, NULL, RSRC_CONF,\n  \"Port was replaced with Listen in Apache 2.0\"),\nAP_INIT_TAKE1(\"HostnameLookups\", set_hostname_lookups, NULL,\n  ACCESS_CONF|RSRC_CONF,\n  \"\\\"on\\\" to enable, \\\"off\\\" to disable reverse DNS lookups, or \\\"double\\\" to \"\n  \"enable double-reverse DNS lookups\"),\nAP_INIT_TAKE1(\"ServerAdmin\", set_server_string_slot,\n  (void *)APR_OFFSETOF(server_rec, server_admin), RSRC_CONF,\n  \"The email address of the server administrator\"),\nAP_INIT_TAKE1(\"ServerName\", server_hostname_port, NULL, RSRC_CONF,\n  \"The hostname and port of the server\"),\nAP_INIT_TAKE1(\"ServerSignature\", set_signature_flag, NULL, OR_ALL,\n  \"En-/disable server signature (on|off|email)\"),\nAP_INIT_TAKE1(\"ServerRoot\", set_server_root, NULL, RSRC_CONF | EXEC_ON_READ,\n  \"Common directory of server-related files (logs, confs, etc.)\"),\nAP_INIT_TAKE1(\"DefaultRuntimeDir\", set_runtime_dir, NULL, RSRC_CONF | EXEC_ON_READ,\n  \"Common directory for run-time files (shared memory, locks, etc.)\"),\nAP_INIT_TAKE12(\"ErrorLog\", set_errorlog,\n  (void *)APR_OFFSETOF(server_rec, error_fname), RSRC_CONF,\n  \"The filename of the error log\"),\nAP_INIT_TAKE12(\"ErrorLogFormat\", set_errorlog_format, NULL, RSRC_CONF,\n  \"Format string for the ErrorLog\"),\nAP_INIT_RAW_ARGS(\"ServerAlias\", set_server_alias, NULL, RSRC_CONF,\n  \"A name or names alternately used to access the server\"),\nAP_INIT_TAKE1(\"ServerPath\", set_serverpath, NULL, RSRC_CONF,\n  \"The pathname the server can be reached at\"),\nAP_INIT_TAKE1(\"Timeout\", set_timeout, NULL, RSRC_CONF,\n  \"Timeout duration (sec)\"),\nAP_INIT_FLAG(\"ContentDigest\", set_content_md5, NULL, OR_OPTIONS,\n  \"whether or not to send a Content-MD5 header with each request\"),\nAP_INIT_TAKE1(\"UseCanonicalName\", set_use_canonical_name, NULL,\n  RSRC_CONF|ACCESS_CONF,\n  \"How to work out the ServerName : Port when constructing URLs\"),\nAP_INIT_TAKE1(\"UseCanonicalPhysicalPort\", set_use_canonical_phys_port, NULL,\n  RSRC_CONF|ACCESS_CONF,\n  \"Whether to use the physical Port when constructing URLs\"),\n/* TODO: RlimitFoo should all be part of mod_cgi, not in the core */\n/* TODO: ListenBacklog in MPM */\nAP_INIT_TAKE1(\"Include\", include_config, NULL,\n  (RSRC_CONF | ACCESS_CONF | EXEC_ON_READ),\n  \"Name(s) of the config file(s) to be included; fails if the wildcard does \"\n  \"not match at least one file\"),\nAP_INIT_TAKE1(\"IncludeOptional\", include_config, (void*)1,\n  (RSRC_CONF | ACCESS_CONF | EXEC_ON_READ),\n  \"Name or pattern of the config file(s) to be included; ignored if the file \"\n  \"does not exist or the pattern does not match any files\"),\nAP_INIT_ITERATE(\"LogLevel\", set_loglevel, NULL, RSRC_CONF|ACCESS_CONF,\n  \"Level of verbosity in error logging\"),\nAP_INIT_TAKE_ARGV(\"LogLevelOverride\", set_loglevel_override, NULL, RSRC_CONF,\n  \"Override LogLevel for clients with certain IPs\"),\nAP_INIT_TAKE1(\"NameVirtualHost\", ap_set_name_virtual_host, NULL, RSRC_CONF,\n  \"A numeric IP address:port, or the name of a host\"),\nAP_INIT_TAKE1(\"ServerTokens\", set_serv_tokens, NULL, RSRC_CONF,\n  \"Determine tokens displayed in the Server: header - Min(imal), \"\n  \"Major, Minor, Prod(uctOnly), OS, or Full\"),\nAP_INIT_TAKE1(\"LimitRequestLine\", set_limit_req_line, NULL, RSRC_CONF,\n  \"Limit on maximum size of an HTTP request line\"),\nAP_INIT_TAKE1(\"LimitRequestFieldsize\", set_limit_req_fieldsize, NULL,\n  RSRC_CONF,\n  \"Limit on maximum size of an HTTP request header field\"),\nAP_INIT_TAKE1(\"LimitRequestFields\", set_limit_req_fields, NULL, RSRC_CONF,\n  \"Limit (0 = unlimited) on max number of header fields in a request message\"),\nAP_INIT_TAKE1(\"LimitRequestBody\", set_limit_req_body,\n  (void*)APR_OFFSETOF(core_dir_config, limit_req_body), OR_ALL,\n  \"Limit (in bytes) on maximum size of request message body\"),\nAP_INIT_TAKE1(\"LimitXMLRequestBody\", set_limit_xml_req_body, NULL, OR_ALL,\n              \"Limit (in bytes) on maximum size of an XML-based request \"\n              \"body\"),\nAP_INIT_RAW_ARGS(\"Mutex\", ap_set_mutex, NULL, RSRC_CONF,\n                 \"mutex (or \\\"default\\\") and mechanism\"),\n\nAP_INIT_TAKE1(\"MaxRanges\", set_max_ranges, NULL, RSRC_CONF|ACCESS_CONF,\n              \"Maximum number of Ranges in a request before returning the entire \"\n              \"resource, or 0 for unlimited\"),\nAP_INIT_TAKE1(\"MaxRangeOverlaps\", set_max_overlaps, NULL, RSRC_CONF|ACCESS_CONF,\n              \"Maximum number of overlaps in Ranges in a request before returning the entire \"\n              \"resource, or 0 for unlimited\"),\nAP_INIT_TAKE1(\"MaxRangeReversals\", set_max_reversals, NULL, RSRC_CONF|ACCESS_CONF,\n              \"Maximum number of reversals in Ranges in a request before returning the entire \"\n              \"resource, or 0 for unlimited\"),\n/* System Resource Controls */\n#ifdef RLIMIT_CPU\nAP_INIT_TAKE12(\"RLimitCPU\", set_limit_cpu,\n  (void*)APR_OFFSETOF(core_dir_config, limit_cpu),\n  OR_ALL, \"Soft/hard limits for max CPU usage in seconds\"),\n#else\nAP_INIT_TAKE12(\"RLimitCPU\", no_set_limit, NULL,\n  OR_ALL, \"Soft/hard limits for max CPU usage in seconds\"),\n#endif\n#if defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined (RLIMIT_AS)\nAP_INIT_TAKE12(\"RLimitMEM\", set_limit_mem,\n  (void*)APR_OFFSETOF(core_dir_config, limit_mem),\n  OR_ALL, \"Soft/hard limits for max memory usage per process\"),\n#else\nAP_INIT_TAKE12(\"RLimitMEM\", no_set_limit, NULL,\n  OR_ALL, \"Soft/hard limits for max memory usage per process\"),\n#endif\n#ifdef RLIMIT_NPROC\nAP_INIT_TAKE12(\"RLimitNPROC\", set_limit_nproc,\n  (void*)APR_OFFSETOF(core_dir_config, limit_nproc),\n  OR_ALL, \"soft/hard limits for max number of processes per uid\"),\n#else\nAP_INIT_TAKE12(\"RLimitNPROC\", no_set_limit, NULL,\n   OR_ALL, \"soft/hard limits for max number of processes per uid\"),\n#endif\n\n/* internal recursion stopper */\nAP_INIT_TAKE12(\"LimitInternalRecursion\", set_recursion_limit, NULL, RSRC_CONF,\n              \"maximum recursion depth of internal redirects and subrequests\"),\n\nAP_INIT_FLAG(\"CGIPassAuth\", set_cgi_pass_auth, NULL, OR_AUTHCFG,\n             \"Controls whether HTTP authorization headers, normally hidden, will \"\n             \"be passed to scripts\"),\nAP_INIT_TAKE2(\"CGIVar\", set_cgi_var, NULL, OR_FILEINFO,\n              \"Controls how some CGI variables are set\"),\nAP_INIT_FLAG(\"QualifyRedirectURL\", set_qualify_redirect_url, NULL, OR_FILEINFO,\n             \"Controls whether the REDIRECT_URL environment variable is fully \"\n             \"qualified\"),\n\nAP_INIT_TAKE1(\"ForceType\", ap_set_string_slot_lower,\n       (void *)APR_OFFSETOF(core_dir_config, mime_type), OR_FILEINFO,\n     \"a mime type that overrides other configured type\"),\nAP_INIT_TAKE1(\"SetHandler\", set_sethandler, NULL, OR_FILEINFO,\n   \"a handler name that overrides any other configured handler\"),\nAP_INIT_TAKE1(\"SetOutputFilter\", ap_set_string_slot,\n       (void *)APR_OFFSETOF(core_dir_config, output_filters), OR_FILEINFO,\n   \"filter (or ; delimited list of filters) to be run on the request content\"),\nAP_INIT_TAKE1(\"SetInputFilter\", ap_set_string_slot,\n       (void *)APR_OFFSETOF(core_dir_config, input_filters), OR_FILEINFO,\n   \"filter (or ; delimited list of filters) to be run on the request body\"),\nAP_INIT_TAKE1(\"AllowEncodedSlashes\", set_allow2f, NULL, RSRC_CONF,\n             \"Allow URLs containing '/' encoded as '%2F'\"),\n\n/* scoreboard.c directives */\nAP_INIT_TAKE1(\"ScoreBoardFile\", ap_set_scoreboard, NULL, RSRC_CONF,\n              \"A file for Apache to maintain runtime process management information\"),\nAP_INIT_FLAG(\"ExtendedStatus\", ap_set_extended_status, NULL, RSRC_CONF,\n             \"\\\"On\\\" to track extended status information, \\\"Off\\\" to disable\"),\nAP_INIT_FLAG(\"SeeRequestTail\", ap_set_reqtail, NULL, RSRC_CONF,\n             \"For extended status, \\\"On\\\" to see the last 63 chars of \"\n             \"the request line, \\\"Off\\\" (default) to see the first 63\"),\n\n/*\n * These are default configuration directives that mpms can/should\n * pay attention to.\n * XXX These are not for all platforms, and even some Unix MPMs might not want\n * some directives.\n */\nAP_INIT_TAKE1(\"PidFile\",  ap_mpm_set_pidfile, NULL, RSRC_CONF,\n              \"A file for logging the server process ID\"),\nAP_INIT_TAKE1(\"MaxRequestsPerChild\", ap_mpm_set_max_requests, NULL, RSRC_CONF,\n              \"Maximum number of connections a particular child serves before \"\n              \"dying. (DEPRECATED, use MaxConnectionsPerChild)\"),\nAP_INIT_TAKE1(\"MaxConnectionsPerChild\", ap_mpm_set_max_requests, NULL, RSRC_CONF,\n              \"Maximum number of connections a particular child serves before dying.\"),\nAP_INIT_TAKE1(\"CoreDumpDirectory\", ap_mpm_set_coredumpdir, NULL, RSRC_CONF,\n              \"The location of the directory Apache changes to before dumping core\"),\nAP_INIT_TAKE1(\"MaxMemFree\", ap_mpm_set_max_mem_free, NULL, RSRC_CONF,\n              \"Maximum number of 1k blocks a particular child's allocator may hold.\"),\nAP_INIT_TAKE1(\"ThreadStackSize\", ap_mpm_set_thread_stacksize, NULL, RSRC_CONF,\n              \"Size in bytes of stack used by threads handling client connections\"),\n#if AP_ENABLE_EXCEPTION_HOOK\nAP_INIT_TAKE1(\"EnableExceptionHook\", ap_mpm_set_exception_hook, NULL, RSRC_CONF,\n              \"Controls whether exception hook may be called after a crash\"),\n#endif\nAP_INIT_TAKE1(\"TraceEnable\", set_trace_enable, NULL, RSRC_CONF,\n              \"'on' (default), 'off' or 'extended' to trace request body content\"),\nAP_INIT_FLAG(\"MergeTrailers\", set_merge_trailers, NULL, RSRC_CONF,\n              \"merge request trailers into request headers or not\"),\nAP_INIT_ITERATE(\"HttpProtocolOptions\", set_http_protocol_options, NULL, RSRC_CONF,\n                \"'Allow0.9' or 'Require1.0' (default); \"\n                \"'RegisteredMethods' or 'LenientMethods' (default); \"\n                \"'Unsafe' or 'Strict' (default). Sets HTTP acceptance rules\"),\nAP_INIT_ITERATE(\"RegisterHttpMethod\", set_http_method, NULL, RSRC_CONF,\n                \"Registers non-standard HTTP methods\"),\nAP_INIT_FLAG(\"HttpContentLengthHeadZero\", set_cl_head_zero, NULL, OR_OPTIONS,\n  \"whether to permit Content-Length of 0 responses to HEAD requests\"),\nAP_INIT_FLAG(\"HttpExpectStrict\", set_expect_strict, NULL, OR_OPTIONS,\n  \"whether to return a 417 if a client doesn't send 100-Continue\"),\nAP_INIT_ITERATE(\"Protocols\", set_protocols, NULL, RSRC_CONF,\n                \"Controls which protocols are allowed\"),\nAP_INIT_TAKE1(\"ProtocolsHonorOrder\", set_protocols_honor_order, NULL, RSRC_CONF,\n              \"'off' (default) or 'on' to respect given order of protocols, \"\n              \"by default the client specified order determines selection\"),\nAP_INIT_TAKE1(\"AsyncFilter\", set_async_filter, NULL, RSRC_CONF,\n              \"'network', 'connection' (default) or 'request' to limit the \"\n              \"types of filters that support asynchronous handling\"),\n{ NULL }\n};\n\n/*****************************************************************\n *\n * Core handlers for various phases of server operation...\n */\n\nAP_DECLARE_NONSTD(int) ap_core_translate(request_rec *r)\n{\n    apr_status_t rv;\n    char *path;\n\n    /* XXX this seems too specific, this should probably become\n     * some general-case test\n     */\n    if (r->proxyreq) {\n        return HTTP_FORBIDDEN;\n    }\n    if (!r->uri || ((r->uri[0] != '/') && strcmp(r->uri, \"*\"))) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00126)\n                     \"Invalid URI in request '%s' '%s'\", r->uri, r->the_request);\n        return HTTP_BAD_REQUEST;\n    }\n\n    if (r->server->path\n        && !strncmp(r->uri, r->server->path, r->server->pathlen)\n        && (r->server->path[r->server->pathlen - 1] == '/'\n            || r->uri[r->server->pathlen] == '/'\n            || r->uri[r->server->pathlen] == '\\0'))\n    {\n        path = r->uri + r->server->pathlen;\n    }\n    else {\n        path = r->uri;\n    }\n    /*\n     * Make sure that we do not mess up the translation by adding two\n     * /'s in a row.  This happens under windows when the document\n     * root ends with a /\n     */\n    /* skip all leading /'s (e.g. http://localhost///foo)\n     * so we are looking at only the relative path.\n     */\n    while (*path == '/') {\n        ++path;\n    }\n    if ((rv = apr_filepath_merge(&r->filename, ap_document_root(r), path,\n                                 APR_FILEPATH_TRUENAME\n                               | APR_FILEPATH_SECUREROOT, r->pool))\n                != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(00127)\n                     \"Cannot map %s to file\", r->the_request);\n        return HTTP_FORBIDDEN;\n    }\n    r->canonical_filename = r->filename;\n\n    return OK;\n}\n\n/*****************************************************************\n *\n * Test the filesystem name through directory_walk and file_walk\n */\nstatic int core_map_to_storage(request_rec *r)\n{\n    int access_status;\n\n    if ((access_status = ap_directory_walk(r))) {\n        return access_status;\n    }\n\n    if ((access_status = ap_file_walk(r))) {\n        return access_status;\n    }\n\n    return OK;\n}\n\n\nstatic int do_nothing(request_rec *r) { return OK; }\n\nstatic int core_override_type(request_rec *r)\n{\n    core_dir_config *conf =\n        (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n\n    /* Check for overrides with ForceType / SetHandler\n     */\n    if (conf->mime_type && strcmp(conf->mime_type, \"none\"))\n        ap_set_content_type(r, (char*) conf->mime_type);\n\n    if (conf->expr_handler) { \n        const char *err;\n        const char *val;\n        val = ap_expr_str_exec(r, conf->expr_handler, &err);\n        if (err) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(03154)\n                          \"Can't evaluate handler expression: %s\", err);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        if (val != ap_strstr_c(val, \"proxy:unix\")) { \n            /* Retained for compatibility --  but not for UDS */\n            char *tmp = apr_pstrdup(r->pool, val);\n            ap_str_tolower(tmp);\n            val = tmp;\n        }\n\n        if (strcmp(val, \"none\")) { \n            r->handler = val;\n        }\n    }\n    else if (conf->handler && strcmp(conf->handler, \"none\")) { \n        r->handler = conf->handler;\n    }\n\n    /* Deal with the poor soul who is trying to force path_info to be\n     * accepted within the core_handler, where they will let the subreq\n     * address its contents.  This is toggled by the user in the very\n     * beginning of the fixup phase (here!), so modules should override the user's\n     * discretion in their own module fixup phase.  It is tristate, if\n     * the user doesn't specify, the result is AP_REQ_DEFAULT_PATH_INFO.\n     * (which the module may interpret to its own customary behavior.)\n     * It won't be touched if the value is no longer AP_ACCEPT_PATHINFO_UNSET,\n     * so any module changing the value prior to the fixup phase\n     * OVERRIDES the user's choice.\n     */\n    if ((r->used_path_info == AP_REQ_DEFAULT_PATH_INFO)\n        && (conf->accept_path_info != AP_ACCEPT_PATHINFO_UNSET)) {\n        /* No module knew better, and the user coded AcceptPathInfo */\n        r->used_path_info = conf->accept_path_info;\n    }\n\n    return OK;\n}\n\nstatic int default_handler(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    apr_bucket_brigade *bb;\n    apr_bucket *e;\n    core_dir_config *d;\n    int errstatus;\n    apr_file_t *fd = NULL;\n    apr_status_t status;\n    /* XXX if/when somebody writes a content-md5 filter we either need to\n     *     remove this support or coordinate when to use the filter vs.\n     *     when to use this code\n     *     The current choice of when to compute the md5 here matches the 1.3\n     *     support fairly closely (unlike 1.3, we don't handle computing md5\n     *     when the charset is translated).\n     */\n    int bld_content_md5;\n\n    d = (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n    bld_content_md5 = (d->content_md5 == AP_CONTENT_MD5_ON)\n                      && r->output_filters->frec->ftype != AP_FTYPE_RESOURCE;\n\n    ap_allow_standard_methods(r, MERGE_ALLOW, M_GET, M_OPTIONS, M_POST, -1);\n\n    /* If filters intend to consume the request body, they must\n     * register an InputFilter to slurp the contents of the POST\n     * data from the POST input stream.  It no longer exists when\n     * the output filters are invoked by the default handler.\n     */\n    if ((errstatus = ap_discard_request_body(r)) != OK) {\n        return errstatus;\n    }\n\n    if (r->method_number == M_GET || r->method_number == M_POST) {\n        if (r->finfo.filetype == APR_NOFILE) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00128)\n                          \"File does not exist: %s\",\n                          apr_pstrcat(r->pool, r->filename, r->path_info, NULL));\n            return HTTP_NOT_FOUND;\n        }\n\n        /* Don't try to serve a dir.  Some OSs do weird things with\n         * raw I/O on a dir.\n         */\n        if (r->finfo.filetype == APR_DIR) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00129)\n                          \"Attempt to serve directory: %s\", r->filename);\n            return HTTP_NOT_FOUND;\n        }\n\n        if ((r->used_path_info != AP_REQ_ACCEPT_PATH_INFO) &&\n            r->path_info && *r->path_info)\n        {\n            /* default to reject */\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00130)\n                          \"File does not exist: %s\",\n                          apr_pstrcat(r->pool, r->filename, r->path_info, NULL));\n            return HTTP_NOT_FOUND;\n        }\n\n        /* We understood the (non-GET) method, but it might not be legal for\n           this particular resource. Check to see if the 'deliver_script'\n           flag is set. If so, then we go ahead and deliver the file since\n           it isn't really content (only GET normally returns content).\n\n           Note: based on logic further above, the only possible non-GET\n           method at this point is POST. In the future, we should enable\n           script delivery for all methods.  */\n        if (r->method_number != M_GET) {\n            core_request_config *req_cfg;\n\n            req_cfg = ap_get_core_module_config(r->request_config);\n            if (!req_cfg->deliver_script) {\n                /* The flag hasn't been set for this request. Punt. */\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00131)\n                              \"This resource does not accept the %s method.\",\n                              r->method);\n                return HTTP_METHOD_NOT_ALLOWED;\n            }\n        }\n\n\n        if ((status = apr_file_open(&fd, r->filename, APR_READ | APR_BINARY\n#if APR_HAS_SENDFILE\n                            | AP_SENDFILE_ENABLED(d->enable_sendfile)\n#endif\n                                    , 0, r->pool)) != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00132)\n                          \"file permissions deny server access: %s\", r->filename);\n            return HTTP_FORBIDDEN;\n        }\n\n        ap_update_mtime(r, r->finfo.mtime);\n        ap_set_last_modified(r);\n        ap_set_etag(r);\n        ap_set_accept_ranges(r);\n        ap_set_content_length(r, r->finfo.size);\n        if (bld_content_md5) {\n            apr_table_setn(r->headers_out, \"Content-MD5\",\n                           ap_md5digest(r->pool, fd));\n        }\n\n        bb = apr_brigade_create(r->pool, c->bucket_alloc);\n\n        if ((errstatus = ap_meets_conditions(r)) != OK) {\n            apr_file_close(fd);\n            r->status = errstatus;\n        }\n        else {\n            e = apr_brigade_insert_file(bb, fd, 0, r->finfo.size, r->pool);\n\n#if APR_HAS_MMAP\n            if (d->enable_mmap == ENABLE_MMAP_OFF) {\n                (void)apr_bucket_file_enable_mmap(e, 0);\n            }\n#endif\n        }\n\n        e = apr_bucket_eos_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n\n        status = ap_pass_brigade(r->output_filters, bb);\n        apr_brigade_cleanup(bb);\n\n        if (status == APR_SUCCESS\n            || r->status != HTTP_OK\n            || c->aborted) {\n            return OK;\n        }\n        else {\n            /* no way to know what type of error occurred */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00133)\n                          \"default_handler: ap_pass_brigade returned %i\",\n                          status);\n            return AP_FILTER_ERROR;\n        }\n    }\n    else {              /* unusual method (not GET or POST) */\n        if (r->method_number == M_INVALID) {\n            /* See if this looks like an undecrypted SSL handshake attempt.\n             * It's safe to look a couple bytes into the_request if it exists, as it's\n             * always allocated at least MIN_LINE_ALLOC (80) bytes.\n             */\n            if (r->the_request\n                && r->the_request[0] == 0x16\n                && (r->the_request[1] == 0x2 || r->the_request[1] == 0x3)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00134)\n                              \"Invalid method in request %s - possible attempt to establish SSL connection on non-SSL port\", r->the_request);\n            } else {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00135)\n                              \"Invalid method in request %s\", r->the_request);\n            }\n            return HTTP_NOT_IMPLEMENTED;\n        }\n\n        if (r->method_number == M_OPTIONS) {\n            return ap_send_http_options(r);\n        }\n        return HTTP_METHOD_NOT_ALLOWED;\n    }\n}\n\n/* Optional function coming from mod_logio, used for logging of output\n * traffic\n */\nAPR_OPTIONAL_FN_TYPE(ap_logio_add_bytes_out) *ap__logio_add_bytes_out;\nAPR_OPTIONAL_FN_TYPE(authz_some_auth_required) *ap__authz_ap_some_auth_required;\n\n/* Insist that at least one module will undertake to provide system\n * security by dropping startup privileges.\n */\nstatic int sys_privileges = 0;\nAP_DECLARE(int) ap_sys_privileges_handlers(int inc)\n{\n    sys_privileges += inc;\n    return sys_privileges;\n}\n\nstatic int check_errorlog_dir(apr_pool_t *p, server_rec *s)\n{\n    if (!s->error_fname || s->error_fname[0] == '|'\n        || s->errorlog_provider != NULL) {\n        return APR_SUCCESS;\n    }\n    else {\n        char *abs = ap_server_root_relative(p, s->error_fname);\n        char *dir = ap_make_dirstr_parent(p, abs);\n        apr_finfo_t finfo;\n        apr_status_t rv = apr_stat(&finfo, dir, APR_FINFO_TYPE, p);\n        if (rv == APR_SUCCESS && finfo.filetype != APR_DIR)\n            rv = APR_ENOTDIR;\n        if (rv != APR_SUCCESS) {\n            const char *desc = \"main error log\";\n            if (s->defn_name)\n                desc = apr_psprintf(p, \"error log of vhost defined at %s:%d\",\n                                    s->defn_name, s->defn_line_number);\n            ap_log_error(APLOG_MARK, APLOG_STARTUP|APLOG_EMERG, rv,\n                          ap_server_conf, APLOGNO(02291)\n                         \"Cannot access directory '%s' for %s\", dir, desc);\n            return !OK;\n        }\n    }\n    return OK;\n}\n\nstatic int core_check_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)\n{\n    int rv = OK;\n    while (s) {\n        if (check_errorlog_dir(ptemp, s) != OK)\n            rv = !OK;\n        s = s->next;\n    }\n    return rv;\n}\n\n\nstatic int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)\n{\n    ap_mutex_init(pconf);\n\n    if (!saved_server_config_defines)\n        init_config_defines(pconf);\n    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,\n                              apr_pool_cleanup_null);\n\n    mpm_common_pre_config(pconf);\n\n    return OK;\n}\n\nstatic int core_post_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)\n{\n    ap__logio_add_bytes_out = APR_RETRIEVE_OPTIONAL_FN(ap_logio_add_bytes_out);\n    ident_lookup = APR_RETRIEVE_OPTIONAL_FN(ap_ident_lookup);\n    ap__authz_ap_some_auth_required = APR_RETRIEVE_OPTIONAL_FN(authz_some_auth_required);\n    authn_ap_auth_type = APR_RETRIEVE_OPTIONAL_FN(authn_ap_auth_type);\n    authn_ap_auth_name = APR_RETRIEVE_OPTIONAL_FN(authn_ap_auth_name);\n    access_compat_ap_satisfies = APR_RETRIEVE_OPTIONAL_FN(access_compat_ap_satisfies);\n\n    set_banner(pconf);\n    ap_setup_make_content_type(pconf);\n    ap_setup_auth_internal(ptemp);\n    if (!sys_privileges) {\n        ap_log_error(APLOG_MARK, APLOG_CRIT, 0, NULL, APLOGNO(00136)\n                     \"Server MUST relinquish startup privileges before \"\n                     \"accepting connections.  Please ensure mod_unixd \"\n                     \"or other system security module is loaded.\");\n        return !OK;\n    }\n    apr_pool_cleanup_register(pconf, NULL, ap_mpm_end_gen_helper,\n                              apr_pool_cleanup_null);\n    return OK;\n}\n\nstatic void core_insert_filter(request_rec *r)\n{\n    core_dir_config *conf = (core_dir_config *)\n                            ap_get_core_module_config(r->per_dir_config);\n    const char *filter, *filters = conf->output_filters;\n\n    if (filters) {\n        while (*filters && (filter = ap_getword(r->pool, &filters, ';'))) {\n            ap_add_output_filter(filter, NULL, r, r->connection);\n        }\n    }\n\n    filters = conf->input_filters;\n    if (filters) {\n        while (*filters && (filter = ap_getword(r->pool, &filters, ';'))) {\n            ap_add_input_filter(filter, NULL, r, r->connection);\n        }\n    }\n}\n\nstatic apr_size_t num_request_notes = AP_NUM_STD_NOTES;\n\nstatic apr_status_t reset_request_notes(void *dummy)\n{\n    num_request_notes = AP_NUM_STD_NOTES;\n    return APR_SUCCESS;\n}\n\nAP_DECLARE(apr_size_t) ap_register_request_note(void)\n{\n    apr_pool_cleanup_register(apr_hook_global_pool, NULL, reset_request_notes,\n                              apr_pool_cleanup_null);\n    return num_request_notes++;\n}\n\nAP_DECLARE(void **) ap_get_request_note(request_rec *r, apr_size_t note_num)\n{\n    core_request_config *req_cfg;\n\n    if (note_num >= num_request_notes) {\n        return NULL;\n    }\n\n    req_cfg = (core_request_config *)\n        ap_get_core_module_config(r->request_config);\n\n    if (!req_cfg) {\n        return NULL;\n    }\n\n    return &(req_cfg->notes[note_num]);\n}\n\nAP_DECLARE(apr_socket_t *) ap_get_conn_socket(conn_rec *c)\n{\n    return ap_get_core_module_config(c->conn_config);\n}\n\nstatic int core_create_req(request_rec *r)\n{\n    /* Alloc the config struct and the array of request notes in\n     * a single block for efficiency\n     */\n    core_request_config *req_cfg;\n\n    req_cfg = apr_pcalloc(r->pool, sizeof(core_request_config) +\n                          sizeof(void *) * num_request_notes);\n    req_cfg->notes = (void **)((char *)req_cfg + sizeof(core_request_config));\n\n    /* ### temporarily enable script delivery as the default */\n    req_cfg->deliver_script = 1;\n\n    if (r->main) {\n        core_request_config *main_req_cfg = (core_request_config *)\n            ap_get_core_module_config(r->main->request_config);\n        req_cfg->bb = main_req_cfg->bb;\n    }\n    else {\n        req_cfg->bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    }\n\n    ap_set_core_module_config(r->request_config, req_cfg);\n\n    return OK;\n}\n\nstatic int core_create_proxy_req(request_rec *r, request_rec *pr)\n{\n    return core_create_req(pr);\n}\n\nstatic conn_rec *core_create_conn(apr_pool_t *ptrans, server_rec *s,\n                                  apr_socket_t *csd, long id, void *sbh,\n                                  apr_bucket_alloc_t *alloc)\n{\n    apr_status_t rv;\n    apr_pool_t *pool;\n    conn_rec *c = (conn_rec *) apr_pcalloc(ptrans, sizeof(conn_rec));\n    core_server_config *sconf = ap_get_core_module_config(s->module_config);\n\n    c->sbh = sbh;\n    ap_update_child_status(c->sbh, SERVER_BUSY_READ, NULL);\n\n    /* Got a connection structure, so initialize what fields we can\n     * (the rest are zeroed out by pcalloc).\n     */\n    apr_pool_create(&pool, ptrans);\n    apr_pool_tag(pool, \"master_conn\");\n    c->pool = pool;\n\n    c->conn_config = ap_create_conn_config(c->pool);\n    c->notes = apr_table_make(c->pool, 5);\n    c->slaves = apr_array_make(c->pool, 20, sizeof(conn_slave_rec *));\n    c->requests = apr_array_make(c->pool, 20, sizeof(request_rec *));\n\n\n    if ((rv = apr_socket_addr_get(&c->local_addr, APR_LOCAL, csd))\n        != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_INFO, rv, s, APLOGNO(00137)\n                     \"apr_socket_addr_get(APR_LOCAL)\");\n        apr_socket_close(csd);\n        return NULL;\n    }\n\n    apr_sockaddr_ip_get(&c->local_ip, c->local_addr);\n    if ((rv = apr_socket_addr_get(&c->client_addr, APR_REMOTE, csd))\n        != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_INFO, rv, s, APLOGNO(00138)\n                     \"apr_socket_addr_get(APR_REMOTE)\");\n        apr_socket_close(csd);\n        return NULL;\n    }\n\n    apr_sockaddr_ip_get(&c->client_ip, c->client_addr);\n    c->base_server = s;\n\n    c->id = id;\n    c->bucket_alloc = alloc;\n    c->empty = apr_brigade_create(c->pool, c->bucket_alloc);\n    c->filters = apr_hash_make(c->pool);\n    c->async_filter = sconf->async_filter;\n\n    c->clogging_input_filters = 0;\n\n    if (sconf->conn_log_level) {\n        int i;\n        conn_log_config *conf;\n        const struct ap_logconf *log = NULL;\n        struct ap_logconf *merged;\n\n        for (i = 0; i < sconf->conn_log_level->nelts; i++) {\n            conf = APR_ARRAY_IDX(sconf->conn_log_level, i, conn_log_config *);\n            if (apr_ipsubnet_test(conf->subnet, c->client_addr))\n                log = &conf->log;\n        }\n        if (log) {\n            merged = ap_new_log_config(c->pool, log);\n            ap_merge_log_config(&s->log, merged);\n            c->log = merged;\n        }\n    }\n\n    return c;\n}\n\nstatic int core_pre_connection(conn_rec *c, void *csd)\n{\n    core_net_rec *net;\n    apr_status_t rv;\n\n    if (c->master) {\n        return DONE;\n    }\n    \n    net = apr_palloc(c->pool, sizeof(*net));\n    /* The Nagle algorithm says that we should delay sending partial\n     * packets in hopes of getting more data.  We don't want to do\n     * this; we are not telnet.  There are bad interactions between\n     * persistent connections and Nagle's algorithm that have very severe\n     * performance penalties.  (Failing to disable Nagle is not much of a\n     * problem with simple HTTP.)\n     */\n    rv = apr_socket_opt_set(csd, APR_TCP_NODELAY, 1);\n    if (rv != APR_SUCCESS && rv != APR_ENOTIMPL) {\n        /* expected cause is that the client disconnected already,\n         * hence the debug level\n         */\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(00139)\n                      \"apr_socket_opt_set(APR_TCP_NODELAY)\");\n    }\n\n    /* The core filter requires the timeout mode to be set, which\n     * incidentally sets the socket to be nonblocking.  If this\n     * is not initialized correctly, Linux - for example - will\n     * be initially blocking, while Solaris will be non blocking\n     * and any initial read will fail.\n     */\n    rv = apr_socket_timeout_set(csd, c->base_server->timeout);\n    if (rv != APR_SUCCESS) {\n        /* expected cause is that the client disconnected already */\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, rv, c, APLOGNO(00140)\n                      \"apr_socket_timeout_set\");\n    }\n\n    net->c = c;\n    net->in_ctx = NULL;\n    net->out_ctx = NULL;\n    net->client_socket = csd;\n\n    ap_set_core_module_config(net->c->conn_config, csd);\n    /* only the master connection talks to the network */\n    if (c->master == NULL) {\n        ap_add_input_filter_handle(ap_core_input_filter_handle, net, NULL,\n                                   net->c);\n        ap_add_output_filter_handle(ap_core_output_filter_handle, net, NULL,\n                                    net->c);\n    }\n    return DONE;\n}\n\nAP_CORE_DECLARE(conn_rec *) ap_create_slave_connection(conn_rec *c)\n{\n    apr_pool_t *pool;\n    conn_slave_rec *new;\n    conn_rec *sc = (conn_rec *) apr_palloc(c->pool, sizeof(conn_rec));\n\n    apr_pool_create(&pool, c->pool);\n    apr_pool_tag(pool, \"slave_conn\");\n    memcpy(sc, c, sizeof(conn_rec));\n    sc->slaves = NULL;\n    sc->master = c;\n    sc->input_filters = NULL;\n    sc->output_filters = NULL;\n    sc->pool = pool;\n    new = apr_array_push(c->slaves);\n    new->c = sc;\n    return sc;\n}\n\nAP_DECLARE(int) ap_state_query(int query)\n{\n    switch (query) {\n    case AP_SQ_MAIN_STATE:\n        return ap_main_state;\n    case AP_SQ_RUN_MODE:\n        return ap_run_mode;\n    case AP_SQ_CONFIG_GEN:\n        return ap_config_generation;\n    default:\n        return AP_SQ_NOT_SUPPORTED;\n    }\n}\n\nstatic apr_random_t *rng = NULL;\n#if APR_HAS_THREADS\nstatic apr_thread_mutex_t *rng_mutex = NULL;\n#endif\n\nstatic void core_child_init(apr_pool_t *pchild, server_rec *s)\n{\n    apr_proc_t proc;\n#if APR_HAS_THREADS\n    int threaded_mpm;\n    if (ap_mpm_query(AP_MPMQ_IS_THREADED, &threaded_mpm) == APR_SUCCESS\n        && threaded_mpm)\n    {\n        apr_thread_mutex_create(&rng_mutex, APR_THREAD_MUTEX_DEFAULT, pchild);\n    }\n#endif\n    /* The MPMs use plain fork() and not apr_proc_fork(), so we have to call\n     * apr_random_after_fork() manually in the child\n     */\n    proc.pid = getpid();\n    apr_random_after_fork(&proc);\n}\n\nstatic void core_optional_fn_retrieve(void)\n{\n    ap_init_scoreboard(NULL);\n}\n\nAP_CORE_DECLARE(void) ap_random_parent_after_fork(void)\n{\n    /*\n     * To ensure that the RNG state in the parent changes after the fork, we\n     * pull some data from the RNG and discard it. This ensures that the RNG\n     * states in the children are different even after the pid wraps around.\n     * As we only use apr_random for insecure random bytes, pulling 2 bytes\n     * should be enough.\n     * XXX: APR should probably have some dedicated API to do this, but it\n     * XXX: currently doesn't.\n     */\n    apr_uint16_t data;\n    apr_random_insecure_bytes(rng, &data, sizeof(data));\n}\n\nAP_CORE_DECLARE(void) ap_init_rng(apr_pool_t *p)\n{\n    unsigned char seed[8];\n    apr_status_t rv;\n    rng = apr_random_standard_new(p);\n    do {\n        rv = apr_generate_random_bytes(seed, sizeof(seed));\n        if (rv != APR_SUCCESS)\n            goto error;\n        apr_random_add_entropy(rng, seed, sizeof(seed));\n        rv = apr_random_insecure_ready(rng);\n    } while (rv == APR_ENOTENOUGHENTROPY);\n    if (rv == APR_SUCCESS)\n        return;\nerror:\n    ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL, APLOGNO(00141)\n                 \"Could not initialize random number generator\");\n    exit(1);\n}\n\nAP_DECLARE(void) ap_random_insecure_bytes(void *buf, apr_size_t size)\n{\n#if APR_HAS_THREADS\n    if (rng_mutex)\n        apr_thread_mutex_lock(rng_mutex);\n#endif\n    /* apr_random_insecure_bytes can only fail with APR_ENOTENOUGHENTROPY,\n     * and we have ruled that out during initialization. Therefore we don't\n     * need to check the return code.\n     */\n    apr_random_insecure_bytes(rng, buf, size);\n#if APR_HAS_THREADS\n    if (rng_mutex)\n        apr_thread_mutex_unlock(rng_mutex);\n#endif\n}\n\n/*\n * Finding a random number in a range.\n *      n' = a + n(b-a+1)/(M+1)\n * where:\n *      n' = random number in range\n *      a  = low end of range\n *      b  = high end of range\n *      n  = random number of 0..M\n *      M  = maxint\n * Algorithm 'borrowed' from PHP's rand() function.\n */\n#define RAND_RANGE(__n, __min, __max, __tmax) \\\n(__n) = (__min) + (long) ((double) ((__max) - (__min) + 1.0) * ((__n) / ((__tmax) + 1.0)))\nAP_DECLARE(apr_uint32_t) ap_random_pick(apr_uint32_t min, apr_uint32_t max)\n{\n    apr_uint32_t number;\n#if (!__GNUC__ || __GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8) || \\\n     !__sparc__ || APR_SIZEOF_VOIDP != 8)\n    /* This triggers a gcc bug on sparc/64bit with gcc < 4.8, PR 52900 */\n    if (max < 16384) {\n        apr_uint16_t num16;\n        ap_random_insecure_bytes(&num16, sizeof(num16));\n        RAND_RANGE(num16, min, max, APR_UINT16_MAX);\n        number = num16;\n    }\n    else\n#endif\n    {\n        ap_random_insecure_bytes(&number, sizeof(number));\n        RAND_RANGE(number, min, max, APR_UINT32_MAX);\n    }\n    return number;\n}\n\nstatic apr_status_t core_insert_network_bucket(conn_rec *c,\n                                               apr_bucket_brigade *bb,\n                                               apr_socket_t *socket)\n{\n    apr_bucket *e = apr_bucket_socket_create(socket, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, e);\n    return APR_SUCCESS;\n}\n\nstatic apr_status_t core_dirwalk_stat(apr_finfo_t *finfo, request_rec *r,\n                                      apr_int32_t wanted) \n{\n    return apr_stat(finfo, r->filename, wanted, r->pool);\n}\n\nstatic void core_dump_config(apr_pool_t *p, server_rec *s)\n{\n    core_server_config *sconf = ap_get_core_module_config(s->module_config);\n    apr_file_t *out = NULL;\n    const char *tmp;\n    const char **defines;\n    int i;\n    if (!ap_exists_config_define(\"DUMP_RUN_CFG\"))\n        return;\n\n    apr_file_open_stdout(&out, p);\n    apr_file_printf(out, \"ServerRoot: \\\"%s\\\"\\n\", ap_server_root);\n    tmp = ap_server_root_relative(p, sconf->ap_document_root);\n    apr_file_printf(out, \"Main DocumentRoot: \\\"%s\\\"\\n\", tmp);\n    if (s->error_fname[0] != '|' && s->errorlog_provider == NULL)\n        tmp = ap_server_root_relative(p, s->error_fname);\n    else\n        tmp = s->error_fname;\n    apr_file_printf(out, \"Main ErrorLog: \\\"%s\\\"\\n\", tmp);\n    if (ap_scoreboard_fname) {\n        tmp = ap_runtime_dir_relative(p, ap_scoreboard_fname);\n        apr_file_printf(out, \"ScoreBoardFile: \\\"%s\\\"\\n\", tmp);\n    }\n    ap_dump_mutexes(p, s, out);\n    ap_mpm_dump_pidfile(p, out);\n\n    defines = (const char **)ap_server_config_defines->elts;\n    for (i = 0; i < ap_server_config_defines->nelts; i++) {\n        const char *name = defines[i];\n        const char *val = NULL;\n        if (server_config_defined_vars)\n           val = apr_table_get(server_config_defined_vars, name);\n        if (val)\n            apr_file_printf(out, \"Define: %s=%s\\n\", name, val);\n        else\n            apr_file_printf(out, \"Define: %s\\n\", name);\n    }\n}\n\nstatic int core_upgrade_handler(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    const char *upgrade;\n\n    if (c->master) {\n        /* Not possible to perform an HTTP/1.1 upgrade from a slave\n         * connection. */\n        return DECLINED;\n    }\n    \n    upgrade = apr_table_get(r->headers_in, \"Upgrade\");\n    if (upgrade && *upgrade) {\n        const char *conn = apr_table_get(r->headers_in, \"Connection\");\n        if (ap_find_token(r->pool, conn, \"upgrade\")) {\n            apr_array_header_t *offers = NULL;\n            const char *err;\n            \n            err = ap_parse_token_list_strict(r->pool, upgrade, &offers, 0);\n            if (err) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02910)\n                              \"parsing Upgrade header: %s\", err);\n                return DECLINED;\n            }\n            \n            if (offers && offers->nelts > 0) {\n                const char *protocol = ap_select_protocol(c, r, NULL, offers);\n                if (protocol && strcmp(protocol, ap_get_protocol(c))) {\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02909)\n                                  \"Upgrade selects '%s'\", protocol);\n                    /* Let the client know what we are upgrading to. */\n                    apr_table_clear(r->headers_out);\n                    apr_table_setn(r->headers_out, \"Upgrade\", protocol);\n                    apr_table_setn(r->headers_out, \"Connection\", \"Upgrade\");\n                    \n                    r->status = HTTP_SWITCHING_PROTOCOLS;\n                    r->status_line = ap_get_status_line(r->status);\n                    ap_send_interim_response(r, 1);\n\n                    ap_switch_protocol(c, r, r->server, protocol);\n\n                    /* make sure httpd closes the connection after this */\n                    c->keepalive = AP_CONN_CLOSE;\n                    return DONE;\n                }\n            }\n        }\n    }\n    else if (!c->keepalives) {\n        /* first request on a master connection, if we have protocols other\n         * than the current one enabled here, announce them to the\n         * client. If the client is already talking a protocol with requests\n         * on slave connections, leave it be. */\n        const apr_array_header_t *upgrades;\n        ap_get_protocol_upgrades(c, r, NULL, 0, &upgrades);\n        if (upgrades && upgrades->nelts > 0) {\n            char *protocols = apr_array_pstrcat(r->pool, upgrades, ',');\n            apr_table_setn(r->headers_out, \"Upgrade\", protocols);\n            apr_table_setn(r->headers_out, \"Connection\", \"Upgrade\");\n        }\n    }\n    \n    return DECLINED;\n}\n\nstatic int core_upgrade_storage(request_rec *r)\n{\n    if ((r->method_number == M_OPTIONS) && r->uri && (r->uri[0] == '*') &&\n        (r->uri[1] == '\\0')) {\n        return core_upgrade_handler(r);\n    }\n    return DECLINED;\n}\n\nstatic void register_hooks(apr_pool_t *p)\n{\n    errorlog_hash = apr_hash_make(p);\n    ap_register_log_hooks(p);\n    ap_register_config_hooks(p);\n    ap_expr_init(p);\n\n    /* create_connection and pre_connection should always be hooked\n     * APR_HOOK_REALLY_LAST by core to give other modules the opportunity\n     * to install alternate network transports and stop other functions\n     * from being run.\n     */\n    ap_hook_create_connection(core_create_conn, NULL, NULL,\n                              APR_HOOK_REALLY_LAST);\n    ap_hook_pre_connection(core_pre_connection, NULL, NULL,\n                           APR_HOOK_REALLY_LAST);\n\n    ap_hook_pre_config(core_pre_config, NULL, NULL, APR_HOOK_REALLY_FIRST);\n    ap_hook_post_config(core_post_config,NULL,NULL,APR_HOOK_REALLY_FIRST);\n    ap_hook_check_config(core_check_config,NULL,NULL,APR_HOOK_FIRST);\n    ap_hook_test_config(core_dump_config,NULL,NULL,APR_HOOK_FIRST);\n    ap_hook_translate_name(ap_core_translate,NULL,NULL,APR_HOOK_REALLY_LAST);\n    ap_hook_map_to_storage(core_upgrade_storage,NULL,NULL,APR_HOOK_REALLY_FIRST);\n    ap_hook_map_to_storage(core_map_to_storage,NULL,NULL,APR_HOOK_REALLY_LAST);\n    ap_hook_open_logs(ap_open_logs,NULL,NULL,APR_HOOK_REALLY_FIRST);\n    ap_hook_child_init(core_child_init,NULL,NULL,APR_HOOK_REALLY_FIRST);\n    ap_hook_child_init(ap_logs_child_init,NULL,NULL,APR_HOOK_MIDDLE);\n    ap_hook_handler(core_upgrade_handler,NULL,NULL,APR_HOOK_REALLY_FIRST);\n    ap_hook_handler(default_handler,NULL,NULL,APR_HOOK_REALLY_LAST);\n    /* FIXME: I suspect we can eliminate the need for these do_nothings - Ben */\n    ap_hook_type_checker(do_nothing,NULL,NULL,APR_HOOK_REALLY_LAST);\n    ap_hook_fixups(core_override_type,NULL,NULL,APR_HOOK_REALLY_FIRST);\n    ap_hook_create_request(core_create_req, NULL, NULL, APR_HOOK_MIDDLE);\n    APR_OPTIONAL_HOOK(proxy, create_req, core_create_proxy_req, NULL, NULL,\n                      APR_HOOK_MIDDLE);\n    ap_hook_pre_mpm(ap_create_scoreboard, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_child_status(ap_core_child_status, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_insert_network_bucket(core_insert_network_bucket, NULL, NULL,\n                                  APR_HOOK_REALLY_LAST);\n    ap_hook_dirwalk_stat(core_dirwalk_stat, NULL, NULL, APR_HOOK_REALLY_LAST);\n    ap_hook_open_htaccess(ap_open_htaccess, NULL, NULL, APR_HOOK_REALLY_LAST);\n    ap_hook_optional_fn_retrieve(core_optional_fn_retrieve, NULL, NULL,\n                                 APR_HOOK_MIDDLE);\n    ap_hook_output_pending(ap_filter_output_pending, NULL, NULL,\n            APR_HOOK_MIDDLE);\n\n    /* register the core's insert_filter hook and register core-provided\n     * filters\n     */\n    ap_hook_insert_filter(core_insert_filter, NULL, NULL, APR_HOOK_MIDDLE);\n\n    ap_core_input_filter_handle =\n        ap_register_input_filter(\"CORE_IN\", ap_core_input_filter,\n                                 NULL, AP_FTYPE_NETWORK);\n    ap_content_length_filter_handle =\n        ap_register_output_filter(\"CONTENT_LENGTH\", ap_content_length_filter,\n                                  NULL, AP_FTYPE_PROTOCOL);\n    ap_core_output_filter_handle =\n        ap_register_output_filter(\"CORE\", ap_core_output_filter,\n                                  NULL, AP_FTYPE_NETWORK);\n    ap_request_core_filter_handle =\n        ap_register_output_filter(\"REQ_CORE\", ap_request_core_filter,\n                                  NULL, AP_FTYPE_TRANSCODE);\n    ap_subreq_core_filter_handle =\n        ap_register_output_filter(\"SUBREQ_CORE\", ap_sub_req_output_filter,\n                                  NULL, AP_FTYPE_CONTENT_SET);\n    ap_old_write_func =\n        ap_register_output_filter(\"OLD_WRITE\", ap_old_write_filter,\n                                  NULL, AP_FTYPE_RESOURCE - 10);\n}\n\nAP_DECLARE_MODULE(core) = {\n    MPM20_MODULE_STUFF,\n    AP_PLATFORM_REWRITE_ARGS_HOOK, /* hook to run before apache parses args */\n    create_core_dir_config,       /* create per-directory config structure */\n    merge_core_dir_configs,       /* merge per-directory config structures */\n    create_core_server_config,    /* create per-server config structure */\n    merge_core_server_configs,    /* merge per-server config structures */\n    core_cmds,                    /* command apr_table_t */\n    register_hooks                /* register hooks */\n};\n\n"], "buggy_code_start_loc": [2, 2333], "buggy_code_end_loc": [2, 2333], "fixing_code_start_loc": [3, 2334], "fixing_code_end_loc": [6, 2340], "type": "CWE-416", "message": "Apache httpd allows remote attackers to read secret data from process memory if the Limit directive can be set in a user's .htaccess file, or if httpd.conf has certain misconfigurations, aka Optionsbleed. This affects the Apache HTTP Server through 2.2.34 and 2.4.x through 2.4.27. The attacker sends an unauthenticated OPTIONS HTTP request when attempting to read secret data. This is a use-after-free issue and thus secret data is not always sent, and the specific data depends on many factors including configuration. Exploitation with .htaccess can be blocked with a patch to the ap_limit_section function in server/core.c.", "other": {"cve": {"id": "CVE-2017-9798", "sourceIdentifier": "security@apache.org", "published": "2017-09-18T15:29:00.307", "lastModified": "2021-06-06T11:15:20.557", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Apache httpd allows remote attackers to read secret data from process memory if the Limit directive can be set in a user's .htaccess file, or if httpd.conf has certain misconfigurations, aka Optionsbleed. This affects the Apache HTTP Server through 2.2.34 and 2.4.x through 2.4.27. The attacker sends an unauthenticated OPTIONS HTTP request when attempting to read secret data. This is a use-after-free issue and thus secret data is not always sent, and the specific data depends on many factors including configuration. Exploitation with .htaccess can be blocked with a patch to the ap_limit_section function in server/core.c."}, {"lang": "es", "value": "Apache httpd permite que atacantes remotos lean datos secretos de la memoria de proceso si la directiva Limit se puede establecer en un archivo .htaccess del usuario o si existen ciertos errores de configuraci\u00f3n en httpd.conf. Esto tambi\u00e9n se conoce como Optionsbleed. Esta vulnerabilidad afecta a Apache HTTP Server hasta la versi\u00f3n 2.2.34 y a las versiones 2.4.x hasta la 2.4.27. El atacante env\u00eda una petici\u00f3n HTTP OPTIONS sin autenticar cuando intenta leer datos secretos. Este es un problema de uso de memoria previamente liberada y, por lo tanto, los datos secretos no siempre se env\u00edan y los datos espec\u00edficos dependen de muchos factores, entre los que se encuentra la configuraci\u00f3n. La explotaci\u00f3n con .htaccess puede bloquearse con un parche en la funci\u00f3n ap_limit_section en server/core.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.34", "matchCriteriaId": "FE75C79F-7F36-41C1-BF03-97416A06D81F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "BDC40E89-2D57-4988-913E-024BFB56B367"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "6FCD3C8C-9BF8-4F30-981A-593EEAEB9EDD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "046487A3-752B-4D0F-8984-96486B828EAB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "89D2E052-51CD-4B57-A8B8-FAE51988D654"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "EAA27058-BACF-4F94-8E3C-7D38EC302EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "8FEAB0DF-04A9-4F99-8666-0BADC5D642B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "E7D924D1-8A36-4C43-9E56-52814F9A6350"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "39CDFECC-E26D-47E0-976F-6629040B3764"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "E3ECBCB1-0675-41F5-857B-438F36925F63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "CB6CBFBF-74F6-42AF-BC79-AA53EA75F00B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "8717A96B-9DB5-48D6-A2CF-A5E2B26AF3F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "E1F45B27-504B-4202-87B8-BD3B094003F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "F2FB2B98-DFD2-420A-8A7F-9B288651242F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "B803D25B-0A19-4569-BA05-09D58F33917C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "8510442C-212F-4013-85FA-E0AB59F6F2C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "FB5673AB-53BB-40B2-83A7-8B82B2D0EBB8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "FBB3ED63-45CA-44AB-973C-9AD2569AD800"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:http_server:2.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "FF30AD98-9CBA-456E-A827-79FCEDEB30A1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2017/09/18/2", "source": "security@apache.org", "tags": ["Mailing List", "VDB Entry"]}, {"url": "http://www.debian.org/security/2017/dsa-3980", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpuapr2018-3678067.html", "source": "security@apache.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpujan2018-3236628.html", "source": "security@apache.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpujul2018-4258247.html", "source": "security@apache.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpuoct2018-4428296.html", "source": "security@apache.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/100872", "source": "security@apache.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/105598", "source": "security@apache.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1039387", "source": "security@apache.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2882", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2972", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3018", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3113", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3114", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3193", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3194", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3195", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3239", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3240", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3475", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3476", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:3477", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://blog.fuzzing-project.org/60-Optionsbleed-HTTP-OPTIONS-method-can-leak-Apaches-server-memory.html", "source": "security@apache.org", "tags": ["Exploit", "Patch", "Technical Description", "Third Party Advisory"]}, {"url": "https://blog.fuzzing-project.org/uploads/apache-2.2-optionsbleed-backport.patch", "source": "security@apache.org", "tags": ["Exploit", "Patch", "Technical Description", "Third Party Advisory"]}, {"url": "https://github.com/apache/httpd/commit/4cc27823899e070268b906ca677ee838d07cf67a", "source": "security@apache.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/hannob/optionsbleed", "source": "security@apache.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://httpd.apache.org/security/vulnerabilities_24.html#CVE-2017-9798", "source": "security@apache.org", "tags": ["Vendor Advisory"]}, {"url": "https://lists.apache.org/thread.html/56c2e7cc9deb1c12a843d0dc251ea7fd3e7e80293cde02fcd65286ba@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://lists.apache.org/thread.html/84a3714f0878781f6ed84473d1a503d2cc382277e100450209231830@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://lists.apache.org/thread.html/8d63cb8e9100f28a99429b4328e4e7cebce861d5772ac9863ba2ae6f@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://lists.apache.org/thread.html/f7f95ac1cd9895db2714fa3ebaa0b94d0c6df360f742a40951384a53@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://lists.apache.org/thread.html/r15f9aa4427581a1aecb4063f1b4b983511ae1c9935e2a0a6876dad3c@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/r57608dc51b79102f3952ae06f54d5277b649c86d6533dcd6a7d201f7@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://lists.apache.org/thread.html/r6521a7f62276340eabdb3339b2aa9a38c5f59d978497a1f794af53be@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/r75cbe9ea3e2114e4271bbeca7aff96117b50c1b6eb7c4772b0337c1f@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/r9ea3538f229874c80a10af473856a81fbf5f694cd7f471cc679ba70b@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/r9f93cf6dde308d42a9c807784e8102600d0397f5f834890708bf6920@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/rc998b18880df98bafaade071346690c2bc1444adaa1a1ea464b93f0a@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/rcc44594d4d6579b90deccd4536b5d31f099ef563df39b094be286b9e@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/rd18c3c43602e66f9cdcf09f1de233804975b9572b0456cc582390b6f@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://lists.apache.org/thread.html/rdca61ae990660bacb682295f2a09d34612b7bb5f457577fe17f4d064@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/re3d27b6250aa8548b8845d314bb8a350b3df326cacbbfdfe4d455234@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf6449464fd8b7437704c55f88361b66f12d5b5f90bcce66af4be4ba9@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://lists.apache.org/thread.html/rfbaf647d52c1cb843e726a0933f156366a806cead84fbd430951591b@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://lists.apache.org/thread.html/rfcf929bd33a6833e3f0c35eebdad70d5060665f9c4e17ea467c66770@%3Ccvs.httpd.apache.org%3E", "source": "security@apache.org"}, {"url": "https://security-tracker.debian.org/tracker/CVE-2017-9798", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201710-32", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20180601-0003/", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/HT208331", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.hpe.com/hpsc/doc/public/display?docLocale=en_US&docId=emr_na-hpesbux03909en_us", "source": "security@apache.org", "tags": ["Third Party Advisory"]}, {"url": "https://svn.apache.org/viewvc/httpd/httpd/branches/2.4.x/server/core.c?r1=1805223&r2=1807754&pathrev=1807754&view=patch", "source": "security@apache.org", "tags": ["Vendor Advisory"]}, {"url": "https://www.exploit-db.com/exploits/42745/", "source": "security@apache.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpuapr2019-5072813.html", "source": "security@apache.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpujan2019-5072801.html", "source": "security@apache.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.tenable.com/security/tns-2019-09", "source": "security@apache.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/apache/httpd/commit/4cc27823899e070268b906ca677ee838d07cf67a"}}