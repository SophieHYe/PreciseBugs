{"buggy_code": ["<?php\n/**\n * WP_Theme Class\n *\n * @package WordPress\n * @subpackage Theme\n * @since 3.4.0\n */\nfinal class WP_Theme implements ArrayAccess {\n\n\t/**\n\t * Whether the theme has been marked as updateable.\n\t *\n\t * @since 4.4.0\n\t * @access public\n\t * @var bool\n\t *\n\t * @see WP_MS_Themes_List_Table\n\t */\n\tpublic $update = false;\n\n\t/**\n\t * Headers for style.css files.\n\t *\n\t * @static\n\t * @access private\n\t * @var array\n\t */\n\tprivate static $file_headers = array(\n\t\t'Name'        => 'Theme Name',\n\t\t'ThemeURI'    => 'Theme URI',\n\t\t'Description' => 'Description',\n\t\t'Author'      => 'Author',\n\t\t'AuthorURI'   => 'Author URI',\n\t\t'Version'     => 'Version',\n\t\t'Template'    => 'Template',\n\t\t'Status'      => 'Status',\n\t\t'Tags'        => 'Tags',\n\t\t'TextDomain'  => 'Text Domain',\n\t\t'DomainPath'  => 'Domain Path',\n\t);\n\n\t/**\n\t * Default themes.\n\t *\n\t * @static\n\t * @access private\n\t * @var array\n\t */\n\tprivate static $default_themes = array(\n\t\t'classic'         => 'WordPress Classic',\n\t\t'default'         => 'WordPress Default',\n\t\t'twentyten'       => 'Twenty Ten',\n\t\t'twentyeleven'    => 'Twenty Eleven',\n\t\t'twentytwelve'    => 'Twenty Twelve',\n\t\t'twentythirteen'  => 'Twenty Thirteen',\n\t\t'twentyfourteen'  => 'Twenty Fourteen',\n\t\t'twentyfifteen'   => 'Twenty Fifteen',\n\t\t'twentysixteen'   => 'Twenty Sixteen',\n\t\t'twentyseventeen' => 'Twenty Seventeen',\n\t);\n\n\t/**\n\t * Renamed theme tags.\n\t *\n\t * @static\n\t * @access private\n\t * @var array\n\t */\n\tprivate static $tag_map = array(\n\t\t'fixed-width'    => 'fixed-layout',\n\t\t'flexible-width' => 'fluid-layout',\n\t);\n\n\t/**\n\t * Absolute path to the theme root, usually wp-content/themes\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $theme_root;\n\n\t/**\n\t * Header data from the theme's style.css file.\n\t *\n\t * @access private\n\t * @var array\n\t */\n\tprivate $headers = array();\n\n\t/**\n\t * Header data from the theme's style.css file after being sanitized.\n\t *\n\t * @access private\n\t * @var array\n\t */\n\tprivate $headers_sanitized;\n\n\t/**\n\t * Header name from the theme's style.css after being translated.\n\t *\n\t * Cached due to sorting functions running over the translated name.\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $name_translated;\n\n\t/**\n\t * Errors encountered when initializing the theme.\n\t *\n\t * @access private\n\t * @var WP_Error\n\t */\n\tprivate $errors;\n\n\t/**\n\t * The directory name of the theme's files, inside the theme root.\n\t *\n\t * In the case of a child theme, this is directory name of the child theme.\n\t * Otherwise, 'stylesheet' is the same as 'template'.\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $stylesheet;\n\n\t/**\n\t * The directory name of the theme's files, inside the theme root.\n\t *\n\t * In the case of a child theme, this is the directory name of the parent theme.\n\t * Otherwise, 'template' is the same as 'stylesheet'.\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $template;\n\n\t/**\n\t * A reference to the parent theme, in the case of a child theme.\n\t *\n\t * @access private\n\t * @var WP_Theme\n\t */\n\tprivate $parent;\n\n\t/**\n\t * URL to the theme root, usually an absolute URL to wp-content/themes\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $theme_root_uri;\n\n\t/**\n\t * Flag for whether the theme's textdomain is loaded.\n\t *\n\t * @access private\n\t * @var bool\n\t */\n\tprivate $textdomain_loaded;\n\n\t/**\n\t * Stores an md5 hash of the theme root, to function as the cache key.\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $cache_hash;\n\n\t/**\n\t * Flag for whether the themes cache bucket should be persistently cached.\n\t *\n\t * Default is false. Can be set with the {@see 'wp_cache_themes_persistently'} filter.\n\t *\n\t * @static\n\t * @access private\n\t * @var bool\n\t */\n\tprivate static $persistently_cache;\n\n\t/**\n\t * Expiration time for the themes cache bucket.\n\t *\n\t * By default the bucket is not cached, so this value is useless.\n\t *\n\t * @static\n\t * @access private\n\t * @var bool\n\t */\n\tprivate static $cache_expiration = 1800;\n\n\t/**\n\t * Constructor for WP_Theme.\n\t *\n\t * @since  3.4.0\n\t *\n\t * @global array $wp_theme_directories\n\t *\n\t * @param string $theme_dir Directory of the theme within the theme_root.\n\t * @param string $theme_root Theme root.\n\t * @param WP_Error|void $_child If this theme is a parent theme, the child may be passed for validation purposes.\n\t */\n\tpublic function __construct( $theme_dir, $theme_root, $_child = null ) {\n\t\tglobal $wp_theme_directories;\n\n\t\t// Initialize caching on first run.\n\t\tif ( ! isset( self::$persistently_cache ) ) {\n\t\t\t/** This action is documented in wp-includes/theme.php */\n\t\t\tself::$persistently_cache = apply_filters( 'wp_cache_themes_persistently', false, 'WP_Theme' );\n\t\t\tif ( self::$persistently_cache ) {\n\t\t\t\twp_cache_add_global_groups( 'themes' );\n\t\t\t\tif ( is_int( self::$persistently_cache ) )\n\t\t\t\t\tself::$cache_expiration = self::$persistently_cache;\n\t\t\t} else {\n\t\t\t\twp_cache_add_non_persistent_groups( 'themes' );\n\t\t\t}\n\t\t}\n\n\t\t$this->theme_root = $theme_root;\n\t\t$this->stylesheet = $theme_dir;\n\n\t\t// Correct a situation where the theme is 'some-directory/some-theme' but 'some-directory' was passed in as part of the theme root instead.\n\t\tif ( ! in_array( $theme_root, (array) $wp_theme_directories ) && in_array( dirname( $theme_root ), (array) $wp_theme_directories ) ) {\n\t\t\t$this->stylesheet = basename( $this->theme_root ) . '/' . $this->stylesheet;\n\t\t\t$this->theme_root = dirname( $theme_root );\n\t\t}\n\n\t\t$this->cache_hash = md5( $this->theme_root . '/' . $this->stylesheet );\n\t\t$theme_file = $this->stylesheet . '/style.css';\n\n\t\t$cache = $this->cache_get( 'theme' );\n\n\t\tif ( is_array( $cache ) ) {\n\t\t\tforeach ( array( 'errors', 'headers', 'template' ) as $key ) {\n\t\t\t\tif ( isset( $cache[ $key ] ) )\n\t\t\t\t\t$this->$key = $cache[ $key ];\n\t\t\t}\n\t\t\tif ( $this->errors )\n\t\t\t\treturn;\n\t\t\tif ( isset( $cache['theme_root_template'] ) )\n\t\t\t\t$theme_root_template = $cache['theme_root_template'];\n\t\t} elseif ( ! file_exists( $this->theme_root . '/' . $theme_file ) ) {\n\t\t\t$this->headers['Name'] = $this->stylesheet;\n\t\t\tif ( ! file_exists( $this->theme_root . '/' . $this->stylesheet ) )\n\t\t\t\t$this->errors = new WP_Error( 'theme_not_found', sprintf( __( 'The theme directory \"%s\" does not exist.' ), esc_html( $this->stylesheet ) ) );\n\t\t\telse\n\t\t\t\t$this->errors = new WP_Error( 'theme_no_stylesheet', __( 'Stylesheet is missing.' ) );\n\t\t\t$this->template = $this->stylesheet;\n\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\tif ( ! file_exists( $this->theme_root ) ) // Don't cache this one.\n\t\t\t\t$this->errors->add( 'theme_root_missing', __( 'ERROR: The themes directory is either empty or doesn&#8217;t exist. Please check your installation.' ) );\n\t\t\treturn;\n\t\t} elseif ( ! is_readable( $this->theme_root . '/' . $theme_file ) ) {\n\t\t\t$this->headers['Name'] = $this->stylesheet;\n\t\t\t$this->errors = new WP_Error( 'theme_stylesheet_not_readable', __( 'Stylesheet is not readable.' ) );\n\t\t\t$this->template = $this->stylesheet;\n\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\treturn;\n\t\t} else {\n\t\t\t$this->headers = get_file_data( $this->theme_root . '/' . $theme_file, self::$file_headers, 'theme' );\n\t\t\t// Default themes always trump their pretenders.\n\t\t\t// Properly identify default themes that are inside a directory within wp-content/themes.\n\t\t\tif ( $default_theme_slug = array_search( $this->headers['Name'], self::$default_themes ) ) {\n\t\t\t\tif ( basename( $this->stylesheet ) != $default_theme_slug )\n\t\t\t\t\t$this->headers['Name'] .= '/' . $this->stylesheet;\n\t\t\t}\n\t\t}\n\n\t\t// (If template is set from cache [and there are no errors], we know it's good.)\n\t\tif ( ! $this->template && ! ( $this->template = $this->headers['Template'] ) ) {\n\t\t\t$this->template = $this->stylesheet;\n\t\t\tif ( ! file_exists( $this->theme_root . '/' . $this->stylesheet . '/index.php' ) ) {\n\t\t\t\t$error_message = sprintf(\n\t\t\t\t\t/* translators: 1: index.php, 2: Codex URL, 3: style.css */\n\t\t\t\t\t__( 'Template is missing. Standalone themes need to have a %1$s template file. <a href=\"%2$s\">Child themes</a> need to have a Template header in the %3$s stylesheet.' ),\n\t\t\t\t\t'<code>index.php</code>',\n\t\t\t\t\t__( 'https://codex.wordpress.org/Child_Themes' ),\n\t\t\t\t\t'<code>style.css</code>'\n\t\t\t\t);\n\t\t\t\t$this->errors = new WP_Error( 'theme_no_index', $error_message );\n\t\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If we got our data from cache, we can assume that 'template' is pointing to the right place.\n\t\tif ( ! is_array( $cache ) && $this->template != $this->stylesheet && ! file_exists( $this->theme_root . '/' . $this->template . '/index.php' ) ) {\n\t\t\t// If we're in a directory of themes inside /themes, look for the parent nearby.\n\t\t\t// wp-content/themes/directory-of-themes/*\n\t\t\t$parent_dir = dirname( $this->stylesheet );\n\t\t\tif ( '.' != $parent_dir && file_exists( $this->theme_root . '/' . $parent_dir . '/' . $this->template . '/index.php' ) ) {\n\t\t\t\t$this->template = $parent_dir . '/' . $this->template;\n\t\t\t} elseif ( ( $directories = search_theme_directories() ) && isset( $directories[ $this->template ] ) ) {\n\t\t\t\t// Look for the template in the search_theme_directories() results, in case it is in another theme root.\n\t\t\t\t// We don't look into directories of themes, just the theme root.\n\t\t\t\t$theme_root_template = $directories[ $this->template ]['theme_root'];\n\t\t\t} else {\n\t\t\t\t// Parent theme is missing.\n\t\t\t\t$this->errors = new WP_Error( 'theme_no_parent', sprintf( __( 'The parent theme is missing. Please install the \"%s\" parent theme.' ), esc_html( $this->template ) ) );\n\t\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\t\t$this->parent = new WP_Theme( $this->template, $this->theme_root, $this );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Set the parent, if we're a child theme.\n\t\tif ( $this->template != $this->stylesheet ) {\n\t\t\t// If we are a parent, then there is a problem. Only two generations allowed! Cancel things out.\n\t\t\tif ( $_child instanceof WP_Theme && $_child->template == $this->stylesheet ) {\n\t\t\t\t$_child->parent = null;\n\t\t\t\t$_child->errors = new WP_Error( 'theme_parent_invalid', sprintf( __( 'The \"%s\" theme is not a valid parent theme.' ), esc_html( $_child->template ) ) );\n\t\t\t\t$_child->cache_add( 'theme', array( 'headers' => $_child->headers, 'errors' => $_child->errors, 'stylesheet' => $_child->stylesheet, 'template' => $_child->template ) );\n\t\t\t\t// The two themes actually reference each other with the Template header.\n\t\t\t\tif ( $_child->stylesheet == $this->template ) {\n\t\t\t\t\t$this->errors = new WP_Error( 'theme_parent_invalid', sprintf( __( 'The \"%s\" theme is not a valid parent theme.' ), esc_html( $this->template ) ) );\n\t\t\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Set the parent. Pass the current instance so we can do the crazy checks above and assess errors.\n\t\t\t$this->parent = new WP_Theme( $this->template, isset( $theme_root_template ) ? $theme_root_template : $this->theme_root, $this );\n\t\t}\n\n\t\t// We're good. If we didn't retrieve from cache, set it.\n\t\tif ( ! is_array( $cache ) ) {\n\t\t\t$cache = array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template );\n\t\t\t// If the parent theme is in another root, we'll want to cache this. Avoids an entire branch of filesystem calls above.\n\t\t\tif ( isset( $theme_root_template ) )\n\t\t\t\t$cache['theme_root_template'] = $theme_root_template;\n\t\t\t$this->cache_add( 'theme', $cache );\n\t\t}\n\t}\n\n\t/**\n\t * When converting the object to a string, the theme name is returned.\n\t *\n\t * @since  3.4.0\n\t *\n\t * @return string Theme name, ready for display (translated)\n\t */\n\tpublic function __toString() {\n\t\treturn (string) $this->display('Name');\n\t}\n\n\t/**\n\t * __isset() magic method for properties formerly returned by current_theme_info()\n\t *\n\t * @staticvar array $properties\n\t *\n\t * @since  3.4.0\n\t *\n\t * @param string $offset Property to check if set.\n\t * @return bool Whether the given property is set.\n\t */\n\tpublic function __isset( $offset ) {\n\t\tstatic $properties = array(\n\t\t\t'name', 'title', 'version', 'parent_theme', 'template_dir', 'stylesheet_dir', 'template', 'stylesheet',\n\t\t\t'screenshot', 'description', 'author', 'tags', 'theme_root', 'theme_root_uri',\n\t\t);\n\n\t\treturn in_array( $offset, $properties );\n\t}\n\n\t/**\n\t * __get() magic method for properties formerly returned by current_theme_info()\n\t *\n\t * @since  3.4.0\n\t *\n\t * @param string $offset Property to get.\n\t * @return mixed Property value.\n\t */\n\tpublic function __get( $offset ) {\n\t\tswitch ( $offset ) {\n\t\t\tcase 'name' :\n\t\t\tcase 'title' :\n\t\t\t\treturn $this->get('Name');\n\t\t\tcase 'version' :\n\t\t\t\treturn $this->get('Version');\n\t\t\tcase 'parent_theme' :\n\t\t\t\treturn $this->parent() ? $this->parent()->get('Name') : '';\n\t\t\tcase 'template_dir' :\n\t\t\t\treturn $this->get_template_directory();\n\t\t\tcase 'stylesheet_dir' :\n\t\t\t\treturn $this->get_stylesheet_directory();\n\t\t\tcase 'template' :\n\t\t\t\treturn $this->get_template();\n\t\t\tcase 'stylesheet' :\n\t\t\t\treturn $this->get_stylesheet();\n\t\t\tcase 'screenshot' :\n\t\t\t\treturn $this->get_screenshot( 'relative' );\n\t\t\t// 'author' and 'description' did not previously return translated data.\n\t\t\tcase 'description' :\n\t\t\t\treturn $this->display('Description');\n\t\t\tcase 'author' :\n\t\t\t\treturn $this->display('Author');\n\t\t\tcase 'tags' :\n\t\t\t\treturn $this->get( 'Tags' );\n\t\t\tcase 'theme_root' :\n\t\t\t\treturn $this->get_theme_root();\n\t\t\tcase 'theme_root_uri' :\n\t\t\t\treturn $this->get_theme_root_uri();\n\t\t\t// For cases where the array was converted to an object.\n\t\t\tdefault :\n\t\t\t\treturn $this->offsetGet( $offset );\n\t\t}\n\t}\n\n\t/**\n\t * Method to implement ArrayAccess for keys formerly returned by get_themes()\n\t *\n\t * @since  3.4.0\n\t *\n\t * @param mixed $offset\n\t * @param mixed $value\n\t */\n\tpublic function offsetSet( $offset, $value ) {}\n\n\t/**\n\t * Method to implement ArrayAccess for keys formerly returned by get_themes()\n\t *\n\t * @since  3.4.0\n\t *\n\t * @param mixed $offset\n\t */\n\tpublic function offsetUnset( $offset ) {}\n\n\t/**\n\t * Method to implement ArrayAccess for keys formerly returned by get_themes()\n\t *\n\t * @staticvar array $keys\n\t *\n\t * @since  3.4.0\n\t *\n\t * @param mixed $offset\n\t * @return bool\n\t */\n\tpublic function offsetExists( $offset ) {\n\t\tstatic $keys = array(\n\t\t\t'Name', 'Version', 'Status', 'Title', 'Author', 'Author Name', 'Author URI', 'Description',\n\t\t\t'Template', 'Stylesheet', 'Template Files', 'Stylesheet Files', 'Template Dir', 'Stylesheet Dir',\n\t\t\t'Screenshot', 'Tags', 'Theme Root', 'Theme Root URI', 'Parent Theme',\n\t\t);\n\n\t\treturn in_array( $offset, $keys );\n\t}\n\n\t/**\n\t * Method to implement ArrayAccess for keys formerly returned by get_themes().\n\t *\n\t * Author, Author Name, Author URI, and Description did not previously return\n\t * translated data. We are doing so now as it is safe to do. However, as\n\t * Name and Title could have been used as the key for get_themes(), both remain\n\t * untranslated for back compatibility. This means that ['Name'] is not ideal,\n\t * and care should be taken to use `$theme::display( 'Name' )` to get a properly\n\t * translated header.\n\t *\n\t * @since  3.4.0\n\t *\n\t * @param mixed $offset\n\t * @return mixed\n\t */\n\tpublic function offsetGet( $offset ) {\n\t\tswitch ( $offset ) {\n\t\t\tcase 'Name' :\n\t\t\tcase 'Title' :\n\t\t\t\t/*\n\t\t\t\t * See note above about using translated data. get() is not ideal.\n\t\t\t\t * It is only for backward compatibility. Use display().\n\t\t\t\t */\n\t\t\t\treturn $this->get('Name');\n\t\t\tcase 'Author' :\n\t\t\t\treturn $this->display( 'Author');\n\t\t\tcase 'Author Name' :\n\t\t\t\treturn $this->display( 'Author', false);\n\t\t\tcase 'Author URI' :\n\t\t\t\treturn $this->display('AuthorURI');\n\t\t\tcase 'Description' :\n\t\t\t\treturn $this->display( 'Description');\n\t\t\tcase 'Version' :\n\t\t\tcase 'Status' :\n\t\t\t\treturn $this->get( $offset );\n\t\t\tcase 'Template' :\n\t\t\t\treturn $this->get_template();\n\t\t\tcase 'Stylesheet' :\n\t\t\t\treturn $this->get_stylesheet();\n\t\t\tcase 'Template Files' :\n\t\t\t\treturn $this->get_files( 'php', 1, true );\n\t\t\tcase 'Stylesheet Files' :\n\t\t\t\treturn $this->get_files( 'css', 0, false );\n\t\t\tcase 'Template Dir' :\n\t\t\t\treturn $this->get_template_directory();\n\t\t\tcase 'Stylesheet Dir' :\n\t\t\t\treturn $this->get_stylesheet_directory();\n\t\t\tcase 'Screenshot' :\n\t\t\t\treturn $this->get_screenshot( 'relative' );\n\t\t\tcase 'Tags' :\n\t\t\t\treturn $this->get('Tags');\n\t\t\tcase 'Theme Root' :\n\t\t\t\treturn $this->get_theme_root();\n\t\t\tcase 'Theme Root URI' :\n\t\t\t\treturn $this->get_theme_root_uri();\n\t\t\tcase 'Parent Theme' :\n\t\t\t\treturn $this->parent() ? $this->parent()->get('Name') : '';\n\t\t\tdefault :\n\t\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Returns errors property.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return WP_Error|false WP_Error if there are errors, or false.\n\t */\n\tpublic function errors() {\n\t\treturn is_wp_error( $this->errors ) ? $this->errors : false;\n\t}\n\n\t/**\n\t * Whether the theme exists.\n\t *\n\t * A theme with errors exists. A theme with the error of 'theme_not_found',\n\t * meaning that the theme's directory was not found, does not exist.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return bool Whether the theme exists.\n\t */\n\tpublic function exists() {\n\t\treturn ! ( $this->errors() && in_array( 'theme_not_found', $this->errors()->get_error_codes() ) );\n\t}\n\n\t/**\n\t * Returns reference to the parent theme.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return WP_Theme|false Parent theme, or false if the current theme is not a child theme.\n\t */\n\tpublic function parent() {\n\t\treturn isset( $this->parent ) ? $this->parent : false;\n\t}\n\n\t/**\n\t * Adds theme data to cache.\n\t *\n\t * Cache entries keyed by the theme and the type of data.\n\t *\n\t * @since 3.4.0\n\t * @access private\n\t *\n\t * @param string $key Type of data to store (theme, screenshot, headers, post_templates)\n\t * @param string $data Data to store\n\t * @return bool Return value from wp_cache_add()\n\t */\n\tprivate function cache_add( $key, $data ) {\n\t\treturn wp_cache_add( $key . '-' . $this->cache_hash, $data, 'themes', self::$cache_expiration );\n\t}\n\n\t/**\n\t * Gets theme data from cache.\n\t *\n\t * Cache entries are keyed by the theme and the type of data.\n\t *\n\t * @since 3.4.0\n\t * @access private\n\t *\n\t * @param string $key Type of data to retrieve (theme, screenshot, headers, post_templates)\n\t * @return mixed Retrieved data\n\t */\n\tprivate function cache_get( $key ) {\n\t\treturn wp_cache_get( $key . '-' . $this->cache_hash, 'themes' );\n\t}\n\n\t/**\n\t * Clears the cache for the theme.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t */\n\tpublic function cache_delete() {\n\t\tforeach ( array( 'theme', 'screenshot', 'headers', 'post_templates' ) as $key )\n\t\t\twp_cache_delete( $key . '-' . $this->cache_hash, 'themes' );\n\t\t$this->template = $this->textdomain_loaded = $this->theme_root_uri = $this->parent = $this->errors = $this->headers_sanitized = $this->name_translated = null;\n\t\t$this->headers = array();\n\t\t$this->__construct( $this->stylesheet, $this->theme_root );\n\t}\n\n\t/**\n\t * Get a raw, unformatted theme header.\n\t *\n\t * The header is sanitized, but is not translated, and is not marked up for display.\n\t * To get a theme header for display, use the display() method.\n\t *\n\t * Use the get_template() method, not the 'Template' header, for finding the template.\n\t * The 'Template' header is only good for what was written in the style.css, while\n\t * get_template() takes into account where WordPress actually located the theme and\n\t * whether it is actually valid.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @return string|false String on success, false on failure.\n\t */\n\tpublic function get( $header ) {\n\t\tif ( ! isset( $this->headers[ $header ] ) )\n\t\t\treturn false;\n\n\t\tif ( ! isset( $this->headers_sanitized ) ) {\n\t\t\t$this->headers_sanitized = $this->cache_get( 'headers' );\n\t\t\tif ( ! is_array( $this->headers_sanitized ) )\n\t\t\t\t$this->headers_sanitized = array();\n\t\t}\n\n\t\tif ( isset( $this->headers_sanitized[ $header ] ) )\n\t\t\treturn $this->headers_sanitized[ $header ];\n\n\t\t// If themes are a persistent group, sanitize everything and cache it. One cache add is better than many cache sets.\n\t\tif ( self::$persistently_cache ) {\n\t\t\tforeach ( array_keys( $this->headers ) as $_header )\n\t\t\t\t$this->headers_sanitized[ $_header ] = $this->sanitize_header( $_header, $this->headers[ $_header ] );\n\t\t\t$this->cache_add( 'headers', $this->headers_sanitized );\n\t\t} else {\n\t\t\t$this->headers_sanitized[ $header ] = $this->sanitize_header( $header, $this->headers[ $header ] );\n\t\t}\n\n\t\treturn $this->headers_sanitized[ $header ];\n\t}\n\n\t/**\n\t * Gets a theme header, formatted and translated for display.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @param bool $markup Optional. Whether to mark up the header. Defaults to true.\n\t * @param bool $translate Optional. Whether to translate the header. Defaults to true.\n\t * @return string|false Processed header, false on failure.\n\t */\n\tpublic function display( $header, $markup = true, $translate = true ) {\n\t\t$value = $this->get( $header );\n\t\tif ( false === $value ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( $translate && ( empty( $value ) || ! $this->load_textdomain() ) )\n\t\t\t$translate = false;\n\n\t\tif ( $translate )\n\t\t\t$value = $this->translate_header( $header, $value );\n\n\t\tif ( $markup )\n\t\t\t$value = $this->markup_header( $header, $value, $translate );\n\n\t\treturn $value;\n\t}\n\n\t/**\n\t * Sanitize a theme header.\n\t *\n\t * @since 3.4.0\n\t * @access private\n\t *\n\t * @staticvar array $header_tags\n\t * @staticvar array $header_tags_with_a\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @param string $value Value to sanitize.\n\t * @return mixed\n\t */\n\tprivate function sanitize_header( $header, $value ) {\n\t\tswitch ( $header ) {\n\t\t\tcase 'Status' :\n\t\t\t\tif ( ! $value ) {\n\t\t\t\t\t$value = 'publish';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Fall through otherwise.\n\t\t\tcase 'Name' :\n\t\t\t\tstatic $header_tags = array(\n\t\t\t\t\t'abbr'    => array( 'title' => true ),\n\t\t\t\t\t'acronym' => array( 'title' => true ),\n\t\t\t\t\t'code'    => true,\n\t\t\t\t\t'em'      => true,\n\t\t\t\t\t'strong'  => true,\n\t\t\t\t);\n\t\t\t\t$value = wp_kses( $value, $header_tags );\n\t\t\t\tbreak;\n\t\t\tcase 'Author' :\n\t\t\t\t// There shouldn't be anchor tags in Author, but some themes like to be challenging.\n\t\t\tcase 'Description' :\n\t\t\t\tstatic $header_tags_with_a = array(\n\t\t\t\t\t'a'       => array( 'href' => true, 'title' => true ),\n\t\t\t\t\t'abbr'    => array( 'title' => true ),\n\t\t\t\t\t'acronym' => array( 'title' => true ),\n\t\t\t\t\t'code'    => true,\n\t\t\t\t\t'em'      => true,\n\t\t\t\t\t'strong'  => true,\n\t\t\t\t);\n\t\t\t\t$value = wp_kses( $value, $header_tags_with_a );\n\t\t\t\tbreak;\n\t\t\tcase 'ThemeURI' :\n\t\t\tcase 'AuthorURI' :\n\t\t\t\t$value = esc_url_raw( $value );\n\t\t\t\tbreak;\n\t\t\tcase 'Tags' :\n\t\t\t\t$value = array_filter( array_map( 'trim', explode( ',', strip_tags( $value ) ) ) );\n\t\t\t\tbreak;\n\t\t\tcase 'Version' :\n\t\t\t\t$value = strip_tags( $value );\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $value;\n\t}\n\n\t/**\n\t * Mark up a theme header.\n\t *\n     * @since 3.4.0\n\t * @access private\n\t *\n\t * @staticvar string $comma\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @param string $value Value to mark up.\n\t * @param string $translate Whether the header has been translated.\n\t * @return string Value, marked up.\n\t */\n\tprivate function markup_header( $header, $value, $translate ) {\n\t\tswitch ( $header ) {\n\t\t\tcase 'Name' :\n\t\t\t\tif ( empty( $value ) )\n\t\t\t\t\t$value = $this->get_stylesheet();\n\t\t\t\tbreak;\n\t\t\tcase 'Description' :\n\t\t\t\t$value = wptexturize( $value );\n\t\t\t\tbreak;\n\t\t\tcase 'Author' :\n\t\t\t\tif ( $this->get('AuthorURI') ) {\n\t\t\t\t\t$value = sprintf( '<a href=\"%1$s\">%2$s</a>', $this->display( 'AuthorURI', true, $translate ), $value );\n\t\t\t\t} elseif ( ! $value ) {\n\t\t\t\t\t$value = __( 'Anonymous' );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Tags' :\n\t\t\t\tstatic $comma = null;\n\t\t\t\tif ( ! isset( $comma ) ) {\n\t\t\t\t\t/* translators: used between list items, there is a space after the comma */\n\t\t\t\t\t$comma = __( ', ' );\n\t\t\t\t}\n\t\t\t\t$value = implode( $comma, $value );\n\t\t\t\tbreak;\n\t\t\tcase 'ThemeURI' :\n\t\t\tcase 'AuthorURI' :\n\t\t\t\t$value = esc_url( $value );\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $value;\n\t}\n\n\t/**\n\t * Translate a theme header.\n\t *\n\t * @since 3.4.0\n\t * @access private\n\t *\n\t * @staticvar array $tags_list\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @param string $value Value to translate.\n\t * @return string Translated value.\n\t */\n\tprivate function translate_header( $header, $value ) {\n\t\tswitch ( $header ) {\n\t\t\tcase 'Name' :\n\t\t\t\t// Cached for sorting reasons.\n\t\t\t\tif ( isset( $this->name_translated ) )\n\t\t\t\t\treturn $this->name_translated;\n\t\t\t\t$this->name_translated = translate( $value, $this->get('TextDomain' ) );\n\t\t\t\treturn $this->name_translated;\n\t\t\tcase 'Tags' :\n\t\t\t\tif ( empty( $value ) || ! function_exists( 'get_theme_feature_list' ) ) {\n\t\t\t\t\treturn $value;\n\t\t\t\t}\n\n\t\t\t\tstatic $tags_list;\n\t\t\t\tif ( ! isset( $tags_list ) ) {\n\t\t\t\t\t$tags_list = array(\n\t\t\t\t\t\t// As of 4.6, deprecated tags which are only used to provide translation for older themes.\n\t\t\t\t\t\t'black' => __( 'Black' ), 'blue' => __( 'Blue' ), 'brown'  => __( 'Brown' ),\n\t\t\t\t\t\t'gray' => __( 'Gray' ), 'green'  => __( 'Green' ), 'orange' => __( 'Orange' ),\n\t\t\t\t\t\t'pink' => __( 'Pink' ), 'purple' => __( 'Purple' ), 'red' => __( 'Red' ),\n\t\t\t\t\t\t'silver' => __( 'Silver' ), 'tan' => __( 'Tan' ), 'white' => __( 'White' ),\n\t\t\t\t\t\t'yellow' => __( 'Yellow' ), 'dark' => __( 'Dark' ), 'light' => __( 'Light' ),\n\t\t\t\t\t\t'fixed-layout' => __( 'Fixed Layout' ), 'fluid-layout' => __( 'Fluid Layout' ),\n\t\t\t\t\t\t'responsive-layout' => __( 'Responsive Layout' ), 'blavatar' => __( 'Blavatar' ),\n\t\t\t\t\t\t'photoblogging' => __( 'Photoblogging' ), 'seasonal' => __( 'Seasonal' ),\n\t\t\t\t\t);\n\n\t\t\t\t\t$feature_list = get_theme_feature_list( false ); // No API\n\t\t\t\t\tforeach ( $feature_list as $tags ) {\n\t\t\t\t\t\t$tags_list += $tags;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tforeach ( $value as &$tag ) {\n\t\t\t\t\tif ( isset( $tags_list[ $tag ] ) ) {\n\t\t\t\t\t\t$tag = $tags_list[ $tag ];\n\t\t\t\t\t} elseif ( isset( self::$tag_map[ $tag ] ) ) {\n\t\t\t\t\t\t$tag = $tags_list[ self::$tag_map[ $tag ] ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn $value;\n\n\t\t\tdefault :\n\t\t\t\t$value = translate( $value, $this->get('TextDomain') );\n\t\t}\n\t\treturn $value;\n\t}\n\n\t/**\n\t * The directory name of the theme's \"stylesheet\" files, inside the theme root.\n\t *\n\t * In the case of a child theme, this is directory name of the child theme.\n\t * Otherwise, get_stylesheet() is the same as get_template().\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Stylesheet\n\t */\n\tpublic function get_stylesheet() {\n\t\treturn $this->stylesheet;\n\t}\n\n\t/**\n\t * The directory name of the theme's \"template\" files, inside the theme root.\n\t *\n\t * In the case of a child theme, this is the directory name of the parent theme.\n\t * Otherwise, the get_template() is the same as get_stylesheet().\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Template\n\t */\n\tpublic function get_template() {\n\t\treturn $this->template;\n\t}\n\n\t/**\n\t * Returns the absolute path to the directory of a theme's \"stylesheet\" files.\n\t *\n\t * In the case of a child theme, this is the absolute path to the directory\n\t * of the child theme's files.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Absolute path of the stylesheet directory.\n\t */\n\tpublic function get_stylesheet_directory() {\n\t\tif ( $this->errors() && in_array( 'theme_root_missing', $this->errors()->get_error_codes() ) )\n\t\t\treturn '';\n\n\t\treturn $this->theme_root . '/' . $this->stylesheet;\n\t}\n\n\t/**\n\t * Returns the absolute path to the directory of a theme's \"template\" files.\n\t *\n\t * In the case of a child theme, this is the absolute path to the directory\n\t * of the parent theme's files.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Absolute path of the template directory.\n\t */\n\tpublic function get_template_directory() {\n\t\tif ( $this->parent() )\n\t\t\t$theme_root = $this->parent()->theme_root;\n\t\telse\n\t\t\t$theme_root = $this->theme_root;\n\n\t\treturn $theme_root . '/' . $this->template;\n\t}\n\n\t/**\n\t * Returns the URL to the directory of a theme's \"stylesheet\" files.\n\t *\n\t * In the case of a child theme, this is the URL to the directory of the\n\t * child theme's files.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string URL to the stylesheet directory.\n\t */\n\tpublic function get_stylesheet_directory_uri() {\n\t\treturn $this->get_theme_root_uri() . '/' . str_replace( '%2F', '/', rawurlencode( $this->stylesheet ) );\n\t}\n\n\t/**\n\t * Returns the URL to the directory of a theme's \"template\" files.\n\t *\n\t * In the case of a child theme, this is the URL to the directory of the\n\t * parent theme's files.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string URL to the template directory.\n\t */\n\tpublic function get_template_directory_uri() {\n\t\tif ( $this->parent() )\n\t\t\t$theme_root_uri = $this->parent()->get_theme_root_uri();\n\t\telse\n\t\t\t$theme_root_uri = $this->get_theme_root_uri();\n\n\t\treturn $theme_root_uri . '/' . str_replace( '%2F', '/', rawurlencode( $this->template ) );\n\t}\n\n\t/**\n\t * The absolute path to the directory of the theme root.\n\t *\n\t * This is typically the absolute path to wp-content/themes.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Theme root.\n\t */\n\tpublic function get_theme_root() {\n\t\treturn $this->theme_root;\n\t}\n\n\t/**\n\t * Returns the URL to the directory of the theme root.\n\t *\n\t * This is typically the absolute URL to wp-content/themes. This forms the basis\n\t * for all other URLs returned by WP_Theme, so we pass it to the public function\n\t * get_theme_root_uri() and allow it to run the {@see 'theme_root_uri'} filter.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Theme root URI.\n\t */\n\tpublic function get_theme_root_uri() {\n\t\tif ( ! isset( $this->theme_root_uri ) )\n\t\t\t$this->theme_root_uri = get_theme_root_uri( $this->stylesheet, $this->theme_root );\n\t\treturn $this->theme_root_uri;\n\t}\n\n\t/**\n\t * Returns the main screenshot file for the theme.\n\t *\n\t * The main screenshot is called screenshot.png. gif and jpg extensions are also allowed.\n\t *\n\t * Screenshots for a theme must be in the stylesheet directory. (In the case of child\n\t * themes, parent theme screenshots are not inherited.)\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param string $uri Type of URL to return, either 'relative' or an absolute URI. Defaults to absolute URI.\n\t * @return string|false Screenshot file. False if the theme does not have a screenshot.\n\t */\n\tpublic function get_screenshot( $uri = 'uri' ) {\n\t\t$screenshot = $this->cache_get( 'screenshot' );\n\t\tif ( $screenshot ) {\n\t\t\tif ( 'relative' == $uri )\n\t\t\t\treturn $screenshot;\n\t\t\treturn $this->get_stylesheet_directory_uri() . '/' . $screenshot;\n\t\t} elseif ( 0 === $screenshot ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tforeach ( array( 'png', 'gif', 'jpg', 'jpeg' ) as $ext ) {\n\t\t\tif ( file_exists( $this->get_stylesheet_directory() . \"/screenshot.$ext\" ) ) {\n\t\t\t\t$this->cache_add( 'screenshot', 'screenshot.' . $ext );\n\t\t\t\tif ( 'relative' == $uri )\n\t\t\t\t\treturn 'screenshot.' . $ext;\n\t\t\t\treturn $this->get_stylesheet_directory_uri() . '/' . 'screenshot.' . $ext;\n\t\t\t}\n\t\t}\n\n\t\t$this->cache_add( 'screenshot', 0 );\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return files in the theme's directory.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param mixed $type Optional. Array of extensions to return. Defaults to all files (null).\n\t * @param int $depth Optional. How deep to search for files. Defaults to a flat scan (0 depth). -1 depth is infinite.\n\t * @param bool $search_parent Optional. Whether to return parent files. Defaults to false.\n\t * @return array Array of files, keyed by the path to the file relative to the theme's directory, with the values\n\t * \t             being absolute paths.\n\t */\n\tpublic function get_files( $type = null, $depth = 0, $search_parent = false ) {\n\t\t$files = (array) self::scandir( $this->get_stylesheet_directory(), $type, $depth );\n\n\t\tif ( $search_parent && $this->parent() )\n\t\t\t$files += (array) self::scandir( $this->get_template_directory(), $type, $depth );\n\n\t\treturn $files;\n\t}\n\n\t/**\n\t * Returns the theme's post templates.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Array of page templates, keyed by filename and post type,\n\t *               with the value of the translated header name.\n\t */\n\tpublic function get_post_templates() {\n\t\t// If you screw up your current theme and we invalidate your parent, most things still work. Let it slide.\n\t\tif ( $this->errors() && $this->errors()->get_error_codes() !== array( 'theme_parent_invalid' ) ) {\n\t\t\treturn array();\n\t\t}\n\n\t\t$post_templates = $this->cache_get( 'post_templates' );\n\n\t\tif ( ! is_array( $post_templates ) ) {\n\t\t\t$post_templates = array();\n\n\t\t\t$files = (array) $this->get_files( 'php', 1 );\n\n\t\t\tforeach ( $files as $file => $full_path ) {\n\t\t\t\tif ( ! preg_match( '|Template Name:(.*)$|mi', file_get_contents( $full_path ), $header ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$types = array( 'page' );\n\t\t\t\tif ( preg_match( '|Template Post Type:(.*)$|mi', file_get_contents( $full_path ), $type ) ) {\n\t\t\t\t\t$types = explode( ',', _cleanup_header_comment( $type[1] ) );\n\t\t\t\t}\n\n\t\t\t\tforeach ( $types as $type ) {\n\t\t\t\t\t$type = sanitize_key( $type );\n\t\t\t\t\tif ( ! isset( $post_templates[ $type ] ) ) {\n\t\t\t\t\t\t$post_templates[ $type ] = array();\n\t\t\t\t\t}\n\n\t\t\t\t\t$post_templates[ $type ][ $file ] = _cleanup_header_comment( $header[1] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$this->cache_add( 'post_templates', $post_templates );\n\t\t}\n\n\t\tif ( $this->load_textdomain() ) {\n\t\t\tforeach ( $post_templates as &$post_type ) {\n\t\t\t\tforeach ( $post_type as &$post_template ) {\n\t\t\t\t\t$post_template = $this->translate_header( 'Template Name', $post_template );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $post_templates;\n\t}\n\n\t/**\n\t * Returns the theme's post templates for a given post type.\n\t *\n\t * @since 3.4.0\n\t * @since 4.7.0 Added the `$post_type` parameter.\n\t * @access public\n\t *\n\t * @param WP_Post|null $post      Optional. The post being edited, provided for context.\n\t * @param string       $post_type Optional. Post type to get the templates for. Default 'page'.\n\t *                                If a post is provided, its post type is used.\n\t * @return array Array of page templates, keyed by filename, with the value of the translated header name.\n\t */\n\tpublic function get_page_templates( $post = null, $post_type = 'page' ) {\n\t\tif ( $post ) {\n\t\t\t$post_type = get_post_type( $post );\n\t\t}\n\n\t\t$post_templates = $this->get_post_templates();\n\t\t$post_templates = isset( $post_templates[ $post_type ] ) ? $post_templates[ $post_type ] : array();\n\n\t\tif ( $this->parent() ) {\n\t\t\t$post_templates += $this->parent()->get_page_templates( $post, $post_type );\n\t\t}\n\n\t\t/**\n\t\t * Filters list of page templates for a theme.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$post_type`, refers to the post type.\n\t\t *\n\t\t * @since 3.9.0\n\t\t * @since 4.4.0 Converted to allow complete control over the `$page_templates` array.\n\t\t * @since 4.7.0 Added the `$post_type` parameter.\n\t\t *\n\t\t * @param array        $post_templates Array of page templates. Keys are filenames,\n\t\t *                                     values are translated names.\n\t\t * @param WP_Theme     $this           The theme object.\n\t\t * @param WP_Post|null $post           The post being edited, provided for context, or null.\n\t\t * @param string       $post_type      Post type to get the templates for.\n\t\t */\n\t\treturn (array) apply_filters( \"theme_{$post_type}_templates\", $post_templates, $this, $post, $post_type );\n\t}\n\n\t/**\n\t * Scans a directory for files of a certain extension.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access private\n\t *\n\t * @param string            $path          Absolute path to search.\n\t * @param array|string|null $extensions    Optional. Array of extensions to find, string of a single extension,\n\t *                                         or null for all extensions. Default null.\n\t * @param int               $depth         Optional. How many levels deep to search for files. Accepts 0, 1+, or\n\t *                                         -1 (infinite depth). Default 0.\n\t * @param string            $relative_path Optional. The basename of the absolute path. Used to control the\n\t *                                         returned path for the found files, particularly when this function\n\t *                                         recurses to lower depths. Default empty.\n\t * @return array|false Array of files, keyed by the path to the file relative to the `$path` directory prepended\n\t *                     with `$relative_path`, with the values being absolute paths. False otherwise.\n\t */\n\tprivate static function scandir( $path, $extensions = null, $depth = 0, $relative_path = '' ) {\n\t\tif ( ! is_dir( $path ) )\n\t\t\treturn false;\n\n\t\tif ( $extensions ) {\n\t\t\t$extensions = (array) $extensions;\n\t\t\t$_extensions = implode( '|', $extensions );\n\t\t}\n\n\t\t$relative_path = trailingslashit( $relative_path );\n\t\tif ( '/' == $relative_path )\n\t\t\t$relative_path = '';\n\n\t\t$results = scandir( $path );\n\t\t$files = array();\n\n\t\tforeach ( $results as $result ) {\n\t\t\tif ( '.' == $result[0] )\n\t\t\t\tcontinue;\n\t\t\tif ( is_dir( $path . '/' . $result ) ) {\n\t\t\t\tif ( ! $depth || 'CVS' == $result )\n\t\t\t\t\tcontinue;\n\t\t\t\t$found = self::scandir( $path . '/' . $result, $extensions, $depth - 1 , $relative_path . $result );\n\t\t\t\t$files = array_merge_recursive( $files, $found );\n\t\t\t} elseif ( ! $extensions || preg_match( '~\\.(' . $_extensions . ')$~', $result ) ) {\n\t\t\t\t$files[ $relative_path . $result ] = $path . '/' . $result;\n\t\t\t}\n\t\t}\n\n\t\treturn $files;\n\t}\n\n\t/**\n\t * Loads the theme's textdomain.\n\t *\n\t * Translation files are not inherited from the parent theme. Todo: if this fails for the\n\t * child theme, it should probably try to load the parent theme's translations.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return bool True if the textdomain was successfully loaded or has already been loaded.\n\t * \tFalse if no textdomain was specified in the file headers, or if the domain could not be loaded.\n\t */\n\tpublic function load_textdomain() {\n\t\tif ( isset( $this->textdomain_loaded ) )\n\t\t\treturn $this->textdomain_loaded;\n\n\t\t$textdomain = $this->get('TextDomain');\n\t\tif ( ! $textdomain ) {\n\t\t\t$this->textdomain_loaded = false;\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( is_textdomain_loaded( $textdomain ) ) {\n\t\t\t$this->textdomain_loaded = true;\n\t\t\treturn true;\n\t\t}\n\n\t\t$path = $this->get_stylesheet_directory();\n\t\tif ( $domainpath = $this->get('DomainPath') )\n\t\t\t$path .= $domainpath;\n\t\telse\n\t\t\t$path .= '/languages';\n\n\t\t$this->textdomain_loaded = load_theme_textdomain( $textdomain, $path );\n\t\treturn $this->textdomain_loaded;\n\t}\n\n\t/**\n\t * Whether the theme is allowed (multisite only).\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param string $check Optional. Whether to check only the 'network'-wide settings, the 'site'\n\t * \tsettings, or 'both'. Defaults to 'both'.\n\t * @param int $blog_id Optional. Ignored if only network-wide settings are checked. Defaults to current site.\n\t * @return bool Whether the theme is allowed for the network. Returns true in single-site.\n\t */\n\tpublic function is_allowed( $check = 'both', $blog_id = null ) {\n\t\tif ( ! is_multisite() )\n\t\t\treturn true;\n\n\t\tif ( 'both' == $check || 'network' == $check ) {\n\t\t\t$allowed = self::get_allowed_on_network();\n\t\t\tif ( ! empty( $allowed[ $this->get_stylesheet() ] ) )\n\t\t\t\treturn true;\n\t\t}\n\n\t\tif ( 'both' == $check || 'site' == $check ) {\n\t\t\t$allowed = self::get_allowed_on_site( $blog_id );\n\t\t\tif ( ! empty( $allowed[ $this->get_stylesheet() ] ) )\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determines the latest WordPress default theme that is installed.\n\t *\n\t * This hits the filesystem.\n\t *\n\t * @since  4.4.0\n\t *\n\t * @return WP_Theme|false Object, or false if no theme is installed, which would be bad.\n\t */\n\tpublic static function get_core_default_theme() {\n\t\tforeach ( array_reverse( self::$default_themes ) as $slug => $name ) {\n\t\t\t$theme = wp_get_theme( $slug );\n\t\t\tif ( $theme->exists() ) {\n\t\t\t\treturn $theme;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns array of stylesheet names of themes allowed on the site or network.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access public\n\t *\n\t * @param int $blog_id Optional. ID of the site. Defaults to the current site.\n\t * @return array Array of stylesheet names.\n\t */\n\tpublic static function get_allowed( $blog_id = null ) {\n\t\t/**\n\t\t * Filters the array of themes allowed on the network.\n\t\t *\n\t\t * Site is provided as context so that a list of network allowed themes can\n\t\t * be filtered further.\n\t\t *\n\t\t * @since 4.5.0\n\t\t *\n\t\t * @param array $allowed_themes An array of theme stylesheet names.\n\t\t * @param int   $blog_id        ID of the site.\n\t\t */\n\t\t$network = (array) apply_filters( 'network_allowed_themes', self::get_allowed_on_network(), $blog_id );\n\t\treturn $network + self::get_allowed_on_site( $blog_id );\n\t}\n\n\t/**\n\t * Returns array of stylesheet names of themes allowed on the network.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access public\n\t *\n\t * @staticvar array $allowed_themes\n\t *\n\t * @return array Array of stylesheet names.\n\t */\n\tpublic static function get_allowed_on_network() {\n\t\tstatic $allowed_themes;\n\t\tif ( ! isset( $allowed_themes ) ) {\n\t\t\t$allowed_themes = (array) get_site_option( 'allowedthemes' );\n\t\t}\n\n\t\t/**\n\t\t * Filters the array of themes allowed on the network.\n\t\t *\n\t\t * @since MU\n\t\t *\n\t\t * @param array $allowed_themes An array of theme stylesheet names.\n\t\t */\n\t\t$allowed_themes = apply_filters( 'allowed_themes', $allowed_themes );\n\n\t\treturn $allowed_themes;\n\t}\n\n\t/**\n\t * Returns array of stylesheet names of themes allowed on the site.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access public\n\t *\n\t * @staticvar array $allowed_themes\n\t *\n\t * @param int $blog_id Optional. ID of the site. Defaults to the current site.\n\t * @return array Array of stylesheet names.\n\t */\n\tpublic static function get_allowed_on_site( $blog_id = null ) {\n\t\tstatic $allowed_themes = array();\n\n\t\tif ( ! $blog_id || ! is_multisite() )\n\t\t\t$blog_id = get_current_blog_id();\n\n\t\tif ( isset( $allowed_themes[ $blog_id ] ) ) {\n\t\t\t/**\n\t\t\t * Filters the array of themes allowed on the site.\n\t\t\t *\n\t\t\t * @since 4.5.0\n\t\t\t *\n\t\t\t * @param array $allowed_themes An array of theme stylesheet names.\n\t\t\t * @param int   $blog_id        ID of the site. Defaults to current site.\n\t\t\t */\n\t\t\treturn (array) apply_filters( 'site_allowed_themes', $allowed_themes[ $blog_id ], $blog_id );\n\t\t}\n\n\t\t$current = $blog_id == get_current_blog_id();\n\n\t\tif ( $current ) {\n\t\t\t$allowed_themes[ $blog_id ] = get_option( 'allowedthemes' );\n\t\t} else {\n\t\t\tswitch_to_blog( $blog_id );\n\t\t\t$allowed_themes[ $blog_id ] = get_option( 'allowedthemes' );\n\t\t\trestore_current_blog();\n\t\t}\n\n\t\t// This is all super old MU back compat joy.\n\t\t// 'allowedthemes' keys things by stylesheet. 'allowed_themes' keyed things by name.\n\t\tif ( false === $allowed_themes[ $blog_id ] ) {\n\t\t\tif ( $current ) {\n\t\t\t\t$allowed_themes[ $blog_id ] = get_option( 'allowed_themes' );\n\t\t\t} else {\n\t\t\t\tswitch_to_blog( $blog_id );\n\t\t\t\t$allowed_themes[ $blog_id ] = get_option( 'allowed_themes' );\n\t\t\t\trestore_current_blog();\n\t\t\t}\n\n\t\t\tif ( ! is_array( $allowed_themes[ $blog_id ] ) || empty( $allowed_themes[ $blog_id ] ) ) {\n\t\t\t\t$allowed_themes[ $blog_id ] = array();\n\t\t\t} else {\n\t\t\t\t$converted = array();\n\t\t\t\t$themes = wp_get_themes();\n\t\t\t\tforeach ( $themes as $stylesheet => $theme_data ) {\n\t\t\t\t\tif ( isset( $allowed_themes[ $blog_id ][ $theme_data->get('Name') ] ) )\n\t\t\t\t\t\t$converted[ $stylesheet ] = true;\n\t\t\t\t}\n\t\t\t\t$allowed_themes[ $blog_id ] = $converted;\n\t\t\t}\n\t\t\t// Set the option so we never have to go through this pain again.\n\t\t\tif ( is_admin() && $allowed_themes[ $blog_id ] ) {\n\t\t\t\tif ( $current ) {\n\t\t\t\t\tupdate_option( 'allowedthemes', $allowed_themes[ $blog_id ] );\n\t\t\t\t\tdelete_option( 'allowed_themes' );\n\t\t\t\t} else {\n\t\t\t\t\tswitch_to_blog( $blog_id );\n\t\t\t\t\tupdate_option( 'allowedthemes', $allowed_themes[ $blog_id ] );\n\t\t\t\t\tdelete_option( 'allowed_themes' );\n\t\t\t\t\trestore_current_blog();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/** This filter is documented in wp-includes/class-wp-theme.php */\n\t\treturn (array) apply_filters( 'site_allowed_themes', $allowed_themes[ $blog_id ], $blog_id );\n\t}\n\n\t/**\n\t * Enables a theme for all sites on the current network.\n\t *\n\t * @since 4.6.0\n\t * @access public\n\t * @static\n\t *\n\t * @param string|array $stylesheets Stylesheet name or array of stylesheet names.\n\t */\n\tpublic static function network_enable_theme( $stylesheets ) {\n\t\tif ( ! is_multisite() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! is_array( $stylesheets ) ) {\n\t\t\t$stylesheets = array( $stylesheets );\n\t\t}\n\n\t\t$allowed_themes = get_site_option( 'allowedthemes' );\n\t\tforeach ( $stylesheets as $stylesheet ) {\n\t\t\t$allowed_themes[ $stylesheet ] = true;\n\t\t}\n\n\t\tupdate_site_option( 'allowedthemes', $allowed_themes );\n\t}\n\n\t/**\n\t * Disables a theme for all sites on the current network.\n\t *\n\t * @since 4.6.0\n\t * @access public\n\t * @static\n\t *\n\t * @param string|array $stylesheets Stylesheet name or array of stylesheet names.\n\t */\n\tpublic static function network_disable_theme( $stylesheets ) {\n\t\tif ( ! is_multisite() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! is_array( $stylesheets ) ) {\n\t\t\t$stylesheets = array( $stylesheets );\n\t\t}\n\n\t\t$allowed_themes = get_site_option( 'allowedthemes' );\n\t\tforeach ( $stylesheets as $stylesheet ) {\n\t\t\tif ( isset( $allowed_themes[ $stylesheet ] ) ) {\n\t\t\t\tunset( $allowed_themes[ $stylesheet ] );\n\t\t\t}\n\t\t}\n\n\t\tupdate_site_option( 'allowedthemes', $allowed_themes );\n\t}\n\n\t/**\n\t * Sorts themes by name.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access public\n\t *\n\t * @param array $themes Array of themes to sort, passed by reference.\n\t */\n\tpublic static function sort_by_name( &$themes ) {\n\t\tif ( 0 === strpos( get_user_locale(), 'en_' ) ) {\n\t\t\tuasort( $themes, array( 'WP_Theme', '_name_sort' ) );\n\t\t} else {\n\t\t\tuasort( $themes, array( 'WP_Theme', '_name_sort_i18n' ) );\n\t\t}\n\t}\n\n\t/**\n\t * Callback function for usort() to naturally sort themes by name.\n\t *\n\t * Accesses the Name header directly from the class for maximum speed.\n\t * Would choke on HTML but we don't care enough to slow it down with strip_tags().\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access private\n\t *\n\t * @param string $a First name.\n\t * @param string $b Second name.\n\t * @return int Negative if `$a` falls lower in the natural order than `$b`. Zero if they fall equally.\n\t *             Greater than 0 if `$a` falls higher in the natural order than `$b`. Used with usort().\n\t */\n\tprivate static function _name_sort( $a, $b ) {\n\t\treturn strnatcasecmp( $a->headers['Name'], $b->headers['Name'] );\n\t}\n\n\t/**\n\t * Name sort (with translation).\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access private\n\t *\n\t * @param string $a First name.\n\t * @param string $b Second name.\n\t * @return int Negative if `$a` falls lower in the natural order than `$b`. Zero if they fall equally.\n\t *             Greater than 0 if `$a` falls higher in the natural order than `$b`. Used with usort().\n\t */\n\tprivate static function _name_sort_i18n( $a, $b ) {\n\t\t// Don't mark up; Do translate.\n\t\treturn strnatcasecmp( $a->display( 'Name', false, true ), $b->display( 'Name', false, true ) );\n\t}\n}\n", "<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '4.8-alpha-39795';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 38590;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4403-20160901';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "fixing_code": ["<?php\n/**\n * WP_Theme Class\n *\n * @package WordPress\n * @subpackage Theme\n * @since 3.4.0\n */\nfinal class WP_Theme implements ArrayAccess {\n\n\t/**\n\t * Whether the theme has been marked as updateable.\n\t *\n\t * @since 4.4.0\n\t * @access public\n\t * @var bool\n\t *\n\t * @see WP_MS_Themes_List_Table\n\t */\n\tpublic $update = false;\n\n\t/**\n\t * Headers for style.css files.\n\t *\n\t * @static\n\t * @access private\n\t * @var array\n\t */\n\tprivate static $file_headers = array(\n\t\t'Name'        => 'Theme Name',\n\t\t'ThemeURI'    => 'Theme URI',\n\t\t'Description' => 'Description',\n\t\t'Author'      => 'Author',\n\t\t'AuthorURI'   => 'Author URI',\n\t\t'Version'     => 'Version',\n\t\t'Template'    => 'Template',\n\t\t'Status'      => 'Status',\n\t\t'Tags'        => 'Tags',\n\t\t'TextDomain'  => 'Text Domain',\n\t\t'DomainPath'  => 'Domain Path',\n\t);\n\n\t/**\n\t * Default themes.\n\t *\n\t * @static\n\t * @access private\n\t * @var array\n\t */\n\tprivate static $default_themes = array(\n\t\t'classic'         => 'WordPress Classic',\n\t\t'default'         => 'WordPress Default',\n\t\t'twentyten'       => 'Twenty Ten',\n\t\t'twentyeleven'    => 'Twenty Eleven',\n\t\t'twentytwelve'    => 'Twenty Twelve',\n\t\t'twentythirteen'  => 'Twenty Thirteen',\n\t\t'twentyfourteen'  => 'Twenty Fourteen',\n\t\t'twentyfifteen'   => 'Twenty Fifteen',\n\t\t'twentysixteen'   => 'Twenty Sixteen',\n\t\t'twentyseventeen' => 'Twenty Seventeen',\n\t);\n\n\t/**\n\t * Renamed theme tags.\n\t *\n\t * @static\n\t * @access private\n\t * @var array\n\t */\n\tprivate static $tag_map = array(\n\t\t'fixed-width'    => 'fixed-layout',\n\t\t'flexible-width' => 'fluid-layout',\n\t);\n\n\t/**\n\t * Absolute path to the theme root, usually wp-content/themes\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $theme_root;\n\n\t/**\n\t * Header data from the theme's style.css file.\n\t *\n\t * @access private\n\t * @var array\n\t */\n\tprivate $headers = array();\n\n\t/**\n\t * Header data from the theme's style.css file after being sanitized.\n\t *\n\t * @access private\n\t * @var array\n\t */\n\tprivate $headers_sanitized;\n\n\t/**\n\t * Header name from the theme's style.css after being translated.\n\t *\n\t * Cached due to sorting functions running over the translated name.\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $name_translated;\n\n\t/**\n\t * Errors encountered when initializing the theme.\n\t *\n\t * @access private\n\t * @var WP_Error\n\t */\n\tprivate $errors;\n\n\t/**\n\t * The directory name of the theme's files, inside the theme root.\n\t *\n\t * In the case of a child theme, this is directory name of the child theme.\n\t * Otherwise, 'stylesheet' is the same as 'template'.\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $stylesheet;\n\n\t/**\n\t * The directory name of the theme's files, inside the theme root.\n\t *\n\t * In the case of a child theme, this is the directory name of the parent theme.\n\t * Otherwise, 'template' is the same as 'stylesheet'.\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $template;\n\n\t/**\n\t * A reference to the parent theme, in the case of a child theme.\n\t *\n\t * @access private\n\t * @var WP_Theme\n\t */\n\tprivate $parent;\n\n\t/**\n\t * URL to the theme root, usually an absolute URL to wp-content/themes\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $theme_root_uri;\n\n\t/**\n\t * Flag for whether the theme's textdomain is loaded.\n\t *\n\t * @access private\n\t * @var bool\n\t */\n\tprivate $textdomain_loaded;\n\n\t/**\n\t * Stores an md5 hash of the theme root, to function as the cache key.\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $cache_hash;\n\n\t/**\n\t * Flag for whether the themes cache bucket should be persistently cached.\n\t *\n\t * Default is false. Can be set with the {@see 'wp_cache_themes_persistently'} filter.\n\t *\n\t * @static\n\t * @access private\n\t * @var bool\n\t */\n\tprivate static $persistently_cache;\n\n\t/**\n\t * Expiration time for the themes cache bucket.\n\t *\n\t * By default the bucket is not cached, so this value is useless.\n\t *\n\t * @static\n\t * @access private\n\t * @var bool\n\t */\n\tprivate static $cache_expiration = 1800;\n\n\t/**\n\t * Constructor for WP_Theme.\n\t *\n\t * @since  3.4.0\n\t *\n\t * @global array $wp_theme_directories\n\t *\n\t * @param string $theme_dir Directory of the theme within the theme_root.\n\t * @param string $theme_root Theme root.\n\t * @param WP_Error|void $_child If this theme is a parent theme, the child may be passed for validation purposes.\n\t */\n\tpublic function __construct( $theme_dir, $theme_root, $_child = null ) {\n\t\tglobal $wp_theme_directories;\n\n\t\t// Initialize caching on first run.\n\t\tif ( ! isset( self::$persistently_cache ) ) {\n\t\t\t/** This action is documented in wp-includes/theme.php */\n\t\t\tself::$persistently_cache = apply_filters( 'wp_cache_themes_persistently', false, 'WP_Theme' );\n\t\t\tif ( self::$persistently_cache ) {\n\t\t\t\twp_cache_add_global_groups( 'themes' );\n\t\t\t\tif ( is_int( self::$persistently_cache ) )\n\t\t\t\t\tself::$cache_expiration = self::$persistently_cache;\n\t\t\t} else {\n\t\t\t\twp_cache_add_non_persistent_groups( 'themes' );\n\t\t\t}\n\t\t}\n\n\t\t$this->theme_root = $theme_root;\n\t\t$this->stylesheet = $theme_dir;\n\n\t\t// Correct a situation where the theme is 'some-directory/some-theme' but 'some-directory' was passed in as part of the theme root instead.\n\t\tif ( ! in_array( $theme_root, (array) $wp_theme_directories ) && in_array( dirname( $theme_root ), (array) $wp_theme_directories ) ) {\n\t\t\t$this->stylesheet = basename( $this->theme_root ) . '/' . $this->stylesheet;\n\t\t\t$this->theme_root = dirname( $theme_root );\n\t\t}\n\n\t\t$this->cache_hash = md5( $this->theme_root . '/' . $this->stylesheet );\n\t\t$theme_file = $this->stylesheet . '/style.css';\n\n\t\t$cache = $this->cache_get( 'theme' );\n\n\t\tif ( is_array( $cache ) ) {\n\t\t\tforeach ( array( 'errors', 'headers', 'template' ) as $key ) {\n\t\t\t\tif ( isset( $cache[ $key ] ) )\n\t\t\t\t\t$this->$key = $cache[ $key ];\n\t\t\t}\n\t\t\tif ( $this->errors )\n\t\t\t\treturn;\n\t\t\tif ( isset( $cache['theme_root_template'] ) )\n\t\t\t\t$theme_root_template = $cache['theme_root_template'];\n\t\t} elseif ( ! file_exists( $this->theme_root . '/' . $theme_file ) ) {\n\t\t\t$this->headers['Name'] = $this->stylesheet;\n\t\t\tif ( ! file_exists( $this->theme_root . '/' . $this->stylesheet ) )\n\t\t\t\t$this->errors = new WP_Error( 'theme_not_found', sprintf( __( 'The theme directory \"%s\" does not exist.' ), esc_html( $this->stylesheet ) ) );\n\t\t\telse\n\t\t\t\t$this->errors = new WP_Error( 'theme_no_stylesheet', __( 'Stylesheet is missing.' ) );\n\t\t\t$this->template = $this->stylesheet;\n\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\tif ( ! file_exists( $this->theme_root ) ) // Don't cache this one.\n\t\t\t\t$this->errors->add( 'theme_root_missing', __( 'ERROR: The themes directory is either empty or doesn&#8217;t exist. Please check your installation.' ) );\n\t\t\treturn;\n\t\t} elseif ( ! is_readable( $this->theme_root . '/' . $theme_file ) ) {\n\t\t\t$this->headers['Name'] = $this->stylesheet;\n\t\t\t$this->errors = new WP_Error( 'theme_stylesheet_not_readable', __( 'Stylesheet is not readable.' ) );\n\t\t\t$this->template = $this->stylesheet;\n\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\treturn;\n\t\t} else {\n\t\t\t$this->headers = get_file_data( $this->theme_root . '/' . $theme_file, self::$file_headers, 'theme' );\n\t\t\t// Default themes always trump their pretenders.\n\t\t\t// Properly identify default themes that are inside a directory within wp-content/themes.\n\t\t\tif ( $default_theme_slug = array_search( $this->headers['Name'], self::$default_themes ) ) {\n\t\t\t\tif ( basename( $this->stylesheet ) != $default_theme_slug )\n\t\t\t\t\t$this->headers['Name'] .= '/' . $this->stylesheet;\n\t\t\t}\n\t\t}\n\n\t\t// (If template is set from cache [and there are no errors], we know it's good.)\n\t\tif ( ! $this->template && ! ( $this->template = $this->headers['Template'] ) ) {\n\t\t\t$this->template = $this->stylesheet;\n\t\t\tif ( ! file_exists( $this->theme_root . '/' . $this->stylesheet . '/index.php' ) ) {\n\t\t\t\t$error_message = sprintf(\n\t\t\t\t\t/* translators: 1: index.php, 2: Codex URL, 3: style.css */\n\t\t\t\t\t__( 'Template is missing. Standalone themes need to have a %1$s template file. <a href=\"%2$s\">Child themes</a> need to have a Template header in the %3$s stylesheet.' ),\n\t\t\t\t\t'<code>index.php</code>',\n\t\t\t\t\t__( 'https://codex.wordpress.org/Child_Themes' ),\n\t\t\t\t\t'<code>style.css</code>'\n\t\t\t\t);\n\t\t\t\t$this->errors = new WP_Error( 'theme_no_index', $error_message );\n\t\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If we got our data from cache, we can assume that 'template' is pointing to the right place.\n\t\tif ( ! is_array( $cache ) && $this->template != $this->stylesheet && ! file_exists( $this->theme_root . '/' . $this->template . '/index.php' ) ) {\n\t\t\t// If we're in a directory of themes inside /themes, look for the parent nearby.\n\t\t\t// wp-content/themes/directory-of-themes/*\n\t\t\t$parent_dir = dirname( $this->stylesheet );\n\t\t\tif ( '.' != $parent_dir && file_exists( $this->theme_root . '/' . $parent_dir . '/' . $this->template . '/index.php' ) ) {\n\t\t\t\t$this->template = $parent_dir . '/' . $this->template;\n\t\t\t} elseif ( ( $directories = search_theme_directories() ) && isset( $directories[ $this->template ] ) ) {\n\t\t\t\t// Look for the template in the search_theme_directories() results, in case it is in another theme root.\n\t\t\t\t// We don't look into directories of themes, just the theme root.\n\t\t\t\t$theme_root_template = $directories[ $this->template ]['theme_root'];\n\t\t\t} else {\n\t\t\t\t// Parent theme is missing.\n\t\t\t\t$this->errors = new WP_Error( 'theme_no_parent', sprintf( __( 'The parent theme is missing. Please install the \"%s\" parent theme.' ), esc_html( $this->template ) ) );\n\t\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\t\t$this->parent = new WP_Theme( $this->template, $this->theme_root, $this );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Set the parent, if we're a child theme.\n\t\tif ( $this->template != $this->stylesheet ) {\n\t\t\t// If we are a parent, then there is a problem. Only two generations allowed! Cancel things out.\n\t\t\tif ( $_child instanceof WP_Theme && $_child->template == $this->stylesheet ) {\n\t\t\t\t$_child->parent = null;\n\t\t\t\t$_child->errors = new WP_Error( 'theme_parent_invalid', sprintf( __( 'The \"%s\" theme is not a valid parent theme.' ), esc_html( $_child->template ) ) );\n\t\t\t\t$_child->cache_add( 'theme', array( 'headers' => $_child->headers, 'errors' => $_child->errors, 'stylesheet' => $_child->stylesheet, 'template' => $_child->template ) );\n\t\t\t\t// The two themes actually reference each other with the Template header.\n\t\t\t\tif ( $_child->stylesheet == $this->template ) {\n\t\t\t\t\t$this->errors = new WP_Error( 'theme_parent_invalid', sprintf( __( 'The \"%s\" theme is not a valid parent theme.' ), esc_html( $this->template ) ) );\n\t\t\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Set the parent. Pass the current instance so we can do the crazy checks above and assess errors.\n\t\t\t$this->parent = new WP_Theme( $this->template, isset( $theme_root_template ) ? $theme_root_template : $this->theme_root, $this );\n\t\t}\n\n\t\t// We're good. If we didn't retrieve from cache, set it.\n\t\tif ( ! is_array( $cache ) ) {\n\t\t\t$cache = array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template );\n\t\t\t// If the parent theme is in another root, we'll want to cache this. Avoids an entire branch of filesystem calls above.\n\t\t\tif ( isset( $theme_root_template ) )\n\t\t\t\t$cache['theme_root_template'] = $theme_root_template;\n\t\t\t$this->cache_add( 'theme', $cache );\n\t\t}\n\t}\n\n\t/**\n\t * When converting the object to a string, the theme name is returned.\n\t *\n\t * @since  3.4.0\n\t *\n\t * @return string Theme name, ready for display (translated)\n\t */\n\tpublic function __toString() {\n\t\treturn (string) $this->display('Name');\n\t}\n\n\t/**\n\t * __isset() magic method for properties formerly returned by current_theme_info()\n\t *\n\t * @staticvar array $properties\n\t *\n\t * @since  3.4.0\n\t *\n\t * @param string $offset Property to check if set.\n\t * @return bool Whether the given property is set.\n\t */\n\tpublic function __isset( $offset ) {\n\t\tstatic $properties = array(\n\t\t\t'name', 'title', 'version', 'parent_theme', 'template_dir', 'stylesheet_dir', 'template', 'stylesheet',\n\t\t\t'screenshot', 'description', 'author', 'tags', 'theme_root', 'theme_root_uri',\n\t\t);\n\n\t\treturn in_array( $offset, $properties );\n\t}\n\n\t/**\n\t * __get() magic method for properties formerly returned by current_theme_info()\n\t *\n\t * @since  3.4.0\n\t *\n\t * @param string $offset Property to get.\n\t * @return mixed Property value.\n\t */\n\tpublic function __get( $offset ) {\n\t\tswitch ( $offset ) {\n\t\t\tcase 'name' :\n\t\t\tcase 'title' :\n\t\t\t\treturn $this->get('Name');\n\t\t\tcase 'version' :\n\t\t\t\treturn $this->get('Version');\n\t\t\tcase 'parent_theme' :\n\t\t\t\treturn $this->parent() ? $this->parent()->get('Name') : '';\n\t\t\tcase 'template_dir' :\n\t\t\t\treturn $this->get_template_directory();\n\t\t\tcase 'stylesheet_dir' :\n\t\t\t\treturn $this->get_stylesheet_directory();\n\t\t\tcase 'template' :\n\t\t\t\treturn $this->get_template();\n\t\t\tcase 'stylesheet' :\n\t\t\t\treturn $this->get_stylesheet();\n\t\t\tcase 'screenshot' :\n\t\t\t\treturn $this->get_screenshot( 'relative' );\n\t\t\t// 'author' and 'description' did not previously return translated data.\n\t\t\tcase 'description' :\n\t\t\t\treturn $this->display('Description');\n\t\t\tcase 'author' :\n\t\t\t\treturn $this->display('Author');\n\t\t\tcase 'tags' :\n\t\t\t\treturn $this->get( 'Tags' );\n\t\t\tcase 'theme_root' :\n\t\t\t\treturn $this->get_theme_root();\n\t\t\tcase 'theme_root_uri' :\n\t\t\t\treturn $this->get_theme_root_uri();\n\t\t\t// For cases where the array was converted to an object.\n\t\t\tdefault :\n\t\t\t\treturn $this->offsetGet( $offset );\n\t\t}\n\t}\n\n\t/**\n\t * Method to implement ArrayAccess for keys formerly returned by get_themes()\n\t *\n\t * @since  3.4.0\n\t *\n\t * @param mixed $offset\n\t * @param mixed $value\n\t */\n\tpublic function offsetSet( $offset, $value ) {}\n\n\t/**\n\t * Method to implement ArrayAccess for keys formerly returned by get_themes()\n\t *\n\t * @since  3.4.0\n\t *\n\t * @param mixed $offset\n\t */\n\tpublic function offsetUnset( $offset ) {}\n\n\t/**\n\t * Method to implement ArrayAccess for keys formerly returned by get_themes()\n\t *\n\t * @staticvar array $keys\n\t *\n\t * @since  3.4.0\n\t *\n\t * @param mixed $offset\n\t * @return bool\n\t */\n\tpublic function offsetExists( $offset ) {\n\t\tstatic $keys = array(\n\t\t\t'Name', 'Version', 'Status', 'Title', 'Author', 'Author Name', 'Author URI', 'Description',\n\t\t\t'Template', 'Stylesheet', 'Template Files', 'Stylesheet Files', 'Template Dir', 'Stylesheet Dir',\n\t\t\t'Screenshot', 'Tags', 'Theme Root', 'Theme Root URI', 'Parent Theme',\n\t\t);\n\n\t\treturn in_array( $offset, $keys );\n\t}\n\n\t/**\n\t * Method to implement ArrayAccess for keys formerly returned by get_themes().\n\t *\n\t * Author, Author Name, Author URI, and Description did not previously return\n\t * translated data. We are doing so now as it is safe to do. However, as\n\t * Name and Title could have been used as the key for get_themes(), both remain\n\t * untranslated for back compatibility. This means that ['Name'] is not ideal,\n\t * and care should be taken to use `$theme::display( 'Name' )` to get a properly\n\t * translated header.\n\t *\n\t * @since  3.4.0\n\t *\n\t * @param mixed $offset\n\t * @return mixed\n\t */\n\tpublic function offsetGet( $offset ) {\n\t\tswitch ( $offset ) {\n\t\t\tcase 'Name' :\n\t\t\tcase 'Title' :\n\t\t\t\t/*\n\t\t\t\t * See note above about using translated data. get() is not ideal.\n\t\t\t\t * It is only for backward compatibility. Use display().\n\t\t\t\t */\n\t\t\t\treturn $this->get('Name');\n\t\t\tcase 'Author' :\n\t\t\t\treturn $this->display( 'Author');\n\t\t\tcase 'Author Name' :\n\t\t\t\treturn $this->display( 'Author', false);\n\t\t\tcase 'Author URI' :\n\t\t\t\treturn $this->display('AuthorURI');\n\t\t\tcase 'Description' :\n\t\t\t\treturn $this->display( 'Description');\n\t\t\tcase 'Version' :\n\t\t\tcase 'Status' :\n\t\t\t\treturn $this->get( $offset );\n\t\t\tcase 'Template' :\n\t\t\t\treturn $this->get_template();\n\t\t\tcase 'Stylesheet' :\n\t\t\t\treturn $this->get_stylesheet();\n\t\t\tcase 'Template Files' :\n\t\t\t\treturn $this->get_files( 'php', 1, true );\n\t\t\tcase 'Stylesheet Files' :\n\t\t\t\treturn $this->get_files( 'css', 0, false );\n\t\t\tcase 'Template Dir' :\n\t\t\t\treturn $this->get_template_directory();\n\t\t\tcase 'Stylesheet Dir' :\n\t\t\t\treturn $this->get_stylesheet_directory();\n\t\t\tcase 'Screenshot' :\n\t\t\t\treturn $this->get_screenshot( 'relative' );\n\t\t\tcase 'Tags' :\n\t\t\t\treturn $this->get('Tags');\n\t\t\tcase 'Theme Root' :\n\t\t\t\treturn $this->get_theme_root();\n\t\t\tcase 'Theme Root URI' :\n\t\t\t\treturn $this->get_theme_root_uri();\n\t\t\tcase 'Parent Theme' :\n\t\t\t\treturn $this->parent() ? $this->parent()->get('Name') : '';\n\t\t\tdefault :\n\t\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Returns errors property.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return WP_Error|false WP_Error if there are errors, or false.\n\t */\n\tpublic function errors() {\n\t\treturn is_wp_error( $this->errors ) ? $this->errors : false;\n\t}\n\n\t/**\n\t * Whether the theme exists.\n\t *\n\t * A theme with errors exists. A theme with the error of 'theme_not_found',\n\t * meaning that the theme's directory was not found, does not exist.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return bool Whether the theme exists.\n\t */\n\tpublic function exists() {\n\t\treturn ! ( $this->errors() && in_array( 'theme_not_found', $this->errors()->get_error_codes() ) );\n\t}\n\n\t/**\n\t * Returns reference to the parent theme.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return WP_Theme|false Parent theme, or false if the current theme is not a child theme.\n\t */\n\tpublic function parent() {\n\t\treturn isset( $this->parent ) ? $this->parent : false;\n\t}\n\n\t/**\n\t * Adds theme data to cache.\n\t *\n\t * Cache entries keyed by the theme and the type of data.\n\t *\n\t * @since 3.4.0\n\t * @access private\n\t *\n\t * @param string $key Type of data to store (theme, screenshot, headers, post_templates)\n\t * @param string $data Data to store\n\t * @return bool Return value from wp_cache_add()\n\t */\n\tprivate function cache_add( $key, $data ) {\n\t\treturn wp_cache_add( $key . '-' . $this->cache_hash, $data, 'themes', self::$cache_expiration );\n\t}\n\n\t/**\n\t * Gets theme data from cache.\n\t *\n\t * Cache entries are keyed by the theme and the type of data.\n\t *\n\t * @since 3.4.0\n\t * @access private\n\t *\n\t * @param string $key Type of data to retrieve (theme, screenshot, headers, post_templates)\n\t * @return mixed Retrieved data\n\t */\n\tprivate function cache_get( $key ) {\n\t\treturn wp_cache_get( $key . '-' . $this->cache_hash, 'themes' );\n\t}\n\n\t/**\n\t * Clears the cache for the theme.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t */\n\tpublic function cache_delete() {\n\t\tforeach ( array( 'theme', 'screenshot', 'headers', 'post_templates' ) as $key )\n\t\t\twp_cache_delete( $key . '-' . $this->cache_hash, 'themes' );\n\t\t$this->template = $this->textdomain_loaded = $this->theme_root_uri = $this->parent = $this->errors = $this->headers_sanitized = $this->name_translated = null;\n\t\t$this->headers = array();\n\t\t$this->__construct( $this->stylesheet, $this->theme_root );\n\t}\n\n\t/**\n\t * Get a raw, unformatted theme header.\n\t *\n\t * The header is sanitized, but is not translated, and is not marked up for display.\n\t * To get a theme header for display, use the display() method.\n\t *\n\t * Use the get_template() method, not the 'Template' header, for finding the template.\n\t * The 'Template' header is only good for what was written in the style.css, while\n\t * get_template() takes into account where WordPress actually located the theme and\n\t * whether it is actually valid.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @return string|false String on success, false on failure.\n\t */\n\tpublic function get( $header ) {\n\t\tif ( ! isset( $this->headers[ $header ] ) )\n\t\t\treturn false;\n\n\t\tif ( ! isset( $this->headers_sanitized ) ) {\n\t\t\t$this->headers_sanitized = $this->cache_get( 'headers' );\n\t\t\tif ( ! is_array( $this->headers_sanitized ) )\n\t\t\t\t$this->headers_sanitized = array();\n\t\t}\n\n\t\tif ( isset( $this->headers_sanitized[ $header ] ) )\n\t\t\treturn $this->headers_sanitized[ $header ];\n\n\t\t// If themes are a persistent group, sanitize everything and cache it. One cache add is better than many cache sets.\n\t\tif ( self::$persistently_cache ) {\n\t\t\tforeach ( array_keys( $this->headers ) as $_header )\n\t\t\t\t$this->headers_sanitized[ $_header ] = $this->sanitize_header( $_header, $this->headers[ $_header ] );\n\t\t\t$this->cache_add( 'headers', $this->headers_sanitized );\n\t\t} else {\n\t\t\t$this->headers_sanitized[ $header ] = $this->sanitize_header( $header, $this->headers[ $header ] );\n\t\t}\n\n\t\treturn $this->headers_sanitized[ $header ];\n\t}\n\n\t/**\n\t * Gets a theme header, formatted and translated for display.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @param bool $markup Optional. Whether to mark up the header. Defaults to true.\n\t * @param bool $translate Optional. Whether to translate the header. Defaults to true.\n\t * @return string|false Processed header, false on failure.\n\t */\n\tpublic function display( $header, $markup = true, $translate = true ) {\n\t\t$value = $this->get( $header );\n\t\tif ( false === $value ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( $translate && ( empty( $value ) || ! $this->load_textdomain() ) )\n\t\t\t$translate = false;\n\n\t\tif ( $translate )\n\t\t\t$value = $this->translate_header( $header, $value );\n\n\t\tif ( $markup )\n\t\t\t$value = $this->markup_header( $header, $value, $translate );\n\n\t\treturn $value;\n\t}\n\n\t/**\n\t * Sanitize a theme header.\n\t *\n\t * @since 3.4.0\n\t * @access private\n\t *\n\t * @staticvar array $header_tags\n\t * @staticvar array $header_tags_with_a\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @param string $value Value to sanitize.\n\t * @return mixed\n\t */\n\tprivate function sanitize_header( $header, $value ) {\n\t\tswitch ( $header ) {\n\t\t\tcase 'Status' :\n\t\t\t\tif ( ! $value ) {\n\t\t\t\t\t$value = 'publish';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Fall through otherwise.\n\t\t\tcase 'Name' :\n\t\t\t\tstatic $header_tags = array(\n\t\t\t\t\t'abbr'    => array( 'title' => true ),\n\t\t\t\t\t'acronym' => array( 'title' => true ),\n\t\t\t\t\t'code'    => true,\n\t\t\t\t\t'em'      => true,\n\t\t\t\t\t'strong'  => true,\n\t\t\t\t);\n\t\t\t\t$value = wp_kses( $value, $header_tags );\n\t\t\t\tbreak;\n\t\t\tcase 'Author' :\n\t\t\t\t// There shouldn't be anchor tags in Author, but some themes like to be challenging.\n\t\t\tcase 'Description' :\n\t\t\t\tstatic $header_tags_with_a = array(\n\t\t\t\t\t'a'       => array( 'href' => true, 'title' => true ),\n\t\t\t\t\t'abbr'    => array( 'title' => true ),\n\t\t\t\t\t'acronym' => array( 'title' => true ),\n\t\t\t\t\t'code'    => true,\n\t\t\t\t\t'em'      => true,\n\t\t\t\t\t'strong'  => true,\n\t\t\t\t);\n\t\t\t\t$value = wp_kses( $value, $header_tags_with_a );\n\t\t\t\tbreak;\n\t\t\tcase 'ThemeURI' :\n\t\t\tcase 'AuthorURI' :\n\t\t\t\t$value = esc_url_raw( $value );\n\t\t\t\tbreak;\n\t\t\tcase 'Tags' :\n\t\t\t\t$value = array_filter( array_map( 'trim', explode( ',', strip_tags( $value ) ) ) );\n\t\t\t\tbreak;\n\t\t\tcase 'Version' :\n\t\t\t\t$value = strip_tags( $value );\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $value;\n\t}\n\n\t/**\n\t * Mark up a theme header.\n\t *\n     * @since 3.4.0\n\t * @access private\n\t *\n\t * @staticvar string $comma\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @param string $value Value to mark up.\n\t * @param string $translate Whether the header has been translated.\n\t * @return string Value, marked up.\n\t */\n\tprivate function markup_header( $header, $value, $translate ) {\n\t\tswitch ( $header ) {\n\t\t\tcase 'Name' :\n\t\t\t\tif ( empty( $value ) ) {\n\t\t\t\t\t$value = esc_html( $this->get_stylesheet() );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Description' :\n\t\t\t\t$value = wptexturize( $value );\n\t\t\t\tbreak;\n\t\t\tcase 'Author' :\n\t\t\t\tif ( $this->get('AuthorURI') ) {\n\t\t\t\t\t$value = sprintf( '<a href=\"%1$s\">%2$s</a>', $this->display( 'AuthorURI', true, $translate ), $value );\n\t\t\t\t} elseif ( ! $value ) {\n\t\t\t\t\t$value = __( 'Anonymous' );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Tags' :\n\t\t\t\tstatic $comma = null;\n\t\t\t\tif ( ! isset( $comma ) ) {\n\t\t\t\t\t/* translators: used between list items, there is a space after the comma */\n\t\t\t\t\t$comma = __( ', ' );\n\t\t\t\t}\n\t\t\t\t$value = implode( $comma, $value );\n\t\t\t\tbreak;\n\t\t\tcase 'ThemeURI' :\n\t\t\tcase 'AuthorURI' :\n\t\t\t\t$value = esc_url( $value );\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $value;\n\t}\n\n\t/**\n\t * Translate a theme header.\n\t *\n\t * @since 3.4.0\n\t * @access private\n\t *\n\t * @staticvar array $tags_list\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @param string $value Value to translate.\n\t * @return string Translated value.\n\t */\n\tprivate function translate_header( $header, $value ) {\n\t\tswitch ( $header ) {\n\t\t\tcase 'Name' :\n\t\t\t\t// Cached for sorting reasons.\n\t\t\t\tif ( isset( $this->name_translated ) )\n\t\t\t\t\treturn $this->name_translated;\n\t\t\t\t$this->name_translated = translate( $value, $this->get('TextDomain' ) );\n\t\t\t\treturn $this->name_translated;\n\t\t\tcase 'Tags' :\n\t\t\t\tif ( empty( $value ) || ! function_exists( 'get_theme_feature_list' ) ) {\n\t\t\t\t\treturn $value;\n\t\t\t\t}\n\n\t\t\t\tstatic $tags_list;\n\t\t\t\tif ( ! isset( $tags_list ) ) {\n\t\t\t\t\t$tags_list = array(\n\t\t\t\t\t\t// As of 4.6, deprecated tags which are only used to provide translation for older themes.\n\t\t\t\t\t\t'black' => __( 'Black' ), 'blue' => __( 'Blue' ), 'brown'  => __( 'Brown' ),\n\t\t\t\t\t\t'gray' => __( 'Gray' ), 'green'  => __( 'Green' ), 'orange' => __( 'Orange' ),\n\t\t\t\t\t\t'pink' => __( 'Pink' ), 'purple' => __( 'Purple' ), 'red' => __( 'Red' ),\n\t\t\t\t\t\t'silver' => __( 'Silver' ), 'tan' => __( 'Tan' ), 'white' => __( 'White' ),\n\t\t\t\t\t\t'yellow' => __( 'Yellow' ), 'dark' => __( 'Dark' ), 'light' => __( 'Light' ),\n\t\t\t\t\t\t'fixed-layout' => __( 'Fixed Layout' ), 'fluid-layout' => __( 'Fluid Layout' ),\n\t\t\t\t\t\t'responsive-layout' => __( 'Responsive Layout' ), 'blavatar' => __( 'Blavatar' ),\n\t\t\t\t\t\t'photoblogging' => __( 'Photoblogging' ), 'seasonal' => __( 'Seasonal' ),\n\t\t\t\t\t);\n\n\t\t\t\t\t$feature_list = get_theme_feature_list( false ); // No API\n\t\t\t\t\tforeach ( $feature_list as $tags ) {\n\t\t\t\t\t\t$tags_list += $tags;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tforeach ( $value as &$tag ) {\n\t\t\t\t\tif ( isset( $tags_list[ $tag ] ) ) {\n\t\t\t\t\t\t$tag = $tags_list[ $tag ];\n\t\t\t\t\t} elseif ( isset( self::$tag_map[ $tag ] ) ) {\n\t\t\t\t\t\t$tag = $tags_list[ self::$tag_map[ $tag ] ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn $value;\n\n\t\t\tdefault :\n\t\t\t\t$value = translate( $value, $this->get('TextDomain') );\n\t\t}\n\t\treturn $value;\n\t}\n\n\t/**\n\t * The directory name of the theme's \"stylesheet\" files, inside the theme root.\n\t *\n\t * In the case of a child theme, this is directory name of the child theme.\n\t * Otherwise, get_stylesheet() is the same as get_template().\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Stylesheet\n\t */\n\tpublic function get_stylesheet() {\n\t\treturn $this->stylesheet;\n\t}\n\n\t/**\n\t * The directory name of the theme's \"template\" files, inside the theme root.\n\t *\n\t * In the case of a child theme, this is the directory name of the parent theme.\n\t * Otherwise, the get_template() is the same as get_stylesheet().\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Template\n\t */\n\tpublic function get_template() {\n\t\treturn $this->template;\n\t}\n\n\t/**\n\t * Returns the absolute path to the directory of a theme's \"stylesheet\" files.\n\t *\n\t * In the case of a child theme, this is the absolute path to the directory\n\t * of the child theme's files.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Absolute path of the stylesheet directory.\n\t */\n\tpublic function get_stylesheet_directory() {\n\t\tif ( $this->errors() && in_array( 'theme_root_missing', $this->errors()->get_error_codes() ) )\n\t\t\treturn '';\n\n\t\treturn $this->theme_root . '/' . $this->stylesheet;\n\t}\n\n\t/**\n\t * Returns the absolute path to the directory of a theme's \"template\" files.\n\t *\n\t * In the case of a child theme, this is the absolute path to the directory\n\t * of the parent theme's files.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Absolute path of the template directory.\n\t */\n\tpublic function get_template_directory() {\n\t\tif ( $this->parent() )\n\t\t\t$theme_root = $this->parent()->theme_root;\n\t\telse\n\t\t\t$theme_root = $this->theme_root;\n\n\t\treturn $theme_root . '/' . $this->template;\n\t}\n\n\t/**\n\t * Returns the URL to the directory of a theme's \"stylesheet\" files.\n\t *\n\t * In the case of a child theme, this is the URL to the directory of the\n\t * child theme's files.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string URL to the stylesheet directory.\n\t */\n\tpublic function get_stylesheet_directory_uri() {\n\t\treturn $this->get_theme_root_uri() . '/' . str_replace( '%2F', '/', rawurlencode( $this->stylesheet ) );\n\t}\n\n\t/**\n\t * Returns the URL to the directory of a theme's \"template\" files.\n\t *\n\t * In the case of a child theme, this is the URL to the directory of the\n\t * parent theme's files.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string URL to the template directory.\n\t */\n\tpublic function get_template_directory_uri() {\n\t\tif ( $this->parent() )\n\t\t\t$theme_root_uri = $this->parent()->get_theme_root_uri();\n\t\telse\n\t\t\t$theme_root_uri = $this->get_theme_root_uri();\n\n\t\treturn $theme_root_uri . '/' . str_replace( '%2F', '/', rawurlencode( $this->template ) );\n\t}\n\n\t/**\n\t * The absolute path to the directory of the theme root.\n\t *\n\t * This is typically the absolute path to wp-content/themes.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Theme root.\n\t */\n\tpublic function get_theme_root() {\n\t\treturn $this->theme_root;\n\t}\n\n\t/**\n\t * Returns the URL to the directory of the theme root.\n\t *\n\t * This is typically the absolute URL to wp-content/themes. This forms the basis\n\t * for all other URLs returned by WP_Theme, so we pass it to the public function\n\t * get_theme_root_uri() and allow it to run the {@see 'theme_root_uri'} filter.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Theme root URI.\n\t */\n\tpublic function get_theme_root_uri() {\n\t\tif ( ! isset( $this->theme_root_uri ) )\n\t\t\t$this->theme_root_uri = get_theme_root_uri( $this->stylesheet, $this->theme_root );\n\t\treturn $this->theme_root_uri;\n\t}\n\n\t/**\n\t * Returns the main screenshot file for the theme.\n\t *\n\t * The main screenshot is called screenshot.png. gif and jpg extensions are also allowed.\n\t *\n\t * Screenshots for a theme must be in the stylesheet directory. (In the case of child\n\t * themes, parent theme screenshots are not inherited.)\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param string $uri Type of URL to return, either 'relative' or an absolute URI. Defaults to absolute URI.\n\t * @return string|false Screenshot file. False if the theme does not have a screenshot.\n\t */\n\tpublic function get_screenshot( $uri = 'uri' ) {\n\t\t$screenshot = $this->cache_get( 'screenshot' );\n\t\tif ( $screenshot ) {\n\t\t\tif ( 'relative' == $uri )\n\t\t\t\treturn $screenshot;\n\t\t\treturn $this->get_stylesheet_directory_uri() . '/' . $screenshot;\n\t\t} elseif ( 0 === $screenshot ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tforeach ( array( 'png', 'gif', 'jpg', 'jpeg' ) as $ext ) {\n\t\t\tif ( file_exists( $this->get_stylesheet_directory() . \"/screenshot.$ext\" ) ) {\n\t\t\t\t$this->cache_add( 'screenshot', 'screenshot.' . $ext );\n\t\t\t\tif ( 'relative' == $uri )\n\t\t\t\t\treturn 'screenshot.' . $ext;\n\t\t\t\treturn $this->get_stylesheet_directory_uri() . '/' . 'screenshot.' . $ext;\n\t\t\t}\n\t\t}\n\n\t\t$this->cache_add( 'screenshot', 0 );\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return files in the theme's directory.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param mixed $type Optional. Array of extensions to return. Defaults to all files (null).\n\t * @param int $depth Optional. How deep to search for files. Defaults to a flat scan (0 depth). -1 depth is infinite.\n\t * @param bool $search_parent Optional. Whether to return parent files. Defaults to false.\n\t * @return array Array of files, keyed by the path to the file relative to the theme's directory, with the values\n\t * \t             being absolute paths.\n\t */\n\tpublic function get_files( $type = null, $depth = 0, $search_parent = false ) {\n\t\t$files = (array) self::scandir( $this->get_stylesheet_directory(), $type, $depth );\n\n\t\tif ( $search_parent && $this->parent() )\n\t\t\t$files += (array) self::scandir( $this->get_template_directory(), $type, $depth );\n\n\t\treturn $files;\n\t}\n\n\t/**\n\t * Returns the theme's post templates.\n\t *\n\t * @since 4.7.0\n\t * @access public\n\t *\n\t * @return array Array of page templates, keyed by filename and post type,\n\t *               with the value of the translated header name.\n\t */\n\tpublic function get_post_templates() {\n\t\t// If you screw up your current theme and we invalidate your parent, most things still work. Let it slide.\n\t\tif ( $this->errors() && $this->errors()->get_error_codes() !== array( 'theme_parent_invalid' ) ) {\n\t\t\treturn array();\n\t\t}\n\n\t\t$post_templates = $this->cache_get( 'post_templates' );\n\n\t\tif ( ! is_array( $post_templates ) ) {\n\t\t\t$post_templates = array();\n\n\t\t\t$files = (array) $this->get_files( 'php', 1 );\n\n\t\t\tforeach ( $files as $file => $full_path ) {\n\t\t\t\tif ( ! preg_match( '|Template Name:(.*)$|mi', file_get_contents( $full_path ), $header ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$types = array( 'page' );\n\t\t\t\tif ( preg_match( '|Template Post Type:(.*)$|mi', file_get_contents( $full_path ), $type ) ) {\n\t\t\t\t\t$types = explode( ',', _cleanup_header_comment( $type[1] ) );\n\t\t\t\t}\n\n\t\t\t\tforeach ( $types as $type ) {\n\t\t\t\t\t$type = sanitize_key( $type );\n\t\t\t\t\tif ( ! isset( $post_templates[ $type ] ) ) {\n\t\t\t\t\t\t$post_templates[ $type ] = array();\n\t\t\t\t\t}\n\n\t\t\t\t\t$post_templates[ $type ][ $file ] = _cleanup_header_comment( $header[1] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$this->cache_add( 'post_templates', $post_templates );\n\t\t}\n\n\t\tif ( $this->load_textdomain() ) {\n\t\t\tforeach ( $post_templates as &$post_type ) {\n\t\t\t\tforeach ( $post_type as &$post_template ) {\n\t\t\t\t\t$post_template = $this->translate_header( 'Template Name', $post_template );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $post_templates;\n\t}\n\n\t/**\n\t * Returns the theme's post templates for a given post type.\n\t *\n\t * @since 3.4.0\n\t * @since 4.7.0 Added the `$post_type` parameter.\n\t * @access public\n\t *\n\t * @param WP_Post|null $post      Optional. The post being edited, provided for context.\n\t * @param string       $post_type Optional. Post type to get the templates for. Default 'page'.\n\t *                                If a post is provided, its post type is used.\n\t * @return array Array of page templates, keyed by filename, with the value of the translated header name.\n\t */\n\tpublic function get_page_templates( $post = null, $post_type = 'page' ) {\n\t\tif ( $post ) {\n\t\t\t$post_type = get_post_type( $post );\n\t\t}\n\n\t\t$post_templates = $this->get_post_templates();\n\t\t$post_templates = isset( $post_templates[ $post_type ] ) ? $post_templates[ $post_type ] : array();\n\n\t\tif ( $this->parent() ) {\n\t\t\t$post_templates += $this->parent()->get_page_templates( $post, $post_type );\n\t\t}\n\n\t\t/**\n\t\t * Filters list of page templates for a theme.\n\t\t *\n\t\t * The dynamic portion of the hook name, `$post_type`, refers to the post type.\n\t\t *\n\t\t * @since 3.9.0\n\t\t * @since 4.4.0 Converted to allow complete control over the `$page_templates` array.\n\t\t * @since 4.7.0 Added the `$post_type` parameter.\n\t\t *\n\t\t * @param array        $post_templates Array of page templates. Keys are filenames,\n\t\t *                                     values are translated names.\n\t\t * @param WP_Theme     $this           The theme object.\n\t\t * @param WP_Post|null $post           The post being edited, provided for context, or null.\n\t\t * @param string       $post_type      Post type to get the templates for.\n\t\t */\n\t\treturn (array) apply_filters( \"theme_{$post_type}_templates\", $post_templates, $this, $post, $post_type );\n\t}\n\n\t/**\n\t * Scans a directory for files of a certain extension.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access private\n\t *\n\t * @param string            $path          Absolute path to search.\n\t * @param array|string|null $extensions    Optional. Array of extensions to find, string of a single extension,\n\t *                                         or null for all extensions. Default null.\n\t * @param int               $depth         Optional. How many levels deep to search for files. Accepts 0, 1+, or\n\t *                                         -1 (infinite depth). Default 0.\n\t * @param string            $relative_path Optional. The basename of the absolute path. Used to control the\n\t *                                         returned path for the found files, particularly when this function\n\t *                                         recurses to lower depths. Default empty.\n\t * @return array|false Array of files, keyed by the path to the file relative to the `$path` directory prepended\n\t *                     with `$relative_path`, with the values being absolute paths. False otherwise.\n\t */\n\tprivate static function scandir( $path, $extensions = null, $depth = 0, $relative_path = '' ) {\n\t\tif ( ! is_dir( $path ) )\n\t\t\treturn false;\n\n\t\tif ( $extensions ) {\n\t\t\t$extensions = (array) $extensions;\n\t\t\t$_extensions = implode( '|', $extensions );\n\t\t}\n\n\t\t$relative_path = trailingslashit( $relative_path );\n\t\tif ( '/' == $relative_path )\n\t\t\t$relative_path = '';\n\n\t\t$results = scandir( $path );\n\t\t$files = array();\n\n\t\tforeach ( $results as $result ) {\n\t\t\tif ( '.' == $result[0] )\n\t\t\t\tcontinue;\n\t\t\tif ( is_dir( $path . '/' . $result ) ) {\n\t\t\t\tif ( ! $depth || 'CVS' == $result )\n\t\t\t\t\tcontinue;\n\t\t\t\t$found = self::scandir( $path . '/' . $result, $extensions, $depth - 1 , $relative_path . $result );\n\t\t\t\t$files = array_merge_recursive( $files, $found );\n\t\t\t} elseif ( ! $extensions || preg_match( '~\\.(' . $_extensions . ')$~', $result ) ) {\n\t\t\t\t$files[ $relative_path . $result ] = $path . '/' . $result;\n\t\t\t}\n\t\t}\n\n\t\treturn $files;\n\t}\n\n\t/**\n\t * Loads the theme's textdomain.\n\t *\n\t * Translation files are not inherited from the parent theme. Todo: if this fails for the\n\t * child theme, it should probably try to load the parent theme's translations.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return bool True if the textdomain was successfully loaded or has already been loaded.\n\t * \tFalse if no textdomain was specified in the file headers, or if the domain could not be loaded.\n\t */\n\tpublic function load_textdomain() {\n\t\tif ( isset( $this->textdomain_loaded ) )\n\t\t\treturn $this->textdomain_loaded;\n\n\t\t$textdomain = $this->get('TextDomain');\n\t\tif ( ! $textdomain ) {\n\t\t\t$this->textdomain_loaded = false;\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( is_textdomain_loaded( $textdomain ) ) {\n\t\t\t$this->textdomain_loaded = true;\n\t\t\treturn true;\n\t\t}\n\n\t\t$path = $this->get_stylesheet_directory();\n\t\tif ( $domainpath = $this->get('DomainPath') )\n\t\t\t$path .= $domainpath;\n\t\telse\n\t\t\t$path .= '/languages';\n\n\t\t$this->textdomain_loaded = load_theme_textdomain( $textdomain, $path );\n\t\treturn $this->textdomain_loaded;\n\t}\n\n\t/**\n\t * Whether the theme is allowed (multisite only).\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param string $check Optional. Whether to check only the 'network'-wide settings, the 'site'\n\t * \tsettings, or 'both'. Defaults to 'both'.\n\t * @param int $blog_id Optional. Ignored if only network-wide settings are checked. Defaults to current site.\n\t * @return bool Whether the theme is allowed for the network. Returns true in single-site.\n\t */\n\tpublic function is_allowed( $check = 'both', $blog_id = null ) {\n\t\tif ( ! is_multisite() )\n\t\t\treturn true;\n\n\t\tif ( 'both' == $check || 'network' == $check ) {\n\t\t\t$allowed = self::get_allowed_on_network();\n\t\t\tif ( ! empty( $allowed[ $this->get_stylesheet() ] ) )\n\t\t\t\treturn true;\n\t\t}\n\n\t\tif ( 'both' == $check || 'site' == $check ) {\n\t\t\t$allowed = self::get_allowed_on_site( $blog_id );\n\t\t\tif ( ! empty( $allowed[ $this->get_stylesheet() ] ) )\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Determines the latest WordPress default theme that is installed.\n\t *\n\t * This hits the filesystem.\n\t *\n\t * @since  4.4.0\n\t *\n\t * @return WP_Theme|false Object, or false if no theme is installed, which would be bad.\n\t */\n\tpublic static function get_core_default_theme() {\n\t\tforeach ( array_reverse( self::$default_themes ) as $slug => $name ) {\n\t\t\t$theme = wp_get_theme( $slug );\n\t\t\tif ( $theme->exists() ) {\n\t\t\t\treturn $theme;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns array of stylesheet names of themes allowed on the site or network.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access public\n\t *\n\t * @param int $blog_id Optional. ID of the site. Defaults to the current site.\n\t * @return array Array of stylesheet names.\n\t */\n\tpublic static function get_allowed( $blog_id = null ) {\n\t\t/**\n\t\t * Filters the array of themes allowed on the network.\n\t\t *\n\t\t * Site is provided as context so that a list of network allowed themes can\n\t\t * be filtered further.\n\t\t *\n\t\t * @since 4.5.0\n\t\t *\n\t\t * @param array $allowed_themes An array of theme stylesheet names.\n\t\t * @param int   $blog_id        ID of the site.\n\t\t */\n\t\t$network = (array) apply_filters( 'network_allowed_themes', self::get_allowed_on_network(), $blog_id );\n\t\treturn $network + self::get_allowed_on_site( $blog_id );\n\t}\n\n\t/**\n\t * Returns array of stylesheet names of themes allowed on the network.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access public\n\t *\n\t * @staticvar array $allowed_themes\n\t *\n\t * @return array Array of stylesheet names.\n\t */\n\tpublic static function get_allowed_on_network() {\n\t\tstatic $allowed_themes;\n\t\tif ( ! isset( $allowed_themes ) ) {\n\t\t\t$allowed_themes = (array) get_site_option( 'allowedthemes' );\n\t\t}\n\n\t\t/**\n\t\t * Filters the array of themes allowed on the network.\n\t\t *\n\t\t * @since MU\n\t\t *\n\t\t * @param array $allowed_themes An array of theme stylesheet names.\n\t\t */\n\t\t$allowed_themes = apply_filters( 'allowed_themes', $allowed_themes );\n\n\t\treturn $allowed_themes;\n\t}\n\n\t/**\n\t * Returns array of stylesheet names of themes allowed on the site.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access public\n\t *\n\t * @staticvar array $allowed_themes\n\t *\n\t * @param int $blog_id Optional. ID of the site. Defaults to the current site.\n\t * @return array Array of stylesheet names.\n\t */\n\tpublic static function get_allowed_on_site( $blog_id = null ) {\n\t\tstatic $allowed_themes = array();\n\n\t\tif ( ! $blog_id || ! is_multisite() )\n\t\t\t$blog_id = get_current_blog_id();\n\n\t\tif ( isset( $allowed_themes[ $blog_id ] ) ) {\n\t\t\t/**\n\t\t\t * Filters the array of themes allowed on the site.\n\t\t\t *\n\t\t\t * @since 4.5.0\n\t\t\t *\n\t\t\t * @param array $allowed_themes An array of theme stylesheet names.\n\t\t\t * @param int   $blog_id        ID of the site. Defaults to current site.\n\t\t\t */\n\t\t\treturn (array) apply_filters( 'site_allowed_themes', $allowed_themes[ $blog_id ], $blog_id );\n\t\t}\n\n\t\t$current = $blog_id == get_current_blog_id();\n\n\t\tif ( $current ) {\n\t\t\t$allowed_themes[ $blog_id ] = get_option( 'allowedthemes' );\n\t\t} else {\n\t\t\tswitch_to_blog( $blog_id );\n\t\t\t$allowed_themes[ $blog_id ] = get_option( 'allowedthemes' );\n\t\t\trestore_current_blog();\n\t\t}\n\n\t\t// This is all super old MU back compat joy.\n\t\t// 'allowedthemes' keys things by stylesheet. 'allowed_themes' keyed things by name.\n\t\tif ( false === $allowed_themes[ $blog_id ] ) {\n\t\t\tif ( $current ) {\n\t\t\t\t$allowed_themes[ $blog_id ] = get_option( 'allowed_themes' );\n\t\t\t} else {\n\t\t\t\tswitch_to_blog( $blog_id );\n\t\t\t\t$allowed_themes[ $blog_id ] = get_option( 'allowed_themes' );\n\t\t\t\trestore_current_blog();\n\t\t\t}\n\n\t\t\tif ( ! is_array( $allowed_themes[ $blog_id ] ) || empty( $allowed_themes[ $blog_id ] ) ) {\n\t\t\t\t$allowed_themes[ $blog_id ] = array();\n\t\t\t} else {\n\t\t\t\t$converted = array();\n\t\t\t\t$themes = wp_get_themes();\n\t\t\t\tforeach ( $themes as $stylesheet => $theme_data ) {\n\t\t\t\t\tif ( isset( $allowed_themes[ $blog_id ][ $theme_data->get('Name') ] ) )\n\t\t\t\t\t\t$converted[ $stylesheet ] = true;\n\t\t\t\t}\n\t\t\t\t$allowed_themes[ $blog_id ] = $converted;\n\t\t\t}\n\t\t\t// Set the option so we never have to go through this pain again.\n\t\t\tif ( is_admin() && $allowed_themes[ $blog_id ] ) {\n\t\t\t\tif ( $current ) {\n\t\t\t\t\tupdate_option( 'allowedthemes', $allowed_themes[ $blog_id ] );\n\t\t\t\t\tdelete_option( 'allowed_themes' );\n\t\t\t\t} else {\n\t\t\t\t\tswitch_to_blog( $blog_id );\n\t\t\t\t\tupdate_option( 'allowedthemes', $allowed_themes[ $blog_id ] );\n\t\t\t\t\tdelete_option( 'allowed_themes' );\n\t\t\t\t\trestore_current_blog();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/** This filter is documented in wp-includes/class-wp-theme.php */\n\t\treturn (array) apply_filters( 'site_allowed_themes', $allowed_themes[ $blog_id ], $blog_id );\n\t}\n\n\t/**\n\t * Enables a theme for all sites on the current network.\n\t *\n\t * @since 4.6.0\n\t * @access public\n\t * @static\n\t *\n\t * @param string|array $stylesheets Stylesheet name or array of stylesheet names.\n\t */\n\tpublic static function network_enable_theme( $stylesheets ) {\n\t\tif ( ! is_multisite() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! is_array( $stylesheets ) ) {\n\t\t\t$stylesheets = array( $stylesheets );\n\t\t}\n\n\t\t$allowed_themes = get_site_option( 'allowedthemes' );\n\t\tforeach ( $stylesheets as $stylesheet ) {\n\t\t\t$allowed_themes[ $stylesheet ] = true;\n\t\t}\n\n\t\tupdate_site_option( 'allowedthemes', $allowed_themes );\n\t}\n\n\t/**\n\t * Disables a theme for all sites on the current network.\n\t *\n\t * @since 4.6.0\n\t * @access public\n\t * @static\n\t *\n\t * @param string|array $stylesheets Stylesheet name or array of stylesheet names.\n\t */\n\tpublic static function network_disable_theme( $stylesheets ) {\n\t\tif ( ! is_multisite() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! is_array( $stylesheets ) ) {\n\t\t\t$stylesheets = array( $stylesheets );\n\t\t}\n\n\t\t$allowed_themes = get_site_option( 'allowedthemes' );\n\t\tforeach ( $stylesheets as $stylesheet ) {\n\t\t\tif ( isset( $allowed_themes[ $stylesheet ] ) ) {\n\t\t\t\tunset( $allowed_themes[ $stylesheet ] );\n\t\t\t}\n\t\t}\n\n\t\tupdate_site_option( 'allowedthemes', $allowed_themes );\n\t}\n\n\t/**\n\t * Sorts themes by name.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access public\n\t *\n\t * @param array $themes Array of themes to sort, passed by reference.\n\t */\n\tpublic static function sort_by_name( &$themes ) {\n\t\tif ( 0 === strpos( get_user_locale(), 'en_' ) ) {\n\t\t\tuasort( $themes, array( 'WP_Theme', '_name_sort' ) );\n\t\t} else {\n\t\t\tuasort( $themes, array( 'WP_Theme', '_name_sort_i18n' ) );\n\t\t}\n\t}\n\n\t/**\n\t * Callback function for usort() to naturally sort themes by name.\n\t *\n\t * Accesses the Name header directly from the class for maximum speed.\n\t * Would choke on HTML but we don't care enough to slow it down with strip_tags().\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access private\n\t *\n\t * @param string $a First name.\n\t * @param string $b Second name.\n\t * @return int Negative if `$a` falls lower in the natural order than `$b`. Zero if they fall equally.\n\t *             Greater than 0 if `$a` falls higher in the natural order than `$b`. Used with usort().\n\t */\n\tprivate static function _name_sort( $a, $b ) {\n\t\treturn strnatcasecmp( $a->headers['Name'], $b->headers['Name'] );\n\t}\n\n\t/**\n\t * Name sort (with translation).\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access private\n\t *\n\t * @param string $a First name.\n\t * @param string $b Second name.\n\t * @return int Negative if `$a` falls lower in the natural order than `$b`. Zero if they fall equally.\n\t *             Greater than 0 if `$a` falls higher in the natural order than `$b`. Used with usort().\n\t */\n\tprivate static function _name_sort_i18n( $a, $b ) {\n\t\t// Don't mark up; Do translate.\n\t\treturn strnatcasecmp( $a->display( 'Name', false, true ), $b->display( 'Name', false, true ) );\n\t}\n}\n", "<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '4.8-alpha-39807';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 38590;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4403-20160901';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "filenames": ["wp-includes/class-wp-theme.php", "wp-includes/version.php"], "buggy_code_start_loc": [740, 7], "buggy_code_end_loc": [742, 8], "fixing_code_start_loc": [740, 7], "fixing_code_end_loc": [743, 8], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in the theme-name fallback functionality in wp-includes/class-wp-theme.php in WordPress before 4.7.1 allows remote attackers to inject arbitrary web script or HTML via a crafted directory name of a theme, related to wp-admin/includes/class-theme-installer-skin.php.", "other": {"cve": {"id": "CVE-2017-5490", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-15T02:59:02.937", "lastModified": "2017-11-04T01:29:43.727", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in the theme-name fallback functionality in wp-includes/class-wp-theme.php in WordPress before 4.7.1 allows remote attackers to inject arbitrary web script or HTML via a crafted directory name of a theme, related to wp-admin/includes/class-theme-installer-skin.php."}, {"lang": "es", "value": "Vulnerabilidad de XSS en la funcionalidad de retorno de nombre de tema en wp-includes/class-wp-theme.php en WordPress en versiones anteriores a 4.7.1 permite a atacantes remotos inyectar secuencias de comandos web o HTML arbitrarios a trav\u00e9s de un nombre de directorio manipulado de un tema, relacionado con wp-admin/includes/class-theme-installer-skin.php."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.7", "matchCriteriaId": "5C55F44C-4A71-4C47-9908-071A23D46939"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3779", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/14/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95402", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1037591", "source": "cve@mitre.org"}, {"url": "https://codex.wordpress.org/Version_4.7.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/WordPress/WordPress/commit/ce7fb2934dd111e6353784852de8aea2a938b359", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://wordpress.org/news/2017/01/wordpress-4-7-1-security-and-maintenance-release/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://wpvulndb.com/vulnerabilities/8718", "source": "cve@mitre.org"}, {"url": "https://www.mehmetince.net/low-severity-wordpress/", "source": "cve@mitre.org", "tags": ["Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/WordPress/WordPress/commit/ce7fb2934dd111e6353784852de8aea2a938b359"}}