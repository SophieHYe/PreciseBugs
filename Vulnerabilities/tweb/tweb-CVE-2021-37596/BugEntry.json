{"buggy_code": ["/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport { formatDateAccordingToToday, months } from \"../helpers/date\";\nimport { copy, getObjectKeysAndSort, safeAssign } from \"../helpers/object\";\nimport { escapeRegExp, limitSymbols } from \"../helpers/string\";\nimport appChatsManager from \"../lib/appManagers/appChatsManager\";\nimport appDialogsManager from \"../lib/appManagers/appDialogsManager\";\nimport appMessagesManager, { MyInputMessagesFilter, MyMessage } from \"../lib/appManagers/appMessagesManager\";\nimport appPeersManager from \"../lib/appManagers/appPeersManager\";\nimport appPhotosManager from \"../lib/appManagers/appPhotosManager\";\nimport appStateManager from \"../lib/appManagers/appStateManager\";\nimport appUsersManager from \"../lib/appManagers/appUsersManager\";\nimport { logger } from \"../lib/logger\";\nimport RichTextProcessor from \"../lib/richtextprocessor\";\nimport rootScope from \"../lib/rootScope\";\nimport AppMediaViewer from \"./appMediaViewer\";\nimport { SearchGroup, SearchGroupType } from \"./appSearch\";\nimport { horizontalMenu } from \"./horizontalMenu\";\nimport LazyLoadQueue from \"./lazyLoadQueue\";\nimport { putPreloader, formatPhoneNumber } from \"./misc\";\nimport { ripple } from \"./ripple\";\nimport Scrollable, { ScrollableX } from \"./scrollable\";\nimport { wrapDocument, wrapPhoto, wrapVideo } from \"./wrappers\";\nimport useHeavyAnimationCheck, { getHeavyAnimationPromise } from \"../hooks/useHeavyAnimationCheck\";\nimport { isSafari } from \"../helpers/userAgent\";\nimport { LangPackKey, i18n } from \"../lib/langPack\";\nimport findUpClassName from \"../helpers/dom/findUpClassName\";\nimport { getMiddleware } from \"../helpers/middleware\";\nimport appProfileManager from \"../lib/appManagers/appProfileManager\";\nimport { ChannelParticipant, ChatFull, ChatParticipant, ChatParticipants } from \"../layer\";\nimport SortedUserList from \"./sortedUserList\";\nimport findUpTag from \"../helpers/dom/findUpTag\";\nimport appSidebarRight from \"./sidebarRight\";\nimport mediaSizes from \"../helpers/mediaSizes\";\nimport appImManager from \"../lib/appManagers/appImManager\";\nimport positionElementByIndex from \"../helpers/dom/positionElementByIndex\";\nimport cleanSearchText from \"../helpers/cleanSearchText\";\n\n//const testScroll = false;\n\nexport type SearchSuperType = MyInputMessagesFilter/*  | 'members' */;\nexport type SearchSuperContext = {\n  peerId: number,\n  inputFilter: MyInputMessagesFilter,\n  query?: string,\n  maxId?: number,\n  folderId?: number,\n  threadId?: number,\n  date?: number,\n  nextRate?: number,\n  minDate?: number,\n  maxDate?: number\n};\n\nexport type SearchSuperMediaType = 'members' | 'media' | 'files' | 'links' | 'music' | 'chats' | 'voice';\nexport type SearchSuperMediaTab = {\n  inputFilter: SearchSuperType,\n  name: LangPackKey,\n  type: SearchSuperMediaType,\n  contentTab?: HTMLElement,\n  menuTab?: HTMLElement,\n  scroll?: {scrollTop: number, scrollHeight: number}\n};\n\nexport default class AppSearchSuper {\n  public tabs: {[t in SearchSuperType]: HTMLDivElement} = {} as any;\n\n  public mediaTab: SearchSuperMediaTab;\n\n  public container: HTMLElement;\n  public nav: HTMLElement;\n  private navScrollableContainer: HTMLDivElement;\n  private tabsContainer: HTMLElement;\n  private tabsMenu: HTMLElement;\n  private prevTabId = -1;\n  \n  private lazyLoadQueue = new LazyLoadQueue();\n  public middleware = getMiddleware();\n\n  public historyStorage: Partial<{[type in SearchSuperType]: {mid: number, peerId: number}[]}> = {};\n  public usedFromHistory: Partial<{[type in SearchSuperType]: number}> = {};\n  public urlsToRevoke: string[] = [];\n\n  private searchContext: SearchSuperContext;\n  public loadMutex: Promise<any> = Promise.resolve();\n\n  private nextRates: Partial<{[type in SearchSuperType]: number}> = {};\n  private loadPromises: Partial<{[type in SearchSuperType]: Promise<void>}> = {};\n  private loaded: Partial<{[type in SearchSuperType]: boolean}> = {};\n  private loadedChats = false;\n  private firstLoad = true;\n\n  private log = logger('SEARCH-SUPER');\n  public selectTab: ReturnType<typeof horizontalMenu>;\n  \n  private monthContainers: Partial<{\n    [type in SearchSuperType]: {\n      [timestamp: number]: {\n        container: HTMLElement,\n        items: HTMLElement\n      }\n    }\n  }> = {};\n\n  private searchGroupMedia: SearchGroup;\n\n  public mediaTabsMap: Map<SearchSuperMediaType, SearchSuperMediaTab> = new Map();\n\n  private membersList: SortedUserList;\n\n  private skipScroll: boolean;\n\n  // * arguments\n  public mediaTabs: SearchSuperMediaTab[];\n  public scrollable: Scrollable;\n  public searchGroups?: {[group in SearchGroupType]: SearchGroup};\n  public asChatList? = false;\n  public groupByMonth? = true;\n  public hideEmptyTabs? = true;\n  public onChangeTab?: (mediaTab: SearchSuperMediaTab) => void;\n  public showSender? = false;\n\n  constructor(options: Pick<AppSearchSuper, 'mediaTabs' | 'scrollable' | 'searchGroups' | 'asChatList' | 'groupByMonth' | 'hideEmptyTabs' | 'onChangeTab' | 'showSender'>) {\n    safeAssign(this, options);\n\n    this.container = document.createElement('div');\n    this.container.classList.add('search-super');\n\n    const navScrollableContainer = this.navScrollableContainer = document.createElement('div');\n    navScrollableContainer.classList.add('search-super-tabs-scrollable', 'menu-horizontal-scrollable', 'sticky');\n\n    const navScrollable = new ScrollableX(navScrollableContainer);\n\n    const nav = this.nav = document.createElement('nav');\n    nav.classList.add('search-super-tabs', 'menu-horizontal-div');\n    this.tabsMenu = nav;\n\n    navScrollable.container.append(nav);\n\n    for(const mediaTab of this.mediaTabs) {\n      const menuTab = document.createElement('div');\n      menuTab.classList.add('menu-horizontal-div-item');\n      const span = document.createElement('span');\n      const i = document.createElement('i');\n\n      span.append(i18n(mediaTab.name));\n      span.append(i);\n\n      menuTab.append(span);\n\n      ripple(menuTab);\n\n      this.tabsMenu.append(menuTab);\n\n      this.mediaTabsMap.set(mediaTab.type, mediaTab);\n\n      mediaTab.menuTab = menuTab;\n    }\n\n    this.tabsContainer = document.createElement('div');\n    this.tabsContainer.classList.add('search-super-tabs-container', 'tabs-container');\n\n    for(const mediaTab of this.mediaTabs) {\n      const container = document.createElement('div');\n      container.classList.add('search-super-container-' + mediaTab.type);\n\n      const content = document.createElement('div');\n      content.classList.add('search-super-content-' + mediaTab.type);\n\n      container.append(content);\n\n      this.tabsContainer.append(container);\n\n      this.tabs[mediaTab.inputFilter] = content;\n\n      mediaTab.contentTab = content;\n    }\n\n    this.container.append(navScrollableContainer, this.tabsContainer);\n\n    // * construct end\n\n    this.searchGroupMedia = new SearchGroup(false, 'messages', true);\n\n    this.scrollable.onScrolledBottom = () => {\n      if(this.mediaTab.contentTab && this.mediaTab.contentTab.childElementCount/* && false */) {\n        //this.log('onScrolledBottom will load media');\n        this.load(true);\n      }\n    };\n    //this.scroll.attachSentinels(undefined, 400);\n\n    this.selectTab = horizontalMenu(this.tabsMenu, this.tabsContainer, (id, tabContent, animate) => {\n      if(this.prevTabId === id && !this.skipScroll) {\n        this.scrollable.scrollIntoViewNew(this.container, 'start');\n        return;\n      }\n      \n      const newMediaTab = this.mediaTabs[id];\n      if(this.onChangeTab) {\n        this.onChangeTab(newMediaTab);\n      }\n      \n      const fromMediaTab = this.mediaTab;\n      this.mediaTab = newMediaTab;\n\n      if(this.prevTabId !== -1 && animate) {\n        this.onTransitionStart();\n      }\n\n      if(this.skipScroll) {\n        this.skipScroll = false;\n      } else {\n        const offsetTop = this.container.offsetTop;\n        let scrollTop = this.scrollable.scrollTop;\n        if(scrollTop < offsetTop) {\n          this.scrollable.scrollIntoViewNew(this.container, 'start');\n          scrollTop = offsetTop;\n        }\n        \n        fromMediaTab.scroll = {scrollTop: scrollTop, scrollHeight: this.scrollable.scrollHeight};\n  \n        if(newMediaTab.scroll === undefined) {\n          const rect = this.container.getBoundingClientRect();\n          const rect2 = this.container.parentElement.getBoundingClientRect();\n          const diff = rect.y - rect2.y;\n  \n          if(scrollTop > diff) {\n            newMediaTab.scroll = {scrollTop: diff, scrollHeight: 0};\n          }\n        }\n  \n        if(newMediaTab.scroll) {\n          const diff = fromMediaTab.scroll.scrollTop - newMediaTab.scroll.scrollTop;\n          //console.log('what you gonna do', this.goingHard, diff);\n  \n          //this.scrollable.scrollTop = scrollTop;\n          if(diff/*  && diff < 0 */) {\n            /* if(diff > -(fromMediaTab.contentTab.scrollHeight + this.nav.scrollHeight)) {\n              fromMediaTab.contentTab.style.transform = `translateY(${diff}px)`;\n              this.scrollable.scrollTop = scrollTop - diff;\n            } else { */\n              newMediaTab.contentTab.style.transform = `translateY(${diff}px)`;\n            //}\n          }\n        }\n      }\n      \n      /* if(this.prevTabId !== -1 && nav.offsetTop) {\n        this.scrollable.scrollTop -= nav.offsetTop;\n      } */\n\n      /* this.log('setVirtualContainer', id, this.sharedMediaSelected, this.sharedMediaSelected.childElementCount);\n      this.scroll.setVirtualContainer(this.sharedMediaSelected); */\n\n      if(this.prevTabId !== -1 && !newMediaTab.contentTab.childElementCount) { // quick brown fix\n        //this.contentContainer.classList.remove('loaded');\n        this.load(true);\n      }\n\n      this.prevTabId = id;\n    }, () => {\n      this.scrollable.onScroll();\n      \n      //console.log('what y', this.tabSelected.style.transform);\n      if(this.mediaTab.scroll !== undefined) {\n        this.mediaTab.contentTab.style.transform = '';\n        this.scrollable.scrollTop = this.mediaTab.scroll.scrollTop;\n      }\n\n      this.onTransitionEnd();\n    }, undefined, navScrollable);\n\n    this.tabs.inputMessagesFilterPhotoVideo.addEventListener('click', (e) => {\n      const target = findUpClassName(e.target as HTMLDivElement, 'grid-item');\n      \n      const mid = +target.dataset.mid;\n      if(!mid) {\n        this.log.warn('no messageId by click on target:', target);\n        return;\n      }\n\n      const peerId = +target.dataset.peerId;\n\n      const targets = (Array.from(this.tabs.inputMessagesFilterPhotoVideo.querySelectorAll('.grid-item')) as HTMLElement[]).map(el => {\n        return {element: el, mid: +el.dataset.mid, peerId: +el.dataset.peerId};\n      });\n\n      //const ids = Object.keys(this.mediaDivsByIds).map(k => +k).sort((a, b) => a - b);\n      const idx = targets.findIndex(item => item.mid === mid && item.peerId === peerId);\n      \n      const message = appMessagesManager.getMessageByPeer(peerId, mid);\n      new AppMediaViewer()\n      .setSearchContext(this.copySearchContext(this.mediaTab.inputFilter))\n      .openMedia(message, target, 0, false, targets.slice(0, idx), targets.slice(idx + 1));\n    });\n\n    this.mediaTab = this.mediaTabs[0];\n\n    useHeavyAnimationCheck(() => {\n      this.lazyLoadQueue.lock();\n    }, () => {\n      this.lazyLoadQueue.unlockAndRefresh(); // ! maybe not so efficient\n    });\n  }\n\n  private onTransitionStart = () => {\n    this.container.classList.add('sliding');\n  };\n\n  private onTransitionEnd = () => {\n    this.container.classList.remove('sliding');\n  };\n\n  public filterMessagesByType(messages: any[], type: SearchSuperType): MyMessage[] {\n    if(type === 'inputMessagesFilterEmpty') return messages;\n\n    if(type !== 'inputMessagesFilterUrl') {\n      messages = messages.filter(message => !!message.media);\n    }\n\n    /* if(!this.peerId) {\n      messages = messages.filter(message => {\n        if(message.peerId === rootScope.myId) {\n          return true;\n        }\n\n        const dialog = appMessagesManager.getDialogByPeerId(message.fromId)[0];\n        return dialog && dialog.folder_id === 0;\n      });\n    } */\n\n    let filtered: any[] = [];\n\n    switch(type) {\n      case 'inputMessagesFilterPhotoVideo': {\n        for(let message of messages) {\n          let media = message.media.photo || message.media.document || (message.media.webpage && message.media.webpage.document);\n          if(!media) {\n            //this.log('no media!', message);\n            continue;\n          }\n          \n          if(media._ === 'document' && media.type !== 'video'/*  && media.type !== 'gif' */) {\n            //this.log('broken video', media);\n            continue;\n          }\n\n          filtered.push(message);\n        }\n        \n        break;\n      }\n\n      case 'inputMessagesFilterDocument': {\n        for(let message of messages) {\n          if(!message.media.document || ['voice', 'audio', 'gif', 'sticker', 'round'].includes(message.media.document.type)) {\n            continue;\n          }\n          \n          filtered.push(message);\n        }\n        break;\n      }\n\n      case 'inputMessagesFilterUrl': {\n        //this.log('inputMessagesFilterUrl', messages);\n        for(let message of messages) {\n          //if((message.media.webpage && message.media.webpage._ !== 'webPageEmpty')) {\n            filtered.push(message);\n          //}\n        }\n        \n        break;\n      }\n\n      case 'inputMessagesFilterMusic': {\n        for(let message of messages) {\n          if(!message.media.document || message.media.document.type !== 'audio') {\n            continue;\n          }\n\n          filtered.push(message);\n        }\n\n        break;\n      }\n\n      case 'inputMessagesFilterVoice': {\n        for(let message of messages) {\n          if(!message.media.document || message.media.document.type !== 'voice') {\n            continue;\n          }\n\n          filtered.push(message);\n        }\n\n        break;\n      }\n\n      default:\n        break;\n    }\n\n    return filtered;\n  }\n  \n  public async performSearchResult(messages: any[], mediaTab: SearchSuperMediaTab, append = true) {\n    const elemsToAppend: {element: HTMLElement, message: any}[] = [];\n    const sharedMediaDiv: HTMLElement = mediaTab.contentTab;\n    const promises: Promise<any>[] = [];\n    const middleware = this.middleware.get();\n    let inputFilter = mediaTab.inputFilter;\n\n    await getHeavyAnimationPromise();\n    \n    let searchGroup: SearchGroup;\n    if(inputFilter === 'inputMessagesFilterPhotoVideo' && !!this.searchContext.query.trim()) {\n      inputFilter = 'inputMessagesFilterEmpty';\n      searchGroup = this.searchGroupMedia;\n      sharedMediaDiv.append(searchGroup.container);\n    } else if(inputFilter === 'inputMessagesFilterEmpty') {\n      searchGroup = this.searchGroups.messages;\n    }\n\n    // https://core.telegram.org/type/MessagesFilter\n    switch(inputFilter) {\n      case 'inputMessagesFilterEmpty': {\n        for(const message of messages) {\n          const {dialog, dom} = appDialogsManager.addDialogNew({\n            dialog: message.peerId, \n            container: searchGroup.list, \n            drawStatus: false,\n            avatarSize: 54\n          });\n          appDialogsManager.setLastMessage(dialog, message, dom, this.searchContext.query);\n        }\n\n        if(searchGroup.list.childElementCount) {\n          searchGroup.setActive();\n        }\n        break;\n      }\n\n      case 'inputMessagesFilterPhotoVideo': {\n        for(const message of messages) {\n          const media = message.media.photo || message.media.document || (message.media.webpage && message.media.webpage.document);\n\n          const div = document.createElement('div');\n          div.classList.add('grid-item');\n          //this.log(message, photo);\n\n          let wrapped: ReturnType<typeof wrapPhoto>;\n          const size = appPhotosManager.choosePhotoSize(media, 200, 200);\n          if(media._ !== 'photo') {\n            wrapped = wrapVideo({\n              doc: media,\n              message,\n              container: div,\n              boxWidth: 0,\n              boxHeight: 0,\n              lazyLoadQueue: this.lazyLoadQueue,\n              middleware,\n              onlyPreview: true,\n              withoutPreloader: true,\n              noPlayButton: true,\n              size\n            }).thumb;\n          } else {\n            wrapped = wrapPhoto({\n              photo: media,\n              message,\n              container: div,\n              boxWidth: 0,\n              boxHeight: 0,\n              lazyLoadQueue: this.lazyLoadQueue,\n              middleware,\n              withoutPreloader: true,\n              noBlur: true,\n              size\n            });\n          }\n\n          [wrapped.images.thumb, wrapped.images.full].filter(Boolean).forEach(image => {\n            image.classList.add('grid-item-media');\n          });\n\n          promises.push(wrapped.loadPromises.thumb);\n\n          elemsToAppend.push({element: div, message});\n        }\n        \n        break;\n      }\n      \n      case 'inputMessagesFilterVoice':\n      case 'inputMessagesFilterMusic':\n      case 'inputMessagesFilterDocument': {\n        for(const message of messages) {\n          const showSender = this.showSender || message.media.document.type === 'voice';\n          const div = wrapDocument({\n            message,\n            withTime: !showSender,\n            fontWeight: 400,\n            voiceAsMusic: true,\n            showSender: showSender,\n            searchContext: this.copySearchContext(inputFilter)\n          });\n\n          if(['audio', 'voice'].includes(message.media.document.type)) {\n            div.classList.add('audio-48');\n          }\n\n          elemsToAppend.push({element: div, message});\n        }\n        break;\n      }\n      \n      case 'inputMessagesFilterUrl': {\n        for(let message of messages) {\n          let webpage: any;\n\n          if(message.media?.webpage && message.media.webpage._ !== 'webPageEmpty') {\n            webpage = message.media.webpage;\n          } else {\n            const entity = message.totalEntities ? message.totalEntities.find((e: any) => e._ === 'messageEntityUrl' || e._ === 'messageEntityTextUrl') : null;\n            let url: string, display_url: string, sliced: string;\n\n            if(!entity) {\n              //this.log.error('NO ENTITY:', message);\n              const match = RichTextProcessor.matchUrl(message.message);\n              if(!match) {\n                //this.log.error('NO ENTITY AND NO MATCH:', message);\n                continue;\n              }\n\n              url = match[0];\n            } else {\n              sliced = message.message.slice(entity.offset, entity.offset + entity.length);\n            }\n\n            if(entity?._ === 'messageEntityTextUrl') {\n              url = entity.url;\n              //display_url = sliced;\n            } else {\n              url = url || sliced;\n            }\n\n            display_url = url;\n\n            const same = message.message === url;\n            if(!url.match(/^(ftp|http|https):\\/\\//)) {\n              display_url = 'https://' + url;\n              url = url.includes('@') ? url : 'https://' + url;\n            }\n\n            display_url = new URL(display_url).hostname;\n\n            webpage = {\n              url,\n              display_url\n            };\n\n            if(!same) {\n              webpage.description = message.message;\n              webpage.rDescription = RichTextProcessor.wrapRichText(limitSymbols(message.message, 150, 180));\n            }\n          }\n\n          let div = document.createElement('div');\n          \n          let previewDiv = document.createElement('div');\n          previewDiv.classList.add('preview');\n          \n          //this.log('wrapping webpage', webpage);\n          \n          if(webpage.photo) {\n            const res = wrapPhoto({\n              container: previewDiv,\n              message: null,\n              photo: webpage.photo,\n              boxWidth: 0,\n              boxHeight: 0,\n              withoutPreloader: true,\n              lazyLoadQueue: this.lazyLoadQueue,\n              middleware,\n              size: appPhotosManager.choosePhotoSize(webpage.photo, 60, 60, false),\n              loadPromises: promises,\n              noBlur: true\n            });\n          } else {\n            previewDiv.classList.add('empty');\n            previewDiv.innerHTML = RichTextProcessor.getAbbreviation(webpage.title || webpage.display_url || webpage.description || webpage.url, true);\n          }\n          \n          let title = webpage.rTitle || '';\n          let subtitle = webpage.rDescription || '';\n          let url = RichTextProcessor.wrapRichText(webpage.url || '');\n          \n          if(!title) {\n            //title = new URL(webpage.url).hostname;\n            title = RichTextProcessor.wrapPlainText(webpage.display_url.split('/', 1)[0]);\n          }\n\n          let sender = this.showSender ? `<div class=\"subtitle sender\">${appMessagesManager.getSenderToPeerText(message)}</div>` : '';\n\n          let titleAdditionHTML = '';\n          if(this.showSender) {\n            titleAdditionHTML = `<div class=\"sent-time\">${formatDateAccordingToToday(new Date(message.date * 1000))}</div>`;\n          }\n\n          div.append(previewDiv);\n          div.insertAdjacentHTML('beforeend', `\n          <div class=\"title\">${title}${titleAdditionHTML}</div>\n          <div class=\"subtitle\">${subtitle}</div>\n          <div class=\"url\">${url}</div>\n          ${sender}\n          `);\n          \n          if(div.innerText.trim().length) {\n            elemsToAppend.push({element: div, message});\n          }\n          \n        }\n        \n        break;\n      }\n\n      default:\n        //this.log.warn('death is my friend', messages);\n        break;\n    }\n\n    if(this.loadMutex) {\n      promises.push(this.loadMutex);\n    }\n\n    if(promises.length) {\n      await Promise.all(promises);\n      if(!middleware()) {\n        //this.log.warn('peer changed');\n        return;\n      }\n    }\n    \n    if(elemsToAppend.length) {\n      const method = append ? 'append' : 'prepend';\n      elemsToAppend.forEach(details => {\n        const {element, message} = details;\n        const monthContainer = this.getMonthContainerByTimestamp(this.groupByMonth ? message.date : 0, inputFilter);\n        element.classList.add('search-super-item');\n        element.dataset.mid = '' + message.mid;\n        element.dataset.peerId = '' + message.peerId;\n        monthContainer.items[method](element);\n      });\n    }\n    \n    //if(type !== 'inputMessagesFilterEmpty') {\n      this.afterPerforming(inputFilter === 'inputMessagesFilterEmpty' ? 1 : messages.length, sharedMediaDiv);\n    //}\n  }\n\n  private afterPerforming(length: number, contentTab: HTMLElement) {\n    if(contentTab) {\n      const parent = contentTab.parentElement;\n      Array.from(parent.children).slice(1).forEach(child => {\n        child.remove();\n      });\n\n      //this.contentContainer.classList.add('loaded');\n\n      if(!length && !contentTab.childElementCount) {\n        const div = document.createElement('div');\n        div.innerText = 'Nothing interesting here yet...';\n        div.classList.add('position-center', 'text-center', 'content-empty', 'no-select');\n\n        parent.append(div);\n      }\n    }\n  }\n\n  private loadChats() {\n    const renderedPeerIds: Set<number> = new Set();\n    const middleware = this.middleware.get();\n\n    for(let i in this.searchGroups) {\n      const group = this.searchGroups[i as SearchGroupType];\n      this.tabs.inputMessagesFilterEmpty.append(group.container);\n      group.clear();\n    }\n\n    const query = this.searchContext.query;\n    if(query) {\n      const setResults = (results: number[], group: SearchGroup, showMembersCount = false) => {\n        results.forEach((peerId) => {\n          if(renderedPeerIds.has(peerId)) {\n            return;\n          }\n  \n          renderedPeerIds.add(peerId);\n  \n          const peer = appPeersManager.getPeer(peerId);\n  \n          //////////this.log('contacts peer', peer);\n  \n          const {dom} = appDialogsManager.addDialogNew({\n            dialog: peerId, \n            container: group.list, \n            drawStatus: false,\n            avatarSize: 48,\n            autonomous: group.autonomous\n          });\n  \n          if(showMembersCount && (peer.participants_count || peer.participants)) {\n            const regExp = new RegExp(`(${escapeRegExp(query)}|${escapeRegExp(cleanSearchText(query))})`, 'gi');\n            dom.titleSpan.innerHTML = dom.titleSpan.innerHTML.replace(regExp, '<i>$1</i>');\n            dom.lastMessageSpan.append(appProfileManager.getChatMembersString(-peerId));\n          } else if(peerId === rootScope.myId) {\n            dom.lastMessageSpan.append(i18n('Presence.YourChat'));\n          } else {\n            let username = appPeersManager.getPeerUsername(peerId);\n            if(!username) {\n              const user = appUsersManager.getUser(peerId);\n              if(user && user.phone) {\n                username = '+' + formatPhoneNumber(user.phone).formatted;\n              }\n            } else {\n              username = '@' + username;\n            }\n  \n            dom.lastMessageSpan.innerHTML = '<i>' + username + '</i>';\n          }\n        });\n  \n        group.toggle();\n      };\n  \n      const onLoad = <T>(arg: T) => {\n        if(!middleware()) {\n          return;\n        }\n  \n        //this.loadedContacts = true;\n  \n        return arg;\n      };\n  \n      return Promise.all([\n        appUsersManager.getContacts(query, true)\n        .then(onLoad)\n        .then((contacts) => {\n          if(contacts) {\n            setResults(contacts, this.searchGroups.contacts, true);\n          }\n        }),\n  \n        appUsersManager.searchContacts(query, 20)\n        .then(onLoad)\n        .then((contacts) => {\n          if(contacts) {\n            setResults(contacts.my_results, this.searchGroups.contacts, true);\n            setResults(contacts.results/* .concat(contacts.results, contacts.results, contacts.results) */, this.searchGroups.globalContacts);\n\n            if(this.searchGroups.globalContacts.nameEl.lastElementChild) {\n              this.searchGroups.globalContacts.nameEl.lastElementChild.remove();\n            }\n\n            this.searchGroups.globalContacts.container.classList.add('is-short');\n            \n            if(this.searchGroups.globalContacts.list.childElementCount > 3) {\n              const showMore = document.createElement('div');\n              showMore.classList.add('search-group__show-more');\n              showMore.innerText = 'Show more';\n              this.searchGroups.globalContacts.nameEl.append(showMore);\n              showMore.addEventListener('click', () => {\n                const isShort = this.searchGroups.globalContacts.container.classList.toggle('is-short');\n                showMore.innerText = isShort ? 'Show more' : 'Show less';\n              });\n            }\n          }\n        }),\n  \n        appMessagesManager.getConversations(query, 0, 20, 0)\n        .then(onLoad)\n        .then(value => {\n          if(value) {\n            setResults(value.dialogs.map(d => d.peerId), this.searchGroups.contacts, true);\n          }\n        })\n      ]);\n    } else if(!this.searchContext.peerId && !this.searchContext.minDate) {\n      const renderRecentSearch = (setActive = true) => {\n        return appStateManager.getState().then(state => {\n          if(!middleware()) {\n            return;\n          }\n    \n          this.searchGroups.recent.list.innerHTML = '';\n    \n          state.recentSearch.slice(0, 20).forEach(peerId => {\n            let {dialog, dom} = appDialogsManager.addDialogNew({\n              dialog: peerId,\n              container: this.searchGroups.recent.list,\n              drawStatus: false,\n              meAsSaved: true,\n              avatarSize: 48,\n              autonomous: true\n            });\n    \n            dom.lastMessageSpan.append(peerId > 0 ? appUsersManager.getUserStatusString(peerId) : appProfileManager.getChatMembersString(-peerId));\n          });\n    \n          if(!state.recentSearch.length) {\n            this.searchGroups.recent.clear();\n          } else if(setActive) {\n            this.searchGroups.recent.setActive();\n          }\n        });\n      };\n\n      return Promise.all([\n        appUsersManager.getTopPeers().then(peers => {\n          if(!middleware()) return;\n\n          const idx = peers.indexOf(rootScope.myId);\n          if(idx !== -1) {\n            peers = peers.slice();\n            peers.splice(idx, 1);\n          }\n          //console.log('got top categories:', categories);\n          if(peers.length) {\n            peers.forEach((peerId) => {\n              appDialogsManager.addDialogNew({\n                dialog: peerId, \n                container: this.searchGroups.people.list, \n                drawStatus: false,\n                onlyFirstName: true,\n                avatarSize: 54,\n                autonomous: false\n              });\n            });\n          }\n    \n          this.searchGroups.people.setActive();\n        }),\n\n        renderRecentSearch()\n      ]);\n    } else return Promise.resolve();\n  }\n\n  private loadMembers(mediaTab: SearchSuperMediaTab) {\n    const id = -this.searchContext.peerId;\n    const middleware = this.middleware.get();\n    let promise: Promise<void>;\n\n    const renderParticipants = async(participants: (ChatParticipant | ChannelParticipant)[]) => {\n      if(this.loadMutex) {\n        await this.loadMutex;\n\n        if(!middleware()) {\n          return;\n        }\n      }\n      \n      if(!this.membersList) {\n        this.membersList = new SortedUserList();\n        this.membersList.lazyLoadQueue = this.lazyLoadQueue;\n        this.membersList.list.addEventListener('click', (e) => {\n          const li = findUpTag(e.target, 'LI');\n          if(!li) {\n            return;\n          }\n\n          const peerId = +li.dataset.peerId;\n          let promise: Promise<any> = Promise.resolve();\n          if(mediaSizes.isMobile) {\n            promise = appSidebarRight.toggleSidebar(false);\n          }\n          \n          promise.then(() => {\n            appImManager.setInnerPeer(peerId);\n          });\n        });\n        mediaTab.contentTab.append(this.membersList.list);\n        this.afterPerforming(1, mediaTab.contentTab);\n      }\n\n      participants.forEach(participant => {\n        const peerId = appChatsManager.getParticipantPeerId(participant);\n        if(peerId < 0) {\n          return;\n        }\n\n        const user = appUsersManager.getUser(peerId);\n        if(user.pFlags.deleted) {\n          return;\n        }\n\n        this.membersList.add(peerId);\n      });\n    };\n\n    if(appChatsManager.isChannel(id)) {\n      const LOAD_COUNT = !this.membersList ? 50 : 200;\n      promise = appProfileManager.getChannelParticipants(id, undefined, LOAD_COUNT, this.nextRates[mediaTab.inputFilter]).then(participants => {\n        if(!middleware()) {\n          return;\n        }\n\n        let list = mediaTab.contentTab.firstElementChild as HTMLUListElement;\n        this.nextRates[mediaTab.inputFilter] = (list ? list.childElementCount : 0) + participants.participants.length;\n\n        if(participants.participants.length < LOAD_COUNT) {\n          this.loaded[mediaTab.inputFilter] = true;\n        }\n\n        return renderParticipants(participants.participants);\n      });\n    } else {\n      promise = (appProfileManager.getChatFull(id) as Promise<ChatFull.chatFull>).then(chatFull => {\n        if(!middleware()) {\n          return;\n        }\n\n        //console.log('anymore', chatFull);\n        this.loaded[mediaTab.inputFilter] = true;\n        const participants = chatFull.participants;\n        if(participants._ === 'chatParticipantsForbidden') {\n          return;\n        }\n        \n        return renderParticipants(participants.participants);\n      });\n    }\n\n    return this.loadPromises[mediaTab.inputFilter] = promise.finally(() => { \n      if(!middleware()) {\n        return;\n      }\n\n      this.loadPromises[mediaTab.inputFilter] = null;\n    });\n  }\n\n  private loadType(mediaTab: SearchSuperMediaTab, justLoad: boolean, loadCount: number, middleware: () => boolean) {\n    const type = mediaTab.inputFilter;\n\n    if(this.loadPromises[type]) {\n      return this.loadPromises[type];\n    }\n\n    if(mediaTab.type === 'members') {\n      return this.loadMembers(mediaTab);\n    }\n\n    const history = this.historyStorage[type] ?? (this.historyStorage[type] = []);\n\n    if(type === 'inputMessagesFilterEmpty' && !history.length) {\n      if(!this.loadedChats) {\n        this.loadChats();\n        this.loadedChats = true;\n      }\n\n      if(!this.searchContext.query.trim() && !this.searchContext.peerId && !this.searchContext.minDate) {\n        this.loaded[type] = true;\n        return Promise.resolve();\n      }\n    }\n\n    const logStr = 'load [' + type + ']: ';\n\n    // render from cache\n    if(history.length && this.usedFromHistory[type] < history.length && !justLoad) {\n      let messages: any[] = [];\n      let used = Math.max(0, this.usedFromHistory[type]);\n      let slicedLength = 0;\n\n      do {\n        let ids = history.slice(used, used + loadCount);\n        //this.log(logStr + 'will render from cache', used, history, ids, loadCount);\n        used += ids.length;\n        slicedLength += ids.length;\n\n        messages.push(...this.filterMessagesByType(ids.map(m => appMessagesManager.getMessageByPeer(m.peerId, m.mid)), type));\n      } while(slicedLength < loadCount && used < history.length);\n      \n      // \u0435\u0441\u043b\u0438 \u043f\u0435\u0440\u0435\u0431\u043e\u0440\n      /* if(slicedLength > loadCount) {\n        let diff = messages.length - loadCount;\n        messages = messages.slice(0, messages.length - diff);\n        used -= diff;\n      } */\n\n      this.usedFromHistory[type] = used;\n      //if(messages.length) {\n        return this.performSearchResult(messages, mediaTab).finally(() => {\n          setTimeout(() => {\n            this.scrollable.checkForTriggers();\n          }, 0);\n        });\n      //}\n\n      return Promise.resolve();\n    }\n    \n    let maxId = history.length ? history[history.length - 1].mid : 0;\n    \n    //this.log(logStr + 'search house of glass pre', type, maxId);\n    \n    //let loadCount = history.length ? 50 : 15;\n    return this.loadPromises[type] = appMessagesManager.getSearch({\n      peerId: this.searchContext.peerId, \n      query: this.searchContext.query,\n      inputFilter: {_: type},\n      maxId, \n      limit: loadCount,\n      nextRate: this.nextRates[type] ?? (this.nextRates[type] = 0),\n      threadId: this.searchContext.threadId,\n      folderId: this.searchContext.folderId,\n      minDate: this.searchContext.minDate,\n      maxDate: this.searchContext.maxDate\n    }).then(value => {\n      history.push(...value.history.map(m => ({mid: m.mid, peerId: m.peerId})));\n      \n      this.log(logStr + 'search house of glass', type, value);\n\n      if(!middleware()) {\n        //this.log.warn('peer changed');\n        return;\n      }\n\n      // ! \u0424\u0438\u043a\u0441 \u0441\u043b\u0443\u0447\u0430\u044f, \u043a\u043e\u0433\u0434\u0430 \u043d\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u044e\u0442\u0441\u044f \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u044b \u043f\u0440\u0438 \u043e\u0442\u043a\u0440\u044b\u0442\u043e\u0439 \u043f\u0430\u043d\u0435\u043b\u0438 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u0432 (\u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0438\u0437-\u0437\u0430 \u0442\u043e\u0433\u043e, \u0447\u0442\u043e \u043d\u0435 \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u044e\u0442 \u043a\u0440\u0438\u0442\u0435\u0440\u0438\u0438 \u043e\u0442\u0431\u043e\u0440\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u0432 getSearch)\n      if(value.history.length < loadCount) {\n      //if((value.count || history.length === value.count) && history.length >= value.count) {\n        //this.log(logStr + 'loaded all media', value, loadCount);\n        this.loaded[type] = true;\n      }\n\n      this.nextRates[type] = value.next_rate;\n\n      if(justLoad) {\n        return Promise.resolve();\n      }\n\n      this.usedFromHistory[type] = history.length;\n\n      if(!this.loaded[type]) {\n        (this.loadPromises[type] || Promise.resolve()).then(() => {\n          setTimeout(() => {\n            if(!middleware()) return;\n            //this.log('will preload more');\n            if(this.mediaTab === mediaTab) {\n              const promise = this.load(true, true);\n              if(promise) {\n                promise.then(() => {\n                  if(!middleware()) return;\n                  //this.log('preloaded more');\n                  setTimeout(() => {\n                    this.scrollable.checkForTriggers();\n                  }, 0);\n                });\n              }\n            }\n          }, 0);\n        });\n      }\n\n      //if(value.history.length) {\n        return this.performSearchResult(this.filterMessagesByType(value.history, type), mediaTab);\n      //}\n    }).catch(err => {\n      this.log.error('load error:', err);\n    }).finally(() => {\n      this.loadPromises[type] = null;\n    });\n  }\n  \n  public async load(single = false, justLoad = false) {\n    // if(testScroll/*  || 1 === 1 */) {\n    //   return;\n    // }\n\n    //return;\n    \n    const peerId = this.searchContext.peerId;\n    this.log('load', single, peerId, this.loadPromises);\n    const middleware = this.middleware.get();\n\n    if(this.firstLoad) {\n      if(this.hideEmptyTabs) {\n        const mediaTabs = this.mediaTabs.filter(mediaTab => mediaTab.inputFilter !== 'inputMessagesFilterEmpty')\n        const filters = mediaTabs.map(mediaTab => ({_: mediaTab.inputFilter}));\n\n        const counters = await appMessagesManager.getSearchCounters(peerId, filters);\n        if(!middleware()) {\n          return;\n        }\n\n        if(this.loadMutex) {\n          await this.loadMutex;\n\n          if(!middleware()) {\n            return;\n          }\n        }\n\n        let firstMediaTab: SearchSuperMediaTab;\n        let count = 0;\n        mediaTabs.forEach(mediaTab => {\n          const counter = counters.find(c => c.filter._ === mediaTab.inputFilter);\n\n          mediaTab.menuTab.classList.toggle('hide', !counter.count);\n          mediaTab.menuTab.classList.remove('active');\n          //mediaTab.contentTab.classList.toggle('hide', !counter.count);\n\n          if(counter.count && firstMediaTab === undefined) {\n            firstMediaTab = mediaTab;\n          }\n\n          if(counter.count) ++count;\n        });\n\n        const membersTab = this.mediaTabsMap.get('members');\n        const canViewMembers = this.canViewMembers();\n        membersTab.menuTab.classList.toggle('hide', !canViewMembers);\n\n        if(canViewMembers) {\n          firstMediaTab = membersTab;\n        }\n\n        this.container.classList.toggle('hide', !firstMediaTab);\n        this.container.parentElement.classList.toggle('search-empty', !firstMediaTab);\n        if(firstMediaTab) {\n          this.skipScroll = true;\n          this.selectTab(this.mediaTabs.indexOf(firstMediaTab), false);\n          firstMediaTab.menuTab.classList.add('active');\n\n          this.navScrollableContainer.classList.toggle('hide', count <= 1);\n        }\n      }\n\n      this.firstLoad = false;\n    }\n    \n    let toLoad = single ? [this.mediaTab] : this.mediaTabs.filter(t => t !== this.mediaTab);\n    toLoad = toLoad.filter(mediaTab => {\n      const inputFilter = mediaTab.inputFilter;\n      return !this.loaded[inputFilter] || (this.historyStorage[inputFilter] && this.usedFromHistory[inputFilter] < this.historyStorage[inputFilter].length);\n    });\n\n    if(peerId > 0) {\n      toLoad.findAndSplice(mediaTab => mediaTab.type === 'members');\n    }\n\n    if(!toLoad.length) {\n      return;\n    }\n\n    const loadCount = justLoad ? 50 : Math.round((appPhotosManager.windowH / 130 | 0) * 3 * 1.25); // that's good for all types\n\n    const promises: Promise<any>[] = toLoad.map(mediaTab => {\n      return this.loadType(mediaTab, justLoad, loadCount, middleware)\n    });\n\n    return Promise.all(promises).catch(err => {\n      this.log.error('Load error all promises:', err);\n    });\n  }\n  \n  public getMonthContainerByTimestamp(timestamp: number, type: SearchSuperType) {\n    const date = new Date(timestamp * 1000);\n    date.setHours(0, 0, 0);\n    date.setDate(1);\n    const dateTimestamp = date.getTime();\n    const containers = this.monthContainers[type] ?? (this.monthContainers[type] = {});\n    if(!(dateTimestamp in containers)) {\n      const str = months[date.getMonth()] + ' ' + date.getFullYear();\n      \n      const container = document.createElement('div');\n      container.className = 'search-super-month';\n\n      const name = document.createElement('div');\n      name.classList.add('search-super-month-name');\n      name.innerText = str;\n      container.append(name);\n\n      const items = document.createElement('div');\n      items.classList.add('search-super-month-items');\n\n      container.append(name, items);\n\n      const haveTimestamps = getObjectKeysAndSort(containers, 'desc');\n      let i = 0;\n      for(; i < haveTimestamps.length; ++i) {\n        const t = haveTimestamps[i];\n        if(dateTimestamp > t) {\n          break;\n        }\n      }\n      \n      containers[dateTimestamp] = {container, items};\n      positionElementByIndex(container, this.tabs[type], i);\n    }\n\n    return containers[dateTimestamp];\n  }\n\n  public canViewMembers() {\n    return this.searchContext.peerId < 0 && !appChatsManager.isBroadcast(-this.searchContext.peerId) && appChatsManager.hasRights(-this.searchContext.peerId, 'view_participants');\n  }\n\n  public cleanup() {\n    this.loadPromises = {};\n    this.loaded = {};\n    this.loadedChats = false;\n    this.nextRates = {};\n    this.firstLoad = true;\n\n    this.lazyLoadQueue.clear();\n\n    this.mediaTabs.forEach(mediaTab => {\n      this.usedFromHistory[mediaTab.inputFilter] = -1;\n    });\n\n    // * must go to first tab (\u044d\u0442\u043e \u043a\u043e\u0441\u0442\u044b\u043b\u044c)\n    /* const membersTab = this.mediaTabsMap.get('members');\n    if(membersTab) {\n      const tab = this.canViewMembers() ? membersTab : this.mediaTabs[this.mediaTabs.indexOf(membersTab) + 1];\n      this.mediaTab = tab;\n    } */\n\n    this.middleware.clean();\n    this.cleanScrollPositions();\n    this.membersList = undefined;\n  }\n\n  public cleanScrollPositions() {\n    this.mediaTabs.forEach(mediaTab => {\n      mediaTab.scroll = undefined;\n    });\n  }\n\n  public cleanupHTML(goFirst = false) {\n    if(this.urlsToRevoke.length) {\n      this.urlsToRevoke.forEach(url => {\n        URL.revokeObjectURL(url);\n      });\n      this.urlsToRevoke.length = 0;\n    }\n\n    this.mediaTabs.forEach((tab) => {\n      tab.contentTab.innerHTML = '';\n\n      if(this.hideEmptyTabs) {\n        //tab.menuTab.classList.add('hide');\n        this.container.classList.add('hide');\n        this.container.parentElement.classList.add('search-empty');\n      }\n\n      if(tab.type === 'chats') {\n        return;\n      }\n      \n      if(!this.historyStorage[tab.inputFilter]) {\n        const parent = tab.contentTab.parentElement;\n        //if(!testScroll) {\n          if(!parent.querySelector('.preloader')) {\n            putPreloader(parent, true);\n          }\n        //}\n\n        const empty = parent.querySelector('.content-empty');\n        if(empty) {\n          empty.remove();\n        }\n      }\n    });\n\n    /* if(goFirst) {\n      const membersTab = this.mediaTabsMap.get('members');\n      if(membersTab) {\n        let idx = this.canViewMembers() ? 0 : 1;\n        membersTab.menuTab.classList.toggle('hide', idx !== 0);\n\n        this.selectTab(idx, false);\n      } else {\n        this.selectTab(0, false);\n      }\n    } */\n\n    this.monthContainers = {};\n    this.searchGroupMedia.clear();\n    this.scrollable.scrollTop = 0;\n\n    /* if(testScroll) {\n      for(let i = 0; i < 1500; ++i) {\n        let div = document.createElement('div');\n        div.insertAdjacentHTML('beforeend', `<img class=\"media-image\" src=\"assets/img/camomile.jpg\">`);\n        div.classList.add('grid-item');\n        div.dataset.id = '' + (i / 3 | 0);\n        //div.innerText = '' + (i / 3 | 0);\n        this.tabs.inputMessagesFilterPhotoVideo.append(div);\n      }\n    } */\n  }\n\n  private copySearchContext(newInputFilter: MyInputMessagesFilter) {\n    const context = copy(this.searchContext);\n    context.inputFilter = newInputFilter;\n    context.nextRate = this.nextRates[newInputFilter];\n    return context;\n  }\n\n  public setQuery({peerId, query, threadId, historyStorage, folderId, minDate, maxDate}: {\n    peerId: number, \n    query?: string, \n    threadId?: number, \n    historyStorage?: AppSearchSuper['historyStorage'], \n    folderId?: number,\n    minDate?: number,\n    maxDate?: number\n  }) {\n    this.searchContext = {\n      peerId: peerId || 0,\n      query: query || '',\n      inputFilter: this.mediaTab.inputFilter,\n      threadId,\n      folderId,\n      minDate,\n      maxDate\n    };\n    \n    this.historyStorage = historyStorage ?? {};\n\n    this.cleanup();\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport appDocsManager, {MyDocument} from \"../lib/appManagers/appDocsManager\";\nimport { RichTextProcessor } from \"../lib/richtextprocessor\";\nimport { formatDate } from \"./wrappers\";\nimport ProgressivePreloader from \"./preloader\";\nimport { MediaProgressLine } from \"../lib/mediaPlayer\";\nimport appMediaPlaybackController from \"./appMediaPlaybackController\";\nimport { DocumentAttribute } from \"../layer\";\nimport mediaSizes from \"../helpers/mediaSizes\";\nimport { isSafari } from \"../helpers/userAgent\";\nimport appMessagesManager from \"../lib/appManagers/appMessagesManager\";\nimport rootScope from \"../lib/rootScope\";\nimport './middleEllipsis';\nimport { SearchSuperContext } from \"./appSearchSuper.\";\nimport { formatDateAccordingToToday } from \"../helpers/date\";\nimport { cancelEvent } from \"../helpers/dom/cancelEvent\";\nimport { attachClickEvent, detachClickEvent } from \"../helpers/dom/clickEvent\";\n\nrootScope.addEventListener('messages_media_read', e => {\n  const {mids, peerId} = e;\n\n  mids.forEach(mid => {\n    (Array.from(document.querySelectorAll('audio-element[message-id=\"' + mid + '\"][peer-id=\"' + peerId + '\"]')) as AudioElement[]).forEach(elem => {\n      //console.log('updating avatar:', elem);\n      elem.classList.remove('is-unread');\n    });\n  });\n});\n\n// https://github.com/LonamiWebs/Telethon/blob/4393ec0b83d511b6a20d8a20334138730f084375/telethon/utils.py#L1285\nexport function decodeWaveform(waveform: Uint8Array | number[]) {\n  if(!(waveform instanceof Uint8Array)) {\n    waveform = new Uint8Array(waveform);\n  }\n\n  const bitCount = waveform.length * 8;\n  const valueCount = bitCount / 5 | 0;\n  if(!valueCount) {\n    return new Uint8Array([]);\n  }\n\n  let result: Uint8Array;\n  try {\n    const dataView = new DataView(waveform.buffer);\n    result = new Uint8Array(valueCount);\n    for(let i = 0; i < valueCount; i++) {\n      const byteIndex = i * 5 / 8 | 0;\n      const bitShift = i * 5 % 8;\n      const value = dataView.getUint16(byteIndex, true);\n      result[i] = (value >> bitShift) & 0b00011111;\n    }\n  } catch(err) {\n    result = new Uint8Array([]);\n  }\n\n  /* var byteIndex = (valueCount - 1) / 8 | 0;\n  var bitShift = (valueCount - 1) % 8;\n  if(byteIndex === waveform.length - 1) {\n    var value = waveform[byteIndex];\n  } else {\n    var value = dataView.getUint16(byteIndex, true);\n  }\n  console.log('decoded waveform, setting last value:', value, byteIndex, bitShift);\n  result[valueCount - 1] = (value >> bitShift) & 0b00011111; */\n  return result;\n}\n\nfunction wrapVoiceMessage(audioEl: AudioElement) {\n  audioEl.classList.add('is-voice');\n\n  const message = audioEl.message;\n  const doc = (message.media.document || message.media.webpage.document) as MyDocument;\n  const isOut = message.fromId === rootScope.myId && message.peerId !== rootScope.myId;\n  let isUnread = message && message.pFlags.media_unread;\n  if(isUnread) {\n    audioEl.classList.add('is-unread');\n  }\n\n  if(message.pFlags.out) {\n    audioEl.classList.add('is-out');\n  }\n\n  const barWidth = 2;\n  const barMargin = 2;      //mediaSizes.isMobile ? 2 : 1;\n  const barHeightMin = 4;   //mediaSizes.isMobile ? 3 : 2;\n  const barHeightMax = mediaSizes.isMobile ? 16 : 23;\n  const availW = 150;       //mediaSizes.isMobile ? 152 : 190;\n\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  svg.classList.add('audio-waveform');\n  svg.setAttributeNS(null, 'width', '' + availW);\n  svg.setAttributeNS(null, 'height', '' + barHeightMax);\n  svg.setAttributeNS(null, 'viewBox', `0 0 ${availW} ${barHeightMax}`);\n\n  const timeDiv = document.createElement('div');\n  timeDiv.classList.add('audio-time');\n  audioEl.append(svg, timeDiv);\n\n  let waveform = (doc.attributes.find(attribute => attribute._ === 'documentAttributeAudio') as DocumentAttribute.documentAttributeAudio).waveform || new Uint8Array([]);\n  waveform = decodeWaveform(waveform.slice(0, 63));\n\n  //console.log('decoded waveform:', waveform);\n\n  const normValue = Math.max(...waveform);\n  const wfSize = waveform.length ? waveform.length : 100;\n  const barCount = Math.min((availW / (barWidth + barMargin)) | 0, wfSize);\n\n  let maxValue = 0;\n  const maxDelta = barHeightMax - barHeightMin;\n\n  let html = '';\n  for(let i = 0, barX = 0, sumI = 0; i < wfSize; ++i) {\n    const value = waveform[i] || 0;\n    if((sumI + barCount) >= wfSize) { // draw bar\n      sumI = sumI + barCount - wfSize;\n\t\t\tif(sumI < (barCount + 1) / 2) {\n\t\t\t\tif(maxValue < value) maxValue = value;\n      }\n      \n      const bar_value = Math.max(((maxValue * maxDelta) + ((normValue + 1) / 2)) / (normValue + 1), barHeightMin);\n      \n      const h = `\n      <rect x=\"${barX}\" y=\"${barHeightMax - bar_value}\" width=\"${barWidth}\" height=\"${bar_value}\" rx=\"1\" ry=\"1\"></rect>\n      `;\n      html += h;\n\n      barX += barWidth + barMargin;\n\n      if(sumI < (barCount + 1) / 2) {\n        maxValue = 0;\n      } else {\n        maxValue = value;\n      }\n    } else {\n      if(maxValue < value) maxValue = value;\n\n      sumI += barCount;\n    }\n  }\n\n  svg.insertAdjacentHTML('beforeend', html);\n  const rects = Array.from(svg.children) as HTMLElement[];\n\n  let progress = audioEl.querySelector('.audio-waveform') as HTMLDivElement;\n  \n  const onLoad = () => {\n    let interval = 0;\n    let lastIndex = 0;\n\n    let audio = audioEl.audio;\n\n    if(!audio.paused || (audio.currentTime > 0 && audio.currentTime !== audio.duration)) {\n      lastIndex = Math.round(audio.currentTime / audio.duration * barCount);\n      rects.slice(0, lastIndex + 1).forEach(node => node.classList.add('active'));\n    }\n\n    let start = () => {\n      clearInterval(interval);\n      interval = window.setInterval(() => {\n        if(lastIndex > svg.childElementCount || isNaN(audio.duration) || audio.paused) {\n          clearInterval(interval);\n          return;\n        }\n\n        lastIndex = Math.round(audio.currentTime / audio.duration * barCount);\n        \n        //svg.children[lastIndex].setAttributeNS(null, 'fill', '#000');\n        //svg.children[lastIndex].classList.add('active'); #\u0418\u043d\u043e\u0433\u0434\u0430 \u043f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u0442 \u043f\u043e\u043b\u043e\u0441\u043a\u0438..\n        rects.slice(0, lastIndex + 1).forEach(node => node.classList.add('active'));\n        //++lastIndex;\n        //console.log('lastIndex:', lastIndex, audio.currentTime);\n        //}, duration * 1000 / svg.childElementCount | 0/* 63 * duration / 10 */);\n      }, 20);\n    };\n\n    if(!audio.paused) {\n      start();\n    }\n\n    audioEl.addAudioListener('playing', () => {\n      if(isUnread && !isOut && audioEl.classList.contains('is-unread')) {\n        audioEl.classList.remove('is-unread');\n        appMessagesManager.readMessages(audioEl.message.peerId, [audioEl.message.mid]);\n        isUnread = false;\n      }\n\n      //rects.forEach(node => node.classList.remove('active'));\n      start();\n    });\n\n    audioEl.addAudioListener('pause', () => {\n      clearInterval(interval);\n    });\n    \n    audioEl.addAudioListener('ended', () => {\n      clearInterval(interval);\n      rects.forEach(node => node.classList.remove('active'));\n    });\n    \n    let mousedown = false, mousemove = false;\n    progress.addEventListener('mouseleave', (e) => {\n      if(mousedown) {\n        audio.play();\n        mousedown = false;\n      }\n      mousemove = false;\n    })\n    progress.addEventListener('mousemove', (e) => {\n      mousemove = true;\n      if(mousedown) scrub(e);\n    });\n    progress.addEventListener('mousedown', (e) => {\n      e.preventDefault();\n      if(!audio.paused) {\n        audio.pause();\n      }\n      \n      scrub(e);\n      mousedown = true;\n    });\n    progress.addEventListener('mouseup', (e) => {\n      if (mousemove && mousedown) {\n        audio.play();\n        mousedown = false;\n      }\n    });\n    attachClickEvent(progress, (e) => {\n      cancelEvent(e);\n      if(!audio.paused) scrub(e);\n    });\n    \n    function scrub(e: MouseEvent | TouchEvent) {\n      let offsetX: number;\n      if(e instanceof MouseEvent) {\n        offsetX = e.offsetX;\n      } else { // touch\n        const rect = (e.target as HTMLElement).getBoundingClientRect();\n        offsetX = e.targetTouches[0].pageX - rect.left;\n      }\n      \n      const scrubTime = offsetX / availW /* width */ * audio.duration;\n      lastIndex = Math.round(scrubTime / audio.duration * barCount);\n      \n      rects.slice(0, lastIndex + 1).forEach(node => node.classList.add('active'));\n      for(let i = lastIndex + 1; i < rects.length; ++i) {\n        rects[i].classList.remove('active')\n      }\n      audio.currentTime = scrubTime;\n    }\n    \n    return () => {\n      clearInterval(interval);\n      progress.remove();\n      progress = null;\n      audio = null;\n    };\n  };\n\n  return onLoad;\n}\n\nfunction wrapAudio(audioEl: AudioElement) {\n  const withTime = audioEl.withTime;\n\n  const message = audioEl.message;\n  const doc: MyDocument = message.media.document || message.media.webpage.document;\n\n  const senderTitle = audioEl.showSender ? appMessagesManager.getSenderToPeerText(message) : '';\n\n  let title = doc.type === 'voice' ? senderTitle : (doc.audioTitle || doc.file_name);\n  let subtitle: string;\n  \n  if(doc.type === 'voice') {\n    subtitle = '';\n  } else {\n    subtitle = doc.audioPerformer ? RichTextProcessor.wrapPlainText(doc.audioPerformer) : '';\n    if(withTime) {\n      subtitle += (subtitle ? ' \u2022 ' : '') + formatDate(doc.date);\n    } else if(!subtitle) {\n      subtitle = 'Unknown Artist';\n    }\n\n    if(audioEl.showSender) {\n      subtitle += ' \u2022 ' + senderTitle;\n    } else {\n      subtitle = ' \u2022 ' + subtitle;\n    }\n  }\n\n  let titleAdditionHTML = '';\n  if(audioEl.showSender) {\n    titleAdditionHTML = `<div class=\"sent-time\">${formatDateAccordingToToday(new Date(message.date * 1000))}</div>`;\n  }\n\n  const html = `\n  <div class=\"audio-details\">\n    <div class=\"audio-title\"><middle-ellipsis-element data-font-weight=\"${audioEl.dataset.fontWeight}\">${title}</middle-ellipsis-element>${titleAdditionHTML}</div>\n    <div class=\"audio-subtitle\"><div class=\"audio-time\"></div>${subtitle || '<div></div>'}</div>\n  </div>`;\n  \n  audioEl.insertAdjacentHTML('beforeend', html);\n\n  const onLoad = () => {\n    const subtitleDiv = audioEl.querySelector('.audio-subtitle') as HTMLDivElement;\n    let launched = false;\n\n    let progressLine = new MediaProgressLine(audioEl.audio, doc.supportsStreaming);\n\n    audioEl.addAudioListener('ended', () => {\n      audioEl.classList.remove('audio-show-progress');\n      // Reset subtitle\n      subtitleDiv.lastChild.replaceWith(subtitle);\n      launched = false;\n    });\n\n    const onPlaying = () => {\n      if(!launched) {\n        audioEl.classList.add('audio-show-progress');\n        launched = true;\n\n        if(progressLine) {\n          subtitleDiv.lastChild.replaceWith(progressLine.container);\n        }\n      }\n    };\n\n    audioEl.addAudioListener('playing', onPlaying);\n\n    if(!audioEl.audio.paused || audioEl.audio.currentTime > 0) {\n      onPlaying();\n    }\n\n    return () => {\n      progressLine.removeListeners();\n      progressLine.container.remove();\n      progressLine = null;\n    };\n  };\n\n  return onLoad;\n}\n\nexport default class AudioElement extends HTMLElement {\n  public audio: HTMLAudioElement;\n  public preloader: ProgressivePreloader;\n  public message: any;\n  public withTime = false;\n  public voiceAsMusic = false;\n  public searchContext: SearchSuperContext;\n  public showSender = false;\n  public noAutoDownload: boolean;\n\n  private attachedHandlers: {[name: string]: any[]} = {};\n  private onTypeDisconnect: () => void;\n  public onLoad: (autoload?: boolean) => void;\n\n  constructor() {\n    super();\n    // \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\n  }\n\n  public render() {\n    this.classList.add('audio');\n\n    const doc = this.message.media.document || this.message.media.webpage.document;\n    const isRealVoice = doc.type === 'voice';\n    const isVoice = !this.voiceAsMusic && isRealVoice;\n    const isOutgoing = this.message.pFlags.is_outgoing;\n    const uploading = isOutgoing && this.preloader;\n\n    const durationStr = String(doc.duration | 0).toHHMMSS();\n\n    this.innerHTML = `<div class=\"audio-toggle audio-ico\">    \n                         <div class=\"part one\" x=\"0\" y=\"0\" fill=\"#fff\"></div>\n                         <div class=\"part two\" x=\"0\" y=\"0\" fill=\"#fff\"></div>\n                      </div>`;\n\n    const downloadDiv = document.createElement('div');\n    downloadDiv.classList.add('audio-download');\n\n    if(uploading) {\n      this.append(downloadDiv);\n    }\n\n    const onTypeLoad = isVoice ? wrapVoiceMessage(this) : wrapAudio(this);\n    \n    const audioTimeDiv = this.querySelector('.audio-time') as HTMLDivElement;\n    audioTimeDiv.innerHTML = durationStr;\n\n    const onLoad = this.onLoad = (autoload = true) => {\n      this.onLoad = undefined;\n\n      const audio = this.audio = appMediaPlaybackController.addMedia(this.message.peerId, this.message.media.document || this.message.media.webpage.document, this.message.mid, autoload);\n\n      this.onTypeDisconnect = onTypeLoad();\n      \n      const toggle = this.querySelector('.audio-toggle') as HTMLDivElement;\n\n      const getTimeStr = () => String(audio.currentTime | 0).toHHMMSS() + (isVoice ? (' / ' + durationStr) : '');\n\n      const onPlaying = () => {\n        audioTimeDiv.innerText = getTimeStr();\n        toggle.classList.toggle('playing', !audio.paused);\n      };\n\n      if(!audio.paused || (audio.currentTime > 0 && audio.currentTime !== audio.duration)) {\n        onPlaying();\n      }\n\n      attachClickEvent(toggle, (e) => {\n        cancelEvent(e);\n        if(audio.paused) audio.play().catch(() => {});\n        else audio.pause();\n      });\n\n      this.addAudioListener('ended', () => {\n        toggle.classList.remove('playing');\n      });\n\n      this.addAudioListener('timeupdate', () => {\n        if(appMediaPlaybackController.isSafariBuffering(audio)) return;\n        audioTimeDiv.innerText = getTimeStr();\n      });\n\n      this.addAudioListener('pause', () => {\n        toggle.classList.remove('playing');\n      });\n\n      this.addAudioListener('playing', onPlaying);\n    };\n\n    if(!isOutgoing) {\n      let preloader: ProgressivePreloader = this.preloader;\n\n      const getDownloadPromise = () => appDocsManager.downloadDoc(doc);\n\n      if(isRealVoice) {\n        if(!preloader) {\n          preloader = new ProgressivePreloader({\n            cancelable: true\n          });\n        }\n\n        const load = () => {\n          const download = getDownloadPromise();\n          preloader.attach(downloadDiv, false, download);\n\n          if(!downloadDiv.parentElement) {\n            this.append(downloadDiv);\n          }\n\n          (download as Promise<any>).then(() => {\n            detachClickEvent(this, onClick);\n            onLoad();\n\n            downloadDiv.classList.add('downloaded');\n            setTimeout(() => {\n              downloadDiv.remove();\n            }, 200);\n          });\n\n          return {download};\n        };\n\n        preloader.construct();\n        preloader.setManual();\n        preloader.attach(downloadDiv);\n        preloader.setDownloadFunction(load);\n\n        const onClick = (e?: Event) => {\n          preloader.onClick(e);\n        };\n    \n        attachClickEvent(this, onClick);\n\n        if(!this.noAutoDownload) {\n          onClick();\n        }\n      } else {\n        if(doc.supportsStreaming) {\n          onLoad(false);\n        }\n\n        //if(appMediaPlaybackController.mediaExists(mid)) { // \u0447\u0442\u043e\u0431\u044b \u043f\u043e\u043a\u0430\u0437\u0430\u0442\u044c \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441, \u0435\u0441\u043b\u0438 \u0430\u0443\u0434\u0438\u043e \u0443\u0436\u0435 \u0431\u044b\u043b\u043e \u0441\u043a\u0430\u0447\u0430\u043d\u043e\n          //onLoad();\n        //} else {\n          const r = (e: Event) => {\n            if(!this.audio) {\n              onLoad(false);\n            }\n\n            if(this.audio.src) {\n              return;\n            }\n            //onLoad();\n            //cancelEvent(e);\n            appMediaPlaybackController.resolveWaitingForLoadMedia(this.message.peerId, this.message.mid);\n  \n            appMediaPlaybackController.willBePlayed(this.audio); // prepare for loading audio\n  \n            if(!preloader) {\n              if(doc.supportsStreaming) {\n                preloader = new ProgressivePreloader({\n                  cancelable: false\n                });\n\n                preloader.attach(downloadDiv, false);\n              } else {\n                preloader = new ProgressivePreloader({\n                  cancelable: true\n                });\n\n                const load = () => {\n                  const download = getDownloadPromise();\n                  preloader.attach(downloadDiv, false, download);\n                  return {download};\n                };\n\n                preloader.setDownloadFunction(load);\n                load();\n              }\n            }\n\n            if(isSafari) {\n              this.audio.autoplay = true;\n              this.audio.play().catch(() => {});\n            }\n\n            this.append(downloadDiv);\n    \n            new Promise<void>((resolve) => {\n              if(this.audio.readyState >= 2) resolve();\n              else this.addAudioListener('canplay', resolve);\n            }).then(() => {\n              downloadDiv.classList.add('downloaded');\n              setTimeout(() => {\n                downloadDiv.remove();\n              }, 200);\n  \n              //setTimeout(() => {\n                // release loaded audio\n                if(appMediaPlaybackController.willBePlayedMedia === this.audio) {\n                  this.audio.play();\n                  appMediaPlaybackController.willBePlayedMedia = null;\n                }\n              //}, 10e3);\n            });\n          };\n\n          if(!this.audio?.src) {\n            attachClickEvent(this, r, {once: true, capture: true, passive: false});\n          }\n        //}\n      }\n    } else if(uploading) {\n      this.preloader.attach(downloadDiv, false);\n      //onLoad();\n    }\n  }\n\n  /* connectedCallback() {\n    // \u0431\u0440\u0430\u0443\u0437\u0435\u0440 \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u0442 \u044d\u0442\u043e\u0442 \u043c\u0435\u0442\u043e\u0434 \u043f\u0440\u0438 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0432 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\n    // (\u043c\u043e\u0436\u0435\u0442 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c\u0441\u044f \u043c\u043d\u043e\u0433\u043e \u0440\u0430\u0437, \u0435\u0441\u043b\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043c\u043d\u043e\u0433\u043e\u043a\u0440\u0430\u0442\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u0442\u0441\u044f/\u0443\u0434\u0430\u043b\u044f\u0435\u0442\u0441\u044f)\n  } */\n\n  public addAudioListener(name: string, callback: any) {\n    if(!this.attachedHandlers[name]) this.attachedHandlers[name] = [];\n    this.attachedHandlers[name].push(callback);\n    this.audio.addEventListener(name, callback);\n  }\n\n  disconnectedCallback() {\n    if(this.isConnected) {\n      return;\n    }\n    \n    // \u0431\u0440\u0430\u0443\u0437\u0435\u0440 \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u0442 \u044d\u0442\u043e\u0442 \u043c\u0435\u0442\u043e\u0434 \u043f\u0440\u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0438\u0437 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\n    // (\u043c\u043e\u0436\u0435\u0442 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c\u0441\u044f \u043c\u043d\u043e\u0433\u043e \u0440\u0430\u0437, \u0435\u0441\u043b\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043c\u043d\u043e\u0433\u043e\u043a\u0440\u0430\u0442\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u0442\u0441\u044f/\u0443\u0434\u0430\u043b\u044f\u0435\u0442\u0441\u044f)\n    if(this.onTypeDisconnect) {\n      this.onTypeDisconnect();\n      this.onTypeDisconnect = null;\n    }\n\n    for(let name in this.attachedHandlers) {\n      for(let callback of this.attachedHandlers[name]) {\n        this.audio.removeEventListener(name, callback);\n      }\n      \n      delete this.attachedHandlers[name];\n    }\n\n    this.preloader = null;\n  }\n}\n\ncustomElements.define(\"audio-element\", AudioElement);\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type { AppMessagesManager } from \"../../lib/appManagers/appMessagesManager\";\nimport type ChatTopbar from \"./topbar\";\nimport { RichTextProcessor } from \"../../lib/richtextprocessor\";\nimport rootScope from \"../../lib/rootScope\";\nimport appMediaPlaybackController from \"../appMediaPlaybackController\";\nimport DivAndCaption from \"../divAndCaption\";\nimport { formatDate } from \"../wrappers\";\nimport PinnedContainer from \"./pinnedContainer\";\nimport Chat from \"./chat\";\nimport { cancelEvent } from \"../../helpers/dom/cancelEvent\";\nimport { attachClickEvent } from \"../../helpers/dom/clickEvent\";\nimport replaceContent from \"../../helpers/dom/replaceContent\";\nimport PeerTitle from \"../peerTitle\";\n\nexport default class ChatAudio extends PinnedContainer {\n  private toggleEl: HTMLElement;\n\n  constructor(protected topbar: ChatTopbar, protected chat: Chat, protected appMessagesManager: AppMessagesManager) {\n    super(topbar, chat, topbar.listenerSetter, 'audio', new DivAndCaption('pinned-audio', (title: string | HTMLElement, subtitle: string | HTMLElement) => {\n      replaceContent(this.divAndCaption.title, title);\n      replaceContent(this.divAndCaption.subtitle, subtitle);\n    }), () => {\n      if(this.toggleEl.classList.contains('flip-icon')) {\n        appMediaPlaybackController.toggle();\n      }\n    });\n\n    this.divAndCaption.border.remove();\n\n    this.toggleEl = document.createElement('button');\n    this.toggleEl.classList.add('pinned-audio-ico', 'tgico', 'btn-icon');\n    attachClickEvent(this.toggleEl, (e) => {\n      cancelEvent(e);\n      appMediaPlaybackController.toggle();\n    }, {listenerSetter: this.topbar.listenerSetter});\n\n    this.wrapper.prepend(this.toggleEl);\n\n    this.topbar.listenerSetter.add(rootScope)('audio_play', (e) => {\n      const {doc, mid, peerId} = e;\n\n      let title: string | HTMLElement, subtitle: string;\n      const message = appMessagesManager.getMessageByPeer(peerId, mid);\n      if(doc.type === 'voice' || doc.type === 'round') {\n        title = new PeerTitle({\n          peerId: message.fromId,\n          onlyFirstName: true\n        }).element;\n\n        //subtitle = 'Voice message';\n        subtitle = formatDate(message.date, false, false);\n      } else {\n        title = doc.audioTitle || doc.file_name;\n        subtitle = doc.audioPerformer ? RichTextProcessor.wrapPlainText(doc.audioPerformer) : 'Unknown Artist';\n      }\n\n      this.fill(title, subtitle, message);\n      this.toggleEl.classList.add('flip-icon');\n      this.toggle(false);\n    });\n\n    this.topbar.listenerSetter.add(rootScope)('audio_pause', () => {\n      this.toggleEl.classList.remove('flip-icon');\n    });\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type Chat from \"../chat/chat\";\nimport InputField from \"../inputField\";\nimport PopupElement from \".\";\nimport Scrollable from \"../scrollable\";\nimport { toast } from \"../toast\";\nimport { prepareAlbum, wrapDocument } from \"../wrappers\";\nimport CheckboxField from \"../checkboxField\";\nimport SendContextMenu from \"../chat/sendContextMenu\";\nimport { createPosterFromVideo, onVideoLoad } from \"../../helpers/files\";\nimport { MyDocument } from \"../../lib/appManagers/appDocsManager\";\nimport I18n, { i18n, LangPackKey } from \"../../lib/langPack\";\nimport appDownloadManager from \"../../lib/appManagers/appDownloadManager\";\nimport calcImageInBox from \"../../helpers/calcImageInBox\";\nimport isSendShortcutPressed from \"../../helpers/dom/isSendShortcutPressed\";\nimport placeCaretAtEnd from \"../../helpers/dom/placeCaretAtEnd\";\nimport rootScope from \"../../lib/rootScope\";\n\ntype SendFileParams = Partial<{\n  file: File,\n  objectURL: string,\n  thumbBlob: Blob,\n  thumbURL: string,\n  width: number,\n  height: number,\n  duration: number\n}>;\n\n// TODO: .gif upload as video\n\nexport default class PopupNewMedia extends PopupElement {\n  private input: HTMLElement;\n  private mediaContainer: HTMLElement;\n  private groupCheckboxField: CheckboxField;\n  private wasInputValue = '';\n\n  private willAttach: Partial<{\n    type: 'media' | 'document',\n    isMedia: true,\n    group: boolean,\n    sendFileDetails: SendFileParams[]\n  }> = {\n    sendFileDetails: [],\n    group: false\n  };\n  private inputField: InputField;\n\n  constructor(private chat: Chat, files: File[], willAttachType: PopupNewMedia['willAttach']['type']) {\n    super('popup-send-photo popup-new-media', null, {closable: true, withConfirm: 'Modal.Send'});\n\n    this.willAttach.type = willAttachType;\n\n    this.btnConfirm.addEventListener('click', () => this.send());\n\n    if(this.chat.type !== 'scheduled') {\n      const sendMenu = new SendContextMenu({\n        onSilentClick: () => {\n          this.chat.input.sendSilent = true;\n          this.send();\n        },\n        onScheduleClick: () => {\n          this.chat.input.scheduleSending(() => {\n            this.send();\n          });\n        },\n        openSide: 'bottom-left',\n        onContextElement: this.btnConfirm,\n      });\n\n      sendMenu.setPeerId(this.chat.peerId);\n\n      this.header.append(sendMenu.sendMenu);\n    }\n\n    this.mediaContainer = document.createElement('div');\n    this.mediaContainer.classList.add('popup-photo');\n    const scrollable = new Scrollable(null);\n    scrollable.container.append(this.mediaContainer);\n    \n    this.inputField = new InputField({\n      placeholder: 'PreviewSender.CaptionPlaceholder',\n      label: 'Caption',\n      name: 'photo-caption',\n      maxLength: rootScope.config.caption_length_max,\n      showLengthOn: 80\n    });\n    this.input = this.inputField.input;\n\n    this.inputField.value = this.wasInputValue = this.chat.input.messageInputField.value;\n    this.chat.input.messageInputField.value = '';\n\n    this.container.append(scrollable.container);\n\n    if(files.length > 1) {\n      this.groupCheckboxField = new CheckboxField({\n        text: 'PreviewSender.GroupItems', \n        name: 'group-items'\n      });\n      this.container.append(this.groupCheckboxField.label, this.inputField.container);\n  \n      this.groupCheckboxField.input.checked = true;\n      this.willAttach.group = true;\n\n      this.groupCheckboxField.input.addEventListener('change', () => {\n        const checked = this.groupCheckboxField.input.checked;\n  \n        this.willAttach.group = checked;\n        this.willAttach.sendFileDetails.length = 0;\n\n        //this.mediaContainer.innerHTML = '';\n        //this.container.classList.remove('is-media', 'is-document', 'is-album');\n        this.attachFiles(files);\n      });\n    }\n    \n    this.container.append(this.inputField.container);\n\n    this.attachFiles(files);\n  }\n\n  private onKeyDown = (e: KeyboardEvent) => {\n    const target = e.target as HTMLElement;\n    if(target !== this.input) {\n      if(target.tagName === 'INPUT' || target.hasAttribute('contenteditable')) {\n        return;\n      }\n\n      this.input.focus();\n      placeCaretAtEnd(this.input);\n    }\n    \n    if(isSendShortcutPressed(e)) {\n      this.btnConfirm.click();\n    }\n  };\n\n  public send(force = false) {\n    if(this.chat.type === 'scheduled' && !force) {\n      this.chat.input.scheduleSending(() => {\n        this.send(true);\n      });\n      \n      return;\n    }\n\n    let caption = this.inputField.value;\n    if(caption.length > rootScope.config.caption_length_max) {\n      toast(I18n.format('Error.PreviewSender.CaptionTooLong', true));\n      return;\n    }\n\n    this.hide();\n    const willAttach = this.willAttach;\n    willAttach.isMedia = willAttach.type === 'media' ? true : undefined;\n\n    //console.log('will send files with options:', willAttach);\n\n    const peerId = this.chat.peerId;\n    const input = this.chat.input;\n    const silent = input.sendSilent;\n    const scheduleDate = input.scheduleDate;\n\n    if(willAttach.sendFileDetails.length > 1 && willAttach.group) {\n      for(let i = 0; i < willAttach.sendFileDetails.length;) {\n        let firstType = willAttach.sendFileDetails[i].file.type.split('/')[0];\n        for(var k = 0; k < 10 && i < willAttach.sendFileDetails.length; ++i, ++k) {\n          const type = willAttach.sendFileDetails[i].file.type.split('/')[0];\n          if(firstType !== type) {\n            break;\n          }\n        }\n\n        const w = {...willAttach};\n        w.sendFileDetails = willAttach.sendFileDetails.slice(i - k, i);\n\n        this.chat.appMessagesManager.sendAlbum(peerId, w.sendFileDetails.map(d => d.file), Object.assign({\n          caption,\n          replyToMsgId: input.replyToMsgId,\n          threadId: this.chat.threadId,\n          isMedia: willAttach.isMedia,\n          silent,\n          scheduleDate,\n          clearDraft: true as true\n        }, w));\n\n        caption = undefined;\n        input.replyToMsgId = this.chat.threadId;\n      }\n    } else {\n      if(caption) {\n        if(willAttach.sendFileDetails.length > 1) {\n          this.chat.appMessagesManager.sendText(peerId, caption, {\n            replyToMsgId: input.replyToMsgId, \n            threadId: this.chat.threadId,\n            silent, \n            scheduleDate,\n            clearDraft: true\n          });\n          caption = '';\n          //input.replyToMsgId = undefined;\n        }\n      }\n  \n      const promises = willAttach.sendFileDetails.map(params => {\n        const promise = this.chat.appMessagesManager.sendFile(peerId, params.file, Object.assign({\n          //isMedia: willAttach.isMedia, \n          isMedia: willAttach.isMedia, \n          caption,\n          replyToMsgId: input.replyToMsgId,\n          threadId: this.chat.threadId,\n          silent,\n          scheduleDate,\n          clearDraft: true as true\n        }, params));\n\n        caption = '';\n        return promise;\n      });\n\n      input.replyToMsgId = this.chat.threadId;\n    }\n\n    //Promise.all(promises);\n\n    //appMessagesManager.sendFile(appImManager.peerId, willAttach.file, willAttach);\n    \n    input.onMessageSent();\n  }\n\n  public attachFile = (file: File) => {\n    const willAttach = this.willAttach;\n    return new Promise<HTMLDivElement>((resolve) => {\n      const params: SendFileParams = {};\n      params.file = file;\n      //console.log('selected file:', file, typeof(file), willAttach);\n      const itemDiv = document.createElement('div');\n      switch(willAttach.type) {\n        case 'media': {\n          const isVideo = file.type.indexOf('video/') === 0;\n\n          itemDiv.classList.add('popup-item-media');\n\n          if(isVideo) {\n            const video = document.createElement('video');\n            const source = document.createElement('source');\n            source.src = params.objectURL = URL.createObjectURL(file);\n            video.autoplay = true;\n            video.controls = false;\n            video.muted = true;\n            video.setAttribute('playsinline', 'true');\n\n            video.addEventListener('timeupdate', () => {\n              video.pause();\n            }, {once: true});\n\n            onVideoLoad(video).then(() => {\n              params.width = video.videoWidth;\n              params.height = video.videoHeight;\n              params.duration = Math.floor(video.duration);\n\n              itemDiv.append(video);\n              createPosterFromVideo(video).then(blob => {\n                params.thumbBlob = blob;\n                params.thumbURL = URL.createObjectURL(blob);\n                resolve(itemDiv);\n              });\n            });\n\n            video.append(source);\n          } else {\n            const img = new Image();\n            img.src = params.objectURL = URL.createObjectURL(file);\n            img.onload = () => {\n              params.width = img.naturalWidth;\n              params.height = img.naturalHeight;\n\n              itemDiv.append(img);\n              resolve(itemDiv);\n            };\n          }\n          \n          break;\n        }\n\n        case 'document': {\n          const isPhoto = file.type.indexOf('image/') !== -1;\n          const isAudio = file.type.indexOf('audio/') !== -1;\n          if(isPhoto || isAudio) {\n            params.objectURL = URL.createObjectURL(file);\n          }\n\n          const doc = {\n            _: 'document',\n            file: file,\n            file_name: file.name || '',\n            size: file.size,\n            type: isPhoto ? 'photo' : 'doc'\n          } as MyDocument;\n\n          const cacheContext = appDownloadManager.getCacheContext(doc);\n          cacheContext.url = params.objectURL;\n          cacheContext.downloaded = file.size;\n\n          const docDiv = wrapDocument({\n            message: {\n              _: 'message',\n              pFlags: {\n                is_outgoing: true\n              },\n              mid: 0,\n              peerId: 0,\n              media: {\n                _: 'messageMediaDocument',\n                document: doc\n              }\n            } as any\n          });\n\n          const finish = () => {\n            itemDiv.append(docDiv);\n            resolve(itemDiv);\n          };\n\n          if(isPhoto) {\n            const img = new Image();\n            img.src = params.objectURL;\n            img.onload = () => {\n              params.width = img.naturalWidth;\n              params.height = img.naturalHeight;\n\n              finish();\n            };\n\n            img.onerror = finish;\n          } else {\n            finish();\n          }\n\n          break;\n        }\n      }\n\n      willAttach.sendFileDetails.push(params);\n    });\n  };\n\n  public attachFiles(files: File[]) {\n    const container = this.container;\n    const willAttach = this.willAttach;\n\n    /* if(files.length > 10 && willAttach.type === 'media') {\n      willAttach.type = 'document';\n    } */\n\n    files = files.filter(file => {\n      if(willAttach.type === 'media') {\n        return ['image/', 'video/'].find(s => file.type.indexOf(s) === 0);\n      } else {\n        return true;\n      }\n    });\n\n    Promise.all(files.map(this.attachFile)).then(results => {\n      this.container.classList.remove('is-media', 'is-document', 'is-album');\n      this.mediaContainer.innerHTML = '';\n\n      if(files.length) {\n        let key: LangPackKey;\n        const args: any[] = [];\n        if(willAttach.type === 'document') {\n          key = 'PreviewSender.SendFile';\n          args.push(files.length);\n          container.classList.add('is-document');\n        } else {\n          container.classList.add('is-media');\n  \n          let foundPhotos = 0;\n          let foundVideos = 0;\n          files.forEach(file => {\n            if(file.type.indexOf('image/') === 0) ++foundPhotos;\n            else if(file.type.indexOf('video/') === 0) ++foundVideos;\n          });\n          \n          const sum = foundPhotos + foundVideos;\n          if(sum > 1 && willAttach.group) {\n            key = 'PreviewSender.SendAlbum';\n            const albumsLength = Math.ceil(sum / 10);\n            args.push(albumsLength);\n          } else if(foundPhotos) {\n            key = 'PreviewSender.SendPhoto';\n            args.push(foundPhotos);\n          } else if(foundVideos) {\n            key = 'PreviewSender.SendVideo';\n            args.push(foundVideos);\n          }\n        }\n\n        this.title.textContent = '';\n        this.title.append(i18n(key, args));\n      }\n\n      if(willAttach.type === 'media') {\n        if(willAttach.sendFileDetails.length > 1 && willAttach.group) {\n          container.classList.add('is-album');\n\n          for(let i = 0; i < results.length; i += 10) {\n            const albumContainer = document.createElement('div');\n            albumContainer.classList.add('popup-album');\n\n            albumContainer.append(...results.slice(i, i + 10));\n            prepareAlbum({\n              container: albumContainer,\n              items: willAttach.sendFileDetails.slice(i, i + 10).map(o => ({w: o.width, h: o.height})),\n              maxWidth: 380,\n              minWidth: 100,\n              spacing: 4\n            });\n\n            this.mediaContainer.append(albumContainer);\n          }\n\n          //console.log('chatInput album layout:', layout);\n        } else {\n          for(let i = 0; i < results.length; ++i) {\n            const params = willAttach.sendFileDetails[i];\n            const div = results[i];\n            const size = calcImageInBox(params.width, params.height, 380, 320);\n            div.style.width = size.width + 'px';\n            div.style.height = size.height + 'px';\n            this.mediaContainer.append(div);\n          }\n        }\n      } else {\n        this.mediaContainer.append(...results);\n      }\n\n      // show now\n      if(!this.element.classList.contains('active')) {\n        document.body.addEventListener('keydown', this.onKeyDown);\n        this.onClose = () => {\n          if(this.wasInputValue) {\n            this.chat.input.messageInputField.value = this.wasInputValue;\n          }\n\n          document.body.removeEventListener('keydown', this.onKeyDown);\n        };\n        this.show();\n      }\n    });\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport { formatNumber } from \"../../helpers/number\";\nimport appImManager from \"../../lib/appManagers/appImManager\";\nimport appStateManager from \"../../lib/appManagers/appStateManager\";\nimport appUsersManager from \"../../lib/appManagers/appUsersManager\";\nimport rootScope from \"../../lib/rootScope\";\nimport { SearchGroup } from \"../appSearch\";\nimport \"../avatar\";\nimport Scrollable, { ScrollableX } from \"../scrollable\";\nimport InputSearch from \"../inputSearch\";\nimport SidebarSlider from \"../slider\";\nimport { TransitionSlider } from \"../transition\";\nimport AppNewGroupTab from \"./tabs/newGroup\";\nimport appMessagesManager from \"../../lib/appManagers/appMessagesManager\";\nimport AppSearchSuper from \"../appSearchSuper.\";\nimport { DateData, fillTipDates } from \"../../helpers/date\";\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\nimport AppSettingsTab from \"./tabs/settings\";\nimport AppNewChannelTab from \"./tabs/newChannel\";\nimport AppContactsTab from \"./tabs/contacts\";\nimport AppArchivedTab from \"./tabs/archivedTab\";\nimport AppAddMembersTab from \"./tabs/addMembers\";\nimport { i18n_, LangPackKey } from \"../../lib/langPack\";\nimport { ButtonMenuItemOptions } from \"../buttonMenu\";\nimport CheckboxField from \"../checkboxField\";\nimport { isMobileSafari } from \"../../helpers/userAgent\";\nimport appNavigationController from \"../appNavigationController\";\nimport findUpClassName from \"../../helpers/dom/findUpClassName\";\nimport findUpTag from \"../../helpers/dom/findUpTag\";\nimport PeerTitle from \"../peerTitle\";\nimport App from \"../../config/app\";\nimport ButtonMenuToggle from \"../buttonMenuToggle\";\nimport replaceContent from \"../../helpers/dom/replaceContent\";\nimport sessionStorage from \"../../lib/sessionStorage\";\n\nexport const LEFT_COLUMN_ACTIVE_CLASSNAME = 'is-left-column-shown';\n\nexport class AppSidebarLeft extends SidebarSlider {\n  private toolsBtn: HTMLButtonElement;\n  private backBtn: HTMLButtonElement;\n  //private searchInput = document.getElementById('global-search') as HTMLInputElement;\n  private inputSearch: InputSearch;\n  \n  public archivedCount: HTMLSpanElement;\n\n  private newBtnMenu: HTMLElement;\n\n  //private log = logger('SL');\n\n  private searchGroups: {[k in 'contacts' | 'globalContacts' | 'messages' | 'people' | 'recent']: SearchGroup} = {} as any;\n  private searchSuper: AppSearchSuper;\n\n  constructor() {\n    super({\n      sidebarEl: document.getElementById('column-left') as HTMLDivElement,\n      navigationType: 'left'\n    });\n\n    //this._selectTab(0); // make first tab as default\n\n    this.inputSearch = new InputSearch('Search');\n    const sidebarHeader = this.sidebarEl.querySelector('.item-main .sidebar-header');\n    sidebarHeader.append(this.inputSearch.container);\n\n    const onNewGroupClick = () => {\n      new AppAddMembersTab(this).open({\n        peerId: 0,\n        type: 'chat',\n        skippable: false,\n        takeOut: (peerIds) => {\n          new AppNewGroupTab(this).open(peerIds);\n        },\n        title: 'GroupAddMembers',\n        placeholder: 'SendMessageTo'\n      });\n    };\n\n    const onContactsClick = () => {\n      new AppContactsTab(this).open();\n    };\n\n    //this.toolsBtn = this.sidebarEl.querySelector('.sidebar-tools-button') as HTMLButtonElement;\n    this.backBtn = this.sidebarEl.querySelector('.sidebar-back-button') as HTMLButtonElement;\n\n    const btnArchive: ButtonMenuItemOptions & {verify?: () => boolean} = {\n      icon: 'archive',\n      text: 'ArchivedChats',\n      onClick: () => {\n        new AppArchivedTab(this).open();\n      },\n      verify: () => {\n        const folder = appMessagesManager.dialogsStorage.getFolder(1);\n        return !!folder.length;\n      }\n    };\n\n    const themeCheckboxField = new CheckboxField({\n      toggle: true,\n      checked: rootScope.getTheme().name === 'night'\n    });\n    themeCheckboxField.input.addEventListener('change', () => {\n      rootScope.settings.theme = themeCheckboxField.input.checked ? 'night' : 'day';\n      appStateManager.pushToState('settings', rootScope.settings);\n      appImManager.applyCurrentTheme();\n    });\n\n    rootScope.addEventListener('theme_change', () => {\n      themeCheckboxField.setValueSilently(rootScope.getTheme().name === 'night');\n    });\n\n    const menuButtons: (ButtonMenuItemOptions & {verify?: () => boolean})[] = [{\n      icon: 'saved',\n      text: 'SavedMessages',\n      onClick: () => {\n        setTimeout(() => { // menu doesn't close if no timeout (lol)\n          appImManager.setPeer(appImManager.myId);\n        }, 0);\n      }\n    }, btnArchive, {\n      icon: 'user',\n      text: 'Contacts',\n      onClick: onContactsClick\n    }, {\n      icon: 'settings',\n      text: 'Settings',\n      onClick: () => {\n        new AppSettingsTab(this).open();\n      }\n    }, {\n      icon: 'darkmode',\n      text: 'DarkMode',\n      onClick: () => {\n        \n      },\n      checkboxField: themeCheckboxField\n    }, {\n      icon: 'animations',\n      text: 'Animations',\n      onClick: () => {\n        \n      },\n      checkboxField: new CheckboxField({\n        toggle: true, \n        checked: true,\n        stateKey: 'settings.animationsEnabled',\n      })\n    }, {\n      icon: 'help',\n      text: 'TelegramFeatures',\n      onClick: () => {\n        appImManager.openUsername('TelegramTips');\n      }\n    }, {\n      icon: 'bug',\n      text: 'ReportBug',\n      onClick: () => {\n        const a = document.createElement('a');\n        a.target = '_blank';\n        a.href = 'https://bugs.telegram.org/?tag_ids=40&sort=time';\n        document.body.append(a);\n        a.click();\n        setTimeout(() => {\n          a.remove();\n        }, 0);\n      }\n    }, {\n      icon: 'char z',\n      text: 'ChatList.Menu.SwitchTo.Z',\n      onClick: () => {\n        sessionStorage.set({kz_version: 'Z'}).then(() => {\n          location.href = 'https://web.telegram.org/z/';\n        });\n      },\n      verify: () => App.isMainDomain\n    }, {\n      icon: 'char w',\n      text: 'ChatList.Menu.SwitchTo.Webogram',\n      onClick: () => {\n        location.href = 'https://web.telegram.org/?legacy=1';\n      },\n      verify: () => App.isMainDomain\n    }];\n\n    this.toolsBtn = ButtonMenuToggle({}, 'bottom-right', menuButtons, (e) => {\n      menuButtons.forEach(button => {\n        if(button.verify) {\n          button.element.classList.toggle('hide', !button.verify());\n        }\n      });\n    });\n    this.toolsBtn.classList.remove('tgico-more');\n    this.toolsBtn.classList.add('sidebar-tools-button', 'is-visible');\n\n    this.backBtn.parentElement.insertBefore(this.toolsBtn, this.backBtn);\n\n    const btnMenu = this.toolsBtn.querySelector('.btn-menu') as HTMLElement;\n\n    const btnMenuFooter = document.createElement('div');\n    btnMenuFooter.classList.add('btn-menu-footer');\n    const t = document.createElement('span');\n    t.classList.add('btn-menu-footer-text');\n    t.innerHTML = 'Telegram Web' + App.suffix + ' alpha ' + App.version;\n    btnMenuFooter.append(t); \n    btnMenu.classList.add('has-footer');\n    btnMenu.append(btnMenuFooter);\n\n    this.newBtnMenu = ButtonMenuToggle({}, 'top-left', [{\n      icon: 'newchannel',\n      text: 'NewChannel',\n      onClick: () => {\n        new AppNewChannelTab(this).open();\n      }\n    }, {\n      icon: 'newgroup',\n      text: 'NewGroup',\n      onClick: onNewGroupClick\n    }, {\n      icon: 'newprivate',\n      text: 'NewPrivateChat',\n      onClick: onContactsClick\n    }]);\n    this.newBtnMenu.className = 'btn-circle rp btn-corner z-depth-1 btn-menu-toggle animated-button-icon';\n    this.newBtnMenu.insertAdjacentHTML('afterbegin', `\n    <span class=\"tgico tgico-newchat_filled\"></span>\n    <span class=\"tgico tgico-close\"></span>\n    `);\n    this.newBtnMenu.id = 'new-menu';\n    sidebarHeader.nextElementSibling.append(this.newBtnMenu);\n\n    this.inputSearch.input.addEventListener('focus', () => this.initSearch(), {once: true});\n\n    //parseMenuButtonsTo(this.newButtons, this.newBtnMenu.firstElementChild.children);\n\n    this.archivedCount = document.createElement('span');\n    this.archivedCount.className = 'archived-count badge badge-24 badge-gray';\n\n    btnArchive.element.append(this.archivedCount);\n\n    rootScope.addEventListener('dialogs_archived_unread', (e) => {\n      this.archivedCount.innerText = '' + formatNumber(e.count, 1);\n      this.archivedCount.classList.toggle('hide', !e.count);\n    });\n\n    appUsersManager.getTopPeers();\n\n    appStateManager.getState().then(state => {\n      const recentSearch = state.recentSearch || [];\n      for(let i = 0, length = recentSearch.length; i < length; ++i) {\n        appStateManager.requestPeer(recentSearch[i], 'recentSearch');\n      }\n    });\n  }\n\n  private initSearch() {\n    const searchContainer = this.sidebarEl.querySelector('#search-container') as HTMLDivElement;\n\n    const scrollable = new Scrollable(searchContainer);\n\n    const close = () => {\n      //setTimeout(() => {\n        this.backBtn.click();\n      //}, 0);\n    };\n\n    this.searchGroups = {\n      contacts: new SearchGroup('Search.Chats', 'contacts', undefined, undefined, undefined, undefined, close),\n      globalContacts: new SearchGroup('Search.Global', 'contacts', undefined, undefined, undefined, undefined, close),\n      messages: new SearchGroup('Search.Messages', 'messages'),\n      people: new SearchGroup(false, 'contacts', true, 'search-group-people', true, false, close),\n      recent: new SearchGroup('Recent', 'contacts', true, 'search-group-recent', true, true, close)\n    };\n\n    const searchSuper = this.searchSuper = new AppSearchSuper({\n      mediaTabs: [{\n        inputFilter: 'inputMessagesFilterEmpty',\n        name: 'FilterChats',\n        type: 'chats'\n      }, {\n        inputFilter: 'inputMessagesFilterPhotoVideo',\n        name: 'SharedMediaTab2',\n        type: 'media'\n      }, {\n        inputFilter: 'inputMessagesFilterUrl',\n        name: 'SharedLinksTab2',\n        type: 'links'\n      }, {\n        inputFilter: 'inputMessagesFilterDocument',\n        name: 'SharedFilesTab2',\n        type: 'files'\n      }, {\n        inputFilter: 'inputMessagesFilterMusic',\n        name: 'SharedMusicTab2',\n        type: 'music'\n      }, {\n        inputFilter: 'inputMessagesFilterVoice',\n        name: 'SharedVoiceTab2',\n        type: 'voice'\n      }], \n      scrollable, \n      searchGroups: this.searchGroups, \n      asChatList: true,\n      hideEmptyTabs: false,\n      showSender: true\n    });\n\n    searchContainer.prepend(searchSuper.nav.parentElement.parentElement);\n    scrollable.container.append(searchSuper.container);\n\n    const resetSearch = () => {\n      searchSuper.setQuery({\n        peerId: 0, \n        folderId: 0\n      });\n      searchSuper.selectTab(0);\n      searchSuper.load(true); \n    };\n\n    resetSearch();\n\n    let pickedElements: HTMLElement[] = [];\n    let selectedPeerId = 0;\n    let selectedMinDate = 0;\n    let selectedMaxDate = 0;\n    const updatePicked = () => {\n      //(this.inputSearch.input as HTMLInputElement).placeholder = pickedElements.length ? 'Search' : 'Telegram Search';\n      this.inputSearch.container.classList.toggle('is-picked-twice', pickedElements.length === 2);\n      this.inputSearch.container.classList.toggle('is-picked', !!pickedElements.length);\n\n      if(pickedElements.length) {\n        this.inputSearch.input.style.setProperty('--paddingLeft', (pickedElements[pickedElements.length - 1].getBoundingClientRect().right - this.inputSearch.input.getBoundingClientRect().left) + 'px');\n      } else {\n        this.inputSearch.input.style.removeProperty('--paddingLeft');\n      }\n    };\n\n    const helper = document.createElement('div');\n    helper.classList.add('search-helper');\n    helper.addEventListener('click', (e) => {\n      const target = findUpClassName(e.target, 'selector-user');\n      if(!target) {\n        return;\n      }\n\n      const key = target.dataset.key;\n      if(key.indexOf('date_') === 0) {\n        const [_, minDate, maxDate] = key.split('_');\n        selectedMinDate = +minDate;\n        selectedMaxDate = +maxDate;\n      } else {\n        selectedPeerId = +key;\n      }\n\n      target.addEventListener('click', () => {\n        unselectEntity(target);\n      });\n\n      this.inputSearch.container.append(target);\n      this.inputSearch.onChange(this.inputSearch.value = '');\n      pickedElements.push(target);\n      updatePicked();\n    });\n\n    searchSuper.nav.parentElement.append(helper);\n\n    const renderEntity = (peerId: any, title?: string | HTMLElement) => {\n      const div = document.createElement('div');\n      div.classList.add('selector-user'/* , 'scale-in' */);\n\n      const avatarEl = document.createElement('avatar-element');\n      avatarEl.classList.add('selector-user-avatar', 'tgico');\n      avatarEl.setAttribute('dialog', '1');\n      avatarEl.classList.add('avatar-30');\n\n      div.dataset.key = '' + peerId;\n      if(typeof(peerId) === 'number') {\n        if(title === undefined) {\n          title = new PeerTitle({peerId, onlyFirstName: true}).element;\n        }\n\n        avatarEl.setAttribute('peer', '' + peerId);\n      } else {\n        avatarEl.classList.add('tgico-calendarfilter');\n      }\n\n      if(title) {\n        if(typeof(title) === 'string') {\n          div.innerHTML = title;\n        } else {\n          replaceContent(div, title);\n          div.append(title);\n        }\n      }\n\n      div.insertAdjacentElement('afterbegin', avatarEl);\n\n      return div;\n    };\n\n    const unselectEntity = (target: HTMLElement) => {\n      const key = target.dataset.key;\n      if(key.indexOf('date_') === 0) {\n        selectedMinDate = selectedMaxDate = 0;\n      } else {\n        selectedPeerId = 0;\n      }\n      \n      target.remove();\n      pickedElements.findAndSplice(t => t === target);\n\n      setTimeout(() => {\n        updatePicked();\n        this.inputSearch.onChange(this.inputSearch.value);\n      }, 0);\n    };\n\n    this.inputSearch.onClear = () => {\n      pickedElements.forEach(el => {\n        unselectEntity(el);\n      });\n    };\n\n    this.inputSearch.onChange = (value) => {\n      searchSuper.cleanupHTML();\n      searchSuper.setQuery({\n        peerId: selectedPeerId, \n        folderId: selectedPeerId ? undefined : 0,\n        query: value,\n        minDate: selectedMinDate,\n        maxDate: selectedMaxDate\n      });\n      searchSuper.load(true);\n\n      helper.innerHTML = '';\n      searchSuper.nav.classList.remove('hide');\n      if(!value) {\n      }\n      \n      if(!selectedPeerId && value.trim()) {\n        const middleware = searchSuper.middleware.get();\n        Promise.all([\n          appMessagesManager.getConversationsAll(value).then(dialogs => dialogs.map(d => d.peerId)),\n          appUsersManager.getContacts(value, true)\n        ]).then(results => {\n          if(!middleware()) return;\n          const peerIds = new Set(results[0].concat(results[1]));\n  \n          peerIds.forEach(peerId => {\n            helper.append(renderEntity(peerId));\n          });\n  \n          searchSuper.nav.classList.toggle('hide', !!helper.innerHTML);\n          //console.log('got peerIds by value:', value, [...peerIds]);\n        });\n      }\n      \n      if(!selectedMinDate && value.trim()) {\n        const dates: DateData[] = [];\n        fillTipDates(value, dates);\n        dates.forEach(dateData => {\n          helper.append(renderEntity('date_' + dateData.minDate + '_' + dateData.maxDate, dateData.title));\n        });\n\n        searchSuper.nav.classList.toggle('hide', !!helper.innerHTML);\n      }\n    };\n\n    searchSuper.tabs.inputMessagesFilterEmpty.addEventListener('mousedown', (e) => {\n      const target = findUpTag(e.target, 'LI') as HTMLElement;\n      if(!target) {\n        return;\n      }\n\n      const searchGroup = findUpClassName(target, 'search-group');\n      if(!searchGroup || searchGroup.classList.contains('search-group-recent') || searchGroup.classList.contains('search-group-people')) {\n        return;\n      }\n\n      const peerId = +target.getAttribute('data-peer-id');\n      appStateManager.getState().then(state => {\n        const recentSearch = state.recentSearch || [];\n        if(recentSearch[0] !== peerId) {\n          recentSearch.findAndSplice(p => p === peerId);\n          recentSearch.unshift(peerId);\n          if(recentSearch.length > 20) {\n            recentSearch.length = 20;\n          }\n  \n          appStateManager.pushToState('recentSearch', recentSearch);\n          for(const peerId of recentSearch) {\n            appStateManager.requestPeer(peerId, 'recentSearch');\n          }\n        }\n      });\n    }, {capture: true});\n\n    let peopleContainer = document.createElement('div');\n    peopleContainer.classList.add('search-group-scrollable');\n    peopleContainer.append(this.searchGroups.people.list);\n    this.searchGroups.people.container.append(peopleContainer);\n    let peopleScrollable = new ScrollableX(peopleContainer);\n\n    let first = true;\n    let hideNewBtnMenuTimeout: number;\n    //const transition = Transition.bind(null, searchContainer.parentElement, 150);\n    const transition = TransitionSlider(searchContainer.parentElement, 'zoom-fade', 150, (id) => {\n      if(hideNewBtnMenuTimeout) clearTimeout(hideNewBtnMenuTimeout);\n\n      if(id === 0 && !first) {\n        searchSuper.selectTab(0, false);\n        this.inputSearch.onClearClick();\n        hideNewBtnMenuTimeout = window.setTimeout(() => {\n          hideNewBtnMenuTimeout = 0;\n          this.newBtnMenu.classList.remove('is-hidden');\n        }, 150);\n      }\n\n      first = false;\n    });\n\n    transition(0);\n\n    const activeClassName = 'is-visible';\n    const onFocus = () => {\n      this.toolsBtn.classList.remove(activeClassName);\n      this.backBtn.classList.add(activeClassName);\n      this.newBtnMenu.classList.add('is-hidden');\n      this.toolsBtn.parentElement.firstElementChild.classList.toggle('state-back', true);\n\n      if(!isMobileSafari && !appNavigationController.findItemByType('global-search')) {\n        appNavigationController.pushItem({\n          onPop: () => {\n            close();\n          },\n          type: 'global-search'\n        });\n      }\n\n      transition(1);\n    };\n\n    this.inputSearch.input.addEventListener('focus', onFocus);\n    onFocus();\n\n    this.backBtn.addEventListener('click', (e) => {\n      this.toolsBtn.classList.add(activeClassName);\n      this.backBtn.classList.remove(activeClassName);\n      this.toolsBtn.parentElement.firstElementChild.classList.toggle('state-back', false);\n\n      appNavigationController.removeByType('global-search');\n\n      transition(0);\n    });\n\n    const clearRecentSearchBtn = document.createElement('button');\n    clearRecentSearchBtn.classList.add('btn-icon', 'tgico-close');\n    this.searchGroups.recent.nameEl.append(clearRecentSearchBtn);\n    clearRecentSearchBtn.addEventListener('click', () => {\n      this.searchGroups.recent.clear();\n      appStateManager.pushToState('recentSearch', []);\n    });\n  }\n}\n\nexport class SettingSection {\n  public container: HTMLElement;\n  public content: HTMLElement;\n  public title: HTMLElement;\n  public caption: HTMLElement;\n\n  constructor(options: {\n    name?: LangPackKey, \n    caption?: LangPackKey | true,\n    noDelimiter?: boolean\n  }) {\n    this.container = document.createElement('div');\n    this.container.classList.add('sidebar-left-section');\n\n    if(!options.noDelimiter) {\n      const hr = document.createElement('hr');\n      this.container.append(hr);\n    } else {\n      this.container.classList.add('no-delimiter');\n    }\n\n    this.content = this.generateContentElement();\n\n    if(options.name) {\n      this.title = document.createElement('div');\n      this.title.classList.add('sidebar-left-h2', 'sidebar-left-section-name');\n      i18n_({element: this.title, key: options.name});\n      this.content.append(this.title);\n    }\n\n    if(options.caption) {\n      this.caption = this.generateContentElement();\n      this.caption.classList.add('sidebar-left-section-caption');\n\n      if(options.caption !== true) {\n        i18n_({element: this.caption, key: options.caption});\n      }\n    }\n  }\n\n  public generateContentElement() {\n    const content = document.createElement('div');\n    content.classList.add('sidebar-left-section-content');\n    this.container.append(content);\n    return content;\n  }\n}\n\nexport const generateSection = (appendTo: Scrollable, name?: LangPackKey, caption?: LangPackKey) => {\n  const section = new SettingSection({name, caption});\n  appendTo.append(section.container);\n  return section.content;\n};\n\nconst appSidebarLeft = new AppSidebarLeft();\nMOUNT_CLASS_TO.appSidebarLeft = appSidebarLeft;\nexport default appSidebarLeft;\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport appDialogsManager from \"../../../lib/appManagers/appDialogsManager\";\nimport { SliderSuperTab } from \"../../slider\";\n\nexport default class AppArchivedTab extends SliderSuperTab {\n  private static filterId = 1;\n  private wasFilterId: number;\n\n  init() {\n    this.container.id = 'chats-archived-container';\n    this.setTitle('ArchivedChats');\n\n    if(!appDialogsManager.chatLists[AppArchivedTab.filterId]) {\n      const chatList = appDialogsManager.createChatList();\n      appDialogsManager.generateScrollable(chatList, AppArchivedTab.filterId);\n      appDialogsManager.setListClickListener(chatList, null, true);\n      //appDialogsManager.setListClickListener(archivedChatList, null, true); // * to test peer changing\n    }\n\n    const scrollable = appDialogsManager.scrollables[AppArchivedTab.filterId];\n    this.scrollable.container.replaceWith(scrollable.container);\n    this.scrollable = scrollable;\n  }\n\n  onOpen() {\n    if(this.init) {\n      this.init();\n      this.init = null;\n    }\n\n    this.wasFilterId = appDialogsManager.filterId;\n    appDialogsManager.filterId = AppArchivedTab.filterId;\n    appDialogsManager.onTabChange();\n  }\n\n  // \u0432\u043e\u043e\u0431\u0449\u0435, \u0442\u0430\u043a \u0434\u0435\u043b\u0430\u0442\u044c \u043d\u0435\u043b\u044c\u0437\u044f, \u043d\u043e \u043d\u0435\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0447\u0442\u043e\u0431\u044b \u043f\u0435\u0440\u0435\u0434\u0435\u043b\u0430\u0442\u044c \u0433\u043b\u0430\u0432\u043d\u044b\u0439 \u0447\u0430\u0442\u043b\u0438\u0441\u0442 \u043d\u0430 \u0441\u043b\u0430\u0439\u0434...\n  onOpenAfterTimeout() {\n    appDialogsManager.chatLists[this.wasFilterId].innerHTML = '';\n  }\n\n  onClose() {\n    appDialogsManager.filterId = this.wasFilterId;\n    appDialogsManager.onTabChange();\n  }\n\n  onCloseAfterTimeout() {\n    appDialogsManager.chatLists[AppArchivedTab.filterId].innerHTML = '';\n    return super.onCloseAfterTimeout();\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport { SliderSuperTab } from \"../../slider\";\nimport appDialogsManager from \"../../../lib/appManagers/appDialogsManager\";\nimport appUsersManager from \"../../../lib/appManagers/appUsersManager\";\nimport appPhotosManager from \"../../../lib/appManagers/appPhotosManager\";\nimport rootScope from \"../../../lib/rootScope\";\nimport InputSearch from \"../../inputSearch\";\nimport { isMobile } from \"../../../helpers/userAgent\";\nimport { canFocus } from \"../../../helpers/dom/canFocus\";\n\n// TODO: \u043f\u043e\u0438\u0441\u043a \u043f\u043e \u043b\u044e\u0434\u044f\u043c \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0439, \u0435\u0441\u043b\u0438 \u043d\u0435 \u043d\u0430\u0448\u043b\u043e \u0432 \u043a\u043e\u043d\u0442\u0430\u043a\u0442\u0430\u0445 \u043d\u0438\u043a\u043e\u0433\u043e\n\nexport default class AppContactsTab extends SliderSuperTab {\n  private list: HTMLUListElement;\n  private promise: Promise<void>;\n\n  private inputSearch: InputSearch;\n  private alive = true;\n  \n  init() {\n    this.container.id = 'contacts-container';\n\n    this.list = appDialogsManager.createChatList(/* {avatarSize: 48, handheldsSize: 66} */);\n    this.list.id = 'contacts';\n    this.list.classList.add('contacts-container');\n\n    appDialogsManager.setListClickListener(this.list, () => {\n      (this.container.querySelector('.sidebar-close-button') as HTMLElement).click();\n    }, undefined, true);\n\n    this.inputSearch = new InputSearch('Search', (value) => {\n      this.list.innerHTML = '';\n      this.openContacts(value);\n    });\n\n    this.title.replaceWith(this.inputSearch.container);\n\n    this.scrollable.append(this.list);\n\n    // preload contacts\n    // appUsersManager.getContacts();\n  }\n\n  onClose() {\n    this.alive = false;\n    /* // need to clear, and left 1 page for smooth slide\n    let pageCount = appPhotosManager.windowH / 72 * 1.25 | 0;\n    (Array.from(this.list.children) as HTMLElement[]).slice(pageCount).forEach(el => el.remove()); */\n  }\n\n  onOpenAfterTimeout() {\n    if(isMobile || !canFocus(true)) return;\n    this.inputSearch.input.focus();\n  }\n\n  public openContacts(query?: string) {\n    if(this.init) {\n      this.init();\n      this.init = null;\n    }\n\n    if(this.promise) return this.promise;\n    this.scrollable.onScrolledBottom = null;\n\n    this.promise = appUsersManager.getContacts(query).then(_contacts => {\n      this.promise = null;\n\n      if(!this.alive) {\n        //console.warn('user closed contacts before it\\'s loaded');\n        return;\n      }\n\n      const contacts = [..._contacts];\n\n      if(!query) {\n        contacts.findAndSplice(u => u === rootScope.myId);\n      }\n      /* if(query && 'saved messages'.includes(query.toLowerCase())) {\n        contacts.unshift(rootScope.myID);\n      } */\n\n      let sorted = contacts\n      .map(userId => {\n        let user = appUsersManager.getUser(userId);\n        let status = appUsersManager.getUserStatusForSort(user.status);\n\n        return {user, status};\n      })\n      .sort((a, b) => b.status - a.status);\n\n      let renderPage = () => {\n        let pageCount = appPhotosManager.windowH / 72 * 1.25 | 0;\n        let arr = sorted.splice(0, pageCount); // \u043d\u0430\u0434\u043e splice!\n\n        arr.forEach(({user}) => {\n          let {dialog, dom} = appDialogsManager.addDialogNew({\n            dialog: user.id,\n            container: this.list,\n            drawStatus: false,\n            avatarSize: 48,\n            autonomous: true\n          });\n  \n          let status = appUsersManager.getUserStatusString(user.id);\n          dom.lastMessageSpan.append(status);\n        });\n\n        if(!sorted.length) renderPage = undefined;\n      };\n\n      renderPage();\n      this.scrollable.onScrolledBottom = () => {\n        if(renderPage) {\n          renderPage();\n        } else {\n          this.scrollable.onScrolledBottom = null;\n        }\n      };\n    });\n  }\n\n  public open() {\n    this.openContacts();\n    return super.open();\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport { attachClickEvent } from \"../../../helpers/dom/clickEvent\";\nimport findUpTag from \"../../../helpers/dom/findUpTag\";\nimport replaceContent from \"../../../helpers/dom/replaceContent\";\nimport ListenerSetter from \"../../../helpers/listenerSetter\";\nimport ScrollableLoader from \"../../../helpers/listLoader\";\nimport { ChannelParticipant, Chat, ChatBannedRights, Update } from \"../../../layer\";\nimport appChatsManager, { ChatRights } from \"../../../lib/appManagers/appChatsManager\";\nimport appDialogsManager from \"../../../lib/appManagers/appDialogsManager\";\nimport appPeersManager from \"../../../lib/appManagers/appPeersManager\";\nimport appProfileManager from \"../../../lib/appManagers/appProfileManager\";\nimport I18n, { i18n, join, LangPackKey } from \"../../../lib/langPack\";\nimport rootScope from \"../../../lib/rootScope\";\nimport CheckboxField from \"../../checkboxField\";\nimport PopupPickUser from \"../../popups/pickUser\";\nimport Row from \"../../row\";\nimport { SettingSection } from \"../../sidebarLeft\";\nimport { SliderSuperTabEventable } from \"../../sliderTab\";\nimport { toast } from \"../../toast\";\nimport AppUserPermissionsTab from \"./userPermissions\";\n\nexport class ChatPermissions {\n  public v: Array<{\n    flags: ChatRights[],\n    text: LangPackKey,\n    exceptionText: LangPackKey,\n    checkboxField?: CheckboxField,\n  }>;\n  private toggleWith: Partial<{[chatRight in ChatRights]: ChatRights[]}>;\n\n  constructor(options: {\n    chatId: number,\n    listenerSetter: ListenerSetter,\n    appendTo: HTMLElement,\n    participant?: ChannelParticipant.channelParticipantBanned\n  }) {\n    this.v = [\n      {flags: ['send_messages'], text: 'UserRestrictionsSend', exceptionText: 'UserRestrictionsNoSend'},\n      {flags: ['send_media'], text: 'UserRestrictionsSendMedia', exceptionText: 'UserRestrictionsNoSendMedia'},\n      {flags: ['send_stickers', 'send_gifs'], text: 'UserRestrictionsSendStickers', exceptionText: 'UserRestrictionsNoSendStickers'},\n      {flags: ['send_polls'], text: 'UserRestrictionsSendPolls', exceptionText: 'UserRestrictionsNoSendPolls'},\n      {flags: ['embed_links'], text: 'UserRestrictionsEmbedLinks', exceptionText: 'UserRestrictionsNoEmbedLinks'},\n      {flags: ['invite_users'], text: 'UserRestrictionsInviteUsers', exceptionText: 'UserRestrictionsNoInviteUsers'},\n      {flags: ['pin_messages'], text: 'UserRestrictionsPinMessages', exceptionText: 'UserRestrictionsNoPinMessages'},\n      {flags: ['change_info'], text: 'UserRestrictionsChangeInfo', exceptionText: 'UserRestrictionsNoChangeInfo'}\n    ];\n\n    this.toggleWith = {\n      'send_messages': ['send_media', 'send_stickers', 'send_polls', 'embed_links']\n    };\n\n    const chat: Chat.chat = appChatsManager.getChat(options.chatId);\n    const defaultBannedRights = chat.default_banned_rights;\n    const rights = options.participant ? appChatsManager.combineParticipantBannedRights(options.chatId, options.participant.banned_rights) : defaultBannedRights;\n    \n    for(const info of this.v) {\n      const mainFlag = info.flags[0];\n      info.checkboxField = new CheckboxField({\n        text: info.text,\n        checked: appChatsManager.hasRights(options.chatId, mainFlag, rights),\n        restriction: true,\n        withRipple: true\n      });\n\n      // @ts-ignore\n      if(options.participant && defaultBannedRights.pFlags[mainFlag]) {\n        info.checkboxField.input.disabled = true;\n        \n        /* options.listenerSetter.add(info.checkboxField.input)('change', (e) => {\n          if(!e.isTrusted) {\n            return;\n          }\n\n          cancelEvent(e);\n          toast('This option is disabled for all members in Group Permissions.');\n          info.checkboxField.checked = false;\n        }); */\n\n        attachClickEvent(info.checkboxField.label, (e) => {\n          toast(I18n.format('UserRestrictionsDisabled', true));\n        }, {listenerSetter: options.listenerSetter});\n      }\n\n      if(this.toggleWith[mainFlag]) {\n        options.listenerSetter.add(info.checkboxField.input)('change', () => {\n          if(!info.checkboxField.checked) {\n            const other = this.v.filter(i => this.toggleWith[mainFlag].includes(i.flags[0]));\n            other.forEach(info => {\n              info.checkboxField.checked = false;\n            });\n          }\n        });\n      }\n\n      options.appendTo.append(info.checkboxField.label);\n    }\n  }\n\n  public takeOut() {\n    const rights: ChatBannedRights = {\n      _: 'chatBannedRights',\n      until_date: 0x7FFFFFFF,\n      pFlags: {}\n    };\n\n    for(const info of this.v) {\n      const banned = !info.checkboxField.checked;\n      if(banned) {\n        info.flags.forEach(flag => {\n          // @ts-ignore\n          rights.pFlags[flag] = true;\n        });\n      }\n    }\n\n    return rights;\n  }\n}\n\nexport default class AppGroupPermissionsTab extends SliderSuperTabEventable {\n  public chatId: number;\n\n  protected async init() {\n    this.container.classList.add('edit-peer-container', 'group-permissions-container');\n    this.setTitle('ChannelPermissions');\n\n    let chatPermissions: ChatPermissions;\n    {\n      const section = new SettingSection({\n        name: 'ChannelPermissionsHeader',\n      });\n\n      chatPermissions = new ChatPermissions({\n        chatId: this.chatId,\n        listenerSetter: this.listenerSetter,\n        appendTo: section.content,\n      });\n\n      this.eventListener.addEventListener('destroy', () => {\n        appChatsManager.editChatDefaultBannedRights(this.chatId, chatPermissions.takeOut());\n      }, {once: true});\n\n      this.scrollable.append(section.container);\n    }\n    \n    {\n      const section = new SettingSection({\n        name: 'PrivacyExceptions'\n      });\n\n      const addExceptionRow = new Row({\n        titleLangKey: 'ChannelAddException',\n        subtitleLangKey: 'Loading',\n        icon: 'adduser',\n        clickable: () => {\n          new PopupPickUser({\n            peerTypes: ['channelParticipants'],\n            onSelect: (peerId) => {\n              setTimeout(() => {\n                openPermissions(peerId);\n              }, 0);\n            },\n            placeholder: 'ExceptionModal.Search.Placeholder',\n            peerId: -this.chatId,\n          });\n        }\n      });\n\n      const openPermissions = async(peerId: number) => {\n        let participant: AppUserPermissionsTab['participant'];\n        try {\n          participant = await appProfileManager.getChannelParticipant(this.chatId, peerId) as any;\n        } catch(err) {\n          toast('User is no longer participant');\n          return;\n        }\n\n        const tab = new AppUserPermissionsTab(this.slider);\n        tab.participant = participant;\n        tab.chatId = this.chatId;\n        tab.userId = peerId;\n        tab.open();\n      };\n\n      section.content.append(addExceptionRow.container);\n\n      /* const removedUsersRow = new Row({\n        titleLangKey: 'ChannelBlockedUsers',\n        subtitleLangKey: 'NoBlockedUsers',\n        icon: 'deleteuser',\n        clickable: true\n      });\n\n      section.content.append(removedUsersRow.container); */\n\n      const c = section.generateContentElement();\n      c.classList.add('chatlist-container');\n      \n      const list = appDialogsManager.createChatList();\n      c.append(list);\n\n      attachClickEvent(list, (e) => {\n        const target = findUpTag(e.target, 'LI');\n        if(!target) return;\n\n        const peerId = +target.dataset.peerId;\n        openPermissions(peerId);\n      }, {listenerSetter: this.listenerSetter});\n\n      const setSubtitle = (li: Element, participant: ChannelParticipant.channelParticipantBanned) => {\n        const bannedRights = participant.banned_rights;//appChatsManager.combineParticipantBannedRights(this.chatId, participant.banned_rights);\n        const defaultBannedRights = (appChatsManager.getChat(this.chatId) as Chat.channel).default_banned_rights;\n        //const combinedRights = appChatsManager.combineParticipantBannedRights(this.chatId, bannedRights);\n\n        const cantWhat: LangPackKey[] = []/* , canWhat: LangPackKey[] = [] */;\n        chatPermissions.v.forEach(info => {\n          const mainFlag = info.flags[0];\n          // @ts-ignore\n          if(bannedRights.pFlags[mainFlag] && !defaultBannedRights.pFlags[mainFlag]) {\n            cantWhat.push(info.exceptionText);\n          // @ts-ignore\n          }/*  else if(!combinedRights.pFlags[mainFlag]) {\n            canWhat.push(info.exceptionText);\n          } */\n        });\n\n        const el = li.querySelector('.user-last-message') as HTMLElement;\n\n        if(cantWhat.length) {\n          el.innerHTML = '';\n          el.append(...join(cantWhat.map(t => i18n(t)), false));\n        }/*  else if(canWhat.length) {\n          str = 'Can ' + canWhat.join(canWhat.length === 2 ? ' and ' : ', ');\n        } */\n  \n        el.classList.toggle('hide', !cantWhat.length);\n      };\n\n      const add = (participant: ChannelParticipant.channelParticipantBanned, append: boolean) => {\n        const {dom} = appDialogsManager.addDialogNew({\n          dialog: appPeersManager.getPeerId(participant.peer),\n          container: list,\n          drawStatus: false,\n          rippleEnabled: true,\n          avatarSize: 48,\n          append\n        });\n\n        setSubtitle(dom.listEl, participant);\n\n        //dom.titleSpan.innerHTML = 'Chinaza Akachi';\n        //dom.lastMessageSpan.innerHTML = 'Can Add Users and Pin Messages';\n      };\n\n      this.listenerSetter.add(rootScope)('updateChannelParticipant', (update: Update.updateChannelParticipant) => {\n        const needAdd = update.new_participant?._ === 'channelParticipantBanned' && !update.new_participant.banned_rights.pFlags.view_messages;\n        const li = list.querySelector(`[data-peer-id=\"${update.user_id}\"]`);\n        if(needAdd) {\n          if(!li) {\n            add(update.new_participant as ChannelParticipant.channelParticipantBanned, false);\n          } else {\n            setSubtitle(li, update.new_participant as ChannelParticipant.channelParticipantBanned);\n          }\n\n          if(update.prev_participant?._ !== 'channelParticipantBanned') {\n            ++exceptionsCount;\n          }\n        } else {\n          if(li) {\n            li.remove();\n          }\n\n          if(update.prev_participant?._ === 'channelParticipantBanned') {\n            --exceptionsCount;\n          }\n        }\n\n        setLength();\n      });\n\n      const setLength = () => {\n        replaceContent(addExceptionRow.subtitle, i18n(exceptionsCount ? 'Permissions.ExceptionsCount' : 'Permissions.NoExceptions', [exceptionsCount]));\n      };\n\n      let exceptionsCount = 0;\n      const LOAD_COUNT = 50;\n      const loader = new ScrollableLoader({\n        scrollable: this.scrollable,\n        getPromise: () => {\n          return appProfileManager.getChannelParticipants(this.chatId, {_: 'channelParticipantsBanned', q: ''}, LOAD_COUNT, list.childElementCount).then(res => {\n            for(const participant of res.participants) {\n              add(participant as ChannelParticipant.channelParticipantBanned, true);\n            }\n\n            exceptionsCount = res.count;\n            setLength();\n\n            return res.participants.length < LOAD_COUNT || res.count === list.childElementCount;\n          });\n        }\n      });\n\n      this.scrollable.append(section.container);\n\n      await loader.load();\n    }\n  }\n\n  onOpenAfterTimeout() {\n    this.scrollable.onScroll();\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport appImManager from \"../../../lib/appManagers/appImManager\";\nimport appMessagesManager, { AppMessagesManager } from \"../../../lib/appManagers/appMessagesManager\";\nimport appPeersManager from \"../../../lib/appManagers/appPeersManager\";\nimport appProfileManager from \"../../../lib/appManagers/appProfileManager\";\nimport appUsersManager, { User } from \"../../../lib/appManagers/appUsersManager\";\nimport { RichTextProcessor } from \"../../../lib/richtextprocessor\";\nimport rootScope from \"../../../lib/rootScope\";\nimport AppSearchSuper, { SearchSuperType } from \"../../appSearchSuper.\";\nimport AvatarElement, { openAvatarViewer } from \"../../avatar\";\nimport SidebarSlider, { SliderSuperTab } from \"../../slider\";\nimport CheckboxField from \"../../checkboxField\";\nimport appSidebarRight from \"..\";\nimport { TransitionSlider } from \"../../transition\";\nimport appNotificationsManager from \"../../../lib/appManagers/appNotificationsManager\";\nimport AppEditChatTab from \"./editChat\";\nimport PeerTitle from \"../../peerTitle\";\nimport AppEditContactTab from \"./editContact\";\nimport appChatsManager, { Channel } from \"../../../lib/appManagers/appChatsManager\";\nimport { Chat, Message, MessageAction, ChatFull, Photo } from \"../../../layer\";\nimport Button from \"../../button\";\nimport ButtonIcon from \"../../buttonIcon\";\nimport I18n, { i18n, LangPackKey } from \"../../../lib/langPack\";\nimport { SettingSection } from \"../../sidebarLeft\";\nimport Row from \"../../row\";\nimport { copyTextToClipboard } from \"../../../helpers/clipboard\";\nimport { toast, toastNew } from \"../../toast\";\nimport { fastRaf } from \"../../../helpers/schedulers\";\nimport { safeAssign } from \"../../../helpers/object\";\nimport { forEachReverse } from \"../../../helpers/array\";\nimport appPhotosManager from \"../../../lib/appManagers/appPhotosManager\";\nimport renderImageFromUrl from \"../../../helpers/dom/renderImageFromUrl\";\nimport SwipeHandler from \"../../swipeHandler\";\nimport { MOUNT_CLASS_TO } from \"../../../config/debug\";\nimport AppAddMembersTab from \"../../sidebarLeft/tabs/addMembers\";\nimport PopupPickUser from \"../../popups/pickUser\";\nimport PopupPeer, { PopupPeerButtonCallbackCheckboxes, PopupPeerCheckboxOptions } from \"../../popups/peer\";\nimport Scrollable from \"../../scrollable\";\nimport { isTouchSupported } from \"../../../helpers/touchSupport\";\nimport { isFirefox } from \"../../../helpers/userAgent\";\nimport appDownloadManager from \"../../../lib/appManagers/appDownloadManager\";\nimport ButtonCorner from \"../../buttonCorner\";\nimport { cancelEvent } from \"../../../helpers/dom/cancelEvent\";\nimport { attachClickEvent } from \"../../../helpers/dom/clickEvent\";\nimport replaceContent from \"../../../helpers/dom/replaceContent\";\nimport appAvatarsManager from \"../../../lib/appManagers/appAvatarsManager\";\n\nlet setText = (text: string, row: Row) => {\n  //fastRaf(() => {\n    row.title.innerHTML = text;\n    row.container.style.display = '';\n  //});\n};\n\nconst PARALLAX_SUPPORTED = !isFirefox;\n\ntype ListLoaderResult<T> = {count: number, items: any[]};\nclass ListLoader<T> {\n  public current: T;\n  public previous: T[] = [];\n  public next: T[] = [];\n  public count: number;\n\n  public tempId = 0;\n  public loadMore: (anchor: T, older: boolean) => Promise<ListLoaderResult<T>>;\n  public processItem: (item: any) => false | T;\n  public onJump: (item: T, older: boolean) => void;\n  public loadCount = 50;\n  public reverse = false; // reverse means next = higher msgid\n\n  public loadedAllUp = false;\n  public loadedAllDown = false;\n  public loadPromiseUp: Promise<void>;\n  public loadPromiseDown: Promise<void>;\n\n  constructor(options: {\n    loadMore: ListLoader<T>['loadMore'],\n    loadCount: ListLoader<T>['loadCount'],\n    processItem?: ListLoader<T>['processItem'],\n    onJump: ListLoader<T>['onJump'],\n  }) {\n    safeAssign(this, options);\n\n\n  }\n\n  get index() {\n    return this.count !== undefined ? this.previous.length : -1;\n  }\n\n  public go(length: number) {\n    let items: T[], item: T;\n    if(length > 0) {\n      items = this.next.splice(0, length);\n      item = items.pop();\n      if(!item) {\n        return;\n      }\n\n      this.previous.push(this.current, ...items);\n    } else {\n      items = this.previous.splice(this.previous.length + length, -length);\n      item = items.shift();\n      if(!item) {\n        return;\n      }\n\n      this.next.unshift(...items, this.current);\n    }\n\n    this.current = item;\n    this.onJump(item, length > 0);\n  }\n\n  public load(older: boolean) {\n    if(older && this.loadedAllDown) return Promise.resolve();\n    else if(!older && this.loadedAllUp) return Promise.resolve();\n\n    if(older && this.loadPromiseDown) return this.loadPromiseDown;\n    else if(!older && this.loadPromiseUp) return this.loadPromiseUp;\n\n    /* const loadCount = 50;\n    const backLimit = older ? 0 : loadCount; */\n  \n    let anchor: T;\n    if(older) {\n      anchor = this.reverse ? this.previous[0] : this.next[this.next.length - 1];\n    } else {\n      anchor = this.reverse ? this.next[this.next.length - 1] : this.previous[0];\n    }\n\n    const promise = this.loadMore(anchor, older).then(result => {\n      if(result.items.length < this.loadCount) {\n        if(older) this.loadedAllDown = true;\n        else this.loadedAllUp = true;\n      }\n\n      if(this.count === undefined) {\n        this.count = result.count || result.items.length;\n      }\n\n      const method = older ? result.items.forEach.bind(result.items) : forEachReverse.bind(null, result.items);\n      method((item: any) => {\n        const processed = this.processItem ? this.processItem(item) : item;\n\n        if(!processed) return;\n\n        if(older) {\n          if(this.reverse) this.previous.unshift(processed);\n          else this.next.push(processed);\n        } else {\n          if(this.reverse) this.next.push(processed);\n          else this.previous.unshift(processed);\n        }\n      });\n    }, () => {}).then(() => {\n      if(older) this.loadPromiseDown = null;\n      else this.loadPromiseUp = null;\n    });\n\n    if(older) this.loadPromiseDown = promise;\n    else this.loadPromiseUp = promise;\n\n    return promise;\n  }\n}\n\nclass PeerProfileAvatars {\n  private static BASE_CLASS = 'profile-avatars';\n  private static SCALE = PARALLAX_SUPPORTED ? 2 : 1;\n  private static TRANSLATE_TEMPLATE = PARALLAX_SUPPORTED ? `translate3d({x}, 0, -1px) scale(${PeerProfileAvatars.SCALE})` : 'translate({x}, 0)';\n  public container: HTMLElement;\n  public avatars: HTMLElement;\n  public gradient: HTMLElement;\n  public info: HTMLElement;\n  public arrowPrevious: HTMLElement;\n  public arrowNext: HTMLElement;\n  private tabs: HTMLDivElement;\n  private listLoader: ListLoader<string | Message.messageService>;\n  private peerId: number;\n\n  constructor(public scrollable: Scrollable) {\n    this.container = document.createElement('div');\n    this.container.classList.add(PeerProfileAvatars.BASE_CLASS + '-container');\n\n    this.avatars = document.createElement('div');\n    this.avatars.classList.add(PeerProfileAvatars.BASE_CLASS + '-avatars');\n\n    this.gradient = document.createElement('div');\n    this.gradient.classList.add(PeerProfileAvatars.BASE_CLASS + '-gradient');\n\n    this.info = document.createElement('div');\n    this.info.classList.add(PeerProfileAvatars.BASE_CLASS + '-info');\n\n    this.tabs = document.createElement('div');\n    this.tabs.classList.add(PeerProfileAvatars.BASE_CLASS + '-tabs');\n\n    this.arrowPrevious = document.createElement('div');\n    this.arrowPrevious.classList.add(PeerProfileAvatars.BASE_CLASS + '-arrow');\n\n    /* const previousIcon = document.createElement('i');\n    previousIcon.classList.add(PeerProfileAvatars.BASE_CLASS + '-arrow-icon', 'tgico-previous');\n    this.arrowBack.append(previousIcon); */\n    \n    this.arrowNext = document.createElement('div');\n    this.arrowNext.classList.add(PeerProfileAvatars.BASE_CLASS + '-arrow', PeerProfileAvatars.BASE_CLASS + '-arrow-next');\n\n    /* const nextIcon = document.createElement('i');\n    nextIcon.classList.add(PeerProfileAvatars.BASE_CLASS + '-arrow-icon', 'tgico-next');\n    this.arrowNext.append(nextIcon); */\n\n    this.container.append(this.avatars, this.gradient, this.info, this.tabs, this.arrowPrevious, this.arrowNext);\n\n    const checkScrollTop = () => {\n      if(this.scrollable.scrollTop !== 0) {\n        this.scrollable.scrollIntoViewNew(this.scrollable.container.firstElementChild as HTMLElement, 'start');\n        return false;\n      }\n\n      return true;\n    };\n\n    const SWITCH_ZONE = 1 / 3;\n    let cancel = false;\n    let freeze = false;\n    attachClickEvent(this.container, async(_e) => {\n      if(freeze) {\n        cancelEvent(_e);\n        return;\n      }\n\n      if(cancel) {\n        cancel = false;\n        return;\n      }\n\n      if(!checkScrollTop()) {\n        return;\n      }\n\n      const rect = this.container.getBoundingClientRect();\n\n      const e = (_e as TouchEvent).touches ? (_e as TouchEvent).touches[0] : _e as MouseEvent;\n      const x = e.pageX;\n\n      const clickX = x - rect.left;\n      if((!this.listLoader.previous.length && !this.listLoader.next.length) \n        || (clickX > (rect.width * SWITCH_ZONE) && clickX < (rect.width - rect.width * SWITCH_ZONE))) {\n        const peerId = this.peerId;\n\n        const targets: {element: HTMLElement, item: string | Message.messageService}[] = [];\n        this.listLoader.previous.concat(this.listLoader.current, this.listLoader.next).forEach((item, idx) => {\n          targets.push({\n            element: /* null */this.avatars.children[idx] as HTMLElement,\n            item\n          });\n        });\n\n        const prevTargets = targets.slice(0, this.listLoader.previous.length);\n        const nextTargets = targets.slice(this.listLoader.previous.length + 1);\n\n        const target = this.avatars.children[this.listLoader.previous.length] as HTMLElement;\n        freeze = true;\n        openAvatarViewer(target, peerId, () => peerId === this.peerId, this.listLoader.current, prevTargets, nextTargets);\n        freeze = false;\n      } else {\n        const centerX = rect.right - (rect.width / 2);\n        const toRight = x > centerX;\n  \n        // this.avatars.classList.remove('no-transition');\n        // fastRaf(() => {\n          this.avatars.classList.add('no-transition');\n          void this.avatars.offsetLeft; // reflow\n\n          let distance: number;\n          if(this.listLoader.index === 0 && !toRight) distance = this.listLoader.count - 1;\n          else if(this.listLoader.index === (this.listLoader.count - 1) && toRight) distance = -(this.listLoader.count - 1);\n          else distance = toRight ? 1 : -1;\n          this.listLoader.go(distance);\n\n          fastRaf(() => {\n            this.avatars.classList.remove('no-transition');\n          });\n        // });\n      }\n    });\n\n    const cancelNextClick = () => {\n      cancel = true;\n      document.body.addEventListener(isTouchSupported ? 'touchend' : 'click', (e) => {\n        cancel = false;\n      }, {once: true});\n    };\n\n    let width = 0, x = 0, lastDiffX = 0, lastIndex = 0, minX = 0;\n    const swipeHandler = new SwipeHandler({\n      element: this.avatars, \n      onSwipe: (xDiff, yDiff) => {\n        lastDiffX = xDiff;\n        let lastX = x + xDiff * -PeerProfileAvatars.SCALE;\n        if(lastX > 0) lastX = 0;\n        else if(lastX < minX) lastX = minX;\n\n        this.avatars.style.transform = PeerProfileAvatars.TRANSLATE_TEMPLATE.replace('{x}', lastX + 'px');\n        //console.log(xDiff, yDiff);\n        return false;\n      }, \n      verifyTouchTarget: (e) => {\n        if(!checkScrollTop()) {\n          cancelNextClick();\n          cancelEvent(e);\n          return false;\n        } else if(this.container.classList.contains('is-single') || freeze) {\n          return false;\n        }\n\n        return true;\n      }, \n      onFirstSwipe: () => {\n        const rect = this.avatars.getBoundingClientRect();\n        width = rect.width;\n        minX = -width * (this.tabs.childElementCount - 1);\n\n        /* lastIndex = whichChild(this.tabs.querySelector('.active'));\n        x = -width * lastIndex; */\n        x = rect.left - this.container.getBoundingClientRect().left;\n        \n        this.avatars.style.transform = PeerProfileAvatars.TRANSLATE_TEMPLATE.replace('{x}', x + 'px');\n\n        this.container.classList.add('is-swiping');\n        this.avatars.classList.add('no-transition');\n        void this.avatars.offsetLeft; // reflow\n      },\n      onReset: () => {\n        const addIndex = Math.ceil(Math.abs(lastDiffX) / (width / PeerProfileAvatars.SCALE)) * (lastDiffX >= 0 ? 1 : -1);\n        cancelNextClick();\n        \n        //console.log(addIndex);\n\n        this.avatars.classList.remove('no-transition');\n        fastRaf(() => {\n          this.listLoader.go(addIndex);\n          this.container.classList.remove('is-swiping');\n        });\n      }\n    });\n  }\n\n  public setPeer(peerId: number) {\n    this.peerId = peerId;\n\n    const photo = appPeersManager.getPeerPhoto(peerId);\n    if(!photo) {\n      return;\n    }\n\n    const loadCount = 50;\n    const listLoader: PeerProfileAvatars['listLoader'] = this.listLoader = new ListLoader<string | Message.messageService>({\n      loadCount,\n      loadMore: (anchor, older) => {\n        if(peerId > 0) {\n          return appPhotosManager.getUserPhotos(peerId, (anchor || listLoader.current) as any, loadCount).then(result => {\n            return {\n              count: result.count,\n              items: result.photos\n            };\n          });\n        } else {\n          const promises: [Promise<ChatFull>, ReturnType<AppMessagesManager['getSearch']>] = [] as any;\n          if(!listLoader.current) {\n            promises.push(appProfileManager.getChatFull(-peerId));\n          }\n          \n          promises.push(appMessagesManager.getSearch({\n            peerId,\n            maxId: Number.MAX_SAFE_INTEGER,\n            inputFilter: {\n              _: 'inputMessagesFilterChatPhotos'\n            },\n            limit: loadCount,\n            backLimit: 0\n          }));\n\n          return Promise.all(promises).then((result) => {\n            const value = result.pop() as typeof result[1];\n\n            if(!listLoader.current) {\n              const chatFull = result[0];\n              const message = value.history.findAndSplice(m => {\n                return ((m as Message.messageService).action as MessageAction.messageActionChannelEditPhoto).photo.id === chatFull.chat_photo.id;\n              }) as Message.messageService;\n              \n              listLoader.current = message || appMessagesManager.generateFakeAvatarMessage(this.peerId, chatFull.chat_photo);\n            }\n\n            //console.log('avatars loaded:', value);\n            return {\n              count: value.count,\n              items: value.history\n            };\n          });\n        }\n      },\n      processItem: this.processItem,\n      onJump: (item, older) => {\n        const id = this.listLoader.index;\n        //const nextId = Math.max(0, id);\n        const x = 100 * PeerProfileAvatars.SCALE * id;\n        this.avatars.style.transform = PeerProfileAvatars.TRANSLATE_TEMPLATE.replace('{x}', `-${x}%`);\n\n        const activeTab = this.tabs.querySelector('.active');\n        if(activeTab) activeTab.classList.remove('active');\n\n        const tab = this.tabs.children[id] as HTMLElement;\n        tab.classList.add('active');\n      }\n    });\n\n    if(photo._ === 'userProfilePhoto') {\n      listLoader.current = photo.photo_id;\n    }\n\n    this.processItem(listLoader.current);\n\n    listLoader.load(true);\n  }\n\n  public addTab() {\n    const tab = document.createElement('div');\n    tab.classList.add(PeerProfileAvatars.BASE_CLASS + '-tab');\n    this.tabs.append(tab);\n\n    if(this.tabs.childElementCount === 1) {\n      tab.classList.add('active');\n    }\n\n    this.container.classList.toggle('is-single', this.tabs.childElementCount <= 1);\n  }\n\n  public processItem = (photoId: string | Message.messageService) => {\n    const avatar = document.createElement('div');\n    avatar.classList.add(PeerProfileAvatars.BASE_CLASS + '-avatar');\n\n    let photo: Photo.photo;\n    if(photoId) {\n      photo = typeof(photoId) === 'string' ? \n        appPhotosManager.getPhoto(photoId) : \n        (photoId.action as MessageAction.messageActionChannelEditPhoto).photo as Photo.photo;\n    }\n\n    const img = new Image();\n    img.classList.add(PeerProfileAvatars.BASE_CLASS + '-avatar-image');\n    img.draggable = false;\n\n    if(photo) {\n      const size = appPhotosManager.choosePhotoSize(photo, 420, 420, false);\n      appPhotosManager.preloadPhoto(photo, size).then(() => {\n        const cacheContext = appDownloadManager.getCacheContext(photo, size.type);\n        renderImageFromUrl(img, cacheContext.url, () => {\n          avatar.append(img);\n        });\n      });\n    } else {\n      const photo = appPeersManager.getPeerPhoto(this.peerId);\n      appAvatarsManager.putAvatar(avatar, this.peerId, photo, 'photo_big', img);\n    }\n\n    this.avatars.append(avatar);\n\n    this.addTab();\n\n    return photoId;\n  };\n}\n\nclass PeerProfile {\n  public element: HTMLElement;\n  public avatars: PeerProfileAvatars;\n  private avatar: AvatarElement;\n  private section: SettingSection;\n  private name: HTMLDivElement;\n  private subtitle: HTMLDivElement;\n  private bio: Row;\n  private username: Row;\n  private phone: Row;\n  private notifications: Row;\n  \n  private cleaned: boolean;\n  private setBioTimeout: number;\n  private setPeerStatusInterval: number;\n\n  private peerId = 0;\n  private threadId: number;\n\n  constructor(public scrollable: Scrollable) {\n    if(!PARALLAX_SUPPORTED) {\n      this.scrollable.container.classList.add('no-parallax');\n    }\n  }\n\n  public init() {\n    this.init = null;\n\n    this.element = document.createElement('div');\n    this.element.classList.add('profile-content');\n\n    this.section = new SettingSection({\n      noDelimiter: true\n    });\n\n    this.avatar = new AvatarElement();\n    this.avatar.classList.add('profile-avatar', 'avatar-120');\n    this.avatar.setAttribute('dialog', '1');\n    this.avatar.setAttribute('clickable', '');\n\n    this.name = document.createElement('div');\n    this.name.classList.add('profile-name');\n\n    this.subtitle = document.createElement('div');\n    this.subtitle.classList.add('profile-subtitle');\n\n    this.bio = new Row({\n      title: ' ',\n      subtitleLangKey: 'UserBio',\n      icon: 'info',\n      clickable: (e) => {\n        if((e.target as HTMLElement).tagName === 'A') {\n          return;\n        }\n        \n        appProfileManager.getProfileByPeerId(this.peerId).then(full => {\n          copyTextToClipboard(full.about);\n          toast(I18n.format('BioCopied', true));\n        });\n      }\n    });\n\n    this.bio.title.classList.add('pre-wrap');\n\n    this.username = new Row({\n      title: ' ',\n      subtitleLangKey: 'Username',\n      icon: 'username',\n      clickable: () => {\n        const peer: Channel | User = appPeersManager.getPeer(this.peerId);\n        copyTextToClipboard('@' + peer.username);\n        toast(I18n.format('UsernameCopied', true));\n      }\n    });\n\n    this.phone = new Row({\n      title: ' ',\n      subtitleLangKey: 'Phone',\n      icon: 'phone',\n      clickable: () => {\n        const peer: User = appUsersManager.getUser(this.peerId);\n        copyTextToClipboard('+' + peer.phone);\n        toast(I18n.format('PhoneCopied', true));\n      }\n    });\n\n    this.notifications = new Row({\n      checkboxField: new CheckboxField({toggle: true}),\n      titleLangKey: 'Notifications',\n      icon: 'unmute'\n    });\n    \n    this.section.content.append(this.phone.container, this.username.container, this.bio.container, this.notifications.container);\n\n    const delimiter = document.createElement('div');\n    delimiter.classList.add('gradient-delimiter');\n\n    this.element.append(this.section.container, delimiter);\n\n    this.notifications.checkboxField.input.addEventListener('change', (e) => {\n      if(!e.isTrusted) {\n        return;\n      }\n\n      //let checked = this.notificationsCheckbox.checked;\n      appMessagesManager.mutePeer(this.peerId);\n    });\n\n    rootScope.addEventListener('dialog_notify_settings', (dialog) => {\n      if(this.peerId === dialog.peerId) {\n        const muted = appNotificationsManager.isPeerLocalMuted(this.peerId, false);\n        this.notifications.checkboxField.checked = !muted;\n      }\n    });\n\n    rootScope.addEventListener('peer_typings', (e) => {\n      const {peerId} = e;\n\n      if(this.peerId === peerId) {\n        this.setPeerStatus();\n      }\n    });\n\n    rootScope.addEventListener('peer_bio_edit', (peerId) => {\n      if(peerId === this.peerId) {\n        this.setBio(true);\n      }\n    });\n\n    rootScope.addEventListener('user_update', (e) => {\n      const userId = e;\n\n      if(this.peerId === userId) {\n        this.setPeerStatus();\n      }\n    });\n\n    this.setPeerStatusInterval = window.setInterval(this.setPeerStatus, 60e3);\n  }\n\n  public setPeerStatus = (needClear = false) => {\n    if(!this.peerId) return;\n\n    const peerId = this.peerId;\n    appImManager.setPeerStatus(this.peerId, this.subtitle, needClear, true, () => peerId === this.peerId);\n  };\n\n  public cleanupHTML() {\n    this.bio.container.style.display = 'none';\n    this.phone.container.style.display = 'none';\n    this.username.container.style.display = 'none';\n    this.notifications.container.style.display = '';\n    this.notifications.checkboxField.checked = true;\n    if(this.setBioTimeout) {\n      window.clearTimeout(this.setBioTimeout);\n      this.setBioTimeout = 0;\n    }\n  }\n\n  public setAvatar() {\n    if(this.peerId !== rootScope.myId) {\n      const photo = appPeersManager.getPeerPhoto(this.peerId);\n\n      if(photo) {\n        const oldAvatars = this.avatars;\n        this.avatars = new PeerProfileAvatars(this.scrollable);\n        this.avatars.setPeer(this.peerId);\n        this.avatars.info.append(this.name, this.subtitle);\n  \n        this.avatar.remove();\n    \n        if(oldAvatars) oldAvatars.container.replaceWith(this.avatars.container);\n        else this.element.prepend(this.avatars.container);\n\n        if(PARALLAX_SUPPORTED) {\n          this.scrollable.container.classList.add('parallax');\n        }\n\n        return;\n      }\n    }\n\n    if(PARALLAX_SUPPORTED) {\n      this.scrollable.container.classList.remove('parallax');\n    }\n\n    if(this.avatars) {\n      this.avatars.container.remove();\n      this.avatars = undefined;\n    }\n\n    this.avatar.setAttribute('peer', '' + this.peerId);\n\n    this.section.content.prepend(this.avatar, this.name, this.subtitle);\n  }\n\n  public fillProfileElements() {\n    if(!this.cleaned) return;\n    this.cleaned = false;\n    \n    const peerId = this.peerId;\n\n    this.cleanupHTML();\n\n    this.setAvatar();\n\n    // username\n    if(peerId !== rootScope.myId) {\n      let username = appPeersManager.getPeerUsername(peerId);\n      if(username) {\n        setText(appPeersManager.getPeerUsername(peerId), this.username);\n      }\n      \n      const muted = appNotificationsManager.isPeerLocalMuted(peerId, false);\n      this.notifications.checkboxField.checked = !muted;\n    } else {\n      window.requestAnimationFrame(() => {\n        this.notifications.container.style.display = 'none';\n      });\n    }\n    \n    //let membersLi = this.profileTabs.firstElementChild.children[0] as HTMLLIElement;\n    if(peerId > 0) {\n      //membersLi.style.display = 'none';\n\n      let user = appUsersManager.getUser(peerId);\n      if(user.phone && peerId !== rootScope.myId) {\n        setText(appUsersManager.formatUserPhone(user.phone), this.phone);\n      }\n    }/*  else {\n      //membersLi.style.display = appPeersManager.isBroadcast(peerId) ? 'none' : '';\n    } */\n\n    this.setBio();\n\n    replaceContent(this.name, new PeerTitle({\n      peerId,\n      dialog: true\n    }).element);\n\n    this.setPeerStatus(true);\n  }\n\n  public setBio(override?: true) {\n    if(this.setBioTimeout) {\n      window.clearTimeout(this.setBioTimeout);\n      this.setBioTimeout = 0;\n    }\n\n    const peerId = this.peerId;\n    const threadId = this.threadId;\n\n    if(!peerId) {\n      return;\n    }\n\n    let promise: Promise<boolean>;\n    if(peerId > 0) {\n      promise = appProfileManager.getProfile(peerId, override).then(userFull => {\n        if(this.peerId !== peerId || this.threadId !== threadId) {\n          //this.log.warn('peer changed');\n          return false;\n        }\n        \n        if(userFull.rAbout && peerId !== rootScope.myId) {\n          setText(userFull.rAbout, this.bio);\n        }\n        \n        //this.log('userFull', userFull);\n        return true;\n      });\n    } else {\n      promise = appProfileManager.getChatFull(-peerId, override).then((chatFull) => {\n        if(this.peerId !== peerId || this.threadId !== threadId) {\n          //this.log.warn('peer changed');\n          return false;\n        }\n        \n        //this.log('chatInfo res 2:', chatFull);\n        \n        if(chatFull.about) {\n          setText(RichTextProcessor.wrapRichText(chatFull.about), this.bio);\n        }\n\n        return true;\n      });\n    }\n\n    promise.then((canSetNext) => {\n      if(canSetNext) {\n        this.setBioTimeout = window.setTimeout(() => this.setBio(true), 60e3);\n      }\n    });\n  }\n\n  public setPeer(peerId: number, threadId = 0) {\n    if(this.peerId === peerId && this.threadId === peerId) return;\n\n    if(this.init) {\n      this.init();\n    }\n\n    this.peerId = peerId;\n    this.threadId = threadId;\n    \n    this.cleaned = true;\n  }\n}\n\n// TODO: \u043e\u0442\u0440\u0435\u0434\u0430\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043d\u0435 \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u0441\u044f\nexport default class AppSharedMediaTab extends SliderSuperTab {\n  private editBtn: HTMLElement;\n\n  private peerId = 0;\n  private threadId = 0;\n\n  private historiesStorage: {\n    [peerId: number]: Partial<{\n      [type in SearchSuperType]: {mid: number, peerId: number}[]\n    }>\n  } = {};\n\n  private searchSuper: AppSearchSuper;\n\n  private profile: PeerProfile;\n  peerChanged: boolean;\n\n  constructor(slider: SidebarSlider) {\n    super(slider, false);\n  }\n\n  public init() {\n    //const perf = performance.now();\n\n    this.container.classList.add('shared-media-container', 'profile-container');\n\n    // * header\n    const newCloseBtn = Button('btn-icon sidebar-close-button', {noRipple: true});\n    this.closeBtn.replaceWith(newCloseBtn);\n    this.closeBtn = newCloseBtn;\n\n    const animatedCloseIcon = document.createElement('div');\n    animatedCloseIcon.classList.add('animated-close-icon');\n    newCloseBtn.append(animatedCloseIcon);\n\n    const transitionContainer = document.createElement('div');\n    transitionContainer.className = 'transition slide-fade';\n    \n    const transitionFirstItem = document.createElement('div');\n    transitionFirstItem.classList.add('transition-item');\n\n    this.title.append(i18n('Profile'));\n    this.editBtn = ButtonIcon('edit');\n    //const moreBtn = ButtonIcon('more');\n\n    transitionFirstItem.append(this.title, this.editBtn/* , moreBtn */);\n\n    const transitionLastItem = document.createElement('div');\n    transitionLastItem.classList.add('transition-item');\n\n    const secondTitle: HTMLElement = this.title.cloneNode() as any;\n    secondTitle.append(i18n('PeerInfo.SharedMedia'));\n\n    transitionLastItem.append(secondTitle);\n\n    transitionContainer.append(transitionFirstItem, transitionLastItem);\n\n    this.header.append(transitionContainer);\n\n    // * body\n\n    this.profile = new PeerProfile(this.scrollable);\n    this.profile.init();\n    \n    this.scrollable.append(this.profile.element);\n\n    const HEADER_HEIGHT = 56;\n    this.scrollable.onAdditionalScroll = () => {\n      const rect = this.searchSuper.nav.getBoundingClientRect(); \n      if(!rect.width) return;\n\n      const top = rect.top - 1;\n      const isSharedMedia = top <= HEADER_HEIGHT;\n      animatedCloseIcon.classList.toggle('state-back', isSharedMedia);\n      this.searchSuper.container.classList.toggle('is-full-viewport', isSharedMedia);\n      transition(+isSharedMedia);\n\n      if(!isSharedMedia) {\n        this.searchSuper.cleanScrollPositions();\n      }\n    };\n\n    const transition = TransitionSlider(transitionContainer, 'slide-fade', 400, null, false);\n\n    transition(0);\n\n    attachClickEvent(this.closeBtn, (e) => {\n      if(this.closeBtn.firstElementChild.classList.contains('state-back')) {\n        this.scrollable.scrollIntoViewNew(this.scrollable.container.firstElementChild as HTMLElement, 'start');\n        transition(0);\n        animatedCloseIcon.classList.remove('state-back');\n      } else if(!this.scrollable.isHeavyAnimationInProgress) {\n        appSidebarRight.onCloseBtnClick();\n      }\n    });\n\n    attachClickEvent(this.editBtn, (e) => {\n      let tab: AppEditChatTab | AppEditContactTab;\n      if(this.peerId < 0) {\n        tab = new AppEditChatTab(appSidebarRight);\n      } else {\n        tab = new AppEditContactTab(appSidebarRight);\n      }\n\n      if(tab) {\n        if(tab instanceof AppEditChatTab) {\n          tab.chatId = -this.peerId;\n        } else {\n          tab.peerId = this.peerId;\n        }\n        \n        tab.open();\n      }\n    });\n\n    //this.container.prepend(this.closeBtn.parentElement);\n\n    this.searchSuper = new AppSearchSuper({\n      mediaTabs: [{\n        inputFilter: 'inputMessagesFilterEmpty',\n        name: 'PeerMedia.Members',\n        type: 'members'\n      }, {\n        inputFilter: 'inputMessagesFilterPhotoVideo',\n        name: 'SharedMediaTab2',\n        type: 'media'\n      }, {\n        inputFilter: 'inputMessagesFilterDocument',\n        name: 'SharedFilesTab2',\n        type: 'files'\n      }, {\n        inputFilter: 'inputMessagesFilterUrl',\n        name: 'SharedLinksTab2',\n        type: 'links'\n      }, {\n        inputFilter: 'inputMessagesFilterMusic',\n        name: 'SharedMusicTab2',\n        type: 'music'\n      }, {\n        inputFilter: 'inputMessagesFilterVoice',\n        name: 'SharedVoiceTab2',\n        type: 'voice'\n      }], \n      scrollable: this.scrollable,\n      onChangeTab: (mediaTab) => {\n        let timeout = mediaTab.type === 'members' && rootScope.settings.animationsEnabled ? 250 : 0;\n        setTimeout(() => {\n          btnAddMembers.classList.toggle('is-hidden', mediaTab.type !== 'members');\n        }, timeout);\n      }\n    });\n\n    this.profile.element.append(this.searchSuper.container);\n\n    const btnAddMembers = ButtonCorner({icon: 'addmember_filled'});\n    this.content.append(btnAddMembers);\n\n    btnAddMembers.addEventListener('click', () => {\n      const id = -this.peerId;\n      const isChannel = appChatsManager.isChannel(id);\n\n      const showConfirmation = (peerIds: number[], callback: (checked: PopupPeerButtonCallbackCheckboxes) => void) => {\n        let titleLangKey: LangPackKey, titleLangArgs: any[],\n          descriptionLangKey: LangPackKey, descriptionLangArgs: any[],\n          checkboxes: PopupPeerCheckboxOptions[];\n\n        if(peerIds.length > 1) {\n          titleLangKey = 'AddMembersAlertTitle';\n          titleLangArgs = [i18n('Members', [peerIds.length])];\n          descriptionLangKey = 'AddMembersAlertCountText';\n          descriptionLangArgs = peerIds.map(peerId => {\n            const b = document.createElement('b');\n            b.append(new PeerTitle({peerId}).element);\n            return b;\n          });\n\n          if(!isChannel) {\n            checkboxes = [{\n              text: 'AddMembersForwardMessages',\n              checked: true\n            }];\n          }\n        } else {\n          titleLangKey = 'AddOneMemberAlertTitle';\n          descriptionLangKey = 'AddMembersAlertNamesText';\n          const b = document.createElement('b');\n          b.append(new PeerTitle({\n            peerId: peerIds[0]\n          }).element);\n          descriptionLangArgs = [b];\n\n          if(!isChannel) {\n            checkboxes = [{\n              text: 'AddOneMemberForwardMessages',\n              textArgs: [new PeerTitle({\n                peerId: peerIds[0],\n                onlyFirstName: true\n              }).element],\n              checked: true\n            }];\n          }\n        }\n\n        descriptionLangArgs.push(new PeerTitle({\n          peerId: -id\n        }).element);\n\n        new PopupPeer('popup-add-members', {\n          peerId: -id,\n          titleLangKey,\n          descriptionLangKey,\n          descriptionLangArgs,\n          buttons: [{\n            langKey: 'Add',\n            callback\n          }],\n          checkboxes\n        }).show();\n      };\n\n      const onError = (err: any) => {\n        if(err.type === 'USER_PRIVACY_RESTRICTED') {\n          toastNew({langPackKey: 'InviteToGroupError'});\n        }\n      };\n      \n      if(isChannel) {\n        const tab = new AppAddMembersTab(this.slider);\n        tab.open({\n          peerId: this.peerId,\n          type: 'channel',\n          skippable: false,\n          takeOut: (peerIds) => {\n            showConfirmation(peerIds, () => {\n              const promise = appChatsManager.inviteToChannel(id, peerIds);\n              promise.catch(onError);\n              tab.attachToPromise(promise);\n            });\n\n            return false;\n          },\n          title: 'GroupAddMembers',\n          placeholder: 'SendMessageTo'\n        });\n      } else {\n        new PopupPickUser({\n          peerTypes: ['contacts'],\n          placeholder: 'Search',\n          onSelect: (peerId) => {\n            setTimeout(() => {\n              showConfirmation([peerId], (checked) => {\n                appChatsManager.addChatUser(id, peerId, checked.size ? undefined : 0)\n                .catch(onError);\n              });\n            }, 0);\n          },\n        });\n      }\n    });\n\n    //console.log('construct shared media time:', performance.now() - perf);\n  }\n\n  public renderNewMessages(peerId: number, mids: number[]) {\n    if(this.init) return; // * not inited yet\n\n    if(!this.historiesStorage[peerId]) return;\n    \n    mids = mids.slice().reverse(); // ! because it will be ascend sorted array\n    for(const mediaTab of this.searchSuper.mediaTabs) {\n      const inputFilter = mediaTab.inputFilter;\n      const filtered = this.searchSuper.filterMessagesByType(mids.map(mid => appMessagesManager.getMessageByPeer(peerId, mid)), inputFilter);\n      if(filtered.length) {\n        if(this.historiesStorage[peerId][inputFilter]) {\n          this.historiesStorage[peerId][inputFilter].unshift(...filtered.map(message => ({mid: message.mid, peerId: message.peerId})));\n        }\n\n        if(this.peerId === peerId && this.searchSuper.usedFromHistory[inputFilter] !== -1) {\n          this.searchSuper.usedFromHistory[inputFilter] += filtered.length;\n          this.searchSuper.performSearchResult(filtered, mediaTab, false);\n        }\n\n        break;\n      }\n    }\n  }\n\n  public deleteDeletedMessages(peerId: number, mids: number[]) {\n    if(this.init) return; // * not inited yet\n\n    if(!this.historiesStorage[peerId]) return;\n\n    for(const mid of mids) {\n      for(const type of this.searchSuper.mediaTabs) {\n        const inputFilter = type.inputFilter;\n\n        if(!this.historiesStorage[peerId][inputFilter]) continue;\n\n        const history = this.historiesStorage[peerId][inputFilter];\n        const idx = history.findIndex(m => m.mid === mid);\n        if(idx !== -1) {\n          history.splice(idx, 1);\n\n          if(this.peerId === peerId) {\n            const container = this.searchSuper.tabs[inputFilter];\n            const div = container.querySelector(`div[data-mid=\"${mid}\"][data-peer-id=\"${peerId}\"]`);\n            if(div) {\n              div.remove();\n            }\n  \n            if(this.searchSuper.usedFromHistory[inputFilter] >= (idx + 1)) {\n              this.searchSuper.usedFromHistory[inputFilter]--;\n            }\n          }\n\n          break;\n        }\n      }\n    }\n\n    this.scrollable.onScroll();\n  }\n\n  public cleanupHTML() {\n    // const perf = performance.now();\n    this.profile.cleanupHTML();\n    \n    this.editBtn.style.display = 'none';\n\n    this.searchSuper.cleanupHTML(true);\n\n    this.container.classList.toggle('can-add-members', this.searchSuper.canViewMembers() && appChatsManager.hasRights(-this.peerId, 'invite_users'));\n\n    // console.log('cleanupHTML shared media time:', performance.now() - perf);\n  }\n\n  public setLoadMutex(promise: Promise<any>) {\n    this.searchSuper.loadMutex = promise;\n  }\n\n  public setPeer(peerId: number, threadId = 0) {\n    if(this.peerId === peerId && this.threadId === threadId) return false;\n\n    this.peerId = peerId;\n    this.threadId = threadId;\n    this.peerChanged = true;\n\n    if(this.init) {\n      this.init();\n      this.init = null;\n    }\n\n    this.searchSuper.setQuery({\n      peerId, \n      //threadId, \n      historyStorage: this.historiesStorage[peerId] ?? (this.historiesStorage[peerId] = {})\n    });\n\n    this.profile.setPeer(peerId, threadId);\n    \n    return true;\n  }\n\n  public fillProfileElements() {\n    if(!this.peerChanged) {\n      return;\n    }\n\n    this.peerChanged = false;\n\n    this.cleanupHTML();\n\n    this.profile.fillProfileElements();\n\n    if(this.peerId > 0) {\n      if(this.peerId !== rootScope.myId && appUsersManager.isContact(this.peerId)) {\n        this.editBtn.style.display = '';\n      }\n    } else {\n      const chat: Chat = appChatsManager.getChat(-this.peerId);\n      if((chat._ === 'chat' || (chat as Chat.channel).admin_rights) && !(chat as Chat.chat).pFlags.deactivated) {\n        this.editBtn.style.display = '';\n      }\n    }\n  }\n\n  public loadSidebarMedia(single: boolean, justLoad = false) {\n    this.searchSuper.load(single, justLoad);\n  }\n\n  onOpenAfterTimeout() {\n    this.scrollable.onScroll();\n  }\n}\n\nMOUNT_CLASS_TO && (MOUNT_CLASS_TO.AppSharedMediaTab = AppSharedMediaTab);\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport { attachClickEvent } from \"../../../helpers/dom/clickEvent\";\nimport toggleDisability from \"../../../helpers/dom/toggleDisability\";\nimport { deepEqual } from \"../../../helpers/object\";\nimport { ChannelParticipant } from \"../../../layer\";\nimport appChatsManager from \"../../../lib/appManagers/appChatsManager\";\nimport appDialogsManager from \"../../../lib/appManagers/appDialogsManager\";\nimport appUsersManager from \"../../../lib/appManagers/appUsersManager\";\nimport Button from \"../../button\";\nimport { SettingSection } from \"../../sidebarLeft\";\nimport { SliderSuperTabEventable } from \"../../sliderTab\";\nimport { ChatPermissions } from \"./groupPermissions\";\n\nexport default class AppUserPermissionsTab extends SliderSuperTabEventable {\n  public participant: ChannelParticipant;\n  public chatId: number;\n  public userId: number;\n\n  protected init() {\n    this.container.classList.add('edit-peer-container', 'user-permissions-container');\n    this.setTitle('UserRestrictions');\n\n    let destroyListener: () => void;\n\n    {\n      const section = new SettingSection({\n        name: 'UserRestrictionsCanDo',\n      });\n      \n      const div = document.createElement('div');\n      div.classList.add('chatlist-container');\n      section.content.insertBefore(div, section.title);\n\n      const list = appDialogsManager.createChatList();\n      div.append(list);\n\n      const {dom} = appDialogsManager.addDialogNew({\n        dialog: this.userId,\n        container: list,\n        drawStatus: false,\n        rippleEnabled: true,\n        avatarSize: 48\n      });\n\n      dom.lastMessageSpan.append(appUsersManager.getUserStatusString(this.userId));\n\n      const p = new ChatPermissions({\n        chatId: this.chatId,\n        listenerSetter: this.listenerSetter,\n        appendTo: section.content,\n        participant: this.participant._ === 'channelParticipantBanned' ? this.participant : undefined\n      });\n\n      destroyListener = () => {\n        //appChatsManager.editChatDefaultBannedRights(this.chatId, p.takeOut());\n        const rights = p.takeOut();\n        if(this.participant._ === 'channelParticipantBanned' && deepEqual(this.participant.banned_rights.pFlags, rights.pFlags)) {\n          return;\n        }\n\n        appChatsManager.editBanned(this.chatId, this.participant, rights);\n      };\n\n      this.eventListener.addEventListener('destroy', destroyListener, {once: true});\n\n      this.scrollable.append(section.container);\n    }\n    \n    {\n      const section = new SettingSection({});\n\n      if(this.participant._ === 'channelParticipantBanned') {\n        const btnDeleteException = Button('btn-primary btn-transparent danger', {icon: 'delete', text: 'GroupPermission.Delete'});\n\n        attachClickEvent(btnDeleteException, () => {\n          const toggle = toggleDisability([btnDeleteException], true);\n          appChatsManager.clearChannelParticipantBannedRights(this.chatId, this.participant).then(() => {\n            this.eventListener.removeEventListener('destroy', destroyListener);\n            this.close();\n          }, () => {\n            toggle();\n          });\n        }, {listenerSetter: this.listenerSetter});\n  \n        section.content.append(btnDeleteException);\n      }\n\n      const btnDelete = Button('btn-primary btn-transparent danger', {icon: 'deleteuser', text: 'UserRestrictionsBlock'});\n\n      attachClickEvent(btnDelete, () => {\n        const toggle = toggleDisability([btnDelete], true);\n        appChatsManager.kickFromChannel(this.chatId, this.participant).then(() => {\n          this.eventListener.removeEventListener('destroy', destroyListener);\n          this.close();\n        });\n        /* new PopupPeer('popup-group-kick-user', {\n          peerId: -this.chatId,\n          title: 'Ban User?',\n          description: `Are you sure you want to ban <b>${appPeersManager.getPeerTitle(this.userId)}</b>`,\n          buttons: addCancelButton([{\n            text: 'BAN',\n            callback: () => {\n              const toggle = toggleDisability([btnDelete], true);\n\n              appChatsManager.kickFromChannel(this.chatId, this.participant).then(() => {\n                this.eventListener.removeEventListener('destroy', destroyListener);\n                this.close();\n              }, () => {\n                toggle();\n              });\n            },\n            isDanger: true\n          }])\n        }).show(); */\n      }, {listenerSetter: this.listenerSetter});\n\n      section.content.append(btnDelete);\n\n      this.scrollable.append(section.container);\n    }\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type { LazyLoadQueueIntersector } from \"./lazyLoadQueue\";\nimport appDialogsManager, { DialogDom } from \"../lib/appManagers/appDialogsManager\";\nimport { getHeavyAnimationPromise } from \"../hooks/useHeavyAnimationCheck\";\nimport appUsersManager from \"../lib/appManagers/appUsersManager\";\nimport { insertInDescendSortedArray } from \"../helpers/array\";\nimport isInDOM from \"../helpers/dom/isInDOM\";\nimport positionElementByIndex from \"../helpers/dom/positionElementByIndex\";\nimport replaceContent from \"../helpers/dom/replaceContent\";\n\ntype SortedUser = {\n  peerId: number, \n  status: number, \n  dom: DialogDom\n};\nexport default class SortedUserList {\n  public static SORT_INTERVAL = 30e3;\n  public list: HTMLUListElement;\n  public users: Map<number, SortedUser>;\n  public sorted: Array<SortedUser>;\n  public lazyLoadQueue: LazyLoadQueueIntersector;\n\n  constructor() {\n    this.list = appDialogsManager.createChatList();\n\n    this.users = new Map();\n    this.sorted = [];\n\n    let timeout: number;\n    const doTimeout = () => {\n      timeout = window.setTimeout(() => {\n        this.updateList().then((good) => {\n          if(good) {\n            doTimeout();\n          }\n        });\n      }, SortedUserList.SORT_INTERVAL);\n    };\n\n    doTimeout();\n  }\n\n  public async updateList() {\n    if(!isInDOM(this.list)) {\n      return false;\n    }\n\n    await getHeavyAnimationPromise();\n\n    if(!isInDOM(this.list)) {\n      return false;\n    }\n\n    this.users.forEach(user => {\n      this.update(user.peerId, true);\n    });\n\n    this.sorted.forEach((sortedUser, idx) => {\n      positionElementByIndex(sortedUser.dom.listEl, this.list, idx);\n    });\n\n    return true;\n  }\n\n  public add(peerId: number) {\n    if(this.users.has(peerId)) {\n      return;\n    }\n\n    const {dom} = appDialogsManager.addDialogNew({\n      dialog: peerId,\n      container: false,\n      drawStatus: false,\n      avatarSize: 48,\n      autonomous: true,\n      meAsSaved: false,\n      rippleEnabled: false,\n      lazyLoadQueue: this.lazyLoadQueue\n    });\n\n    const sortedUser: SortedUser = {\n      peerId,\n      status: appUsersManager.getUserStatusForSort(peerId),\n      dom\n    };\n\n    this.users.set(peerId, sortedUser);\n    this.update(peerId);\n  }\n\n  public update(peerId: number, batch = false) {\n    const sortedUser = this.users.get(peerId);\n    sortedUser.status = appUsersManager.getUserStatusForSort(peerId);\n    const status = appUsersManager.getUserStatusString(peerId);\n    replaceContent(sortedUser.dom.lastMessageSpan, status);\n\n    const idx = insertInDescendSortedArray(this.sorted, sortedUser, 'status');\n    if(!batch) {\n      positionElementByIndex(sortedUser.dom.listEl, this.list, idx);\n    }\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type Chat from './chat/chat';\nimport { getEmojiToneIndex } from '../vendor/emoji';\nimport { readBlobAsText } from '../helpers/blob';\nimport { deferredPromise } from '../helpers/cancellablePromise';\nimport { formatDateAccordingToToday, months } from '../helpers/date';\nimport mediaSizes from '../helpers/mediaSizes';\nimport { formatBytes } from '../helpers/number';\nimport { isSafari } from '../helpers/userAgent';\nimport { PhotoSize, StickerSet } from '../layer';\nimport appDocsManager, { MyDocument } from \"../lib/appManagers/appDocsManager\";\nimport appMessagesManager from '../lib/appManagers/appMessagesManager';\nimport appPhotosManager, { MyPhoto } from '../lib/appManagers/appPhotosManager';\nimport LottieLoader from '../lib/lottieLoader';\nimport webpWorkerController from '../lib/webp/webpWorkerController';\nimport animationIntersector from './animationIntersector';\nimport appMediaPlaybackController from './appMediaPlaybackController';\nimport AudioElement from './audio';\nimport ReplyContainer from './chat/replyContainer';\nimport { Layouter, RectPart } from './groupedLayout';\nimport LazyLoadQueue from './lazyLoadQueue';\nimport PollElement from './poll';\nimport ProgressivePreloader from './preloader';\nimport './middleEllipsis';\nimport RichTextProcessor from '../lib/richtextprocessor';\nimport appImManager from '../lib/appManagers/appImManager';\nimport { SearchSuperContext } from './appSearchSuper.';\nimport rootScope from '../lib/rootScope';\nimport { onVideoLoad } from '../helpers/files';\nimport { animateSingle } from '../helpers/animation';\nimport renderImageFromUrl from '../helpers/dom/renderImageFromUrl';\nimport sequentialDom from '../helpers/sequentialDom';\nimport { fastRaf } from '../helpers/schedulers';\nimport appDownloadManager, { DownloadBlob, ThumbCache } from '../lib/appManagers/appDownloadManager';\nimport appStickersManager from '../lib/appManagers/appStickersManager';\nimport { cancelEvent } from '../helpers/dom/cancelEvent';\nimport { attachClickEvent } from '../helpers/dom/clickEvent';\nimport isInDOM from '../helpers/dom/isInDOM';\nimport lottieLoader from '../lib/lottieLoader';\n\nconst MAX_VIDEO_AUTOPLAY_SIZE = 50 * 1024 * 1024; // 50 MB\n\nexport function wrapVideo({doc, container, message, boxWidth, boxHeight, withTail, isOut, middleware, lazyLoadQueue, noInfo, group, onlyPreview, withoutPreloader, loadPromises, noPlayButton, noAutoDownload, size}: {\n  doc: MyDocument, \n  container?: HTMLElement, \n  message?: any, \n  boxWidth?: number, \n  boxHeight?: number, \n  withTail?: boolean, \n  isOut?: boolean,\n  middleware?: () => boolean,\n  lazyLoadQueue?: LazyLoadQueue,\n  noInfo?: true,\n  noPlayButton?: boolean,\n  group?: string,\n  onlyPreview?: boolean,\n  withoutPreloader?: boolean,\n  loadPromises?: Promise<any>[],\n  noAutoDownload?: boolean,\n  size?: PhotoSize\n}) {\n  const isAlbumItem = !(boxWidth && boxHeight);\n  const canAutoplay = (doc.type !== 'video' || (doc.size <= MAX_VIDEO_AUTOPLAY_SIZE && !isAlbumItem)) \n    && (doc.type === 'gif' ? rootScope.settings.autoPlay.gifs : rootScope.settings.autoPlay.videos);\n  let spanTime: HTMLElement, spanPlay: HTMLElement;\n\n  if(!noInfo) {\n    spanTime = document.createElement('span');\n    spanTime.classList.add('video-time');\n    container.append(spanTime);\n  \n    let needPlayButton = false;\n    if(doc.type !== 'gif') {\n      spanTime.innerText = (doc.duration + '').toHHMMSS(false);\n\n      if(!noPlayButton && doc.type !== 'round') {\n        if(canAutoplay) {\n          spanTime.classList.add('tgico', 'can-autoplay');\n        } else {\n          needPlayButton = true;\n        }\n      }\n    } else {\n      spanTime.innerText = 'GIF';\n\n      if(!canAutoplay && !noPlayButton) {\n        needPlayButton = true;\n        noAutoDownload = undefined;\n      }\n    }\n\n    if(needPlayButton) {\n      spanPlay = document.createElement('span');\n      spanPlay.classList.add('video-play', 'tgico-largeplay', 'btn-circle', 'position-center');\n      container.append(spanPlay);\n    }\n  }\n\n  let res: {\n    thumb?: typeof photoRes,\n    loadPromise: Promise<any>\n  } = {} as any;\n\n  if(doc.mime_type === 'image/gif') {\n    const photoRes = wrapPhoto({\n      photo: doc, \n      message, \n      container, \n      boxWidth, \n      boxHeight, \n      withTail, \n      isOut, \n      lazyLoadQueue, \n      middleware,\n      withoutPreloader,\n      loadPromises,\n      noAutoDownload,\n      size\n    });\n\n    res.thumb = photoRes;\n    res.loadPromise = photoRes.loadPromises.full;\n    return res;\n  }\n\n  /* const video = doc.type === 'round' ? appMediaPlaybackController.addMedia(doc, message.mid) as HTMLVideoElement : document.createElement('video');\n  if(video.parentElement) {\n    video.remove();\n  } */\n\n  const video = document.createElement('video');\n  video.classList.add('media-video');\n  video.setAttribute('playsinline', 'true');\n  video.muted = true;\n  if(doc.type === 'round') {\n    const globalVideo = appMediaPlaybackController.addMedia(message.peerId, doc, message.mid, !noAutoDownload) as HTMLVideoElement;\n \n    const divRound = document.createElement('div');\n    divRound.classList.add('media-round', 'z-depth-1');\n\n    divRound.innerHTML = `<svg class=\"progress-ring\" width=\"200px\" height=\"200px\">\n      <circle class=\"progress-ring__circle\" stroke=\"white\" stroke-opacity=\"0.3\" stroke-width=\"3.5\" cx=\"100\" cy=\"100\" r=\"93\" fill=\"transparent\" transform=\"rotate(-90, 100, 100)\"/>\n    </svg>`;\n\n    const circle = divRound.querySelector('.progress-ring__circle') as SVGCircleElement;\n    const radius = circle.r.baseVal.value;\n    const circumference = 2 * Math.PI * radius;\n    circle.style.strokeDasharray = circumference + ' ' + circumference;\n    circle.style.strokeDashoffset = '' + circumference;\n    \n    spanTime.classList.add('tgico');\n\n    const canvas = document.createElement('canvas');\n    canvas.width = canvas.height = doc.w/*  * window.devicePixelRatio */;\n\n    divRound.prepend(canvas, spanTime);\n    divRound.append(video);\n    container.append(divRound);\n\n    const ctx = canvas.getContext('2d');\n    /* ctx.beginPath();\n    ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2, 0, Math.PI * 2);\n    ctx.clip(); */\n\n    const clear = () => {\n      (appImManager.chat.setPeerPromise || Promise.resolve()).finally(() => {\n        if(isInDOM(globalVideo)) {\n          return;\n        }\n\n        globalVideo.removeEventListener('play', onPlay);\n        globalVideo.removeEventListener('timeupdate', onTimeUpdate);\n        globalVideo.removeEventListener('pause', onPaused);\n      });\n    };\n\n    const onFrame = () => {\n      ctx.drawImage(globalVideo, 0, 0);\n\n      const offset = circumference - globalVideo.currentTime / globalVideo.duration * circumference;\n      circle.style.strokeDashoffset = '' + offset;\n\n      return !globalVideo.paused;\n    };\n\n    const onTimeUpdate = () => {\n      if(!globalVideo.duration) return;\n\n      if(!isInDOM(globalVideo)) {\n        clear();\n        return;\n      }\n\n      spanTime.innerText = (globalVideo.duration - globalVideo.currentTime + '').toHHMMSS(false);\n    };\n\n    const onPlay = () => {\n      video.classList.add('hide');\n      divRound.classList.remove('is-paused');\n      animateSingle(onFrame, canvas);\n    };\n\n    const onPaused = () => {\n      if(!isInDOM(globalVideo)) {\n        clear();\n        return;\n      }\n\n      divRound.classList.add('is-paused');\n    };\n\n    globalVideo.addEventListener('play', onPlay);\n    globalVideo.addEventListener('timeupdate', onTimeUpdate);\n    globalVideo.addEventListener('pause', onPaused);\n\n    attachClickEvent(canvas, (e) => {\n      cancelEvent(e);\n\n      if(globalVideo.paused) {\n        globalVideo.play();\n      } else {\n        globalVideo.pause();\n      }\n    });\n\n    if(globalVideo.paused) {\n      if(globalVideo.duration && globalVideo.currentTime !== globalVideo.duration) {\n        onFrame();\n        onTimeUpdate();\n        video.classList.add('hide');\n      } else {\n        onPaused();\n      }\n    } else {\n      onPlay();\n    }\n  } else {\n    video.autoplay = true; // \u0434\u043b\u044f safari\n  }\n\n  let photoRes: ReturnType<typeof wrapPhoto>;\n  if(message) {\n    photoRes = wrapPhoto({\n      photo: doc, \n      message, \n      container, \n      boxWidth, \n      boxHeight, \n      withTail, \n      isOut, \n      lazyLoadQueue, \n      middleware,\n      withoutPreloader: true,\n      loadPromises,\n      noAutoDownload,\n      size\n    });\n\n    res.thumb = photoRes;\n\n    if((!canAutoplay && doc.type !== 'gif') || onlyPreview) {\n      res.loadPromise = photoRes.loadPromises.full;\n      return res;\n    }\n\n    if(withTail) {\n      const foreignObject = (photoRes.images.thumb || photoRes.images.full).parentElement;\n      video.width = +foreignObject.getAttributeNS(null, 'width');\n      video.height = +foreignObject.getAttributeNS(null, 'height');\n      foreignObject.append(video);\n    }\n  } else { // * gifs masonry\n    const gotThumb = appDocsManager.getThumb(doc, false);\n    if(gotThumb) {\n      gotThumb.promise.then(() => {\n        video.poster = gotThumb.cacheContext.url;\n      });\n    }\n  }\n\n  if(!video.parentElement && container) {\n    (photoRes?.aspecter || container).append(video);\n  }\n\n  const cacheContext = appDownloadManager.getCacheContext(doc);\n\n  let preloader: ProgressivePreloader;\n  if(message?.media?.preloader) { // means upload\n    preloader = message.media.preloader as ProgressivePreloader;\n    preloader.attach(container, false);\n    noAutoDownload = undefined;\n  } else if(!cacheContext.downloaded && !doc.supportsStreaming) {\n    preloader = new ProgressivePreloader({\n      attachMethod: 'prepend'\n    });\n  } else if(doc.supportsStreaming) {\n    preloader = new ProgressivePreloader({\n      cancelable: false,\n      attachMethod: 'prepend'\n    });\n  }\n\n  let f = noAutoDownload && photoRes?.preloader?.loadFunc;\n  const load = () => {\n    if(preloader && noAutoDownload && !withoutPreloader) {\n      preloader.construct();\n      preloader.setManual();\n    }\n\n    let loadPromise: Promise<any> = Promise.resolve();\n    if(preloader) {\n      if(!cacheContext.downloaded && !doc.supportsStreaming) {\n        const promise = loadPromise = appDocsManager.downloadDoc(doc, lazyLoadQueue?.queueId, noAutoDownload);\n        preloader.attach(container, false, promise);\n      } else if(doc.supportsStreaming) {\n        if(noAutoDownload) {\n          loadPromise = Promise.reject();\n        } else if(!cacheContext.downloaded) { // * check for uploading video\n          preloader.attach(container, false, null);\n          video.addEventListener(isSafari ? 'timeupdate' : 'canplay', () => {\n            preloader.detach();\n          }, {once: true});\n        }\n      }\n    }\n\n    video.addEventListener('error', (e) => {\n      console.error(\"Error \" + video.error.code + \"; details: \" + video.error.message);\n      if(preloader) {\n        preloader.detach();\n      }\n    }, {once: true});\n\n    if(!noAutoDownload && f) {\n      f();\n      f = null;\n    }\n\n    noAutoDownload = undefined;\n\n    const deferred = deferredPromise<void>();\n    loadPromise.then(() => {\n      if(middleware && !middleware()) {\n        deferred.resolve();\n        return;\n      }\n\n      if(doc.type === 'round') {\n        appMediaPlaybackController.resolveWaitingForLoadMedia(message.peerId, message.mid);\n      }\n\n      onVideoLoad(video).then(() => {\n        if(group) {\n          animationIntersector.addAnimation(video, group);\n        }\n  \n        deferred.resolve();\n      });\n  \n      if(doc.type === 'video') {\n        video.addEventListener('timeupdate', () => {\n          spanTime.innerText = (video.duration - video.currentTime + '').toHHMMSS(false);\n        });\n      }\n  \n      video.addEventListener('error', (e) => {\n        deferred.resolve();\n      });\n  \n      video.muted = true;\n      video.loop = true;\n      //video.play();\n      video.autoplay = true;\n\n      renderImageFromUrl(video, cacheContext.url);\n    }, () => {});\n\n    return {download: loadPromise, render: deferred};\n  };\n\n  if(preloader) {\n    preloader.setDownloadFunction(load);\n  }\n\n  /* if(doc.size >= 20e6 && !doc.downloaded) {\n    let downloadDiv = document.createElement('div');\n    downloadDiv.classList.add('download');\n\n    let span = document.createElement('span');\n    span.classList.add('btn-circle', 'tgico-download');\n    downloadDiv.append(span);\n\n    downloadDiv.addEventListener('click', () => {\n      downloadDiv.remove();\n      loadVideo();\n    });\n\n    container.prepend(downloadDiv);\n\n    return;\n  } */\n\n  if(doc.type === 'gif' && !canAutoplay) {\n    attachClickEvent(container, (e) => {\n      cancelEvent(e);\n      spanPlay.remove();\n      load();\n    }, {capture: true, once: true});\n  } else {\n    res.loadPromise = !lazyLoadQueue ? load().render : (lazyLoadQueue.push({div: container, load: () => load().render}), Promise.resolve());\n  }\n\n  return res;\n}\n\nexport const formatDate = (timestamp: number, monthShort = false, withYear = true) => {\n  const date = new Date(timestamp * 1000);\n  \n  let month = months[date.getMonth()];\n  if(monthShort) month = month.slice(0, 3);\n\n  let str = month + ' ' + date.getDate();\n  if(withYear) {\n    str += ', ' + date.getFullYear();\n  }\n  \n  return str + ' at ' + date.getHours() + ':' + ('0' + date.getMinutes()).slice(-2);\n};\n\nexport function wrapDocument({message, withTime, fontWeight, voiceAsMusic, showSender, searchContext, loadPromises, noAutoDownload}: {\n  message: any, \n  withTime?: boolean,\n  fontWeight?: number,\n  voiceAsMusic?: boolean,\n  showSender?: boolean,\n  searchContext?: SearchSuperContext,\n  loadPromises?: Promise<any>[],\n  noAutoDownload?: boolean,\n}): HTMLElement {\n  if(!fontWeight) fontWeight = 500;\n\n  const doc = (message.media.document || message.media.webpage.document) as MyDocument;\n  const uploading = message.pFlags.is_outgoing && message.media?.preloader;\n  if(doc.type === 'audio' || doc.type === 'voice') {\n    const audioElement = new AudioElement();\n    audioElement.setAttribute('message-id', '' + message.mid);\n    audioElement.setAttribute('peer-id', '' + message.peerId);\n    audioElement.withTime = withTime;\n    audioElement.message = message;\n    audioElement.noAutoDownload = noAutoDownload;\n    \n    if(voiceAsMusic) audioElement.voiceAsMusic = voiceAsMusic;\n    if(searchContext) audioElement.searchContext = searchContext;\n    if(showSender) audioElement.showSender = showSender;\n    \n    if(uploading) {\n      audioElement.preloader = message.media.preloader;\n    }\n\n    audioElement.dataset.fontWeight = '' + fontWeight;\n    audioElement.render();\n    return audioElement;\n  }\n\n  let extSplitted = doc.file_name ? doc.file_name.split('.') : '';\n  let ext = '';\n  ext = extSplitted.length > 1 && Array.isArray(extSplitted) ? extSplitted.pop().toLowerCase() : 'file';\n\n  let docDiv = document.createElement('div');\n  docDiv.classList.add('document', `ext-${ext}`);\n  docDiv.dataset.docId = doc.id;\n\n  const icoDiv = document.createElement('div');\n  icoDiv.classList.add('document-ico');\n\n  const cacheContext = appDownloadManager.getCacheContext(doc);\n  if(doc.thumbs?.length || (message.pFlags.is_outgoing && cacheContext.url && doc.type === 'photo')) {\n    docDiv.classList.add('document-with-thumb');\n\n    let imgs: HTMLImageElement[] = [];\n    if(message.pFlags.is_outgoing) {\n      icoDiv.innerHTML = `<img src=\"${cacheContext.url}\">`;\n      imgs.push(icoDiv.firstElementChild as HTMLImageElement);\n    } else {\n      const wrapped = wrapPhoto({\n        photo: doc, \n        message: null, \n        container: icoDiv, \n        boxWidth: 54, \n        boxHeight: 54,\n        loadPromises,\n        withoutPreloader: true\n      });\n      icoDiv.style.width = icoDiv.style.height = '';\n      if(wrapped.images.thumb) imgs.push(wrapped.images.thumb);\n      if(wrapped.images.full) imgs.push(wrapped.images.full);\n    }\n\n    imgs.forEach(img => img.classList.add('document-thumb'));\n  } else {\n    icoDiv.innerText = ext;\n  }\n\n  //let fileName = stringMiddleOverflow(doc.file_name || 'Unknown.file', 26);\n  let fileName = doc.file_name || 'Unknown.file';\n  let size = formatBytes(doc.size);\n  \n  if(withTime) {\n    size += ' \u00b7 ' + formatDate(doc.date);\n  }\n\n  if(showSender) {\n    size += ' \u00b7 ' + appMessagesManager.getSenderToPeerText(message);\n  }\n\n  let titleAdditionHTML = '';\n  if(showSender) {\n    titleAdditionHTML = `<div class=\"sent-time\">${formatDateAccordingToToday(new Date(message.date * 1000))}</div>`;\n  }\n  \n  docDiv.innerHTML = `\n  ${cacheContext.downloaded && !uploading ? '' : `<div class=\"document-download\"></div>`}\n  <div class=\"document-name\"><middle-ellipsis-element data-font-weight=\"${fontWeight}\">${fileName}</middle-ellipsis-element>${titleAdditionHTML}</div>\n  <div class=\"document-size\">${size}</div>\n  `;\n\n  docDiv.prepend(icoDiv);\n\n  if(!uploading && message.pFlags.is_outgoing) {\n    return docDiv;\n  }\n\n  let downloadDiv: HTMLElement, preloader: ProgressivePreloader = null;\n  const onLoad = () => {\n    if(downloadDiv) {\n      downloadDiv.classList.add('downloaded');\n      const _downloadDiv = downloadDiv;\n      setTimeout(() => {\n        _downloadDiv.remove();\n      }, 200);\n      downloadDiv = null;\n    }\n\n    if(preloader) {\n      preloader = null;\n    }\n  };\n\n  const load = () => {\n    const doc = appDocsManager.getDoc(docDiv.dataset.docId);\n    let download: DownloadBlob;\n    if(doc.type === 'pdf') {\n      download = appDocsManager.downloadDoc(doc, appImManager.chat.bubbles ? appImManager.chat.bubbles.lazyLoadQueue.queueId : 0);\n      download.then(() => {\n        const cacheContext = appDownloadManager.getCacheContext(doc);\n        window.open(cacheContext.url);\n      });\n    } else {\n      download = appDocsManager.saveDocFile(doc, appImManager.chat.bubbles ? appImManager.chat.bubbles.lazyLoadQueue.queueId : 0);\n    }\n\n    if(downloadDiv) {\n      download.then(onLoad);\n      preloader.attach(downloadDiv, true, download);\n    }\n\n    return {download};\n  };\n\n  if(!(cacheContext.downloaded && !uploading)) {\n    downloadDiv = docDiv.querySelector('.document-download');\n    preloader = message.media.preloader as ProgressivePreloader;\n\n    if(!preloader) {\n      preloader = new ProgressivePreloader();\n\n      preloader.construct();\n      preloader.setManual();\n      preloader.attach(downloadDiv);\n      preloader.setDownloadFunction(load);\n    } else {\n      preloader.attach(downloadDiv);\n      message.media.promise.then(onLoad);\n    }\n  }\n\n  attachClickEvent(docDiv, (e) => {\n    if(preloader) {\n      preloader.onClick(e);\n    } else {\n      load();\n    }\n  });\n  \n  return docDiv;\n}\n\n/* function wrapMediaWithTail(photo: MyPhoto | MyDocument, message: {mid: number, message: string}, container: HTMLElement, boxWidth: number, boxHeight: number, isOut: boolean) {\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  svg.classList.add('bubble__media-container', isOut ? 'is-out' : 'is-in');\n  \n  const foreignObject = document.createElementNS(\"http://www.w3.org/2000/svg\", 'foreignObject');\n\n  const gotThumb = appPhotosManager.getStrippedThumbIfNeeded(photo, true);\n  if(gotThumb) {\n    foreignObject.append(gotThumb.image);\n  }\n  appPhotosManager.setAttachmentSize(photo, foreignObject, boxWidth, boxHeight);\n  \n  const width = +foreignObject.getAttributeNS(null, 'width');\n  const height = +foreignObject.getAttributeNS(null, 'height');\n\n  svg.setAttributeNS(null, 'width', '' + width);\n  svg.setAttributeNS(null, 'height', '' + height);\n\n  svg.setAttributeNS(null, 'viewBox', '0 0 ' + width + ' ' + height);\n  svg.setAttributeNS(null, 'preserveAspectRatio', 'none');\n\n  const clipId = 'clip' + message.mid + '_' + nextRandomInt(9999);\n  svg.dataset.clipId = clipId;\n  \n  const defs = document.createElementNS(\"http://www.w3.org/2000/svg\", 'defs');\n  let clipPathHTML: string = '';\n  \n  if(message.message) {\n    //clipPathHTML += `<rect width=\"${width}\" height=\"${height}\"></rect>`;\n  } else {\n    if(isOut) {\n      clipPathHTML += `\n      <use href=\"#message-tail\" transform=\"translate(${width - 2}, ${height}) scale(-1, -1)\"></use>\n      <path />\n      `;\n    } else {\n      clipPathHTML += `\n      <use href=\"#message-tail\" transform=\"translate(2, ${height}) scale(1, -1)\"></use>\n      <path />\n      `;\n    }\n  }\n\n  defs.innerHTML = `<clipPath id=\"${clipId}\">${clipPathHTML}</clipPath>`;\n  \n  container.style.width = parseInt(container.style.width) - 9 + 'px';\n  container.classList.add('with-tail');\n\n  svg.append(defs, foreignObject);\n  container.append(svg);\n\n  let img = foreignObject.firstElementChild as HTMLImageElement;\n  if(!img) {\n    foreignObject.append(img = new Image());\n  }\n\n  return img;\n} */\n\nexport function wrapPhoto({photo, message, container, boxWidth, boxHeight, withTail, isOut, lazyLoadQueue, middleware, size, withoutPreloader, loadPromises, noAutoDownload, noBlur, noThumb, noFadeIn}: {\n  photo: MyPhoto | MyDocument, \n  message: any, \n  container: HTMLElement, \n  boxWidth?: number, \n  boxHeight?: number, \n  withTail?: boolean, \n  isOut?: boolean, \n  lazyLoadQueue?: LazyLoadQueue, \n  middleware?: () => boolean, \n  size?: PhotoSize,\n  withoutPreloader?: boolean,\n  loadPromises?: Promise<any>[],\n  noAutoDownload?: boolean,\n  noBlur?: boolean,\n  noThumb?: boolean,\n  noFadeIn?: boolean,\n}) {\n  if(!((photo as MyPhoto).sizes || (photo as MyDocument).thumbs)) {\n    if(boxWidth && boxHeight && !size && photo._ === 'document') {\n      appPhotosManager.setAttachmentSize(photo, container, boxWidth, boxHeight, undefined, message);\n    }\n\n    return {\n      loadPromises: {\n        thumb: Promise.resolve(),\n        full: Promise.resolve()\n      },\n      images: {\n        thumb: null,\n        full: null\n      },\n      preloader: null,\n      aspecter: null\n    };\n  }\n\n  if(!size) {\n    if(boxWidth === undefined) boxWidth = mediaSizes.active.regular.width;\n    if(boxHeight === undefined) boxHeight = mediaSizes.active.regular.height;\n  }\n\n  container.classList.add('media-container');\n  let aspecter = container;\n\n  let isFit = true;\n  let loadThumbPromise: Promise<any> = Promise.resolve();\n  let thumbImage: HTMLImageElement;\n  let image: HTMLImageElement;\n  let cacheContext: ThumbCache;\n  // if(withTail) {\n  //   image = wrapMediaWithTail(photo, message, container, boxWidth, boxHeight, isOut);\n  // } else {\n    image = new Image();\n\n    if(boxWidth && boxHeight && !size) { // !album\n      const set = appPhotosManager.setAttachmentSize(photo, container, boxWidth, boxHeight, undefined, message);\n      size = set.photoSize;\n      isFit = set.isFit;\n      cacheContext = appDownloadManager.getCacheContext(photo, size.type);\n\n      if(!isFit) {\n        aspecter = document.createElement('div');\n        aspecter.classList.add('media-container-aspecter');\n        aspecter.style.width = set.size.width + 'px';\n        aspecter.style.height = set.size.height + 'px';\n\n        const gotThumb = appPhotosManager.getStrippedThumbIfNeeded(photo, cacheContext, !noBlur, true);\n        if(gotThumb) {\n          loadThumbPromise = gotThumb.loadPromise;\n          const thumbImage = gotThumb.image; // local scope\n          thumbImage.classList.add('media-photo');\n          container.append(thumbImage);\n        } else {\n          const res = wrapPhoto({\n            container,\n            message,\n            photo,\n            boxWidth: 0,\n            boxHeight: 0,\n            size,\n            lazyLoadQueue,\n            isOut,\n            loadPromises,\n            middleware,\n            withoutPreloader,\n            withTail,\n            noAutoDownload,\n            noBlur,\n            noThumb: true,\n            //noFadeIn: true\n          });\n          const thumbImage = res.images.full;\n          thumbImage.classList.add('media-photo', 'thumbnail');\n          //container.append(thumbImage);\n        }\n\n        container.classList.add('media-container-fitted');\n        container.append(aspecter);\n      }\n    } else {\n      if(!size) {\n        size = appPhotosManager.choosePhotoSize(photo, boxWidth, boxHeight, true);\n      }\n      \n      cacheContext = appDownloadManager.getCacheContext(photo, size?.type);\n    }\n\n    if(!noThumb) {\n      const gotThumb = appPhotosManager.getStrippedThumbIfNeeded(photo, cacheContext, !noBlur);\n      if(gotThumb) {\n        loadThumbPromise = Promise.all([loadThumbPromise, gotThumb.loadPromise]);\n        thumbImage = gotThumb.image;\n        thumbImage.classList.add('media-photo');\n        aspecter.append(thumbImage);\n      }\n    }\n  // }\n\n  image.classList.add('media-photo');\n  \n  //console.log('wrapPhoto downloaded:', photo, photo.downloaded, container);\n\n  const needFadeIn = (thumbImage || !cacheContext.downloaded) && rootScope.settings.animationsEnabled && !noFadeIn;\n  if(needFadeIn) {\n    image.classList.add('fade-in');\n  }\n\n  let preloader: ProgressivePreloader;\n  if(message?.media?.preloader) { // means upload\n    preloader = message.media.preloader;\n    preloader.attach(container);\n    noAutoDownload = undefined;\n  } else {\n    preloader = new ProgressivePreloader({\n      attachMethod: 'prepend'\n    });\n  }\n\n  const getDownloadPromise = () => {\n    const promise = photo._ === 'document' && photo.mime_type === 'image/gif' ? \n      appDocsManager.downloadDoc(photo, /* undefined,  */lazyLoadQueue?.queueId) : \n      appPhotosManager.preloadPhoto(photo, size, lazyLoadQueue?.queueId, noAutoDownload);\n\n    noAutoDownload = undefined;\n\n    return promise;\n  };\n\n  const onLoad = (): Promise<void> => {\n    if(middleware && !middleware()) return Promise.resolve();\n\n    return new Promise((resolve) => {\n      /* if(photo._ === 'document') {\n        console.error('wrapPhoto: will render document', photo, size, cacheContext);\n        return resolve();\n      } */\n\n      renderImageFromUrl(image, cacheContext.url, () => {\n        sequentialDom.mutateElement(container, () => {\n          aspecter.append(image);\n\n          fastRaf(() => {\n            resolve();\n          });\n  \n          if(needFadeIn) {\n            image.addEventListener('animationend', () => {\n              sequentialDom.mutate(() => {\n                image.classList.remove('fade-in');\n    \n                if(thumbImage) {\n                  thumbImage.remove();\n                }\n              });\n            }, {once: true});\n          }\n        });\n      });\n    });\n  };\n\n  let loadPromise: Promise<any>;\n  const load = () => {\n    if(noAutoDownload && !withoutPreloader) {\n      preloader.construct();\n      preloader.setManual();\n    }\n\n    const promise = getDownloadPromise();\n\n    if(!cacheContext.downloaded && !withoutPreloader && (size as PhotoSize.photoSize).w >= 150 && (size as PhotoSize.photoSize).h >= 150) {\n      preloader.attach(container, false, promise);\n    }\n\n    const renderPromise = promise.then(onLoad);\n    renderPromise.catch(() => {});\n    return {download: promise, render: renderPromise};\n  };\n\n  preloader.setDownloadFunction(load);\n  \n  if(cacheContext.downloaded) {\n    loadThumbPromise = loadPromise = load().render;\n  } else {\n    if(!lazyLoadQueue) loadPromise = load().render;\n    /* else if(noAutoDownload) {\n      preloader.construct();\n      preloader.setManual();\n      preloader.attach(container);\n    } */ else lazyLoadQueue.push({div: container, load: () => load().download});\n  }\n\n  if(loadPromises && loadThumbPromise) {\n    loadPromises.push(loadThumbPromise);\n  }\n\n  return {\n    loadPromises: {\n      thumb: loadThumbPromise,\n      full: loadPromise || Promise.resolve()\n    },\n    images: {\n      thumb: thumbImage,\n      full: image\n    },\n    preloader,\n    aspecter\n  };\n}\n\nexport function wrapSticker({doc, div, middleware, lazyLoadQueue, group, play, onlyThumb, emoji, width, height, withThumb, loop, loadPromises, needFadeIn}: {\n  doc: MyDocument, \n  div: HTMLElement, \n  middleware?: () => boolean, \n  lazyLoadQueue?: LazyLoadQueue, \n  group?: string, \n  play?: boolean, \n  onlyThumb?: boolean,\n  emoji?: string,\n  width?: number,\n  height?: number,\n  withThumb?: boolean,\n  loop?: boolean,\n  loadPromises?: Promise<any>[],\n  needFadeIn?: boolean,\n}) {\n  const stickerType = doc.sticker;\n\n  if(!width) {\n    width = !emoji ? 200 : undefined;\n  }\n\n  if(!height) {\n    height = !emoji ? 200 : undefined;\n  }\n\n  if(stickerType === 2 && !LottieLoader.loaded) {\n    //LottieLoader.loadLottie();\n    LottieLoader.loadLottieWorkers();\n  }\n  \n  if(!stickerType) {\n    console.error('wrong doc for wrapSticker!', doc);\n    throw new Error('wrong doc for wrapSticker!');\n  }\n\n  div.dataset.docId = doc.id;\n  div.classList.add('media-sticker-wrapper');\n  \n  //console.log('wrap sticker', doc, div, onlyThumb);\n\n  const cacheContext = appDownloadManager.getCacheContext(doc);\n\n  const toneIndex = emoji ? getEmojiToneIndex(emoji) : -1;\n  const downloaded = cacheContext.downloaded && !needFadeIn;\n  \n  let loadThumbPromise = deferredPromise<void>();\n  let haveThumbCached = false;\n  if((doc.thumbs?.length || doc.stickerCachedThumbs) && !div.firstElementChild && (!downloaded || stickerType === 2 || onlyThumb)/*  && doc.thumbs[0]._ !== 'photoSizeEmpty' */) {\n    let thumb = doc.stickerCachedThumbs && doc.stickerCachedThumbs[toneIndex] || doc.thumbs[0];\n    \n    //console.log('wrap sticker', thumb, div);\n\n    let thumbImage: HTMLImageElement;\n    const afterRender = () => {\n      if(!div.childElementCount) {\n        thumbImage.classList.add('media-sticker', 'thumbnail');\n        \n        sequentialDom.mutateElement(div, () => {\n          div.append(thumbImage);\n          loadThumbPromise.resolve();\n        });\n      }\n    };\n\n    if('url' in thumb) {\n      thumbImage = new Image();\n      renderImageFromUrl(thumbImage, thumb.url, afterRender);\n      haveThumbCached = true;\n    } else if('bytes' in thumb) {\n      if(thumb._ === 'photoPathSize') {\n        if(thumb.bytes.length) {\n          const d = appPhotosManager.getPathFromPhotoPathSize(thumb);\n          div.innerHTML = `<svg class=\"rlottie-vector media-sticker thumbnail\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 ${doc.w || 512} ${doc.h || 512}\" xml:space=\"preserve\">\n            <path d=\"${d}\"/>\n          </svg>`;\n        } else {\n          thumb = doc.thumbs.find(t => (t as PhotoSize.photoStrippedSize).bytes?.length) || thumb;\n        }\n      } \n      \n      if(thumb && thumb._ !== 'photoPathSize' && toneIndex <= 0) {\n        thumbImage = new Image();\n\n        if((webpWorkerController.isWebpSupported() || doc.pFlags.stickerThumbConverted || cacheContext.url)/*  && false */) {\n          renderImageFromUrl(thumbImage, appPhotosManager.getPreviewURLFromThumb(doc, thumb as PhotoSize.photoStrippedSize, true), afterRender);\n          haveThumbCached = true;\n        } else {\n          webpWorkerController.convert(doc.id, (thumb as PhotoSize.photoStrippedSize).bytes as Uint8Array).then(bytes => {\n            (thumb as PhotoSize.photoStrippedSize).bytes = bytes;\n            doc.pFlags.stickerThumbConverted = true;\n            \n            if(middleware && !middleware()) return;\n  \n            if(!div.childElementCount) {\n              renderImageFromUrl(thumbImage, appPhotosManager.getPreviewURLFromThumb(doc, thumb as PhotoSize.photoStrippedSize, true), afterRender);\n            }\n          }).catch(() => {});\n        }\n      }\n    } else if(stickerType === 2 && (withThumb || onlyThumb) && toneIndex <= 0) {\n      thumbImage = new Image();\n\n      const load = () => {\n        if(div.childElementCount || (middleware && !middleware())) return;\n\n        const r = () => {\n          if(div.childElementCount || (middleware && !middleware())) return;\n          renderImageFromUrl(thumbImage, cacheContext.url, afterRender);\n        };\n  \n        if(cacheContext.url) {\n          r();\n          return Promise.resolve();\n        } else {\n          return appDocsManager.getThumbURL(doc, thumb as PhotoSize.photoStrippedSize).promise.then(r);\n        }\n      };\n      \n      if(lazyLoadQueue && onlyThumb) {\n        lazyLoadQueue.push({div, load});\n        return Promise.resolve();\n      } else {\n        load();\n\n        if((thumb as any).url) {\n          haveThumbCached = true;\n        }\n      }\n    }\n  }\n\n  if(loadPromises && haveThumbCached) {\n    loadPromises.push(loadThumbPromise);\n  }\n\n  if(onlyThumb) { // for sticker panel\n    return Promise.resolve();\n  }\n  \n  const load = async() => {\n    if(middleware && !middleware()) return;\n\n    if(stickerType === 2) {\n      /* if(doc.id === '1860749763008266301') {\n        console.log('loaded sticker:', doc, div);\n      } */\n\n      //await new Promise((resolve) => setTimeout(resolve, 500));\n      //return;\n\n      //console.time('download sticker' + doc.id);\n\n      //appDocsManager.downloadDocNew(doc.id).promise.then(res => res.json()).then(async(json) => {\n      //fetch(doc.url).then(res => res.json()).then(async(json) => {\n      /* return */ await appDocsManager.downloadDoc(doc, /* undefined,  */lazyLoadQueue?.queueId)\n      .then(readBlobAsText)\n      //.then(JSON.parse)\n      .then(async(json) => {\n        //console.timeEnd('download sticker' + doc.id);\n        //console.log('loaded sticker:', doc, div/* , blob */);\n        if(middleware && !middleware()) return;\n\n        let animation = await LottieLoader.loadAnimationWorker({\n          container: div,\n          loop: loop && !emoji,\n          autoplay: play,\n          animationData: json,\n          width,\n          height\n        }, group, toneIndex);\n\n        //const deferred = deferredPromise<void>();\n  \n        animation.addEventListener('firstFrame', () => {\n          const element = div.firstElementChild;\n          needFadeIn = (needFadeIn || !element || element.tagName === 'svg') && rootScope.settings.animationsEnabled;\n\n          const cb = () => {\n            if(element && element !== animation.canvas) {\n              element.remove();\n            }\n          };\n\n          if(!needFadeIn) {\n            if(element) {\n              sequentialDom.mutate(cb);\n            }\n          } else {\n            sequentialDom.mutate(() => {\n              animation.canvas.classList.add('fade-in');\n              if(element) {\n                element.classList.add('fade-out');\n              }\n  \n              animation.canvas.addEventListener('animationend', () => {\n                sequentialDom.mutate(() => {\n                  animation.canvas.classList.remove('fade-in');\n                  cb();\n                });\n              }, {once: true});\n            });\n          }\n\n          appDocsManager.saveLottiePreview(doc, animation.canvas, toneIndex);\n\n          //deferred.resolve();\n        }, {once: true});\n  \n        if(emoji) {\n          attachClickEvent(div, (e) => {\n            cancelEvent(e);\n            let animation = LottieLoader.getAnimation(div);\n  \n            if(animation.paused) {\n              animation.autoplay = true;\n              animation.restart();\n            }\n          });\n        }\n\n        //return deferred;\n        //await new Promise((resolve) => setTimeout(resolve, 5e3));\n      });\n\n      //console.timeEnd('render sticker' + doc.id);\n    } else if(stickerType === 1) {\n      const image = new Image();\n      const thumbImage = div.firstElementChild !== image && div.firstElementChild;\n      needFadeIn = (needFadeIn || !downloaded || thumbImage) && rootScope.settings.animationsEnabled;\n\n      image.classList.add('media-sticker');\n\n      if(needFadeIn) {\n        image.classList.add('fade-in');\n      }\n\n      return new Promise<void>((resolve, reject) => {\n        const r = () => {\n          if(middleware && !middleware()) return resolve();\n  \n          renderImageFromUrl(image, cacheContext.url, () => {\n            sequentialDom.mutateElement(div, () => {\n              div.append(image);\n              if(thumbImage) {\n                thumbImage.classList.add('fade-out');\n              }\n\n              resolve();\n\n              if(needFadeIn) {\n                image.addEventListener('animationend', () => {\n                  image.classList.remove('fade-in');\n                  if(thumbImage) {\n                    thumbImage.remove();\n                  }\n                }, {once: true});\n              }\n            });\n          });\n        };\n  \n        if(cacheContext.url) r();\n        else {\n          appDocsManager.downloadDoc(doc, /* undefined,  */lazyLoadQueue?.queueId).then(r, resolve);\n        }\n      });\n    }\n  };\n\n  const loadPromise: Promise<any> = lazyLoadQueue && (!downloaded || stickerType === 2) ? \n    (lazyLoadQueue.push({div, load}), Promise.resolve()) : \n    load();\n\n  if(downloaded && stickerType === 1) {\n    loadThumbPromise = loadPromise;\n    if(loadPromises) {\n      loadPromises.push(loadThumbPromise);\n    }\n  }\n\n  return loadPromise;\n}\n\nexport async function wrapStickerSetThumb({set, lazyLoadQueue, container, group, autoplay, width, height}: {\n  set: StickerSet.stickerSet,\n  lazyLoadQueue: LazyLoadQueue,\n  container: HTMLElement,\n  group: string,\n  autoplay: boolean,\n  width: number,\n  height: number\n}) {\n  if(set.thumbs?.length) {\n    container.classList.add('media-sticker-wrapper');\n    lazyLoadQueue.push({\n      div: container,\n      load: () => {\n        const downloadOptions = appStickersManager.getStickerSetThumbDownloadOptions(set);\n        const promise = appDownloadManager.download(downloadOptions);\n\n        if(set.pFlags.animated) {\n          return promise\n          .then(readBlobAsText)\n          //.then(JSON.parse)\n          .then(json => {\n            lottieLoader.loadAnimationWorker({\n              container,\n              loop: true,\n              autoplay,\n              animationData: json,\n              width,\n              height,\n              needUpscale: true\n            }, group);\n          });\n        } else {\n          const image = new Image();\n          image.classList.add('media-sticker');\n  \n          return promise.then(blob => {\n            renderImageFromUrl(image, URL.createObjectURL(blob), () => {\n              container.append(image);\n            });\n          });\n        }\n      }\n    });\n\n    return;\n  }\n\n  const promise = appStickersManager.getStickerSet(set);\n  const stickerSet = await promise;\n  if(stickerSet.documents[0]._ !== 'documentEmpty') { // as thumb will be used first sticker\n    wrapSticker({\n      doc: stickerSet.documents[0],\n      div: container, \n      group: group,\n      lazyLoadQueue\n    }); // kostil\n  }\n}\n\nexport function wrapLocalSticker({emoji, width, height}: {\n  doc?: MyDocument,\n  url?: string,\n  emoji?: string,\n  width: number,\n  height: number,\n}) {\n  const container = document.createElement('div');\n\n  const doc = appStickersManager.getAnimatedEmojiSticker(emoji);\n  if(doc) {\n    wrapSticker({\n      doc,\n      div: container,\n      loop: false,\n      play: true,\n      width,\n      height,\n      emoji\n    }).then(() => {\n      // this.animation = player;\n    });\n  } else {\n    container.classList.add('media-sticker-wrapper');\n  }\n\n  return {container};\n}\n\nexport function wrapReply(title: string | HTMLElement, subtitle: string | HTMLElement, message?: any) {\n  const replyContainer = new ReplyContainer('reply');\n  replyContainer.fill(title, subtitle, message);\n  /////////console.log('wrapReply', title, subtitle, media);\n  return replyContainer.container;\n}\n\nexport function prepareAlbum(options: {\n  container: HTMLElement,\n  items: {w: number, h: number}[],\n  maxWidth: number,\n  minWidth: number,\n  spacing: number,\n  maxHeight?: number,\n  forMedia?: true\n}) {\n  const layouter = new Layouter(options.items, options.maxWidth, options.minWidth, options.spacing, options.maxHeight);\n  const layout = layouter.layout();\n\n  const widthItem = layout.find(item => item.sides & RectPart.Right);\n  const width = widthItem.geometry.width + widthItem.geometry.x;\n\n  const heightItem = layout.find(item => item.sides & RectPart.Bottom);\n  const height = heightItem.geometry.height + heightItem.geometry.y;\n\n  const container = options.container;\n  container.style.width = width + 'px';\n  container.style.height = height + 'px';\n  const children = container.children;\n\n  layout.forEach(({geometry, sides}, idx) => {\n    let div: HTMLElement;\n    div = children[idx] as HTMLElement;\n    if(!div) {\n      div = document.createElement('div');\n      container.append(div);\n    }\n\n    div.classList.add('album-item', 'grouped-item');\n\n    div.style.width = (geometry.width / width * 100) + '%';\n    div.style.height = (geometry.height / height * 100) + '%';\n    div.style.top = (geometry.y / height * 100) + '%';\n    div.style.left = (geometry.x / width * 100) + '%';\n\n    if(sides & RectPart.Left && sides & RectPart.Top) {\n      div.style.borderTopLeftRadius = 'inherit';\n    }\n\n    if(sides & RectPart.Left && sides & RectPart.Bottom) {\n      div.style.borderBottomLeftRadius = 'inherit';\n    }\n\n    if(sides & RectPart.Right && sides & RectPart.Top) {\n      div.style.borderTopRightRadius = 'inherit';\n    }\n\n    if(sides & RectPart.Right && sides & RectPart.Bottom) {\n      div.style.borderBottomRightRadius = 'inherit';\n    }\n\n    if(options.forMedia) {\n      const mediaDiv = document.createElement('div');\n      mediaDiv.classList.add('album-item-media');\n  \n      div.append(mediaDiv);\n    }\n\n    // @ts-ignore\n    //div.style.backgroundColor = '#' + Math.floor(Math.random() * (2 ** 24 - 1)).toString(16).padStart(6, '0');\n  });\n\n  /* if(options.forMedia) {\n    layout.forEach((_, i) => {\n      const mediaDiv = document.createElement('div');\n      mediaDiv.classList.add('album-item-media');\n  \n      options.container.children[i].append(mediaDiv);\n    });\n  } */\n}\n\nexport function wrapAlbum({groupId, attachmentDiv, middleware, uploading, lazyLoadQueue, isOut, chat, loadPromises, noAutoDownload}: {\n  groupId: string, \n  attachmentDiv: HTMLElement,\n  middleware?: () => boolean,\n  lazyLoadQueue?: LazyLoadQueue,\n  uploading?: boolean,\n  isOut: boolean,\n  chat: Chat,\n  loadPromises?: Promise<any>[],\n  noAutoDownload?: boolean,\n}) {\n  const items: {size: PhotoSize.photoSize, media: any, message: any}[] = [];\n\n  // !lowest msgID will be the FIRST in album\n  const storage = appMessagesManager.getMidsByAlbum(groupId);\n  for(const mid of storage) {\n    const m = chat.getMessage(mid);\n    const media = m.media.photo || m.media.document;\n\n    const size: any = media._ === 'photo' ? appPhotosManager.choosePhotoSize(media, 480, 480) : {w: media.w, h: media.h};\n    items.push({size, media, message: m});\n  }\n\n  /* // * pending\n  if(storage[0] < 0) {\n    items.reverse();\n  } */\n\n  prepareAlbum({\n    container: attachmentDiv,\n    items: items.map(i => ({w: i.size.w, h: i.size.h})),\n    maxWidth: mediaSizes.active.album.width,\n    minWidth: 100,\n    spacing: 2,\n    forMedia: true\n  });\n\n  items.forEach((item, idx) => {\n    const {size, media, message} = item;\n\n    const div = attachmentDiv.children[idx] as HTMLElement;\n    div.dataset.mid = '' + message.mid;\n    const mediaDiv = div.firstElementChild as HTMLElement;\n    if(media._ === 'photo') {\n      wrapPhoto({\n        photo: media,\n        message,\n        container: mediaDiv,\n        boxWidth: 0,\n        boxHeight: 0,\n        isOut,\n        lazyLoadQueue,\n        middleware,\n        size,\n        loadPromises,\n        noAutoDownload\n      });\n    } else {\n      wrapVideo({\n        doc: message.media.document,\n        container: mediaDiv,\n        message,\n        boxWidth: 0,\n        boxHeight: 0,\n        withTail: false,\n        isOut,\n        lazyLoadQueue,\n        middleware,\n        loadPromises,\n        noAutoDownload\n      });\n    }\n  });\n}\n\nexport function wrapGroupedDocuments({albumMustBeRenderedFull, message, bubble, messageDiv, chat, loadPromises, noAutoDownload}: {\n  albumMustBeRenderedFull: boolean,\n  message: any,\n  messageDiv: HTMLElement,\n  bubble: HTMLElement,\n  uploading?: boolean,\n  chat: Chat,\n  loadPromises?: Promise<any>[],\n  noAutoDownload?: boolean,\n}) {\n  let nameContainer: HTMLElement;\n  const mids = albumMustBeRenderedFull ? chat.getMidsByMid(message.mid) : [message.mid];\n  /* if(isPending) {\n    mids.reverse();\n  } */\n\n  mids.forEach((mid, idx) => {\n    const message = chat.getMessage(mid);\n    const div = wrapDocument({\n      message,\n      loadPromises,\n      noAutoDownload\n    });\n\n    const container = document.createElement('div');\n    container.classList.add('document-container');\n    container.dataset.mid = '' + mid;\n\n    const wrapper = document.createElement('div');\n    wrapper.classList.add('document-wrapper');\n    \n    if(message.message) {\n      const messageDiv = document.createElement('div');\n      messageDiv.classList.add('document-message');\n\n      const richText = RichTextProcessor.wrapRichText(message.message, {\n        entities: message.totalEntities\n      });\n\n      messageDiv.innerHTML = richText;\n      wrapper.append(messageDiv);\n    }\n\n    if(mids.length > 1) {\n      const selection = document.createElement('div');\n      selection.classList.add('document-selection');\n      container.append(selection);\n      \n      container.classList.add('grouped-item');\n\n      if(idx === 0) {\n        nameContainer = wrapper;\n      }\n    }\n\n    wrapper.append(div);\n    container.append(wrapper);\n    messageDiv.append(container);\n  });\n\n  if(mids.length > 1) {\n    bubble.classList.add('is-multiple-documents', 'is-grouped');\n  }\n\n  return nameContainer;\n}\n\nexport function wrapPoll(message: any) {\n  const elem = new PollElement();\n  elem.message = message;\n  elem.setAttribute('peer-id', '' + message.peerId);\n  elem.setAttribute('poll-id', message.media.poll.id);\n  elem.setAttribute('message-id', '' + message.mid);\n  elem.render();\n  return elem;\n}\n", "/**\n * @link https://core.telegram.org/type/Error\n */\nexport type Error = Error.error;\n\nexport namespace Error {\n  export type error = {\n\t\t_: 'error',\n\t\tcode: number,\n\t\ttext: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputPeer\n */\nexport type InputPeer = InputPeer.inputPeerEmpty | InputPeer.inputPeerSelf | InputPeer.inputPeerChat | InputPeer.inputPeerUser | InputPeer.inputPeerChannel | InputPeer.inputPeerUserFromMessage | InputPeer.inputPeerChannelFromMessage;\n\nexport namespace InputPeer {\n  export type inputPeerEmpty = {\n\t\t_: 'inputPeerEmpty'\n\t};\n\n\texport type inputPeerSelf = {\n\t\t_: 'inputPeerSelf'\n\t};\n\n\texport type inputPeerChat = {\n\t\t_: 'inputPeerChat',\n\t\tchat_id: number\n\t};\n\n\texport type inputPeerUser = {\n\t\t_: 'inputPeerUser',\n\t\tuser_id: number,\n\t\taccess_hash: string\n\t};\n\n\texport type inputPeerChannel = {\n\t\t_: 'inputPeerChannel',\n\t\tchannel_id: number,\n\t\taccess_hash: string\n\t};\n\n\texport type inputPeerUserFromMessage = {\n\t\t_: 'inputPeerUserFromMessage',\n\t\tpeer: InputPeer,\n\t\tmsg_id: number,\n\t\tuser_id: number\n\t};\n\n\texport type inputPeerChannelFromMessage = {\n\t\t_: 'inputPeerChannelFromMessage',\n\t\tpeer: InputPeer,\n\t\tmsg_id: number,\n\t\tchannel_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputUser\n */\nexport type InputUser = InputUser.inputUserEmpty | InputUser.inputUserSelf | InputUser.inputUser | InputUser.inputUserFromMessage;\n\nexport namespace InputUser {\n  export type inputUserEmpty = {\n\t\t_: 'inputUserEmpty'\n\t};\n\n\texport type inputUserSelf = {\n\t\t_: 'inputUserSelf'\n\t};\n\n\texport type inputUser = {\n\t\t_: 'inputUser',\n\t\tuser_id: number,\n\t\taccess_hash: string\n\t};\n\n\texport type inputUserFromMessage = {\n\t\t_: 'inputUserFromMessage',\n\t\tpeer: InputPeer,\n\t\tmsg_id: number,\n\t\tuser_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputContact\n */\nexport type InputContact = InputContact.inputPhoneContact;\n\nexport namespace InputContact {\n  export type inputPhoneContact = {\n\t\t_: 'inputPhoneContact',\n\t\tclient_id: string,\n\t\tphone: string,\n\t\tfirst_name: string,\n\t\tlast_name: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputFile\n */\nexport type InputFile = InputFile.inputFile | InputFile.inputFileBig;\n\nexport namespace InputFile {\n  export type inputFile = {\n\t\t_: 'inputFile',\n\t\tid: string,\n\t\tparts: number,\n\t\tname: string,\n\t\tmd5_checksum: string\n\t};\n\n\texport type inputFileBig = {\n\t\t_: 'inputFileBig',\n\t\tid: string,\n\t\tparts: number,\n\t\tname: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputMedia\n */\nexport type InputMedia = InputMedia.inputMediaEmpty | InputMedia.inputMediaUploadedPhoto | InputMedia.inputMediaPhoto | InputMedia.inputMediaGeoPoint | InputMedia.inputMediaContact | InputMedia.inputMediaUploadedDocument | InputMedia.inputMediaDocument | InputMedia.inputMediaVenue | InputMedia.inputMediaPhotoExternal | InputMedia.inputMediaDocumentExternal | InputMedia.inputMediaGame | InputMedia.inputMediaInvoice | InputMedia.inputMediaGeoLive | InputMedia.inputMediaPoll | InputMedia.inputMediaDice;\n\nexport namespace InputMedia {\n  export type inputMediaEmpty = {\n\t\t_: 'inputMediaEmpty'\n\t};\n\n\texport type inputMediaUploadedPhoto = {\n\t\t_: 'inputMediaUploadedPhoto',\n\t\tflags?: number,\n\t\tfile: InputFile,\n\t\tstickers?: Array<InputDocument>,\n\t\tttl_seconds?: number\n\t};\n\n\texport type inputMediaPhoto = {\n\t\t_: 'inputMediaPhoto',\n\t\tflags?: number,\n\t\tid: InputPhoto,\n\t\tttl_seconds?: number\n\t};\n\n\texport type inputMediaGeoPoint = {\n\t\t_: 'inputMediaGeoPoint',\n\t\tgeo_point: InputGeoPoint\n\t};\n\n\texport type inputMediaContact = {\n\t\t_: 'inputMediaContact',\n\t\tphone_number: string,\n\t\tfirst_name: string,\n\t\tlast_name: string,\n\t\tvcard: string\n\t};\n\n\texport type inputMediaUploadedDocument = {\n\t\t_: 'inputMediaUploadedDocument',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tnosound_video?: true,\n\t\t\tforce_file?: true,\n\t\t}>,\n\t\tfile: InputFile,\n\t\tthumb?: InputFile,\n\t\tmime_type: string,\n\t\tattributes: Array<DocumentAttribute>,\n\t\tstickers?: Array<InputDocument>,\n\t\tttl_seconds?: number\n\t};\n\n\texport type inputMediaDocument = {\n\t\t_: 'inputMediaDocument',\n\t\tflags?: number,\n\t\tid: InputDocument,\n\t\tttl_seconds?: number,\n\t\tquery?: string\n\t};\n\n\texport type inputMediaVenue = {\n\t\t_: 'inputMediaVenue',\n\t\tgeo_point: InputGeoPoint,\n\t\ttitle: string,\n\t\taddress: string,\n\t\tprovider: string,\n\t\tvenue_id: string,\n\t\tvenue_type: string\n\t};\n\n\texport type inputMediaPhotoExternal = {\n\t\t_: 'inputMediaPhotoExternal',\n\t\tflags?: number,\n\t\turl: string,\n\t\tttl_seconds?: number\n\t};\n\n\texport type inputMediaDocumentExternal = {\n\t\t_: 'inputMediaDocumentExternal',\n\t\tflags?: number,\n\t\turl: string,\n\t\tttl_seconds?: number\n\t};\n\n\texport type inputMediaGame = {\n\t\t_: 'inputMediaGame',\n\t\tid: InputGame\n\t};\n\n\texport type inputMediaInvoice = {\n\t\t_: 'inputMediaInvoice',\n\t\tflags?: number,\n\t\ttitle: string,\n\t\tdescription: string,\n\t\tphoto?: InputWebDocument,\n\t\tinvoice: Invoice,\n\t\tpayload: Uint8Array,\n\t\tprovider: string,\n\t\tprovider_data: DataJSON,\n\t\tstart_param?: string\n\t};\n\n\texport type inputMediaGeoLive = {\n\t\t_: 'inputMediaGeoLive',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tstopped?: true,\n\t\t}>,\n\t\tgeo_point: InputGeoPoint,\n\t\theading?: number,\n\t\tperiod?: number,\n\t\tproximity_notification_radius?: number\n\t};\n\n\texport type inputMediaPoll = {\n\t\t_: 'inputMediaPoll',\n\t\tflags?: number,\n\t\tpoll: Poll,\n\t\tcorrect_answers?: Array<Uint8Array>,\n\t\tsolution?: string,\n\t\tsolution_entities?: Array<MessageEntity>\n\t};\n\n\texport type inputMediaDice = {\n\t\t_: 'inputMediaDice',\n\t\temoticon: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputChatPhoto\n */\nexport type InputChatPhoto = InputChatPhoto.inputChatPhotoEmpty | InputChatPhoto.inputChatUploadedPhoto | InputChatPhoto.inputChatPhoto;\n\nexport namespace InputChatPhoto {\n  export type inputChatPhotoEmpty = {\n\t\t_: 'inputChatPhotoEmpty'\n\t};\n\n\texport type inputChatUploadedPhoto = {\n\t\t_: 'inputChatUploadedPhoto',\n\t\tflags?: number,\n\t\tfile?: InputFile,\n\t\tvideo?: InputFile,\n\t\tvideo_start_ts?: number\n\t};\n\n\texport type inputChatPhoto = {\n\t\t_: 'inputChatPhoto',\n\t\tid: InputPhoto\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputGeoPoint\n */\nexport type InputGeoPoint = InputGeoPoint.inputGeoPointEmpty | InputGeoPoint.inputGeoPoint;\n\nexport namespace InputGeoPoint {\n  export type inputGeoPointEmpty = {\n\t\t_: 'inputGeoPointEmpty'\n\t};\n\n\texport type inputGeoPoint = {\n\t\t_: 'inputGeoPoint',\n\t\tflags?: number,\n\t\tlat: number,\n\t\tlong: number,\n\t\taccuracy_radius?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputPhoto\n */\nexport type InputPhoto = InputPhoto.inputPhotoEmpty | InputPhoto.inputPhoto;\n\nexport namespace InputPhoto {\n  export type inputPhotoEmpty = {\n\t\t_: 'inputPhotoEmpty'\n\t};\n\n\texport type inputPhoto = {\n\t\t_: 'inputPhoto',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tfile_reference: Uint8Array | number[]\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputFileLocation\n */\nexport type InputFileLocation = InputFileLocation.inputFileLocation | InputFileLocation.inputEncryptedFileLocation | InputFileLocation.inputDocumentFileLocation | InputFileLocation.inputSecureFileLocation | InputFileLocation.inputTakeoutFileLocation | InputFileLocation.inputPhotoFileLocation | InputFileLocation.inputPhotoLegacyFileLocation | InputFileLocation.inputPeerPhotoFileLocation | InputFileLocation.inputStickerSetThumb | InputFileLocation.inputGroupCallStream;\n\nexport namespace InputFileLocation {\n  export type inputFileLocation = {\n\t\t_: 'inputFileLocation',\n\t\tvolume_id: string,\n\t\tlocal_id: number,\n\t\tsecret: string,\n\t\tfile_reference: Uint8Array | number[]\n\t};\n\n\texport type inputEncryptedFileLocation = {\n\t\t_: 'inputEncryptedFileLocation',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputDocumentFileLocation = {\n\t\t_: 'inputDocumentFileLocation',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tfile_reference: Uint8Array | number[],\n\t\tthumb_size: string,\n\t\tcheckedReference?: boolean\n\t};\n\n\texport type inputSecureFileLocation = {\n\t\t_: 'inputSecureFileLocation',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputTakeoutFileLocation = {\n\t\t_: 'inputTakeoutFileLocation'\n\t};\n\n\texport type inputPhotoFileLocation = {\n\t\t_: 'inputPhotoFileLocation',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tfile_reference: Uint8Array | number[],\n\t\tthumb_size: string\n\t};\n\n\texport type inputPhotoLegacyFileLocation = {\n\t\t_: 'inputPhotoLegacyFileLocation',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tfile_reference: Uint8Array | number[],\n\t\tvolume_id: string,\n\t\tlocal_id: number,\n\t\tsecret: string\n\t};\n\n\texport type inputPeerPhotoFileLocation = {\n\t\t_: 'inputPeerPhotoFileLocation',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tbig?: true,\n\t\t}>,\n\t\tpeer: InputPeer,\n\t\tphoto_id: string\n\t};\n\n\texport type inputStickerSetThumb = {\n\t\t_: 'inputStickerSetThumb',\n\t\tstickerset: InputStickerSet,\n\t\tthumb_version: number\n\t};\n\n\texport type inputGroupCallStream = {\n\t\t_: 'inputGroupCallStream',\n\t\tcall: InputGroupCall,\n\t\ttime_ms: string,\n\t\tscale: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Peer\n */\nexport type Peer = Peer.peerUser | Peer.peerChat | Peer.peerChannel;\n\nexport namespace Peer {\n  export type peerUser = {\n\t\t_: 'peerUser',\n\t\tuser_id: number\n\t};\n\n\texport type peerChat = {\n\t\t_: 'peerChat',\n\t\tchat_id: number\n\t};\n\n\texport type peerChannel = {\n\t\t_: 'peerChannel',\n\t\tchannel_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/storage.FileType\n */\nexport type StorageFileType = StorageFileType.storageFileUnknown | StorageFileType.storageFilePartial | StorageFileType.storageFileJpeg | StorageFileType.storageFileGif | StorageFileType.storageFilePng | StorageFileType.storageFilePdf | StorageFileType.storageFileMp3 | StorageFileType.storageFileMov | StorageFileType.storageFileMp4 | StorageFileType.storageFileWebp;\n\nexport namespace StorageFileType {\n  export type storageFileUnknown = {\n\t\t_: 'storage.fileUnknown'\n\t};\n\n\texport type storageFilePartial = {\n\t\t_: 'storage.filePartial'\n\t};\n\n\texport type storageFileJpeg = {\n\t\t_: 'storage.fileJpeg'\n\t};\n\n\texport type storageFileGif = {\n\t\t_: 'storage.fileGif'\n\t};\n\n\texport type storageFilePng = {\n\t\t_: 'storage.filePng'\n\t};\n\n\texport type storageFilePdf = {\n\t\t_: 'storage.filePdf'\n\t};\n\n\texport type storageFileMp3 = {\n\t\t_: 'storage.fileMp3'\n\t};\n\n\texport type storageFileMov = {\n\t\t_: 'storage.fileMov'\n\t};\n\n\texport type storageFileMp4 = {\n\t\t_: 'storage.fileMp4'\n\t};\n\n\texport type storageFileWebp = {\n\t\t_: 'storage.fileWebp'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/User\n */\nexport type User = User.userEmpty | User.user;\n\nexport namespace User {\n  export type userEmpty = {\n\t\t_: 'userEmpty',\n\t\tid: number\n\t};\n\n\texport type user = {\n\t\t_: 'user',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tself?: true,\n\t\t\tcontact?: true,\n\t\t\tmutual_contact?: true,\n\t\t\tdeleted?: true,\n\t\t\tbot?: true,\n\t\t\tbot_chat_history?: true,\n\t\t\tbot_nochats?: true,\n\t\t\tverified?: true,\n\t\t\trestricted?: true,\n\t\t\tmin?: true,\n\t\t\tbot_inline_geo?: true,\n\t\t\tsupport?: true,\n\t\t\tscam?: true,\n\t\t\tapply_min_photo?: true,\n\t\t\tfake?: true,\n\t\t}>,\n\t\tid: number,\n\t\taccess_hash?: string,\n\t\tfirst_name?: string,\n\t\tlast_name?: string,\n\t\tusername?: string,\n\t\tphone?: string,\n\t\tphoto?: UserProfilePhoto,\n\t\tstatus?: UserStatus,\n\t\tbot_info_version?: number,\n\t\trestriction_reason?: Array<RestrictionReason>,\n\t\tbot_inline_placeholder?: string,\n\t\tlang_code?: string,\n\t\tinitials?: string,\n\t\tsortName?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/UserProfilePhoto\n */\nexport type UserProfilePhoto = UserProfilePhoto.userProfilePhotoEmpty | UserProfilePhoto.userProfilePhoto;\n\nexport namespace UserProfilePhoto {\n  export type userProfilePhotoEmpty = {\n\t\t_: 'userProfilePhotoEmpty'\n\t};\n\n\texport type userProfilePhoto = {\n\t\t_: 'userProfilePhoto',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\thas_video?: true,\n\t\t}>,\n\t\tphoto_id: string,\n\t\tstripped_thumb?: Uint8Array,\n\t\tdc_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/UserStatus\n */\nexport type UserStatus = UserStatus.userStatusEmpty | UserStatus.userStatusOnline | UserStatus.userStatusOffline | UserStatus.userStatusRecently | UserStatus.userStatusLastWeek | UserStatus.userStatusLastMonth;\n\nexport namespace UserStatus {\n  export type userStatusEmpty = {\n\t\t_: 'userStatusEmpty'\n\t};\n\n\texport type userStatusOnline = {\n\t\t_: 'userStatusOnline',\n\t\texpires: number\n\t};\n\n\texport type userStatusOffline = {\n\t\t_: 'userStatusOffline',\n\t\twas_online: number\n\t};\n\n\texport type userStatusRecently = {\n\t\t_: 'userStatusRecently'\n\t};\n\n\texport type userStatusLastWeek = {\n\t\t_: 'userStatusLastWeek'\n\t};\n\n\texport type userStatusLastMonth = {\n\t\t_: 'userStatusLastMonth'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Chat\n */\nexport type Chat = Chat.chatEmpty | Chat.chat | Chat.chatForbidden | Chat.channel | Chat.channelForbidden;\n\nexport namespace Chat {\n  export type chatEmpty = {\n\t\t_: 'chatEmpty',\n\t\tid: number\n\t};\n\n\texport type chat = {\n\t\t_: 'chat',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcreator?: true,\n\t\t\tkicked?: true,\n\t\t\tleft?: true,\n\t\t\tdeactivated?: true,\n\t\t\tcall_active?: true,\n\t\t\tcall_not_empty?: true,\n\t\t}>,\n\t\tid: number,\n\t\ttitle: string,\n\t\tphoto: ChatPhoto,\n\t\tparticipants_count: number,\n\t\tdate: number,\n\t\tversion: number,\n\t\tmigrated_to?: InputChannel,\n\t\tadmin_rights?: ChatAdminRights,\n\t\tdefault_banned_rights?: ChatBannedRights,\n\t\tinitials?: string\n\t};\n\n\texport type chatForbidden = {\n\t\t_: 'chatForbidden',\n\t\tid: number,\n\t\ttitle: string,\n\t\tinitials?: string\n\t};\n\n\texport type channel = {\n\t\t_: 'channel',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcreator?: true,\n\t\t\tleft?: true,\n\t\t\tbroadcast?: true,\n\t\t\tverified?: true,\n\t\t\tmegagroup?: true,\n\t\t\trestricted?: true,\n\t\t\tsignatures?: true,\n\t\t\tmin?: true,\n\t\t\tscam?: true,\n\t\t\thas_link?: true,\n\t\t\thas_geo?: true,\n\t\t\tslowmode_enabled?: true,\n\t\t\tcall_active?: true,\n\t\t\tcall_not_empty?: true,\n\t\t\tfake?: true,\n\t\t\tgigagroup?: true,\n\t\t}>,\n\t\tid: number,\n\t\taccess_hash?: string,\n\t\ttitle: string,\n\t\tusername?: string,\n\t\tphoto: ChatPhoto,\n\t\tdate: number,\n\t\tversion: number,\n\t\trestriction_reason?: Array<RestrictionReason>,\n\t\tadmin_rights?: ChatAdminRights,\n\t\tbanned_rights?: ChatBannedRights,\n\t\tdefault_banned_rights?: ChatBannedRights,\n\t\tparticipants_count?: number,\n\t\tinitials?: string\n\t};\n\n\texport type channelForbidden = {\n\t\t_: 'channelForbidden',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tbroadcast?: true,\n\t\t\tmegagroup?: true,\n\t\t}>,\n\t\tid: number,\n\t\taccess_hash: string,\n\t\ttitle: string,\n\t\tuntil_date?: number,\n\t\tinitials?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatFull\n */\nexport type ChatFull = ChatFull.chatFull | ChatFull.channelFull;\n\nexport namespace ChatFull {\n  export type chatFull = {\n\t\t_: 'chatFull',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcan_set_username?: true,\n\t\t\thas_scheduled?: true,\n\t\t}>,\n\t\tid: number,\n\t\tabout: string,\n\t\tparticipants: ChatParticipants,\n\t\tchat_photo?: Photo,\n\t\tnotify_settings: PeerNotifySettings,\n\t\texported_invite?: ExportedChatInvite,\n\t\tbot_info?: Array<BotInfo>,\n\t\tpinned_msg_id?: number,\n\t\tfolder_id?: number,\n\t\tcall?: InputGroupCall,\n\t\tttl_period?: number,\n\t\tgroupcall_default_join_as?: Peer\n\t};\n\n\texport type channelFull = {\n\t\t_: 'channelFull',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcan_view_participants?: true,\n\t\t\tcan_set_username?: true,\n\t\t\tcan_set_stickers?: true,\n\t\t\thidden_prehistory?: true,\n\t\t\tcan_set_location?: true,\n\t\t\thas_scheduled?: true,\n\t\t\tcan_view_stats?: true,\n\t\t\tblocked?: true,\n\t\t}>,\n\t\tid: number,\n\t\tabout: string,\n\t\tparticipants_count?: number,\n\t\tadmins_count?: number,\n\t\tkicked_count?: number,\n\t\tbanned_count?: number,\n\t\tonline_count?: number,\n\t\tread_inbox_max_id: number,\n\t\tread_outbox_max_id: number,\n\t\tunread_count: number,\n\t\tchat_photo: Photo,\n\t\tnotify_settings: PeerNotifySettings,\n\t\texported_invite?: ExportedChatInvite,\n\t\tbot_info: Array<BotInfo>,\n\t\tmigrated_from_chat_id?: number,\n\t\tmigrated_from_max_id?: number,\n\t\tpinned_msg_id?: number,\n\t\tstickerset?: StickerSet,\n\t\tavailable_min_id?: number,\n\t\tfolder_id?: number,\n\t\tlinked_chat_id?: number,\n\t\tlocation?: ChannelLocation,\n\t\tslowmode_seconds?: number,\n\t\tslowmode_next_send_date?: number,\n\t\tstats_dc?: number,\n\t\tpts: number,\n\t\tcall?: InputGroupCall,\n\t\tttl_period?: number,\n\t\tpending_suggestions?: Array<string>,\n\t\tgroupcall_default_join_as?: Peer\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatParticipant\n */\nexport type ChatParticipant = ChatParticipant.chatParticipant | ChatParticipant.chatParticipantCreator | ChatParticipant.chatParticipantAdmin;\n\nexport namespace ChatParticipant {\n  export type chatParticipant = {\n\t\t_: 'chatParticipant',\n\t\tuser_id: number,\n\t\tinviter_id: number,\n\t\tdate: number\n\t};\n\n\texport type chatParticipantCreator = {\n\t\t_: 'chatParticipantCreator',\n\t\tuser_id: number\n\t};\n\n\texport type chatParticipantAdmin = {\n\t\t_: 'chatParticipantAdmin',\n\t\tuser_id: number,\n\t\tinviter_id: number,\n\t\tdate: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatParticipants\n */\nexport type ChatParticipants = ChatParticipants.chatParticipantsForbidden | ChatParticipants.chatParticipants;\n\nexport namespace ChatParticipants {\n  export type chatParticipantsForbidden = {\n\t\t_: 'chatParticipantsForbidden',\n\t\tflags?: number,\n\t\tchat_id: number,\n\t\tself_participant?: ChatParticipant\n\t};\n\n\texport type chatParticipants = {\n\t\t_: 'chatParticipants',\n\t\tchat_id: number,\n\t\tparticipants: Array<ChatParticipant>,\n\t\tversion: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatPhoto\n */\nexport type ChatPhoto = ChatPhoto.chatPhotoEmpty | ChatPhoto.chatPhoto;\n\nexport namespace ChatPhoto {\n  export type chatPhotoEmpty = {\n\t\t_: 'chatPhotoEmpty'\n\t};\n\n\texport type chatPhoto = {\n\t\t_: 'chatPhoto',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\thas_video?: true,\n\t\t}>,\n\t\tphoto_id: string,\n\t\tstripped_thumb?: Uint8Array,\n\t\tdc_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Message\n */\nexport type Message = Message.messageEmpty | Message.message | Message.messageService;\n\nexport namespace Message {\n  export type messageEmpty = {\n\t\t_: 'messageEmpty',\n\t\tflags?: number,\n\t\tid: number,\n\t\tpeer_id?: Peer,\n\t\tdeleted?: boolean\n\t};\n\n\texport type message = {\n\t\t_: 'message',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tout?: true,\n\t\t\tmentioned?: true,\n\t\t\tmedia_unread?: true,\n\t\t\tsilent?: true,\n\t\t\tpost?: true,\n\t\t\tfrom_scheduled?: true,\n\t\t\tlegacy?: true,\n\t\t\tedit_hide?: true,\n\t\t\tpinned?: true,\n\t\t\tunread?: true,\n\t\t\tis_outgoing?: true,\n\t\t}>,\n\t\tid: number,\n\t\tfrom_id?: Peer,\n\t\tpeer_id: Peer,\n\t\tfwd_from?: MessageFwdHeader,\n\t\tvia_bot_id?: number,\n\t\treply_to?: MessageReplyHeader,\n\t\tdate: number,\n\t\tmessage: string,\n\t\tmedia?: MessageMedia,\n\t\treply_markup?: ReplyMarkup,\n\t\tentities?: Array<MessageEntity>,\n\t\tviews?: number,\n\t\tforwards?: number,\n\t\treplies?: MessageReplies,\n\t\tedit_date?: number,\n\t\tpost_author?: string,\n\t\tgrouped_id?: string,\n\t\trestriction_reason?: Array<RestrictionReason>,\n\t\tttl_period?: number,\n\t\tmid?: number,\n\t\tdeleted?: boolean,\n\t\tpeerId?: number,\n\t\tfromId?: number,\n\t\trandom_id?: string,\n\t\trReply?: string,\n\t\tviaBotId?: number,\n\t\tclear_history?: boolean\n\t};\n\n\texport type messageService = {\n\t\t_: 'messageService',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tout?: true,\n\t\t\tmentioned?: true,\n\t\t\tmedia_unread?: true,\n\t\t\tsilent?: true,\n\t\t\tpost?: true,\n\t\t\tlegacy?: true,\n\t\t\tunread?: true,\n\t\t\tis_outgoing?: true,\n\t\t\tis_single?: true,\n\t\t}>,\n\t\tid: number,\n\t\tfrom_id?: Peer,\n\t\tpeer_id: Peer,\n\t\treply_to?: MessageReplyHeader,\n\t\tdate: number,\n\t\taction: MessageAction,\n\t\tttl_period?: number,\n\t\tmid?: number,\n\t\tdeleted?: boolean,\n\t\tpeerId?: number,\n\t\tfromId?: number,\n\t\trReply?: string,\n\t\tviaBotId?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageMedia\n */\nexport type MessageMedia = MessageMedia.messageMediaEmpty | MessageMedia.messageMediaPhoto | MessageMedia.messageMediaGeo | MessageMedia.messageMediaContact | MessageMedia.messageMediaUnsupported | MessageMedia.messageMediaDocument | MessageMedia.messageMediaWebPage | MessageMedia.messageMediaVenue | MessageMedia.messageMediaGame | MessageMedia.messageMediaInvoice | MessageMedia.messageMediaGeoLive | MessageMedia.messageMediaPoll | MessageMedia.messageMediaDice;\n\nexport namespace MessageMedia {\n  export type messageMediaEmpty = {\n\t\t_: 'messageMediaEmpty'\n\t};\n\n\texport type messageMediaPhoto = {\n\t\t_: 'messageMediaPhoto',\n\t\tflags?: number,\n\t\tphoto?: Photo,\n\t\tttl_seconds?: number\n\t};\n\n\texport type messageMediaGeo = {\n\t\t_: 'messageMediaGeo',\n\t\tgeo: GeoPoint\n\t};\n\n\texport type messageMediaContact = {\n\t\t_: 'messageMediaContact',\n\t\tphone_number: string,\n\t\tfirst_name: string,\n\t\tlast_name: string,\n\t\tvcard: string,\n\t\tuser_id: number\n\t};\n\n\texport type messageMediaUnsupported = {\n\t\t_: 'messageMediaUnsupported'\n\t};\n\n\texport type messageMediaDocument = {\n\t\t_: 'messageMediaDocument',\n\t\tflags?: number,\n\t\tdocument?: Document,\n\t\tttl_seconds?: number\n\t};\n\n\texport type messageMediaWebPage = {\n\t\t_: 'messageMediaWebPage',\n\t\twebpage: WebPage\n\t};\n\n\texport type messageMediaVenue = {\n\t\t_: 'messageMediaVenue',\n\t\tgeo: GeoPoint,\n\t\ttitle: string,\n\t\taddress: string,\n\t\tprovider: string,\n\t\tvenue_id: string,\n\t\tvenue_type: string\n\t};\n\n\texport type messageMediaGame = {\n\t\t_: 'messageMediaGame',\n\t\tgame: Game\n\t};\n\n\texport type messageMediaInvoice = {\n\t\t_: 'messageMediaInvoice',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tshipping_address_requested?: true,\n\t\t\ttest?: true,\n\t\t}>,\n\t\ttitle: string,\n\t\tdescription: string,\n\t\tphoto?: WebDocument,\n\t\treceipt_msg_id?: number,\n\t\tcurrency: string,\n\t\ttotal_amount: string,\n\t\tstart_param: string\n\t};\n\n\texport type messageMediaGeoLive = {\n\t\t_: 'messageMediaGeoLive',\n\t\tflags?: number,\n\t\tgeo: GeoPoint,\n\t\theading?: number,\n\t\tperiod: number,\n\t\tproximity_notification_radius?: number\n\t};\n\n\texport type messageMediaPoll = {\n\t\t_: 'messageMediaPoll',\n\t\tpoll: Poll,\n\t\tresults: PollResults\n\t};\n\n\texport type messageMediaDice = {\n\t\t_: 'messageMediaDice',\n\t\tvalue: number,\n\t\temoticon: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageAction\n */\nexport type MessageAction = MessageAction.messageActionEmpty | MessageAction.messageActionChatCreate | MessageAction.messageActionChatEditTitle | MessageAction.messageActionChatEditPhoto | MessageAction.messageActionChatDeletePhoto | MessageAction.messageActionChatAddUser | MessageAction.messageActionChatDeleteUser | MessageAction.messageActionChatJoinedByLink | MessageAction.messageActionChannelCreate | MessageAction.messageActionChatMigrateTo | MessageAction.messageActionChannelMigrateFrom | MessageAction.messageActionPinMessage | MessageAction.messageActionHistoryClear | MessageAction.messageActionGameScore | MessageAction.messageActionPaymentSentMe | MessageAction.messageActionPaymentSent | MessageAction.messageActionPhoneCall | MessageAction.messageActionScreenshotTaken | MessageAction.messageActionCustomAction | MessageAction.messageActionBotAllowed | MessageAction.messageActionSecureValuesSentMe | MessageAction.messageActionSecureValuesSent | MessageAction.messageActionContactSignUp | MessageAction.messageActionGeoProximityReached | MessageAction.messageActionGroupCall | MessageAction.messageActionInviteToGroupCall | MessageAction.messageActionSetMessagesTTL | MessageAction.messageActionGroupCallScheduled | MessageAction.messageActionChatLeave | MessageAction.messageActionChannelDeletePhoto | MessageAction.messageActionChannelEditTitle | MessageAction.messageActionChannelEditPhoto | MessageAction.messageActionChannelEditVideo | MessageAction.messageActionChatEditVideo | MessageAction.messageActionChatAddUsers | MessageAction.messageActionChatJoined | MessageAction.messageActionChatReturn | MessageAction.messageActionChatJoinedYou | MessageAction.messageActionChatReturnYou;\n\nexport namespace MessageAction {\n  export type messageActionEmpty = {\n\t\t_: 'messageActionEmpty'\n\t};\n\n\texport type messageActionChatCreate = {\n\t\t_: 'messageActionChatCreate',\n\t\ttitle: string,\n\t\tusers: Array<number>\n\t};\n\n\texport type messageActionChatEditTitle = {\n\t\t_: 'messageActionChatEditTitle',\n\t\ttitle: string\n\t};\n\n\texport type messageActionChatEditPhoto = {\n\t\t_: 'messageActionChatEditPhoto',\n\t\tphoto: Photo\n\t};\n\n\texport type messageActionChatDeletePhoto = {\n\t\t_: 'messageActionChatDeletePhoto'\n\t};\n\n\texport type messageActionChatAddUser = {\n\t\t_: 'messageActionChatAddUser',\n\t\tusers: Array<number>\n\t};\n\n\texport type messageActionChatDeleteUser = {\n\t\t_: 'messageActionChatDeleteUser',\n\t\tuser_id: number\n\t};\n\n\texport type messageActionChatJoinedByLink = {\n\t\t_: 'messageActionChatJoinedByLink',\n\t\tinviter_id: number\n\t};\n\n\texport type messageActionChannelCreate = {\n\t\t_: 'messageActionChannelCreate',\n\t\ttitle: string\n\t};\n\n\texport type messageActionChatMigrateTo = {\n\t\t_: 'messageActionChatMigrateTo',\n\t\tchannel_id: number\n\t};\n\n\texport type messageActionChannelMigrateFrom = {\n\t\t_: 'messageActionChannelMigrateFrom',\n\t\ttitle: string,\n\t\tchat_id: number\n\t};\n\n\texport type messageActionPinMessage = {\n\t\t_: 'messageActionPinMessage'\n\t};\n\n\texport type messageActionHistoryClear = {\n\t\t_: 'messageActionHistoryClear'\n\t};\n\n\texport type messageActionGameScore = {\n\t\t_: 'messageActionGameScore',\n\t\tgame_id: string,\n\t\tscore: number\n\t};\n\n\texport type messageActionPaymentSentMe = {\n\t\t_: 'messageActionPaymentSentMe',\n\t\tflags?: number,\n\t\tcurrency: string,\n\t\ttotal_amount: string,\n\t\tpayload: Uint8Array,\n\t\tinfo?: PaymentRequestedInfo,\n\t\tshipping_option_id?: string,\n\t\tcharge: PaymentCharge\n\t};\n\n\texport type messageActionPaymentSent = {\n\t\t_: 'messageActionPaymentSent',\n\t\tcurrency: string,\n\t\ttotal_amount: string\n\t};\n\n\texport type messageActionPhoneCall = {\n\t\t_: 'messageActionPhoneCall',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tvideo?: true,\n\t\t}>,\n\t\tcall_id: string,\n\t\treason?: PhoneCallDiscardReason,\n\t\tduration?: number\n\t};\n\n\texport type messageActionScreenshotTaken = {\n\t\t_: 'messageActionScreenshotTaken'\n\t};\n\n\texport type messageActionCustomAction = {\n\t\t_: 'messageActionCustomAction',\n\t\tmessage: string\n\t};\n\n\texport type messageActionBotAllowed = {\n\t\t_: 'messageActionBotAllowed',\n\t\tdomain: string\n\t};\n\n\texport type messageActionSecureValuesSentMe = {\n\t\t_: 'messageActionSecureValuesSentMe',\n\t\tvalues: Array<SecureValue>,\n\t\tcredentials: SecureCredentialsEncrypted\n\t};\n\n\texport type messageActionSecureValuesSent = {\n\t\t_: 'messageActionSecureValuesSent',\n\t\ttypes: Array<SecureValueType>\n\t};\n\n\texport type messageActionContactSignUp = {\n\t\t_: 'messageActionContactSignUp'\n\t};\n\n\texport type messageActionGeoProximityReached = {\n\t\t_: 'messageActionGeoProximityReached',\n\t\tfrom_id: Peer,\n\t\tto_id: Peer,\n\t\tdistance: number\n\t};\n\n\texport type messageActionGroupCall = {\n\t\t_: 'messageActionGroupCall',\n\t\tflags?: number,\n\t\tcall: InputGroupCall,\n\t\tduration?: number\n\t};\n\n\texport type messageActionInviteToGroupCall = {\n\t\t_: 'messageActionInviteToGroupCall',\n\t\tcall: InputGroupCall,\n\t\tusers: Array<number>\n\t};\n\n\texport type messageActionSetMessagesTTL = {\n\t\t_: 'messageActionSetMessagesTTL',\n\t\tperiod: number\n\t};\n\n\texport type messageActionGroupCallScheduled = {\n\t\t_: 'messageActionGroupCallScheduled',\n\t\tcall: InputGroupCall,\n\t\tschedule_date: number\n\t};\n\n\texport type messageActionChatLeave = {\n\t\t_: 'messageActionChatLeave',\n\t\tuser_id?: number\n\t};\n\n\texport type messageActionChannelDeletePhoto = {\n\t\t_: 'messageActionChannelDeletePhoto'\n\t};\n\n\texport type messageActionChannelEditTitle = {\n\t\t_: 'messageActionChannelEditTitle',\n\t\ttitle?: string\n\t};\n\n\texport type messageActionChannelEditPhoto = {\n\t\t_: 'messageActionChannelEditPhoto',\n\t\tphoto?: Photo\n\t};\n\n\texport type messageActionChannelEditVideo = {\n\t\t_: 'messageActionChannelEditVideo',\n\t\tphoto?: Photo\n\t};\n\n\texport type messageActionChatEditVideo = {\n\t\t_: 'messageActionChatEditVideo',\n\t\tphoto?: Photo\n\t};\n\n\texport type messageActionChatAddUsers = {\n\t\t_: 'messageActionChatAddUsers',\n\t\tusers?: Array<number>\n\t};\n\n\texport type messageActionChatJoined = {\n\t\t_: 'messageActionChatJoined',\n\t\tusers?: Array<number>\n\t};\n\n\texport type messageActionChatReturn = {\n\t\t_: 'messageActionChatReturn',\n\t\tusers?: Array<number>\n\t};\n\n\texport type messageActionChatJoinedYou = {\n\t\t_: 'messageActionChatJoinedYou',\n\t\tusers?: Array<number>\n\t};\n\n\texport type messageActionChatReturnYou = {\n\t\t_: 'messageActionChatReturnYou',\n\t\tusers?: Array<number>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Dialog\n */\nexport type Dialog = Dialog.dialog | Dialog.dialogFolder;\n\nexport namespace Dialog {\n  export type dialog = {\n\t\t_: 'dialog',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpinned?: true,\n\t\t\tunread_mark?: true,\n\t\t}>,\n\t\tpeer: Peer,\n\t\ttop_message: number,\n\t\tread_inbox_max_id: number,\n\t\tread_outbox_max_id: number,\n\t\tunread_count: number,\n\t\tunread_mentions_count: number,\n\t\tnotify_settings: PeerNotifySettings,\n\t\tpts?: number,\n\t\tdraft?: DraftMessage,\n\t\tfolder_id?: number,\n\t\tindex?: number,\n\t\tpeerId?: number,\n\t\ttopMessage?: any,\n\t\tmigratedTo?: number\n\t};\n\n\texport type dialogFolder = {\n\t\t_: 'dialogFolder',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpinned?: true,\n\t\t}>,\n\t\tfolder: Folder,\n\t\tpeer: Peer,\n\t\ttop_message: number,\n\t\tunread_muted_peers_count: number,\n\t\tunread_unmuted_peers_count: number,\n\t\tunread_muted_messages_count: number,\n\t\tunread_unmuted_messages_count: number,\n\t\tindex?: number,\n\t\tpeerId?: number,\n\t\tfolder_id?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Photo\n */\nexport type Photo = Photo.photoEmpty | Photo.photo;\n\nexport namespace Photo {\n  export type photoEmpty = {\n\t\t_: 'photoEmpty',\n\t\tid: string\n\t};\n\n\texport type photo = {\n\t\t_: 'photo',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\thas_stickers?: true,\n\t\t}>,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tfile_reference: Uint8Array | number[],\n\t\tdate: number,\n\t\tsizes: Array<PhotoSize>,\n\t\tvideo_sizes?: Array<VideoSize>,\n\t\tdc_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PhotoSize\n */\nexport type PhotoSize = PhotoSize.photoSizeEmpty | PhotoSize.photoSize | PhotoSize.photoCachedSize | PhotoSize.photoStrippedSize | PhotoSize.photoSizeProgressive | PhotoSize.photoPathSize;\n\nexport namespace PhotoSize {\n  export type photoSizeEmpty = {\n\t\t_: 'photoSizeEmpty',\n\t\ttype: string\n\t};\n\n\texport type photoSize = {\n\t\t_: 'photoSize',\n\t\ttype: string,\n\t\tw: number,\n\t\th: number,\n\t\tsize: number\n\t};\n\n\texport type photoCachedSize = {\n\t\t_: 'photoCachedSize',\n\t\ttype: string,\n\t\tw: number,\n\t\th: number,\n\t\tbytes: Uint8Array\n\t};\n\n\texport type photoStrippedSize = {\n\t\t_: 'photoStrippedSize',\n\t\ttype: string,\n\t\tbytes: Uint8Array\n\t};\n\n\texport type photoSizeProgressive = {\n\t\t_: 'photoSizeProgressive',\n\t\ttype: string,\n\t\tw: number,\n\t\th: number,\n\t\tsizes: Array<number>,\n\t\tsize?: number\n\t};\n\n\texport type photoPathSize = {\n\t\t_: 'photoPathSize',\n\t\ttype: string,\n\t\tbytes: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/GeoPoint\n */\nexport type GeoPoint = GeoPoint.geoPointEmpty | GeoPoint.geoPoint;\n\nexport namespace GeoPoint {\n  export type geoPointEmpty = {\n\t\t_: 'geoPointEmpty'\n\t};\n\n\texport type geoPoint = {\n\t\t_: 'geoPoint',\n\t\tflags?: number,\n\t\tlong: number,\n\t\tlat: number,\n\t\taccess_hash: string,\n\t\taccuracy_radius?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/auth.SentCode\n */\nexport type AuthSentCode = AuthSentCode.authSentCode;\n\nexport namespace AuthSentCode {\n  export type authSentCode = {\n\t\t_: 'auth.sentCode',\n\t\tflags?: number,\n\t\ttype: AuthSentCodeType,\n\t\tphone_code_hash: string,\n\t\tnext_type?: AuthCodeType,\n\t\ttimeout?: number,\n\t\tphone_number?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/auth.Authorization\n */\nexport type AuthAuthorization = AuthAuthorization.authAuthorization | AuthAuthorization.authAuthorizationSignUpRequired;\n\nexport namespace AuthAuthorization {\n  export type authAuthorization = {\n\t\t_: 'auth.authorization',\n\t\tflags?: number,\n\t\ttmp_sessions?: number,\n\t\tuser: User\n\t};\n\n\texport type authAuthorizationSignUpRequired = {\n\t\t_: 'auth.authorizationSignUpRequired',\n\t\tflags?: number,\n\t\tterms_of_service?: HelpTermsOfService\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/auth.ExportedAuthorization\n */\nexport type AuthExportedAuthorization = AuthExportedAuthorization.authExportedAuthorization;\n\nexport namespace AuthExportedAuthorization {\n  export type authExportedAuthorization = {\n\t\t_: 'auth.exportedAuthorization',\n\t\tid: number,\n\t\tbytes: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputNotifyPeer\n */\nexport type InputNotifyPeer = InputNotifyPeer.inputNotifyPeer | InputNotifyPeer.inputNotifyUsers | InputNotifyPeer.inputNotifyChats | InputNotifyPeer.inputNotifyBroadcasts;\n\nexport namespace InputNotifyPeer {\n  export type inputNotifyPeer = {\n\t\t_: 'inputNotifyPeer',\n\t\tpeer: InputPeer\n\t};\n\n\texport type inputNotifyUsers = {\n\t\t_: 'inputNotifyUsers'\n\t};\n\n\texport type inputNotifyChats = {\n\t\t_: 'inputNotifyChats'\n\t};\n\n\texport type inputNotifyBroadcasts = {\n\t\t_: 'inputNotifyBroadcasts'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputPeerNotifySettings\n */\nexport type InputPeerNotifySettings = InputPeerNotifySettings.inputPeerNotifySettings;\n\nexport namespace InputPeerNotifySettings {\n  export type inputPeerNotifySettings = {\n\t\t_: 'inputPeerNotifySettings',\n\t\tflags?: number,\n\t\tshow_previews?: boolean,\n\t\tsilent?: boolean,\n\t\tmute_until?: number,\n\t\tsound?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PeerNotifySettings\n */\nexport type PeerNotifySettings = PeerNotifySettings.peerNotifySettings;\n\nexport namespace PeerNotifySettings {\n  export type peerNotifySettings = {\n\t\t_: 'peerNotifySettings',\n\t\tflags?: number,\n\t\tshow_previews?: boolean,\n\t\tsilent?: boolean,\n\t\tmute_until?: number,\n\t\tsound?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PeerSettings\n */\nexport type PeerSettings = PeerSettings.peerSettings;\n\nexport namespace PeerSettings {\n  export type peerSettings = {\n\t\t_: 'peerSettings',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\treport_spam?: true,\n\t\t\tadd_contact?: true,\n\t\t\tblock_contact?: true,\n\t\t\tshare_contact?: true,\n\t\t\tneed_contacts_exception?: true,\n\t\t\treport_geo?: true,\n\t\t\tautoarchived?: true,\n\t\t\tinvite_members?: true,\n\t\t}>,\n\t\tgeo_distance?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/WallPaper\n */\nexport type WallPaper = WallPaper.wallPaper | WallPaper.wallPaperNoFile;\n\nexport namespace WallPaper {\n  export type wallPaper = {\n\t\t_: 'wallPaper',\n\t\tid: string,\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcreator?: true,\n\t\t\tdefault?: true,\n\t\t\tpattern?: true,\n\t\t\tdark?: true,\n\t\t}>,\n\t\taccess_hash: string,\n\t\tslug: string,\n\t\tdocument: Document,\n\t\tsettings?: WallPaperSettings\n\t};\n\n\texport type wallPaperNoFile = {\n\t\t_: 'wallPaperNoFile',\n\t\tid: string,\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tdefault?: true,\n\t\t\tdark?: true,\n\t\t}>,\n\t\tsettings?: WallPaperSettings\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ReportReason\n */\nexport type ReportReason = ReportReason.inputReportReasonSpam | ReportReason.inputReportReasonViolence | ReportReason.inputReportReasonPornography | ReportReason.inputReportReasonChildAbuse | ReportReason.inputReportReasonOther | ReportReason.inputReportReasonCopyright | ReportReason.inputReportReasonGeoIrrelevant | ReportReason.inputReportReasonFake;\n\nexport namespace ReportReason {\n  export type inputReportReasonSpam = {\n\t\t_: 'inputReportReasonSpam'\n\t};\n\n\texport type inputReportReasonViolence = {\n\t\t_: 'inputReportReasonViolence'\n\t};\n\n\texport type inputReportReasonPornography = {\n\t\t_: 'inputReportReasonPornography'\n\t};\n\n\texport type inputReportReasonChildAbuse = {\n\t\t_: 'inputReportReasonChildAbuse'\n\t};\n\n\texport type inputReportReasonOther = {\n\t\t_: 'inputReportReasonOther'\n\t};\n\n\texport type inputReportReasonCopyright = {\n\t\t_: 'inputReportReasonCopyright'\n\t};\n\n\texport type inputReportReasonGeoIrrelevant = {\n\t\t_: 'inputReportReasonGeoIrrelevant'\n\t};\n\n\texport type inputReportReasonFake = {\n\t\t_: 'inputReportReasonFake'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/UserFull\n */\nexport type UserFull = UserFull.userFull;\n\nexport namespace UserFull {\n  export type userFull = {\n\t\t_: 'userFull',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tblocked?: true,\n\t\t\tphone_calls_available?: true,\n\t\t\tphone_calls_private?: true,\n\t\t\tcan_pin_message?: true,\n\t\t\thas_scheduled?: true,\n\t\t\tvideo_calls_available?: true,\n\t\t}>,\n\t\tuser: User,\n\t\tabout?: string,\n\t\tsettings: PeerSettings,\n\t\tprofile_photo?: Photo,\n\t\tnotify_settings: PeerNotifySettings,\n\t\tbot_info?: BotInfo,\n\t\tpinned_msg_id?: number,\n\t\tcommon_chats_count: number,\n\t\tfolder_id?: number,\n\t\tttl_period?: number,\n\t\trAbout?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Contact\n */\nexport type Contact = Contact.contact;\n\nexport namespace Contact {\n  export type contact = {\n\t\t_: 'contact',\n\t\tuser_id: number,\n\t\tmutual: boolean\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ImportedContact\n */\nexport type ImportedContact = ImportedContact.importedContact;\n\nexport namespace ImportedContact {\n  export type importedContact = {\n\t\t_: 'importedContact',\n\t\tuser_id: number,\n\t\tclient_id: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ContactStatus\n */\nexport type ContactStatus = ContactStatus.contactStatus;\n\nexport namespace ContactStatus {\n  export type contactStatus = {\n\t\t_: 'contactStatus',\n\t\tuser_id: number,\n\t\tstatus: UserStatus\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/contacts.Contacts\n */\nexport type ContactsContacts = ContactsContacts.contactsContactsNotModified | ContactsContacts.contactsContacts;\n\nexport namespace ContactsContacts {\n  export type contactsContactsNotModified = {\n\t\t_: 'contacts.contactsNotModified'\n\t};\n\n\texport type contactsContacts = {\n\t\t_: 'contacts.contacts',\n\t\tcontacts: Array<Contact>,\n\t\tsaved_count: number,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/contacts.ImportedContacts\n */\nexport type ContactsImportedContacts = ContactsImportedContacts.contactsImportedContacts;\n\nexport namespace ContactsImportedContacts {\n  export type contactsImportedContacts = {\n\t\t_: 'contacts.importedContacts',\n\t\timported: Array<ImportedContact>,\n\t\tpopular_invites: Array<PopularContact>,\n\t\tretry_contacts: Array<string>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/contacts.Blocked\n */\nexport type ContactsBlocked = ContactsBlocked.contactsBlocked | ContactsBlocked.contactsBlockedSlice;\n\nexport namespace ContactsBlocked {\n  export type contactsBlocked = {\n\t\t_: 'contacts.blocked',\n\t\tblocked: Array<PeerBlocked>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type contactsBlockedSlice = {\n\t\t_: 'contacts.blockedSlice',\n\t\tcount: number,\n\t\tblocked: Array<PeerBlocked>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.Dialogs\n */\nexport type MessagesDialogs = MessagesDialogs.messagesDialogs | MessagesDialogs.messagesDialogsSlice | MessagesDialogs.messagesDialogsNotModified;\n\nexport namespace MessagesDialogs {\n  export type messagesDialogs = {\n\t\t_: 'messages.dialogs',\n\t\tdialogs: Array<Dialog>,\n\t\tmessages: Array<Message>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type messagesDialogsSlice = {\n\t\t_: 'messages.dialogsSlice',\n\t\tcount: number,\n\t\tdialogs: Array<Dialog>,\n\t\tmessages: Array<Message>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type messagesDialogsNotModified = {\n\t\t_: 'messages.dialogsNotModified',\n\t\tcount: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.Messages\n */\nexport type MessagesMessages = MessagesMessages.messagesMessages | MessagesMessages.messagesMessagesSlice | MessagesMessages.messagesChannelMessages | MessagesMessages.messagesMessagesNotModified;\n\nexport namespace MessagesMessages {\n  export type messagesMessages = {\n\t\t_: 'messages.messages',\n\t\tmessages: Array<Message>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type messagesMessagesSlice = {\n\t\t_: 'messages.messagesSlice',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tinexact?: true,\n\t\t}>,\n\t\tcount: number,\n\t\tnext_rate?: number,\n\t\toffset_id_offset?: number,\n\t\tmessages: Array<Message>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type messagesChannelMessages = {\n\t\t_: 'messages.channelMessages',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tinexact?: true,\n\t\t}>,\n\t\tpts: number,\n\t\tcount: number,\n\t\toffset_id_offset?: number,\n\t\tmessages: Array<Message>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type messagesMessagesNotModified = {\n\t\t_: 'messages.messagesNotModified',\n\t\tcount: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.Chats\n */\nexport type MessagesChats = MessagesChats.messagesChats | MessagesChats.messagesChatsSlice;\n\nexport namespace MessagesChats {\n  export type messagesChats = {\n\t\t_: 'messages.chats',\n\t\tchats: Array<Chat>\n\t};\n\n\texport type messagesChatsSlice = {\n\t\t_: 'messages.chatsSlice',\n\t\tcount: number,\n\t\tchats: Array<Chat>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.ChatFull\n */\nexport type MessagesChatFull = MessagesChatFull.messagesChatFull;\n\nexport namespace MessagesChatFull {\n  export type messagesChatFull = {\n\t\t_: 'messages.chatFull',\n\t\tfull_chat: ChatFull,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.AffectedHistory\n */\nexport type MessagesAffectedHistory = MessagesAffectedHistory.messagesAffectedHistory;\n\nexport namespace MessagesAffectedHistory {\n  export type messagesAffectedHistory = {\n\t\t_: 'messages.affectedHistory',\n\t\tpts: number,\n\t\tpts_count: number,\n\t\toffset: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessagesFilter\n */\nexport type MessagesFilter = MessagesFilter.inputMessagesFilterEmpty | MessagesFilter.inputMessagesFilterPhotos | MessagesFilter.inputMessagesFilterVideo | MessagesFilter.inputMessagesFilterPhotoVideo | MessagesFilter.inputMessagesFilterDocument | MessagesFilter.inputMessagesFilterUrl | MessagesFilter.inputMessagesFilterGif | MessagesFilter.inputMessagesFilterVoice | MessagesFilter.inputMessagesFilterMusic | MessagesFilter.inputMessagesFilterChatPhotos | MessagesFilter.inputMessagesFilterPhoneCalls | MessagesFilter.inputMessagesFilterRoundVoice | MessagesFilter.inputMessagesFilterRoundVideo | MessagesFilter.inputMessagesFilterMyMentions | MessagesFilter.inputMessagesFilterGeo | MessagesFilter.inputMessagesFilterContacts | MessagesFilter.inputMessagesFilterPinned;\n\nexport namespace MessagesFilter {\n  export type inputMessagesFilterEmpty = {\n\t\t_: 'inputMessagesFilterEmpty'\n\t};\n\n\texport type inputMessagesFilterPhotos = {\n\t\t_: 'inputMessagesFilterPhotos'\n\t};\n\n\texport type inputMessagesFilterVideo = {\n\t\t_: 'inputMessagesFilterVideo'\n\t};\n\n\texport type inputMessagesFilterPhotoVideo = {\n\t\t_: 'inputMessagesFilterPhotoVideo'\n\t};\n\n\texport type inputMessagesFilterDocument = {\n\t\t_: 'inputMessagesFilterDocument'\n\t};\n\n\texport type inputMessagesFilterUrl = {\n\t\t_: 'inputMessagesFilterUrl'\n\t};\n\n\texport type inputMessagesFilterGif = {\n\t\t_: 'inputMessagesFilterGif'\n\t};\n\n\texport type inputMessagesFilterVoice = {\n\t\t_: 'inputMessagesFilterVoice'\n\t};\n\n\texport type inputMessagesFilterMusic = {\n\t\t_: 'inputMessagesFilterMusic'\n\t};\n\n\texport type inputMessagesFilterChatPhotos = {\n\t\t_: 'inputMessagesFilterChatPhotos'\n\t};\n\n\texport type inputMessagesFilterPhoneCalls = {\n\t\t_: 'inputMessagesFilterPhoneCalls',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tmissed?: true,\n\t\t}>\n\t};\n\n\texport type inputMessagesFilterRoundVoice = {\n\t\t_: 'inputMessagesFilterRoundVoice'\n\t};\n\n\texport type inputMessagesFilterRoundVideo = {\n\t\t_: 'inputMessagesFilterRoundVideo'\n\t};\n\n\texport type inputMessagesFilterMyMentions = {\n\t\t_: 'inputMessagesFilterMyMentions'\n\t};\n\n\texport type inputMessagesFilterGeo = {\n\t\t_: 'inputMessagesFilterGeo'\n\t};\n\n\texport type inputMessagesFilterContacts = {\n\t\t_: 'inputMessagesFilterContacts'\n\t};\n\n\texport type inputMessagesFilterPinned = {\n\t\t_: 'inputMessagesFilterPinned'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Update\n */\nexport type Update = Update.updateNewMessage | Update.updateMessageID | Update.updateDeleteMessages | Update.updateUserTyping | Update.updateChatUserTyping | Update.updateChatParticipants | Update.updateUserStatus | Update.updateUserName | Update.updateUserPhoto | Update.updateNewEncryptedMessage | Update.updateEncryptedChatTyping | Update.updateEncryption | Update.updateEncryptedMessagesRead | Update.updateChatParticipantAdd | Update.updateChatParticipantDelete | Update.updateDcOptions | Update.updateNotifySettings | Update.updateServiceNotification | Update.updatePrivacy | Update.updateUserPhone | Update.updateReadHistoryInbox | Update.updateReadHistoryOutbox | Update.updateWebPage | Update.updateReadMessagesContents | Update.updateChannelTooLong | Update.updateChannel | Update.updateNewChannelMessage | Update.updateReadChannelInbox | Update.updateDeleteChannelMessages | Update.updateChannelMessageViews | Update.updateChatParticipantAdmin | Update.updateNewStickerSet | Update.updateStickerSetsOrder | Update.updateStickerSets | Update.updateSavedGifs | Update.updateBotInlineQuery | Update.updateBotInlineSend | Update.updateEditChannelMessage | Update.updateBotCallbackQuery | Update.updateEditMessage | Update.updateInlineBotCallbackQuery | Update.updateReadChannelOutbox | Update.updateDraftMessage | Update.updateReadFeaturedStickers | Update.updateRecentStickers | Update.updateConfig | Update.updatePtsChanged | Update.updateChannelWebPage | Update.updateDialogPinned | Update.updatePinnedDialogs | Update.updateBotWebhookJSON | Update.updateBotWebhookJSONQuery | Update.updateBotShippingQuery | Update.updateBotPrecheckoutQuery | Update.updatePhoneCall | Update.updateLangPackTooLong | Update.updateLangPack | Update.updateFavedStickers | Update.updateChannelReadMessagesContents | Update.updateContactsReset | Update.updateChannelAvailableMessages | Update.updateDialogUnreadMark | Update.updateMessagePoll | Update.updateChatDefaultBannedRights | Update.updateFolderPeers | Update.updatePeerSettings | Update.updatePeerLocated | Update.updateNewScheduledMessage | Update.updateDeleteScheduledMessages | Update.updateTheme | Update.updateGeoLiveViewed | Update.updateLoginToken | Update.updateMessagePollVote | Update.updateDialogFilter | Update.updateDialogFilterOrder | Update.updateDialogFilters | Update.updatePhoneCallSignalingData | Update.updateChannelMessageForwards | Update.updateReadChannelDiscussionInbox | Update.updateReadChannelDiscussionOutbox | Update.updatePeerBlocked | Update.updateChannelUserTyping | Update.updatePinnedMessages | Update.updatePinnedChannelMessages | Update.updateChat | Update.updateGroupCallParticipants | Update.updateGroupCall | Update.updatePeerHistoryTTL | Update.updateChatParticipant | Update.updateChannelParticipant | Update.updateBotStopped | Update.updateGroupCallConnection | Update.updateBotCommands | Update.updateNewDiscussionMessage | Update.updateDeleteDiscussionMessages | Update.updateChannelReload;\n\nexport namespace Update {\n  export type updateNewMessage = {\n\t\t_: 'updateNewMessage',\n\t\tmessage: Message,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateMessageID = {\n\t\t_: 'updateMessageID',\n\t\tid: number,\n\t\trandom_id: string\n\t};\n\n\texport type updateDeleteMessages = {\n\t\t_: 'updateDeleteMessages',\n\t\tmessages: Array<number>,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateUserTyping = {\n\t\t_: 'updateUserTyping',\n\t\tuser_id: number,\n\t\taction: SendMessageAction\n\t};\n\n\texport type updateChatUserTyping = {\n\t\t_: 'updateChatUserTyping',\n\t\tchat_id: number,\n\t\tfrom_id: Peer,\n\t\taction: SendMessageAction\n\t};\n\n\texport type updateChatParticipants = {\n\t\t_: 'updateChatParticipants',\n\t\tparticipants: ChatParticipants\n\t};\n\n\texport type updateUserStatus = {\n\t\t_: 'updateUserStatus',\n\t\tuser_id: number,\n\t\tstatus: UserStatus\n\t};\n\n\texport type updateUserName = {\n\t\t_: 'updateUserName',\n\t\tuser_id: number,\n\t\tfirst_name: string,\n\t\tlast_name: string,\n\t\tusername: string\n\t};\n\n\texport type updateUserPhoto = {\n\t\t_: 'updateUserPhoto',\n\t\tuser_id: number,\n\t\tdate: number,\n\t\tphoto: UserProfilePhoto,\n\t\tprevious: boolean\n\t};\n\n\texport type updateNewEncryptedMessage = {\n\t\t_: 'updateNewEncryptedMessage',\n\t\tmessage: EncryptedMessage,\n\t\tqts: number\n\t};\n\n\texport type updateEncryptedChatTyping = {\n\t\t_: 'updateEncryptedChatTyping',\n\t\tchat_id: number\n\t};\n\n\texport type updateEncryption = {\n\t\t_: 'updateEncryption',\n\t\tchat: EncryptedChat,\n\t\tdate: number\n\t};\n\n\texport type updateEncryptedMessagesRead = {\n\t\t_: 'updateEncryptedMessagesRead',\n\t\tchat_id: number,\n\t\tmax_date: number,\n\t\tdate: number\n\t};\n\n\texport type updateChatParticipantAdd = {\n\t\t_: 'updateChatParticipantAdd',\n\t\tchat_id: number,\n\t\tuser_id: number,\n\t\tinviter_id: number,\n\t\tdate: number,\n\t\tversion: number\n\t};\n\n\texport type updateChatParticipantDelete = {\n\t\t_: 'updateChatParticipantDelete',\n\t\tchat_id: number,\n\t\tuser_id: number,\n\t\tversion: number\n\t};\n\n\texport type updateDcOptions = {\n\t\t_: 'updateDcOptions',\n\t\tdc_options: Array<DcOption>\n\t};\n\n\texport type updateNotifySettings = {\n\t\t_: 'updateNotifySettings',\n\t\tpeer: NotifyPeer,\n\t\tnotify_settings: PeerNotifySettings\n\t};\n\n\texport type updateServiceNotification = {\n\t\t_: 'updateServiceNotification',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpopup?: true,\n\t\t}>,\n\t\tinbox_date?: number,\n\t\ttype: string,\n\t\tmessage: string,\n\t\tmedia: MessageMedia,\n\t\tentities: Array<MessageEntity>\n\t};\n\n\texport type updatePrivacy = {\n\t\t_: 'updatePrivacy',\n\t\tkey: PrivacyKey,\n\t\trules: Array<PrivacyRule>\n\t};\n\n\texport type updateUserPhone = {\n\t\t_: 'updateUserPhone',\n\t\tuser_id: number,\n\t\tphone: string\n\t};\n\n\texport type updateReadHistoryInbox = {\n\t\t_: 'updateReadHistoryInbox',\n\t\tflags?: number,\n\t\tfolder_id?: number,\n\t\tpeer: Peer,\n\t\tmax_id: number,\n\t\tstill_unread_count: number,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateReadHistoryOutbox = {\n\t\t_: 'updateReadHistoryOutbox',\n\t\tpeer: Peer,\n\t\tmax_id: number,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateWebPage = {\n\t\t_: 'updateWebPage',\n\t\twebpage: WebPage,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateReadMessagesContents = {\n\t\t_: 'updateReadMessagesContents',\n\t\tmessages: Array<number>,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateChannelTooLong = {\n\t\t_: 'updateChannelTooLong',\n\t\tflags?: number,\n\t\tchannel_id: number,\n\t\tpts?: number\n\t};\n\n\texport type updateChannel = {\n\t\t_: 'updateChannel',\n\t\tchannel_id: number\n\t};\n\n\texport type updateNewChannelMessage = {\n\t\t_: 'updateNewChannelMessage',\n\t\tmessage: Message,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateReadChannelInbox = {\n\t\t_: 'updateReadChannelInbox',\n\t\tflags?: number,\n\t\tfolder_id?: number,\n\t\tchannel_id: number,\n\t\tmax_id: number,\n\t\tstill_unread_count: number,\n\t\tpts: number\n\t};\n\n\texport type updateDeleteChannelMessages = {\n\t\t_: 'updateDeleteChannelMessages',\n\t\tchannel_id: number,\n\t\tmessages: Array<number>,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateChannelMessageViews = {\n\t\t_: 'updateChannelMessageViews',\n\t\tchannel_id: number,\n\t\tid: number,\n\t\tviews: number\n\t};\n\n\texport type updateChatParticipantAdmin = {\n\t\t_: 'updateChatParticipantAdmin',\n\t\tchat_id: number,\n\t\tuser_id: number,\n\t\tis_admin: boolean,\n\t\tversion: number\n\t};\n\n\texport type updateNewStickerSet = {\n\t\t_: 'updateNewStickerSet',\n\t\tstickerset: MessagesStickerSet\n\t};\n\n\texport type updateStickerSetsOrder = {\n\t\t_: 'updateStickerSetsOrder',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tmasks?: true,\n\t\t}>,\n\t\torder: Array<string>\n\t};\n\n\texport type updateStickerSets = {\n\t\t_: 'updateStickerSets'\n\t};\n\n\texport type updateSavedGifs = {\n\t\t_: 'updateSavedGifs'\n\t};\n\n\texport type updateBotInlineQuery = {\n\t\t_: 'updateBotInlineQuery',\n\t\tflags?: number,\n\t\tquery_id: string,\n\t\tuser_id: number,\n\t\tquery: string,\n\t\tgeo?: GeoPoint,\n\t\tpeer_type?: InlineQueryPeerType,\n\t\toffset: string\n\t};\n\n\texport type updateBotInlineSend = {\n\t\t_: 'updateBotInlineSend',\n\t\tflags?: number,\n\t\tuser_id: number,\n\t\tquery: string,\n\t\tgeo?: GeoPoint,\n\t\tid: string,\n\t\tmsg_id?: InputBotInlineMessageID\n\t};\n\n\texport type updateEditChannelMessage = {\n\t\t_: 'updateEditChannelMessage',\n\t\tmessage: Message,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateBotCallbackQuery = {\n\t\t_: 'updateBotCallbackQuery',\n\t\tflags?: number,\n\t\tquery_id: string,\n\t\tuser_id: number,\n\t\tpeer: Peer,\n\t\tmsg_id: number,\n\t\tchat_instance: string,\n\t\tdata?: Uint8Array,\n\t\tgame_short_name?: string\n\t};\n\n\texport type updateEditMessage = {\n\t\t_: 'updateEditMessage',\n\t\tmessage: Message,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateInlineBotCallbackQuery = {\n\t\t_: 'updateInlineBotCallbackQuery',\n\t\tflags?: number,\n\t\tquery_id: string,\n\t\tuser_id: number,\n\t\tmsg_id: InputBotInlineMessageID,\n\t\tchat_instance: string,\n\t\tdata?: Uint8Array,\n\t\tgame_short_name?: string\n\t};\n\n\texport type updateReadChannelOutbox = {\n\t\t_: 'updateReadChannelOutbox',\n\t\tchannel_id: number,\n\t\tmax_id: number\n\t};\n\n\texport type updateDraftMessage = {\n\t\t_: 'updateDraftMessage',\n\t\tpeer: Peer,\n\t\tdraft: DraftMessage,\n\t\tlocal?: boolean,\n\t\tthreadId?: number\n\t};\n\n\texport type updateReadFeaturedStickers = {\n\t\t_: 'updateReadFeaturedStickers'\n\t};\n\n\texport type updateRecentStickers = {\n\t\t_: 'updateRecentStickers'\n\t};\n\n\texport type updateConfig = {\n\t\t_: 'updateConfig'\n\t};\n\n\texport type updatePtsChanged = {\n\t\t_: 'updatePtsChanged'\n\t};\n\n\texport type updateChannelWebPage = {\n\t\t_: 'updateChannelWebPage',\n\t\tchannel_id: number,\n\t\twebpage: WebPage,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateDialogPinned = {\n\t\t_: 'updateDialogPinned',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpinned?: true,\n\t\t}>,\n\t\tfolder_id?: number,\n\t\tpeer: DialogPeer\n\t};\n\n\texport type updatePinnedDialogs = {\n\t\t_: 'updatePinnedDialogs',\n\t\tflags?: number,\n\t\tfolder_id?: number,\n\t\torder?: Array<DialogPeer>\n\t};\n\n\texport type updateBotWebhookJSON = {\n\t\t_: 'updateBotWebhookJSON',\n\t\tdata: DataJSON\n\t};\n\n\texport type updateBotWebhookJSONQuery = {\n\t\t_: 'updateBotWebhookJSONQuery',\n\t\tquery_id: string,\n\t\tdata: DataJSON,\n\t\ttimeout: number\n\t};\n\n\texport type updateBotShippingQuery = {\n\t\t_: 'updateBotShippingQuery',\n\t\tquery_id: string,\n\t\tuser_id: number,\n\t\tpayload: Uint8Array,\n\t\tshipping_address: PostAddress\n\t};\n\n\texport type updateBotPrecheckoutQuery = {\n\t\t_: 'updateBotPrecheckoutQuery',\n\t\tflags?: number,\n\t\tquery_id: string,\n\t\tuser_id: number,\n\t\tpayload: Uint8Array,\n\t\tinfo?: PaymentRequestedInfo,\n\t\tshipping_option_id?: string,\n\t\tcurrency: string,\n\t\ttotal_amount: string\n\t};\n\n\texport type updatePhoneCall = {\n\t\t_: 'updatePhoneCall',\n\t\tphone_call: PhoneCall\n\t};\n\n\texport type updateLangPackTooLong = {\n\t\t_: 'updateLangPackTooLong',\n\t\tlang_code: string\n\t};\n\n\texport type updateLangPack = {\n\t\t_: 'updateLangPack',\n\t\tdifference: LangPackDifference\n\t};\n\n\texport type updateFavedStickers = {\n\t\t_: 'updateFavedStickers'\n\t};\n\n\texport type updateChannelReadMessagesContents = {\n\t\t_: 'updateChannelReadMessagesContents',\n\t\tchannel_id: number,\n\t\tmessages: Array<number>\n\t};\n\n\texport type updateContactsReset = {\n\t\t_: 'updateContactsReset'\n\t};\n\n\texport type updateChannelAvailableMessages = {\n\t\t_: 'updateChannelAvailableMessages',\n\t\tchannel_id: number,\n\t\tavailable_min_id: number\n\t};\n\n\texport type updateDialogUnreadMark = {\n\t\t_: 'updateDialogUnreadMark',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tunread?: true,\n\t\t}>,\n\t\tpeer: DialogPeer\n\t};\n\n\texport type updateMessagePoll = {\n\t\t_: 'updateMessagePoll',\n\t\tflags?: number,\n\t\tpoll_id: string,\n\t\tpoll?: Poll,\n\t\tresults: PollResults\n\t};\n\n\texport type updateChatDefaultBannedRights = {\n\t\t_: 'updateChatDefaultBannedRights',\n\t\tpeer: Peer,\n\t\tdefault_banned_rights: ChatBannedRights,\n\t\tversion: number\n\t};\n\n\texport type updateFolderPeers = {\n\t\t_: 'updateFolderPeers',\n\t\tfolder_peers: Array<FolderPeer>,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updatePeerSettings = {\n\t\t_: 'updatePeerSettings',\n\t\tpeer: Peer,\n\t\tsettings: PeerSettings\n\t};\n\n\texport type updatePeerLocated = {\n\t\t_: 'updatePeerLocated',\n\t\tpeers: Array<PeerLocated>\n\t};\n\n\texport type updateNewScheduledMessage = {\n\t\t_: 'updateNewScheduledMessage',\n\t\tmessage: Message\n\t};\n\n\texport type updateDeleteScheduledMessages = {\n\t\t_: 'updateDeleteScheduledMessages',\n\t\tpeer: Peer,\n\t\tmessages: Array<number>\n\t};\n\n\texport type updateTheme = {\n\t\t_: 'updateTheme',\n\t\ttheme: Theme\n\t};\n\n\texport type updateGeoLiveViewed = {\n\t\t_: 'updateGeoLiveViewed',\n\t\tpeer: Peer,\n\t\tmsg_id: number\n\t};\n\n\texport type updateLoginToken = {\n\t\t_: 'updateLoginToken'\n\t};\n\n\texport type updateMessagePollVote = {\n\t\t_: 'updateMessagePollVote',\n\t\tpoll_id: string,\n\t\tuser_id: number,\n\t\toptions: Array<Uint8Array>,\n\t\tqts: number\n\t};\n\n\texport type updateDialogFilter = {\n\t\t_: 'updateDialogFilter',\n\t\tflags?: number,\n\t\tid: number,\n\t\tfilter?: DialogFilter\n\t};\n\n\texport type updateDialogFilterOrder = {\n\t\t_: 'updateDialogFilterOrder',\n\t\torder: Array<number>\n\t};\n\n\texport type updateDialogFilters = {\n\t\t_: 'updateDialogFilters'\n\t};\n\n\texport type updatePhoneCallSignalingData = {\n\t\t_: 'updatePhoneCallSignalingData',\n\t\tphone_call_id: string,\n\t\tdata: Uint8Array\n\t};\n\n\texport type updateChannelMessageForwards = {\n\t\t_: 'updateChannelMessageForwards',\n\t\tchannel_id: number,\n\t\tid: number,\n\t\tforwards: number\n\t};\n\n\texport type updateReadChannelDiscussionInbox = {\n\t\t_: 'updateReadChannelDiscussionInbox',\n\t\tflags?: number,\n\t\tchannel_id: number,\n\t\ttop_msg_id: number,\n\t\tread_max_id: number,\n\t\tbroadcast_id?: number,\n\t\tbroadcast_post?: number\n\t};\n\n\texport type updateReadChannelDiscussionOutbox = {\n\t\t_: 'updateReadChannelDiscussionOutbox',\n\t\tchannel_id: number,\n\t\ttop_msg_id: number,\n\t\tread_max_id: number\n\t};\n\n\texport type updatePeerBlocked = {\n\t\t_: 'updatePeerBlocked',\n\t\tpeer_id: Peer,\n\t\tblocked: boolean\n\t};\n\n\texport type updateChannelUserTyping = {\n\t\t_: 'updateChannelUserTyping',\n\t\tflags?: number,\n\t\tchannel_id: number,\n\t\ttop_msg_id?: number,\n\t\tfrom_id: Peer,\n\t\taction: SendMessageAction\n\t};\n\n\texport type updatePinnedMessages = {\n\t\t_: 'updatePinnedMessages',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpinned?: true,\n\t\t}>,\n\t\tpeer: Peer,\n\t\tmessages: Array<number>,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updatePinnedChannelMessages = {\n\t\t_: 'updatePinnedChannelMessages',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpinned?: true,\n\t\t}>,\n\t\tchannel_id: number,\n\t\tmessages: Array<number>,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateChat = {\n\t\t_: 'updateChat',\n\t\tchat_id: number\n\t};\n\n\texport type updateGroupCallParticipants = {\n\t\t_: 'updateGroupCallParticipants',\n\t\tcall: InputGroupCall,\n\t\tparticipants: Array<GroupCallParticipant>,\n\t\tversion: number\n\t};\n\n\texport type updateGroupCall = {\n\t\t_: 'updateGroupCall',\n\t\tchat_id: number,\n\t\tcall: GroupCall\n\t};\n\n\texport type updatePeerHistoryTTL = {\n\t\t_: 'updatePeerHistoryTTL',\n\t\tflags?: number,\n\t\tpeer: Peer,\n\t\tttl_period?: number\n\t};\n\n\texport type updateChatParticipant = {\n\t\t_: 'updateChatParticipant',\n\t\tflags?: number,\n\t\tchat_id: number,\n\t\tdate: number,\n\t\tactor_id: number,\n\t\tuser_id: number,\n\t\tprev_participant?: ChatParticipant,\n\t\tnew_participant?: ChatParticipant,\n\t\tinvite?: ExportedChatInvite,\n\t\tqts: number\n\t};\n\n\texport type updateChannelParticipant = {\n\t\t_: 'updateChannelParticipant',\n\t\tflags?: number,\n\t\tchannel_id: number,\n\t\tdate: number,\n\t\tactor_id: number,\n\t\tuser_id: number,\n\t\tprev_participant?: ChannelParticipant,\n\t\tnew_participant?: ChannelParticipant,\n\t\tinvite?: ExportedChatInvite,\n\t\tqts: number\n\t};\n\n\texport type updateBotStopped = {\n\t\t_: 'updateBotStopped',\n\t\tuser_id: number,\n\t\tdate: number,\n\t\tstopped: boolean,\n\t\tqts: number\n\t};\n\n\texport type updateGroupCallConnection = {\n\t\t_: 'updateGroupCallConnection',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpresentation?: true,\n\t\t}>,\n\t\tparams: DataJSON\n\t};\n\n\texport type updateBotCommands = {\n\t\t_: 'updateBotCommands',\n\t\tpeer: Peer,\n\t\tbot_id: number,\n\t\tcommands: Array<BotCommand>\n\t};\n\n\texport type updateNewDiscussionMessage = {\n\t\t_: 'updateNewDiscussionMessage',\n\t\tmessage?: Message\n\t};\n\n\texport type updateDeleteDiscussionMessages = {\n\t\t_: 'updateDeleteDiscussionMessages',\n\t\tmessages?: number[],\n\t\tchannel_id?: number\n\t};\n\n\texport type updateChannelReload = {\n\t\t_: 'updateChannelReload',\n\t\tchannel_id?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/updates.State\n */\nexport type UpdatesState = UpdatesState.updatesState;\n\nexport namespace UpdatesState {\n  export type updatesState = {\n\t\t_: 'updates.state',\n\t\tpts: number,\n\t\tqts: number,\n\t\tdate: number,\n\t\tseq: number,\n\t\tunread_count: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/updates.Difference\n */\nexport type UpdatesDifference = UpdatesDifference.updatesDifferenceEmpty | UpdatesDifference.updatesDifference | UpdatesDifference.updatesDifferenceSlice | UpdatesDifference.updatesDifferenceTooLong;\n\nexport namespace UpdatesDifference {\n  export type updatesDifferenceEmpty = {\n\t\t_: 'updates.differenceEmpty',\n\t\tdate: number,\n\t\tseq: number\n\t};\n\n\texport type updatesDifference = {\n\t\t_: 'updates.difference',\n\t\tnew_messages: Array<Message>,\n\t\tnew_encrypted_messages: Array<EncryptedMessage>,\n\t\tother_updates: Array<Update>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>,\n\t\tstate: UpdatesState\n\t};\n\n\texport type updatesDifferenceSlice = {\n\t\t_: 'updates.differenceSlice',\n\t\tnew_messages: Array<Message>,\n\t\tnew_encrypted_messages: Array<EncryptedMessage>,\n\t\tother_updates: Array<Update>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>,\n\t\tintermediate_state: UpdatesState\n\t};\n\n\texport type updatesDifferenceTooLong = {\n\t\t_: 'updates.differenceTooLong',\n\t\tpts: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Updates\n */\nexport type Updates = Updates.updatesTooLong | Updates.updateShortMessage | Updates.updateShortChatMessage | Updates.updateShort | Updates.updatesCombined | Updates.updates | Updates.updateShortSentMessage;\n\nexport namespace Updates {\n  export type updatesTooLong = {\n\t\t_: 'updatesTooLong'\n\t};\n\n\texport type updateShortMessage = {\n\t\t_: 'updateShortMessage',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tout?: true,\n\t\t\tmentioned?: true,\n\t\t\tmedia_unread?: true,\n\t\t\tsilent?: true,\n\t\t}>,\n\t\tid: number,\n\t\tuser_id: number,\n\t\tmessage: string,\n\t\tpts: number,\n\t\tpts_count: number,\n\t\tdate: number,\n\t\tfwd_from?: MessageFwdHeader,\n\t\tvia_bot_id?: number,\n\t\treply_to?: MessageReplyHeader,\n\t\tentities?: Array<MessageEntity>,\n\t\tttl_period?: number\n\t};\n\n\texport type updateShortChatMessage = {\n\t\t_: 'updateShortChatMessage',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tout?: true,\n\t\t\tmentioned?: true,\n\t\t\tmedia_unread?: true,\n\t\t\tsilent?: true,\n\t\t}>,\n\t\tid: number,\n\t\tfrom_id: number,\n\t\tchat_id: number,\n\t\tmessage: string,\n\t\tpts: number,\n\t\tpts_count: number,\n\t\tdate: number,\n\t\tfwd_from?: MessageFwdHeader,\n\t\tvia_bot_id?: number,\n\t\treply_to?: MessageReplyHeader,\n\t\tentities?: Array<MessageEntity>,\n\t\tttl_period?: number\n\t};\n\n\texport type updateShort = {\n\t\t_: 'updateShort',\n\t\tupdate: Update,\n\t\tdate: number\n\t};\n\n\texport type updatesCombined = {\n\t\t_: 'updatesCombined',\n\t\tupdates: Array<Update>,\n\t\tusers: Array<User>,\n\t\tchats: Array<Chat>,\n\t\tdate: number,\n\t\tseq_start: number,\n\t\tseq: number\n\t};\n\n\texport type updates = {\n\t\t_: 'updates',\n\t\tupdates: Array<Update>,\n\t\tusers: Array<User>,\n\t\tchats: Array<Chat>,\n\t\tdate: number,\n\t\tseq: number\n\t};\n\n\texport type updateShortSentMessage = {\n\t\t_: 'updateShortSentMessage',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tout?: true,\n\t\t}>,\n\t\tid: number,\n\t\tpts: number,\n\t\tpts_count: number,\n\t\tdate: number,\n\t\tmedia?: MessageMedia,\n\t\tentities?: Array<MessageEntity>,\n\t\tttl_period?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/photos.Photos\n */\nexport type PhotosPhotos = PhotosPhotos.photosPhotos | PhotosPhotos.photosPhotosSlice;\n\nexport namespace PhotosPhotos {\n  export type photosPhotos = {\n\t\t_: 'photos.photos',\n\t\tphotos: Array<Photo>,\n\t\tusers: Array<User>\n\t};\n\n\texport type photosPhotosSlice = {\n\t\t_: 'photos.photosSlice',\n\t\tcount: number,\n\t\tphotos: Array<Photo>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/photos.Photo\n */\nexport type PhotosPhoto = PhotosPhoto.photosPhoto;\n\nexport namespace PhotosPhoto {\n  export type photosPhoto = {\n\t\t_: 'photos.photo',\n\t\tphoto: Photo,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/upload.File\n */\nexport type UploadFile = UploadFile.uploadFile | UploadFile.uploadFileCdnRedirect;\n\nexport namespace UploadFile {\n  export type uploadFile = {\n\t\t_: 'upload.file',\n\t\ttype: StorageFileType,\n\t\tmtime: number,\n\t\tbytes: Uint8Array\n\t};\n\n\texport type uploadFileCdnRedirect = {\n\t\t_: 'upload.fileCdnRedirect',\n\t\tdc_id: number,\n\t\tfile_token: Uint8Array,\n\t\tencryption_key: Uint8Array,\n\t\tencryption_iv: Uint8Array,\n\t\tfile_hashes: Array<FileHash>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/DcOption\n */\nexport type DcOption = DcOption.dcOption;\n\nexport namespace DcOption {\n  export type dcOption = {\n\t\t_: 'dcOption',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tipv6?: true,\n\t\t\tmedia_only?: true,\n\t\t\ttcpo_only?: true,\n\t\t\tcdn?: true,\n\t\t\tstatic?: true,\n\t\t}>,\n\t\tid: number,\n\t\tip_address: string,\n\t\tport: number,\n\t\tsecret?: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Config\n */\nexport type Config = Config.config;\n\nexport namespace Config {\n  export type config = {\n\t\t_: 'config',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tphonecalls_enabled?: true,\n\t\t\tdefault_p2p_contacts?: true,\n\t\t\tpreload_featured_stickers?: true,\n\t\t\tignore_phone_entities?: true,\n\t\t\trevoke_pm_inbox?: true,\n\t\t\tblocked_mode?: true,\n\t\t\tpfs_enabled?: true,\n\t\t}>,\n\t\tdate: number,\n\t\texpires: number,\n\t\ttest_mode: boolean,\n\t\tthis_dc: number,\n\t\tdc_options: Array<DcOption>,\n\t\tdc_txt_domain_name: string,\n\t\tchat_size_max: number,\n\t\tmegagroup_size_max: number,\n\t\tforwarded_count_max: number,\n\t\tonline_update_period_ms: number,\n\t\toffline_blur_timeout_ms: number,\n\t\toffline_idle_timeout_ms: number,\n\t\tonline_cloud_timeout_ms: number,\n\t\tnotify_cloud_delay_ms: number,\n\t\tnotify_default_delay_ms: number,\n\t\tpush_chat_period_ms: number,\n\t\tpush_chat_limit: number,\n\t\tsaved_gifs_limit: number,\n\t\tedit_time_limit: number,\n\t\trevoke_time_limit: number,\n\t\trevoke_pm_time_limit: number,\n\t\trating_e_decay: number,\n\t\tstickers_recent_limit: number,\n\t\tstickers_faved_limit: number,\n\t\tchannels_read_media_period: number,\n\t\ttmp_sessions?: number,\n\t\tpinned_dialogs_count_max: number,\n\t\tpinned_infolder_count_max: number,\n\t\tcall_receive_timeout_ms: number,\n\t\tcall_ring_timeout_ms: number,\n\t\tcall_connect_timeout_ms: number,\n\t\tcall_packet_timeout_ms: number,\n\t\tme_url_prefix: string,\n\t\tautoupdate_url_prefix?: string,\n\t\tgif_search_username?: string,\n\t\tvenue_search_username?: string,\n\t\timg_search_username?: string,\n\t\tstatic_maps_provider?: string,\n\t\tcaption_length_max: number,\n\t\tmessage_length_max: number,\n\t\twebfile_dc_id: number,\n\t\tsuggested_lang_code?: string,\n\t\tlang_pack_version?: number,\n\t\tbase_lang_pack_version?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/NearestDc\n */\nexport type NearestDc = NearestDc.nearestDc;\n\nexport namespace NearestDc {\n  export type nearestDc = {\n\t\t_: 'nearestDc',\n\t\tcountry: string,\n\t\tthis_dc: number,\n\t\tnearest_dc: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.AppUpdate\n */\nexport type HelpAppUpdate = HelpAppUpdate.helpAppUpdate | HelpAppUpdate.helpNoAppUpdate;\n\nexport namespace HelpAppUpdate {\n  export type helpAppUpdate = {\n\t\t_: 'help.appUpdate',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcan_not_skip?: true,\n\t\t}>,\n\t\tid: number,\n\t\tversion: string,\n\t\ttext: string,\n\t\tentities: Array<MessageEntity>,\n\t\tdocument?: Document,\n\t\turl?: string,\n\t\tsticker?: Document\n\t};\n\n\texport type helpNoAppUpdate = {\n\t\t_: 'help.noAppUpdate'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.InviteText\n */\nexport type HelpInviteText = HelpInviteText.helpInviteText;\n\nexport namespace HelpInviteText {\n  export type helpInviteText = {\n\t\t_: 'help.inviteText',\n\t\tmessage: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/EncryptedChat\n */\nexport type EncryptedChat = EncryptedChat.encryptedChatEmpty | EncryptedChat.encryptedChatWaiting | EncryptedChat.encryptedChatRequested | EncryptedChat.encryptedChat | EncryptedChat.encryptedChatDiscarded;\n\nexport namespace EncryptedChat {\n  export type encryptedChatEmpty = {\n\t\t_: 'encryptedChatEmpty',\n\t\tid: number\n\t};\n\n\texport type encryptedChatWaiting = {\n\t\t_: 'encryptedChatWaiting',\n\t\tid: number,\n\t\taccess_hash: string,\n\t\tdate: number,\n\t\tadmin_id: number,\n\t\tparticipant_id: number\n\t};\n\n\texport type encryptedChatRequested = {\n\t\t_: 'encryptedChatRequested',\n\t\tflags?: number,\n\t\tfolder_id?: number,\n\t\tid: number,\n\t\taccess_hash: string,\n\t\tdate: number,\n\t\tadmin_id: number,\n\t\tparticipant_id: number,\n\t\tg_a: Uint8Array\n\t};\n\n\texport type encryptedChat = {\n\t\t_: 'encryptedChat',\n\t\tid: number,\n\t\taccess_hash: string,\n\t\tdate: number,\n\t\tadmin_id: number,\n\t\tparticipant_id: number,\n\t\tg_a_or_b: Uint8Array,\n\t\tkey_fingerprint: string\n\t};\n\n\texport type encryptedChatDiscarded = {\n\t\t_: 'encryptedChatDiscarded',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\thistory_deleted?: true,\n\t\t}>,\n\t\tid: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputEncryptedChat\n */\nexport type InputEncryptedChat = InputEncryptedChat.inputEncryptedChat;\n\nexport namespace InputEncryptedChat {\n  export type inputEncryptedChat = {\n\t\t_: 'inputEncryptedChat',\n\t\tchat_id: number,\n\t\taccess_hash: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/EncryptedFile\n */\nexport type EncryptedFile = EncryptedFile.encryptedFileEmpty | EncryptedFile.encryptedFile;\n\nexport namespace EncryptedFile {\n  export type encryptedFileEmpty = {\n\t\t_: 'encryptedFileEmpty'\n\t};\n\n\texport type encryptedFile = {\n\t\t_: 'encryptedFile',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tsize: number,\n\t\tdc_id: number,\n\t\tkey_fingerprint: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputEncryptedFile\n */\nexport type InputEncryptedFile = InputEncryptedFile.inputEncryptedFileEmpty | InputEncryptedFile.inputEncryptedFileUploaded | InputEncryptedFile.inputEncryptedFile | InputEncryptedFile.inputEncryptedFileBigUploaded;\n\nexport namespace InputEncryptedFile {\n  export type inputEncryptedFileEmpty = {\n\t\t_: 'inputEncryptedFileEmpty'\n\t};\n\n\texport type inputEncryptedFileUploaded = {\n\t\t_: 'inputEncryptedFileUploaded',\n\t\tid: string,\n\t\tparts: number,\n\t\tmd5_checksum: string,\n\t\tkey_fingerprint: number\n\t};\n\n\texport type inputEncryptedFile = {\n\t\t_: 'inputEncryptedFile',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputEncryptedFileBigUploaded = {\n\t\t_: 'inputEncryptedFileBigUploaded',\n\t\tid: string,\n\t\tparts: number,\n\t\tkey_fingerprint: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/EncryptedMessage\n */\nexport type EncryptedMessage = EncryptedMessage.encryptedMessage | EncryptedMessage.encryptedMessageService;\n\nexport namespace EncryptedMessage {\n  export type encryptedMessage = {\n\t\t_: 'encryptedMessage',\n\t\trandom_id: string,\n\t\tchat_id: number,\n\t\tdate: number,\n\t\tbytes: Uint8Array,\n\t\tfile: EncryptedFile\n\t};\n\n\texport type encryptedMessageService = {\n\t\t_: 'encryptedMessageService',\n\t\trandom_id: string,\n\t\tchat_id: number,\n\t\tdate: number,\n\t\tbytes: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.DhConfig\n */\nexport type MessagesDhConfig = MessagesDhConfig.messagesDhConfigNotModified | MessagesDhConfig.messagesDhConfig;\n\nexport namespace MessagesDhConfig {\n  export type messagesDhConfigNotModified = {\n\t\t_: 'messages.dhConfigNotModified',\n\t\trandom: Uint8Array\n\t};\n\n\texport type messagesDhConfig = {\n\t\t_: 'messages.dhConfig',\n\t\tg: number,\n\t\tp: Uint8Array,\n\t\tversion: number,\n\t\trandom: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.SentEncryptedMessage\n */\nexport type MessagesSentEncryptedMessage = MessagesSentEncryptedMessage.messagesSentEncryptedMessage | MessagesSentEncryptedMessage.messagesSentEncryptedFile;\n\nexport namespace MessagesSentEncryptedMessage {\n  export type messagesSentEncryptedMessage = {\n\t\t_: 'messages.sentEncryptedMessage',\n\t\tdate: number\n\t};\n\n\texport type messagesSentEncryptedFile = {\n\t\t_: 'messages.sentEncryptedFile',\n\t\tdate: number,\n\t\tfile: EncryptedFile\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputDocument\n */\nexport type InputDocument = InputDocument.inputDocumentEmpty | InputDocument.inputDocument;\n\nexport namespace InputDocument {\n  export type inputDocumentEmpty = {\n\t\t_: 'inputDocumentEmpty'\n\t};\n\n\texport type inputDocument = {\n\t\t_: 'inputDocument',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tfile_reference: Uint8Array | number[]\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Document\n */\nexport type Document = Document.documentEmpty | Document.document;\n\nexport namespace Document {\n  export type documentEmpty = {\n\t\t_: 'documentEmpty',\n\t\tid: string\n\t};\n\n\texport type document = {\n\t\t_: 'document',\n\t\tflags?: number,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tfile_reference: Uint8Array | number[],\n\t\tdate: number,\n\t\tmime_type: string,\n\t\tsize: number,\n\t\tthumbs?: Array<PhotoSize.photoSize | PhotoSize.photoCachedSize | PhotoSize.photoStrippedSize | PhotoSize.photoPathSize>,\n\t\tvideo_thumbs?: Array<VideoSize>,\n\t\tdc_id: number,\n\t\tattributes: Array<DocumentAttribute>,\n\t\ttype?: 'gif' | 'sticker' | 'audio' | 'voice' | 'video' | 'round' | 'photo' | 'pdf',\n\t\th?: number,\n\t\tw?: number,\n\t\tfile_name?: string,\n\t\tfile?: File,\n\t\tduration?: number,\n\t\taudioTitle?: string,\n\t\taudioPerformer?: string,\n\t\tsticker?: number,\n\t\tstickerEmoji?: string,\n\t\tstickerEmojiRaw?: string,\n\t\tstickerSetInput?: InputStickerSet.inputStickerSetID,\n\t\tpFlags?: Partial<{\n\t\t\tstickerThumbConverted?: true,\n\t\t}>,\n\t\tstickerCachedThumbs?: {[toneIndex: number]: {url: string, w: number, h: number}},\n\t\tanimated?: boolean,\n\t\tsupportsStreaming?: boolean\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.Support\n */\nexport type HelpSupport = HelpSupport.helpSupport;\n\nexport namespace HelpSupport {\n  export type helpSupport = {\n\t\t_: 'help.support',\n\t\tphone_number: string,\n\t\tuser: User\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/NotifyPeer\n */\nexport type NotifyPeer = NotifyPeer.notifyPeer | NotifyPeer.notifyUsers | NotifyPeer.notifyChats | NotifyPeer.notifyBroadcasts;\n\nexport namespace NotifyPeer {\n  export type notifyPeer = {\n\t\t_: 'notifyPeer',\n\t\tpeer: Peer\n\t};\n\n\texport type notifyUsers = {\n\t\t_: 'notifyUsers'\n\t};\n\n\texport type notifyChats = {\n\t\t_: 'notifyChats'\n\t};\n\n\texport type notifyBroadcasts = {\n\t\t_: 'notifyBroadcasts'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SendMessageAction\n */\nexport type SendMessageAction = SendMessageAction.sendMessageTypingAction | SendMessageAction.sendMessageCancelAction | SendMessageAction.sendMessageRecordVideoAction | SendMessageAction.sendMessageUploadVideoAction | SendMessageAction.sendMessageRecordAudioAction | SendMessageAction.sendMessageUploadAudioAction | SendMessageAction.sendMessageUploadPhotoAction | SendMessageAction.sendMessageUploadDocumentAction | SendMessageAction.sendMessageGeoLocationAction | SendMessageAction.sendMessageChooseContactAction | SendMessageAction.sendMessageGamePlayAction | SendMessageAction.sendMessageRecordRoundAction | SendMessageAction.sendMessageUploadRoundAction | SendMessageAction.speakingInGroupCallAction | SendMessageAction.sendMessageHistoryImportAction;\n\nexport namespace SendMessageAction {\n  export type sendMessageTypingAction = {\n\t\t_: 'sendMessageTypingAction'\n\t};\n\n\texport type sendMessageCancelAction = {\n\t\t_: 'sendMessageCancelAction'\n\t};\n\n\texport type sendMessageRecordVideoAction = {\n\t\t_: 'sendMessageRecordVideoAction'\n\t};\n\n\texport type sendMessageUploadVideoAction = {\n\t\t_: 'sendMessageUploadVideoAction',\n\t\tprogress: number\n\t};\n\n\texport type sendMessageRecordAudioAction = {\n\t\t_: 'sendMessageRecordAudioAction'\n\t};\n\n\texport type sendMessageUploadAudioAction = {\n\t\t_: 'sendMessageUploadAudioAction',\n\t\tprogress: number\n\t};\n\n\texport type sendMessageUploadPhotoAction = {\n\t\t_: 'sendMessageUploadPhotoAction',\n\t\tprogress: number\n\t};\n\n\texport type sendMessageUploadDocumentAction = {\n\t\t_: 'sendMessageUploadDocumentAction',\n\t\tprogress: number\n\t};\n\n\texport type sendMessageGeoLocationAction = {\n\t\t_: 'sendMessageGeoLocationAction'\n\t};\n\n\texport type sendMessageChooseContactAction = {\n\t\t_: 'sendMessageChooseContactAction'\n\t};\n\n\texport type sendMessageGamePlayAction = {\n\t\t_: 'sendMessageGamePlayAction'\n\t};\n\n\texport type sendMessageRecordRoundAction = {\n\t\t_: 'sendMessageRecordRoundAction'\n\t};\n\n\texport type sendMessageUploadRoundAction = {\n\t\t_: 'sendMessageUploadRoundAction',\n\t\tprogress: number\n\t};\n\n\texport type speakingInGroupCallAction = {\n\t\t_: 'speakingInGroupCallAction'\n\t};\n\n\texport type sendMessageHistoryImportAction = {\n\t\t_: 'sendMessageHistoryImportAction',\n\t\tprogress: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/contacts.Found\n */\nexport type ContactsFound = ContactsFound.contactsFound;\n\nexport namespace ContactsFound {\n  export type contactsFound = {\n\t\t_: 'contacts.found',\n\t\tmy_results: Array<Peer>,\n\t\tresults: Array<Peer>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputPrivacyKey\n */\nexport type InputPrivacyKey = InputPrivacyKey.inputPrivacyKeyStatusTimestamp | InputPrivacyKey.inputPrivacyKeyChatInvite | InputPrivacyKey.inputPrivacyKeyPhoneCall | InputPrivacyKey.inputPrivacyKeyPhoneP2P | InputPrivacyKey.inputPrivacyKeyForwards | InputPrivacyKey.inputPrivacyKeyProfilePhoto | InputPrivacyKey.inputPrivacyKeyPhoneNumber | InputPrivacyKey.inputPrivacyKeyAddedByPhone;\n\nexport namespace InputPrivacyKey {\n  export type inputPrivacyKeyStatusTimestamp = {\n\t\t_: 'inputPrivacyKeyStatusTimestamp'\n\t};\n\n\texport type inputPrivacyKeyChatInvite = {\n\t\t_: 'inputPrivacyKeyChatInvite'\n\t};\n\n\texport type inputPrivacyKeyPhoneCall = {\n\t\t_: 'inputPrivacyKeyPhoneCall'\n\t};\n\n\texport type inputPrivacyKeyPhoneP2P = {\n\t\t_: 'inputPrivacyKeyPhoneP2P'\n\t};\n\n\texport type inputPrivacyKeyForwards = {\n\t\t_: 'inputPrivacyKeyForwards'\n\t};\n\n\texport type inputPrivacyKeyProfilePhoto = {\n\t\t_: 'inputPrivacyKeyProfilePhoto'\n\t};\n\n\texport type inputPrivacyKeyPhoneNumber = {\n\t\t_: 'inputPrivacyKeyPhoneNumber'\n\t};\n\n\texport type inputPrivacyKeyAddedByPhone = {\n\t\t_: 'inputPrivacyKeyAddedByPhone'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PrivacyKey\n */\nexport type PrivacyKey = PrivacyKey.privacyKeyStatusTimestamp | PrivacyKey.privacyKeyChatInvite | PrivacyKey.privacyKeyPhoneCall | PrivacyKey.privacyKeyPhoneP2P | PrivacyKey.privacyKeyForwards | PrivacyKey.privacyKeyProfilePhoto | PrivacyKey.privacyKeyPhoneNumber | PrivacyKey.privacyKeyAddedByPhone;\n\nexport namespace PrivacyKey {\n  export type privacyKeyStatusTimestamp = {\n\t\t_: 'privacyKeyStatusTimestamp'\n\t};\n\n\texport type privacyKeyChatInvite = {\n\t\t_: 'privacyKeyChatInvite'\n\t};\n\n\texport type privacyKeyPhoneCall = {\n\t\t_: 'privacyKeyPhoneCall'\n\t};\n\n\texport type privacyKeyPhoneP2P = {\n\t\t_: 'privacyKeyPhoneP2P'\n\t};\n\n\texport type privacyKeyForwards = {\n\t\t_: 'privacyKeyForwards'\n\t};\n\n\texport type privacyKeyProfilePhoto = {\n\t\t_: 'privacyKeyProfilePhoto'\n\t};\n\n\texport type privacyKeyPhoneNumber = {\n\t\t_: 'privacyKeyPhoneNumber'\n\t};\n\n\texport type privacyKeyAddedByPhone = {\n\t\t_: 'privacyKeyAddedByPhone'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputPrivacyRule\n */\nexport type InputPrivacyRule = InputPrivacyRule.inputPrivacyValueAllowContacts | InputPrivacyRule.inputPrivacyValueAllowAll | InputPrivacyRule.inputPrivacyValueAllowUsers | InputPrivacyRule.inputPrivacyValueDisallowContacts | InputPrivacyRule.inputPrivacyValueDisallowAll | InputPrivacyRule.inputPrivacyValueDisallowUsers | InputPrivacyRule.inputPrivacyValueAllowChatParticipants | InputPrivacyRule.inputPrivacyValueDisallowChatParticipants;\n\nexport namespace InputPrivacyRule {\n  export type inputPrivacyValueAllowContacts = {\n\t\t_: 'inputPrivacyValueAllowContacts'\n\t};\n\n\texport type inputPrivacyValueAllowAll = {\n\t\t_: 'inputPrivacyValueAllowAll'\n\t};\n\n\texport type inputPrivacyValueAllowUsers = {\n\t\t_: 'inputPrivacyValueAllowUsers',\n\t\tusers: Array<InputUser>\n\t};\n\n\texport type inputPrivacyValueDisallowContacts = {\n\t\t_: 'inputPrivacyValueDisallowContacts'\n\t};\n\n\texport type inputPrivacyValueDisallowAll = {\n\t\t_: 'inputPrivacyValueDisallowAll'\n\t};\n\n\texport type inputPrivacyValueDisallowUsers = {\n\t\t_: 'inputPrivacyValueDisallowUsers',\n\t\tusers: Array<InputUser>\n\t};\n\n\texport type inputPrivacyValueAllowChatParticipants = {\n\t\t_: 'inputPrivacyValueAllowChatParticipants',\n\t\tchats: Array<number>\n\t};\n\n\texport type inputPrivacyValueDisallowChatParticipants = {\n\t\t_: 'inputPrivacyValueDisallowChatParticipants',\n\t\tchats: Array<number>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PrivacyRule\n */\nexport type PrivacyRule = PrivacyRule.privacyValueAllowContacts | PrivacyRule.privacyValueAllowAll | PrivacyRule.privacyValueAllowUsers | PrivacyRule.privacyValueDisallowContacts | PrivacyRule.privacyValueDisallowAll | PrivacyRule.privacyValueDisallowUsers | PrivacyRule.privacyValueAllowChatParticipants | PrivacyRule.privacyValueDisallowChatParticipants;\n\nexport namespace PrivacyRule {\n  export type privacyValueAllowContacts = {\n\t\t_: 'privacyValueAllowContacts'\n\t};\n\n\texport type privacyValueAllowAll = {\n\t\t_: 'privacyValueAllowAll'\n\t};\n\n\texport type privacyValueAllowUsers = {\n\t\t_: 'privacyValueAllowUsers',\n\t\tusers: Array<number>\n\t};\n\n\texport type privacyValueDisallowContacts = {\n\t\t_: 'privacyValueDisallowContacts'\n\t};\n\n\texport type privacyValueDisallowAll = {\n\t\t_: 'privacyValueDisallowAll'\n\t};\n\n\texport type privacyValueDisallowUsers = {\n\t\t_: 'privacyValueDisallowUsers',\n\t\tusers: Array<number>\n\t};\n\n\texport type privacyValueAllowChatParticipants = {\n\t\t_: 'privacyValueAllowChatParticipants',\n\t\tchats: Array<number>\n\t};\n\n\texport type privacyValueDisallowChatParticipants = {\n\t\t_: 'privacyValueDisallowChatParticipants',\n\t\tchats: Array<number>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.PrivacyRules\n */\nexport type AccountPrivacyRules = AccountPrivacyRules.accountPrivacyRules;\n\nexport namespace AccountPrivacyRules {\n  export type accountPrivacyRules = {\n\t\t_: 'account.privacyRules',\n\t\trules: Array<PrivacyRule>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/AccountDaysTTL\n */\nexport type AccountDaysTTL = AccountDaysTTL.accountDaysTTL;\n\nexport namespace AccountDaysTTL {\n  export type accountDaysTTL = {\n\t\t_: 'accountDaysTTL',\n\t\tdays: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/DocumentAttribute\n */\nexport type DocumentAttribute = DocumentAttribute.documentAttributeImageSize | DocumentAttribute.documentAttributeAnimated | DocumentAttribute.documentAttributeSticker | DocumentAttribute.documentAttributeVideo | DocumentAttribute.documentAttributeAudio | DocumentAttribute.documentAttributeFilename | DocumentAttribute.documentAttributeHasStickers;\n\nexport namespace DocumentAttribute {\n  export type documentAttributeImageSize = {\n\t\t_: 'documentAttributeImageSize',\n\t\tw: number,\n\t\th: number\n\t};\n\n\texport type documentAttributeAnimated = {\n\t\t_: 'documentAttributeAnimated'\n\t};\n\n\texport type documentAttributeSticker = {\n\t\t_: 'documentAttributeSticker',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tmask?: true,\n\t\t}>,\n\t\talt: string,\n\t\tstickerset: InputStickerSet,\n\t\tmask_coords?: MaskCoords\n\t};\n\n\texport type documentAttributeVideo = {\n\t\t_: 'documentAttributeVideo',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tround_message?: true,\n\t\t\tsupports_streaming?: true,\n\t\t}>,\n\t\tduration: number,\n\t\tw: number,\n\t\th: number\n\t};\n\n\texport type documentAttributeAudio = {\n\t\t_: 'documentAttributeAudio',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tvoice?: true,\n\t\t}>,\n\t\tduration: number,\n\t\ttitle?: string,\n\t\tperformer?: string,\n\t\twaveform?: Uint8Array\n\t};\n\n\texport type documentAttributeFilename = {\n\t\t_: 'documentAttributeFilename',\n\t\tfile_name: string\n\t};\n\n\texport type documentAttributeHasStickers = {\n\t\t_: 'documentAttributeHasStickers'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.Stickers\n */\nexport type MessagesStickers = MessagesStickers.messagesStickersNotModified | MessagesStickers.messagesStickers;\n\nexport namespace MessagesStickers {\n  export type messagesStickersNotModified = {\n\t\t_: 'messages.stickersNotModified'\n\t};\n\n\texport type messagesStickers = {\n\t\t_: 'messages.stickers',\n\t\thash: number,\n\t\tstickers: Array<Document>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StickerPack\n */\nexport type StickerPack = StickerPack.stickerPack;\n\nexport namespace StickerPack {\n  export type stickerPack = {\n\t\t_: 'stickerPack',\n\t\temoticon: string,\n\t\tdocuments: Array<string>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.AllStickers\n */\nexport type MessagesAllStickers = MessagesAllStickers.messagesAllStickersNotModified | MessagesAllStickers.messagesAllStickers;\n\nexport namespace MessagesAllStickers {\n  export type messagesAllStickersNotModified = {\n\t\t_: 'messages.allStickersNotModified'\n\t};\n\n\texport type messagesAllStickers = {\n\t\t_: 'messages.allStickers',\n\t\thash: number,\n\t\tsets: Array<StickerSet>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.AffectedMessages\n */\nexport type MessagesAffectedMessages = MessagesAffectedMessages.messagesAffectedMessages;\n\nexport namespace MessagesAffectedMessages {\n  export type messagesAffectedMessages = {\n\t\t_: 'messages.affectedMessages',\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/WebPage\n */\nexport type WebPage = WebPage.webPageEmpty | WebPage.webPagePending | WebPage.webPage | WebPage.webPageNotModified;\n\nexport namespace WebPage {\n  export type webPageEmpty = {\n\t\t_: 'webPageEmpty',\n\t\tid: string\n\t};\n\n\texport type webPagePending = {\n\t\t_: 'webPagePending',\n\t\tid: string,\n\t\tdate: number\n\t};\n\n\texport type webPage = {\n\t\t_: 'webPage',\n\t\tflags?: number,\n\t\tid: string,\n\t\turl: string,\n\t\tdisplay_url: string,\n\t\thash: number,\n\t\ttype?: string,\n\t\tsite_name?: string,\n\t\ttitle?: string,\n\t\tdescription?: string,\n\t\tphoto?: Photo,\n\t\tembed_url?: string,\n\t\tembed_type?: string,\n\t\tembed_width?: number,\n\t\tembed_height?: number,\n\t\tduration?: number,\n\t\tauthor?: string,\n\t\tdocument?: Document,\n\t\tcached_page?: Page,\n\t\tattributes?: Array<WebPageAttribute>\n\t};\n\n\texport type webPageNotModified = {\n\t\t_: 'webPageNotModified',\n\t\tflags?: number,\n\t\tcached_page_views?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Authorization\n */\nexport type Authorization = Authorization.authorization;\n\nexport namespace Authorization {\n  export type authorization = {\n\t\t_: 'authorization',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcurrent?: true,\n\t\t\tofficial_app?: true,\n\t\t\tpassword_pending?: true,\n\t\t}>,\n\t\thash: string,\n\t\tdevice_model: string,\n\t\tplatform: string,\n\t\tsystem_version: string,\n\t\tapi_id: number,\n\t\tapp_name: string,\n\t\tapp_version: string,\n\t\tdate_created: number,\n\t\tdate_active: number,\n\t\tip: string,\n\t\tcountry: string,\n\t\tregion: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.Authorizations\n */\nexport type AccountAuthorizations = AccountAuthorizations.accountAuthorizations;\n\nexport namespace AccountAuthorizations {\n  export type accountAuthorizations = {\n\t\t_: 'account.authorizations',\n\t\tauthorizations: Array<Authorization>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.Password\n */\nexport type AccountPassword = AccountPassword.accountPassword;\n\nexport namespace AccountPassword {\n  export type accountPassword = {\n\t\t_: 'account.password',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\thas_recovery?: true,\n\t\t\thas_secure_values?: true,\n\t\t\thas_password?: true,\n\t\t}>,\n\t\tcurrent_algo?: PasswordKdfAlgo,\n\t\tsrp_B?: Uint8Array,\n\t\tsrp_id?: string,\n\t\thint?: string,\n\t\temail_unconfirmed_pattern?: string,\n\t\tnew_algo: PasswordKdfAlgo,\n\t\tnew_secure_algo: SecurePasswordKdfAlgo,\n\t\tsecure_random: Uint8Array,\n\t\tpending_reset_date?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.PasswordSettings\n */\nexport type AccountPasswordSettings = AccountPasswordSettings.accountPasswordSettings;\n\nexport namespace AccountPasswordSettings {\n  export type accountPasswordSettings = {\n\t\t_: 'account.passwordSettings',\n\t\tflags?: number,\n\t\temail?: string,\n\t\tsecure_settings?: SecureSecretSettings\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.PasswordInputSettings\n */\nexport type AccountPasswordInputSettings = AccountPasswordInputSettings.accountPasswordInputSettings;\n\nexport namespace AccountPasswordInputSettings {\n  export type accountPasswordInputSettings = {\n\t\t_: 'account.passwordInputSettings',\n\t\tflags?: number,\n\t\tnew_algo?: PasswordKdfAlgo,\n\t\tnew_password_hash?: Uint8Array,\n\t\thint?: string,\n\t\temail?: string,\n\t\tnew_secure_settings?: SecureSecretSettings\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/auth.PasswordRecovery\n */\nexport type AuthPasswordRecovery = AuthPasswordRecovery.authPasswordRecovery;\n\nexport namespace AuthPasswordRecovery {\n  export type authPasswordRecovery = {\n\t\t_: 'auth.passwordRecovery',\n\t\temail_pattern: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ReceivedNotifyMessage\n */\nexport type ReceivedNotifyMessage = ReceivedNotifyMessage.receivedNotifyMessage;\n\nexport namespace ReceivedNotifyMessage {\n  export type receivedNotifyMessage = {\n\t\t_: 'receivedNotifyMessage',\n\t\tid: number,\n\t\tflags?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ExportedChatInvite\n */\nexport type ExportedChatInvite = ExportedChatInvite.chatInviteExported;\n\nexport namespace ExportedChatInvite {\n  export type chatInviteExported = {\n\t\t_: 'chatInviteExported',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\trevoked?: true,\n\t\t\tpermanent?: true,\n\t\t}>,\n\t\tlink: string,\n\t\tadmin_id: number,\n\t\tdate: number,\n\t\tstart_date?: number,\n\t\texpire_date?: number,\n\t\tusage_limit?: number,\n\t\tusage?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatInvite\n */\nexport type ChatInvite = ChatInvite.chatInviteAlready | ChatInvite.chatInvite | ChatInvite.chatInvitePeek;\n\nexport namespace ChatInvite {\n  export type chatInviteAlready = {\n\t\t_: 'chatInviteAlready',\n\t\tchat: Chat\n\t};\n\n\texport type chatInvite = {\n\t\t_: 'chatInvite',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tchannel?: true,\n\t\t\tbroadcast?: true,\n\t\t\tpublic?: true,\n\t\t\tmegagroup?: true,\n\t\t}>,\n\t\ttitle: string,\n\t\tphoto: Photo,\n\t\tparticipants_count: number,\n\t\tparticipants?: Array<User>\n\t};\n\n\texport type chatInvitePeek = {\n\t\t_: 'chatInvitePeek',\n\t\tchat: Chat,\n\t\texpires: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputStickerSet\n */\nexport type InputStickerSet = InputStickerSet.inputStickerSetEmpty | InputStickerSet.inputStickerSetID | InputStickerSet.inputStickerSetShortName | InputStickerSet.inputStickerSetAnimatedEmoji | InputStickerSet.inputStickerSetDice;\n\nexport namespace InputStickerSet {\n  export type inputStickerSetEmpty = {\n\t\t_: 'inputStickerSetEmpty'\n\t};\n\n\texport type inputStickerSetID = {\n\t\t_: 'inputStickerSetID',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputStickerSetShortName = {\n\t\t_: 'inputStickerSetShortName',\n\t\tshort_name: string\n\t};\n\n\texport type inputStickerSetAnimatedEmoji = {\n\t\t_: 'inputStickerSetAnimatedEmoji'\n\t};\n\n\texport type inputStickerSetDice = {\n\t\t_: 'inputStickerSetDice',\n\t\temoticon: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StickerSet\n */\nexport type StickerSet = StickerSet.stickerSet;\n\nexport namespace StickerSet {\n  export type stickerSet = {\n\t\t_: 'stickerSet',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tarchived?: true,\n\t\t\tofficial?: true,\n\t\t\tmasks?: true,\n\t\t\tanimated?: true,\n\t\t}>,\n\t\tinstalled_date?: number,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\ttitle: string,\n\t\tshort_name: string,\n\t\tthumbs?: Array<PhotoSize>,\n\t\tthumb_dc_id?: number,\n\t\tthumb_version?: number,\n\t\tcount: number,\n\t\thash: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.StickerSet\n */\nexport type MessagesStickerSet = MessagesStickerSet.messagesStickerSet;\n\nexport namespace MessagesStickerSet {\n  export type messagesStickerSet = {\n\t\t_: 'messages.stickerSet',\n\t\tset: StickerSet,\n\t\tpacks: Array<StickerPack>,\n\t\tdocuments: Array<Document>,\n\t\trefreshTime?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/BotCommand\n */\nexport type BotCommand = BotCommand.botCommand;\n\nexport namespace BotCommand {\n  export type botCommand = {\n\t\t_: 'botCommand',\n\t\tcommand: string,\n\t\tdescription: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/BotInfo\n */\nexport type BotInfo = BotInfo.botInfo;\n\nexport namespace BotInfo {\n  export type botInfo = {\n\t\t_: 'botInfo',\n\t\tuser_id: number,\n\t\tdescription: string,\n\t\tcommands: Array<BotCommand>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/KeyboardButton\n */\nexport type KeyboardButton = KeyboardButton.keyboardButton | KeyboardButton.keyboardButtonUrl | KeyboardButton.keyboardButtonCallback | KeyboardButton.keyboardButtonRequestPhone | KeyboardButton.keyboardButtonRequestGeoLocation | KeyboardButton.keyboardButtonSwitchInline | KeyboardButton.keyboardButtonGame | KeyboardButton.keyboardButtonBuy | KeyboardButton.keyboardButtonUrlAuth | KeyboardButton.inputKeyboardButtonUrlAuth | KeyboardButton.keyboardButtonRequestPoll;\n\nexport namespace KeyboardButton {\n  export type keyboardButton = {\n\t\t_: 'keyboardButton',\n\t\ttext: string\n\t};\n\n\texport type keyboardButtonUrl = {\n\t\t_: 'keyboardButtonUrl',\n\t\ttext: string,\n\t\turl: string\n\t};\n\n\texport type keyboardButtonCallback = {\n\t\t_: 'keyboardButtonCallback',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\trequires_password?: true,\n\t\t}>,\n\t\ttext: string,\n\t\tdata: Uint8Array\n\t};\n\n\texport type keyboardButtonRequestPhone = {\n\t\t_: 'keyboardButtonRequestPhone',\n\t\ttext: string\n\t};\n\n\texport type keyboardButtonRequestGeoLocation = {\n\t\t_: 'keyboardButtonRequestGeoLocation',\n\t\ttext: string\n\t};\n\n\texport type keyboardButtonSwitchInline = {\n\t\t_: 'keyboardButtonSwitchInline',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tsame_peer?: true,\n\t\t}>,\n\t\ttext: string,\n\t\tquery: string\n\t};\n\n\texport type keyboardButtonGame = {\n\t\t_: 'keyboardButtonGame',\n\t\ttext: string\n\t};\n\n\texport type keyboardButtonBuy = {\n\t\t_: 'keyboardButtonBuy',\n\t\ttext: string\n\t};\n\n\texport type keyboardButtonUrlAuth = {\n\t\t_: 'keyboardButtonUrlAuth',\n\t\tflags?: number,\n\t\ttext: string,\n\t\tfwd_text?: string,\n\t\turl: string,\n\t\tbutton_id: number\n\t};\n\n\texport type inputKeyboardButtonUrlAuth = {\n\t\t_: 'inputKeyboardButtonUrlAuth',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\trequest_write_access?: true,\n\t\t}>,\n\t\ttext: string,\n\t\tfwd_text?: string,\n\t\turl: string,\n\t\tbot: InputUser\n\t};\n\n\texport type keyboardButtonRequestPoll = {\n\t\t_: 'keyboardButtonRequestPoll',\n\t\tflags?: number,\n\t\tquiz?: boolean,\n\t\ttext: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/KeyboardButtonRow\n */\nexport type KeyboardButtonRow = KeyboardButtonRow.keyboardButtonRow;\n\nexport namespace KeyboardButtonRow {\n  export type keyboardButtonRow = {\n\t\t_: 'keyboardButtonRow',\n\t\tbuttons: Array<KeyboardButton>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ReplyMarkup\n */\nexport type ReplyMarkup = ReplyMarkup.replyKeyboardHide | ReplyMarkup.replyKeyboardForceReply | ReplyMarkup.replyKeyboardMarkup | ReplyMarkup.replyInlineMarkup;\n\nexport namespace ReplyMarkup {\n  export type replyKeyboardHide = {\n\t\t_: 'replyKeyboardHide',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tselective?: true,\n\t\t}>,\n\t\tmid?: number\n\t};\n\n\texport type replyKeyboardForceReply = {\n\t\t_: 'replyKeyboardForceReply',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tsingle_use?: true,\n\t\t\tselective?: true,\n\t\t\thidden?: true,\n\t\t}>,\n\t\tplaceholder?: string,\n\t\tmid?: number,\n\t\tfromId?: number\n\t};\n\n\texport type replyKeyboardMarkup = {\n\t\t_: 'replyKeyboardMarkup',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tresize?: true,\n\t\t\tsingle_use?: true,\n\t\t\tselective?: true,\n\t\t\thidden?: true,\n\t\t}>,\n\t\trows: Array<KeyboardButtonRow>,\n\t\tplaceholder?: string,\n\t\tmid?: number,\n\t\tfromId?: number\n\t};\n\n\texport type replyInlineMarkup = {\n\t\t_: 'replyInlineMarkup',\n\t\trows: Array<KeyboardButtonRow>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageEntity\n */\nexport type MessageEntity = MessageEntity.messageEntityUnknown | MessageEntity.messageEntityMention | MessageEntity.messageEntityHashtag | MessageEntity.messageEntityBotCommand | MessageEntity.messageEntityUrl | MessageEntity.messageEntityEmail | MessageEntity.messageEntityBold | MessageEntity.messageEntityItalic | MessageEntity.messageEntityCode | MessageEntity.messageEntityPre | MessageEntity.messageEntityTextUrl | MessageEntity.messageEntityMentionName | MessageEntity.inputMessageEntityMentionName | MessageEntity.messageEntityPhone | MessageEntity.messageEntityCashtag | MessageEntity.messageEntityUnderline | MessageEntity.messageEntityStrike | MessageEntity.messageEntityBlockquote | MessageEntity.messageEntityBankCard | MessageEntity.messageEntityEmoji | MessageEntity.messageEntityHighlight | MessageEntity.messageEntityLinebreak | MessageEntity.messageEntityCaret;\n\nexport namespace MessageEntity {\n  export type messageEntityUnknown = {\n\t\t_: 'messageEntityUnknown',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityMention = {\n\t\t_: 'messageEntityMention',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityHashtag = {\n\t\t_: 'messageEntityHashtag',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityBotCommand = {\n\t\t_: 'messageEntityBotCommand',\n\t\toffset: number,\n\t\tlength: number,\n\t\tunsafe?: boolean\n\t};\n\n\texport type messageEntityUrl = {\n\t\t_: 'messageEntityUrl',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityEmail = {\n\t\t_: 'messageEntityEmail',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityBold = {\n\t\t_: 'messageEntityBold',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityItalic = {\n\t\t_: 'messageEntityItalic',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityCode = {\n\t\t_: 'messageEntityCode',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityPre = {\n\t\t_: 'messageEntityPre',\n\t\toffset: number,\n\t\tlength: number,\n\t\tlanguage: string\n\t};\n\n\texport type messageEntityTextUrl = {\n\t\t_: 'messageEntityTextUrl',\n\t\toffset: number,\n\t\tlength: number,\n\t\turl: string\n\t};\n\n\texport type messageEntityMentionName = {\n\t\t_: 'messageEntityMentionName',\n\t\toffset: number,\n\t\tlength: number,\n\t\tuser_id: number\n\t};\n\n\texport type inputMessageEntityMentionName = {\n\t\t_: 'inputMessageEntityMentionName',\n\t\toffset: number,\n\t\tlength: number,\n\t\tuser_id: InputUser\n\t};\n\n\texport type messageEntityPhone = {\n\t\t_: 'messageEntityPhone',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityCashtag = {\n\t\t_: 'messageEntityCashtag',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityUnderline = {\n\t\t_: 'messageEntityUnderline',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityStrike = {\n\t\t_: 'messageEntityStrike',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityBlockquote = {\n\t\t_: 'messageEntityBlockquote',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityBankCard = {\n\t\t_: 'messageEntityBankCard',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityEmoji = {\n\t\t_: 'messageEntityEmoji',\n\t\toffset?: number,\n\t\tlength?: number,\n\t\tunicode?: string\n\t};\n\n\texport type messageEntityHighlight = {\n\t\t_: 'messageEntityHighlight',\n\t\toffset?: number,\n\t\tlength?: number\n\t};\n\n\texport type messageEntityLinebreak = {\n\t\t_: 'messageEntityLinebreak',\n\t\toffset?: number,\n\t\tlength?: number\n\t};\n\n\texport type messageEntityCaret = {\n\t\t_: 'messageEntityCaret',\n\t\toffset?: number,\n\t\tlength?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputChannel\n */\nexport type InputChannel = InputChannel.inputChannelEmpty | InputChannel.inputChannel | InputChannel.inputChannelFromMessage;\n\nexport namespace InputChannel {\n  export type inputChannelEmpty = {\n\t\t_: 'inputChannelEmpty'\n\t};\n\n\texport type inputChannel = {\n\t\t_: 'inputChannel',\n\t\tchannel_id: number,\n\t\taccess_hash: string\n\t};\n\n\texport type inputChannelFromMessage = {\n\t\t_: 'inputChannelFromMessage',\n\t\tpeer: InputPeer,\n\t\tmsg_id: number,\n\t\tchannel_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/contacts.ResolvedPeer\n */\nexport type ContactsResolvedPeer = ContactsResolvedPeer.contactsResolvedPeer;\n\nexport namespace ContactsResolvedPeer {\n  export type contactsResolvedPeer = {\n\t\t_: 'contacts.resolvedPeer',\n\t\tpeer: Peer,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageRange\n */\nexport type MessageRange = MessageRange.messageRange;\n\nexport namespace MessageRange {\n  export type messageRange = {\n\t\t_: 'messageRange',\n\t\tmin_id: number,\n\t\tmax_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/updates.ChannelDifference\n */\nexport type UpdatesChannelDifference = UpdatesChannelDifference.updatesChannelDifferenceEmpty | UpdatesChannelDifference.updatesChannelDifferenceTooLong | UpdatesChannelDifference.updatesChannelDifference;\n\nexport namespace UpdatesChannelDifference {\n  export type updatesChannelDifferenceEmpty = {\n\t\t_: 'updates.channelDifferenceEmpty',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tfinal?: true,\n\t\t}>,\n\t\tpts: number,\n\t\ttimeout?: number\n\t};\n\n\texport type updatesChannelDifferenceTooLong = {\n\t\t_: 'updates.channelDifferenceTooLong',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tfinal?: true,\n\t\t}>,\n\t\ttimeout?: number,\n\t\tdialog: Dialog,\n\t\tmessages: Array<Message>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type updatesChannelDifference = {\n\t\t_: 'updates.channelDifference',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tfinal?: true,\n\t\t}>,\n\t\tpts: number,\n\t\ttimeout?: number,\n\t\tnew_messages: Array<Message>,\n\t\tother_updates: Array<Update>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChannelMessagesFilter\n */\nexport type ChannelMessagesFilter = ChannelMessagesFilter.channelMessagesFilterEmpty | ChannelMessagesFilter.channelMessagesFilter;\n\nexport namespace ChannelMessagesFilter {\n  export type channelMessagesFilterEmpty = {\n\t\t_: 'channelMessagesFilterEmpty'\n\t};\n\n\texport type channelMessagesFilter = {\n\t\t_: 'channelMessagesFilter',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\texclude_new_messages?: true,\n\t\t}>,\n\t\tranges: Array<MessageRange>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChannelParticipant\n */\nexport type ChannelParticipant = ChannelParticipant.channelParticipant | ChannelParticipant.channelParticipantSelf | ChannelParticipant.channelParticipantCreator | ChannelParticipant.channelParticipantAdmin | ChannelParticipant.channelParticipantBanned | ChannelParticipant.channelParticipantLeft;\n\nexport namespace ChannelParticipant {\n  export type channelParticipant = {\n\t\t_: 'channelParticipant',\n\t\tuser_id: number,\n\t\tdate: number\n\t};\n\n\texport type channelParticipantSelf = {\n\t\t_: 'channelParticipantSelf',\n\t\tuser_id: number,\n\t\tinviter_id: number,\n\t\tdate: number\n\t};\n\n\texport type channelParticipantCreator = {\n\t\t_: 'channelParticipantCreator',\n\t\tflags?: number,\n\t\tuser_id: number,\n\t\tadmin_rights: ChatAdminRights,\n\t\trank?: string\n\t};\n\n\texport type channelParticipantAdmin = {\n\t\t_: 'channelParticipantAdmin',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcan_edit?: true,\n\t\t\tself?: true,\n\t\t}>,\n\t\tuser_id: number,\n\t\tinviter_id?: number,\n\t\tpromoted_by: number,\n\t\tdate: number,\n\t\tadmin_rights: ChatAdminRights,\n\t\trank?: string\n\t};\n\n\texport type channelParticipantBanned = {\n\t\t_: 'channelParticipantBanned',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tleft?: true,\n\t\t}>,\n\t\tpeer: Peer,\n\t\tkicked_by: number,\n\t\tdate: number,\n\t\tbanned_rights: ChatBannedRights\n\t};\n\n\texport type channelParticipantLeft = {\n\t\t_: 'channelParticipantLeft',\n\t\tpeer: Peer\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChannelParticipantsFilter\n */\nexport type ChannelParticipantsFilter = ChannelParticipantsFilter.channelParticipantsRecent | ChannelParticipantsFilter.channelParticipantsAdmins | ChannelParticipantsFilter.channelParticipantsKicked | ChannelParticipantsFilter.channelParticipantsBots | ChannelParticipantsFilter.channelParticipantsBanned | ChannelParticipantsFilter.channelParticipantsSearch | ChannelParticipantsFilter.channelParticipantsContacts | ChannelParticipantsFilter.channelParticipantsMentions;\n\nexport namespace ChannelParticipantsFilter {\n  export type channelParticipantsRecent = {\n\t\t_: 'channelParticipantsRecent'\n\t};\n\n\texport type channelParticipantsAdmins = {\n\t\t_: 'channelParticipantsAdmins'\n\t};\n\n\texport type channelParticipantsKicked = {\n\t\t_: 'channelParticipantsKicked',\n\t\tq: string\n\t};\n\n\texport type channelParticipantsBots = {\n\t\t_: 'channelParticipantsBots'\n\t};\n\n\texport type channelParticipantsBanned = {\n\t\t_: 'channelParticipantsBanned',\n\t\tq: string\n\t};\n\n\texport type channelParticipantsSearch = {\n\t\t_: 'channelParticipantsSearch',\n\t\tq: string\n\t};\n\n\texport type channelParticipantsContacts = {\n\t\t_: 'channelParticipantsContacts',\n\t\tq: string\n\t};\n\n\texport type channelParticipantsMentions = {\n\t\t_: 'channelParticipantsMentions',\n\t\tflags?: number,\n\t\tq?: string,\n\t\ttop_msg_id?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/channels.ChannelParticipants\n */\nexport type ChannelsChannelParticipants = ChannelsChannelParticipants.channelsChannelParticipants | ChannelsChannelParticipants.channelsChannelParticipantsNotModified;\n\nexport namespace ChannelsChannelParticipants {\n  export type channelsChannelParticipants = {\n\t\t_: 'channels.channelParticipants',\n\t\tcount: number,\n\t\tparticipants: Array<ChannelParticipant>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type channelsChannelParticipantsNotModified = {\n\t\t_: 'channels.channelParticipantsNotModified'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/channels.ChannelParticipant\n */\nexport type ChannelsChannelParticipant = ChannelsChannelParticipant.channelsChannelParticipant;\n\nexport namespace ChannelsChannelParticipant {\n  export type channelsChannelParticipant = {\n\t\t_: 'channels.channelParticipant',\n\t\tparticipant: ChannelParticipant,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.TermsOfService\n */\nexport type HelpTermsOfService = HelpTermsOfService.helpTermsOfService;\n\nexport namespace HelpTermsOfService {\n  export type helpTermsOfService = {\n\t\t_: 'help.termsOfService',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpopup?: true,\n\t\t}>,\n\t\tid: DataJSON,\n\t\ttext: string,\n\t\tentities: Array<MessageEntity>,\n\t\tmin_age_confirm?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.SavedGifs\n */\nexport type MessagesSavedGifs = MessagesSavedGifs.messagesSavedGifsNotModified | MessagesSavedGifs.messagesSavedGifs;\n\nexport namespace MessagesSavedGifs {\n  export type messagesSavedGifsNotModified = {\n\t\t_: 'messages.savedGifsNotModified'\n\t};\n\n\texport type messagesSavedGifs = {\n\t\t_: 'messages.savedGifs',\n\t\thash: number,\n\t\tgifs: Array<Document>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputBotInlineMessage\n */\nexport type InputBotInlineMessage = InputBotInlineMessage.inputBotInlineMessageMediaAuto | InputBotInlineMessage.inputBotInlineMessageText | InputBotInlineMessage.inputBotInlineMessageMediaGeo | InputBotInlineMessage.inputBotInlineMessageMediaVenue | InputBotInlineMessage.inputBotInlineMessageMediaContact | InputBotInlineMessage.inputBotInlineMessageGame | InputBotInlineMessage.inputBotInlineMessageMediaInvoice;\n\nexport namespace InputBotInlineMessage {\n  export type inputBotInlineMessageMediaAuto = {\n\t\t_: 'inputBotInlineMessageMediaAuto',\n\t\tflags?: number,\n\t\tmessage: string,\n\t\tentities?: Array<MessageEntity>,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type inputBotInlineMessageText = {\n\t\t_: 'inputBotInlineMessageText',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tno_webpage?: true,\n\t\t}>,\n\t\tmessage: string,\n\t\tentities?: Array<MessageEntity>,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type inputBotInlineMessageMediaGeo = {\n\t\t_: 'inputBotInlineMessageMediaGeo',\n\t\tflags?: number,\n\t\tgeo_point: InputGeoPoint,\n\t\theading?: number,\n\t\tperiod?: number,\n\t\tproximity_notification_radius?: number,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type inputBotInlineMessageMediaVenue = {\n\t\t_: 'inputBotInlineMessageMediaVenue',\n\t\tflags?: number,\n\t\tgeo_point: InputGeoPoint,\n\t\ttitle: string,\n\t\taddress: string,\n\t\tprovider: string,\n\t\tvenue_id: string,\n\t\tvenue_type: string,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type inputBotInlineMessageMediaContact = {\n\t\t_: 'inputBotInlineMessageMediaContact',\n\t\tflags?: number,\n\t\tphone_number: string,\n\t\tfirst_name: string,\n\t\tlast_name: string,\n\t\tvcard: string,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type inputBotInlineMessageGame = {\n\t\t_: 'inputBotInlineMessageGame',\n\t\tflags?: number,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type inputBotInlineMessageMediaInvoice = {\n\t\t_: 'inputBotInlineMessageMediaInvoice',\n\t\tflags?: number,\n\t\ttitle: string,\n\t\tdescription: string,\n\t\tphoto?: InputWebDocument,\n\t\tinvoice: Invoice,\n\t\tpayload: Uint8Array,\n\t\tprovider: string,\n\t\tprovider_data: DataJSON,\n\t\treply_markup?: ReplyMarkup\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputBotInlineResult\n */\nexport type InputBotInlineResult = InputBotInlineResult.inputBotInlineResult | InputBotInlineResult.inputBotInlineResultPhoto | InputBotInlineResult.inputBotInlineResultDocument | InputBotInlineResult.inputBotInlineResultGame;\n\nexport namespace InputBotInlineResult {\n  export type inputBotInlineResult = {\n\t\t_: 'inputBotInlineResult',\n\t\tflags?: number,\n\t\tid: string,\n\t\ttype: string,\n\t\ttitle?: string,\n\t\tdescription?: string,\n\t\turl?: string,\n\t\tthumb?: InputWebDocument,\n\t\tcontent?: InputWebDocument,\n\t\tsend_message: InputBotInlineMessage\n\t};\n\n\texport type inputBotInlineResultPhoto = {\n\t\t_: 'inputBotInlineResultPhoto',\n\t\tid: string,\n\t\ttype: string,\n\t\tphoto: InputPhoto,\n\t\tsend_message: InputBotInlineMessage\n\t};\n\n\texport type inputBotInlineResultDocument = {\n\t\t_: 'inputBotInlineResultDocument',\n\t\tflags?: number,\n\t\tid: string,\n\t\ttype: string,\n\t\ttitle?: string,\n\t\tdescription?: string,\n\t\tdocument: InputDocument,\n\t\tsend_message: InputBotInlineMessage\n\t};\n\n\texport type inputBotInlineResultGame = {\n\t\t_: 'inputBotInlineResultGame',\n\t\tid: string,\n\t\tshort_name: string,\n\t\tsend_message: InputBotInlineMessage\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/BotInlineMessage\n */\nexport type BotInlineMessage = BotInlineMessage.botInlineMessageMediaAuto | BotInlineMessage.botInlineMessageText | BotInlineMessage.botInlineMessageMediaGeo | BotInlineMessage.botInlineMessageMediaVenue | BotInlineMessage.botInlineMessageMediaContact | BotInlineMessage.botInlineMessageMediaInvoice;\n\nexport namespace BotInlineMessage {\n  export type botInlineMessageMediaAuto = {\n\t\t_: 'botInlineMessageMediaAuto',\n\t\tflags?: number,\n\t\tmessage: string,\n\t\tentities?: Array<MessageEntity>,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type botInlineMessageText = {\n\t\t_: 'botInlineMessageText',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tno_webpage?: true,\n\t\t}>,\n\t\tmessage: string,\n\t\tentities?: Array<MessageEntity>,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type botInlineMessageMediaGeo = {\n\t\t_: 'botInlineMessageMediaGeo',\n\t\tflags?: number,\n\t\tgeo: GeoPoint,\n\t\theading?: number,\n\t\tperiod?: number,\n\t\tproximity_notification_radius?: number,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type botInlineMessageMediaVenue = {\n\t\t_: 'botInlineMessageMediaVenue',\n\t\tflags?: number,\n\t\tgeo: GeoPoint,\n\t\ttitle: string,\n\t\taddress: string,\n\t\tprovider: string,\n\t\tvenue_id: string,\n\t\tvenue_type: string,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type botInlineMessageMediaContact = {\n\t\t_: 'botInlineMessageMediaContact',\n\t\tflags?: number,\n\t\tphone_number: string,\n\t\tfirst_name: string,\n\t\tlast_name: string,\n\t\tvcard: string,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type botInlineMessageMediaInvoice = {\n\t\t_: 'botInlineMessageMediaInvoice',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tshipping_address_requested?: true,\n\t\t\ttest?: true,\n\t\t}>,\n\t\ttitle: string,\n\t\tdescription: string,\n\t\tphoto?: WebDocument,\n\t\tcurrency: string,\n\t\ttotal_amount: string,\n\t\treply_markup?: ReplyMarkup\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/BotInlineResult\n */\nexport type BotInlineResult = BotInlineResult.botInlineResult | BotInlineResult.botInlineMediaResult;\n\nexport namespace BotInlineResult {\n  export type botInlineResult = {\n\t\t_: 'botInlineResult',\n\t\tflags?: number,\n\t\tid: string,\n\t\ttype: string,\n\t\ttitle?: string,\n\t\tdescription?: string,\n\t\turl?: string,\n\t\tthumb?: WebDocument,\n\t\tcontent?: WebDocument,\n\t\tsend_message: BotInlineMessage\n\t};\n\n\texport type botInlineMediaResult = {\n\t\t_: 'botInlineMediaResult',\n\t\tflags?: number,\n\t\tid: string,\n\t\ttype: string,\n\t\tphoto?: Photo,\n\t\tdocument?: Document,\n\t\ttitle?: string,\n\t\tdescription?: string,\n\t\tsend_message: BotInlineMessage\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.BotResults\n */\nexport type MessagesBotResults = MessagesBotResults.messagesBotResults;\n\nexport namespace MessagesBotResults {\n  export type messagesBotResults = {\n\t\t_: 'messages.botResults',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tgallery?: true,\n\t\t}>,\n\t\tquery_id: string,\n\t\tnext_offset?: string,\n\t\tswitch_pm?: InlineBotSwitchPM,\n\t\tresults: Array<BotInlineResult>,\n\t\tcache_time: number,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ExportedMessageLink\n */\nexport type ExportedMessageLink = ExportedMessageLink.exportedMessageLink;\n\nexport namespace ExportedMessageLink {\n  export type exportedMessageLink = {\n\t\t_: 'exportedMessageLink',\n\t\tlink: string,\n\t\thtml: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageFwdHeader\n */\nexport type MessageFwdHeader = MessageFwdHeader.messageFwdHeader;\n\nexport namespace MessageFwdHeader {\n  export type messageFwdHeader = {\n\t\t_: 'messageFwdHeader',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\timported?: true,\n\t\t}>,\n\t\tfrom_id?: Peer,\n\t\tfrom_name?: string,\n\t\tdate: number,\n\t\tchannel_post?: number,\n\t\tpost_author?: string,\n\t\tsaved_from_peer?: Peer,\n\t\tsaved_from_msg_id?: number,\n\t\tpsa_type?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/auth.CodeType\n */\nexport type AuthCodeType = AuthCodeType.authCodeTypeSms | AuthCodeType.authCodeTypeCall | AuthCodeType.authCodeTypeFlashCall;\n\nexport namespace AuthCodeType {\n  export type authCodeTypeSms = {\n\t\t_: 'auth.codeTypeSms'\n\t};\n\n\texport type authCodeTypeCall = {\n\t\t_: 'auth.codeTypeCall'\n\t};\n\n\texport type authCodeTypeFlashCall = {\n\t\t_: 'auth.codeTypeFlashCall'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/auth.SentCodeType\n */\nexport type AuthSentCodeType = AuthSentCodeType.authSentCodeTypeApp | AuthSentCodeType.authSentCodeTypeSms | AuthSentCodeType.authSentCodeTypeCall | AuthSentCodeType.authSentCodeTypeFlashCall;\n\nexport namespace AuthSentCodeType {\n  export type authSentCodeTypeApp = {\n\t\t_: 'auth.sentCodeTypeApp',\n\t\tlength: number\n\t};\n\n\texport type authSentCodeTypeSms = {\n\t\t_: 'auth.sentCodeTypeSms',\n\t\tlength: number\n\t};\n\n\texport type authSentCodeTypeCall = {\n\t\t_: 'auth.sentCodeTypeCall',\n\t\tlength: number\n\t};\n\n\texport type authSentCodeTypeFlashCall = {\n\t\t_: 'auth.sentCodeTypeFlashCall',\n\t\tpattern: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.BotCallbackAnswer\n */\nexport type MessagesBotCallbackAnswer = MessagesBotCallbackAnswer.messagesBotCallbackAnswer;\n\nexport namespace MessagesBotCallbackAnswer {\n  export type messagesBotCallbackAnswer = {\n\t\t_: 'messages.botCallbackAnswer',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\talert?: true,\n\t\t\thas_url?: true,\n\t\t\tnative_ui?: true,\n\t\t}>,\n\t\tmessage?: string,\n\t\turl?: string,\n\t\tcache_time: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.MessageEditData\n */\nexport type MessagesMessageEditData = MessagesMessageEditData.messagesMessageEditData;\n\nexport namespace MessagesMessageEditData {\n  export type messagesMessageEditData = {\n\t\t_: 'messages.messageEditData',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcaption?: true,\n\t\t}>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputBotInlineMessageID\n */\nexport type InputBotInlineMessageID = InputBotInlineMessageID.inputBotInlineMessageID;\n\nexport namespace InputBotInlineMessageID {\n  export type inputBotInlineMessageID = {\n\t\t_: 'inputBotInlineMessageID',\n\t\tdc_id: number,\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InlineBotSwitchPM\n */\nexport type InlineBotSwitchPM = InlineBotSwitchPM.inlineBotSwitchPM;\n\nexport namespace InlineBotSwitchPM {\n  export type inlineBotSwitchPM = {\n\t\t_: 'inlineBotSwitchPM',\n\t\ttext: string,\n\t\tstart_param: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.PeerDialogs\n */\nexport type MessagesPeerDialogs = MessagesPeerDialogs.messagesPeerDialogs;\n\nexport namespace MessagesPeerDialogs {\n  export type messagesPeerDialogs = {\n\t\t_: 'messages.peerDialogs',\n\t\tdialogs: Array<Dialog>,\n\t\tmessages: Array<Message>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>,\n\t\tstate: UpdatesState\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/TopPeer\n */\nexport type TopPeer = TopPeer.topPeer;\n\nexport namespace TopPeer {\n  export type topPeer = {\n\t\t_: 'topPeer',\n\t\tpeer: Peer,\n\t\trating: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/TopPeerCategory\n */\nexport type TopPeerCategory = TopPeerCategory.topPeerCategoryBotsPM | TopPeerCategory.topPeerCategoryBotsInline | TopPeerCategory.topPeerCategoryCorrespondents | TopPeerCategory.topPeerCategoryGroups | TopPeerCategory.topPeerCategoryChannels | TopPeerCategory.topPeerCategoryPhoneCalls | TopPeerCategory.topPeerCategoryForwardUsers | TopPeerCategory.topPeerCategoryForwardChats;\n\nexport namespace TopPeerCategory {\n  export type topPeerCategoryBotsPM = {\n\t\t_: 'topPeerCategoryBotsPM'\n\t};\n\n\texport type topPeerCategoryBotsInline = {\n\t\t_: 'topPeerCategoryBotsInline'\n\t};\n\n\texport type topPeerCategoryCorrespondents = {\n\t\t_: 'topPeerCategoryCorrespondents'\n\t};\n\n\texport type topPeerCategoryGroups = {\n\t\t_: 'topPeerCategoryGroups'\n\t};\n\n\texport type topPeerCategoryChannels = {\n\t\t_: 'topPeerCategoryChannels'\n\t};\n\n\texport type topPeerCategoryPhoneCalls = {\n\t\t_: 'topPeerCategoryPhoneCalls'\n\t};\n\n\texport type topPeerCategoryForwardUsers = {\n\t\t_: 'topPeerCategoryForwardUsers'\n\t};\n\n\texport type topPeerCategoryForwardChats = {\n\t\t_: 'topPeerCategoryForwardChats'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/TopPeerCategoryPeers\n */\nexport type TopPeerCategoryPeers = TopPeerCategoryPeers.topPeerCategoryPeers;\n\nexport namespace TopPeerCategoryPeers {\n  export type topPeerCategoryPeers = {\n\t\t_: 'topPeerCategoryPeers',\n\t\tcategory: TopPeerCategory,\n\t\tcount: number,\n\t\tpeers: Array<TopPeer>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/contacts.TopPeers\n */\nexport type ContactsTopPeers = ContactsTopPeers.contactsTopPeersNotModified | ContactsTopPeers.contactsTopPeers | ContactsTopPeers.contactsTopPeersDisabled;\n\nexport namespace ContactsTopPeers {\n  export type contactsTopPeersNotModified = {\n\t\t_: 'contacts.topPeersNotModified'\n\t};\n\n\texport type contactsTopPeers = {\n\t\t_: 'contacts.topPeers',\n\t\tcategories: Array<TopPeerCategoryPeers>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type contactsTopPeersDisabled = {\n\t\t_: 'contacts.topPeersDisabled'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/DraftMessage\n */\nexport type DraftMessage = DraftMessage.draftMessageEmpty | DraftMessage.draftMessage;\n\nexport namespace DraftMessage {\n  export type draftMessageEmpty = {\n\t\t_: 'draftMessageEmpty',\n\t\tflags?: number,\n\t\tdate?: number\n\t};\n\n\texport type draftMessage = {\n\t\t_: 'draftMessage',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tno_webpage?: true,\n\t\t}>,\n\t\treply_to_msg_id?: number,\n\t\tmessage: string,\n\t\tentities?: Array<MessageEntity>,\n\t\tdate: number,\n\t\trReply?: string,\n\t\trMessage?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.FeaturedStickers\n */\nexport type MessagesFeaturedStickers = MessagesFeaturedStickers.messagesFeaturedStickersNotModified | MessagesFeaturedStickers.messagesFeaturedStickers;\n\nexport namespace MessagesFeaturedStickers {\n  export type messagesFeaturedStickersNotModified = {\n\t\t_: 'messages.featuredStickersNotModified',\n\t\tcount: number\n\t};\n\n\texport type messagesFeaturedStickers = {\n\t\t_: 'messages.featuredStickers',\n\t\thash: number,\n\t\tcount: number,\n\t\tsets: Array<StickerSetCovered>,\n\t\tunread: Array<string>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.RecentStickers\n */\nexport type MessagesRecentStickers = MessagesRecentStickers.messagesRecentStickersNotModified | MessagesRecentStickers.messagesRecentStickers;\n\nexport namespace MessagesRecentStickers {\n  export type messagesRecentStickersNotModified = {\n\t\t_: 'messages.recentStickersNotModified'\n\t};\n\n\texport type messagesRecentStickers = {\n\t\t_: 'messages.recentStickers',\n\t\thash: number,\n\t\tpacks: Array<StickerPack>,\n\t\tstickers: Array<Document>,\n\t\tdates: Array<number>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.ArchivedStickers\n */\nexport type MessagesArchivedStickers = MessagesArchivedStickers.messagesArchivedStickers;\n\nexport namespace MessagesArchivedStickers {\n  export type messagesArchivedStickers = {\n\t\t_: 'messages.archivedStickers',\n\t\tcount: number,\n\t\tsets: Array<StickerSetCovered>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.StickerSetInstallResult\n */\nexport type MessagesStickerSetInstallResult = MessagesStickerSetInstallResult.messagesStickerSetInstallResultSuccess | MessagesStickerSetInstallResult.messagesStickerSetInstallResultArchive;\n\nexport namespace MessagesStickerSetInstallResult {\n  export type messagesStickerSetInstallResultSuccess = {\n\t\t_: 'messages.stickerSetInstallResultSuccess'\n\t};\n\n\texport type messagesStickerSetInstallResultArchive = {\n\t\t_: 'messages.stickerSetInstallResultArchive',\n\t\tsets: Array<StickerSetCovered>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StickerSetCovered\n */\nexport type StickerSetCovered = StickerSetCovered.stickerSetCovered | StickerSetCovered.stickerSetMultiCovered;\n\nexport namespace StickerSetCovered {\n  export type stickerSetCovered = {\n\t\t_: 'stickerSetCovered',\n\t\tset: StickerSet,\n\t\tcover: Document\n\t};\n\n\texport type stickerSetMultiCovered = {\n\t\t_: 'stickerSetMultiCovered',\n\t\tset: StickerSet,\n\t\tcovers: Array<Document>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MaskCoords\n */\nexport type MaskCoords = MaskCoords.maskCoords;\n\nexport namespace MaskCoords {\n  export type maskCoords = {\n\t\t_: 'maskCoords',\n\t\tn: number,\n\t\tx: number,\n\t\ty: number,\n\t\tzoom: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputStickeredMedia\n */\nexport type InputStickeredMedia = InputStickeredMedia.inputStickeredMediaPhoto | InputStickeredMedia.inputStickeredMediaDocument;\n\nexport namespace InputStickeredMedia {\n  export type inputStickeredMediaPhoto = {\n\t\t_: 'inputStickeredMediaPhoto',\n\t\tid: InputPhoto\n\t};\n\n\texport type inputStickeredMediaDocument = {\n\t\t_: 'inputStickeredMediaDocument',\n\t\tid: InputDocument\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Game\n */\nexport type Game = Game.game;\n\nexport namespace Game {\n  export type game = {\n\t\t_: 'game',\n\t\tflags?: number,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tshort_name: string,\n\t\ttitle: string,\n\t\tdescription: string,\n\t\tphoto: Photo,\n\t\tdocument?: Document\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputGame\n */\nexport type InputGame = InputGame.inputGameID | InputGame.inputGameShortName;\n\nexport namespace InputGame {\n  export type inputGameID = {\n\t\t_: 'inputGameID',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputGameShortName = {\n\t\t_: 'inputGameShortName',\n\t\tbot_id: InputUser,\n\t\tshort_name: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/HighScore\n */\nexport type HighScore = HighScore.highScore;\n\nexport namespace HighScore {\n  export type highScore = {\n\t\t_: 'highScore',\n\t\tpos: number,\n\t\tuser_id: number,\n\t\tscore: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.HighScores\n */\nexport type MessagesHighScores = MessagesHighScores.messagesHighScores;\n\nexport namespace MessagesHighScores {\n  export type messagesHighScores = {\n\t\t_: 'messages.highScores',\n\t\tscores: Array<HighScore>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/RichText\n */\nexport type RichText = RichText.textEmpty | RichText.textPlain | RichText.textBold | RichText.textItalic | RichText.textUnderline | RichText.textStrike | RichText.textFixed | RichText.textUrl | RichText.textEmail | RichText.textConcat | RichText.textSubscript | RichText.textSuperscript | RichText.textMarked | RichText.textPhone | RichText.textImage | RichText.textAnchor;\n\nexport namespace RichText {\n  export type textEmpty = {\n\t\t_: 'textEmpty'\n\t};\n\n\texport type textPlain = {\n\t\t_: 'textPlain',\n\t\ttext: string\n\t};\n\n\texport type textBold = {\n\t\t_: 'textBold',\n\t\ttext: RichText\n\t};\n\n\texport type textItalic = {\n\t\t_: 'textItalic',\n\t\ttext: RichText\n\t};\n\n\texport type textUnderline = {\n\t\t_: 'textUnderline',\n\t\ttext: RichText\n\t};\n\n\texport type textStrike = {\n\t\t_: 'textStrike',\n\t\ttext: RichText\n\t};\n\n\texport type textFixed = {\n\t\t_: 'textFixed',\n\t\ttext: RichText\n\t};\n\n\texport type textUrl = {\n\t\t_: 'textUrl',\n\t\ttext: RichText,\n\t\turl: string,\n\t\twebpage_id: string\n\t};\n\n\texport type textEmail = {\n\t\t_: 'textEmail',\n\t\ttext: RichText,\n\t\temail: string\n\t};\n\n\texport type textConcat = {\n\t\t_: 'textConcat',\n\t\ttexts: Array<RichText>\n\t};\n\n\texport type textSubscript = {\n\t\t_: 'textSubscript',\n\t\ttext: RichText\n\t};\n\n\texport type textSuperscript = {\n\t\t_: 'textSuperscript',\n\t\ttext: RichText\n\t};\n\n\texport type textMarked = {\n\t\t_: 'textMarked',\n\t\ttext: RichText\n\t};\n\n\texport type textPhone = {\n\t\t_: 'textPhone',\n\t\ttext: RichText,\n\t\tphone: string\n\t};\n\n\texport type textImage = {\n\t\t_: 'textImage',\n\t\tdocument_id: string,\n\t\tw: number,\n\t\th: number\n\t};\n\n\texport type textAnchor = {\n\t\t_: 'textAnchor',\n\t\ttext: RichText,\n\t\tname: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PageBlock\n */\nexport type PageBlock = PageBlock.pageBlockUnsupported | PageBlock.pageBlockTitle | PageBlock.pageBlockSubtitle | PageBlock.pageBlockAuthorDate | PageBlock.pageBlockHeader | PageBlock.pageBlockSubheader | PageBlock.pageBlockParagraph | PageBlock.pageBlockPreformatted | PageBlock.pageBlockFooter | PageBlock.pageBlockDivider | PageBlock.pageBlockAnchor | PageBlock.pageBlockList | PageBlock.pageBlockBlockquote | PageBlock.pageBlockPullquote | PageBlock.pageBlockPhoto | PageBlock.pageBlockVideo | PageBlock.pageBlockCover | PageBlock.pageBlockEmbed | PageBlock.pageBlockEmbedPost | PageBlock.pageBlockCollage | PageBlock.pageBlockSlideshow | PageBlock.pageBlockChannel | PageBlock.pageBlockAudio | PageBlock.pageBlockKicker | PageBlock.pageBlockTable | PageBlock.pageBlockOrderedList | PageBlock.pageBlockDetails | PageBlock.pageBlockRelatedArticles | PageBlock.pageBlockMap;\n\nexport namespace PageBlock {\n  export type pageBlockUnsupported = {\n\t\t_: 'pageBlockUnsupported'\n\t};\n\n\texport type pageBlockTitle = {\n\t\t_: 'pageBlockTitle',\n\t\ttext: RichText\n\t};\n\n\texport type pageBlockSubtitle = {\n\t\t_: 'pageBlockSubtitle',\n\t\ttext: RichText\n\t};\n\n\texport type pageBlockAuthorDate = {\n\t\t_: 'pageBlockAuthorDate',\n\t\tauthor: RichText,\n\t\tpublished_date: number\n\t};\n\n\texport type pageBlockHeader = {\n\t\t_: 'pageBlockHeader',\n\t\ttext: RichText\n\t};\n\n\texport type pageBlockSubheader = {\n\t\t_: 'pageBlockSubheader',\n\t\ttext: RichText\n\t};\n\n\texport type pageBlockParagraph = {\n\t\t_: 'pageBlockParagraph',\n\t\ttext: RichText\n\t};\n\n\texport type pageBlockPreformatted = {\n\t\t_: 'pageBlockPreformatted',\n\t\ttext: RichText,\n\t\tlanguage: string\n\t};\n\n\texport type pageBlockFooter = {\n\t\t_: 'pageBlockFooter',\n\t\ttext: RichText\n\t};\n\n\texport type pageBlockDivider = {\n\t\t_: 'pageBlockDivider'\n\t};\n\n\texport type pageBlockAnchor = {\n\t\t_: 'pageBlockAnchor',\n\t\tname: string\n\t};\n\n\texport type pageBlockList = {\n\t\t_: 'pageBlockList',\n\t\titems: Array<PageListItem>\n\t};\n\n\texport type pageBlockBlockquote = {\n\t\t_: 'pageBlockBlockquote',\n\t\ttext: RichText,\n\t\tcaption: RichText\n\t};\n\n\texport type pageBlockPullquote = {\n\t\t_: 'pageBlockPullquote',\n\t\ttext: RichText,\n\t\tcaption: RichText\n\t};\n\n\texport type pageBlockPhoto = {\n\t\t_: 'pageBlockPhoto',\n\t\tflags?: number,\n\t\tphoto_id: string,\n\t\tcaption: PageCaption,\n\t\turl?: string,\n\t\twebpage_id?: string\n\t};\n\n\texport type pageBlockVideo = {\n\t\t_: 'pageBlockVideo',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tautoplay?: true,\n\t\t\tloop?: true,\n\t\t}>,\n\t\tvideo_id: string,\n\t\tcaption: PageCaption\n\t};\n\n\texport type pageBlockCover = {\n\t\t_: 'pageBlockCover',\n\t\tcover: PageBlock\n\t};\n\n\texport type pageBlockEmbed = {\n\t\t_: 'pageBlockEmbed',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tfull_width?: true,\n\t\t\tallow_scrolling?: true,\n\t\t}>,\n\t\turl?: string,\n\t\thtml?: string,\n\t\tposter_photo_id?: string,\n\t\tw?: number,\n\t\th?: number,\n\t\tcaption: PageCaption\n\t};\n\n\texport type pageBlockEmbedPost = {\n\t\t_: 'pageBlockEmbedPost',\n\t\turl: string,\n\t\twebpage_id: string,\n\t\tauthor_photo_id: string,\n\t\tauthor: string,\n\t\tdate: number,\n\t\tblocks: Array<PageBlock>,\n\t\tcaption: PageCaption\n\t};\n\n\texport type pageBlockCollage = {\n\t\t_: 'pageBlockCollage',\n\t\titems: Array<PageBlock>,\n\t\tcaption: PageCaption\n\t};\n\n\texport type pageBlockSlideshow = {\n\t\t_: 'pageBlockSlideshow',\n\t\titems: Array<PageBlock>,\n\t\tcaption: PageCaption\n\t};\n\n\texport type pageBlockChannel = {\n\t\t_: 'pageBlockChannel',\n\t\tchannel: Chat\n\t};\n\n\texport type pageBlockAudio = {\n\t\t_: 'pageBlockAudio',\n\t\taudio_id: string,\n\t\tcaption: PageCaption\n\t};\n\n\texport type pageBlockKicker = {\n\t\t_: 'pageBlockKicker',\n\t\ttext: RichText\n\t};\n\n\texport type pageBlockTable = {\n\t\t_: 'pageBlockTable',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tbordered?: true,\n\t\t\tstriped?: true,\n\t\t}>,\n\t\ttitle: RichText,\n\t\trows: Array<PageTableRow>\n\t};\n\n\texport type pageBlockOrderedList = {\n\t\t_: 'pageBlockOrderedList',\n\t\titems: Array<PageListOrderedItem>\n\t};\n\n\texport type pageBlockDetails = {\n\t\t_: 'pageBlockDetails',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\topen?: true,\n\t\t}>,\n\t\tblocks: Array<PageBlock>,\n\t\ttitle: RichText\n\t};\n\n\texport type pageBlockRelatedArticles = {\n\t\t_: 'pageBlockRelatedArticles',\n\t\ttitle: RichText,\n\t\tarticles: Array<PageRelatedArticle>\n\t};\n\n\texport type pageBlockMap = {\n\t\t_: 'pageBlockMap',\n\t\tgeo: GeoPoint,\n\t\tzoom: number,\n\t\tw: number,\n\t\th: number,\n\t\tcaption: PageCaption\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PhoneCallDiscardReason\n */\nexport type PhoneCallDiscardReason = PhoneCallDiscardReason.phoneCallDiscardReasonMissed | PhoneCallDiscardReason.phoneCallDiscardReasonDisconnect | PhoneCallDiscardReason.phoneCallDiscardReasonHangup | PhoneCallDiscardReason.phoneCallDiscardReasonBusy;\n\nexport namespace PhoneCallDiscardReason {\n  export type phoneCallDiscardReasonMissed = {\n\t\t_: 'phoneCallDiscardReasonMissed'\n\t};\n\n\texport type phoneCallDiscardReasonDisconnect = {\n\t\t_: 'phoneCallDiscardReasonDisconnect'\n\t};\n\n\texport type phoneCallDiscardReasonHangup = {\n\t\t_: 'phoneCallDiscardReasonHangup'\n\t};\n\n\texport type phoneCallDiscardReasonBusy = {\n\t\t_: 'phoneCallDiscardReasonBusy'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/DataJSON\n */\nexport type DataJSON = DataJSON.dataJSON;\n\nexport namespace DataJSON {\n  export type dataJSON = {\n\t\t_: 'dataJSON',\n\t\tdata: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/LabeledPrice\n */\nexport type LabeledPrice = LabeledPrice.labeledPrice;\n\nexport namespace LabeledPrice {\n  export type labeledPrice = {\n\t\t_: 'labeledPrice',\n\t\tlabel: string,\n\t\tamount: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Invoice\n */\nexport type Invoice = Invoice.invoice;\n\nexport namespace Invoice {\n  export type invoice = {\n\t\t_: 'invoice',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\ttest?: true,\n\t\t\tname_requested?: true,\n\t\t\tphone_requested?: true,\n\t\t\temail_requested?: true,\n\t\t\tshipping_address_requested?: true,\n\t\t\tflexible?: true,\n\t\t\tphone_to_provider?: true,\n\t\t\temail_to_provider?: true,\n\t\t}>,\n\t\tcurrency: string,\n\t\tprices: Array<LabeledPrice>,\n\t\tmax_tip_amount?: string,\n\t\tsuggested_tip_amounts?: Array<string>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PaymentCharge\n */\nexport type PaymentCharge = PaymentCharge.paymentCharge;\n\nexport namespace PaymentCharge {\n  export type paymentCharge = {\n\t\t_: 'paymentCharge',\n\t\tid: string,\n\t\tprovider_charge_id: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PostAddress\n */\nexport type PostAddress = PostAddress.postAddress;\n\nexport namespace PostAddress {\n  export type postAddress = {\n\t\t_: 'postAddress',\n\t\tstreet_line1: string,\n\t\tstreet_line2: string,\n\t\tcity: string,\n\t\tstate: string,\n\t\tcountry_iso2: string,\n\t\tpost_code: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PaymentRequestedInfo\n */\nexport type PaymentRequestedInfo = PaymentRequestedInfo.paymentRequestedInfo;\n\nexport namespace PaymentRequestedInfo {\n  export type paymentRequestedInfo = {\n\t\t_: 'paymentRequestedInfo',\n\t\tflags?: number,\n\t\tname?: string,\n\t\tphone?: string,\n\t\temail?: string,\n\t\tshipping_address?: PostAddress\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PaymentSavedCredentials\n */\nexport type PaymentSavedCredentials = PaymentSavedCredentials.paymentSavedCredentialsCard;\n\nexport namespace PaymentSavedCredentials {\n  export type paymentSavedCredentialsCard = {\n\t\t_: 'paymentSavedCredentialsCard',\n\t\tid: string,\n\t\ttitle: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/WebDocument\n */\nexport type WebDocument = WebDocument.webDocument | WebDocument.webDocumentNoProxy;\n\nexport namespace WebDocument {\n  export type webDocument = {\n\t\t_: 'webDocument',\n\t\turl: string,\n\t\taccess_hash: string,\n\t\tsize: number,\n\t\tmime_type: string,\n\t\tattributes: Array<DocumentAttribute>\n\t};\n\n\texport type webDocumentNoProxy = {\n\t\t_: 'webDocumentNoProxy',\n\t\turl: string,\n\t\tsize: number,\n\t\tmime_type: string,\n\t\tattributes: Array<DocumentAttribute>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputWebDocument\n */\nexport type InputWebDocument = InputWebDocument.inputWebDocument;\n\nexport namespace InputWebDocument {\n  export type inputWebDocument = {\n\t\t_: 'inputWebDocument',\n\t\turl: string,\n\t\tsize: number,\n\t\tmime_type: string,\n\t\tattributes: Array<DocumentAttribute>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputWebFileLocation\n */\nexport type InputWebFileLocation = InputWebFileLocation.inputWebFileLocation | InputWebFileLocation.inputWebFileGeoPointLocation;\n\nexport namespace InputWebFileLocation {\n  export type inputWebFileLocation = {\n\t\t_: 'inputWebFileLocation',\n\t\turl: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputWebFileGeoPointLocation = {\n\t\t_: 'inputWebFileGeoPointLocation',\n\t\tgeo_point: InputGeoPoint,\n\t\taccess_hash: string,\n\t\tw: number,\n\t\th: number,\n\t\tzoom: number,\n\t\tscale: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/upload.WebFile\n */\nexport type UploadWebFile = UploadWebFile.uploadWebFile;\n\nexport namespace UploadWebFile {\n  export type uploadWebFile = {\n\t\t_: 'upload.webFile',\n\t\tsize: number,\n\t\tmime_type: string,\n\t\tfile_type: StorageFileType,\n\t\tmtime: number,\n\t\tbytes: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/payments.PaymentForm\n */\nexport type PaymentsPaymentForm = PaymentsPaymentForm.paymentsPaymentForm;\n\nexport namespace PaymentsPaymentForm {\n  export type paymentsPaymentForm = {\n\t\t_: 'payments.paymentForm',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcan_save_credentials?: true,\n\t\t\tpassword_missing?: true,\n\t\t}>,\n\t\tform_id: string,\n\t\tbot_id: number,\n\t\tinvoice: Invoice,\n\t\tprovider_id: number,\n\t\turl: string,\n\t\tnative_provider?: string,\n\t\tnative_params?: DataJSON,\n\t\tsaved_info?: PaymentRequestedInfo,\n\t\tsaved_credentials?: PaymentSavedCredentials,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/payments.ValidatedRequestedInfo\n */\nexport type PaymentsValidatedRequestedInfo = PaymentsValidatedRequestedInfo.paymentsValidatedRequestedInfo;\n\nexport namespace PaymentsValidatedRequestedInfo {\n  export type paymentsValidatedRequestedInfo = {\n\t\t_: 'payments.validatedRequestedInfo',\n\t\tflags?: number,\n\t\tid?: string,\n\t\tshipping_options?: Array<ShippingOption>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/payments.PaymentResult\n */\nexport type PaymentsPaymentResult = PaymentsPaymentResult.paymentsPaymentResult | PaymentsPaymentResult.paymentsPaymentVerificationNeeded;\n\nexport namespace PaymentsPaymentResult {\n  export type paymentsPaymentResult = {\n\t\t_: 'payments.paymentResult',\n\t\tupdates: Updates\n\t};\n\n\texport type paymentsPaymentVerificationNeeded = {\n\t\t_: 'payments.paymentVerificationNeeded',\n\t\turl: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/payments.PaymentReceipt\n */\nexport type PaymentsPaymentReceipt = PaymentsPaymentReceipt.paymentsPaymentReceipt;\n\nexport namespace PaymentsPaymentReceipt {\n  export type paymentsPaymentReceipt = {\n\t\t_: 'payments.paymentReceipt',\n\t\tflags?: number,\n\t\tdate: number,\n\t\tbot_id: number,\n\t\tprovider_id: number,\n\t\ttitle: string,\n\t\tdescription: string,\n\t\tphoto?: WebDocument,\n\t\tinvoice: Invoice,\n\t\tinfo?: PaymentRequestedInfo,\n\t\tshipping?: ShippingOption,\n\t\ttip_amount?: string,\n\t\tcurrency: string,\n\t\ttotal_amount: string,\n\t\tcredentials_title: string,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/payments.SavedInfo\n */\nexport type PaymentsSavedInfo = PaymentsSavedInfo.paymentsSavedInfo;\n\nexport namespace PaymentsSavedInfo {\n  export type paymentsSavedInfo = {\n\t\t_: 'payments.savedInfo',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\thas_saved_credentials?: true,\n\t\t}>,\n\t\tsaved_info?: PaymentRequestedInfo\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputPaymentCredentials\n */\nexport type InputPaymentCredentials = InputPaymentCredentials.inputPaymentCredentialsSaved | InputPaymentCredentials.inputPaymentCredentials | InputPaymentCredentials.inputPaymentCredentialsApplePay | InputPaymentCredentials.inputPaymentCredentialsGooglePay;\n\nexport namespace InputPaymentCredentials {\n  export type inputPaymentCredentialsSaved = {\n\t\t_: 'inputPaymentCredentialsSaved',\n\t\tid: string,\n\t\ttmp_password: Uint8Array\n\t};\n\n\texport type inputPaymentCredentials = {\n\t\t_: 'inputPaymentCredentials',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tsave?: true,\n\t\t}>,\n\t\tdata: DataJSON\n\t};\n\n\texport type inputPaymentCredentialsApplePay = {\n\t\t_: 'inputPaymentCredentialsApplePay',\n\t\tpayment_data: DataJSON\n\t};\n\n\texport type inputPaymentCredentialsGooglePay = {\n\t\t_: 'inputPaymentCredentialsGooglePay',\n\t\tpayment_token: DataJSON\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.TmpPassword\n */\nexport type AccountTmpPassword = AccountTmpPassword.accountTmpPassword;\n\nexport namespace AccountTmpPassword {\n  export type accountTmpPassword = {\n\t\t_: 'account.tmpPassword',\n\t\ttmp_password: Uint8Array,\n\t\tvalid_until: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ShippingOption\n */\nexport type ShippingOption = ShippingOption.shippingOption;\n\nexport namespace ShippingOption {\n  export type shippingOption = {\n\t\t_: 'shippingOption',\n\t\tid: string,\n\t\ttitle: string,\n\t\tprices: Array<LabeledPrice>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputStickerSetItem\n */\nexport type InputStickerSetItem = InputStickerSetItem.inputStickerSetItem;\n\nexport namespace InputStickerSetItem {\n  export type inputStickerSetItem = {\n\t\t_: 'inputStickerSetItem',\n\t\tflags?: number,\n\t\tdocument: InputDocument,\n\t\temoji: string,\n\t\tmask_coords?: MaskCoords\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputPhoneCall\n */\nexport type InputPhoneCall = InputPhoneCall.inputPhoneCall;\n\nexport namespace InputPhoneCall {\n  export type inputPhoneCall = {\n\t\t_: 'inputPhoneCall',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PhoneCall\n */\nexport type PhoneCall = PhoneCall.phoneCallEmpty | PhoneCall.phoneCallWaiting | PhoneCall.phoneCallRequested | PhoneCall.phoneCallAccepted | PhoneCall.phoneCall | PhoneCall.phoneCallDiscarded;\n\nexport namespace PhoneCall {\n  export type phoneCallEmpty = {\n\t\t_: 'phoneCallEmpty',\n\t\tid: string\n\t};\n\n\texport type phoneCallWaiting = {\n\t\t_: 'phoneCallWaiting',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tvideo?: true,\n\t\t}>,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tdate: number,\n\t\tadmin_id: number,\n\t\tparticipant_id: number,\n\t\tprotocol: PhoneCallProtocol,\n\t\treceive_date?: number\n\t};\n\n\texport type phoneCallRequested = {\n\t\t_: 'phoneCallRequested',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tvideo?: true,\n\t\t}>,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tdate: number,\n\t\tadmin_id: number,\n\t\tparticipant_id: number,\n\t\tg_a_hash: Uint8Array,\n\t\tprotocol: PhoneCallProtocol\n\t};\n\n\texport type phoneCallAccepted = {\n\t\t_: 'phoneCallAccepted',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tvideo?: true,\n\t\t}>,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tdate: number,\n\t\tadmin_id: number,\n\t\tparticipant_id: number,\n\t\tg_b: Uint8Array,\n\t\tprotocol: PhoneCallProtocol\n\t};\n\n\texport type phoneCall = {\n\t\t_: 'phoneCall',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tp2p_allowed?: true,\n\t\t\tvideo?: true,\n\t\t}>,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tdate: number,\n\t\tadmin_id: number,\n\t\tparticipant_id: number,\n\t\tg_a_or_b: Uint8Array,\n\t\tkey_fingerprint: string,\n\t\tprotocol: PhoneCallProtocol,\n\t\tconnections: Array<PhoneConnection>,\n\t\tstart_date: number\n\t};\n\n\texport type phoneCallDiscarded = {\n\t\t_: 'phoneCallDiscarded',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tneed_rating?: true,\n\t\t\tneed_debug?: true,\n\t\t\tvideo?: true,\n\t\t}>,\n\t\tid: string,\n\t\treason?: PhoneCallDiscardReason,\n\t\tduration?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PhoneConnection\n */\nexport type PhoneConnection = PhoneConnection.phoneConnection | PhoneConnection.phoneConnectionWebrtc;\n\nexport namespace PhoneConnection {\n  export type phoneConnection = {\n\t\t_: 'phoneConnection',\n\t\tid: string,\n\t\tip: string,\n\t\tipv6: string,\n\t\tport: number,\n\t\tpeer_tag: Uint8Array\n\t};\n\n\texport type phoneConnectionWebrtc = {\n\t\t_: 'phoneConnectionWebrtc',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tturn?: true,\n\t\t\tstun?: true,\n\t\t}>,\n\t\tid: string,\n\t\tip: string,\n\t\tipv6: string,\n\t\tport: number,\n\t\tusername: string,\n\t\tpassword: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PhoneCallProtocol\n */\nexport type PhoneCallProtocol = PhoneCallProtocol.phoneCallProtocol;\n\nexport namespace PhoneCallProtocol {\n  export type phoneCallProtocol = {\n\t\t_: 'phoneCallProtocol',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tudp_p2p?: true,\n\t\t\tudp_reflector?: true,\n\t\t}>,\n\t\tmin_layer: number,\n\t\tmax_layer: number,\n\t\tlibrary_versions: Array<string>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/phone.PhoneCall\n */\nexport type PhonePhoneCall = PhonePhoneCall.phonePhoneCall;\n\nexport namespace PhonePhoneCall {\n  export type phonePhoneCall = {\n\t\t_: 'phone.phoneCall',\n\t\tphone_call: PhoneCall,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/upload.CdnFile\n */\nexport type UploadCdnFile = UploadCdnFile.uploadCdnFileReuploadNeeded | UploadCdnFile.uploadCdnFile;\n\nexport namespace UploadCdnFile {\n  export type uploadCdnFileReuploadNeeded = {\n\t\t_: 'upload.cdnFileReuploadNeeded',\n\t\trequest_token: Uint8Array\n\t};\n\n\texport type uploadCdnFile = {\n\t\t_: 'upload.cdnFile',\n\t\tbytes: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/CdnPublicKey\n */\nexport type CdnPublicKey = CdnPublicKey.cdnPublicKey;\n\nexport namespace CdnPublicKey {\n  export type cdnPublicKey = {\n\t\t_: 'cdnPublicKey',\n\t\tdc_id: number,\n\t\tpublic_key: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/CdnConfig\n */\nexport type CdnConfig = CdnConfig.cdnConfig;\n\nexport namespace CdnConfig {\n  export type cdnConfig = {\n\t\t_: 'cdnConfig',\n\t\tpublic_keys: Array<CdnPublicKey>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/LangPackString\n */\nexport type LangPackString = LangPackString.langPackString | LangPackString.langPackStringPluralized | LangPackString.langPackStringDeleted;\n\nexport namespace LangPackString {\n  export type langPackString = {\n\t\t_: 'langPackString',\n\t\tkey: string,\n\t\tvalue: string\n\t};\n\n\texport type langPackStringPluralized = {\n\t\t_: 'langPackStringPluralized',\n\t\tflags?: number,\n\t\tkey: string,\n\t\tzero_value?: string,\n\t\tone_value?: string,\n\t\ttwo_value?: string,\n\t\tfew_value?: string,\n\t\tmany_value?: string,\n\t\tother_value: string\n\t};\n\n\texport type langPackStringDeleted = {\n\t\t_: 'langPackStringDeleted',\n\t\tkey: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/LangPackDifference\n */\nexport type LangPackDifference = LangPackDifference.langPackDifference;\n\nexport namespace LangPackDifference {\n  export type langPackDifference = {\n\t\t_: 'langPackDifference',\n\t\tlang_code: string,\n\t\tfrom_version: number,\n\t\tversion: number,\n\t\tstrings: Array<LangPackString>,\n\t\tlocal?: boolean,\n\t\tappVersion?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/LangPackLanguage\n */\nexport type LangPackLanguage = LangPackLanguage.langPackLanguage;\n\nexport namespace LangPackLanguage {\n  export type langPackLanguage = {\n\t\t_: 'langPackLanguage',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tofficial?: true,\n\t\t\trtl?: true,\n\t\t\tbeta?: true,\n\t\t}>,\n\t\tname: string,\n\t\tnative_name: string,\n\t\tlang_code: string,\n\t\tbase_lang_code?: string,\n\t\tplural_code: string,\n\t\tstrings_count: number,\n\t\ttranslated_count: number,\n\t\ttranslations_url: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChannelAdminLogEventAction\n */\nexport type ChannelAdminLogEventAction = ChannelAdminLogEventAction.channelAdminLogEventActionChangeTitle | ChannelAdminLogEventAction.channelAdminLogEventActionChangeAbout | ChannelAdminLogEventAction.channelAdminLogEventActionChangeUsername | ChannelAdminLogEventAction.channelAdminLogEventActionChangePhoto | ChannelAdminLogEventAction.channelAdminLogEventActionToggleInvites | ChannelAdminLogEventAction.channelAdminLogEventActionToggleSignatures | ChannelAdminLogEventAction.channelAdminLogEventActionUpdatePinned | ChannelAdminLogEventAction.channelAdminLogEventActionEditMessage | ChannelAdminLogEventAction.channelAdminLogEventActionDeleteMessage | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantJoin | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantLeave | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantInvite | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantToggleBan | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantToggleAdmin | ChannelAdminLogEventAction.channelAdminLogEventActionChangeStickerSet | ChannelAdminLogEventAction.channelAdminLogEventActionTogglePreHistoryHidden | ChannelAdminLogEventAction.channelAdminLogEventActionDefaultBannedRights | ChannelAdminLogEventAction.channelAdminLogEventActionStopPoll | ChannelAdminLogEventAction.channelAdminLogEventActionChangeLinkedChat | ChannelAdminLogEventAction.channelAdminLogEventActionChangeLocation | ChannelAdminLogEventAction.channelAdminLogEventActionToggleSlowMode | ChannelAdminLogEventAction.channelAdminLogEventActionStartGroupCall | ChannelAdminLogEventAction.channelAdminLogEventActionDiscardGroupCall | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantMute | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantUnmute | ChannelAdminLogEventAction.channelAdminLogEventActionToggleGroupCallSetting | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantJoinByInvite | ChannelAdminLogEventAction.channelAdminLogEventActionExportedInviteDelete | ChannelAdminLogEventAction.channelAdminLogEventActionExportedInviteRevoke | ChannelAdminLogEventAction.channelAdminLogEventActionExportedInviteEdit | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantVolume | ChannelAdminLogEventAction.channelAdminLogEventActionChangeHistoryTTL;\n\nexport namespace ChannelAdminLogEventAction {\n  export type channelAdminLogEventActionChangeTitle = {\n\t\t_: 'channelAdminLogEventActionChangeTitle',\n\t\tprev_value: string,\n\t\tnew_value: string\n\t};\n\n\texport type channelAdminLogEventActionChangeAbout = {\n\t\t_: 'channelAdminLogEventActionChangeAbout',\n\t\tprev_value: string,\n\t\tnew_value: string\n\t};\n\n\texport type channelAdminLogEventActionChangeUsername = {\n\t\t_: 'channelAdminLogEventActionChangeUsername',\n\t\tprev_value: string,\n\t\tnew_value: string\n\t};\n\n\texport type channelAdminLogEventActionChangePhoto = {\n\t\t_: 'channelAdminLogEventActionChangePhoto',\n\t\tprev_photo: Photo,\n\t\tnew_photo: Photo\n\t};\n\n\texport type channelAdminLogEventActionToggleInvites = {\n\t\t_: 'channelAdminLogEventActionToggleInvites',\n\t\tnew_value: boolean\n\t};\n\n\texport type channelAdminLogEventActionToggleSignatures = {\n\t\t_: 'channelAdminLogEventActionToggleSignatures',\n\t\tnew_value: boolean\n\t};\n\n\texport type channelAdminLogEventActionUpdatePinned = {\n\t\t_: 'channelAdminLogEventActionUpdatePinned',\n\t\tmessage: Message\n\t};\n\n\texport type channelAdminLogEventActionEditMessage = {\n\t\t_: 'channelAdminLogEventActionEditMessage',\n\t\tprev_message: Message,\n\t\tnew_message: Message\n\t};\n\n\texport type channelAdminLogEventActionDeleteMessage = {\n\t\t_: 'channelAdminLogEventActionDeleteMessage',\n\t\tmessage: Message\n\t};\n\n\texport type channelAdminLogEventActionParticipantJoin = {\n\t\t_: 'channelAdminLogEventActionParticipantJoin'\n\t};\n\n\texport type channelAdminLogEventActionParticipantLeave = {\n\t\t_: 'channelAdminLogEventActionParticipantLeave'\n\t};\n\n\texport type channelAdminLogEventActionParticipantInvite = {\n\t\t_: 'channelAdminLogEventActionParticipantInvite',\n\t\tparticipant: ChannelParticipant\n\t};\n\n\texport type channelAdminLogEventActionParticipantToggleBan = {\n\t\t_: 'channelAdminLogEventActionParticipantToggleBan',\n\t\tprev_participant: ChannelParticipant,\n\t\tnew_participant: ChannelParticipant\n\t};\n\n\texport type channelAdminLogEventActionParticipantToggleAdmin = {\n\t\t_: 'channelAdminLogEventActionParticipantToggleAdmin',\n\t\tprev_participant: ChannelParticipant,\n\t\tnew_participant: ChannelParticipant\n\t};\n\n\texport type channelAdminLogEventActionChangeStickerSet = {\n\t\t_: 'channelAdminLogEventActionChangeStickerSet',\n\t\tprev_stickerset: InputStickerSet,\n\t\tnew_stickerset: InputStickerSet\n\t};\n\n\texport type channelAdminLogEventActionTogglePreHistoryHidden = {\n\t\t_: 'channelAdminLogEventActionTogglePreHistoryHidden',\n\t\tnew_value: boolean\n\t};\n\n\texport type channelAdminLogEventActionDefaultBannedRights = {\n\t\t_: 'channelAdminLogEventActionDefaultBannedRights',\n\t\tprev_banned_rights: ChatBannedRights,\n\t\tnew_banned_rights: ChatBannedRights\n\t};\n\n\texport type channelAdminLogEventActionStopPoll = {\n\t\t_: 'channelAdminLogEventActionStopPoll',\n\t\tmessage: Message\n\t};\n\n\texport type channelAdminLogEventActionChangeLinkedChat = {\n\t\t_: 'channelAdminLogEventActionChangeLinkedChat',\n\t\tprev_value: number,\n\t\tnew_value: number\n\t};\n\n\texport type channelAdminLogEventActionChangeLocation = {\n\t\t_: 'channelAdminLogEventActionChangeLocation',\n\t\tprev_value: ChannelLocation,\n\t\tnew_value: ChannelLocation\n\t};\n\n\texport type channelAdminLogEventActionToggleSlowMode = {\n\t\t_: 'channelAdminLogEventActionToggleSlowMode',\n\t\tprev_value: number,\n\t\tnew_value: number\n\t};\n\n\texport type channelAdminLogEventActionStartGroupCall = {\n\t\t_: 'channelAdminLogEventActionStartGroupCall',\n\t\tcall: InputGroupCall\n\t};\n\n\texport type channelAdminLogEventActionDiscardGroupCall = {\n\t\t_: 'channelAdminLogEventActionDiscardGroupCall',\n\t\tcall: InputGroupCall\n\t};\n\n\texport type channelAdminLogEventActionParticipantMute = {\n\t\t_: 'channelAdminLogEventActionParticipantMute',\n\t\tparticipant: GroupCallParticipant\n\t};\n\n\texport type channelAdminLogEventActionParticipantUnmute = {\n\t\t_: 'channelAdminLogEventActionParticipantUnmute',\n\t\tparticipant: GroupCallParticipant\n\t};\n\n\texport type channelAdminLogEventActionToggleGroupCallSetting = {\n\t\t_: 'channelAdminLogEventActionToggleGroupCallSetting',\n\t\tjoin_muted: boolean\n\t};\n\n\texport type channelAdminLogEventActionParticipantJoinByInvite = {\n\t\t_: 'channelAdminLogEventActionParticipantJoinByInvite',\n\t\tinvite: ExportedChatInvite\n\t};\n\n\texport type channelAdminLogEventActionExportedInviteDelete = {\n\t\t_: 'channelAdminLogEventActionExportedInviteDelete',\n\t\tinvite: ExportedChatInvite\n\t};\n\n\texport type channelAdminLogEventActionExportedInviteRevoke = {\n\t\t_: 'channelAdminLogEventActionExportedInviteRevoke',\n\t\tinvite: ExportedChatInvite\n\t};\n\n\texport type channelAdminLogEventActionExportedInviteEdit = {\n\t\t_: 'channelAdminLogEventActionExportedInviteEdit',\n\t\tprev_invite: ExportedChatInvite,\n\t\tnew_invite: ExportedChatInvite\n\t};\n\n\texport type channelAdminLogEventActionParticipantVolume = {\n\t\t_: 'channelAdminLogEventActionParticipantVolume',\n\t\tparticipant: GroupCallParticipant\n\t};\n\n\texport type channelAdminLogEventActionChangeHistoryTTL = {\n\t\t_: 'channelAdminLogEventActionChangeHistoryTTL',\n\t\tprev_value: number,\n\t\tnew_value: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChannelAdminLogEvent\n */\nexport type ChannelAdminLogEvent = ChannelAdminLogEvent.channelAdminLogEvent;\n\nexport namespace ChannelAdminLogEvent {\n  export type channelAdminLogEvent = {\n\t\t_: 'channelAdminLogEvent',\n\t\tid: string,\n\t\tdate: number,\n\t\tuser_id: number,\n\t\taction: ChannelAdminLogEventAction\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/channels.AdminLogResults\n */\nexport type ChannelsAdminLogResults = ChannelsAdminLogResults.channelsAdminLogResults;\n\nexport namespace ChannelsAdminLogResults {\n  export type channelsAdminLogResults = {\n\t\t_: 'channels.adminLogResults',\n\t\tevents: Array<ChannelAdminLogEvent>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChannelAdminLogEventsFilter\n */\nexport type ChannelAdminLogEventsFilter = ChannelAdminLogEventsFilter.channelAdminLogEventsFilter;\n\nexport namespace ChannelAdminLogEventsFilter {\n  export type channelAdminLogEventsFilter = {\n\t\t_: 'channelAdminLogEventsFilter',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tjoin?: true,\n\t\t\tleave?: true,\n\t\t\tinvite?: true,\n\t\t\tban?: true,\n\t\t\tunban?: true,\n\t\t\tkick?: true,\n\t\t\tunkick?: true,\n\t\t\tpromote?: true,\n\t\t\tdemote?: true,\n\t\t\tinfo?: true,\n\t\t\tsettings?: true,\n\t\t\tpinned?: true,\n\t\t\tedit?: true,\n\t\t\tdelete?: true,\n\t\t\tgroup_call?: true,\n\t\t\tinvites?: true,\n\t\t}>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PopularContact\n */\nexport type PopularContact = PopularContact.popularContact;\n\nexport namespace PopularContact {\n  export type popularContact = {\n\t\t_: 'popularContact',\n\t\tclient_id: string,\n\t\timporters: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.FavedStickers\n */\nexport type MessagesFavedStickers = MessagesFavedStickers.messagesFavedStickersNotModified | MessagesFavedStickers.messagesFavedStickers;\n\nexport namespace MessagesFavedStickers {\n  export type messagesFavedStickersNotModified = {\n\t\t_: 'messages.favedStickersNotModified'\n\t};\n\n\texport type messagesFavedStickers = {\n\t\t_: 'messages.favedStickers',\n\t\thash: number,\n\t\tpacks: Array<StickerPack>,\n\t\tstickers: Array<Document>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/RecentMeUrl\n */\nexport type RecentMeUrl = RecentMeUrl.recentMeUrlUnknown | RecentMeUrl.recentMeUrlUser | RecentMeUrl.recentMeUrlChat | RecentMeUrl.recentMeUrlChatInvite | RecentMeUrl.recentMeUrlStickerSet;\n\nexport namespace RecentMeUrl {\n  export type recentMeUrlUnknown = {\n\t\t_: 'recentMeUrlUnknown',\n\t\turl: string\n\t};\n\n\texport type recentMeUrlUser = {\n\t\t_: 'recentMeUrlUser',\n\t\turl: string,\n\t\tuser_id: number\n\t};\n\n\texport type recentMeUrlChat = {\n\t\t_: 'recentMeUrlChat',\n\t\turl: string,\n\t\tchat_id: number\n\t};\n\n\texport type recentMeUrlChatInvite = {\n\t\t_: 'recentMeUrlChatInvite',\n\t\turl: string,\n\t\tchat_invite: ChatInvite\n\t};\n\n\texport type recentMeUrlStickerSet = {\n\t\t_: 'recentMeUrlStickerSet',\n\t\turl: string,\n\t\tset: StickerSetCovered\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.RecentMeUrls\n */\nexport type HelpRecentMeUrls = HelpRecentMeUrls.helpRecentMeUrls;\n\nexport namespace HelpRecentMeUrls {\n  export type helpRecentMeUrls = {\n\t\t_: 'help.recentMeUrls',\n\t\turls: Array<RecentMeUrl>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputSingleMedia\n */\nexport type InputSingleMedia = InputSingleMedia.inputSingleMedia;\n\nexport namespace InputSingleMedia {\n  export type inputSingleMedia = {\n\t\t_: 'inputSingleMedia',\n\t\tflags?: number,\n\t\tmedia: InputMedia,\n\t\trandom_id: string,\n\t\tmessage: string,\n\t\tentities?: Array<MessageEntity>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/WebAuthorization\n */\nexport type WebAuthorization = WebAuthorization.webAuthorization;\n\nexport namespace WebAuthorization {\n  export type webAuthorization = {\n\t\t_: 'webAuthorization',\n\t\thash: string,\n\t\tbot_id: number,\n\t\tdomain: string,\n\t\tbrowser: string,\n\t\tplatform: string,\n\t\tdate_created: number,\n\t\tdate_active: number,\n\t\tip: string,\n\t\tregion: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.WebAuthorizations\n */\nexport type AccountWebAuthorizations = AccountWebAuthorizations.accountWebAuthorizations;\n\nexport namespace AccountWebAuthorizations {\n  export type accountWebAuthorizations = {\n\t\t_: 'account.webAuthorizations',\n\t\tauthorizations: Array<WebAuthorization>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputMessage\n */\nexport type InputMessage = InputMessage.inputMessageID | InputMessage.inputMessageReplyTo | InputMessage.inputMessagePinned | InputMessage.inputMessageCallbackQuery;\n\nexport namespace InputMessage {\n  export type inputMessageID = {\n\t\t_: 'inputMessageID',\n\t\tid: number\n\t};\n\n\texport type inputMessageReplyTo = {\n\t\t_: 'inputMessageReplyTo',\n\t\tid: number\n\t};\n\n\texport type inputMessagePinned = {\n\t\t_: 'inputMessagePinned'\n\t};\n\n\texport type inputMessageCallbackQuery = {\n\t\t_: 'inputMessageCallbackQuery',\n\t\tid: number,\n\t\tquery_id: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputDialogPeer\n */\nexport type InputDialogPeer = InputDialogPeer.inputDialogPeer | InputDialogPeer.inputDialogPeerFolder;\n\nexport namespace InputDialogPeer {\n  export type inputDialogPeer = {\n\t\t_: 'inputDialogPeer',\n\t\tpeer: InputPeer\n\t};\n\n\texport type inputDialogPeerFolder = {\n\t\t_: 'inputDialogPeerFolder',\n\t\tfolder_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/DialogPeer\n */\nexport type DialogPeer = DialogPeer.dialogPeer | DialogPeer.dialogPeerFolder;\n\nexport namespace DialogPeer {\n  export type dialogPeer = {\n\t\t_: 'dialogPeer',\n\t\tpeer: Peer\n\t};\n\n\texport type dialogPeerFolder = {\n\t\t_: 'dialogPeerFolder',\n\t\tfolder_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.FoundStickerSets\n */\nexport type MessagesFoundStickerSets = MessagesFoundStickerSets.messagesFoundStickerSetsNotModified | MessagesFoundStickerSets.messagesFoundStickerSets;\n\nexport namespace MessagesFoundStickerSets {\n  export type messagesFoundStickerSetsNotModified = {\n\t\t_: 'messages.foundStickerSetsNotModified'\n\t};\n\n\texport type messagesFoundStickerSets = {\n\t\t_: 'messages.foundStickerSets',\n\t\thash: number,\n\t\tsets: Array<StickerSetCovered>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/FileHash\n */\nexport type FileHash = FileHash.fileHash;\n\nexport namespace FileHash {\n  export type fileHash = {\n\t\t_: 'fileHash',\n\t\toffset: number,\n\t\tlimit: number,\n\t\thash: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputClientProxy\n */\nexport type InputClientProxy = InputClientProxy.inputClientProxy;\n\nexport namespace InputClientProxy {\n  export type inputClientProxy = {\n\t\t_: 'inputClientProxy',\n\t\taddress: string,\n\t\tport: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.TermsOfServiceUpdate\n */\nexport type HelpTermsOfServiceUpdate = HelpTermsOfServiceUpdate.helpTermsOfServiceUpdateEmpty | HelpTermsOfServiceUpdate.helpTermsOfServiceUpdate;\n\nexport namespace HelpTermsOfServiceUpdate {\n  export type helpTermsOfServiceUpdateEmpty = {\n\t\t_: 'help.termsOfServiceUpdateEmpty',\n\t\texpires: number\n\t};\n\n\texport type helpTermsOfServiceUpdate = {\n\t\t_: 'help.termsOfServiceUpdate',\n\t\texpires: number,\n\t\tterms_of_service: HelpTermsOfService\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputSecureFile\n */\nexport type InputSecureFile = InputSecureFile.inputSecureFileUploaded | InputSecureFile.inputSecureFile;\n\nexport namespace InputSecureFile {\n  export type inputSecureFileUploaded = {\n\t\t_: 'inputSecureFileUploaded',\n\t\tid: string,\n\t\tparts: number,\n\t\tmd5_checksum: string,\n\t\tfile_hash: Uint8Array,\n\t\tsecret: Uint8Array\n\t};\n\n\texport type inputSecureFile = {\n\t\t_: 'inputSecureFile',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureFile\n */\nexport type SecureFile = SecureFile.secureFileEmpty | SecureFile.secureFile;\n\nexport namespace SecureFile {\n  export type secureFileEmpty = {\n\t\t_: 'secureFileEmpty'\n\t};\n\n\texport type secureFile = {\n\t\t_: 'secureFile',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tsize: number,\n\t\tdc_id: number,\n\t\tdate: number,\n\t\tfile_hash: Uint8Array,\n\t\tsecret: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureData\n */\nexport type SecureData = SecureData.secureData;\n\nexport namespace SecureData {\n  export type secureData = {\n\t\t_: 'secureData',\n\t\tdata: Uint8Array,\n\t\tdata_hash: Uint8Array,\n\t\tsecret: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecurePlainData\n */\nexport type SecurePlainData = SecurePlainData.securePlainPhone | SecurePlainData.securePlainEmail;\n\nexport namespace SecurePlainData {\n  export type securePlainPhone = {\n\t\t_: 'securePlainPhone',\n\t\tphone: string\n\t};\n\n\texport type securePlainEmail = {\n\t\t_: 'securePlainEmail',\n\t\temail: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureValueType\n */\nexport type SecureValueType = SecureValueType.secureValueTypePersonalDetails | SecureValueType.secureValueTypePassport | SecureValueType.secureValueTypeDriverLicense | SecureValueType.secureValueTypeIdentityCard | SecureValueType.secureValueTypeInternalPassport | SecureValueType.secureValueTypeAddress | SecureValueType.secureValueTypeUtilityBill | SecureValueType.secureValueTypeBankStatement | SecureValueType.secureValueTypeRentalAgreement | SecureValueType.secureValueTypePassportRegistration | SecureValueType.secureValueTypeTemporaryRegistration | SecureValueType.secureValueTypePhone | SecureValueType.secureValueTypeEmail;\n\nexport namespace SecureValueType {\n  export type secureValueTypePersonalDetails = {\n\t\t_: 'secureValueTypePersonalDetails'\n\t};\n\n\texport type secureValueTypePassport = {\n\t\t_: 'secureValueTypePassport'\n\t};\n\n\texport type secureValueTypeDriverLicense = {\n\t\t_: 'secureValueTypeDriverLicense'\n\t};\n\n\texport type secureValueTypeIdentityCard = {\n\t\t_: 'secureValueTypeIdentityCard'\n\t};\n\n\texport type secureValueTypeInternalPassport = {\n\t\t_: 'secureValueTypeInternalPassport'\n\t};\n\n\texport type secureValueTypeAddress = {\n\t\t_: 'secureValueTypeAddress'\n\t};\n\n\texport type secureValueTypeUtilityBill = {\n\t\t_: 'secureValueTypeUtilityBill'\n\t};\n\n\texport type secureValueTypeBankStatement = {\n\t\t_: 'secureValueTypeBankStatement'\n\t};\n\n\texport type secureValueTypeRentalAgreement = {\n\t\t_: 'secureValueTypeRentalAgreement'\n\t};\n\n\texport type secureValueTypePassportRegistration = {\n\t\t_: 'secureValueTypePassportRegistration'\n\t};\n\n\texport type secureValueTypeTemporaryRegistration = {\n\t\t_: 'secureValueTypeTemporaryRegistration'\n\t};\n\n\texport type secureValueTypePhone = {\n\t\t_: 'secureValueTypePhone'\n\t};\n\n\texport type secureValueTypeEmail = {\n\t\t_: 'secureValueTypeEmail'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureValue\n */\nexport type SecureValue = SecureValue.secureValue;\n\nexport namespace SecureValue {\n  export type secureValue = {\n\t\t_: 'secureValue',\n\t\tflags?: number,\n\t\ttype: SecureValueType,\n\t\tdata?: SecureData,\n\t\tfront_side?: SecureFile,\n\t\treverse_side?: SecureFile,\n\t\tselfie?: SecureFile,\n\t\ttranslation?: Array<SecureFile>,\n\t\tfiles?: Array<SecureFile>,\n\t\tplain_data?: SecurePlainData,\n\t\thash: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputSecureValue\n */\nexport type InputSecureValue = InputSecureValue.inputSecureValue;\n\nexport namespace InputSecureValue {\n  export type inputSecureValue = {\n\t\t_: 'inputSecureValue',\n\t\tflags?: number,\n\t\ttype: SecureValueType,\n\t\tdata?: SecureData,\n\t\tfront_side?: InputSecureFile,\n\t\treverse_side?: InputSecureFile,\n\t\tselfie?: InputSecureFile,\n\t\ttranslation?: Array<InputSecureFile>,\n\t\tfiles?: Array<InputSecureFile>,\n\t\tplain_data?: SecurePlainData\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureValueHash\n */\nexport type SecureValueHash = SecureValueHash.secureValueHash;\n\nexport namespace SecureValueHash {\n  export type secureValueHash = {\n\t\t_: 'secureValueHash',\n\t\ttype: SecureValueType,\n\t\thash: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureValueError\n */\nexport type SecureValueError = SecureValueError.secureValueErrorData | SecureValueError.secureValueErrorFrontSide | SecureValueError.secureValueErrorReverseSide | SecureValueError.secureValueErrorSelfie | SecureValueError.secureValueErrorFile | SecureValueError.secureValueErrorFiles | SecureValueError.secureValueError | SecureValueError.secureValueErrorTranslationFile | SecureValueError.secureValueErrorTranslationFiles;\n\nexport namespace SecureValueError {\n  export type secureValueErrorData = {\n\t\t_: 'secureValueErrorData',\n\t\ttype: SecureValueType,\n\t\tdata_hash: Uint8Array,\n\t\tfield: string,\n\t\ttext: string\n\t};\n\n\texport type secureValueErrorFrontSide = {\n\t\t_: 'secureValueErrorFrontSide',\n\t\ttype: SecureValueType,\n\t\tfile_hash: Uint8Array,\n\t\ttext: string\n\t};\n\n\texport type secureValueErrorReverseSide = {\n\t\t_: 'secureValueErrorReverseSide',\n\t\ttype: SecureValueType,\n\t\tfile_hash: Uint8Array,\n\t\ttext: string\n\t};\n\n\texport type secureValueErrorSelfie = {\n\t\t_: 'secureValueErrorSelfie',\n\t\ttype: SecureValueType,\n\t\tfile_hash: Uint8Array,\n\t\ttext: string\n\t};\n\n\texport type secureValueErrorFile = {\n\t\t_: 'secureValueErrorFile',\n\t\ttype: SecureValueType,\n\t\tfile_hash: Uint8Array,\n\t\ttext: string\n\t};\n\n\texport type secureValueErrorFiles = {\n\t\t_: 'secureValueErrorFiles',\n\t\ttype: SecureValueType,\n\t\tfile_hash: Array<Uint8Array>,\n\t\ttext: string\n\t};\n\n\texport type secureValueError = {\n\t\t_: 'secureValueError',\n\t\ttype: SecureValueType,\n\t\thash: Uint8Array,\n\t\ttext: string\n\t};\n\n\texport type secureValueErrorTranslationFile = {\n\t\t_: 'secureValueErrorTranslationFile',\n\t\ttype: SecureValueType,\n\t\tfile_hash: Uint8Array,\n\t\ttext: string\n\t};\n\n\texport type secureValueErrorTranslationFiles = {\n\t\t_: 'secureValueErrorTranslationFiles',\n\t\ttype: SecureValueType,\n\t\tfile_hash: Array<Uint8Array>,\n\t\ttext: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureCredentialsEncrypted\n */\nexport type SecureCredentialsEncrypted = SecureCredentialsEncrypted.secureCredentialsEncrypted;\n\nexport namespace SecureCredentialsEncrypted {\n  export type secureCredentialsEncrypted = {\n\t\t_: 'secureCredentialsEncrypted',\n\t\tdata: Uint8Array,\n\t\thash: Uint8Array,\n\t\tsecret: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.AuthorizationForm\n */\nexport type AccountAuthorizationForm = AccountAuthorizationForm.accountAuthorizationForm;\n\nexport namespace AccountAuthorizationForm {\n  export type accountAuthorizationForm = {\n\t\t_: 'account.authorizationForm',\n\t\tflags?: number,\n\t\trequired_types: Array<SecureRequiredType>,\n\t\tvalues: Array<SecureValue>,\n\t\terrors: Array<SecureValueError>,\n\t\tusers: Array<User>,\n\t\tprivacy_policy_url?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.SentEmailCode\n */\nexport type AccountSentEmailCode = AccountSentEmailCode.accountSentEmailCode;\n\nexport namespace AccountSentEmailCode {\n  export type accountSentEmailCode = {\n\t\t_: 'account.sentEmailCode',\n\t\temail_pattern: string,\n\t\tlength: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.DeepLinkInfo\n */\nexport type HelpDeepLinkInfo = HelpDeepLinkInfo.helpDeepLinkInfoEmpty | HelpDeepLinkInfo.helpDeepLinkInfo;\n\nexport namespace HelpDeepLinkInfo {\n  export type helpDeepLinkInfoEmpty = {\n\t\t_: 'help.deepLinkInfoEmpty'\n\t};\n\n\texport type helpDeepLinkInfo = {\n\t\t_: 'help.deepLinkInfo',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tupdate_app?: true,\n\t\t}>,\n\t\tmessage: string,\n\t\tentities?: Array<MessageEntity>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SavedContact\n */\nexport type SavedContact = SavedContact.savedPhoneContact;\n\nexport namespace SavedContact {\n  export type savedPhoneContact = {\n\t\t_: 'savedPhoneContact',\n\t\tphone: string,\n\t\tfirst_name: string,\n\t\tlast_name: string,\n\t\tdate: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.Takeout\n */\nexport type AccountTakeout = AccountTakeout.accountTakeout;\n\nexport namespace AccountTakeout {\n  export type accountTakeout = {\n\t\t_: 'account.takeout',\n\t\tid: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PasswordKdfAlgo\n */\nexport type PasswordKdfAlgo = PasswordKdfAlgo.passwordKdfAlgoUnknown | PasswordKdfAlgo.passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow;\n\nexport namespace PasswordKdfAlgo {\n  export type passwordKdfAlgoUnknown = {\n\t\t_: 'passwordKdfAlgoUnknown'\n\t};\n\n\texport type passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow = {\n\t\t_: 'passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow',\n\t\tsalt1: Uint8Array,\n\t\tsalt2: Uint8Array,\n\t\tg: number,\n\t\tp: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecurePasswordKdfAlgo\n */\nexport type SecurePasswordKdfAlgo = SecurePasswordKdfAlgo.securePasswordKdfAlgoUnknown | SecurePasswordKdfAlgo.securePasswordKdfAlgoPBKDF2HMACSHA512iter100000 | SecurePasswordKdfAlgo.securePasswordKdfAlgoSHA512;\n\nexport namespace SecurePasswordKdfAlgo {\n  export type securePasswordKdfAlgoUnknown = {\n\t\t_: 'securePasswordKdfAlgoUnknown'\n\t};\n\n\texport type securePasswordKdfAlgoPBKDF2HMACSHA512iter100000 = {\n\t\t_: 'securePasswordKdfAlgoPBKDF2HMACSHA512iter100000',\n\t\tsalt: Uint8Array\n\t};\n\n\texport type securePasswordKdfAlgoSHA512 = {\n\t\t_: 'securePasswordKdfAlgoSHA512',\n\t\tsalt: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureSecretSettings\n */\nexport type SecureSecretSettings = SecureSecretSettings.secureSecretSettings;\n\nexport namespace SecureSecretSettings {\n  export type secureSecretSettings = {\n\t\t_: 'secureSecretSettings',\n\t\tsecure_algo: SecurePasswordKdfAlgo,\n\t\tsecure_secret: Uint8Array,\n\t\tsecure_secret_id: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputCheckPasswordSRP\n */\nexport type InputCheckPasswordSRP = InputCheckPasswordSRP.inputCheckPasswordEmpty | InputCheckPasswordSRP.inputCheckPasswordSRP;\n\nexport namespace InputCheckPasswordSRP {\n  export type inputCheckPasswordEmpty = {\n\t\t_: 'inputCheckPasswordEmpty'\n\t};\n\n\texport type inputCheckPasswordSRP = {\n\t\t_: 'inputCheckPasswordSRP',\n\t\tsrp_id: string,\n\t\tA: Uint8Array,\n\t\tM1: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureRequiredType\n */\nexport type SecureRequiredType = SecureRequiredType.secureRequiredType | SecureRequiredType.secureRequiredTypeOneOf;\n\nexport namespace SecureRequiredType {\n  export type secureRequiredType = {\n\t\t_: 'secureRequiredType',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tnative_names?: true,\n\t\t\tselfie_required?: true,\n\t\t\ttranslation_required?: true,\n\t\t}>,\n\t\ttype: SecureValueType\n\t};\n\n\texport type secureRequiredTypeOneOf = {\n\t\t_: 'secureRequiredTypeOneOf',\n\t\ttypes: Array<SecureRequiredType>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.PassportConfig\n */\nexport type HelpPassportConfig = HelpPassportConfig.helpPassportConfigNotModified | HelpPassportConfig.helpPassportConfig;\n\nexport namespace HelpPassportConfig {\n  export type helpPassportConfigNotModified = {\n\t\t_: 'help.passportConfigNotModified'\n\t};\n\n\texport type helpPassportConfig = {\n\t\t_: 'help.passportConfig',\n\t\thash: number,\n\t\tcountries_langs: DataJSON\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputAppEvent\n */\nexport type InputAppEvent = InputAppEvent.inputAppEvent;\n\nexport namespace InputAppEvent {\n  export type inputAppEvent = {\n\t\t_: 'inputAppEvent',\n\t\ttime: number,\n\t\ttype: string,\n\t\tpeer: string,\n\t\tdata: JSONValue\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/JSONObjectValue\n */\nexport type JSONObjectValue = JSONObjectValue.jsonObjectValue;\n\nexport namespace JSONObjectValue {\n  export type jsonObjectValue = {\n\t\t_: 'jsonObjectValue',\n\t\tkey: string,\n\t\tvalue: JSONValue\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/JSONValue\n */\nexport type JSONValue = JSONValue.jsonNull | JSONValue.jsonBool | JSONValue.jsonNumber | JSONValue.jsonString | JSONValue.jsonArray | JSONValue.jsonObject;\n\nexport namespace JSONValue {\n  export type jsonNull = {\n\t\t_: 'jsonNull'\n\t};\n\n\texport type jsonBool = {\n\t\t_: 'jsonBool',\n\t\tvalue: boolean\n\t};\n\n\texport type jsonNumber = {\n\t\t_: 'jsonNumber',\n\t\tvalue: number\n\t};\n\n\texport type jsonString = {\n\t\t_: 'jsonString',\n\t\tvalue: string\n\t};\n\n\texport type jsonArray = {\n\t\t_: 'jsonArray',\n\t\tvalue: Array<JSONValue>\n\t};\n\n\texport type jsonObject = {\n\t\t_: 'jsonObject',\n\t\tvalue: Array<JSONObjectValue>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PageTableCell\n */\nexport type PageTableCell = PageTableCell.pageTableCell;\n\nexport namespace PageTableCell {\n  export type pageTableCell = {\n\t\t_: 'pageTableCell',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\theader?: true,\n\t\t\talign_center?: true,\n\t\t\talign_right?: true,\n\t\t\tvalign_middle?: true,\n\t\t\tvalign_bottom?: true,\n\t\t}>,\n\t\ttext?: RichText,\n\t\tcolspan?: number,\n\t\trowspan?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PageTableRow\n */\nexport type PageTableRow = PageTableRow.pageTableRow;\n\nexport namespace PageTableRow {\n  export type pageTableRow = {\n\t\t_: 'pageTableRow',\n\t\tcells: Array<PageTableCell>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PageCaption\n */\nexport type PageCaption = PageCaption.pageCaption;\n\nexport namespace PageCaption {\n  export type pageCaption = {\n\t\t_: 'pageCaption',\n\t\ttext: RichText,\n\t\tcredit: RichText\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PageListItem\n */\nexport type PageListItem = PageListItem.pageListItemText | PageListItem.pageListItemBlocks;\n\nexport namespace PageListItem {\n  export type pageListItemText = {\n\t\t_: 'pageListItemText',\n\t\ttext: RichText\n\t};\n\n\texport type pageListItemBlocks = {\n\t\t_: 'pageListItemBlocks',\n\t\tblocks: Array<PageBlock>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PageListOrderedItem\n */\nexport type PageListOrderedItem = PageListOrderedItem.pageListOrderedItemText | PageListOrderedItem.pageListOrderedItemBlocks;\n\nexport namespace PageListOrderedItem {\n  export type pageListOrderedItemText = {\n\t\t_: 'pageListOrderedItemText',\n\t\tnum: string,\n\t\ttext: RichText\n\t};\n\n\texport type pageListOrderedItemBlocks = {\n\t\t_: 'pageListOrderedItemBlocks',\n\t\tnum: string,\n\t\tblocks: Array<PageBlock>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PageRelatedArticle\n */\nexport type PageRelatedArticle = PageRelatedArticle.pageRelatedArticle;\n\nexport namespace PageRelatedArticle {\n  export type pageRelatedArticle = {\n\t\t_: 'pageRelatedArticle',\n\t\tflags?: number,\n\t\turl: string,\n\t\twebpage_id: string,\n\t\ttitle?: string,\n\t\tdescription?: string,\n\t\tphoto_id?: string,\n\t\tauthor?: string,\n\t\tpublished_date?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Page\n */\nexport type Page = Page.page;\n\nexport namespace Page {\n  export type page = {\n\t\t_: 'page',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpart?: true,\n\t\t\trtl?: true,\n\t\t\tv2?: true,\n\t\t}>,\n\t\turl: string,\n\t\tblocks: Array<PageBlock>,\n\t\tphotos: Array<Photo>,\n\t\tdocuments: Array<Document>,\n\t\tviews?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.SupportName\n */\nexport type HelpSupportName = HelpSupportName.helpSupportName;\n\nexport namespace HelpSupportName {\n  export type helpSupportName = {\n\t\t_: 'help.supportName',\n\t\tname: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.UserInfo\n */\nexport type HelpUserInfo = HelpUserInfo.helpUserInfoEmpty | HelpUserInfo.helpUserInfo;\n\nexport namespace HelpUserInfo {\n  export type helpUserInfoEmpty = {\n\t\t_: 'help.userInfoEmpty'\n\t};\n\n\texport type helpUserInfo = {\n\t\t_: 'help.userInfo',\n\t\tmessage: string,\n\t\tentities: Array<MessageEntity>,\n\t\tauthor: string,\n\t\tdate: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PollAnswer\n */\nexport type PollAnswer = PollAnswer.pollAnswer;\n\nexport namespace PollAnswer {\n  export type pollAnswer = {\n\t\t_: 'pollAnswer',\n\t\ttext: string,\n\t\toption: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Poll\n */\nexport type Poll = Poll.poll;\n\nexport namespace Poll {\n  export type poll = {\n\t\t_: 'poll',\n\t\tid: string,\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tclosed?: true,\n\t\t\tpublic_voters?: true,\n\t\t\tmultiple_choice?: true,\n\t\t\tquiz?: true,\n\t\t}>,\n\t\tquestion: string,\n\t\tanswers: Array<PollAnswer>,\n\t\tclose_period?: number,\n\t\tclose_date?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PollAnswerVoters\n */\nexport type PollAnswerVoters = PollAnswerVoters.pollAnswerVoters;\n\nexport namespace PollAnswerVoters {\n  export type pollAnswerVoters = {\n\t\t_: 'pollAnswerVoters',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tchosen?: true,\n\t\t\tcorrect?: true,\n\t\t}>,\n\t\toption: Uint8Array,\n\t\tvoters: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PollResults\n */\nexport type PollResults = PollResults.pollResults;\n\nexport namespace PollResults {\n  export type pollResults = {\n\t\t_: 'pollResults',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tmin?: true,\n\t\t}>,\n\t\tresults?: Array<PollAnswerVoters>,\n\t\ttotal_voters?: number,\n\t\trecent_voters?: Array<number>,\n\t\tsolution?: string,\n\t\tsolution_entities?: Array<MessageEntity>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatOnlines\n */\nexport type ChatOnlines = ChatOnlines.chatOnlines;\n\nexport namespace ChatOnlines {\n  export type chatOnlines = {\n\t\t_: 'chatOnlines',\n\t\tonlines: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsURL\n */\nexport type StatsURL = StatsURL.statsURL;\n\nexport namespace StatsURL {\n  export type statsURL = {\n\t\t_: 'statsURL',\n\t\turl: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatAdminRights\n */\nexport type ChatAdminRights = ChatAdminRights.chatAdminRights;\n\nexport namespace ChatAdminRights {\n  export type chatAdminRights = {\n\t\t_: 'chatAdminRights',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tchange_info?: true,\n\t\t\tpost_messages?: true,\n\t\t\tedit_messages?: true,\n\t\t\tdelete_messages?: true,\n\t\t\tban_users?: true,\n\t\t\tinvite_users?: true,\n\t\t\tpin_messages?: true,\n\t\t\tadd_admins?: true,\n\t\t\tanonymous?: true,\n\t\t\tmanage_call?: true,\n\t\t\tother?: true,\n\t\t}>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatBannedRights\n */\nexport type ChatBannedRights = ChatBannedRights.chatBannedRights;\n\nexport namespace ChatBannedRights {\n  export type chatBannedRights = {\n\t\t_: 'chatBannedRights',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tview_messages?: true,\n\t\t\tsend_messages?: true,\n\t\t\tsend_media?: true,\n\t\t\tsend_stickers?: true,\n\t\t\tsend_gifs?: true,\n\t\t\tsend_games?: true,\n\t\t\tsend_inline?: true,\n\t\t\tembed_links?: true,\n\t\t\tsend_polls?: true,\n\t\t\tchange_info?: true,\n\t\t\tinvite_users?: true,\n\t\t\tpin_messages?: true,\n\t\t}>,\n\t\tuntil_date: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputWallPaper\n */\nexport type InputWallPaper = InputWallPaper.inputWallPaper | InputWallPaper.inputWallPaperSlug | InputWallPaper.inputWallPaperNoFile;\n\nexport namespace InputWallPaper {\n  export type inputWallPaper = {\n\t\t_: 'inputWallPaper',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputWallPaperSlug = {\n\t\t_: 'inputWallPaperSlug',\n\t\tslug: string\n\t};\n\n\texport type inputWallPaperNoFile = {\n\t\t_: 'inputWallPaperNoFile',\n\t\tid: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.WallPapers\n */\nexport type AccountWallPapers = AccountWallPapers.accountWallPapersNotModified | AccountWallPapers.accountWallPapers;\n\nexport namespace AccountWallPapers {\n  export type accountWallPapersNotModified = {\n\t\t_: 'account.wallPapersNotModified'\n\t};\n\n\texport type accountWallPapers = {\n\t\t_: 'account.wallPapers',\n\t\thash: number,\n\t\twallpapers: Array<WallPaper>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/CodeSettings\n */\nexport type CodeSettings = CodeSettings.codeSettings;\n\nexport namespace CodeSettings {\n  export type codeSettings = {\n\t\t_: 'codeSettings',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tallow_flashcall?: true,\n\t\t\tcurrent_number?: true,\n\t\t\tallow_app_hash?: true,\n\t\t}>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/WallPaperSettings\n */\nexport type WallPaperSettings = WallPaperSettings.wallPaperSettings;\n\nexport namespace WallPaperSettings {\n  export type wallPaperSettings = {\n\t\t_: 'wallPaperSettings',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tblur?: true,\n\t\t\tmotion?: true,\n\t\t}>,\n\t\tbackground_color?: number,\n\t\tsecond_background_color?: number,\n\t\tthird_background_color?: number,\n\t\tfourth_background_color?: number,\n\t\tintensity?: number,\n\t\trotation?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/AutoDownloadSettings\n */\nexport type AutoDownloadSettings = AutoDownloadSettings.autoDownloadSettings;\n\nexport namespace AutoDownloadSettings {\n  export type autoDownloadSettings = {\n\t\t_: 'autoDownloadSettings',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tdisabled?: true,\n\t\t\tvideo_preload_large?: true,\n\t\t\taudio_preload_next?: true,\n\t\t\tphonecalls_less_data?: true,\n\t\t}>,\n\t\tphoto_size_max: number,\n\t\tvideo_size_max: number,\n\t\tfile_size_max: number,\n\t\tvideo_upload_maxbitrate: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.AutoDownloadSettings\n */\nexport type AccountAutoDownloadSettings = AccountAutoDownloadSettings.accountAutoDownloadSettings;\n\nexport namespace AccountAutoDownloadSettings {\n  export type accountAutoDownloadSettings = {\n\t\t_: 'account.autoDownloadSettings',\n\t\tlow: AutoDownloadSettings,\n\t\tmedium: AutoDownloadSettings,\n\t\thigh: AutoDownloadSettings\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/EmojiKeyword\n */\nexport type EmojiKeyword = EmojiKeyword.emojiKeyword | EmojiKeyword.emojiKeywordDeleted;\n\nexport namespace EmojiKeyword {\n  export type emojiKeyword = {\n\t\t_: 'emojiKeyword',\n\t\tkeyword: string,\n\t\temoticons: Array<string>\n\t};\n\n\texport type emojiKeywordDeleted = {\n\t\t_: 'emojiKeywordDeleted',\n\t\tkeyword: string,\n\t\temoticons: Array<string>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/EmojiKeywordsDifference\n */\nexport type EmojiKeywordsDifference = EmojiKeywordsDifference.emojiKeywordsDifference;\n\nexport namespace EmojiKeywordsDifference {\n  export type emojiKeywordsDifference = {\n\t\t_: 'emojiKeywordsDifference',\n\t\tlang_code: string,\n\t\tfrom_version: number,\n\t\tversion: number,\n\t\tkeywords: Array<EmojiKeyword>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/EmojiURL\n */\nexport type EmojiURL = EmojiURL.emojiURL;\n\nexport namespace EmojiURL {\n  export type emojiURL = {\n\t\t_: 'emojiURL',\n\t\turl: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/EmojiLanguage\n */\nexport type EmojiLanguage = EmojiLanguage.emojiLanguage;\n\nexport namespace EmojiLanguage {\n  export type emojiLanguage = {\n\t\t_: 'emojiLanguage',\n\t\tlang_code: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Folder\n */\nexport type Folder = Folder.folder;\n\nexport namespace Folder {\n  export type folder = {\n\t\t_: 'folder',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tautofill_new_broadcasts?: true,\n\t\t\tautofill_public_groups?: true,\n\t\t\tautofill_new_correspondents?: true,\n\t\t}>,\n\t\tid: number,\n\t\ttitle: string,\n\t\tphoto?: ChatPhoto\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputFolderPeer\n */\nexport type InputFolderPeer = InputFolderPeer.inputFolderPeer;\n\nexport namespace InputFolderPeer {\n  export type inputFolderPeer = {\n\t\t_: 'inputFolderPeer',\n\t\tpeer: InputPeer,\n\t\tfolder_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/FolderPeer\n */\nexport type FolderPeer = FolderPeer.folderPeer;\n\nexport namespace FolderPeer {\n  export type folderPeer = {\n\t\t_: 'folderPeer',\n\t\tpeer: Peer,\n\t\tfolder_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.SearchCounter\n */\nexport type MessagesSearchCounter = MessagesSearchCounter.messagesSearchCounter;\n\nexport namespace MessagesSearchCounter {\n  export type messagesSearchCounter = {\n\t\t_: 'messages.searchCounter',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tinexact?: true,\n\t\t}>,\n\t\tfilter: MessagesFilter,\n\t\tcount: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/UrlAuthResult\n */\nexport type UrlAuthResult = UrlAuthResult.urlAuthResultRequest | UrlAuthResult.urlAuthResultAccepted | UrlAuthResult.urlAuthResultDefault;\n\nexport namespace UrlAuthResult {\n  export type urlAuthResultRequest = {\n\t\t_: 'urlAuthResultRequest',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\trequest_write_access?: true,\n\t\t}>,\n\t\tbot: User,\n\t\tdomain: string\n\t};\n\n\texport type urlAuthResultAccepted = {\n\t\t_: 'urlAuthResultAccepted',\n\t\turl: string\n\t};\n\n\texport type urlAuthResultDefault = {\n\t\t_: 'urlAuthResultDefault'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChannelLocation\n */\nexport type ChannelLocation = ChannelLocation.channelLocationEmpty | ChannelLocation.channelLocation;\n\nexport namespace ChannelLocation {\n  export type channelLocationEmpty = {\n\t\t_: 'channelLocationEmpty'\n\t};\n\n\texport type channelLocation = {\n\t\t_: 'channelLocation',\n\t\tgeo_point: GeoPoint,\n\t\taddress: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PeerLocated\n */\nexport type PeerLocated = PeerLocated.peerLocated | PeerLocated.peerSelfLocated;\n\nexport namespace PeerLocated {\n  export type peerLocated = {\n\t\t_: 'peerLocated',\n\t\tpeer: Peer,\n\t\texpires: number,\n\t\tdistance: number\n\t};\n\n\texport type peerSelfLocated = {\n\t\t_: 'peerSelfLocated',\n\t\texpires: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/RestrictionReason\n */\nexport type RestrictionReason = RestrictionReason.restrictionReason;\n\nexport namespace RestrictionReason {\n  export type restrictionReason = {\n\t\t_: 'restrictionReason',\n\t\tplatform: string,\n\t\treason: string,\n\t\ttext: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputTheme\n */\nexport type InputTheme = InputTheme.inputTheme | InputTheme.inputThemeSlug;\n\nexport namespace InputTheme {\n  export type inputTheme = {\n\t\t_: 'inputTheme',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputThemeSlug = {\n\t\t_: 'inputThemeSlug',\n\t\tslug: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Theme\n */\nexport type Theme = Theme.theme;\n\nexport namespace Theme {\n  export type theme = {\n\t\t_: 'theme',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcreator?: true,\n\t\t\tdefault?: true,\n\t\t}>,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tslug: string,\n\t\ttitle: string,\n\t\tdocument?: Document,\n\t\tsettings?: ThemeSettings,\n\t\tinstalls_count: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.Themes\n */\nexport type AccountThemes = AccountThemes.accountThemesNotModified | AccountThemes.accountThemes;\n\nexport namespace AccountThemes {\n  export type accountThemesNotModified = {\n\t\t_: 'account.themesNotModified'\n\t};\n\n\texport type accountThemes = {\n\t\t_: 'account.themes',\n\t\thash: number,\n\t\tthemes: Array<Theme>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/auth.LoginToken\n */\nexport type AuthLoginToken = AuthLoginToken.authLoginToken | AuthLoginToken.authLoginTokenMigrateTo | AuthLoginToken.authLoginTokenSuccess;\n\nexport namespace AuthLoginToken {\n  export type authLoginToken = {\n\t\t_: 'auth.loginToken',\n\t\texpires: number,\n\t\ttoken: Uint8Array\n\t};\n\n\texport type authLoginTokenMigrateTo = {\n\t\t_: 'auth.loginTokenMigrateTo',\n\t\tdc_id: number,\n\t\ttoken: Uint8Array\n\t};\n\n\texport type authLoginTokenSuccess = {\n\t\t_: 'auth.loginTokenSuccess',\n\t\tauthorization: AuthAuthorization\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.ContentSettings\n */\nexport type AccountContentSettings = AccountContentSettings.accountContentSettings;\n\nexport namespace AccountContentSettings {\n  export type accountContentSettings = {\n\t\t_: 'account.contentSettings',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tsensitive_enabled?: true,\n\t\t\tsensitive_can_change?: true,\n\t\t}>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.InactiveChats\n */\nexport type MessagesInactiveChats = MessagesInactiveChats.messagesInactiveChats;\n\nexport namespace MessagesInactiveChats {\n  export type messagesInactiveChats = {\n\t\t_: 'messages.inactiveChats',\n\t\tdates: Array<number>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/BaseTheme\n */\nexport type BaseTheme = BaseTheme.baseThemeClassic | BaseTheme.baseThemeDay | BaseTheme.baseThemeNight | BaseTheme.baseThemeTinted | BaseTheme.baseThemeArctic;\n\nexport namespace BaseTheme {\n  export type baseThemeClassic = {\n\t\t_: 'baseThemeClassic'\n\t};\n\n\texport type baseThemeDay = {\n\t\t_: 'baseThemeDay'\n\t};\n\n\texport type baseThemeNight = {\n\t\t_: 'baseThemeNight'\n\t};\n\n\texport type baseThemeTinted = {\n\t\t_: 'baseThemeTinted'\n\t};\n\n\texport type baseThemeArctic = {\n\t\t_: 'baseThemeArctic'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputThemeSettings\n */\nexport type InputThemeSettings = InputThemeSettings.inputThemeSettings;\n\nexport namespace InputThemeSettings {\n  export type inputThemeSettings = {\n\t\t_: 'inputThemeSettings',\n\t\tflags?: number,\n\t\tbase_theme: BaseTheme,\n\t\taccent_color: number,\n\t\tmessage_top_color?: number,\n\t\tmessage_bottom_color?: number,\n\t\twallpaper?: InputWallPaper,\n\t\twallpaper_settings?: WallPaperSettings\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ThemeSettings\n */\nexport type ThemeSettings = ThemeSettings.themeSettings;\n\nexport namespace ThemeSettings {\n  export type themeSettings = {\n\t\t_: 'themeSettings',\n\t\tflags?: number,\n\t\tbase_theme: BaseTheme,\n\t\taccent_color: number,\n\t\tmessage_top_color?: number,\n\t\tmessage_bottom_color?: number,\n\t\twallpaper?: WallPaper\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/WebPageAttribute\n */\nexport type WebPageAttribute = WebPageAttribute.webPageAttributeTheme;\n\nexport namespace WebPageAttribute {\n  export type webPageAttributeTheme = {\n\t\t_: 'webPageAttributeTheme',\n\t\tflags?: number,\n\t\tdocuments?: Array<Document>,\n\t\tsettings?: ThemeSettings\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageUserVote\n */\nexport type MessageUserVote = MessageUserVote.messageUserVote | MessageUserVote.messageUserVoteInputOption | MessageUserVote.messageUserVoteMultiple;\n\nexport namespace MessageUserVote {\n  export type messageUserVote = {\n\t\t_: 'messageUserVote',\n\t\tuser_id: number,\n\t\toption: Uint8Array,\n\t\tdate: number\n\t};\n\n\texport type messageUserVoteInputOption = {\n\t\t_: 'messageUserVoteInputOption',\n\t\tuser_id: number,\n\t\tdate: number\n\t};\n\n\texport type messageUserVoteMultiple = {\n\t\t_: 'messageUserVoteMultiple',\n\t\tuser_id: number,\n\t\toptions: Array<Uint8Array>,\n\t\tdate: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.VotesList\n */\nexport type MessagesVotesList = MessagesVotesList.messagesVotesList;\n\nexport namespace MessagesVotesList {\n  export type messagesVotesList = {\n\t\t_: 'messages.votesList',\n\t\tflags?: number,\n\t\tcount: number,\n\t\tvotes: Array<MessageUserVote>,\n\t\tusers: Array<User>,\n\t\tnext_offset?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/BankCardOpenUrl\n */\nexport type BankCardOpenUrl = BankCardOpenUrl.bankCardOpenUrl;\n\nexport namespace BankCardOpenUrl {\n  export type bankCardOpenUrl = {\n\t\t_: 'bankCardOpenUrl',\n\t\turl: string,\n\t\tname: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/payments.BankCardData\n */\nexport type PaymentsBankCardData = PaymentsBankCardData.paymentsBankCardData;\n\nexport namespace PaymentsBankCardData {\n  export type paymentsBankCardData = {\n\t\t_: 'payments.bankCardData',\n\t\ttitle: string,\n\t\topen_urls: Array<BankCardOpenUrl>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/DialogFilter\n */\nexport type DialogFilter = DialogFilter.dialogFilter;\n\nexport namespace DialogFilter {\n  export type dialogFilter = {\n\t\t_: 'dialogFilter',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcontacts?: true,\n\t\t\tnon_contacts?: true,\n\t\t\tgroups?: true,\n\t\t\tbroadcasts?: true,\n\t\t\tbots?: true,\n\t\t\texclude_muted?: true,\n\t\t\texclude_read?: true,\n\t\t\texclude_archived?: true,\n\t\t}>,\n\t\tid: number,\n\t\ttitle: string,\n\t\temoticon?: string,\n\t\tpinned_peers: Array<InputPeer>,\n\t\tinclude_peers: Array<InputPeer>,\n\t\texclude_peers: Array<InputPeer>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/DialogFilterSuggested\n */\nexport type DialogFilterSuggested = DialogFilterSuggested.dialogFilterSuggested;\n\nexport namespace DialogFilterSuggested {\n  export type dialogFilterSuggested = {\n\t\t_: 'dialogFilterSuggested',\n\t\tfilter: DialogFilter,\n\t\tdescription: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsDateRangeDays\n */\nexport type StatsDateRangeDays = StatsDateRangeDays.statsDateRangeDays;\n\nexport namespace StatsDateRangeDays {\n  export type statsDateRangeDays = {\n\t\t_: 'statsDateRangeDays',\n\t\tmin_date: number,\n\t\tmax_date: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsAbsValueAndPrev\n */\nexport type StatsAbsValueAndPrev = StatsAbsValueAndPrev.statsAbsValueAndPrev;\n\nexport namespace StatsAbsValueAndPrev {\n  export type statsAbsValueAndPrev = {\n\t\t_: 'statsAbsValueAndPrev',\n\t\tcurrent: number,\n\t\tprevious: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsPercentValue\n */\nexport type StatsPercentValue = StatsPercentValue.statsPercentValue;\n\nexport namespace StatsPercentValue {\n  export type statsPercentValue = {\n\t\t_: 'statsPercentValue',\n\t\tpart: number,\n\t\ttotal: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsGraph\n */\nexport type StatsGraph = StatsGraph.statsGraphAsync | StatsGraph.statsGraphError | StatsGraph.statsGraph;\n\nexport namespace StatsGraph {\n  export type statsGraphAsync = {\n\t\t_: 'statsGraphAsync',\n\t\ttoken: string\n\t};\n\n\texport type statsGraphError = {\n\t\t_: 'statsGraphError',\n\t\terror: string\n\t};\n\n\texport type statsGraph = {\n\t\t_: 'statsGraph',\n\t\tflags?: number,\n\t\tjson: DataJSON,\n\t\tzoom_token?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageInteractionCounters\n */\nexport type MessageInteractionCounters = MessageInteractionCounters.messageInteractionCounters;\n\nexport namespace MessageInteractionCounters {\n  export type messageInteractionCounters = {\n\t\t_: 'messageInteractionCounters',\n\t\tmsg_id: number,\n\t\tviews: number,\n\t\tforwards: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/stats.BroadcastStats\n */\nexport type StatsBroadcastStats = StatsBroadcastStats.statsBroadcastStats;\n\nexport namespace StatsBroadcastStats {\n  export type statsBroadcastStats = {\n\t\t_: 'stats.broadcastStats',\n\t\tperiod: StatsDateRangeDays,\n\t\tfollowers: StatsAbsValueAndPrev,\n\t\tviews_per_post: StatsAbsValueAndPrev,\n\t\tshares_per_post: StatsAbsValueAndPrev,\n\t\tenabled_notifications: StatsPercentValue,\n\t\tgrowth_graph: StatsGraph,\n\t\tfollowers_graph: StatsGraph,\n\t\tmute_graph: StatsGraph,\n\t\ttop_hours_graph: StatsGraph,\n\t\tinteractions_graph: StatsGraph,\n\t\tiv_interactions_graph: StatsGraph,\n\t\tviews_by_source_graph: StatsGraph,\n\t\tnew_followers_by_source_graph: StatsGraph,\n\t\tlanguages_graph: StatsGraph,\n\t\trecent_message_interactions: Array<MessageInteractionCounters>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.PromoData\n */\nexport type HelpPromoData = HelpPromoData.helpPromoDataEmpty | HelpPromoData.helpPromoData;\n\nexport namespace HelpPromoData {\n  export type helpPromoDataEmpty = {\n\t\t_: 'help.promoDataEmpty',\n\t\texpires: number\n\t};\n\n\texport type helpPromoData = {\n\t\t_: 'help.promoData',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tproxy?: true,\n\t\t}>,\n\t\texpires: number,\n\t\tpeer: Peer,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>,\n\t\tpsa_type?: string,\n\t\tpsa_message?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/VideoSize\n */\nexport type VideoSize = VideoSize.videoSize;\n\nexport namespace VideoSize {\n  export type videoSize = {\n\t\t_: 'videoSize',\n\t\tflags?: number,\n\t\ttype: string,\n\t\tw: number,\n\t\th: number,\n\t\tsize: number,\n\t\tvideo_start_ts?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsGroupTopPoster\n */\nexport type StatsGroupTopPoster = StatsGroupTopPoster.statsGroupTopPoster;\n\nexport namespace StatsGroupTopPoster {\n  export type statsGroupTopPoster = {\n\t\t_: 'statsGroupTopPoster',\n\t\tuser_id: number,\n\t\tmessages: number,\n\t\tavg_chars: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsGroupTopAdmin\n */\nexport type StatsGroupTopAdmin = StatsGroupTopAdmin.statsGroupTopAdmin;\n\nexport namespace StatsGroupTopAdmin {\n  export type statsGroupTopAdmin = {\n\t\t_: 'statsGroupTopAdmin',\n\t\tuser_id: number,\n\t\tdeleted: number,\n\t\tkicked: number,\n\t\tbanned: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsGroupTopInviter\n */\nexport type StatsGroupTopInviter = StatsGroupTopInviter.statsGroupTopInviter;\n\nexport namespace StatsGroupTopInviter {\n  export type statsGroupTopInviter = {\n\t\t_: 'statsGroupTopInviter',\n\t\tuser_id: number,\n\t\tinvitations: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/stats.MegagroupStats\n */\nexport type StatsMegagroupStats = StatsMegagroupStats.statsMegagroupStats;\n\nexport namespace StatsMegagroupStats {\n  export type statsMegagroupStats = {\n\t\t_: 'stats.megagroupStats',\n\t\tperiod: StatsDateRangeDays,\n\t\tmembers: StatsAbsValueAndPrev,\n\t\tmessages: StatsAbsValueAndPrev,\n\t\tviewers: StatsAbsValueAndPrev,\n\t\tposters: StatsAbsValueAndPrev,\n\t\tgrowth_graph: StatsGraph,\n\t\tmembers_graph: StatsGraph,\n\t\tnew_members_by_source_graph: StatsGraph,\n\t\tlanguages_graph: StatsGraph,\n\t\tmessages_graph: StatsGraph,\n\t\tactions_graph: StatsGraph,\n\t\ttop_hours_graph: StatsGraph,\n\t\tweekdays_graph: StatsGraph,\n\t\ttop_posters: Array<StatsGroupTopPoster>,\n\t\ttop_admins: Array<StatsGroupTopAdmin>,\n\t\ttop_inviters: Array<StatsGroupTopInviter>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/GlobalPrivacySettings\n */\nexport type GlobalPrivacySettings = GlobalPrivacySettings.globalPrivacySettings;\n\nexport namespace GlobalPrivacySettings {\n  export type globalPrivacySettings = {\n\t\t_: 'globalPrivacySettings',\n\t\tflags?: number,\n\t\tarchive_and_mute_new_noncontact_peers?: boolean\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.CountryCode\n */\nexport type HelpCountryCode = HelpCountryCode.helpCountryCode;\n\nexport namespace HelpCountryCode {\n  export type helpCountryCode = {\n\t\t_: 'help.countryCode',\n\t\tflags?: number,\n\t\tcountry_code: string,\n\t\tprefixes?: Array<string>,\n\t\tpatterns?: Array<string>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.Country\n */\nexport type HelpCountry = HelpCountry.helpCountry;\n\nexport namespace HelpCountry {\n  export type helpCountry = {\n\t\t_: 'help.country',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\thidden?: true,\n\t\t}>,\n\t\tiso2: string,\n\t\tdefault_name: string,\n\t\tname?: string,\n\t\tcountry_codes: Array<HelpCountryCode>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.CountriesList\n */\nexport type HelpCountriesList = HelpCountriesList.helpCountriesListNotModified | HelpCountriesList.helpCountriesList;\n\nexport namespace HelpCountriesList {\n  export type helpCountriesListNotModified = {\n\t\t_: 'help.countriesListNotModified'\n\t};\n\n\texport type helpCountriesList = {\n\t\t_: 'help.countriesList',\n\t\tcountries: Array<HelpCountry>,\n\t\thash: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageViews\n */\nexport type MessageViews = MessageViews.messageViews;\n\nexport namespace MessageViews {\n  export type messageViews = {\n\t\t_: 'messageViews',\n\t\tflags?: number,\n\t\tviews?: number,\n\t\tforwards?: number,\n\t\treplies?: MessageReplies\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.MessageViews\n */\nexport type MessagesMessageViews = MessagesMessageViews.messagesMessageViews;\n\nexport namespace MessagesMessageViews {\n  export type messagesMessageViews = {\n\t\t_: 'messages.messageViews',\n\t\tviews: Array<MessageViews>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.DiscussionMessage\n */\nexport type MessagesDiscussionMessage = MessagesDiscussionMessage.messagesDiscussionMessage;\n\nexport namespace MessagesDiscussionMessage {\n  export type messagesDiscussionMessage = {\n\t\t_: 'messages.discussionMessage',\n\t\tflags?: number,\n\t\tmessages: Array<Message>,\n\t\tmax_id?: number,\n\t\tread_inbox_max_id?: number,\n\t\tread_outbox_max_id?: number,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageReplyHeader\n */\nexport type MessageReplyHeader = MessageReplyHeader.messageReplyHeader;\n\nexport namespace MessageReplyHeader {\n  export type messageReplyHeader = {\n\t\t_: 'messageReplyHeader',\n\t\tflags?: number,\n\t\treply_to_msg_id: number,\n\t\treply_to_peer_id?: Peer,\n\t\treply_to_top_id?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageReplies\n */\nexport type MessageReplies = MessageReplies.messageReplies;\n\nexport namespace MessageReplies {\n  export type messageReplies = {\n\t\t_: 'messageReplies',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcomments?: true,\n\t\t}>,\n\t\treplies: number,\n\t\treplies_pts: number,\n\t\trecent_repliers?: Array<Peer>,\n\t\tchannel_id?: number,\n\t\tmax_id?: number,\n\t\tread_max_id?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PeerBlocked\n */\nexport type PeerBlocked = PeerBlocked.peerBlocked;\n\nexport namespace PeerBlocked {\n  export type peerBlocked = {\n\t\t_: 'peerBlocked',\n\t\tpeer_id: Peer,\n\t\tdate: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/stats.MessageStats\n */\nexport type StatsMessageStats = StatsMessageStats.statsMessageStats;\n\nexport namespace StatsMessageStats {\n  export type statsMessageStats = {\n\t\t_: 'stats.messageStats',\n\t\tviews_graph: StatsGraph\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/GroupCall\n */\nexport type GroupCall = GroupCall.groupCallDiscarded | GroupCall.groupCall;\n\nexport namespace GroupCall {\n  export type groupCallDiscarded = {\n\t\t_: 'groupCallDiscarded',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tduration: number\n\t};\n\n\texport type groupCall = {\n\t\t_: 'groupCall',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tjoin_muted?: true,\n\t\t\tcan_change_join_muted?: true,\n\t\t\tjoin_date_asc?: true,\n\t\t\tschedule_start_subscribed?: true,\n\t\t\tcan_start_video?: true,\n\t\t}>,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tparticipants_count: number,\n\t\ttitle?: string,\n\t\tstream_dc_id?: number,\n\t\trecord_start_date?: number,\n\t\tschedule_date?: number,\n\t\tunmuted_video_count?: number,\n\t\tunmuted_video_limit: number,\n\t\tversion: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputGroupCall\n */\nexport type InputGroupCall = InputGroupCall.inputGroupCall;\n\nexport namespace InputGroupCall {\n  export type inputGroupCall = {\n\t\t_: 'inputGroupCall',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/GroupCallParticipant\n */\nexport type GroupCallParticipant = GroupCallParticipant.groupCallParticipant;\n\nexport namespace GroupCallParticipant {\n  export type groupCallParticipant = {\n\t\t_: 'groupCallParticipant',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tmuted?: true,\n\t\t\tleft?: true,\n\t\t\tcan_self_unmute?: true,\n\t\t\tjust_joined?: true,\n\t\t\tversioned?: true,\n\t\t\tmin?: true,\n\t\t\tmuted_by_you?: true,\n\t\t\tvolume_by_admin?: true,\n\t\t\tself?: true,\n\t\t\tvideo_joined?: true,\n\t\t}>,\n\t\tpeer: Peer,\n\t\tdate: number,\n\t\tactive_date?: number,\n\t\tsource: number,\n\t\tvolume?: number,\n\t\tabout?: string,\n\t\traise_hand_rating?: string,\n\t\tvideo?: GroupCallParticipantVideo,\n\t\tpresentation?: GroupCallParticipantVideo\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/phone.GroupCall\n */\nexport type PhoneGroupCall = PhoneGroupCall.phoneGroupCall;\n\nexport namespace PhoneGroupCall {\n  export type phoneGroupCall = {\n\t\t_: 'phone.groupCall',\n\t\tcall: GroupCall,\n\t\tparticipants: Array<GroupCallParticipant>,\n\t\tparticipants_next_offset: string,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/phone.GroupParticipants\n */\nexport type PhoneGroupParticipants = PhoneGroupParticipants.phoneGroupParticipants;\n\nexport namespace PhoneGroupParticipants {\n  export type phoneGroupParticipants = {\n\t\t_: 'phone.groupParticipants',\n\t\tcount: number,\n\t\tparticipants: Array<GroupCallParticipant>,\n\t\tnext_offset: string,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>,\n\t\tversion: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InlineQueryPeerType\n */\nexport type InlineQueryPeerType = InlineQueryPeerType.inlineQueryPeerTypeSameBotPM | InlineQueryPeerType.inlineQueryPeerTypePM | InlineQueryPeerType.inlineQueryPeerTypeChat | InlineQueryPeerType.inlineQueryPeerTypeMegagroup | InlineQueryPeerType.inlineQueryPeerTypeBroadcast;\n\nexport namespace InlineQueryPeerType {\n  export type inlineQueryPeerTypeSameBotPM = {\n\t\t_: 'inlineQueryPeerTypeSameBotPM'\n\t};\n\n\texport type inlineQueryPeerTypePM = {\n\t\t_: 'inlineQueryPeerTypePM'\n\t};\n\n\texport type inlineQueryPeerTypeChat = {\n\t\t_: 'inlineQueryPeerTypeChat'\n\t};\n\n\texport type inlineQueryPeerTypeMegagroup = {\n\t\t_: 'inlineQueryPeerTypeMegagroup'\n\t};\n\n\texport type inlineQueryPeerTypeBroadcast = {\n\t\t_: 'inlineQueryPeerTypeBroadcast'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.HistoryImport\n */\nexport type MessagesHistoryImport = MessagesHistoryImport.messagesHistoryImport;\n\nexport namespace MessagesHistoryImport {\n  export type messagesHistoryImport = {\n\t\t_: 'messages.historyImport',\n\t\tid: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.HistoryImportParsed\n */\nexport type MessagesHistoryImportParsed = MessagesHistoryImportParsed.messagesHistoryImportParsed;\n\nexport namespace MessagesHistoryImportParsed {\n  export type messagesHistoryImportParsed = {\n\t\t_: 'messages.historyImportParsed',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpm?: true,\n\t\t\tgroup?: true,\n\t\t}>,\n\t\ttitle?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.AffectedFoundMessages\n */\nexport type MessagesAffectedFoundMessages = MessagesAffectedFoundMessages.messagesAffectedFoundMessages;\n\nexport namespace MessagesAffectedFoundMessages {\n  export type messagesAffectedFoundMessages = {\n\t\t_: 'messages.affectedFoundMessages',\n\t\tpts: number,\n\t\tpts_count: number,\n\t\toffset: number,\n\t\tmessages: Array<number>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatInviteImporter\n */\nexport type ChatInviteImporter = ChatInviteImporter.chatInviteImporter;\n\nexport namespace ChatInviteImporter {\n  export type chatInviteImporter = {\n\t\t_: 'chatInviteImporter',\n\t\tuser_id: number,\n\t\tdate: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.ExportedChatInvites\n */\nexport type MessagesExportedChatInvites = MessagesExportedChatInvites.messagesExportedChatInvites;\n\nexport namespace MessagesExportedChatInvites {\n  export type messagesExportedChatInvites = {\n\t\t_: 'messages.exportedChatInvites',\n\t\tcount: number,\n\t\tinvites: Array<ExportedChatInvite>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.ExportedChatInvite\n */\nexport type MessagesExportedChatInvite = MessagesExportedChatInvite.messagesExportedChatInvite | MessagesExportedChatInvite.messagesExportedChatInviteReplaced;\n\nexport namespace MessagesExportedChatInvite {\n  export type messagesExportedChatInvite = {\n\t\t_: 'messages.exportedChatInvite',\n\t\tinvite: ExportedChatInvite,\n\t\tusers: Array<User>\n\t};\n\n\texport type messagesExportedChatInviteReplaced = {\n\t\t_: 'messages.exportedChatInviteReplaced',\n\t\tinvite: ExportedChatInvite,\n\t\tnew_invite: ExportedChatInvite,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.ChatInviteImporters\n */\nexport type MessagesChatInviteImporters = MessagesChatInviteImporters.messagesChatInviteImporters;\n\nexport namespace MessagesChatInviteImporters {\n  export type messagesChatInviteImporters = {\n\t\t_: 'messages.chatInviteImporters',\n\t\tcount: number,\n\t\timporters: Array<ChatInviteImporter>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatAdminWithInvites\n */\nexport type ChatAdminWithInvites = ChatAdminWithInvites.chatAdminWithInvites;\n\nexport namespace ChatAdminWithInvites {\n  export type chatAdminWithInvites = {\n\t\t_: 'chatAdminWithInvites',\n\t\tadmin_id: number,\n\t\tinvites_count: number,\n\t\trevoked_invites_count: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.ChatAdminsWithInvites\n */\nexport type MessagesChatAdminsWithInvites = MessagesChatAdminsWithInvites.messagesChatAdminsWithInvites;\n\nexport namespace MessagesChatAdminsWithInvites {\n  export type messagesChatAdminsWithInvites = {\n\t\t_: 'messages.chatAdminsWithInvites',\n\t\tadmins: Array<ChatAdminWithInvites>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.CheckedHistoryImportPeer\n */\nexport type MessagesCheckedHistoryImportPeer = MessagesCheckedHistoryImportPeer.messagesCheckedHistoryImportPeer;\n\nexport namespace MessagesCheckedHistoryImportPeer {\n  export type messagesCheckedHistoryImportPeer = {\n\t\t_: 'messages.checkedHistoryImportPeer',\n\t\tconfirm_text: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/phone.JoinAsPeers\n */\nexport type PhoneJoinAsPeers = PhoneJoinAsPeers.phoneJoinAsPeers;\n\nexport namespace PhoneJoinAsPeers {\n  export type phoneJoinAsPeers = {\n\t\t_: 'phone.joinAsPeers',\n\t\tpeers: Array<Peer>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/phone.ExportedGroupCallInvite\n */\nexport type PhoneExportedGroupCallInvite = PhoneExportedGroupCallInvite.phoneExportedGroupCallInvite;\n\nexport namespace PhoneExportedGroupCallInvite {\n  export type phoneExportedGroupCallInvite = {\n\t\t_: 'phone.exportedGroupCallInvite',\n\t\tlink: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/GroupCallParticipantVideoSourceGroup\n */\nexport type GroupCallParticipantVideoSourceGroup = GroupCallParticipantVideoSourceGroup.groupCallParticipantVideoSourceGroup;\n\nexport namespace GroupCallParticipantVideoSourceGroup {\n  export type groupCallParticipantVideoSourceGroup = {\n\t\t_: 'groupCallParticipantVideoSourceGroup',\n\t\tsemantics: string,\n\t\tsources: Array<number>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/GroupCallParticipantVideo\n */\nexport type GroupCallParticipantVideo = GroupCallParticipantVideo.groupCallParticipantVideo;\n\nexport namespace GroupCallParticipantVideo {\n  export type groupCallParticipantVideo = {\n\t\t_: 'groupCallParticipantVideo',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpaused?: true,\n\t\t}>,\n\t\tendpoint: string,\n\t\tsource_groups: Array<GroupCallParticipantVideoSourceGroup>,\n\t\taudio_source?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/stickers.SuggestedShortName\n */\nexport type StickersSuggestedShortName = StickersSuggestedShortName.stickersSuggestedShortName;\n\nexport namespace StickersSuggestedShortName {\n  export type stickersSuggestedShortName = {\n\t\t_: 'stickers.suggestedShortName',\n\t\tshort_name: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/BotCommandScope\n */\nexport type BotCommandScope = BotCommandScope.botCommandScopeDefault | BotCommandScope.botCommandScopeUsers | BotCommandScope.botCommandScopeChats | BotCommandScope.botCommandScopeChatAdmins | BotCommandScope.botCommandScopePeer | BotCommandScope.botCommandScopePeerAdmins | BotCommandScope.botCommandScopePeerUser;\n\nexport namespace BotCommandScope {\n  export type botCommandScopeDefault = {\n\t\t_: 'botCommandScopeDefault'\n\t};\n\n\texport type botCommandScopeUsers = {\n\t\t_: 'botCommandScopeUsers'\n\t};\n\n\texport type botCommandScopeChats = {\n\t\t_: 'botCommandScopeChats'\n\t};\n\n\texport type botCommandScopeChatAdmins = {\n\t\t_: 'botCommandScopeChatAdmins'\n\t};\n\n\texport type botCommandScopePeer = {\n\t\t_: 'botCommandScopePeer',\n\t\tpeer: InputPeer\n\t};\n\n\texport type botCommandScopePeerAdmins = {\n\t\t_: 'botCommandScopePeerAdmins',\n\t\tpeer: InputPeer\n\t};\n\n\texport type botCommandScopePeerUser = {\n\t\t_: 'botCommandScopePeerUser',\n\t\tpeer: InputPeer,\n\t\tuser_id: InputUser\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.ResetPasswordResult\n */\nexport type AccountResetPasswordResult = AccountResetPasswordResult.accountResetPasswordFailedWait | AccountResetPasswordResult.accountResetPasswordRequestedWait | AccountResetPasswordResult.accountResetPasswordOk;\n\nexport namespace AccountResetPasswordResult {\n  export type accountResetPasswordFailedWait = {\n\t\t_: 'account.resetPasswordFailedWait',\n\t\tretry_date: number\n\t};\n\n\texport type accountResetPasswordRequestedWait = {\n\t\t_: 'account.resetPasswordRequestedWait',\n\t\tuntil_date: number\n\t};\n\n\texport type accountResetPasswordOk = {\n\t\t_: 'account.resetPasswordOk'\n\t};\n}\n\nexport interface ConstructorDeclMap {\n\t'error': Error.error,\n\t'inputPeerEmpty': InputPeer.inputPeerEmpty,\n\t'inputPeerSelf': InputPeer.inputPeerSelf,\n\t'inputPeerChat': InputPeer.inputPeerChat,\n\t'inputUserEmpty': InputUser.inputUserEmpty,\n\t'inputUserSelf': InputUser.inputUserSelf,\n\t'inputPhoneContact': InputContact.inputPhoneContact,\n\t'inputFile': InputFile.inputFile,\n\t'inputMediaEmpty': InputMedia.inputMediaEmpty,\n\t'inputMediaUploadedPhoto': InputMedia.inputMediaUploadedPhoto,\n\t'inputMediaPhoto': InputMedia.inputMediaPhoto,\n\t'inputMediaGeoPoint': InputMedia.inputMediaGeoPoint,\n\t'inputMediaContact': InputMedia.inputMediaContact,\n\t'inputChatPhotoEmpty': InputChatPhoto.inputChatPhotoEmpty,\n\t'inputChatUploadedPhoto': InputChatPhoto.inputChatUploadedPhoto,\n\t'inputChatPhoto': InputChatPhoto.inputChatPhoto,\n\t'inputGeoPointEmpty': InputGeoPoint.inputGeoPointEmpty,\n\t'inputGeoPoint': InputGeoPoint.inputGeoPoint,\n\t'inputPhotoEmpty': InputPhoto.inputPhotoEmpty,\n\t'inputPhoto': InputPhoto.inputPhoto,\n\t'inputFileLocation': InputFileLocation.inputFileLocation,\n\t'peerUser': Peer.peerUser,\n\t'peerChat': Peer.peerChat,\n\t'storage.fileUnknown': StorageFileType.storageFileUnknown,\n\t'storage.filePartial': StorageFileType.storageFilePartial,\n\t'storage.fileJpeg': StorageFileType.storageFileJpeg,\n\t'storage.fileGif': StorageFileType.storageFileGif,\n\t'storage.filePng': StorageFileType.storageFilePng,\n\t'storage.filePdf': StorageFileType.storageFilePdf,\n\t'storage.fileMp3': StorageFileType.storageFileMp3,\n\t'storage.fileMov': StorageFileType.storageFileMov,\n\t'storage.fileMp4': StorageFileType.storageFileMp4,\n\t'storage.fileWebp': StorageFileType.storageFileWebp,\n\t'userEmpty': User.userEmpty,\n\t'userProfilePhotoEmpty': UserProfilePhoto.userProfilePhotoEmpty,\n\t'userProfilePhoto': UserProfilePhoto.userProfilePhoto,\n\t'userStatusEmpty': UserStatus.userStatusEmpty,\n\t'userStatusOnline': UserStatus.userStatusOnline,\n\t'userStatusOffline': UserStatus.userStatusOffline,\n\t'chatEmpty': Chat.chatEmpty,\n\t'chat': Chat.chat,\n\t'chatForbidden': Chat.chatForbidden,\n\t'chatFull': ChatFull.chatFull,\n\t'chatParticipant': ChatParticipant.chatParticipant,\n\t'chatParticipantsForbidden': ChatParticipants.chatParticipantsForbidden,\n\t'chatParticipants': ChatParticipants.chatParticipants,\n\t'chatPhotoEmpty': ChatPhoto.chatPhotoEmpty,\n\t'chatPhoto': ChatPhoto.chatPhoto,\n\t'messageEmpty': Message.messageEmpty,\n\t'message': Message.message,\n\t'messageService': Message.messageService,\n\t'messageMediaEmpty': MessageMedia.messageMediaEmpty,\n\t'messageMediaPhoto': MessageMedia.messageMediaPhoto,\n\t'messageMediaGeo': MessageMedia.messageMediaGeo,\n\t'messageMediaContact': MessageMedia.messageMediaContact,\n\t'messageMediaUnsupported': MessageMedia.messageMediaUnsupported,\n\t'messageActionEmpty': MessageAction.messageActionEmpty,\n\t'messageActionChatCreate': MessageAction.messageActionChatCreate,\n\t'messageActionChatEditTitle': MessageAction.messageActionChatEditTitle,\n\t'messageActionChatEditPhoto': MessageAction.messageActionChatEditPhoto,\n\t'messageActionChatDeletePhoto': MessageAction.messageActionChatDeletePhoto,\n\t'messageActionChatAddUser': MessageAction.messageActionChatAddUser,\n\t'messageActionChatDeleteUser': MessageAction.messageActionChatDeleteUser,\n\t'dialog': Dialog.dialog,\n\t'photoEmpty': Photo.photoEmpty,\n\t'photo': Photo.photo,\n\t'photoSizeEmpty': PhotoSize.photoSizeEmpty,\n\t'photoSize': PhotoSize.photoSize,\n\t'photoCachedSize': PhotoSize.photoCachedSize,\n\t'geoPointEmpty': GeoPoint.geoPointEmpty,\n\t'geoPoint': GeoPoint.geoPoint,\n\t'auth.sentCode': AuthSentCode.authSentCode,\n\t'auth.authorization': AuthAuthorization.authAuthorization,\n\t'auth.exportedAuthorization': AuthExportedAuthorization.authExportedAuthorization,\n\t'inputNotifyPeer': InputNotifyPeer.inputNotifyPeer,\n\t'inputNotifyUsers': InputNotifyPeer.inputNotifyUsers,\n\t'inputNotifyChats': InputNotifyPeer.inputNotifyChats,\n\t'inputPeerNotifySettings': InputPeerNotifySettings.inputPeerNotifySettings,\n\t'peerNotifySettings': PeerNotifySettings.peerNotifySettings,\n\t'peerSettings': PeerSettings.peerSettings,\n\t'wallPaper': WallPaper.wallPaper,\n\t'inputReportReasonSpam': ReportReason.inputReportReasonSpam,\n\t'inputReportReasonViolence': ReportReason.inputReportReasonViolence,\n\t'inputReportReasonPornography': ReportReason.inputReportReasonPornography,\n\t'inputReportReasonChildAbuse': ReportReason.inputReportReasonChildAbuse,\n\t'inputReportReasonOther': ReportReason.inputReportReasonOther,\n\t'userFull': UserFull.userFull,\n\t'contact': Contact.contact,\n\t'importedContact': ImportedContact.importedContact,\n\t'contactStatus': ContactStatus.contactStatus,\n\t'contacts.contactsNotModified': ContactsContacts.contactsContactsNotModified,\n\t'contacts.contacts': ContactsContacts.contactsContacts,\n\t'contacts.importedContacts': ContactsImportedContacts.contactsImportedContacts,\n\t'contacts.blocked': ContactsBlocked.contactsBlocked,\n\t'contacts.blockedSlice': ContactsBlocked.contactsBlockedSlice,\n\t'messages.dialogs': MessagesDialogs.messagesDialogs,\n\t'messages.dialogsSlice': MessagesDialogs.messagesDialogsSlice,\n\t'messages.messages': MessagesMessages.messagesMessages,\n\t'messages.messagesSlice': MessagesMessages.messagesMessagesSlice,\n\t'messages.chats': MessagesChats.messagesChats,\n\t'messages.chatFull': MessagesChatFull.messagesChatFull,\n\t'messages.affectedHistory': MessagesAffectedHistory.messagesAffectedHistory,\n\t'inputMessagesFilterEmpty': MessagesFilter.inputMessagesFilterEmpty,\n\t'inputMessagesFilterPhotos': MessagesFilter.inputMessagesFilterPhotos,\n\t'inputMessagesFilterVideo': MessagesFilter.inputMessagesFilterVideo,\n\t'inputMessagesFilterPhotoVideo': MessagesFilter.inputMessagesFilterPhotoVideo,\n\t'inputMessagesFilterDocument': MessagesFilter.inputMessagesFilterDocument,\n\t'inputMessagesFilterUrl': MessagesFilter.inputMessagesFilterUrl,\n\t'inputMessagesFilterGif': MessagesFilter.inputMessagesFilterGif,\n\t'updateNewMessage': Update.updateNewMessage,\n\t'updateMessageID': Update.updateMessageID,\n\t'updateDeleteMessages': Update.updateDeleteMessages,\n\t'updateUserTyping': Update.updateUserTyping,\n\t'updateChatUserTyping': Update.updateChatUserTyping,\n\t'updateChatParticipants': Update.updateChatParticipants,\n\t'updateUserStatus': Update.updateUserStatus,\n\t'updateUserName': Update.updateUserName,\n\t'updateUserPhoto': Update.updateUserPhoto,\n\t'updates.state': UpdatesState.updatesState,\n\t'updates.differenceEmpty': UpdatesDifference.updatesDifferenceEmpty,\n\t'updates.difference': UpdatesDifference.updatesDifference,\n\t'updates.differenceSlice': UpdatesDifference.updatesDifferenceSlice,\n\t'updatesTooLong': Updates.updatesTooLong,\n\t'updateShortMessage': Updates.updateShortMessage,\n\t'updateShortChatMessage': Updates.updateShortChatMessage,\n\t'updateShort': Updates.updateShort,\n\t'updatesCombined': Updates.updatesCombined,\n\t'updates': Updates.updates,\n\t'photos.photos': PhotosPhotos.photosPhotos,\n\t'photos.photosSlice': PhotosPhotos.photosPhotosSlice,\n\t'photos.photo': PhotosPhoto.photosPhoto,\n\t'upload.file': UploadFile.uploadFile,\n\t'dcOption': DcOption.dcOption,\n\t'config': Config.config,\n\t'nearestDc': NearestDc.nearestDc,\n\t'help.appUpdate': HelpAppUpdate.helpAppUpdate,\n\t'help.noAppUpdate': HelpAppUpdate.helpNoAppUpdate,\n\t'help.inviteText': HelpInviteText.helpInviteText,\n\t'updateNewEncryptedMessage': Update.updateNewEncryptedMessage,\n\t'updateEncryptedChatTyping': Update.updateEncryptedChatTyping,\n\t'updateEncryption': Update.updateEncryption,\n\t'updateEncryptedMessagesRead': Update.updateEncryptedMessagesRead,\n\t'encryptedChatEmpty': EncryptedChat.encryptedChatEmpty,\n\t'encryptedChatWaiting': EncryptedChat.encryptedChatWaiting,\n\t'encryptedChatRequested': EncryptedChat.encryptedChatRequested,\n\t'encryptedChat': EncryptedChat.encryptedChat,\n\t'encryptedChatDiscarded': EncryptedChat.encryptedChatDiscarded,\n\t'inputEncryptedChat': InputEncryptedChat.inputEncryptedChat,\n\t'encryptedFileEmpty': EncryptedFile.encryptedFileEmpty,\n\t'encryptedFile': EncryptedFile.encryptedFile,\n\t'inputEncryptedFileEmpty': InputEncryptedFile.inputEncryptedFileEmpty,\n\t'inputEncryptedFileUploaded': InputEncryptedFile.inputEncryptedFileUploaded,\n\t'inputEncryptedFile': InputEncryptedFile.inputEncryptedFile,\n\t'inputEncryptedFileLocation': InputFileLocation.inputEncryptedFileLocation,\n\t'encryptedMessage': EncryptedMessage.encryptedMessage,\n\t'encryptedMessageService': EncryptedMessage.encryptedMessageService,\n\t'messages.dhConfigNotModified': MessagesDhConfig.messagesDhConfigNotModified,\n\t'messages.dhConfig': MessagesDhConfig.messagesDhConfig,\n\t'messages.sentEncryptedMessage': MessagesSentEncryptedMessage.messagesSentEncryptedMessage,\n\t'messages.sentEncryptedFile': MessagesSentEncryptedMessage.messagesSentEncryptedFile,\n\t'inputFileBig': InputFile.inputFileBig,\n\t'inputEncryptedFileBigUploaded': InputEncryptedFile.inputEncryptedFileBigUploaded,\n\t'updateChatParticipantAdd': Update.updateChatParticipantAdd,\n\t'updateChatParticipantDelete': Update.updateChatParticipantDelete,\n\t'updateDcOptions': Update.updateDcOptions,\n\t'inputMediaUploadedDocument': InputMedia.inputMediaUploadedDocument,\n\t'inputMediaDocument': InputMedia.inputMediaDocument,\n\t'messageMediaDocument': MessageMedia.messageMediaDocument,\n\t'inputDocumentEmpty': InputDocument.inputDocumentEmpty,\n\t'inputDocument': InputDocument.inputDocument,\n\t'inputDocumentFileLocation': InputFileLocation.inputDocumentFileLocation,\n\t'documentEmpty': Document.documentEmpty,\n\t'document': Document.document,\n\t'help.support': HelpSupport.helpSupport,\n\t'notifyPeer': NotifyPeer.notifyPeer,\n\t'notifyUsers': NotifyPeer.notifyUsers,\n\t'notifyChats': NotifyPeer.notifyChats,\n\t'updateNotifySettings': Update.updateNotifySettings,\n\t'sendMessageTypingAction': SendMessageAction.sendMessageTypingAction,\n\t'sendMessageCancelAction': SendMessageAction.sendMessageCancelAction,\n\t'sendMessageRecordVideoAction': SendMessageAction.sendMessageRecordVideoAction,\n\t'sendMessageUploadVideoAction': SendMessageAction.sendMessageUploadVideoAction,\n\t'sendMessageRecordAudioAction': SendMessageAction.sendMessageRecordAudioAction,\n\t'sendMessageUploadAudioAction': SendMessageAction.sendMessageUploadAudioAction,\n\t'sendMessageUploadPhotoAction': SendMessageAction.sendMessageUploadPhotoAction,\n\t'sendMessageUploadDocumentAction': SendMessageAction.sendMessageUploadDocumentAction,\n\t'sendMessageGeoLocationAction': SendMessageAction.sendMessageGeoLocationAction,\n\t'sendMessageChooseContactAction': SendMessageAction.sendMessageChooseContactAction,\n\t'contacts.found': ContactsFound.contactsFound,\n\t'updateServiceNotification': Update.updateServiceNotification,\n\t'userStatusRecently': UserStatus.userStatusRecently,\n\t'userStatusLastWeek': UserStatus.userStatusLastWeek,\n\t'userStatusLastMonth': UserStatus.userStatusLastMonth,\n\t'updatePrivacy': Update.updatePrivacy,\n\t'inputPrivacyKeyStatusTimestamp': InputPrivacyKey.inputPrivacyKeyStatusTimestamp,\n\t'privacyKeyStatusTimestamp': PrivacyKey.privacyKeyStatusTimestamp,\n\t'inputPrivacyValueAllowContacts': InputPrivacyRule.inputPrivacyValueAllowContacts,\n\t'inputPrivacyValueAllowAll': InputPrivacyRule.inputPrivacyValueAllowAll,\n\t'inputPrivacyValueAllowUsers': InputPrivacyRule.inputPrivacyValueAllowUsers,\n\t'inputPrivacyValueDisallowContacts': InputPrivacyRule.inputPrivacyValueDisallowContacts,\n\t'inputPrivacyValueDisallowAll': InputPrivacyRule.inputPrivacyValueDisallowAll,\n\t'inputPrivacyValueDisallowUsers': InputPrivacyRule.inputPrivacyValueDisallowUsers,\n\t'privacyValueAllowContacts': PrivacyRule.privacyValueAllowContacts,\n\t'privacyValueAllowAll': PrivacyRule.privacyValueAllowAll,\n\t'privacyValueAllowUsers': PrivacyRule.privacyValueAllowUsers,\n\t'privacyValueDisallowContacts': PrivacyRule.privacyValueDisallowContacts,\n\t'privacyValueDisallowAll': PrivacyRule.privacyValueDisallowAll,\n\t'privacyValueDisallowUsers': PrivacyRule.privacyValueDisallowUsers,\n\t'account.privacyRules': AccountPrivacyRules.accountPrivacyRules,\n\t'accountDaysTTL': AccountDaysTTL.accountDaysTTL,\n\t'updateUserPhone': Update.updateUserPhone,\n\t'documentAttributeImageSize': DocumentAttribute.documentAttributeImageSize,\n\t'documentAttributeAnimated': DocumentAttribute.documentAttributeAnimated,\n\t'documentAttributeSticker': DocumentAttribute.documentAttributeSticker,\n\t'documentAttributeVideo': DocumentAttribute.documentAttributeVideo,\n\t'documentAttributeAudio': DocumentAttribute.documentAttributeAudio,\n\t'documentAttributeFilename': DocumentAttribute.documentAttributeFilename,\n\t'messages.stickersNotModified': MessagesStickers.messagesStickersNotModified,\n\t'messages.stickers': MessagesStickers.messagesStickers,\n\t'stickerPack': StickerPack.stickerPack,\n\t'messages.allStickersNotModified': MessagesAllStickers.messagesAllStickersNotModified,\n\t'messages.allStickers': MessagesAllStickers.messagesAllStickers,\n\t'updateReadHistoryInbox': Update.updateReadHistoryInbox,\n\t'updateReadHistoryOutbox': Update.updateReadHistoryOutbox,\n\t'messages.affectedMessages': MessagesAffectedMessages.messagesAffectedMessages,\n\t'updateWebPage': Update.updateWebPage,\n\t'webPageEmpty': WebPage.webPageEmpty,\n\t'webPagePending': WebPage.webPagePending,\n\t'webPage': WebPage.webPage,\n\t'messageMediaWebPage': MessageMedia.messageMediaWebPage,\n\t'authorization': Authorization.authorization,\n\t'account.authorizations': AccountAuthorizations.accountAuthorizations,\n\t'account.password': AccountPassword.accountPassword,\n\t'account.passwordSettings': AccountPasswordSettings.accountPasswordSettings,\n\t'account.passwordInputSettings': AccountPasswordInputSettings.accountPasswordInputSettings,\n\t'auth.passwordRecovery': AuthPasswordRecovery.authPasswordRecovery,\n\t'inputMediaVenue': InputMedia.inputMediaVenue,\n\t'messageMediaVenue': MessageMedia.messageMediaVenue,\n\t'receivedNotifyMessage': ReceivedNotifyMessage.receivedNotifyMessage,\n\t'chatInviteExported': ExportedChatInvite.chatInviteExported,\n\t'chatInviteAlready': ChatInvite.chatInviteAlready,\n\t'chatInvite': ChatInvite.chatInvite,\n\t'messageActionChatJoinedByLink': MessageAction.messageActionChatJoinedByLink,\n\t'updateReadMessagesContents': Update.updateReadMessagesContents,\n\t'inputStickerSetEmpty': InputStickerSet.inputStickerSetEmpty,\n\t'inputStickerSetID': InputStickerSet.inputStickerSetID,\n\t'inputStickerSetShortName': InputStickerSet.inputStickerSetShortName,\n\t'stickerSet': StickerSet.stickerSet,\n\t'messages.stickerSet': MessagesStickerSet.messagesStickerSet,\n\t'user': User.user,\n\t'botCommand': BotCommand.botCommand,\n\t'botInfo': BotInfo.botInfo,\n\t'keyboardButton': KeyboardButton.keyboardButton,\n\t'keyboardButtonRow': KeyboardButtonRow.keyboardButtonRow,\n\t'replyKeyboardHide': ReplyMarkup.replyKeyboardHide,\n\t'replyKeyboardForceReply': ReplyMarkup.replyKeyboardForceReply,\n\t'replyKeyboardMarkup': ReplyMarkup.replyKeyboardMarkup,\n\t'inputPeerUser': InputPeer.inputPeerUser,\n\t'inputUser': InputUser.inputUser,\n\t'messageEntityUnknown': MessageEntity.messageEntityUnknown,\n\t'messageEntityMention': MessageEntity.messageEntityMention,\n\t'messageEntityHashtag': MessageEntity.messageEntityHashtag,\n\t'messageEntityBotCommand': MessageEntity.messageEntityBotCommand,\n\t'messageEntityUrl': MessageEntity.messageEntityUrl,\n\t'messageEntityEmail': MessageEntity.messageEntityEmail,\n\t'messageEntityBold': MessageEntity.messageEntityBold,\n\t'messageEntityItalic': MessageEntity.messageEntityItalic,\n\t'messageEntityCode': MessageEntity.messageEntityCode,\n\t'messageEntityPre': MessageEntity.messageEntityPre,\n\t'messageEntityTextUrl': MessageEntity.messageEntityTextUrl,\n\t'updateShortSentMessage': Updates.updateShortSentMessage,\n\t'inputChannelEmpty': InputChannel.inputChannelEmpty,\n\t'inputChannel': InputChannel.inputChannel,\n\t'peerChannel': Peer.peerChannel,\n\t'inputPeerChannel': InputPeer.inputPeerChannel,\n\t'channel': Chat.channel,\n\t'channelForbidden': Chat.channelForbidden,\n\t'contacts.resolvedPeer': ContactsResolvedPeer.contactsResolvedPeer,\n\t'channelFull': ChatFull.channelFull,\n\t'messageRange': MessageRange.messageRange,\n\t'messages.channelMessages': MessagesMessages.messagesChannelMessages,\n\t'messageActionChannelCreate': MessageAction.messageActionChannelCreate,\n\t'updateChannelTooLong': Update.updateChannelTooLong,\n\t'updateChannel': Update.updateChannel,\n\t'updateNewChannelMessage': Update.updateNewChannelMessage,\n\t'updateReadChannelInbox': Update.updateReadChannelInbox,\n\t'updateDeleteChannelMessages': Update.updateDeleteChannelMessages,\n\t'updateChannelMessageViews': Update.updateChannelMessageViews,\n\t'updates.channelDifferenceEmpty': UpdatesChannelDifference.updatesChannelDifferenceEmpty,\n\t'updates.channelDifferenceTooLong': UpdatesChannelDifference.updatesChannelDifferenceTooLong,\n\t'updates.channelDifference': UpdatesChannelDifference.updatesChannelDifference,\n\t'channelMessagesFilterEmpty': ChannelMessagesFilter.channelMessagesFilterEmpty,\n\t'channelMessagesFilter': ChannelMessagesFilter.channelMessagesFilter,\n\t'channelParticipant': ChannelParticipant.channelParticipant,\n\t'channelParticipantSelf': ChannelParticipant.channelParticipantSelf,\n\t'channelParticipantCreator': ChannelParticipant.channelParticipantCreator,\n\t'channelParticipantsRecent': ChannelParticipantsFilter.channelParticipantsRecent,\n\t'channelParticipantsAdmins': ChannelParticipantsFilter.channelParticipantsAdmins,\n\t'channelParticipantsKicked': ChannelParticipantsFilter.channelParticipantsKicked,\n\t'channels.channelParticipants': ChannelsChannelParticipants.channelsChannelParticipants,\n\t'channels.channelParticipant': ChannelsChannelParticipant.channelsChannelParticipant,\n\t'chatParticipantCreator': ChatParticipant.chatParticipantCreator,\n\t'chatParticipantAdmin': ChatParticipant.chatParticipantAdmin,\n\t'updateChatParticipantAdmin': Update.updateChatParticipantAdmin,\n\t'messageActionChatMigrateTo': MessageAction.messageActionChatMigrateTo,\n\t'messageActionChannelMigrateFrom': MessageAction.messageActionChannelMigrateFrom,\n\t'channelParticipantsBots': ChannelParticipantsFilter.channelParticipantsBots,\n\t'help.termsOfService': HelpTermsOfService.helpTermsOfService,\n\t'updateNewStickerSet': Update.updateNewStickerSet,\n\t'updateStickerSetsOrder': Update.updateStickerSetsOrder,\n\t'updateStickerSets': Update.updateStickerSets,\n\t'messages.savedGifsNotModified': MessagesSavedGifs.messagesSavedGifsNotModified,\n\t'messages.savedGifs': MessagesSavedGifs.messagesSavedGifs,\n\t'updateSavedGifs': Update.updateSavedGifs,\n\t'inputBotInlineMessageMediaAuto': InputBotInlineMessage.inputBotInlineMessageMediaAuto,\n\t'inputBotInlineMessageText': InputBotInlineMessage.inputBotInlineMessageText,\n\t'inputBotInlineResult': InputBotInlineResult.inputBotInlineResult,\n\t'botInlineMessageMediaAuto': BotInlineMessage.botInlineMessageMediaAuto,\n\t'botInlineMessageText': BotInlineMessage.botInlineMessageText,\n\t'botInlineResult': BotInlineResult.botInlineResult,\n\t'messages.botResults': MessagesBotResults.messagesBotResults,\n\t'updateBotInlineQuery': Update.updateBotInlineQuery,\n\t'updateBotInlineSend': Update.updateBotInlineSend,\n\t'inputMessagesFilterVoice': MessagesFilter.inputMessagesFilterVoice,\n\t'inputMessagesFilterMusic': MessagesFilter.inputMessagesFilterMusic,\n\t'inputPrivacyKeyChatInvite': InputPrivacyKey.inputPrivacyKeyChatInvite,\n\t'privacyKeyChatInvite': PrivacyKey.privacyKeyChatInvite,\n\t'exportedMessageLink': ExportedMessageLink.exportedMessageLink,\n\t'messageFwdHeader': MessageFwdHeader.messageFwdHeader,\n\t'updateEditChannelMessage': Update.updateEditChannelMessage,\n\t'messageActionPinMessage': MessageAction.messageActionPinMessage,\n\t'auth.codeTypeSms': AuthCodeType.authCodeTypeSms,\n\t'auth.codeTypeCall': AuthCodeType.authCodeTypeCall,\n\t'auth.codeTypeFlashCall': AuthCodeType.authCodeTypeFlashCall,\n\t'auth.sentCodeTypeApp': AuthSentCodeType.authSentCodeTypeApp,\n\t'auth.sentCodeTypeSms': AuthSentCodeType.authSentCodeTypeSms,\n\t'auth.sentCodeTypeCall': AuthSentCodeType.authSentCodeTypeCall,\n\t'auth.sentCodeTypeFlashCall': AuthSentCodeType.authSentCodeTypeFlashCall,\n\t'keyboardButtonUrl': KeyboardButton.keyboardButtonUrl,\n\t'keyboardButtonCallback': KeyboardButton.keyboardButtonCallback,\n\t'keyboardButtonRequestPhone': KeyboardButton.keyboardButtonRequestPhone,\n\t'keyboardButtonRequestGeoLocation': KeyboardButton.keyboardButtonRequestGeoLocation,\n\t'keyboardButtonSwitchInline': KeyboardButton.keyboardButtonSwitchInline,\n\t'replyInlineMarkup': ReplyMarkup.replyInlineMarkup,\n\t'messages.botCallbackAnswer': MessagesBotCallbackAnswer.messagesBotCallbackAnswer,\n\t'updateBotCallbackQuery': Update.updateBotCallbackQuery,\n\t'messages.messageEditData': MessagesMessageEditData.messagesMessageEditData,\n\t'updateEditMessage': Update.updateEditMessage,\n\t'inputBotInlineMessageMediaGeo': InputBotInlineMessage.inputBotInlineMessageMediaGeo,\n\t'inputBotInlineMessageMediaVenue': InputBotInlineMessage.inputBotInlineMessageMediaVenue,\n\t'inputBotInlineMessageMediaContact': InputBotInlineMessage.inputBotInlineMessageMediaContact,\n\t'botInlineMessageMediaGeo': BotInlineMessage.botInlineMessageMediaGeo,\n\t'botInlineMessageMediaVenue': BotInlineMessage.botInlineMessageMediaVenue,\n\t'botInlineMessageMediaContact': BotInlineMessage.botInlineMessageMediaContact,\n\t'inputBotInlineResultPhoto': InputBotInlineResult.inputBotInlineResultPhoto,\n\t'inputBotInlineResultDocument': InputBotInlineResult.inputBotInlineResultDocument,\n\t'botInlineMediaResult': BotInlineResult.botInlineMediaResult,\n\t'inputBotInlineMessageID': InputBotInlineMessageID.inputBotInlineMessageID,\n\t'updateInlineBotCallbackQuery': Update.updateInlineBotCallbackQuery,\n\t'inlineBotSwitchPM': InlineBotSwitchPM.inlineBotSwitchPM,\n\t'messages.peerDialogs': MessagesPeerDialogs.messagesPeerDialogs,\n\t'topPeer': TopPeer.topPeer,\n\t'topPeerCategoryBotsPM': TopPeerCategory.topPeerCategoryBotsPM,\n\t'topPeerCategoryBotsInline': TopPeerCategory.topPeerCategoryBotsInline,\n\t'topPeerCategoryCorrespondents': TopPeerCategory.topPeerCategoryCorrespondents,\n\t'topPeerCategoryGroups': TopPeerCategory.topPeerCategoryGroups,\n\t'topPeerCategoryChannels': TopPeerCategory.topPeerCategoryChannels,\n\t'topPeerCategoryPeers': TopPeerCategoryPeers.topPeerCategoryPeers,\n\t'contacts.topPeersNotModified': ContactsTopPeers.contactsTopPeersNotModified,\n\t'contacts.topPeers': ContactsTopPeers.contactsTopPeers,\n\t'messageEntityMentionName': MessageEntity.messageEntityMentionName,\n\t'inputMessageEntityMentionName': MessageEntity.inputMessageEntityMentionName,\n\t'inputMessagesFilterChatPhotos': MessagesFilter.inputMessagesFilterChatPhotos,\n\t'updateReadChannelOutbox': Update.updateReadChannelOutbox,\n\t'updateDraftMessage': Update.updateDraftMessage,\n\t'draftMessageEmpty': DraftMessage.draftMessageEmpty,\n\t'draftMessage': DraftMessage.draftMessage,\n\t'messageActionHistoryClear': MessageAction.messageActionHistoryClear,\n\t'messages.featuredStickersNotModified': MessagesFeaturedStickers.messagesFeaturedStickersNotModified,\n\t'messages.featuredStickers': MessagesFeaturedStickers.messagesFeaturedStickers,\n\t'updateReadFeaturedStickers': Update.updateReadFeaturedStickers,\n\t'messages.recentStickersNotModified': MessagesRecentStickers.messagesRecentStickersNotModified,\n\t'messages.recentStickers': MessagesRecentStickers.messagesRecentStickers,\n\t'updateRecentStickers': Update.updateRecentStickers,\n\t'messages.archivedStickers': MessagesArchivedStickers.messagesArchivedStickers,\n\t'messages.stickerSetInstallResultSuccess': MessagesStickerSetInstallResult.messagesStickerSetInstallResultSuccess,\n\t'messages.stickerSetInstallResultArchive': MessagesStickerSetInstallResult.messagesStickerSetInstallResultArchive,\n\t'stickerSetCovered': StickerSetCovered.stickerSetCovered,\n\t'updateConfig': Update.updateConfig,\n\t'updatePtsChanged': Update.updatePtsChanged,\n\t'inputMediaPhotoExternal': InputMedia.inputMediaPhotoExternal,\n\t'inputMediaDocumentExternal': InputMedia.inputMediaDocumentExternal,\n\t'stickerSetMultiCovered': StickerSetCovered.stickerSetMultiCovered,\n\t'maskCoords': MaskCoords.maskCoords,\n\t'documentAttributeHasStickers': DocumentAttribute.documentAttributeHasStickers,\n\t'inputStickeredMediaPhoto': InputStickeredMedia.inputStickeredMediaPhoto,\n\t'inputStickeredMediaDocument': InputStickeredMedia.inputStickeredMediaDocument,\n\t'game': Game.game,\n\t'inputBotInlineResultGame': InputBotInlineResult.inputBotInlineResultGame,\n\t'inputBotInlineMessageGame': InputBotInlineMessage.inputBotInlineMessageGame,\n\t'messageMediaGame': MessageMedia.messageMediaGame,\n\t'inputMediaGame': InputMedia.inputMediaGame,\n\t'inputGameID': InputGame.inputGameID,\n\t'inputGameShortName': InputGame.inputGameShortName,\n\t'keyboardButtonGame': KeyboardButton.keyboardButtonGame,\n\t'messageActionGameScore': MessageAction.messageActionGameScore,\n\t'highScore': HighScore.highScore,\n\t'messages.highScores': MessagesHighScores.messagesHighScores,\n\t'updates.differenceTooLong': UpdatesDifference.updatesDifferenceTooLong,\n\t'updateChannelWebPage': Update.updateChannelWebPage,\n\t'messages.chatsSlice': MessagesChats.messagesChatsSlice,\n\t'textEmpty': RichText.textEmpty,\n\t'textPlain': RichText.textPlain,\n\t'textBold': RichText.textBold,\n\t'textItalic': RichText.textItalic,\n\t'textUnderline': RichText.textUnderline,\n\t'textStrike': RichText.textStrike,\n\t'textFixed': RichText.textFixed,\n\t'textUrl': RichText.textUrl,\n\t'textEmail': RichText.textEmail,\n\t'textConcat': RichText.textConcat,\n\t'pageBlockUnsupported': PageBlock.pageBlockUnsupported,\n\t'pageBlockTitle': PageBlock.pageBlockTitle,\n\t'pageBlockSubtitle': PageBlock.pageBlockSubtitle,\n\t'pageBlockAuthorDate': PageBlock.pageBlockAuthorDate,\n\t'pageBlockHeader': PageBlock.pageBlockHeader,\n\t'pageBlockSubheader': PageBlock.pageBlockSubheader,\n\t'pageBlockParagraph': PageBlock.pageBlockParagraph,\n\t'pageBlockPreformatted': PageBlock.pageBlockPreformatted,\n\t'pageBlockFooter': PageBlock.pageBlockFooter,\n\t'pageBlockDivider': PageBlock.pageBlockDivider,\n\t'pageBlockAnchor': PageBlock.pageBlockAnchor,\n\t'pageBlockList': PageBlock.pageBlockList,\n\t'pageBlockBlockquote': PageBlock.pageBlockBlockquote,\n\t'pageBlockPullquote': PageBlock.pageBlockPullquote,\n\t'pageBlockPhoto': PageBlock.pageBlockPhoto,\n\t'pageBlockVideo': PageBlock.pageBlockVideo,\n\t'pageBlockCover': PageBlock.pageBlockCover,\n\t'pageBlockEmbed': PageBlock.pageBlockEmbed,\n\t'pageBlockEmbedPost': PageBlock.pageBlockEmbedPost,\n\t'pageBlockCollage': PageBlock.pageBlockCollage,\n\t'pageBlockSlideshow': PageBlock.pageBlockSlideshow,\n\t'webPageNotModified': WebPage.webPageNotModified,\n\t'inputPrivacyKeyPhoneCall': InputPrivacyKey.inputPrivacyKeyPhoneCall,\n\t'privacyKeyPhoneCall': PrivacyKey.privacyKeyPhoneCall,\n\t'sendMessageGamePlayAction': SendMessageAction.sendMessageGamePlayAction,\n\t'phoneCallDiscardReasonMissed': PhoneCallDiscardReason.phoneCallDiscardReasonMissed,\n\t'phoneCallDiscardReasonDisconnect': PhoneCallDiscardReason.phoneCallDiscardReasonDisconnect,\n\t'phoneCallDiscardReasonHangup': PhoneCallDiscardReason.phoneCallDiscardReasonHangup,\n\t'phoneCallDiscardReasonBusy': PhoneCallDiscardReason.phoneCallDiscardReasonBusy,\n\t'updateDialogPinned': Update.updateDialogPinned,\n\t'updatePinnedDialogs': Update.updatePinnedDialogs,\n\t'dataJSON': DataJSON.dataJSON,\n\t'updateBotWebhookJSON': Update.updateBotWebhookJSON,\n\t'updateBotWebhookJSONQuery': Update.updateBotWebhookJSONQuery,\n\t'labeledPrice': LabeledPrice.labeledPrice,\n\t'invoice': Invoice.invoice,\n\t'inputMediaInvoice': InputMedia.inputMediaInvoice,\n\t'paymentCharge': PaymentCharge.paymentCharge,\n\t'messageActionPaymentSentMe': MessageAction.messageActionPaymentSentMe,\n\t'messageMediaInvoice': MessageMedia.messageMediaInvoice,\n\t'postAddress': PostAddress.postAddress,\n\t'paymentRequestedInfo': PaymentRequestedInfo.paymentRequestedInfo,\n\t'keyboardButtonBuy': KeyboardButton.keyboardButtonBuy,\n\t'messageActionPaymentSent': MessageAction.messageActionPaymentSent,\n\t'paymentSavedCredentialsCard': PaymentSavedCredentials.paymentSavedCredentialsCard,\n\t'webDocument': WebDocument.webDocument,\n\t'inputWebDocument': InputWebDocument.inputWebDocument,\n\t'inputWebFileLocation': InputWebFileLocation.inputWebFileLocation,\n\t'upload.webFile': UploadWebFile.uploadWebFile,\n\t'payments.paymentForm': PaymentsPaymentForm.paymentsPaymentForm,\n\t'payments.validatedRequestedInfo': PaymentsValidatedRequestedInfo.paymentsValidatedRequestedInfo,\n\t'payments.paymentResult': PaymentsPaymentResult.paymentsPaymentResult,\n\t'payments.paymentReceipt': PaymentsPaymentReceipt.paymentsPaymentReceipt,\n\t'payments.savedInfo': PaymentsSavedInfo.paymentsSavedInfo,\n\t'inputPaymentCredentialsSaved': InputPaymentCredentials.inputPaymentCredentialsSaved,\n\t'inputPaymentCredentials': InputPaymentCredentials.inputPaymentCredentials,\n\t'account.tmpPassword': AccountTmpPassword.accountTmpPassword,\n\t'shippingOption': ShippingOption.shippingOption,\n\t'updateBotShippingQuery': Update.updateBotShippingQuery,\n\t'updateBotPrecheckoutQuery': Update.updateBotPrecheckoutQuery,\n\t'inputStickerSetItem': InputStickerSetItem.inputStickerSetItem,\n\t'updatePhoneCall': Update.updatePhoneCall,\n\t'inputPhoneCall': InputPhoneCall.inputPhoneCall,\n\t'phoneCallEmpty': PhoneCall.phoneCallEmpty,\n\t'phoneCallWaiting': PhoneCall.phoneCallWaiting,\n\t'phoneCallRequested': PhoneCall.phoneCallRequested,\n\t'phoneCallAccepted': PhoneCall.phoneCallAccepted,\n\t'phoneCall': PhoneCall.phoneCall,\n\t'phoneCallDiscarded': PhoneCall.phoneCallDiscarded,\n\t'phoneConnection': PhoneConnection.phoneConnection,\n\t'phoneCallProtocol': PhoneCallProtocol.phoneCallProtocol,\n\t'phone.phoneCall': PhonePhoneCall.phonePhoneCall,\n\t'inputMessagesFilterPhoneCalls': MessagesFilter.inputMessagesFilterPhoneCalls,\n\t'messageActionPhoneCall': MessageAction.messageActionPhoneCall,\n\t'inputMessagesFilterRoundVoice': MessagesFilter.inputMessagesFilterRoundVoice,\n\t'inputMessagesFilterRoundVideo': MessagesFilter.inputMessagesFilterRoundVideo,\n\t'sendMessageRecordRoundAction': SendMessageAction.sendMessageRecordRoundAction,\n\t'sendMessageUploadRoundAction': SendMessageAction.sendMessageUploadRoundAction,\n\t'upload.fileCdnRedirect': UploadFile.uploadFileCdnRedirect,\n\t'upload.cdnFileReuploadNeeded': UploadCdnFile.uploadCdnFileReuploadNeeded,\n\t'upload.cdnFile': UploadCdnFile.uploadCdnFile,\n\t'cdnPublicKey': CdnPublicKey.cdnPublicKey,\n\t'cdnConfig': CdnConfig.cdnConfig,\n\t'pageBlockChannel': PageBlock.pageBlockChannel,\n\t'langPackString': LangPackString.langPackString,\n\t'langPackStringPluralized': LangPackString.langPackStringPluralized,\n\t'langPackStringDeleted': LangPackString.langPackStringDeleted,\n\t'langPackDifference': LangPackDifference.langPackDifference,\n\t'langPackLanguage': LangPackLanguage.langPackLanguage,\n\t'updateLangPackTooLong': Update.updateLangPackTooLong,\n\t'updateLangPack': Update.updateLangPack,\n\t'channelParticipantAdmin': ChannelParticipant.channelParticipantAdmin,\n\t'channelParticipantBanned': ChannelParticipant.channelParticipantBanned,\n\t'channelParticipantsBanned': ChannelParticipantsFilter.channelParticipantsBanned,\n\t'channelParticipantsSearch': ChannelParticipantsFilter.channelParticipantsSearch,\n\t'channelAdminLogEventActionChangeTitle': ChannelAdminLogEventAction.channelAdminLogEventActionChangeTitle,\n\t'channelAdminLogEventActionChangeAbout': ChannelAdminLogEventAction.channelAdminLogEventActionChangeAbout,\n\t'channelAdminLogEventActionChangeUsername': ChannelAdminLogEventAction.channelAdminLogEventActionChangeUsername,\n\t'channelAdminLogEventActionChangePhoto': ChannelAdminLogEventAction.channelAdminLogEventActionChangePhoto,\n\t'channelAdminLogEventActionToggleInvites': ChannelAdminLogEventAction.channelAdminLogEventActionToggleInvites,\n\t'channelAdminLogEventActionToggleSignatures': ChannelAdminLogEventAction.channelAdminLogEventActionToggleSignatures,\n\t'channelAdminLogEventActionUpdatePinned': ChannelAdminLogEventAction.channelAdminLogEventActionUpdatePinned,\n\t'channelAdminLogEventActionEditMessage': ChannelAdminLogEventAction.channelAdminLogEventActionEditMessage,\n\t'channelAdminLogEventActionDeleteMessage': ChannelAdminLogEventAction.channelAdminLogEventActionDeleteMessage,\n\t'channelAdminLogEventActionParticipantJoin': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantJoin,\n\t'channelAdminLogEventActionParticipantLeave': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantLeave,\n\t'channelAdminLogEventActionParticipantInvite': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantInvite,\n\t'channelAdminLogEventActionParticipantToggleBan': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantToggleBan,\n\t'channelAdminLogEventActionParticipantToggleAdmin': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantToggleAdmin,\n\t'channelAdminLogEvent': ChannelAdminLogEvent.channelAdminLogEvent,\n\t'channels.adminLogResults': ChannelsAdminLogResults.channelsAdminLogResults,\n\t'channelAdminLogEventsFilter': ChannelAdminLogEventsFilter.channelAdminLogEventsFilter,\n\t'topPeerCategoryPhoneCalls': TopPeerCategory.topPeerCategoryPhoneCalls,\n\t'pageBlockAudio': PageBlock.pageBlockAudio,\n\t'popularContact': PopularContact.popularContact,\n\t'messageActionScreenshotTaken': MessageAction.messageActionScreenshotTaken,\n\t'messages.favedStickersNotModified': MessagesFavedStickers.messagesFavedStickersNotModified,\n\t'messages.favedStickers': MessagesFavedStickers.messagesFavedStickers,\n\t'updateFavedStickers': Update.updateFavedStickers,\n\t'updateChannelReadMessagesContents': Update.updateChannelReadMessagesContents,\n\t'inputMessagesFilterMyMentions': MessagesFilter.inputMessagesFilterMyMentions,\n\t'updateContactsReset': Update.updateContactsReset,\n\t'channelAdminLogEventActionChangeStickerSet': ChannelAdminLogEventAction.channelAdminLogEventActionChangeStickerSet,\n\t'messageActionCustomAction': MessageAction.messageActionCustomAction,\n\t'inputPaymentCredentialsApplePay': InputPaymentCredentials.inputPaymentCredentialsApplePay,\n\t'inputMessagesFilterGeo': MessagesFilter.inputMessagesFilterGeo,\n\t'inputMessagesFilterContacts': MessagesFilter.inputMessagesFilterContacts,\n\t'updateChannelAvailableMessages': Update.updateChannelAvailableMessages,\n\t'channelAdminLogEventActionTogglePreHistoryHidden': ChannelAdminLogEventAction.channelAdminLogEventActionTogglePreHistoryHidden,\n\t'inputMediaGeoLive': InputMedia.inputMediaGeoLive,\n\t'messageMediaGeoLive': MessageMedia.messageMediaGeoLive,\n\t'recentMeUrlUnknown': RecentMeUrl.recentMeUrlUnknown,\n\t'recentMeUrlUser': RecentMeUrl.recentMeUrlUser,\n\t'recentMeUrlChat': RecentMeUrl.recentMeUrlChat,\n\t'recentMeUrlChatInvite': RecentMeUrl.recentMeUrlChatInvite,\n\t'recentMeUrlStickerSet': RecentMeUrl.recentMeUrlStickerSet,\n\t'help.recentMeUrls': HelpRecentMeUrls.helpRecentMeUrls,\n\t'channels.channelParticipantsNotModified': ChannelsChannelParticipants.channelsChannelParticipantsNotModified,\n\t'messages.messagesNotModified': MessagesMessages.messagesMessagesNotModified,\n\t'inputSingleMedia': InputSingleMedia.inputSingleMedia,\n\t'webAuthorization': WebAuthorization.webAuthorization,\n\t'account.webAuthorizations': AccountWebAuthorizations.accountWebAuthorizations,\n\t'inputMessageID': InputMessage.inputMessageID,\n\t'inputMessageReplyTo': InputMessage.inputMessageReplyTo,\n\t'inputMessagePinned': InputMessage.inputMessagePinned,\n\t'messageEntityPhone': MessageEntity.messageEntityPhone,\n\t'messageEntityCashtag': MessageEntity.messageEntityCashtag,\n\t'messageActionBotAllowed': MessageAction.messageActionBotAllowed,\n\t'inputDialogPeer': InputDialogPeer.inputDialogPeer,\n\t'dialogPeer': DialogPeer.dialogPeer,\n\t'messages.foundStickerSetsNotModified': MessagesFoundStickerSets.messagesFoundStickerSetsNotModified,\n\t'messages.foundStickerSets': MessagesFoundStickerSets.messagesFoundStickerSets,\n\t'fileHash': FileHash.fileHash,\n\t'webDocumentNoProxy': WebDocument.webDocumentNoProxy,\n\t'inputClientProxy': InputClientProxy.inputClientProxy,\n\t'help.termsOfServiceUpdateEmpty': HelpTermsOfServiceUpdate.helpTermsOfServiceUpdateEmpty,\n\t'help.termsOfServiceUpdate': HelpTermsOfServiceUpdate.helpTermsOfServiceUpdate,\n\t'inputSecureFileUploaded': InputSecureFile.inputSecureFileUploaded,\n\t'inputSecureFile': InputSecureFile.inputSecureFile,\n\t'inputSecureFileLocation': InputFileLocation.inputSecureFileLocation,\n\t'secureFileEmpty': SecureFile.secureFileEmpty,\n\t'secureFile': SecureFile.secureFile,\n\t'secureData': SecureData.secureData,\n\t'securePlainPhone': SecurePlainData.securePlainPhone,\n\t'securePlainEmail': SecurePlainData.securePlainEmail,\n\t'secureValueTypePersonalDetails': SecureValueType.secureValueTypePersonalDetails,\n\t'secureValueTypePassport': SecureValueType.secureValueTypePassport,\n\t'secureValueTypeDriverLicense': SecureValueType.secureValueTypeDriverLicense,\n\t'secureValueTypeIdentityCard': SecureValueType.secureValueTypeIdentityCard,\n\t'secureValueTypeInternalPassport': SecureValueType.secureValueTypeInternalPassport,\n\t'secureValueTypeAddress': SecureValueType.secureValueTypeAddress,\n\t'secureValueTypeUtilityBill': SecureValueType.secureValueTypeUtilityBill,\n\t'secureValueTypeBankStatement': SecureValueType.secureValueTypeBankStatement,\n\t'secureValueTypeRentalAgreement': SecureValueType.secureValueTypeRentalAgreement,\n\t'secureValueTypePassportRegistration': SecureValueType.secureValueTypePassportRegistration,\n\t'secureValueTypeTemporaryRegistration': SecureValueType.secureValueTypeTemporaryRegistration,\n\t'secureValueTypePhone': SecureValueType.secureValueTypePhone,\n\t'secureValueTypeEmail': SecureValueType.secureValueTypeEmail,\n\t'secureValue': SecureValue.secureValue,\n\t'inputSecureValue': InputSecureValue.inputSecureValue,\n\t'secureValueHash': SecureValueHash.secureValueHash,\n\t'secureValueErrorData': SecureValueError.secureValueErrorData,\n\t'secureValueErrorFrontSide': SecureValueError.secureValueErrorFrontSide,\n\t'secureValueErrorReverseSide': SecureValueError.secureValueErrorReverseSide,\n\t'secureValueErrorSelfie': SecureValueError.secureValueErrorSelfie,\n\t'secureValueErrorFile': SecureValueError.secureValueErrorFile,\n\t'secureValueErrorFiles': SecureValueError.secureValueErrorFiles,\n\t'secureCredentialsEncrypted': SecureCredentialsEncrypted.secureCredentialsEncrypted,\n\t'account.authorizationForm': AccountAuthorizationForm.accountAuthorizationForm,\n\t'account.sentEmailCode': AccountSentEmailCode.accountSentEmailCode,\n\t'messageActionSecureValuesSentMe': MessageAction.messageActionSecureValuesSentMe,\n\t'messageActionSecureValuesSent': MessageAction.messageActionSecureValuesSent,\n\t'help.deepLinkInfoEmpty': HelpDeepLinkInfo.helpDeepLinkInfoEmpty,\n\t'help.deepLinkInfo': HelpDeepLinkInfo.helpDeepLinkInfo,\n\t'savedPhoneContact': SavedContact.savedPhoneContact,\n\t'account.takeout': AccountTakeout.accountTakeout,\n\t'inputTakeoutFileLocation': InputFileLocation.inputTakeoutFileLocation,\n\t'updateDialogUnreadMark': Update.updateDialogUnreadMark,\n\t'messages.dialogsNotModified': MessagesDialogs.messagesDialogsNotModified,\n\t'inputWebFileGeoPointLocation': InputWebFileLocation.inputWebFileGeoPointLocation,\n\t'contacts.topPeersDisabled': ContactsTopPeers.contactsTopPeersDisabled,\n\t'inputReportReasonCopyright': ReportReason.inputReportReasonCopyright,\n\t'passwordKdfAlgoUnknown': PasswordKdfAlgo.passwordKdfAlgoUnknown,\n\t'securePasswordKdfAlgoUnknown': SecurePasswordKdfAlgo.securePasswordKdfAlgoUnknown,\n\t'securePasswordKdfAlgoPBKDF2HMACSHA512iter100000': SecurePasswordKdfAlgo.securePasswordKdfAlgoPBKDF2HMACSHA512iter100000,\n\t'securePasswordKdfAlgoSHA512': SecurePasswordKdfAlgo.securePasswordKdfAlgoSHA512,\n\t'secureSecretSettings': SecureSecretSettings.secureSecretSettings,\n\t'passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow': PasswordKdfAlgo.passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow,\n\t'inputCheckPasswordEmpty': InputCheckPasswordSRP.inputCheckPasswordEmpty,\n\t'inputCheckPasswordSRP': InputCheckPasswordSRP.inputCheckPasswordSRP,\n\t'secureValueError': SecureValueError.secureValueError,\n\t'secureValueErrorTranslationFile': SecureValueError.secureValueErrorTranslationFile,\n\t'secureValueErrorTranslationFiles': SecureValueError.secureValueErrorTranslationFiles,\n\t'secureRequiredType': SecureRequiredType.secureRequiredType,\n\t'secureRequiredTypeOneOf': SecureRequiredType.secureRequiredTypeOneOf,\n\t'help.passportConfigNotModified': HelpPassportConfig.helpPassportConfigNotModified,\n\t'help.passportConfig': HelpPassportConfig.helpPassportConfig,\n\t'inputAppEvent': InputAppEvent.inputAppEvent,\n\t'jsonObjectValue': JSONObjectValue.jsonObjectValue,\n\t'jsonNull': JSONValue.jsonNull,\n\t'jsonBool': JSONValue.jsonBool,\n\t'jsonNumber': JSONValue.jsonNumber,\n\t'jsonString': JSONValue.jsonString,\n\t'jsonArray': JSONValue.jsonArray,\n\t'jsonObject': JSONValue.jsonObject,\n\t'inputNotifyBroadcasts': InputNotifyPeer.inputNotifyBroadcasts,\n\t'notifyBroadcasts': NotifyPeer.notifyBroadcasts,\n\t'textSubscript': RichText.textSubscript,\n\t'textSuperscript': RichText.textSuperscript,\n\t'textMarked': RichText.textMarked,\n\t'textPhone': RichText.textPhone,\n\t'textImage': RichText.textImage,\n\t'pageBlockKicker': PageBlock.pageBlockKicker,\n\t'pageTableCell': PageTableCell.pageTableCell,\n\t'pageTableRow': PageTableRow.pageTableRow,\n\t'pageBlockTable': PageBlock.pageBlockTable,\n\t'pageCaption': PageCaption.pageCaption,\n\t'pageListItemText': PageListItem.pageListItemText,\n\t'pageListItemBlocks': PageListItem.pageListItemBlocks,\n\t'pageListOrderedItemText': PageListOrderedItem.pageListOrderedItemText,\n\t'pageListOrderedItemBlocks': PageListOrderedItem.pageListOrderedItemBlocks,\n\t'pageBlockOrderedList': PageBlock.pageBlockOrderedList,\n\t'pageBlockDetails': PageBlock.pageBlockDetails,\n\t'pageRelatedArticle': PageRelatedArticle.pageRelatedArticle,\n\t'pageBlockRelatedArticles': PageBlock.pageBlockRelatedArticles,\n\t'pageBlockMap': PageBlock.pageBlockMap,\n\t'page': Page.page,\n\t'inputPrivacyKeyPhoneP2P': InputPrivacyKey.inputPrivacyKeyPhoneP2P,\n\t'privacyKeyPhoneP2P': PrivacyKey.privacyKeyPhoneP2P,\n\t'textAnchor': RichText.textAnchor,\n\t'help.supportName': HelpSupportName.helpSupportName,\n\t'help.userInfoEmpty': HelpUserInfo.helpUserInfoEmpty,\n\t'help.userInfo': HelpUserInfo.helpUserInfo,\n\t'messageActionContactSignUp': MessageAction.messageActionContactSignUp,\n\t'updateMessagePoll': Update.updateMessagePoll,\n\t'pollAnswer': PollAnswer.pollAnswer,\n\t'poll': Poll.poll,\n\t'pollAnswerVoters': PollAnswerVoters.pollAnswerVoters,\n\t'pollResults': PollResults.pollResults,\n\t'inputMediaPoll': InputMedia.inputMediaPoll,\n\t'messageMediaPoll': MessageMedia.messageMediaPoll,\n\t'chatOnlines': ChatOnlines.chatOnlines,\n\t'statsURL': StatsURL.statsURL,\n\t'photoStrippedSize': PhotoSize.photoStrippedSize,\n\t'chatAdminRights': ChatAdminRights.chatAdminRights,\n\t'chatBannedRights': ChatBannedRights.chatBannedRights,\n\t'updateChatDefaultBannedRights': Update.updateChatDefaultBannedRights,\n\t'inputWallPaper': InputWallPaper.inputWallPaper,\n\t'inputWallPaperSlug': InputWallPaper.inputWallPaperSlug,\n\t'channelParticipantsContacts': ChannelParticipantsFilter.channelParticipantsContacts,\n\t'channelAdminLogEventActionDefaultBannedRights': ChannelAdminLogEventAction.channelAdminLogEventActionDefaultBannedRights,\n\t'channelAdminLogEventActionStopPoll': ChannelAdminLogEventAction.channelAdminLogEventActionStopPoll,\n\t'account.wallPapersNotModified': AccountWallPapers.accountWallPapersNotModified,\n\t'account.wallPapers': AccountWallPapers.accountWallPapers,\n\t'codeSettings': CodeSettings.codeSettings,\n\t'wallPaperSettings': WallPaperSettings.wallPaperSettings,\n\t'autoDownloadSettings': AutoDownloadSettings.autoDownloadSettings,\n\t'account.autoDownloadSettings': AccountAutoDownloadSettings.accountAutoDownloadSettings,\n\t'emojiKeyword': EmojiKeyword.emojiKeyword,\n\t'emojiKeywordDeleted': EmojiKeyword.emojiKeywordDeleted,\n\t'emojiKeywordsDifference': EmojiKeywordsDifference.emojiKeywordsDifference,\n\t'emojiURL': EmojiURL.emojiURL,\n\t'emojiLanguage': EmojiLanguage.emojiLanguage,\n\t'inputPrivacyKeyForwards': InputPrivacyKey.inputPrivacyKeyForwards,\n\t'privacyKeyForwards': PrivacyKey.privacyKeyForwards,\n\t'inputPrivacyKeyProfilePhoto': InputPrivacyKey.inputPrivacyKeyProfilePhoto,\n\t'privacyKeyProfilePhoto': PrivacyKey.privacyKeyProfilePhoto,\n\t'inputPhotoFileLocation': InputFileLocation.inputPhotoFileLocation,\n\t'inputPhotoLegacyFileLocation': InputFileLocation.inputPhotoLegacyFileLocation,\n\t'inputPeerPhotoFileLocation': InputFileLocation.inputPeerPhotoFileLocation,\n\t'inputStickerSetThumb': InputFileLocation.inputStickerSetThumb,\n\t'folder': Folder.folder,\n\t'dialogFolder': Dialog.dialogFolder,\n\t'inputDialogPeerFolder': InputDialogPeer.inputDialogPeerFolder,\n\t'dialogPeerFolder': DialogPeer.dialogPeerFolder,\n\t'inputFolderPeer': InputFolderPeer.inputFolderPeer,\n\t'folderPeer': FolderPeer.folderPeer,\n\t'updateFolderPeers': Update.updateFolderPeers,\n\t'inputUserFromMessage': InputUser.inputUserFromMessage,\n\t'inputChannelFromMessage': InputChannel.inputChannelFromMessage,\n\t'inputPeerUserFromMessage': InputPeer.inputPeerUserFromMessage,\n\t'inputPeerChannelFromMessage': InputPeer.inputPeerChannelFromMessage,\n\t'inputPrivacyKeyPhoneNumber': InputPrivacyKey.inputPrivacyKeyPhoneNumber,\n\t'privacyKeyPhoneNumber': PrivacyKey.privacyKeyPhoneNumber,\n\t'topPeerCategoryForwardUsers': TopPeerCategory.topPeerCategoryForwardUsers,\n\t'topPeerCategoryForwardChats': TopPeerCategory.topPeerCategoryForwardChats,\n\t'channelAdminLogEventActionChangeLinkedChat': ChannelAdminLogEventAction.channelAdminLogEventActionChangeLinkedChat,\n\t'messages.searchCounter': MessagesSearchCounter.messagesSearchCounter,\n\t'keyboardButtonUrlAuth': KeyboardButton.keyboardButtonUrlAuth,\n\t'inputKeyboardButtonUrlAuth': KeyboardButton.inputKeyboardButtonUrlAuth,\n\t'urlAuthResultRequest': UrlAuthResult.urlAuthResultRequest,\n\t'urlAuthResultAccepted': UrlAuthResult.urlAuthResultAccepted,\n\t'urlAuthResultDefault': UrlAuthResult.urlAuthResultDefault,\n\t'inputPrivacyValueAllowChatParticipants': InputPrivacyRule.inputPrivacyValueAllowChatParticipants,\n\t'inputPrivacyValueDisallowChatParticipants': InputPrivacyRule.inputPrivacyValueDisallowChatParticipants,\n\t'privacyValueAllowChatParticipants': PrivacyRule.privacyValueAllowChatParticipants,\n\t'privacyValueDisallowChatParticipants': PrivacyRule.privacyValueDisallowChatParticipants,\n\t'messageEntityUnderline': MessageEntity.messageEntityUnderline,\n\t'messageEntityStrike': MessageEntity.messageEntityStrike,\n\t'messageEntityBlockquote': MessageEntity.messageEntityBlockquote,\n\t'updatePeerSettings': Update.updatePeerSettings,\n\t'channelLocationEmpty': ChannelLocation.channelLocationEmpty,\n\t'channelLocation': ChannelLocation.channelLocation,\n\t'peerLocated': PeerLocated.peerLocated,\n\t'updatePeerLocated': Update.updatePeerLocated,\n\t'channelAdminLogEventActionChangeLocation': ChannelAdminLogEventAction.channelAdminLogEventActionChangeLocation,\n\t'inputReportReasonGeoIrrelevant': ReportReason.inputReportReasonGeoIrrelevant,\n\t'channelAdminLogEventActionToggleSlowMode': ChannelAdminLogEventAction.channelAdminLogEventActionToggleSlowMode,\n\t'auth.authorizationSignUpRequired': AuthAuthorization.authAuthorizationSignUpRequired,\n\t'payments.paymentVerificationNeeded': PaymentsPaymentResult.paymentsPaymentVerificationNeeded,\n\t'inputStickerSetAnimatedEmoji': InputStickerSet.inputStickerSetAnimatedEmoji,\n\t'updateNewScheduledMessage': Update.updateNewScheduledMessage,\n\t'updateDeleteScheduledMessages': Update.updateDeleteScheduledMessages,\n\t'restrictionReason': RestrictionReason.restrictionReason,\n\t'inputTheme': InputTheme.inputTheme,\n\t'inputThemeSlug': InputTheme.inputThemeSlug,\n\t'theme': Theme.theme,\n\t'account.themesNotModified': AccountThemes.accountThemesNotModified,\n\t'account.themes': AccountThemes.accountThemes,\n\t'updateTheme': Update.updateTheme,\n\t'inputPrivacyKeyAddedByPhone': InputPrivacyKey.inputPrivacyKeyAddedByPhone,\n\t'privacyKeyAddedByPhone': PrivacyKey.privacyKeyAddedByPhone,\n\t'updateGeoLiveViewed': Update.updateGeoLiveViewed,\n\t'updateLoginToken': Update.updateLoginToken,\n\t'auth.loginToken': AuthLoginToken.authLoginToken,\n\t'auth.loginTokenMigrateTo': AuthLoginToken.authLoginTokenMigrateTo,\n\t'auth.loginTokenSuccess': AuthLoginToken.authLoginTokenSuccess,\n\t'account.contentSettings': AccountContentSettings.accountContentSettings,\n\t'messages.inactiveChats': MessagesInactiveChats.messagesInactiveChats,\n\t'baseThemeClassic': BaseTheme.baseThemeClassic,\n\t'baseThemeDay': BaseTheme.baseThemeDay,\n\t'baseThemeNight': BaseTheme.baseThemeNight,\n\t'baseThemeTinted': BaseTheme.baseThemeTinted,\n\t'baseThemeArctic': BaseTheme.baseThemeArctic,\n\t'inputWallPaperNoFile': InputWallPaper.inputWallPaperNoFile,\n\t'wallPaperNoFile': WallPaper.wallPaperNoFile,\n\t'inputThemeSettings': InputThemeSettings.inputThemeSettings,\n\t'themeSettings': ThemeSettings.themeSettings,\n\t'webPageAttributeTheme': WebPageAttribute.webPageAttributeTheme,\n\t'updateMessagePollVote': Update.updateMessagePollVote,\n\t'messageUserVote': MessageUserVote.messageUserVote,\n\t'messageUserVoteInputOption': MessageUserVote.messageUserVoteInputOption,\n\t'messageUserVoteMultiple': MessageUserVote.messageUserVoteMultiple,\n\t'messages.votesList': MessagesVotesList.messagesVotesList,\n\t'keyboardButtonRequestPoll': KeyboardButton.keyboardButtonRequestPoll,\n\t'messageEntityBankCard': MessageEntity.messageEntityBankCard,\n\t'bankCardOpenUrl': BankCardOpenUrl.bankCardOpenUrl,\n\t'payments.bankCardData': PaymentsBankCardData.paymentsBankCardData,\n\t'peerSelfLocated': PeerLocated.peerSelfLocated,\n\t'dialogFilter': DialogFilter.dialogFilter,\n\t'dialogFilterSuggested': DialogFilterSuggested.dialogFilterSuggested,\n\t'updateDialogFilter': Update.updateDialogFilter,\n\t'updateDialogFilterOrder': Update.updateDialogFilterOrder,\n\t'updateDialogFilters': Update.updateDialogFilters,\n\t'statsDateRangeDays': StatsDateRangeDays.statsDateRangeDays,\n\t'statsAbsValueAndPrev': StatsAbsValueAndPrev.statsAbsValueAndPrev,\n\t'statsPercentValue': StatsPercentValue.statsPercentValue,\n\t'statsGraphAsync': StatsGraph.statsGraphAsync,\n\t'statsGraphError': StatsGraph.statsGraphError,\n\t'statsGraph': StatsGraph.statsGraph,\n\t'messageInteractionCounters': MessageInteractionCounters.messageInteractionCounters,\n\t'stats.broadcastStats': StatsBroadcastStats.statsBroadcastStats,\n\t'inputMediaDice': InputMedia.inputMediaDice,\n\t'messageMediaDice': MessageMedia.messageMediaDice,\n\t'inputStickerSetDice': InputStickerSet.inputStickerSetDice,\n\t'help.promoDataEmpty': HelpPromoData.helpPromoDataEmpty,\n\t'help.promoData': HelpPromoData.helpPromoData,\n\t'videoSize': VideoSize.videoSize,\n\t'updatePhoneCallSignalingData': Update.updatePhoneCallSignalingData,\n\t'chatInvitePeek': ChatInvite.chatInvitePeek,\n\t'statsGroupTopPoster': StatsGroupTopPoster.statsGroupTopPoster,\n\t'statsGroupTopAdmin': StatsGroupTopAdmin.statsGroupTopAdmin,\n\t'statsGroupTopInviter': StatsGroupTopInviter.statsGroupTopInviter,\n\t'stats.megagroupStats': StatsMegagroupStats.statsMegagroupStats,\n\t'globalPrivacySettings': GlobalPrivacySettings.globalPrivacySettings,\n\t'phoneConnectionWebrtc': PhoneConnection.phoneConnectionWebrtc,\n\t'help.countryCode': HelpCountryCode.helpCountryCode,\n\t'help.country': HelpCountry.helpCountry,\n\t'help.countriesListNotModified': HelpCountriesList.helpCountriesListNotModified,\n\t'help.countriesList': HelpCountriesList.helpCountriesList,\n\t'messageViews': MessageViews.messageViews,\n\t'updateChannelMessageForwards': Update.updateChannelMessageForwards,\n\t'photoSizeProgressive': PhotoSize.photoSizeProgressive,\n\t'messages.messageViews': MessagesMessageViews.messagesMessageViews,\n\t'updateReadChannelDiscussionInbox': Update.updateReadChannelDiscussionInbox,\n\t'updateReadChannelDiscussionOutbox': Update.updateReadChannelDiscussionOutbox,\n\t'messages.discussionMessage': MessagesDiscussionMessage.messagesDiscussionMessage,\n\t'messageReplyHeader': MessageReplyHeader.messageReplyHeader,\n\t'messageReplies': MessageReplies.messageReplies,\n\t'updatePeerBlocked': Update.updatePeerBlocked,\n\t'peerBlocked': PeerBlocked.peerBlocked,\n\t'updateChannelUserTyping': Update.updateChannelUserTyping,\n\t'inputMessageCallbackQuery': InputMessage.inputMessageCallbackQuery,\n\t'channelParticipantLeft': ChannelParticipant.channelParticipantLeft,\n\t'channelParticipantsMentions': ChannelParticipantsFilter.channelParticipantsMentions,\n\t'updatePinnedMessages': Update.updatePinnedMessages,\n\t'updatePinnedChannelMessages': Update.updatePinnedChannelMessages,\n\t'inputMessagesFilterPinned': MessagesFilter.inputMessagesFilterPinned,\n\t'stats.messageStats': StatsMessageStats.statsMessageStats,\n\t'messageActionGeoProximityReached': MessageAction.messageActionGeoProximityReached,\n\t'photoPathSize': PhotoSize.photoPathSize,\n\t'speakingInGroupCallAction': SendMessageAction.speakingInGroupCallAction,\n\t'groupCallDiscarded': GroupCall.groupCallDiscarded,\n\t'groupCall': GroupCall.groupCall,\n\t'inputGroupCall': InputGroupCall.inputGroupCall,\n\t'messageActionGroupCall': MessageAction.messageActionGroupCall,\n\t'messageActionInviteToGroupCall': MessageAction.messageActionInviteToGroupCall,\n\t'groupCallParticipant': GroupCallParticipant.groupCallParticipant,\n\t'updateChat': Update.updateChat,\n\t'updateGroupCallParticipants': Update.updateGroupCallParticipants,\n\t'updateGroupCall': Update.updateGroupCall,\n\t'phone.groupCall': PhoneGroupCall.phoneGroupCall,\n\t'phone.groupParticipants': PhoneGroupParticipants.phoneGroupParticipants,\n\t'inlineQueryPeerTypeSameBotPM': InlineQueryPeerType.inlineQueryPeerTypeSameBotPM,\n\t'inlineQueryPeerTypePM': InlineQueryPeerType.inlineQueryPeerTypePM,\n\t'inlineQueryPeerTypeChat': InlineQueryPeerType.inlineQueryPeerTypeChat,\n\t'inlineQueryPeerTypeMegagroup': InlineQueryPeerType.inlineQueryPeerTypeMegagroup,\n\t'inlineQueryPeerTypeBroadcast': InlineQueryPeerType.inlineQueryPeerTypeBroadcast,\n\t'channelAdminLogEventActionStartGroupCall': ChannelAdminLogEventAction.channelAdminLogEventActionStartGroupCall,\n\t'channelAdminLogEventActionDiscardGroupCall': ChannelAdminLogEventAction.channelAdminLogEventActionDiscardGroupCall,\n\t'channelAdminLogEventActionParticipantMute': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantMute,\n\t'channelAdminLogEventActionParticipantUnmute': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantUnmute,\n\t'channelAdminLogEventActionToggleGroupCallSetting': ChannelAdminLogEventAction.channelAdminLogEventActionToggleGroupCallSetting,\n\t'inputPaymentCredentialsGooglePay': InputPaymentCredentials.inputPaymentCredentialsGooglePay,\n\t'messages.historyImport': MessagesHistoryImport.messagesHistoryImport,\n\t'sendMessageHistoryImportAction': SendMessageAction.sendMessageHistoryImportAction,\n\t'messages.historyImportParsed': MessagesHistoryImportParsed.messagesHistoryImportParsed,\n\t'inputReportReasonFake': ReportReason.inputReportReasonFake,\n\t'messages.affectedFoundMessages': MessagesAffectedFoundMessages.messagesAffectedFoundMessages,\n\t'messageActionSetMessagesTTL': MessageAction.messageActionSetMessagesTTL,\n\t'updatePeerHistoryTTL': Update.updatePeerHistoryTTL,\n\t'updateChatParticipant': Update.updateChatParticipant,\n\t'updateChannelParticipant': Update.updateChannelParticipant,\n\t'updateBotStopped': Update.updateBotStopped,\n\t'chatInviteImporter': ChatInviteImporter.chatInviteImporter,\n\t'messages.exportedChatInvites': MessagesExportedChatInvites.messagesExportedChatInvites,\n\t'messages.exportedChatInvite': MessagesExportedChatInvite.messagesExportedChatInvite,\n\t'messages.exportedChatInviteReplaced': MessagesExportedChatInvite.messagesExportedChatInviteReplaced,\n\t'messages.chatInviteImporters': MessagesChatInviteImporters.messagesChatInviteImporters,\n\t'chatAdminWithInvites': ChatAdminWithInvites.chatAdminWithInvites,\n\t'messages.chatAdminsWithInvites': MessagesChatAdminsWithInvites.messagesChatAdminsWithInvites,\n\t'channelAdminLogEventActionParticipantJoinByInvite': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantJoinByInvite,\n\t'channelAdminLogEventActionExportedInviteDelete': ChannelAdminLogEventAction.channelAdminLogEventActionExportedInviteDelete,\n\t'channelAdminLogEventActionExportedInviteRevoke': ChannelAdminLogEventAction.channelAdminLogEventActionExportedInviteRevoke,\n\t'channelAdminLogEventActionExportedInviteEdit': ChannelAdminLogEventAction.channelAdminLogEventActionExportedInviteEdit,\n\t'channelAdminLogEventActionParticipantVolume': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantVolume,\n\t'channelAdminLogEventActionChangeHistoryTTL': ChannelAdminLogEventAction.channelAdminLogEventActionChangeHistoryTTL,\n\t'messages.checkedHistoryImportPeer': MessagesCheckedHistoryImportPeer.messagesCheckedHistoryImportPeer,\n\t'inputGroupCallStream': InputFileLocation.inputGroupCallStream,\n\t'phone.joinAsPeers': PhoneJoinAsPeers.phoneJoinAsPeers,\n\t'phone.exportedGroupCallInvite': PhoneExportedGroupCallInvite.phoneExportedGroupCallInvite,\n\t'inputBotInlineMessageMediaInvoice': InputBotInlineMessage.inputBotInlineMessageMediaInvoice,\n\t'botInlineMessageMediaInvoice': BotInlineMessage.botInlineMessageMediaInvoice,\n\t'messageActionGroupCallScheduled': MessageAction.messageActionGroupCallScheduled,\n\t'groupCallParticipantVideoSourceGroup': GroupCallParticipantVideoSourceGroup.groupCallParticipantVideoSourceGroup,\n\t'groupCallParticipantVideo': GroupCallParticipantVideo.groupCallParticipantVideo,\n\t'updateGroupCallConnection': Update.updateGroupCallConnection,\n\t'stickers.suggestedShortName': StickersSuggestedShortName.stickersSuggestedShortName,\n\t'botCommandScopeDefault': BotCommandScope.botCommandScopeDefault,\n\t'botCommandScopeUsers': BotCommandScope.botCommandScopeUsers,\n\t'botCommandScopeChats': BotCommandScope.botCommandScopeChats,\n\t'botCommandScopeChatAdmins': BotCommandScope.botCommandScopeChatAdmins,\n\t'botCommandScopePeer': BotCommandScope.botCommandScopePeer,\n\t'botCommandScopePeerAdmins': BotCommandScope.botCommandScopePeerAdmins,\n\t'botCommandScopePeerUser': BotCommandScope.botCommandScopePeerUser,\n\t'account.resetPasswordFailedWait': AccountResetPasswordResult.accountResetPasswordFailedWait,\n\t'account.resetPasswordRequestedWait': AccountResetPasswordResult.accountResetPasswordRequestedWait,\n\t'account.resetPasswordOk': AccountResetPasswordResult.accountResetPasswordOk,\n\t'updateBotCommands': Update.updateBotCommands,\n\t'messageEntityEmoji': MessageEntity.messageEntityEmoji,\n\t'messageEntityHighlight': MessageEntity.messageEntityHighlight,\n\t'messageEntityLinebreak': MessageEntity.messageEntityLinebreak,\n\t'messageEntityCaret': MessageEntity.messageEntityCaret,\n\t'messageActionChatLeave': MessageAction.messageActionChatLeave,\n\t'messageActionChannelDeletePhoto': MessageAction.messageActionChannelDeletePhoto,\n\t'messageActionChannelEditTitle': MessageAction.messageActionChannelEditTitle,\n\t'messageActionChannelEditPhoto': MessageAction.messageActionChannelEditPhoto,\n\t'messageActionChannelEditVideo': MessageAction.messageActionChannelEditVideo,\n\t'messageActionChatEditVideo': MessageAction.messageActionChatEditVideo,\n\t'messageActionChatAddUsers': MessageAction.messageActionChatAddUsers,\n\t'messageActionChatJoined': MessageAction.messageActionChatJoined,\n\t'messageActionChatReturn': MessageAction.messageActionChatReturn,\n\t'messageActionChatJoinedYou': MessageAction.messageActionChatJoinedYou,\n\t'messageActionChatReturnYou': MessageAction.messageActionChatReturnYou,\n\t'updateNewDiscussionMessage': Update.updateNewDiscussionMessage,\n\t'updateDeleteDiscussionMessages': Update.updateDeleteDiscussionMessages,\n\t'updateChannelReload': Update.updateChannelReload,\n}\n\nexport type InvokeAfterMsg = {\n\tmsg_id: string,\n\tquery: any\n};\n\nexport type InvokeAfterMsgs = {\n\tmsg_ids: Array<string>,\n\tquery: any\n};\n\nexport type AuthSendCode = {\n\tphone_number: string,\n\tapi_id: number,\n\tapi_hash: string,\n\tsettings: CodeSettings\n};\n\nexport type AuthSignUp = {\n\tphone_number: string,\n\tphone_code_hash: string,\n\tfirst_name: string,\n\tlast_name: string\n};\n\nexport type AuthSignIn = {\n\tphone_number: string,\n\tphone_code_hash: string,\n\tphone_code: string\n};\n\nexport type AuthLogOut = {\n\n};\n\nexport type AuthResetAuthorizations = {\n\n};\n\nexport type AuthExportAuthorization = {\n\tdc_id: number\n};\n\nexport type AuthImportAuthorization = {\n\tid: number,\n\tbytes: Uint8Array\n};\n\nexport type AuthBindTempAuthKey = {\n\tperm_auth_key_id: string,\n\tnonce: string,\n\texpires_at: number,\n\tencrypted_message: Uint8Array\n};\n\nexport type AccountRegisterDevice = {\n\tflags?: number,\n\tno_muted?: boolean,\n\ttoken_type: number,\n\ttoken: string,\n\tapp_sandbox: boolean,\n\tsecret: Uint8Array,\n\tother_uids: Array<number>\n};\n\nexport type AccountUnregisterDevice = {\n\ttoken_type: number,\n\ttoken: string,\n\tother_uids: Array<number>\n};\n\nexport type AccountUpdateNotifySettings = {\n\tpeer: InputNotifyPeer,\n\tsettings: InputPeerNotifySettings\n};\n\nexport type AccountGetNotifySettings = {\n\tpeer: InputNotifyPeer\n};\n\nexport type AccountResetNotifySettings = {\n\n};\n\nexport type AccountUpdateProfile = {\n\tflags?: number,\n\tfirst_name?: string,\n\tlast_name?: string,\n\tabout?: string\n};\n\nexport type AccountUpdateStatus = {\n\toffline: boolean\n};\n\nexport type AccountGetWallPapers = {\n\thash: number\n};\n\nexport type AccountReportPeer = {\n\tpeer: InputPeer,\n\treason: ReportReason,\n\tmessage: string\n};\n\nexport type UsersGetUsers = {\n\tid: Array<InputUser>\n};\n\nexport type UsersGetFullUser = {\n\tid: InputUser\n};\n\nexport type ContactsGetContactIDs = {\n\thash: number\n};\n\nexport type ContactsGetStatuses = {\n\n};\n\nexport type ContactsGetContacts = {\n\thash: number\n};\n\nexport type ContactsImportContacts = {\n\tcontacts: Array<InputContact>\n};\n\nexport type ContactsDeleteContacts = {\n\tid: Array<InputUser>\n};\n\nexport type ContactsDeleteByPhones = {\n\tphones: Array<string>\n};\n\nexport type ContactsBlock = {\n\tid: InputPeer\n};\n\nexport type ContactsUnblock = {\n\tid: InputPeer\n};\n\nexport type ContactsGetBlocked = {\n\toffset: number,\n\tlimit: number\n};\n\nexport type MessagesGetMessages = {\n\tid: Array<InputMessage>\n};\n\nexport type MessagesGetDialogs = {\n\tflags?: number,\n\texclude_pinned?: boolean,\n\tfolder_id?: number,\n\toffset_date: number,\n\toffset_id: number,\n\toffset_peer: InputPeer,\n\tlimit: number,\n\thash: number\n};\n\nexport type MessagesGetHistory = {\n\tpeer: InputPeer,\n\toffset_id: number,\n\toffset_date: number,\n\tadd_offset: number,\n\tlimit: number,\n\tmax_id: number,\n\tmin_id: number,\n\thash: number\n};\n\nexport type MessagesSearch = {\n\tflags?: number,\n\tpeer: InputPeer,\n\tq: string,\n\tfrom_id?: InputPeer,\n\ttop_msg_id?: number,\n\tfilter: MessagesFilter,\n\tmin_date: number,\n\tmax_date: number,\n\toffset_id: number,\n\tadd_offset: number,\n\tlimit: number,\n\tmax_id: number,\n\tmin_id: number,\n\thash: number\n};\n\nexport type MessagesReadHistory = {\n\tpeer: InputPeer,\n\tmax_id: number\n};\n\nexport type MessagesDeleteHistory = {\n\tflags?: number,\n\tjust_clear?: boolean,\n\trevoke?: boolean,\n\tpeer: InputPeer,\n\tmax_id: number\n};\n\nexport type MessagesDeleteMessages = {\n\tflags?: number,\n\trevoke?: boolean,\n\tid: Array<number>\n};\n\nexport type MessagesReceivedMessages = {\n\tmax_id: number\n};\n\nexport type MessagesSetTyping = {\n\tflags?: number,\n\tpeer: InputPeer,\n\ttop_msg_id?: number,\n\taction: SendMessageAction\n};\n\nexport type MessagesSendMessage = {\n\tflags?: number,\n\tno_webpage?: boolean,\n\tsilent?: boolean,\n\tbackground?: boolean,\n\tclear_draft?: boolean,\n\tpeer: InputPeer,\n\treply_to_msg_id?: number,\n\tmessage: string,\n\trandom_id: string,\n\treply_markup?: ReplyMarkup,\n\tentities?: Array<MessageEntity>,\n\tschedule_date?: number\n};\n\nexport type MessagesSendMedia = {\n\tflags?: number,\n\tsilent?: boolean,\n\tbackground?: boolean,\n\tclear_draft?: boolean,\n\tpeer: InputPeer,\n\treply_to_msg_id?: number,\n\tmedia: InputMedia,\n\tmessage: string,\n\trandom_id: string,\n\treply_markup?: ReplyMarkup,\n\tentities?: Array<MessageEntity>,\n\tschedule_date?: number\n};\n\nexport type MessagesForwardMessages = {\n\tflags?: number,\n\tsilent?: boolean,\n\tbackground?: boolean,\n\twith_my_score?: boolean,\n\tfrom_peer: InputPeer,\n\tid: Array<number>,\n\trandom_id: Array<string>,\n\tto_peer: InputPeer,\n\tschedule_date?: number\n};\n\nexport type MessagesReportSpam = {\n\tpeer: InputPeer\n};\n\nexport type MessagesGetPeerSettings = {\n\tpeer: InputPeer\n};\n\nexport type MessagesReport = {\n\tpeer: InputPeer,\n\tid: Array<number>,\n\treason: ReportReason,\n\tmessage: string\n};\n\nexport type MessagesGetChats = {\n\tid: Array<number>\n};\n\nexport type MessagesGetFullChat = {\n\tchat_id: number\n};\n\nexport type MessagesEditChatTitle = {\n\tchat_id: number,\n\ttitle: string\n};\n\nexport type MessagesEditChatPhoto = {\n\tchat_id: number,\n\tphoto: InputChatPhoto\n};\n\nexport type MessagesAddChatUser = {\n\tchat_id: number,\n\tuser_id: InputUser,\n\tfwd_limit: number\n};\n\nexport type MessagesDeleteChatUser = {\n\tflags?: number,\n\trevoke_history?: boolean,\n\tchat_id: number,\n\tuser_id: InputUser\n};\n\nexport type MessagesCreateChat = {\n\tusers: Array<InputUser>,\n\ttitle: string\n};\n\nexport type UpdatesGetState = {\n\n};\n\nexport type UpdatesGetDifference = {\n\tflags?: number,\n\tpts: number,\n\tpts_total_limit?: number,\n\tdate: number,\n\tqts: number\n};\n\nexport type PhotosUpdateProfilePhoto = {\n\tid: InputPhoto\n};\n\nexport type PhotosUploadProfilePhoto = {\n\tflags?: number,\n\tfile?: InputFile,\n\tvideo?: InputFile,\n\tvideo_start_ts?: number\n};\n\nexport type PhotosDeletePhotos = {\n\tid: Array<InputPhoto>\n};\n\nexport type UploadSaveFilePart = {\n\tfile_id: string,\n\tfile_part: number,\n\tbytes: Uint8Array\n};\n\nexport type UploadGetFile = {\n\tflags?: number,\n\tprecise?: boolean,\n\tcdn_supported?: boolean,\n\tlocation: InputFileLocation,\n\toffset: number,\n\tlimit: number\n};\n\nexport type HelpGetConfig = {\n\n};\n\nexport type HelpGetNearestDc = {\n\n};\n\nexport type HelpGetAppUpdate = {\n\tsource: string\n};\n\nexport type HelpGetInviteText = {\n\n};\n\nexport type PhotosGetUserPhotos = {\n\tuser_id: InputUser,\n\toffset: number,\n\tmax_id: string,\n\tlimit: number\n};\n\nexport type MessagesGetDhConfig = {\n\tversion: number,\n\trandom_length: number\n};\n\nexport type MessagesRequestEncryption = {\n\tuser_id: InputUser,\n\trandom_id: number,\n\tg_a: Uint8Array\n};\n\nexport type MessagesAcceptEncryption = {\n\tpeer: InputEncryptedChat,\n\tg_b: Uint8Array,\n\tkey_fingerprint: string\n};\n\nexport type MessagesDiscardEncryption = {\n\tflags?: number,\n\tdelete_history?: boolean,\n\tchat_id: number\n};\n\nexport type MessagesSetEncryptedTyping = {\n\tpeer: InputEncryptedChat,\n\ttyping: boolean\n};\n\nexport type MessagesReadEncryptedHistory = {\n\tpeer: InputEncryptedChat,\n\tmax_date: number\n};\n\nexport type MessagesSendEncrypted = {\n\tflags?: number,\n\tsilent?: boolean,\n\tpeer: InputEncryptedChat,\n\trandom_id: string,\n\tdata: Uint8Array\n};\n\nexport type MessagesSendEncryptedFile = {\n\tflags?: number,\n\tsilent?: boolean,\n\tpeer: InputEncryptedChat,\n\trandom_id: string,\n\tdata: Uint8Array,\n\tfile: InputEncryptedFile\n};\n\nexport type MessagesSendEncryptedService = {\n\tpeer: InputEncryptedChat,\n\trandom_id: string,\n\tdata: Uint8Array\n};\n\nexport type MessagesReceivedQueue = {\n\tmax_qts: number\n};\n\nexport type MessagesReportEncryptedSpam = {\n\tpeer: InputEncryptedChat\n};\n\nexport type UploadSaveBigFilePart = {\n\tfile_id: string,\n\tfile_part: number,\n\tfile_total_parts: number,\n\tbytes: Uint8Array\n};\n\nexport type InitConnection = {\n\tflags?: number,\n\tapi_id: number,\n\tdevice_model: string,\n\tsystem_version: string,\n\tapp_version: string,\n\tsystem_lang_code: string,\n\tlang_pack: string,\n\tlang_code: string,\n\tproxy?: InputClientProxy,\n\tparams?: JSONValue,\n\tquery: any\n};\n\nexport type HelpGetSupport = {\n\n};\n\nexport type MessagesReadMessageContents = {\n\tid: Array<number>\n};\n\nexport type AccountCheckUsername = {\n\tusername: string\n};\n\nexport type AccountUpdateUsername = {\n\tusername: string\n};\n\nexport type ContactsSearch = {\n\tq: string,\n\tlimit: number\n};\n\nexport type AccountGetPrivacy = {\n\tkey: InputPrivacyKey\n};\n\nexport type AccountSetPrivacy = {\n\tkey: InputPrivacyKey,\n\trules: Array<InputPrivacyRule>\n};\n\nexport type AccountDeleteAccount = {\n\treason: string\n};\n\nexport type AccountGetAccountTTL = {\n\n};\n\nexport type AccountSetAccountTTL = {\n\tttl: AccountDaysTTL\n};\n\nexport type InvokeWithLayer = {\n\tlayer: number,\n\tquery: any\n};\n\nexport type ContactsResolveUsername = {\n\tusername: string\n};\n\nexport type AccountSendChangePhoneCode = {\n\tphone_number: string,\n\tsettings: CodeSettings\n};\n\nexport type AccountChangePhone = {\n\tphone_number: string,\n\tphone_code_hash: string,\n\tphone_code: string\n};\n\nexport type MessagesGetStickers = {\n\temoticon: string,\n\thash: number\n};\n\nexport type MessagesGetAllStickers = {\n\thash: number\n};\n\nexport type AccountUpdateDeviceLocked = {\n\tperiod: number\n};\n\nexport type AuthImportBotAuthorization = {\n\tflags?: number,\n\tapi_id: number,\n\tapi_hash: string,\n\tbot_auth_token: string\n};\n\nexport type MessagesGetWebPagePreview = {\n\tflags?: number,\n\tmessage: string,\n\tentities?: Array<MessageEntity>\n};\n\nexport type AccountGetAuthorizations = {\n\n};\n\nexport type AccountResetAuthorization = {\n\thash: string\n};\n\nexport type AccountGetPassword = {\n\n};\n\nexport type AccountGetPasswordSettings = {\n\tpassword: InputCheckPasswordSRP\n};\n\nexport type AccountUpdatePasswordSettings = {\n\tpassword: InputCheckPasswordSRP,\n\tnew_settings: AccountPasswordInputSettings\n};\n\nexport type AuthCheckPassword = {\n\tpassword: InputCheckPasswordSRP\n};\n\nexport type AuthRequestPasswordRecovery = {\n\n};\n\nexport type AuthRecoverPassword = {\n\tflags?: number,\n\tcode: string,\n\tnew_settings?: AccountPasswordInputSettings\n};\n\nexport type InvokeWithoutUpdates = {\n\tquery: any\n};\n\nexport type MessagesExportChatInvite = {\n\tflags?: number,\n\tlegacy_revoke_permanent?: boolean,\n\tpeer: InputPeer,\n\texpire_date?: number,\n\tusage_limit?: number\n};\n\nexport type MessagesCheckChatInvite = {\n\thash: string\n};\n\nexport type MessagesImportChatInvite = {\n\thash: string\n};\n\nexport type MessagesGetStickerSet = {\n\tstickerset: InputStickerSet\n};\n\nexport type MessagesInstallStickerSet = {\n\tstickerset: InputStickerSet,\n\tarchived: boolean\n};\n\nexport type MessagesUninstallStickerSet = {\n\tstickerset: InputStickerSet\n};\n\nexport type MessagesStartBot = {\n\tbot: InputUser,\n\tpeer: InputPeer,\n\trandom_id: string,\n\tstart_param: string\n};\n\nexport type HelpGetAppChangelog = {\n\tprev_app_version: string\n};\n\nexport type MessagesGetMessagesViews = {\n\tpeer: InputPeer,\n\tid: Array<number>,\n\tincrement: boolean\n};\n\nexport type ChannelsReadHistory = {\n\tchannel: InputChannel,\n\tmax_id: number\n};\n\nexport type ChannelsDeleteMessages = {\n\tchannel: InputChannel,\n\tid: Array<number>\n};\n\nexport type ChannelsDeleteUserHistory = {\n\tchannel: InputChannel,\n\tuser_id: InputUser\n};\n\nexport type ChannelsReportSpam = {\n\tchannel: InputChannel,\n\tuser_id: InputUser,\n\tid: Array<number>\n};\n\nexport type ChannelsGetMessages = {\n\tchannel: InputChannel,\n\tid: Array<InputMessage>\n};\n\nexport type ChannelsGetParticipants = {\n\tchannel: InputChannel,\n\tfilter: ChannelParticipantsFilter,\n\toffset: number,\n\tlimit: number,\n\thash: number\n};\n\nexport type ChannelsGetParticipant = {\n\tchannel: InputChannel,\n\tparticipant: InputPeer\n};\n\nexport type ChannelsGetChannels = {\n\tid: Array<InputChannel>\n};\n\nexport type ChannelsGetFullChannel = {\n\tchannel: InputChannel\n};\n\nexport type ChannelsCreateChannel = {\n\tflags?: number,\n\tbroadcast?: boolean,\n\tmegagroup?: boolean,\n\tfor_import?: boolean,\n\ttitle: string,\n\tabout: string,\n\tgeo_point?: InputGeoPoint,\n\taddress?: string\n};\n\nexport type ChannelsEditAdmin = {\n\tchannel: InputChannel,\n\tuser_id: InputUser,\n\tadmin_rights: ChatAdminRights,\n\trank: string\n};\n\nexport type ChannelsEditTitle = {\n\tchannel: InputChannel,\n\ttitle: string\n};\n\nexport type ChannelsEditPhoto = {\n\tchannel: InputChannel,\n\tphoto: InputChatPhoto\n};\n\nexport type ChannelsCheckUsername = {\n\tchannel: InputChannel,\n\tusername: string\n};\n\nexport type ChannelsUpdateUsername = {\n\tchannel: InputChannel,\n\tusername: string\n};\n\nexport type ChannelsJoinChannel = {\n\tchannel: InputChannel\n};\n\nexport type ChannelsLeaveChannel = {\n\tchannel: InputChannel\n};\n\nexport type ChannelsInviteToChannel = {\n\tchannel: InputChannel,\n\tusers: Array<InputUser>\n};\n\nexport type ChannelsDeleteChannel = {\n\tchannel: InputChannel\n};\n\nexport type UpdatesGetChannelDifference = {\n\tflags?: number,\n\tforce?: boolean,\n\tchannel: InputChannel,\n\tfilter: ChannelMessagesFilter,\n\tpts: number,\n\tlimit: number\n};\n\nexport type MessagesEditChatAdmin = {\n\tchat_id: number,\n\tuser_id: InputUser,\n\tis_admin: boolean\n};\n\nexport type MessagesMigrateChat = {\n\tchat_id: number\n};\n\nexport type MessagesSearchGlobal = {\n\tflags?: number,\n\tfolder_id?: number,\n\tq: string,\n\tfilter: MessagesFilter,\n\tmin_date: number,\n\tmax_date: number,\n\toffset_rate: number,\n\toffset_peer: InputPeer,\n\toffset_id: number,\n\tlimit: number\n};\n\nexport type MessagesReorderStickerSets = {\n\tflags?: number,\n\tmasks?: boolean,\n\torder: Array<string>\n};\n\nexport type MessagesGetDocumentByHash = {\n\tsha256: Uint8Array,\n\tsize: number,\n\tmime_type: string\n};\n\nexport type MessagesGetSavedGifs = {\n\thash: number\n};\n\nexport type MessagesSaveGif = {\n\tid: InputDocument,\n\tunsave: boolean\n};\n\nexport type MessagesGetInlineBotResults = {\n\tflags?: number,\n\tbot: InputUser,\n\tpeer: InputPeer,\n\tgeo_point?: InputGeoPoint,\n\tquery: string,\n\toffset: string\n};\n\nexport type MessagesSetInlineBotResults = {\n\tflags?: number,\n\tgallery?: boolean,\n\tprivate?: boolean,\n\tquery_id: string,\n\tresults: Array<InputBotInlineResult>,\n\tcache_time: number,\n\tnext_offset?: string,\n\tswitch_pm?: InlineBotSwitchPM\n};\n\nexport type MessagesSendInlineBotResult = {\n\tflags?: number,\n\tsilent?: boolean,\n\tbackground?: boolean,\n\tclear_draft?: boolean,\n\thide_via?: boolean,\n\tpeer: InputPeer,\n\treply_to_msg_id?: number,\n\trandom_id: string,\n\tquery_id: string,\n\tid: string,\n\tschedule_date?: number\n};\n\nexport type ChannelsExportMessageLink = {\n\tflags?: number,\n\tgrouped?: boolean,\n\tthread?: boolean,\n\tchannel: InputChannel,\n\tid: number\n};\n\nexport type ChannelsToggleSignatures = {\n\tchannel: InputChannel,\n\tenabled: boolean\n};\n\nexport type AuthResendCode = {\n\tphone_number: string,\n\tphone_code_hash: string\n};\n\nexport type AuthCancelCode = {\n\tphone_number: string,\n\tphone_code_hash: string\n};\n\nexport type MessagesGetMessageEditData = {\n\tpeer: InputPeer,\n\tid: number\n};\n\nexport type MessagesEditMessage = {\n\tflags?: number,\n\tno_webpage?: boolean,\n\tpeer: InputPeer,\n\tid: number,\n\tmessage?: string,\n\tmedia?: InputMedia,\n\treply_markup?: ReplyMarkup,\n\tentities?: Array<MessageEntity>,\n\tschedule_date?: number\n};\n\nexport type MessagesEditInlineBotMessage = {\n\tflags?: number,\n\tno_webpage?: boolean,\n\tid: InputBotInlineMessageID,\n\tmessage?: string,\n\tmedia?: InputMedia,\n\treply_markup?: ReplyMarkup,\n\tentities?: Array<MessageEntity>\n};\n\nexport type MessagesGetBotCallbackAnswer = {\n\tflags?: number,\n\tgame?: boolean,\n\tpeer: InputPeer,\n\tmsg_id: number,\n\tdata?: Uint8Array,\n\tpassword?: InputCheckPasswordSRP\n};\n\nexport type MessagesSetBotCallbackAnswer = {\n\tflags?: number,\n\talert?: boolean,\n\tquery_id: string,\n\tmessage?: string,\n\turl?: string,\n\tcache_time: number\n};\n\nexport type ContactsGetTopPeers = {\n\tflags?: number,\n\tcorrespondents?: boolean,\n\tbots_pm?: boolean,\n\tbots_inline?: boolean,\n\tphone_calls?: boolean,\n\tforward_users?: boolean,\n\tforward_chats?: boolean,\n\tgroups?: boolean,\n\tchannels?: boolean,\n\toffset: number,\n\tlimit: number,\n\thash: number\n};\n\nexport type ContactsResetTopPeerRating = {\n\tcategory: TopPeerCategory,\n\tpeer: InputPeer\n};\n\nexport type MessagesGetPeerDialogs = {\n\tpeers: Array<InputDialogPeer>\n};\n\nexport type MessagesSaveDraft = {\n\tflags?: number,\n\tno_webpage?: boolean,\n\treply_to_msg_id?: number,\n\tpeer: InputPeer,\n\tmessage: string,\n\tentities?: Array<MessageEntity>\n};\n\nexport type MessagesGetAllDrafts = {\n\n};\n\nexport type MessagesGetFeaturedStickers = {\n\thash: number\n};\n\nexport type MessagesReadFeaturedStickers = {\n\tid: Array<string>\n};\n\nexport type MessagesGetRecentStickers = {\n\tflags?: number,\n\tattached?: boolean,\n\thash: number\n};\n\nexport type MessagesSaveRecentSticker = {\n\tflags?: number,\n\tattached?: boolean,\n\tid: InputDocument,\n\tunsave: boolean\n};\n\nexport type MessagesClearRecentStickers = {\n\tflags?: number,\n\tattached?: boolean\n};\n\nexport type MessagesGetArchivedStickers = {\n\tflags?: number,\n\tmasks?: boolean,\n\toffset_id: string,\n\tlimit: number\n};\n\nexport type AccountSendConfirmPhoneCode = {\n\thash: string,\n\tsettings: CodeSettings\n};\n\nexport type AccountConfirmPhone = {\n\tphone_code_hash: string,\n\tphone_code: string\n};\n\nexport type ChannelsGetAdminedPublicChannels = {\n\tflags?: number,\n\tby_location?: boolean,\n\tcheck_limit?: boolean\n};\n\nexport type MessagesGetMaskStickers = {\n\thash: number\n};\n\nexport type MessagesGetAttachedStickers = {\n\tmedia: InputStickeredMedia\n};\n\nexport type AuthDropTempAuthKeys = {\n\texcept_auth_keys: Array<string>\n};\n\nexport type MessagesSetGameScore = {\n\tflags?: number,\n\tedit_message?: boolean,\n\tforce?: boolean,\n\tpeer: InputPeer,\n\tid: number,\n\tuser_id: InputUser,\n\tscore: number\n};\n\nexport type MessagesSetInlineGameScore = {\n\tflags?: number,\n\tedit_message?: boolean,\n\tforce?: boolean,\n\tid: InputBotInlineMessageID,\n\tuser_id: InputUser,\n\tscore: number\n};\n\nexport type MessagesGetGameHighScores = {\n\tpeer: InputPeer,\n\tid: number,\n\tuser_id: InputUser\n};\n\nexport type MessagesGetInlineGameHighScores = {\n\tid: InputBotInlineMessageID,\n\tuser_id: InputUser\n};\n\nexport type MessagesGetCommonChats = {\n\tuser_id: InputUser,\n\tmax_id: number,\n\tlimit: number\n};\n\nexport type MessagesGetAllChats = {\n\texcept_ids: Array<number>\n};\n\nexport type HelpSetBotUpdatesStatus = {\n\tpending_updates_count: number,\n\tmessage: string\n};\n\nexport type MessagesGetWebPage = {\n\turl: string,\n\thash: number\n};\n\nexport type MessagesToggleDialogPin = {\n\tflags?: number,\n\tpinned?: boolean,\n\tpeer: InputDialogPeer\n};\n\nexport type MessagesReorderPinnedDialogs = {\n\tflags?: number,\n\tforce?: boolean,\n\tfolder_id: number,\n\torder: Array<InputDialogPeer>\n};\n\nexport type MessagesGetPinnedDialogs = {\n\tfolder_id: number\n};\n\nexport type BotsSendCustomRequest = {\n\tcustom_method: string,\n\tparams: DataJSON\n};\n\nexport type BotsAnswerWebhookJSONQuery = {\n\tquery_id: string,\n\tdata: DataJSON\n};\n\nexport type UploadGetWebFile = {\n\tlocation: InputWebFileLocation,\n\toffset: number,\n\tlimit: number\n};\n\nexport type PaymentsGetPaymentForm = {\n\tflags?: number,\n\tpeer: InputPeer,\n\tmsg_id: number,\n\ttheme_params?: DataJSON\n};\n\nexport type PaymentsGetPaymentReceipt = {\n\tpeer: InputPeer,\n\tmsg_id: number\n};\n\nexport type PaymentsValidateRequestedInfo = {\n\tflags?: number,\n\tsave?: boolean,\n\tpeer: InputPeer,\n\tmsg_id: number,\n\tinfo: PaymentRequestedInfo\n};\n\nexport type PaymentsSendPaymentForm = {\n\tflags?: number,\n\tform_id: string,\n\tpeer: InputPeer,\n\tmsg_id: number,\n\trequested_info_id?: string,\n\tshipping_option_id?: string,\n\tcredentials: InputPaymentCredentials,\n\ttip_amount?: string\n};\n\nexport type AccountGetTmpPassword = {\n\tpassword: InputCheckPasswordSRP,\n\tperiod: number\n};\n\nexport type PaymentsGetSavedInfo = {\n\n};\n\nexport type PaymentsClearSavedInfo = {\n\tflags?: number,\n\tcredentials?: boolean,\n\tinfo?: boolean\n};\n\nexport type MessagesSetBotShippingResults = {\n\tflags?: number,\n\tquery_id: string,\n\terror?: string,\n\tshipping_options?: Array<ShippingOption>\n};\n\nexport type MessagesSetBotPrecheckoutResults = {\n\tflags?: number,\n\tsuccess?: boolean,\n\tquery_id: string,\n\terror?: string\n};\n\nexport type StickersCreateStickerSet = {\n\tflags?: number,\n\tmasks?: boolean,\n\tanimated?: boolean,\n\tuser_id: InputUser,\n\ttitle: string,\n\tshort_name: string,\n\tthumb?: InputDocument,\n\tstickers: Array<InputStickerSetItem>,\n\tsoftware?: string\n};\n\nexport type StickersRemoveStickerFromSet = {\n\tsticker: InputDocument\n};\n\nexport type StickersChangeStickerPosition = {\n\tsticker: InputDocument,\n\tposition: number\n};\n\nexport type StickersAddStickerToSet = {\n\tstickerset: InputStickerSet,\n\tsticker: InputStickerSetItem\n};\n\nexport type MessagesUploadMedia = {\n\tpeer: InputPeer,\n\tmedia: InputMedia\n};\n\nexport type PhoneGetCallConfig = {\n\n};\n\nexport type PhoneRequestCall = {\n\tflags?: number,\n\tvideo?: boolean,\n\tuser_id: InputUser,\n\trandom_id: number,\n\tg_a_hash: Uint8Array,\n\tprotocol: PhoneCallProtocol\n};\n\nexport type PhoneAcceptCall = {\n\tpeer: InputPhoneCall,\n\tg_b: Uint8Array,\n\tprotocol: PhoneCallProtocol\n};\n\nexport type PhoneConfirmCall = {\n\tpeer: InputPhoneCall,\n\tg_a: Uint8Array,\n\tkey_fingerprint: string,\n\tprotocol: PhoneCallProtocol\n};\n\nexport type PhoneReceivedCall = {\n\tpeer: InputPhoneCall\n};\n\nexport type PhoneDiscardCall = {\n\tflags?: number,\n\tvideo?: boolean,\n\tpeer: InputPhoneCall,\n\tduration: number,\n\treason: PhoneCallDiscardReason,\n\tconnection_id: string\n};\n\nexport type PhoneSetCallRating = {\n\tflags?: number,\n\tuser_initiative?: boolean,\n\tpeer: InputPhoneCall,\n\trating: number,\n\tcomment: string\n};\n\nexport type PhoneSaveCallDebug = {\n\tpeer: InputPhoneCall,\n\tdebug: DataJSON\n};\n\nexport type UploadGetCdnFile = {\n\tfile_token: Uint8Array,\n\toffset: number,\n\tlimit: number\n};\n\nexport type UploadReuploadCdnFile = {\n\tfile_token: Uint8Array,\n\trequest_token: Uint8Array\n};\n\nexport type HelpGetCdnConfig = {\n\n};\n\nexport type LangpackGetLangPack = {\n\tlang_pack: string,\n\tlang_code: string\n};\n\nexport type LangpackGetStrings = {\n\tlang_pack: string,\n\tlang_code: string,\n\tkeys: Array<string>\n};\n\nexport type LangpackGetDifference = {\n\tlang_pack: string,\n\tlang_code: string,\n\tfrom_version: number\n};\n\nexport type LangpackGetLanguages = {\n\tlang_pack: string\n};\n\nexport type ChannelsEditBanned = {\n\tchannel: InputChannel,\n\tparticipant: InputPeer,\n\tbanned_rights: ChatBannedRights\n};\n\nexport type ChannelsGetAdminLog = {\n\tflags?: number,\n\tchannel: InputChannel,\n\tq: string,\n\tevents_filter?: ChannelAdminLogEventsFilter,\n\tadmins?: Array<InputUser>,\n\tmax_id: string,\n\tmin_id: string,\n\tlimit: number\n};\n\nexport type UploadGetCdnFileHashes = {\n\tfile_token: Uint8Array,\n\toffset: number\n};\n\nexport type MessagesSendScreenshotNotification = {\n\tpeer: InputPeer,\n\treply_to_msg_id: number,\n\trandom_id: string\n};\n\nexport type ChannelsSetStickers = {\n\tchannel: InputChannel,\n\tstickerset: InputStickerSet\n};\n\nexport type MessagesGetFavedStickers = {\n\thash: number\n};\n\nexport type MessagesFaveSticker = {\n\tid: InputDocument,\n\tunfave: boolean\n};\n\nexport type ChannelsReadMessageContents = {\n\tchannel: InputChannel,\n\tid: Array<number>\n};\n\nexport type ContactsResetSaved = {\n\n};\n\nexport type MessagesGetUnreadMentions = {\n\tpeer: InputPeer,\n\toffset_id: number,\n\tadd_offset: number,\n\tlimit: number,\n\tmax_id: number,\n\tmin_id: number\n};\n\nexport type ChannelsDeleteHistory = {\n\tchannel: InputChannel,\n\tmax_id: number\n};\n\nexport type HelpGetRecentMeUrls = {\n\treferer: string\n};\n\nexport type ChannelsTogglePreHistoryHidden = {\n\tchannel: InputChannel,\n\tenabled: boolean\n};\n\nexport type MessagesReadMentions = {\n\tpeer: InputPeer\n};\n\nexport type MessagesGetRecentLocations = {\n\tpeer: InputPeer,\n\tlimit: number,\n\thash: number\n};\n\nexport type MessagesSendMultiMedia = {\n\tflags?: number,\n\tsilent?: boolean,\n\tbackground?: boolean,\n\tclear_draft?: boolean,\n\tpeer: InputPeer,\n\treply_to_msg_id?: number,\n\tmulti_media: Array<InputSingleMedia>,\n\tschedule_date?: number\n};\n\nexport type MessagesUploadEncryptedFile = {\n\tpeer: InputEncryptedChat,\n\tfile: InputEncryptedFile\n};\n\nexport type AccountGetWebAuthorizations = {\n\n};\n\nexport type AccountResetWebAuthorization = {\n\thash: string\n};\n\nexport type AccountResetWebAuthorizations = {\n\n};\n\nexport type MessagesSearchStickerSets = {\n\tflags?: number,\n\texclude_featured?: boolean,\n\tq: string,\n\thash: number\n};\n\nexport type UploadGetFileHashes = {\n\tlocation: InputFileLocation,\n\toffset: number\n};\n\nexport type HelpGetTermsOfServiceUpdate = {\n\n};\n\nexport type HelpAcceptTermsOfService = {\n\tid: DataJSON\n};\n\nexport type AccountGetAllSecureValues = {\n\n};\n\nexport type AccountGetSecureValue = {\n\ttypes: Array<SecureValueType>\n};\n\nexport type AccountSaveSecureValue = {\n\tvalue: InputSecureValue,\n\tsecure_secret_id: string\n};\n\nexport type AccountDeleteSecureValue = {\n\ttypes: Array<SecureValueType>\n};\n\nexport type UsersSetSecureValueErrors = {\n\tid: InputUser,\n\terrors: Array<SecureValueError>\n};\n\nexport type AccountGetAuthorizationForm = {\n\tbot_id: number,\n\tscope: string,\n\tpublic_key: string\n};\n\nexport type AccountAcceptAuthorization = {\n\tbot_id: number,\n\tscope: string,\n\tpublic_key: string,\n\tvalue_hashes: Array<SecureValueHash>,\n\tcredentials: SecureCredentialsEncrypted\n};\n\nexport type AccountSendVerifyPhoneCode = {\n\tphone_number: string,\n\tsettings: CodeSettings\n};\n\nexport type AccountVerifyPhone = {\n\tphone_number: string,\n\tphone_code_hash: string,\n\tphone_code: string\n};\n\nexport type AccountSendVerifyEmailCode = {\n\temail: string\n};\n\nexport type AccountVerifyEmail = {\n\temail: string,\n\tcode: string\n};\n\nexport type HelpGetDeepLinkInfo = {\n\tpath: string\n};\n\nexport type ContactsGetSaved = {\n\n};\n\nexport type ChannelsGetLeftChannels = {\n\toffset: number\n};\n\nexport type AccountInitTakeoutSession = {\n\tflags?: number,\n\tcontacts?: boolean,\n\tmessage_users?: boolean,\n\tmessage_chats?: boolean,\n\tmessage_megagroups?: boolean,\n\tmessage_channels?: boolean,\n\tfiles?: boolean,\n\tfile_max_size?: number\n};\n\nexport type AccountFinishTakeoutSession = {\n\tflags?: number,\n\tsuccess?: boolean\n};\n\nexport type MessagesGetSplitRanges = {\n\n};\n\nexport type InvokeWithMessagesRange = {\n\trange: MessageRange,\n\tquery: any\n};\n\nexport type InvokeWithTakeout = {\n\ttakeout_id: string,\n\tquery: any\n};\n\nexport type MessagesMarkDialogUnread = {\n\tflags?: number,\n\tunread?: boolean,\n\tpeer: InputDialogPeer\n};\n\nexport type MessagesGetDialogUnreadMarks = {\n\n};\n\nexport type ContactsToggleTopPeers = {\n\tenabled: boolean\n};\n\nexport type MessagesClearAllDrafts = {\n\n};\n\nexport type HelpGetAppConfig = {\n\n};\n\nexport type HelpSaveAppLog = {\n\tevents: Array<InputAppEvent>\n};\n\nexport type HelpGetPassportConfig = {\n\thash: number\n};\n\nexport type LangpackGetLanguage = {\n\tlang_pack: string,\n\tlang_code: string\n};\n\nexport type MessagesUpdatePinnedMessage = {\n\tflags?: number,\n\tsilent?: boolean,\n\tunpin?: boolean,\n\tpm_oneside?: boolean,\n\tpeer: InputPeer,\n\tid: number\n};\n\nexport type AccountConfirmPasswordEmail = {\n\tcode: string\n};\n\nexport type AccountResendPasswordEmail = {\n\n};\n\nexport type AccountCancelPasswordEmail = {\n\n};\n\nexport type HelpGetSupportName = {\n\n};\n\nexport type HelpGetUserInfo = {\n\tuser_id: InputUser\n};\n\nexport type HelpEditUserInfo = {\n\tuser_id: InputUser,\n\tmessage: string,\n\tentities: Array<MessageEntity>\n};\n\nexport type AccountGetContactSignUpNotification = {\n\n};\n\nexport type AccountSetContactSignUpNotification = {\n\tsilent: boolean\n};\n\nexport type AccountGetNotifyExceptions = {\n\tflags?: number,\n\tcompare_sound?: boolean,\n\tpeer?: InputNotifyPeer\n};\n\nexport type MessagesSendVote = {\n\tpeer: InputPeer,\n\tmsg_id: number,\n\toptions: Array<Uint8Array>\n};\n\nexport type MessagesGetPollResults = {\n\tpeer: InputPeer,\n\tmsg_id: number\n};\n\nexport type MessagesGetOnlines = {\n\tpeer: InputPeer\n};\n\nexport type MessagesGetStatsURL = {\n\tflags?: number,\n\tdark?: boolean,\n\tpeer: InputPeer,\n\tparams: string\n};\n\nexport type MessagesEditChatAbout = {\n\tpeer: InputPeer,\n\tabout: string\n};\n\nexport type MessagesEditChatDefaultBannedRights = {\n\tpeer: InputPeer,\n\tbanned_rights: ChatBannedRights\n};\n\nexport type AccountGetWallPaper = {\n\twallpaper: InputWallPaper\n};\n\nexport type AccountUploadWallPaper = {\n\tfile: InputFile,\n\tmime_type: string,\n\tsettings: WallPaperSettings\n};\n\nexport type AccountSaveWallPaper = {\n\twallpaper: InputWallPaper,\n\tunsave: boolean,\n\tsettings: WallPaperSettings\n};\n\nexport type AccountInstallWallPaper = {\n\twallpaper: InputWallPaper,\n\tsettings: WallPaperSettings\n};\n\nexport type AccountResetWallPapers = {\n\n};\n\nexport type AccountGetAutoDownloadSettings = {\n\n};\n\nexport type AccountSaveAutoDownloadSettings = {\n\tflags?: number,\n\tlow?: boolean,\n\thigh?: boolean,\n\tsettings: AutoDownloadSettings\n};\n\nexport type MessagesGetEmojiKeywords = {\n\tlang_code: string\n};\n\nexport type MessagesGetEmojiKeywordsDifference = {\n\tlang_code: string,\n\tfrom_version: number\n};\n\nexport type MessagesGetEmojiKeywordsLanguages = {\n\tlang_codes: Array<string>\n};\n\nexport type MessagesGetEmojiURL = {\n\tlang_code: string\n};\n\nexport type FoldersEditPeerFolders = {\n\tfolder_peers: Array<InputFolderPeer>\n};\n\nexport type FoldersDeleteFolder = {\n\tfolder_id: number\n};\n\nexport type MessagesGetSearchCounters = {\n\tpeer: InputPeer,\n\tfilters: Array<MessagesFilter>\n};\n\nexport type ChannelsGetGroupsForDiscussion = {\n\n};\n\nexport type ChannelsSetDiscussionGroup = {\n\tbroadcast: InputChannel,\n\tgroup: InputChannel\n};\n\nexport type MessagesRequestUrlAuth = {\n\tflags?: number,\n\tpeer?: InputPeer,\n\tmsg_id?: number,\n\tbutton_id?: number,\n\turl?: string\n};\n\nexport type MessagesAcceptUrlAuth = {\n\tflags?: number,\n\twrite_allowed?: boolean,\n\tpeer?: InputPeer,\n\tmsg_id?: number,\n\tbutton_id?: number,\n\turl?: string\n};\n\nexport type MessagesHidePeerSettingsBar = {\n\tpeer: InputPeer\n};\n\nexport type ContactsAddContact = {\n\tflags?: number,\n\tadd_phone_privacy_exception?: boolean,\n\tid: InputUser,\n\tfirst_name: string,\n\tlast_name: string,\n\tphone: string\n};\n\nexport type ContactsAcceptContact = {\n\tid: InputUser\n};\n\nexport type ChannelsEditCreator = {\n\tchannel: InputChannel,\n\tuser_id: InputUser,\n\tpassword: InputCheckPasswordSRP\n};\n\nexport type ContactsGetLocated = {\n\tflags?: number,\n\tbackground?: boolean,\n\tgeo_point: InputGeoPoint,\n\tself_expires?: number\n};\n\nexport type ChannelsEditLocation = {\n\tchannel: InputChannel,\n\tgeo_point: InputGeoPoint,\n\taddress: string\n};\n\nexport type ChannelsToggleSlowMode = {\n\tchannel: InputChannel,\n\tseconds: number\n};\n\nexport type MessagesGetScheduledHistory = {\n\tpeer: InputPeer,\n\thash: number\n};\n\nexport type MessagesGetScheduledMessages = {\n\tpeer: InputPeer,\n\tid: Array<number>\n};\n\nexport type MessagesSendScheduledMessages = {\n\tpeer: InputPeer,\n\tid: Array<number>\n};\n\nexport type MessagesDeleteScheduledMessages = {\n\tpeer: InputPeer,\n\tid: Array<number>\n};\n\nexport type AccountUploadTheme = {\n\tflags?: number,\n\tfile: InputFile,\n\tthumb?: InputFile,\n\tfile_name: string,\n\tmime_type: string\n};\n\nexport type AccountCreateTheme = {\n\tflags?: number,\n\tslug: string,\n\ttitle: string,\n\tdocument?: InputDocument,\n\tsettings?: InputThemeSettings\n};\n\nexport type AccountUpdateTheme = {\n\tflags?: number,\n\tformat: string,\n\ttheme: InputTheme,\n\tslug?: string,\n\ttitle?: string,\n\tdocument?: InputDocument,\n\tsettings?: InputThemeSettings\n};\n\nexport type AccountSaveTheme = {\n\ttheme: InputTheme,\n\tunsave: boolean\n};\n\nexport type AccountInstallTheme = {\n\tflags?: number,\n\tdark?: boolean,\n\tformat?: string,\n\ttheme?: InputTheme\n};\n\nexport type AccountGetTheme = {\n\tformat: string,\n\ttheme: InputTheme,\n\tdocument_id: string\n};\n\nexport type AccountGetThemes = {\n\tformat: string,\n\thash: number\n};\n\nexport type AuthExportLoginToken = {\n\tapi_id: number,\n\tapi_hash: string,\n\texcept_ids: Array<number>\n};\n\nexport type AuthImportLoginToken = {\n\ttoken: Uint8Array\n};\n\nexport type AuthAcceptLoginToken = {\n\ttoken: Uint8Array\n};\n\nexport type AccountSetContentSettings = {\n\tflags?: number,\n\tsensitive_enabled?: boolean\n};\n\nexport type AccountGetContentSettings = {\n\n};\n\nexport type ChannelsGetInactiveChannels = {\n\n};\n\nexport type AccountGetMultiWallPapers = {\n\twallpapers: Array<InputWallPaper>\n};\n\nexport type MessagesGetPollVotes = {\n\tflags?: number,\n\tpeer: InputPeer,\n\tid: number,\n\toption?: Uint8Array,\n\toffset?: string,\n\tlimit: number\n};\n\nexport type MessagesToggleStickerSets = {\n\tflags?: number,\n\tuninstall?: boolean,\n\tarchive?: boolean,\n\tunarchive?: boolean,\n\tstickersets: Array<InputStickerSet>\n};\n\nexport type PaymentsGetBankCardData = {\n\tnumber: string\n};\n\nexport type MessagesGetDialogFilters = {\n\n};\n\nexport type MessagesGetSuggestedDialogFilters = {\n\n};\n\nexport type MessagesUpdateDialogFilter = {\n\tflags?: number,\n\tid: number,\n\tfilter?: DialogFilter\n};\n\nexport type MessagesUpdateDialogFiltersOrder = {\n\torder: Array<number>\n};\n\nexport type StatsGetBroadcastStats = {\n\tflags?: number,\n\tdark?: boolean,\n\tchannel: InputChannel\n};\n\nexport type StatsLoadAsyncGraph = {\n\tflags?: number,\n\ttoken: string,\n\tx?: string\n};\n\nexport type StickersSetStickerSetThumb = {\n\tstickerset: InputStickerSet,\n\tthumb: InputDocument\n};\n\nexport type BotsSetBotCommands = {\n\tscope: BotCommandScope,\n\tlang_code: string,\n\tcommands: Array<BotCommand>\n};\n\nexport type MessagesGetOldFeaturedStickers = {\n\toffset: number,\n\tlimit: number,\n\thash: number\n};\n\nexport type HelpGetPromoData = {\n\n};\n\nexport type HelpHidePromoData = {\n\tpeer: InputPeer\n};\n\nexport type PhoneSendSignalingData = {\n\tpeer: InputPhoneCall,\n\tdata: Uint8Array\n};\n\nexport type StatsGetMegagroupStats = {\n\tflags?: number,\n\tdark?: boolean,\n\tchannel: InputChannel\n};\n\nexport type AccountGetGlobalPrivacySettings = {\n\n};\n\nexport type AccountSetGlobalPrivacySettings = {\n\tsettings: GlobalPrivacySettings\n};\n\nexport type HelpDismissSuggestion = {\n\tpeer: InputPeer,\n\tsuggestion: string\n};\n\nexport type HelpGetCountriesList = {\n\tlang_code: string,\n\thash: number\n};\n\nexport type MessagesGetReplies = {\n\tpeer: InputPeer,\n\tmsg_id: number,\n\toffset_id: number,\n\toffset_date: number,\n\tadd_offset: number,\n\tlimit: number,\n\tmax_id: number,\n\tmin_id: number,\n\thash: number\n};\n\nexport type MessagesGetDiscussionMessage = {\n\tpeer: InputPeer,\n\tmsg_id: number\n};\n\nexport type MessagesReadDiscussion = {\n\tpeer: InputPeer,\n\tmsg_id: number,\n\tread_max_id: number\n};\n\nexport type ContactsBlockFromReplies = {\n\tflags?: number,\n\tdelete_message?: boolean,\n\tdelete_history?: boolean,\n\treport_spam?: boolean,\n\tmsg_id: number\n};\n\nexport type StatsGetMessagePublicForwards = {\n\tchannel: InputChannel,\n\tmsg_id: number,\n\toffset_rate: number,\n\toffset_peer: InputPeer,\n\toffset_id: number,\n\tlimit: number\n};\n\nexport type StatsGetMessageStats = {\n\tflags?: number,\n\tdark?: boolean,\n\tchannel: InputChannel,\n\tmsg_id: number\n};\n\nexport type MessagesUnpinAllMessages = {\n\tpeer: InputPeer\n};\n\nexport type PhoneCreateGroupCall = {\n\tflags?: number,\n\tpeer: InputPeer,\n\trandom_id: number,\n\ttitle?: string,\n\tschedule_date?: number\n};\n\nexport type PhoneJoinGroupCall = {\n\tflags?: number,\n\tmuted?: boolean,\n\tvideo_stopped?: boolean,\n\tcall: InputGroupCall,\n\tjoin_as: InputPeer,\n\tinvite_hash?: string,\n\tparams: DataJSON\n};\n\nexport type PhoneLeaveGroupCall = {\n\tcall: InputGroupCall,\n\tsource: number\n};\n\nexport type PhoneInviteToGroupCall = {\n\tcall: InputGroupCall,\n\tusers: Array<InputUser>\n};\n\nexport type PhoneDiscardGroupCall = {\n\tcall: InputGroupCall\n};\n\nexport type PhoneToggleGroupCallSettings = {\n\tflags?: number,\n\treset_invite_hash?: boolean,\n\tcall: InputGroupCall,\n\tjoin_muted?: boolean\n};\n\nexport type PhoneGetGroupCall = {\n\tcall: InputGroupCall,\n\tlimit: number\n};\n\nexport type PhoneGetGroupParticipants = {\n\tcall: InputGroupCall,\n\tids: Array<InputPeer>,\n\tsources: Array<number>,\n\toffset: string,\n\tlimit: number\n};\n\nexport type PhoneCheckGroupCall = {\n\tcall: InputGroupCall,\n\tsources: Array<number>\n};\n\nexport type MessagesDeleteChat = {\n\tchat_id: number\n};\n\nexport type MessagesDeletePhoneCallHistory = {\n\tflags?: number,\n\trevoke?: boolean\n};\n\nexport type MessagesCheckHistoryImport = {\n\timport_head: string\n};\n\nexport type MessagesInitHistoryImport = {\n\tpeer: InputPeer,\n\tfile: InputFile,\n\tmedia_count: number\n};\n\nexport type MessagesUploadImportedMedia = {\n\tpeer: InputPeer,\n\timport_id: string,\n\tfile_name: string,\n\tmedia: InputMedia\n};\n\nexport type MessagesStartHistoryImport = {\n\tpeer: InputPeer,\n\timport_id: string\n};\n\nexport type MessagesGetExportedChatInvites = {\n\tflags?: number,\n\trevoked?: boolean,\n\tpeer: InputPeer,\n\tadmin_id: InputUser,\n\toffset_date?: number,\n\toffset_link?: string,\n\tlimit: number\n};\n\nexport type MessagesGetExportedChatInvite = {\n\tpeer: InputPeer,\n\tlink: string\n};\n\nexport type MessagesEditExportedChatInvite = {\n\tflags?: number,\n\trevoked?: boolean,\n\tpeer: InputPeer,\n\tlink: string,\n\texpire_date?: number,\n\tusage_limit?: number\n};\n\nexport type MessagesDeleteRevokedExportedChatInvites = {\n\tpeer: InputPeer,\n\tadmin_id: InputUser\n};\n\nexport type MessagesDeleteExportedChatInvite = {\n\tpeer: InputPeer,\n\tlink: string\n};\n\nexport type MessagesGetAdminsWithInvites = {\n\tpeer: InputPeer\n};\n\nexport type MessagesGetChatInviteImporters = {\n\tpeer: InputPeer,\n\tlink: string,\n\toffset_date: number,\n\toffset_user: InputUser,\n\tlimit: number\n};\n\nexport type MessagesSetHistoryTTL = {\n\tpeer: InputPeer,\n\tperiod: number\n};\n\nexport type AccountReportProfilePhoto = {\n\tpeer: InputPeer,\n\tphoto_id: InputPhoto,\n\treason: ReportReason,\n\tmessage: string\n};\n\nexport type ChannelsConvertToGigagroup = {\n\tchannel: InputChannel\n};\n\nexport type MessagesCheckHistoryImportPeer = {\n\tpeer: InputPeer\n};\n\nexport type PhoneToggleGroupCallRecord = {\n\tflags?: number,\n\tstart?: boolean,\n\tcall: InputGroupCall,\n\ttitle?: string\n};\n\nexport type PhoneEditGroupCallParticipant = {\n\tflags?: number,\n\tcall: InputGroupCall,\n\tparticipant: InputPeer,\n\tmuted?: boolean,\n\tvolume?: number,\n\traise_hand?: boolean,\n\tvideo_stopped?: boolean,\n\tvideo_paused?: boolean,\n\tpresentation_paused?: boolean\n};\n\nexport type PhoneEditGroupCallTitle = {\n\tcall: InputGroupCall,\n\ttitle: string\n};\n\nexport type PhoneGetGroupCallJoinAs = {\n\tpeer: InputPeer\n};\n\nexport type PhoneExportGroupCallInvite = {\n\tflags?: number,\n\tcan_self_unmute?: boolean,\n\tcall: InputGroupCall\n};\n\nexport type PhoneToggleGroupCallStartSubscription = {\n\tcall: InputGroupCall,\n\tsubscribed: boolean\n};\n\nexport type PhoneStartScheduledGroupCall = {\n\tcall: InputGroupCall\n};\n\nexport type PhoneSaveDefaultGroupCallJoinAs = {\n\tpeer: InputPeer,\n\tjoin_as: InputPeer\n};\n\nexport type PhoneJoinGroupCallPresentation = {\n\tcall: InputGroupCall,\n\tparams: DataJSON\n};\n\nexport type PhoneLeaveGroupCallPresentation = {\n\tcall: InputGroupCall\n};\n\nexport type StickersCheckShortName = {\n\tshort_name: string\n};\n\nexport type StickersSuggestShortName = {\n\ttitle: string\n};\n\nexport type BotsResetBotCommands = {\n\tscope: BotCommandScope,\n\tlang_code: string\n};\n\nexport type BotsGetBotCommands = {\n\tscope: BotCommandScope,\n\tlang_code: string\n};\n\nexport type AccountResetPassword = {\n\n};\n\nexport type AccountDeclinePasswordReset = {\n\n};\n\nexport type AuthCheckRecoveryPassword = {\n\tcode: string\n};\n\nexport interface MethodDeclMap {\n\t'invokeAfterMsg': {req: InvokeAfterMsg, res: any},\n\t'invokeAfterMsgs': {req: InvokeAfterMsgs, res: any},\n\t'auth.sendCode': {req: AuthSendCode, res: AuthSentCode},\n\t'auth.signUp': {req: AuthSignUp, res: AuthAuthorization},\n\t'auth.signIn': {req: AuthSignIn, res: AuthAuthorization},\n\t'auth.logOut': {req: AuthLogOut, res: boolean},\n\t'auth.resetAuthorizations': {req: AuthResetAuthorizations, res: boolean},\n\t'auth.exportAuthorization': {req: AuthExportAuthorization, res: AuthExportedAuthorization},\n\t'auth.importAuthorization': {req: AuthImportAuthorization, res: AuthAuthorization},\n\t'auth.bindTempAuthKey': {req: AuthBindTempAuthKey, res: boolean},\n\t'account.registerDevice': {req: AccountRegisterDevice, res: boolean},\n\t'account.unregisterDevice': {req: AccountUnregisterDevice, res: boolean},\n\t'account.updateNotifySettings': {req: AccountUpdateNotifySettings, res: boolean},\n\t'account.getNotifySettings': {req: AccountGetNotifySettings, res: PeerNotifySettings},\n\t'account.resetNotifySettings': {req: AccountResetNotifySettings, res: boolean},\n\t'account.updateProfile': {req: AccountUpdateProfile, res: User},\n\t'account.updateStatus': {req: AccountUpdateStatus, res: boolean},\n\t'account.getWallPapers': {req: AccountGetWallPapers, res: AccountWallPapers},\n\t'account.reportPeer': {req: AccountReportPeer, res: boolean},\n\t'users.getUsers': {req: UsersGetUsers, res: Array<User>},\n\t'users.getFullUser': {req: UsersGetFullUser, res: UserFull},\n\t'contacts.getContactIDs': {req: ContactsGetContactIDs, res: Array<number>},\n\t'contacts.getStatuses': {req: ContactsGetStatuses, res: Array<ContactStatus>},\n\t'contacts.getContacts': {req: ContactsGetContacts, res: ContactsContacts},\n\t'contacts.importContacts': {req: ContactsImportContacts, res: ContactsImportedContacts},\n\t'contacts.deleteContacts': {req: ContactsDeleteContacts, res: Updates},\n\t'contacts.deleteByPhones': {req: ContactsDeleteByPhones, res: boolean},\n\t'contacts.block': {req: ContactsBlock, res: boolean},\n\t'contacts.unblock': {req: ContactsUnblock, res: boolean},\n\t'contacts.getBlocked': {req: ContactsGetBlocked, res: ContactsBlocked},\n\t'messages.getMessages': {req: MessagesGetMessages, res: MessagesMessages},\n\t'messages.getDialogs': {req: MessagesGetDialogs, res: MessagesDialogs},\n\t'messages.getHistory': {req: MessagesGetHistory, res: MessagesMessages},\n\t'messages.search': {req: MessagesSearch, res: MessagesMessages},\n\t'messages.readHistory': {req: MessagesReadHistory, res: MessagesAffectedMessages},\n\t'messages.deleteHistory': {req: MessagesDeleteHistory, res: MessagesAffectedHistory},\n\t'messages.deleteMessages': {req: MessagesDeleteMessages, res: MessagesAffectedMessages},\n\t'messages.receivedMessages': {req: MessagesReceivedMessages, res: Array<ReceivedNotifyMessage>},\n\t'messages.setTyping': {req: MessagesSetTyping, res: boolean},\n\t'messages.sendMessage': {req: MessagesSendMessage, res: Updates},\n\t'messages.sendMedia': {req: MessagesSendMedia, res: Updates},\n\t'messages.forwardMessages': {req: MessagesForwardMessages, res: Updates},\n\t'messages.reportSpam': {req: MessagesReportSpam, res: boolean},\n\t'messages.getPeerSettings': {req: MessagesGetPeerSettings, res: PeerSettings},\n\t'messages.report': {req: MessagesReport, res: boolean},\n\t'messages.getChats': {req: MessagesGetChats, res: MessagesChats},\n\t'messages.getFullChat': {req: MessagesGetFullChat, res: MessagesChatFull},\n\t'messages.editChatTitle': {req: MessagesEditChatTitle, res: Updates},\n\t'messages.editChatPhoto': {req: MessagesEditChatPhoto, res: Updates},\n\t'messages.addChatUser': {req: MessagesAddChatUser, res: Updates},\n\t'messages.deleteChatUser': {req: MessagesDeleteChatUser, res: Updates},\n\t'messages.createChat': {req: MessagesCreateChat, res: Updates},\n\t'updates.getState': {req: UpdatesGetState, res: UpdatesState},\n\t'updates.getDifference': {req: UpdatesGetDifference, res: UpdatesDifference},\n\t'photos.updateProfilePhoto': {req: PhotosUpdateProfilePhoto, res: PhotosPhoto},\n\t'photos.uploadProfilePhoto': {req: PhotosUploadProfilePhoto, res: PhotosPhoto},\n\t'photos.deletePhotos': {req: PhotosDeletePhotos, res: Array<string>},\n\t'upload.saveFilePart': {req: UploadSaveFilePart, res: boolean},\n\t'upload.getFile': {req: UploadGetFile, res: UploadFile},\n\t'help.getConfig': {req: HelpGetConfig, res: Config},\n\t'help.getNearestDc': {req: HelpGetNearestDc, res: NearestDc},\n\t'help.getAppUpdate': {req: HelpGetAppUpdate, res: HelpAppUpdate},\n\t'help.getInviteText': {req: HelpGetInviteText, res: HelpInviteText},\n\t'photos.getUserPhotos': {req: PhotosGetUserPhotos, res: PhotosPhotos},\n\t'messages.getDhConfig': {req: MessagesGetDhConfig, res: MessagesDhConfig},\n\t'messages.requestEncryption': {req: MessagesRequestEncryption, res: EncryptedChat},\n\t'messages.acceptEncryption': {req: MessagesAcceptEncryption, res: EncryptedChat},\n\t'messages.discardEncryption': {req: MessagesDiscardEncryption, res: boolean},\n\t'messages.setEncryptedTyping': {req: MessagesSetEncryptedTyping, res: boolean},\n\t'messages.readEncryptedHistory': {req: MessagesReadEncryptedHistory, res: boolean},\n\t'messages.sendEncrypted': {req: MessagesSendEncrypted, res: MessagesSentEncryptedMessage},\n\t'messages.sendEncryptedFile': {req: MessagesSendEncryptedFile, res: MessagesSentEncryptedMessage},\n\t'messages.sendEncryptedService': {req: MessagesSendEncryptedService, res: MessagesSentEncryptedMessage},\n\t'messages.receivedQueue': {req: MessagesReceivedQueue, res: Array<string>},\n\t'messages.reportEncryptedSpam': {req: MessagesReportEncryptedSpam, res: boolean},\n\t'upload.saveBigFilePart': {req: UploadSaveBigFilePart, res: boolean},\n\t'initConnection': {req: InitConnection, res: any},\n\t'help.getSupport': {req: HelpGetSupport, res: HelpSupport},\n\t'messages.readMessageContents': {req: MessagesReadMessageContents, res: MessagesAffectedMessages},\n\t'account.checkUsername': {req: AccountCheckUsername, res: boolean},\n\t'account.updateUsername': {req: AccountUpdateUsername, res: User},\n\t'contacts.search': {req: ContactsSearch, res: ContactsFound},\n\t'account.getPrivacy': {req: AccountGetPrivacy, res: AccountPrivacyRules},\n\t'account.setPrivacy': {req: AccountSetPrivacy, res: AccountPrivacyRules},\n\t'account.deleteAccount': {req: AccountDeleteAccount, res: boolean},\n\t'account.getAccountTTL': {req: AccountGetAccountTTL, res: AccountDaysTTL},\n\t'account.setAccountTTL': {req: AccountSetAccountTTL, res: boolean},\n\t'invokeWithLayer': {req: InvokeWithLayer, res: any},\n\t'contacts.resolveUsername': {req: ContactsResolveUsername, res: ContactsResolvedPeer},\n\t'account.sendChangePhoneCode': {req: AccountSendChangePhoneCode, res: AuthSentCode},\n\t'account.changePhone': {req: AccountChangePhone, res: User},\n\t'messages.getStickers': {req: MessagesGetStickers, res: MessagesStickers},\n\t'messages.getAllStickers': {req: MessagesGetAllStickers, res: MessagesAllStickers},\n\t'account.updateDeviceLocked': {req: AccountUpdateDeviceLocked, res: boolean},\n\t'auth.importBotAuthorization': {req: AuthImportBotAuthorization, res: AuthAuthorization},\n\t'messages.getWebPagePreview': {req: MessagesGetWebPagePreview, res: MessageMedia},\n\t'account.getAuthorizations': {req: AccountGetAuthorizations, res: AccountAuthorizations},\n\t'account.resetAuthorization': {req: AccountResetAuthorization, res: boolean},\n\t'account.getPassword': {req: AccountGetPassword, res: AccountPassword},\n\t'account.getPasswordSettings': {req: AccountGetPasswordSettings, res: AccountPasswordSettings},\n\t'account.updatePasswordSettings': {req: AccountUpdatePasswordSettings, res: boolean},\n\t'auth.checkPassword': {req: AuthCheckPassword, res: AuthAuthorization},\n\t'auth.requestPasswordRecovery': {req: AuthRequestPasswordRecovery, res: AuthPasswordRecovery},\n\t'auth.recoverPassword': {req: AuthRecoverPassword, res: AuthAuthorization},\n\t'invokeWithoutUpdates': {req: InvokeWithoutUpdates, res: any},\n\t'messages.exportChatInvite': {req: MessagesExportChatInvite, res: ExportedChatInvite},\n\t'messages.checkChatInvite': {req: MessagesCheckChatInvite, res: ChatInvite},\n\t'messages.importChatInvite': {req: MessagesImportChatInvite, res: Updates},\n\t'messages.getStickerSet': {req: MessagesGetStickerSet, res: MessagesStickerSet},\n\t'messages.installStickerSet': {req: MessagesInstallStickerSet, res: MessagesStickerSetInstallResult},\n\t'messages.uninstallStickerSet': {req: MessagesUninstallStickerSet, res: boolean},\n\t'messages.startBot': {req: MessagesStartBot, res: Updates},\n\t'help.getAppChangelog': {req: HelpGetAppChangelog, res: Updates},\n\t'messages.getMessagesViews': {req: MessagesGetMessagesViews, res: MessagesMessageViews},\n\t'channels.readHistory': {req: ChannelsReadHistory, res: boolean},\n\t'channels.deleteMessages': {req: ChannelsDeleteMessages, res: MessagesAffectedMessages},\n\t'channels.deleteUserHistory': {req: ChannelsDeleteUserHistory, res: MessagesAffectedHistory},\n\t'channels.reportSpam': {req: ChannelsReportSpam, res: boolean},\n\t'channels.getMessages': {req: ChannelsGetMessages, res: MessagesMessages},\n\t'channels.getParticipants': {req: ChannelsGetParticipants, res: ChannelsChannelParticipants},\n\t'channels.getParticipant': {req: ChannelsGetParticipant, res: ChannelsChannelParticipant},\n\t'channels.getChannels': {req: ChannelsGetChannels, res: MessagesChats},\n\t'channels.getFullChannel': {req: ChannelsGetFullChannel, res: MessagesChatFull},\n\t'channels.createChannel': {req: ChannelsCreateChannel, res: Updates},\n\t'channels.editAdmin': {req: ChannelsEditAdmin, res: Updates},\n\t'channels.editTitle': {req: ChannelsEditTitle, res: Updates},\n\t'channels.editPhoto': {req: ChannelsEditPhoto, res: Updates},\n\t'channels.checkUsername': {req: ChannelsCheckUsername, res: boolean},\n\t'channels.updateUsername': {req: ChannelsUpdateUsername, res: boolean},\n\t'channels.joinChannel': {req: ChannelsJoinChannel, res: Updates},\n\t'channels.leaveChannel': {req: ChannelsLeaveChannel, res: Updates},\n\t'channels.inviteToChannel': {req: ChannelsInviteToChannel, res: Updates},\n\t'channels.deleteChannel': {req: ChannelsDeleteChannel, res: Updates},\n\t'updates.getChannelDifference': {req: UpdatesGetChannelDifference, res: UpdatesChannelDifference},\n\t'messages.editChatAdmin': {req: MessagesEditChatAdmin, res: boolean},\n\t'messages.migrateChat': {req: MessagesMigrateChat, res: Updates},\n\t'messages.searchGlobal': {req: MessagesSearchGlobal, res: MessagesMessages},\n\t'messages.reorderStickerSets': {req: MessagesReorderStickerSets, res: boolean},\n\t'messages.getDocumentByHash': {req: MessagesGetDocumentByHash, res: Document},\n\t'messages.getSavedGifs': {req: MessagesGetSavedGifs, res: MessagesSavedGifs},\n\t'messages.saveGif': {req: MessagesSaveGif, res: boolean},\n\t'messages.getInlineBotResults': {req: MessagesGetInlineBotResults, res: MessagesBotResults},\n\t'messages.setInlineBotResults': {req: MessagesSetInlineBotResults, res: boolean},\n\t'messages.sendInlineBotResult': {req: MessagesSendInlineBotResult, res: Updates},\n\t'channels.exportMessageLink': {req: ChannelsExportMessageLink, res: ExportedMessageLink},\n\t'channels.toggleSignatures': {req: ChannelsToggleSignatures, res: Updates},\n\t'auth.resendCode': {req: AuthResendCode, res: AuthSentCode},\n\t'auth.cancelCode': {req: AuthCancelCode, res: boolean},\n\t'messages.getMessageEditData': {req: MessagesGetMessageEditData, res: MessagesMessageEditData},\n\t'messages.editMessage': {req: MessagesEditMessage, res: Updates},\n\t'messages.editInlineBotMessage': {req: MessagesEditInlineBotMessage, res: boolean},\n\t'messages.getBotCallbackAnswer': {req: MessagesGetBotCallbackAnswer, res: MessagesBotCallbackAnswer},\n\t'messages.setBotCallbackAnswer': {req: MessagesSetBotCallbackAnswer, res: boolean},\n\t'contacts.getTopPeers': {req: ContactsGetTopPeers, res: ContactsTopPeers},\n\t'contacts.resetTopPeerRating': {req: ContactsResetTopPeerRating, res: boolean},\n\t'messages.getPeerDialogs': {req: MessagesGetPeerDialogs, res: MessagesPeerDialogs},\n\t'messages.saveDraft': {req: MessagesSaveDraft, res: boolean},\n\t'messages.getAllDrafts': {req: MessagesGetAllDrafts, res: Updates},\n\t'messages.getFeaturedStickers': {req: MessagesGetFeaturedStickers, res: MessagesFeaturedStickers},\n\t'messages.readFeaturedStickers': {req: MessagesReadFeaturedStickers, res: boolean},\n\t'messages.getRecentStickers': {req: MessagesGetRecentStickers, res: MessagesRecentStickers},\n\t'messages.saveRecentSticker': {req: MessagesSaveRecentSticker, res: boolean},\n\t'messages.clearRecentStickers': {req: MessagesClearRecentStickers, res: boolean},\n\t'messages.getArchivedStickers': {req: MessagesGetArchivedStickers, res: MessagesArchivedStickers},\n\t'account.sendConfirmPhoneCode': {req: AccountSendConfirmPhoneCode, res: AuthSentCode},\n\t'account.confirmPhone': {req: AccountConfirmPhone, res: boolean},\n\t'channels.getAdminedPublicChannels': {req: ChannelsGetAdminedPublicChannels, res: MessagesChats},\n\t'messages.getMaskStickers': {req: MessagesGetMaskStickers, res: MessagesAllStickers},\n\t'messages.getAttachedStickers': {req: MessagesGetAttachedStickers, res: Array<StickerSetCovered>},\n\t'auth.dropTempAuthKeys': {req: AuthDropTempAuthKeys, res: boolean},\n\t'messages.setGameScore': {req: MessagesSetGameScore, res: Updates},\n\t'messages.setInlineGameScore': {req: MessagesSetInlineGameScore, res: boolean},\n\t'messages.getGameHighScores': {req: MessagesGetGameHighScores, res: MessagesHighScores},\n\t'messages.getInlineGameHighScores': {req: MessagesGetInlineGameHighScores, res: MessagesHighScores},\n\t'messages.getCommonChats': {req: MessagesGetCommonChats, res: MessagesChats},\n\t'messages.getAllChats': {req: MessagesGetAllChats, res: MessagesChats},\n\t'help.setBotUpdatesStatus': {req: HelpSetBotUpdatesStatus, res: boolean},\n\t'messages.getWebPage': {req: MessagesGetWebPage, res: WebPage},\n\t'messages.toggleDialogPin': {req: MessagesToggleDialogPin, res: boolean},\n\t'messages.reorderPinnedDialogs': {req: MessagesReorderPinnedDialogs, res: boolean},\n\t'messages.getPinnedDialogs': {req: MessagesGetPinnedDialogs, res: MessagesPeerDialogs},\n\t'bots.sendCustomRequest': {req: BotsSendCustomRequest, res: DataJSON},\n\t'bots.answerWebhookJSONQuery': {req: BotsAnswerWebhookJSONQuery, res: boolean},\n\t'upload.getWebFile': {req: UploadGetWebFile, res: UploadWebFile},\n\t'payments.getPaymentForm': {req: PaymentsGetPaymentForm, res: PaymentsPaymentForm},\n\t'payments.getPaymentReceipt': {req: PaymentsGetPaymentReceipt, res: PaymentsPaymentReceipt},\n\t'payments.validateRequestedInfo': {req: PaymentsValidateRequestedInfo, res: PaymentsValidatedRequestedInfo},\n\t'payments.sendPaymentForm': {req: PaymentsSendPaymentForm, res: PaymentsPaymentResult},\n\t'account.getTmpPassword': {req: AccountGetTmpPassword, res: AccountTmpPassword},\n\t'payments.getSavedInfo': {req: PaymentsGetSavedInfo, res: PaymentsSavedInfo},\n\t'payments.clearSavedInfo': {req: PaymentsClearSavedInfo, res: boolean},\n\t'messages.setBotShippingResults': {req: MessagesSetBotShippingResults, res: boolean},\n\t'messages.setBotPrecheckoutResults': {req: MessagesSetBotPrecheckoutResults, res: boolean},\n\t'stickers.createStickerSet': {req: StickersCreateStickerSet, res: MessagesStickerSet},\n\t'stickers.removeStickerFromSet': {req: StickersRemoveStickerFromSet, res: MessagesStickerSet},\n\t'stickers.changeStickerPosition': {req: StickersChangeStickerPosition, res: MessagesStickerSet},\n\t'stickers.addStickerToSet': {req: StickersAddStickerToSet, res: MessagesStickerSet},\n\t'messages.uploadMedia': {req: MessagesUploadMedia, res: MessageMedia},\n\t'phone.getCallConfig': {req: PhoneGetCallConfig, res: DataJSON},\n\t'phone.requestCall': {req: PhoneRequestCall, res: PhonePhoneCall},\n\t'phone.acceptCall': {req: PhoneAcceptCall, res: PhonePhoneCall},\n\t'phone.confirmCall': {req: PhoneConfirmCall, res: PhonePhoneCall},\n\t'phone.receivedCall': {req: PhoneReceivedCall, res: boolean},\n\t'phone.discardCall': {req: PhoneDiscardCall, res: Updates},\n\t'phone.setCallRating': {req: PhoneSetCallRating, res: Updates},\n\t'phone.saveCallDebug': {req: PhoneSaveCallDebug, res: boolean},\n\t'upload.getCdnFile': {req: UploadGetCdnFile, res: UploadCdnFile},\n\t'upload.reuploadCdnFile': {req: UploadReuploadCdnFile, res: Array<FileHash>},\n\t'help.getCdnConfig': {req: HelpGetCdnConfig, res: CdnConfig},\n\t'langpack.getLangPack': {req: LangpackGetLangPack, res: LangPackDifference},\n\t'langpack.getStrings': {req: LangpackGetStrings, res: Array<LangPackString>},\n\t'langpack.getDifference': {req: LangpackGetDifference, res: LangPackDifference},\n\t'langpack.getLanguages': {req: LangpackGetLanguages, res: Array<LangPackLanguage>},\n\t'channels.editBanned': {req: ChannelsEditBanned, res: Updates},\n\t'channels.getAdminLog': {req: ChannelsGetAdminLog, res: ChannelsAdminLogResults},\n\t'upload.getCdnFileHashes': {req: UploadGetCdnFileHashes, res: Array<FileHash>},\n\t'messages.sendScreenshotNotification': {req: MessagesSendScreenshotNotification, res: Updates},\n\t'channels.setStickers': {req: ChannelsSetStickers, res: boolean},\n\t'messages.getFavedStickers': {req: MessagesGetFavedStickers, res: MessagesFavedStickers},\n\t'messages.faveSticker': {req: MessagesFaveSticker, res: boolean},\n\t'channels.readMessageContents': {req: ChannelsReadMessageContents, res: boolean},\n\t'contacts.resetSaved': {req: ContactsResetSaved, res: boolean},\n\t'messages.getUnreadMentions': {req: MessagesGetUnreadMentions, res: MessagesMessages},\n\t'channels.deleteHistory': {req: ChannelsDeleteHistory, res: boolean},\n\t'help.getRecentMeUrls': {req: HelpGetRecentMeUrls, res: HelpRecentMeUrls},\n\t'channels.togglePreHistoryHidden': {req: ChannelsTogglePreHistoryHidden, res: Updates},\n\t'messages.readMentions': {req: MessagesReadMentions, res: MessagesAffectedHistory},\n\t'messages.getRecentLocations': {req: MessagesGetRecentLocations, res: MessagesMessages},\n\t'messages.sendMultiMedia': {req: MessagesSendMultiMedia, res: Updates},\n\t'messages.uploadEncryptedFile': {req: MessagesUploadEncryptedFile, res: EncryptedFile},\n\t'account.getWebAuthorizations': {req: AccountGetWebAuthorizations, res: AccountWebAuthorizations},\n\t'account.resetWebAuthorization': {req: AccountResetWebAuthorization, res: boolean},\n\t'account.resetWebAuthorizations': {req: AccountResetWebAuthorizations, res: boolean},\n\t'messages.searchStickerSets': {req: MessagesSearchStickerSets, res: MessagesFoundStickerSets},\n\t'upload.getFileHashes': {req: UploadGetFileHashes, res: Array<FileHash>},\n\t'help.getTermsOfServiceUpdate': {req: HelpGetTermsOfServiceUpdate, res: HelpTermsOfServiceUpdate},\n\t'help.acceptTermsOfService': {req: HelpAcceptTermsOfService, res: boolean},\n\t'account.getAllSecureValues': {req: AccountGetAllSecureValues, res: Array<SecureValue>},\n\t'account.getSecureValue': {req: AccountGetSecureValue, res: Array<SecureValue>},\n\t'account.saveSecureValue': {req: AccountSaveSecureValue, res: SecureValue},\n\t'account.deleteSecureValue': {req: AccountDeleteSecureValue, res: boolean},\n\t'users.setSecureValueErrors': {req: UsersSetSecureValueErrors, res: boolean},\n\t'account.getAuthorizationForm': {req: AccountGetAuthorizationForm, res: AccountAuthorizationForm},\n\t'account.acceptAuthorization': {req: AccountAcceptAuthorization, res: boolean},\n\t'account.sendVerifyPhoneCode': {req: AccountSendVerifyPhoneCode, res: AuthSentCode},\n\t'account.verifyPhone': {req: AccountVerifyPhone, res: boolean},\n\t'account.sendVerifyEmailCode': {req: AccountSendVerifyEmailCode, res: AccountSentEmailCode},\n\t'account.verifyEmail': {req: AccountVerifyEmail, res: boolean},\n\t'help.getDeepLinkInfo': {req: HelpGetDeepLinkInfo, res: HelpDeepLinkInfo},\n\t'contacts.getSaved': {req: ContactsGetSaved, res: Array<SavedContact>},\n\t'channels.getLeftChannels': {req: ChannelsGetLeftChannels, res: MessagesChats},\n\t'account.initTakeoutSession': {req: AccountInitTakeoutSession, res: AccountTakeout},\n\t'account.finishTakeoutSession': {req: AccountFinishTakeoutSession, res: boolean},\n\t'messages.getSplitRanges': {req: MessagesGetSplitRanges, res: Array<MessageRange>},\n\t'invokeWithMessagesRange': {req: InvokeWithMessagesRange, res: any},\n\t'invokeWithTakeout': {req: InvokeWithTakeout, res: any},\n\t'messages.markDialogUnread': {req: MessagesMarkDialogUnread, res: boolean},\n\t'messages.getDialogUnreadMarks': {req: MessagesGetDialogUnreadMarks, res: Array<DialogPeer>},\n\t'contacts.toggleTopPeers': {req: ContactsToggleTopPeers, res: boolean},\n\t'messages.clearAllDrafts': {req: MessagesClearAllDrafts, res: boolean},\n\t'help.getAppConfig': {req: HelpGetAppConfig, res: JSONValue},\n\t'help.saveAppLog': {req: HelpSaveAppLog, res: boolean},\n\t'help.getPassportConfig': {req: HelpGetPassportConfig, res: HelpPassportConfig},\n\t'langpack.getLanguage': {req: LangpackGetLanguage, res: LangPackLanguage},\n\t'messages.updatePinnedMessage': {req: MessagesUpdatePinnedMessage, res: Updates},\n\t'account.confirmPasswordEmail': {req: AccountConfirmPasswordEmail, res: boolean},\n\t'account.resendPasswordEmail': {req: AccountResendPasswordEmail, res: boolean},\n\t'account.cancelPasswordEmail': {req: AccountCancelPasswordEmail, res: boolean},\n\t'help.getSupportName': {req: HelpGetSupportName, res: HelpSupportName},\n\t'help.getUserInfo': {req: HelpGetUserInfo, res: HelpUserInfo},\n\t'help.editUserInfo': {req: HelpEditUserInfo, res: HelpUserInfo},\n\t'account.getContactSignUpNotification': {req: AccountGetContactSignUpNotification, res: boolean},\n\t'account.setContactSignUpNotification': {req: AccountSetContactSignUpNotification, res: boolean},\n\t'account.getNotifyExceptions': {req: AccountGetNotifyExceptions, res: Updates},\n\t'messages.sendVote': {req: MessagesSendVote, res: Updates},\n\t'messages.getPollResults': {req: MessagesGetPollResults, res: Updates},\n\t'messages.getOnlines': {req: MessagesGetOnlines, res: ChatOnlines},\n\t'messages.getStatsURL': {req: MessagesGetStatsURL, res: StatsURL},\n\t'messages.editChatAbout': {req: MessagesEditChatAbout, res: boolean},\n\t'messages.editChatDefaultBannedRights': {req: MessagesEditChatDefaultBannedRights, res: Updates},\n\t'account.getWallPaper': {req: AccountGetWallPaper, res: WallPaper},\n\t'account.uploadWallPaper': {req: AccountUploadWallPaper, res: WallPaper},\n\t'account.saveWallPaper': {req: AccountSaveWallPaper, res: boolean},\n\t'account.installWallPaper': {req: AccountInstallWallPaper, res: boolean},\n\t'account.resetWallPapers': {req: AccountResetWallPapers, res: boolean},\n\t'account.getAutoDownloadSettings': {req: AccountGetAutoDownloadSettings, res: AccountAutoDownloadSettings},\n\t'account.saveAutoDownloadSettings': {req: AccountSaveAutoDownloadSettings, res: boolean},\n\t'messages.getEmojiKeywords': {req: MessagesGetEmojiKeywords, res: EmojiKeywordsDifference},\n\t'messages.getEmojiKeywordsDifference': {req: MessagesGetEmojiKeywordsDifference, res: EmojiKeywordsDifference},\n\t'messages.getEmojiKeywordsLanguages': {req: MessagesGetEmojiKeywordsLanguages, res: Array<EmojiLanguage>},\n\t'messages.getEmojiURL': {req: MessagesGetEmojiURL, res: EmojiURL},\n\t'folders.editPeerFolders': {req: FoldersEditPeerFolders, res: Updates},\n\t'folders.deleteFolder': {req: FoldersDeleteFolder, res: Updates},\n\t'messages.getSearchCounters': {req: MessagesGetSearchCounters, res: Array<MessagesSearchCounter>},\n\t'channels.getGroupsForDiscussion': {req: ChannelsGetGroupsForDiscussion, res: MessagesChats},\n\t'channels.setDiscussionGroup': {req: ChannelsSetDiscussionGroup, res: boolean},\n\t'messages.requestUrlAuth': {req: MessagesRequestUrlAuth, res: UrlAuthResult},\n\t'messages.acceptUrlAuth': {req: MessagesAcceptUrlAuth, res: UrlAuthResult},\n\t'messages.hidePeerSettingsBar': {req: MessagesHidePeerSettingsBar, res: boolean},\n\t'contacts.addContact': {req: ContactsAddContact, res: Updates},\n\t'contacts.acceptContact': {req: ContactsAcceptContact, res: Updates},\n\t'channels.editCreator': {req: ChannelsEditCreator, res: Updates},\n\t'contacts.getLocated': {req: ContactsGetLocated, res: Updates},\n\t'channels.editLocation': {req: ChannelsEditLocation, res: boolean},\n\t'channels.toggleSlowMode': {req: ChannelsToggleSlowMode, res: Updates},\n\t'messages.getScheduledHistory': {req: MessagesGetScheduledHistory, res: MessagesMessages},\n\t'messages.getScheduledMessages': {req: MessagesGetScheduledMessages, res: MessagesMessages},\n\t'messages.sendScheduledMessages': {req: MessagesSendScheduledMessages, res: Updates},\n\t'messages.deleteScheduledMessages': {req: MessagesDeleteScheduledMessages, res: Updates},\n\t'account.uploadTheme': {req: AccountUploadTheme, res: Document},\n\t'account.createTheme': {req: AccountCreateTheme, res: Theme},\n\t'account.updateTheme': {req: AccountUpdateTheme, res: Theme},\n\t'account.saveTheme': {req: AccountSaveTheme, res: boolean},\n\t'account.installTheme': {req: AccountInstallTheme, res: boolean},\n\t'account.getTheme': {req: AccountGetTheme, res: Theme},\n\t'account.getThemes': {req: AccountGetThemes, res: AccountThemes},\n\t'auth.exportLoginToken': {req: AuthExportLoginToken, res: AuthLoginToken},\n\t'auth.importLoginToken': {req: AuthImportLoginToken, res: AuthLoginToken},\n\t'auth.acceptLoginToken': {req: AuthAcceptLoginToken, res: Authorization},\n\t'account.setContentSettings': {req: AccountSetContentSettings, res: boolean},\n\t'account.getContentSettings': {req: AccountGetContentSettings, res: AccountContentSettings},\n\t'channels.getInactiveChannels': {req: ChannelsGetInactiveChannels, res: MessagesInactiveChats},\n\t'account.getMultiWallPapers': {req: AccountGetMultiWallPapers, res: Array<WallPaper>},\n\t'messages.getPollVotes': {req: MessagesGetPollVotes, res: MessagesVotesList},\n\t'messages.toggleStickerSets': {req: MessagesToggleStickerSets, res: boolean},\n\t'payments.getBankCardData': {req: PaymentsGetBankCardData, res: PaymentsBankCardData},\n\t'messages.getDialogFilters': {req: MessagesGetDialogFilters, res: Array<DialogFilter>},\n\t'messages.getSuggestedDialogFilters': {req: MessagesGetSuggestedDialogFilters, res: Array<DialogFilterSuggested>},\n\t'messages.updateDialogFilter': {req: MessagesUpdateDialogFilter, res: boolean},\n\t'messages.updateDialogFiltersOrder': {req: MessagesUpdateDialogFiltersOrder, res: boolean},\n\t'stats.getBroadcastStats': {req: StatsGetBroadcastStats, res: StatsBroadcastStats},\n\t'stats.loadAsyncGraph': {req: StatsLoadAsyncGraph, res: StatsGraph},\n\t'stickers.setStickerSetThumb': {req: StickersSetStickerSetThumb, res: MessagesStickerSet},\n\t'bots.setBotCommands': {req: BotsSetBotCommands, res: boolean},\n\t'messages.getOldFeaturedStickers': {req: MessagesGetOldFeaturedStickers, res: MessagesFeaturedStickers},\n\t'help.getPromoData': {req: HelpGetPromoData, res: HelpPromoData},\n\t'help.hidePromoData': {req: HelpHidePromoData, res: boolean},\n\t'phone.sendSignalingData': {req: PhoneSendSignalingData, res: boolean},\n\t'stats.getMegagroupStats': {req: StatsGetMegagroupStats, res: StatsMegagroupStats},\n\t'account.getGlobalPrivacySettings': {req: AccountGetGlobalPrivacySettings, res: GlobalPrivacySettings},\n\t'account.setGlobalPrivacySettings': {req: AccountSetGlobalPrivacySettings, res: GlobalPrivacySettings},\n\t'help.dismissSuggestion': {req: HelpDismissSuggestion, res: boolean},\n\t'help.getCountriesList': {req: HelpGetCountriesList, res: HelpCountriesList},\n\t'messages.getReplies': {req: MessagesGetReplies, res: MessagesMessages},\n\t'messages.getDiscussionMessage': {req: MessagesGetDiscussionMessage, res: MessagesDiscussionMessage},\n\t'messages.readDiscussion': {req: MessagesReadDiscussion, res: boolean},\n\t'contacts.blockFromReplies': {req: ContactsBlockFromReplies, res: Updates},\n\t'stats.getMessagePublicForwards': {req: StatsGetMessagePublicForwards, res: MessagesMessages},\n\t'stats.getMessageStats': {req: StatsGetMessageStats, res: StatsMessageStats},\n\t'messages.unpinAllMessages': {req: MessagesUnpinAllMessages, res: MessagesAffectedHistory},\n\t'phone.createGroupCall': {req: PhoneCreateGroupCall, res: Updates},\n\t'phone.joinGroupCall': {req: PhoneJoinGroupCall, res: Updates},\n\t'phone.leaveGroupCall': {req: PhoneLeaveGroupCall, res: Updates},\n\t'phone.inviteToGroupCall': {req: PhoneInviteToGroupCall, res: Updates},\n\t'phone.discardGroupCall': {req: PhoneDiscardGroupCall, res: Updates},\n\t'phone.toggleGroupCallSettings': {req: PhoneToggleGroupCallSettings, res: Updates},\n\t'phone.getGroupCall': {req: PhoneGetGroupCall, res: PhoneGroupCall},\n\t'phone.getGroupParticipants': {req: PhoneGetGroupParticipants, res: PhoneGroupParticipants},\n\t'phone.checkGroupCall': {req: PhoneCheckGroupCall, res: Array<number>},\n\t'messages.deleteChat': {req: MessagesDeleteChat, res: boolean},\n\t'messages.deletePhoneCallHistory': {req: MessagesDeletePhoneCallHistory, res: MessagesAffectedFoundMessages},\n\t'messages.checkHistoryImport': {req: MessagesCheckHistoryImport, res: MessagesHistoryImportParsed},\n\t'messages.initHistoryImport': {req: MessagesInitHistoryImport, res: MessagesHistoryImport},\n\t'messages.uploadImportedMedia': {req: MessagesUploadImportedMedia, res: MessageMedia},\n\t'messages.startHistoryImport': {req: MessagesStartHistoryImport, res: boolean},\n\t'messages.getExportedChatInvites': {req: MessagesGetExportedChatInvites, res: MessagesExportedChatInvites},\n\t'messages.getExportedChatInvite': {req: MessagesGetExportedChatInvite, res: MessagesExportedChatInvite},\n\t'messages.editExportedChatInvite': {req: MessagesEditExportedChatInvite, res: MessagesExportedChatInvite},\n\t'messages.deleteRevokedExportedChatInvites': {req: MessagesDeleteRevokedExportedChatInvites, res: boolean},\n\t'messages.deleteExportedChatInvite': {req: MessagesDeleteExportedChatInvite, res: boolean},\n\t'messages.getAdminsWithInvites': {req: MessagesGetAdminsWithInvites, res: MessagesChatAdminsWithInvites},\n\t'messages.getChatInviteImporters': {req: MessagesGetChatInviteImporters, res: MessagesChatInviteImporters},\n\t'messages.setHistoryTTL': {req: MessagesSetHistoryTTL, res: Updates},\n\t'account.reportProfilePhoto': {req: AccountReportProfilePhoto, res: boolean},\n\t'channels.convertToGigagroup': {req: ChannelsConvertToGigagroup, res: Updates},\n\t'messages.checkHistoryImportPeer': {req: MessagesCheckHistoryImportPeer, res: MessagesCheckedHistoryImportPeer},\n\t'phone.toggleGroupCallRecord': {req: PhoneToggleGroupCallRecord, res: Updates},\n\t'phone.editGroupCallParticipant': {req: PhoneEditGroupCallParticipant, res: Updates},\n\t'phone.editGroupCallTitle': {req: PhoneEditGroupCallTitle, res: Updates},\n\t'phone.getGroupCallJoinAs': {req: PhoneGetGroupCallJoinAs, res: PhoneJoinAsPeers},\n\t'phone.exportGroupCallInvite': {req: PhoneExportGroupCallInvite, res: PhoneExportedGroupCallInvite},\n\t'phone.toggleGroupCallStartSubscription': {req: PhoneToggleGroupCallStartSubscription, res: Updates},\n\t'phone.startScheduledGroupCall': {req: PhoneStartScheduledGroupCall, res: Updates},\n\t'phone.saveDefaultGroupCallJoinAs': {req: PhoneSaveDefaultGroupCallJoinAs, res: boolean},\n\t'phone.joinGroupCallPresentation': {req: PhoneJoinGroupCallPresentation, res: Updates},\n\t'phone.leaveGroupCallPresentation': {req: PhoneLeaveGroupCallPresentation, res: Updates},\n\t'stickers.checkShortName': {req: StickersCheckShortName, res: boolean},\n\t'stickers.suggestShortName': {req: StickersSuggestShortName, res: StickersSuggestedShortName},\n\t'bots.resetBotCommands': {req: BotsResetBotCommands, res: boolean},\n\t'bots.getBotCommands': {req: BotsGetBotCommands, res: Array<BotCommand>},\n\t'account.resetPassword': {req: AccountResetPassword, res: AccountResetPasswordResult},\n\t'account.declinePasswordReset': {req: AccountDeclinePasswordReset, res: boolean},\n\t'auth.checkRecoveryPassword': {req: AuthCheckRecoveryPassword, res: boolean},\n}\n\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport AvatarElement from \"../../components/avatar\";\nimport DialogsContextMenu from \"../../components/dialogsContextMenu\";\nimport { horizontalMenu } from \"../../components/horizontalMenu\";\nimport { attachContextMenuListener, putPreloader } from \"../../components/misc\";\nimport { ripple } from \"../../components/ripple\";\n//import Scrollable from \"../../components/scrollable\";\nimport Scrollable, { ScrollableX, SliceSides } from \"../../components/scrollable\";\nimport { formatDateAccordingToTodayNew } from \"../../helpers/date\";\nimport { isSafari } from \"../../helpers/userAgent\";\nimport { logger, LogTypes } from \"../logger\";\nimport { RichTextProcessor } from \"../richtextprocessor\";\nimport rootScope from \"../rootScope\";\nimport apiUpdatesManager from \"./apiUpdatesManager\";\nimport appPeersManager from './appPeersManager';\nimport appImManager from \"./appImManager\";\nimport appMessagesManager, { Dialog } from \"./appMessagesManager\";\nimport {MyDialogFilter as DialogFilter} from \"../storages/filters\";\nimport appStateManager, { State } from \"./appStateManager\";\nimport appUsersManager from \"./appUsersManager\";\nimport Button from \"../../components/button\";\nimport SetTransition from \"../../components/singleTransition\";\nimport appDraftsManager, { MyDraftMessage } from \"./appDraftsManager\";\nimport DEBUG, { MOUNT_CLASS_TO } from \"../../config/debug\";\nimport appNotificationsManager from \"./appNotificationsManager\";\nimport PeerTitle from \"../../components/peerTitle\";\nimport I18n, { FormatterArguments, i18n, LangPackKey, _i18n } from \"../langPack\";\nimport findUpTag from \"../../helpers/dom/findUpTag\";\nimport { LazyLoadQueueIntersector } from \"../../components/lazyLoadQueue\";\nimport lottieLoader from \"../lottieLoader\";\nimport { wrapLocalSticker } from \"../../components/wrappers\";\nimport AppEditFolderTab from \"../../components/sidebarLeft/tabs/editFolder\";\nimport appSidebarLeft from \"../../components/sidebarLeft\";\nimport { attachClickEvent } from \"../../helpers/dom/clickEvent\";\nimport positionElementByIndex from \"../../helpers/dom/positionElementByIndex\";\nimport replaceContent from \"../../helpers/dom/replaceContent\";\nimport ConnectionStatusComponent from \"../../components/connectionStatus\";\nimport appChatsManager from \"./appChatsManager\";\nimport { renderImageFromUrlPromise } from \"../../helpers/dom/renderImageFromUrl\";\nimport { fastRafPromise } from \"../../helpers/schedulers\";\n\nexport type DialogDom = {\n  avatarEl: AvatarElement,\n  captionDiv: HTMLDivElement,\n  titleSpan: HTMLSpanElement,\n  titleSpanContainer: HTMLSpanElement,\n  statusSpan: HTMLSpanElement,\n  lastTimeSpan: HTMLSpanElement,\n  unreadMessagesSpan: HTMLSpanElement,\n  lastMessageSpan: HTMLSpanElement,\n  containerEl: HTMLElement,\n  listEl: HTMLLIElement,\n  muteAnimationTimeout?: number\n};\n\n//const testScroll = false;\n//let testTopSlice = 1;\n\nexport class AppDialogsManager {\n  private chatList: HTMLUListElement;\n\n  private doms: {[peerId: number]: DialogDom} = {};\n\n  private chatsContainer = document.getElementById('chatlist-container') as HTMLDivElement;\n  private chatsPreloader: HTMLElement;\n\n  private loadDialogsPromise: Promise<any>;\n\n  private scroll: Scrollable = null;\n  \n  private log = logger('DIALOGS', LogTypes.Log | LogTypes.Error | LogTypes.Warn | LogTypes.Debug);\n\n  private contextMenu = new DialogsContextMenu();\n\n  public chatLists: {[filterId: number]: HTMLUListElement} = {};\n  public scrollables: {[filterId: number]: Scrollable} = {};\n  public filterId: number;\n  private folders: {[k in 'menu' | 'container' | 'menuScrollContainer']: HTMLElement} = {\n    menu: document.getElementById('folders-tabs'),\n    menuScrollContainer: null,\n    container: document.getElementById('folders-container')\n  };\n  private filtersRendered: {\n    [filterId: string]: {\n      menu: HTMLElement, \n      container: HTMLElement,\n      unread: HTMLElement,\n      title: HTMLElement\n    }\n  } = {};\n  private showFiltersPromise: Promise<void>;\n  private allUnreadCount: HTMLElement;\n\n  private accumulateArchivedTimeout: number;\n\n  //private topOffsetIndex = 0;\n\n  private sliceTimeout: number;\n  private reorderDialogsTimeout: number;\n\n  private lastActiveElements: Set<HTMLElement> = new Set();\n\n  private offsets: {top: number, bottom: number} = {top: 0, bottom: 0};\n\n  constructor() {\n    this.chatsPreloader = putPreloader(null, true);\n\n    this.allUnreadCount = this.folders.menu.querySelector('.badge');\n    \n    this.folders.menuScrollContainer = this.folders.menu.parentElement;\n\n    const bottomPart = document.createElement('div');\n    bottomPart.classList.add('connection-status-bottom');\n    bottomPart.append(this.folders.container);\n\n    /* if(isTouchSupported && isSafari) {\n      let allowUp: boolean, allowDown: boolean, slideBeginY: number;\n      const container = this.scroll.container;\n      container.addEventListener('touchstart', (event) => {\n        allowUp = container.scrollTop > 0;\n        allowDown = (container.scrollTop < container.scrollHeight - container.clientHeight);\n        // @ts-ignore\n        slideBeginY = event.pageY;\n      });\n      \n      container.addEventListener('touchmove', (event: any) => {\n        var up = (event.pageY > slideBeginY);\n        var down = (event.pageY < slideBeginY);\n        slideBeginY = event.pageY;\n        if((up && allowUp) || (down && allowDown)) {\n          event.stopPropagation();\n        } else if(up || down) {\n          event.preventDefault();\n        }\n      });\n    } */\n\n    this.filterId = 0;\n    this.addFilter({\n      id: this.filterId,\n      title: '',\n      titleEl: i18n('ChatList.Filter.AllChats'),\n      orderIndex: 0\n    });\n\n    this.chatList = this.chatLists[this.filterId];\n    this.scroll = this.scrollables[this.filterId];\n\n    /* if(testScroll) {\n      let i = 0;\n      let add = () => {\n        let li = document.createElement('li');\n        li.dataset.id = '' + i;\n        li.id = '' + i;\n        li.innerHTML = `<div class=\"rp\"><avatar-element style=\"background-color: rgb(166, 149, 231); font-size: 0px;\"><img src=\"assets/img/pepe.jpg\"></avatar-element><div class=\"user-caption\"><p><span class=\"user-title\">${i}</span><span><span class=\"message-status\"></span><span class=\"message-time\">18:33</span></span></p><p><span class=\"user-last-message\"><b>-_-_-_-: </b>qweasd</span><span></span></p></div></div>`;\n        i++;\n        this.scroll.append(li);\n      };\n      for(let i = 0; i < 500; ++i) {\n        add();\n      }\n      (window as any).addElement = add;\n    } */\n\n    rootScope.addEventListener('user_update', (userId) => {\n      //console.log('updating user:', user, dialog);\n      \n      const dom = this.getDialogDom(userId);\n      if(dom && !appUsersManager.isBot(userId) && userId !== rootScope.myId) {\n        const user = appUsersManager.getUser(userId);\n        const online = user.status?._ === 'userStatusOnline';\n        dom.avatarEl.classList.toggle('is-online', online);\n      }\n    });\n\n    /* rootScope.$on('dialog_top', (e) => {\n      const dialog = e;\n\n      this.setLastMessage(dialog);\n      this.setDialogPosition(dialog);\n\n      this.setFiltersUnreadCount();\n    }); */\n\n    rootScope.addEventListener('dialog_flush', (e) => {\n      const peerId: number = e.peerId;\n      const dialog = appMessagesManager.getDialogOnly(peerId);\n      if(dialog) {\n        this.setLastMessage(dialog);\n        this.validateForFilter();\n        this.setFiltersUnreadCount();\n      }\n    });\n\n    rootScope.addEventListener('dialogs_multiupdate', (e) => {\n      const dialogs = e;\n\n      for(const id in dialogs) {\n        const dialog = dialogs[id];\n        this.updateDialog(dialog);\n      }\n\n      this.validateForFilter();\n      this.setFiltersUnreadCount();\n    });\n\n    rootScope.addEventListener('dialog_drop', (e) => {\n      const {peerId} = e;\n\n      this.deleteDialog(peerId);\n      this.setFiltersUnreadCount();\n    });\n\n    rootScope.addEventListener('dialog_unread', (e) => {\n      const info = e;\n\n      const dialog = appMessagesManager.getDialogOnly(info.peerId);\n      if(dialog) {\n        this.setUnreadMessages(dialog);\n        this.validateForFilter();\n        this.setFiltersUnreadCount();\n      }\n    });\n\n    rootScope.addEventListener('dialog_notify_settings', (dialog) => {\n      this.setUnreadMessages(dialog); // \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u044d\u0442\u043e \u043d\u0435 \u043d\u0443\u0436\u043d\u043e, \u043d\u043e \u043d\u0443\u0436\u043d\u043e \u043c\u0435\u043d\u044f\u0442\u044c is-muted\n    });\n\n    rootScope.addEventListener('dialog_draft', (e) => {\n      const dialog = appMessagesManager.getDialogOnly(e.peerId);\n      if(dialog) {\n        this.updateDialog(dialog);\n      }\n    });\n\n    rootScope.addEventListener('peer_changed', (e) => {\n      const peerId = e;\n\n      //const perf = performance.now();\n      for(const element of this.lastActiveElements) {\n        if(+element.dataset.peerId !== peerId) {\n          element.classList.remove('active');\n          this.lastActiveElements.delete(element);\n        }\n      }\n\n      const elements = Array.from(document.querySelectorAll(`[data-autonomous=\"0\"] li[data-peer-id=\"${peerId}\"]`)) as HTMLElement[];\n      elements.forEach(element => {\n        element.classList.add('active');\n        this.lastActiveElements.add(element);\n      });\n      //this.log('peer_changed total time:', performance.now() - perf);\n    });\n\n    rootScope.addEventListener('filter_update', (e) => {\n      const filter: DialogFilter = e;\n      if(!this.filtersRendered[filter.id]) {\n        this.addFilter(filter);\n        return;\n      } else if(filter.id === this.filterId) { // \u044d\u0442\u043e \u043d\u0435\u0442 \u0442\u0443\u0442 \u0441\u043c\u044b\u0441\u043b\u0430 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c, \u0442\u0430\u043a \u043a\u0430\u043a \u0431\u0443\u0434\u0435\u0442 dialogs_multiupdate\n        //this.validateForFilter();\n        const folder = appMessagesManager.dialogsStorage.getFolder(filter.id);\n        this.validateForFilter();\n        for(let i = 0, length = folder.length; i < length; ++i) {\n          const dialog = folder[i];\n          this.updateDialog(dialog);\n        }\n        this.setFiltersUnreadCount();\n      }\n\n      const elements = this.filtersRendered[filter.id];\n      elements.title.innerHTML = RichTextProcessor.wrapEmojiText(filter.title);\n    });\n\n    rootScope.addEventListener('filter_delete', (e) => {\n      const filter: DialogFilter = e;\n      const elements = this.filtersRendered[filter.id];\n      if(!elements) return;\n\n      // set tab\n      //(this.folders.menu.firstElementChild.children[Math.max(0, filter.id - 2)] as HTMLElement).click();\n      (this.folders.menu.firstElementChild as HTMLElement).click();\n\n      elements.container.remove();\n      elements.menu.remove();\n      \n      delete this.chatLists[filter.id];\n      delete this.scrollables[filter.id];\n      delete this.filtersRendered[filter.id];\n\n      if(Object.keys(this.filtersRendered).length <= 1) {\n        this.folders.menuScrollContainer.classList.add('hide');\n      }\n    });\n\n    rootScope.addEventListener('filter_order', (e) => {\n      const order = e;\n      \n      const containerToAppend = this.folders.menu as HTMLElement;\n      order.forEach((filterId) => {\n        const filter = appMessagesManager.filtersStorage.filters[filterId];\n        const renderedFilter = this.filtersRendered[filterId];\n\n        positionElementByIndex(renderedFilter.menu, containerToAppend, filter.orderIndex);\n        positionElementByIndex(renderedFilter.container, this.folders.container, filter.orderIndex);\n      });\n\n      /* if(this.filterId) {\n        const tabIndex = order.indexOf(this.filterId) + 1;\n        selectTab.prevId = tabIndex;\n      } */\n    });\n\n    rootScope.addEventListener('peer_typings', (e) => {\n      const {peerId, typings} = e;\n\n      const dialog = appMessagesManager.getDialogOnly(peerId);\n      if(!dialog) return;\n\n      if(typings.length) {\n        this.setTyping(dialog);\n      } else {\n        this.unsetTyping(dialog);\n      }\n    });\n\n    rootScope.addEventListener('state_cleared', () => {\n      //setTimeout(() => \n      appStateManager.getState().then((state) => {\n        appUsersManager.clear();\n        appChatsManager.clear();\n        \n        const filtersStorage = appMessagesManager.filtersStorage;\n        const filters = filtersStorage.filters;\n        for(const filterId in filters) { // delete filters\n          rootScope.dispatchEvent('updateDialogFilter', {\n            _: 'updateDialogFilter',\n            id: +filterId,\n          });\n        }\n\n        appMessagesManager.clear();\n\n        /* const clearPromises: Promise<any>[] = [];\n        for(const name in appStateManager.storagesResults) {\n          const results = appStateManager.storagesResults[name as keyof AppStateManager['storages']];\n          const storage = appStateManager.storages[name as keyof AppStateManager['storages']];\n          results.length = 0;\n          clearPromises.push(storage.clear());\n        } */\n\n        this.validateForFilter();\n\n        this.onStateLoaded(state);\n      })//, 5000);\n    });\n\n    const foldersScrollable = new ScrollableX(this.folders.menuScrollContainer);\n    bottomPart.prepend(this.folders.menuScrollContainer);\n    const selectTab = horizontalMenu(this.folders.menu, this.folders.container, (id, tabContent) => {\n      /* if(id !== 0) {\n        id += 1;\n      } */\n\n      id = +tabContent.dataset.filterId || 0;\n\n      if(this.filterId === id) return;\n\n      this.chatLists[id].innerHTML = '';\n      this.filterId = id;\n      this.onTabChange();\n    }, () => {\n      for(const folderId in this.chatLists) {\n        if(+folderId !== this.filterId) {\n          this.chatLists[folderId].innerHTML = '';\n        }\n      }\n    }, undefined, foldersScrollable);\n\n    //selectTab(0);\n    (this.folders.menu.firstElementChild as HTMLElement).click();\n    appMessagesManager.construct();\n    appStateManager.getState().then((state) => {\n      return this.onStateLoaded(state);\n    }).then(() => {\n      //return;\n      \n      const isLoadedMain = appMessagesManager.dialogsStorage.isDialogsLoaded(0);\n      const isLoadedArchive = appMessagesManager.dialogsStorage.isDialogsLoaded(1);\n      const wasLoaded = isLoadedMain || isLoadedArchive;\n      const a: Promise<any> = isLoadedMain ? Promise.resolve() : appMessagesManager.getConversationsAll('', 0);\n      const b: Promise<any> = isLoadedArchive ? Promise.resolve() : appMessagesManager.getConversationsAll('', 1);\n      a.finally(() => {\n        b.then(() => {\n          this.accumulateArchivedUnread();\n\n          if(wasLoaded) {\n            (apiUpdatesManager.updatesState.syncLoading || Promise.resolve()).then(() => {\n              appMessagesManager.refreshConversations();\n            });\n          }\n        });\n      });\n    });\n\n    new ConnectionStatusComponent(this.chatsContainer);\n    this.chatsContainer.append(bottomPart);\n\n    setTimeout(() => {\n      lottieLoader.loadLottieWorkers();\n    }, 200);\n  }\n\n  private async onStateLoaded(state: State) {\n    appNotificationsManager.getNotifyPeerTypeSettings();\n      \n    const renderFiltersPromise = appMessagesManager.filtersStorage.getDialogFilters().then((filters) => {\n      for(const filter of filters) {\n        this.addFilter(filter);\n      }\n    });\n\n    if(state.filters && Object.keys(state.filters).length) {\n      await renderFiltersPromise;\n      if(this.showFiltersPromise) {\n        await this.showFiltersPromise;\n      }\n    }\n\n    if(appStateManager.storagesResults.dialogs.length) {\n      appDraftsManager.addMissedDialogs();\n    }\n\n    return this.loadDialogs();\n  }\n\n  /* private getOffset(side: 'top' | 'bottom'): {index: number, pos: number} {\n    if(!this.scroll.loadedAll[side]) {\n      const element = (side === 'top' ? this.chatList.firstElementChild : this.chatList.lastElementChild) as HTMLElement;\n      if(element) {\n        const peerId = +element.dataset.peerId;\n        const dialog = appMessagesManager.getDialogByPeerId(peerId);\n        return {index: dialog[0].index, pos: dialog[1]};\n      }\n    }\n\n    return {index: 0, pos: -1};\n  } */\n  private getOffsetIndex(side: 'top' | 'bottom') {\n    return {index: this.scroll.loadedAll[side] ? 0 : this.offsets[side]};\n  }\n\n  private isDialogMustBeInViewport(dialog: Dialog) {\n    if(dialog.migratedTo !== undefined) return false;\n    //return true;\n    const topOffset = this.getOffsetIndex('top');\n    const bottomOffset = this.getOffsetIndex('bottom');\n    \n    if(!topOffset.index && !bottomOffset.index) {\n      return true;\n    }\n    \n    const index = dialog.index;\n    return (!topOffset.index || index <= topOffset.index) && (!bottomOffset.index || index >= bottomOffset.index);\n  }\n\n  private deleteDialog(peerId: number) {\n    const dom = this.getDialogDom(peerId);\n    if(dom) {\n      dom.listEl.remove();\n      delete this.doms[peerId];\n\n      this.onListLengthChange();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private updateDialog(dialog: Dialog) {\n    if(!dialog) {\n      return;\n    }\n\n    if(this.isDialogMustBeInViewport(dialog)) {\n      if(!this.doms.hasOwnProperty(dialog.peerId)) {\n        const ret = this.addDialogNew({dialog});\n        if(ret) {\n          const idx = appMessagesManager.getDialogByPeerId(dialog.peerId)[1];\n          positionElementByIndex(ret.dom.listEl, this.chatList, idx);\n          this.onListLengthChange();\n        } else {\n          return;\n        }\n      }\n    } else {\n      this.deleteDialog(dialog.peerId);\n      return;\n    }\n\n    /* const topOffset = this.getOffset('top');\n    if(topOffset.index && dialog.index > topOffset.index) {\n      const dom = this.getDialogDom(dialog.peerId);\n      if(dom) {\n        dom.listEl.remove();\n        delete this.doms[dialog.peerId];\n      }\n\n      return;\n    }\n\n    if(!this.doms.hasOwnProperty(dialog.peerId)) {\n      this.addDialogNew({dialog});\n    } */\n\n    if(this.getDialogDom(dialog.peerId)) {\n      this.setLastMessage(dialog);\n      this.reorderDialogs();\n    }\n  }\n\n  public onTabChange = () => {\n    this.doms = {};\n    this.scroll = this.scrollables[this.filterId];\n    this.scroll.loadedAll.top = true;\n    this.scroll.loadedAll.bottom = false;\n    this.offsets.top = this.offsets.bottom = 0;\n    this.loadDialogsPromise = undefined;\n    this.chatList = this.chatLists[this.filterId];\n    this.loadDialogs();\n  };\n\n  private setFilterUnreadCount(filterId: number, folder?: Dialog[]) {\n    const unreadSpan = filterId === 0 ? this.allUnreadCount : this.filtersRendered[filterId]?.unread;\n    if(!unreadSpan) {\n      return;\n    }\n\n    folder = folder || appMessagesManager.dialogsStorage.getFolder(filterId);\n    let mutedCount = 0;\n    let notMutedCount = 0;\n    folder.forEach(dialog => {\n      const isMuted = appNotificationsManager.isPeerLocalMuted(dialog.peerId, true);\n\n      if(isMuted && filterId === 0) {\n        return;\n      }\n\n      const value = +!!dialog.unread_count || +dialog.pFlags.unread_mark || 0; // * unread_mark can be undefined\n      if(isMuted) mutedCount += value;\n      else notMutedCount += value;\n    });\n    \n    unreadSpan.classList.toggle('badge-gray', mutedCount && !notMutedCount);\n    \n    const sum = mutedCount + notMutedCount;\n    unreadSpan.innerText = sum ? '' + sum : '';\n  }\n\n  private setFiltersUnreadCount() {\n    for(const filterId in this.filtersRendered) {\n      this.setFilterUnreadCount(+filterId);\n    }\n\n    this.setFilterUnreadCount(0);\n  }\n\n  /**\n   * \u0423\u0434\u0430\u043b\u0438\u0442 \u043d\u0435\u043f\u043e\u0434\u0445\u043e\u0434\u044f\u0449\u0438\u0435 \u0447\u0430\u0442\u044b \u0438\u0437 \u0441\u043f\u0438\u0441\u043a\u0430, \u043d\u043e \u043d\u0435 \u0434\u043e\u0431\u0430\u0432\u0438\u0442 \u0438\u0445(!)\n   */\n  private validateForFilter() {\n    // !WARNING, \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u044d\u0442\u043e \u0431\u044b\u043b\u043e \u0437\u0430\u0447\u0435\u043c-\u0442\u043e, \u043d\u043e \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0439 \u0438\u0441\u043f\u0440\u0430\u0432\u0438\u043b \u0430\u0440\u0445\u0438\u0432\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435\n    //if(this.filterId === 0) return;\n\n    const folder = appMessagesManager.dialogsStorage.getFolder(this.filterId);\n    for(const _peerId in this.doms) {\n      const peerId = +_peerId;\n\n      // \u0435\u0441\u043b\u0438 \u0431\u043e\u043b\u044c\u0448\u0435 \u043d\u0435 \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442 \u043f\u043e \u0444\u0438\u043b\u044c\u0442\u0440\u0443, \u0443\u0434\u0430\u043b\u044f\u0435\u043c\n      if(folder.findIndex((dialog) => dialog.peerId === peerId) === -1) {\n        this.deleteDialog(peerId);\n      }\n    }\n  }\n\n  public generateScrollable(list: HTMLUListElement, filterId: number) {\n    const scrollable = new Scrollable(null, 'CL', 500);\n    scrollable.container.addEventListener('scroll', this.onChatsRegularScroll);\n    scrollable.container.dataset.filterId = '' + filterId;\n    scrollable.container.append(list);\n    scrollable.onScrolledTop = this.onChatsScrollTop;\n    scrollable.onScrolledBottom = this.onChatsScroll;\n    scrollable.setVirtualContainer(list);\n\n    this.chatLists[filterId] = list;\n    this.scrollables[filterId] = scrollable;\n\n    return scrollable;\n  }\n\n  private addFilter(filter: Pick<DialogFilter, 'title' | 'id' | 'orderIndex'> & Partial<{titleEl: HTMLElement}>) {\n    if(this.filtersRendered[filter.id]) return;\n\n    const menuTab = document.createElement('div');\n    menuTab.classList.add('menu-horizontal-div-item');\n    const span = document.createElement('span');\n    const titleSpan = document.createElement('span');\n    titleSpan.classList.add('text-super');\n    if(filter.titleEl) titleSpan.append(filter.titleEl);\n    else titleSpan.innerHTML = RichTextProcessor.wrapEmojiText(filter.title);\n    const unreadSpan = document.createElement('div');\n    unreadSpan.classList.add('badge', 'badge-20', 'badge-primary');\n    const i = document.createElement('i');\n    span.append(titleSpan, unreadSpan, i);\n    menuTab.append(span);\n    ripple(menuTab);\n\n    const containerToAppend = this.folders.menu as HTMLElement;\n    positionElementByIndex(menuTab, containerToAppend, filter.orderIndex);\n    //containerToAppend.append(li);\n\n    const ul = this.createChatList();\n    const scrollable = this.generateScrollable(ul, filter.id);\n    const div = scrollable.container;\n    //this.folders.container.append(div);\n    positionElementByIndex(scrollable.container, this.folders.container, filter.orderIndex);\n\n    this.setListClickListener(ul, null, true);\n\n    this.filtersRendered[filter.id] = {\n      menu: menuTab,\n      container: div,\n      unread: unreadSpan,\n      title: titleSpan\n    };\n\n    if(!this.showFiltersPromise && Object.keys(this.filtersRendered).length > 1) {\n      this.showFiltersPromise = new Promise<void>((resolve) => {\n        window.setTimeout(() => {\n          this.showFiltersPromise = undefined;\n          if(Object.keys(this.filtersRendered).length > 1) {\n            this.folders.menuScrollContainer.classList.remove('hide');\n            this.setFiltersUnreadCount();\n          }\n          resolve();\n        }, 0);\n      });\n    }\n  }\n\n  private loadDialogs(side: SliceSides = 'bottom') {\n    /* if(testScroll) {\n      return;\n    } */\n    \n    if(this.loadDialogsPromise/*  || 1 === 1 */) return this.loadDialogsPromise;\n\n    const promise = new Promise<void>(async(resolve) => {\n      if(!this.chatList.childElementCount) {\n        const container = this.chatList.parentElement;\n        container.append(this.chatsPreloader);\n      }\n  \n      //return;\n  \n      const filterId = this.filterId;\n      let loadCount = 30/*this.chatsLoadCount */;\n      let offsetIndex = 0;\n      \n      const {index: currentOffsetIndex} = this.getOffsetIndex(side);\n      if(currentOffsetIndex) {\n        if(side === 'top') {\n          const storage = appMessagesManager.dialogsStorage.getFolder(filterId);\n          const index = storage.findIndex(dialog => dialog.index <= currentOffsetIndex);\n          const needIndex = Math.max(0, index - loadCount);\n          loadCount = index - needIndex;\n          offsetIndex = storage[needIndex].index + 1;\n        } else {\n          offsetIndex = currentOffsetIndex;\n        }\n      }\n      \n      //let offset = storage[storage.length - 1]?.index || 0;\n  \n      try {\n        //console.time('getDialogs time');\n  \n        const getConversationPromise = (this.filterId > 1 ? appUsersManager.getContacts() as Promise<any> : Promise.resolve()).then(() => {\n          return appMessagesManager.getConversations('', offsetIndex, loadCount, filterId);\n        });\n  \n        const result = await getConversationPromise;\n  \n        if(this.loadDialogsPromise !== promise) {\n          return;\n        }\n  \n        //console.timeEnd('getDialogs time');\n  \n        // * loaded all\n        //if(!result.dialogs.length || this.chatList.childElementCount === result.count) {\n        // !result.dialogs.length \u043d\u0435 \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442, \u0442\u0430\u043a \u043a\u0430\u043a \u043f\u0440\u0438 \u0441\u0443\u043f\u0435\u0440\u0434\u0440\u0435\u0432\u043d\u043e\u043c \u0434\u0438\u0430\u043b\u043e\u0433\u0435 getConversations \u0435\u0433\u043e \u043d\u0435 \u0432\u044b\u0434\u0430\u0441\u0442.\n        //if(this.chatList.childElementCount === result.count) {\n        if(side === 'bottom') {\n          if(result.isEnd) {\n            this.scroll.loadedAll[side] = true;\n          }\n        } else {\n          const storage = appMessagesManager.dialogsStorage.getFolder(filterId);\n          if(!result.dialogs.length || (storage.length && storage[0].index < offsetIndex)) {\n            this.scroll.loadedAll[side] = true;\n          }\n        }\n        \n        if(result.dialogs.length) {\n          const dialogs = side === 'top' ? result.dialogs.slice().reverse() : result.dialogs;\n  \n          dialogs.forEach((dialog) => {\n            this.addDialogNew({\n              dialog,\n              append: side === 'bottom'\n            });\n          });\n        }\n\n        const offsetDialog = result.dialogs[side === 'top' ? 0 : result.dialogs.length - 1];\n        if(offsetDialog) {\n          this.offsets[side] = offsetDialog.index;\n        }\n\n        this.onListLengthChange();\n  \n        this.log.debug('getDialogs ' + loadCount + ' dialogs by offset:', offsetIndex, result, this.chatList.childElementCount);\n  \n        setTimeout(() => {\n          this.scroll.onScroll();\n        }, 0);\n      } catch(err) {\n        this.log.error(err);\n      }\n      \n      this.chatsPreloader.remove();\n      resolve();\n    }).finally(() => {\n      this.loadDialogsPromise = undefined;\n    });\n\n    return this.loadDialogsPromise = promise;\n  }\n\n  private generateEmptyPlaceholder(options: {\n    title: LangPackKey,\n    subtitle?: LangPackKey,\n    subtitleArgs?: FormatterArguments,\n    classNameType: string\n  }) {\n    const BASE_CLASS = 'empty-placeholder';\n    const container = document.createElement('div');\n    container.classList.add(BASE_CLASS, BASE_CLASS + '-' + options.classNameType);\n    \n    const header = document.createElement('div');\n    header.classList.add(BASE_CLASS + '-header');\n    _i18n(header, options.title);\n\n    const subtitle = document.createElement('div');\n    subtitle.classList.add(BASE_CLASS + '-subtitle');\n    if(options.subtitle) {\n      _i18n(subtitle, options.subtitle, options.subtitleArgs);\n    }\n\n    container.append(header, subtitle);\n\n    return {container, header, subtitle};\n  }\n\n  private onListLengthChange = () => {\n    //return;\n    if(this.filterId === 1) {\n      return;\n    }\n\n    let placeholderContainer = (Array.from(this.chatList.parentElement.children) as HTMLElement[]).find(el => el.matches('.empty-placeholder'));\n    const needPlaceholder = this.scroll.loadedAll.bottom && !this.chatList.childElementCount/*  || true */;\n    // this.chatList.style.display = 'none';\n\n    if(needPlaceholder && placeholderContainer) {\n      return;\n    } else if(!needPlaceholder) {\n      if(placeholderContainer) {\n        placeholderContainer.remove();\n      }\n\n      return;\n    }\n\n    let placeholder: ReturnType<AppDialogsManager['generateEmptyPlaceholder']>;\n    if(!this.filterId) {\n      placeholder = this.generateEmptyPlaceholder({\n        title: 'ChatList.Main.EmptyPlaceholder.Title',\n        classNameType: 'dialogs'\n      });\n      \n      placeholderContainer = placeholder.container;\n      \n      const img = document.createElement('img');\n      img.classList.add('empty-placeholder-dialogs-icon');\n      \n      Promise.all([\n        appUsersManager.getContacts().then(users => {\n          let key: LangPackKey, args: FormatterArguments;\n\n          if(users.length) {\n            key = 'ChatList.Main.EmptyPlaceholder.Subtitle';\n            args = [i18n('Contacts.Count', [users.length])];\n          } else {\n            key = 'ChatList.Main.EmptyPlaceholder.SubtitleNoContacts';\n            args = [];\n          }\n\n          const subtitleEl = new I18n.IntlElement({\n            key,\n            args,\n            element: placeholder.subtitle\n          });\n        }),\n        renderImageFromUrlPromise(img, 'assets/img/EmptyChats.svg'),\n        fastRafPromise()\n      ]).then(() => {\n        placeholderContainer.classList.add('visible');\n      });\n\n      placeholderContainer.prepend(img);\n    } else {\n      placeholder = this.generateEmptyPlaceholder({\n        title: 'FilterNoChatsToDisplay',\n        subtitle: 'FilterNoChatsToDisplayInfo',\n        classNameType: 'folder'\n      });\n\n      placeholderContainer = placeholder.container;\n\n      placeholderContainer.prepend(wrapLocalSticker({\n        emoji: '\ud83d\udcc2',\n        width: 128,\n        height: 128\n      }).container)\n\n      const button = Button('btn-primary btn-color-primary btn-control tgico', {\n        text: 'FilterHeaderEdit',\n        icon: 'settings'\n      });\n\n      attachClickEvent(button, () => {\n        new AppEditFolderTab(appSidebarLeft).open(appMessagesManager.filtersStorage.filters[this.filterId]);\n      });\n\n      placeholderContainer.append(button);\n    }\n\n    this.chatList.parentElement.append(placeholderContainer);\n  };\n\n  public onChatsRegularScroll = () => {\n    if(this.sliceTimeout) clearTimeout(this.sliceTimeout);\n    this.sliceTimeout = window.setTimeout(() => {\n      this.sliceTimeout = undefined;\n      \n      if(this.reorderDialogsTimeout) {\n        this.onChatsRegularScroll();\n        return;\n      }\n\n      if(!this.chatList.childElementCount) {\n        return;\n      }\n\n      /* const observer = new IntersectionObserver((entries) => {\n        const \n      });\n\n      Array.from(this.chatList.children).forEach(el => {\n        observer.observe(el);\n      }); */\n\n      const scrollTopWas = this.scroll.scrollTop;\n\n      const firstElementChild = this.chatList.firstElementChild;\n      const rectContainer = this.scroll.container.getBoundingClientRect();\n      const rectTarget = firstElementChild.getBoundingClientRect();\n      const children = Array.from(this.scroll.splitUp.children) as HTMLElement[];\n\n      // const padding = 8;\n      // const offsetTop = this.folders.container.offsetTop;\n      let offsetTop = this.scroll.splitUp.offsetTop;\n      if(offsetTop && scrollTopWas < offsetTop) offsetTop -= scrollTopWas;\n      // const offsetTop = scrollTopWas < padding ? padding - scrollTopWas : 0;\n      const firstY = rectContainer.y + offsetTop;\n      const lastY = rectContainer.y/*  - 8 */; // 8px - .chatlist padding-bottom\n      \n      const firstElement = findUpTag(document.elementFromPoint(Math.ceil(rectTarget.x), Math.ceil(firstY + 1)), firstElementChild.tagName) as HTMLElement;\n      const lastElement = findUpTag(document.elementFromPoint(Math.ceil(rectTarget.x), Math.floor(lastY + rectContainer.height - 1)), firstElementChild.tagName) as HTMLElement;\n\n      //alert('got element:' + rect.y);\n\n      if(!firstElement || !lastElement) {\n        return;\n      }\n\n      //alert('got element:' + !!firstElement);\n\n      const firstElementRect = firstElement.getBoundingClientRect();\n      const elementOverflow = firstElementRect.y - firstY;\n\n      const sliced: HTMLElement[] = [];\n      const firstIndex = children.indexOf(firstElement);\n      const lastIndex = children.indexOf(lastElement);\n\n      const saveLength = 10;\n\n      const sliceFromStart = isSafari ? [] : children.slice(0, Math.max(0, firstIndex - saveLength));\n      const sliceFromEnd = children.slice(lastIndex + saveLength);\n\n      /* if(sliceFromStart.length !== sliceFromEnd.length) {\n        console.log('not equal', sliceFromStart.length, sliceFromEnd.length);\n      }\n\n      if(sliceFromStart.length > sliceFromEnd.length) {\n        const diff = sliceFromStart.length - sliceFromEnd.length;\n        sliceFromStart.splice(0, diff);\n      } else if(sliceFromEnd.length > sliceFromStart.length) {\n        const diff = sliceFromEnd.length - sliceFromStart.length;\n        sliceFromEnd.splice(sliceFromEnd.length - diff, diff);\n      } */\n\n      if(sliceFromStart.length) {\n        this.scroll.loadedAll.top = false;\n      }\n\n      if(sliceFromEnd.length) {\n        this.scroll.loadedAll.bottom = false;\n      }\n\n      sliced.push(...sliceFromStart);\n      sliced.push(...sliceFromEnd);\n\n      sliced.forEach(el => {\n        const peerId = +el.dataset.peerId;\n        this.deleteDialog(peerId);\n      });\n\n      this.setOffsets();\n\n      //this.log('[slicer] elements', firstElement, lastElement, rect, sliced, sliceFromStart.length, sliceFromEnd.length);\n\n      //this.log('[slicer] reset scrollTop', this.scroll.scrollTop, firstElement.offsetTop, firstElementRect.y, rect.y, elementOverflow);\n\n      //alert('left length:' + children.length);\n\n      this.scroll.scrollTop = firstElement.offsetTop - elementOverflow;\n      /* const firstElementRect = firstElement.getBoundingClientRect();\n      const scrollTop =  */\n\n      //this.scroll.scrollIntoView(firstElement, false);\n    }, 200);\n  };\n\n  private setOffsets() {\n    const firstDialog = this.getDialogFromElement(this.chatList.firstElementChild as HTMLElement);\n    const lastDialog = this.getDialogFromElement(this.chatList.lastElementChild as HTMLElement);\n\n    this.offsets.top = firstDialog.index;\n    this.offsets.bottom = lastDialog.index;\n  }\n\n  private getDialogFromElement(element: HTMLElement) {\n    return appMessagesManager.getDialogOnly(+element.dataset.peerId);\n  }\n\n  public onChatsScrollTop = () => {\n    this.onChatsScroll('top');\n  };\n  \n  public onChatsScroll = (side: SliceSides = 'bottom') => {\n    if(this.scroll.loadedAll[side] || this.loadDialogsPromise) return;\n    this.log('onChatsScroll', side);\n    this.loadDialogs(side);\n  };\n\n  public setListClickListener(list: HTMLUListElement, onFound?: () => void, withContext = false, autonomous = false, openInner = false) {\n    let lastActiveListElement: HTMLElement;\n\n    const setPeerFunc = (openInner ? appImManager.setInnerPeer : appImManager.setPeer).bind(appImManager);\n\n    list.dataset.autonomous = '' + +autonomous;\n    list.addEventListener('mousedown', (e) => {\n      if(e.button !== 0) return;\n      //cancelEvent(e);\n\n      this.log('dialogs click list');\n      const target = e.target as HTMLElement;\n      const elem = findUpTag(target, 'LI');\n\n      if(!elem) {\n        return;\n      }\n\n      if(autonomous) {\n        const sameElement = lastActiveListElement === elem;\n        if(lastActiveListElement && !sameElement) {\n          lastActiveListElement.classList.remove('active');\n        }\n\n        if(elem) {\n          elem.classList.add('active');\n          lastActiveListElement = elem;\n          this.lastActiveElements.add(elem);\n        }\n      }\n\n      if(elem) {\n        if(onFound) onFound();\n\n        const peerId = +elem.dataset.peerId;\n        const lastMsgId = +elem.dataset.mid || undefined;\n\n        setPeerFunc(peerId, lastMsgId);\n      } else {\n        setPeerFunc(0);\n      }\n    }, {capture: true});\n\n    if(DEBUG) {\n      list.addEventListener('dblclick', (e) => {\n        const li = findUpTag(e.target, 'LI');\n        if(li) {\n          const peerId = +li.dataset.peerId;\n          this.log('debug dialog:', appMessagesManager.getDialogByPeerId(peerId));\n        }\n      });\n    }\n\n    if(withContext) {\n      attachContextMenuListener(list, this.contextMenu.onContextMenu);\n    }\n  }\n\n  public createChatList(/* options: {\n    avatarSize?: number,\n    handheldsSize?: number,\n    //size?: number,\n  } = {} */) {\n    const list = document.createElement('ul');\n    list.classList.add('chatlist'/* , \n      'chatlist-avatar-' + (options.avatarSize || 54) *//* , 'chatlist-' + (options.size || 72) */);\n\n    /* if(options.handheldsSize) {\n      list.classList.add('chatlist-handhelds-' + options.handheldsSize);\n    } */\n\n    return list;\n  }\n\n  private reorderDialogs() {\n    //const perf = performance.now();\n    if(this.reorderDialogsTimeout) {\n      window.cancelAnimationFrame(this.reorderDialogsTimeout);\n    }\n    \n    this.reorderDialogsTimeout = window.requestAnimationFrame(() => {\n      this.reorderDialogsTimeout = 0;\n      const dialogs = appMessagesManager.dialogsStorage.getFolder(this.filterId);\n\n      const currentOrder = (Array.from(this.chatList.children) as HTMLElement[]).map(el => +el.dataset.peerId);\n\n      const {index} = this.getOffsetIndex('top');\n      const pos = dialogs.findIndex(dialog => dialog.index <= index);\n\n      const offset = Math.max(0, pos);\n      dialogs.forEach((dialog, index) => {\n        const dom = this.getDialogDom(dialog.peerId);\n        if(!dom) {\n          return;\n        }\n  \n        const needIndex = index - offset;\n        if(needIndex > currentOrder.length) {\n          this.deleteDialog(dialog.peerId);\n          return;\n        }\n\n        const peerIdByIndex = currentOrder[needIndex];\n  \n        if(peerIdByIndex !== dialog.peerId) {\n          if(positionElementByIndex(dom.listEl, this.chatList, needIndex)) {\n            this.log.debug('setDialogPosition:', dialog, dom, peerIdByIndex, needIndex);\n          }\n        }\n      });\n  \n      //this.log('Reorder time:', performance.now() - perf);\n    });\n  }\n\n  public setLastMessage(dialog: Dialog, lastMessage?: any, dom?: DialogDom, highlightWord?: string) {\n    ///////console.log('setlastMessage:', lastMessage);\n    if(!dom) {\n      dom = this.getDialogDom(dialog.peerId);\n\n      if(!dom) {\n        //this.log.error('no dom for dialog:', dialog, lastMessage, dom, highlightWord);\n        return;\n      }\n    }\n\n    let draftMessage: MyDraftMessage;\n    if(!lastMessage) {\n      if(dialog.draft && dialog.draft._ === 'draftMessage') {\n        draftMessage = dialog.draft;\n      }\n      \n      lastMessage = appMessagesManager.getMessageByPeer(dialog.peerId, dialog.top_message);\n    }\n\n    if(lastMessage._ === 'messageEmpty'/*  || (lastMessage._ === 'messageService' && !lastMessage.rReply) */) {\n      dom.lastMessageSpan.innerHTML = '';\n      dom.lastTimeSpan.innerHTML = '';\n      delete dom.listEl.dataset.mid;\n      return;\n    }\n\n    let peer = dialog.peer;\n    let peerId = dialog.peerId;\n    //let peerId = appMessagesManager.getMessagePeer(lastMessage);\n\n    //console.log('setting last message:', lastMessage);\n\n    /* if(!dom.lastMessageSpan.classList.contains('user-typing')) */ {\n\n      dom.lastMessageSpan.textContent = '';\n      if(highlightWord && lastMessage.message) {\n        dom.lastMessageSpan.append(appMessagesManager.wrapMessageForReply(lastMessage, undefined, undefined, false, highlightWord));\n      } else if(draftMessage) {\n        dom.lastMessageSpan.append(appMessagesManager.wrapMessageForReply(draftMessage));\n      } else if(!lastMessage.deleted) {\n        dom.lastMessageSpan.append(appMessagesManager.wrapMessageForReply(lastMessage));\n      }\n  \n      /* if(lastMessage.from_id === auth.id) { // You:  */\n      if(draftMessage) {\n        const bold = document.createElement('b');\n        bold.classList.add('danger');\n        bold.append(i18n('Draft'));\n        bold.append(': ');\n        dom.lastMessageSpan.prepend(bold);\n      } else if(peer._ !== 'peerUser' && peerId !== lastMessage.fromId && !lastMessage.action) {\n        const sender = appPeersManager.getPeer(lastMessage.fromId);\n        if(sender && sender.id) {\n          const senderBold = document.createElement('b');\n\n          if(sender.id === rootScope.myId) {\n            senderBold.append(i18n('FromYou'));\n          } else {\n            //str = sender.first_name || sender.last_name || sender.username;\n            senderBold.append(new PeerTitle({\n              peerId: lastMessage.fromId,\n              onlyFirstName: true,\n            }).element);\n          }\n\n          senderBold.append(': ');\n          //console.log(sender, senderBold.innerText);\n          dom.lastMessageSpan.prepend(senderBold);\n        } //////// else console.log('no sender', lastMessage, peerId);\n      }\n    }\n\n    if(!lastMessage.deleted || draftMessage/*  && lastMessage._ !== 'draftMessage' */) {\n      const date = draftMessage ? Math.max(draftMessage.date, lastMessage.date || 0) : lastMessage.date;\n      dom.lastTimeSpan.textContent = '';\n      dom.lastTimeSpan.append(formatDateAccordingToTodayNew(new Date(date * 1000)));\n    } else dom.lastTimeSpan.textContent = '';\n\n    if(this.doms[peerId] === dom) {\n      this.setUnreadMessages(dialog);\n    } else { // means search\n      dom.listEl.dataset.mid = lastMessage.mid;\n    }\n  }\n\n  private setUnreadMessages(dialog: Dialog) {\n    const dom = this.getDialogDom(dialog.peerId);\n\n    if(dialog.folder_id === 1) {\n      this.accumulateArchivedUnread();\n    }\n\n    if(!dom) {\n      //this.log.error('setUnreadMessages no dom!', dialog);\n      return;\n    }\n\n    const isMuted = appNotificationsManager.isPeerLocalMuted(dialog.peerId, true);\n    const wasMuted = dom.listEl.classList.contains('is-muted');\n    if(isMuted !== wasMuted) {\n      SetTransition(dom.listEl, 'is-muted', isMuted, 200);\n    }\n\n    const lastMessage = dialog.draft && dialog.draft._ === 'draftMessage' ? \n      dialog.draft : \n      appMessagesManager.getMessageByPeer(dialog.peerId, dialog.top_message);\n    if(lastMessage._ !== 'messageEmpty' && !lastMessage.deleted && \n      lastMessage.pFlags.out && lastMessage.peerId !== rootScope.myId/*  && \n      dialog.read_outbox_max_id */) { // maybe comment, 06.20.2020\n      const outgoing = (lastMessage.pFlags && lastMessage.pFlags.unread)\n        /*  && dialog.read_outbox_max_id !== 0 */; // maybe uncomment, 31.01.2020\n    \n      //console.log('outgoing', outgoing, lastMessage);\n  \n      if(outgoing) {\n        dom.statusSpan.classList.remove('tgico-checks');\n        dom.statusSpan.classList.add('tgico-check');\n      } else {\n        dom.statusSpan.classList.remove('tgico-check');\n        dom.statusSpan.classList.add('tgico-checks');\n      }\n    } else dom.statusSpan.classList.remove('tgico-check', 'tgico-checks');\n\n    dom.unreadMessagesSpan.innerText = '';\n\n    const filter = appMessagesManager.filtersStorage.filters[this.filterId];\n    let isPinned: boolean;\n    if(filter) {\n      isPinned = filter.pinned_peers.findIndex(peerId => peerId === dialog.peerId) !== -1;\n    } else {\n      isPinned = !!dialog.pFlags.pinned;\n    }\n\n    if(isPinned) {\n      dom.unreadMessagesSpan.classList.add('tgico-chatspinned', 'tgico');\n    } else {\n      dom.unreadMessagesSpan.classList.remove('tgico-chatspinned', 'tgico');\n    }\n\n    if(dialog.unread_count || dialog.pFlags.unread_mark) {\n      //dom.unreadMessagesSpan.innerText = '' + (dialog.unread_count ? formatNumber(dialog.unread_count, 1) : ' ');\n      dom.unreadMessagesSpan.innerText = '' + (dialog.unread_count || ' ');\n      dom.unreadMessagesSpan.classList.add('unread');\n    } else {\n      dom.unreadMessagesSpan.classList.remove('unread');\n    }\n  }\n\n  private accumulateArchivedUnread() {\n    if(this.accumulateArchivedTimeout) return;\n    this.accumulateArchivedTimeout = window.setTimeout(() => {\n      this.accumulateArchivedTimeout = 0;\n      const dialogs = appMessagesManager.dialogsStorage.getFolder(1);\n      const sum = dialogs.reduce((acc, dialog) => acc + dialog.unread_count, 0);\n      rootScope.dispatchEvent('dialogs_archived_unread', {count: sum});\n    }, 0);\n  }\n\n  private getDialogDom(peerId: number) {\n    return this.doms[peerId];\n  }\n\n  public addDialogNew(options: {\n    dialog: Dialog | number,\n    container?: HTMLUListElement | Scrollable | false,\n    drawStatus?: boolean,\n    rippleEnabled?: boolean,\n    onlyFirstName?: boolean,\n    meAsSaved?: boolean,\n    append?: boolean,\n    avatarSize?: number,\n    autonomous?: boolean,\n    lazyLoadQueue?: LazyLoadQueueIntersector,\n  }) {\n    return this.addDialog(options.dialog, options.container, options.drawStatus, options.rippleEnabled, options.onlyFirstName, options.meAsSaved, options.append, options.avatarSize, options.autonomous, options.lazyLoadQueue);\n  }\n\n  public addDialog(_dialog: Dialog | number, container?: HTMLUListElement | Scrollable | false, drawStatus = true, rippleEnabled = true, onlyFirstName = false, meAsSaved = true, append = true, avatarSize = 54, autonomous = !!container, lazyLoadQueue?: LazyLoadQueueIntersector) {\n    let dialog: Dialog;\n    \n    if(typeof(_dialog) === 'number') {\n      let originalDialog = appMessagesManager.getDialogOnly(_dialog);\n      if(!originalDialog) {\n        originalDialog = {\n          peerId: _dialog,\n          peer: appPeersManager.getOutputPeer(_dialog),\n          pFlags: {}\n        } as any;\n      }\n\n      dialog = originalDialog;\n    } else {\n      dialog = _dialog;\n    }\n\n    const peerId: number = dialog.peerId;\n\n    if(container === undefined) {\n      if(this.doms[peerId] || dialog.migratedTo !== undefined) return;\n\n      const filter = appMessagesManager.filtersStorage.filters[this.filterId];\n      if((filter && !appMessagesManager.filtersStorage.testDialogForFilter(dialog, filter)) || (!filter && this.filterId !== dialog.folder_id)) {\n        return;\n      }\n    }\n\n    const avatarEl = new AvatarElement();\n    avatarEl.lazyLoadQueue = lazyLoadQueue;\n    avatarEl.setAttribute('dialog', meAsSaved ? '1' : '0');\n    avatarEl.setAttribute('peer', '' + peerId);\n    avatarEl.classList.add('dialog-avatar', 'avatar-' + avatarSize);\n\n    if(drawStatus && peerId !== rootScope.myId && dialog.peer) {\n      const peer = dialog.peer;\n      \n      switch(peer._) {\n        case 'peerUser':\n          const user = appUsersManager.getUser(peerId);\n          //console.log('found user', user);\n  \n          if(user.status && user.status._ === 'userStatusOnline') {\n            avatarEl.classList.add('is-online');\n          }\n  \n          break;\n        default:\n          break;\n      }\n    }\n\n    const captionDiv = document.createElement('div');\n    captionDiv.classList.add('user-caption');\n\n    const titleSpanContainer = document.createElement('span');\n    titleSpanContainer.classList.add('user-title');\n\n    const peerTitle = new PeerTitle({\n      peerId,\n      dialog: meAsSaved,\n      onlyFirstName,\n      plainText: false\n    });\n\n    titleSpanContainer.append(peerTitle.element);\n    //p.classList.add('')\n\n    // \u0432 \u0434\u0440\u0443\u0433\u0438\u0445 \u0441\u043b\u0443\u0447\u0430\u044f\u0445 \u0438\u043a\u043e\u043d\u043a\u0430 \u0432\u0435\u0440\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 \u043d\u0435 \u043d\u0443\u0436\u043d\u0430 (\u0430 \u043f\u0435\u0440\u0432\u044b\u0439 - \u044d\u0442\u043e \u0433\u043b\u0430\u0432\u043d\u044b\u0435 \u0447\u0430\u0442\u043b\u0438\u0441\u0442\u044b)\n    //if(!container) {\n      const peer = appPeersManager.getPeer(peerId);\n\n      // for muted icon\n      titleSpanContainer.classList.add('tgico'); // * \u044d\u0442\u0430 \u0441\u0442\u0440\u043e\u043a\u0430 \u0431\u0443\u0434\u0435\u0442 \u0430\u043a\u0442\u0443\u0430\u043b\u044c\u043d\u0430 \u0442\u043e\u043b\u044c\u043a\u043e \u0434\u043b\u044f !container, \u043d\u043e \u043b\u0430\u0434\u043d\u043e\n\n      if(peer?.pFlags?.verified) {\n        titleSpanContainer.classList.add('is-verified');\n        titleSpanContainer.append(generateVerifiedIcon());\n      }\n    //}\n    \n    const span = document.createElement('span');\n    span.classList.add('user-last-message');\n    span.setAttribute('dir', 'auto');\n\n    //captionDiv.append(titleSpan);\n    //captionDiv.append(span);\n\n    const li = document.createElement('li');\n    if(rippleEnabled) {\n      ripple(li);\n    }\n\n    li.append(avatarEl, captionDiv);\n    li.dataset.peerId = '' + peerId;\n\n    const statusSpan = document.createElement('span');\n    statusSpan.classList.add('message-status');\n\n    const lastTimeSpan = document.createElement('span');\n    lastTimeSpan.classList.add('message-time');\n\n    const unreadMessagesSpan = document.createElement('div');\n    unreadMessagesSpan.className = 'dialog-subtitle-badge badge badge-24';\n\n    const titleP = document.createElement('p');\n    titleP.classList.add('dialog-title');\n\n    const rightSpan = document.createElement('span');\n    rightSpan.classList.add('dialog-title-details');\n    rightSpan.append(statusSpan, lastTimeSpan);\n    titleP.append(titleSpanContainer, rightSpan);\n\n    const messageP = document.createElement('p');\n    messageP.classList.add('dialog-subtitle');\n    messageP.append(span, unreadMessagesSpan);\n\n    captionDiv.append(titleP, messageP);\n\n    const dom: DialogDom = {\n      avatarEl,\n      captionDiv,\n      titleSpan: peerTitle.element,\n      titleSpanContainer,\n      statusSpan,\n      lastTimeSpan,\n      unreadMessagesSpan,\n      lastMessageSpan: span,\n      containerEl: li,\n      listEl: li\n    };\n\n    /* let good = false;\n    for(const folderId in this.chatLists) {\n      if(this.chatLists[folderId] === container) {\n        good = true;\n      }\n    } */\n    const method: 'append' | 'prepend' = append ? 'append' : 'prepend';\n    if(container === undefined/*  || good */) {\n      this.scroll[method](li);\n\n      this.doms[dialog.peerId] = dom;\n\n      /* if(container) {\n        container.append(li);\n      } */\n\n      const isMuted = appNotificationsManager.isPeerLocalMuted(dialog.peerId, true);\n      if(isMuted) {\n        li.classList.add('is-muted');\n      }\n\n      this.setLastMessage(dialog);\n    } else if(container) {\n      container[method](li);\n    }\n\n    if(!autonomous && appImManager.chat?.peerId === peerId) {\n      li.classList.add('active');\n      this.lastActiveElements.add(li);\n    } \n    \n    return {dom, dialog};\n  }\n\n  public setTyping(dialog: Dialog) {\n    const dom = this.getDialogDom(dialog.peerId);\n    if(!dom) {\n      return;\n    }\n\n    let typingElement = dom.lastMessageSpan.querySelector('.peer-typing-container') as HTMLElement;\n    if(typingElement) {\n      appImManager.getPeerTyping(dialog.peerId, typingElement);\n    } else {\n      typingElement = appImManager.getPeerTyping(dialog.peerId);\n      replaceContent(dom.lastMessageSpan, typingElement);\n      dom.lastMessageSpan.classList.add('user-typing');\n    }\n  }\n\n  public unsetTyping(dialog: Dialog) {\n    const dom = this.getDialogDom(dialog.peerId);\n    if(!dom) {\n      return;\n    }\n\n    dom.lastMessageSpan.classList.remove('user-typing');\n    this.setLastMessage(dialog, null, dom);\n  }\n}\n\nexport function generateVerifiedIcon() {\n  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n  svg.setAttributeNS(null, 'viewBox', '0 0 24 24');\n  svg.setAttributeNS(null, 'width', '24');\n  svg.setAttributeNS(null, 'height', '24');\n  svg.classList.add('verified-icon');\n\n  const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');\n  use.setAttributeNS(null, 'href', '#verified-background');\n  use.classList.add('verified-background');\n\n  const use2 = document.createElementNS('http://www.w3.org/2000/svg', 'use');\n  use2.setAttributeNS(null, 'href', '#verified-check');\n  use2.classList.add('verified-check');\n\n  svg.append(use, use2);\n\n  return svg;\n}\n\nconst appDialogsManager = new AppDialogsManager();\nMOUNT_CLASS_TO.appDialogsManager = appDialogsManager;\nexport default appDialogsManager;\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport { FileURLType, getFileNameByLocation, getFileURL } from '../../helpers/fileName';\nimport { safeReplaceArrayInObject, defineNotNumerableProperties, isObject } from '../../helpers/object';\nimport { Document, InputFileLocation, PhotoSize } from '../../layer';\nimport referenceDatabase, { ReferenceContext } from '../mtproto/referenceDatabase';\nimport opusDecodeController from '../opusDecodeController';\nimport { RichTextProcessor } from '../richtextprocessor';\nimport webpWorkerController from '../webp/webpWorkerController';\nimport appDownloadManager, { DownloadBlob } from './appDownloadManager';\nimport appPhotosManager from './appPhotosManager';\nimport blur from '../../helpers/blur';\nimport apiManager from '../mtproto/mtprotoworker';\nimport { MOUNT_CLASS_TO } from '../../config/debug';\nimport { getFullDate } from '../../helpers/date';\n\nexport type MyDocument = Document.document;\n\n// TODO: \u0435\u0441\u043b\u0438 \u0437\u0430\u043b\u0438\u0442\u044c \u043a\u0430\u0440\u0442\u0438\u043d\u043a\u0443 \u0444\u0430\u0439\u043b\u043e\u043c, \u0430 \u043f\u043e\u0442\u043e\u043c \u043f\u0435\u0440\u0435\u0437\u0430\u0439\u0442\u0438 \u0432 \u0434\u0438\u0430\u043b\u043e\u0433 - \u043f\u0440\u0435\u0432\u044c\u044e\u0448\u043a\u0430 \u0437\u0430\u043d\u043e\u0432\u043e \u0441\u043a\u0430\u0447\u0430\u0435\u0442\u0441\u044f\n\nexport class AppDocsManager {\n  private docs: {[docId: string]: MyDocument} = {};\n  private savingLottiePreview: {[docId: string]: true} = {};\n\n  constructor() {\n    apiManager.onServiceWorkerFail = this.onServiceWorkerFail;\n  }\n\n  public onServiceWorkerFail = () => {\n    for(const id in this.docs) {\n      const doc = this.docs[id];\n\n      if(doc.supportsStreaming) {\n        delete doc.supportsStreaming;\n        const cacheContext = appDownloadManager.getCacheContext(doc);\n        delete cacheContext.url;\n      }\n    }\n  };\n\n  public saveDoc(doc: Document, context?: ReferenceContext): MyDocument {\n    if(doc._ === 'documentEmpty') {\n      return undefined;\n    }\n\n    const oldDoc = this.docs[doc.id];\n\n    if(doc.file_reference) { // * because we can have a new object w/o the file_reference while sending\n      safeReplaceArrayInObject('file_reference', oldDoc, doc);\n      referenceDatabase.saveContext(doc.file_reference, context);\n    }\n    \n    //console.log('saveDoc', apiDoc, this.docs[apiDoc.id]);\n    // if(oldDoc) {\n    //   //if(doc._ !== 'documentEmpty' && doc._ === d._) {\n    //     if(doc.thumbs) {\n    //       if(!oldDoc.thumbs) oldDoc.thumbs = doc.thumbs;\n    //       /* else if(apiDoc.thumbs[0].bytes && !d.thumbs[0].bytes) {\n    //         d.thumbs.unshift(apiDoc.thumbs[0]);\n    //       } else if(d.thumbs[0].url) { // fix for converted thumb in safari\n    //         apiDoc.thumbs[0] = d.thumbs[0];\n    //       } */\n    //     }\n\n    //   //}\n\n    //   return oldDoc;\n\n    //   //return Object.assign(d, apiDoc, context);\n    //   //return context ? Object.assign(d, context) : d;\n    // }\n\n    if(!oldDoc) {\n      this.docs[doc.id] = doc;\n    }\n\n    // * exclude from state\n    // defineNotNumerableProperties(doc, [/* 'thumbs',  */'type', 'h', 'w', 'file_name', \n    // 'file', 'duration', 'downloaded', 'url', 'audioTitle', \n    // 'audioPerformer', 'sticker', 'stickerEmoji', 'stickerEmojiRaw', \n    // 'stickerSetInput', 'stickerThumbConverted', 'animated', 'supportsStreaming']);\n\n    doc.attributes.forEach(attribute => {\n      switch(attribute._) {\n        case 'documentAttributeFilename':\n          doc.file_name = RichTextProcessor.wrapPlainText(attribute.file_name);\n          break;\n\n        case 'documentAttributeAudio':\n          doc.duration = attribute.duration;\n          doc.audioTitle = attribute.title;\n          doc.audioPerformer = attribute.performer;\n          doc.type = attribute.pFlags.voice && doc.mime_type === 'audio/ogg' ? 'voice' : 'audio';\n          /* if(apiDoc.type === 'audio') {\n            apiDoc.supportsStreaming = true;\n          } */\n          break;\n\n        case 'documentAttributeVideo':\n          doc.duration = attribute.duration;\n          doc.w = attribute.w;\n          doc.h = attribute.h;\n          //apiDoc.supportsStreaming = attribute.pFlags?.supports_streaming/*  && apiDoc.size > 524288 */;\n          if(/* apiDoc.thumbs &&  */attribute.pFlags.round_message) {\n            doc.type = 'round';\n          } else /* if(apiDoc.thumbs) */ {\n            doc.type = 'video';\n          }\n          break;\n\n        case 'documentAttributeSticker':\n          if(attribute.alt !== undefined) {\n            doc.stickerEmojiRaw = attribute.alt;\n            doc.stickerEmoji = RichTextProcessor.wrapRichText(doc.stickerEmojiRaw, {noLinks: true, noLinebreaks: true});\n          }\n\n          if(attribute.stickerset) {\n            if(attribute.stickerset._ === 'inputStickerSetEmpty') {\n              delete attribute.stickerset;\n            } else if(attribute.stickerset._ === 'inputStickerSetID') {\n              doc.stickerSetInput = attribute.stickerset;\n            }\n          }\n\n          // * there can be no thumbs, then it is a document\n          if(/* apiDoc.thumbs &&  */doc.mime_type === 'image/webp' && (doc.thumbs || webpWorkerController.isWebpSupported())) {\n            doc.type = 'sticker';\n            doc.sticker = 1;\n          }\n          break;\n\n        case 'documentAttributeImageSize':\n          doc.type = 'photo';\n          doc.w = attribute.w;\n          doc.h = attribute.h;\n          break;\n\n        case 'documentAttributeAnimated':\n          if((doc.mime_type === 'image/gif' || doc.mime_type === 'video/mp4')/*  && apiDoc.thumbs */) {\n            doc.type = 'gif';\n          }\n\n          doc.animated = true;\n          break;\n      }\n    });\n    \n    if(!doc.mime_type) {\n      switch(doc.type) {\n        case 'gif':\n        case 'video':\n        case 'round':\n          doc.mime_type = 'video/mp4';\n          break;\n        case 'sticker':\n          doc.mime_type = 'image/webp';\n          break;\n        case 'audio':\n          doc.mime_type = 'audio/mpeg';\n          break;\n        case 'voice':\n          doc.mime_type = 'audio/ogg';\n          break;\n        default:\n          doc.mime_type = 'application/octet-stream';\n          break;\n      }\n    }\n\n    if(doc.mime_type === 'application/pdf') {\n      doc.type = 'pdf';\n    }\n\n    if(doc.type === 'voice' || doc.type === 'round') {\n      // browser will identify extension\n      doc.file_name = doc.type + '_' + getFullDate(new Date(doc.date * 1000), {monthAsNumber: true, leadingZero: true}).replace(/[:\\.]/g, '-').replace(', ', '_');\n    }\n\n    if(apiManager.isServiceWorkerOnline()) {\n      if((doc.type === 'gif' && doc.size > 8e6) || doc.type === 'audio' || doc.type === 'video') {\n        doc.supportsStreaming = true;\n        \n        const cacheContext = appDownloadManager.getCacheContext(doc);\n        if(!cacheContext.url) {\n          cacheContext.url = this.getFileURL(doc);\n        }\n      }\n    }\n\n    // for testing purposes\n    // doc.supportsStreaming = false;\n    // doc.url = ''; // * this will break upload urls\n    \n    if(!doc.file_name) {\n      doc.file_name = '';\n    }\n\n    if(doc.mime_type === 'application/x-tgsticker' && doc.file_name === 'AnimatedSticker.tgs') {\n      doc.type = 'sticker';\n      doc.animated = true;\n      doc.sticker = 2;\n    }\n\n    /* if(!doc.url) {\n      doc.url = this.getFileURL(doc);\n    } */\n\n    if(oldDoc) {\n      return Object.assign(oldDoc, doc);\n    }\n\n    return doc;\n  }\n  \n  public getDoc(docId: string | MyDocument): MyDocument {\n    return isObject(docId) && typeof(docId) !== 'string' ? docId as any : this.docs[docId as string] as any;\n  }\n\n  public getMediaInput(doc: MyDocument) {\n    return {\n      _: 'inputMediaDocument',\n      id: {\n        _: 'inputDocument',\n        id: doc.id,\n        access_hash: doc.access_hash,\n        file_reference: doc.file_reference\n      },\n      ttl_seconds: 0\n    };\n  }\n\n  public getInput(doc: MyDocument, thumbSize?: string): InputFileLocation.inputDocumentFileLocation {\n    return {\n      _: 'inputDocumentFileLocation',\n      id: doc.id,\n      access_hash: doc.access_hash,\n      file_reference: doc.file_reference,\n      thumb_size: thumbSize\n    };\n  }\n\n  public getFileDownloadOptions(doc: MyDocument, thumb?: PhotoSize.photoSize, queueId?: number, onlyCache?: boolean) {\n    const inputFileLocation = this.getInput(doc, thumb?.type);\n\n    let mimeType: string;\n    if(thumb) {\n      mimeType = doc.sticker ? 'image/webp' : 'image/jpeg'/* doc.mime_type */;\n    } else {\n      mimeType = doc.mime_type || 'application/octet-stream';\n    }\n\n    return {\n      dcId: doc.dc_id, \n      location: inputFileLocation, \n      size: thumb ? thumb.size : doc.size, \n      mimeType,\n      fileName: doc.file_name,\n      queueId,\n      onlyCache\n    };\n  }\n\n  public getFileURL(doc: MyDocument, download = false, thumb?: PhotoSize.photoSize) {\n    let type: FileURLType;\n    if(download) {\n      type = 'download';\n    } else if(thumb) {\n      type = 'thumb';\n    } else if(doc.supportsStreaming) {\n      type = 'stream';\n    } else {\n      type = 'document';\n    }\n\n    return getFileURL(type, this.getFileDownloadOptions(doc, thumb));\n  }\n\n  public getThumbURL(doc: MyDocument, thumb: PhotoSize.photoSize | PhotoSize.photoCachedSize | PhotoSize.photoStrippedSize) {\n    let promise: Promise<any> = Promise.resolve();\n\n    const cacheContext = appDownloadManager.getCacheContext(doc, thumb.type);\n    if(!cacheContext.url) {\n      if('bytes' in thumb) {\n        promise = blur(appPhotosManager.getPreviewURLFromBytes(thumb.bytes, !!doc.sticker)).then(url => {\n          cacheContext.url = url;\n        }) as any;\n      } else {\n        //return this.getFileURL(doc, false, thumb);\n        promise = appPhotosManager.preloadPhoto(doc, thumb) as any;\n      }\n    }\n\n    return {thumb, cacheContext, promise};\n  }\n\n  public getThumb(doc: MyDocument, tryNotToUseBytes = true) {\n    const thumb = appPhotosManager.choosePhotoSize(doc, 0, 0, !tryNotToUseBytes);\n    if(thumb._ === 'photoSizeEmpty') return null;\n    return this.getThumbURL(doc, thumb as any);\n  }\n\n  public getInputFileName(doc: MyDocument, thumbSize?: string) {\n    return getFileNameByLocation(this.getInput(doc, thumbSize), {fileName: doc.file_name});\n  }\n\n  public downloadDoc(doc: MyDocument, queueId?: number, onlyCache?: boolean): DownloadBlob {\n    const fileName = this.getInputFileName(doc);\n\n    let download: DownloadBlob = appDownloadManager.getDownload(fileName);\n    if(download) {\n      return download;\n    }\n\n    const downloadOptions = this.getFileDownloadOptions(doc, undefined, queueId, onlyCache);\n    download = appDownloadManager.download(downloadOptions);\n\n    const cacheContext = appDownloadManager.getCacheContext(doc);\n    const originalPromise = download;\n    originalPromise.then((blob) => {\n      cacheContext.url = URL.createObjectURL(blob);\n      cacheContext.downloaded = blob.size;\n    }, () => {});\n    \n    if(doc.type === 'voice' && !opusDecodeController.isPlaySupported()) {\n      download = originalPromise.then(async(blob) => {\n        const reader = new FileReader();\n  \n        await new Promise<void>((resolve, reject) => {\n          reader.onloadend = (e) => {\n            const uint8 = new Uint8Array(e.target.result as ArrayBuffer);\n            //console.log('sending uint8 to decoder:', uint8);\n            opusDecodeController.decode(uint8).then(result => {\n              cacheContext.url = result.url;\n              resolve();\n            }, (err) => {\n              delete cacheContext.downloaded;\n              reject(err);\n            });\n          };\n    \n          reader.readAsArrayBuffer(blob);\n        });\n  \n        return blob;\n      });\n    }\n\n    return download;\n  }\n\n  public saveLottiePreview(doc: MyDocument, canvas: HTMLCanvasElement, toneIndex: number) {\n    const key = doc.id + '-' + toneIndex;\n    if(this.savingLottiePreview[key]/*  || true */) return;\n\n    if(!doc.stickerCachedThumbs) {\n      defineNotNumerableProperties(doc, ['stickerCachedThumbs']);\n      doc.stickerCachedThumbs = {};\n    }\n\n    const thumb = doc.stickerCachedThumbs[toneIndex];\n    if(thumb && thumb.w >= canvas.width && thumb.h >= canvas.height) {\n      return;\n    }\n\n    /* if(doc.thumbs.find(t => t._ === 'photoStrippedSize') \n      || (doc.stickerCachedThumb || (doc.stickerSavedThumbWidth >= canvas.width && doc.stickerSavedThumbHeight >= canvas.height))) {\n      return;\n    } */\n\n    this.savingLottiePreview[key] = true;\n    canvas.toBlob((blob) => {\n      //console.log('got lottie preview', doc, blob, URL.createObjectURL(blob));\n\n      const thumb = {\n        url: URL.createObjectURL(blob),\n        w: canvas.width,\n        h: canvas.height\n      };\n\n      doc.stickerCachedThumbs[toneIndex] = thumb;\n\n      delete this.savingLottiePreview[key];\n      \n      /* const reader = new FileReader();\n      reader.onloadend = (e) => {\n        const uint8 = new Uint8Array(e.target.result as ArrayBuffer);\n        const thumb: PhotoSize.photoStrippedSize = {\n          _: 'photoStrippedSize',\n          bytes: uint8,\n          type: 'i'\n        };\n\n        doc.stickerSavedThumbWidth = canvas.width;\n        doc.stickerSavedThumbHeight = canvas.width;\n\n        defineNotNumerableProperties(thumb, ['url']);\n        thumb.url = URL.createObjectURL(blob);\n        doc.thumbs.findAndSplice(t => t._ === thumb._);\n        doc.thumbs.unshift(thumb);\n\n        if(!webpWorkerController.isWebpSupported()) {\n          doc.pFlags.stickerThumbConverted = true;\n        }\n\n        delete this.savingLottiePreview[doc.id];\n      };\n      reader.readAsArrayBuffer(blob); */\n    });\n  }\n\n  public saveDocFile(doc: MyDocument, queueId?: number) {\n    /* const options = this.getFileDownloadOptions(doc, undefined, queueId);\n    return appDownloadManager.downloadToDisc(options, doc.file_name); */\n    const promise = this.downloadDoc(doc, queueId);\n    promise.then(() => {\n      const cacheContext = appDownloadManager.getCacheContext(doc);\n      appDownloadManager.createDownloadAnchor(cacheContext.url, doc.file_name);\n    });\n    return promise;\n  }\n}\n\nconst appDocsManager = new AppDocsManager();\nMOUNT_CLASS_TO.appDocsManager = appDocsManager;\nexport default appDocsManager;\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport { LazyLoadQueueBase } from \"../../components/lazyLoadQueue\";\nimport ProgressivePreloader from \"../../components/preloader\";\nimport { CancellablePromise, deferredPromise } from \"../../helpers/cancellablePromise\";\nimport { formatTime, tsNow } from \"../../helpers/date\";\nimport { createPosterForVideo } from \"../../helpers/files\";\nimport { copy, getObjectKeysAndSort } from \"../../helpers/object\";\nimport { randomLong } from \"../../helpers/random\";\nimport { splitStringByLength, limitSymbols, escapeRegExp } from \"../../helpers/string\";\nimport { Chat, ChatFull, Dialog as MTDialog, DialogPeer, DocumentAttribute, InputMedia, InputMessage, InputPeerNotifySettings, InputSingleMedia, Message, MessageAction, MessageEntity, MessageFwdHeader, MessageMedia, MessageReplies, MessageReplyHeader, MessagesDialogs, MessagesFilter, MessagesMessages, MethodDeclMap, NotifyPeer, PeerNotifySettings, PhotoSize, SendMessageAction, Update, Photo, Updates, ReplyMarkup, InputPeer } from \"../../layer\";\nimport { InvokeApiOptions } from \"../../types\";\nimport I18n, { i18n, join, langPack, LangPackKey, _i18n } from \"../langPack\";\nimport { logger, LogTypes } from \"../logger\";\nimport type { ApiFileManager } from '../mtproto/apiFileManager';\n//import apiManager from '../mtproto/apiManager';\nimport apiManager from '../mtproto/mtprotoworker';\nimport referenceDatabase, { ReferenceContext } from \"../mtproto/referenceDatabase\";\nimport serverTimeManager from \"../mtproto/serverTimeManager\";\nimport { RichTextProcessor } from \"../richtextprocessor\";\nimport rootScope from \"../rootScope\";\nimport DialogsStorage from \"../storages/dialogs\";\nimport FiltersStorage from \"../storages/filters\";\n//import { telegramMeWebService } from \"../mtproto/mtproto\";\nimport apiUpdatesManager from \"./apiUpdatesManager\";\nimport appChatsManager from \"./appChatsManager\";\nimport appDocsManager, { MyDocument } from \"./appDocsManager\";\nimport appDownloadManager from \"./appDownloadManager\";\nimport appPeersManager from \"./appPeersManager\";\nimport appPhotosManager, { MyPhoto } from \"./appPhotosManager\";\nimport appPollsManager from \"./appPollsManager\";\nimport appStateManager from \"./appStateManager\";\nimport appUsersManager from \"./appUsersManager\";\nimport appWebPagesManager from \"./appWebPagesManager\";\nimport appDraftsManager from \"./appDraftsManager\";\nimport { getFileNameByLocation } from \"../../helpers/fileName\";\nimport appProfileManager from \"./appProfileManager\";\nimport DEBUG, { MOUNT_CLASS_TO } from \"../../config/debug\";\nimport SlicedArray, { Slice, SliceEnd } from \"../../helpers/slicedArray\";\nimport appNotificationsManager, { NotifyOptions } from \"./appNotificationsManager\";\nimport PeerTitle from \"../../components/peerTitle\";\nimport { forEachReverse } from \"../../helpers/array\";\nimport htmlToDocumentFragment from \"../../helpers/dom/htmlToDocumentFragment\";\nimport htmlToSpan from \"../../helpers/dom/htmlToSpan\";\nimport { REPLIES_PEER_ID } from \"../mtproto/mtproto_config\";\nimport formatCallDuration from \"../../helpers/formatCallDuration\";\nimport appAvatarsManager from \"./appAvatarsManager\";\nimport telegramMeWebManager from \"../mtproto/telegramMeWebManager\";\nimport { getMiddleware } from \"../../helpers/middleware\";\nimport assumeType from \"../../helpers/assumeType\";\n\n//console.trace('include');\n// TODO: \u0435\u0441\u043b\u0438 \u0443\u0434\u0430\u043b\u0438\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0432 \u043d\u0435\u043f\u0440\u043e\u0433\u0440\u0443\u0436\u0435\u043d\u043d\u043e\u043c \u0434\u0438\u0430\u043b\u043e\u0433\u0435, \u0442\u043e \u043f\u0440\u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0438, \u0438\u0437-\u0437\u0430 \u0441\u0442\u0435\u0439\u0442\u0430, \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0432 \u0447\u0430\u0442\u043b\u0438\u0441\u0442\u0435 \u043d\u0435 \u0431\u0443\u0434\u0435\u0442\n// TODO: \u0435\u0441\u043b\u0438 \u0443\u0434\u0430\u043b\u0438\u0442\u044c \u0434\u0438\u0430\u043b\u043e\u0433 \u043d\u0430\u0445\u043e\u0434\u044f\u0441\u044c \u0432 \u043f\u0430\u043f\u043a\u0435, \u0442\u043e \u043e\u043d \u043d\u0435 \u0443\u0434\u0430\u043b\u0438\u0442\u0441\u044f \u0438\u0437 \u043f\u0430\u043f\u043a\u0438 \u0438 \u0431\u0443\u0434\u0435\u0442 \u0432\u0438\u0434\u0435\u043d \u0432 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430\u0445\n\nconst APITIMEOUT = 0;\n\nexport type HistoryStorage = {\n  count: number | null,\n  history: SlicedArray,\n\n  maxId?: number,\n  readPromise?: Promise<void>,\n  readMaxId?: number,\n  readOutboxMaxId?: number,\n  triedToReadMaxId?: number,\n\n  maxOutId?: number,\n  reply_markup?: Exclude<ReplyMarkup, ReplyMarkup.replyInlineMarkup>\n};\n\nexport type HistoryResult = {\n  count: number,\n  history: Slice,\n  offsetIdOffset?: number,\n};\n\nexport type Dialog = MTDialog.dialog;\n\nexport type MyMessage = Message.message | Message.messageService;\nexport type MyInputMessagesFilter = 'inputMessagesFilterEmpty' \n  | 'inputMessagesFilterPhotos' \n  | 'inputMessagesFilterPhotoVideo' \n  | 'inputMessagesFilterVideo' \n  | 'inputMessagesFilterDocument' \n  | 'inputMessagesFilterVoice' \n  | 'inputMessagesFilterRoundVoice' \n  | 'inputMessagesFilterRoundVideo' \n  | 'inputMessagesFilterMusic' \n  | 'inputMessagesFilterUrl' \n  | 'inputMessagesFilterMyMentions'\n  | 'inputMessagesFilterChatPhotos'\n  | 'inputMessagesFilterPinned';\n\nexport type PinnedStorage = Partial<{\n  promise: Promise<PinnedStorage>,\n  count: number,\n  maxId: number\n}>;\nexport type MessagesStorage = {\n  //generateIndex: (message: any) => void\n  [mid: string]: any\n};\n\nexport type MyMessageActionType = Message.messageService['action']['_'];\n\ntype PendingAfterMsg = Partial<InvokeApiOptions & {\n  afterMessageId: string,\n  messageId: string\n}>;\n\nexport class AppMessagesManager {\n  private static MESSAGE_ID_INCREMENT = 0x10000;\n  private static MESSAGE_ID_OFFSET = 0xFFFFFFFF;\n\n  private messagesStorageByPeerId: {[peerId: string]: MessagesStorage};\n  public groupedMessagesStorage: {[groupId: string]: MessagesStorage}; // will be used for albums\n  private scheduledMessagesStorage: {[peerId: string]: MessagesStorage};\n  private historiesStorage: {\n    [peerId: string]: HistoryStorage\n  };\n  private threadsStorage: {\n    [peerId: string]: {\n      [threadId: string]: HistoryStorage\n    }\n  };\n  private searchesStorage: {\n    [peerId: string]: Partial<{\n      [inputFilter in MyInputMessagesFilter]: {\n        count?: number,\n        history: number[]\n      }\n    }>\n  };\n  public pinnedMessages: {[peerId: string]: PinnedStorage};\n\n  public threadsServiceMessagesIdsStorage: {[peerId_threadId: string]: number};\n  private threadsToReplies: {\n    [peerId_threadId: string]: string;\n  };\n\n  private pendingByRandomId: {\n    [randomId: string]: {\n      peerId: number,\n      tempId: number,\n      threadId: number,\n      storage: MessagesStorage\n    }\n  } = {};\n  private pendingByMessageId: {[mid: string]: string} = {};\n  private pendingAfterMsgs: {[peerId: string]: PendingAfterMsg} = {};\n  public pendingTopMsgs: {[peerId: string]: number} = {};\n  private tempNum = 0;\n  private tempFinalizeCallbacks: {\n    [tempId: string]: {\n      [callbackName: string]: Partial<{\n        deferred: CancellablePromise<void>, \n        callback: (message: any) => Promise<any>\n      }>\n    }\n  } = {};\n  \n  private sendSmthLazyLoadQueue = new LazyLoadQueueBase(1);\n\n  private needSingleMessages: {[peerId: string]: number[]} = {};\n  private fetchSingleMessagesPromise: Promise<void> = null;\n\n  private maxSeenId = 0;\n\n  public migratedFromTo: {[peerId: number]: number} = {};\n  public migratedToFrom: {[peerId: number]: number} = {};\n\n  private newMessagesHandleTimeout = 0;\n  private newMessagesToHandle: {[peerId: string]: Set<number>} = {};\n  private newDialogsHandlePromise: Promise<any>;\n  private newDialogsToHandle: {[peerId: string]: Dialog} = {};\n  public newUpdatesAfterReloadToHandle: {[peerId: string]: Set<Update>} = {};\n\n  private notificationsHandlePromise = 0;\n  private notificationsToHandle: {[peerId: string]: {\n    fwdCount: number,\n    fromId: number,\n    topMessage?: MyMessage\n  }} = {};\n\n  private reloadConversationsPromise: Promise<void>;\n  private reloadConversationsPeers: Set<number> = new Set();\n\n  public log = logger('MESSAGES', LogTypes.Error | LogTypes.Debug | LogTypes.Log | LogTypes.Warn);\n\n  public dialogsStorage: DialogsStorage;\n  public filtersStorage: FiltersStorage;\n\n  private groupedTempId = 0;\n\n  private typings: {[peerId: string]: {type: SendMessageAction['_'], timeout?: number}} = {};\n\n  private middleware: ReturnType<typeof getMiddleware>;\n\n  constructor() {\n    this.clear();\n\n    rootScope.addMultipleEventsListeners({\n      updateMessageID: this.onUpdateMessageId,\n\n      updateNewDiscussionMessage: this.onUpdateNewMessage,\n      updateNewMessage: this.onUpdateNewMessage,\n      updateNewChannelMessage: this.onUpdateNewMessage,\n\n      updateDialogUnreadMark: this.onUpdateDialogUnreadMark,\n\n      updateEditMessage: this.onUpdateEditMessage,\n      updateEditChannelMessage: this.onUpdateEditMessage,\n\n      updateReadChannelDiscussionInbox: this.onUpdateReadHistory,\n      updateReadChannelDiscussionOutbox: this.onUpdateReadHistory,\n      updateReadHistoryInbox: this.onUpdateReadHistory,\n      updateReadHistoryOutbox: this.onUpdateReadHistory,\n      updateReadChannelInbox: this.onUpdateReadHistory,\n      updateReadChannelOutbox: this.onUpdateReadHistory,\n\n      updateChannelReadMessagesContents: this.onUpdateReadMessagesContents,\n      updateReadMessagesContents: this.onUpdateReadMessagesContents,\n\n      updateChannelAvailableMessages: this.onUpdateChannelAvailableMessages,\n\n      updateDeleteMessages: this.onUpdateDeleteMessages,\n      updateDeleteChannelMessages: this.onUpdateDeleteMessages,\n\n      updateChannel: this.onUpdateChannel,\n\n      updateChannelReload: this.onUpdateChannelReload,\n\n      updateChannelMessageViews: this.onUpdateChannelMessageViews,\n\n      updateServiceNotification: this.onUpdateServiceNotification,\n\n      updatePinnedMessages: this.onUpdatePinnedMessages,\n      updatePinnedChannelMessages: this.onUpdatePinnedMessages,\n\n      updateNotifySettings: this.onUpdateNotifySettings,\n\n      updateNewScheduledMessage: this.onUpdateNewScheduledMessage,\n\n      updateDeleteScheduledMessages: this.onUpdateDeleteScheduledMessages\n    });\n\n    // ! Invalidate notify settings, can optimize though\n    rootScope.addEventListener('notify_peer_type_settings', ({key, settings}) => {\n      this.getConversationsAll().then(dialogs => {\n        let filterFunc: (dialog: Dialog) => boolean;\n        if(key === 'notifyUsers') filterFunc = (dialog) => dialog.peerId > 0;\n        else if(key === 'notifyBroadcasts') filterFunc = (dialog) => appChatsManager.isBroadcast(-dialog.peerId);\n        else filterFunc = (dialog) => appPeersManager.isAnyGroup(dialog.peerId);\n\n        dialogs\n        .filter(filterFunc)\n        .forEach(dialog => {\n          rootScope.dispatchEvent('dialog_notify_settings', dialog);\n        });\n      });\n    });\n\n    rootScope.addEventListener('webpage_updated', (e) => {\n      const eventData = e;\n      eventData.msgs.forEach((mid) => {\n        const message = this.getMessageById(mid) as Message.message;\n        if(!message) return;\n        message.media = {\n          _: 'messageMediaWebPage', \n          webpage: appWebPagesManager.getWebPage(eventData.id)\n        };\n\n        const peerId = this.getMessagePeer(message);\n        const storage = this.getMessagesStorage(peerId);\n        rootScope.dispatchEvent('message_edit', {\n          storage,\n          peerId,\n          mid\n        });\n      });\n    });\n\n    rootScope.addEventListener('draft_updated', (e) => {\n      const {peerId, threadId, draft} = e;\n\n      if(threadId) return;\n\n      const dialog = this.getDialogOnly(peerId);\n      if(dialog && !threadId) {\n        dialog.draft = draft;\n        this.dialogsStorage.generateIndexForDialog(dialog);\n        this.dialogsStorage.pushDialog(dialog);\n\n        rootScope.dispatchEvent('dialog_draft', {\n          peerId,\n          draft,\n          index: dialog.index\n        });\n      } else {\n        this.reloadConversation(peerId);\n      }\n    });\n    \n    appStateManager.getState().then(state => {\n      if(state.maxSeenMsgId) {\n        this.maxSeenId = state.maxSeenMsgId;\n      }\n    });\n  }\n\n  public clear() {\n    if(this.middleware) {\n      this.middleware.clean();\n    } else {\n      this.middleware = getMiddleware();\n    }\n\n    this.messagesStorageByPeerId = {};\n    this.groupedMessagesStorage = {};\n    this.scheduledMessagesStorage = {};\n    this.historiesStorage = {};\n    this.threadsStorage = {};\n    this.searchesStorage = {};\n    this.pinnedMessages = {};\n    this.threadsServiceMessagesIdsStorage = {};\n    this.threadsToReplies = {};\n\n    this.dialogsStorage && this.dialogsStorage.clear();\n    this.filtersStorage && this.filtersStorage.clear();\n  }\n\n  public construct() {\n    this.filtersStorage = new FiltersStorage(this, appPeersManager, appUsersManager, appNotificationsManager, appStateManager, apiUpdatesManager, /* apiManager, */ rootScope);\n    this.dialogsStorage = new DialogsStorage(this, appChatsManager, appPeersManager, appUsersManager, appDraftsManager, appNotificationsManager, appStateManager, apiUpdatesManager, serverTimeManager);\n  }\n\n  public getInputEntities(entities: MessageEntity[]) {\n    const sendEntites = copy(entities);\n    sendEntites.forEach((entity) => {\n      if(entity._ === 'messageEntityMentionName') {\n        (entity as any as MessageEntity.inputMessageEntityMentionName)._ = 'inputMessageEntityMentionName';\n        (entity as any as MessageEntity.inputMessageEntityMentionName).user_id = appUsersManager.getUserInput(entity.user_id);\n      }\n    });\n    return sendEntites;\n  }\n\n  public invokeAfterMessageIsSent(tempId: number, callbackName: string, callback: (message: any) => Promise<any>) {\n    const finalize = this.tempFinalizeCallbacks[tempId] ?? (this.tempFinalizeCallbacks[tempId] = {});\n    const obj = finalize[callbackName] ?? (finalize[callbackName] = {deferred: deferredPromise<void>()});\n\n    obj.callback = callback;\n\n    return obj.deferred;\n  }\n\n  public editMessage(message: any, text: string, options: Partial<{\n    noWebPage: true,\n    newMedia: any,\n    scheduleDate: number,\n    entities: MessageEntity[]\n  }> = {}): Promise<void> {\n    /* if(!this.canEditMessage(messageId)) {\n      return Promise.reject({type: 'MESSAGE_EDIT_FORBIDDEN'});\n    } */\n\n    const {mid, peerId} = message;\n\n    if(message.pFlags.is_outgoing) {\n      return this.invokeAfterMessageIsSent(mid, 'edit', (message) => {\n        //this.log('invoke editMessage callback', message);\n        return this.editMessage(message, text, options);\n      });\n    }\n\n    let entities = options.entities || [];\n    if(text) {\n      text = RichTextProcessor.parseMarkdown(text, entities);\n    }\n\n    const schedule_date = options.scheduleDate || (message.pFlags.is_scheduled ? message.date : undefined);\n    return apiManager.invokeApi('messages.editMessage', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      id: message.id,\n      message: text,\n      media: options.newMedia,\n      entities: entities.length ? this.getInputEntities(entities) : undefined,\n      no_webpage: options.noWebPage,\n      schedule_date\n    }).then((updates) => {\n      apiUpdatesManager.processUpdateMessage(updates);\n    }, (error) => {\n      this.log.error('editMessage error:', error);\n      \n      if(error && error.type === 'MESSAGE_NOT_MODIFIED') {\n        error.handled = true;\n        return;\n      }\n      if(error && error.type === 'MESSAGE_EMPTY') {\n        error.handled = true;\n      }\n      return Promise.reject(error);\n    });\n  }\n\n  public sendText(peerId: number, text: string, options: Partial<{\n    entities: any[],\n    replyToMsgId: number,\n    threadId: number,\n    viaBotId: number,\n    queryId: string,\n    resultId: string,\n    noWebPage: true,\n    reply_markup: any,\n    clearDraft: true,\n    webPage: any,\n    scheduleDate: number,\n    silent: true\n  }> = {}) {\n    if(typeof(text) !== 'string' || !text.length) {\n      return;\n    }\n\n    //this.checkSendOptions(options);\n\n    if(options.threadId && !options.replyToMsgId) {\n      options.replyToMsgId = options.threadId;\n    }\n\n    const MAX_LENGTH = rootScope.config.message_length_max;\n    if(text.length > MAX_LENGTH) {\n      const splitted = splitStringByLength(text, MAX_LENGTH);\n      text = splitted[0];\n\n      if(splitted.length > 1) {\n        delete options.webPage;\n      }\n\n      for(let i = 1; i < splitted.length; ++i) {\n        setTimeout(() => {\n          this.sendText(peerId, splitted[i], options);\n        }, i);\n      }\n    }\n\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\n\n    let entities = options.entities || [];\n    if(!options.viaBotId) {\n      text = RichTextProcessor.parseMarkdown(text, entities);\n      //entities = RichTextProcessor.mergeEntities(entities, RichTextProcessor.parseEntities(text));\n    }\n\n    let sendEntites = this.getInputEntities(entities);\n    if(!sendEntites.length) {\n      sendEntites = undefined;\n    }\n\n    const message = this.generateOutgoingMessage(peerId, options);\n    message.entities = entities;\n    message.message = text;\n\n    const replyToMsgId = options.replyToMsgId ? this.getServerMessageId(options.replyToMsgId) : undefined;\n    const isChannel = appPeersManager.isChannel(peerId);\n\n    if(options.webPage) {\n      message.media = {\n        _: 'messageMediaWebPage',\n        webpage: options.webPage\n      };\n    }\n\n    const toggleError = (on: any) => {\n      if(on) {\n        message.error = true;\n      } else {\n        delete message.error;\n      }\n      rootScope.dispatchEvent('messages_pending');\n    };\n\n    message.send = () => {\n      toggleError(false);\n      const sentRequestOptions: PendingAfterMsg = {};\n      if(this.pendingAfterMsgs[peerId]) {\n        sentRequestOptions.afterMessageId = this.pendingAfterMsgs[peerId].messageId;\n      }\n\n      let apiPromise: any;\n      if(options.viaBotId) {\n        apiPromise = apiManager.invokeApiAfter('messages.sendInlineBotResult', {\n          peer: appPeersManager.getInputPeerById(peerId),\n          random_id: message.random_id,\n          reply_to_msg_id: replyToMsgId || undefined,\n          query_id: options.queryId,\n          id: options.resultId,\n          clear_draft: options.clearDraft\n        }, sentRequestOptions);\n      } else {\n        apiPromise = apiManager.invokeApiAfter('messages.sendMessage', {\n          no_webpage: options.noWebPage,\n          peer: appPeersManager.getInputPeerById(peerId),\n          message: text,\n          random_id: message.random_id,\n          reply_to_msg_id: replyToMsgId || undefined,\n          entities: sendEntites,\n          clear_draft: options.clearDraft,\n          schedule_date: options.scheduleDate || undefined,\n          silent: options.silent\n        }, sentRequestOptions);\n      }\n\n      /* function is<T>(value: any, condition: boolean): value is T {\n        return condition;\n      } */\n\n      //this.log('sendText', message.mid);\n      apiPromise.then((updates: Updates) => {\n        //this.log('sendText sent', message.mid);\n        //if(is<Updates.updateShortSentMessage>(updates, updates._ === 'updateShortSentMessage')) {\n        if(updates._ === 'updateShortSentMessage') {\n          //assumeType<Updates.updateShortSentMessage>(updates);\n          message.date = updates.date;\n          message.id = updates.id;\n          message.media = updates.media;\n          message.entities = updates.entities;\n          this.wrapMessageEntities(message);\n          if(updates.pFlags.out) {\n            message.pFlags.out = true;\n          }\n\n          // * override with new updates\n          updates = {\n            _: 'updates',\n            users: [],\n            chats: [],\n            seq: 0,\n            updates: [{\n              _: 'updateMessageID',\n              random_id: message.random_id,\n              id: updates.id\n            }, {\n              _: options.scheduleDate ? 'updateNewScheduledMessage' : (isChannel ? 'updateNewChannelMessage' : 'updateNewMessage'),\n              message: message,\n              pts: updates.pts,\n              pts_count: updates.pts_count\n            }]\n          } as any;\n        } else if((updates as Updates.updates).updates) {\n          (updates as Updates.updates).updates.forEach((update) => {\n            if(update._ === 'updateDraftMessage') {\n              update.local = true;\n            }\n          });\n        }\n        // Testing bad situations\n        // var upd = angular.copy(updates)\n        // updates.updates.splice(0, 1)\n\n        apiUpdatesManager.processUpdateMessage(updates);\n\n        // $timeout(function () {\n        // ApiUpdatesManager.processUpdateMessage(upd)\n        // }, 5000)\n      }, (/* error: any */) => {\n        toggleError(true);\n      }).finally(() => {\n        if(this.pendingAfterMsgs[peerId] === sentRequestOptions) {\n          delete this.pendingAfterMsgs[peerId];\n        }\n      });\n\n      this.pendingAfterMsgs[peerId] = sentRequestOptions;\n    }\n\n    this.beforeMessageSending(message, {\n      isScheduled: !!options.scheduleDate || undefined, \n      threadId: options.threadId,\n      clearDraft: options.clearDraft\n    });\n  }\n\n  public sendFile(peerId: number, file: File | Blob | MyDocument, options: Partial<{\n    isRoundMessage: true,\n    isVoiceMessage: true,\n    isGroupedItem: true,\n    isMedia: true,\n\n    replyToMsgId: number,\n    threadId: number,\n    groupId: string,\n    caption: string,\n    entities: MessageEntity[],\n    width: number,\n    height: number,\n    objectURL: string,\n    thumbBlob: Blob,\n    thumbURL: string,\n    duration: number,\n    background: true,\n    silent: true,\n    clearDraft: true,\n    scheduleDate: number,\n\n    waveform: Uint8Array,\n  }> = {}) {\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\n\n    //this.checkSendOptions(options);\n\n    const message = this.generateOutgoingMessage(peerId, options);\n    const replyToMsgId = options.replyToMsgId ? this.getServerMessageId(options.replyToMsgId) : undefined;\n\n    let attachType: string, apiFileName: string;\n\n    const fileType = 'mime_type' in file ? file.mime_type : file.type;\n    const fileName = file instanceof File ? file.name : '';\n    const isDocument = !(file instanceof File) && !(file instanceof Blob);\n    let caption = options.caption || '';\n\n    this.log('sendFile', file, fileType);\n\n    const entities = options.entities || [];\n    if(caption) {\n      caption = RichTextProcessor.parseMarkdown(caption, entities);\n    }\n\n    const attributes: DocumentAttribute[] = [];\n\n    const isPhoto = ['image/jpeg', 'image/png', 'image/bmp'].indexOf(fileType) >= 0;\n\n    let photo: MyPhoto, document: MyDocument;\n\n    let actionName: SendMessageAction['_'];\n    if(isDocument) { // maybe it's a sticker or gif\n      attachType = 'document';\n      apiFileName = '';\n    } else if(fileType.indexOf('audio/') === 0 || ['video/ogg'].indexOf(fileType) >= 0) {\n      attachType = 'audio';\n      apiFileName = 'audio.' + (fileType.split('/')[1] === 'ogg' ? 'ogg' : 'mp3');\n      actionName = 'sendMessageUploadAudioAction';\n\n      if(options.isVoiceMessage) {\n        attachType = 'voice';\n        message.pFlags.media_unread = true;\n      }\n\n      let attribute: DocumentAttribute.documentAttributeAudio = {\n        _: 'documentAttributeAudio',\n        pFlags: {\n          voice: options.isVoiceMessage\n        },\n        waveform: options.waveform,\n        duration: options.duration || 0\n      };\n\n      attributes.push(attribute);\n    } else if(!options.isMedia) {\n      attachType = 'document';\n      apiFileName = 'document.' + fileType.split('/')[1];\n      actionName = 'sendMessageUploadDocumentAction';\n    } else if(isPhoto) {\n      attachType = 'photo';\n      apiFileName = 'photo.' + fileType.split('/')[1];\n      actionName = 'sendMessageUploadPhotoAction';\n\n      const photoSize = {\n        _: 'photoSize',\n        w: options.width,\n        h: options.height,\n        type: 'full',\n        location: null,\n        size: file.size\n      } as PhotoSize.photoSize;\n\n      photo = {\n        _: 'photo',\n        id: '' + message.id,\n        sizes: [photoSize],\n        w: options.width,\n        h: options.height\n      } as any;\n\n      const cacheContext = appDownloadManager.getCacheContext(photo, photoSize.type);\n      cacheContext.downloaded = file.size;\n      cacheContext.url = options.objectURL || '';\n      \n      photo = appPhotosManager.savePhoto(photo);\n    } else if(fileType.indexOf('video/') === 0) {\n      attachType = 'video';\n      apiFileName = 'video.mp4';\n      actionName = 'sendMessageUploadVideoAction';\n\n      let videoAttribute: DocumentAttribute.documentAttributeVideo = {\n        _: 'documentAttributeVideo',\n        pFlags: {\n          round_message: options.isRoundMessage\n        }, \n        duration: options.duration,\n        w: options.width,\n        h: options.height\n      };\n\n      attributes.push(videoAttribute);\n    } else {\n      attachType = 'document';\n      apiFileName = 'document.' + fileType.split('/')[1];\n      actionName = 'sendMessageUploadDocumentAction';\n    }\n\n    attributes.push({_: 'documentAttributeFilename', file_name: fileName || apiFileName});\n\n    if(['document', 'video', 'audio', 'voice'].indexOf(attachType) !== -1 && !isDocument) {\n      const thumbs: PhotoSize[] = [];\n      document = {\n        _: 'document',\n        id: '' + message.id,\n        duration: options.duration,\n        attributes,\n        w: options.width,\n        h: options.height,\n        thumbs,\n        mime_type: fileType,\n        size: file.size\n      } as any;\n\n      const cacheContext = appDownloadManager.getCacheContext(document);\n      cacheContext.downloaded = file.size;\n      cacheContext.url = options.objectURL || '';\n\n      let thumb: PhotoSize.photoSize;\n      if(isPhoto) {\n        attributes.push({\n          _: 'documentAttributeImageSize',\n          w: options.width,\n          h: options.height\n        });\n\n        thumb = {\n          _: 'photoSize',\n          w: options.width,\n          h: options.height,\n          type: 'full',\n          size: file.size\n        };\n      } else if(attachType === 'video') {\n        if(options.thumbURL) {\n          thumb = {\n            _: 'photoSize',\n            w: options.width,\n            h: options.height,\n            type: 'full',\n            size: options.thumbBlob.size\n          };\n\n          const thumbCacheContext = appDownloadManager.getCacheContext(document, thumb.type);\n          thumbCacheContext.downloaded = thumb.size;\n          thumbCacheContext.url = options.thumbURL;\n        }\n      }\n\n      if(thumb) {\n        thumbs.push(thumb);\n      }\n\n      /* if(thumbs.length) {\n        const thumb = thumbs[0] as PhotoSize.photoSize;\n        const docThumb = appPhotosManager.getDocumentCachedThumb(document.id);\n        docThumb.downloaded = thumb.size;\n        docThumb.url = thumb.url;\n      } */\n      \n      document = appDocsManager.saveDoc(document);\n    }\n\n    this.log('sendFile', attachType, apiFileName, file.type, options);\n\n    const preloader = isDocument ? undefined : new ProgressivePreloader({\n      attachMethod: 'prepend',\n      tryAgainOnFail: false,\n      isUpload: true\n    });\n\n    const sentDeferred = deferredPromise<InputMedia>();\n\n    if(preloader) {\n      preloader.attachPromise(sentDeferred);\n      sentDeferred.cancel = () => {\n        const error = new Error('Download canceled');\n        error.name = 'AbortError';\n        sentDeferred.reject(error);\n      };\n\n      sentDeferred.catch(err => {\n        if(err.name === 'AbortError' && !uploaded) {\n          this.log('cancelling upload', media);\n\n          sentDeferred.reject(err);\n          this.cancelPendingMessage(message.random_id);\n          this.setTyping(peerId, {_: 'sendMessageCancelAction'});\n\n          if(uploadPromise?.cancel) {\n            uploadPromise.cancel();\n          }\n        }\n      });\n    }\n\n    const media = isDocument ? undefined : {\n      _: photo ? 'messageMediaPhoto' : 'messageMediaDocument',\n      pFlags: {},\n      preloader,\n      photo,\n      document,\n      promise: sentDeferred\n    };\n\n    message.entities = entities;\n    message.message = caption;\n    message.media = isDocument ? {\n      _: 'messageMediaDocument',\n      pFlags: {},\n      document: file \n    } : media;\n\n    const toggleError = (on: boolean) => {\n      if(on) {\n        message.error = true;\n      } else {\n        delete message.error;\n      }\n\n      rootScope.dispatchEvent('messages_pending');\n    };\n\n    let uploaded = false,\n      uploadPromise: ReturnType<ApiFileManager['uploadFile']> = null;\n\n    message.send = () => {\n      if(isDocument) {\n        const {id, access_hash, file_reference} = file as MyDocument;\n\n        const inputMedia: InputMedia = {\n          _: 'inputMediaDocument',\n          id: {\n            _: 'inputDocument',\n            id,\n            access_hash,\n            file_reference\n          }\n        };\n        \n        sentDeferred.resolve(inputMedia);\n      } else if(file instanceof File || file instanceof Blob) {\n        const load = () => {\n          if(!uploaded || message.error) {\n            uploaded = false;\n            uploadPromise = appDownloadManager.upload(file);\n            sentDeferred.notifyAll({done: 0, total: file.size});\n          }\n\n          let thumbUploadPromise: typeof uploadPromise;\n          if(attachType === 'video' && options.objectURL) {\n            thumbUploadPromise = new Promise((resolve, reject) => {\n              const blobPromise = options.thumbBlob ? Promise.resolve(options.thumbBlob) : createPosterForVideo(options.objectURL);\n              blobPromise.then(blob => {\n                if(!blob) {\n                  resolve(null);\n                } else {\n                  appDownloadManager.upload(blob).then(resolve, reject);\n                }\n              }, reject);\n            });\n          }\n  \n          uploadPromise && uploadPromise.then(async(inputFile) => {\n            /* if(DEBUG) {\n              this.log('appMessagesManager: sendFile uploaded:', inputFile);\n            } */\n\n            delete message.media.preloader;\n\n            inputFile.name = apiFileName;\n            uploaded = true;\n            let inputMedia: InputMedia;\n            switch(attachType) {\n              case 'photo':\n                inputMedia = {\n                  _: 'inputMediaUploadedPhoto', \n                  file: inputFile\n                };\n                break;\n\n              default:\n                inputMedia = {\n                  _: 'inputMediaUploadedDocument', \n                  file: inputFile, \n                  mime_type: fileType, \n                  attributes\n                };\n            }\n\n            if(thumbUploadPromise) {\n              try {\n                const inputFile = await thumbUploadPromise;\n                (inputMedia as InputMedia.inputMediaUploadedDocument).thumb = inputFile;\n              } catch(err) {\n                this.log.error('sendFile thumb upload error:', err);\n              }\n            }\n            \n            sentDeferred.resolve(inputMedia);\n          }, (/* error */) => {\n            toggleError(true);\n          });\n  \n          uploadPromise.addNotifyListener((progress: {done: number, total: number}) => {\n            /* if(DEBUG) {\n              this.log('upload progress', progress);\n            } */\n\n            const percents = Math.max(1, Math.floor(100 * progress.done / progress.total));\n            if(actionName) {\n              this.setTyping(peerId, {_: actionName, progress: percents | 0});\n            }\n            sentDeferred.notifyAll(progress);\n          });\n\n          return sentDeferred;\n        };\n\n        if(options.isGroupedItem) {\n          load();\n        } else {\n          this.sendSmthLazyLoadQueue.push({\n            load\n          });\n        }\n      }\n\n      return sentDeferred;\n    };\n\n    this.beforeMessageSending(message, {\n      isGroupedItem: options.isGroupedItem, \n      isScheduled: !!options.scheduleDate || undefined, \n      threadId: options.threadId,\n      clearDraft: options.clearDraft\n    });\n\n    if(!options.isGroupedItem) {\n      sentDeferred.then(inputMedia => {\n        this.setTyping(peerId, {_: 'sendMessageCancelAction'});\n\n        return apiManager.invokeApi('messages.sendMedia', {\n          background: options.background,\n          peer: appPeersManager.getInputPeerById(peerId),\n          media: inputMedia,\n          message: caption,\n          random_id: message.random_id,\n          reply_to_msg_id: replyToMsgId,\n          schedule_date: options.scheduleDate,\n          silent: options.silent,\n          entities,\n          clear_draft: options.clearDraft\n        }).then((updates) => {\n          apiUpdatesManager.processUpdateMessage(updates);\n        }, (error) => {\n          if(attachType === 'photo' &&\n            error.code === 400 &&\n            (error.type === 'PHOTO_INVALID_DIMENSIONS' ||\n            error.type === 'PHOTO_SAVE_FILE_INVALID')) {\n            error.handled = true;\n            attachType = 'document';\n            message.send();\n            return;\n          }\n\n          toggleError(true);\n        });\n      });\n    }\n\n    return {message, promise: sentDeferred};\n  }\n\n  public async sendAlbum(peerId: number, files: File[], options: Partial<{\n    isMedia: true,\n    entities: MessageEntity[],\n    replyToMsgId: number,\n    threadId: number,\n    caption: string,\n    sendFileDetails: Partial<{\n      duration: number,\n      width: number,\n      height: number,\n      objectURL: string,\n      thumbBlob: Blob,\n      thumbURL: string\n    }>[],\n    silent: true,\n    clearDraft: true,\n    scheduleDate: number\n  }> = {}) {\n    //this.checkSendOptions(options);\n\n    if(options.threadId && !options.replyToMsgId) {\n      options.replyToMsgId = options.threadId;\n    }\n\n    if(files.length === 1) {\n      return this.sendFile(peerId, files[0], {...options, ...options.sendFileDetails[0]});\n    }\n\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\n    const replyToMsgId = options.replyToMsgId ? this.getServerMessageId(options.replyToMsgId) : undefined;\n\n    let caption = options.caption || '';\n    let entities = options.entities || [];\n    if(caption) {\n      caption = RichTextProcessor.parseMarkdown(caption, entities);\n    }\n\n    this.log('sendAlbum', files, options);\n\n    const groupId = '' + ++this.groupedTempId;\n\n    const messages = files.map((file, idx) => {\n      const details = options.sendFileDetails[idx];\n      const o: any = {\n        isGroupedItem: true,\n        isMedia: options.isMedia,\n        scheduleDate: options.scheduleDate,\n        silent: options.silent,\n        replyToMsgId,\n        threadId: options.threadId,\n        groupId,\n        ...details\n      };\n\n      if(idx === 0) {\n        o.caption = caption;\n        o.entities = entities;\n        //o.replyToMsgId = replyToMsgId;\n      }\n\n      return this.sendFile(peerId, file, o).message;\n    });\n\n    if(options.threadId) {\n      appDraftsManager.syncDraft(peerId, options.threadId);\n    } else {\n      appDraftsManager.saveDraft(peerId, options.threadId, null, {notify: true});  \n    }\n    \n    // * test pending\n    //return;\n\n    const toggleError = (message: any, on: boolean) => {\n      if(on) {\n        message.error = true;\n      } else {\n        delete message.error;\n      }\n\n      rootScope.dispatchEvent('messages_pending');\n    };\n\n    const inputPeer = appPeersManager.getInputPeerById(peerId);\n    const invoke = (multiMedia: any[]) => {\n      this.setTyping(peerId, {_: 'sendMessageCancelAction'});\n\n      this.sendSmthLazyLoadQueue.push({\n        load: () => {\n          return apiManager.invokeApi('messages.sendMultiMedia', {\n            peer: inputPeer,\n            multi_media: multiMedia,\n            reply_to_msg_id: replyToMsgId,\n            schedule_date: options.scheduleDate,\n            silent: options.silent,\n            clear_draft: options.clearDraft\n          }).then((updates) => {\n            apiUpdatesManager.processUpdateMessage(updates);\n          }, (error) => {\n            messages.forEach(message => toggleError(message, true));\n          });\n        }\n      });\n    };\n\n    const promises: Promise<InputSingleMedia>[] = messages.map((message, idx) => {\n      return (message.send() as Promise<InputMedia>).then((inputMedia: InputMedia) => {\n        return apiManager.invokeApi('messages.uploadMedia', {\n          peer: inputPeer,\n          media: inputMedia\n        });\n      })\n      .then(messageMedia => {\n        let inputMedia: any;\n        if(messageMedia._ === 'messageMediaPhoto') {\n          const photo = appPhotosManager.savePhoto(messageMedia.photo);\n          inputMedia = appPhotosManager.getInput(photo);\n        } else if(messageMedia._ === 'messageMediaDocument') {\n          const doc = appDocsManager.saveDoc(messageMedia.document);\n          inputMedia = appDocsManager.getMediaInput(doc);\n        }\n\n        const inputSingleMedia: InputSingleMedia = {\n          _: 'inputSingleMedia',\n          media: inputMedia,\n          random_id: message.random_id,\n          message: caption,\n          entities\n        };\n\n        // * only 1 caption for all inputs\n        if(caption) {\n          caption = '';\n          entities = [];\n        }\n\n        return inputSingleMedia;\n      }).catch((err: any) => {\n        if(err.name === 'AbortError') {\n          return null;\n        }\n\n        this.log.error('sendAlbum upload item error:', err, message);\n        toggleError(message, true);\n        throw err;\n      });\n    });\n\n    Promise.all(promises).then(inputs => {\n      invoke(inputs.filter(Boolean));\n    });\n  }\n\n  public sendOther(peerId: number, inputMedia: any, options: Partial<{\n    replyToMsgId: number,\n    threadId: number,\n    viaBotId: number,\n    reply_markup: any,\n    clearDraft: true,\n    queryId: string\n    resultId: string,\n    scheduleDate: number,\n    silent: true\n  }> = {}) {\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\n\n    //this.checkSendOptions(options);\n    const message = this.generateOutgoingMessage(peerId, options);\n    const replyToMsgId = options.replyToMsgId ? this.getServerMessageId(options.replyToMsgId) : undefined;\n\n    let media;\n    switch(inputMedia._) {\n      case 'inputMediaPoll': {\n        inputMedia.poll.id = message.id;\n        appPollsManager.savePoll(inputMedia.poll, {\n          _: 'pollResults',\n          flags: 4,\n          total_voters: 0,\n          pFlags: {},\n        });\n\n        const {poll, results} = appPollsManager.getPoll('' + message.id);\n        media = {\n          _: 'messageMediaPoll',\n          poll,\n          results\n        };\n\n        break;\n      }\n      /* case 'inputMediaPhoto':\n        media = {\n          _: 'messageMediaPhoto',\n          photo: appPhotosManager.getPhoto(inputMedia.id.id),\n          caption: inputMedia.caption || ''\n        };\n        break;\n\n      case 'inputMediaDocument':\n        var doc = appDocsManager.getDoc(inputMedia.id.id);\n        if(doc.sticker && doc.stickerSetInput) {\n          appStickersManager.pushPopularSticker(doc.id);\n        }\n        media = {\n          _: 'messageMediaDocument',\n          'document': doc,\n          caption: inputMedia.caption || ''\n        };\n        break;\n\n      case 'inputMediaContact':\n        media = {\n          _: 'messageMediaContact',\n          phone_number: inputMedia.phone_number,\n          first_name: inputMedia.first_name,\n          last_name: inputMedia.last_name,\n          user_id: 0\n        };\n        break;\n\n      case 'inputMediaGeoPoint':\n        media = {\n          _: 'messageMediaGeo',\n          geo: {\n            _: 'geoPoint',\n            'lat': inputMedia.geo_point['lat'],\n            'long': inputMedia.geo_point['long']\n          }\n        };\n        break;\n\n      case 'inputMediaVenue':\n        media = {\n          _: 'messageMediaVenue',\n          geo: {\n            _: 'geoPoint',\n            'lat': inputMedia.geo_point['lat'],\n            'long': inputMedia.geo_point['long']\n          },\n          title: inputMedia.title,\n          address: inputMedia.address,\n          provider: inputMedia.provider,\n          venue_id: inputMedia.venue_id\n        };\n        break;\n\n      case 'messageMediaPending':\n        media = inputMedia;\n        break; */\n    }\n\n    message.media = media;\n\n    let toggleError = (on: boolean) => {\n      /* const historyMessage = this.messagesForHistory[messageId];\n      if (on) {\n        message.error = true\n        if (historyMessage) {\n          historyMessage.error = true\n        }\n      } else {\n        delete message.error\n        if (historyMessage) {\n          delete historyMessage.error\n        }\n      } */\n      rootScope.dispatchEvent('messages_pending');\n    };\n\n    message.send = () => {\n      const sentRequestOptions: PendingAfterMsg = {};\n      if(this.pendingAfterMsgs[peerId]) {\n        sentRequestOptions.afterMessageId = this.pendingAfterMsgs[peerId].messageId;\n      }\n\n      let apiPromise: Promise<any>;\n      if(options.viaBotId) {\n        apiPromise = apiManager.invokeApiAfter('messages.sendInlineBotResult', {\n          peer: appPeersManager.getInputPeerById(peerId),\n          random_id: message.random_id,\n          reply_to_msg_id: replyToMsgId || undefined,\n          query_id: options.queryId,\n          id: options.resultId,\n          clear_draft: options.clearDraft\n        }, sentRequestOptions);\n      } else {\n        apiPromise = apiManager.invokeApiAfter('messages.sendMedia', {\n          peer: appPeersManager.getInputPeerById(peerId),\n          media: inputMedia,\n          random_id: message.random_id,\n          reply_to_msg_id: replyToMsgId || undefined,\n          message: '',\n          clear_draft: options.clearDraft,\n          schedule_date: options.scheduleDate,\n          silent: options.silent\n        }, sentRequestOptions);\n      }\n\n      apiPromise.then((updates) => {\n        if(updates.updates) {\n          updates.updates.forEach((update: any) => {\n            if(update._ === 'updateDraftMessage') {\n              update.local = true\n            }\n          });\n        }\n\n        apiUpdatesManager.processUpdateMessage(updates);\n      }, (error) => {\n        toggleError(true);\n      }).finally(() => {\n        if(this.pendingAfterMsgs[peerId] === sentRequestOptions) {\n          delete this.pendingAfterMsgs[peerId];\n        }\n      });\n      this.pendingAfterMsgs[peerId] = sentRequestOptions;\n    }\n\n    this.beforeMessageSending(message, {\n      isScheduled: !!options.scheduleDate || undefined, \n      threadId: options.threadId,\n      clearDraft: options.clearDraft\n    });\n  }\n\n  /* private checkSendOptions(options: Partial<{\n    scheduleDate: number\n  }>) {\n    if(options.scheduleDate) {\n      const minTimestamp = (Date.now() / 1000 | 0) + 10;\n      if(options.scheduleDate <= minTimestamp) {\n        delete options.scheduleDate;\n      }\n    }\n  } */\n\n  private beforeMessageSending(message: any, options: Partial<{\n    isGroupedItem: true, \n    isScheduled: true, \n    threadId: number, \n    clearDraft: true\n  }> = {}) {\n    const messageId = message.id;\n    const peerId = this.getMessagePeer(message);\n    const storage = options.isScheduled ? this.getScheduledMessagesStorage(peerId) : this.getMessagesStorage(peerId);\n\n    if(options.isScheduled) {\n      //if(!options.isGroupedItem) {\n      this.saveMessages([message], {storage, isScheduled: true, isOutgoing: true});\n      setTimeout(() => {\n        rootScope.dispatchEvent('scheduled_new', {peerId, mid: messageId});\n      }, 0);\n    } else {\n      /* if(options.threadId && this.threadsStorage[peerId]) {\n        delete this.threadsStorage[peerId][options.threadId];\n      } */\n      const storages: HistoryStorage[] = [\n        this.getHistoryStorage(peerId),\n        options.threadId ? this.getHistoryStorage(peerId, options.threadId) : undefined\n      ];\n\n      for(const storage of storages) {\n        if(storage) {\n          storage.history.unshift(messageId);\n        }\n      }\n\n      //if(!options.isGroupedItem) {\n      this.saveMessages([message], {storage, isOutgoing: true});\n      setTimeout(() => {\n        this.setDialogTopMessage(message);\n        rootScope.dispatchEvent('history_append', {storage, peerId, mid: messageId});\n      }, 0);\n    }\n\n    if(!options.isGroupedItem && options.clearDraft) {\n      if(options.threadId) {\n        appDraftsManager.syncDraft(peerId, options.threadId);\n      } else {\n        appDraftsManager.saveDraft(peerId, options.threadId, null, {notify: true});  \n      }\n    }\n    \n    this.pendingByRandomId[message.random_id] = {\n      peerId, \n      tempId: messageId, \n      threadId: options.threadId, \n      storage\n    };\n\n    if(!options.isGroupedItem && message.send) {\n      setTimeout(message.send, 0);\n      //setTimeout(message.send, 4000);\n      //setTimeout(message.send, 7000);\n    }\n  }\n\n  private generateOutgoingMessage(peerId: number, options: Partial<{\n    scheduleDate: number,\n    replyToMsgId: number,\n    threadId: number,\n    viaBotId: number,\n    groupId: string,\n    reply_markup: any,\n  }>) {\n    if(options.threadId && !options.replyToMsgId) {\n      options.replyToMsgId = options.threadId;\n    }\n\n    const message: any = {\n      _: 'message',\n      id: this.generateTempMessageId(peerId),\n      from_id: this.generateFromId(peerId),\n      peer_id: appPeersManager.getOutputPeer(peerId),\n      pFlags: this.generateFlags(peerId),\n      date: options.scheduleDate || (tsNow(true) + serverTimeManager.serverTimeOffset),\n      message: '',\n      grouped_id: options.groupId,\n      random_id: randomLong(),\n      reply_to: this.generateReplyHeader(options.replyToMsgId, options.threadId),\n      via_bot_id: options.viaBotId,\n      reply_markup: options.reply_markup,\n      replies: this.generateReplies(peerId),\n      views: appPeersManager.isBroadcast(peerId) && 1,\n      pending: true,\n    };\n\n    return message;\n  }\n\n  private generateReplyHeader(replyToMsgId: number, replyToTopId?: number) {\n    const header = {\n      _: 'messageReplyHeader',\n      reply_to_msg_id: replyToMsgId || replyToTopId,\n    } as MessageReplyHeader;\n\n    if(replyToTopId && header.reply_to_msg_id !== replyToTopId) {\n      header.reply_to_top_id = replyToTopId;\n    }\n\n    return header;\n  }\n\n  private generateReplies(peerId: number) {\n    let replies: MessageReplies.messageReplies;\n    if(appPeersManager.isBroadcast(peerId)) {\n      const channelFull = appProfileManager.chatsFull[-peerId] as ChatFull.channelFull;\n      if(channelFull?.linked_chat_id) {\n        replies = {\n          _: 'messageReplies',\n          flags: 1,\n          pFlags: {\n            comments: true\n          },\n          channel_id: channelFull.linked_chat_id,\n          replies: 0,\n          replies_pts: 0\n        };\n      }\n    }\n\n    return replies;\n  }\n\n  /**\n   * Generate correct from_id according to anonymous or broadcast\n   */\n  private generateFromId(peerId: number) {\n    if(peerId < 0 && (appPeersManager.isBroadcast(peerId) || appPeersManager.getPeer(peerId).admin_rights?.pFlags?.anonymous)) {\n      return undefined;\n    } else {\n      return appPeersManager.getOutputPeer(appUsersManager.getSelf().id);\n    }\n  }\n\n  private generateFlags(peerId: number) {\n    const pFlags: any = {};\n    const fromId = appUsersManager.getSelf().id;\n    if(peerId !== fromId) {\n      pFlags.out = true;\n\n      if(!appPeersManager.isChannel(peerId) && !appUsersManager.isBot(peerId)) {\n        pFlags.unread = true;\n      }\n    }\n\n    if(appPeersManager.isBroadcast(peerId)) {\n      pFlags.post = true;\n    }\n\n    return pFlags;\n  }\n\n  private generateForwardHeader(peerId: number, originalMessage: Message.message) {\n    const myId = appUsersManager.getSelf().id;\n    if(originalMessage.fromId === myId && originalMessage.peerId === myId && !originalMessage.fwd_from) {\n      return;\n    }\n\n    const fwdHeader: MessageFwdHeader.messageFwdHeader = {\n      _: 'messageFwdHeader',\n      flags: 0,\n      date: originalMessage.date\n    };\n\n    if(originalMessage.fwd_from) {\n      fwdHeader.from_id = originalMessage.fwd_from.from_id;\n      fwdHeader.from_name = originalMessage.fwd_from.from_name;\n      fwdHeader.post_author = originalMessage.fwd_from.post_author;\n    } else {\n      fwdHeader.from_id = appPeersManager.getOutputPeer(originalMessage.fromId);\n      fwdHeader.post_author = originalMessage.post_author;\n    }\n\n    if(appPeersManager.isBroadcast(originalMessage.peerId)) {\n      if(originalMessage.post_author) {\n        fwdHeader.post_author = originalMessage.post_author;\n      }\n\n      fwdHeader.channel_post = originalMessage.id;\n    }\n    \n    // * there is no way to detect whether user profile is hidden\n    if(peerId === myId) {\n      fwdHeader.saved_from_msg_id = originalMessage.id;\n      fwdHeader.saved_from_peer = appPeersManager.getOutputPeer(originalMessage.peerId);\n    }\n\n    return fwdHeader;\n  }\n\n  public generateFakeAvatarMessage(peerId: number, photo: Photo) {\n    const maxId = Number.MAX_SAFE_INTEGER;\n    const message = {\n      _: 'messageService',\n      action: {\n        _: 'messageActionChannelEditPhoto',\n        photo\n      },\n      mid: maxId,\n      peerId,\n      date: (photo as Photo.photo).date,\n      fromId: peerId\n    } as Message.messageService;\n\n    this.getMessagesStorage(peerId)[maxId] = message;\n    return message;\n  }\n\n  public setDialogTopMessage(message: MyMessage, dialog: MTDialog.dialog = this.getDialogOnly(message.peerId)) {\n    if(dialog) {\n      dialog.top_message = message.mid;\n      \n      const historyStorage = this.getHistoryStorage(message.peerId);\n      historyStorage.maxId = message.mid;\n\n      this.dialogsStorage.generateIndexForDialog(dialog, false, message);\n\n      this.scheduleHandleNewDialogs(message.peerId, dialog);\n    }\n  }\n\n  public cancelPendingMessage(randomId: string) {\n    const pendingData = this.pendingByRandomId[randomId];\n\n    /* if(DEBUG) {\n      this.log('cancelPendingMessage', randomId, pendingData);\n    } */\n\n    if(pendingData) {\n      const {peerId, tempId, storage} = pendingData;\n      const historyStorage = this.getHistoryStorage(peerId);\n\n      apiUpdatesManager.processLocalUpdate({\n        _: 'updateDeleteMessages',\n        messages: [tempId],\n        pts: undefined,\n        pts_count: undefined\n      });\n\n      historyStorage.history.delete(tempId);\n\n      delete this.pendingByRandomId[randomId];\n      delete storage[tempId];\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public async refreshConversations() {\n    const limit = 200, outDialogs: Dialog[] = [];\n    for(let folderId = 0; folderId < 2; ++folderId) {\n      let offsetDate = 0;\n      for(;;) {\n        const {dialogs, isEnd} = await this.getTopMessages(limit, folderId, offsetDate);\n  \n        if(dialogs.length) {\n          outDialogs.push(...dialogs as Dialog[]);\n          const dialog = dialogs[dialogs.length - 1];\n\n          // * get peerId and mid manually, because dialog can be migrated peer and it won't be saved\n          const peerId = appPeersManager.getPeerId(dialog.peer);\n          const mid = this.generateMessageId(dialog.top_message);\n          offsetDate = this.getMessageByPeer(peerId, mid).date;\n\n          if(!offsetDate) {\n            console.error('refreshConversations: got no offsetDate', dialog);\n            break;\n          }\n        }\n        \n        if(isEnd) {\n          break;\n        }\n      }\n    }\n\n    let obj: {[peerId: string]: Dialog} = {};\n    outDialogs.forEach(dialog => {\n      obj[dialog.peerId] = dialog;\n    });\n    rootScope.dispatchEvent('dialogs_multiupdate', obj);\n\n    return outDialogs;\n  }\n\n  public async getConversationsAll(query = '', folderId = 0) {\n    const limit = 200, outDialogs: Dialog[] = [];\n    for(; folderId < 2; ++folderId) {\n      let offsetIndex = 0;\n      for(;;) {\n        const {dialogs} = await appMessagesManager.getConversations(query, offsetIndex, limit, folderId);\n  \n        if(dialogs.length) {\n          outDialogs.push(...dialogs);\n          offsetIndex = dialogs[dialogs.length - 1].index || 0;\n        } else {\n          break;\n        }\n      }\n    }\n\n    return outDialogs;\n  }\n\n  public getConversations(query = '', offsetIndex?: number, limit = 20, folderId = 0) {\n    return this.dialogsStorage.getDialogs(query, offsetIndex, limit, folderId);\n  }\n\n  public getReadMaxIdIfUnread(peerId: number, threadId?: number) {\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\n    if(threadId) {\n      const chatHistoryStorage = this.getHistoryStorage(peerId);\n      const readMaxId = Math.max(chatHistoryStorage.readMaxId ?? 0, historyStorage.readMaxId);\n      const message = this.getMessageByPeer(peerId, historyStorage.maxId); // usually message is missing, so pFlags.out won't be there anyway\n      return !message.pFlags.out && readMaxId < historyStorage.maxId ? readMaxId : 0;\n    } else {\n      const message = this.getMessageByPeer(peerId, historyStorage.maxId);\n      const readMaxId = peerId > 0 ? Math.max(historyStorage.readMaxId, historyStorage.readOutboxMaxId) : historyStorage.readMaxId;\n      return !message.pFlags.out && readMaxId < historyStorage.maxId ? readMaxId : 0;\n    }\n  }\n\n  // public lolSet = new Set();\n  public getTopMessages(limit: number, folderId: number, offsetDate?: number) {\n    //const dialogs = this.dialogsStorage.getFolder(folderId);\n    let offsetId = 0;\n    let offsetPeerId = 0;\n    let offsetIndex = 0;\n\n    if(offsetDate === undefined) {\n      offsetDate = this.dialogsStorage.getOffsetDate(folderId);\n    }\n\n    if(offsetDate) {\n      offsetIndex = offsetDate * 0x10000;\n      offsetDate += serverTimeManager.serverTimeOffset;\n    }\n\n    const middleware = this.middleware.get();\n\n    // ! \u0412\u041d\u0418\u041c\u0410\u041d\u0418\u0415: \u041e\u0427\u0415\u041d\u042c \u0421\u041b\u041e\u0416\u041d\u0410\u042f \u041b\u041e\u0413\u0418\u041a\u0410:\n    // ! \u0435\u0441\u043b\u0438 \u0434\u0435\u043b\u0430\u0442\u044c \u0437\u0430\u043f\u0440\u043e\u0441 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u043f\u043e \u043f\u0430\u043f\u043a\u0435 0, \u043f\u043e\u0442\u043e\u043c \u043f\u043e \u043f\u0430\u043f\u043a\u0435 1, \u043f\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0443 0 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\u0435 \u0431\u0443\u0434\u0435\u0442 \u043e\u0434\u0438\u043d \u0438 \u0442\u043e\u0442 \u0436\u0435 \u0434\u0438\u0430\u043b\u043e\u0433, \u0441 dialog.pFlags.pinned, \u041b\u041e\u041b???\n    // ! \u0442.\u0435., \u0441 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u043c folder_id: 1, \u0438 exclude_pinned: 0, \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0435 \u0431\u0443\u0434\u0443\u0442 \u0435\u0449\u0451 \u0438 \u0437\u0430\u043a\u0440\u0435\u043f\u043b\u0451\u043d\u043d\u044b\u0435 \u0441 \u043f\u0430\u043f\u043a\u0438 0\n    return apiManager.invokeApiSingle('messages.getDialogs', {\n      folder_id: folderId,\n      offset_date: offsetDate,\n      offset_id: offsetId,\n      offset_peer: appPeersManager.getInputPeerById(offsetPeerId),\n      limit,\n      hash: 0\n    }, {\n      //timeout: APITIMEOUT,\n      noErrorBox: true\n    }).then((dialogsResult) => {\n      if(!middleware() || dialogsResult._ === 'messages.dialogsNotModified') return null;\n\n      if(DEBUG) {\n        this.log('messages.getDialogs result:', dialogsResult.dialogs, {...dialogsResult.dialogs[0]});\n      }\n\n      /* if(!offsetDate) {\n        telegramMeWebService.setAuthorized(true);\n      } */\n\n      // can reset pinned order here\n      if(!offsetId && !offsetDate && !offsetPeerId) {\n        this.dialogsStorage.resetPinnedOrder(folderId);\n      }\n\n      if(!offsetDate) {\n        telegramMeWebManager.setAuthorized(true);\n      }\n\n      appUsersManager.saveApiUsers(dialogsResult.users);\n      appChatsManager.saveApiChats(dialogsResult.chats);\n      this.saveMessages(dialogsResult.messages);\n\n      let maxSeenIdIncremented = offsetDate ? true : false;\n      let hasPrepend = false;\n      const noIdsDialogs: {[peerId: number]: Dialog} = {};\n      forEachReverse((dialogsResult.dialogs as Dialog[]), dialog => {\n        //const d = Object.assign({}, dialog);\n        // ! \u043d\u0443\u0436\u043d\u043e \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0442\u044c folderId, \u0442\u0430\u043a \u043a\u0430\u043a \u043f\u043e \u043f\u0430\u043f\u043a\u0435 !== 0 \u043d\u0435\u0442 \u0441\u0432\u043e\u0439\u0441\u0442\u0432\u0430 folder_id\n        this.dialogsStorage.saveDialog(dialog, dialog.folder_id ?? folderId, true);\n\n        if(!maxSeenIdIncremented &&\n          !appPeersManager.isChannel(dialog.peerId || appPeersManager.getPeerId(dialog.peer))) {\n          this.incrementMaxSeenId(dialog.top_message);\n          maxSeenIdIncremented = true;\n        }\n\n        if(dialog.peerId === undefined) {\n          return;\n        }\n\n        // if(!folderId && !dialog.folder_id) {\n        //   this.lolSet.add(dialog.peerId);\n        // }\n\n        /* if(dialog.peerId === -1213511294) {\n          this.log.error('lun bot', folderId, d);\n        } */\n\n        if(offsetIndex && dialog.index > offsetIndex) {\n          this.scheduleHandleNewDialogs(dialog.peerId, dialog);\n          hasPrepend = true;\n        }\n\n        // ! \u044d\u0442\u043e \u043c\u043e\u0436\u0435\u0442 \u0441\u043b\u0443\u0447\u0438\u0442\u044c\u0441\u044f, \u0435\u0441\u043b\u0438 \u0437\u0430\u043f\u0440\u043e\u0441 \u0438\u0434\u0451\u0442 \u043d\u0435 \u043f\u043e \u043f\u0430\u043f\u043a\u0435 0, \u0430 \u043f\u043e 1. \u043f\u043e\u0447\u0435\u043c\u0443-\u0442\u043e read'\u043e\u0432 \u043d\u0435\u0442\n        // ! \u0432 \u0438\u0442\u043e\u0433\u0435, \u0447\u0442\u043e\u0431\u044b \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c 1 \u0434\u0438\u0430\u043b\u043e\u0433, \u0434\u0435\u043b\u0430\u0435\u0442\u0441\u044f \u043f\u0435\u0440\u0432\u044b\u0439 \u0437\u0430\u043f\u0440\u043e\u0441 \u043f\u043e \u043f\u0430\u043f\u043a\u0435 0, \u043f\u043e\u0442\u043e\u043c \u0437\u0430\u043f\u0440\u043e\u0441 \u0434\u043b\u044f \u0430\u0440\u0445\u0438\u0432\u043d\u044b\u0445 \u043f\u043e \u043f\u0430\u043f\u043a\u0435 1, \u0438 \u043f\u043e\u0442\u043e\u043c \u0435\u0449\u0451 \u043f\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u0430\u0440\u0445\u0438\u0432\u043d\u043e\u0433\u043e \u0434\u0438\u0430\u043b\u043e\u0433\u0430\n        if(!this.getServerMessageId(dialog.read_inbox_max_id) && !this.getServerMessageId(dialog.read_outbox_max_id)) {\n          noIdsDialogs[dialog.peerId] = dialog;\n\n          this.log.error('noIdsDialogs', dialog);\n\n          /* if(dialog.peerId === -1213511294) {\n            this.log.error('lun bot', folderId);\n          } */\n        }\n      });\n\n      if(Object.keys(noIdsDialogs).length) {\n        //setTimeout(() => { // test bad situation\n          this.reloadConversation(Object.keys(noIdsDialogs).map(id => +id)).then(() => {\n            rootScope.dispatchEvent('dialogs_multiupdate', noIdsDialogs);\n  \n            for(let peerId in noIdsDialogs) {\n              rootScope.dispatchEvent('dialog_unread', {peerId: +peerId});\n            }\n          });\n        //}, 10e3);\n      }\n\n      const count = (dialogsResult as MessagesDialogs.messagesDialogsSlice).count;\n\n      // exclude empty draft dialogs\n      const dialogs = this.dialogsStorage.getFolder(folderId, false);\n      let dialogsLength = 0;\n      for(let i = 0, length = dialogs.length; i < length; ++i) {\n        if(this.getServerMessageId(dialogs[i].top_message)) {\n          ++dialogsLength;\n        }\n      }\n\n      const isEnd = /* limit > dialogsResult.dialogs.length || */ \n        !count || \n        dialogsLength >= count ||\n        !dialogsResult.dialogs.length;\n      if(isEnd) {\n        this.dialogsStorage.setDialogsLoaded(folderId, true);\n      }\n\n      if(hasPrepend) {\n        this.scheduleHandleNewDialogs();\n      } else {\n        rootScope.dispatchEvent('dialogs_multiupdate', {});\n      }\n\n      return {\n        isEnd, \n        count, \n        dialogs: (dialogsResult as MessagesDialogs.messagesDialogsSlice).dialogs\n      };\n    });\n  }\n\n  public forwardMessages(peerId: number, fromPeerId: number, mids: number[], options: Partial<{\n    withMyScore: true,\n    silent: true,\n    scheduleDate: number\n  }> = {}) {\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\n    mids = mids.slice().sort((a, b) => a - b);\n\n    const groups: {\n      [groupId: string]: {\n        tempId: string,\n        messages: any[]\n      }\n    } = {};\n\n    const newMessages = mids.map(mid => {\n      const originalMessage: Message.message = this.getMessageByPeer(fromPeerId, mid);\n      const message: Message.message = this.generateOutgoingMessage(peerId, options);\n      message.fwd_from = this.generateForwardHeader(peerId, originalMessage);\n\n      (['entities', 'forwards', 'message', 'media', 'reply_markup', 'views'] as any as Array<keyof MyMessage>).forEach(key => {\n        // @ts-ignore\n        message[key] = originalMessage[key];\n      });\n\n      const document = (message.media as MessageMedia.messageMediaDocument)?.document as MyDocument;\n      if(document) {\n        const types: MyDocument['type'][] = ['round', 'voice'];\n        if(types.includes(document.type)) {\n          (message as MyMessage).pFlags.media_unread = true;\n        }\n      }\n\n      if(originalMessage.grouped_id) {\n        const group = groups[originalMessage.grouped_id] ?? (groups[originalMessage.grouped_id] = {tempId: '' + ++this.groupedTempId, messages: []});\n        group.messages.push(message);\n      }\n\n      return message;\n    });\n\n    for(const groupId in groups) {\n      const group = groups[groupId];\n      if(group.messages.length > 1) {\n        group.messages.forEach(message => {\n          message.grouped_id = group.tempId;\n        });\n      }\n    }\n\n    newMessages.forEach(message => {\n      this.beforeMessageSending(message, {\n        isScheduled: !!options.scheduleDate || undefined\n      });\n    });\n\n    const sentRequestOptions: PendingAfterMsg = {};\n    if(this.pendingAfterMsgs[peerId]) {\n      sentRequestOptions.afterMessageId = this.pendingAfterMsgs[peerId].messageId;\n    }\n\n    const promise = /* true ? Promise.resolve() :  */apiManager.invokeApiAfter('messages.forwardMessages', {\n      from_peer: appPeersManager.getInputPeerById(fromPeerId),\n      id: mids.map(mid => this.getServerMessageId(mid)),\n      random_id: newMessages.map(message => message.random_id),\n      to_peer: appPeersManager.getInputPeerById(peerId),\n      with_my_score: options.withMyScore,\n      silent: options.silent,\n      schedule_date: options.scheduleDate\n    }, sentRequestOptions).then((updates) => {\n      this.log('forwardMessages updates:', updates);\n      apiUpdatesManager.processUpdateMessage(updates);\n    }).finally(() => {\n      if(this.pendingAfterMsgs[peerId] === sentRequestOptions) {\n        delete this.pendingAfterMsgs[peerId];\n      }\n    });\n\n    this.pendingAfterMsgs[peerId] = sentRequestOptions;\n    return promise;\n  }\n\n  public getMessageFromStorage(storage: MessagesStorage, messageId: number) {\n    return storage && storage[messageId] || {\n      _: 'messageEmpty',\n      id: messageId,\n      deleted: true,\n      pFlags: {}\n    };\n  }\n\n  private createMessageStorage() {\n    const storage: MessagesStorage = {} as any;\n    \n    /* let num = 0;\n    Object.defineProperty(storage, 'num', {\n      get: () => ++num,\n      set: (_num: number) => num = _num, \n      enumerable: false\n    });\n\n    Object.defineProperty(storage, 'generateIndex', {\n      value: (message: any) => {\n        if(message.index === undefined) {\n          message.index = (message.date * 0x10000) + (storage.num & 0xFFFF);\n        }\n      },\n      enumerable: false\n    }); */\n\n    return storage;\n  }\n\n  public getMessagesStorage(peerId: number) {\n    return this.messagesStorageByPeerId[peerId] ?? (this.messagesStorageByPeerId[peerId] = this.createMessageStorage());\n  }\n\n  public getMessageById(messageId: number) {\n    for(const peerId in this.messagesStorageByPeerId) {\n      if(appPeersManager.isChannel(+peerId)) {\n        continue;\n      }\n\n      const message = this.messagesStorageByPeerId[peerId][messageId];\n      if(message) {\n        return message;\n      }\n    }\n\n    return this.getMessageFromStorage(null, messageId);\n  }\n\n  public getMessageByPeer(peerId: number, messageId: number) {\n    if(!peerId) {\n      return this.getMessageById(messageId);\n    }\n\n    return this.getMessageFromStorage(this.getMessagesStorage(peerId), messageId);\n  }\n\n  public getMessagePeer(message: any): number {\n    const toId = message.peer_id && appPeersManager.getPeerId(message.peer_id) || 0;\n\n    return toId;\n  }\n\n  public getDialogByPeerId(peerId: number): [Dialog, number] | [] {\n    return this.dialogsStorage.getDialog(peerId);\n  }\n\n  public getDialogOnly(peerId: number) {\n    return this.dialogsStorage.getDialogOnly(peerId);\n  }\n\n  public reloadConversation(peerId?: number | number[]) {\n    if(peerId !== undefined) {\n      [].concat(peerId).forEach(peerId => {\n        if(!this.reloadConversationsPeers.has(peerId)) {\n          this.reloadConversationsPeers.add(peerId);\n          //this.log('will reloadConversation', peerId);\n        }\n      });\n    }\n\n    if(this.reloadConversationsPromise) return this.reloadConversationsPromise;\n    return this.reloadConversationsPromise = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        const peers = Array.from(this.reloadConversationsPeers).map(peerId => appPeersManager.getInputDialogPeerById(peerId));\n        this.reloadConversationsPeers.clear();\n\n        apiManager.invokeApi('messages.getPeerDialogs', {peers}).then((result) => {\n          this.dialogsStorage.applyDialogs(result);\n          resolve();\n        }, reject).finally(() => {\n          this.reloadConversationsPromise = null;\n\n          if(this.reloadConversationsPeers.size) {\n            this.reloadConversation();\n          }\n        });\n      }, 0);\n    });\n  }\n\n  private doFlushHistory(peer: InputPeer, just_clear?: boolean, revoke?: boolean): Promise<true> {\n    return apiManager.invokeApiSingle('messages.deleteHistory', {\n      just_clear,\n      revoke,\n      peer,\n      max_id: 0\n    }).then((affectedHistory) => {\n      apiUpdatesManager.processUpdateMessage({\n        _: 'updateShort',\n        update: {\n          _: 'updatePts',\n          pts: affectedHistory.pts,\n          pts_count: affectedHistory.pts_count\n        }\n      });\n\n      if(!affectedHistory.offset) {\n        return true;\n      }\n\n      return this.doFlushHistory(peer, just_clear, revoke);\n    });\n  }\n\n  public async flushHistory(peerId: number, justClear?: boolean, revoke?: boolean) {\n    if(appPeersManager.isChannel(peerId)) {\n      const promise = this.getHistory(peerId, 0, 1);\n\n      const historyResult = promise instanceof Promise ? await promise : promise;\n\n      const channelId = -peerId;\n      const maxId = historyResult.history[0] || 0;\n      return apiManager.invokeApiSingle('channels.deleteHistory', {\n        channel: appChatsManager.getChannelInput(channelId),\n        max_id: this.getServerMessageId(maxId)\n      }).then(() => {\n        apiUpdatesManager.processLocalUpdate({\n          _: 'updateChannelAvailableMessages',\n          channel_id: channelId,\n          available_min_id: maxId\n        });\n\n        return true;\n      });\n    }\n\n    return this.doFlushHistory(appPeersManager.getInputPeerById(peerId), justClear, revoke).then(() => {\n      delete this.historiesStorage[peerId];\n      delete this.messagesStorageByPeerId[peerId];\n      delete this.scheduledMessagesStorage[peerId];\n      delete this.threadsStorage[peerId];\n      delete this.searchesStorage[peerId];\n      delete this.pinnedMessages[peerId];\n      delete this.pendingAfterMsgs[peerId];\n      delete this.pendingTopMsgs[peerId];\n      delete this.needSingleMessages[peerId];\n      \n      if(justClear) {\n        rootScope.dispatchEvent('dialog_flush', {peerId});\n      } else {\n        delete this.notificationsToHandle[peerId];\n        delete this.typings[peerId];\n        this.reloadConversationsPeers.delete(peerId);\n\n        this.dialogsStorage.dropDialog(peerId);\n        rootScope.dispatchEvent('dialog_drop', {peerId});\n      }\n    });\n  }\n\n  public hidePinnedMessages(peerId: number) {\n    return Promise.all([\n      appStateManager.getState(),\n      this.getPinnedMessage(peerId)\n    ])\n    .then(([state, pinned]) => {\n      state.hiddenPinnedMessages[peerId] = pinned.maxId;\n      rootScope.dispatchEvent('peer_pinned_hidden', {peerId, maxId: pinned.maxId});\n    });\n  }\n\n  public getPinnedMessage(peerId: number) {\n    const p = this.pinnedMessages[peerId] ?? (this.pinnedMessages[peerId] = {});\n    if(p.promise) return p.promise;\n    else if(p.maxId) return Promise.resolve(p);\n\n    return p.promise = this.getSearch({\n      peerId, \n      inputFilter: {_: 'inputMessagesFilterPinned'},\n      maxId: 0,\n      limit: 1\n    }).then(result => {\n      p.count = result.count;\n      p.maxId = result.history[0]?.mid;\n      return p;\n    }).finally(() => {\n      delete p.promise;\n    });\n  }\n\n  public updatePinnedMessage(peerId: number, mid: number, unpin?: boolean, silent?: boolean, pm_oneside?: boolean) {\n    return apiManager.invokeApi('messages.updatePinnedMessage', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      unpin,\n      silent,\n      pm_oneside,\n      id: this.getServerMessageId(mid)\n    }).then(updates => {\n      //this.log('pinned updates:', updates);\n      apiUpdatesManager.processUpdateMessage(updates);\n    });\n  }\n\n  public unpinAllMessages(peerId: number): Promise<boolean> {\n    return apiManager.invokeApiSingle('messages.unpinAllMessages', {\n      peer: appPeersManager.getInputPeerById(peerId)\n    }).then(affectedHistory => {\n      apiUpdatesManager.processUpdateMessage({\n        _: 'updateShort',\n        update: {\n          _: 'updatePts',\n          pts: affectedHistory.pts,\n          pts_count: affectedHistory.pts_count\n        }\n      });\n\n      if(!affectedHistory.offset) {\n        const storage = this.getMessagesStorage(peerId);\n        for(const mid in storage) {\n          const message = storage[mid];\n          if(message.pFlags.pinned) {\n            delete message.pFlags.pinned;\n          }\n        }\n\n        rootScope.dispatchEvent('peer_pinned_messages', {peerId, unpinAll: true});\n        delete this.pinnedMessages[peerId];\n\n        return true;\n      }\n\n      return this.unpinAllMessages(peerId);\n    });\n  }\n\n  public getAlbumText(grouped_id: string) {\n    const group = this.groupedMessagesStorage[grouped_id];\n    let foundMessages = 0, message: string, totalEntities: MessageEntity[], entities: MessageEntity[];\n    for(const i in group) {\n      const m = group[i];\n      if(m.message) {\n        if(++foundMessages > 1) break;\n        message = m.message;\n        totalEntities = m.totalEntities;\n        entities = m.entities;\n      }  \n    }\n\n    if(foundMessages > 1) {\n      message = undefined;\n      totalEntities = undefined;\n      entities = undefined;\n    }\n\n    return {message, entities, totalEntities};\n  }\n\n  public getMidsByAlbum(grouped_id: string) {\n    return getObjectKeysAndSort(this.groupedMessagesStorage[grouped_id], 'asc');\n    //return Object.keys(this.groupedMessagesStorage[grouped_id]).map(id => +id).sort((a, b) => a - b);\n  }\n\n  public getMidsByMessage(message: any) {\n    if(message?.grouped_id) return this.getMidsByAlbum(message.grouped_id);\n    else return [message.mid];\n  }\n\n  public filterMessages(message: any, verify: (message: MyMessage) => boolean) {\n    const out: MyMessage[] = [];\n    if(message.grouped_id) {\n      const storage = this.groupedMessagesStorage[message.grouped_id];\n      for(const mid in storage) {\n        const message = storage[mid];\n        if(verify(message)) {\n          out.push(message);\n        }\n      }\n    } else {\n      if(verify(message)) {\n        out.push(message);\n      }\n    }\n\n    return out;\n  }\n\n  public generateTempMessageId(peerId: number) {\n    const dialog = this.getDialogOnly(peerId);\n    return this.generateMessageId(dialog?.top_message || 0, true);\n  }\n\n  public generateMessageId(messageId: number, temp = false) {\n    const q = AppMessagesManager.MESSAGE_ID_OFFSET;\n    const num = temp ? ++this.tempNum : 0;\n    if(messageId >= q) {\n      if(temp) {\n        return messageId + (num & (AppMessagesManager.MESSAGE_ID_INCREMENT - 1));\n      }\n\n      return messageId;\n    }\n\n    return q + (messageId * AppMessagesManager.MESSAGE_ID_INCREMENT + (num & (AppMessagesManager.MESSAGE_ID_INCREMENT - 1)));\n  }\n\n  /**\n   * * will ignore outgoing offset\n   */\n  public getServerMessageId(messageId: number) {\n    const q = AppMessagesManager.MESSAGE_ID_OFFSET;\n    if(messageId < q) { // id 0 -> mid 0xFFFFFFFF, so 0xFFFFFFFF must convert to 0\n      return messageId;\n    }\n\n    const l = AppMessagesManager.MESSAGE_ID_INCREMENT - 1;\n    const used = messageId & l;\n    if(used !== l) {\n      messageId -= used + 1;\n    }\n\n    return (messageId - q) / AppMessagesManager.MESSAGE_ID_INCREMENT;\n  }\n\n  public incrementMessageId(messageId: number, increment: number) {\n    return this.generateMessageId(this.getServerMessageId(messageId) + increment);\n  }\n\n  public saveMessages(messages: any[], options: Partial<{\n    storage: MessagesStorage,\n    isScheduled: true,\n    isOutgoing: true,\n    //isNew: boolean, // * new - from update\n  }> = {}) {\n    //let groups: Set<string>;\n    messages.forEach((message) => {\n      if(message.pFlags === undefined) {\n        message.pFlags = {};\n      }\n\n      if(message._ === 'messageEmpty') {\n        return;\n      }\n\n      // * exclude from state\n      // defineNotNumerableProperties(message, ['rReply', 'mid', 'savedFrom', 'fwdFromId', 'fromId', 'peerId', 'reply_to_mid', 'viaBotId']);\n\n      const peerId = this.getMessagePeer(message);\n      const storage = options.storage || this.getMessagesStorage(peerId);\n      const isChannel = message.peer_id._ === 'peerChannel';\n      const channelId = isChannel ? -peerId : 0;\n      const isBroadcast = isChannel && appChatsManager.isBroadcast(channelId);\n\n      if(options.isScheduled) {\n        message.pFlags.is_scheduled = true;\n      }\n\n      if(options.isOutgoing) {\n        message.pFlags.is_outgoing = true;\n      }\n      \n      const mid = this.generateMessageId(message.id);\n      message.mid = mid;\n\n      if(message.grouped_id) {\n        const storage = this.groupedMessagesStorage[message.grouped_id] ?? (this.groupedMessagesStorage[message.grouped_id] = {});\n        storage[mid] = message;\n      }\n\n      const dialog = this.getDialogOnly(peerId);\n      if(dialog && mid) {\n        if(mid > dialog[message.pFlags.out\n          ? 'read_outbox_max_id'\n          : 'read_inbox_max_id']) {\n          message.pFlags.unread = true;\n        }\n      }\n      // this.log(dT(), 'msg unread', mid, apiMessage.pFlags.out, dialog && dialog[apiMessage.pFlags.out ? 'read_outbox_max_id' : 'read_inbox_max_id'])\n\n      if(message.reply_to) {\n        if(message.reply_to.reply_to_msg_id) {\n          message.reply_to.reply_to_msg_id = message.reply_to_mid = this.generateMessageId(message.reply_to.reply_to_msg_id);\n        } \n\n        if(message.reply_to.reply_to_top_id) message.reply_to.reply_to_top_id = this.generateMessageId(message.reply_to.reply_to_top_id);\n      }\n\n      if(message.replies) {\n        if(message.replies.max_id) message.replies.max_id = this.generateMessageId(message.replies.max_id);\n        if(message.replies.read_max_id) message.replies.read_max_id = this.generateMessageId(message.replies.read_max_id);\n      }\n\n      const overwriting = !!peerId;\n      if(!overwriting) {\n        message.date -= serverTimeManager.serverTimeOffset;\n      }\n      \n      //storage.generateIndex(message);\n      const myId = appUsersManager.getSelf().id;\n\n      message.peerId = peerId;\n      if(peerId === myId/*  && !message.from_id && !message.fwd_from */) {\n        message.fromId = message.fwd_from ? (message.fwd_from.from_id ? appPeersManager.getPeerId(message.fwd_from.from_id) : 0) : myId;\n      } else {\n        //message.fromId = message.pFlags.post || (!message.pFlags.out && !message.from_id) ? peerId : appPeersManager.getPeerId(message.from_id);\n        message.fromId = message.pFlags.post || !message.from_id ? peerId : appPeersManager.getPeerId(message.from_id);\n      }\n\n      const fwdHeader = message.fwd_from as MessageFwdHeader;\n      if(fwdHeader) {\n        //if(peerId === myID) {\n          if(fwdHeader.saved_from_msg_id) fwdHeader.saved_from_msg_id = this.generateMessageId(fwdHeader.saved_from_msg_id);\n          if(fwdHeader.channel_post) fwdHeader.channel_post = this.generateMessageId(fwdHeader.channel_post);\n\n          const peer = fwdHeader.saved_from_peer || fwdHeader.from_id;\n          const msgId = fwdHeader.saved_from_msg_id || fwdHeader.channel_post;\n          if(peer && msgId) {\n            const savedFromPeerId = appPeersManager.getPeerId(peer);\n            const savedFromMid = this.generateMessageId(msgId);\n            message.savedFrom = savedFromPeerId + '_' + savedFromMid;\n          }\n\n          /* if(peerId < 0 || peerId === myID) {\n            message.fromId = appPeersManager.getPeerID(!message.from_id || deepEqual(message.from_id, fwdHeader.from_id) ? fwdHeader.from_id : message.from_id);\n          } */\n        /* } else {\n          apiMessage.fwdPostID = fwdHeader.channel_post;\n        } */\n\n        message.fwdFromId = appPeersManager.getPeerId(fwdHeader.from_id);\n\n        if(!overwriting) {\n          fwdHeader.date -= serverTimeManager.serverTimeOffset;\n        }\n      }\n\n      if(message.via_bot_id > 0) {\n        message.viaBotId = message.via_bot_id;\n      }\n\n      const mediaContext: ReferenceContext = {\n        type: 'message',\n        peerId,\n        messageId: mid\n      };\n\n      if(message.media) {\n        switch(message.media._) {\n          case 'messageMediaEmpty':\n            delete message.media;\n            break;\n          case 'messageMediaPhoto':\n            if(message.media.ttl_seconds) {\n              message.media = {_: 'messageMediaUnsupportedWeb'};\n            } else {\n              message.media.photo = appPhotosManager.savePhoto(message.media.photo, mediaContext);\n            }\n\n            if(!message.media.photo) { // * found this bug on test DC\n              delete message.media;\n            }\n            \n            break;\n          case 'messageMediaPoll':\n            message.media.poll = appPollsManager.savePoll(message.media.poll, message.media.results);\n            break;\n          case 'messageMediaDocument':\n            if(message.media.ttl_seconds) {\n              message.media = {_: 'messageMediaUnsupportedWeb'};\n            } else {\n              message.media.document = appDocsManager.saveDoc(message.media.document, mediaContext); // 11.04.2020 warning\n            }\n\n            break;\n          case 'messageMediaWebPage':\n            message.media.webpage = appWebPagesManager.saveWebPage(message.media.webpage, message.mid, mediaContext);\n            break;\n          /*case 'messageMediaGame':\n            AppGamesManager.saveGame(apiMessage.media.game, apiMessage.mid, mediaContext);\n            apiMessage.media.handleMessage = true;\n            break; */\n          case 'messageMediaInvoice':\n            message.media = {_: 'messageMediaUnsupportedWeb'};\n            break;\n        }\n      }\n\n      if(message.action) {\n        const action = message.action;\n        let migrateFrom: number;\n        let migrateTo: number;\n        const suffix = message.fromId === appUsersManager.getSelf().id ? 'You' : '';\n        switch(action._) {\n          //case 'messageActionChannelEditPhoto':\n          case 'messageActionChatEditPhoto':\n            action.photo = appPhotosManager.savePhoto(action.photo, mediaContext);\n            if(action.photo.video_sizes) {\n              action._ = isBroadcast ? 'messageActionChannelEditVideo' : 'messageActionChatEditVideo';\n            } else {\n              if(isBroadcast) { // ! messageActionChannelEditPhoto \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \u043f\u0440\u0438\u043d\u0446\u0438\u043f\u0435, \u044d\u0442\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0430.\n                action._ = 'messageActionChannelEditPhoto';\n              }\n            }\n            break;\n          \n          case 'messageActionGroupCall': {\n            //assumeType<MessageAction.messageActionGroupCall>(action);\n\n            let type: string;\n            if(action.duration === undefined) {\n              type = 'started';\n              if(peerId !== message.fromId) {\n                type += '_by' + suffix;\n              }\n            } else {\n              type = 'ended_by' + suffix;\n            }\n\n            action.type = type;\n\n            break;\n          }\n\n          case 'messageActionChatEditTitle':\n            /* if(options.isNew) {\n              const chat = appChatsManager.getChat(-peerId);\n              chat.title = action.title;\n              appChatsManager.saveApiChat(chat, true);\n            } */\n            \n            if(isBroadcast) {\n              action._ = 'messageActionChannelEditTitle';\n            }\n            break;\n\n          case 'messageActionChatDeletePhoto':\n            if(isBroadcast) {\n              action._ = 'messageActionChannelDeletePhoto';\n            }\n            break;\n\n          case 'messageActionChatAddUser':\n            if(action.users.length === 1) {\n              action.user_id = action.users[0];\n              if(message.fromId === action.user_id) {\n                if(isChannel) {\n                  action._ = 'messageActionChatJoined' + suffix;\n                } else {\n                  action._ = 'messageActionChatReturn' + suffix;\n                }\n              }\n            } else if(action.users.length > 1) {\n              action._ = 'messageActionChatAddUsers';\n            }\n            break;\n\n          case 'messageActionChatDeleteUser':\n            if(message.fromId === action.user_id) {\n              action._ = 'messageActionChatLeave' + suffix;\n            }\n            break;\n\n          case 'messageActionChannelMigrateFrom':\n            migrateFrom = -action.chat_id;\n            migrateTo = -channelId;\n            break\n\n          case 'messageActionChatMigrateTo':\n            migrateFrom = -channelId;\n            migrateTo = -action.channel_id;\n            break;\n\n          case 'messageActionHistoryClear':\n            //apiMessage.deleted = true;\n            message.clear_history = true;\n            delete message.pFlags.out;\n            delete message.pFlags.unread;\n            break;\n\n          case 'messageActionPhoneCall':\n            action.type = \n              (message.pFlags.out ? 'out_' : 'in_') +\n              (\n                action.reason._ === 'phoneCallDiscardReasonMissed' ||\n                action.reason._ === 'phoneCallDiscardReasonBusy'\n                   ? 'missed'\n                   : 'ok'\n              );\n            break;\n        }\n        \n        if(migrateFrom &&\n            migrateTo &&\n            !this.migratedFromTo[migrateFrom] &&\n            !this.migratedToFrom[migrateTo]) {\n          this.migrateChecks(migrateFrom, migrateTo);\n        }\n      }\n\n      /* if(message.grouped_id) {\n        if(!groups) {\n          groups = new Set();\n        }\n\n        groups.add(message.grouped_id);\n      } else {\n        message.rReply = this.getRichReplyText(message);\n      } */\n\n      if(message.message && message.message.length && !message.totalEntities) {\n        this.wrapMessageEntities(message);  \n      }\n\n      storage[mid] = message;\n    });\n\n    /* if(groups) {\n      for(const groupId of groups) {\n        const mids = this.groupedMessagesStorage[groupId];\n        for(const mid in mids) {\n          const message = this.groupedMessagesStorage[groupId][mid];\n          message.rReply = this.getRichReplyText(message);\n        }\n      }\n    } */\n  }\n\n  private wrapMessageEntities(message: any) {\n    const apiEntities = message.entities ? message.entities.slice() : [];\n    message.message = RichTextProcessor.fixEmoji(message.message, apiEntities);\n\n    const myEntities = RichTextProcessor.parseEntities(message.message);\n    message.totalEntities = RichTextProcessor.mergeEntities(apiEntities, myEntities); // ! only in this order, otherwise bold and emoji formatting won't work\n  }\n\n  public wrapMessageForReply(message: any, text: string, usingMids: number[], plain: true, highlightWord?: string): string;\n  public wrapMessageForReply(message: any, text?: string, usingMids?: number[], plain?: false, highlightWord?: string): DocumentFragment;\n  public wrapMessageForReply(message: any, text: string = message.message, usingMids?: number[], plain?: boolean, highlightWord?: string): DocumentFragment | string {\n    const parts: (HTMLElement | string)[] = [];\n\n    const addPart = (langKey: LangPackKey, part?: string | HTMLElement, text?: string) => {\n      if(langKey) {\n        part = plain ? I18n.format(langKey, true) : i18n(langKey);\n      }\n      \n      if(plain) {\n        parts.push(part);\n      } else {\n        const el = document.createElement('i');\n        if(typeof(part) === 'string') el.innerHTML = part;\n        else el.append(part);\n        parts.push(el);\n      }\n\n      if(text) {\n        parts.push(', ');\n      }\n    };\n\n    if(message.media) {\n      let usingFullAlbum = true;\n      if(message.grouped_id) {\n        if(usingMids) {\n          const mids = this.getMidsByMessage(message);\n          if(usingMids.length === mids.length) {\n            for(const mid of mids) {\n              if(!usingMids.includes(mid)) {\n                usingFullAlbum = false;\n                break;\n              }\n            }\n          } else {\n            usingFullAlbum = false;\n          }\n        }\n\n        if(usingFullAlbum) {\n          text = this.getAlbumText(message.grouped_id).message;\n          addPart('AttachAlbum', undefined, text);\n        }\n      } else {\n        usingFullAlbum = false;\n      }\n\n      if(!usingFullAlbum) {\n        const media = message.media;\n        switch(media._) {\n          case 'messageMediaPhoto':\n            addPart('AttachPhoto', undefined, message.message);\n            break;\n          case 'messageMediaDice':\n            addPart(undefined, plain ? media.emoticon : RichTextProcessor.wrapEmojiText(media.emoticon));\n            break;\n          case 'messageMediaVenue': {\n            const text = plain ? media.title : RichTextProcessor.wrapEmojiText(media.title);\n            addPart('AttachLocation', undefined, text);\n            parts.push(htmlToDocumentFragment(text) as any);\n            break;\n          }\n          case 'messageMediaGeo':\n            addPart('AttachLocation');\n            break;\n          case 'messageMediaGeoLive':\n            addPart('AttachLiveLocation');\n            break;\n          case 'messageMediaPoll':\n            addPart(undefined, plain ? '\ud83d\udcca' + ' ' + (media.poll.question || 'poll') : media.poll.rReply);\n            break;\n          case 'messageMediaContact':\n            addPart('AttachContact');\n            break;\n          case 'messageMediaGame': {\n            const prefix = '\ud83c\udfae' + ' ';\n            addPart(undefined, plain ? prefix + media.game.title : RichTextProcessor.wrapEmojiText(prefix + media.game.title));\n            break;\n          }\n          case 'messageMediaDocument':\n            let document = media.document;\n  \n            if(document.type === 'video') {\n              addPart('AttachVideo', undefined, message.message);\n            } else if(document.type === 'voice') {\n              addPart('AttachAudio', undefined, message.message);\n            } else if(document.type === 'gif') {\n              addPart('AttachGif', undefined, message.message);\n            } else if(document.type === 'round') {\n              addPart('AttachRound', undefined, message.message);\n            } else if(document.type === 'sticker') {\n              addPart(undefined, ((plain ? document.stickerEmojiRaw : document.stickerEmoji) || '') + 'Sticker');\n              text = '';\n            } else {\n              addPart(document.file_name, undefined, message.message);\n            }\n  \n            break;\n  \n          default:\n            //messageText += media._;\n            ///////this.log.warn('Got unknown media type!', message);\n            break;\n        }\n      } \n    }\n\n    if(message.action) {\n      const actionWrapped = this.wrapMessageActionTextNew(message, plain);\n      if(actionWrapped) {\n        addPart(undefined, actionWrapped);\n      }\n    }\n\n    if(text) {\n      text = limitSymbols(text, 100);\n\n      if(plain) {\n        parts.push(text);\n      } else {\n        let entities = RichTextProcessor.parseEntities(text.replace(/\\n/g, ' '));\n\n        if(highlightWord) {\n          highlightWord = highlightWord.trim();\n          if(!entities) entities = [];\n          let found = false;\n          let match: any;\n          let regExp = new RegExp(escapeRegExp(highlightWord), 'gi');\n          while((match = regExp.exec(text)) !== null) {\n            entities.push({_: 'messageEntityHighlight', length: highlightWord.length, offset: match.index});\n            found = true;\n          }\n      \n          if(found) {\n            entities.sort((a, b) => a.offset - b.offset);\n          }\n        }\n\n        const messageWrapped = RichTextProcessor.wrapRichText(text, {\n          noLinebreaks: true, \n          entities, \n          noLinks: true,\n          noTextFormat: true\n        });\n  \n        parts.push(htmlToDocumentFragment(messageWrapped) as any);\n      }\n    }\n\n    if(plain) {\n      return parts.join('');\n    } else {\n      const fragment = document.createDocumentFragment();\n      fragment.append(...parts);\n      return fragment;\n    }\n  }\n\n  public getSenderToPeerText(message: MyMessage) {\n    let senderTitle = '', peerTitle: string;\n    \n    senderTitle = message.pFlags.out ? 'You' : appPeersManager.getPeerTitle(message.fromId, false, false);\n    peerTitle = appPeersManager.isAnyGroup(message.peerId) || (message.pFlags.out && message.peerId !== rootScope.myId) ? \n      appPeersManager.getPeerTitle(message.peerId, false, false) : \n      '';\n\n    if(peerTitle) {\n      senderTitle += ' \u279d ' + peerTitle;\n    }\n\n    return senderTitle;\n  }\n\n  public wrapMessageActionTextNew(message: any, plain: true): string;\n  public wrapMessageActionTextNew(message: any, plain?: false): HTMLElement;\n  public wrapMessageActionTextNew(message: any, plain: boolean): HTMLElement | string;\n  public wrapMessageActionTextNew(message: any, plain?: boolean): HTMLElement | string {\n    const element: HTMLElement = plain ? undefined : document.createElement('span');\n    const action = message.action as MessageAction;\n\n    // this.log('message action:', action);\n\n    if((action as MessageAction.messageActionCustomAction).message) {\n      if(plain) {\n        return RichTextProcessor.wrapPlainText(message.message);\n      } else {\n        element.innerHTML = RichTextProcessor.wrapRichText((action as MessageAction.messageActionCustomAction).message, {noLinebreaks: true});\n        return element;\n      }\n    } else {\n      let _ = action._;\n      //let suffix = '';\n      let langPackKey: LangPackKey;\n      let args: any[];\n\n      const getNameDivHTML = (peerId: number, plain: boolean) => {\n        return plain ? appPeersManager.getPeerTitle(peerId, plain) + ' ' : (new PeerTitle({peerId})).element;\n      };\n\n      switch(action._) {\n        case 'messageActionPhoneCall': {\n          _ += '.' + (action as any).type;\n\n          args = [formatCallDuration(action.duration)];\n          break;\n        }\n\n        case 'messageActionGroupCall': {\n          _ += '.' + (action as any).type;\n\n          args = [];\n          if(!_.endsWith('You')) {\n            args.push(getNameDivHTML(message.fromId, plain));\n          }\n\n          args.push(formatCallDuration(action.duration));\n          break;\n        }\n\n        case 'messageActionInviteToGroupCall': {\n          const peerIds = [message.fromId, action.users[0]];\n          let a = 'ActionGroupCall';\n          const myId = appUsersManager.getSelf().id;\n          if(peerIds[0] === myId) a += 'You';\n          a += 'Invited';\n          if(peerIds[1] === myId) a += 'You';\n          peerIds.findAndSplice(peerId => peerId === myId);\n\n          langPackKey = a as LangPackKey;\n          args = peerIds.map(peerId => getNameDivHTML(peerId, plain));\n          break;\n        }\n\n        case 'messageActionGroupCallScheduled': {\n          const today = new Date();\n          const date = new Date(action.schedule_date * 1000);\n          const daysToStart = (date.getTime() - today.getTime()) / 86400e3;\n          const tomorrowDate = new Date(today);\n          tomorrowDate.setDate(tomorrowDate.getDate() + 1);\n\n          langPackKey = 'ChatList.Service.VoiceChatScheduled';\n          const myId = appUsersManager.getSelf().id;\n          if(message.fromId === myId) {\n            langPackKey += 'You';\n          }\n\n          let k: LangPackKey, _args: any[] = [];\n          if(daysToStart < 1 && date.getDate() === today.getDate()) {\n            k = 'TodayAtFormattedWithToday';\n          } else if(daysToStart < 2 && date.getDate() === tomorrowDate.getDate()) {\n            k = 'Time.TomorrowAt';\n          } else {\n            k = 'formatDateAtTime';\n            _args.push(new I18n.IntlDateElement({\n              date, \n              options: {\n                day: '2-digit',\n                month: '2-digit',\n                year: '2-digit'\n              }\n            }).element);\n          }\n\n          _args.push(formatTime(date));\n          const t = i18n(k, _args);\n          args = [t];\n\n          break;\n        }\n\n        case 'messageActionChatCreate': {\n          const myId = appUsersManager.getSelf().id;\n          if(message.fromId === myId) {\n            _ += 'You';\n          } else {\n            args = [getNameDivHTML(message.fromId, plain)];\n          }\n          \n          break;\n        }\n\n        case 'messageActionPinMessage':\n        case 'messageActionContactSignUp':\n        case 'messageActionChatReturn':\n        case 'messageActionChatLeave':\n        case 'messageActionChatJoined':\n        case 'messageActionChatEditPhoto':\n        case 'messageActionChatDeletePhoto':\n        case 'messageActionChatEditVideo':\n        case 'messageActionChatJoinedByLink':\n        case 'messageActionChannelEditVideo':\n        case 'messageActionChannelDeletePhoto': {\n          args = [getNameDivHTML(message.fromId, plain)];\n          break;\n        }\n\n        case 'messageActionChannelEditTitle':\n        case 'messageActionChatEditTitle': {\n          args = [];\n          if(action._ === 'messageActionChatEditTitle') {\n            args.push(getNameDivHTML(message.fromId, plain));\n          }\n\n          args.push(plain ? action.title : htmlToSpan(RichTextProcessor.wrapEmojiText(action.title)));\n          break;\n        }\n\n        case 'messageActionChatDeleteUser':\n        case 'messageActionChatAddUsers':\n        case 'messageActionChatAddUser': {\n          const users: number[] = (action as MessageAction.messageActionChatAddUser).users \n            || [(action as MessageAction.messageActionChatDeleteUser).user_id];\n\n          args = [getNameDivHTML(message.fromId, plain)];\n\n          if(users.length > 1) {\n            if(plain) {\n              args.push(...users.map((userId: number) => (getNameDivHTML(userId, true) as string).trim()).join(', '));\n            } else {\n              const fragment = document.createElement('span');\n              fragment.append(\n                ...join(\n                  users.map((userId: number) => getNameDivHTML(userId, false)) as HTMLElement[],\n                  false\n                )\n              );\n              args.push(fragment);\n            }\n          } else {\n            args.push(getNameDivHTML(users[0], plain));\n          }\n\n          break;\n        }\n\n        case 'messageActionBotAllowed': {\n          const anchorHTML = RichTextProcessor.wrapRichText(action.domain, {\n            entities: [{\n              _: 'messageEntityUrl',\n              length: action.domain.length,\n              offset: 0\n            }]\n          });\n\n          const node = htmlToSpan(anchorHTML);\n\n          args = [node];\n          break;\n        }\n\n        default:\n          langPackKey = (langPack[_] || `[${action._}]`) as any;\n          break;\n      }\n\n      if(!langPackKey) {\n        langPackKey = langPack[_];\n        if(langPackKey === undefined) {\n          langPackKey = '[' + _ + ']' as any;\n        }\n      }\n\n      if(plain) {\n        return I18n.format(langPackKey, true, args);\n      } else {\n        return _i18n(element, langPackKey, args);\n      }\n\n      //str = !langPackKey || langPackKey[0].toUpperCase() === langPackKey[0] ? langPackKey : getNameDivHTML(message.fromId) + langPackKey + (suffix ? ' ' : '');\n    }\n  }\n\n  public editPeerFolders(peerIds: number[], folderId: number) {\n    apiManager.invokeApi('folders.editPeerFolders', {\n      folder_peers: peerIds.map(peerId => {\n        return {\n          _: 'inputFolderPeer',\n          peer: appPeersManager.getInputPeerById(peerId),\n          folder_id: folderId\n        };\n      })\n    }).then(updates => {\n      //this.log('editPeerFolders updates:', updates);\n      apiUpdatesManager.processUpdateMessage(updates); // WARNING! \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0442\u0443\u0442 \u043d\u0443\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c channelId, \u0438 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c \u0430\u043f\u0434\u0435\u0439\u0442 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043a\u0430\u043d\u0430\u043b\u0430 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\n    });\n  }\n\n  public toggleDialogPin(peerId: number, filterId?: number) {\n    if(filterId > 1) {\n      return this.filtersStorage.toggleDialogPin(peerId, filterId);\n    }\n\n    const dialog = this.getDialogOnly(peerId);\n    if(!dialog) return Promise.reject();\n\n    const pinned = dialog.pFlags?.pinned ? undefined : true;\n\n    if(pinned) {\n      const max = filterId === 1 ? rootScope.config.pinned_infolder_count_max : rootScope.config.pinned_dialogs_count_max;\n      if(this.dialogsStorage.getPinnedOrders(filterId).length >= max) {\n        return Promise.reject({type: 'PINNED_DIALOGS_TOO_MUCH'});\n      }\n    }\n\n    return apiManager.invokeApi('messages.toggleDialogPin', {\n      peer: appPeersManager.getInputDialogPeerById(peerId),\n      pinned\n    }).then(bool => {\n      if(bool) {\n        const pFlags: Update.updateDialogPinned['pFlags'] = pinned ? {pinned} : {};\n        apiUpdatesManager.saveUpdate({\n          _: 'updateDialogPinned',\n          peer: appPeersManager.getDialogPeer(peerId),\n          folder_id: filterId,\n          pFlags\n        });\n      }\n    });\n  }\n\n  public markDialogUnread(peerId: number, read?: true) {\n    const dialog = this.getDialogOnly(peerId);\n    if(!dialog) return Promise.reject();\n\n    const unread = read || dialog.pFlags?.unread_mark ? undefined : true;\n    return apiManager.invokeApi('messages.markDialogUnread', {\n      peer: appPeersManager.getInputDialogPeerById(peerId),\n      unread\n    }).then(bool => {\n      if(bool) {\n        const pFlags: Update.updateDialogUnreadMark['pFlags'] = unread ? {unread} : {};\n        this.onUpdateDialogUnreadMark({\n          _: 'updateDialogUnreadMark',\n          peer: appPeersManager.getDialogPeer(peerId),\n          pFlags\n        });\n      }\n    });\n  }\n\n  public migrateChecks(migrateFrom: number, migrateTo: number) {\n    if(!this.migratedFromTo[migrateFrom] &&\n      !this.migratedToFrom[migrateTo] &&\n      appChatsManager.hasChat(-migrateTo)) {\n      const fromChat = appChatsManager.getChat(-migrateFrom);\n      if(fromChat &&\n        fromChat.migrated_to &&\n        fromChat.migrated_to.channel_id === -migrateTo) {\n          this.migratedFromTo[migrateFrom] = migrateTo;\n          this.migratedToFrom[migrateTo] = migrateFrom;\n\n        //setTimeout(() => {\n          rootScope.dispatchEvent('dialog_migrate', {migrateFrom, migrateTo});\n\n          const dropped = this.dialogsStorage.dropDialog(migrateFrom);\n          if(dropped.length) {\n            rootScope.dispatchEvent('dialog_drop', {peerId: migrateFrom, dialog: dropped[0]});\n          }\n        //}, 100);\n      }\n    }\n  }\n\n  private canMessageBeEdited(message: any, kind: 'text' | 'poll') {\n    if(message.pFlags.is_outgoing) {\n      return false;\n    }\n\n    const goodMedias = [\n      'messageMediaPhoto',\n      'messageMediaDocument',\n      'messageMediaWebPage'\n    ];\n\n    if(kind === 'poll') {\n      goodMedias.push('messageMediaPoll');\n    }\n\n    if(message._ !== 'message' ||\n        message.deleted ||\n        message.fwd_from ||\n        message.via_bot_id ||\n        message.media && goodMedias.indexOf(message.media._) === -1 ||\n        message.fromId && appUsersManager.isBot(message.fromId)) {\n      return false;\n    }\n    \n    if(message.media &&\n        message.media._ === 'messageMediaDocument' &&\n        (message.media.document.sticker || message.media.document.type === 'round')) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public canEditMessage(message: any, kind: 'text' | 'poll' = 'text') {\n    if(!message || !this.canMessageBeEdited(message, kind)) {\n      return false;\n    }\n\n    // * second rule for saved messages, because there is no 'out' flag\n    if(/* message.pFlags.out ||  */this.getMessagePeer(message) === appUsersManager.getSelf().id) {\n      return true;\n    }\n\n    if((message.date < (tsNow(true) - rootScope.config.edit_time_limit) && \n      message.media?._ !== 'messageMediaPoll') || !message.pFlags.out) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public canDeleteMessage(message: any) {\n    return message && (\n      message.peerId > 0 \n      || message.fromId === rootScope.myId \n      || appChatsManager.getChat(message.peerId)._ === 'chat' \n      || appChatsManager.hasRights(message.peerId, 'delete_messages')\n    ) && !message.pFlags.is_outgoing;\n  }\n\n  public getReplyKeyboard(peerId: number) {\n    return this.getHistoryStorage(peerId).reply_markup;\n  }\n\n  public mergeReplyKeyboard(historyStorage: HistoryStorage, message: Message.messageService | Message.message) {\n    // this.log('merge', message.mid, message.reply_markup, historyStorage.reply_markup)\n    let messageReplyMarkup = (message as Message.message).reply_markup;\n    if(!messageReplyMarkup &&\n      !message.pFlags?.out &&\n      !(message as Message.messageService).action) {\n      return false;\n    }\n\n    if(messageReplyMarkup?._ === 'replyInlineMarkup') {\n      return false;\n    }\n\n    const lastReplyMarkup = historyStorage.reply_markup;\n    if(messageReplyMarkup) {\n      if(lastReplyMarkup && lastReplyMarkup.mid >= message.mid) {\n        return false;\n      }\n\n      if(messageReplyMarkup.pFlags.selective) {\n        return false;\n      }\n\n      if(historyStorage.maxOutId &&\n        message.mid < historyStorage.maxOutId &&\n        (messageReplyMarkup as ReplyMarkup.replyKeyboardMarkup | ReplyMarkup.replyKeyboardForceReply).pFlags.single_use) {\n        (messageReplyMarkup as ReplyMarkup.replyKeyboardMarkup | ReplyMarkup.replyKeyboardForceReply).pFlags.hidden = true;\n      }\n\n      messageReplyMarkup.mid = message.mid;\n      /* messageReplyMarkup = Object.assign({\n        mid: message.mid\n      }, messageReplyMarkup); */\n\n      if(messageReplyMarkup._ !== 'replyKeyboardHide') {\n        messageReplyMarkup.fromId = appPeersManager.getPeerId(message.from_id);\n      }\n\n      historyStorage.reply_markup = messageReplyMarkup;\n      // this.log('set', historyStorage.reply_markup)\n      return true;\n    }\n\n    if(message.pFlags.out) {\n      if(lastReplyMarkup) {\n        assumeType<ReplyMarkup.replyKeyboardMarkup>(lastReplyMarkup);\n        if(lastReplyMarkup.pFlags.single_use &&\n          !lastReplyMarkup.pFlags.hidden &&\n          (message.mid > lastReplyMarkup.mid || message.pFlags.is_outgoing) &&\n          (message as Message.message).message) {\n          lastReplyMarkup.pFlags.hidden = true;\n          // this.log('set', historyStorage.reply_markup)\n          return true;\n        }\n      } else if(!historyStorage.maxOutId ||\n        message.mid > historyStorage.maxOutId) {\n        historyStorage.maxOutId = message.mid;\n      }\n    }\n\n    assumeType<Message.messageService>(message);\n    if(message.action?._ === 'messageActionChatDeleteUser' &&\n      (lastReplyMarkup\n        ? message.action.user_id === (lastReplyMarkup as ReplyMarkup.replyKeyboardMarkup).fromId\n        : appUsersManager.isBot(message.action.user_id)\n      )\n    ) {\n      historyStorage.reply_markup = {\n        _: 'replyKeyboardHide',\n        mid: message.mid,\n        pFlags: {}\n      };\n      // this.log('set', historyStorage.reply_markup)\n      return true;\n    }\n\n    return false;\n  }\n\n  public getSearchStorage(peerId: number, inputFilter: MyInputMessagesFilter) {\n    if(!this.searchesStorage[peerId]) this.searchesStorage[peerId] = {};\n    if(!this.searchesStorage[peerId][inputFilter]) this.searchesStorage[peerId][inputFilter] = {history: []};\n    return this.searchesStorage[peerId][inputFilter];\n  }\n\n  public getSearchCounters(peerId: number, filters: MessagesFilter[], canCache = true) {\n    const func = (canCache ? apiManager.invokeApiCacheable : apiManager.invokeApi).bind(apiManager);\n    return func('messages.getSearchCounters', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      filters\n    });\n  }\n\n  public getSearch({peerId, query, inputFilter, maxId, limit, nextRate, backLimit, threadId, folderId, minDate, maxDate}: {\n    peerId?: number,\n    maxId?: number,\n    limit?: number,\n    nextRate?: number,\n    backLimit?: number,\n    threadId?: number,\n    folderId?: number,\n    query?: string,\n    inputFilter?: {\n      _: MyInputMessagesFilter\n    },\n    minDate?: number,\n    maxDate?: number\n  }): Promise<{\n    count: number,\n    next_rate: number,\n    offset_id_offset: number,\n    history: MyMessage[]\n  }> {\n    if(!peerId) peerId = 0;\n    if(!query) query = '';\n    if(!inputFilter) inputFilter = {_: 'inputMessagesFilterEmpty'};\n    if(limit === undefined) limit = 20;\n    if(!nextRate) nextRate = 0;\n    if(!backLimit) backLimit = 0;\n\n    minDate = minDate ? minDate / 1000 | 0 : 0;\n    maxDate = maxDate ? maxDate / 1000 | 0 : 0;\n\n    const foundMsgs: Message.message[] = [];\n\n    //this.log('search', maxId);\n\n    if(backLimit) {\n      limit += backLimit;\n    }\n\n    //const beta = inputFilter._ === 'inputMessagesFilterPinned' && !backLimit;\n    const beta = false;\n\n    let storage: {\n      count?: number;\n      history: SlicedArray;\n    };\n\n    // * \u043a\u043e\u0441\u0442\u044b\u043b\u044c \u0434\u043b\u044f limit 1, \u0435\u0441\u043b\u0438 \u043d\u0443\u0436\u043d\u043e \u0438 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0438 \u0443\u0437\u043d\u0430\u0442\u044c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439\n    if(peerId && !backLimit && !maxId && !query && limit !== 1 && !threadId/*  && inputFilter._ !== 'inputMessagesFilterPinned' */) {\n      storage = beta ? \n        this.getSearchStorage(peerId, inputFilter._) as any : \n        this.getHistoryStorage(peerId);\n      let filtering = true;\n\n      const history = /* maxId ? storage.history.slice(storage.history.indexOf(maxId) + 1) :  */storage.history;\n\n      if(storage !== undefined && history.length) {\n        const neededContents: {\n          [messageMediaType: string]: boolean\n        } = {},\n          neededDocTypes: string[] = [], \n          excludeDocTypes: string[] = []/* ,\n          neededFlags: string[] = [] */;\n\n        switch(inputFilter._) {\n          case 'inputMessagesFilterPhotos':\n            neededContents['messageMediaPhoto'] = true;\n            break;\n\n          case 'inputMessagesFilterPhotoVideo':\n            neededContents['messageMediaPhoto'] = true;\n            neededContents['messageMediaDocument'] = true;\n            neededDocTypes.push('video');\n            break;\n\n          case 'inputMessagesFilterVideo':\n            neededContents['messageMediaDocument'] = true;\n            neededDocTypes.push('video');\n            break;\n\n          case 'inputMessagesFilterDocument':\n            neededContents['messageMediaDocument'] = true;\n            excludeDocTypes.push('video');\n            break;\n\n          case 'inputMessagesFilterVoice':\n            neededContents['messageMediaDocument'] = true;\n            neededDocTypes.push('voice');\n            break;\n\n          case 'inputMessagesFilterRoundVoice':\n            neededContents['messageMediaDocument'] = true;\n            neededDocTypes.push('round', 'voice');\n            break;\n\n          case 'inputMessagesFilterRoundVideo':\n            neededContents['messageMediaDocument'] = true;\n            neededDocTypes.push('round');\n            break;\n\n          case 'inputMessagesFilterMusic':\n            neededContents['messageMediaDocument'] = true;\n            neededDocTypes.push('audio');\n            break;\n\n          case 'inputMessagesFilterUrl':\n            neededContents['url'] = true;\n            break;\n\n          case 'inputMessagesFilterChatPhotos':\n            neededContents['avatar'] = true;\n            break;\n\n          /* case 'inputMessagesFilterPinned':\n            neededFlags.push('pinned');\n            break; */\n\n          /* case 'inputMessagesFilterMyMentions':\n            neededContents['mentioned'] = true;\n            break; */\n\n          default:\n            filtering = false;\n            break;\n            /* return Promise.resolve({\n              count: 0,\n              next_rate: 0,\n              history: [] as number[]\n            }); */\n        }\n\n        if(filtering) {\n          const storage = this.getMessagesStorage(peerId);\n          for(let i = 0, length = history.length; i < length; i++) {\n            const message = storage[history.slice[i]];\n\n            if(!message) continue;\n  \n            //|| (neededContents['mentioned'] && message.totalEntities.find((e: any) => e._ === 'messageEntityMention'));\n  \n            let found = false;\n            if(message.media && neededContents[message.media._] && !message.fwd_from) {\n              if(message.media._ === 'messageMediaDocument') {\n                if((neededDocTypes.length && !neededDocTypes.includes(message.media.document.type)) \n                  || excludeDocTypes.includes(message.media.document.type)) {\n                  continue;\n                }\n              }\n  \n              found = true;\n            } else if(neededContents['url'] && message.message) {\n              const goodEntities = ['messageEntityTextUrl', 'messageEntityUrl'];\n              if((message.totalEntities as MessageEntity[]).find(e => goodEntities.includes(e._)) || RichTextProcessor.matchUrl(message.message)) {\n                found = true;\n              }\n            } else if(neededContents['avatar'] && message.action && ['messageActionChannelEditPhoto', 'messageActionChatEditPhoto', 'messageActionChannelEditVideo', 'messageActionChatEditVideo'].includes(message.action._)) {\n              found = true;\n            }/*  else if(neededFlags.find(flag => message.pFlags[flag])) {\n              found = true;\n            } */\n  \n            if(found) {\n              foundMsgs.push(message);\n              if(foundMsgs.length >= limit) {\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if(foundMsgs.length) {\n      if(foundMsgs.length < limit && (beta ? storage.count !== storage.history.length : true)) {\n        maxId = foundMsgs[foundMsgs.length - 1].mid;\n        limit = limit - foundMsgs.length;\n      } else {\n        return Promise.resolve({\n          count: beta ? storage.count : 0,\n          next_rate: 0,\n          offset_id_offset: 0,\n          history: foundMsgs\n        });\n      }\n    } else if(beta && storage?.count) {\n      return Promise.resolve({\n        count: storage.count,\n        next_rate: 0,\n        offset_id_offset: 0,\n        history: []\n      });\n    }\n\n    const canCache = false && (['inputMessagesFilterChatPhotos', 'inputMessagesFilterPinned'] as MyInputMessagesFilter[]).includes(inputFilter._);\n    const method = (canCache ? apiManager.invokeApiCacheable : apiManager.invokeApi).bind(apiManager);\n\n    let apiPromise: Promise<any>;\n    if(peerId && !nextRate && folderId === undefined/*  || !query */) {\n      apiPromise = method('messages.search', {\n        peer: appPeersManager.getInputPeerById(peerId),\n        q: query || '',\n        filter: inputFilter as any as MessagesFilter,\n        min_date: minDate,\n        max_date: maxDate,\n        limit,\n        offset_id: this.getServerMessageId(maxId) || 0,\n        add_offset: backLimit ? -backLimit : 0,\n        max_id: 0,\n        min_id: 0,\n        hash: 0,\n        top_msg_id: this.getServerMessageId(threadId) || 0\n      }, {\n        //timeout: APITIMEOUT,\n        noErrorBox: true\n      });\n    } else {\n      //var offsetDate = 0;\n      let offsetPeerId = 0;\n      let offsetId = 0;\n      let offsetMessage = maxId && this.getMessageByPeer(peerId, maxId);\n\n      if(offsetMessage && offsetMessage.date) {\n        //offsetDate = offsetMessage.date + serverTimeManager.serverTimeOffset;\n        offsetId = offsetMessage.id;\n        offsetPeerId = this.getMessagePeer(offsetMessage);\n      }\n\n      apiPromise = method('messages.searchGlobal', {\n        q: query,\n        filter: inputFilter as any as MessagesFilter,\n        min_date: minDate,\n        max_date: maxDate,\n        offset_rate: nextRate,\n        offset_peer: appPeersManager.getInputPeerById(offsetPeerId),\n        offset_id: offsetId,\n        limit,\n        folder_id: folderId\n      }, {\n        //timeout: APITIMEOUT,\n        noErrorBox: true\n      });\n    }\n\n    return apiPromise.then((searchResult: any) => {\n      appUsersManager.saveApiUsers(searchResult.users);\n      appChatsManager.saveApiChats(searchResult.chats);\n      this.saveMessages(searchResult.messages);\n\n      /* if(beta && storage && (!maxId || storage.history[storage.history.length - 1] === maxId)) {\n        const storage = this.getSearchStorage(peerId, inputFilter._);\n        const add = (searchResult.messages.map((m: any) => m.mid) as number[]).filter(mid => storage.history.indexOf(mid) === -1);\n        storage.history.push(...add);\n        storage.history.sort((a, b) => b - a);\n        storage.count = searchResult.count;\n      } */\n\n      if(DEBUG) {\n        this.log('getSearch result:', inputFilter, searchResult);\n      }\n\n      const foundCount: number = searchResult.count || (foundMsgs.length + searchResult.messages.length);\n\n      searchResult.messages.forEach((message: any) => {\n        const peerId = this.getMessagePeer(message);\n        if(peerId < 0) {\n          const chat = appChatsManager.getChat(-peerId);\n          if(chat.migrated_to) {\n            this.migrateChecks(peerId, -chat.migrated_to.channel_id);\n          }\n        }\n\n        foundMsgs.push(message);\n      });\n\n      return {\n        count: foundCount,\n        offset_id_offset: searchResult.offset_id_offset || 0,\n        next_rate: searchResult.next_rate,\n        history: foundMsgs\n      };\n    });\n  }\n\n  public subscribeRepliesThread(peerId: number, mid: number) {\n    const repliesKey = peerId + '_' + mid;\n    for(const threadKey in this.threadsToReplies) {\n      if(this.threadsToReplies[threadKey] === repliesKey) return;\n    }\n\n    this.getDiscussionMessage(peerId, mid);\n  }\n\n  public generateThreadServiceStartMessage(message: Message.message) {\n    const threadKey = message.peerId + '_' + message.mid;\n    if(this.threadsServiceMessagesIdsStorage[threadKey]) return;\n\n    const maxMessageId = this.getServerMessageId(Math.max(...this.getMidsByMessage(message)));\n    const serviceStartMessage: Message.messageService = {\n      _: 'messageService',\n      pFlags: {\n        is_single: true\n      },\n      id: this.generateMessageId(maxMessageId, true),\n      date: message.date,\n      from_id: {_: 'peerUser', user_id: 0}/* message.from_id */,\n      peer_id: message.peer_id,\n      action: {\n        _: 'messageActionCustomAction',\n        message: 'Discussion started'\n      },\n      reply_to: this.generateReplyHeader(message.id)\n    };\n\n    this.saveMessages([serviceStartMessage], {isOutgoing: true});\n    this.threadsServiceMessagesIdsStorage[threadKey] = serviceStartMessage.mid;\n  } \n\n  public getDiscussionMessage(peerId: number, mid: number) {\n    return apiManager.invokeApiSingle('messages.getDiscussionMessage', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      msg_id: this.getServerMessageId(mid)\n    }).then(result => {\n      appChatsManager.saveApiChats(result.chats);\n      appUsersManager.saveApiUsers(result.users);\n      this.saveMessages(result.messages);\n\n      const message = this.filterMessages(result.messages[0], message => !!(message as Message.message).replies)[0] as Message.message;\n      const threadKey = message.peerId + '_' + message.mid;\n\n      this.generateThreadServiceStartMessage(message);\n      \n      const historyStorage = this.getHistoryStorage(message.peerId, message.mid);\n      result.max_id = historyStorage.maxId = this.generateMessageId(result.max_id) || 0;\n      result.read_inbox_max_id = historyStorage.readMaxId = this.generateMessageId(result.read_inbox_max_id ?? message.mid);\n      result.read_outbox_max_id = historyStorage.readOutboxMaxId = this.generateMessageId(result.read_outbox_max_id) || 0;\n\n      this.threadsToReplies[threadKey] = peerId + '_' + mid;\n\n      return message;\n    });\n  }\n\n  private handleNewMessage(peerId: number, mid: number) {\n    if(this.newMessagesToHandle[peerId] === undefined) {\n      this.newMessagesToHandle[peerId] = new Set();\n    }\n\n    this.newMessagesToHandle[peerId].add(mid);\n    if(!this.newMessagesHandleTimeout) {\n      this.newMessagesHandleTimeout = window.setTimeout(this.handleNewMessages, 0);\n    }\n  }\n\n  handleNewMessages = () => {\n    clearTimeout(this.newMessagesHandleTimeout);\n    this.newMessagesHandleTimeout = 0;\n\n    rootScope.dispatchEvent('history_multiappend', this.newMessagesToHandle);\n    this.newMessagesToHandle = {};\n  };\n\n  handleNewDialogs = () => {\n    let newMaxSeenId = 0;\n    const obj = this.newDialogsToHandle;\n    for(const peerId in obj) {\n      const dialog = obj[peerId];\n      if(!dialog) {\n        this.reloadConversation(+peerId);\n        delete obj[peerId];\n      } else {\n        this.dialogsStorage.pushDialog(dialog);\n        if(!appPeersManager.isChannel(+peerId)) {\n          newMaxSeenId = Math.max(newMaxSeenId, dialog.top_message || 0);\n        }\n      }\n    }\n\n    //this.log('after order:', this.dialogsStorage[0].map(d => d.peerId));\n\n    if(newMaxSeenId !== 0) {\n      this.incrementMaxSeenId(newMaxSeenId);\n    }\n\n    rootScope.dispatchEvent('dialogs_multiupdate', obj);\n    this.newDialogsToHandle = {};\n  };\n\n  public scheduleHandleNewDialogs(peerId?: number, dialog?: Dialog) {\n    if(peerId !== undefined) {\n      this.newDialogsToHandle[peerId] = dialog;\n    }\n\n    if(this.newDialogsHandlePromise) return this.newDialogsHandlePromise;\n    return this.newDialogsHandlePromise = new Promise((resolve) => {\n      setTimeout(() => {\n        this.newDialogsHandlePromise = undefined;\n        this.handleNewDialogs();\n      }, 0);\n    });\n  }\n\n  public deleteMessages(peerId: number, mids: number[], revoke?: boolean) {\n    let promise: Promise<any>;\n\n    const localMessageIds = mids.map(mid => this.getServerMessageId(mid));\n\n    if(peerId < 0 && appPeersManager.isChannel(peerId)) {\n      const channelId = -peerId;\n      const channel = appChatsManager.getChat(channelId);\n      if(!channel.pFlags.creator && !(channel.pFlags.editor && channel.pFlags.megagroup)) {\n        const goodMsgIds: number[] = [];\n        if(channel.pFlags.editor || channel.pFlags.megagroup) {\n          mids.forEach((msgId, i) => {\n            const message = this.getMessageByPeer(peerId, mids[i]);\n            if(message.pFlags.out) {\n              goodMsgIds.push(msgId);\n            }\n          });\n        }\n\n        if(!goodMsgIds.length) {\n          return;\n        }\n\n        mids = goodMsgIds;\n      }\n\n      promise = apiManager.invokeApi('channels.deleteMessages', {\n        channel: appChatsManager.getChannelInput(channelId),\n        id: localMessageIds\n      }).then((affectedMessages) => {\n        apiUpdatesManager.processLocalUpdate({\n          _: 'updateDeleteChannelMessages',\n          channel_id: channelId,\n          messages: mids,\n          pts: affectedMessages.pts,\n          pts_count: affectedMessages.pts_count\n        });\n      });\n    } else {\n      promise = apiManager.invokeApi('messages.deleteMessages', {\n        revoke,\n        id: localMessageIds\n      }).then((affectedMessages) => {\n        apiUpdatesManager.processLocalUpdate({\n          _: 'updateDeleteMessages',\n          messages: mids,\n          pts: affectedMessages.pts,\n          pts_count: affectedMessages.pts_count\n        });\n      });\n    }\n\n    return promise;\n  }\n\n  // TODO: cancel notification by peer when this function is being called\n  public readHistory(peerId: number, maxId = 0, threadId?: number, force = false) {\n    // return Promise.resolve();\n    // console.trace('start read')\n    this.log('readHistory:', peerId, maxId, threadId);\n    if(!this.getReadMaxIdIfUnread(peerId, threadId) && !force) {\n      this.log('readHistory: isn\\'t unread');\n      return Promise.resolve();\n    }\n\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\n\n    if(historyStorage.triedToReadMaxId >= maxId) {\n      return Promise.resolve();\n    }\n\n    let apiPromise: Promise<any>;\n    if(threadId) {\n      if(!historyStorage.readPromise) {\n        apiPromise = apiManager.invokeApi('messages.readDiscussion', {\n          peer: appPeersManager.getInputPeerById(peerId),\n          msg_id: this.getServerMessageId(threadId),\n          read_max_id: this.getServerMessageId(maxId)\n        });\n      }\n\n      apiUpdatesManager.processLocalUpdate({\n        _: 'updateReadChannelDiscussionInbox',\n        channel_id: -peerId,\n        top_msg_id: threadId,\n        read_max_id: maxId\n      });\n    } else if(appPeersManager.isChannel(peerId)) {\n      if(!historyStorage.readPromise) {\n        apiPromise = apiManager.invokeApi('channels.readHistory', {\n          channel: appChatsManager.getChannelInput(-peerId),\n          max_id: this.getServerMessageId(maxId)\n        });\n      }\n\n      apiUpdatesManager.processLocalUpdate({\n        _: 'updateReadChannelInbox',\n        max_id: maxId,\n        channel_id: -peerId,\n        still_unread_count: undefined,\n        pts: undefined\n      });\n    } else {\n      if(!historyStorage.readPromise) {\n        apiPromise = apiManager.invokeApi('messages.readHistory', {\n          peer: appPeersManager.getInputPeerById(peerId),\n          max_id: this.getServerMessageId(maxId)\n        }).then((affectedMessages) => {\n          apiUpdatesManager.processUpdateMessage({\n            _: 'updateShort',\n            update: {\n              _: 'updatePts',\n              pts: affectedMessages.pts,\n              pts_count: affectedMessages.pts_count\n            }\n          });\n        });\n      }\n\n      apiUpdatesManager.processLocalUpdate({\n        _: 'updateReadHistoryInbox',\n        max_id: maxId,\n        peer: appPeersManager.getOutputPeer(peerId),\n        still_unread_count: undefined,\n        pts: undefined,\n        pts_count: undefined\n      });\n    }\n\n    appNotificationsManager.soundReset(appPeersManager.getPeerString(peerId));\n\n    if(historyStorage.readPromise) {\n      return historyStorage.readPromise;\n    }\n\n    historyStorage.triedToReadMaxId = maxId;\n\n    apiPromise.finally(() => {\n      delete historyStorage.readPromise;\n\n      this.log('readHistory: promise finally', maxId, historyStorage.readMaxId);\n\n      if(historyStorage.readMaxId > maxId) {\n        this.readHistory(peerId, historyStorage.readMaxId, threadId, true);\n      }\n    });\n\n    return historyStorage.readPromise = apiPromise;\n  }\n\n  public readAllHistory(peerId: number, threadId?: number, force = false) {\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\n    if(historyStorage.maxId) {\n      this.readHistory(peerId, historyStorage.maxId, threadId, force); // lol\n    }\n  }\n\n  public readMessages(peerId: number, msgIds: number[]) {\n    msgIds = msgIds.map(mid => this.getServerMessageId(mid));\n    if(peerId < 0 && appPeersManager.isChannel(peerId)) {\n      const channelId = -peerId;\n      apiManager.invokeApi('channels.readMessageContents', {\n        channel: appChatsManager.getChannelInput(channelId),\n        id: msgIds\n      }).then(() => {\n        apiUpdatesManager.processLocalUpdate({\n          _: 'updateChannelReadMessagesContents',\n          channel_id: channelId,\n          messages: msgIds\n        });\n      });\n    } else {\n      apiManager.invokeApi('messages.readMessageContents', {\n        id: msgIds\n      }).then((affectedMessages) => {\n        apiUpdatesManager.processLocalUpdate({\n          _: 'updateReadMessagesContents',\n          messages: msgIds,\n          pts: affectedMessages.pts,\n          pts_count: affectedMessages.pts_count\n        });\n      });\n    }\n  }\n\n  public getHistoryStorage(peerId: number, threadId?: number) {\n    if(threadId) {\n      //threadId = this.getLocalMessageId(threadId);\n      if(!this.threadsStorage[peerId]) this.threadsStorage[peerId] = {};\n      return this.threadsStorage[peerId][threadId] ?? (this.threadsStorage[peerId][threadId] = {count: null, history: new SlicedArray()});\n    }\n\n    return this.historiesStorage[peerId] ?? (this.historiesStorage[peerId] = {count: null, history: new SlicedArray()});\n  }\n\n  private handleNotifications = () => {\n    window.clearTimeout(this.notificationsHandlePromise);\n    this.notificationsHandlePromise = 0;\n\n    //var timeout = $rootScope.idle.isIDLE && StatusManager.isOtherDeviceActive() ? 30000 : 1000;\n    //const timeout = 1000;\n\n    for(const _peerId in this.notificationsToHandle) {\n      const peerId = +_peerId;\n\n      if(rootScope.peerId === peerId && !rootScope.idle.isIDLE) {\n        continue;\n      }\n\n      const notifyPeerToHandle = this.notificationsToHandle[peerId];\n\n      Promise.all([\n        appNotificationsManager.getNotifyPeerTypeSettings(),\n        appNotificationsManager.getNotifySettings(appPeersManager.getInputNotifyPeerById(peerId, true))\n      ]).then(([_, peerTypeNotifySettings]) => {\n        const topMessage = notifyPeerToHandle.topMessage;\n        if(appNotificationsManager.isPeerLocalMuted(peerId, true) || !topMessage.pFlags.unread) {\n          return;\n        }\n\n        //setTimeout(() => {\n          if(topMessage.pFlags.unread) {\n            this.notifyAboutMessage(topMessage, {\n              fwdCount: notifyPeerToHandle.fwdCount,\n              peerTypeNotifySettings\n            });\n          }\n        //}, timeout);\n      });\n    }\n\n    this.notificationsToHandle = {};\n  };\n\n  private onUpdateMessageId = (update: Update.updateMessageID) => {\n    const randomId = update.random_id;\n    const pendingData = this.pendingByRandomId[randomId];\n    //this.log('AMM updateMessageID:', update, pendingData);\n    if(pendingData) {\n      const {peerId, tempId, threadId, storage} = pendingData;\n      //const mid = update.id;\n      const mid = this.generateMessageId(update.id);\n      const message = this.getMessageFromStorage(storage, mid);\n      if(!message.deleted) {\n        [this.getHistoryStorage(peerId), threadId ? this.getHistoryStorage(peerId, threadId) : undefined]\n        .filter(Boolean)\n        .forEach(storage => {\n          storage.history.delete(tempId);\n        });\n\n        this.finalizePendingMessageCallbacks(storage, tempId, mid);\n      } else {\n        this.pendingByMessageId[mid] = randomId;\n      }\n    }\n  };\n\n  private onUpdateNewMessage = (update: Update.updateNewDiscussionMessage | Update.updateNewMessage | Update.updateNewChannelMessage) => {\n    const message = update.message as MyMessage;\n    const peerId = this.getMessagePeer(message);\n    const storage = this.getMessagesStorage(peerId);\n    const dialog = this.getDialogOnly(peerId);\n\n    // * local update\n    const isLocalThreadUpdate = update._ === 'updateNewDiscussionMessage';\n\n    // * temporary save the message for info (peerId, reply mids...)\n    this.saveMessages([message], {storage: {}});\n\n    const threadKey = this.getThreadKey(message);\n    const threadId = threadKey ? +threadKey.split('_')[1] : undefined;\n    if(threadId && !isLocalThreadUpdate && this.threadsStorage[peerId] && this.threadsStorage[peerId][threadId]) {\n      const update = {\n        _: 'updateNewDiscussionMessage',\n        message\n      } as Update.updateNewDiscussionMessage;\n\n      this.onUpdateNewMessage(update);\n    }\n\n    if(!dialog && !isLocalThreadUpdate) {\n      let good = true;\n      if(peerId < 0) {\n        good = appChatsManager.isInChat(-peerId);\n      }\n\n      if(good) {\n        const set = this.newUpdatesAfterReloadToHandle[peerId] ?? (this.newUpdatesAfterReloadToHandle[peerId] = new Set());\n        if(set.has(update)) {\n          this.log.error('here we go again', peerId);\n          return;\n        }\n\n        this.scheduleHandleNewDialogs(peerId);\n        set.add(update);\n      }\n\n      return;\n    }\n\n    /* if(update._ === 'updateNewChannelMessage') {\n      const chat = appChatsManager.getChat(-peerId);\n      if(chat.pFlags && (chat.pFlags.left || chat.pFlags.kicked)) {\n        return;\n      }\n    } */\n\n    this.saveMessages([message], {storage});\n    // this.log.warn(dT(), 'message unread', message.mid, message.pFlags.unread)\n\n    /* if((message as Message.message).grouped_id) {\n      this.log('updateNewMessage', message);\n    } */\n\n    const pendingMessage = this.checkPendingMessage(message);\n    const historyStorage = this.getHistoryStorage(peerId, isLocalThreadUpdate ? threadId : undefined);\n\n    if(!isLocalThreadUpdate) {\n      this.updateMessageRepliesIfNeeded(message);\n    }\n\n    if(historyStorage.history.findSlice(message.mid)) {\n      return false;\n    }\n\n    // * catch situation with disconnect. if message's id is lower than we already have (in bottom end slice), will sort it\n    const firstSlice = historyStorage.history.first;\n    if(firstSlice.isEnd(SliceEnd.Bottom)) {\n      let i = 0;\n      for(const length = firstSlice.length; i < length; ++i) {\n        if(message.mid > firstSlice[i]) {\n          break;\n        }\n      }\n\n      firstSlice.splice(i, 0, message.mid);\n    } else {\n      historyStorage.history.unshift(message.mid);\n    }\n\n    if(historyStorage.count !== null) {\n      historyStorage.count++;\n    }\n\n    if(this.mergeReplyKeyboard(historyStorage, message)) {\n      rootScope.dispatchEvent('history_reply_markup', {peerId});\n    }\n\n    const fromId = message.fromId;\n    if(fromId > 0 && !message.pFlags.out && message.from_id) {\n      appUsersManager.forceUserOnline(fromId, message.date);\n\n      const action: SendMessageAction = {\n        _: 'sendMessageCancelAction'\n      };\n\n      let update: Update.updateUserTyping | Update.updateChatUserTyping | Update.updateChannelUserTyping;\n      if(peerId > 0) {\n        update = {\n          _: 'updateUserTyping',\n          action,\n          user_id: fromId\n        };\n      } else if(appPeersManager.isChannel(peerId)) {\n        update = {\n          _: 'updateChannelUserTyping',\n          action,\n          channel_id: -peerId,\n          from_id: appPeersManager.getOutputPeer(fromId),\n          top_msg_id: threadId ? this.getServerMessageId(threadId) : undefined\n        };\n      } else {\n        update = {\n          _: 'updateChatUserTyping',\n          action,\n          chat_id: -peerId,\n          from_id: appPeersManager.getOutputPeer(fromId)\n        };\n      }\n\n      apiUpdatesManager.processLocalUpdate(update);\n    }\n\n    if(!pendingMessage) {\n      this.handleNewMessage(peerId, message.mid);\n    }\n\n    if(isLocalThreadUpdate) {\n      return;\n    }\n    \n    const inboxUnread = !message.pFlags.out && message.pFlags.unread;\n    if(dialog) {\n      this.setDialogTopMessage(message, dialog);\n      if(inboxUnread) {\n        dialog.unread_count++;\n      }\n    }\n\n    if(inboxUnread/*  && ($rootScope.selectedPeerID != peerID || $rootScope.idle.isIDLE) */) {\n      const notifyPeer = peerId;\n      let notifyPeerToHandle = this.notificationsToHandle[notifyPeer];\n      if(notifyPeerToHandle === undefined) {\n        notifyPeerToHandle = this.notificationsToHandle[notifyPeer] = {\n          fwdCount: 0,\n          fromId: 0\n        };\n      }\n\n      if(notifyPeerToHandle.fromId !== fromId) {\n        notifyPeerToHandle.fromId = fromId;\n        notifyPeerToHandle.fwdCount = 0;\n      }\n\n      if((message as Message.message).fwd_from) {\n        notifyPeerToHandle.fwdCount++;\n      }\n\n      notifyPeerToHandle.topMessage = message;\n\n      if(!this.notificationsHandlePromise) {\n        this.notificationsHandlePromise = window.setTimeout(this.handleNotifications, 0);\n      }\n    }\n  };\n\n  private onUpdateDialogUnreadMark = (update: Update.updateDialogUnreadMark) => {\n    //this.log('updateDialogUnreadMark', update);\n    const peerId = appPeersManager.getPeerId((update.peer as DialogPeer.dialogPeer).peer);\n    const dialog = this.getDialogOnly(peerId);\n\n    if(!dialog) {\n      this.scheduleHandleNewDialogs(peerId);\n    } else {\n      if(!update.pFlags.unread) {\n        delete dialog.pFlags.unread_mark;\n      } else {\n        dialog.pFlags.unread_mark = true;\n      }\n\n      rootScope.dispatchEvent('dialogs_multiupdate', {[peerId]: dialog});\n      this.dialogsStorage.setDialogToState(dialog);\n    }\n  };\n\n  private onUpdateEditMessage = (update: Update.updateEditMessage | Update.updateEditChannelMessage) => {\n    const message = update.message as MyMessage;\n    const peerId = this.getMessagePeer(message);\n    const mid = this.generateMessageId(message.id);\n    const storage = this.getMessagesStorage(peerId);\n    if(storage[mid] === undefined) {\n      return;\n    }\n\n    // console.trace(dT(), 'edit message', message)\n    \n    const oldMessage = this.getMessageFromStorage(storage, mid);\n    this.saveMessages([message], {storage});\n    const newMessage = this.getMessageFromStorage(storage, mid);\n\n    this.handleEditedMessage(oldMessage, newMessage);\n\n    const dialog = this.getDialogOnly(peerId);\n    const isTopMessage = dialog && dialog.top_message === mid;\n    if((message as Message.message).clear_history) {\n      if(isTopMessage) {\n        rootScope.dispatchEvent('dialog_flush', {peerId});\n      }\n    } else {\n      rootScope.dispatchEvent('message_edit', {\n        storage,\n        peerId,\n        mid\n      });\n\n      if(isTopMessage || (message as Message.message).grouped_id) {\n        const updatedDialogs: {[peerId: number]: Dialog} = {};\n        updatedDialogs[peerId] = dialog;\n        rootScope.dispatchEvent('dialogs_multiupdate', updatedDialogs);\n        this.dialogsStorage.setDialogToState(dialog);\n      }\n    }\n  };\n\n  private onUpdateReadHistory = (update: Update.updateReadChannelDiscussionInbox | Update.updateReadChannelDiscussionOutbox \n    | Update.updateReadHistoryInbox | Update.updateReadHistoryOutbox \n    | Update.updateReadChannelInbox | Update.updateReadChannelOutbox) => {\n    const channelId = (update as Update.updateReadChannelInbox).channel_id;\n    const maxId = this.generateMessageId((update as Update.updateReadChannelInbox).max_id || (update as Update.updateReadChannelDiscussionInbox).read_max_id);\n    const threadId = this.generateMessageId((update as Update.updateReadChannelDiscussionInbox).top_msg_id);\n    const peerId = channelId ? -channelId : appPeersManager.getPeerId((update as Update.updateReadHistoryInbox).peer);\n\n    const isOut = update._ === 'updateReadHistoryOutbox' || update._ === 'updateReadChannelOutbox' || update._ === 'updateReadChannelDiscussionOutbox' ? true : undefined;\n\n    const storage = this.getMessagesStorage(peerId);\n    const history = getObjectKeysAndSort(storage, 'desc');\n    const foundDialog = this.getDialogOnly(peerId);\n    const stillUnreadCount = (update as Update.updateReadChannelInbox).still_unread_count;\n    let newUnreadCount = 0;\n    let foundAffected = false;\n\n    //this.log.warn(dT(), 'read', peerId, isOut ? 'out' : 'in', maxId)\n\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\n\n    if(peerId > 0 && isOut) {\n      appUsersManager.forceUserOnline(peerId);\n    }\n\n    if(threadId) {\n      const repliesKey = this.threadsToReplies[peerId + '_' + threadId];\n      if(repliesKey) {\n        const [peerId, mid] = repliesKey.split('_').map(n => +n);\n        this.updateMessage(peerId, mid, 'replies_updated');\n      }\n    }\n\n    for(let i = 0, length = history.length; i < length; i++) {\n      const messageId = history[i];\n      if(messageId > maxId) {\n        continue;\n      }\n      \n      const message = storage[messageId];\n\n      if(message.pFlags.out !== isOut) {\n        continue;\n      }\n\n      if(!message.pFlags.unread) {\n        break;\n      }\n\n      if(threadId) {\n        const replyTo = message.reply_to as MessageReplyHeader;\n        if(!replyTo || (replyTo.reply_to_top_id || replyTo.reply_to_msg_id) !== threadId) {\n          continue;\n        }\n      }\n      \n      // this.log.warn('read', messageId, message.pFlags.unread, message)\n      if(message.pFlags.unread) {\n        delete message.pFlags.unread;\n        if(!foundAffected) {\n          foundAffected = true;\n        }\n\n        if(!message.pFlags.out && !threadId && foundDialog && stillUnreadCount === undefined) {\n          newUnreadCount = --foundDialog.unread_count;\n        }\n        \n        appNotificationsManager.cancel('msg' + messageId);\n      }\n    }\n\n    if(isOut) historyStorage.readOutboxMaxId = maxId;\n    else historyStorage.readMaxId = maxId;\n\n    if(!threadId && foundDialog) {\n      if(isOut) foundDialog.read_outbox_max_id = maxId;\n      else foundDialog.read_inbox_max_id = maxId;\n\n      if(!isOut) {\n        if(newUnreadCount < 0 || !this.getReadMaxIdIfUnread(peerId)) {\n          foundDialog.unread_count = 0;\n        } else if(newUnreadCount && foundDialog.top_message > maxId) {\n          foundDialog.unread_count = newUnreadCount;\n        }\n      }\n      \n      rootScope.dispatchEvent('dialog_unread', {peerId});\n      this.dialogsStorage.setDialogToState(foundDialog);\n    }\n\n    if(foundAffected) {\n      rootScope.dispatchEvent('messages_read');\n    }\n\n    if(!threadId && channelId) {\n      const threadKeyPart = peerId + '_';\n      for(const threadKey in this.threadsToReplies) {\n        if(threadKey.indexOf(threadKeyPart) === 0) {\n          const [peerId, mid] = this.threadsToReplies[threadKey].split('_').map(n => +n);\n          rootScope.dispatchEvent('replies_updated', this.getMessageByPeer(peerId, mid));\n        }\n      }\n    }\n  };\n\n  private onUpdateReadMessagesContents = (update: Update.updateChannelReadMessagesContents | Update.updateReadMessagesContents) => {\n    const channelId = (update as Update.updateChannelReadMessagesContents).channel_id;\n    const mids = (update as Update.updateReadMessagesContents).messages.map(id => this.generateMessageId(id));\n    const peerId = channelId ? -channelId : this.getMessageById(mids[0]).peerId;\n    for(const mid of mids) {\n      const message = this.getMessageByPeer(peerId, mid);\n      if(!message.deleted) {\n        delete message.pFlags.media_unread;\n        this.setDialogToStateIfMessageIsTop(message);\n      }\n    }\n\n    rootScope.dispatchEvent('messages_media_read', {peerId, mids});\n  };\n\n  private onUpdateChannelAvailableMessages = (update: Update.updateChannelAvailableMessages) => {\n    const channelId: number = update.channel_id;\n    const messages: number[] = [];\n    const peerId: number = -channelId;\n    const history = this.getHistoryStorage(peerId).history.slice;\n    if(history.length) {\n      history.forEach((msgId: number) => {\n        if(!update.available_min_id || msgId <= update.available_min_id) {\n          messages.push(msgId);\n        }\n      });\n    }\n\n    (update as any as Update.updateDeleteChannelMessages).messages = messages;\n    this.onUpdateDeleteMessages(update as any as Update.updateDeleteChannelMessages);\n  };\n\n  private onUpdateDeleteMessages = (update: Update.updateDeleteMessages | Update.updateDeleteChannelMessages) => {\n    const channelId: number = (update as Update.updateDeleteChannelMessages).channel_id;\n    //const messages = (update as any as Update.updateDeleteChannelMessages).messages;\n    const messages = (update as any as Update.updateDeleteChannelMessages).messages.map(id => this.generateMessageId(id));\n    const peerId: number = channelId ? -channelId : this.getMessageById(messages[0]).peerId;\n    \n    if(!peerId) {\n      return;\n    }\n\n    apiManager.clearCache('messages.getSearchCounters', (params) => {\n      return appPeersManager.getPeerId(params.peer) === peerId;\n    });\n\n    const threadKeys: Set<string> = new Set();\n    for(const mid of messages) {\n      const message = this.getMessageByPeer(peerId, mid);\n      const threadKey = this.getThreadKey(message);\n      if(threadKey && this.threadsStorage[peerId] && this.threadsStorage[peerId][+threadKey.split('_')[1]]) {\n        threadKeys.add(threadKey);\n      }\n    }\n    \n    const historyUpdated = this.handleDeletedMessages(peerId, this.getMessagesStorage(peerId), messages);\n\n    const threadsStorages = Array.from(threadKeys).map(threadKey => {\n      const splitted = threadKey.split('_');\n      return this.getHistoryStorage(+splitted[0], +splitted[1]);\n    });\n\n    [this.getHistoryStorage(peerId)].concat(threadsStorages).forEach(historyStorage => {\n      for(const mid in historyUpdated.msgs) {\n        historyStorage.history.delete(+mid);\n      }\n      if(historyUpdated.count &&\n        historyStorage.count !== null &&\n        historyStorage.count > 0) {\n        historyStorage.count -= historyUpdated.count;\n        if(historyStorage.count < 0) {\n          historyStorage.count = 0;\n        }\n      }\n    });\n\n    rootScope.dispatchEvent('history_delete', {peerId, msgs: historyUpdated.msgs});\n\n    const foundDialog = this.getDialogOnly(peerId);\n    if(foundDialog) {\n      if(historyUpdated.unread) {\n        foundDialog.unread_count -= historyUpdated.unread;\n\n        rootScope.dispatchEvent('dialog_unread', {peerId});\n      }\n\n      if(historyUpdated.msgs[foundDialog.top_message]) {\n        this.reloadConversation(peerId);\n      }\n    }\n  };\n\n  private onUpdateChannel = (update: Update.updateChannel) => {\n    const channelId: number = update.channel_id;\n    const peerId = -channelId;\n    const channel: Chat.channel = appChatsManager.getChat(channelId);\n\n    const needDialog = appChatsManager.isInChat(channelId);\n    \n    const canViewHistory = !!channel.username || !channel.pFlags.left;\n    const hasHistory = this.historiesStorage[peerId] !== undefined;\n    \n    if(canViewHistory !== hasHistory) {\n      delete this.historiesStorage[peerId];\n      rootScope.dispatchEvent('history_forbidden', peerId);\n    }\n    \n    const dialog = this.getDialogOnly(peerId);\n    if(!!dialog !== needDialog) {\n      if(needDialog) {\n        this.reloadConversation(-channelId);\n      } else {\n        if(dialog) {\n          this.dialogsStorage.dropDialog(peerId);\n          rootScope.dispatchEvent('dialog_drop', {peerId, dialog});\n        }\n      }\n    }\n  };\n\n  private onUpdateChannelReload = (update: Update.updateChannelReload) => {\n    const channelId = update.channel_id;\n    const peerId = -channelId;\n\n    this.dialogsStorage.dropDialog(peerId);\n\n    delete this.historiesStorage[peerId];\n    this.reloadConversation(-channelId).then(() => {\n      rootScope.dispatchEvent('history_reload', peerId);\n    });\n  };\n  \n  private onUpdateChannelMessageViews = (update: Update.updateChannelMessageViews) => {\n    const views = update.views;\n    //const mid = update.id;\n    const mid = this.generateMessageId(update.id);\n    const message = this.getMessageByPeer(-update.channel_id, mid);\n    if(!message.deleted && message.views && message.views < views) {\n      message.views = views;\n      rootScope.dispatchEvent('message_views', {mid, views});\n    }\n  };\n\n  private onUpdateServiceNotification = (update: Update.updateServiceNotification) => {\n    //this.log('updateServiceNotification', update);\n    const fromId = 777000;\n    const peerId = fromId;\n    const messageId = this.generateTempMessageId(peerId);\n    const message: any = {\n      _: 'message',\n      id: messageId,\n      from_id: appPeersManager.getOutputPeer(fromId),\n      peer_id: appPeersManager.getOutputPeer(peerId),\n      pFlags: {unread: true},\n      date: (update.inbox_date || tsNow(true)) + serverTimeManager.serverTimeOffset,\n      message: update.message,\n      media: update.media,\n      entities: update.entities\n    };\n    if(!appUsersManager.hasUser(fromId)) {\n      appUsersManager.saveApiUsers([{\n        _: 'user',\n        id: fromId,\n        pFlags: {verified: true},\n        access_hash: 0,\n        first_name: 'Telegram',\n        phone: '42777'\n      }]);\n    }\n    this.saveMessages([message], {isOutgoing: true});\n\n    if(update.inbox_date) {\n      this.pendingTopMsgs[peerId] = messageId;\n      this.onUpdateNewMessage({\n        _: 'updateNewMessage',\n        message\n      } as any);\n    }\n  };\n\n  private onUpdatePinnedMessages = (update: Update.updatePinnedMessages | Update.updatePinnedChannelMessages) => {\n    const channelId = update._ === 'updatePinnedChannelMessages' ? update.channel_id : undefined;\n    const peerId = channelId ? -channelId : appPeersManager.getPeerId((update as Update.updatePinnedMessages).peer);\n\n    /* const storage = this.getSearchStorage(peerId, 'inputMessagesFilterPinned');\n    if(storage.count !== storage.history.length) {\n      if(storage.count !== undefined) {\n        delete this.searchesStorage[peerId]['inputMessagesFilterPinned'];  \n      }\n\n      rootScope.broadcast('peer_pinned_messages', peerId);\n      break;\n    } */\n\n    const messages = update.messages.map(id => this.generateMessageId(id)); \n\n    const storage = this.getMessagesStorage(peerId);\n    const missingMessages = messages.filter(mid => !storage[mid]);\n    const getMissingPromise = missingMessages.length ? Promise.all(missingMessages.map(mid => this.wrapSingleMessage(peerId, mid))) : Promise.resolve();\n    getMissingPromise.finally(() => {\n      const werePinned = update.pFlags?.pinned;\n      if(werePinned) {\n        for(const mid of messages) {\n          //storage.history.push(mid);\n          const message = storage[mid];\n          message.pFlags.pinned = true;\n        }\n\n        /* if(this.pinnedMessages[peerId]?.maxId) {\n          const maxMid = Math.max(...messages);\n          this.pinnedMessages\n        } */\n\n        //storage.history.sort((a, b) => b - a);\n      } else {\n        for(const mid of messages) {\n          //storage.history.findAndSplice(_mid => _mid === mid);\n          const message = storage[mid];\n          delete message.pFlags.pinned;\n        }\n      }\n\n      /* const info = this.pinnedMessages[peerId];\n      if(info) {\n        info.count += messages.length * (werePinned ? 1 : -1);\n      } */\n  \n      delete this.pinnedMessages[peerId];\n      appStateManager.getState().then(state => {\n        delete state.hiddenPinnedMessages[peerId];\n        rootScope.dispatchEvent('peer_pinned_messages', {peerId, mids: messages, pinned: werePinned});\n      });\n    });\n  };\n\n  private onUpdateNotifySettings = (update: Update.updateNotifySettings) => {\n    const {peer, notify_settings} = update;\n    if(peer._ === 'notifyPeer') {\n      const peerId = appPeersManager.getPeerId((peer as NotifyPeer.notifyPeer).peer);\n    \n      const dialog = this.getDialogOnly(peerId);\n      if(dialog) {\n        dialog.notify_settings = notify_settings;\n        rootScope.dispatchEvent('dialog_notify_settings', dialog);\n        this.dialogsStorage.setDialogToState(dialog);\n      }\n    }\n  };\n\n  private onUpdateNewScheduledMessage = (update: Update.updateNewScheduledMessage) => {\n    const message = update.message as MyMessage;\n    const peerId = this.getMessagePeer(message);\n\n    const storage = this.scheduledMessagesStorage[peerId];\n    if(storage) {\n      const mid = this.generateMessageId(message.id);\n\n      const oldMessage = this.getMessageFromStorage(storage, mid);\n      this.saveMessages([message], {storage, isScheduled: true});\n      const newMessage = this.getMessageFromStorage(storage, mid);\n\n      if(!oldMessage.deleted) {\n        this.handleEditedMessage(oldMessage, newMessage);\n        rootScope.dispatchEvent('message_edit', {storage, peerId, mid: message.mid});\n      } else {\n        const pendingMessage = this.checkPendingMessage(message);\n        if(!pendingMessage) {\n          rootScope.dispatchEvent('scheduled_new', {peerId, mid: message.mid});\n        }\n      }\n    }\n  };\n\n  private onUpdateDeleteScheduledMessages = (update: Update.updateDeleteScheduledMessages) => {\n    const peerId = appPeersManager.getPeerId(update.peer);\n\n    const storage = this.scheduledMessagesStorage[peerId];\n    if(storage) {\n      const mids = update.messages.map(id => this.generateMessageId(id));\n      this.handleDeletedMessages(peerId, storage, mids);\n\n      rootScope.dispatchEvent('scheduled_delete', {peerId, mids});\n    }\n  };\n\n  public setDialogToStateIfMessageIsTop(message: any) {\n    const dialog = this.getDialogOnly(message.peerId);\n    if(dialog && dialog.top_message === message.mid) {\n      this.dialogsStorage.setDialogToState(dialog);\n    }\n  }\n\n  private updateMessageRepliesIfNeeded(threadMessage: MyMessage) {\n    try { // * \u043d\u0430 \u0432\u0441\u044f\u043a\u0438\u0439 \u0441\u043b\u0443\u0447\u0430\u0439, \u0441\u043a\u043e\u0440\u0435\u0435 \u0432\u0441\u0435\u0433\u043e \u044d\u0442\u043e \u043d\u0435 \u043f\u043e\u043d\u0430\u0434\u043e\u0431\u0438\u0442\u0441\u044f\n      const threadKey = this.getThreadKey(threadMessage);\n      if(threadKey) {\n        const repliesKey = this.threadsToReplies[threadKey];\n        if(repliesKey) {\n          const [peerId, mid] = repliesKey.split('_').map(n => +n);\n\n          this.updateMessage(peerId, mid, 'replies_updated');\n        }\n      }\n    } catch(err) {\n      this.log.error('incrementMessageReplies err', err, threadMessage);\n    }\n  }\n\n  private getThreadKey(threadMessage: MyMessage) {\n    let threadKey = '';\n    if(threadMessage.peerId < 0 && threadMessage.reply_to) {\n      const threadId = threadMessage.reply_to.reply_to_top_id || threadMessage.reply_to.reply_to_msg_id;\n      threadKey = threadMessage.peerId + '_' + threadId;\n    }\n\n    return threadKey;\n  }\n\n  public updateMessage(peerId: number, mid: number, broadcastEventName?: 'replies_updated'): Promise<Message.message> {\n    const promise: Promise<Message.message> = this.wrapSingleMessage(peerId, mid, true).then(() => {\n      const message = this.getMessageByPeer(peerId, mid);\n\n      if(broadcastEventName) {\n        rootScope.dispatchEvent(broadcastEventName, message);\n      }\n\n      return message;\n    });\n    \n    return promise;\n  }\n\n  private checkPendingMessage(message: any) {\n    const randomId = this.pendingByMessageId[message.mid];\n    let pendingMessage: any;\n    if(randomId) {\n      const pendingData = this.pendingByRandomId[randomId];\n      if(pendingMessage = this.finalizePendingMessage(randomId, message)) {\n        rootScope.dispatchEvent('history_update', {storage: pendingData.storage, peerId: message.peerId, mid: message.mid});\n      }\n\n      delete this.pendingByMessageId[message.mid];\n    }\n\n    return pendingMessage;\n  }\n\n  public mutePeer(peerId: number, mute?: boolean) {\n    const settings: InputPeerNotifySettings = {\n      _: 'inputPeerNotifySettings'\n    };\n\n    if(mute === undefined) {\n      mute = !appNotificationsManager.isPeerLocalMuted(peerId, false);\n    }\n    \n    settings.mute_until = mute ? 0x7FFFFFFF : 0;\n\n    return appNotificationsManager.updateNotifySettings({\n      _: 'inputNotifyPeer',\n      peer: appPeersManager.getInputPeerById(peerId)\n    }, settings);\n  }\n\n  public canWriteToPeer(peerId: number, threadId?: number) {\n    if(peerId < 0) {\n      //const isChannel = appPeersManager.isChannel(peerId);\n      const hasRights = /* isChannel &&  */appChatsManager.hasRights(-peerId, 'send_messages', undefined, !!threadId); \n      return /* !isChannel ||  */hasRights;\n    } else {\n      return appUsersManager.canSendToUser(peerId);\n    }\n  }\n\n  public finalizePendingMessage(randomId: string, finalMessage: any) {\n    const pendingData = this.pendingByRandomId[randomId];\n    // this.log('pdata', randomID, pendingData)\n\n    if(pendingData) {\n      const {peerId, tempId, threadId, storage} = pendingData;\n\n      [this.getHistoryStorage(peerId), threadId ? this.getHistoryStorage(peerId, threadId) : undefined]\n      .filter(Boolean)\n      .forEach(storage => {\n        storage.history.delete(tempId);\n      });\n\n      // this.log('pending', randomID, historyStorage.pending)\n\n      const message = this.getMessageFromStorage(storage, tempId);\n      if(!message.deleted) {\n        delete message.pFlags.is_outgoing;\n        delete message.pending;\n        delete message.error;\n        delete message.random_id;\n        delete message.send;\n\n        rootScope.dispatchEvent('messages_pending');\n      }\n      \n      delete this.pendingByRandomId[randomId];\n\n      this.finalizePendingMessageCallbacks(storage, tempId, finalMessage.mid);\n\n      return message;\n    }\n\n    return false;\n  }\n\n  public finalizePendingMessageCallbacks(storage: MessagesStorage, tempId: number, mid: number) {\n    const message = this.getMessageFromStorage(storage, mid);\n    const callbacks = this.tempFinalizeCallbacks[tempId];\n    //this.log.warn(callbacks, tempId);\n    if(callbacks !== undefined) {\n      for(const name in callbacks) {\n        const {deferred, callback} = callbacks[name];\n        //this.log(`finalizePendingMessageCallbacks: will invoke ${name} callback`);\n        callback(message).then(deferred.resolve, deferred.reject);\n      }\n\n      delete this.tempFinalizeCallbacks[tempId];\n    }\n\n    // set cached url to media\n    if(message.media) {\n      if(message.media.photo) {\n        const photo = appPhotosManager.getPhoto('' + tempId);\n        if(/* photo._ !== 'photoEmpty' */photo) {\n          const newPhoto = message.media.photo as MyPhoto;\n          const newPhotoSize = newPhoto.sizes[newPhoto.sizes.length - 1];\n          const cacheContext = appDownloadManager.getCacheContext(newPhoto, newPhotoSize.type);\n          const oldCacheContext = appDownloadManager.getCacheContext(photo, 'full');\n          Object.assign(cacheContext, oldCacheContext);\n\n          const photoSize = newPhoto.sizes[newPhoto.sizes.length - 1] as PhotoSize.photoSize;\n\n          const downloadOptions = appPhotosManager.getPhotoDownloadOptions(newPhoto, photoSize);\n          const fileName = getFileNameByLocation(downloadOptions.location);\n          appDownloadManager.fakeDownload(fileName, oldCacheContext.url);\n        }\n      } else if(message.media.document) {\n        const doc = appDocsManager.getDoc('' + tempId);\n        if(doc) {\n          if(/* doc._ !== 'documentEmpty' &&  */doc.type && doc.type !== 'sticker') {\n            const newDoc = message.media.document;\n            const cacheContext = appDownloadManager.getCacheContext(newDoc);\n            const oldCacheContext = appDownloadManager.getCacheContext(doc);\n            Object.assign(cacheContext, oldCacheContext);\n\n            const fileName = appDocsManager.getInputFileName(newDoc);\n            appDownloadManager.fakeDownload(fileName, oldCacheContext.url);\n          }\n        }\n      } else if(message.media.poll) {\n        delete appPollsManager.polls[tempId];\n        delete appPollsManager.results[tempId];\n      }\n    }\n\n    const tempMessage = this.getMessageFromStorage(storage, tempId);\n    delete storage[tempId];\n    \n    this.handleReleasingMessage(tempMessage);\n\n    rootScope.dispatchEvent('message_sent', {storage, tempId, tempMessage, mid});\n  }\n\n  public incrementMaxSeenId(maxId: number) {\n    if(!maxId || !(!this.maxSeenId || maxId > this.maxSeenId)) {\n      return false;\n    }\n\n    this.maxSeenId = maxId;\n    appStateManager.pushToState('maxSeenMsgId', maxId);\n\n    apiManager.invokeApi('messages.receivedMessages', {\n      max_id: this.getServerMessageId(maxId)\n    });\n  }\n\n  private notifyAboutMessage(message: MyMessage, options: Partial<{\n    fwdCount: number,\n    peerTypeNotifySettings: PeerNotifySettings\n  }> = {}) {\n    const peerId = this.getMessagePeer(message);\n    const notification: NotifyOptions = {};\n    const peerString = appPeersManager.getPeerString(peerId);\n    let notificationMessage: string;\n\n    if(options.peerTypeNotifySettings.show_previews) {\n      if(message._ === 'message' && message.fwd_from && options.fwdCount) {\n        notificationMessage = I18n.format('Notifications.Forwarded', true, [options.fwdCount]);\n      } else {\n        notificationMessage = this.wrapMessageForReply(message, undefined, undefined, true);\n      }\n    } else {\n      notificationMessage = I18n.format('Notifications.New', true);\n    }\n\n    notification.title = appPeersManager.getPeerTitle(peerId, true);\n    if(peerId < 0 && message.fromId !== message.peerId) {\n      notification.title = appPeersManager.getPeerTitle(message.fromId, true) +\n        ' @ ' +\n        notification.title;\n    }\n\n    notification.title = RichTextProcessor.wrapPlainText(notification.title);\n\n    notification.onclick = () => {\n      rootScope.dispatchEvent('history_focus', {peerId, mid: message.mid});\n    };\n\n    notification.message = notificationMessage;\n    notification.key = 'msg' + message.mid;\n    notification.tag = peerString;\n    notification.silent = true;//message.pFlags.silent || false;\n\n    const peerPhoto = appPeersManager.getPeerPhoto(peerId);\n    if(peerPhoto) {\n      appAvatarsManager.loadAvatar(peerId, peerPhoto, 'photo_small').loadPromise.then(url => {\n        if(message.pFlags.unread) {\n          notification.image = url;\n          appNotificationsManager.notify(notification);\n        }\n      });\n    } else {\n      appNotificationsManager.notify(notification);\n    }\n  }\n\n  public getScheduledMessagesStorage(peerId: number) {\n    return this.scheduledMessagesStorage[peerId] ?? (this.scheduledMessagesStorage[peerId] = this.createMessageStorage());\n  }\n\n  public getScheduledMessages(peerId: number): Promise<number[]> {\n    if(!this.canWriteToPeer(peerId)) return Promise.resolve([]);\n\n    const storage = this.getScheduledMessagesStorage(peerId);\n    if(Object.keys(storage).length) {\n      return Promise.resolve(Object.keys(storage).map(id => +id));\n    }\n\n    return apiManager.invokeApiSingle('messages.getScheduledHistory', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      hash: 0\n    }).then(historyResult => {\n      if(historyResult._ !== 'messages.messagesNotModified') {\n        appUsersManager.saveApiUsers(historyResult.users);\n        appChatsManager.saveApiChats(historyResult.chats);\n        \n        const storage = this.getScheduledMessagesStorage(peerId);\n        this.saveMessages(historyResult.messages, {storage, isScheduled: true});\n        return Object.keys(storage).map(id => +id);\n      }\n      \n      return [];\n    });\n  }\n\n  public sendScheduledMessages(peerId: number, mids: number[]) {\n    return apiManager.invokeApi('messages.sendScheduledMessages', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      id: mids.map(mid => this.getServerMessageId(mid))\n    }).then(updates => {\n      apiUpdatesManager.processUpdateMessage(updates);\n    });\n  }\n\n  public deleteScheduledMessages(peerId: number, mids: number[]) {\n    return apiManager.invokeApi('messages.deleteScheduledMessages', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      id: mids.map(mid => this.getServerMessageId(mid))\n    }).then(updates => {\n      apiUpdatesManager.processUpdateMessage(updates);\n    });\n  }\n\n  public getMessageWithReplies(message: Message.message) {\n    if(message.peerId !== REPLIES_PEER_ID) {\n      message = this.filterMessages(message, message => !!(message as Message.message).replies)[0] as any;\n      if(!(message && message.replies && message.replies.pFlags.comments && message.replies.channel_id !== 777)) {\n        return;\n      }\n    }\n\n    return message;\n  }\n\n  public isFetchIntervalNeeded(peerId: number) {\n    return peerId < 0 && !appChatsManager.isInChat(peerId);\n  }\n\n  public async getNewHistory(peerId: number, threadId?: number) {\n    if(!this.isFetchIntervalNeeded(peerId)) {\n      return;\n    }\n\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\n    const slice = historyStorage.history.slice;\n    if(!slice.isEnd(SliceEnd.Bottom)) {\n      return;\n    }\n\n    delete historyStorage.maxId;\n    slice.unsetEnd(SliceEnd.Bottom);\n\n    // if there is no id - then request by first id because cannot request by id 0 with backLimit\n    let historyResult = this.getHistory(peerId, slice[0] ?? 1, 0, 50, threadId);\n    if(historyResult instanceof Promise) {\n      historyResult = await historyResult;\n    }\n\n    for(let i = 0, length = historyResult.history.length; i < length; ++i) {\n      this.handleNewMessage(peerId, historyResult.history[i]);\n    }\n\n    return historyStorage;\n  }\n\n  /**\n   * * https://core.telegram.org/api/offsets, offset_id is inclusive\n   */\n  public getHistory(peerId: number, maxId = 0, limit: number, backLimit?: number, threadId?: number): Promise<HistoryResult> | HistoryResult {\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\n\n    let offset = 0;\n    /* \n    let offsetFound = true;\n\n    if(maxId) {\n      offsetFound = false;\n      for(; offset < historyStorage.history.length; offset++) {\n        if(maxId > historyStorage.history.slice[offset]) {\n          offsetFound = true;\n          break;\n        }\n      }\n    }\n\n    if(offsetFound && (\n      historyStorage.count !== null && historyStorage.history.length === historyStorage.count ||\n      historyStorage.history.length >= offset + limit\n      )) {\n      if(backLimit) {\n        backLimit = Math.min(offset, backLimit);\n        offset = Math.max(0, offset - backLimit);\n        limit += backLimit;\n      } else {\n        limit = limit;\n      }\n\n      const history = historyStorage.history.slice.slice(offset, offset + limit);\n      return {\n        count: historyStorage.count,\n        history: history,\n        offsetIdOffset: offset\n      };\n    }\n\n    if(offsetFound) {\n      offset = 0;\n    } */\n\n    if(backLimit) {\n      offset = -backLimit;\n      limit += backLimit;\n\n      /* return this.requestHistory(reqPeerId, maxId, limit, offset, undefined, threadId).then((historyResult) => {\n        historyStorage.count = (historyResult as MessagesMessages.messagesMessagesSlice).count || historyResult.messages.length;\n\n        const history = (historyResult.messages as MyMessage[]).map(message => message.mid);\n        return {\n          count: historyStorage.count,\n          history,\n          offsetIdOffset: (historyResult as MessagesMessages.messagesMessagesSlice).offset_id_offset || 0\n        };\n      }); */\n    }\n\n    const haveSlice = historyStorage.history.sliceMe(maxId, offset, limit);\n    if(haveSlice && (haveSlice.slice.length === limit || (haveSlice.fulfilled & SliceEnd.Both) === SliceEnd.Both)) {\n      return {\n        count: historyStorage.count,\n        history: haveSlice.slice,\n        offsetIdOffset: haveSlice.offsetIdOffset\n      }; \n    }\n\n    return this.fillHistoryStorage(peerId, maxId, limit, offset, historyStorage, threadId).then(() => {\n      const slice = historyStorage.history.sliceMe(maxId, offset, limit);\n      return {\n        count: historyStorage.count,\n        history: slice?.slice || historyStorage.history.constructSlice(),\n        offsetIdOffset: slice?.offsetIdOffset || historyStorage.count\n      };\n    });\n  }\n\n  public fillHistoryStorage(peerId: number, offset_id: number, limit: number, add_offset: number, historyStorage: HistoryStorage, threadId?: number): Promise<void> {\n    return this.requestHistory(peerId, offset_id, limit, add_offset, undefined, threadId).then((historyResult) => {\n      const {offset_id_offset, count, messages} = historyResult as MessagesMessages.messagesMessagesSlice;\n\n      historyStorage.count = count || messages.length;\n      const offsetIdOffset = offset_id_offset || 0;\n\n      const topWasMeantToLoad = add_offset < 0 ? limit + add_offset : limit;\n\n      const isTopEnd = offsetIdOffset >= (historyStorage.count - topWasMeantToLoad) || historyStorage.count < topWasMeantToLoad;\n      const isBottomEnd = !offsetIdOffset || (add_offset < 0 && (offsetIdOffset + add_offset) <= 0);\n\n      /* if(!maxId && historyResult.messages.length) {\n        maxId = this.incrementMessageId((historyResult.messages[0] as MyMessage).mid, 1);\n      }\n\n      const wasTotalCount = historyStorage.history.length; */\n\n      const mids = messages.map((message) => {\n        if(this.mergeReplyKeyboard(historyStorage, message as MyMessage)) {\n          rootScope.dispatchEvent('history_reply_markup', {peerId});\n        }\n\n        return (message as MyMessage).mid;\n      });\n\n      // * add bound manually. \n      // * offset_id will be inclusive only if there is 'add_offset' <= -1 (-1 - will only include the 'offset_id')\n      if(offset_id && !mids.includes(offset_id) && offsetIdOffset < historyStorage.count) {\n        let i = 0;\n        for(const length = mids.length; i < length; ++i) {\n          if(offset_id > mids[i]) {\n            break;\n          }\n        }\n\n        mids.splice(i, 0, offset_id);\n      }\n      \n      const slice = historyStorage.history.insertSlice(mids) || historyStorage.history.slice;\n      if(isTopEnd) {\n        slice.setEnd(SliceEnd.Top);\n      }\n  \n      if(isBottomEnd) {\n        slice.setEnd(SliceEnd.Bottom);\n        historyStorage.maxId = slice[0]; // ! WARNING\n      }\n      \n      /* const isBackLimit = offset < 0 && -offset !== fullLimit;\n      if(isBackLimit) {\n        return;\n      }\n\n      const totalCount = historyStorage.history.length;\n      fullLimit -= (totalCount - wasTotalCount);\n\n      const migratedNextPeer = this.migratedFromTo[peerId];\n      const migratedPrevPeer = this.migratedToFrom[peerId]\n      const isMigrated = migratedNextPeer !== undefined || migratedPrevPeer !== undefined;\n\n      if(isMigrated) {\n        historyStorage.count = Math.max(historyStorage.count, totalCount) + 1;\n      }\n\n      if(fullLimit > 0) {\n        maxId = historyStorage.history.slice[totalCount - 1];\n        if(isMigrated) {\n          if(!historyResult.messages.length) {\n            if(migratedPrevPeer) {\n              maxId = 0;\n              peerId = migratedPrevPeer;\n            } else {\n              historyStorage.count = totalCount;\n              return true;\n            }\n          }\n\n          return this.fillHistoryStorage(peerId, maxId, fullLimit, historyStorage, threadId);\n        } else if(totalCount < historyStorage.count) {\n          return this.fillHistoryStorage(peerId, maxId, fullLimit, offset, historyStorage, threadId);\n        }\n      } */\n    });\n  }\n\n  public requestHistory(peerId: number, maxId: number, limit = 0, offset = 0, offsetDate = 0, threadId = 0): Promise<Exclude<MessagesMessages, MessagesMessages.messagesMessagesNotModified>> {\n    //console.trace('requestHistory', peerId, maxId, limit, offset);\n\n    //rootScope.broadcast('history_request');\n\n    const options: any = {\n      peer: appPeersManager.getInputPeerById(peerId),\n      offset_id: this.getServerMessageId(maxId) || 0,\n      offset_date: offsetDate,\n      add_offset: offset,\n      limit,\n      max_id: 0,\n      min_id: 0,\n      hash: 0\n    };\n\n    if(threadId) {\n      options.msg_id = this.getServerMessageId(threadId) || 0;\n    }\n\n    const promise: ReturnType<AppMessagesManager['requestHistory']> = apiManager.invokeApiSingle(threadId ? 'messages.getReplies' : 'messages.getHistory', options, {\n      //timeout: APITIMEOUT,\n      noErrorBox: true\n    }) as any;\n\n    return promise.then((historyResult) => {\n      if(DEBUG) {\n        this.log('requestHistory result:', peerId, historyResult, maxId, limit, offset);\n      }\n\n      appUsersManager.saveApiUsers(historyResult.users);\n      appChatsManager.saveApiChats(historyResult.chats);\n      this.saveMessages(historyResult.messages);\n\n      if(appPeersManager.isChannel(peerId)) {\n        apiUpdatesManager.addChannelState(-peerId, (historyResult as MessagesMessages.messagesChannelMessages).pts);\n      }\n\n      let length = historyResult.messages.length, count = (historyResult as MessagesMessages.messagesMessagesSlice).count;\n      if(length && historyResult.messages[length - 1].deleted) {\n        historyResult.messages.splice(length - 1, 1);\n        length--;\n        count--;\n      }\n\n      // will load more history if last message is album grouped (because it can be not last item)\n      // historyResult.messages: desc sorted\n      const historyStorage = this.getHistoryStorage(peerId, threadId);\n      const oldestMessage: Message.message = historyResult.messages[length - 1] as any;\n      if(length && oldestMessage.grouped_id) {\n        const foundSlice = historyStorage.history.findSlice(oldestMessage.mid);\n        if(foundSlice && (foundSlice.slice.length + historyResult.messages.length) < count) {\n          return this.requestHistory(peerId, oldestMessage.mid, 10, 0, offsetDate, threadId).then((_historyResult) => {\n            return historyResult;\n          });\n        }\n      }\n\n      return historyResult;\n    }, (error) => {\n      switch (error.type) {\n        case 'CHANNEL_PRIVATE':\n          let channel = appChatsManager.getChat(-peerId);\n          channel = {_: 'channelForbidden', access_hash: channel.access_hash, title: channel.title};\n          apiUpdatesManager.processUpdateMessage({\n            _: 'updates',\n            updates: [{\n              _: 'updateChannel',\n              channel_id: -peerId\n            }],\n            chats: [channel],\n            users: []\n          });\n          break;\n      }\n\n      throw error;\n    });\n  }\n\n  public fetchSingleMessages() {\n    if(this.fetchSingleMessagesPromise) {\n      return this.fetchSingleMessagesPromise;\n    }\n\n    return this.fetchSingleMessagesPromise = new Promise((resolve) => {\n      setTimeout(() => {\n        let promises: Promise<void>[] = [];\n        \n        for(const peerId in this.needSingleMessages) {\n          const mids = this.needSingleMessages[peerId];\n          delete this.needSingleMessages[peerId];\n    \n          const msgIds: InputMessage[] = mids.map((msgId: number) => {\n            return {\n              _: 'inputMessageID',\n              id: this.getServerMessageId(msgId)\n            };\n          });\n    \n          let promise: Promise<MethodDeclMap['channels.getMessages']['res'] | MethodDeclMap['messages.getMessages']['res']>;\n          if(+peerId < 0 && appPeersManager.isChannel(+peerId)) {\n            promise = apiManager.invokeApiSingle('channels.getMessages', {\n              channel: appChatsManager.getChannelInput(-+peerId),\n              id: msgIds\n            });\n          } else {\n            promise = apiManager.invokeApiSingle('messages.getMessages', {\n              id: msgIds\n            });\n          }\n    \n          promises.push(promise.then(getMessagesResult => {\n            if(getMessagesResult._ !== 'messages.messagesNotModified') {\n              appUsersManager.saveApiUsers(getMessagesResult.users);\n              appChatsManager.saveApiChats(getMessagesResult.chats);\n              this.saveMessages(getMessagesResult.messages);\n            }\n    \n            rootScope.dispatchEvent('messages_downloaded', {peerId: +peerId, mids});\n          }));\n        }\n\n        Promise.all(promises).finally(() => {\n          this.fetchSingleMessagesPromise = null;\n          if(Object.keys(this.needSingleMessages).length) this.fetchSingleMessages();\n          resolve();\n        });\n      }, 0);\n    });\n  }\n\n  public wrapSingleMessage(peerId: number, msgId: number, overwrite = false): Promise<void> {\n    if(!this.getMessageByPeer(peerId, msgId).deleted && !overwrite) {\n      rootScope.dispatchEvent('messages_downloaded', {peerId, mids: [msgId]});\n      return Promise.resolve();\n    } else if(!this.needSingleMessages[peerId] || this.needSingleMessages[peerId].indexOf(msgId) === -1) {\n      (this.needSingleMessages[peerId] ?? (this.needSingleMessages[peerId] = [])).push(msgId);\n      return this.fetchSingleMessages();\n    } else if(this.fetchSingleMessagesPromise) {\n      return this.fetchSingleMessagesPromise;\n    }\n  }\n\n  public setTyping(peerId: number, action: SendMessageAction): Promise<boolean> {\n    let typing = this.typings[peerId];\n    if(!rootScope.myId || \n      !peerId || \n      !this.canWriteToPeer(peerId) || \n      peerId === rootScope.myId ||\n      typing?.type === action._\n    ) {\n      return Promise.resolve(false);\n    }\n\n    if(typing?.timeout) {\n      clearTimeout(typing.timeout);\n    }\n\n    typing = this.typings[peerId] = {\n      type: action._\n    };\n\n    return apiManager.invokeApi('messages.setTyping', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      action\n    }).finally(() => {\n      if(typing === this.typings[peerId]) {\n        typing.timeout = window.setTimeout(() => {\n          delete this.typings[peerId];\n        }, 6000);\n      }\n    });\n  }\n\n  private handleReleasingMessage(message: MyMessage) {\n    if('media' in message) {\n      // @ts-ignore\n      const c = message.media.webpage || message.media;\n      const smth: Photo.photo | MyDocument = c.photo || c.document;\n\n      if(smth?.file_reference) {\n        referenceDatabase.deleteContext(smth.file_reference, {type: 'message', peerId: message.peerId, messageId: message.mid});\n      }\n\n      if('webpage' in message.media) {\n        appWebPagesManager.deleteWebPageFromPending(message.media.webpage, message.mid);\n      }\n    }\n  }\n\n  private handleDeletedMessages(peerId: number, storage: MessagesStorage, messages: number[]) {\n    const history: {\n      count: number, \n      unread: number, \n      msgs: {[mid: number]: true},\n      albums?: {[groupId: string]: Set<number>},\n    } = {count: 0, unread: 0, msgs: {}} as any;\n\n    for(const mid of messages) {\n      const message: MyMessage = this.getMessageFromStorage(storage, mid);\n      if(message.deleted) continue;\n\n      this.handleReleasingMessage(message);\n\n      this.updateMessageRepliesIfNeeded(message);\n\n      if(!message.pFlags.out && !message.pFlags.is_outgoing && message.pFlags.unread) {\n        history.unread++;\n        appNotificationsManager.cancel('msg' + mid);\n      }\n      history.count++;\n      history.msgs[mid] = true;\n\n      message.deleted = true;\n\n      if(message._ !== 'messageService' && message.grouped_id) {\n        const groupedStorage = this.groupedMessagesStorage[message.grouped_id];\n        if(groupedStorage) {\n          delete groupedStorage[mid];\n\n          if(!history.albums) history.albums = {};\n          (history.albums[message.grouped_id] || (history.albums[message.grouped_id] = new Set())).add(mid);\n\n          if(!Object.keys(groupedStorage).length) {\n            delete history.albums;\n            delete this.groupedMessagesStorage[message.grouped_id];\n          }\n        }\n      }\n\n      delete storage[mid];\n\n      const peerMessagesToHandle = this.newMessagesToHandle[peerId];\n      if(peerMessagesToHandle && peerMessagesToHandle.has(mid)) {\n        peerMessagesToHandle.delete(mid);\n      }\n    }\n\n    if(history.albums) {\n      for(const groupId in history.albums) {\n        rootScope.dispatchEvent('album_edit', {peerId, groupId, deletedMids: [...history.albums[groupId]]});\n        /* const mids = this.getMidsByAlbum(groupId);\n        if(mids.length) {\n          const mid = Math.max(...mids);\n          rootScope.$broadcast('message_edit', {peerId, mid, justMedia: false});\n        } */\n      }\n    }\n\n    return history;\n  }\n  \n  private handleEditedMessage(oldMessage: any, newMessage: any) {\n    if(oldMessage.media?.webpage) {\n      appWebPagesManager.deleteWebPageFromPending(oldMessage.media.webpage, oldMessage.mid);\n    }\n  }\n}\n\nconst appMessagesManager = new AppMessagesManager();\nMOUNT_CLASS_TO.appMessagesManager = appMessagesManager;\nexport default appMessagesManager;\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport { formatPhoneNumber } from \"../../components/misc\";\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\nimport { filterUnique } from \"../../helpers/array\";\nimport cleanSearchText from \"../../helpers/cleanSearchText\";\nimport cleanUsername from \"../../helpers/cleanUsername\";\nimport { tsNow } from \"../../helpers/date\";\nimport { safeReplaceObject, isObject } from \"../../helpers/object\";\nimport { InputUser, User as MTUser, UserProfilePhoto, UserStatus } from \"../../layer\";\nimport I18n, { i18n, LangPackKey } from \"../langPack\";\n//import apiManager from '../mtproto/apiManager';\nimport apiManager from '../mtproto/mtprotoworker';\nimport { REPLIES_PEER_ID } from \"../mtproto/mtproto_config\";\nimport serverTimeManager from \"../mtproto/serverTimeManager\";\nimport { RichTextProcessor } from \"../richtextprocessor\";\nimport rootScope from \"../rootScope\";\nimport SearchIndex from \"../searchIndex\";\nimport apiUpdatesManager from \"./apiUpdatesManager\";\nimport appChatsManager from \"./appChatsManager\";\nimport appPeersManager from \"./appPeersManager\";\nimport appStateManager from \"./appStateManager\";\n\n// TODO: updateUserBlocked\n\nexport type User = MTUser.user;\n\nexport class AppUsersManager {\n  private storage = appStateManager.storages.users;\n  \n  private users: {[userId: number]: User};\n  private usernames: {[username: string]: number};\n  private contactsIndex: SearchIndex<number>;\n  private contactsFillPromise: Promise<Set<number>>;\n  private contactsList: Set<number>;\n  private updatedContactsList: boolean;\n  \n  private getTopPeersPromise: Promise<number[]>;\n\n  constructor() {\n    this.clear(true);\n\n    setInterval(this.updateUsersStatuses, 60000);\n\n    rootScope.addEventListener('state_synchronized', this.updateUsersStatuses);\n\n    rootScope.addMultipleEventsListeners({\n      updateUserStatus: (update) => {\n        const userId = update.user_id;\n        const user = this.users[userId];\n        if(user) {\n          user.status = update.status;\n          if(user.status) {\n            if('expires' in user.status) {\n              user.status.expires -= serverTimeManager.serverTimeOffset;\n            }\n\n            if('was_online' in user.status) {\n              user.status.was_online -= serverTimeManager.serverTimeOffset;\n            }\n          }\n\n          //user.sortStatus = this.getUserStatusForSort(user.status);\n          rootScope.dispatchEvent('user_update', userId);\n          this.setUserToStateIfNeeded(user);\n        } //////else console.warn('No user by id:', userId);\n      },\n\n      updateUserPhoto: (update) => {\n        const userId = update.user_id;\n        const user = this.users[userId];\n        if(user) {\n          this.forceUserOnline(userId);\n\n          if(update.photo._ === 'userProfilePhotoEmpty') {\n            delete user.photo;\n          } else {\n            user.photo = safeReplaceObject(user.photo, update.photo);\n          }\n\n          this.setUserToStateIfNeeded(user);\n\n          rootScope.dispatchEvent('user_update', userId);\n          rootScope.dispatchEvent('avatar_update', userId);\n        } else console.warn('No user by id:', userId);\n      },\n\n      updateUserName: (update) => {\n        const userId = update.user_id;\n        const user = this.users[userId];\n        if(user) {\n          this.forceUserOnline(userId);\n          \n          this.saveApiUser(Object.assign({}, user, {\n            first_name: update.first_name,\n            last_name: update.last_name,\n            username: update.username\n          }), true);\n        }\n      }\n    });\n\n    /* case 'updateContactLink':\n    this.onContactUpdated(update.user_id, update.my_link._ === 'contactLinkContact');\n    break; */\n\n    rootScope.addEventListener('language_change', (e) => {\n      const userId = this.getSelf().id;\n      this.contactsIndex.indexObject(userId, this.getUserSearchText(userId));\n    });\n\n    appStateManager.getState().then((state) => {\n      const users = appStateManager.storagesResults.users;\n      if(users.length) {\n        for(let i = 0, length = users.length; i < length; ++i) {\n          const user = users[i];\n          if(user) {\n            this.users[user.id] = user;\n          }\n        }\n      }\n\n      const contactsList = state.contactsList;\n      if(contactsList && Array.isArray(contactsList)) {\n        contactsList.forEach(userId => {\n          this.pushContact(userId);\n        });\n\n        if(contactsList.length) {\n          this.contactsFillPromise = Promise.resolve(this.contactsList);\n        }\n      }\n\n      appStateManager.addEventListener('peerNeeded', (peerId: number) => {\n        if(peerId < 0 || this.storage.getFromCache(peerId)) {\n          return;\n        }\n\n        this.storage.set({\n          [peerId]: this.getUser(peerId)\n        });\n      });\n\n      appStateManager.addEventListener('peerUnneeded', (peerId: number) => {\n        if(peerId < 0 || !this.storage.getFromCache(peerId)) {\n          return;\n        }\n\n        this.storage.delete(peerId);\n      });\n    });\n  }\n\n  public clear(init = false) {\n    if(!init) {\n      const users = appStateManager.storagesResults.users;\n      for(const _userId in this.users) {\n        const userId = +_userId;\n        if(!userId) continue;\n        if(!appStateManager.isPeerNeeded(userId)) {\n          const user = this.users[userId];\n          if(user.username) {\n            delete this.usernames[cleanUsername(user.username)];\n          }\n\n          users.findAndSplice((user) => user.id === userId);\n          this.storage.delete(userId);\n          delete this.users[userId];\n        }\n      }\n    } else {\n      this.users = {};\n      this.usernames = {};\n    }\n    \n    this.contactsIndex = new SearchIndex();\n    this.contactsFillPromise = undefined;\n    this.contactsList = new Set();\n    this.updatedContactsList = false;\n  }\n\n  private onContactsModified() {\n    const contactsList = [...this.contactsList];\n    appStateManager.pushToState('contactsList', contactsList);\n  }\n\n  public fillContacts() {\n    if(this.contactsFillPromise && this.updatedContactsList) {\n      return this.contactsFillPromise;\n    }\n\n    this.updatedContactsList = true;\n\n    const promise = apiManager.invokeApi('contacts.getContacts').then((result) => {\n      if(result._ === 'contacts.contacts') {\n        this.saveApiUsers(result.users);\n\n        result.contacts.forEach((contact) => {\n          this.pushContact(contact.user_id);\n        });\n\n        this.onContactsModified();\n      }\n\n      this.contactsFillPromise = promise;\n\n      return this.contactsList;\n    });\n\n    return this.contactsFillPromise || (this.contactsFillPromise = promise);\n  }\n\n  public resolveUsername(username: string) {\n    if(username[0] === '@') {\n      username = username.slice(1);\n    }\n\n    username = username.toLowerCase();\n    if(this.usernames[username]) {\n      return Promise.resolve(this.users[this.usernames[username]]);\n    }\n\n    return apiManager.invokeApi('contacts.resolveUsername', {username}).then(resolvedPeer => {\n      this.saveApiUsers(resolvedPeer.users);\n      appChatsManager.saveApiChats(resolvedPeer.chats);\n\n      return appPeersManager.getPeer(appPeersManager.getPeerId(resolvedPeer.peer));\n    });\n  }\n\n  public pushContact(userId: number) {\n    this.contactsList.add(userId);\n    this.contactsIndex.indexObject(userId, this.getUserSearchText(userId));\n    appStateManager.requestPeer(userId, 'contacts');\n  }\n\n  public getUserSearchText(id: number) {\n    const user = this.users[id];\n    if(!user) {\n      return '';\n    }\n\n    const arr: string[] = [\n      user.first_name,\n      user.last_name,\n      user.phone,\n      user.username,\n      user.pFlags.self ? I18n.format('SavedMessages', true) : '',\n      user.pFlags.self ? 'Saved Messages' : ''\n    ];\n\n    return arr.filter(Boolean).join(' ');\n  }\n\n  public getContacts(query?: string, includeSaved = false) {\n    return this.fillContacts().then(_contactsList => {\n      let contactsList = [..._contactsList];\n      if(query) {\n        const results = this.contactsIndex.search(query);\n        const filteredContactsList = [...contactsList].filter(id => results.has(id));\n\n        contactsList = filteredContactsList;\n      }\n\n      contactsList.sort((userId1: number, userId2: number) => {\n        const sortName1 = (this.users[userId1] || {}).sortName || '';\n        const sortName2 = (this.users[userId2] || {}).sortName || '';\n\n        return sortName1.localeCompare(sortName2);\n      });\n\n      if(includeSaved) {\n        if(this.testSelfSearch(query)) {\n          contactsList.findAndSplice(p => p === rootScope.myId);\n          contactsList.unshift(rootScope.myId);\n        }\n      }\n\n      /* contactsList.sort((userId1: number, userId2: number) => {\n        const sortName1 = (this.users[userId1] || {}).sortName || '';\n        const sortName2 = (this.users[userId2] || {}).sortName || '';\n        if(sortName1 === sortName2) {\n          return 0;\n        } \n        \n        return sortName1 > sortName2 ? 1 : -1;\n      }); */\n\n      return contactsList;\n    });\n  }\n\n  public toggleBlock(peerId: number, block: boolean) {\n    return apiManager.invokeApiSingle(block ? 'contacts.block' : 'contacts.unblock', {\n      id: appPeersManager.getInputPeerById(peerId)\n    }).then(value => {\n      if(value) {\n        apiUpdatesManager.processLocalUpdate({\n          _: 'updatePeerBlocked',\n          peer_id: appPeersManager.getOutputPeer(peerId),\n          blocked: block\n        });\n      }\n\n      return value;\n    });\n  }\n\n  public testSelfSearch(query: string) {\n    const user = this.getSelf();\n    const index = new SearchIndex();\n    index.indexObject(user.id, this.getUserSearchText(user.id));\n    return index.search(query).has(user.id);\n  }\n\n  public saveApiUsers(apiUsers: any[], override?: boolean) {\n    apiUsers.forEach((user) => this.saveApiUser(user, override));\n  }\n\n  public saveApiUser(user: MTUser, override?: boolean) {\n    if(user._ === 'userEmpty') return;\n\n    const userId = user.id;\n    const oldUser = this.users[userId];\n\n    // ! commented block can affect performance !\n    // if(oldUser && !override) {\n    //   console.log('saveApiUser same');\n    //   return;\n    // }\n\n    if(user.pFlags === undefined) {\n      user.pFlags = {};\n    }\n\n    if(user.pFlags.min && oldUser !== undefined) {\n      return;\n    }\n\n    // * exclude from state\n    // defineNotNumerableProperties(user, ['initials', 'num', 'rFirstName', 'rFullName', 'rPhone', 'sortName', 'sortStatus']);\n\n    const fullName = user.first_name + ' ' + (user.last_name || '');\n    if(user.username) {\n      const searchUsername = cleanUsername(user.username);\n      this.usernames[searchUsername] = userId;\n    }\n\n    user.sortName = user.pFlags.deleted ? '' : cleanSearchText(fullName, false);\n\n    user.initials = RichTextProcessor.getAbbreviation(fullName);\n\n    if(user.status) {\n      if((user.status as UserStatus.userStatusOnline).expires) {\n        (user.status as UserStatus.userStatusOnline).expires -= serverTimeManager.serverTimeOffset;\n      }\n\n      if((user.status as UserStatus.userStatusOffline).was_online) {\n        (user.status as UserStatus.userStatusOffline).was_online -= serverTimeManager.serverTimeOffset;\n      }\n    }\n\n    //user.sortStatus = user.pFlags.bot ? -1 : this.getUserStatusForSort(user.status);\n\n    let changedPhoto = false, changedTitle = false;\n    if(oldUser === undefined) {\n      this.users[userId] = user;\n    } else {\n      if(user.first_name !== oldUser.first_name \n        || user.last_name !== oldUser.last_name \n        || user.username !== oldUser.username) {\n        changedTitle = true;\n      }\n\n      const oldPhotoId = (oldUser.photo as UserProfilePhoto.userProfilePhoto)?.photo_id;\n      const newPhotoId = (user.photo as UserProfilePhoto.userProfilePhoto)?.photo_id;\n      if(oldPhotoId !== newPhotoId) {\n        changedPhoto = true;\n      }\n\n      /* if(user.pFlags.bot && user.bot_info_version !== oldUser.bot_info_version) {\n        \n      } */\n\n      safeReplaceObject(oldUser, user);\n      rootScope.dispatchEvent('user_update', userId);\n    }\n\n    if(changedPhoto) {\n      rootScope.dispatchEvent('avatar_update', user.id);\n    }\n\n    if(changedTitle) {\n      rootScope.dispatchEvent('peer_title_edit', user.id);\n    }\n\n    this.setUserToStateIfNeeded(user);\n  }\n\n  public setUserToStateIfNeeded(user: User) {\n    if(appStateManager.isPeerNeeded(user.id)) {\n      this.storage.set({\n        [user.id]: user\n      });\n    }\n  }\n\n  public formatUserPhone(phone: string) {\n    return '+' + formatPhoneNumber(phone).formatted;\n  }\n\n  public getUserStatusForSort(status: User['status'] | number) {\n    if(typeof(status) === 'number') {\n      status = this.getUser(status).status;\n    }\n\n    if(status) {\n      const expires = status._ === 'userStatusOnline' ? status.expires : (status._ === 'userStatusOffline' ? status.was_online : 0);\n      if(expires) {\n        return expires;\n      }\n\n      /* const timeNow = tsNow(true);\n      switch(status._) {\n        case 'userStatusRecently':\n          return timeNow - 86400 * 3;\n        case 'userStatusLastWeek':\n          return timeNow - 86400 * 7;\n        case 'userStatusLastMonth':\n          return timeNow - 86400 * 30;\n      } */\n      switch(status._) {\n        case 'userStatusRecently':\n          return 3;\n        case 'userStatusLastWeek':\n          return 2;\n        case 'userStatusLastMonth':\n          return 1;\n      }\n    }\n\n    return 0;\n  }\n\n  public getUser(id: any): User {\n    if(isObject(id)) {\n      return id;\n    }\n\n    return this.users[id] || {id: id, pFlags: {deleted: true}, access_hash: ''} as User;\n  }\n\n  public getSelf() {\n    return this.getUser(rootScope.myId);\n  }\n\n  public getUserStatusString(userId: number): HTMLElement {\n    let key: LangPackKey;\n    let args: any[];\n\n    switch(userId) {\n      case REPLIES_PEER_ID:\n        key = 'Peer.RepliesNotifications';\n        break;\n      case 777000:\n        key = 'Peer.ServiceNotifications';\n        break;\n      default: {\n        if(this.isBot(userId)) {\n          key = 'Bot';\n          break;\n        }\n\n        const user = this.getUser(userId);\n        if(!user) {\n          key = '' as any;\n          break;\n        }\n\n        if(user.pFlags.support) {\n          key = 'SupportStatus';\n          break;\n        }\n\n        switch(user.status?._) {\n          case 'userStatusRecently': {\n            key = 'Lately';\n            break;\n          }\n    \n          case 'userStatusLastWeek': {\n            key = 'WithinAWeek';\n            break;\n          }\n    \n          case 'userStatusLastMonth': {\n            key = 'WithinAMonth';\n            break;\n          }\n          \n          case 'userStatusOffline': {\n            const date = user.status.was_online;\n            const now = Date.now() / 1000;\n            \n            if((now - date) < 60) {\n              key = 'Peer.Status.justNow';\n            } else if((now - date) < 3600) {\n              key = 'Peer.Status.minAgo';\n              const c = (now - date) / 60 | 0;\n              args = [c];\n            } else if(now - date < 86400) {\n              key = 'LastSeen.HoursAgo';\n              const c = (now - date) / 3600 | 0;\n              args = [c];\n            } else {\n              key = 'Peer.Status.LastSeenAt';\n              const d = new Date(date * 1000);\n              args = [('0' + d.getDate()).slice(-2) + '.' + ('0' + (d.getMonth() + 1)).slice(-2), \n                ('0' + d.getHours()).slice(-2) + ':' + ('0' + d.getMinutes()).slice(-2)];\n            }\n            \n            break;\n          }\n    \n          case 'userStatusOnline': {\n            key = 'Online';\n            break;\n          }\n    \n          default: {\n            key = 'ALongTimeAgo';\n            break;\n          }\n        }\n\n        break;\n      }\n    }\n    \n    return i18n(key, args);\n  }\n\n  public isBot(id: number) {\n    return this.users[id] && this.users[id].pFlags.bot;\n  }\n\n  public isContact(id: number) {\n    return this.contactsList.has(id) || (this.users[id] && this.users[id].pFlags.contact);\n  }\n  \n  public isRegularUser(id: number) {\n    const user = this.users[id];\n    return user && !this.isBot(id) && !user.pFlags.deleted && !user.pFlags.support;\n  }\n\n  public isNonContactUser(id: number) {\n    return this.isRegularUser(id) && !this.isContact(id) && id !== rootScope.myId;\n  }\n\n  public hasUser(id: number, allowMin?: boolean) {\n    const user = this.users[id];\n    return isObject(user) && (allowMin || !user.pFlags.min);\n  }\n\n  public canSendToUser(id: number) {\n    const user = this.getUser(id);\n    return !user.pFlags.deleted && user.username !== 'replies';\n  }\n\n  public getUserPhoto(id: number) {\n    const user = this.getUser(id);\n\n    return user && user.photo || {\n      _: 'userProfilePhotoEmpty'\n    };\n  }\n\n  public getUserString(id: number) {\n    const user = this.getUser(id);\n    return 'u' + id + (user.access_hash ? '_' + user.access_hash : '');\n  }\n\n  public getUserInput(id: number): InputUser {\n    const user = this.getUser(id);\n    if(user.pFlags && user.pFlags.self) {\n      return {_: 'inputUserSelf'};\n    }\n\n    return {\n      _: 'inputUser',\n      user_id: id,\n      access_hash: user.access_hash\n    };\n  }\n\n  public updateUsersStatuses = () => {\n    const timestampNow = tsNow(true);\n    for(const i in this.users) {\n      const user = this.users[i];\n\n      if(user.status &&\n        user.status._ === 'userStatusOnline' &&\n        user.status.expires < timestampNow) {\n\n        user.status = {_: 'userStatusOffline', was_online: user.status.expires};\n        rootScope.dispatchEvent('user_update', user.id);\n\n        this.setUserToStateIfNeeded(user);\n      }\n    }\n  };\n\n  public forceUserOnline(id: number, eventTimestamp?: number) {\n    if(this.isBot(id)) {\n      return;\n    }\n\n    const timestamp = tsNow(true);\n    const onlineTimeFor = 60;\n    if(eventTimestamp) {\n      if((timestamp - eventTimestamp) >= onlineTimeFor) {\n        return;\n      }\n    } else if(apiUpdatesManager.updatesState.syncLoading) {\n      return;\n    }\n\n    const user = this.getUser(id);\n    if(user &&\n      user.status &&\n      user.status._ !== 'userStatusOnline' &&\n      user.status._ !== 'userStatusEmpty' &&\n      !user.pFlags.support &&\n      !user.pFlags.deleted) {\n\n      user.status = {\n        _: 'userStatusOnline',\n        expires: timestamp + onlineTimeFor\n      };\n      \n      //user.sortStatus = this.getUserStatusForSort(user.status);\n      rootScope.dispatchEvent('user_update', id);\n\n      this.setUserToStateIfNeeded(user);\n    }\n  }\n\n  /* function importContact (phone, firstName, lastName) {\n      return MtpApiManager.invokeApi('contacts.importContacts', {\n        contacts: [{\n          _: 'inputPhoneContact',\n          client_id: '1',\n          phone: phone,\n          first_name: firstName,\n          last_name: lastName\n        }],\n        replace: false\n      }).then(function (importedContactsResult) {\n        saveApiUsers(importedContactsResult.users)\n\n        var foundUserID = false\n        angular.forEach(importedContactsResult.imported, function (importedContact) {\n          onContactUpdated(foundUserID = importedContact.user_id, true)\n        })\n\n        return foundUserID || false\n      })\n  }\n\n  function importContacts (contacts) {\n    var inputContacts = [],\n      i\n    var j\n\n    for (i = 0; i < contacts.length; i++) {\n      for (j = 0; j < contacts[i].phones.length; j++) {\n        inputContacts.push({\n          _: 'inputPhoneContact',\n          client_id: (i << 16 | j).toString(10),\n          phone: contacts[i].phones[j],\n          first_name: contacts[i].first_name,\n          last_name: contacts[i].last_name\n        })\n      }\n    }\n\n    return MtpApiManager.invokeApi('contacts.importContacts', {\n      contacts: inputContacts,\n      replace: false\n    }).then(function (importedContactsResult) {\n      saveApiUsers(importedContactsResult.users)\n\n      var result = []\n      angular.forEach(importedContactsResult.imported, function (importedContact) {\n        onContactUpdated(importedContact.user_id, true)\n        result.push(importedContact.user_id)\n      })\n\n      return result\n    })\n  } */\n\n  /* public deleteContacts(userIds: number[]) {\n    var ids: any[] = [];\n    userIds.forEach((userId) => {\n      ids.push(this.getUserInput(userId));\n    })\n\n    return apiManager.invokeApi('contacts.deleteContacts', {\n      id: ids\n    }).then(() => {\n      userIds.forEach((userId) => {\n        this.onContactUpdated(userId, false);\n      });\n    });\n  } */\n\n  public getTopPeers(): Promise<number[]> {\n    if(this.getTopPeersPromise) return this.getTopPeersPromise;\n\n    return this.getTopPeersPromise = appStateManager.getState().then((state) => {\n      if(state?.topPeers?.length) {\n        return state.topPeers;\n      }\n\n      return apiManager.invokeApi('contacts.getTopPeers', {\n        correspondents: true,\n        offset: 0,\n        limit: 15,\n        hash: 0,\n      }).then((result) => {\n        let peerIds: number[] = [];\n        if(result._ === 'contacts.topPeers') {\n          //console.log(result);\n          this.saveApiUsers(result.users);\n          appChatsManager.saveApiChats(result.chats);\n\n          if(result.categories.length) {\n            peerIds = result.categories[0].peers.map((topPeer) => {\n              const peerId = appPeersManager.getPeerId(topPeer.peer);\n              appStateManager.requestPeer(peerId, 'topPeer');\n              return peerId;\n            });\n          }\n        }\n  \n        appStateManager.pushToState('topPeers', peerIds);\n  \n        return peerIds;\n      });\n    });\n  }\n\n  public getBlocked(offset = 0, limit = 0) {\n    return apiManager.invokeApiSingle('contacts.getBlocked', {offset, limit}).then(contactsBlocked => {\n      this.saveApiUsers(contactsBlocked.users);\n      appChatsManager.saveApiChats(contactsBlocked.chats);\n      const count = contactsBlocked._ === 'contacts.blocked' ? contactsBlocked.users.length + contactsBlocked.chats.length : contactsBlocked.count;\n\n      const peerIds = contactsBlocked.users.map(u => u.id).concat(contactsBlocked.chats.map(c => -c.id));\n\n      return {count, peerIds};\n    });\n  }\n\n  /* public searchContacts(query: string, limit = 20) {\n    return Promise.all([\n      this.getContacts(query),\n      apiManager.invokeApi('contacts.search', {\n        q: query,\n        limit\n      })\n    ]).then(results => {\n      const [myContacts, peers] = results;\n\n      this.saveApiUsers(peers.users);\n      appChatsManager.saveApiChats(peers.chats);\n\n      // * contacts.search returns duplicates in my_results\n      const myResults = new Set(myContacts.concat(peers.my_results.map(p => appPeersManager.getPeerID(p))));\n\n      const out = {\n        my_results: [...myResults].slice(0, limit),\n        results: peers.results.map(p => appPeersManager.getPeerID(p))\n      };\n\n      return out;\n    });\n  } */\n  public searchContacts(query: string, limit = 20) {\n    return apiManager.invokeApiCacheable('contacts.search', {\n      q: query,\n      limit\n    }, {cacheSeconds: 60}).then(peers => {\n      this.saveApiUsers(peers.users);\n      appChatsManager.saveApiChats(peers.chats);\n\n      const out = {\n        my_results: filterUnique(peers.my_results.map(p => appPeersManager.getPeerId(p))), // ! contacts.search returns duplicates in my_results\n        results: peers.results.map(p => appPeersManager.getPeerId(p))\n      };\n\n      return out;\n    });\n  }\n\n  private onContactUpdated(userId: number, isContact: boolean) {\n    const curIsContact = this.isContact(userId);\n    if(isContact !== curIsContact) {\n      if(isContact) {\n        this.pushContact(userId);\n      } else {\n        this.contactsList.delete(userId);\n      }\n\n      this.onContactsModified();\n\n      rootScope.dispatchEvent('contacts_update', userId);\n    }\n  }\n\n  public updateUsername(username: string) {\n    return apiManager.invokeApi('account.updateUsername', {\n      username\n    }).then((user) => {\n      this.saveApiUser(user);\n    });\n  }\n\n  public setUserStatus(userId: number, offline: boolean) {\n    if(this.isBot(userId)) {\n      return;\n    }\n\n    const user = this.users[userId];\n    if(user) {\n      const status: any = offline ? {\n        _: 'userStatusOffline',\n        was_online: tsNow(true)\n      } : {\n        _: 'userStatusOnline',\n        expires: tsNow(true) + 500\n      };\n\n      user.status = status;\n      //user.sortStatus = this.getUserStatusForSort(user.status);\n      rootScope.dispatchEvent('user_update', userId);\n    }\n  }\n\n  public addContact(userId: number, first_name: string, last_name: string, phone: string, showPhone?: true) {\n    return apiManager.invokeApi('contacts.addContact', {\n      id: this.getUserInput(userId),\n      first_name,\n      last_name,\n      phone,\n      add_phone_privacy_exception: showPhone\n    }).then((updates) => {\n      apiUpdatesManager.processUpdateMessage(updates, {override: true});\n\n      this.onContactUpdated(userId, true);\n    });\n  }\n\n  public deleteContacts(userIds: number[]) {\n    return apiManager.invokeApi('contacts.deleteContacts', {\n      id: userIds.map(userId => this.getUserInput(userId))\n    }).then((updates) => {\n      apiUpdatesManager.processUpdateMessage(updates, {override: true});\n\n      userIds.forEach(userId => {\n        this.onContactUpdated(userId, false);\n      });\n    });\n  }\n}\n\nconst appUsersManager = new AppUsersManager();\nMOUNT_CLASS_TO.appUsersManager = appUsersManager;\nexport default appUsersManager\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport Config from './config';\n\nimport emojiRegExp from '../vendor/emoji/regex';\nimport { encodeEmoji, toCodePoints } from '../vendor/emoji';\nimport { MessageEntity } from '../layer';\nimport { encodeEntities } from '../helpers/string';\nimport { isSafari } from '../helpers/userAgent';\nimport { MOUNT_CLASS_TO } from '../config/debug';\nimport IS_EMOJI_SUPPORTED from '../helpers/emojiSupport';\n\nconst EmojiHelper = {\n  emojiMap: (code: string) => { return code; },\n  shortcuts: [] as any,\n  emojis: [] as any\n};\n\nconst emojiData = Config.Emoji;\n\nconst alphaCharsRegExp = 'a-z' +\n  '\\\\u00c0-\\\\u00d6\\\\u00d8-\\\\u00f6\\\\u00f8-\\\\u00ff' + // Latin-1\n  '\\\\u0100-\\\\u024f' + // Latin Extended A and B\n  '\\\\u0253\\\\u0254\\\\u0256\\\\u0257\\\\u0259\\\\u025b\\\\u0263\\\\u0268\\\\u026f\\\\u0272\\\\u0289\\\\u028b' + // IPA Extensions\n  '\\\\u02bb' + // Hawaiian\n  '\\\\u0300-\\\\u036f' + // Combining diacritics\n  '\\\\u1e00-\\\\u1eff' + // Latin Extended Additional (mostly for Vietnamese)\n  '\\\\u0400-\\\\u04ff\\\\u0500-\\\\u0527' + // Cyrillic\n  '\\\\u2de0-\\\\u2dff\\\\ua640-\\\\ua69f' + // Cyrillic Extended A/B\n  '\\\\u0591-\\\\u05bf\\\\u05c1-\\\\u05c2\\\\u05c4-\\\\u05c5\\\\u05c7' +\n  '\\\\u05d0-\\\\u05ea\\\\u05f0-\\\\u05f4' + // Hebrew\n  '\\\\ufb1d-\\\\ufb28\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40-\\\\ufb41' +\n  '\\\\ufb43-\\\\ufb44\\\\ufb46-\\\\ufb4f' + // Hebrew Pres. Forms\n  '\\\\u0610-\\\\u061a\\\\u0620-\\\\u065f\\\\u066e-\\\\u06d3\\\\u06d5-\\\\u06dc' +\n  '\\\\u06de-\\\\u06e8\\\\u06ea-\\\\u06ef\\\\u06fa-\\\\u06fc\\\\u06ff' + // Arabic\n  '\\\\u0750-\\\\u077f\\\\u08a0\\\\u08a2-\\\\u08ac\\\\u08e4-\\\\u08fe' + // Arabic Supplement and Extended A\n  '\\\\ufb50-\\\\ufbb1\\\\ufbd3-\\\\ufd3d\\\\ufd50-\\\\ufd8f\\\\ufd92-\\\\ufdc7\\\\ufdf0-\\\\ufdfb' + // Pres. Forms A\n  '\\\\ufe70-\\\\ufe74\\\\ufe76-\\\\ufefc' + // Pres. Forms B\n  '\\\\u200c' + // Zero-Width Non-Joiner\n  '\\\\u0e01-\\\\u0e3a\\\\u0e40-\\\\u0e4e' + // Thai\n  '\\\\u1100-\\\\u11ff\\\\u3130-\\\\u3185\\\\uA960-\\\\uA97F\\\\uAC00-\\\\uD7AF\\\\uD7B0-\\\\uD7FF' + // Hangul (Korean)\n  '\\\\u3003\\\\u3005\\\\u303b' + // Kanji/Han iteration marks\n  '\\\\uff21-\\\\uff3a\\\\uff41-\\\\uff5a' + // full width Alphabet\n  '\\\\uff66-\\\\uff9f' + // half width Katakana\n  '\\\\uffa1-\\\\uffdc'; // half width Hangul (Korean)\nconst alphaNumericRegExp = '0-9\\_' + alphaCharsRegExp;\nconst domainAddChars = '\\u00b7';\n// Based on Regular Expression for URL validation by Diego Perini\nconst urlAlphanumericRegExpPart = '[' + alphaCharsRegExp + '0-9]';\nconst urlProtocolRegExpPart = '((?:https?|ftp)://|mailto:)?';\nconst urlRegExp = urlProtocolRegExpPart +\n  // user:pass authentication\n  '(?:' + urlAlphanumericRegExpPart + '{1,64}(?::' + urlAlphanumericRegExpPart + '{0,64})?@)?' +\n  '(?:' +\n  // sindresorhus/ip-regexp\n  '(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])(?:\\\\.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])){3}' +\n  '|' +\n  // host name\n  urlAlphanumericRegExpPart + '[' + alphaCharsRegExp + domainAddChars + '0-9\\-]{0,64}' +\n  // domain name\n  '(?:\\\\.' + urlAlphanumericRegExpPart + '[' + alphaCharsRegExp + domainAddChars + '0-9\\-]{0,64}){0,10}' +\n  // TLD identifier\n  '(?:\\\\.(xn--[0-9a-z]{2,16}|[' + alphaCharsRegExp + ']{2,24}))' +\n  ')' +\n  // port number\n  '(?::\\\\d{2,5})?' +\n  // resource path\n  '(?:/(?:\\\\S{0,255}[^\\\\s.;,(\\\\[\\\\]{}<>\"\\'])?)?';\nconst urlProtocolRegExp = new RegExp('^' + urlProtocolRegExpPart.slice(0, -1), 'i');\nconst urlAnyProtocolRegExp = /^((?:.+?):\\/\\/|mailto:)/;\nconst usernameRegExp = '[a-zA-Z\\\\d_]{5,32}';\nconst botCommandRegExp = '\\\\/([a-zA-Z\\\\d_]{1,32})(?:@(' + usernameRegExp + '))?(\\\\b|$)';\nconst fullRegExp = new RegExp('(^| )(@)(' + usernameRegExp + ')|(' + urlRegExp + ')|(\\\\n)|(' + emojiRegExp + ')|(^|[\\\\s\\\\(\\\\]])(#[' + alphaNumericRegExp + ']{2,64})|(^|\\\\s)' + botCommandRegExp, 'i');\nconst emailRegExp = /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n//const markdownTestRegExp = /[`_*@~]/;\nconst markdownRegExp = /(^|\\s|\\n)(````?)([\\s\\S]+?)(````?)([\\s\\n\\.,:?!;]|$)|(^|\\s|\\x01)(`|~~|\\*\\*|__|_-_)([^\\n]+?)\\7([\\x01\\s\\.,:?!;]|$)|@(\\d+)\\s*\\((.+?)\\)|(\\[(.+?)\\]\\((.+?)\\))/m;\nconst siteHashtags: {[siteName: string]: string} = {\n  Telegram: 'tg://search_hashtag?hashtag={1}',\n  Twitter: 'https://twitter.com/hashtag/{1}',\n  Instagram: 'https://instagram.com/explore/tags/{1}/',\n  'Google Plus': 'https://plus.google.com/explore/{1}'\n};\n\nconst siteMentions: {[siteName: string]: string} = {\n  Telegram: '#/im?p=%40{1}',\n  Twitter: 'https://twitter.com/{1}',\n  Instagram: 'https://instagram.com/{1}/',\n  GitHub: 'https://github.com/{1}'\n};\nconst markdownEntities: {[markdown: string]: MessageEntity['_']} = {\n  '`': 'messageEntityCode',\n  '``': 'messageEntityPre',\n  '**': 'messageEntityBold',\n  '__': 'messageEntityItalic',\n  '~~': 'messageEntityStrike',\n  '_-_': 'messageEntityUnderline'\n};\n\nconst passConflictingEntities: Set<MessageEntity['_']> = new Set([\n  'messageEntityEmoji',\n  'messageEntityLinebreak',\n  'messageEntityCaret'\n]);\nfor(let i in markdownEntities) {\n  passConflictingEntities.add(markdownEntities[i]);\n}\n\nnamespace RichTextProcessor {\n  export const emojiSupported = IS_EMOJI_SUPPORTED;\n\n  export function getEmojiSpritesheetCoords(emojiCode: string) {\n    let unified = encodeEmoji(emojiCode).replace(/-?fe0f/g, '');\n  \n    /* if(unified === '1f441-200d-1f5e8') {\n      //unified = '1f441-fe0f-200d-1f5e8-fe0f';\n      unified = '1f441-fe0f-200d-1f5e8';\n    } */\n  \n    if(!emojiData.hasOwnProperty(unified) \n      // && !emojiData.hasOwnProperty(unified.replace(/-?fe0f$/, ''))\n    ) {\n      //console.error('lol', unified);\n      return null;\n    }\n  \n    return unified;\n  }\n\n  export function parseEntities(text: string) {\n    let match: any;\n    let raw = text;\n    const entities: MessageEntity[] = [];\n    let matchIndex;\n    let rawOffset = 0;\n    // var start = tsNow()\n    fullRegExp.lastIndex = 0;\n    while((match = raw.match(fullRegExp))) {\n      matchIndex = rawOffset + match.index;\n  \n      //console.log('parseEntities match:', match);\n  \n      if(match[3]) { // mentions\n        entities.push({\n          _: 'messageEntityMention',\n          offset: matchIndex + match[1].length,\n          length: match[2].length + match[3].length\n        });\n      } else if(match[4]) {\n        if(emailRegExp.test(match[4])) { // email\n          entities.push({\n            _: 'messageEntityEmail',\n            offset: matchIndex,\n            length: match[4].length\n          });\n        } else {\n          let url: string;\n          let protocol = match[5];\n          const tld = match[6];\n          // let excluded = '';\n          if(tld) { // URL\n            if(!protocol && (tld.substr(0, 4) === 'xn--' || Config.TLD.indexOf(tld.toLowerCase()) !== -1)) {\n              protocol = 'http://';\n            }\n  \n            if(protocol) {\n              const balanced = checkBrackets(match[4]);\n              if(balanced.length !== match[4].length) {\n                // excluded = match[4].substring(balanced.length);\n                match[4] = balanced;\n              }\n  \n              url = (match[5] ? '' : protocol) + match[4];\n            }\n          } else { // IP address\n            url = (match[5] ? '' : 'http://') + match[4];\n          }\n  \n          if(url) {\n            entities.push({\n              _: 'messageEntityUrl',\n              offset: matchIndex,\n              length: match[4].length\n            });\n          }\n        }\n      } else if(match[7]) { // New line\n        entities.push({\n          _: 'messageEntityLinebreak',\n          offset: matchIndex,\n          length: 1\n        });\n      } else if(match[8]) { // Emoji\n        //console.log('hit', match[8]);\n        const emojiCoords = getEmojiSpritesheetCoords(match[8]);\n        if(emojiCoords) {\n          entities.push({\n            _: 'messageEntityEmoji',\n            offset: matchIndex,\n            length: match[8].length,\n            unicode: emojiCoords\n          });\n        }\n      } else if(match[11]) { // Hashtag\n        entities.push({\n          _: 'messageEntityHashtag',\n          offset: matchIndex + (match[10] ? match[10].length : 0),\n          length: match[11].length\n        });\n      } else if(match[13]) { // Bot command\n        entities.push({\n          _: 'messageEntityBotCommand',\n          offset: matchIndex + (match[11] ? match[11].length : 0) + (match[12] ? match[12].length : 0),\n          length: 1 + match[13].length + (match[14] ? 1 + match[14].length : 0),\n          unsafe: true\n        });\n      }\n  \n      raw = raw.substr(match.index + match[0].length);\n      rawOffset += match.index + match[0].length;\n    }\n  \n    // if (entities.length) {\n    //   console.log('parse entities', text, entities.slice())\n    // }\n    return entities;\n  }\n\n  /* export function parseEmojis(text: string) {\n    return text.replace(/:([a-z0-9\\-\\+\\*_]+?):/gi, function (all, shortcut) {\n      var emojiCode = EmojiHelper.shortcuts[shortcut]\n      if (emojiCode !== undefined) {\n        return EmojiHelper.emojis[emojiCode][0]\n      }\n      return all\n    })\n  } */\n\n  export function parseMarkdown(text: string, currentEntities: MessageEntity[], noTrim?: boolean): string {\n  \u00a0 /* if(!markdownTestRegExp.test(text)) {\n      return noTrim ? text : text.trim();\n    } */\n\n    const entities: MessageEntity[] = [];\n    let pushedEntity = false;\n    const pushEntity = (entity: MessageEntity) => !findConflictingEntity(currentEntities, entity) ? (entities.push(entity), pushedEntity = true) : pushedEntity = false;\n\n    let raw = text;\n    let match;\n    let newText: any = [];\n    let rawOffset = 0;\n    while(match = raw.match(markdownRegExp)) {\n      const matchIndex = rawOffset + match.index;\n      newText.push(raw.substr(0, match.index));\n      let text = (match[3] || match[8] || match[11] || match[13]);\n      rawOffset -= text.length;\n      //text = text.replace(/^\\s+|\\s+$/g, '');\n      rawOffset += text.length;\n\n      let entity: MessageEntity;\n      pushedEntity = false;\n      if(text.match(/^`*$/)) {\n        newText.push(match[0]);\n      } else if(match[3]) { // pre\n        entity = {\n          _: 'messageEntityPre',\n          language: '',\n          offset: matchIndex + match[1].length,\n          length: text.length\n        };\n\n        if(pushEntity(entity)) {\n          if(match[5] === '\\n') {\n            match[5] = '';\n            rawOffset -= 1;\n          }\n  \n          newText.push(match[1] + text + match[5]);\n          \n          rawOffset -= match[2].length + match[4].length;\n        }\n      } else if(match[7]) { // code|italic|bold\n        const isSOH = match[6] === '\\x01';\n\n        entity = {\n          _: markdownEntities[match[7]] as (MessageEntity.messageEntityBold | MessageEntity.messageEntityCode | MessageEntity.messageEntityItalic)['_'],\n          //offset: matchIndex + match[6].length,\n          offset: matchIndex + (isSOH ? 0 : match[6].length),\n          length: text.length\n        };\n\n        if(pushEntity(entity)) {\n          if(!isSOH) {\n            newText.push(match[6] + text + match[9]);\n          } else {\n            newText.push(text);\n          }\n  \n          rawOffset -= match[7].length * 2 + (isSOH ? 2 : 0);\n        }\n      } else if(match[11]) { // custom mention\n        entity = {\n          _: 'messageEntityMentionName',\n          user_id: +match[10],\n          offset: matchIndex,\n          length: text.length\n        };\n        \n        if(pushEntity(entity)) {\n          newText.push(text);\n          \n          rawOffset -= match[0].length - text.length;\n        }\n      } else if(match[12]) { // text url\n        entity = {\n          _: 'messageEntityTextUrl',\n          url: match[14],\n          offset: matchIndex,\n          length: text.length\n        };\n        \n        if(pushEntity(entity)) {\n          newText.push(text);\n\n          rawOffset -= match[12].length - text.length;\n        }\n      }\n\n      if(!pushedEntity) {\n        newText.push(match[0]);\n      }\n\n      raw = raw.substr(match.index + match[0].length);\n      rawOffset += match.index + match[0].length;\n    }\n\n    newText.push(raw);\n    newText = newText.join('');\n    if(!newText.replace(/\\s+/g, '').length) {\n      newText = text;\n      entities.splice(0, entities.length);\n    }\n\n    if(!entities.length && !noTrim) {\n      newText = newText.trim();\n    }\n\n    mergeEntities(currentEntities, entities);\n    combineSameEntities(currentEntities);\n\n    return newText;\n  }\n\n  export function findConflictingEntity(currentEntities: MessageEntity[], newEntity: MessageEntity) {\n    return currentEntities.find(currentEntity => {\n      const isConflictingTypes = newEntity._ === currentEntity._ || \n        (!passConflictingEntities.has(newEntity._) && !passConflictingEntities.has(currentEntity._));\n\n      if(!isConflictingTypes) {\n        return false;\n      }\n\n      const isConflictingOffset = newEntity.offset >= currentEntity.offset && \n        (newEntity.length + newEntity.offset) <= (currentEntity.length + currentEntity.offset);\n\n      return isConflictingOffset;\n    });\n  }\n\n  export function mergeEntities(currentEntities: MessageEntity[], newEntities: MessageEntity[]) {\n    const filtered = newEntities.filter(e => {\n      return !findConflictingEntity(currentEntities, e);\n    });\n\n    currentEntities.push(...filtered);\n    currentEntities.sort((a, b) => a.offset - b.offset);\n    return currentEntities;\n  }\n\n  export function combineSameEntities(entities: MessageEntity[]) {\n    //entities = entities.slice();\n    for(let i = 0; i < entities.length; ++i) {\n      const entity = entities[i];\n\n      let nextEntityIdx = -1;\n      do {\n        nextEntityIdx = entities.findIndex((e, _i) => _i !== i && e._ === entity._ && (e.offset - entity.length) === entity.offset);\n        if(nextEntityIdx !== -1) {\n          const nextEntity = entities[nextEntityIdx];\n          entity.length += nextEntity.length;\n          entities.splice(nextEntityIdx, 1);\n        }\n      } while(nextEntityIdx !== -1);\n    }\n    //return entities;\n  }\n\n  export function wrapRichText(text: string, options: Partial<{\n    entities: MessageEntity[],\n    contextSite: string,\n    highlightUsername: string,\n    noLinks: true,\n    noLinebreaks: true,\n    noCommands: true,\n    wrappingDraft: true,\n    //mustWrapEmoji: boolean,\n    fromBot: boolean,\n    noTextFormat: true,\n    passEntities: Partial<{\n      [_ in MessageEntity['_']]: boolean\n    }>,\n\n    contextHashtag?: string,\n  }> = {}) {\n    if(!text) {\n      return '';\n    }\n\n    const lol: {\n      part: string,\n      offset: number\n    }[] = [];\n    const entities = options.entities || parseEntities(text);\n\n    const passEntities: typeof options.passEntities = options.passEntities || {};\n    const contextSite = options.contextSite || 'Telegram';\n    const contextExternal = contextSite !== 'Telegram';\n\n    const insertPart = (entity: MessageEntity, startPart: string, endPart?: string) => {\n      lol.push({part: startPart, offset: entity.offset});\n\n      if(endPart) {\n        lol.unshift({part: endPart, offset: entity.offset + entity.length});\n      }\n    };\n\n    for(let i = 0, length = entities.length; i < length; ++i) {\n      const entity = entities[i];\n      switch(entity._) {\n        case 'messageEntityBold': {\n          if(!options.noTextFormat) {\n            if(options.wrappingDraft) {\n              insertPart(entity, '<span style=\"font-weight: bold;\">', '</span>');\n            } else {\n              insertPart(entity, '<strong>', '</strong>');\n            }\n          }\n\n          break;\n        }\n\n        case 'messageEntityItalic': {\n          if(!options.noTextFormat) {\n            if(options.wrappingDraft) {\n              insertPart(entity, '<span style=\"font-style: italic;\">', '</span>');\n            } else {\n              insertPart(entity, '<em>', '</em>');\n            }\n          }\n\n          break;\n        }\n\n        case 'messageEntityStrike': {\n          if(options.wrappingDraft) {\n            const styleName = isSafari ? 'text-decoration' : 'text-decoration-line';\n            insertPart(entity, `<span style=\"${styleName}: line-through;\">`, '</span>');\n          } else {\n            insertPart(entity, '<del>', '</del>');\n          }\n\n          break;\n        }\n\n        case 'messageEntityUnderline': {\n          if(options.wrappingDraft) {\n            const styleName = isSafari ? 'text-decoration' : 'text-decoration-line';\n            insertPart(entity, `<span style=\"${styleName}: underline;\">`, '</span>');\n          } else {\n            insertPart(entity, '<u>', '</u>');\n          }\n\n          break;\n        }\n          \n        case 'messageEntityCode': {\n          if(options.wrappingDraft) {\n            insertPart(entity, '<span style=\"font-family: monospace;\">', '</span>');\n          } else {\n            insertPart(entity, '<code>', '</code>');\n          }\n          \n          break;\n        }\n          \n        case 'messageEntityPre': {\n          if(!options.noTextFormat) {\n            insertPart(entity, `<pre><code${entity.language ? ' class=\"language-' + encodeEntities(entity.language) + '\"' : ''}>`, '</code></pre>');\n          }\n          \n          break;\n        }\n\n        case 'messageEntityHighlight': {\n          insertPart(entity, '<i class=\"text-highlight\">', '</i>');\n          break;\n        }\n\n        case 'messageEntityBotCommand': {\n          // if(!(options.noLinks || options.noCommands || contextExternal)/*  && !entity.unsafe */) {\n          if(!options.noLinks && passEntities[entity._]) {\n            const entityText = text.substr(entity.offset, entity.length);\n            let command = entityText.substr(1);\n            let bot: string | boolean;\n            let atPos: number;\n            if((atPos = command.indexOf('@')) !== -1) {\n              bot = command.substr(atPos + 1);\n              command = command.substr(0, atPos);\n            } else {\n              bot = options.fromBot;\n            }\n\n            insertPart(entity, `<a href=\"${encodeEntities('tg://bot_command?command=' + encodeURIComponent(command) + (bot ? '&bot=' + encodeURIComponent(bot) : ''))}\" ${contextExternal ? '' : 'onclick=\"execBotCommand(this)\"'}>`, `</a>`);\n          }\n\n          break;\n        }\n\n        case 'messageEntityEmoji': {\n          //if(!(options.wrappingDraft && emojiSupported)) { // * fix safari emoji\n          if(!emojiSupported) { // no wrapping needed\n            // if(emojiSupported) { // ! contenteditable=\"false\" \u043d\u0443\u0436\u0435\u043d \u0434\u043b\u044f \u043f\u043e\u043b\u044f \u0432\u0432\u043e\u0434\u0430, \u0438\u043d\u0430\u0447\u0435 \u0442\u0430\u043c \u0431\u0443\u0434\u0435\u0442 \u043c\u0435\u043d\u044f\u0442\u044c\u0441\u044f \u0448\u0440\u0438\u0444\u0442 \u0432 Safari, \u0438\u043b\u0438 \u0436\u0435 \u0440\u0435\u043d\u0434\u0435\u0440\u0438\u0442\u044c \u0441\u043c\u0430\u0439\u043b\u0438\u043a \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e, \u0431\u0435\u0437 \u043a\u043e\u043d\u0442\u0435\u0439\u043d\u0435\u0440\u0430\n            //   insertPart(entity, '<span class=\"emoji\">', '</span>');\n            // } else {\n              insertPart(entity, `<img src=\"assets/img/emoji/${entity.unicode}.png\" alt=\"`, `\" class=\"emoji\">`);\n            // }\n          }/*  else if(options.mustWrapEmoji) {\n            insertPart(entity, '<span class=\"emoji\">', '</span>');\n          } */\n          /* if(!emojiSupported) {\n            insertPart(entity, `<img src=\"assets/img/emoji/${entity.unicode}.png\" alt=\"`, `\" class=\"emoji\">`);\n          } */\n\n          break;\n        }\n        \n        case 'messageEntityCaret': {\n          insertPart(entity, '<span class=\"composer-sel\"></span>');\n          break;\n        }\n\n        /* case 'messageEntityLinebreak': {\n          if(options.noLinebreaks) {\n            insertPart(entity, ' ');\n          } else {\n            insertPart(entity, '<br/>');\n          }\n          \n          break;\n        } */\n\n        case 'messageEntityUrl':\n        case 'messageEntityTextUrl': {\n          if(!(options.noLinks && !passEntities[entity._])) {\n            const entityText = text.substr(entity.offset, entity.length);\n\n            // let inner: string;\n            let url: string = (entity as MessageEntity.messageEntityTextUrl).url || entityText;\n            let masked = false;\n            let onclick: string;\n\n            const wrapped = wrapUrl(url, true);\n            url = wrapped.url;\n            onclick = wrapped.onclick;\n\n            if(entity._ === 'messageEntityTextUrl') {\n              const nextEntity = entities[i + 1];\n              if(nextEntity?._ === 'messageEntityUrl' && \n                nextEntity.length === entity.length && \n                nextEntity.offset === entity.offset) {\n                i++;\n              }\n\n              if(url !== entityText) {\n                masked = true;\n              }\n            } else {\n              //inner = encodeEntities(replaceUrlEncodings(entityText));\n            }\n\n            const currentContext = url[0] === '#';\n            if(!onclick && masked && !currentContext) {\n              onclick = 'showMaskedAlert';\n            }\n\n            const href = (currentContext || typeof electronHelpers === 'undefined') \n              ? encodeEntities(url)\n              : `javascript:electronHelpers.openExternal('${encodeEntities(url)}');`;\n\n            const target = (currentContext || typeof electronHelpers !== 'undefined')\n              ? '' : ' target=\"_blank\" rel=\"noopener noreferrer\"';\n\n            insertPart(entity, `<a class=\"anchor-url\" href=\"${href}\"${target}${onclick ? `onclick=\"${onclick}(this)\"` : ''}>`, '</a>');\n          }\n\n          break;\n        }\n\n        case 'messageEntityEmail': {\n          if(!options.noLinks) {\n            const entityText = text.substr(entity.offset, entity.length);\n            insertPart(entity, `<a href=\"${encodeEntities('mailto:' + entityText)}\" target=\"_blank\" rel=\"noopener noreferrer\">`, '</a>');\n          }\n\n          break;\n        }\n          \n        case 'messageEntityHashtag': {\n          const contextUrl = !options.noLinks && siteHashtags[contextSite];\n          if(contextUrl) {\n            const entityText = text.substr(entity.offset, entity.length);\n            const hashtag = entityText.substr(1);\n            insertPart(entity, `<a class=\"anchor-hashtag\" href=\"${contextUrl.replace('{1}', encodeURIComponent(hashtag))}\"${contextExternal ? ' target=\"_blank\" rel=\"noopener noreferrer\"' : ' onclick=\"searchByHashtag(this)\"'}>`, '</a>');\n          }\n\n          break;\n        }\n\n        case 'messageEntityMentionName': {\n          if(!(options.noLinks && !passEntities[entity._])) {\n            insertPart(entity, `<a href=\"#/im?p=${encodeURIComponent(entity.user_id)}\" class=\"follow\" data-follow=\"${entity.user_id}\">`, '</a>');\n          }\n\n          break;\n        }\n\n        case 'messageEntityMention': {\n          const contextUrl = !options.noLinks && siteMentions[contextSite];\n          if(contextUrl) {\n            const entityText = text.substr(entity.offset, entity.length);\n            const username = entityText.substr(1);\n\n            insertPart(entity, `<a class=\"mention\" href=\"${contextUrl.replace('{1}', encodeURIComponent(username))}\"${contextExternal ? ' target=\"_blank\" rel=\"noopener noreferrer\"' : ''}>`, '</a>');\n          }\n          \n          break;\n        }\n      }\n    }\n\n    lol.sort((a, b) => a.offset - b.offset);\n\n    const arr: string[] = [];\n    let usedLength = 0;\n    for(const {part, offset} of lol) {\n      if(offset > usedLength) {\n        arr.push(encodeEntities(text.slice(usedLength, offset)));\n        usedLength = offset;\n      }\n\n      arr.push(part);\n    }\n\n    if(usedLength < text.length) {\n      arr.push(encodeEntities(text.slice(usedLength)));\n    }\n\n    return arr.join('');\n  }\n\n  export function fixEmoji(text: string, entities?: MessageEntity[]) {\n    /* if(!emojiSupported) {\n      return text;\n    } */\n    // '$`\\ufe0f'\n\n    text = text.replace(/[\\u2640\\u2642\\u2764](?!\\ufe0f)/g, (match, offset, string) => {\n      if(entities) {\n        const length = match.length;\n\n        offset += length;\n        entities.forEach(entity => {\n          const end = entity.offset + entity.length;\n          if(end === offset) { // current entity\n            entity.length += length;\n          } else if(end > offset) {\n            entity.offset += length;\n          }\n        });\n      }\n      \n      // console.log([match, offset, string]);\n      return match + '\\ufe0f';\n    });\n\n    return text;\n  }\n\n  export function wrapDraftText(text: string, options: Partial<{\n    entities: MessageEntity[]\n  }> = {}) {\n    if(!text) {\n      return '';\n    }\n\n    return wrapRichText(text, {\n      entities: options.entities, \n      noLinks: true,\n      wrappingDraft: true,\n      passEntities: {\n        messageEntityTextUrl: true,\n        messageEntityMentionName: true\n      }\n    });\n  }\n\n  export function checkBrackets(url: string) {\n    var urlLength = url.length;\n    var urlOpenBrackets = url.split('(').length - 1;\n    var urlCloseBrackets = url.split(')').length - 1;\n    while(urlCloseBrackets > urlOpenBrackets &&\n      url.charAt(urlLength - 1) === ')') {\n      url = url.substr(0, urlLength - 1)\n      urlCloseBrackets--;\n      urlLength--;\n    }\n    if(urlOpenBrackets > urlCloseBrackets) {\n      url = url.replace(/\\)+$/, '');\n    }\n    return url;\n  }\n  \n  export function replaceUrlEncodings(urlWithEncoded: string) {\n    return urlWithEncoded.replace(/(%[A-Z\\d]{2})+/g, (str) => {\n      try {\n        return decodeURIComponent(str);\n      } catch (e) {\n        return str;\n      }\n    });\n  }\n  \n  export function wrapPlainText(text: any) {\n    if(emojiSupported) {\n      return text;\n    }\n  \n    if(!text || !text.length) {\n      return '';\n    }\n  \n    text = text.replace(/\\ufe0f/g, '', text);\n    var match;\n    var raw = text;\n    var text: any = [],\n      emojiTitle;\n    fullRegExp.lastIndex = 0;\n    while((match = raw.match(fullRegExp))) {\n      text.push(raw.substr(0, match.index))\n      if(match[8]) {\n        // @ts-ignore\n        const emojiCode = EmojiHelper.emojiMap[match[8]];\n        if(emojiCode &&\n        // @ts-ignore\n          (emojiTitle = emojiData[emojiCode][1][0])) {\n          text.push(':' + emojiTitle + ':');\n        } else {\n          text.push(match[0]);\n        }\n      } else {\n        text.push(match[0]);\n      }\n  \n      raw = raw.substr(match.index + match[0].length);\n    }\n    text.push(raw);\n    return text.join('');\n  }\n\n  export function wrapEmojiText(text: string) {\n    if(!text) return '';\n  \n    let entities = parseEntities(text).filter(e => e._ === 'messageEntityEmoji');\n    return wrapRichText(text, {entities});\n  }\n\n  export function wrapUrl(url: string, unsafe?: number | boolean): {url: string, onclick: string} {\n    if(!matchUrlProtocol(url)) {\n      url = 'https://' + url;\n    }\n  \n    let tgMeMatch;\n    let telescoPeMatch;\n    let onclick: string;\n    /* if(unsafe === 2) {\n      url = 'tg://unsafe_url?url=' + encodeURIComponent(url);\n    } else  */if((tgMeMatch = url.match(/^(?:https?:\\/\\/)?t(?:elegram)?\\.me\\/(.+)/))) {\n      const fullPath = tgMeMatch[1];\n      const path = fullPath.split('/');\n      switch(path[0]) {\n        case 'joinchat':\n        case 'addstickers':\n          onclick = path[0];\n          break;\n  \n        /* case 'joinchat':\n          onclick = 'joinchat';\n          url = 'tg://join?invite=' + path[1];\n          break;\n  \n        case 'addstickers':\n          onclick = 'addstickers';\n          url = 'tg://addstickers?set=' + path[1];\n          break; */\n  \n        default:\n          if(path[1] && path[1].match(/^\\d+$/)) {               // https://t.me/.+/[0-9]+ (channel w/ username)\n            if(path[0] === 'c' && path[2]) {                    // https://t.me/c/111111111/111 (channel w/o username)\n              url = '#/im?p=' + path[1] + '&post=' + path[2];\n            } else {                                            // https://t.me/durov/151 (channel w/ username)\n              url = siteMentions['Telegram'].replace('{1}', path[0] + '&post=' + path[1]);\n            }\n          } else if(path.length === 1) {\n            const domainQuery = path[0].split('?');\n            const domain = domainQuery[0];\n            const query = domainQuery[1];\n\n            if(domain === 'iv') {\n              const match = (query || '').match(/url=([^&=]+)/);\n              if(match) {\n                url = match[1];\n                try {\n                  url = decodeURIComponent(url);\n                } catch (e) {}\n  \n                return wrapUrl(url, unsafe);\n              }\n            }\n  \n            url = siteMentions['Telegram'].replace('{1}', domain + (query ? '&' + query : ''));\n            //url = 'tg://resolve?domain=' + domain + (query ? '&' + query : '');\n          }\n\n          break;\n      }\n    } else if((telescoPeMatch = url.match(/^(?:https?:\\/\\/)?telesco\\.pe\\/([^/?]+)\\/(\\d+)/))) {\n      url = 'tg://resolve?domain=' + telescoPeMatch[1] + '&post=' + telescoPeMatch[2];\n    }/*  else if(unsafe) {\n      url = 'tg://unsafe_url?url=' + encodeURIComponent(url);\n    } */\n  \n    return {url, onclick};\n  }\n\n  export function matchUrlProtocol(text: string) {\n    return !text ? null : text.match(urlAnyProtocolRegExp);\n  }\n  \n  export function matchUrl(text: string) {\n    return !text ? null : text.match(urlRegExp);\n  }\n\n  export function matchEmail(text: string) {\n    return !text ? null : text.match(emailRegExp);\n  }\n\n  export function getAbbreviation(str: string, onlyFirst = false) {\n    const splitted = str.trim().split(' ');\n    if(!splitted[0]) return '';\n\n    const first = [...splitted[0]][0];\n\n    if(onlyFirst || splitted.length === 1) return wrapEmojiText(first);\n\n    const last = [...splitted[splitted.length - 1]][0];\n\n    return wrapEmojiText(first + last);\n  }\n\n  export function isUsernameValid(username: string) {\n    return ((username.length >= 5 && username.length <= 32) || !username.length) && /^[a-zA-Z0-9_]*$/.test(username);\n  }\n\n  export function getEmojiEntityFromEmoji(emoji: string): MessageEntity.messageEntityEmoji {\n    return {\n      _: 'messageEntityEmoji',\n      offset: 0,\n      length: emoji.length,\n      unicode: toCodePoints(emoji).join('-').replace(/-?fe0f/g, '')\n    };\n  }\n\n  export function wrapSingleEmoji(emoji: string) {\n    return wrapRichText(emoji, {\n      entities: [getEmojiEntityFromEmoji(emoji)]\n    });\n  }\n}\n\nMOUNT_CLASS_TO.RichTextProcessor = RichTextProcessor;\n\nexport {RichTextProcessor};\nexport default RichTextProcessor;\n\n", "[{\n  \"predicate\": \"document\",\n  \"params\": [\n    {\"name\": \"thumbs\", \"type\": \"Array<PhotoSize.photoSize | PhotoSize.photoCachedSize | PhotoSize.photoStrippedSize | PhotoSize.photoPathSize>\"},\n    {\"name\": \"type\", \"type\": \"'gif' | 'sticker' | 'audio' | 'voice' | 'video' | 'round' | 'photo' | 'pdf'\"},\n    {\"name\": \"h\", \"type\": \"number\"},\n    {\"name\": \"w\", \"type\": \"number\"},\n    {\"name\": \"file_name\", \"type\": \"string\"},\n    {\"name\": \"file\", \"type\": \"File\"},\n    {\"name\": \"duration\", \"type\": \"number\"},\n    {\"name\": \"audioTitle\", \"type\": \"string\"},\n    {\"name\": \"audioPerformer\", \"type\": \"string\"},\n    {\"name\": \"sticker\", \"type\": \"number\"},\n    {\"name\": \"stickerEmoji\", \"type\": \"string\"},\n    {\"name\": \"stickerEmojiRaw\", \"type\": \"string\"},\n    {\"name\": \"stickerSetInput\", \"type\": \"InputStickerSet.inputStickerSetID\"},\n    {\"name\": \"stickerThumbConverted\", \"type\": \"true\"},\n    {\"name\": \"stickerCachedThumbs\", \"type\": \"{[toneIndex: number]: {url: string, w: number, h: number}}\"},\n    {\"name\": \"animated\", \"type\": \"boolean\"},\n    {\"name\": \"supportsStreaming\", \"type\": \"boolean\"}\n  ]\n}, {\n  \"predicate\": \"photoSizeProgressive\",\n  \"params\": [\n    {\"name\": \"size\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"dialog\",\n  \"params\": [\n    {\"name\": \"index\", \"type\": \"number\"},\n    {\"name\": \"peerId\", \"type\": \"number\"},\n    {\"name\": \"topMessage\", \"type\": \"any\"},\n    {\"name\": \"migratedTo\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"dialogFolder\",\n  \"params\": [\n    {\"name\": \"index\", \"type\": \"number\"},\n    {\"name\": \"peerId\", \"type\": \"number\"},\n    {\"name\": \"folder_id\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"message\",\n  \"params\": [\n    {\"name\": \"mid\", \"type\": \"number\"},\n    {\"name\": \"deleted\", \"type\": \"boolean\"},\n    {\"name\": \"peerId\", \"type\": \"number\"},\n    {\"name\": \"fromId\", \"type\": \"number\"},\n    {\"name\": \"grouped_id\", \"type\": \"string\"},\n    {\"name\": \"random_id\", \"type\": \"string\"},\n    {\"name\": \"unread\", \"type\": \"true\"},\n    {\"name\": \"is_outgoing\", \"type\": \"true\"},\n    {\"name\": \"rReply\", \"type\": \"string\"},\n    {\"name\": \"viaBotId\", \"type\": \"number\"},\n    {\"name\": \"clear_history\", \"type\": \"boolean\"}\n  ]\n}, {\n  \"predicate\": \"messageService\",\n  \"params\": [\n    {\"name\": \"mid\", \"type\": \"number\"},\n    {\"name\": \"deleted\", \"type\": \"boolean\"},\n    {\"name\": \"peerId\", \"type\": \"number\"},\n    {\"name\": \"fromId\", \"type\": \"number\"},\n    {\"name\": \"unread\", \"type\": \"true\"},\n    {\"name\": \"is_outgoing\", \"type\": \"true\"},\n    {\"name\": \"rReply\", \"type\": \"string\"},\n    {\"name\": \"viaBotId\", \"type\": \"number\"},\n    {\"name\": \"is_single\", \"type\": \"true\"}\n  ]\n}, {\n  \"predicate\": \"messageEmpty\",\n  \"params\": [\n    {\"name\": \"deleted\", \"type\": \"boolean\"}\n  ]\n}, {\n  \"predicate\": \"userFull\",\n  \"params\": [\n    {\"name\": \"rAbout\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"messageEntityEmoji\",\n  \"params\": [\n    {\"name\": \"offset\", \"type\": \"number\"},\n    {\"name\": \"length\", \"type\": \"number\"},\n    {\"name\": \"unicode\", \"type\": \"string\"}\n  ],\n  \"type\": \"MessageEntity\"\n}, {\n  \"predicate\": \"messageEntityHighlight\",\n  \"params\": [\n    {\"name\": \"offset\", \"type\": \"number\"},\n    {\"name\": \"length\", \"type\": \"number\"}\n  ],\n  \"type\": \"MessageEntity\"\n}, {\n  \"predicate\": \"messageEntityLinebreak\",\n  \"params\": [\n    {\"name\": \"offset\", \"type\": \"number\"},\n    {\"name\": \"length\", \"type\": \"number\"}\n  ],\n  \"type\": \"MessageEntity\"\n}, {\n  \"predicate\": \"messageEntityCaret\",\n  \"params\": [\n    {\"name\": \"offset\", \"type\": \"number\"},\n    {\"name\": \"length\", \"type\": \"number\"}\n  ],\n  \"type\": \"MessageEntity\"\n}, {\n  \"predicate\": \"messageEntityBotCommand\",\n  \"params\": [\n    {\"name\": \"unsafe\", \"type\": \"boolean\"}\n  ]\n}, {\n  \"predicate\": \"user\",\n  \"params\": [\n    {\"name\": \"initials\", \"type\": \"string\"},\n    {\"name\": \"sortName\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"auth.sentCode\",\n  \"params\": [\n    {\"name\": \"phone_number\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"draftMessage\",\n  \"params\": [\n    {\"name\": \"rReply\", \"type\": \"string\"},\n    {\"name\": \"rMessage\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"chat\",\n  \"params\": [\n    {\"name\": \"initials\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"chatForbidden\",\n  \"params\": [\n    {\"name\": \"initials\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"channel\",\n  \"params\": [\n    {\"name\": \"initials\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"channelForbidden\",\n  \"params\": [\n    {\"name\": \"initials\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"messageActionChatLeave\",\n  \"params\": [\n    {\"name\": \"user_id\", \"type\": \"number\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChannelDeletePhoto\",\n  \"params\": [],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChannelEditTitle\",\n  \"params\": [\n    {\"name\": \"title\", \"type\": \"string\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChannelEditPhoto\",\n  \"params\": [\n    {\"name\": \"photo\", \"type\": \"Photo\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChannelEditVideo\",\n  \"params\": [\n    {\"name\": \"photo\", \"type\": \"Photo\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChatEditVideo\",\n  \"params\": [\n    {\"name\": \"photo\", \"type\": \"Photo\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChatAddUsers\",\n  \"params\": [\n    {\"name\": \"users\", \"type\": \"Array<number>\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChatJoined\",\n  \"params\": [\n    {\"name\": \"users\", \"type\": \"Array<number>\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChatReturn\",\n  \"params\": [\n    {\"name\": \"users\", \"type\": \"Array<number>\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChatJoinedYou\",\n  \"params\": [\n    {\"name\": \"users\", \"type\": \"Array<number>\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChatReturnYou\",\n  \"params\": [\n    {\"name\": \"users\", \"type\": \"Array<number>\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"langPackDifference\",\n  \"params\": [\n    {\"name\": \"local\", \"type\": \"boolean\"},\n    {\"name\": \"appVersion\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"updateNewDiscussionMessage\",\n  \"params\": [\n    {\"name\": \"message\", \"type\": \"Message\"}\n  ],\n  \"type\": \"Update\"\n}, {\n  \"predicate\": \"updateDeleteDiscussionMessages\",\n  \"params\": [\n    {\"name\": \"messages\", \"type\": \"number[]\"},\n    {\"name\": \"channel_id\", \"type\": \"number\"}\n  ],\n  \"type\": \"Update\"\n}, {\n  \"predicate\": \"updateDraftMessage\",\n  \"params\": [\n    {\"name\": \"local\", \"type\": \"boolean\"},\n    {\"name\": \"threadId\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"updateChannelReload\",\n  \"params\": [\n    {\"name\": \"channel_id\", \"type\": \"number\"}\n  ],\n  \"type\": \"Update\"\n}, {\n  \"predicate\": \"messages.stickerSet\",\n  \"params\": [\n    {\"name\": \"refreshTime\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"replyKeyboardHide\",\n  \"params\": [\n    {\"name\": \"mid\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"replyKeyboardForceReply\",\n  \"params\": [\n    {\"name\": \"mid\", \"type\": \"number\"},\n    {\"name\": \"hidden\", \"type\": \"true\"},\n    {\"name\": \"fromId\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"replyKeyboardMarkup\",\n  \"params\": [\n    {\"name\": \"mid\", \"type\": \"number\"},\n    {\"name\": \"hidden\", \"type\": \"true\"},\n    {\"name\": \"fromId\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"inputDocumentFileLocation\",\n  \"params\": [\n    {\"name\": \"checkedReference\", \"type\": \"boolean\"}\n  ]\n}]", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n.chatlist-container {\n  position: relative;\n\n  .search-group-recent.search-group {\n    @include respond-to(handhelds) {\n      padding: 2px 0 0;\n    }\n  }\n\n  .search-group {\n    width: 100%;\n    padding: 1rem 0 .5rem;\n    margin-bottom: 17px;\n\n    @include respond-to(handhelds) {\n      margin-bottom: 0;\n    }\n\n    &__name {\n      color: var(--secondary-text-color);\n      padding: 0 23px;\n      padding-bottom: 1rem;\n      font-weight: 500;\n      user-select: none;\n\n      @include respond-to(handhelds) {\n        padding: 5px 9px 0 16px;\n        font-size: 15px;\n      }\n    }\n\n    &-contacts {\n      border-bottom: 1px solid var(--border-color);\n\n      @include respond-to(handhelds) {\n        padding: 0px 0 2px;\n      }\n\n      // .search-group__name {\n      //   padding-bottom: 17px;\n        \n      //   @include respond-to(handhelds) {\n      //     padding-bottom: 0;\n      //   }\n      // }\n    }\n\n    &-people.search-group-contacts {\n      padding: 5px 0 5px !important;\n    }\n\n    &:last-child {\n      border-bottom: none;\n    }\n  }\n\n  .search-super {\n    .search-group {\n      margin-bottom: 0px;\n      padding: 4px 0 0;\n\n      &__name {\n        padding-top: 1rem;\n        display: flex;\n        justify-content: space-between;\n      }\n    }\n  }\n\n}\n\nul.chatlist {\n  padding: 0 .5rem/*  .5rem */;\n\n  @include respond-to(handhelds) {\n    // padding: 0 0 .5rem;\n    padding: 0;\n  }\n}\n\n.chatlist {\n  //--avatarSize: 54px;\n  //--height: 72px;\n  margin: 0;\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  width: 100%;\n  background-color: var(--surface-color);\n\n  user-select: none;\n  -webkit-user-select: none; /* disable selection/Copy of UIWebView */\n  -webkit-touch-callout: none; /* disable the IOS popup when long-press on a link */\n\n  /* &.chatlist-avatar-48 {\n    --avatarSize: 48px;\n  }\n\n  @include respond-to(handhelds) {\n    &.chatlist-handhelds-66 {\n      --height: 66px;\n    }\n  } */\n\n  li {\n    //height: var(--height);\n    height: 72px;\n    //max-height: var(--height);\n    border-radius: $border-radius-medium;\n    display: flex;\n    align-items: flex-start; // TODO: \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c \u0440\u0430\u0437\u043d\u0438\u0446\u0443 \u0432 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u0441 align-items: center;\n    flex-direction: row;\n    position: relative;\n    cursor: pointer;\n    padding: .5625rem;\n    /* padding-top: calc((var(--height) - var(--avatarSize)) / 2);\n    padding-bottom: calc((var(--height) - var(--avatarSize)) / 2);\n    padding-right: 8.5px;\n    padding-left: 8.5px; */\n    overflow: hidden;\n\n    @include respond-to(handhelds) {\n      border-radius: 0;\n    }\n\n    @include hover-background-effect();\n\n    &.is-muted {\n      .user-title {\n        &:after {\n          flex: 0 0 auto;\n          content: $tgico-nosound;\n          color: var(--chatlist-pinned-color);\n          font-size: 1.125rem;\n          margin-left: .125rem;\n        }\n      }\n\n      body:not(.animation-level-0) & {\n        &.animating {\n          &:not(.backwards) {\n            .user-title:after {\n              animation: fade-in-opacity .2s ease-in-out forwards;\n            }\n          }\n  \n          &.backwards .user-title:after {\n            animation: fade-in-backwards-opacity .2s ease-in-out forwards;\n          }\n        }\n      }\n    }\n\n    p {\n      margin: 0;\n      display: flex;\n      justify-content: space-between;\n      flex-direction: row;\n      align-items: flex-start;\n      height: 27px;\n    }\n\n    a {\n      color: inherit;\n    }\n\n    .text-highlight {\n      color: var(--primary-text-color);\n    }\n\n    /* img.emoji {\n      margin-right: .25rem;\n      margin-left: .25rem;\n\n      &:first-child {\n        margin-left: 0;\n      }\n    } */\n\n    &.menu-open {\n      background: var(--light-secondary-text-color);\n    }\n\n    @include respond-to(not-handhelds) {\n      &.active {\n        //background: var(--light-secondary-text-color);\n        background: var(--primary-color) !important;\n\n        .user-caption,\n        .tgico-chatspinned:before,\n        //.user-title:after,\n        .user-title,\n        .message-status,\n        .text-highlight {\n          color: #fff;\n        }\n\n        b {\n          color: #fff !important;\n        }\n\n        .user-title:after {\n          color: rgba(255, 255, 255, .7);\n        }\n\n        .verified-background {\n          fill: #fff !important;\n        }\n\n        .verified-check {\n          fill: var(--primary-color) !important;\n        }\n\n        .dialog-avatar.is-online:after {\n          background-color: #fff;\n          border-color: var(--primary-color);\n        }\n\n        .badge.unread {\n          background-color: #fff !important;\n          color: var(--primary-color);\n        }\n\n        .peer-typing-container {\n          --color: #fff;\n        }\n      }\n    }\n  }\n\n  /* .user-title,\n  .dialog-title-details,\n  .user-last-message */li span {\n    //display: inline-block;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    //margin: .1rem 0;\n    line-height: 27px;\n  }\n\n  .peer-typing-container {\n    --color: var(--secondary-text-color);\n\n    .peer-typing-text {\n      display: inline-flex;\n      transform: translateY(-2px);\n    }\n  }\n\n  .dialog {\n    &-title {\n      &-details {\n        font-size: .75rem;\n        padding: 1px 0px 0px 0px;\n        flex: 0 0 auto;\n        margin-left: .5rem;\n      }\n    }\n    \n    &-subtitle {\n      margin-top: -3px;\n\n      &-badge {\n        &:not(:empty), &.tgico-pinnedchat {\n          margin-left: .5rem;\n        }\n\n        &.unread {\n          transition: none;\n        }\n      }\n    }\n  }\n\n  .dialog-avatar {\n    flex: 0 0 auto;\n  }\n\n  .user-caption {\n    max-width: 100%;\n    max-height: 100%;\n    overflow: hidden;\n    color: var(--secondary-text-color);\n    flex: 1 1 auto;\n    padding: .0625rem .4375rem .0625rem .5625rem;\n  }\n\n  .dialog-avatar, .user-caption {\n    pointer-events: none;\n    position: relative; // for z-index\n  }\n\n  .user-title {\n    display: flex !important;\n    align-items: center;\n\n    img.emoji {\n      vertical-align: top;\n      margin-top: 4px;\n      width: 18px;\n      height: 18px;\n    }\n\n    /* span.emoji {\n      &:first-of-type:not(:first-child) {\n        margin-left: .125rem;\n      }\n    } */\n\n    .verified-icon {\n      flex: 0 0 auto;\n      width: 20px;\n      height: 20px;\n      margin-left: .125rem;\n    }\n  }\n\n  .user-last-message {\n    img.emoji {\n      width: 20px;\n      height: 20px;\n      margin-top: -3px;\n    }\n\n    span.emoji {\n      font-size: 1.2rem;\n      margin: 0 .125rem;\n      overflow: visible;\n      //margin-top: -1.5px;\n    }\n  }\n\n  .user-title, .user-last-message {\n    i {\n      font-style: normal;\n      //color: var(--primary-color);\n    }\n  }\n\n  .message-status {\n    margin-right: .1rem;\n    //margin-top: .3rem;\n    margin-top: -.3rem;\n    display: inline-block;\n    vertical-align: middle;\n\n    &[class*=\" tgico-\"] {\n      color: var(--chatlist-status-color);\n      font-size: 1.25rem;\n    }\n\n    &:before {\n      vertical-align: middle;\n    }\n  }\n\n  .message-time {\n    vertical-align: middle;\n  }\n\n  .dialog-subtitle-badge {\n    margin-top: 4px;\n    margin-right: -3px;\n    margin-left: .25rem;\n    flex: 0 0 auto;\n  }\n\n  .tgico-chatspinned {\n    background: transparent;\n    position: relative;\n\n    &:before {\n      color: var(--chatlist-pinned-color);\n      transition: opacity .2s ease-in-out;\n      opacity: 1;\n      position: absolute;\n      top: 0;\n      left: 0;\n    }\n\n    &.unread {\n      &:before {\n        opacity: 0;\n      }\n    }\n  }\n\n  .unread, li.is-muted.backwards .unread {\n    background-color: var(--chatlist-status-color);\n  }\n\n  li.is-muted .unread {\n    background-color: var(--secondary-color);\n  }\n}\n\n// use together like class=\"chatlist-container contacts-container\"\n.contacts-container, .search-group-contacts {\n  li {\n    padding: .75rem;\n\n    @include respond-to(handhelds) {\n      height: 66px;\n      padding-top: 9px;\n      padding-bottom: 9px;\n    }\n  }\n\n  .user-caption {\n    padding: 1px 3.5px 1px 13px;\n\n    @include respond-to(handhelds) {\n      padding: 0 4px 0 14px;\n    }\n  }\n\n  .user-title, b, .user-last-message b {\n    font-weight: normal;\n  }\n\n  p {\n    height: 24px;\n\n    @include respond-to(handhelds) {\n      height: 26px;\n    }\n  }\n\n  span.user-last-message {\n    font-size: 14px;\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n#column-left {\n  //display: flex;\n  flex-direction: column;\n  flex: 1 1 auto;\n  min-width: 18rem;\n  max-width: calc(#{$large-screen} / 4);\n\n  @include respond-to(handhelds) {\n    width: 100%;\n    max-width: 100%;\n\n    body:not(.is-left-column-shown) & {\n      transform: translate3d(-25vw, 0, 0);\n      filter: brightness(80%);\n    }\n  }\n\n  @include respond-to(not-handhelds) {\n    overflow: visible;\n\n    &:after {\n      position: absolute;\n      content: \" \";\n      display: block;\n      height: 100vh;\n      width: 1px;\n      background-color: var(--border-color);\n      right: -1px;\n      top: 0;\n      z-index: 2;\n    }\n  }\n  \n  @include respond-to(floating-left-sidebar) {\n    display: flex;\n    position: fixed;\n    left: 0;\n    top: 0;\n    /* height: calc(var(--vh, 1vh) * 100);\n    min-height: calc(var(--vh, 1vh) * 100) !important; */\n    width: 26.5rem;\n    transform: translate3d(-5rem, 0, 0);\n    transition: transform var(--layer-transition);\n    max-width: unset;\n    \n    body.animation-level-0 & {\n      transition: none;\n    }\n\n    body.is-left-column-shown & {\n      transform: translateZ(0);\n    }\n  }\n\n  @include respond-to(no-floating-left-sidebar) {\n    display: flex;\n  }\n\n  @include respond-to(before-medium-screens) {\n    flex: 2;\n  }\n\n  // ! WARNING, \u041e\u0427\u0415\u041d\u042c \u041a\u0420\u0423\u0422\u041e\u0419 \u041a\u041e\u0421\u0422\u042b\u041b\u042c - \u0424\u0418\u041a\u0421 \u0427\u0401\u0420\u041d\u041e\u0419 \u0420\u0410\u041c\u041a\u0418 \u0423 \u041a\u0410\u0420\u0422\u0418\u041d\u041e\u041a \u0421 \u0425\u0412\u041e\u0421\u0422\u0418\u041a\u041e\u041c\n  html.is-safari & {\n    @include respond-to(large-screens) {\n      max-width: calc(#{$large-screen} / 4 - 1.25px);\n    }\n  }\n\n  .item-main {\n    --menu-size: 3rem;\n  }\n\n  .menu-horizontal-scrollable {\n    --scrollable-size: var(--menu-size);\n    z-index: 1;\n    background-color: var(--surface-color);\n    position: relative;\n    top: unset;\n    \n    @include respond-to(handhelds) {\n      box-shadow: 0px 1px 5px -1px rgba(0, 0, 0, .16);\n    }\n\n    .scrollable {\n      position: relative;\n    }\n\n    .menu-horizontal-div {\n      position: relative !important;\n      justify-content: flex-start;\n      z-index: 0;\n\n      &-item {\n        flex: 0 0 auto;\n        min-width: 3rem;\n        border-top-left-radius: 6px;\n        border-top-right-radius: 6px;\n\n        > span {\n          overflow: visible;\n\n          i {\n            bottom: calc(-.6875rem - 2px);\n            /* padding-right: 1rem !important;\n\t          margin-left: -.5rem !important; */\n          }\n        }\n      }\n\n      &__stripe {\n        display: none;\n      }\n    }\n\n    .badge {\n      margin-left: 5px;\n      //line-height: inherit !important;\n    }\n\n    &:not(.hide) + #folders-container {\n      height: calc(100% - var(--menu-size));\n      position: relative;\n\n      .scrollable {\n        padding-top: .5rem;\n      }\n\n      /* .chatlist {\n        top: .5rem;\n      } */\n    }\n  }\n\n  .folders-tabs-scrollable {\n    .menu-horizontal-div-item:first-child {\n      margin-left: .6875rem;\n  \n      @include respond-to(handhelds) {\n        margin-left: .1875rem;\n      }\n    }\n  }\n\n  .item-main {\n    .input-search {\n      /* &-input {\n        --paddingLeft: 0px;\n        padding-left: calc(42px - var(--border-width) + var(--paddingLeft));\n      } */\n\n      .selector-user {\n        height: 30px;\n        position: absolute!important;\n        left: 6px;\n        top: 6px;\n        z-index: 1;\n        margin-left: 0;\n      }\n\n      &.is-picked {\n        .input-search-input {\n          padding-left: calc(var(--paddingLeft) + 12px - var(--border-width));\n        }\n\n        .tgico-close {\n          display: block !important;\n        }\n      }\n      \n      &.is-picked-twice {\n        .selector-user:first-of-type {\n          width: 30px;\n        }\n\n        .selector-user:last-of-type {\n          left: 38px;\n        }\n      }\n    }\n  \n    .search-helper {\n      display: flex;\n      margin-left: 28px;\n\n      @include respond-to(handhelds) {\n       margin-left: 20px;\n      }\n\n      .selector-user {\n        margin-top: 7px;\n        font-size: 14px;\n\n        @include hover() {\n          background-color: var(--light-primary-color);\n        }\n\n        &-avatar:after {\n          display: none !important;\n        }\n      }\n    }\n    \n    .search-super-tabs-scrollable { \n      position: relative !important; \n\n      &:before {\n        display: none;\n      }\n\n      .menu-horizontal-div-item {\n        flex: 1 0 auto !important;\n      }\n    }\n\n    .search-super {\n      .preloader {\n        height: 100%;\n        top: 50%;\n        transform: translate(-50%, -50%);\n      }\n    }\n  }\n\n  #chatlist-container {\n    max-height: 100%;\n    overflow: hidden;\n    position: relative;\n    background-color: var(--surface-color);\n  }\n\n  #folders-container {\n    .scrollable-y {\n      background-color: transparent;\n      position: absolute;\n      \n      &.active { // fix safari 14.0.2 scrollHeight\n        display: block;\n      }\n    }\n  }\n\n  .sidebar-slider {\n    height: 100%;\n  }\n\n  .sidebar-header__btn-container {\n    position: relative;\n    width: 2.5rem;\n    height: 2.5rem;\n    flex: 0 0 auto;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n\n    > .btn-icon {\n      visibility: hidden;\n      opacity: 0;\n      position: absolute;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      left: 0;\n      transition: .2s opacity, .15s background-color;\n      z-index: 2;\n      margin: 0;\n\n      body.animation-level-0 &, body.animation-level-0 &:before {\n        transition: none;\n      }\n\n      &.is-visible {\n        //margin-top: 1px;\n        opacity: 1;\n        visibility: visible;\n      }\n    }\n\n    @include respond-to(handhelds) {\n      .btn-menu {\n        margin-top: -.25rem;\n      }\n    }\n  }\n\n  .sidebar-tools-button {\n    width: 100%;\n    \n    .btn-menu {\n      width: 300px;\n  \n      .archived-count {\n        justify-self: flex-end;\n        margin-left: .625rem;\n  \n        @include respond-to(handhelds) {\n          font-weight: 600;\n        }\n      }\n  \n      .btn-menu-item {\n        padding-right: 1rem;\n      }\n  \n      .archived-count:empty {\n        display: none;\n      }\n    }\n  }\n\n  .search-group-people {\n    .chatlist {\n      display: flex;\n      flex-direction: row;\n      padding-left: 4px;\n      margin-top: -1px;\n      padding-bottom: 1px;\n    }\n\n    li {\n      height: 98px;\n      border-radius: 10px;\n      max-width: 78px;\n      width: 78px;\n      align-items: center;\n      display: flex;\n      flex-direction: column;\n      padding: 12px 0 0 !important;\n      margin: 0 5px 0 0;\n      flex: 0 0 auto;\n\n      @include respond-to(handhelds) {\n        width: 77px;\n        max-width: 77px;\n      }\n    }\n\n    .dialog-title-details, .dialog-subtitle {\n      display: none;\n    }\n\n    .user-caption {\n      max-width: 65px;\n      padding: 2px 0px 9px;\n      font-size: 12px;\n\n      @include respond-to(handhelds) {\n        max-width: 56px;\n      }\n    }\n\n    .search-group-scrollable {\n      position: relative;\n      \n      @include respond-to(handhelds) {\n        margin-left: -7px;\n        margin-top: 4px;\n      }\n      \n      > .scrollable {\n        position: relative;\n      }\n    }\n  }\n\n  .item-main .sidebar-content {\n    .btn-menu {\n      bottom: calc(100% + 10px);\n    }\n\n    .btn-corner {\n      &:not(.menu-open) .tgico-newchat_filled, \n      &.menu-open .tgico-close {\n        animation: grow-icon .4s forwards ease-in-out !important;\n        visibility: visible !important;\n      }\n\n      @include respond-to(handhelds) {\n        --size: 54px;\n        bottom: 14px;\n        right: 14px;\n\n        position: fixed !important;\n        z-index: 1;\n      }\n\n      /* html:not(.no-touch) & {\n        transform: translateZ(0);\n      } */\n      &:not(.is-hidden) {\n        transform: translateZ(0);\n      }\n    }\n\n    /* html.no-touch &:hover .btn-corner:not(.is-hidden) {\n      transform: translateZ(0);\n    } */\n  }\n\n  .connection-status {\n    width: 100%;\n    padding: 0 .5rem .5rem;\n    overflow: hidden;\n    flex: 0 0 auto;\n    \n    &:not(.is-shown) {\n      .connection-status-button {\n        display: none;\n      }\n    }\n\n    &.is-shown {\n      &.animating {\n        .connection-status-button, & + .connection-status-bottom {\n          transition: transform var(--layer-transition);\n        }\n      }\n\n      &:not(.backwards) {\n        .connection-status-button {\n          transform: translateY(0);\n        }\n\n        & + .connection-status-bottom {\n          transform: translateY(64px);\n        }\n      }\n\n      &:not(.animating):not(.backwards) {\n        & + .connection-status-bottom {\n          height: calc(100% - 64px);\n        }\n      }\n    }\n\n    &-button {\n      color: #2e3939;\n      align-self: center;\n      cursor: default;\n      padding-left: 4.5rem;\n      text-align: left;\n      height: 3.5rem;\n\n      .force-reconnect {\n        cursor: pointer;\n        text-decoration: underline;\n        color: inherit;\n      }\n\n      transform: translateY(-100%);\n\n      .preloader-container {\n        right: auto;\n        left: 1rem;\n        width: 1.5rem;\n        height: 1.5rem;\n\n        .preloader-path-new {\n          stroke: #2e3939;\n        }\n      }\n    }\n\n    &-bottom {\n      position: absolute;\n      left: 0;\n      top: 0;\n      bottom: 0;\n      right: 0;\n      overflow: hidden;\n      background-color: var(--surface-color);\n\n      transform: translateY(0);\n      height: 100%;\n\n      /* transform: translateY(64px);\n      height: calc(100% - 64px); */\n    }\n  }\n\n  .input-wrapper {\n    width: 420px;\n    margin: 0 auto;\n    flex: 0 0 auto;\n    padding: 0 1.25rem;\n    max-width: 100%;\n\n    @include respond-to(handhelds) {\n      width: 100%;\n      padding: 0 1rem;\n    }\n  }\n}\n\n#search-container {\n  display: flex;\n\n  .scrollable-y {\n    position: relative;\n  }\n}\n\n.new-channel-container, .new-group-container, .edit-profile-container {\n  .sidebar-content {\n    flex-direction: column;\n  }\n\n  .chatlist-container {\n    flex: 1 1 auto;\n  }\n\n  .caption {\n    font-size: 0.875rem;\n    margin-top: 14px;\n    margin-left: 23px;\n    color: var(--secondary-text-color);\n    padding-right: 24px;\n  }\n}\n\n.language-container {\n  .sidebar-left-section {\n    padding-bottom: .5rem;\n  }\n}\n\n.new-group-container {\n  .search-group {\n    margin-top: .5rem;\n  }\n}\n\n.edit-folder-container {\n  .chatlist {\n    padding: 0;\n  }\n\n  .folder-categories {\n    .folder-category-button {\n      &:nth-child(n+2) {\n        pointer-events: none;\n      }\n    }\n  }\n}\n\n.new-group-members {\n  padding: 1.5rem 0 .4375rem;\n\n  .search-group__name {\n    text-transform: capitalize;\n  }\n}\n\n.settings-container {\n  .profile {\n    &-button {\n      @include respond-to(handhelds) {\n        border-radius: 0;\n      }\n    }\n\n    &-buttons {\n      margin-top: 1.1875rem;\n      width: 100%;\n      padding: 0 .4375rem;\n\n      @include respond-to(handhelds) {\n        margin-top: .6875rem;\n        padding: 0;\n      }\n    }\n  }\n}\n\n.edit-profile-container {\n  .caption {\n    margin-top: 1.0625rem;\n    margin-left: 1.4375rem;\n    line-height: var(--line-height);\n    padding-bottom: 1.4375rem;\n\n    @include respond-to(handhelds) {\n      padding-right: 24px;\n    }\n  }\n\n  .sidebar-left-h2 {\n    padding: 0 1.4375rem;\n    padding-bottom: 1.5rem;\n  }\n\n  hr {\n    margin-bottom: 1rem;\n  }\n\n  .scroll-wrapper {\n    width: 100%;\n  }\n}\n\n.chat-folders-container, .edit-folder-container {\n  user-select: none;\n\n  .sticker-container {\n    width: 86px;\n    height: 86px;\n    margin: 1px auto 29px;\n    flex: 0 0 auto;\n    position: relative;\n  }\n\n  .caption {\n    text-align: center;\n    color: var(--secondary-text-color);\n    font-size: 14px;\n    line-height: var(--line-height);\n    max-width: 20rem;\n    margin: 0 auto;\n  }\n}\n\n.chat-folders-container {\n  .sidebar-left-section {\n    &:not(:last-child) {\n      padding-bottom: 0;\n    }\n\n    &:last-child {\n      padding-bottom: .5rem;\n    }\n\n    /* &-name {\n      padding-top: .5rem;\n      padding-bottom: .5rem;\n    } */\n  }\n\n  .row {\n    .btn-primary {\n      height: 30px;\n      padding: 0 12px;\n      font-size: 15px;\n      width: auto;\n      transition: width 0.2s;\n      margin: 0;\n      position: absolute;\n      right: 1rem;\n      top: 50%;\n      transform: translateY(-50%);\n      border-radius: 15px;\n\n      body.animation-level-0 & {\n        transition: none;\n      }\n    }\n  }\n}\n\n.edit-folder-container {\n  .caption {\n    margin-bottom: 18px;\n  }\n\n  @include respond-to(handhelds) {\n    .input-wrapper {\n      width: 100%;\n      padding: 0 16px;\n    }\n  }\n\n  .input-wrapper {\n    margin-bottom: .125rem !important;\n  }\n\n  .sidebar-left-section {\n    padding-bottom: 0rem;\n\n    &:last-child {\n      padding-bottom: .5rem;\n    }\n  }\n}\n\n.folder-list {\n  li {\n    padding: 9px 12px;\n    height: 50px;\n  }\n\n  .user-caption {\n    padding: 3px 28px 6px 27px;\n  }  \n\n  p span {\n    font-weight: normal;\n  }\n}\n\n.folder-categories {\n  .checkbox-field {\n    position: absolute;\n    right: 1.125rem !important;\n  }\n}\n\n.folder-category-button {\n  height: 50px;\n}\n\n.popup-forward, .included-chatlist-container {\n  .selector {\n    .chatlist {\n      li {\n        padding: 7px .75rem !important;\n        height: 3.75rem;\n      }\n  \n      .user-caption {\n        padding: 0px 0px 0 14px;\n        margin-top: -2px;\n      }\n  \n      .user-last-message {\n        font-size: 15px;\n        margin-top: 2px;\n      }\n    }\n  }\n}\n\n.included-chatlist-container {\n  .sidebar-left-section {\n    padding-bottom: 0;\n\n    &:first-child {\n      padding-top: 0;\n    }\n    \n    &:last-child {\n      padding-bottom: .5rem;\n    }\n\n    .chatlist {\n      padding: 0;\n    }\n  }\n\n  .selector {\n    .chatlist {\n      .checkbox {\n        margin-top: 10px;\n      }\n\n      [type=\"checkbox\"] + span {\n        padding-left: 26px;\n      }\n    }\n  }\n}\n\n.search-group-recent {\n  .search-group__name {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n\n  .btn-icon {\n    //@include respond-to(handhelds) {\n      font-size: 22px;\n    //}\n  }\n\n  @include respond-to(handhelds) {\n    li {\n      height: 62px;\n      padding-top: 7px;\n      padding-bottom: 7px;\n    }\n\n    .user-caption {\n      margin-top: -2px;\n    }\n\n    .user-title {\n      font-weight: 500 !important;\n    }\n\n    .dialog-avatar {\n      --size: 46px;\n      --multiplier: 1.173913;\n    }\n  }\n}\n\n@include respond-to(handhelds) {\n  .search-group-recent.search-group.search-group-contacts ul {\n    margin-top: 0;\n  }\n\n  .search-group.search-group-contacts ul, .search-group.search-group-messages ul {\n    margin-top: 7px;\n  }\n\n  .search-group.search-group-messages {\n    margin-top: -6px;\n  }\n}\n\n@include respond-to(not-handhelds) {\n  .search-group-recent.search-group.search-group-contacts {\n    padding: 0px 0 7px;\n  }\n}\n\n.sidebar-left {\n  &-section {\n    /* padding-bottom: .75rem;\n\n    @include respond-to(handhelds) {\n      padding-bottom: .5rem;\n    } */\n    user-select: none;\n    padding: .5rem 0 1rem;\n\n    @include respond-to(handhelds) {\n      padding-bottom: .5rem;\n    }\n  \n    &-content {\n      @include respond-to(not-handhelds) {\n        margin: 0 .5rem;\n      }\n\n      > .btn-primary {\n        margin: 0;\n      }\n\n      > .checkbox-field {\n        .checkbox-box {\n          left: auto;\n        }\n      }\n\n      @include respond-to(handhelds) {\n        > .checkbox-ripple, \n        > .btn-primary {\n          border-radius: 0;\n        }\n      }\n    }\n  \n    &-name {\n      padding: 1rem;\n\n      @include respond-to(handhelds) {\n        padding: .5rem 1rem;\n        font-size: .875rem;\n      }\n    }\n\n    &-caption {\n      margin-top: 1rem;\n      font-size: 1rem;\n      color: var(--secondary-text-color);\n      line-height: var(--line-height);\n      padding: 0 1rem;\n\n      @include respond-to(handhelds) {\n        margin: .5rem;\n        font-size: .875rem;\n      }\n    }\n\n    .checkbox-field, .radio-field {\n      margin: 0;\n    }\n\n    // * comment later\n    &:first-child:not(.no-delimiter) {\n      padding-top: 0;\n    }\n\n    .checkbox-field {\n      display: flex;\n      align-items: center;\n      height: 3.5rem;\n      padding: 0 1.125rem;\n    }\n\n    &-disabled {\n      pointer-events: none !important;\n      opacity: .25;\n    }\n\n    .media-sticker-wrapper {\n      width: 86px;\n      height: 86px;\n      margin: 1px auto 29px;\n      flex: 0 0 auto;\n      position: relative;\n    }\n  }\n\n  &-h2 {\n    color: var(--primary-color);\n    font-size: 16px;\n    font-weight: 500;\n  }\n}\n\n.general-settings-container {\n  user-select: none;\n\n  .sidebar-left-section {\n    padding-bottom: 0;\n  }\n\n  .sidebar-left-section:last-child {\n    padding-bottom: .5rem;\n  }\n}\n\n.two-step-verification {\n  .sidebar-left-section { // * main tab verified with mockup\n    &:first-child { // ! refactor is needed\n      padding-top: 0;\n    }\n\n    &-caption {\n      text-align: center;\n      max-width: 342px;\n      margin-left: auto;\n      margin-right: auto;\n      margin-bottom: 1.125rem;\n    }\n  }\n\n  &-main {\n    .btn-primary + .btn-primary {\n      margin-top: .125rem !important;\n    }\n  }\n\n  .btn-primary:not(.btn-transparent) {\n    text-transform: uppercase;\n  }\n\n  .media-sticker-wrapper {\n    width: 168px;\n    height: 168px;\n    margin: .625rem auto 1.1875rem;\n  }\n\n  .input-wrapper .btn-primary:first-child:last-child {\n    margin-top: .25rem;\n  }\n\n  &-enter-password {\n    .media-sticker-wrapper {\n      margin: 1.125rem auto 1.8125rem;\n      width: 157px;\n      height: 157px;\n    }\n  }\n\n  &-hint {\n    .media-sticker-wrapper {\n      width: 160px;\n      height: 160px;\n      margin: .5rem auto 2.25rem;\n    }\n  }\n\n  &-email {\n    .media-sticker-wrapper {\n      width: 160px;\n      height: 160px;\n      margin: .5625rem auto 2.1875rem;\n    }\n  }\n\n  &-set {\n    .media-sticker-wrapper {\n      width: 160px;\n      height: 160px;\n      margin: 1rem auto 1.3125rem;\n\n      .rlottie, .rlottie-vector {\n        left: .625rem;\n      }\n    }\n  }\n}\n\n.dont-u-dare-block-me {\n  .sidebar-left-section.no-delimiter {\n    padding-top: .75rem;\n  }\n\n  .sidebar-left-section {\n    padding: 0 0 .5rem;\n  }\n\n  /* .privacy-navigation-container {\n    .sidebar-left-section-name + .row {\n      margin-top: -5px; // ! just to match mockup.\n    }\n  } */\n}\n\n.privacy-tab {\n  // * just to match mockup\n  @include respond-to(not-handhelds) {\n    .sidebar-left-section:first-child {\n      padding-bottom: 1.125rem;\n    }\n  }\n\n  form {\n    padding-bottom: .0625rem;\n  }\n}\n\n.active-sessions-container {\n  .row {\n    margin-top: 0;\n    padding-top: 1rem;\n    padding-bottom: .9375rem;\n\n    &-title-row {\n      align-items: flex-end;\n    }\n\n    &-title:first-child {\n      font-weight: 500;\n    }\n\n    &-title-right {\n      font-size: .75rem;\n      color: var(--secondary-text-color);\n      line-height: 1.5;\n    }\n\n    &-midtitle, &-subtitle {\n      white-space: nowrap;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n  }\n\n  .sidebar-left-section:first-child {\n    padding-bottom: 0;\n\n    .row-title {\n      font-weight: 500;\n    }\n  }\n}\n\n.blocked-users-container {\n  li {\n    height: 66px;\n    padding-top: 9px;\n    padding-bottom: 9px;\n  }\n\n  .user-caption {\n    padding-left: .75rem;\n  }\n\n  .dialog-subtitle {\n    margin-top: -.375rem;\n    font-size: .875rem;\n  }\n\n  ul {\n    margin-top: .3125rem;\n    \n    @include respond-to(not-handhelds) {\n      padding: 0 .6875rem;\n    }\n  }\n}\n\n.notifications-container {\n  .sidebar-left-section {\n    padding-bottom: 0;\n  }\n}\n\n.range-setting-selector {\n  padding: 1rem .875rem;\n\n  &-details {\n    display: flex;\n    justify-content: space-between;\n    margin-bottom: 1rem;\n  }\n\n  &-name {\n    color: var(--primary-text-color);\n  }\n\n  &-value {\n    color: var(--secondary-text-color);\n  }\n\n  .progress-line {\n    --height: 2px;\n    --border-radius: 4px;\n    background-color: #e6ecf0;\n    \n    &__filled {\n      background-color: var(--primary-color);\n    }\n    \n    &__seek {\n      --thumb-color: var(--primary-color);\n      --thumb-size: 12px;\n    }\n  }\n}\n\n.background-container {\n  .grid {\n    padding: 0 .5rem .5rem;\n\n    &-item {\n      &:after {\n        content: \" \";\n        display: block;\n        position: absolute;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        border: 3px solid var(--primary-color);\n        opacity: 0;\n        transition: opacity .2s ease-in-out;\n      }\n\n      &.active {\n        &:after {\n          opacity: 1;\n        }\n\n        .grid-item-media {\n          transform: scale(.91);\n        }\n      }\n\n      &-media {\n        transition: transform .2s ease-in-out;\n        transform: scale(1);\n      }\n    }\n\n    .media-photo {\n      width: 100%;\n      height: 100%;\n      object-fit: cover;\n    }\n\n    .preloader-container {\n      z-index: 1;\n    }\n  }\n}\n\n.background-image-container {\n  .sidebar-left-section {\n    padding-bottom: .5rem;\n  }\n}\n\n.empty-placeholder {\n  top: 40%;\n  transform: translateY(-50%);\n  text-align: center;\n  line-height: var(--line-height);\n  user-select: none;\n  width: 21rem !important;\n  margin: 0 auto;\n  padding: 0 1rem;\n  \n  .media-sticker-wrapper {\n    width: 128px;\n    height: 128px;\n    margin: 0 auto 1.9375rem;\n    position: relative;\n  }\n\n  &-header {\n    font-size: 1.25rem;\n    font-weight: 500;\n  }\n\n  &-subtitle {\n    color: var(--secondary-text-color);\n    font-size: .875rem;\n    margin-top: .375rem;\n  }\n\n  .btn-control {\n    margin-top: 1.75rem;\n    padding: 0 1.0625rem 0 .8125rem;\n\n    &:before {\n      margin-right: .625rem;\n    }\n  }\n\n  &-dialogs {\n    opacity: 0;\n\n    @include animation-level(2) {\n      transition: opacity .2s ease-in-out;  \n    }\n\n    &-icon {\n      margin-bottom: 1.0625rem;\n    }\n\n    &.visible {\n      opacity: 1;\n    }\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n#column-right {\n  position: relative;\n  overflow: unset;\n\n  @include respond-to(only-small-screens) {\n    box-shadow: 0 0.25rem 0.5rem 0.1rem rgba(0, 0, 0, .2);\n  }\n\n  @include respond-to(handhelds) {\n    body:not(.is-right-column-shown) & {\n      transform: translate3d(100vw, 0, 0);\n    }\n  }\n\n  @include respond-to(not-handhelds) {\n    width: calc(var(--right-column-width));\n    transition: transform var(--transition-standard-out);\n    position: absolute;\n    right: 0;\n    z-index: 3;\n    transform: translate3d(var(--right-column-width), 0, 0);\n    //transform: translate3d(calc(var(--right-column-width) + 1px), 0, 0);\n  \n    .sidebar-content {\n      min-width: var(--right-column-width);\n    }\n  \n    /* &:not(.active) {\n      border-left-width: 0;\n    } */\n  \n    body.is-right-column-shown:not(.is-left-column-shown) & {\n      transition: transform var(--transition-standard-in);\n      transform: translate3d(0, 0, 0);\n    }\n\n    body.animation-level-0 & {\n\t\t\ttransition: none;\n\t\t}\n\n    /* &:before {\n      position: absolute;\n      content: \" \";\n      display: block;\n      //height: 56px;\n      height: 100vh;\n      width: 1px;\n      background-color: var(--border-color);\n      left: 0px;\n      top: 0;\n    } */\n  }\n\n  @include respond-to(medium-screens) {\n    width: calc(var(--right-column-width) + 1px);\n    transform: translate3d(calc(var(--right-column-width) + 1px), 0, 0);\n    border-left: 1px solid var(--border-color);\n  }\n\n  /* @include respond-to(medium-screens) {\n    border-left: 1px solid var(--border-color);\n  } */\n\n  /* body.is-forward-active & {\n    z-index: 4;\n  } */\n\n  .sidebar-header {\n    flex: 0 0 auto;\n\n    .sidebar-close-button.tgico:before {\n      content: $tgico-left;\n\n      @include respond-to(not-handhelds) {\n        content: $tgico-close;\n      }\n    }\n  }\n\n  #search-private-container {\n    .chatlist-container {\n      position: relative;\n      flex: 1 1 auto;\n    }\n  }\n\n  /* #forward-container {\n    z-index: 5;\n  } */\n\n  .sidebar-search {\n    display: none;\n\n    &.active {\n      display: flex;\n    }\n  }\n\n  .input-wrapper {\n    width: 100%;\n    max-width: 100%;\n  }\n}\n\n.shared-media-container {\n  //background-color: var(--background-color-true) !important;\n  /* .search-super {\n    top: 100%;\n    min-height: calc((var(--vh, 1vh) * 100) - 100% - 56px);\n\n    &.sliding {\n      max-height: calc((var(--vh, 1vh) * 100) - 100% - 56px);\n    }\n  } */\n  .scrollable:not(.no-parallax) {\n    perspective: 0px;\n    perspective-origin: left top;\n\n    &.parallax {\n      perspective: 1px;\n    }\n  }\n\n  .search-super {\n    top: 100%;\n    min-height: calc((var(--vh, 1vh) * 100) - 56px);\n  }\n\n  .sidebar-header .transition {\n    flex-grow: 1;\n\n    .transition-item {\n      display: flex;\n      align-items: center;\n    }\n  }\n\n  .btn-corner {\n    &.menu-open:before {\n      content: $tgico-close;\n    }\n\n    @include respond-to(handhelds) {\n      width: 54px;\n      height: 54px;\n      bottom: 14px;\n      right: 14px;\n\n      position: fixed !important;\n      z-index: 1;\n    }\n  }\n\n  &.can-add-members {\n    //@include respond-to(handhelds) {\n      .btn-corner:not(.is-hidden) {\n        transform: translateZ(0);\n      }\n    //}\n\n    /* @include hover() {\n      .btn-corner:not(.is-hidden) {\n        transform: translateZ(0);\n      }\n    } */\n  }\n}\n\n.search-super {\n  width: 100%;\n  max-width: 100%;\n  position: absolute;\n  min-height: 100%;\n  display: flex;\n  flex-direction: column;\n  background-color: var(--surface-color);\n\n  .search-group__show-more {\n    color: var(--primary-color);\n    cursor: pointer;\n    font-weight: 400;\n  }\n\n  .search-super-month-name {\n    border-top: 1px solid var(--border-color);\n    padding: 24px 0px 0px 24px;\n    font-weight: 500;\n    color: var(--secondary-text-color);\n\n    @include respond-to(handhelds) {\n      padding: 18px 0px 0px 16px;\n    }\n  }\n\n  /* &.sliding {\n    max-height: 100%;\n  } */\n\n  &.sliding {\n    max-height: none !important;\n  }\n\n  &-tabs {\n    width: auto;\n    flex: 1 1 auto;\n    \n    //margin-top: 36px;\n    /* i {\n      padding-right: 1.5rem !important;\n\t    margin-left: -.75rem !important;\n    } */\n  }\n\n  &-tabs-scrollable {\n    box-shadow: none !important;\n    position: -webkit-sticky !important;\n\t  position: sticky !important;\n    //top: -1px;\n    top: 0px;\n    z-index: 2;\n    background-color: var(--surface-color);\n\n    &:before {\n      position: absolute;\n      width: 100%;\n      height: 1px;\n      left: 0;\n      top: 0;\n      background-color: inherit;\n      display: block;\n      content: \" \";\n      z-index: -1;\n\n      .search-super.is-full-viewport & {\n        top: -1px;\n      }\n    }\n\n    .scrollable {\n      position: relative;\n      display: flex;\n    }\n  }\n\n  &-tabs-container {\n    //min-height: 100%;\n    min-height: calc(100% - 49px);\n    grid-template-rows: 100%;\n    flex: 1 1 auto;\n    //position: absolute; // FIX THE SAFARI!\n    //position: relative;\n    /* width: 500%;\n    margin-left: -100%;\n */\n    /* > div {\n      height: 0;\n    \n      &.active {\n        height: auto;\n      }\n    } */\n\n    > div {\n      //height: 100%;\n      position: relative;\n      min-height: 150px;\n\n      /* > div:not(:empty) + .content-empty {\n        display: none;\n      } */\n\n      > div:first-child {\n        transform: translateY(0);\n\n        // * fix saving scroll on tab switching, when FROM tab has height < 100vh, and another is scrolled less than the FROM tab's height\n        // * adding 1 extra pixel for scroll\n        min-height: calc(100vh - 111px);\n      }\n    }\n\n    /* .scrollable-y {\n      height: auto;\n      position: absolute !important;\n    } */\n\n    /* > div > div:not(.scroll-padding) {\n      height: 100%;\n    } */\n\n    .preloader {\n      padding: 0;\n      position: absolute !important;\n      top: 100px;\n      transform: translate(-50%);\n\n      > svg {\n        height: 50px;\n        width: 50px;\n      }\n    }\n  }\n\n  &-month:first-of-type &-month-name {\n    display: none;\n  }\n\n  .document-name, .audio-title, .title {\n    display: flex;\n    justify-content: space-between;\n  }\n\n  .sent-time {\n    flex: 0 0 auto;\n    margin-left: 8px;\n    margin-top: 3px;\n    font-size: 12px;\n    color: var(--secondary-text-color);\n  }\n\n  &-content-media {\n    .search-super-month-name {\n      border: none;\n      padding: 9px 0px 7px 24px;\n    }\n\n    .video-time {\n      position: absolute;\n      left: 5px;\n      top: 4px;\n      height: 18px;\n      border-radius: 4px;\n      background-color: var(--message-time-background);\n      padding: 0px 6px 0px 5px;\n      z-index: 1;\n      font-size: 12px;\n      color: white;\n      line-height: 18px;\n    }\n\n    .grid-item {\n      overflow: hidden;\n    }\n\n    /* span.video-play {\n      background-color: var(--message-time-background);\n      color: #fff;\n      text-align: center;\n      font-size: 34px;\n      line-height: 60px;\n      cursor: pointer;\n    } */\n  }\n\n  &-content-media &-month {\n    &-items {\n      width: 100%;\n      padding-top: 1px;\n\n      display: grid;\n      grid-template-columns: repeat(3,1fr);\n      grid-auto-rows: 1fr;\n      grid-gap: 1px;\n    }\n  }\n\n  &-content-files {\n    // padding: 8px 20px;\n    .search-super-month-items {\n      padding: 8px 24px 16px 20px;\n\n      @include respond-to(handhelds) {\n        padding: 8px 16px 8px 12px;\n      }\n    }\n\n    .document {\n      padding-left: 60px;\n      // padding-right: 1rem;\n      //height: 54px;\n      height: calc(48px + 1.5rem);\n\n      &-ico, &-download {\n        width: 48px;\n        height: 48px;\n        border-radius: 5px !important;\n      }\n\n      /* & + .document {\n        margin-top: 1.5rem;\n      } */\n    }\n\n    .document-name {\n      font-weight: normal;\n\n      width: 100%;\n      max-width: 100%;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n  }\n\n  &-content-links {\n    // padding: 0 24px 15px 15px;\n\n    .search-super-item {\n      display: flex;\n      flex-direction: column;\n      margin-top: 20px;\n      margin-left: 5px;\n      padding-bottom: 2px;\n      //padding-bottom: 10px;\n      position: relative;\n      padding-left: 60px;\n      overflow: hidden;\n      //min-height: 48px;\n      min-height: 58px;\n\n      .preview {\n        height: 3rem;\n        width: 3rem;\n        border-radius: .375rem;\n        overflow: hidden;\n        position: absolute;\n        left: 0;\n        top: 0;\n\n        &.empty {\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          font-size: 2rem;\n          color: #fff;\n          text-transform: uppercase;\n          background-color: var(--primary-color);\n        }\n\n        .media-photo {\n          object-fit: cover;\n          width: 100%;\n          height: 100%;\n        }\n      }\n\n      .url {\n        white-space: nowrap;\n        text-overflow: ellipsis;\n        overflow: hidden;\n        font-size: 14px;\n        margin-top: -1px;\n      }\n    }\n\n    .title {\n      font-size: 16px;\n      margin-top: 2px;\n    }\n\n    .subtitle {\n      font-size: 14px;\n      max-width: 310px;\n\n      &.sender {\n        margin-top: 2px;\n      }\n    }\n\n    .search-super-month-items {\n      padding: 0 24px 15px 15px;\n    \n      @include respond-to(handhelds) {\n        padding: 0 16px 15px 7px;\n      }\n    }\n\n  }\n\n  &-content-music, &-content-voice {\n    .search-super-month-items {\n      padding: 20px 15px 0px 20px;\n\n      @include respond-to(handhelds) {\n        padding: 20px 15px 0px 12px;\n      }\n    }\n\n    .audio {\n      /* min-height: 58px; */\n      justify-content: unset;\n      margin-bottom: 1.5rem;\n\n      @include respond-to(not-handhelds) {\n        max-width: 377px;\n      }\n\n      &.audio-show-progress .audio-subtitle {\n        overflow: visible;\n      }\n\n      /* &-no-subtitle {\n        padding-bottom: 16px;\n      } */\n    }\n  }\n\n  &-content-members {\n    .chatlist {\n      padding-top: .5rem;\n      padding-bottom: .5rem;\n\n      li {\n        padding: .75rem;\n      }\n\n      .user-caption {\n        padding-left: .75rem;\n      }\n\n      .dialog-subtitle {\n        font-size: .875rem;\n        margin-top: -.375rem;\n      }\n    }\n  }\n}\n\n#search-container {\n  .search-super-content-music {\n    .audio:not(.audio-show-progress) .audio-time {\n      display: none;\n    }\n  }\n  \n  .search-group.is-short {\n    li:nth-child(n + 4) {\n      display: none;\n    }\n  }\n}\n\n#stickers-container {\n  .sticker-sets {\n    display: flex;\n    flex-direction: column;\n    margin-top: 16px;\n  }\n\n  .sticker-set {\n    display: flex;\n    flex-direction: column;\n    height: 140px;\n    cursor: pointer;\n\n    &-name {\n      font-weight: 500;\n    }\n\n    &-count {\n      font-size: 14px;\n      color: var(--secondary-text-color);  \n    }\n\n    &-header {\n      display: flex;\n      padding-left: 16px;\n      padding-bottom: 12px;\n      justify-content: space-between;\n  \n    }\n\n    &-button {\n      height: 30px;\n      padding-left: 12px;\n      padding-right: 13px;\n      margin-right: 16px;\n      font-size: 15px;\n      border-radius: 16px;\n      font-weight: 400;\n      width: auto;\n      transition: width 0.2s;\n\n      &.gray {\n        background: #F1F3F4;\n        color: var(--secondary-text-color);\n      }\n    }\n\n    &-stickers {\n      display: flex;\n      justify-content: space-around;\n    }\n\n    &-sticker {\n      width: 68px;\n      height: 68px;\n      position: relative;\n      //padding: 0 5px;  \n\n      &:hover {\n        border-radius: 12px;\n        background-color: var(--light-secondary-text-color);\n      }\n\n      img {\n        max-width: 100%;\n        max-height: 100%;\n      }\n    }\n  }\n}\n\n#poll-results-container {\n  .poll-results {\n    display: flex;\n    flex-direction: column;\n    position: relative;\n    width: 100%;\n  \n    &-answer {\n      color: var(--secondary-text-color);\n      padding: 0 16px 8px 16px;\n      margin: 0;\n      font-weight: 500;\n      justify-content: space-between;\n      display: flex;\n      font-size: 15px;\n      user-select: none;\n\n      @include respond-to(not-handhelds) {\n        padding: 0 24px 8px 24px;\n      }\n    }\n\n    &-more {\n      padding-top: 13px;\n      padding-bottom: 13px;\n      cursor: pointer;\n      user-select: none;\n      position: relative;\n\n      @include respond-to(not-handhelds) {\n        padding-left: 8px;\n      }\n\n      .tgico-down {\n        float: left;\n        padding-right: 32px;\n        padding-left: 16.5px;\n        font-size: 24px;\n        color: var(--secondary-text-color);\n      }\n    }\n\n    h3 {\n      padding: 0 16px;\n      margin-top: 15px;\n      font-size: 20px;\n      margin-bottom: 16px;\n\n      @include respond-to(not-handhelds) {\n        padding: 0 24px;\n      }\n    }\n  \n    hr {\n      margin-bottom: 15px;\n      margin-top: 7px;\n    }\n  \n    .user-caption {\n      padding: 3px 28px 6px;\n    }\n\n    .user-title {\n      font-weight: normal;\n    }\n  \n    li {\n      height: 50px;\n      padding: 9px;\n\n      @include respond-to(not-handhelds) {\n        padding: 9px 12px;\n      }\n    }\n  }\n}\n\n#search-gifs-container {\n  .gifs-masonry {\n    margin-top: -2.5px;\n  }\n}\n\n.edit-peer-container {\n  .input-wrapper {\n    padding: 0 .75rem;\n    margin-bottom: .5625rem;\n  }\n\n  .sidebar-left-section {\n    padding: 0 0 .5rem;\n  }\n\n  // * supernew and correct layout\n  .chatlist {\n    padding: 0;\n\n    li {\n      height: 72px;\n      padding: 0 .75rem;\n      align-items: center;\n    }\n\n    .user-caption {\n      padding-left: .75rem;\n    }\n\n    p {\n      height: auto;\n    }\n\n    span {\n      line-height: 1.3125;\n    }\n\n    .dialog-subtitle {\n      margin-top: .125rem;\n    }\n\n    .user-last-message {\n      font-size: .875rem;\n    }\n  }\n}\n\n.edit-contact-container {\n  .input-wrapper {\n    margin-top: 1.8125rem;\n    padding-bottom: 1rem;\n  }\n\n  .avatar-placeholder {\n    filter: none !important;\n  }\n\n  .avatar-edit {\n    margin-bottom: 1.375rem !important;\n  }\n\n  .profile-name {\n    font-size: 1.5rem;\n    line-height: 1.3125;\n  }\n}\n\n.group-type-container {\n  .sidebar-left-section-caption {\n    font-size: .875rem;\n    margin-top: .8125rem;\n  }\n\n  .input-wrapper {\n    margin-top: .875rem;\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n.menu-horizontal-scrollable {\n  --scrollable-size: 3.5rem;\n  height: var(--scrollable-size);\n  \n  &:after {\n    content: \" \";\n    position: absolute;\n    height: 1px;\n    border-bottom: 1px solid var(--border-color);\n    bottom: 0;\n    left: 0;\n    right: 0;\n    z-index: -1;\n  }\n\n  .menu-horizontal-div {\n    border-bottom: none;\n  }\n}\n\n.menu-horizontal-div {\n  --size: var(--scrollable-size, 3.5rem);\n  width: 100%;\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  flex-direction: row;\n  position: relative;\n  z-index: 2;\n  user-select: none;\n\n  color: var(--secondary-text-color);\n  border-bottom: 1px solid var(--border-color);\n\n  &-item {\n    height: var(--size);\n    padding: 0 1rem;\n    cursor: pointer;\n    text-align: center;\n    flex: 1 1 auto;\n    font-size: 1rem;\n    font-weight: 500;\n    position: relative;\n    transition: none !important;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    line-height: var(--line-height);\n    border-radius: 0;\n\n    @include hover-background-effect();\n\n    &.active {\n      color: var(--primary-color);\n\n      i {\n        opacity: 1;\n      }\n\n      .c-ripple__circle {\n        background-color: var(--light-primary-color);\n      }\n  \n      @include hover-background-effect(primary);\n\n      .badge {\n        background-color: var(--primary-color);\n      }\n    }\n\n    > span {\n      position: relative;\n      display: inline-flex;\n      align-items: center;\n      overflow: visible;\n    }\n  }\n\n  i {\n    position: absolute;\n    bottom: calc(-.625rem - 7px);\n    left: 0;\n    opacity: 0;\n    background-color: var(--primary-color);\n    height: .1875rem;\n    width: 100%;\n    border-radius: .1875rem .1875rem 0 0;\n    pointer-events: none;\n    /* padding-right: .5rem;\n    margin-left: -.25rem; */\n    box-sizing: content-box;\n    transform-origin: left;\n    z-index: 1;\n\n    &.animate {\n      transition: transform var(--tabs-transition);\n    }\n  }\n}\n\n.tabs-container {\n  min-width: 100%;\n  width: 100%;\n  display: grid;\n  //grid-template-columns: 1fr;\n  grid-template-columns: 100%;\n  grid-template-rows: 100%;\n\n  /* @include respond-to(not-handhelds) {\n    overflow-x: hidden;\n  } */\n\n  // &.animated {\n  //   transition: .3s transform;\n  // }\n  \n  > div {\n    // * can't define these rules because of old firefox, though they don't work\n    //height: 100%;\n    //max-height: 100%;\n    //width: 100%;\n    //max-width: 100%;\n    \n    display: none;\n    flex-direction: column;\n    position: relative;\n    grid-row-start: 1;\n    grid-column-start: 1;\n    background-color: var(--background-color);\n    //z-index: 1;\n\n    body.animation-level-0 & {\n      transition: none !important;\n    }\n    \n    //@include respond-to(not-handhelds) {\n      overflow: hidden;\n    //}\n\n    &.active {\n      display: flex;\n    }\n    \n    > div:not(.scroll-padding) {\n      width: 100%;\n      max-width: 100%;\n      //overflow: hidden;\n      position: relative;\n    }\n  }\n\n  /* &[data-animation=\"tabs\"] {\n    & > div {\n      --width: 100%;\n      transition: transform var(--tabs-transition);\n      transform: translateZ(0);\n\n      &.from {\n        animation: slide-tabs-from var(--tabs-transition) forwards;\n      }\n\n      &.to {\n        transform: translate3d(var(--width), 0, 0);\n        animation: slide-tabs-to var(--tabs-transition) forwards;\n      }\n    }\n\n    &.backwards > div {\n      &.from {\n        animation: slide-tabs-backwards-from var(--tabs-transition) forwards;\n      }\n\n      &.to {\n        transform: translate3d(calc(var(--width) * -1), 0, 0);\n        animation: slide-tabs-backwards-to var(--tabs-transition) forwards;\n      }\n    }\n  } */\n  \n  &[data-animation=\"tabs\"] > div {\n    transition: transform var(--tabs-transition);\n  }\n\n  &[data-animation=\"navigation\"] > div {\n    transition: transform var(--tabs-transition), filter var(--tabs-transition);\n  }\n}\n\n/* @keyframes slide-tabs-from {\n  to {\n    transform: translate3d(calc(var(--width) * -1), 0, 0);\n  }\n}\n\n@keyframes slide-tabs-to {\n  to {\n    transform: translateZ(0);\n  }\n}\n\n@keyframes slide-tabs-backwards-from {\n  to {\n    transform: translate3d(var(--width), 0, 0);\n  }\n}\n\n@keyframes slide-tabs-backwards-to {\n  to {\n    transform: translateZ(0);\n  }\n} */\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n$placeholder-color: #9e9e9e;\n$border-radius: 8px;\n$border-radius-medium: 10px;\n$border-radius-big: 12px;\n\n$hover-alpha: .08;\n\n//$small-screen: 720px;\n$small-screen: 600px;\n//$small-screen: 900px;\n$medium-screen: 1275px;\n$large-screen: 1680px;\n//$large-screen: 16800px;\n\n$floating-left-sidebar: 925px;\n$messages-container-width: 728px;\n\n$chat-input-size: 3.375rem;\n$chat-input-handhelds-size: 2.875rem;\n$chat-padding: .8125rem;\n$chat-padding-handhelds: .5rem;\n$chat-input-inner-padding: .5rem;\n$chat-input-inner-padding-handhelds: .25rem;\n\n@function hover-color($color) {\n  @return rgba($color, $hover-alpha);\n}\n\n/* @mixin safari-overflow() {\n  html.is-safari & {\n    -webkit-mask-image: -webkit-radial-gradient(circle, white 100%, black 100%);\n    @content;\n  }\n} */\n\n@import \"mixins/hover\";\n@import \"mixins/respondTo\";\n@import \"mixins/textOverflow\";\n@import \"mixins/animationLevel\";\n\n:root {\n  --vh: 1vh;\n  --z-below: -1;\n  --hover-alpha: #{$hover-alpha};\n\n  --transition-standard-easing: cubic-bezier(.4, .0, .2, 1);\n  --transition-standard-in-time: .3s;\n  --transition-standard-out-time: .25s;\n  --transition-standard-in: var(--transition-standard-in-time) var(--transition-standard-easing);\n  --transition-standard-out: var(--transition-standard-out-time) var(--transition-standard-easing);\n  \n  --pm-transition: .2s ease-in-out;\n  --layer-transition: .2s cubic-bezier(.4, .0, .2, 1);\n  --slide-header-transition: .4s ease-in-out;\n  --tabs-transition: .25s ease-in-out;\n  --btn-menu-transition: .2s cubic-bezier(.4, 0, .2, 1);\n  --esg-transition: var(--btn-menu-transition);\n  --popup-transition-function: cubic-bezier(.4, 0, .2, 1);\n  --popup-transition-time: .15s;\n  //--layer-transition: .3s cubic-bezier(.33, 1, .68, 1);\n  //--layer-transition: none;\n  --btn-corner-transition: .2s cubic-bezier(.34, 1.56, .64, 1);\n  --message-handhelds-margin: 5.5625rem;\n  --message-beside-button-margin: 2.875rem;\n  --message-time-background: rgba(0, 0, 0, .35);\n  --message-highlightning-color: hsla(85.5319, 36.9171%, 40.402%, .4);//rgba(77, 142, 80, .4);\n  --messages-container-width: #{$messages-container-width};\n  --messages-text-size: 16px;\n  --messages-secondary-text-size: calc(var(--messages-text-size) - 1px);\n  --line-height: 1.3125;\n  --esg-sticker-size: 80px;\n  --disabled-opacity: .3;\n\n  // https://github.com/overtake/TelegramSwift/blob/5cc7d2475fe4738a6aa0486c23eaf80a89d33b97/submodules/TGUIKit/TGUIKit/PresentationTheme.swift#L2054\n  --peer-avatar-red-top: #ff885e;\n  --peer-avatar-red-bottom: #ff516a;\n  --peer-avatar-orange-top: #ffcd6a;\n  --peer-avatar-orange-bottom: #ffa85c;\n  --peer-avatar-violet-top: #82b1ff;\n  --peer-avatar-violet-bottom: #665fff;\n  --peer-avatar-green-top: #a0de7e;\n  --peer-avatar-green-bottom: #54cb68;\n  --peer-avatar-cyan-top: #53edd6;\n  --peer-avatar-cyan-bottom: #28c9b7;\n  --peer-avatar-blue-top: #72d5fd;\n  --peer-avatar-blue-bottom: #2a9ef1;\n  --peer-avatar-pink-top: #e0a2f3;\n  --peer-avatar-pink-bottom: #d669ed;\n\n  @include respond-to(handhelds) {\n    --right-column-width: 100vw;\n    --esg-sticker-size: 68px;\n\n    --chat-input-size: #{$chat-input-handhelds-size};\n    --chat-input-padding: #{$chat-padding-handhelds};\n    --chat-input-inner-padding: #{$chat-input-inner-padding-handhelds};\n  }\n\n  @include respond-to(not-handhelds) {\n    --right-column-width: calc(#{$large-screen} / 4);\n\n    --chat-input-size: #{$chat-input-size};\n    --chat-input-padding: #{$chat-padding};\n    --chat-input-inner-padding: #{$chat-input-inner-padding};\n  }\n\n  @include respond-to(esg-bottom) {\n    --chat-input-size: #{$chat-input-handhelds-size};\n    --chat-input-inner-padding: #{$chat-input-inner-padding-handhelds};\n  }\n\n  @include respond-to(only-medium-screens) {\n    --right-column-width: 25vw;\n  }\n}\n\n@mixin splitColor($property, $color, $light: true, $dark: true) {\n  --#{$property}: #{$color};\n\n  @if $light != false {\n    --light-#{$property}: #{hover-color($color)};\n  }\n\n  @if $dark != false {\n    --dark-#{$property}: #{darken($color, $hover-alpha * 100)};\n  }\n}\n\n:root {\n  // * Day theme\n  --body-background-color: #fff;\n  --background-color-true: #f4f4f5;\n  --background-color: #fff;\n  --border-color: #dfe1e5;\n  --surface-color: #fff;\n  --scrollbar-color: rgba(0, 0, 0, .2);\n\n  --input-search-background-color: #fff;\n  --input-search-border-color: #dfe1e5;\n\n  @include splitColor(primary-color, #3390ec, true, true);\n  --primary-text-color: #000;\n\n  --secondary-color: #c4c9cc;\n  @include splitColor(secondary-text-color, #707579, true, false);\n\n  @include splitColor(danger-color, #df3f40, true, false);\n\n  --avatar-online-color: #0ac630;\n  --avatar-color-top: var(--peer-avatar-blue-top);\n  --avatar-color-bottom: var(--peer-avatar-blue-bottom);\n  --chatlist-status-color: var(--avatar-online-color);\n  --chatlist-pinned-color: #a2abb2;\n  --badge-text-color: #fff;\n  --link-color: #00488f;\n  --ripple-color: rgba(0, 0, 0, .08);\n  --poll-circle-color: var(--border-color);\n\n  --message-background-color: var(--surface-color);\n  --message-checkbox-color: #61c642;\n  --message-checkbox-border-color: #fff;\n  --message-secondary-color: var(--secondary-color);\n\n  @include splitColor(message-out-background-color, #eeffde, true, true);\n  --message-out-link-color: var(--link-color);\n  --message-out-primary-color: #4fae4e;\n  --message-out-status-color: var(--message-out-primary-color);\n  --message-out-audio-play-button-color: #fff;\n\n  // * Day theme end\n}\n\nhtml.night {\n//:root {\n  // * Night theme\n  --body-background-color: #181818;\n  --background-color-true: #181818;\n  --background-color: #212121;\n  --border-color: #0f0f0f;\n  --surface-color: #212121;\n  --scrollbar-color: rgba(255, 255, 255, .2);\n\n  --input-search-background-color: #181818;\n  --input-search-border-color: #2f2f2f;\n\n  @include splitColor(primary-color, #8774E1, true, true);\n  --primary-text-color: #fff;\n\n  --secondary-color: #707579;\n  @include splitColor(secondary-text-color, #aaaaaa, true, false);\n\n  @include splitColor(danger-color, #ff595a, true, false);\n\n  --avatar-online-color: #0ac630;\n  --avatar-color-top: var(--peer-avatar-violet-top);\n  --avatar-color-bottom: var(--peer-avatar-violet-bottom);\n  --chatlist-status-color: var(--primary-color);\n  --chatlist-pinned-color: var(--secondary-color);\n  --badge-text-color: #fff;\n  --link-color: var(--primary-color);\n  --ripple-color: rgba(255, 255, 255, .08);\n  --poll-circle-color: #fff;\n\n  --message-background-color: var(--surface-color);\n  --message-checkbox-color: var(--primary-color);\n  --message-checkbox-border-color: #fff;\n  --message-secondary-color: var(--secondary-color);\n\n  //@include splitColor(message-out-background-color, #ae582d, true, true);\n  @include splitColor(message-out-background-color, #8774E1, true, true);\n  --message-out-link-color: #fff;\n  --message-out-primary-color: #fff;\n  --message-out-status-color: rgba(255, 255, 255, .6);\n  --message-out-audio-play-button-color: var(--message-out-background-color);\n  // * Night theme end\n}\n\n@import \"partials/ico\";\n@import \"partials/input\";\n@import \"partials/button\";\n@import \"partials/animatedIcon\";\n@import \"partials/autocompleteHelper\";\n@import \"partials/autocompletePeerHelper\";\n@import \"partials/badge\";\n@import \"partials/checkbox\";\n@import \"partials/chatlist\";\n@import \"partials/chat\";\n@import \"partials/chatTopbar\";\n@import \"partials/chatBubble\";\n@import \"partials/chatPinned\";\n@import \"partials/chatMarkupTooltip\";\n@import \"partials/chatStickersHelper\";\n@import \"partials/chatEmojiHelper\";\n@import \"partials/chatSearch\";\n@import \"partials/chatDrop\";\n@import \"partials/crop\";\n@import \"partials/sidebar\";\n@import \"partials/profile\";\n@import \"partials/slider\";\n@import \"partials/leftSidebar\";\n@import \"partials/rightSidebar\";\n@import \"partials/mediaViewer\";\n@import \"partials/ckin\";\n@import \"partials/emojiDropdown\";\n@import \"partials/scrollable\";\n@import \"partials/selector\";\n@import \"partials/gifsMasonry\";\n@import \"partials/preloader\";\n@import \"partials/ripple\";\n@import \"partials/avatar\";\n@import \"partials/document\";\n@import \"partials/audio\";\n@import \"partials/quizHint\";\n@import \"partials/peerTyping\";\n@import \"partials/poll\";\n@import \"partials/transition\";\n@import \"partials/row\";\n@import \"partials/colorPicker\";\n@import \"partials/replyKeyboard\";\n\n@import \"partials/popups/popup\";\n@import \"partials/popups/editAvatar\";\n@import \"partials/popups/mediaAttacher\";\n@import \"partials/popups/peer\";\n@import \"partials/popups/stickers\";\n@import \"partials/popups/datePicker\";\n@import \"partials/popups/createPoll\";\n@import \"partials/popups/forward\"; \n@import \"partials/popups/instanceDeactivated\";\n@import \"partials/popups/joinChatInvite\";\n\n@import \"partials/pages/pages\";\n@import \"partials/pages/authCode\";\n@import \"partials/pages/chats\";\n@import \"partials/pages/password\";\n\n/* cyrillic */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 400;\n  font-display: swap;\n  src: local('Roboto'), local('Roboto-Regular'), url(assets/fonts/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format('woff2');\n  unicode-range:U + 0400-045F, U + 0490-0491, U + 04B0-04B1, U + 2116\n}\n\n/* latin-ext */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 400;\n  font-display: swap;\n  src: local('Roboto'), local('Roboto-Regular'), url(assets/fonts/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format('woff2');\n  unicode-range:U + 0100-024F, U + 0259, U + 1E00-1EFF, U + 2020, U + 20A0-20AB, U + 20AD-20CF, U + 2113, U + 2C60-2C7F, U + A720-A7FF\n}\n\n/* latin */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 400;\n  font-display: swap;\n  src: local('Roboto'), local('Roboto-Regular'), url(assets/fonts/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format('woff2');\n  unicode-range:U + 0000-00FF, U + 0131, U + 0152-0153, U + 02BB-02BC, U + 02C6, U + 02DA, U + 02DC, U + 2000-206F, U + 2074, U + 20AC, U + 2122, U + 2191, U + 2193, U + 2212, U + 2215, U + FEFF, U + FFFD\n}\n\n/* cyrillic */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 500;\n  font-display: swap;\n  src: local('Roboto Medium'), local('Roboto-Medium'), url(assets/fonts/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format('woff2');\n  unicode-range:U + 0400-045F, U + 0490-0491, U + 04B0-04B1, U + 2116\n}\n\n/* latin-ext */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 500;\n  font-display: swap;\n  src: local('Roboto Medium'), local('Roboto-Medium'), url(assets/fonts/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format('woff2');\n  unicode-range:U + 0100-024F, U + 0259, U + 1E00-1EFF, U + 2020, U + 20A0-20AB, U + 20AD-20CF, U + 2113, U + 2C60-2C7F, U + A720-A7FF\n}\n\n/* latin */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 500;\n  font-display: swap;\n  src: local('Roboto Medium'), local('Roboto-Medium'), url(assets/fonts/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format('woff2');\n  unicode-range:U + 0000-00FF, U + 0131, U + 0152-0153, U + 02BB-02BC, U + 02C6, U + 02DA, U + 02DC, U + 2000-206F, U + 2074, U + 20AC, U + 2122, U + 2191, U + 2193, U + 2212, U + 2215, U + FEFF, U + FFFD\n}\n\n// !!! FIX FOR [contenteditable] Ctrl+B, due to font-weight: 500;\n\n/* cyrillic */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 700;\n  font-display: swap;\n  src: local('Roboto Medium'), local('Roboto-Medium'), url(assets/fonts/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format('woff2');\n  unicode-range:U + 0400-045F, U + 0490-0491, U + 04B0-04B1, U + 2116\n}\n\n/* latin-ext */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 700;\n  font-display: swap;\n  src: local('Roboto Medium'), local('Roboto-Medium'), url(assets/fonts/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format('woff2');\n  unicode-range:U + 0100-024F, U + 0259, U + 1E00-1EFF, U + 2020, U + 20A0-20AB, U + 20AD-20CF, U + 2113, U + 2C60-2C7F, U + A720-A7FF\n}\n\n/* latin */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 700;\n  font-display: swap;\n  src: local('Roboto Medium'), local('Roboto-Medium'), url(assets/fonts/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format('woff2');\n  unicode-range:U + 0000-00FF, U + 0131, U + 0152-0153, U + 02BB-02BC, U + 02C6, U + 02DA, U + 02DC, U + 2000-206F, U + 2074, U + 20AC, U + 2122, U + 2191, U + 2193, U + 2212, U + 2215, U + FEFF, U + FFFD\n}\n\nhtml, body {\n  height: 100%;\n  width: 100%;\n  margin: 0;\n  padding: 0;\n  \n  @include respond-to(handhelds) {\n    overflow: hidden;\n    height: calc(var(--vh, 1vh) * 100);\n  }\n\n  /* @include respond-to(handhelds) {\n    //overflow-y: auto;\n    height: 100%;\n    min-height: 100%;\n    min-width: 100%;\n  }\n\n  @include respond-to(not-handhelds) {\n    width: 100%;\n    height: 100%;\n  } */\n}\n\nhtml.is-ios {\n  //&, body {\n    position: fixed; // fix iOS fullscreen scroll\n  //}\n}\n\n@supports(padding: unquote('max(0px)')) {\n  html {\n    padding: 0 unquote('min(16px, env(safe-area-inset-right))') 0 unquote('min(16px, env(safe-area-inset-left))');\n  }\n}\n\nhtml {\n  font-size: 16px;\n  //overflow: hidden;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-size-adjust: 100%;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  //text-rendering: optimizeSpeed;\n}\n\nbody {\n  //touch-action: pan-x pan-y;\n  background-color: var(--body-background-color);\n  color: var(--primary-text-color);\n}\n\nbody.deactivated {\n  animation: grayscale-in var(--transition-standard-in) forwards;\n}\n\nbody.deactivated-backwards {\n  animation: grayscale-out var(--transition-standard-out) forwards;\n}\n\n@keyframes grayscale-in {\n  0% {\n    filter: grayscale(0);\n  }\n\n  100% {\n    filter: grayscale(1);\n  }\n}\n\n@keyframes grayscale-out {\n  0% {\n    filter: grayscale(1);\n  }\n\n  100% {\n    filter: grayscale(0);\n  }\n}\n\n/* body {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  min-height: 0!important;\n} */\n\na {\n  color: var(--link-color);\n}\n\nbutton, input, optgroup, select, textarea, html {\n  font-family: \"Roboto\", -apple-system, apple color emoji, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif;\n}\n\ninput, textarea, button, select, a, div {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n\n.whole {\n  min-height: 100%;\n  width: 100%;\n  //min-width: 100%;\n  margin: 0 auto;\n  max-width: $large-screen;\n\n  //@include respond-to(not-handhelds) {\n    height: 100%;\n  //}\n}\n\n.disable-hover/* ,\n.disable-hover * */ {\n  pointer-events: none !important;\n}\n\n@include respond-to(not-handhelds) {\n  .only-handhelds {\n    display: none !important;\n  }\n}\n\n.container {\n  margin: 0 auto;\n}\n\nh1, h2, h3, h4, h5, h6 {\n  font-weight: 500;\n}\n\nh4 {\n  font-size: 2rem;\n  //margin: 1.5rem 0 1rem 0;\n  margin: 22px 0 14px;\n  line-height: 110%;\n\n  @include respond-to(handhelds) {\n    font-size: 20px;\n    margin: 2px 0 8px;\n  }\n}\n\ninput, [contenteditable=true] {\n  caret-color: var(--primary-color);\n  color: var(--primary-text-color);\n  background-color: transparent;\n}\n\ninput, textarea {\n\t-webkit-appearance: none;\n}\n\n/* input:-webkit-autofill,\ninput:-webkit-autofill:hover,\ninput:-webkit-autofill:focus,\ninput:-webkit-autofill:active {\n  transition: background-color 5000s ease-in-out 0s;\n} */\n\n.subtitle {\n  /* font-weight: 500; */\n  color: var(--secondary-text-color);\n  line-height: 1.35;\n}\n\n.danger {\n  color: var(--danger-color) !important;\n\n  .c-ripple__circle {\n    background-color: var(--light-danger-color);\n  }\n}\n\n.blue, .primary {\n  color: var(--primary-color) !important;\n\n  .c-ripple__circle {\n    background-color: var(--light-primary-color);\n  }\n}\n\n.blue:before, .primary:before, .danger:before {\n  color: inherit !important;\n}\n\n.bg-warning {\n  background: #fed85a !important;\n}\n\n.contextmenu {\n\tposition: fixed !important;\n\tright: auto !important;\n  bottom: auto !important;\n  width: auto !important;\n  z-index: 4 !important;\n}\n\n.preloader {\n  width: 50px;\n  height: 50px;\n  \n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  \n  // ! do not change it to &-path\n  .preloader-path {\n    stroke: var(--primary-color);\n  }\n}\n\n@keyframes thumbnail-fade-in-opacity {\n  0% {\n    opacity: 0;\n  }\n\n  to {\n    opacity: .8;\n  }\n}\n\n@keyframes fade-in-opacity {\n  0% {\n    opacity: 0;\n  }\n\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fade-out-opacity {\n  0% {\n    opacity: 1;\n  }\n\n  to {\n    opacity: 0;\n  }\n}\n\n@keyframes fade-in-backwards-opacity {\n  0% {\n    opacity: 1;\n  }\n  100% {\n    opacity: 0;\n  }\n}\n\n@keyframes fade-out-backwards-opacity {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n@keyframes fade-in-opacity-fade-out-opacity {\n  0% {\n    opacity: 0;\n  }\n\n  10% {\n    opacity: 1;\n  }\n\n  50% {\n    opacity: 1;\n  }\n\n  to {\n    opacity: 0;\n  }\n}\n\n.toast {\n  position: fixed;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  padding: .5rem 1rem;\n  background-color: rgba(0, 0, 0, .66);\n  color: #fff;\n  font-size: 1rem;\n  border-radius: $border-radius-medium;\n  animation: fade-in-opacity-fade-out-opacity 3s linear forwards;\n  z-index: 5;\n  max-width: 22.5rem;\n\n  b {\n    color: inherit;\n  }\n}\n\nhr {\n  width: 100%;\n  border: none;\n  border-top: 1px solid var(--border-color);\n  margin: 0;\n  padding-bottom: .5rem;\n}\n\n.user-title, b/* , .user-last-message b */ {\n  color: var(--primary-text-color);\n  font-weight: bolder;\n  //font-weight: 500;\n  //font-weight: normal;\n}\n\n.user-last-message b {\n  font-weight: 400;\n  //margin-right: .25rem;\n}\n\n.avatar-edit {\n  position: relative;\n  border-radius: 50%;\n  cursor: pointer;\n  overflow: hidden;\n\n  &-canvas {\n    max-width: 100%;\n    max-height: 100%;\n    width: 100%;\n    height: 100%;\n    background-color: var(--primary-color);\n  }\n\n  .tgico-cameraadd {\n    position: absolute;\n    font-size: 48px;\n\t  line-height: 48px;\n    top: 50%;\n    left: 50%;\n    transform: translateY(-50%) translateX(-50%);\n    z-index: 2;\n    color: #fff;\n  }\n\n  .avatar-placeholder {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    filter: brightness(0.7);\n  }\n}\n\n.select-wrapper {\n  max-height: 23.5rem;\n  /* height: auto; */\n  position: absolute;\n  width: 100%;\n  top: calc(100% + .5rem);\n  left: 0;\n  overflow: hidden;\n  background-color: var(--surface-color);\n  z-index: 3;\n  border-radius: $border-radius-medium;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: wrap;\n  transition: opacity .2s ease-out, transform .2s ease-out;\n  transform: scale(.95);\n  transform-origin: top center;\n  opacity: 0;\n\n  &.active {\n    transform: scale(1);\n    opacity: 1;\n  }\n  \n  ul {\n    margin: .5rem 0;\n  }\n  \n  li {\n    /* display: flex; */\n    align-items: center;\n    padding: 0 1rem;\n    justify-content: space-between;\n    height: 3.5rem;\n    cursor: pointer;\n    /* font-weight: 500; */\n    \n    text-align: left;\n    display: grid;\n    grid-template-columns: calc(26px + 2rem) 1fr 80px;\n    \n    @include hover-background-effect();\n  }\n  \n  // +2 px bc of whitespace\n  .emoji {\n    height: 26px;\n    width: 26px;\n    font-size: 26px;\n    line-height: 1;\n  }\n\n  .scrollable {\n    position: relative;\n  }\n}\n\n.phone-code {\n  color: $placeholder-color;\n  text-align: right;\n}\n\n// this dimensions will be used for monkey business\n.auth-image {\n  width: 166px;\n  height: 166px;\n  margin: 0 auto 18px;\n  position: relative;\n  \n  @include respond-to(handhelds) {\n    width: 120px;\n    height: 120px;\n  }\n}\n\n/* .phone-wrapper {\n  display: flex;\n  align-items: ;\n} */\n\n.phone-edit {\n  display: inline-block;\n  width: 24px;\n  height: 24px;\n  margin-left: .4rem;\n  opacity: .5;\n  transition: .2s opacity;\n  cursor: pointer;\n  font-size: 1.5rem;\n  \n  @include respond-to(handhelds) {\n    margin-top: -14px;\n  }\n  \n  @include hover() {\n    opacity: 1;\n  }\n}\n\nspan.emoji {\n  display: inline !important;\n  vertical-align: unset !important;\n  //line-height: 1em;\n  //font-size: 1em;\n\n  font-family: apple color emoji,segoe ui emoji,noto color emoji,android emoji,emojisymbols,emojione mozilla,twemoji mozilla,segoe ui symbol;\n  line-height: 1 !important;\n}\n\nimg.emoji {\n  width: 18px;\n  height: 18px;\n  margin: 0 .125rem;\n\n  display: inline-block;\n  /* width: 100%;\n  height: 100%; */\n  max-width: 100%;\n  max-height: 100%;\n  vertical-align: middle;\n}\n\n[contenteditable=true] {\n  user-select: text;\n  outline: none;\n  cursor: text;\n}\n\n[contenteditable][data-placeholder] {\n  &:empty:before {\n    content: attr(data-placeholder);\n    color: #a2acb4;\n    display: block; /* For Firefox By Ariel Flesler */\n    pointer-events: none;\n  }\n}\n\n.sticky_sentinel {\n  position: absolute;\n  left: 0;\n  right: 0; /* needs dimensions */\n  visibility: hidden;\n  pointer-events: none;\n}\n\n.super-stickers {\n  width: 100%;\n\tdisplay: grid;\n\tgrid-template-columns: repeat(auto-fill, var(--esg-sticker-size)); // 64px\n\tgrid-column-gap: 1px;\n\tjustify-content: space-between;\n}\n\n.super-sticker {\n  @include hover-background-effect() {\n    border-radius: 10px;\n  }\n  \n  /* &:nth-child(5n+5) {\n    margin-right: 0;\n  } */\n  \n  /* > img, > .rlottie {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n  }\n\n  > img {\n    object-fit: contain;\n    \n    @include animation-level(2) {\n      animation: fade-in-opacity .2s ease forwards;\n    }\n  } */\n}\n\n.fade-in-transition {\n  opacity: 1;\n  transition: opacity .2s ease;\n}\n\n.show-more {\n  padding-top: 13px;\n  padding-bottom: 13px;\n  cursor: pointer;\n  user-select: none;\n  position: relative;\n\n  @include respond-to(not-handhelds) {\n    padding-left: 8px;\n  }\n\n  .tgico-down {\n    float: left;\n    padding-right: 32px;\n    padding-left: 16px;\n    font-size: 24px;\n    color: var(--secondary-text-color);\n  }\n}\n\n// .message .audio .preloader-container {\n// \t@include respond-to(handhelds) {\n// \t\twidth: 30px;\n// \t\theight: 30px;\n// \t\tleft: 2px;\n// \t}\n// }\n\n.content-empty {\n  color: var(--secondary-text-color);\n}\n\n@keyframes grow-icon {\n  0% {\n    transform: scale(.5);\n    opacity: .8;\n  }\n\n  50% {\n    transform: scale(1.1);\n    opacity: 1;\n  }\n\n  100% {\n    transform: scale(1);\n  }\n}\n\n@keyframes hide-icon {\n  from {\n    transform: scale(1);\n    opacity: .4;\n  }\n\n  to {\n    transform: scale(.5);\n    opacity: 0;\n  }\n}\n\n.popup-disable-password, .popup-skip-email {\n  .popup-description {\n    max-width: 284px;\n  }\n}\n\n.grid {\n  width: 100%;\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-auto-rows: 1fr;\n  grid-gap: .25rem;\n\n  &-item {\n    height: 0;\n    padding-bottom: 100%;\n    //overflow: hidden;\n    position: relative;\n    cursor: pointer;\n    user-select: none;\n    \n    &-media {\n      position: absolute;\n      left: 0;\n      top: 0;\n      width: 100%;\n      height: 100%;\n      object-fit: cover;\n    }\n  }\n}\n\n.animated-super {\n  &-row {\n    --translateY: 100%;\n    position: absolute;\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    transition: transform var(--pm-transition), opacity var(--pm-transition);\n\n    body.animation-level-0 & {\n      transition: none;\n    }\n\n    /* &:not(.is-hiding) {\n      transform: none !important;\n    } */\n\n    &.is-hiding {\n      opacity: 0;\n\n      &.from-top {\n        transform: translate3d(0, calc(var(--translateY) * -1), 0);\n        //transform: translateY(calc(var(--translateY) * -1));\n        //transform: translateY(-100%);\n      }\n\n      &.from-bottom {\n        transform: translate3d(0, var(--translateY), 0);\n        //transform: translateY(var(--translateY));\n        //transform: translateY(100%);\n      }\n      \n      /* &.backwards {\n        opacity: 1;\n        transform: translateY(0) !important;\n      } */\n    }\n  }\n}\n\n.animated-counter {\n  display: inline-flex;\n\n  &-decimal {\n    position: relative;\n\n    &-placeholder {\n      color: transparent;\n    }\n\n    &-wrapper {\n      position: absolute;\n      left: 0;\n      top: 0;\n      bottom: 0;\n      right: 0;\n    }\n\n    /* &:not(:first-child) {\n      .animated-super {\n        &-row {\n          &.is-hiding {\n            &.from-top {\n              transform: translateY(100%);\n            }\n      \n            &.from-bottom {\n              transform: translateY(-100%);\n            }\n          }\n        }\n      }\n    } */\n  }\n\n  /* &.from-top {\n    .animated-super-row.is-hiding {\n      &.from-top {\n        transform: translateY(100%) !important;\n      }\n    }\n  } */\n}\n\n// *:not(input):not(textarea) {\n//   -webkit-user-select: none; /* disable selection/Copy of UIWebView */\n//   -webkit-touch-callout: none; /* disable the IOS popup when long-press on a link */\n// }   \n\nmiddle-ellipsis-element {\n  width: 100%;\n\toverflow: hidden;\n\tdisplay: block;\n}\n\n.album-item {\n  &-media {\n    width: 100%;\n    height: 100%;\n  }\n}\n\n.hover-effect {\n  @include hover-background-effect();\n}\n\n.progress-ring {\n  position: absolute;\n  top: 0;\n  left: 0;\n  pointer-events: none;\n\n  &__circle {\n    transition: stroke-dashoffset;\n    stroke-linecap: round;\n  }\n}\n\n.rlottie, .rlottie-vector {\n  left: 0;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  position: absolute;\n  max-width: 100%;\n  max-height: 100%;\n  width: 100%;\n  height: 100%;\n}\n\n.rlottie.fade-in {\n  @include animation-level(2) {\n    animation: fade-in-opacity .2s ease-in-out forwards;\n  }\n}\n\n.rlottie-vector {\n  fill: rgba(0, 0, 0, .08);\n}\n\n.media-photo, .media-video, .media-sticker, .media-round {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n\n  @include animation-level(2) {\n    &.fade-in {\n      animation: fade-in-opacity .2s ease-in-out forwards;\n    }\n  \n    &.fade-out {\n      animation: fade-out-opacity .2s ease-in-out forwards;\n    }\n  }\n}\n\n.media-photo.thumbnail {\n  @include animation-level(2) {\n    &.fade-in {\n      animation: thumbnail-fade-in-opacity .2s ease-in-out forwards;\n    }\n  }\n}\n\n.media-video {\n  z-index: 1; // * overflow media-photo\n}\n\n.media-sticker {\n  margin: auto;\n  object-fit: contain;\n  width: 100%;\n  height: 100%;\n  max-width: 100%;\n  max-height: 100%;\n}\n\n.media-round {\n  max-width: 200px;\n  max-height: 200px;\n  z-index: 1;\n\n  canvas {\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    position: relative;\n  }\n\n  .video-time {\n    padding: 1px 6px 2px;\n    background-color: rgba(0, 0, 0, .23) !important;\n  }\n\n  &.is-paused .video-time {\n    &:after {\n      content: $tgico-nosound;\n      padding-left: .25rem;\n      display: flex;\n      align-items: center;\n      font-size: 1.125rem;\n    }\n  }\n}\n\n.gradient-delimiter {\n  width: 100%;\n  height: .75rem;\n  display: flex;\n  background-color: var(--background-color-true);\n  position: relative;\n\n  &:before {\n    content: \" \";\n    position: absolute;\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    background: linear-gradient(180deg, rgba(0, 0, 0, .06) 0%, rgba(0, 0, 0, 0) 20%, rgba(0, 0, 0, 0) 94%, rgba(0, 0, 0, .06) 100%);\n  }\n}\n\n// ! TEMPORARY\n.tgico-reply:before, \n.tgico-attach:before,\n.tgico-saved:before,\n.tgico-phone:before,\n.tgico-admin:before,\n.tgico-message:before,\n.tgico-fontsize:before,\n.tgico-forward:before {\n  font-size: 20px !important;\n  padding: 0 2px;\n}\n\n.stealthy {\n  left: 0;\n  margin: 0;\n  max-height: 1px;\n  max-width: 1px;\n  opacity: 0;\n  outline: none;\n  overflow: hidden;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  z-index: -1;\n}\n\n.verified-check {\n  fill: #fff;\n}\n\n.verified-background {\n  fill: #33a8e5;\n}\n\n.navigable-list {\n  .active {\n    background-color: var(--light-secondary-text-color);\n    border-radius: inherit;\n  }\n}\n\n.super-emojis {\n  // ! No chrome 56 support\n  display: grid;\n  grid-column-gap: 2.44px;\n  grid-template-columns: repeat(auto-fill, 2.625rem);\n  justify-content: space-between;\n\n  font-size: 2.125rem;\n  line-height: 2.125rem;\n\n  .super-emoji {\n    display: inline-block;\n    margin: 0 .0625rem;\n    padding: .25rem;\n    line-height: inherit;\n    border-radius: $border-radius;\n    cursor: pointer;\n    user-select: none;\n    vertical-align: middle;\n    \n    width: 2.625rem;\n    height: 2.625rem;\n\n    html:not(.emoji-supported) & {\n      position: relative;\n    }\n\n    .emoji-placeholder {\n      position: absolute;\n      left: 7px;\n      top: 7px;\n      width: 1.75rem;\n      height: 1.75rem;\n      border-radius: 50%;\n      background-color: var(--light-secondary-text-color);\n      pointer-events: none;\n\n      @include animation-level(2) {\n        opacity: 0;\n        transition: opacity .2s ease-in-out;\n      }\n    }\n\n    @include animation-level(2) {\n      img {\n        opacity: 1;\n        transition: opacity .2s ease-in-out;\n      }\n    }\n    \n    .emoji {\n      width: 100%;\n      height: 100%;\n      vertical-align: unset;\n      margin: 0;\n    }\n    \n    @include hover-background-effect();\n  }\n}\n\n.tgico-char {\n  &:before {\n    font-family: \"Roboto\" !important;\n    font-weight: 500;\n    width: 1.5rem;\n    text-align: center;\n  }\n\n  &.z:before {\n    content: \"Z\";\n  }\n\n  &.w:before {\n    content: \"W\";\n  }\n}\n"], "fixing_code": ["/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport { formatDateAccordingToToday, months } from \"../helpers/date\";\nimport { copy, getObjectKeysAndSort, safeAssign } from \"../helpers/object\";\nimport { escapeRegExp, limitSymbols } from \"../helpers/string\";\nimport appChatsManager from \"../lib/appManagers/appChatsManager\";\nimport appDialogsManager from \"../lib/appManagers/appDialogsManager\";\nimport appMessagesManager, { MyInputMessagesFilter, MyMessage } from \"../lib/appManagers/appMessagesManager\";\nimport appPeersManager from \"../lib/appManagers/appPeersManager\";\nimport appPhotosManager from \"../lib/appManagers/appPhotosManager\";\nimport appStateManager from \"../lib/appManagers/appStateManager\";\nimport appUsersManager from \"../lib/appManagers/appUsersManager\";\nimport { logger } from \"../lib/logger\";\nimport RichTextProcessor from \"../lib/richtextprocessor\";\nimport rootScope from \"../lib/rootScope\";\nimport AppMediaViewer from \"./appMediaViewer\";\nimport { SearchGroup, SearchGroupType } from \"./appSearch\";\nimport { horizontalMenu } from \"./horizontalMenu\";\nimport LazyLoadQueue from \"./lazyLoadQueue\";\nimport { putPreloader, formatPhoneNumber } from \"./misc\";\nimport { ripple } from \"./ripple\";\nimport Scrollable, { ScrollableX } from \"./scrollable\";\nimport { wrapDocument, wrapPhoto, wrapVideo } from \"./wrappers\";\nimport useHeavyAnimationCheck, { getHeavyAnimationPromise } from \"../hooks/useHeavyAnimationCheck\";\nimport { isSafari } from \"../helpers/userAgent\";\nimport { LangPackKey, i18n } from \"../lib/langPack\";\nimport findUpClassName from \"../helpers/dom/findUpClassName\";\nimport { getMiddleware } from \"../helpers/middleware\";\nimport appProfileManager from \"../lib/appManagers/appProfileManager\";\nimport { ChannelParticipant, ChatFull, ChatParticipant, ChatParticipants } from \"../layer\";\nimport SortedUserList from \"./sortedUserList\";\nimport findUpTag from \"../helpers/dom/findUpTag\";\nimport appSidebarRight from \"./sidebarRight\";\nimport mediaSizes from \"../helpers/mediaSizes\";\nimport appImManager from \"../lib/appManagers/appImManager\";\nimport positionElementByIndex from \"../helpers/dom/positionElementByIndex\";\nimport cleanSearchText from \"../helpers/cleanSearchText\";\n\n//const testScroll = false;\n\nexport type SearchSuperType = MyInputMessagesFilter/*  | 'members' */;\nexport type SearchSuperContext = {\n  peerId: number,\n  inputFilter: MyInputMessagesFilter,\n  query?: string,\n  maxId?: number,\n  folderId?: number,\n  threadId?: number,\n  date?: number,\n  nextRate?: number,\n  minDate?: number,\n  maxDate?: number\n};\n\nexport type SearchSuperMediaType = 'members' | 'media' | 'files' | 'links' | 'music' | 'chats' | 'voice';\nexport type SearchSuperMediaTab = {\n  inputFilter: SearchSuperType,\n  name: LangPackKey,\n  type: SearchSuperMediaType,\n  contentTab?: HTMLElement,\n  menuTab?: HTMLElement,\n  scroll?: {scrollTop: number, scrollHeight: number}\n};\n\nexport default class AppSearchSuper {\n  public tabs: {[t in SearchSuperType]: HTMLDivElement} = {} as any;\n\n  public mediaTab: SearchSuperMediaTab;\n\n  public container: HTMLElement;\n  public nav: HTMLElement;\n  private navScrollableContainer: HTMLDivElement;\n  private tabsContainer: HTMLElement;\n  private tabsMenu: HTMLElement;\n  private prevTabId = -1;\n  \n  private lazyLoadQueue = new LazyLoadQueue();\n  public middleware = getMiddleware();\n\n  public historyStorage: Partial<{[type in SearchSuperType]: {mid: number, peerId: number}[]}> = {};\n  public usedFromHistory: Partial<{[type in SearchSuperType]: number}> = {};\n  public urlsToRevoke: string[] = [];\n\n  private searchContext: SearchSuperContext;\n  public loadMutex: Promise<any> = Promise.resolve();\n\n  private nextRates: Partial<{[type in SearchSuperType]: number}> = {};\n  private loadPromises: Partial<{[type in SearchSuperType]: Promise<void>}> = {};\n  private loaded: Partial<{[type in SearchSuperType]: boolean}> = {};\n  private loadedChats = false;\n  private firstLoad = true;\n\n  private log = logger('SEARCH-SUPER');\n  public selectTab: ReturnType<typeof horizontalMenu>;\n  \n  private monthContainers: Partial<{\n    [type in SearchSuperType]: {\n      [timestamp: number]: {\n        container: HTMLElement,\n        items: HTMLElement\n      }\n    }\n  }> = {};\n\n  private searchGroupMedia: SearchGroup;\n\n  public mediaTabsMap: Map<SearchSuperMediaType, SearchSuperMediaTab> = new Map();\n\n  private membersList: SortedUserList;\n\n  private skipScroll: boolean;\n\n  // * arguments\n  public mediaTabs: SearchSuperMediaTab[];\n  public scrollable: Scrollable;\n  public searchGroups?: {[group in SearchGroupType]: SearchGroup};\n  public asChatList? = false;\n  public groupByMonth? = true;\n  public hideEmptyTabs? = true;\n  public onChangeTab?: (mediaTab: SearchSuperMediaTab) => void;\n  public showSender? = false;\n\n  constructor(options: Pick<AppSearchSuper, 'mediaTabs' | 'scrollable' | 'searchGroups' | 'asChatList' | 'groupByMonth' | 'hideEmptyTabs' | 'onChangeTab' | 'showSender'>) {\n    safeAssign(this, options);\n\n    this.container = document.createElement('div');\n    this.container.classList.add('search-super');\n\n    const navScrollableContainer = this.navScrollableContainer = document.createElement('div');\n    navScrollableContainer.classList.add('search-super-tabs-scrollable', 'menu-horizontal-scrollable', 'sticky');\n\n    const navScrollable = new ScrollableX(navScrollableContainer);\n\n    const nav = this.nav = document.createElement('nav');\n    nav.classList.add('search-super-tabs', 'menu-horizontal-div');\n    this.tabsMenu = nav;\n\n    navScrollable.container.append(nav);\n\n    for(const mediaTab of this.mediaTabs) {\n      const menuTab = document.createElement('div');\n      menuTab.classList.add('menu-horizontal-div-item');\n      const span = document.createElement('span');\n      const i = document.createElement('i');\n\n      span.append(i18n(mediaTab.name));\n      span.append(i);\n\n      menuTab.append(span);\n\n      ripple(menuTab);\n\n      this.tabsMenu.append(menuTab);\n\n      this.mediaTabsMap.set(mediaTab.type, mediaTab);\n\n      mediaTab.menuTab = menuTab;\n    }\n\n    this.tabsContainer = document.createElement('div');\n    this.tabsContainer.classList.add('search-super-tabs-container', 'tabs-container');\n\n    for(const mediaTab of this.mediaTabs) {\n      const container = document.createElement('div');\n      container.classList.add('search-super-container-' + mediaTab.type);\n\n      const content = document.createElement('div');\n      content.classList.add('search-super-content-' + mediaTab.type);\n\n      container.append(content);\n\n      this.tabsContainer.append(container);\n\n      this.tabs[mediaTab.inputFilter] = content;\n\n      mediaTab.contentTab = content;\n    }\n\n    this.container.append(navScrollableContainer, this.tabsContainer);\n\n    // * construct end\n\n    this.searchGroupMedia = new SearchGroup(false, 'messages', true);\n\n    this.scrollable.onScrolledBottom = () => {\n      if(this.mediaTab.contentTab && this.mediaTab.contentTab.childElementCount/* && false */) {\n        //this.log('onScrolledBottom will load media');\n        this.load(true);\n      }\n    };\n    //this.scroll.attachSentinels(undefined, 400);\n\n    this.selectTab = horizontalMenu(this.tabsMenu, this.tabsContainer, (id, tabContent, animate) => {\n      if(this.prevTabId === id && !this.skipScroll) {\n        this.scrollable.scrollIntoViewNew(this.container, 'start');\n        return;\n      }\n      \n      const newMediaTab = this.mediaTabs[id];\n      if(this.onChangeTab) {\n        this.onChangeTab(newMediaTab);\n      }\n      \n      const fromMediaTab = this.mediaTab;\n      this.mediaTab = newMediaTab;\n\n      if(this.prevTabId !== -1 && animate) {\n        this.onTransitionStart();\n      }\n\n      if(this.skipScroll) {\n        this.skipScroll = false;\n      } else {\n        const offsetTop = this.container.offsetTop;\n        let scrollTop = this.scrollable.scrollTop;\n        if(scrollTop < offsetTop) {\n          this.scrollable.scrollIntoViewNew(this.container, 'start');\n          scrollTop = offsetTop;\n        }\n        \n        fromMediaTab.scroll = {scrollTop: scrollTop, scrollHeight: this.scrollable.scrollHeight};\n  \n        if(newMediaTab.scroll === undefined) {\n          const rect = this.container.getBoundingClientRect();\n          const rect2 = this.container.parentElement.getBoundingClientRect();\n          const diff = rect.y - rect2.y;\n  \n          if(scrollTop > diff) {\n            newMediaTab.scroll = {scrollTop: diff, scrollHeight: 0};\n          }\n        }\n  \n        if(newMediaTab.scroll) {\n          const diff = fromMediaTab.scroll.scrollTop - newMediaTab.scroll.scrollTop;\n          //console.log('what you gonna do', this.goingHard, diff);\n  \n          //this.scrollable.scrollTop = scrollTop;\n          if(diff/*  && diff < 0 */) {\n            /* if(diff > -(fromMediaTab.contentTab.scrollHeight + this.nav.scrollHeight)) {\n              fromMediaTab.contentTab.style.transform = `translateY(${diff}px)`;\n              this.scrollable.scrollTop = scrollTop - diff;\n            } else { */\n              newMediaTab.contentTab.style.transform = `translateY(${diff}px)`;\n            //}\n          }\n        }\n      }\n      \n      /* if(this.prevTabId !== -1 && nav.offsetTop) {\n        this.scrollable.scrollTop -= nav.offsetTop;\n      } */\n\n      /* this.log('setVirtualContainer', id, this.sharedMediaSelected, this.sharedMediaSelected.childElementCount);\n      this.scroll.setVirtualContainer(this.sharedMediaSelected); */\n\n      if(this.prevTabId !== -1 && !newMediaTab.contentTab.childElementCount) { // quick brown fix\n        //this.contentContainer.classList.remove('loaded');\n        this.load(true);\n      }\n\n      this.prevTabId = id;\n    }, () => {\n      this.scrollable.onScroll();\n      \n      //console.log('what y', this.tabSelected.style.transform);\n      if(this.mediaTab.scroll !== undefined) {\n        this.mediaTab.contentTab.style.transform = '';\n        this.scrollable.scrollTop = this.mediaTab.scroll.scrollTop;\n      }\n\n      this.onTransitionEnd();\n    }, undefined, navScrollable);\n\n    this.tabs.inputMessagesFilterPhotoVideo.addEventListener('click', (e) => {\n      const target = findUpClassName(e.target as HTMLDivElement, 'grid-item');\n      \n      const mid = +target.dataset.mid;\n      if(!mid) {\n        this.log.warn('no messageId by click on target:', target);\n        return;\n      }\n\n      const peerId = +target.dataset.peerId;\n\n      const targets = (Array.from(this.tabs.inputMessagesFilterPhotoVideo.querySelectorAll('.grid-item')) as HTMLElement[]).map(el => {\n        return {element: el, mid: +el.dataset.mid, peerId: +el.dataset.peerId};\n      });\n\n      //const ids = Object.keys(this.mediaDivsByIds).map(k => +k).sort((a, b) => a - b);\n      const idx = targets.findIndex(item => item.mid === mid && item.peerId === peerId);\n      \n      const message = appMessagesManager.getMessageByPeer(peerId, mid);\n      new AppMediaViewer()\n      .setSearchContext(this.copySearchContext(this.mediaTab.inputFilter))\n      .openMedia(message, target, 0, false, targets.slice(0, idx), targets.slice(idx + 1));\n    });\n\n    this.mediaTab = this.mediaTabs[0];\n\n    useHeavyAnimationCheck(() => {\n      this.lazyLoadQueue.lock();\n    }, () => {\n      this.lazyLoadQueue.unlockAndRefresh(); // ! maybe not so efficient\n    });\n  }\n\n  private onTransitionStart = () => {\n    this.container.classList.add('sliding');\n  };\n\n  private onTransitionEnd = () => {\n    this.container.classList.remove('sliding');\n  };\n\n  public filterMessagesByType(messages: any[], type: SearchSuperType): MyMessage[] {\n    if(type === 'inputMessagesFilterEmpty') return messages;\n\n    if(type !== 'inputMessagesFilterUrl') {\n      messages = messages.filter(message => !!message.media);\n    }\n\n    /* if(!this.peerId) {\n      messages = messages.filter(message => {\n        if(message.peerId === rootScope.myId) {\n          return true;\n        }\n\n        const dialog = appMessagesManager.getDialogByPeerId(message.fromId)[0];\n        return dialog && dialog.folder_id === 0;\n      });\n    } */\n\n    let filtered: any[] = [];\n\n    switch(type) {\n      case 'inputMessagesFilterPhotoVideo': {\n        for(let message of messages) {\n          let media = message.media.photo || message.media.document || (message.media.webpage && message.media.webpage.document);\n          if(!media) {\n            //this.log('no media!', message);\n            continue;\n          }\n          \n          if(media._ === 'document' && media.type !== 'video'/*  && media.type !== 'gif' */) {\n            //this.log('broken video', media);\n            continue;\n          }\n\n          filtered.push(message);\n        }\n        \n        break;\n      }\n\n      case 'inputMessagesFilterDocument': {\n        for(let message of messages) {\n          if(!message.media.document || ['voice', 'audio', 'gif', 'sticker', 'round'].includes(message.media.document.type)) {\n            continue;\n          }\n          \n          filtered.push(message);\n        }\n        break;\n      }\n\n      case 'inputMessagesFilterUrl': {\n        //this.log('inputMessagesFilterUrl', messages);\n        for(let message of messages) {\n          //if((message.media.webpage && message.media.webpage._ !== 'webPageEmpty')) {\n            filtered.push(message);\n          //}\n        }\n        \n        break;\n      }\n\n      case 'inputMessagesFilterMusic': {\n        for(let message of messages) {\n          if(!message.media.document || message.media.document.type !== 'audio') {\n            continue;\n          }\n\n          filtered.push(message);\n        }\n\n        break;\n      }\n\n      case 'inputMessagesFilterVoice': {\n        for(let message of messages) {\n          if(!message.media.document || message.media.document.type !== 'voice') {\n            continue;\n          }\n\n          filtered.push(message);\n        }\n\n        break;\n      }\n\n      default:\n        break;\n    }\n\n    return filtered;\n  }\n  \n  public async performSearchResult(messages: any[], mediaTab: SearchSuperMediaTab, append = true) {\n    const elemsToAppend: {element: HTMLElement, message: any}[] = [];\n    const sharedMediaDiv: HTMLElement = mediaTab.contentTab;\n    const promises: Promise<any>[] = [];\n    const middleware = this.middleware.get();\n    let inputFilter = mediaTab.inputFilter;\n\n    await getHeavyAnimationPromise();\n    \n    let searchGroup: SearchGroup;\n    if(inputFilter === 'inputMessagesFilterPhotoVideo' && !!this.searchContext.query.trim()) {\n      inputFilter = 'inputMessagesFilterEmpty';\n      searchGroup = this.searchGroupMedia;\n      sharedMediaDiv.append(searchGroup.container);\n    } else if(inputFilter === 'inputMessagesFilterEmpty') {\n      searchGroup = this.searchGroups.messages;\n    }\n\n    // https://core.telegram.org/type/MessagesFilter\n    switch(inputFilter) {\n      case 'inputMessagesFilterEmpty': {\n        for(const message of messages) {\n          const {dialog, dom} = appDialogsManager.addDialogNew({\n            dialog: message.peerId, \n            container: searchGroup.list, \n            drawStatus: false,\n            avatarSize: 54\n          });\n          appDialogsManager.setLastMessage(dialog, message, dom, this.searchContext.query);\n        }\n\n        if(searchGroup.list.childElementCount) {\n          searchGroup.setActive();\n        }\n        break;\n      }\n\n      case 'inputMessagesFilterPhotoVideo': {\n        for(const message of messages) {\n          const media = message.media.photo || message.media.document || (message.media.webpage && message.media.webpage.document);\n\n          const div = document.createElement('div');\n          div.classList.add('grid-item');\n          //this.log(message, photo);\n\n          let wrapped: ReturnType<typeof wrapPhoto>;\n          const size = appPhotosManager.choosePhotoSize(media, 200, 200);\n          if(media._ !== 'photo') {\n            wrapped = wrapVideo({\n              doc: media,\n              message,\n              container: div,\n              boxWidth: 0,\n              boxHeight: 0,\n              lazyLoadQueue: this.lazyLoadQueue,\n              middleware,\n              onlyPreview: true,\n              withoutPreloader: true,\n              noPlayButton: true,\n              size\n            }).thumb;\n          } else {\n            wrapped = wrapPhoto({\n              photo: media,\n              message,\n              container: div,\n              boxWidth: 0,\n              boxHeight: 0,\n              lazyLoadQueue: this.lazyLoadQueue,\n              middleware,\n              withoutPreloader: true,\n              noBlur: true,\n              size\n            });\n          }\n\n          [wrapped.images.thumb, wrapped.images.full].filter(Boolean).forEach(image => {\n            image.classList.add('grid-item-media');\n          });\n\n          promises.push(wrapped.loadPromises.thumb);\n\n          elemsToAppend.push({element: div, message});\n        }\n        \n        break;\n      }\n      \n      case 'inputMessagesFilterVoice':\n      case 'inputMessagesFilterMusic':\n      case 'inputMessagesFilterDocument': {\n        for(const message of messages) {\n          const showSender = this.showSender || message.media.document.type === 'voice';\n          const div = wrapDocument({\n            message,\n            withTime: !showSender,\n            fontWeight: 400,\n            voiceAsMusic: true,\n            showSender: showSender,\n            searchContext: this.copySearchContext(inputFilter)\n          });\n\n          if(['audio', 'voice'].includes(message.media.document.type)) {\n            div.classList.add('audio-48');\n          }\n\n          elemsToAppend.push({element: div, message});\n        }\n        break;\n      }\n      \n      case 'inputMessagesFilterUrl': {\n        for(let message of messages) {\n          let webpage: any;\n\n          if(message.media?.webpage && message.media.webpage._ !== 'webPageEmpty') {\n            webpage = message.media.webpage;\n          } else {\n            const entity = message.totalEntities ? message.totalEntities.find((e: any) => e._ === 'messageEntityUrl' || e._ === 'messageEntityTextUrl') : null;\n            let url: string, display_url: string, sliced: string;\n\n            if(!entity) {\n              //this.log.error('NO ENTITY:', message);\n              const match = RichTextProcessor.matchUrl(message.message);\n              if(!match) {\n                //this.log.error('NO ENTITY AND NO MATCH:', message);\n                continue;\n              }\n\n              url = match[0];\n            } else {\n              sliced = message.message.slice(entity.offset, entity.offset + entity.length);\n            }\n\n            if(entity?._ === 'messageEntityTextUrl') {\n              url = entity.url;\n              //display_url = sliced;\n            } else {\n              url = url || sliced;\n            }\n\n            display_url = url;\n\n            const same = message.message === url;\n            if(!url.match(/^(ftp|http|https):\\/\\//)) {\n              display_url = 'https://' + url;\n              url = url.includes('@') ? url : 'https://' + url;\n            }\n\n            display_url = new URL(display_url).hostname;\n\n            webpage = {\n              url,\n              display_url\n            };\n\n            if(!same) {\n              webpage.description = message.message;\n              webpage.rDescription = RichTextProcessor.wrapRichText(limitSymbols(message.message, 150, 180));\n            }\n          }\n\n          let div = document.createElement('div');\n          \n          let previewDiv = document.createElement('div');\n          previewDiv.classList.add('preview');\n          \n          //this.log('wrapping webpage', webpage);\n          \n          if(webpage.photo) {\n            const res = wrapPhoto({\n              container: previewDiv,\n              message: null,\n              photo: webpage.photo,\n              boxWidth: 0,\n              boxHeight: 0,\n              withoutPreloader: true,\n              lazyLoadQueue: this.lazyLoadQueue,\n              middleware,\n              size: appPhotosManager.choosePhotoSize(webpage.photo, 60, 60, false),\n              loadPromises: promises,\n              noBlur: true\n            });\n          } else {\n            previewDiv.classList.add('empty');\n            previewDiv.innerHTML = RichTextProcessor.getAbbreviation(webpage.title || webpage.display_url || webpage.description || webpage.url, true);\n          }\n          \n          let title = webpage.rTitle || '';\n          let subtitle = webpage.rDescription || '';\n          let url = RichTextProcessor.wrapRichText(webpage.url || '');\n          \n          if(!title) {\n            //title = new URL(webpage.url).hostname;\n            title = RichTextProcessor.wrapPlainText(webpage.display_url.split('/', 1)[0]);\n          }\n\n          let sender = this.showSender ? `<div class=\"subtitle sender\">${appMessagesManager.getSenderToPeerText(message)}</div>` : '';\n\n          let titleAdditionHTML = '';\n          if(this.showSender) {\n            titleAdditionHTML = `<div class=\"sent-time\">${formatDateAccordingToToday(new Date(message.date * 1000))}</div>`;\n          }\n\n          div.append(previewDiv);\n          div.insertAdjacentHTML('beforeend', `\n          <div class=\"title\">${title}${titleAdditionHTML}</div>\n          <div class=\"subtitle\">${subtitle}</div>\n          <div class=\"url\">${url}</div>\n          ${sender}\n          `);\n          \n          if(div.innerText.trim().length) {\n            elemsToAppend.push({element: div, message});\n          }\n          \n        }\n        \n        break;\n      }\n\n      default:\n        //this.log.warn('death is my friend', messages);\n        break;\n    }\n\n    if(this.loadMutex) {\n      promises.push(this.loadMutex);\n    }\n\n    if(promises.length) {\n      await Promise.all(promises);\n      if(!middleware()) {\n        //this.log.warn('peer changed');\n        return;\n      }\n    }\n    \n    if(elemsToAppend.length) {\n      const method = append ? 'append' : 'prepend';\n      elemsToAppend.forEach(details => {\n        const {element, message} = details;\n        const monthContainer = this.getMonthContainerByTimestamp(this.groupByMonth ? message.date : 0, inputFilter);\n        element.classList.add('search-super-item');\n        element.dataset.mid = '' + message.mid;\n        element.dataset.peerId = '' + message.peerId;\n        monthContainer.items[method](element);\n      });\n    }\n    \n    //if(type !== 'inputMessagesFilterEmpty') {\n      this.afterPerforming(inputFilter === 'inputMessagesFilterEmpty' ? 1 : messages.length, sharedMediaDiv);\n    //}\n  }\n\n  private afterPerforming(length: number, contentTab: HTMLElement) {\n    if(contentTab) {\n      const parent = contentTab.parentElement;\n      Array.from(parent.children).slice(1).forEach(child => {\n        child.remove();\n      });\n\n      //this.contentContainer.classList.add('loaded');\n\n      if(!length && !contentTab.childElementCount) {\n        const div = document.createElement('div');\n        div.innerText = 'Nothing interesting here yet...';\n        div.classList.add('position-center', 'text-center', 'content-empty', 'no-select');\n\n        parent.append(div);\n      }\n    }\n  }\n\n  private loadChats() {\n    const renderedPeerIds: Set<number> = new Set();\n    const middleware = this.middleware.get();\n\n    for(let i in this.searchGroups) {\n      const group = this.searchGroups[i as SearchGroupType];\n      this.tabs.inputMessagesFilterEmpty.append(group.container);\n      group.clear();\n    }\n\n    const query = this.searchContext.query;\n    if(query) {\n      const setResults = (results: number[], group: SearchGroup, showMembersCount = false) => {\n        results.forEach((peerId) => {\n          if(renderedPeerIds.has(peerId)) {\n            return;\n          }\n  \n          renderedPeerIds.add(peerId);\n  \n          const peer = appPeersManager.getPeer(peerId);\n  \n          //////////this.log('contacts peer', peer);\n  \n          const {dom} = appDialogsManager.addDialogNew({\n            dialog: peerId, \n            container: group.list, \n            drawStatus: false,\n            avatarSize: 48,\n            autonomous: group.autonomous\n          });\n  \n          if(showMembersCount && (peer.participants_count || peer.participants)) {\n            const regExp = new RegExp(`(${escapeRegExp(query)}|${escapeRegExp(cleanSearchText(query))})`, 'gi');\n            dom.titleSpan.innerHTML = dom.titleSpan.innerHTML.replace(regExp, '<i>$1</i>');\n            dom.lastMessageSpan.append(appProfileManager.getChatMembersString(-peerId));\n          } else if(peerId === rootScope.myId) {\n            dom.lastMessageSpan.append(i18n('Presence.YourChat'));\n          } else {\n            let username = appPeersManager.getPeerUsername(peerId);\n            if(!username) {\n              const user = appUsersManager.getUser(peerId);\n              if(user && user.phone) {\n                username = '+' + formatPhoneNumber(user.phone).formatted;\n              }\n            } else {\n              username = '@' + username;\n            }\n  \n            dom.lastMessageSpan.innerHTML = '<i>' + username + '</i>';\n          }\n        });\n  \n        group.toggle();\n      };\n  \n      const onLoad = <T>(arg: T) => {\n        if(!middleware()) {\n          return;\n        }\n  \n        //this.loadedContacts = true;\n  \n        return arg;\n      };\n  \n      return Promise.all([\n        appUsersManager.getContacts(query, true)\n        .then(onLoad)\n        .then((contacts) => {\n          if(contacts) {\n            setResults(contacts, this.searchGroups.contacts, true);\n          }\n        }),\n  \n        appUsersManager.searchContacts(query, 20)\n        .then(onLoad)\n        .then((contacts) => {\n          if(contacts) {\n            setResults(contacts.my_results, this.searchGroups.contacts, true);\n            setResults(contacts.results/* .concat(contacts.results, contacts.results, contacts.results) */, this.searchGroups.globalContacts);\n\n            if(this.searchGroups.globalContacts.nameEl.lastElementChild) {\n              this.searchGroups.globalContacts.nameEl.lastElementChild.remove();\n            }\n\n            this.searchGroups.globalContacts.container.classList.add('is-short');\n            \n            if(this.searchGroups.globalContacts.list.childElementCount > 3) {\n              const showMore = document.createElement('div');\n              showMore.classList.add('search-group__show-more');\n              showMore.innerText = 'Show more';\n              this.searchGroups.globalContacts.nameEl.append(showMore);\n              showMore.addEventListener('click', () => {\n                const isShort = this.searchGroups.globalContacts.container.classList.toggle('is-short');\n                showMore.innerText = isShort ? 'Show more' : 'Show less';\n              });\n            }\n          }\n        }),\n  \n        appMessagesManager.getConversations(query, 0, 20, 0)\n        .then(onLoad)\n        .then(value => {\n          if(value) {\n            setResults(value.dialogs.map(d => d.peerId), this.searchGroups.contacts, true);\n          }\n        })\n      ]);\n    } else if(!this.searchContext.peerId && !this.searchContext.minDate) {\n      const renderRecentSearch = (setActive = true) => {\n        return appStateManager.getState().then(state => {\n          if(!middleware()) {\n            return;\n          }\n    \n          this.searchGroups.recent.list.innerHTML = '';\n    \n          state.recentSearch.slice(0, 20).forEach(peerId => {\n            let {dialog, dom} = appDialogsManager.addDialogNew({\n              dialog: peerId,\n              container: this.searchGroups.recent.list,\n              drawStatus: false,\n              meAsSaved: true,\n              avatarSize: 48,\n              autonomous: true\n            });\n    \n            dom.lastMessageSpan.append(peerId > 0 ? appUsersManager.getUserStatusString(peerId) : appProfileManager.getChatMembersString(-peerId));\n          });\n    \n          if(!state.recentSearch.length) {\n            this.searchGroups.recent.clear();\n          } else if(setActive) {\n            this.searchGroups.recent.setActive();\n          }\n        });\n      };\n\n      return Promise.all([\n        appUsersManager.getTopPeers().then(peers => {\n          if(!middleware()) return;\n\n          const idx = peers.indexOf(rootScope.myId);\n          if(idx !== -1) {\n            peers = peers.slice();\n            peers.splice(idx, 1);\n          }\n          //console.log('got top categories:', categories);\n          if(peers.length) {\n            peers.forEach((peerId) => {\n              appDialogsManager.addDialogNew({\n                dialog: peerId, \n                container: this.searchGroups.people.list, \n                drawStatus: false,\n                onlyFirstName: true,\n                avatarSize: 54,\n                autonomous: false\n              });\n            });\n          }\n    \n          this.searchGroups.people.setActive();\n        }),\n\n        renderRecentSearch()\n      ]);\n    } else return Promise.resolve();\n  }\n\n  private loadMembers(mediaTab: SearchSuperMediaTab) {\n    const id = -this.searchContext.peerId;\n    const middleware = this.middleware.get();\n    let promise: Promise<void>;\n\n    const renderParticipants = async(participants: (ChatParticipant | ChannelParticipant)[]) => {\n      if(this.loadMutex) {\n        await this.loadMutex;\n\n        if(!middleware()) {\n          return;\n        }\n      }\n      \n      if(!this.membersList) {\n        this.membersList = new SortedUserList({lazyLoadQueue: this.lazyLoadQueue, rippleEnabled: false});\n        this.membersList.list.addEventListener('click', (e) => {\n          const li = findUpTag(e.target, 'LI');\n          if(!li) {\n            return;\n          }\n\n          const peerId = +li.dataset.peerId;\n          let promise: Promise<any> = Promise.resolve();\n          if(mediaSizes.isMobile) {\n            promise = appSidebarRight.toggleSidebar(false);\n          }\n          \n          promise.then(() => {\n            appImManager.setInnerPeer(peerId);\n          });\n        });\n        mediaTab.contentTab.append(this.membersList.list);\n        this.afterPerforming(1, mediaTab.contentTab);\n      }\n\n      participants.forEach(participant => {\n        const peerId = appChatsManager.getParticipantPeerId(participant);\n        if(peerId < 0) {\n          return;\n        }\n\n        const user = appUsersManager.getUser(peerId);\n        if(user.pFlags.deleted) {\n          return;\n        }\n\n        this.membersList.add(peerId);\n      });\n    };\n\n    if(appChatsManager.isChannel(id)) {\n      const LOAD_COUNT = !this.membersList ? 50 : 200;\n      promise = appProfileManager.getChannelParticipants(id, undefined, LOAD_COUNT, this.nextRates[mediaTab.inputFilter]).then(participants => {\n        if(!middleware()) {\n          return;\n        }\n\n        let list = mediaTab.contentTab.firstElementChild as HTMLUListElement;\n        this.nextRates[mediaTab.inputFilter] = (list ? list.childElementCount : 0) + participants.participants.length;\n\n        if(participants.participants.length < LOAD_COUNT) {\n          this.loaded[mediaTab.inputFilter] = true;\n        }\n\n        return renderParticipants(participants.participants);\n      });\n    } else {\n      promise = (appProfileManager.getChatFull(id) as Promise<ChatFull.chatFull>).then(chatFull => {\n        if(!middleware()) {\n          return;\n        }\n\n        //console.log('anymore', chatFull);\n        this.loaded[mediaTab.inputFilter] = true;\n        const participants = chatFull.participants;\n        if(participants._ === 'chatParticipantsForbidden') {\n          return;\n        }\n        \n        return renderParticipants(participants.participants);\n      });\n    }\n\n    return this.loadPromises[mediaTab.inputFilter] = promise.finally(() => { \n      if(!middleware()) {\n        return;\n      }\n\n      this.loadPromises[mediaTab.inputFilter] = null;\n    });\n  }\n\n  private loadType(mediaTab: SearchSuperMediaTab, justLoad: boolean, loadCount: number, middleware: () => boolean) {\n    const type = mediaTab.inputFilter;\n\n    if(this.loadPromises[type]) {\n      return this.loadPromises[type];\n    }\n\n    if(mediaTab.type === 'members') {\n      return this.loadMembers(mediaTab);\n    }\n\n    const history = this.historyStorage[type] ?? (this.historyStorage[type] = []);\n\n    if(type === 'inputMessagesFilterEmpty' && !history.length) {\n      if(!this.loadedChats) {\n        this.loadChats();\n        this.loadedChats = true;\n      }\n\n      if(!this.searchContext.query.trim() && !this.searchContext.peerId && !this.searchContext.minDate) {\n        this.loaded[type] = true;\n        return Promise.resolve();\n      }\n    }\n\n    const logStr = 'load [' + type + ']: ';\n\n    // render from cache\n    if(history.length && this.usedFromHistory[type] < history.length && !justLoad) {\n      let messages: any[] = [];\n      let used = Math.max(0, this.usedFromHistory[type]);\n      let slicedLength = 0;\n\n      do {\n        let ids = history.slice(used, used + loadCount);\n        //this.log(logStr + 'will render from cache', used, history, ids, loadCount);\n        used += ids.length;\n        slicedLength += ids.length;\n\n        messages.push(...this.filterMessagesByType(ids.map(m => appMessagesManager.getMessageByPeer(m.peerId, m.mid)), type));\n      } while(slicedLength < loadCount && used < history.length);\n      \n      // \u0435\u0441\u043b\u0438 \u043f\u0435\u0440\u0435\u0431\u043e\u0440\n      /* if(slicedLength > loadCount) {\n        let diff = messages.length - loadCount;\n        messages = messages.slice(0, messages.length - diff);\n        used -= diff;\n      } */\n\n      this.usedFromHistory[type] = used;\n      //if(messages.length) {\n        return this.performSearchResult(messages, mediaTab).finally(() => {\n          setTimeout(() => {\n            this.scrollable.checkForTriggers();\n          }, 0);\n        });\n      //}\n\n      return Promise.resolve();\n    }\n    \n    let maxId = history.length ? history[history.length - 1].mid : 0;\n    \n    //this.log(logStr + 'search house of glass pre', type, maxId);\n    \n    //let loadCount = history.length ? 50 : 15;\n    return this.loadPromises[type] = appMessagesManager.getSearch({\n      peerId: this.searchContext.peerId, \n      query: this.searchContext.query,\n      inputFilter: {_: type},\n      maxId, \n      limit: loadCount,\n      nextRate: this.nextRates[type] ?? (this.nextRates[type] = 0),\n      threadId: this.searchContext.threadId,\n      folderId: this.searchContext.folderId,\n      minDate: this.searchContext.minDate,\n      maxDate: this.searchContext.maxDate\n    }).then(value => {\n      history.push(...value.history.map(m => ({mid: m.mid, peerId: m.peerId})));\n      \n      this.log(logStr + 'search house of glass', type, value);\n\n      if(!middleware()) {\n        //this.log.warn('peer changed');\n        return;\n      }\n\n      // ! \u0424\u0438\u043a\u0441 \u0441\u043b\u0443\u0447\u0430\u044f, \u043a\u043e\u0433\u0434\u0430 \u043d\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u044e\u0442\u0441\u044f \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u044b \u043f\u0440\u0438 \u043e\u0442\u043a\u0440\u044b\u0442\u043e\u0439 \u043f\u0430\u043d\u0435\u043b\u0438 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u0432 (\u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0438\u0437-\u0437\u0430 \u0442\u043e\u0433\u043e, \u0447\u0442\u043e \u043d\u0435 \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u044e\u0442 \u043a\u0440\u0438\u0442\u0435\u0440\u0438\u0438 \u043e\u0442\u0431\u043e\u0440\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u0432 getSearch)\n      if(value.history.length < loadCount) {\n      //if((value.count || history.length === value.count) && history.length >= value.count) {\n        //this.log(logStr + 'loaded all media', value, loadCount);\n        this.loaded[type] = true;\n      }\n\n      this.nextRates[type] = value.next_rate;\n\n      if(justLoad) {\n        return Promise.resolve();\n      }\n\n      this.usedFromHistory[type] = history.length;\n\n      if(!this.loaded[type]) {\n        (this.loadPromises[type] || Promise.resolve()).then(() => {\n          setTimeout(() => {\n            if(!middleware()) return;\n            //this.log('will preload more');\n            if(this.mediaTab === mediaTab) {\n              const promise = this.load(true, true);\n              if(promise) {\n                promise.then(() => {\n                  if(!middleware()) return;\n                  //this.log('preloaded more');\n                  setTimeout(() => {\n                    this.scrollable.checkForTriggers();\n                  }, 0);\n                });\n              }\n            }\n          }, 0);\n        });\n      }\n\n      //if(value.history.length) {\n        return this.performSearchResult(this.filterMessagesByType(value.history, type), mediaTab);\n      //}\n    }).catch(err => {\n      this.log.error('load error:', err);\n    }).finally(() => {\n      this.loadPromises[type] = null;\n    });\n  }\n  \n  public async load(single = false, justLoad = false) {\n    // if(testScroll/*  || 1 === 1 */) {\n    //   return;\n    // }\n\n    //return;\n    \n    const peerId = this.searchContext.peerId;\n    this.log('load', single, peerId, this.loadPromises);\n    const middleware = this.middleware.get();\n\n    if(this.firstLoad) {\n      if(this.hideEmptyTabs) {\n        const mediaTabs = this.mediaTabs.filter(mediaTab => mediaTab.inputFilter !== 'inputMessagesFilterEmpty')\n        const filters = mediaTabs.map(mediaTab => ({_: mediaTab.inputFilter}));\n\n        const counters = await appMessagesManager.getSearchCounters(peerId, filters);\n        if(!middleware()) {\n          return;\n        }\n\n        if(this.loadMutex) {\n          await this.loadMutex;\n\n          if(!middleware()) {\n            return;\n          }\n        }\n\n        let firstMediaTab: SearchSuperMediaTab;\n        let count = 0;\n        mediaTabs.forEach(mediaTab => {\n          const counter = counters.find(c => c.filter._ === mediaTab.inputFilter);\n\n          mediaTab.menuTab.classList.toggle('hide', !counter.count);\n          mediaTab.menuTab.classList.remove('active');\n          //mediaTab.contentTab.classList.toggle('hide', !counter.count);\n\n          if(counter.count && firstMediaTab === undefined) {\n            firstMediaTab = mediaTab;\n          }\n\n          if(counter.count) ++count;\n        });\n\n        const membersTab = this.mediaTabsMap.get('members');\n        const canViewMembers = this.canViewMembers();\n        membersTab.menuTab.classList.toggle('hide', !canViewMembers);\n\n        if(canViewMembers) {\n          firstMediaTab = membersTab;\n        }\n\n        this.container.classList.toggle('hide', !firstMediaTab);\n        this.container.parentElement.classList.toggle('search-empty', !firstMediaTab);\n        if(firstMediaTab) {\n          this.skipScroll = true;\n          this.selectTab(this.mediaTabs.indexOf(firstMediaTab), false);\n          firstMediaTab.menuTab.classList.add('active');\n\n          this.navScrollableContainer.classList.toggle('hide', count <= 1);\n        }\n      }\n\n      this.firstLoad = false;\n    }\n    \n    let toLoad = single ? [this.mediaTab] : this.mediaTabs.filter(t => t !== this.mediaTab);\n    toLoad = toLoad.filter(mediaTab => {\n      const inputFilter = mediaTab.inputFilter;\n      return !this.loaded[inputFilter] || (this.historyStorage[inputFilter] && this.usedFromHistory[inputFilter] < this.historyStorage[inputFilter].length);\n    });\n\n    if(peerId > 0) {\n      toLoad.findAndSplice(mediaTab => mediaTab.type === 'members');\n    }\n\n    if(!toLoad.length) {\n      return;\n    }\n\n    const loadCount = justLoad ? 50 : Math.round((appPhotosManager.windowH / 130 | 0) * 3 * 1.25); // that's good for all types\n\n    const promises: Promise<any>[] = toLoad.map(mediaTab => {\n      return this.loadType(mediaTab, justLoad, loadCount, middleware)\n    });\n\n    return Promise.all(promises).catch(err => {\n      this.log.error('Load error all promises:', err);\n    });\n  }\n  \n  public getMonthContainerByTimestamp(timestamp: number, type: SearchSuperType) {\n    const date = new Date(timestamp * 1000);\n    date.setHours(0, 0, 0);\n    date.setDate(1);\n    const dateTimestamp = date.getTime();\n    const containers = this.monthContainers[type] ?? (this.monthContainers[type] = {});\n    if(!(dateTimestamp in containers)) {\n      const str = months[date.getMonth()] + ' ' + date.getFullYear();\n      \n      const container = document.createElement('div');\n      container.className = 'search-super-month';\n\n      const name = document.createElement('div');\n      name.classList.add('search-super-month-name');\n      name.innerText = str;\n      container.append(name);\n\n      const items = document.createElement('div');\n      items.classList.add('search-super-month-items');\n\n      container.append(name, items);\n\n      const haveTimestamps = getObjectKeysAndSort(containers, 'desc');\n      let i = 0;\n      for(; i < haveTimestamps.length; ++i) {\n        const t = haveTimestamps[i];\n        if(dateTimestamp > t) {\n          break;\n        }\n      }\n      \n      containers[dateTimestamp] = {container, items};\n      positionElementByIndex(container, this.tabs[type], i);\n    }\n\n    return containers[dateTimestamp];\n  }\n\n  public canViewMembers() {\n    return this.searchContext.peerId < 0 && !appChatsManager.isBroadcast(-this.searchContext.peerId) && appChatsManager.hasRights(-this.searchContext.peerId, 'view_participants');\n  }\n\n  public cleanup() {\n    this.loadPromises = {};\n    this.loaded = {};\n    this.loadedChats = false;\n    this.nextRates = {};\n    this.firstLoad = true;\n\n    this.lazyLoadQueue.clear();\n\n    this.mediaTabs.forEach(mediaTab => {\n      this.usedFromHistory[mediaTab.inputFilter] = -1;\n    });\n\n    // * must go to first tab (\u044d\u0442\u043e \u043a\u043e\u0441\u0442\u044b\u043b\u044c)\n    /* const membersTab = this.mediaTabsMap.get('members');\n    if(membersTab) {\n      const tab = this.canViewMembers() ? membersTab : this.mediaTabs[this.mediaTabs.indexOf(membersTab) + 1];\n      this.mediaTab = tab;\n    } */\n\n    this.middleware.clean();\n    this.cleanScrollPositions();\n    this.membersList = undefined;\n  }\n\n  public cleanScrollPositions() {\n    this.mediaTabs.forEach(mediaTab => {\n      mediaTab.scroll = undefined;\n    });\n  }\n\n  public cleanupHTML(goFirst = false) {\n    if(this.urlsToRevoke.length) {\n      this.urlsToRevoke.forEach(url => {\n        URL.revokeObjectURL(url);\n      });\n      this.urlsToRevoke.length = 0;\n    }\n\n    this.mediaTabs.forEach((tab) => {\n      tab.contentTab.innerHTML = '';\n\n      if(this.hideEmptyTabs) {\n        //tab.menuTab.classList.add('hide');\n        this.container.classList.add('hide');\n        this.container.parentElement.classList.add('search-empty');\n      }\n\n      if(tab.type === 'chats') {\n        return;\n      }\n      \n      if(!this.historyStorage[tab.inputFilter]) {\n        const parent = tab.contentTab.parentElement;\n        //if(!testScroll) {\n          if(!parent.querySelector('.preloader')) {\n            putPreloader(parent, true);\n          }\n        //}\n\n        const empty = parent.querySelector('.content-empty');\n        if(empty) {\n          empty.remove();\n        }\n      }\n    });\n\n    /* if(goFirst) {\n      const membersTab = this.mediaTabsMap.get('members');\n      if(membersTab) {\n        let idx = this.canViewMembers() ? 0 : 1;\n        membersTab.menuTab.classList.toggle('hide', idx !== 0);\n\n        this.selectTab(idx, false);\n      } else {\n        this.selectTab(0, false);\n      }\n    } */\n\n    this.monthContainers = {};\n    this.searchGroupMedia.clear();\n    this.scrollable.scrollTop = 0;\n\n    /* if(testScroll) {\n      for(let i = 0; i < 1500; ++i) {\n        let div = document.createElement('div');\n        div.insertAdjacentHTML('beforeend', `<img class=\"media-image\" src=\"assets/img/camomile.jpg\">`);\n        div.classList.add('grid-item');\n        div.dataset.id = '' + (i / 3 | 0);\n        //div.innerText = '' + (i / 3 | 0);\n        this.tabs.inputMessagesFilterPhotoVideo.append(div);\n      }\n    } */\n  }\n\n  private copySearchContext(newInputFilter: MyInputMessagesFilter) {\n    const context = copy(this.searchContext);\n    context.inputFilter = newInputFilter;\n    context.nextRate = this.nextRates[newInputFilter];\n    return context;\n  }\n\n  public setQuery({peerId, query, threadId, historyStorage, folderId, minDate, maxDate}: {\n    peerId: number, \n    query?: string, \n    threadId?: number, \n    historyStorage?: AppSearchSuper['historyStorage'], \n    folderId?: number,\n    minDate?: number,\n    maxDate?: number\n  }) {\n    this.searchContext = {\n      peerId: peerId || 0,\n      query: query || '',\n      inputFilter: this.mediaTab.inputFilter,\n      threadId,\n      folderId,\n      minDate,\n      maxDate\n    };\n    \n    this.historyStorage = historyStorage ?? {};\n\n    this.cleanup();\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport appDocsManager, {MyDocument} from \"../lib/appManagers/appDocsManager\";\nimport { RichTextProcessor } from \"../lib/richtextprocessor\";\nimport { formatDate } from \"./wrappers\";\nimport ProgressivePreloader from \"./preloader\";\nimport { MediaProgressLine } from \"../lib/mediaPlayer\";\nimport appMediaPlaybackController from \"./appMediaPlaybackController\";\nimport { DocumentAttribute } from \"../layer\";\nimport mediaSizes from \"../helpers/mediaSizes\";\nimport { isSafari } from \"../helpers/userAgent\";\nimport appMessagesManager from \"../lib/appManagers/appMessagesManager\";\nimport rootScope from \"../lib/rootScope\";\nimport './middleEllipsis';\nimport { SearchSuperContext } from \"./appSearchSuper.\";\nimport { formatDateAccordingToToday } from \"../helpers/date\";\nimport { cancelEvent } from \"../helpers/dom/cancelEvent\";\nimport { attachClickEvent, detachClickEvent } from \"../helpers/dom/clickEvent\";\n\nrootScope.addEventListener('messages_media_read', e => {\n  const {mids, peerId} = e;\n\n  mids.forEach(mid => {\n    (Array.from(document.querySelectorAll('audio-element[message-id=\"' + mid + '\"][peer-id=\"' + peerId + '\"]')) as AudioElement[]).forEach(elem => {\n      //console.log('updating avatar:', elem);\n      elem.classList.remove('is-unread');\n    });\n  });\n});\n\n// https://github.com/LonamiWebs/Telethon/blob/4393ec0b83d511b6a20d8a20334138730f084375/telethon/utils.py#L1285\nexport function decodeWaveform(waveform: Uint8Array | number[]) {\n  if(!(waveform instanceof Uint8Array)) {\n    waveform = new Uint8Array(waveform);\n  }\n\n  const bitCount = waveform.length * 8;\n  const valueCount = bitCount / 5 | 0;\n  if(!valueCount) {\n    return new Uint8Array([]);\n  }\n\n  let result: Uint8Array;\n  try {\n    const dataView = new DataView(waveform.buffer);\n    result = new Uint8Array(valueCount);\n    for(let i = 0; i < valueCount; i++) {\n      const byteIndex = i * 5 / 8 | 0;\n      const bitShift = i * 5 % 8;\n      const value = dataView.getUint16(byteIndex, true);\n      result[i] = (value >> bitShift) & 0b00011111;\n    }\n  } catch(err) {\n    result = new Uint8Array([]);\n  }\n\n  /* var byteIndex = (valueCount - 1) / 8 | 0;\n  var bitShift = (valueCount - 1) % 8;\n  if(byteIndex === waveform.length - 1) {\n    var value = waveform[byteIndex];\n  } else {\n    var value = dataView.getUint16(byteIndex, true);\n  }\n  console.log('decoded waveform, setting last value:', value, byteIndex, bitShift);\n  result[valueCount - 1] = (value >> bitShift) & 0b00011111; */\n  return result;\n}\n\nfunction wrapVoiceMessage(audioEl: AudioElement) {\n  audioEl.classList.add('is-voice');\n\n  const message = audioEl.message;\n  const doc = (message.media.document || message.media.webpage.document) as MyDocument;\n  const isOut = message.fromId === rootScope.myId && message.peerId !== rootScope.myId;\n  let isUnread = message && message.pFlags.media_unread;\n  if(isUnread) {\n    audioEl.classList.add('is-unread');\n  }\n\n  if(message.pFlags.out) {\n    audioEl.classList.add('is-out');\n  }\n\n  const barWidth = 2;\n  const barMargin = 2;      //mediaSizes.isMobile ? 2 : 1;\n  const barHeightMin = 4;   //mediaSizes.isMobile ? 3 : 2;\n  const barHeightMax = mediaSizes.isMobile ? 16 : 23;\n  const availW = 150;       //mediaSizes.isMobile ? 152 : 190;\n\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  svg.classList.add('audio-waveform');\n  svg.setAttributeNS(null, 'width', '' + availW);\n  svg.setAttributeNS(null, 'height', '' + barHeightMax);\n  svg.setAttributeNS(null, 'viewBox', `0 0 ${availW} ${barHeightMax}`);\n\n  const timeDiv = document.createElement('div');\n  timeDiv.classList.add('audio-time');\n  audioEl.append(svg, timeDiv);\n\n  let waveform = (doc.attributes.find(attribute => attribute._ === 'documentAttributeAudio') as DocumentAttribute.documentAttributeAudio).waveform || new Uint8Array([]);\n  waveform = decodeWaveform(waveform.slice(0, 63));\n\n  //console.log('decoded waveform:', waveform);\n\n  const normValue = Math.max(...waveform);\n  const wfSize = waveform.length ? waveform.length : 100;\n  const barCount = Math.min((availW / (barWidth + barMargin)) | 0, wfSize);\n\n  let maxValue = 0;\n  const maxDelta = barHeightMax - barHeightMin;\n\n  let html = '';\n  for(let i = 0, barX = 0, sumI = 0; i < wfSize; ++i) {\n    const value = waveform[i] || 0;\n    if((sumI + barCount) >= wfSize) { // draw bar\n      sumI = sumI + barCount - wfSize;\n\t\t\tif(sumI < (barCount + 1) / 2) {\n\t\t\t\tif(maxValue < value) maxValue = value;\n      }\n      \n      const bar_value = Math.max(((maxValue * maxDelta) + ((normValue + 1) / 2)) / (normValue + 1), barHeightMin);\n      \n      const h = `\n      <rect x=\"${barX}\" y=\"${barHeightMax - bar_value}\" width=\"${barWidth}\" height=\"${bar_value}\" rx=\"1\" ry=\"1\"></rect>\n      `;\n      html += h;\n\n      barX += barWidth + barMargin;\n\n      if(sumI < (barCount + 1) / 2) {\n        maxValue = 0;\n      } else {\n        maxValue = value;\n      }\n    } else {\n      if(maxValue < value) maxValue = value;\n\n      sumI += barCount;\n    }\n  }\n\n  svg.insertAdjacentHTML('beforeend', html);\n  const rects = Array.from(svg.children) as HTMLElement[];\n\n  let progress = audioEl.querySelector('.audio-waveform') as HTMLDivElement;\n  \n  const onLoad = () => {\n    let interval = 0;\n    let lastIndex = 0;\n\n    let audio = audioEl.audio;\n\n    if(!audio.paused || (audio.currentTime > 0 && audio.currentTime !== audio.duration)) {\n      lastIndex = Math.round(audio.currentTime / audio.duration * barCount);\n      rects.slice(0, lastIndex + 1).forEach(node => node.classList.add('active'));\n    }\n\n    let start = () => {\n      clearInterval(interval);\n      interval = window.setInterval(() => {\n        if(lastIndex > svg.childElementCount || isNaN(audio.duration) || audio.paused) {\n          clearInterval(interval);\n          return;\n        }\n\n        lastIndex = Math.round(audio.currentTime / audio.duration * barCount);\n        \n        //svg.children[lastIndex].setAttributeNS(null, 'fill', '#000');\n        //svg.children[lastIndex].classList.add('active'); #\u0418\u043d\u043e\u0433\u0434\u0430 \u043f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u0442 \u043f\u043e\u043b\u043e\u0441\u043a\u0438..\n        rects.slice(0, lastIndex + 1).forEach(node => node.classList.add('active'));\n        //++lastIndex;\n        //console.log('lastIndex:', lastIndex, audio.currentTime);\n        //}, duration * 1000 / svg.childElementCount | 0/* 63 * duration / 10 */);\n      }, 20);\n    };\n\n    if(!audio.paused) {\n      start();\n    }\n\n    audioEl.addAudioListener('playing', () => {\n      if(isUnread && !isOut && audioEl.classList.contains('is-unread')) {\n        audioEl.classList.remove('is-unread');\n        appMessagesManager.readMessages(audioEl.message.peerId, [audioEl.message.mid]);\n        isUnread = false;\n      }\n\n      //rects.forEach(node => node.classList.remove('active'));\n      start();\n    });\n\n    audioEl.addAudioListener('pause', () => {\n      clearInterval(interval);\n    });\n    \n    audioEl.addAudioListener('ended', () => {\n      clearInterval(interval);\n      rects.forEach(node => node.classList.remove('active'));\n    });\n    \n    let mousedown = false, mousemove = false;\n    progress.addEventListener('mouseleave', (e) => {\n      if(mousedown) {\n        audio.play();\n        mousedown = false;\n      }\n      mousemove = false;\n    })\n    progress.addEventListener('mousemove', (e) => {\n      mousemove = true;\n      if(mousedown) scrub(e);\n    });\n    progress.addEventListener('mousedown', (e) => {\n      e.preventDefault();\n      if(!audio.paused) {\n        audio.pause();\n      }\n      \n      scrub(e);\n      mousedown = true;\n    });\n    progress.addEventListener('mouseup', (e) => {\n      if (mousemove && mousedown) {\n        audio.play();\n        mousedown = false;\n      }\n    });\n    attachClickEvent(progress, (e) => {\n      cancelEvent(e);\n      if(!audio.paused) scrub(e);\n    });\n    \n    function scrub(e: MouseEvent | TouchEvent) {\n      let offsetX: number;\n      if(e instanceof MouseEvent) {\n        offsetX = e.offsetX;\n      } else { // touch\n        const rect = (e.target as HTMLElement).getBoundingClientRect();\n        offsetX = e.targetTouches[0].pageX - rect.left;\n      }\n      \n      const scrubTime = offsetX / availW /* width */ * audio.duration;\n      lastIndex = Math.round(scrubTime / audio.duration * barCount);\n      \n      rects.slice(0, lastIndex + 1).forEach(node => node.classList.add('active'));\n      for(let i = lastIndex + 1; i < rects.length; ++i) {\n        rects[i].classList.remove('active')\n      }\n      audio.currentTime = scrubTime;\n    }\n    \n    return () => {\n      clearInterval(interval);\n      progress.remove();\n      progress = null;\n      audio = null;\n    };\n  };\n\n  return onLoad;\n}\n\nfunction wrapAudio(audioEl: AudioElement) {\n  const withTime = audioEl.withTime;\n\n  const message = audioEl.message;\n  const doc: MyDocument = message.media.document || message.media.webpage.document;\n\n  const senderTitle = audioEl.showSender ? appMessagesManager.getSenderToPeerText(message) : '';\n\n  let title = doc.type === 'voice' ? senderTitle : (doc.audioTitle || doc.fileName);\n  let subtitle: string;\n  \n  if(doc.type === 'voice') {\n    subtitle = '';\n  } else {\n    subtitle = doc.audioPerformer ? RichTextProcessor.wrapPlainText(doc.audioPerformer) : '';\n    if(withTime) {\n      subtitle += (subtitle ? ' \u2022 ' : '') + formatDate(doc.date);\n    } else if(!subtitle) {\n      subtitle = 'Unknown Artist';\n    }\n\n    if(audioEl.showSender) {\n      subtitle += ' \u2022 ' + senderTitle;\n    } else {\n      subtitle = ' \u2022 ' + subtitle;\n    }\n  }\n\n  let titleAdditionHTML = '';\n  if(audioEl.showSender) {\n    titleAdditionHTML = `<div class=\"sent-time\">${formatDateAccordingToToday(new Date(message.date * 1000))}</div>`;\n  }\n\n  const html = `\n  <div class=\"audio-details\">\n    <div class=\"audio-title\"><middle-ellipsis-element data-font-weight=\"${audioEl.dataset.fontWeight}\">${title}</middle-ellipsis-element>${titleAdditionHTML}</div>\n    <div class=\"audio-subtitle\"><div class=\"audio-time\"></div>${subtitle || '<div></div>'}</div>\n  </div>`;\n  \n  audioEl.insertAdjacentHTML('beforeend', html);\n\n  const onLoad = () => {\n    const subtitleDiv = audioEl.querySelector('.audio-subtitle') as HTMLDivElement;\n    let launched = false;\n\n    let progressLine = new MediaProgressLine(audioEl.audio, doc.supportsStreaming);\n\n    audioEl.addAudioListener('ended', () => {\n      audioEl.classList.remove('audio-show-progress');\n      // Reset subtitle\n      subtitleDiv.lastChild.replaceWith(subtitle);\n      launched = false;\n    });\n\n    const onPlaying = () => {\n      if(!launched) {\n        audioEl.classList.add('audio-show-progress');\n        launched = true;\n\n        if(progressLine) {\n          subtitleDiv.lastChild.replaceWith(progressLine.container);\n        }\n      }\n    };\n\n    audioEl.addAudioListener('playing', onPlaying);\n\n    if(!audioEl.audio.paused || audioEl.audio.currentTime > 0) {\n      onPlaying();\n    }\n\n    return () => {\n      progressLine.removeListeners();\n      progressLine.container.remove();\n      progressLine = null;\n    };\n  };\n\n  return onLoad;\n}\n\nexport default class AudioElement extends HTMLElement {\n  public audio: HTMLAudioElement;\n  public preloader: ProgressivePreloader;\n  public message: any;\n  public withTime = false;\n  public voiceAsMusic = false;\n  public searchContext: SearchSuperContext;\n  public showSender = false;\n  public noAutoDownload: boolean;\n\n  private attachedHandlers: {[name: string]: any[]} = {};\n  private onTypeDisconnect: () => void;\n  public onLoad: (autoload?: boolean) => void;\n\n  constructor() {\n    super();\n    // \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0441\u043e\u0437\u0434\u0430\u043d\n  }\n\n  public render() {\n    this.classList.add('audio');\n\n    const doc = this.message.media.document || this.message.media.webpage.document;\n    const isRealVoice = doc.type === 'voice';\n    const isVoice = !this.voiceAsMusic && isRealVoice;\n    const isOutgoing = this.message.pFlags.is_outgoing;\n    const uploading = isOutgoing && this.preloader;\n\n    const durationStr = String(doc.duration | 0).toHHMMSS();\n\n    this.innerHTML = `<div class=\"audio-toggle audio-ico\">    \n                         <div class=\"part one\" x=\"0\" y=\"0\" fill=\"#fff\"></div>\n                         <div class=\"part two\" x=\"0\" y=\"0\" fill=\"#fff\"></div>\n                      </div>`;\n\n    const downloadDiv = document.createElement('div');\n    downloadDiv.classList.add('audio-download');\n\n    if(uploading) {\n      this.append(downloadDiv);\n    }\n\n    const onTypeLoad = isVoice ? wrapVoiceMessage(this) : wrapAudio(this);\n    \n    const audioTimeDiv = this.querySelector('.audio-time') as HTMLDivElement;\n    audioTimeDiv.innerHTML = durationStr;\n\n    const onLoad = this.onLoad = (autoload = true) => {\n      this.onLoad = undefined;\n\n      const audio = this.audio = appMediaPlaybackController.addMedia(this.message.peerId, this.message.media.document || this.message.media.webpage.document, this.message.mid, autoload);\n\n      this.onTypeDisconnect = onTypeLoad();\n      \n      const toggle = this.querySelector('.audio-toggle') as HTMLDivElement;\n\n      const getTimeStr = () => String(audio.currentTime | 0).toHHMMSS() + (isVoice ? (' / ' + durationStr) : '');\n\n      const onPlaying = () => {\n        audioTimeDiv.innerText = getTimeStr();\n        toggle.classList.toggle('playing', !audio.paused);\n      };\n\n      if(!audio.paused || (audio.currentTime > 0 && audio.currentTime !== audio.duration)) {\n        onPlaying();\n      }\n\n      attachClickEvent(toggle, (e) => {\n        cancelEvent(e);\n        if(audio.paused) audio.play().catch(() => {});\n        else audio.pause();\n      });\n\n      this.addAudioListener('ended', () => {\n        toggle.classList.remove('playing');\n      });\n\n      this.addAudioListener('timeupdate', () => {\n        if(appMediaPlaybackController.isSafariBuffering(audio)) return;\n        audioTimeDiv.innerText = getTimeStr();\n      });\n\n      this.addAudioListener('pause', () => {\n        toggle.classList.remove('playing');\n      });\n\n      this.addAudioListener('playing', onPlaying);\n    };\n\n    if(!isOutgoing) {\n      let preloader: ProgressivePreloader = this.preloader;\n\n      const getDownloadPromise = () => appDocsManager.downloadDoc(doc);\n\n      if(isRealVoice) {\n        if(!preloader) {\n          preloader = new ProgressivePreloader({\n            cancelable: true\n          });\n        }\n\n        const load = () => {\n          const download = getDownloadPromise();\n          preloader.attach(downloadDiv, false, download);\n\n          if(!downloadDiv.parentElement) {\n            this.append(downloadDiv);\n          }\n\n          (download as Promise<any>).then(() => {\n            detachClickEvent(this, onClick);\n            onLoad();\n\n            downloadDiv.classList.add('downloaded');\n            setTimeout(() => {\n              downloadDiv.remove();\n            }, 200);\n          });\n\n          return {download};\n        };\n\n        preloader.construct();\n        preloader.setManual();\n        preloader.attach(downloadDiv);\n        preloader.setDownloadFunction(load);\n\n        const onClick = (e?: Event) => {\n          preloader.onClick(e);\n        };\n    \n        attachClickEvent(this, onClick);\n\n        if(!this.noAutoDownload) {\n          onClick();\n        }\n      } else {\n        if(doc.supportsStreaming) {\n          onLoad(false);\n        }\n\n        //if(appMediaPlaybackController.mediaExists(mid)) { // \u0447\u0442\u043e\u0431\u044b \u043f\u043e\u043a\u0430\u0437\u0430\u0442\u044c \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441, \u0435\u0441\u043b\u0438 \u0430\u0443\u0434\u0438\u043e \u0443\u0436\u0435 \u0431\u044b\u043b\u043e \u0441\u043a\u0430\u0447\u0430\u043d\u043e\n          //onLoad();\n        //} else {\n          const r = (e: Event) => {\n            if(!this.audio) {\n              onLoad(false);\n            }\n\n            if(this.audio.src) {\n              return;\n            }\n            //onLoad();\n            //cancelEvent(e);\n            appMediaPlaybackController.resolveWaitingForLoadMedia(this.message.peerId, this.message.mid);\n  \n            appMediaPlaybackController.willBePlayed(this.audio); // prepare for loading audio\n  \n            if(!preloader) {\n              if(doc.supportsStreaming) {\n                preloader = new ProgressivePreloader({\n                  cancelable: false\n                });\n\n                preloader.attach(downloadDiv, false);\n              } else {\n                preloader = new ProgressivePreloader({\n                  cancelable: true\n                });\n\n                const load = () => {\n                  const download = getDownloadPromise();\n                  preloader.attach(downloadDiv, false, download);\n                  return {download};\n                };\n\n                preloader.setDownloadFunction(load);\n                load();\n              }\n            }\n\n            if(isSafari) {\n              this.audio.autoplay = true;\n              this.audio.play().catch(() => {});\n            }\n\n            this.append(downloadDiv);\n    \n            new Promise<void>((resolve) => {\n              if(this.audio.readyState >= 2) resolve();\n              else this.addAudioListener('canplay', resolve);\n            }).then(() => {\n              downloadDiv.classList.add('downloaded');\n              setTimeout(() => {\n                downloadDiv.remove();\n              }, 200);\n  \n              //setTimeout(() => {\n                // release loaded audio\n                if(appMediaPlaybackController.willBePlayedMedia === this.audio) {\n                  this.audio.play();\n                  appMediaPlaybackController.willBePlayedMedia = null;\n                }\n              //}, 10e3);\n            });\n          };\n\n          if(!this.audio?.src) {\n            attachClickEvent(this, r, {once: true, capture: true, passive: false});\n          }\n        //}\n      }\n    } else if(uploading) {\n      this.preloader.attach(downloadDiv, false);\n      //onLoad();\n    }\n  }\n\n  /* connectedCallback() {\n    // \u0431\u0440\u0430\u0443\u0437\u0435\u0440 \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u0442 \u044d\u0442\u043e\u0442 \u043c\u0435\u0442\u043e\u0434 \u043f\u0440\u0438 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0432 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\n    // (\u043c\u043e\u0436\u0435\u0442 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c\u0441\u044f \u043c\u043d\u043e\u0433\u043e \u0440\u0430\u0437, \u0435\u0441\u043b\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043c\u043d\u043e\u0433\u043e\u043a\u0440\u0430\u0442\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u0442\u0441\u044f/\u0443\u0434\u0430\u043b\u044f\u0435\u0442\u0441\u044f)\n  } */\n\n  public addAudioListener(name: string, callback: any) {\n    if(!this.attachedHandlers[name]) this.attachedHandlers[name] = [];\n    this.attachedHandlers[name].push(callback);\n    this.audio.addEventListener(name, callback);\n  }\n\n  disconnectedCallback() {\n    if(this.isConnected) {\n      return;\n    }\n    \n    // \u0431\u0440\u0430\u0443\u0437\u0435\u0440 \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u0442 \u044d\u0442\u043e\u0442 \u043c\u0435\u0442\u043e\u0434 \u043f\u0440\u0438 \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0438\u0437 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\n    // (\u043c\u043e\u0436\u0435\u0442 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c\u0441\u044f \u043c\u043d\u043e\u0433\u043e \u0440\u0430\u0437, \u0435\u0441\u043b\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043c\u043d\u043e\u0433\u043e\u043a\u0440\u0430\u0442\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u0442\u0441\u044f/\u0443\u0434\u0430\u043b\u044f\u0435\u0442\u0441\u044f)\n    if(this.onTypeDisconnect) {\n      this.onTypeDisconnect();\n      this.onTypeDisconnect = null;\n    }\n\n    for(let name in this.attachedHandlers) {\n      for(let callback of this.attachedHandlers[name]) {\n        this.audio.removeEventListener(name, callback);\n      }\n      \n      delete this.attachedHandlers[name];\n    }\n\n    this.preloader = null;\n  }\n}\n\ncustomElements.define(\"audio-element\", AudioElement);\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type { AppMessagesManager } from \"../../lib/appManagers/appMessagesManager\";\nimport type ChatTopbar from \"./topbar\";\nimport { RichTextProcessor } from \"../../lib/richtextprocessor\";\nimport rootScope from \"../../lib/rootScope\";\nimport appMediaPlaybackController from \"../appMediaPlaybackController\";\nimport DivAndCaption from \"../divAndCaption\";\nimport { formatDate } from \"../wrappers\";\nimport PinnedContainer from \"./pinnedContainer\";\nimport Chat from \"./chat\";\nimport { cancelEvent } from \"../../helpers/dom/cancelEvent\";\nimport { attachClickEvent } from \"../../helpers/dom/clickEvent\";\nimport replaceContent from \"../../helpers/dom/replaceContent\";\nimport PeerTitle from \"../peerTitle\";\n\nexport default class ChatAudio extends PinnedContainer {\n  private toggleEl: HTMLElement;\n\n  constructor(protected topbar: ChatTopbar, protected chat: Chat, protected appMessagesManager: AppMessagesManager) {\n    super(topbar, chat, topbar.listenerSetter, 'audio', new DivAndCaption('pinned-audio', (title: string | HTMLElement, subtitle: string | HTMLElement) => {\n      replaceContent(this.divAndCaption.title, title);\n      replaceContent(this.divAndCaption.subtitle, subtitle);\n    }), () => {\n      if(this.toggleEl.classList.contains('flip-icon')) {\n        appMediaPlaybackController.toggle();\n      }\n    });\n\n    this.divAndCaption.border.remove();\n\n    this.toggleEl = document.createElement('button');\n    this.toggleEl.classList.add('pinned-audio-ico', 'tgico', 'btn-icon');\n    attachClickEvent(this.toggleEl, (e) => {\n      cancelEvent(e);\n      appMediaPlaybackController.toggle();\n    }, {listenerSetter: this.topbar.listenerSetter});\n\n    this.wrapper.prepend(this.toggleEl);\n\n    this.topbar.listenerSetter.add(rootScope)('audio_play', (e) => {\n      const {doc, mid, peerId} = e;\n\n      let title: string | HTMLElement, subtitle: string;\n      const message = appMessagesManager.getMessageByPeer(peerId, mid);\n      if(doc.type === 'voice' || doc.type === 'round') {\n        title = new PeerTitle({\n          peerId: message.fromId,\n          onlyFirstName: true\n        }).element;\n\n        //subtitle = 'Voice message';\n        subtitle = formatDate(message.date, false, false);\n      } else {\n        title = doc.audioTitle || doc.fileName;\n        subtitle = doc.audioPerformer ? RichTextProcessor.wrapPlainText(doc.audioPerformer) : 'Unknown Artist';\n      }\n\n      this.fill(title, subtitle, message);\n      this.toggleEl.classList.add('flip-icon');\n      this.toggle(false);\n    });\n\n    this.topbar.listenerSetter.add(rootScope)('audio_pause', () => {\n      this.toggleEl.classList.remove('flip-icon');\n    });\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type Chat from \"../chat/chat\";\nimport InputField from \"../inputField\";\nimport PopupElement from \".\";\nimport Scrollable from \"../scrollable\";\nimport { toast } from \"../toast\";\nimport { prepareAlbum, wrapDocument } from \"../wrappers\";\nimport CheckboxField from \"../checkboxField\";\nimport SendContextMenu from \"../chat/sendContextMenu\";\nimport { createPosterFromVideo, onVideoLoad } from \"../../helpers/files\";\nimport { MyDocument } from \"../../lib/appManagers/appDocsManager\";\nimport I18n, { i18n, LangPackKey } from \"../../lib/langPack\";\nimport appDownloadManager from \"../../lib/appManagers/appDownloadManager\";\nimport calcImageInBox from \"../../helpers/calcImageInBox\";\nimport isSendShortcutPressed from \"../../helpers/dom/isSendShortcutPressed\";\nimport placeCaretAtEnd from \"../../helpers/dom/placeCaretAtEnd\";\nimport rootScope from \"../../lib/rootScope\";\nimport RichTextProcessor from \"../../lib/richtextprocessor\";\n\ntype SendFileParams = Partial<{\n  file: File,\n  objectURL: string,\n  thumbBlob: Blob,\n  thumbURL: string,\n  width: number,\n  height: number,\n  duration: number\n}>;\n\n// TODO: .gif upload as video\n\nexport default class PopupNewMedia extends PopupElement {\n  private input: HTMLElement;\n  private mediaContainer: HTMLElement;\n  private groupCheckboxField: CheckboxField;\n  private wasInputValue = '';\n\n  private willAttach: Partial<{\n    type: 'media' | 'document',\n    isMedia: true,\n    group: boolean,\n    sendFileDetails: SendFileParams[]\n  }> = {\n    sendFileDetails: [],\n    group: false\n  };\n  private inputField: InputField;\n\n  constructor(private chat: Chat, files: File[], willAttachType: PopupNewMedia['willAttach']['type']) {\n    super('popup-send-photo popup-new-media', null, {closable: true, withConfirm: 'Modal.Send'});\n\n    this.willAttach.type = willAttachType;\n\n    this.btnConfirm.addEventListener('click', () => this.send());\n\n    if(this.chat.type !== 'scheduled') {\n      const sendMenu = new SendContextMenu({\n        onSilentClick: () => {\n          this.chat.input.sendSilent = true;\n          this.send();\n        },\n        onScheduleClick: () => {\n          this.chat.input.scheduleSending(() => {\n            this.send();\n          });\n        },\n        openSide: 'bottom-left',\n        onContextElement: this.btnConfirm,\n      });\n\n      sendMenu.setPeerId(this.chat.peerId);\n\n      this.header.append(sendMenu.sendMenu);\n    }\n\n    this.mediaContainer = document.createElement('div');\n    this.mediaContainer.classList.add('popup-photo');\n    const scrollable = new Scrollable(null);\n    scrollable.container.append(this.mediaContainer);\n    \n    this.inputField = new InputField({\n      placeholder: 'PreviewSender.CaptionPlaceholder',\n      label: 'Caption',\n      name: 'photo-caption',\n      maxLength: rootScope.config.caption_length_max,\n      showLengthOn: 80\n    });\n    this.input = this.inputField.input;\n\n    this.inputField.value = this.wasInputValue = this.chat.input.messageInputField.value;\n    this.chat.input.messageInputField.value = '';\n\n    this.container.append(scrollable.container);\n\n    if(files.length > 1) {\n      this.groupCheckboxField = new CheckboxField({\n        text: 'PreviewSender.GroupItems', \n        name: 'group-items'\n      });\n      this.container.append(this.groupCheckboxField.label, this.inputField.container);\n  \n      this.groupCheckboxField.input.checked = true;\n      this.willAttach.group = true;\n\n      this.groupCheckboxField.input.addEventListener('change', () => {\n        const checked = this.groupCheckboxField.input.checked;\n  \n        this.willAttach.group = checked;\n        this.willAttach.sendFileDetails.length = 0;\n\n        //this.mediaContainer.innerHTML = '';\n        //this.container.classList.remove('is-media', 'is-document', 'is-album');\n        this.attachFiles(files);\n      });\n    }\n    \n    this.container.append(this.inputField.container);\n\n    this.attachFiles(files);\n  }\n\n  private onKeyDown = (e: KeyboardEvent) => {\n    const target = e.target as HTMLElement;\n    if(target !== this.input) {\n      if(target.tagName === 'INPUT' || target.hasAttribute('contenteditable')) {\n        return;\n      }\n\n      this.input.focus();\n      placeCaretAtEnd(this.input);\n    }\n    \n    if(isSendShortcutPressed(e)) {\n      this.btnConfirm.click();\n    }\n  };\n\n  public send(force = false) {\n    if(this.chat.type === 'scheduled' && !force) {\n      this.chat.input.scheduleSending(() => {\n        this.send(true);\n      });\n      \n      return;\n    }\n\n    let caption = this.inputField.value;\n    if(caption.length > rootScope.config.caption_length_max) {\n      toast(I18n.format('Error.PreviewSender.CaptionTooLong', true));\n      return;\n    }\n\n    this.hide();\n    const willAttach = this.willAttach;\n    willAttach.isMedia = willAttach.type === 'media' ? true : undefined;\n\n    //console.log('will send files with options:', willAttach);\n\n    const peerId = this.chat.peerId;\n    const input = this.chat.input;\n    const silent = input.sendSilent;\n    const scheduleDate = input.scheduleDate;\n\n    if(willAttach.sendFileDetails.length > 1 && willAttach.group) {\n      for(let i = 0; i < willAttach.sendFileDetails.length;) {\n        let firstType = willAttach.sendFileDetails[i].file.type.split('/')[0];\n        for(var k = 0; k < 10 && i < willAttach.sendFileDetails.length; ++i, ++k) {\n          const type = willAttach.sendFileDetails[i].file.type.split('/')[0];\n          if(firstType !== type) {\n            break;\n          }\n        }\n\n        const w = {...willAttach};\n        w.sendFileDetails = willAttach.sendFileDetails.slice(i - k, i);\n\n        this.chat.appMessagesManager.sendAlbum(peerId, w.sendFileDetails.map(d => d.file), Object.assign({\n          caption,\n          replyToMsgId: input.replyToMsgId,\n          threadId: this.chat.threadId,\n          isMedia: willAttach.isMedia,\n          silent,\n          scheduleDate,\n          clearDraft: true as true\n        }, w));\n\n        caption = undefined;\n        input.replyToMsgId = this.chat.threadId;\n      }\n    } else {\n      if(caption) {\n        if(willAttach.sendFileDetails.length > 1) {\n          this.chat.appMessagesManager.sendText(peerId, caption, {\n            replyToMsgId: input.replyToMsgId, \n            threadId: this.chat.threadId,\n            silent, \n            scheduleDate,\n            clearDraft: true\n          });\n          caption = '';\n          //input.replyToMsgId = undefined;\n        }\n      }\n  \n      const promises = willAttach.sendFileDetails.map(params => {\n        const promise = this.chat.appMessagesManager.sendFile(peerId, params.file, Object.assign({\n          //isMedia: willAttach.isMedia, \n          isMedia: willAttach.isMedia, \n          caption,\n          replyToMsgId: input.replyToMsgId,\n          threadId: this.chat.threadId,\n          silent,\n          scheduleDate,\n          clearDraft: true as true\n        }, params));\n\n        caption = '';\n        return promise;\n      });\n\n      input.replyToMsgId = this.chat.threadId;\n    }\n\n    //Promise.all(promises);\n\n    //appMessagesManager.sendFile(appImManager.peerId, willAttach.file, willAttach);\n    \n    input.onMessageSent();\n  }\n\n  public attachFile = (file: File) => {\n    const willAttach = this.willAttach;\n    return new Promise<HTMLDivElement>((resolve) => {\n      const params: SendFileParams = {};\n      params.file = file;\n      //console.log('selected file:', file, typeof(file), willAttach);\n      const itemDiv = document.createElement('div');\n      switch(willAttach.type) {\n        case 'media': {\n          const isVideo = file.type.indexOf('video/') === 0;\n\n          itemDiv.classList.add('popup-item-media');\n\n          if(isVideo) {\n            const video = document.createElement('video');\n            const source = document.createElement('source');\n            source.src = params.objectURL = URL.createObjectURL(file);\n            video.autoplay = true;\n            video.controls = false;\n            video.muted = true;\n            video.setAttribute('playsinline', 'true');\n\n            video.addEventListener('timeupdate', () => {\n              video.pause();\n            }, {once: true});\n\n            onVideoLoad(video).then(() => {\n              params.width = video.videoWidth;\n              params.height = video.videoHeight;\n              params.duration = Math.floor(video.duration);\n\n              itemDiv.append(video);\n              createPosterFromVideo(video).then(blob => {\n                params.thumbBlob = blob;\n                params.thumbURL = URL.createObjectURL(blob);\n                resolve(itemDiv);\n              });\n            });\n\n            video.append(source);\n          } else {\n            const img = new Image();\n            img.src = params.objectURL = URL.createObjectURL(file);\n            img.onload = () => {\n              params.width = img.naturalWidth;\n              params.height = img.naturalHeight;\n\n              itemDiv.append(img);\n              resolve(itemDiv);\n            };\n          }\n          \n          break;\n        }\n\n        case 'document': {\n          const isPhoto = file.type.indexOf('image/') !== -1;\n          const isAudio = file.type.indexOf('audio/') !== -1;\n          if(isPhoto || isAudio) {\n            params.objectURL = URL.createObjectURL(file);\n          }\n\n          const doc = {\n            _: 'document',\n            file: file,\n            file_name: file.name || '',\n            fileName: file.name ? RichTextProcessor.wrapEmojiText(file.name) : '',\n            size: file.size,\n            type: isPhoto ? 'photo' : 'doc'\n          } as MyDocument;\n\n          const cacheContext = appDownloadManager.getCacheContext(doc);\n          cacheContext.url = params.objectURL;\n          cacheContext.downloaded = file.size;\n\n          const docDiv = wrapDocument({\n            message: {\n              _: 'message',\n              pFlags: {\n                is_outgoing: true\n              },\n              mid: 0,\n              peerId: 0,\n              media: {\n                _: 'messageMediaDocument',\n                document: doc\n              }\n            } as any\n          });\n\n          const finish = () => {\n            itemDiv.append(docDiv);\n            resolve(itemDiv);\n          };\n\n          if(isPhoto) {\n            const img = new Image();\n            img.src = params.objectURL;\n            img.onload = () => {\n              params.width = img.naturalWidth;\n              params.height = img.naturalHeight;\n\n              finish();\n            };\n\n            img.onerror = finish;\n          } else {\n            finish();\n          }\n\n          break;\n        }\n      }\n\n      willAttach.sendFileDetails.push(params);\n    });\n  };\n\n  public attachFiles(files: File[]) {\n    const container = this.container;\n    const willAttach = this.willAttach;\n\n    /* if(files.length > 10 && willAttach.type === 'media') {\n      willAttach.type = 'document';\n    } */\n\n    files = files.filter(file => {\n      if(willAttach.type === 'media') {\n        return ['image/', 'video/'].find(s => file.type.indexOf(s) === 0);\n      } else {\n        return true;\n      }\n    });\n\n    Promise.all(files.map(this.attachFile)).then(results => {\n      this.container.classList.remove('is-media', 'is-document', 'is-album');\n      this.mediaContainer.innerHTML = '';\n\n      if(files.length) {\n        let key: LangPackKey;\n        const args: any[] = [];\n        if(willAttach.type === 'document') {\n          key = 'PreviewSender.SendFile';\n          args.push(files.length);\n          container.classList.add('is-document');\n        } else {\n          container.classList.add('is-media');\n  \n          let foundPhotos = 0;\n          let foundVideos = 0;\n          files.forEach(file => {\n            if(file.type.indexOf('image/') === 0) ++foundPhotos;\n            else if(file.type.indexOf('video/') === 0) ++foundVideos;\n          });\n          \n          const sum = foundPhotos + foundVideos;\n          if(sum > 1 && willAttach.group) {\n            key = 'PreviewSender.SendAlbum';\n            const albumsLength = Math.ceil(sum / 10);\n            args.push(albumsLength);\n          } else if(foundPhotos) {\n            key = 'PreviewSender.SendPhoto';\n            args.push(foundPhotos);\n          } else if(foundVideos) {\n            key = 'PreviewSender.SendVideo';\n            args.push(foundVideos);\n          }\n        }\n\n        this.title.textContent = '';\n        this.title.append(i18n(key, args));\n      }\n\n      if(willAttach.type === 'media') {\n        if(willAttach.sendFileDetails.length > 1 && willAttach.group) {\n          container.classList.add('is-album');\n\n          for(let i = 0; i < results.length; i += 10) {\n            const albumContainer = document.createElement('div');\n            albumContainer.classList.add('popup-album');\n\n            albumContainer.append(...results.slice(i, i + 10));\n            prepareAlbum({\n              container: albumContainer,\n              items: willAttach.sendFileDetails.slice(i, i + 10).map(o => ({w: o.width, h: o.height})),\n              maxWidth: 380,\n              minWidth: 100,\n              spacing: 4\n            });\n\n            this.mediaContainer.append(albumContainer);\n          }\n\n          //console.log('chatInput album layout:', layout);\n        } else {\n          for(let i = 0; i < results.length; ++i) {\n            const params = willAttach.sendFileDetails[i];\n            const div = results[i];\n            const size = calcImageInBox(params.width, params.height, 380, 320);\n            div.style.width = size.width + 'px';\n            div.style.height = size.height + 'px';\n            this.mediaContainer.append(div);\n          }\n        }\n      } else {\n        this.mediaContainer.append(...results);\n      }\n\n      // show now\n      if(!this.element.classList.contains('active')) {\n        document.body.addEventListener('keydown', this.onKeyDown);\n        this.onClose = () => {\n          if(this.wasInputValue) {\n            this.chat.input.messageInputField.value = this.wasInputValue;\n          }\n\n          document.body.removeEventListener('keydown', this.onKeyDown);\n        };\n        this.show();\n      }\n    });\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport { formatNumber } from \"../../helpers/number\";\nimport appImManager from \"../../lib/appManagers/appImManager\";\nimport appStateManager from \"../../lib/appManagers/appStateManager\";\nimport appUsersManager from \"../../lib/appManagers/appUsersManager\";\nimport rootScope from \"../../lib/rootScope\";\nimport { SearchGroup } from \"../appSearch\";\nimport \"../avatar\";\nimport Scrollable, { ScrollableX } from \"../scrollable\";\nimport InputSearch from \"../inputSearch\";\nimport SidebarSlider from \"../slider\";\nimport { TransitionSlider } from \"../transition\";\nimport AppNewGroupTab from \"./tabs/newGroup\";\nimport appMessagesManager from \"../../lib/appManagers/appMessagesManager\";\nimport AppSearchSuper from \"../appSearchSuper.\";\nimport { DateData, fillTipDates } from \"../../helpers/date\";\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\nimport AppSettingsTab from \"./tabs/settings\";\nimport AppNewChannelTab from \"./tabs/newChannel\";\nimport AppContactsTab from \"./tabs/contacts\";\nimport AppArchivedTab from \"./tabs/archivedTab\";\nimport AppAddMembersTab from \"./tabs/addMembers\";\nimport { i18n_, LangPackKey } from \"../../lib/langPack\";\nimport { ButtonMenuItemOptions } from \"../buttonMenu\";\nimport CheckboxField from \"../checkboxField\";\nimport { isMobileSafari } from \"../../helpers/userAgent\";\nimport appNavigationController from \"../appNavigationController\";\nimport findUpClassName from \"../../helpers/dom/findUpClassName\";\nimport findUpTag from \"../../helpers/dom/findUpTag\";\nimport PeerTitle from \"../peerTitle\";\nimport App from \"../../config/app\";\nimport ButtonMenuToggle from \"../buttonMenuToggle\";\nimport replaceContent from \"../../helpers/dom/replaceContent\";\nimport sessionStorage from \"../../lib/sessionStorage\";\n\nexport const LEFT_COLUMN_ACTIVE_CLASSNAME = 'is-left-column-shown';\n\nexport class AppSidebarLeft extends SidebarSlider {\n  private toolsBtn: HTMLButtonElement;\n  private backBtn: HTMLButtonElement;\n  //private searchInput = document.getElementById('global-search') as HTMLInputElement;\n  private inputSearch: InputSearch;\n  \n  public archivedCount: HTMLSpanElement;\n\n  private newBtnMenu: HTMLElement;\n\n  //private log = logger('SL');\n\n  private searchGroups: {[k in 'contacts' | 'globalContacts' | 'messages' | 'people' | 'recent']: SearchGroup} = {} as any;\n  private searchSuper: AppSearchSuper;\n\n  constructor() {\n    super({\n      sidebarEl: document.getElementById('column-left') as HTMLDivElement,\n      navigationType: 'left'\n    });\n\n    //this._selectTab(0); // make first tab as default\n\n    this.inputSearch = new InputSearch('Search');\n    const sidebarHeader = this.sidebarEl.querySelector('.item-main .sidebar-header');\n    sidebarHeader.append(this.inputSearch.container);\n\n    const onNewGroupClick = () => {\n      new AppAddMembersTab(this).open({\n        peerId: 0,\n        type: 'chat',\n        skippable: false,\n        takeOut: (peerIds) => {\n          new AppNewGroupTab(this).open(peerIds);\n        },\n        title: 'GroupAddMembers',\n        placeholder: 'SendMessageTo'\n      });\n    };\n\n    const onContactsClick = () => {\n      new AppContactsTab(this).open();\n    };\n\n    //this.toolsBtn = this.sidebarEl.querySelector('.sidebar-tools-button') as HTMLButtonElement;\n    this.backBtn = this.sidebarEl.querySelector('.sidebar-back-button') as HTMLButtonElement;\n\n    const btnArchive: ButtonMenuItemOptions & {verify?: () => boolean} = {\n      icon: 'archive',\n      text: 'ArchivedChats',\n      onClick: () => {\n        new AppArchivedTab(this).open();\n      },\n      verify: () => {\n        const folder = appMessagesManager.dialogsStorage.getFolder(1);\n        return !!folder.length;\n      }\n    };\n\n    const themeCheckboxField = new CheckboxField({\n      toggle: true,\n      checked: rootScope.getTheme().name === 'night'\n    });\n    themeCheckboxField.input.addEventListener('change', () => {\n      rootScope.settings.theme = themeCheckboxField.input.checked ? 'night' : 'day';\n      appStateManager.pushToState('settings', rootScope.settings);\n      appImManager.applyCurrentTheme();\n    });\n\n    rootScope.addEventListener('theme_change', () => {\n      themeCheckboxField.setValueSilently(rootScope.getTheme().name === 'night');\n    });\n\n    const menuButtons: (ButtonMenuItemOptions & {verify?: () => boolean})[] = [{\n      icon: 'saved',\n      text: 'SavedMessages',\n      onClick: () => {\n        setTimeout(() => { // menu doesn't close if no timeout (lol)\n          appImManager.setPeer(appImManager.myId);\n        }, 0);\n      }\n    }, btnArchive, {\n      icon: 'user',\n      text: 'Contacts',\n      onClick: onContactsClick\n    }, {\n      icon: 'settings',\n      text: 'Settings',\n      onClick: () => {\n        new AppSettingsTab(this).open();\n      }\n    }, {\n      icon: 'darkmode',\n      text: 'DarkMode',\n      onClick: () => {\n        \n      },\n      checkboxField: themeCheckboxField\n    }, {\n      icon: 'animations',\n      text: 'Animations',\n      onClick: () => {\n        \n      },\n      checkboxField: new CheckboxField({\n        toggle: true, \n        checked: true,\n        stateKey: 'settings.animationsEnabled',\n      })\n    }, {\n      icon: 'help',\n      text: 'TelegramFeatures',\n      onClick: () => {\n        appImManager.openUsername('TelegramTips');\n      }\n    }, {\n      icon: 'bug',\n      text: 'ReportBug',\n      onClick: () => {\n        const a = document.createElement('a');\n        a.target = '_blank';\n        a.href = 'https://bugs.telegram.org/?tag_ids=40&sort=time';\n        document.body.append(a);\n        a.click();\n        setTimeout(() => {\n          a.remove();\n        }, 0);\n      }\n    }, {\n      icon: 'char z',\n      text: 'ChatList.Menu.SwitchTo.Z',\n      onClick: () => {\n        sessionStorage.set({kz_version: 'Z'}).then(() => {\n          location.href = 'https://web.telegram.org/z/';\n        });\n      },\n      verify: () => App.isMainDomain\n    }, {\n      icon: 'char w',\n      text: 'ChatList.Menu.SwitchTo.Webogram',\n      onClick: () => {\n        location.href = 'https://web.telegram.org/?legacy=1';\n      },\n      verify: () => App.isMainDomain\n    }];\n\n    this.toolsBtn = ButtonMenuToggle({}, 'bottom-right', menuButtons, (e) => {\n      menuButtons.forEach(button => {\n        if(button.verify) {\n          button.element.classList.toggle('hide', !button.verify());\n        }\n      });\n    });\n    this.toolsBtn.classList.remove('tgico-more');\n    this.toolsBtn.classList.add('sidebar-tools-button', 'is-visible');\n\n    this.backBtn.parentElement.insertBefore(this.toolsBtn, this.backBtn);\n\n    const btnMenu = this.toolsBtn.querySelector('.btn-menu') as HTMLElement;\n\n    const btnMenuFooter = document.createElement('div');\n    btnMenuFooter.classList.add('btn-menu-footer');\n    const t = document.createElement('span');\n    t.classList.add('btn-menu-footer-text');\n    t.innerHTML = 'Telegram Web' + App.suffix + ' alpha ' + App.version;\n    btnMenuFooter.append(t); \n    btnMenu.classList.add('has-footer');\n    btnMenu.append(btnMenuFooter);\n\n    this.newBtnMenu = ButtonMenuToggle({}, 'top-left', [{\n      icon: 'newchannel',\n      text: 'NewChannel',\n      onClick: () => {\n        new AppNewChannelTab(this).open();\n      }\n    }, {\n      icon: 'newgroup',\n      text: 'NewGroup',\n      onClick: onNewGroupClick\n    }, {\n      icon: 'newprivate',\n      text: 'NewPrivateChat',\n      onClick: onContactsClick\n    }]);\n    this.newBtnMenu.className = 'btn-circle rp btn-corner z-depth-1 btn-menu-toggle animated-button-icon';\n    this.newBtnMenu.insertAdjacentHTML('afterbegin', `\n    <span class=\"tgico tgico-newchat_filled\"></span>\n    <span class=\"tgico tgico-close\"></span>\n    `);\n    this.newBtnMenu.id = 'new-menu';\n    sidebarHeader.nextElementSibling.append(this.newBtnMenu);\n\n    this.inputSearch.input.addEventListener('focus', () => this.initSearch(), {once: true});\n\n    //parseMenuButtonsTo(this.newButtons, this.newBtnMenu.firstElementChild.children);\n\n    this.archivedCount = document.createElement('span');\n    this.archivedCount.className = 'archived-count badge badge-24 badge-gray';\n\n    btnArchive.element.append(this.archivedCount);\n\n    rootScope.addEventListener('dialogs_archived_unread', (e) => {\n      this.archivedCount.innerText = '' + formatNumber(e.count, 1);\n      this.archivedCount.classList.toggle('hide', !e.count);\n    });\n\n    appUsersManager.getTopPeers();\n\n    appStateManager.getState().then(state => {\n      const recentSearch = state.recentSearch || [];\n      for(let i = 0, length = recentSearch.length; i < length; ++i) {\n        appStateManager.requestPeer(recentSearch[i], 'recentSearch');\n      }\n    });\n  }\n\n  private initSearch() {\n    const searchContainer = this.sidebarEl.querySelector('#search-container') as HTMLDivElement;\n\n    const scrollable = new Scrollable(searchContainer);\n\n    const close = () => {\n      //setTimeout(() => {\n        this.backBtn.click();\n      //}, 0);\n    };\n\n    this.searchGroups = {\n      contacts: new SearchGroup('Search.Chats', 'contacts', undefined, undefined, undefined, undefined, close),\n      globalContacts: new SearchGroup('Search.Global', 'contacts', undefined, undefined, undefined, undefined, close),\n      messages: new SearchGroup('Search.Messages', 'messages'),\n      people: new SearchGroup(false, 'contacts', true, 'search-group-people', true, false, close),\n      recent: new SearchGroup('Recent', 'contacts', true, 'search-group-recent', true, true, close)\n    };\n\n    const searchSuper = this.searchSuper = new AppSearchSuper({\n      mediaTabs: [{\n        inputFilter: 'inputMessagesFilterEmpty',\n        name: 'FilterChats',\n        type: 'chats'\n      }, {\n        inputFilter: 'inputMessagesFilterPhotoVideo',\n        name: 'SharedMediaTab2',\n        type: 'media'\n      }, {\n        inputFilter: 'inputMessagesFilterUrl',\n        name: 'SharedLinksTab2',\n        type: 'links'\n      }, {\n        inputFilter: 'inputMessagesFilterDocument',\n        name: 'SharedFilesTab2',\n        type: 'files'\n      }, {\n        inputFilter: 'inputMessagesFilterMusic',\n        name: 'SharedMusicTab2',\n        type: 'music'\n      }, {\n        inputFilter: 'inputMessagesFilterVoice',\n        name: 'SharedVoiceTab2',\n        type: 'voice'\n      }], \n      scrollable, \n      searchGroups: this.searchGroups, \n      asChatList: true,\n      hideEmptyTabs: false,\n      showSender: true\n    });\n\n    searchContainer.prepend(searchSuper.nav.parentElement.parentElement);\n    scrollable.container.append(searchSuper.container);\n\n    const resetSearch = () => {\n      searchSuper.setQuery({\n        peerId: 0, \n        folderId: 0\n      });\n      searchSuper.selectTab(0);\n      searchSuper.load(true); \n    };\n\n    resetSearch();\n\n    let pickedElements: HTMLElement[] = [];\n    let selectedPeerId = 0;\n    let selectedMinDate = 0;\n    let selectedMaxDate = 0;\n    const updatePicked = () => {\n      //(this.inputSearch.input as HTMLInputElement).placeholder = pickedElements.length ? 'Search' : 'Telegram Search';\n      this.inputSearch.container.classList.toggle('is-picked-twice', pickedElements.length === 2);\n      this.inputSearch.container.classList.toggle('is-picked', !!pickedElements.length);\n\n      if(pickedElements.length) {\n        this.inputSearch.input.style.setProperty('--paddingLeft', (pickedElements[pickedElements.length - 1].getBoundingClientRect().right - this.inputSearch.input.getBoundingClientRect().left) + 'px');\n      } else {\n        this.inputSearch.input.style.removeProperty('--paddingLeft');\n      }\n    };\n\n    const helper = document.createElement('div');\n    helper.classList.add('search-helper');\n    helper.addEventListener('click', (e) => {\n      const target = findUpClassName(e.target, 'selector-user');\n      if(!target) {\n        return;\n      }\n\n      const key = target.dataset.key;\n      if(key.indexOf('date_') === 0) {\n        const [_, minDate, maxDate] = key.split('_');\n        selectedMinDate = +minDate;\n        selectedMaxDate = +maxDate;\n      } else {\n        selectedPeerId = +key;\n      }\n\n      target.addEventListener('click', () => {\n        unselectEntity(target);\n      });\n\n      this.inputSearch.container.append(target);\n      this.inputSearch.onChange(this.inputSearch.value = '');\n      pickedElements.push(target);\n      updatePicked();\n    });\n\n    searchSuper.nav.parentElement.append(helper);\n\n    const renderEntity = (peerId: any, title?: string | HTMLElement) => {\n      const div = document.createElement('div');\n      div.classList.add('selector-user'/* , 'scale-in' */);\n\n      const avatarEl = document.createElement('avatar-element');\n      avatarEl.classList.add('selector-user-avatar', 'tgico');\n      avatarEl.setAttribute('dialog', '1');\n      avatarEl.classList.add('avatar-30');\n\n      div.dataset.key = '' + peerId;\n      if(typeof(peerId) === 'number') {\n        if(title === undefined) {\n          title = new PeerTitle({peerId, onlyFirstName: true}).element;\n        }\n\n        avatarEl.setAttribute('peer', '' + peerId);\n      } else {\n        avatarEl.classList.add('tgico-calendarfilter');\n      }\n\n      if(title) {\n        if(typeof(title) === 'string') {\n          div.innerHTML = title;\n        } else {\n          replaceContent(div, title);\n          div.append(title);\n        }\n      }\n\n      div.insertAdjacentElement('afterbegin', avatarEl);\n\n      return div;\n    };\n\n    const unselectEntity = (target: HTMLElement) => {\n      const key = target.dataset.key;\n      if(key.indexOf('date_') === 0) {\n        selectedMinDate = selectedMaxDate = 0;\n      } else {\n        selectedPeerId = 0;\n      }\n      \n      target.remove();\n      pickedElements.findAndSplice(t => t === target);\n\n      setTimeout(() => {\n        updatePicked();\n        this.inputSearch.onChange(this.inputSearch.value);\n      }, 0);\n    };\n\n    this.inputSearch.onClear = () => {\n      pickedElements.forEach(el => {\n        unselectEntity(el);\n      });\n    };\n\n    this.inputSearch.onChange = (value) => {\n      searchSuper.cleanupHTML();\n      searchSuper.setQuery({\n        peerId: selectedPeerId, \n        folderId: selectedPeerId ? undefined : 0,\n        query: value,\n        minDate: selectedMinDate,\n        maxDate: selectedMaxDate\n      });\n      searchSuper.load(true);\n\n      helper.innerHTML = '';\n      searchSuper.nav.classList.remove('hide');\n      if(!value) {\n      }\n      \n      if(!selectedPeerId && value.trim()) {\n        const middleware = searchSuper.middleware.get();\n        Promise.all([\n          appMessagesManager.getConversationsAll(value).then(dialogs => dialogs.map(d => d.peerId)),\n          appUsersManager.getContacts(value, true)\n        ]).then(results => {\n          if(!middleware()) return;\n          const peerIds = new Set(results[0].concat(results[1]));\n  \n          peerIds.forEach(peerId => {\n            helper.append(renderEntity(peerId));\n          });\n  \n          searchSuper.nav.classList.toggle('hide', !!helper.innerHTML);\n          //console.log('got peerIds by value:', value, [...peerIds]);\n        });\n      }\n      \n      if(!selectedMinDate && value.trim()) {\n        const dates: DateData[] = [];\n        fillTipDates(value, dates);\n        dates.forEach(dateData => {\n          helper.append(renderEntity('date_' + dateData.minDate + '_' + dateData.maxDate, dateData.title));\n        });\n\n        searchSuper.nav.classList.toggle('hide', !!helper.innerHTML);\n      }\n    };\n\n    searchSuper.tabs.inputMessagesFilterEmpty.addEventListener('mousedown', (e) => {\n      const target = findUpTag(e.target, 'LI') as HTMLElement;\n      if(!target) {\n        return;\n      }\n\n      const searchGroup = findUpClassName(target, 'search-group');\n      if(!searchGroup || searchGroup.classList.contains('search-group-recent') || searchGroup.classList.contains('search-group-people')) {\n        return;\n      }\n\n      const peerId = +target.getAttribute('data-peer-id');\n      appStateManager.getState().then(state => {\n        const recentSearch = state.recentSearch || [];\n        if(recentSearch[0] !== peerId) {\n          recentSearch.findAndSplice(p => p === peerId);\n          recentSearch.unshift(peerId);\n          if(recentSearch.length > 20) {\n            recentSearch.length = 20;\n          }\n  \n          appStateManager.pushToState('recentSearch', recentSearch);\n          for(const peerId of recentSearch) {\n            appStateManager.requestPeer(peerId, 'recentSearch');\n          }\n        }\n      });\n    }, {capture: true});\n\n    let peopleContainer = document.createElement('div');\n    peopleContainer.classList.add('search-group-scrollable');\n    peopleContainer.append(this.searchGroups.people.list);\n    this.searchGroups.people.container.append(peopleContainer);\n    let peopleScrollable = new ScrollableX(peopleContainer);\n\n    let first = true;\n    let hideNewBtnMenuTimeout: number;\n    //const transition = Transition.bind(null, searchContainer.parentElement, 150);\n    const transition = TransitionSlider(searchContainer.parentElement, 'zoom-fade', 150, (id) => {\n      if(hideNewBtnMenuTimeout) clearTimeout(hideNewBtnMenuTimeout);\n\n      if(id === 0 && !first) {\n        searchSuper.selectTab(0, false);\n        this.inputSearch.onClearClick();\n        hideNewBtnMenuTimeout = window.setTimeout(() => {\n          hideNewBtnMenuTimeout = 0;\n          this.newBtnMenu.classList.remove('is-hidden');\n        }, 150);\n      }\n\n      first = false;\n    });\n\n    transition(0);\n\n    const activeClassName = 'is-visible';\n    const onFocus = () => {\n      this.toolsBtn.classList.remove(activeClassName);\n      this.backBtn.classList.add(activeClassName);\n      this.newBtnMenu.classList.add('is-hidden');\n      this.toolsBtn.parentElement.firstElementChild.classList.toggle('state-back', true);\n\n      if(!isMobileSafari && !appNavigationController.findItemByType('global-search')) {\n        appNavigationController.pushItem({\n          onPop: () => {\n            close();\n          },\n          type: 'global-search'\n        });\n      }\n\n      transition(1);\n    };\n\n    this.inputSearch.input.addEventListener('focus', onFocus);\n    onFocus();\n\n    this.backBtn.addEventListener('click', (e) => {\n      this.toolsBtn.classList.add(activeClassName);\n      this.backBtn.classList.remove(activeClassName);\n      this.toolsBtn.parentElement.firstElementChild.classList.toggle('state-back', false);\n\n      appNavigationController.removeByType('global-search');\n\n      transition(0);\n    });\n\n    const clearRecentSearchBtn = document.createElement('button');\n    clearRecentSearchBtn.classList.add('btn-icon', 'tgico-close');\n    this.searchGroups.recent.nameEl.append(clearRecentSearchBtn);\n    clearRecentSearchBtn.addEventListener('click', () => {\n      this.searchGroups.recent.clear();\n      appStateManager.pushToState('recentSearch', []);\n    });\n  }\n}\n\nexport class SettingSection {\n  public container: HTMLElement;\n  public content: HTMLElement;\n  public title: HTMLElement;\n  public caption: HTMLElement;\n\n  constructor(options: {\n    name?: LangPackKey, \n    caption?: LangPackKey | true,\n    noDelimiter?: boolean,\n    fakeGradientDelimiter?: boolean\n  }) {\n    this.container = document.createElement('div');\n    this.container.classList.add('sidebar-left-section');\n\n    if(options.fakeGradientDelimiter) {\n      this.container.append(generateDelimiter());\n      this.container.classList.add('with-fake-delimiter');\n    } else if(!options.noDelimiter) {\n      const hr = document.createElement('hr');\n      this.container.append(hr);\n    } else {\n      this.container.classList.add('no-delimiter');\n    }\n\n    this.content = this.generateContentElement();\n\n    if(options.name) {\n      this.title = document.createElement('div');\n      this.title.classList.add('sidebar-left-h2', 'sidebar-left-section-name');\n      i18n_({element: this.title, key: options.name});\n      this.content.append(this.title);\n    }\n\n    if(options.caption) {\n      this.caption = this.generateContentElement();\n      this.caption.classList.add('sidebar-left-section-caption');\n\n      if(options.caption !== true) {\n        i18n_({element: this.caption, key: options.caption});\n      }\n    }\n  }\n\n  public generateContentElement() {\n    const content = document.createElement('div');\n    content.classList.add('sidebar-left-section-content');\n    this.container.append(content);\n    return content;\n  }\n}\n\nexport const generateSection = (appendTo: Scrollable, name?: LangPackKey, caption?: LangPackKey) => {\n  const section = new SettingSection({name, caption});\n  appendTo.append(section.container);\n  return section.content;\n};\n\nexport const generateDelimiter = () => {\n  const delimiter = document.createElement('div');\n  delimiter.classList.add('gradient-delimiter');\n  return delimiter;\n};\n\nconst appSidebarLeft = new AppSidebarLeft();\nMOUNT_CLASS_TO.appSidebarLeft = appSidebarLeft;\nexport default appSidebarLeft;\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport appDialogsManager from \"../../../lib/appManagers/appDialogsManager\";\nimport { SliderSuperTab } from \"../../slider\";\n\nexport default class AppArchivedTab extends SliderSuperTab {\n  private static filterId = 1;\n  private wasFilterId: number;\n\n  init() {\n    this.container.id = 'chats-archived-container';\n    this.setTitle('ArchivedChats');\n\n    if(!appDialogsManager.chatLists[AppArchivedTab.filterId]) {\n      const chatList = appDialogsManager.createChatList();\n      appDialogsManager.generateScrollable(chatList, AppArchivedTab.filterId).container.append(chatList);\n      appDialogsManager.setListClickListener(chatList, null, true);\n      //appDialogsManager.setListClickListener(archivedChatList, null, true); // * to test peer changing\n    }\n\n    const scrollable = appDialogsManager.scrollables[AppArchivedTab.filterId];\n    this.scrollable.container.replaceWith(scrollable.container);\n    this.scrollable = scrollable;\n  }\n\n  onOpen() {\n    if(this.init) {\n      this.init();\n      this.init = null;\n    }\n\n    this.wasFilterId = appDialogsManager.filterId;\n    appDialogsManager.filterId = AppArchivedTab.filterId;\n    appDialogsManager.onTabChange();\n  }\n\n  // \u0432\u043e\u043e\u0431\u0449\u0435, \u0442\u0430\u043a \u0434\u0435\u043b\u0430\u0442\u044c \u043d\u0435\u043b\u044c\u0437\u044f, \u043d\u043e \u043d\u0435\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u0447\u0442\u043e\u0431\u044b \u043f\u0435\u0440\u0435\u0434\u0435\u043b\u0430\u0442\u044c \u0433\u043b\u0430\u0432\u043d\u044b\u0439 \u0447\u0430\u0442\u043b\u0438\u0441\u0442 \u043d\u0430 \u0441\u043b\u0430\u0439\u0434...\n  onOpenAfterTimeout() {\n    appDialogsManager.chatLists[this.wasFilterId].innerHTML = '';\n  }\n\n  onClose() {\n    appDialogsManager.filterId = this.wasFilterId;\n    appDialogsManager.onTabChange();\n  }\n\n  onCloseAfterTimeout() {\n    appDialogsManager.chatLists[AppArchivedTab.filterId].innerHTML = '';\n    return super.onCloseAfterTimeout();\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport { SliderSuperTab } from \"../../slider\";\nimport appDialogsManager from \"../../../lib/appManagers/appDialogsManager\";\nimport appUsersManager from \"../../../lib/appManagers/appUsersManager\";\nimport appPhotosManager from \"../../../lib/appManagers/appPhotosManager\";\nimport InputSearch from \"../../inputSearch\";\nimport { isMobile } from \"../../../helpers/userAgent\";\nimport { canFocus } from \"../../../helpers/dom/canFocus\";\n\n// TODO: \u043f\u043e\u0438\u0441\u043a \u043f\u043e \u043b\u044e\u0434\u044f\u043c \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0439, \u0435\u0441\u043b\u0438 \u043d\u0435 \u043d\u0430\u0448\u043b\u043e \u0432 \u043a\u043e\u043d\u0442\u0430\u043a\u0442\u0430\u0445 \u043d\u0438\u043a\u043e\u0433\u043e\n\nexport default class AppContactsTab extends SliderSuperTab {\n  private list: HTMLUListElement;\n  private promise: Promise<void>;\n\n  private inputSearch: InputSearch;\n  private alive = true;\n  \n  init() {\n    this.container.id = 'contacts-container';\n\n    this.list = appDialogsManager.createChatList(/* {avatarSize: 48, handheldsSize: 66} */);\n    this.list.id = 'contacts';\n    this.list.classList.add('contacts-container');\n\n    appDialogsManager.setListClickListener(this.list, () => {\n      (this.container.querySelector('.sidebar-close-button') as HTMLElement).click();\n    }, undefined, true);\n\n    this.inputSearch = new InputSearch('Search', (value) => {\n      this.list.innerHTML = '';\n      this.openContacts(value);\n    });\n\n    this.title.replaceWith(this.inputSearch.container);\n\n    this.scrollable.append(this.list);\n\n    // preload contacts\n    // appUsersManager.getContacts();\n  }\n\n  onClose() {\n    this.alive = false;\n    /* // need to clear, and left 1 page for smooth slide\n    let pageCount = appPhotosManager.windowH / 72 * 1.25 | 0;\n    (Array.from(this.list.children) as HTMLElement[]).slice(pageCount).forEach(el => el.remove()); */\n  }\n\n  onOpenAfterTimeout() {\n    if(isMobile || !canFocus(true)) return;\n    this.inputSearch.input.focus();\n  }\n\n  public openContacts(query?: string) {\n    if(this.init) {\n      this.init();\n      this.init = null;\n    }\n\n    if(this.promise) return this.promise;\n    this.scrollable.onScrolledBottom = null;\n\n    this.promise = appUsersManager.getContacts(query, undefined, 'online').then(contacts => {\n      this.promise = null;\n\n      if(!this.alive) {\n        //console.warn('user closed contacts before it\\'s loaded');\n        return;\n      }\n\n      let renderPage = () => {\n        const pageCount = appPhotosManager.windowH / 72 * 1.25 | 0;\n        const arr = contacts.splice(0, pageCount); // \u043d\u0430\u0434\u043e splice!\n\n        arr.forEach((peerId) => {\n          const {dom} = appDialogsManager.addDialogNew({\n            dialog: peerId,\n            container: this.list,\n            drawStatus: false,\n            avatarSize: 48,\n            autonomous: true\n          });\n  \n          const status = appUsersManager.getUserStatusString(peerId);\n          dom.lastMessageSpan.append(status);\n        });\n\n        if(!contacts.length) {\n          renderPage = undefined;\n        }\n      };\n\n      renderPage();\n      this.scrollable.onScrolledBottom = () => {\n        if(renderPage) {\n          renderPage();\n        } else {\n          this.scrollable.onScrolledBottom = null;\n        }\n      };\n    });\n  }\n\n  public open() {\n    this.openContacts();\n    return super.open();\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport { attachClickEvent } from \"../../../helpers/dom/clickEvent\";\nimport findUpTag from \"../../../helpers/dom/findUpTag\";\nimport replaceContent from \"../../../helpers/dom/replaceContent\";\nimport ListenerSetter from \"../../../helpers/listenerSetter\";\nimport ScrollableLoader from \"../../../helpers/listLoader\";\nimport { ChannelParticipant, Chat, ChatBannedRights, Update } from \"../../../layer\";\nimport appChatsManager, { ChatRights } from \"../../../lib/appManagers/appChatsManager\";\nimport appDialogsManager from \"../../../lib/appManagers/appDialogsManager\";\nimport appPeersManager from \"../../../lib/appManagers/appPeersManager\";\nimport appProfileManager from \"../../../lib/appManagers/appProfileManager\";\nimport I18n, { i18n, join, LangPackKey } from \"../../../lib/langPack\";\nimport rootScope from \"../../../lib/rootScope\";\nimport CheckboxField from \"../../checkboxField\";\nimport PopupPickUser from \"../../popups/pickUser\";\nimport Row from \"../../row\";\nimport { SettingSection } from \"../../sidebarLeft\";\nimport { SliderSuperTabEventable } from \"../../sliderTab\";\nimport { toast } from \"../../toast\";\nimport AppUserPermissionsTab from \"./userPermissions\";\n\nexport class ChatPermissions {\n  public v: Array<{\n    flags: ChatRights[],\n    text: LangPackKey,\n    exceptionText: LangPackKey,\n    checkboxField?: CheckboxField,\n  }>;\n  private toggleWith: Partial<{[chatRight in ChatRights]: ChatRights[]}>;\n\n  constructor(options: {\n    chatId: number,\n    listenerSetter: ListenerSetter,\n    appendTo: HTMLElement,\n    participant?: ChannelParticipant.channelParticipantBanned\n  }) {\n    this.v = [\n      {flags: ['send_messages'], text: 'UserRestrictionsSend', exceptionText: 'UserRestrictionsNoSend'},\n      {flags: ['send_media'], text: 'UserRestrictionsSendMedia', exceptionText: 'UserRestrictionsNoSendMedia'},\n      {flags: ['send_stickers', 'send_gifs'], text: 'UserRestrictionsSendStickers', exceptionText: 'UserRestrictionsNoSendStickers'},\n      {flags: ['send_polls'], text: 'UserRestrictionsSendPolls', exceptionText: 'UserRestrictionsNoSendPolls'},\n      {flags: ['embed_links'], text: 'UserRestrictionsEmbedLinks', exceptionText: 'UserRestrictionsNoEmbedLinks'},\n      {flags: ['invite_users'], text: 'UserRestrictionsInviteUsers', exceptionText: 'UserRestrictionsNoInviteUsers'},\n      {flags: ['pin_messages'], text: 'UserRestrictionsPinMessages', exceptionText: 'UserRestrictionsNoPinMessages'},\n      {flags: ['change_info'], text: 'UserRestrictionsChangeInfo', exceptionText: 'UserRestrictionsNoChangeInfo'}\n    ];\n\n    this.toggleWith = {\n      'send_messages': ['send_media', 'send_stickers', 'send_polls', 'embed_links']\n    };\n\n    const chat: Chat.chat = appChatsManager.getChat(options.chatId);\n    const defaultBannedRights = chat.default_banned_rights;\n    const rights = options.participant ? appChatsManager.combineParticipantBannedRights(options.chatId, options.participant.banned_rights) : defaultBannedRights;\n    \n    for(const info of this.v) {\n      const mainFlag = info.flags[0];\n      info.checkboxField = new CheckboxField({\n        text: info.text,\n        checked: appChatsManager.hasRights(options.chatId, mainFlag, rights),\n        restriction: true,\n        withRipple: true\n      });\n\n      // @ts-ignore\n      if(options.participant && defaultBannedRights.pFlags[mainFlag]) {\n        info.checkboxField.input.disabled = true;\n        \n        /* options.listenerSetter.add(info.checkboxField.input)('change', (e) => {\n          if(!e.isTrusted) {\n            return;\n          }\n\n          cancelEvent(e);\n          toast('This option is disabled for all members in Group Permissions.');\n          info.checkboxField.checked = false;\n        }); */\n\n        attachClickEvent(info.checkboxField.label, (e) => {\n          toast(I18n.format('UserRestrictionsDisabled', true));\n        }, {listenerSetter: options.listenerSetter});\n      }\n\n      if(this.toggleWith[mainFlag]) {\n        options.listenerSetter.add(info.checkboxField.input)('change', () => {\n          if(!info.checkboxField.checked) {\n            const other = this.v.filter(i => this.toggleWith[mainFlag].includes(i.flags[0]));\n            other.forEach(info => {\n              info.checkboxField.checked = false;\n            });\n          }\n        });\n      }\n\n      options.appendTo.append(info.checkboxField.label);\n    }\n  }\n\n  public takeOut() {\n    const rights: ChatBannedRights = {\n      _: 'chatBannedRights',\n      until_date: 0x7FFFFFFF,\n      pFlags: {}\n    };\n\n    for(const info of this.v) {\n      const banned = !info.checkboxField.checked;\n      if(banned) {\n        info.flags.forEach(flag => {\n          // @ts-ignore\n          rights.pFlags[flag] = true;\n        });\n      }\n    }\n\n    return rights;\n  }\n}\n\nexport default class AppGroupPermissionsTab extends SliderSuperTabEventable {\n  public chatId: number;\n\n  protected async init() {\n    this.container.classList.add('edit-peer-container', 'group-permissions-container');\n    this.setTitle('ChannelPermissions');\n\n    let chatPermissions: ChatPermissions;\n    {\n      const section = new SettingSection({\n        name: 'ChannelPermissionsHeader',\n      });\n\n      chatPermissions = new ChatPermissions({\n        chatId: this.chatId,\n        listenerSetter: this.listenerSetter,\n        appendTo: section.content,\n      });\n\n      this.eventListener.addEventListener('destroy', () => {\n        appChatsManager.editChatDefaultBannedRights(this.chatId, chatPermissions.takeOut());\n      }, {once: true});\n\n      this.scrollable.append(section.container);\n    }\n    \n    {\n      const section = new SettingSection({\n        name: 'PrivacyExceptions'\n      });\n\n      const addExceptionRow = new Row({\n        titleLangKey: 'ChannelAddException',\n        subtitleLangKey: 'Loading',\n        icon: 'adduser',\n        clickable: () => {\n          new PopupPickUser({\n            peerTypes: ['channelParticipants'],\n            onSelect: (peerId) => {\n              setTimeout(() => {\n                openPermissions(peerId);\n              }, 0);\n            },\n            placeholder: 'ExceptionModal.Search.Placeholder',\n            peerId: -this.chatId,\n          });\n        }\n      });\n\n      const openPermissions = async(peerId: number) => {\n        let participant: AppUserPermissionsTab['participant'];\n        try {\n          participant = await appProfileManager.getChannelParticipant(this.chatId, peerId) as any;\n        } catch(err) {\n          toast('User is no longer participant');\n          return;\n        }\n\n        const tab = new AppUserPermissionsTab(this.slider);\n        tab.participant = participant;\n        tab.chatId = this.chatId;\n        tab.userId = peerId;\n        tab.open();\n      };\n\n      section.content.append(addExceptionRow.container);\n\n      /* const removedUsersRow = new Row({\n        titleLangKey: 'ChannelBlockedUsers',\n        subtitleLangKey: 'NoBlockedUsers',\n        icon: 'deleteuser',\n        clickable: true\n      });\n\n      section.content.append(removedUsersRow.container); */\n\n      const c = section.generateContentElement();\n      c.classList.add('chatlist-container');\n      \n      const list = appDialogsManager.createChatList({new: true});\n      c.append(list);\n\n      attachClickEvent(list, (e) => {\n        const target = findUpTag(e.target, 'LI');\n        if(!target) return;\n\n        const peerId = +target.dataset.peerId;\n        openPermissions(peerId);\n      }, {listenerSetter: this.listenerSetter});\n\n      const setSubtitle = (li: Element, participant: ChannelParticipant.channelParticipantBanned) => {\n        const bannedRights = participant.banned_rights;//appChatsManager.combineParticipantBannedRights(this.chatId, participant.banned_rights);\n        const defaultBannedRights = (appChatsManager.getChat(this.chatId) as Chat.channel).default_banned_rights;\n        //const combinedRights = appChatsManager.combineParticipantBannedRights(this.chatId, bannedRights);\n\n        const cantWhat: LangPackKey[] = []/* , canWhat: LangPackKey[] = [] */;\n        chatPermissions.v.forEach(info => {\n          const mainFlag = info.flags[0];\n          // @ts-ignore\n          if(bannedRights.pFlags[mainFlag] && !defaultBannedRights.pFlags[mainFlag]) {\n            cantWhat.push(info.exceptionText);\n          // @ts-ignore\n          }/*  else if(!combinedRights.pFlags[mainFlag]) {\n            canWhat.push(info.exceptionText);\n          } */\n        });\n\n        const el = li.querySelector('.user-last-message') as HTMLElement;\n\n        if(cantWhat.length) {\n          el.innerHTML = '';\n          el.append(...join(cantWhat.map(t => i18n(t)), false));\n        }/*  else if(canWhat.length) {\n          str = 'Can ' + canWhat.join(canWhat.length === 2 ? ' and ' : ', ');\n        } */\n  \n        el.classList.toggle('hide', !cantWhat.length);\n      };\n\n      const add = (participant: ChannelParticipant.channelParticipantBanned, append: boolean) => {\n        const {dom} = appDialogsManager.addDialogNew({\n          dialog: appPeersManager.getPeerId(participant.peer),\n          container: list,\n          drawStatus: false,\n          rippleEnabled: true,\n          avatarSize: 48,\n          append\n        });\n\n        setSubtitle(dom.listEl, participant);\n\n        //dom.titleSpan.innerHTML = 'Chinaza Akachi';\n        //dom.lastMessageSpan.innerHTML = 'Can Add Users and Pin Messages';\n      };\n\n      this.listenerSetter.add(rootScope)('updateChannelParticipant', (update: Update.updateChannelParticipant) => {\n        const needAdd = update.new_participant?._ === 'channelParticipantBanned' && !update.new_participant.banned_rights.pFlags.view_messages;\n        const li = list.querySelector(`[data-peer-id=\"${update.user_id}\"]`);\n        if(needAdd) {\n          if(!li) {\n            add(update.new_participant as ChannelParticipant.channelParticipantBanned, false);\n          } else {\n            setSubtitle(li, update.new_participant as ChannelParticipant.channelParticipantBanned);\n          }\n\n          if(update.prev_participant?._ !== 'channelParticipantBanned') {\n            ++exceptionsCount;\n          }\n        } else {\n          if(li) {\n            li.remove();\n          }\n\n          if(update.prev_participant?._ === 'channelParticipantBanned') {\n            --exceptionsCount;\n          }\n        }\n\n        setLength();\n      });\n\n      const setLength = () => {\n        replaceContent(addExceptionRow.subtitle, i18n(exceptionsCount ? 'Permissions.ExceptionsCount' : 'Permissions.NoExceptions', [exceptionsCount]));\n      };\n\n      let exceptionsCount = 0;\n      const LOAD_COUNT = 50;\n      const loader = new ScrollableLoader({\n        scrollable: this.scrollable,\n        getPromise: () => {\n          return appProfileManager.getChannelParticipants(this.chatId, {_: 'channelParticipantsBanned', q: ''}, LOAD_COUNT, list.childElementCount).then(res => {\n            for(const participant of res.participants) {\n              add(participant as ChannelParticipant.channelParticipantBanned, true);\n            }\n\n            exceptionsCount = res.count;\n            setLength();\n\n            return res.participants.length < LOAD_COUNT || res.count === list.childElementCount;\n          });\n        }\n      });\n\n      this.scrollable.append(section.container);\n\n      await loader.load();\n    }\n  }\n\n  onOpenAfterTimeout() {\n    this.scrollable.onScroll();\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport appImManager from \"../../../lib/appManagers/appImManager\";\nimport appMessagesManager, { AppMessagesManager } from \"../../../lib/appManagers/appMessagesManager\";\nimport appPeersManager from \"../../../lib/appManagers/appPeersManager\";\nimport appProfileManager from \"../../../lib/appManagers/appProfileManager\";\nimport appUsersManager, { User } from \"../../../lib/appManagers/appUsersManager\";\nimport { RichTextProcessor } from \"../../../lib/richtextprocessor\";\nimport rootScope from \"../../../lib/rootScope\";\nimport AppSearchSuper, { SearchSuperType } from \"../../appSearchSuper.\";\nimport AvatarElement, { openAvatarViewer } from \"../../avatar\";\nimport SidebarSlider, { SliderSuperTab } from \"../../slider\";\nimport CheckboxField from \"../../checkboxField\";\nimport appSidebarRight from \"..\";\nimport { TransitionSlider } from \"../../transition\";\nimport appNotificationsManager from \"../../../lib/appManagers/appNotificationsManager\";\nimport AppEditChatTab from \"./editChat\";\nimport PeerTitle from \"../../peerTitle\";\nimport AppEditContactTab from \"./editContact\";\nimport appChatsManager, { Channel } from \"../../../lib/appManagers/appChatsManager\";\nimport { Chat, Message, MessageAction, ChatFull, Photo } from \"../../../layer\";\nimport Button from \"../../button\";\nimport ButtonIcon from \"../../buttonIcon\";\nimport I18n, { i18n, LangPackKey } from \"../../../lib/langPack\";\nimport { generateDelimiter, SettingSection } from \"../../sidebarLeft\";\nimport Row from \"../../row\";\nimport { copyTextToClipboard } from \"../../../helpers/clipboard\";\nimport { toast, toastNew } from \"../../toast\";\nimport { fastRaf } from \"../../../helpers/schedulers\";\nimport { safeAssign } from \"../../../helpers/object\";\nimport { forEachReverse } from \"../../../helpers/array\";\nimport appPhotosManager from \"../../../lib/appManagers/appPhotosManager\";\nimport renderImageFromUrl from \"../../../helpers/dom/renderImageFromUrl\";\nimport SwipeHandler from \"../../swipeHandler\";\nimport { MOUNT_CLASS_TO } from \"../../../config/debug\";\nimport AppAddMembersTab from \"../../sidebarLeft/tabs/addMembers\";\nimport PopupPickUser from \"../../popups/pickUser\";\nimport PopupPeer, { PopupPeerButtonCallbackCheckboxes, PopupPeerCheckboxOptions } from \"../../popups/peer\";\nimport Scrollable from \"../../scrollable\";\nimport { isTouchSupported } from \"../../../helpers/touchSupport\";\nimport { isFirefox } from \"../../../helpers/userAgent\";\nimport appDownloadManager from \"../../../lib/appManagers/appDownloadManager\";\nimport ButtonCorner from \"../../buttonCorner\";\nimport { cancelEvent } from \"../../../helpers/dom/cancelEvent\";\nimport { attachClickEvent } from \"../../../helpers/dom/clickEvent\";\nimport replaceContent from \"../../../helpers/dom/replaceContent\";\nimport appAvatarsManager from \"../../../lib/appManagers/appAvatarsManager\";\n\nlet setText = (text: string, row: Row) => {\n  //fastRaf(() => {\n    row.title.innerHTML = text;\n    row.container.style.display = '';\n  //});\n};\n\nconst PARALLAX_SUPPORTED = !isFirefox;\n\ntype ListLoaderResult<T> = {count: number, items: any[]};\nclass ListLoader<T> {\n  public current: T;\n  public previous: T[] = [];\n  public next: T[] = [];\n  public count: number;\n\n  public tempId = 0;\n  public loadMore: (anchor: T, older: boolean) => Promise<ListLoaderResult<T>>;\n  public processItem: (item: any) => false | T;\n  public onJump: (item: T, older: boolean) => void;\n  public loadCount = 50;\n  public reverse = false; // reverse means next = higher msgid\n\n  public loadedAllUp = false;\n  public loadedAllDown = false;\n  public loadPromiseUp: Promise<void>;\n  public loadPromiseDown: Promise<void>;\n\n  constructor(options: {\n    loadMore: ListLoader<T>['loadMore'],\n    loadCount: ListLoader<T>['loadCount'],\n    processItem?: ListLoader<T>['processItem'],\n    onJump: ListLoader<T>['onJump'],\n  }) {\n    safeAssign(this, options);\n\n\n  }\n\n  get index() {\n    return this.count !== undefined ? this.previous.length : -1;\n  }\n\n  public go(length: number) {\n    let items: T[], item: T;\n    if(length > 0) {\n      items = this.next.splice(0, length);\n      item = items.pop();\n      if(!item) {\n        return;\n      }\n\n      this.previous.push(this.current, ...items);\n    } else {\n      items = this.previous.splice(this.previous.length + length, -length);\n      item = items.shift();\n      if(!item) {\n        return;\n      }\n\n      this.next.unshift(...items, this.current);\n    }\n\n    this.current = item;\n    this.onJump(item, length > 0);\n  }\n\n  public load(older: boolean) {\n    if(older && this.loadedAllDown) return Promise.resolve();\n    else if(!older && this.loadedAllUp) return Promise.resolve();\n\n    if(older && this.loadPromiseDown) return this.loadPromiseDown;\n    else if(!older && this.loadPromiseUp) return this.loadPromiseUp;\n\n    /* const loadCount = 50;\n    const backLimit = older ? 0 : loadCount; */\n  \n    let anchor: T;\n    if(older) {\n      anchor = this.reverse ? this.previous[0] : this.next[this.next.length - 1];\n    } else {\n      anchor = this.reverse ? this.next[this.next.length - 1] : this.previous[0];\n    }\n\n    const promise = this.loadMore(anchor, older).then(result => {\n      if(result.items.length < this.loadCount) {\n        if(older) this.loadedAllDown = true;\n        else this.loadedAllUp = true;\n      }\n\n      if(this.count === undefined) {\n        this.count = result.count || result.items.length;\n      }\n\n      const method = older ? result.items.forEach.bind(result.items) : forEachReverse.bind(null, result.items);\n      method((item: any) => {\n        const processed = this.processItem ? this.processItem(item) : item;\n\n        if(!processed) return;\n\n        if(older) {\n          if(this.reverse) this.previous.unshift(processed);\n          else this.next.push(processed);\n        } else {\n          if(this.reverse) this.next.push(processed);\n          else this.previous.unshift(processed);\n        }\n      });\n    }, () => {}).then(() => {\n      if(older) this.loadPromiseDown = null;\n      else this.loadPromiseUp = null;\n    });\n\n    if(older) this.loadPromiseDown = promise;\n    else this.loadPromiseUp = promise;\n\n    return promise;\n  }\n}\n\nclass PeerProfileAvatars {\n  private static BASE_CLASS = 'profile-avatars';\n  private static SCALE = PARALLAX_SUPPORTED ? 2 : 1;\n  private static TRANSLATE_TEMPLATE = PARALLAX_SUPPORTED ? `translate3d({x}, 0, -1px) scale(${PeerProfileAvatars.SCALE})` : 'translate({x}, 0)';\n  public container: HTMLElement;\n  public avatars: HTMLElement;\n  public gradient: HTMLElement;\n  public info: HTMLElement;\n  public arrowPrevious: HTMLElement;\n  public arrowNext: HTMLElement;\n  private tabs: HTMLDivElement;\n  private listLoader: ListLoader<string | Message.messageService>;\n  private peerId: number;\n\n  constructor(public scrollable: Scrollable) {\n    this.container = document.createElement('div');\n    this.container.classList.add(PeerProfileAvatars.BASE_CLASS + '-container');\n\n    this.avatars = document.createElement('div');\n    this.avatars.classList.add(PeerProfileAvatars.BASE_CLASS + '-avatars');\n\n    this.gradient = document.createElement('div');\n    this.gradient.classList.add(PeerProfileAvatars.BASE_CLASS + '-gradient');\n\n    this.info = document.createElement('div');\n    this.info.classList.add(PeerProfileAvatars.BASE_CLASS + '-info');\n\n    this.tabs = document.createElement('div');\n    this.tabs.classList.add(PeerProfileAvatars.BASE_CLASS + '-tabs');\n\n    this.arrowPrevious = document.createElement('div');\n    this.arrowPrevious.classList.add(PeerProfileAvatars.BASE_CLASS + '-arrow');\n\n    /* const previousIcon = document.createElement('i');\n    previousIcon.classList.add(PeerProfileAvatars.BASE_CLASS + '-arrow-icon', 'tgico-previous');\n    this.arrowBack.append(previousIcon); */\n    \n    this.arrowNext = document.createElement('div');\n    this.arrowNext.classList.add(PeerProfileAvatars.BASE_CLASS + '-arrow', PeerProfileAvatars.BASE_CLASS + '-arrow-next');\n\n    /* const nextIcon = document.createElement('i');\n    nextIcon.classList.add(PeerProfileAvatars.BASE_CLASS + '-arrow-icon', 'tgico-next');\n    this.arrowNext.append(nextIcon); */\n\n    this.container.append(this.avatars, this.gradient, this.info, this.tabs, this.arrowPrevious, this.arrowNext);\n\n    const checkScrollTop = () => {\n      if(this.scrollable.scrollTop !== 0) {\n        this.scrollable.scrollIntoViewNew(this.scrollable.container.firstElementChild as HTMLElement, 'start');\n        return false;\n      }\n\n      return true;\n    };\n\n    const SWITCH_ZONE = 1 / 3;\n    let cancel = false;\n    let freeze = false;\n    attachClickEvent(this.container, async(_e) => {\n      if(freeze) {\n        cancelEvent(_e);\n        return;\n      }\n\n      if(cancel) {\n        cancel = false;\n        return;\n      }\n\n      if(!checkScrollTop()) {\n        return;\n      }\n\n      const rect = this.container.getBoundingClientRect();\n\n      const e = (_e as TouchEvent).touches ? (_e as TouchEvent).touches[0] : _e as MouseEvent;\n      const x = e.pageX;\n\n      const clickX = x - rect.left;\n      if((!this.listLoader.previous.length && !this.listLoader.next.length) \n        || (clickX > (rect.width * SWITCH_ZONE) && clickX < (rect.width - rect.width * SWITCH_ZONE))) {\n        const peerId = this.peerId;\n\n        const targets: {element: HTMLElement, item: string | Message.messageService}[] = [];\n        this.listLoader.previous.concat(this.listLoader.current, this.listLoader.next).forEach((item, idx) => {\n          targets.push({\n            element: /* null */this.avatars.children[idx] as HTMLElement,\n            item\n          });\n        });\n\n        const prevTargets = targets.slice(0, this.listLoader.previous.length);\n        const nextTargets = targets.slice(this.listLoader.previous.length + 1);\n\n        const target = this.avatars.children[this.listLoader.previous.length] as HTMLElement;\n        freeze = true;\n        openAvatarViewer(target, peerId, () => peerId === this.peerId, this.listLoader.current, prevTargets, nextTargets);\n        freeze = false;\n      } else {\n        const centerX = rect.right - (rect.width / 2);\n        const toRight = x > centerX;\n  \n        // this.avatars.classList.remove('no-transition');\n        // fastRaf(() => {\n          this.avatars.classList.add('no-transition');\n          void this.avatars.offsetLeft; // reflow\n\n          let distance: number;\n          if(this.listLoader.index === 0 && !toRight) distance = this.listLoader.count - 1;\n          else if(this.listLoader.index === (this.listLoader.count - 1) && toRight) distance = -(this.listLoader.count - 1);\n          else distance = toRight ? 1 : -1;\n          this.listLoader.go(distance);\n\n          fastRaf(() => {\n            this.avatars.classList.remove('no-transition');\n          });\n        // });\n      }\n    });\n\n    const cancelNextClick = () => {\n      cancel = true;\n      document.body.addEventListener(isTouchSupported ? 'touchend' : 'click', (e) => {\n        cancel = false;\n      }, {once: true});\n    };\n\n    let width = 0, x = 0, lastDiffX = 0, lastIndex = 0, minX = 0;\n    const swipeHandler = new SwipeHandler({\n      element: this.avatars, \n      onSwipe: (xDiff, yDiff) => {\n        lastDiffX = xDiff;\n        let lastX = x + xDiff * -PeerProfileAvatars.SCALE;\n        if(lastX > 0) lastX = 0;\n        else if(lastX < minX) lastX = minX;\n\n        this.avatars.style.transform = PeerProfileAvatars.TRANSLATE_TEMPLATE.replace('{x}', lastX + 'px');\n        //console.log(xDiff, yDiff);\n        return false;\n      }, \n      verifyTouchTarget: (e) => {\n        if(!checkScrollTop()) {\n          cancelNextClick();\n          cancelEvent(e);\n          return false;\n        } else if(this.container.classList.contains('is-single') || freeze) {\n          return false;\n        }\n\n        return true;\n      }, \n      onFirstSwipe: () => {\n        const rect = this.avatars.getBoundingClientRect();\n        width = rect.width;\n        minX = -width * (this.tabs.childElementCount - 1);\n\n        /* lastIndex = whichChild(this.tabs.querySelector('.active'));\n        x = -width * lastIndex; */\n        x = rect.left - this.container.getBoundingClientRect().left;\n        \n        this.avatars.style.transform = PeerProfileAvatars.TRANSLATE_TEMPLATE.replace('{x}', x + 'px');\n\n        this.container.classList.add('is-swiping');\n        this.avatars.classList.add('no-transition');\n        void this.avatars.offsetLeft; // reflow\n      },\n      onReset: () => {\n        const addIndex = Math.ceil(Math.abs(lastDiffX) / (width / PeerProfileAvatars.SCALE)) * (lastDiffX >= 0 ? 1 : -1);\n        cancelNextClick();\n        \n        //console.log(addIndex);\n\n        this.avatars.classList.remove('no-transition');\n        fastRaf(() => {\n          this.listLoader.go(addIndex);\n          this.container.classList.remove('is-swiping');\n        });\n      }\n    });\n  }\n\n  public setPeer(peerId: number) {\n    this.peerId = peerId;\n\n    const photo = appPeersManager.getPeerPhoto(peerId);\n    if(!photo) {\n      return;\n    }\n\n    const loadCount = 50;\n    const listLoader: PeerProfileAvatars['listLoader'] = this.listLoader = new ListLoader<string | Message.messageService>({\n      loadCount,\n      loadMore: (anchor, older) => {\n        if(peerId > 0) {\n          return appPhotosManager.getUserPhotos(peerId, (anchor || listLoader.current) as any, loadCount).then(result => {\n            return {\n              count: result.count,\n              items: result.photos\n            };\n          });\n        } else {\n          const promises: [Promise<ChatFull>, ReturnType<AppMessagesManager['getSearch']>] = [] as any;\n          if(!listLoader.current) {\n            promises.push(appProfileManager.getChatFull(-peerId));\n          }\n          \n          promises.push(appMessagesManager.getSearch({\n            peerId,\n            maxId: Number.MAX_SAFE_INTEGER,\n            inputFilter: {\n              _: 'inputMessagesFilterChatPhotos'\n            },\n            limit: loadCount,\n            backLimit: 0\n          }));\n\n          return Promise.all(promises).then((result) => {\n            const value = result.pop() as typeof result[1];\n\n            if(!listLoader.current) {\n              const chatFull = result[0];\n              const message = value.history.findAndSplice(m => {\n                return ((m as Message.messageService).action as MessageAction.messageActionChannelEditPhoto).photo.id === chatFull.chat_photo.id;\n              }) as Message.messageService;\n              \n              listLoader.current = message || appMessagesManager.generateFakeAvatarMessage(this.peerId, chatFull.chat_photo);\n            }\n\n            //console.log('avatars loaded:', value);\n            return {\n              count: value.count,\n              items: value.history\n            };\n          });\n        }\n      },\n      processItem: this.processItem,\n      onJump: (item, older) => {\n        const id = this.listLoader.index;\n        //const nextId = Math.max(0, id);\n        const x = 100 * PeerProfileAvatars.SCALE * id;\n        this.avatars.style.transform = PeerProfileAvatars.TRANSLATE_TEMPLATE.replace('{x}', `-${x}%`);\n\n        const activeTab = this.tabs.querySelector('.active');\n        if(activeTab) activeTab.classList.remove('active');\n\n        const tab = this.tabs.children[id] as HTMLElement;\n        tab.classList.add('active');\n      }\n    });\n\n    if(photo._ === 'userProfilePhoto') {\n      listLoader.current = photo.photo_id;\n    }\n\n    this.processItem(listLoader.current);\n\n    listLoader.load(true);\n  }\n\n  public addTab() {\n    const tab = document.createElement('div');\n    tab.classList.add(PeerProfileAvatars.BASE_CLASS + '-tab');\n    this.tabs.append(tab);\n\n    if(this.tabs.childElementCount === 1) {\n      tab.classList.add('active');\n    }\n\n    this.container.classList.toggle('is-single', this.tabs.childElementCount <= 1);\n  }\n\n  public processItem = (photoId: string | Message.messageService) => {\n    const avatar = document.createElement('div');\n    avatar.classList.add(PeerProfileAvatars.BASE_CLASS + '-avatar');\n\n    let photo: Photo.photo;\n    if(photoId) {\n      photo = typeof(photoId) === 'string' ? \n        appPhotosManager.getPhoto(photoId) : \n        (photoId.action as MessageAction.messageActionChannelEditPhoto).photo as Photo.photo;\n    }\n\n    const img = new Image();\n    img.classList.add(PeerProfileAvatars.BASE_CLASS + '-avatar-image');\n    img.draggable = false;\n\n    if(photo) {\n      const size = appPhotosManager.choosePhotoSize(photo, 420, 420, false);\n      appPhotosManager.preloadPhoto(photo, size).then(() => {\n        const cacheContext = appDownloadManager.getCacheContext(photo, size.type);\n        renderImageFromUrl(img, cacheContext.url, () => {\n          avatar.append(img);\n        });\n      });\n    } else {\n      const photo = appPeersManager.getPeerPhoto(this.peerId);\n      appAvatarsManager.putAvatar(avatar, this.peerId, photo, 'photo_big', img);\n    }\n\n    this.avatars.append(avatar);\n\n    this.addTab();\n\n    return photoId;\n  };\n}\n\nclass PeerProfile {\n  public element: HTMLElement;\n  public avatars: PeerProfileAvatars;\n  private avatar: AvatarElement;\n  private section: SettingSection;\n  private name: HTMLDivElement;\n  private subtitle: HTMLDivElement;\n  private bio: Row;\n  private username: Row;\n  private phone: Row;\n  private notifications: Row;\n  \n  private cleaned: boolean;\n  private setBioTimeout: number;\n  private setPeerStatusInterval: number;\n\n  private peerId = 0;\n  private threadId: number;\n\n  constructor(public scrollable: Scrollable) {\n    if(!PARALLAX_SUPPORTED) {\n      this.scrollable.container.classList.add('no-parallax');\n    }\n  }\n\n  public init() {\n    this.init = null;\n\n    this.element = document.createElement('div');\n    this.element.classList.add('profile-content');\n\n    this.section = new SettingSection({\n      noDelimiter: true\n    });\n\n    this.avatar = new AvatarElement();\n    this.avatar.classList.add('profile-avatar', 'avatar-120');\n    this.avatar.setAttribute('dialog', '1');\n    this.avatar.setAttribute('clickable', '');\n\n    this.name = document.createElement('div');\n    this.name.classList.add('profile-name');\n\n    this.subtitle = document.createElement('div');\n    this.subtitle.classList.add('profile-subtitle');\n\n    this.bio = new Row({\n      title: ' ',\n      subtitleLangKey: 'UserBio',\n      icon: 'info',\n      clickable: (e) => {\n        if((e.target as HTMLElement).tagName === 'A') {\n          return;\n        }\n        \n        appProfileManager.getProfileByPeerId(this.peerId).then(full => {\n          copyTextToClipboard(full.about);\n          toast(I18n.format('BioCopied', true));\n        });\n      }\n    });\n\n    this.bio.title.classList.add('pre-wrap');\n\n    this.username = new Row({\n      title: ' ',\n      subtitleLangKey: 'Username',\n      icon: 'username',\n      clickable: () => {\n        const peer: Channel | User = appPeersManager.getPeer(this.peerId);\n        copyTextToClipboard('@' + peer.username);\n        toast(I18n.format('UsernameCopied', true));\n      }\n    });\n\n    this.phone = new Row({\n      title: ' ',\n      subtitleLangKey: 'Phone',\n      icon: 'phone',\n      clickable: () => {\n        const peer: User = appUsersManager.getUser(this.peerId);\n        copyTextToClipboard('+' + peer.phone);\n        toast(I18n.format('PhoneCopied', true));\n      }\n    });\n\n    this.notifications = new Row({\n      checkboxField: new CheckboxField({toggle: true}),\n      titleLangKey: 'Notifications',\n      icon: 'unmute'\n    });\n    \n    this.section.content.append(this.phone.container, this.username.container, this.bio.container, this.notifications.container);\n\n    this.element.append(this.section.container, generateDelimiter());\n\n    this.notifications.checkboxField.input.addEventListener('change', (e) => {\n      if(!e.isTrusted) {\n        return;\n      }\n\n      //let checked = this.notificationsCheckbox.checked;\n      appMessagesManager.mutePeer(this.peerId);\n    });\n\n    rootScope.addEventListener('dialog_notify_settings', (dialog) => {\n      if(this.peerId === dialog.peerId) {\n        const muted = appNotificationsManager.isPeerLocalMuted(this.peerId, false);\n        this.notifications.checkboxField.checked = !muted;\n      }\n    });\n\n    rootScope.addEventListener('peer_typings', (e) => {\n      const {peerId} = e;\n\n      if(this.peerId === peerId) {\n        this.setPeerStatus();\n      }\n    });\n\n    rootScope.addEventListener('peer_bio_edit', (peerId) => {\n      if(peerId === this.peerId) {\n        this.setBio(true);\n      }\n    });\n\n    rootScope.addEventListener('user_update', (e) => {\n      const userId = e;\n\n      if(this.peerId === userId) {\n        this.setPeerStatus();\n      }\n    });\n\n    this.setPeerStatusInterval = window.setInterval(this.setPeerStatus, 60e3);\n  }\n\n  public setPeerStatus = (needClear = false) => {\n    if(!this.peerId) return;\n\n    const peerId = this.peerId;\n    appImManager.setPeerStatus(this.peerId, this.subtitle, needClear, true, () => peerId === this.peerId);\n  };\n\n  public cleanupHTML() {\n    this.bio.container.style.display = 'none';\n    this.phone.container.style.display = 'none';\n    this.username.container.style.display = 'none';\n    this.notifications.container.style.display = '';\n    this.notifications.checkboxField.checked = true;\n    if(this.setBioTimeout) {\n      window.clearTimeout(this.setBioTimeout);\n      this.setBioTimeout = 0;\n    }\n  }\n\n  public setAvatar() {\n    if(this.peerId !== rootScope.myId) {\n      const photo = appPeersManager.getPeerPhoto(this.peerId);\n\n      if(photo) {\n        const oldAvatars = this.avatars;\n        this.avatars = new PeerProfileAvatars(this.scrollable);\n        this.avatars.setPeer(this.peerId);\n        this.avatars.info.append(this.name, this.subtitle);\n  \n        this.avatar.remove();\n    \n        if(oldAvatars) oldAvatars.container.replaceWith(this.avatars.container);\n        else this.element.prepend(this.avatars.container);\n\n        if(PARALLAX_SUPPORTED) {\n          this.scrollable.container.classList.add('parallax');\n        }\n\n        return;\n      }\n    }\n\n    if(PARALLAX_SUPPORTED) {\n      this.scrollable.container.classList.remove('parallax');\n    }\n\n    if(this.avatars) {\n      this.avatars.container.remove();\n      this.avatars = undefined;\n    }\n\n    this.avatar.setAttribute('peer', '' + this.peerId);\n\n    this.section.content.prepend(this.avatar, this.name, this.subtitle);\n  }\n\n  public fillProfileElements() {\n    if(!this.cleaned) return;\n    this.cleaned = false;\n    \n    const peerId = this.peerId;\n\n    this.cleanupHTML();\n\n    this.setAvatar();\n\n    // username\n    if(peerId !== rootScope.myId) {\n      let username = appPeersManager.getPeerUsername(peerId);\n      if(username) {\n        setText(appPeersManager.getPeerUsername(peerId), this.username);\n      }\n      \n      const muted = appNotificationsManager.isPeerLocalMuted(peerId, false);\n      this.notifications.checkboxField.checked = !muted;\n    } else {\n      window.requestAnimationFrame(() => {\n        this.notifications.container.style.display = 'none';\n      });\n    }\n    \n    //let membersLi = this.profileTabs.firstElementChild.children[0] as HTMLLIElement;\n    if(peerId > 0) {\n      //membersLi.style.display = 'none';\n\n      let user = appUsersManager.getUser(peerId);\n      if(user.phone && peerId !== rootScope.myId) {\n        setText(appUsersManager.formatUserPhone(user.phone), this.phone);\n      }\n    }/*  else {\n      //membersLi.style.display = appPeersManager.isBroadcast(peerId) ? 'none' : '';\n    } */\n\n    this.setBio();\n\n    replaceContent(this.name, new PeerTitle({\n      peerId,\n      dialog: true\n    }).element);\n\n    this.setPeerStatus(true);\n  }\n\n  public setBio(override?: true) {\n    if(this.setBioTimeout) {\n      window.clearTimeout(this.setBioTimeout);\n      this.setBioTimeout = 0;\n    }\n\n    const peerId = this.peerId;\n    const threadId = this.threadId;\n\n    if(!peerId) {\n      return;\n    }\n\n    let promise: Promise<boolean>;\n    if(peerId > 0) {\n      promise = appProfileManager.getProfile(peerId, override).then(userFull => {\n        if(this.peerId !== peerId || this.threadId !== threadId) {\n          //this.log.warn('peer changed');\n          return false;\n        }\n        \n        if(userFull.rAbout && peerId !== rootScope.myId) {\n          setText(userFull.rAbout, this.bio);\n        }\n        \n        //this.log('userFull', userFull);\n        return true;\n      });\n    } else {\n      promise = appProfileManager.getChatFull(-peerId, override).then((chatFull) => {\n        if(this.peerId !== peerId || this.threadId !== threadId) {\n          //this.log.warn('peer changed');\n          return false;\n        }\n        \n        //this.log('chatInfo res 2:', chatFull);\n        \n        if(chatFull.about) {\n          setText(RichTextProcessor.wrapRichText(chatFull.about), this.bio);\n        }\n\n        return true;\n      });\n    }\n\n    promise.then((canSetNext) => {\n      if(canSetNext) {\n        this.setBioTimeout = window.setTimeout(() => this.setBio(true), 60e3);\n      }\n    });\n  }\n\n  public setPeer(peerId: number, threadId = 0) {\n    if(this.peerId === peerId && this.threadId === peerId) return;\n\n    if(this.init) {\n      this.init();\n    }\n\n    this.peerId = peerId;\n    this.threadId = threadId;\n    \n    this.cleaned = true;\n  }\n}\n\n// TODO: \u043e\u0442\u0440\u0435\u0434\u0430\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043d\u0435 \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u0441\u044f\nexport default class AppSharedMediaTab extends SliderSuperTab {\n  private editBtn: HTMLElement;\n\n  private peerId = 0;\n  private threadId = 0;\n\n  private historiesStorage: {\n    [peerId: number]: Partial<{\n      [type in SearchSuperType]: {mid: number, peerId: number}[]\n    }>\n  } = {};\n\n  private searchSuper: AppSearchSuper;\n\n  private profile: PeerProfile;\n  peerChanged: boolean;\n\n  constructor(slider: SidebarSlider) {\n    super(slider, false);\n  }\n\n  public init() {\n    //const perf = performance.now();\n\n    this.container.classList.add('shared-media-container', 'profile-container');\n\n    // * header\n    const newCloseBtn = Button('btn-icon sidebar-close-button', {noRipple: true});\n    this.closeBtn.replaceWith(newCloseBtn);\n    this.closeBtn = newCloseBtn;\n\n    const animatedCloseIcon = document.createElement('div');\n    animatedCloseIcon.classList.add('animated-close-icon');\n    newCloseBtn.append(animatedCloseIcon);\n\n    const transitionContainer = document.createElement('div');\n    transitionContainer.className = 'transition slide-fade';\n    \n    const transitionFirstItem = document.createElement('div');\n    transitionFirstItem.classList.add('transition-item');\n\n    this.title.append(i18n('Profile'));\n    this.editBtn = ButtonIcon('edit');\n    //const moreBtn = ButtonIcon('more');\n\n    transitionFirstItem.append(this.title, this.editBtn/* , moreBtn */);\n\n    const transitionLastItem = document.createElement('div');\n    transitionLastItem.classList.add('transition-item');\n\n    const secondTitle: HTMLElement = this.title.cloneNode() as any;\n    secondTitle.append(i18n('PeerInfo.SharedMedia'));\n\n    transitionLastItem.append(secondTitle);\n\n    transitionContainer.append(transitionFirstItem, transitionLastItem);\n\n    this.header.append(transitionContainer);\n\n    // * body\n\n    this.profile = new PeerProfile(this.scrollable);\n    this.profile.init();\n    \n    this.scrollable.append(this.profile.element);\n\n    const HEADER_HEIGHT = 56;\n    this.scrollable.onAdditionalScroll = () => {\n      const rect = this.searchSuper.nav.getBoundingClientRect(); \n      if(!rect.width) return;\n\n      const top = rect.top - 1;\n      const isSharedMedia = top <= HEADER_HEIGHT;\n      animatedCloseIcon.classList.toggle('state-back', isSharedMedia);\n      this.searchSuper.container.classList.toggle('is-full-viewport', isSharedMedia);\n      transition(+isSharedMedia);\n\n      if(!isSharedMedia) {\n        this.searchSuper.cleanScrollPositions();\n      }\n    };\n\n    const transition = TransitionSlider(transitionContainer, 'slide-fade', 400, null, false);\n\n    transition(0);\n\n    attachClickEvent(this.closeBtn, (e) => {\n      if(this.closeBtn.firstElementChild.classList.contains('state-back')) {\n        this.scrollable.scrollIntoViewNew(this.scrollable.container.firstElementChild as HTMLElement, 'start');\n        transition(0);\n        animatedCloseIcon.classList.remove('state-back');\n      } else if(!this.scrollable.isHeavyAnimationInProgress) {\n        appSidebarRight.onCloseBtnClick();\n      }\n    });\n\n    attachClickEvent(this.editBtn, (e) => {\n      let tab: AppEditChatTab | AppEditContactTab;\n      if(this.peerId < 0) {\n        tab = new AppEditChatTab(appSidebarRight);\n      } else {\n        tab = new AppEditContactTab(appSidebarRight);\n      }\n\n      if(tab) {\n        if(tab instanceof AppEditChatTab) {\n          tab.chatId = -this.peerId;\n        } else {\n          tab.peerId = this.peerId;\n        }\n        \n        tab.open();\n      }\n    });\n\n    //this.container.prepend(this.closeBtn.parentElement);\n\n    this.searchSuper = new AppSearchSuper({\n      mediaTabs: [{\n        inputFilter: 'inputMessagesFilterEmpty',\n        name: 'PeerMedia.Members',\n        type: 'members'\n      }, {\n        inputFilter: 'inputMessagesFilterPhotoVideo',\n        name: 'SharedMediaTab2',\n        type: 'media'\n      }, {\n        inputFilter: 'inputMessagesFilterDocument',\n        name: 'SharedFilesTab2',\n        type: 'files'\n      }, {\n        inputFilter: 'inputMessagesFilterUrl',\n        name: 'SharedLinksTab2',\n        type: 'links'\n      }, {\n        inputFilter: 'inputMessagesFilterMusic',\n        name: 'SharedMusicTab2',\n        type: 'music'\n      }, {\n        inputFilter: 'inputMessagesFilterVoice',\n        name: 'SharedVoiceTab2',\n        type: 'voice'\n      }], \n      scrollable: this.scrollable,\n      onChangeTab: (mediaTab) => {\n        let timeout = mediaTab.type === 'members' && rootScope.settings.animationsEnabled ? 250 : 0;\n        setTimeout(() => {\n          btnAddMembers.classList.toggle('is-hidden', mediaTab.type !== 'members');\n        }, timeout);\n      }\n    });\n\n    this.profile.element.append(this.searchSuper.container);\n\n    const btnAddMembers = ButtonCorner({icon: 'addmember_filled'});\n    this.content.append(btnAddMembers);\n\n    btnAddMembers.addEventListener('click', () => {\n      const id = -this.peerId;\n      const isChannel = appChatsManager.isChannel(id);\n\n      const showConfirmation = (peerIds: number[], callback: (checked: PopupPeerButtonCallbackCheckboxes) => void) => {\n        let titleLangKey: LangPackKey, titleLangArgs: any[],\n          descriptionLangKey: LangPackKey, descriptionLangArgs: any[],\n          checkboxes: PopupPeerCheckboxOptions[];\n\n        if(peerIds.length > 1) {\n          titleLangKey = 'AddMembersAlertTitle';\n          titleLangArgs = [i18n('Members', [peerIds.length])];\n          descriptionLangKey = 'AddMembersAlertCountText';\n          descriptionLangArgs = peerIds.map(peerId => {\n            const b = document.createElement('b');\n            b.append(new PeerTitle({peerId}).element);\n            return b;\n          });\n\n          if(!isChannel) {\n            checkboxes = [{\n              text: 'AddMembersForwardMessages',\n              checked: true\n            }];\n          }\n        } else {\n          titleLangKey = 'AddOneMemberAlertTitle';\n          descriptionLangKey = 'AddMembersAlertNamesText';\n          const b = document.createElement('b');\n          b.append(new PeerTitle({\n            peerId: peerIds[0]\n          }).element);\n          descriptionLangArgs = [b];\n\n          if(!isChannel) {\n            checkboxes = [{\n              text: 'AddOneMemberForwardMessages',\n              textArgs: [new PeerTitle({\n                peerId: peerIds[0],\n                onlyFirstName: true\n              }).element],\n              checked: true\n            }];\n          }\n        }\n\n        descriptionLangArgs.push(new PeerTitle({\n          peerId: -id\n        }).element);\n\n        new PopupPeer('popup-add-members', {\n          peerId: -id,\n          titleLangKey,\n          descriptionLangKey,\n          descriptionLangArgs,\n          buttons: [{\n            langKey: 'Add',\n            callback\n          }],\n          checkboxes\n        }).show();\n      };\n\n      const onError = (err: any) => {\n        if(err.type === 'USER_PRIVACY_RESTRICTED') {\n          toastNew({langPackKey: 'InviteToGroupError'});\n        }\n      };\n      \n      if(isChannel) {\n        const tab = new AppAddMembersTab(this.slider);\n        tab.open({\n          peerId: this.peerId,\n          type: 'channel',\n          skippable: false,\n          takeOut: (peerIds) => {\n            showConfirmation(peerIds, () => {\n              const promise = appChatsManager.inviteToChannel(id, peerIds);\n              promise.catch(onError);\n              tab.attachToPromise(promise);\n            });\n\n            return false;\n          },\n          title: 'GroupAddMembers',\n          placeholder: 'SendMessageTo'\n        });\n      } else {\n        new PopupPickUser({\n          peerTypes: ['contacts'],\n          placeholder: 'Search',\n          onSelect: (peerId) => {\n            setTimeout(() => {\n              showConfirmation([peerId], (checked) => {\n                appChatsManager.addChatUser(id, peerId, checked.size ? undefined : 0)\n                .catch(onError);\n              });\n            }, 0);\n          },\n        });\n      }\n    });\n\n    //console.log('construct shared media time:', performance.now() - perf);\n  }\n\n  public renderNewMessages(peerId: number, mids: number[]) {\n    if(this.init) return; // * not inited yet\n\n    if(!this.historiesStorage[peerId]) return;\n    \n    mids = mids.slice().reverse(); // ! because it will be ascend sorted array\n    for(const mediaTab of this.searchSuper.mediaTabs) {\n      const inputFilter = mediaTab.inputFilter;\n      const filtered = this.searchSuper.filterMessagesByType(mids.map(mid => appMessagesManager.getMessageByPeer(peerId, mid)), inputFilter);\n      if(filtered.length) {\n        if(this.historiesStorage[peerId][inputFilter]) {\n          this.historiesStorage[peerId][inputFilter].unshift(...filtered.map(message => ({mid: message.mid, peerId: message.peerId})));\n        }\n\n        if(this.peerId === peerId && this.searchSuper.usedFromHistory[inputFilter] !== -1) {\n          this.searchSuper.usedFromHistory[inputFilter] += filtered.length;\n          this.searchSuper.performSearchResult(filtered, mediaTab, false);\n        }\n\n        break;\n      }\n    }\n  }\n\n  public deleteDeletedMessages(peerId: number, mids: number[]) {\n    if(this.init) return; // * not inited yet\n\n    if(!this.historiesStorage[peerId]) return;\n\n    for(const mid of mids) {\n      for(const type of this.searchSuper.mediaTabs) {\n        const inputFilter = type.inputFilter;\n\n        if(!this.historiesStorage[peerId][inputFilter]) continue;\n\n        const history = this.historiesStorage[peerId][inputFilter];\n        const idx = history.findIndex(m => m.mid === mid);\n        if(idx !== -1) {\n          history.splice(idx, 1);\n\n          if(this.peerId === peerId) {\n            const container = this.searchSuper.tabs[inputFilter];\n            const div = container.querySelector(`div[data-mid=\"${mid}\"][data-peer-id=\"${peerId}\"]`);\n            if(div) {\n              div.remove();\n            }\n  \n            if(this.searchSuper.usedFromHistory[inputFilter] >= (idx + 1)) {\n              this.searchSuper.usedFromHistory[inputFilter]--;\n            }\n          }\n\n          break;\n        }\n      }\n    }\n\n    this.scrollable.onScroll();\n  }\n\n  public cleanupHTML() {\n    // const perf = performance.now();\n    this.profile.cleanupHTML();\n    \n    this.editBtn.style.display = 'none';\n\n    this.searchSuper.cleanupHTML(true);\n\n    this.container.classList.toggle('can-add-members', this.searchSuper.canViewMembers() && appChatsManager.hasRights(-this.peerId, 'invite_users'));\n\n    // console.log('cleanupHTML shared media time:', performance.now() - perf);\n  }\n\n  public setLoadMutex(promise: Promise<any>) {\n    this.searchSuper.loadMutex = promise;\n  }\n\n  public setPeer(peerId: number, threadId = 0) {\n    if(this.peerId === peerId && this.threadId === threadId) return false;\n\n    this.peerId = peerId;\n    this.threadId = threadId;\n    this.peerChanged = true;\n\n    if(this.init) {\n      this.init();\n      this.init = null;\n    }\n\n    this.searchSuper.setQuery({\n      peerId, \n      //threadId, \n      historyStorage: this.historiesStorage[peerId] ?? (this.historiesStorage[peerId] = {})\n    });\n\n    this.profile.setPeer(peerId, threadId);\n    \n    return true;\n  }\n\n  public fillProfileElements() {\n    if(!this.peerChanged) {\n      return;\n    }\n\n    this.peerChanged = false;\n\n    this.cleanupHTML();\n\n    this.profile.fillProfileElements();\n\n    if(this.peerId > 0) {\n      if(this.peerId !== rootScope.myId && appUsersManager.isContact(this.peerId)) {\n        this.editBtn.style.display = '';\n      }\n    } else {\n      const chat: Chat = appChatsManager.getChat(-this.peerId);\n      if((chat._ === 'chat' || (chat as Chat.channel).admin_rights) && !(chat as Chat.chat).pFlags.deactivated) {\n        this.editBtn.style.display = '';\n      }\n    }\n  }\n\n  public loadSidebarMedia(single: boolean, justLoad = false) {\n    this.searchSuper.load(single, justLoad);\n  }\n\n  onOpenAfterTimeout() {\n    this.scrollable.onScroll();\n  }\n}\n\nMOUNT_CLASS_TO && (MOUNT_CLASS_TO.AppSharedMediaTab = AppSharedMediaTab);\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport { attachClickEvent } from \"../../../helpers/dom/clickEvent\";\nimport toggleDisability from \"../../../helpers/dom/toggleDisability\";\nimport { deepEqual } from \"../../../helpers/object\";\nimport { ChannelParticipant } from \"../../../layer\";\nimport appChatsManager from \"../../../lib/appManagers/appChatsManager\";\nimport appDialogsManager from \"../../../lib/appManagers/appDialogsManager\";\nimport appUsersManager from \"../../../lib/appManagers/appUsersManager\";\nimport Button from \"../../button\";\nimport { SettingSection } from \"../../sidebarLeft\";\nimport { SliderSuperTabEventable } from \"../../sliderTab\";\nimport { ChatPermissions } from \"./groupPermissions\";\n\nexport default class AppUserPermissionsTab extends SliderSuperTabEventable {\n  public participant: ChannelParticipant;\n  public chatId: number;\n  public userId: number;\n\n  protected init() {\n    this.container.classList.add('edit-peer-container', 'user-permissions-container');\n    this.setTitle('UserRestrictions');\n\n    let destroyListener: () => void;\n\n    {\n      const section = new SettingSection({\n        name: 'UserRestrictionsCanDo',\n      });\n      \n      const div = document.createElement('div');\n      div.classList.add('chatlist-container');\n      section.content.insertBefore(div, section.title);\n\n      const list = appDialogsManager.createChatList({new: true});\n      div.append(list);\n\n      const {dom} = appDialogsManager.addDialogNew({\n        dialog: this.userId,\n        container: list,\n        drawStatus: false,\n        rippleEnabled: true,\n        avatarSize: 48\n      });\n\n      dom.lastMessageSpan.append(appUsersManager.getUserStatusString(this.userId));\n\n      const p = new ChatPermissions({\n        chatId: this.chatId,\n        listenerSetter: this.listenerSetter,\n        appendTo: section.content,\n        participant: this.participant._ === 'channelParticipantBanned' ? this.participant : undefined\n      });\n\n      destroyListener = () => {\n        //appChatsManager.editChatDefaultBannedRights(this.chatId, p.takeOut());\n        const rights = p.takeOut();\n        if(this.participant._ === 'channelParticipantBanned' && deepEqual(this.participant.banned_rights.pFlags, rights.pFlags)) {\n          return;\n        }\n\n        appChatsManager.editBanned(this.chatId, this.participant, rights);\n      };\n\n      this.eventListener.addEventListener('destroy', destroyListener, {once: true});\n\n      this.scrollable.append(section.container);\n    }\n    \n    {\n      const section = new SettingSection({});\n\n      if(this.participant._ === 'channelParticipantBanned') {\n        const btnDeleteException = Button('btn-primary btn-transparent danger', {icon: 'delete', text: 'GroupPermission.Delete'});\n\n        attachClickEvent(btnDeleteException, () => {\n          const toggle = toggleDisability([btnDeleteException], true);\n          appChatsManager.clearChannelParticipantBannedRights(this.chatId, this.participant).then(() => {\n            this.eventListener.removeEventListener('destroy', destroyListener);\n            this.close();\n          }, () => {\n            toggle();\n          });\n        }, {listenerSetter: this.listenerSetter});\n  \n        section.content.append(btnDeleteException);\n      }\n\n      const btnDelete = Button('btn-primary btn-transparent danger', {icon: 'deleteuser', text: 'UserRestrictionsBlock'});\n\n      attachClickEvent(btnDelete, () => {\n        const toggle = toggleDisability([btnDelete], true);\n        appChatsManager.kickFromChannel(this.chatId, this.participant).then(() => {\n          this.eventListener.removeEventListener('destroy', destroyListener);\n          this.close();\n        });\n        /* new PopupPeer('popup-group-kick-user', {\n          peerId: -this.chatId,\n          title: 'Ban User?',\n          description: `Are you sure you want to ban <b>${appPeersManager.getPeerTitle(this.userId)}</b>`,\n          buttons: addCancelButton([{\n            text: 'BAN',\n            callback: () => {\n              const toggle = toggleDisability([btnDelete], true);\n\n              appChatsManager.kickFromChannel(this.chatId, this.participant).then(() => {\n                this.eventListener.removeEventListener('destroy', destroyListener);\n                this.close();\n              }, () => {\n                toggle();\n              });\n            },\n            isDanger: true\n          }])\n        }).show(); */\n      }, {listenerSetter: this.listenerSetter});\n\n      section.content.append(btnDelete);\n\n      this.scrollable.append(section.container);\n    }\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type { LazyLoadQueueIntersector } from \"./lazyLoadQueue\";\nimport appDialogsManager, { DialogDom } from \"../lib/appManagers/appDialogsManager\";\nimport { getHeavyAnimationPromise } from \"../hooks/useHeavyAnimationCheck\";\nimport appUsersManager from \"../lib/appManagers/appUsersManager\";\nimport { insertInDescendSortedArray } from \"../helpers/array\";\nimport isInDOM from \"../helpers/dom/isInDOM\";\nimport positionElementByIndex from \"../helpers/dom/positionElementByIndex\";\nimport replaceContent from \"../helpers/dom/replaceContent\";\nimport { safeAssign } from \"../helpers/object\";\n\ntype SortedUser = {\n  peerId: number, \n  status: number, \n  dom: DialogDom\n};\nexport default class SortedUserList {\n  protected static SORT_INTERVAL = 30e3;\n  protected users: Map<number, SortedUser>;\n  protected sorted: Array<SortedUser>;\n  public list: HTMLUListElement;\n  \n  protected lazyLoadQueue: LazyLoadQueueIntersector;\n  protected avatarSize = 48;\n  protected rippleEnabled = true;\n\n  constructor(options: Partial<{\n    lazyLoadQueue: SortedUserList['lazyLoadQueue'],\n    avatarSize: SortedUserList['avatarSize'],\n    rippleEnabled: SortedUserList['rippleEnabled'],\n    new: boolean\n  }> = {}) {\n    safeAssign(this, options);\n\n    this.list = appDialogsManager.createChatList({new: options.new});\n\n    this.users = new Map();\n    this.sorted = [];\n\n    let timeout: number;\n    const doTimeout = () => {\n      timeout = window.setTimeout(() => {\n        this.updateList().then((good) => {\n          if(good) {\n            doTimeout();\n          }\n        });\n      }, SortedUserList.SORT_INTERVAL);\n    };\n\n    doTimeout();\n  }\n\n  public async updateList() {\n    if(!isInDOM(this.list)) {\n      return false;\n    }\n\n    await getHeavyAnimationPromise();\n\n    if(!isInDOM(this.list)) {\n      return false;\n    }\n\n    this.users.forEach(user => {\n      this.update(user.peerId, true);\n    });\n\n    this.sorted.forEach((sortedUser, idx) => {\n      positionElementByIndex(sortedUser.dom.listEl, this.list, idx);\n    });\n\n    return true;\n  }\n\n  public add(peerId: number) {\n    if(this.users.has(peerId)) {\n      return;\n    }\n\n    const {dom} = appDialogsManager.addDialogNew({\n      dialog: peerId,\n      container: false,\n      drawStatus: false,\n      avatarSize: this.avatarSize,\n      autonomous: true,\n      meAsSaved: false,\n      rippleEnabled: this.rippleEnabled,\n      lazyLoadQueue: this.lazyLoadQueue\n    });\n\n    const sortedUser: SortedUser = {\n      peerId,\n      status: appUsersManager.getUserStatusForSort(peerId),\n      dom\n    };\n\n    this.users.set(peerId, sortedUser);\n    this.update(peerId);\n  }\n\n  public update(peerId: number, batch = false) {\n    const sortedUser = this.users.get(peerId);\n    sortedUser.status = appUsersManager.getUserStatusForSort(peerId);\n    const status = appUsersManager.getUserStatusString(peerId);\n    replaceContent(sortedUser.dom.lastMessageSpan, status);\n\n    const idx = insertInDescendSortedArray(this.sorted, sortedUser, 'status');\n    if(!batch) {\n      positionElementByIndex(sortedUser.dom.listEl, this.list, idx);\n    }\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport type Chat from './chat/chat';\nimport { getEmojiToneIndex } from '../vendor/emoji';\nimport { readBlobAsText } from '../helpers/blob';\nimport { deferredPromise } from '../helpers/cancellablePromise';\nimport { formatDateAccordingToToday, months } from '../helpers/date';\nimport mediaSizes from '../helpers/mediaSizes';\nimport { formatBytes } from '../helpers/number';\nimport { isSafari } from '../helpers/userAgent';\nimport { PhotoSize, StickerSet } from '../layer';\nimport appDocsManager, { MyDocument } from \"../lib/appManagers/appDocsManager\";\nimport appMessagesManager from '../lib/appManagers/appMessagesManager';\nimport appPhotosManager, { MyPhoto } from '../lib/appManagers/appPhotosManager';\nimport LottieLoader from '../lib/lottieLoader';\nimport webpWorkerController from '../lib/webp/webpWorkerController';\nimport animationIntersector from './animationIntersector';\nimport appMediaPlaybackController from './appMediaPlaybackController';\nimport AudioElement from './audio';\nimport ReplyContainer from './chat/replyContainer';\nimport { Layouter, RectPart } from './groupedLayout';\nimport LazyLoadQueue from './lazyLoadQueue';\nimport PollElement from './poll';\nimport ProgressivePreloader from './preloader';\nimport './middleEllipsis';\nimport RichTextProcessor from '../lib/richtextprocessor';\nimport appImManager from '../lib/appManagers/appImManager';\nimport { SearchSuperContext } from './appSearchSuper.';\nimport rootScope from '../lib/rootScope';\nimport { onVideoLoad } from '../helpers/files';\nimport { animateSingle } from '../helpers/animation';\nimport renderImageFromUrl from '../helpers/dom/renderImageFromUrl';\nimport sequentialDom from '../helpers/sequentialDom';\nimport { fastRaf } from '../helpers/schedulers';\nimport appDownloadManager, { DownloadBlob, ThumbCache } from '../lib/appManagers/appDownloadManager';\nimport appStickersManager from '../lib/appManagers/appStickersManager';\nimport { cancelEvent } from '../helpers/dom/cancelEvent';\nimport { attachClickEvent } from '../helpers/dom/clickEvent';\nimport isInDOM from '../helpers/dom/isInDOM';\nimport lottieLoader from '../lib/lottieLoader';\n\nconst MAX_VIDEO_AUTOPLAY_SIZE = 50 * 1024 * 1024; // 50 MB\n\nexport function wrapVideo({doc, container, message, boxWidth, boxHeight, withTail, isOut, middleware, lazyLoadQueue, noInfo, group, onlyPreview, withoutPreloader, loadPromises, noPlayButton, noAutoDownload, size}: {\n  doc: MyDocument, \n  container?: HTMLElement, \n  message?: any, \n  boxWidth?: number, \n  boxHeight?: number, \n  withTail?: boolean, \n  isOut?: boolean,\n  middleware?: () => boolean,\n  lazyLoadQueue?: LazyLoadQueue,\n  noInfo?: true,\n  noPlayButton?: boolean,\n  group?: string,\n  onlyPreview?: boolean,\n  withoutPreloader?: boolean,\n  loadPromises?: Promise<any>[],\n  noAutoDownload?: boolean,\n  size?: PhotoSize\n}) {\n  const isAlbumItem = !(boxWidth && boxHeight);\n  const canAutoplay = (doc.type !== 'video' || (doc.size <= MAX_VIDEO_AUTOPLAY_SIZE && !isAlbumItem)) \n    && (doc.type === 'gif' ? rootScope.settings.autoPlay.gifs : rootScope.settings.autoPlay.videos);\n  let spanTime: HTMLElement, spanPlay: HTMLElement;\n\n  if(!noInfo) {\n    spanTime = document.createElement('span');\n    spanTime.classList.add('video-time');\n    container.append(spanTime);\n  \n    let needPlayButton = false;\n    if(doc.type !== 'gif') {\n      spanTime.innerText = (doc.duration + '').toHHMMSS(false);\n\n      if(!noPlayButton && doc.type !== 'round') {\n        if(canAutoplay) {\n          spanTime.classList.add('tgico', 'can-autoplay');\n        } else {\n          needPlayButton = true;\n        }\n      }\n    } else {\n      spanTime.innerText = 'GIF';\n\n      if(!canAutoplay && !noPlayButton) {\n        needPlayButton = true;\n        noAutoDownload = undefined;\n      }\n    }\n\n    if(needPlayButton) {\n      spanPlay = document.createElement('span');\n      spanPlay.classList.add('video-play', 'tgico-largeplay', 'btn-circle', 'position-center');\n      container.append(spanPlay);\n    }\n  }\n\n  let res: {\n    thumb?: typeof photoRes,\n    loadPromise: Promise<any>\n  } = {} as any;\n\n  if(doc.mime_type === 'image/gif') {\n    const photoRes = wrapPhoto({\n      photo: doc, \n      message, \n      container, \n      boxWidth, \n      boxHeight, \n      withTail, \n      isOut, \n      lazyLoadQueue, \n      middleware,\n      withoutPreloader,\n      loadPromises,\n      noAutoDownload,\n      size\n    });\n\n    res.thumb = photoRes;\n    res.loadPromise = photoRes.loadPromises.full;\n    return res;\n  }\n\n  /* const video = doc.type === 'round' ? appMediaPlaybackController.addMedia(doc, message.mid) as HTMLVideoElement : document.createElement('video');\n  if(video.parentElement) {\n    video.remove();\n  } */\n\n  const video = document.createElement('video');\n  video.classList.add('media-video');\n  video.setAttribute('playsinline', 'true');\n  video.muted = true;\n  if(doc.type === 'round') {\n    const globalVideo = appMediaPlaybackController.addMedia(message.peerId, doc, message.mid, !noAutoDownload) as HTMLVideoElement;\n \n    const divRound = document.createElement('div');\n    divRound.classList.add('media-round', 'z-depth-1');\n\n    divRound.innerHTML = `<svg class=\"progress-ring\" width=\"200px\" height=\"200px\">\n      <circle class=\"progress-ring__circle\" stroke=\"white\" stroke-opacity=\"0.3\" stroke-width=\"3.5\" cx=\"100\" cy=\"100\" r=\"93\" fill=\"transparent\" transform=\"rotate(-90, 100, 100)\"/>\n    </svg>`;\n\n    const circle = divRound.querySelector('.progress-ring__circle') as SVGCircleElement;\n    const radius = circle.r.baseVal.value;\n    const circumference = 2 * Math.PI * radius;\n    circle.style.strokeDasharray = circumference + ' ' + circumference;\n    circle.style.strokeDashoffset = '' + circumference;\n    \n    spanTime.classList.add('tgico');\n\n    const canvas = document.createElement('canvas');\n    canvas.width = canvas.height = doc.w/*  * window.devicePixelRatio */;\n\n    divRound.prepend(canvas, spanTime);\n    divRound.append(video);\n    container.append(divRound);\n\n    const ctx = canvas.getContext('2d');\n    /* ctx.beginPath();\n    ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2, 0, Math.PI * 2);\n    ctx.clip(); */\n\n    const clear = () => {\n      (appImManager.chat.setPeerPromise || Promise.resolve()).finally(() => {\n        if(isInDOM(globalVideo)) {\n          return;\n        }\n\n        globalVideo.removeEventListener('play', onPlay);\n        globalVideo.removeEventListener('timeupdate', onTimeUpdate);\n        globalVideo.removeEventListener('pause', onPaused);\n      });\n    };\n\n    const onFrame = () => {\n      ctx.drawImage(globalVideo, 0, 0);\n\n      const offset = circumference - globalVideo.currentTime / globalVideo.duration * circumference;\n      circle.style.strokeDashoffset = '' + offset;\n\n      return !globalVideo.paused;\n    };\n\n    const onTimeUpdate = () => {\n      if(!globalVideo.duration) return;\n\n      if(!isInDOM(globalVideo)) {\n        clear();\n        return;\n      }\n\n      spanTime.innerText = (globalVideo.duration - globalVideo.currentTime + '').toHHMMSS(false);\n    };\n\n    const onPlay = () => {\n      video.classList.add('hide');\n      divRound.classList.remove('is-paused');\n      animateSingle(onFrame, canvas);\n    };\n\n    const onPaused = () => {\n      if(!isInDOM(globalVideo)) {\n        clear();\n        return;\n      }\n\n      divRound.classList.add('is-paused');\n    };\n\n    globalVideo.addEventListener('play', onPlay);\n    globalVideo.addEventListener('timeupdate', onTimeUpdate);\n    globalVideo.addEventListener('pause', onPaused);\n\n    attachClickEvent(canvas, (e) => {\n      cancelEvent(e);\n\n      if(globalVideo.paused) {\n        globalVideo.play();\n      } else {\n        globalVideo.pause();\n      }\n    });\n\n    if(globalVideo.paused) {\n      if(globalVideo.duration && globalVideo.currentTime !== globalVideo.duration) {\n        onFrame();\n        onTimeUpdate();\n        video.classList.add('hide');\n      } else {\n        onPaused();\n      }\n    } else {\n      onPlay();\n    }\n  } else {\n    video.autoplay = true; // \u0434\u043b\u044f safari\n  }\n\n  let photoRes: ReturnType<typeof wrapPhoto>;\n  if(message) {\n    photoRes = wrapPhoto({\n      photo: doc, \n      message, \n      container, \n      boxWidth, \n      boxHeight, \n      withTail, \n      isOut, \n      lazyLoadQueue, \n      middleware,\n      withoutPreloader: true,\n      loadPromises,\n      noAutoDownload,\n      size\n    });\n\n    res.thumb = photoRes;\n\n    if((!canAutoplay && doc.type !== 'gif') || onlyPreview) {\n      res.loadPromise = photoRes.loadPromises.full;\n      return res;\n    }\n\n    if(withTail) {\n      const foreignObject = (photoRes.images.thumb || photoRes.images.full).parentElement;\n      video.width = +foreignObject.getAttributeNS(null, 'width');\n      video.height = +foreignObject.getAttributeNS(null, 'height');\n      foreignObject.append(video);\n    }\n  } else { // * gifs masonry\n    const gotThumb = appDocsManager.getThumb(doc, false);\n    if(gotThumb) {\n      gotThumb.promise.then(() => {\n        video.poster = gotThumb.cacheContext.url;\n      });\n    }\n  }\n\n  if(!video.parentElement && container) {\n    (photoRes?.aspecter || container).append(video);\n  }\n\n  const cacheContext = appDownloadManager.getCacheContext(doc);\n\n  let preloader: ProgressivePreloader;\n  if(message?.media?.preloader) { // means upload\n    preloader = message.media.preloader as ProgressivePreloader;\n    preloader.attach(container, false);\n    noAutoDownload = undefined;\n  } else if(!cacheContext.downloaded && !doc.supportsStreaming) {\n    preloader = new ProgressivePreloader({\n      attachMethod: 'prepend'\n    });\n  } else if(doc.supportsStreaming) {\n    preloader = new ProgressivePreloader({\n      cancelable: false,\n      attachMethod: 'prepend'\n    });\n  }\n\n  let f = noAutoDownload && photoRes?.preloader?.loadFunc;\n  const load = () => {\n    if(preloader && noAutoDownload && !withoutPreloader) {\n      preloader.construct();\n      preloader.setManual();\n    }\n\n    let loadPromise: Promise<any> = Promise.resolve();\n    if(preloader) {\n      if(!cacheContext.downloaded && !doc.supportsStreaming) {\n        const promise = loadPromise = appDocsManager.downloadDoc(doc, lazyLoadQueue?.queueId, noAutoDownload);\n        preloader.attach(container, false, promise);\n      } else if(doc.supportsStreaming) {\n        if(noAutoDownload) {\n          loadPromise = Promise.reject();\n        } else if(!cacheContext.downloaded) { // * check for uploading video\n          preloader.attach(container, false, null);\n          video.addEventListener(isSafari ? 'timeupdate' : 'canplay', () => {\n            preloader.detach();\n          }, {once: true});\n        }\n      }\n    }\n\n    video.addEventListener('error', (e) => {\n      console.error(\"Error \" + video.error.code + \"; details: \" + video.error.message);\n      if(preloader) {\n        preloader.detach();\n      }\n    }, {once: true});\n\n    if(!noAutoDownload && f) {\n      f();\n      f = null;\n    }\n\n    noAutoDownload = undefined;\n\n    const deferred = deferredPromise<void>();\n    loadPromise.then(() => {\n      if(middleware && !middleware()) {\n        deferred.resolve();\n        return;\n      }\n\n      if(doc.type === 'round') {\n        appMediaPlaybackController.resolveWaitingForLoadMedia(message.peerId, message.mid);\n      }\n\n      onVideoLoad(video).then(() => {\n        if(group) {\n          animationIntersector.addAnimation(video, group);\n        }\n  \n        deferred.resolve();\n      });\n  \n      if(doc.type === 'video') {\n        video.addEventListener('timeupdate', () => {\n          spanTime.innerText = (video.duration - video.currentTime + '').toHHMMSS(false);\n        });\n      }\n  \n      video.addEventListener('error', (e) => {\n        deferred.resolve();\n      });\n  \n      video.muted = true;\n      video.loop = true;\n      //video.play();\n      video.autoplay = true;\n\n      renderImageFromUrl(video, cacheContext.url);\n    }, () => {});\n\n    return {download: loadPromise, render: deferred};\n  };\n\n  if(preloader) {\n    preloader.setDownloadFunction(load);\n  }\n\n  /* if(doc.size >= 20e6 && !doc.downloaded) {\n    let downloadDiv = document.createElement('div');\n    downloadDiv.classList.add('download');\n\n    let span = document.createElement('span');\n    span.classList.add('btn-circle', 'tgico-download');\n    downloadDiv.append(span);\n\n    downloadDiv.addEventListener('click', () => {\n      downloadDiv.remove();\n      loadVideo();\n    });\n\n    container.prepend(downloadDiv);\n\n    return;\n  } */\n\n  if(doc.type === 'gif' && !canAutoplay) {\n    attachClickEvent(container, (e) => {\n      cancelEvent(e);\n      spanPlay.remove();\n      load();\n    }, {capture: true, once: true});\n  } else {\n    res.loadPromise = !lazyLoadQueue ? load().render : (lazyLoadQueue.push({div: container, load: () => load().render}), Promise.resolve());\n  }\n\n  return res;\n}\n\nexport const formatDate = (timestamp: number, monthShort = false, withYear = true) => {\n  const date = new Date(timestamp * 1000);\n  \n  let month = months[date.getMonth()];\n  if(monthShort) month = month.slice(0, 3);\n\n  let str = month + ' ' + date.getDate();\n  if(withYear) {\n    str += ', ' + date.getFullYear();\n  }\n  \n  return str + ' at ' + date.getHours() + ':' + ('0' + date.getMinutes()).slice(-2);\n};\n\nexport function wrapDocument({message, withTime, fontWeight, voiceAsMusic, showSender, searchContext, loadPromises, noAutoDownload}: {\n  message: any, \n  withTime?: boolean,\n  fontWeight?: number,\n  voiceAsMusic?: boolean,\n  showSender?: boolean,\n  searchContext?: SearchSuperContext,\n  loadPromises?: Promise<any>[],\n  noAutoDownload?: boolean,\n}): HTMLElement {\n  if(!fontWeight) fontWeight = 500;\n\n  const doc = (message.media.document || message.media.webpage.document) as MyDocument;\n  const uploading = message.pFlags.is_outgoing && message.media?.preloader;\n  if(doc.type === 'audio' || doc.type === 'voice') {\n    const audioElement = new AudioElement();\n    audioElement.setAttribute('message-id', '' + message.mid);\n    audioElement.setAttribute('peer-id', '' + message.peerId);\n    audioElement.withTime = withTime;\n    audioElement.message = message;\n    audioElement.noAutoDownload = noAutoDownload;\n    \n    if(voiceAsMusic) audioElement.voiceAsMusic = voiceAsMusic;\n    if(searchContext) audioElement.searchContext = searchContext;\n    if(showSender) audioElement.showSender = showSender;\n    \n    if(uploading) {\n      audioElement.preloader = message.media.preloader;\n    }\n\n    audioElement.dataset.fontWeight = '' + fontWeight;\n    audioElement.render();\n    return audioElement;\n  }\n\n  let extSplitted = doc.file_name ? doc.file_name.split('.') : '';\n  let ext = '';\n  ext = extSplitted.length > 1 && Array.isArray(extSplitted) ? extSplitted.pop().toLowerCase() : 'file';\n\n  let docDiv = document.createElement('div');\n  docDiv.classList.add('document', `ext-${ext}`);\n  docDiv.dataset.docId = doc.id;\n\n  const icoDiv = document.createElement('div');\n  icoDiv.classList.add('document-ico');\n\n  const cacheContext = appDownloadManager.getCacheContext(doc);\n  if(doc.thumbs?.length || (message.pFlags.is_outgoing && cacheContext.url && doc.type === 'photo')) {\n    docDiv.classList.add('document-with-thumb');\n\n    let imgs: HTMLImageElement[] = [];\n    if(message.pFlags.is_outgoing) {\n      icoDiv.innerHTML = `<img src=\"${cacheContext.url}\">`;\n      imgs.push(icoDiv.firstElementChild as HTMLImageElement);\n    } else {\n      const wrapped = wrapPhoto({\n        photo: doc, \n        message: null, \n        container: icoDiv, \n        boxWidth: 54, \n        boxHeight: 54,\n        loadPromises,\n        withoutPreloader: true\n      });\n      icoDiv.style.width = icoDiv.style.height = '';\n      if(wrapped.images.thumb) imgs.push(wrapped.images.thumb);\n      if(wrapped.images.full) imgs.push(wrapped.images.full);\n    }\n\n    imgs.forEach(img => img.classList.add('document-thumb'));\n  } else {\n    icoDiv.innerText = ext;\n  }\n\n  //let fileName = stringMiddleOverflow(doc.file_name || 'Unknown.file', 26);\n  let fileName = doc.fileName || 'Unknown.file';\n  let size = formatBytes(doc.size);\n  \n  if(withTime) {\n    size += ' \u00b7 ' + formatDate(doc.date);\n  }\n\n  if(showSender) {\n    size += ' \u00b7 ' + appMessagesManager.getSenderToPeerText(message);\n  }\n\n  let titleAdditionHTML = '';\n  if(showSender) {\n    titleAdditionHTML = `<div class=\"sent-time\">${formatDateAccordingToToday(new Date(message.date * 1000))}</div>`;\n  }\n  \n  docDiv.innerHTML = `\n  ${cacheContext.downloaded && !uploading ? '' : `<div class=\"document-download\"></div>`}\n  <div class=\"document-name\"><middle-ellipsis-element data-font-weight=\"${fontWeight}\">${fileName}</middle-ellipsis-element>${titleAdditionHTML}</div>\n  <div class=\"document-size\">${size}</div>\n  `;\n\n  docDiv.prepend(icoDiv);\n\n  if(!uploading && message.pFlags.is_outgoing) {\n    return docDiv;\n  }\n\n  let downloadDiv: HTMLElement, preloader: ProgressivePreloader = null;\n  const onLoad = () => {\n    if(downloadDiv) {\n      downloadDiv.classList.add('downloaded');\n      const _downloadDiv = downloadDiv;\n      setTimeout(() => {\n        _downloadDiv.remove();\n      }, 200);\n      downloadDiv = null;\n    }\n\n    if(preloader) {\n      preloader = null;\n    }\n  };\n\n  const load = () => {\n    const doc = appDocsManager.getDoc(docDiv.dataset.docId);\n    let download: DownloadBlob;\n    if(doc.type === 'pdf') {\n      download = appDocsManager.downloadDoc(doc, appImManager.chat.bubbles ? appImManager.chat.bubbles.lazyLoadQueue.queueId : 0);\n      download.then(() => {\n        const cacheContext = appDownloadManager.getCacheContext(doc);\n        window.open(cacheContext.url);\n      });\n    } else {\n      download = appDocsManager.saveDocFile(doc, appImManager.chat.bubbles ? appImManager.chat.bubbles.lazyLoadQueue.queueId : 0);\n    }\n\n    if(downloadDiv) {\n      download.then(onLoad);\n      preloader.attach(downloadDiv, true, download);\n    }\n\n    return {download};\n  };\n\n  if(!(cacheContext.downloaded && !uploading)) {\n    downloadDiv = docDiv.querySelector('.document-download');\n    preloader = message.media.preloader as ProgressivePreloader;\n\n    if(!preloader) {\n      preloader = new ProgressivePreloader();\n\n      preloader.construct();\n      preloader.setManual();\n      preloader.attach(downloadDiv);\n      preloader.setDownloadFunction(load);\n    } else {\n      preloader.attach(downloadDiv);\n      message.media.promise.then(onLoad);\n    }\n  }\n\n  attachClickEvent(docDiv, (e) => {\n    if(preloader) {\n      preloader.onClick(e);\n    } else {\n      load();\n    }\n  });\n  \n  return docDiv;\n}\n\n/* function wrapMediaWithTail(photo: MyPhoto | MyDocument, message: {mid: number, message: string}, container: HTMLElement, boxWidth: number, boxHeight: number, isOut: boolean) {\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n  svg.classList.add('bubble__media-container', isOut ? 'is-out' : 'is-in');\n  \n  const foreignObject = document.createElementNS(\"http://www.w3.org/2000/svg\", 'foreignObject');\n\n  const gotThumb = appPhotosManager.getStrippedThumbIfNeeded(photo, true);\n  if(gotThumb) {\n    foreignObject.append(gotThumb.image);\n  }\n  appPhotosManager.setAttachmentSize(photo, foreignObject, boxWidth, boxHeight);\n  \n  const width = +foreignObject.getAttributeNS(null, 'width');\n  const height = +foreignObject.getAttributeNS(null, 'height');\n\n  svg.setAttributeNS(null, 'width', '' + width);\n  svg.setAttributeNS(null, 'height', '' + height);\n\n  svg.setAttributeNS(null, 'viewBox', '0 0 ' + width + ' ' + height);\n  svg.setAttributeNS(null, 'preserveAspectRatio', 'none');\n\n  const clipId = 'clip' + message.mid + '_' + nextRandomInt(9999);\n  svg.dataset.clipId = clipId;\n  \n  const defs = document.createElementNS(\"http://www.w3.org/2000/svg\", 'defs');\n  let clipPathHTML: string = '';\n  \n  if(message.message) {\n    //clipPathHTML += `<rect width=\"${width}\" height=\"${height}\"></rect>`;\n  } else {\n    if(isOut) {\n      clipPathHTML += `\n      <use href=\"#message-tail\" transform=\"translate(${width - 2}, ${height}) scale(-1, -1)\"></use>\n      <path />\n      `;\n    } else {\n      clipPathHTML += `\n      <use href=\"#message-tail\" transform=\"translate(2, ${height}) scale(1, -1)\"></use>\n      <path />\n      `;\n    }\n  }\n\n  defs.innerHTML = `<clipPath id=\"${clipId}\">${clipPathHTML}</clipPath>`;\n  \n  container.style.width = parseInt(container.style.width) - 9 + 'px';\n  container.classList.add('with-tail');\n\n  svg.append(defs, foreignObject);\n  container.append(svg);\n\n  let img = foreignObject.firstElementChild as HTMLImageElement;\n  if(!img) {\n    foreignObject.append(img = new Image());\n  }\n\n  return img;\n} */\n\nexport function wrapPhoto({photo, message, container, boxWidth, boxHeight, withTail, isOut, lazyLoadQueue, middleware, size, withoutPreloader, loadPromises, noAutoDownload, noBlur, noThumb, noFadeIn}: {\n  photo: MyPhoto | MyDocument, \n  message: any, \n  container: HTMLElement, \n  boxWidth?: number, \n  boxHeight?: number, \n  withTail?: boolean, \n  isOut?: boolean, \n  lazyLoadQueue?: LazyLoadQueue, \n  middleware?: () => boolean, \n  size?: PhotoSize,\n  withoutPreloader?: boolean,\n  loadPromises?: Promise<any>[],\n  noAutoDownload?: boolean,\n  noBlur?: boolean,\n  noThumb?: boolean,\n  noFadeIn?: boolean,\n}) {\n  if(!((photo as MyPhoto).sizes || (photo as MyDocument).thumbs)) {\n    if(boxWidth && boxHeight && !size && photo._ === 'document') {\n      appPhotosManager.setAttachmentSize(photo, container, boxWidth, boxHeight, undefined, message);\n    }\n\n    return {\n      loadPromises: {\n        thumb: Promise.resolve(),\n        full: Promise.resolve()\n      },\n      images: {\n        thumb: null,\n        full: null\n      },\n      preloader: null,\n      aspecter: null\n    };\n  }\n\n  if(!size) {\n    if(boxWidth === undefined) boxWidth = mediaSizes.active.regular.width;\n    if(boxHeight === undefined) boxHeight = mediaSizes.active.regular.height;\n  }\n\n  container.classList.add('media-container');\n  let aspecter = container;\n\n  let isFit = true;\n  let loadThumbPromise: Promise<any> = Promise.resolve();\n  let thumbImage: HTMLImageElement;\n  let image: HTMLImageElement;\n  let cacheContext: ThumbCache;\n  // if(withTail) {\n  //   image = wrapMediaWithTail(photo, message, container, boxWidth, boxHeight, isOut);\n  // } else {\n    image = new Image();\n\n    if(boxWidth && boxHeight && !size) { // !album\n      const set = appPhotosManager.setAttachmentSize(photo, container, boxWidth, boxHeight, undefined, message);\n      size = set.photoSize;\n      isFit = set.isFit;\n      cacheContext = appDownloadManager.getCacheContext(photo, size.type);\n\n      if(!isFit) {\n        aspecter = document.createElement('div');\n        aspecter.classList.add('media-container-aspecter');\n        aspecter.style.width = set.size.width + 'px';\n        aspecter.style.height = set.size.height + 'px';\n\n        const gotThumb = appPhotosManager.getStrippedThumbIfNeeded(photo, cacheContext, !noBlur, true);\n        if(gotThumb) {\n          loadThumbPromise = gotThumb.loadPromise;\n          const thumbImage = gotThumb.image; // local scope\n          thumbImage.classList.add('media-photo');\n          container.append(thumbImage);\n        } else {\n          const res = wrapPhoto({\n            container,\n            message,\n            photo,\n            boxWidth: 0,\n            boxHeight: 0,\n            size,\n            lazyLoadQueue,\n            isOut,\n            loadPromises,\n            middleware,\n            withoutPreloader,\n            withTail,\n            noAutoDownload,\n            noBlur,\n            noThumb: true,\n            //noFadeIn: true\n          });\n          const thumbImage = res.images.full;\n          thumbImage.classList.add('media-photo', 'thumbnail');\n          //container.append(thumbImage);\n        }\n\n        container.classList.add('media-container-fitted');\n        container.append(aspecter);\n      }\n    } else {\n      if(!size) {\n        size = appPhotosManager.choosePhotoSize(photo, boxWidth, boxHeight, true);\n      }\n      \n      cacheContext = appDownloadManager.getCacheContext(photo, size?.type);\n    }\n\n    if(!noThumb) {\n      const gotThumb = appPhotosManager.getStrippedThumbIfNeeded(photo, cacheContext, !noBlur);\n      if(gotThumb) {\n        loadThumbPromise = Promise.all([loadThumbPromise, gotThumb.loadPromise]);\n        thumbImage = gotThumb.image;\n        thumbImage.classList.add('media-photo');\n        aspecter.append(thumbImage);\n      }\n    }\n  // }\n\n  image.classList.add('media-photo');\n  \n  //console.log('wrapPhoto downloaded:', photo, photo.downloaded, container);\n\n  const needFadeIn = (thumbImage || !cacheContext.downloaded) && rootScope.settings.animationsEnabled && !noFadeIn;\n  if(needFadeIn) {\n    image.classList.add('fade-in');\n  }\n\n  let preloader: ProgressivePreloader;\n  if(message?.media?.preloader) { // means upload\n    preloader = message.media.preloader;\n    preloader.attach(container);\n    noAutoDownload = undefined;\n  } else {\n    preloader = new ProgressivePreloader({\n      attachMethod: 'prepend'\n    });\n  }\n\n  const getDownloadPromise = () => {\n    const promise = photo._ === 'document' && photo.mime_type === 'image/gif' ? \n      appDocsManager.downloadDoc(photo, /* undefined,  */lazyLoadQueue?.queueId) : \n      appPhotosManager.preloadPhoto(photo, size, lazyLoadQueue?.queueId, noAutoDownload);\n\n    noAutoDownload = undefined;\n\n    return promise;\n  };\n\n  const onLoad = (): Promise<void> => {\n    if(middleware && !middleware()) return Promise.resolve();\n\n    return new Promise((resolve) => {\n      /* if(photo._ === 'document') {\n        console.error('wrapPhoto: will render document', photo, size, cacheContext);\n        return resolve();\n      } */\n\n      renderImageFromUrl(image, cacheContext.url, () => {\n        sequentialDom.mutateElement(container, () => {\n          aspecter.append(image);\n\n          fastRaf(() => {\n            resolve();\n          });\n  \n          if(needFadeIn) {\n            image.addEventListener('animationend', () => {\n              sequentialDom.mutate(() => {\n                image.classList.remove('fade-in');\n    \n                if(thumbImage) {\n                  thumbImage.remove();\n                }\n              });\n            }, {once: true});\n          }\n        });\n      });\n    });\n  };\n\n  let loadPromise: Promise<any>;\n  const load = () => {\n    if(noAutoDownload && !withoutPreloader) {\n      preloader.construct();\n      preloader.setManual();\n    }\n\n    const promise = getDownloadPromise();\n\n    if(!cacheContext.downloaded && !withoutPreloader && (size as PhotoSize.photoSize).w >= 150 && (size as PhotoSize.photoSize).h >= 150) {\n      preloader.attach(container, false, promise);\n    }\n\n    const renderPromise = promise.then(onLoad);\n    renderPromise.catch(() => {});\n    return {download: promise, render: renderPromise};\n  };\n\n  preloader.setDownloadFunction(load);\n  \n  if(cacheContext.downloaded) {\n    loadThumbPromise = loadPromise = load().render;\n  } else {\n    if(!lazyLoadQueue) loadPromise = load().render;\n    /* else if(noAutoDownload) {\n      preloader.construct();\n      preloader.setManual();\n      preloader.attach(container);\n    } */ else lazyLoadQueue.push({div: container, load: () => load().download});\n  }\n\n  if(loadPromises && loadThumbPromise) {\n    loadPromises.push(loadThumbPromise);\n  }\n\n  return {\n    loadPromises: {\n      thumb: loadThumbPromise,\n      full: loadPromise || Promise.resolve()\n    },\n    images: {\n      thumb: thumbImage,\n      full: image\n    },\n    preloader,\n    aspecter\n  };\n}\n\nexport function wrapSticker({doc, div, middleware, lazyLoadQueue, group, play, onlyThumb, emoji, width, height, withThumb, loop, loadPromises, needFadeIn}: {\n  doc: MyDocument, \n  div: HTMLElement, \n  middleware?: () => boolean, \n  lazyLoadQueue?: LazyLoadQueue, \n  group?: string, \n  play?: boolean, \n  onlyThumb?: boolean,\n  emoji?: string,\n  width?: number,\n  height?: number,\n  withThumb?: boolean,\n  loop?: boolean,\n  loadPromises?: Promise<any>[],\n  needFadeIn?: boolean,\n}) {\n  const stickerType = doc.sticker;\n\n  if(!width) {\n    width = !emoji ? 200 : undefined;\n  }\n\n  if(!height) {\n    height = !emoji ? 200 : undefined;\n  }\n\n  if(stickerType === 2 && !LottieLoader.loaded) {\n    //LottieLoader.loadLottie();\n    LottieLoader.loadLottieWorkers();\n  }\n  \n  if(!stickerType) {\n    console.error('wrong doc for wrapSticker!', doc);\n    throw new Error('wrong doc for wrapSticker!');\n  }\n\n  div.dataset.docId = doc.id;\n  div.classList.add('media-sticker-wrapper');\n  \n  //console.log('wrap sticker', doc, div, onlyThumb);\n\n  const cacheContext = appDownloadManager.getCacheContext(doc);\n\n  const toneIndex = emoji ? getEmojiToneIndex(emoji) : -1;\n  const downloaded = cacheContext.downloaded && !needFadeIn;\n  \n  let loadThumbPromise = deferredPromise<void>();\n  let haveThumbCached = false;\n  if((doc.thumbs?.length || doc.stickerCachedThumbs) && !div.firstElementChild && (!downloaded || stickerType === 2 || onlyThumb)/*  && doc.thumbs[0]._ !== 'photoSizeEmpty' */) {\n    let thumb = doc.stickerCachedThumbs && doc.stickerCachedThumbs[toneIndex] || doc.thumbs[0];\n    \n    //console.log('wrap sticker', thumb, div);\n\n    let thumbImage: HTMLImageElement;\n    const afterRender = () => {\n      if(!div.childElementCount) {\n        thumbImage.classList.add('media-sticker', 'thumbnail');\n        \n        sequentialDom.mutateElement(div, () => {\n          div.append(thumbImage);\n          loadThumbPromise.resolve();\n        });\n      }\n    };\n\n    if('url' in thumb) {\n      thumbImage = new Image();\n      renderImageFromUrl(thumbImage, thumb.url, afterRender);\n      haveThumbCached = true;\n    } else if('bytes' in thumb) {\n      if(thumb._ === 'photoPathSize') {\n        if(thumb.bytes.length) {\n          const d = appPhotosManager.getPathFromPhotoPathSize(thumb);\n          div.innerHTML = `<svg class=\"rlottie-vector media-sticker thumbnail\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 ${doc.w || 512} ${doc.h || 512}\" xml:space=\"preserve\">\n            <path d=\"${d}\"/>\n          </svg>`;\n        } else {\n          thumb = doc.thumbs.find(t => (t as PhotoSize.photoStrippedSize).bytes?.length) || thumb;\n        }\n      } \n      \n      if(thumb && thumb._ !== 'photoPathSize' && toneIndex <= 0) {\n        thumbImage = new Image();\n\n        if((webpWorkerController.isWebpSupported() || doc.pFlags.stickerThumbConverted || cacheContext.url)/*  && false */) {\n          renderImageFromUrl(thumbImage, appPhotosManager.getPreviewURLFromThumb(doc, thumb as PhotoSize.photoStrippedSize, true), afterRender);\n          haveThumbCached = true;\n        } else {\n          webpWorkerController.convert(doc.id, (thumb as PhotoSize.photoStrippedSize).bytes as Uint8Array).then(bytes => {\n            (thumb as PhotoSize.photoStrippedSize).bytes = bytes;\n            doc.pFlags.stickerThumbConverted = true;\n            \n            if(middleware && !middleware()) return;\n  \n            if(!div.childElementCount) {\n              renderImageFromUrl(thumbImage, appPhotosManager.getPreviewURLFromThumb(doc, thumb as PhotoSize.photoStrippedSize, true), afterRender);\n            }\n          }).catch(() => {});\n        }\n      }\n    } else if(stickerType === 2 && (withThumb || onlyThumb) && toneIndex <= 0) {\n      thumbImage = new Image();\n\n      const load = () => {\n        if(div.childElementCount || (middleware && !middleware())) return;\n\n        const r = () => {\n          if(div.childElementCount || (middleware && !middleware())) return;\n          renderImageFromUrl(thumbImage, cacheContext.url, afterRender);\n        };\n  \n        if(cacheContext.url) {\n          r();\n          return Promise.resolve();\n        } else {\n          return appDocsManager.getThumbURL(doc, thumb as PhotoSize.photoStrippedSize).promise.then(r);\n        }\n      };\n      \n      if(lazyLoadQueue && onlyThumb) {\n        lazyLoadQueue.push({div, load});\n        return Promise.resolve();\n      } else {\n        load();\n\n        if((thumb as any).url) {\n          haveThumbCached = true;\n        }\n      }\n    }\n  }\n\n  if(loadPromises && haveThumbCached) {\n    loadPromises.push(loadThumbPromise);\n  }\n\n  if(onlyThumb) { // for sticker panel\n    return Promise.resolve();\n  }\n  \n  const load = async() => {\n    if(middleware && !middleware()) return;\n\n    if(stickerType === 2) {\n      /* if(doc.id === '1860749763008266301') {\n        console.log('loaded sticker:', doc, div);\n      } */\n\n      //await new Promise((resolve) => setTimeout(resolve, 500));\n      //return;\n\n      //console.time('download sticker' + doc.id);\n\n      //appDocsManager.downloadDocNew(doc.id).promise.then(res => res.json()).then(async(json) => {\n      //fetch(doc.url).then(res => res.json()).then(async(json) => {\n      /* return */ await appDocsManager.downloadDoc(doc, /* undefined,  */lazyLoadQueue?.queueId)\n      .then(readBlobAsText)\n      //.then(JSON.parse)\n      .then(async(json) => {\n        //console.timeEnd('download sticker' + doc.id);\n        //console.log('loaded sticker:', doc, div/* , blob */);\n        if(middleware && !middleware()) return;\n\n        let animation = await LottieLoader.loadAnimationWorker({\n          container: div,\n          loop: loop && !emoji,\n          autoplay: play,\n          animationData: json,\n          width,\n          height\n        }, group, toneIndex);\n\n        //const deferred = deferredPromise<void>();\n  \n        animation.addEventListener('firstFrame', () => {\n          const element = div.firstElementChild;\n          needFadeIn = (needFadeIn || !element || element.tagName === 'svg') && rootScope.settings.animationsEnabled;\n\n          const cb = () => {\n            if(element && element !== animation.canvas) {\n              element.remove();\n            }\n          };\n\n          if(!needFadeIn) {\n            if(element) {\n              sequentialDom.mutate(cb);\n            }\n          } else {\n            sequentialDom.mutate(() => {\n              animation.canvas.classList.add('fade-in');\n              if(element) {\n                element.classList.add('fade-out');\n              }\n  \n              animation.canvas.addEventListener('animationend', () => {\n                sequentialDom.mutate(() => {\n                  animation.canvas.classList.remove('fade-in');\n                  cb();\n                });\n              }, {once: true});\n            });\n          }\n\n          appDocsManager.saveLottiePreview(doc, animation.canvas, toneIndex);\n\n          //deferred.resolve();\n        }, {once: true});\n  \n        if(emoji) {\n          attachClickEvent(div, (e) => {\n            cancelEvent(e);\n            let animation = LottieLoader.getAnimation(div);\n  \n            if(animation.paused) {\n              animation.autoplay = true;\n              animation.restart();\n            }\n          });\n        }\n\n        //return deferred;\n        //await new Promise((resolve) => setTimeout(resolve, 5e3));\n      });\n\n      //console.timeEnd('render sticker' + doc.id);\n    } else if(stickerType === 1) {\n      const image = new Image();\n      const thumbImage = div.firstElementChild !== image && div.firstElementChild;\n      needFadeIn = (needFadeIn || !downloaded || thumbImage) && rootScope.settings.animationsEnabled;\n\n      image.classList.add('media-sticker');\n\n      if(needFadeIn) {\n        image.classList.add('fade-in');\n      }\n\n      return new Promise<void>((resolve, reject) => {\n        const r = () => {\n          if(middleware && !middleware()) return resolve();\n  \n          renderImageFromUrl(image, cacheContext.url, () => {\n            sequentialDom.mutateElement(div, () => {\n              div.append(image);\n              if(thumbImage) {\n                thumbImage.classList.add('fade-out');\n              }\n\n              resolve();\n\n              if(needFadeIn) {\n                image.addEventListener('animationend', () => {\n                  image.classList.remove('fade-in');\n                  if(thumbImage) {\n                    thumbImage.remove();\n                  }\n                }, {once: true});\n              }\n            });\n          });\n        };\n  \n        if(cacheContext.url) r();\n        else {\n          appDocsManager.downloadDoc(doc, /* undefined,  */lazyLoadQueue?.queueId).then(r, resolve);\n        }\n      });\n    }\n  };\n\n  const loadPromise: Promise<any> = lazyLoadQueue && (!downloaded || stickerType === 2) ? \n    (lazyLoadQueue.push({div, load}), Promise.resolve()) : \n    load();\n\n  if(downloaded && stickerType === 1) {\n    loadThumbPromise = loadPromise;\n    if(loadPromises) {\n      loadPromises.push(loadThumbPromise);\n    }\n  }\n\n  return loadPromise;\n}\n\nexport async function wrapStickerSetThumb({set, lazyLoadQueue, container, group, autoplay, width, height}: {\n  set: StickerSet.stickerSet,\n  lazyLoadQueue: LazyLoadQueue,\n  container: HTMLElement,\n  group: string,\n  autoplay: boolean,\n  width: number,\n  height: number\n}) {\n  if(set.thumbs?.length) {\n    container.classList.add('media-sticker-wrapper');\n    lazyLoadQueue.push({\n      div: container,\n      load: () => {\n        const downloadOptions = appStickersManager.getStickerSetThumbDownloadOptions(set);\n        const promise = appDownloadManager.download(downloadOptions);\n\n        if(set.pFlags.animated) {\n          return promise\n          .then(readBlobAsText)\n          //.then(JSON.parse)\n          .then(json => {\n            lottieLoader.loadAnimationWorker({\n              container,\n              loop: true,\n              autoplay,\n              animationData: json,\n              width,\n              height,\n              needUpscale: true\n            }, group);\n          });\n        } else {\n          const image = new Image();\n          image.classList.add('media-sticker');\n  \n          return promise.then(blob => {\n            renderImageFromUrl(image, URL.createObjectURL(blob), () => {\n              container.append(image);\n            });\n          });\n        }\n      }\n    });\n\n    return;\n  }\n\n  const promise = appStickersManager.getStickerSet(set);\n  const stickerSet = await promise;\n  if(stickerSet.documents[0]._ !== 'documentEmpty') { // as thumb will be used first sticker\n    wrapSticker({\n      doc: stickerSet.documents[0],\n      div: container, \n      group: group,\n      lazyLoadQueue\n    }); // kostil\n  }\n}\n\nexport function wrapLocalSticker({emoji, width, height}: {\n  doc?: MyDocument,\n  url?: string,\n  emoji?: string,\n  width: number,\n  height: number,\n}) {\n  const container = document.createElement('div');\n\n  const doc = appStickersManager.getAnimatedEmojiSticker(emoji);\n  if(doc) {\n    wrapSticker({\n      doc,\n      div: container,\n      loop: false,\n      play: true,\n      width,\n      height,\n      emoji\n    }).then(() => {\n      // this.animation = player;\n    });\n  } else {\n    container.classList.add('media-sticker-wrapper');\n  }\n\n  return {container};\n}\n\nexport function wrapReply(title: string | HTMLElement, subtitle: string | HTMLElement, message?: any) {\n  const replyContainer = new ReplyContainer('reply');\n  replyContainer.fill(title, subtitle, message);\n  /////////console.log('wrapReply', title, subtitle, media);\n  return replyContainer.container;\n}\n\nexport function prepareAlbum(options: {\n  container: HTMLElement,\n  items: {w: number, h: number}[],\n  maxWidth: number,\n  minWidth: number,\n  spacing: number,\n  maxHeight?: number,\n  forMedia?: true\n}) {\n  const layouter = new Layouter(options.items, options.maxWidth, options.minWidth, options.spacing, options.maxHeight);\n  const layout = layouter.layout();\n\n  const widthItem = layout.find(item => item.sides & RectPart.Right);\n  const width = widthItem.geometry.width + widthItem.geometry.x;\n\n  const heightItem = layout.find(item => item.sides & RectPart.Bottom);\n  const height = heightItem.geometry.height + heightItem.geometry.y;\n\n  const container = options.container;\n  container.style.width = width + 'px';\n  container.style.height = height + 'px';\n  const children = container.children;\n\n  layout.forEach(({geometry, sides}, idx) => {\n    let div: HTMLElement;\n    div = children[idx] as HTMLElement;\n    if(!div) {\n      div = document.createElement('div');\n      container.append(div);\n    }\n\n    div.classList.add('album-item', 'grouped-item');\n\n    div.style.width = (geometry.width / width * 100) + '%';\n    div.style.height = (geometry.height / height * 100) + '%';\n    div.style.top = (geometry.y / height * 100) + '%';\n    div.style.left = (geometry.x / width * 100) + '%';\n\n    if(sides & RectPart.Left && sides & RectPart.Top) {\n      div.style.borderTopLeftRadius = 'inherit';\n    }\n\n    if(sides & RectPart.Left && sides & RectPart.Bottom) {\n      div.style.borderBottomLeftRadius = 'inherit';\n    }\n\n    if(sides & RectPart.Right && sides & RectPart.Top) {\n      div.style.borderTopRightRadius = 'inherit';\n    }\n\n    if(sides & RectPart.Right && sides & RectPart.Bottom) {\n      div.style.borderBottomRightRadius = 'inherit';\n    }\n\n    if(options.forMedia) {\n      const mediaDiv = document.createElement('div');\n      mediaDiv.classList.add('album-item-media');\n  \n      div.append(mediaDiv);\n    }\n\n    // @ts-ignore\n    //div.style.backgroundColor = '#' + Math.floor(Math.random() * (2 ** 24 - 1)).toString(16).padStart(6, '0');\n  });\n\n  /* if(options.forMedia) {\n    layout.forEach((_, i) => {\n      const mediaDiv = document.createElement('div');\n      mediaDiv.classList.add('album-item-media');\n  \n      options.container.children[i].append(mediaDiv);\n    });\n  } */\n}\n\nexport function wrapAlbum({groupId, attachmentDiv, middleware, uploading, lazyLoadQueue, isOut, chat, loadPromises, noAutoDownload}: {\n  groupId: string, \n  attachmentDiv: HTMLElement,\n  middleware?: () => boolean,\n  lazyLoadQueue?: LazyLoadQueue,\n  uploading?: boolean,\n  isOut: boolean,\n  chat: Chat,\n  loadPromises?: Promise<any>[],\n  noAutoDownload?: boolean,\n}) {\n  const items: {size: PhotoSize.photoSize, media: any, message: any}[] = [];\n\n  // !lowest msgID will be the FIRST in album\n  const storage = appMessagesManager.getMidsByAlbum(groupId);\n  for(const mid of storage) {\n    const m = chat.getMessage(mid);\n    const media = m.media.photo || m.media.document;\n\n    const size: any = media._ === 'photo' ? appPhotosManager.choosePhotoSize(media, 480, 480) : {w: media.w, h: media.h};\n    items.push({size, media, message: m});\n  }\n\n  /* // * pending\n  if(storage[0] < 0) {\n    items.reverse();\n  } */\n\n  prepareAlbum({\n    container: attachmentDiv,\n    items: items.map(i => ({w: i.size.w, h: i.size.h})),\n    maxWidth: mediaSizes.active.album.width,\n    minWidth: 100,\n    spacing: 2,\n    forMedia: true\n  });\n\n  items.forEach((item, idx) => {\n    const {size, media, message} = item;\n\n    const div = attachmentDiv.children[idx] as HTMLElement;\n    div.dataset.mid = '' + message.mid;\n    const mediaDiv = div.firstElementChild as HTMLElement;\n    if(media._ === 'photo') {\n      wrapPhoto({\n        photo: media,\n        message,\n        container: mediaDiv,\n        boxWidth: 0,\n        boxHeight: 0,\n        isOut,\n        lazyLoadQueue,\n        middleware,\n        size,\n        loadPromises,\n        noAutoDownload\n      });\n    } else {\n      wrapVideo({\n        doc: message.media.document,\n        container: mediaDiv,\n        message,\n        boxWidth: 0,\n        boxHeight: 0,\n        withTail: false,\n        isOut,\n        lazyLoadQueue,\n        middleware,\n        loadPromises,\n        noAutoDownload\n      });\n    }\n  });\n}\n\nexport function wrapGroupedDocuments({albumMustBeRenderedFull, message, bubble, messageDiv, chat, loadPromises, noAutoDownload}: {\n  albumMustBeRenderedFull: boolean,\n  message: any,\n  messageDiv: HTMLElement,\n  bubble: HTMLElement,\n  uploading?: boolean,\n  chat: Chat,\n  loadPromises?: Promise<any>[],\n  noAutoDownload?: boolean,\n}) {\n  let nameContainer: HTMLElement;\n  const mids = albumMustBeRenderedFull ? chat.getMidsByMid(message.mid) : [message.mid];\n  /* if(isPending) {\n    mids.reverse();\n  } */\n\n  mids.forEach((mid, idx) => {\n    const message = chat.getMessage(mid);\n    const div = wrapDocument({\n      message,\n      loadPromises,\n      noAutoDownload\n    });\n\n    const container = document.createElement('div');\n    container.classList.add('document-container');\n    container.dataset.mid = '' + mid;\n\n    const wrapper = document.createElement('div');\n    wrapper.classList.add('document-wrapper');\n    \n    if(message.message) {\n      const messageDiv = document.createElement('div');\n      messageDiv.classList.add('document-message');\n\n      const richText = RichTextProcessor.wrapRichText(message.message, {\n        entities: message.totalEntities\n      });\n\n      messageDiv.innerHTML = richText;\n      wrapper.append(messageDiv);\n    }\n\n    if(mids.length > 1) {\n      const selection = document.createElement('div');\n      selection.classList.add('document-selection');\n      container.append(selection);\n      \n      container.classList.add('grouped-item');\n\n      if(idx === 0) {\n        nameContainer = wrapper;\n      }\n    }\n\n    wrapper.append(div);\n    container.append(wrapper);\n    messageDiv.append(container);\n  });\n\n  if(mids.length > 1) {\n    bubble.classList.add('is-multiple-documents', 'is-grouped');\n  }\n\n  return nameContainer;\n}\n\nexport function wrapPoll(message: any) {\n  const elem = new PollElement();\n  elem.message = message;\n  elem.setAttribute('peer-id', '' + message.peerId);\n  elem.setAttribute('poll-id', message.media.poll.id);\n  elem.setAttribute('message-id', '' + message.mid);\n  elem.render();\n  return elem;\n}\n", "/**\n * @link https://core.telegram.org/type/Error\n */\nexport type Error = Error.error;\n\nexport namespace Error {\n  export type error = {\n\t\t_: 'error',\n\t\tcode: number,\n\t\ttext: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputPeer\n */\nexport type InputPeer = InputPeer.inputPeerEmpty | InputPeer.inputPeerSelf | InputPeer.inputPeerChat | InputPeer.inputPeerUser | InputPeer.inputPeerChannel | InputPeer.inputPeerUserFromMessage | InputPeer.inputPeerChannelFromMessage;\n\nexport namespace InputPeer {\n  export type inputPeerEmpty = {\n\t\t_: 'inputPeerEmpty'\n\t};\n\n\texport type inputPeerSelf = {\n\t\t_: 'inputPeerSelf'\n\t};\n\n\texport type inputPeerChat = {\n\t\t_: 'inputPeerChat',\n\t\tchat_id: number\n\t};\n\n\texport type inputPeerUser = {\n\t\t_: 'inputPeerUser',\n\t\tuser_id: number,\n\t\taccess_hash: string\n\t};\n\n\texport type inputPeerChannel = {\n\t\t_: 'inputPeerChannel',\n\t\tchannel_id: number,\n\t\taccess_hash: string\n\t};\n\n\texport type inputPeerUserFromMessage = {\n\t\t_: 'inputPeerUserFromMessage',\n\t\tpeer: InputPeer,\n\t\tmsg_id: number,\n\t\tuser_id: number\n\t};\n\n\texport type inputPeerChannelFromMessage = {\n\t\t_: 'inputPeerChannelFromMessage',\n\t\tpeer: InputPeer,\n\t\tmsg_id: number,\n\t\tchannel_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputUser\n */\nexport type InputUser = InputUser.inputUserEmpty | InputUser.inputUserSelf | InputUser.inputUser | InputUser.inputUserFromMessage;\n\nexport namespace InputUser {\n  export type inputUserEmpty = {\n\t\t_: 'inputUserEmpty'\n\t};\n\n\texport type inputUserSelf = {\n\t\t_: 'inputUserSelf'\n\t};\n\n\texport type inputUser = {\n\t\t_: 'inputUser',\n\t\tuser_id: number,\n\t\taccess_hash: string\n\t};\n\n\texport type inputUserFromMessage = {\n\t\t_: 'inputUserFromMessage',\n\t\tpeer: InputPeer,\n\t\tmsg_id: number,\n\t\tuser_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputContact\n */\nexport type InputContact = InputContact.inputPhoneContact;\n\nexport namespace InputContact {\n  export type inputPhoneContact = {\n\t\t_: 'inputPhoneContact',\n\t\tclient_id: string,\n\t\tphone: string,\n\t\tfirst_name: string,\n\t\tlast_name: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputFile\n */\nexport type InputFile = InputFile.inputFile | InputFile.inputFileBig;\n\nexport namespace InputFile {\n  export type inputFile = {\n\t\t_: 'inputFile',\n\t\tid: string,\n\t\tparts: number,\n\t\tname: string,\n\t\tmd5_checksum: string\n\t};\n\n\texport type inputFileBig = {\n\t\t_: 'inputFileBig',\n\t\tid: string,\n\t\tparts: number,\n\t\tname: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputMedia\n */\nexport type InputMedia = InputMedia.inputMediaEmpty | InputMedia.inputMediaUploadedPhoto | InputMedia.inputMediaPhoto | InputMedia.inputMediaGeoPoint | InputMedia.inputMediaContact | InputMedia.inputMediaUploadedDocument | InputMedia.inputMediaDocument | InputMedia.inputMediaVenue | InputMedia.inputMediaPhotoExternal | InputMedia.inputMediaDocumentExternal | InputMedia.inputMediaGame | InputMedia.inputMediaInvoice | InputMedia.inputMediaGeoLive | InputMedia.inputMediaPoll | InputMedia.inputMediaDice;\n\nexport namespace InputMedia {\n  export type inputMediaEmpty = {\n\t\t_: 'inputMediaEmpty'\n\t};\n\n\texport type inputMediaUploadedPhoto = {\n\t\t_: 'inputMediaUploadedPhoto',\n\t\tflags?: number,\n\t\tfile: InputFile,\n\t\tstickers?: Array<InputDocument>,\n\t\tttl_seconds?: number\n\t};\n\n\texport type inputMediaPhoto = {\n\t\t_: 'inputMediaPhoto',\n\t\tflags?: number,\n\t\tid: InputPhoto,\n\t\tttl_seconds?: number\n\t};\n\n\texport type inputMediaGeoPoint = {\n\t\t_: 'inputMediaGeoPoint',\n\t\tgeo_point: InputGeoPoint\n\t};\n\n\texport type inputMediaContact = {\n\t\t_: 'inputMediaContact',\n\t\tphone_number: string,\n\t\tfirst_name: string,\n\t\tlast_name: string,\n\t\tvcard: string\n\t};\n\n\texport type inputMediaUploadedDocument = {\n\t\t_: 'inputMediaUploadedDocument',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tnosound_video?: true,\n\t\t\tforce_file?: true,\n\t\t}>,\n\t\tfile: InputFile,\n\t\tthumb?: InputFile,\n\t\tmime_type: string,\n\t\tattributes: Array<DocumentAttribute>,\n\t\tstickers?: Array<InputDocument>,\n\t\tttl_seconds?: number\n\t};\n\n\texport type inputMediaDocument = {\n\t\t_: 'inputMediaDocument',\n\t\tflags?: number,\n\t\tid: InputDocument,\n\t\tttl_seconds?: number,\n\t\tquery?: string\n\t};\n\n\texport type inputMediaVenue = {\n\t\t_: 'inputMediaVenue',\n\t\tgeo_point: InputGeoPoint,\n\t\ttitle: string,\n\t\taddress: string,\n\t\tprovider: string,\n\t\tvenue_id: string,\n\t\tvenue_type: string\n\t};\n\n\texport type inputMediaPhotoExternal = {\n\t\t_: 'inputMediaPhotoExternal',\n\t\tflags?: number,\n\t\turl: string,\n\t\tttl_seconds?: number\n\t};\n\n\texport type inputMediaDocumentExternal = {\n\t\t_: 'inputMediaDocumentExternal',\n\t\tflags?: number,\n\t\turl: string,\n\t\tttl_seconds?: number\n\t};\n\n\texport type inputMediaGame = {\n\t\t_: 'inputMediaGame',\n\t\tid: InputGame\n\t};\n\n\texport type inputMediaInvoice = {\n\t\t_: 'inputMediaInvoice',\n\t\tflags?: number,\n\t\ttitle: string,\n\t\tdescription: string,\n\t\tphoto?: InputWebDocument,\n\t\tinvoice: Invoice,\n\t\tpayload: Uint8Array,\n\t\tprovider: string,\n\t\tprovider_data: DataJSON,\n\t\tstart_param?: string\n\t};\n\n\texport type inputMediaGeoLive = {\n\t\t_: 'inputMediaGeoLive',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tstopped?: true,\n\t\t}>,\n\t\tgeo_point: InputGeoPoint,\n\t\theading?: number,\n\t\tperiod?: number,\n\t\tproximity_notification_radius?: number\n\t};\n\n\texport type inputMediaPoll = {\n\t\t_: 'inputMediaPoll',\n\t\tflags?: number,\n\t\tpoll: Poll,\n\t\tcorrect_answers?: Array<Uint8Array>,\n\t\tsolution?: string,\n\t\tsolution_entities?: Array<MessageEntity>\n\t};\n\n\texport type inputMediaDice = {\n\t\t_: 'inputMediaDice',\n\t\temoticon: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputChatPhoto\n */\nexport type InputChatPhoto = InputChatPhoto.inputChatPhotoEmpty | InputChatPhoto.inputChatUploadedPhoto | InputChatPhoto.inputChatPhoto;\n\nexport namespace InputChatPhoto {\n  export type inputChatPhotoEmpty = {\n\t\t_: 'inputChatPhotoEmpty'\n\t};\n\n\texport type inputChatUploadedPhoto = {\n\t\t_: 'inputChatUploadedPhoto',\n\t\tflags?: number,\n\t\tfile?: InputFile,\n\t\tvideo?: InputFile,\n\t\tvideo_start_ts?: number\n\t};\n\n\texport type inputChatPhoto = {\n\t\t_: 'inputChatPhoto',\n\t\tid: InputPhoto\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputGeoPoint\n */\nexport type InputGeoPoint = InputGeoPoint.inputGeoPointEmpty | InputGeoPoint.inputGeoPoint;\n\nexport namespace InputGeoPoint {\n  export type inputGeoPointEmpty = {\n\t\t_: 'inputGeoPointEmpty'\n\t};\n\n\texport type inputGeoPoint = {\n\t\t_: 'inputGeoPoint',\n\t\tflags?: number,\n\t\tlat: number,\n\t\tlong: number,\n\t\taccuracy_radius?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputPhoto\n */\nexport type InputPhoto = InputPhoto.inputPhotoEmpty | InputPhoto.inputPhoto;\n\nexport namespace InputPhoto {\n  export type inputPhotoEmpty = {\n\t\t_: 'inputPhotoEmpty'\n\t};\n\n\texport type inputPhoto = {\n\t\t_: 'inputPhoto',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tfile_reference: Uint8Array | number[]\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputFileLocation\n */\nexport type InputFileLocation = InputFileLocation.inputFileLocation | InputFileLocation.inputEncryptedFileLocation | InputFileLocation.inputDocumentFileLocation | InputFileLocation.inputSecureFileLocation | InputFileLocation.inputTakeoutFileLocation | InputFileLocation.inputPhotoFileLocation | InputFileLocation.inputPhotoLegacyFileLocation | InputFileLocation.inputPeerPhotoFileLocation | InputFileLocation.inputStickerSetThumb | InputFileLocation.inputGroupCallStream;\n\nexport namespace InputFileLocation {\n  export type inputFileLocation = {\n\t\t_: 'inputFileLocation',\n\t\tvolume_id: string,\n\t\tlocal_id: number,\n\t\tsecret: string,\n\t\tfile_reference: Uint8Array | number[]\n\t};\n\n\texport type inputEncryptedFileLocation = {\n\t\t_: 'inputEncryptedFileLocation',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputDocumentFileLocation = {\n\t\t_: 'inputDocumentFileLocation',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tfile_reference: Uint8Array | number[],\n\t\tthumb_size: string,\n\t\tcheckedReference?: boolean\n\t};\n\n\texport type inputSecureFileLocation = {\n\t\t_: 'inputSecureFileLocation',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputTakeoutFileLocation = {\n\t\t_: 'inputTakeoutFileLocation'\n\t};\n\n\texport type inputPhotoFileLocation = {\n\t\t_: 'inputPhotoFileLocation',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tfile_reference: Uint8Array | number[],\n\t\tthumb_size: string\n\t};\n\n\texport type inputPhotoLegacyFileLocation = {\n\t\t_: 'inputPhotoLegacyFileLocation',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tfile_reference: Uint8Array | number[],\n\t\tvolume_id: string,\n\t\tlocal_id: number,\n\t\tsecret: string\n\t};\n\n\texport type inputPeerPhotoFileLocation = {\n\t\t_: 'inputPeerPhotoFileLocation',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tbig?: true,\n\t\t}>,\n\t\tpeer: InputPeer,\n\t\tphoto_id: string\n\t};\n\n\texport type inputStickerSetThumb = {\n\t\t_: 'inputStickerSetThumb',\n\t\tstickerset: InputStickerSet,\n\t\tthumb_version: number\n\t};\n\n\texport type inputGroupCallStream = {\n\t\t_: 'inputGroupCallStream',\n\t\tcall: InputGroupCall,\n\t\ttime_ms: string,\n\t\tscale: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Peer\n */\nexport type Peer = Peer.peerUser | Peer.peerChat | Peer.peerChannel;\n\nexport namespace Peer {\n  export type peerUser = {\n\t\t_: 'peerUser',\n\t\tuser_id: number\n\t};\n\n\texport type peerChat = {\n\t\t_: 'peerChat',\n\t\tchat_id: number\n\t};\n\n\texport type peerChannel = {\n\t\t_: 'peerChannel',\n\t\tchannel_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/storage.FileType\n */\nexport type StorageFileType = StorageFileType.storageFileUnknown | StorageFileType.storageFilePartial | StorageFileType.storageFileJpeg | StorageFileType.storageFileGif | StorageFileType.storageFilePng | StorageFileType.storageFilePdf | StorageFileType.storageFileMp3 | StorageFileType.storageFileMov | StorageFileType.storageFileMp4 | StorageFileType.storageFileWebp;\n\nexport namespace StorageFileType {\n  export type storageFileUnknown = {\n\t\t_: 'storage.fileUnknown'\n\t};\n\n\texport type storageFilePartial = {\n\t\t_: 'storage.filePartial'\n\t};\n\n\texport type storageFileJpeg = {\n\t\t_: 'storage.fileJpeg'\n\t};\n\n\texport type storageFileGif = {\n\t\t_: 'storage.fileGif'\n\t};\n\n\texport type storageFilePng = {\n\t\t_: 'storage.filePng'\n\t};\n\n\texport type storageFilePdf = {\n\t\t_: 'storage.filePdf'\n\t};\n\n\texport type storageFileMp3 = {\n\t\t_: 'storage.fileMp3'\n\t};\n\n\texport type storageFileMov = {\n\t\t_: 'storage.fileMov'\n\t};\n\n\texport type storageFileMp4 = {\n\t\t_: 'storage.fileMp4'\n\t};\n\n\texport type storageFileWebp = {\n\t\t_: 'storage.fileWebp'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/User\n */\nexport type User = User.userEmpty | User.user;\n\nexport namespace User {\n  export type userEmpty = {\n\t\t_: 'userEmpty',\n\t\tid: number\n\t};\n\n\texport type user = {\n\t\t_: 'user',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tself?: true,\n\t\t\tcontact?: true,\n\t\t\tmutual_contact?: true,\n\t\t\tdeleted?: true,\n\t\t\tbot?: true,\n\t\t\tbot_chat_history?: true,\n\t\t\tbot_nochats?: true,\n\t\t\tverified?: true,\n\t\t\trestricted?: true,\n\t\t\tmin?: true,\n\t\t\tbot_inline_geo?: true,\n\t\t\tsupport?: true,\n\t\t\tscam?: true,\n\t\t\tapply_min_photo?: true,\n\t\t\tfake?: true,\n\t\t}>,\n\t\tid: number,\n\t\taccess_hash?: string,\n\t\tfirst_name?: string,\n\t\tlast_name?: string,\n\t\tusername?: string,\n\t\tphone?: string,\n\t\tphoto?: UserProfilePhoto,\n\t\tstatus?: UserStatus,\n\t\tbot_info_version?: number,\n\t\trestriction_reason?: Array<RestrictionReason>,\n\t\tbot_inline_placeholder?: string,\n\t\tlang_code?: string,\n\t\tinitials?: string,\n\t\tsortName?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/UserProfilePhoto\n */\nexport type UserProfilePhoto = UserProfilePhoto.userProfilePhotoEmpty | UserProfilePhoto.userProfilePhoto;\n\nexport namespace UserProfilePhoto {\n  export type userProfilePhotoEmpty = {\n\t\t_: 'userProfilePhotoEmpty'\n\t};\n\n\texport type userProfilePhoto = {\n\t\t_: 'userProfilePhoto',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\thas_video?: true,\n\t\t}>,\n\t\tphoto_id: string,\n\t\tstripped_thumb?: Uint8Array,\n\t\tdc_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/UserStatus\n */\nexport type UserStatus = UserStatus.userStatusEmpty | UserStatus.userStatusOnline | UserStatus.userStatusOffline | UserStatus.userStatusRecently | UserStatus.userStatusLastWeek | UserStatus.userStatusLastMonth;\n\nexport namespace UserStatus {\n  export type userStatusEmpty = {\n\t\t_: 'userStatusEmpty'\n\t};\n\n\texport type userStatusOnline = {\n\t\t_: 'userStatusOnline',\n\t\texpires: number\n\t};\n\n\texport type userStatusOffline = {\n\t\t_: 'userStatusOffline',\n\t\twas_online: number\n\t};\n\n\texport type userStatusRecently = {\n\t\t_: 'userStatusRecently'\n\t};\n\n\texport type userStatusLastWeek = {\n\t\t_: 'userStatusLastWeek'\n\t};\n\n\texport type userStatusLastMonth = {\n\t\t_: 'userStatusLastMonth'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Chat\n */\nexport type Chat = Chat.chatEmpty | Chat.chat | Chat.chatForbidden | Chat.channel | Chat.channelForbidden;\n\nexport namespace Chat {\n  export type chatEmpty = {\n\t\t_: 'chatEmpty',\n\t\tid: number\n\t};\n\n\texport type chat = {\n\t\t_: 'chat',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcreator?: true,\n\t\t\tkicked?: true,\n\t\t\tleft?: true,\n\t\t\tdeactivated?: true,\n\t\t\tcall_active?: true,\n\t\t\tcall_not_empty?: true,\n\t\t}>,\n\t\tid: number,\n\t\ttitle: string,\n\t\tphoto: ChatPhoto,\n\t\tparticipants_count: number,\n\t\tdate: number,\n\t\tversion: number,\n\t\tmigrated_to?: InputChannel,\n\t\tadmin_rights?: ChatAdminRights,\n\t\tdefault_banned_rights?: ChatBannedRights,\n\t\tinitials?: string\n\t};\n\n\texport type chatForbidden = {\n\t\t_: 'chatForbidden',\n\t\tid: number,\n\t\ttitle: string,\n\t\tinitials?: string\n\t};\n\n\texport type channel = {\n\t\t_: 'channel',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcreator?: true,\n\t\t\tleft?: true,\n\t\t\tbroadcast?: true,\n\t\t\tverified?: true,\n\t\t\tmegagroup?: true,\n\t\t\trestricted?: true,\n\t\t\tsignatures?: true,\n\t\t\tmin?: true,\n\t\t\tscam?: true,\n\t\t\thas_link?: true,\n\t\t\thas_geo?: true,\n\t\t\tslowmode_enabled?: true,\n\t\t\tcall_active?: true,\n\t\t\tcall_not_empty?: true,\n\t\t\tfake?: true,\n\t\t\tgigagroup?: true,\n\t\t}>,\n\t\tid: number,\n\t\taccess_hash?: string,\n\t\ttitle: string,\n\t\tusername?: string,\n\t\tphoto: ChatPhoto,\n\t\tdate: number,\n\t\tversion: number,\n\t\trestriction_reason?: Array<RestrictionReason>,\n\t\tadmin_rights?: ChatAdminRights,\n\t\tbanned_rights?: ChatBannedRights,\n\t\tdefault_banned_rights?: ChatBannedRights,\n\t\tparticipants_count?: number,\n\t\tinitials?: string\n\t};\n\n\texport type channelForbidden = {\n\t\t_: 'channelForbidden',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tbroadcast?: true,\n\t\t\tmegagroup?: true,\n\t\t}>,\n\t\tid: number,\n\t\taccess_hash: string,\n\t\ttitle: string,\n\t\tuntil_date?: number,\n\t\tinitials?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatFull\n */\nexport type ChatFull = ChatFull.chatFull | ChatFull.channelFull;\n\nexport namespace ChatFull {\n  export type chatFull = {\n\t\t_: 'chatFull',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcan_set_username?: true,\n\t\t\thas_scheduled?: true,\n\t\t}>,\n\t\tid: number,\n\t\tabout: string,\n\t\tparticipants: ChatParticipants,\n\t\tchat_photo?: Photo,\n\t\tnotify_settings: PeerNotifySettings,\n\t\texported_invite?: ExportedChatInvite,\n\t\tbot_info?: Array<BotInfo>,\n\t\tpinned_msg_id?: number,\n\t\tfolder_id?: number,\n\t\tcall?: InputGroupCall,\n\t\tttl_period?: number,\n\t\tgroupcall_default_join_as?: Peer\n\t};\n\n\texport type channelFull = {\n\t\t_: 'channelFull',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcan_view_participants?: true,\n\t\t\tcan_set_username?: true,\n\t\t\tcan_set_stickers?: true,\n\t\t\thidden_prehistory?: true,\n\t\t\tcan_set_location?: true,\n\t\t\thas_scheduled?: true,\n\t\t\tcan_view_stats?: true,\n\t\t\tblocked?: true,\n\t\t}>,\n\t\tid: number,\n\t\tabout: string,\n\t\tparticipants_count?: number,\n\t\tadmins_count?: number,\n\t\tkicked_count?: number,\n\t\tbanned_count?: number,\n\t\tonline_count?: number,\n\t\tread_inbox_max_id: number,\n\t\tread_outbox_max_id: number,\n\t\tunread_count: number,\n\t\tchat_photo: Photo,\n\t\tnotify_settings: PeerNotifySettings,\n\t\texported_invite?: ExportedChatInvite,\n\t\tbot_info: Array<BotInfo>,\n\t\tmigrated_from_chat_id?: number,\n\t\tmigrated_from_max_id?: number,\n\t\tpinned_msg_id?: number,\n\t\tstickerset?: StickerSet,\n\t\tavailable_min_id?: number,\n\t\tfolder_id?: number,\n\t\tlinked_chat_id?: number,\n\t\tlocation?: ChannelLocation,\n\t\tslowmode_seconds?: number,\n\t\tslowmode_next_send_date?: number,\n\t\tstats_dc?: number,\n\t\tpts: number,\n\t\tcall?: InputGroupCall,\n\t\tttl_period?: number,\n\t\tpending_suggestions?: Array<string>,\n\t\tgroupcall_default_join_as?: Peer\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatParticipant\n */\nexport type ChatParticipant = ChatParticipant.chatParticipant | ChatParticipant.chatParticipantCreator | ChatParticipant.chatParticipantAdmin;\n\nexport namespace ChatParticipant {\n  export type chatParticipant = {\n\t\t_: 'chatParticipant',\n\t\tuser_id: number,\n\t\tinviter_id: number,\n\t\tdate: number\n\t};\n\n\texport type chatParticipantCreator = {\n\t\t_: 'chatParticipantCreator',\n\t\tuser_id: number\n\t};\n\n\texport type chatParticipantAdmin = {\n\t\t_: 'chatParticipantAdmin',\n\t\tuser_id: number,\n\t\tinviter_id: number,\n\t\tdate: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatParticipants\n */\nexport type ChatParticipants = ChatParticipants.chatParticipantsForbidden | ChatParticipants.chatParticipants;\n\nexport namespace ChatParticipants {\n  export type chatParticipantsForbidden = {\n\t\t_: 'chatParticipantsForbidden',\n\t\tflags?: number,\n\t\tchat_id: number,\n\t\tself_participant?: ChatParticipant\n\t};\n\n\texport type chatParticipants = {\n\t\t_: 'chatParticipants',\n\t\tchat_id: number,\n\t\tparticipants: Array<ChatParticipant>,\n\t\tversion: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatPhoto\n */\nexport type ChatPhoto = ChatPhoto.chatPhotoEmpty | ChatPhoto.chatPhoto;\n\nexport namespace ChatPhoto {\n  export type chatPhotoEmpty = {\n\t\t_: 'chatPhotoEmpty'\n\t};\n\n\texport type chatPhoto = {\n\t\t_: 'chatPhoto',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\thas_video?: true,\n\t\t}>,\n\t\tphoto_id: string,\n\t\tstripped_thumb?: Uint8Array,\n\t\tdc_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Message\n */\nexport type Message = Message.messageEmpty | Message.message | Message.messageService;\n\nexport namespace Message {\n  export type messageEmpty = {\n\t\t_: 'messageEmpty',\n\t\tflags?: number,\n\t\tid: number,\n\t\tpeer_id?: Peer,\n\t\tdeleted?: boolean\n\t};\n\n\texport type message = {\n\t\t_: 'message',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tout?: true,\n\t\t\tmentioned?: true,\n\t\t\tmedia_unread?: true,\n\t\t\tsilent?: true,\n\t\t\tpost?: true,\n\t\t\tfrom_scheduled?: true,\n\t\t\tlegacy?: true,\n\t\t\tedit_hide?: true,\n\t\t\tpinned?: true,\n\t\t\tunread?: true,\n\t\t\tis_outgoing?: true,\n\t\t}>,\n\t\tid: number,\n\t\tfrom_id?: Peer,\n\t\tpeer_id: Peer,\n\t\tfwd_from?: MessageFwdHeader,\n\t\tvia_bot_id?: number,\n\t\treply_to?: MessageReplyHeader,\n\t\tdate: number,\n\t\tmessage: string,\n\t\tmedia?: MessageMedia,\n\t\treply_markup?: ReplyMarkup,\n\t\tentities?: Array<MessageEntity>,\n\t\tviews?: number,\n\t\tforwards?: number,\n\t\treplies?: MessageReplies,\n\t\tedit_date?: number,\n\t\tpost_author?: string,\n\t\tgrouped_id?: string,\n\t\trestriction_reason?: Array<RestrictionReason>,\n\t\tttl_period?: number,\n\t\tmid?: number,\n\t\tdeleted?: boolean,\n\t\tpeerId?: number,\n\t\tfromId?: number,\n\t\trandom_id?: string,\n\t\trReply?: string,\n\t\tviaBotId?: number,\n\t\tclear_history?: boolean\n\t};\n\n\texport type messageService = {\n\t\t_: 'messageService',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tout?: true,\n\t\t\tmentioned?: true,\n\t\t\tmedia_unread?: true,\n\t\t\tsilent?: true,\n\t\t\tpost?: true,\n\t\t\tlegacy?: true,\n\t\t\tunread?: true,\n\t\t\tis_outgoing?: true,\n\t\t\tis_single?: true,\n\t\t}>,\n\t\tid: number,\n\t\tfrom_id?: Peer,\n\t\tpeer_id: Peer,\n\t\treply_to?: MessageReplyHeader,\n\t\tdate: number,\n\t\taction: MessageAction,\n\t\tttl_period?: number,\n\t\tmid?: number,\n\t\tdeleted?: boolean,\n\t\tpeerId?: number,\n\t\tfromId?: number,\n\t\trReply?: string,\n\t\tviaBotId?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageMedia\n */\nexport type MessageMedia = MessageMedia.messageMediaEmpty | MessageMedia.messageMediaPhoto | MessageMedia.messageMediaGeo | MessageMedia.messageMediaContact | MessageMedia.messageMediaUnsupported | MessageMedia.messageMediaDocument | MessageMedia.messageMediaWebPage | MessageMedia.messageMediaVenue | MessageMedia.messageMediaGame | MessageMedia.messageMediaInvoice | MessageMedia.messageMediaGeoLive | MessageMedia.messageMediaPoll | MessageMedia.messageMediaDice;\n\nexport namespace MessageMedia {\n  export type messageMediaEmpty = {\n\t\t_: 'messageMediaEmpty'\n\t};\n\n\texport type messageMediaPhoto = {\n\t\t_: 'messageMediaPhoto',\n\t\tflags?: number,\n\t\tphoto?: Photo,\n\t\tttl_seconds?: number\n\t};\n\n\texport type messageMediaGeo = {\n\t\t_: 'messageMediaGeo',\n\t\tgeo: GeoPoint\n\t};\n\n\texport type messageMediaContact = {\n\t\t_: 'messageMediaContact',\n\t\tphone_number: string,\n\t\tfirst_name: string,\n\t\tlast_name: string,\n\t\tvcard: string,\n\t\tuser_id: number\n\t};\n\n\texport type messageMediaUnsupported = {\n\t\t_: 'messageMediaUnsupported'\n\t};\n\n\texport type messageMediaDocument = {\n\t\t_: 'messageMediaDocument',\n\t\tflags?: number,\n\t\tdocument?: Document,\n\t\tttl_seconds?: number\n\t};\n\n\texport type messageMediaWebPage = {\n\t\t_: 'messageMediaWebPage',\n\t\twebpage: WebPage\n\t};\n\n\texport type messageMediaVenue = {\n\t\t_: 'messageMediaVenue',\n\t\tgeo: GeoPoint,\n\t\ttitle: string,\n\t\taddress: string,\n\t\tprovider: string,\n\t\tvenue_id: string,\n\t\tvenue_type: string\n\t};\n\n\texport type messageMediaGame = {\n\t\t_: 'messageMediaGame',\n\t\tgame: Game\n\t};\n\n\texport type messageMediaInvoice = {\n\t\t_: 'messageMediaInvoice',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tshipping_address_requested?: true,\n\t\t\ttest?: true,\n\t\t}>,\n\t\ttitle: string,\n\t\tdescription: string,\n\t\tphoto?: WebDocument,\n\t\treceipt_msg_id?: number,\n\t\tcurrency: string,\n\t\ttotal_amount: string,\n\t\tstart_param: string\n\t};\n\n\texport type messageMediaGeoLive = {\n\t\t_: 'messageMediaGeoLive',\n\t\tflags?: number,\n\t\tgeo: GeoPoint,\n\t\theading?: number,\n\t\tperiod: number,\n\t\tproximity_notification_radius?: number\n\t};\n\n\texport type messageMediaPoll = {\n\t\t_: 'messageMediaPoll',\n\t\tpoll: Poll,\n\t\tresults: PollResults\n\t};\n\n\texport type messageMediaDice = {\n\t\t_: 'messageMediaDice',\n\t\tvalue: number,\n\t\temoticon: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageAction\n */\nexport type MessageAction = MessageAction.messageActionEmpty | MessageAction.messageActionChatCreate | MessageAction.messageActionChatEditTitle | MessageAction.messageActionChatEditPhoto | MessageAction.messageActionChatDeletePhoto | MessageAction.messageActionChatAddUser | MessageAction.messageActionChatDeleteUser | MessageAction.messageActionChatJoinedByLink | MessageAction.messageActionChannelCreate | MessageAction.messageActionChatMigrateTo | MessageAction.messageActionChannelMigrateFrom | MessageAction.messageActionPinMessage | MessageAction.messageActionHistoryClear | MessageAction.messageActionGameScore | MessageAction.messageActionPaymentSentMe | MessageAction.messageActionPaymentSent | MessageAction.messageActionPhoneCall | MessageAction.messageActionScreenshotTaken | MessageAction.messageActionCustomAction | MessageAction.messageActionBotAllowed | MessageAction.messageActionSecureValuesSentMe | MessageAction.messageActionSecureValuesSent | MessageAction.messageActionContactSignUp | MessageAction.messageActionGeoProximityReached | MessageAction.messageActionGroupCall | MessageAction.messageActionInviteToGroupCall | MessageAction.messageActionSetMessagesTTL | MessageAction.messageActionGroupCallScheduled | MessageAction.messageActionChatLeave | MessageAction.messageActionChannelDeletePhoto | MessageAction.messageActionChannelEditTitle | MessageAction.messageActionChannelEditPhoto | MessageAction.messageActionChannelEditVideo | MessageAction.messageActionChatEditVideo | MessageAction.messageActionChatAddUsers | MessageAction.messageActionChatJoined | MessageAction.messageActionChatReturn | MessageAction.messageActionChatJoinedYou | MessageAction.messageActionChatReturnYou;\n\nexport namespace MessageAction {\n  export type messageActionEmpty = {\n\t\t_: 'messageActionEmpty'\n\t};\n\n\texport type messageActionChatCreate = {\n\t\t_: 'messageActionChatCreate',\n\t\ttitle: string,\n\t\tusers: Array<number>\n\t};\n\n\texport type messageActionChatEditTitle = {\n\t\t_: 'messageActionChatEditTitle',\n\t\ttitle: string\n\t};\n\n\texport type messageActionChatEditPhoto = {\n\t\t_: 'messageActionChatEditPhoto',\n\t\tphoto: Photo\n\t};\n\n\texport type messageActionChatDeletePhoto = {\n\t\t_: 'messageActionChatDeletePhoto'\n\t};\n\n\texport type messageActionChatAddUser = {\n\t\t_: 'messageActionChatAddUser',\n\t\tusers: Array<number>\n\t};\n\n\texport type messageActionChatDeleteUser = {\n\t\t_: 'messageActionChatDeleteUser',\n\t\tuser_id: number\n\t};\n\n\texport type messageActionChatJoinedByLink = {\n\t\t_: 'messageActionChatJoinedByLink',\n\t\tinviter_id: number\n\t};\n\n\texport type messageActionChannelCreate = {\n\t\t_: 'messageActionChannelCreate',\n\t\ttitle: string\n\t};\n\n\texport type messageActionChatMigrateTo = {\n\t\t_: 'messageActionChatMigrateTo',\n\t\tchannel_id: number\n\t};\n\n\texport type messageActionChannelMigrateFrom = {\n\t\t_: 'messageActionChannelMigrateFrom',\n\t\ttitle: string,\n\t\tchat_id: number\n\t};\n\n\texport type messageActionPinMessage = {\n\t\t_: 'messageActionPinMessage'\n\t};\n\n\texport type messageActionHistoryClear = {\n\t\t_: 'messageActionHistoryClear'\n\t};\n\n\texport type messageActionGameScore = {\n\t\t_: 'messageActionGameScore',\n\t\tgame_id: string,\n\t\tscore: number\n\t};\n\n\texport type messageActionPaymentSentMe = {\n\t\t_: 'messageActionPaymentSentMe',\n\t\tflags?: number,\n\t\tcurrency: string,\n\t\ttotal_amount: string,\n\t\tpayload: Uint8Array,\n\t\tinfo?: PaymentRequestedInfo,\n\t\tshipping_option_id?: string,\n\t\tcharge: PaymentCharge\n\t};\n\n\texport type messageActionPaymentSent = {\n\t\t_: 'messageActionPaymentSent',\n\t\tcurrency: string,\n\t\ttotal_amount: string\n\t};\n\n\texport type messageActionPhoneCall = {\n\t\t_: 'messageActionPhoneCall',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tvideo?: true,\n\t\t}>,\n\t\tcall_id: string,\n\t\treason?: PhoneCallDiscardReason,\n\t\tduration?: number\n\t};\n\n\texport type messageActionScreenshotTaken = {\n\t\t_: 'messageActionScreenshotTaken'\n\t};\n\n\texport type messageActionCustomAction = {\n\t\t_: 'messageActionCustomAction',\n\t\tmessage: string\n\t};\n\n\texport type messageActionBotAllowed = {\n\t\t_: 'messageActionBotAllowed',\n\t\tdomain: string\n\t};\n\n\texport type messageActionSecureValuesSentMe = {\n\t\t_: 'messageActionSecureValuesSentMe',\n\t\tvalues: Array<SecureValue>,\n\t\tcredentials: SecureCredentialsEncrypted\n\t};\n\n\texport type messageActionSecureValuesSent = {\n\t\t_: 'messageActionSecureValuesSent',\n\t\ttypes: Array<SecureValueType>\n\t};\n\n\texport type messageActionContactSignUp = {\n\t\t_: 'messageActionContactSignUp'\n\t};\n\n\texport type messageActionGeoProximityReached = {\n\t\t_: 'messageActionGeoProximityReached',\n\t\tfrom_id: Peer,\n\t\tto_id: Peer,\n\t\tdistance: number\n\t};\n\n\texport type messageActionGroupCall = {\n\t\t_: 'messageActionGroupCall',\n\t\tflags?: number,\n\t\tcall: InputGroupCall,\n\t\tduration?: number\n\t};\n\n\texport type messageActionInviteToGroupCall = {\n\t\t_: 'messageActionInviteToGroupCall',\n\t\tcall: InputGroupCall,\n\t\tusers: Array<number>\n\t};\n\n\texport type messageActionSetMessagesTTL = {\n\t\t_: 'messageActionSetMessagesTTL',\n\t\tperiod: number\n\t};\n\n\texport type messageActionGroupCallScheduled = {\n\t\t_: 'messageActionGroupCallScheduled',\n\t\tcall: InputGroupCall,\n\t\tschedule_date: number\n\t};\n\n\texport type messageActionChatLeave = {\n\t\t_: 'messageActionChatLeave',\n\t\tuser_id?: number\n\t};\n\n\texport type messageActionChannelDeletePhoto = {\n\t\t_: 'messageActionChannelDeletePhoto'\n\t};\n\n\texport type messageActionChannelEditTitle = {\n\t\t_: 'messageActionChannelEditTitle',\n\t\ttitle?: string\n\t};\n\n\texport type messageActionChannelEditPhoto = {\n\t\t_: 'messageActionChannelEditPhoto',\n\t\tphoto?: Photo\n\t};\n\n\texport type messageActionChannelEditVideo = {\n\t\t_: 'messageActionChannelEditVideo',\n\t\tphoto?: Photo\n\t};\n\n\texport type messageActionChatEditVideo = {\n\t\t_: 'messageActionChatEditVideo',\n\t\tphoto?: Photo\n\t};\n\n\texport type messageActionChatAddUsers = {\n\t\t_: 'messageActionChatAddUsers',\n\t\tusers?: Array<number>\n\t};\n\n\texport type messageActionChatJoined = {\n\t\t_: 'messageActionChatJoined',\n\t\tusers?: Array<number>\n\t};\n\n\texport type messageActionChatReturn = {\n\t\t_: 'messageActionChatReturn',\n\t\tusers?: Array<number>\n\t};\n\n\texport type messageActionChatJoinedYou = {\n\t\t_: 'messageActionChatJoinedYou',\n\t\tusers?: Array<number>\n\t};\n\n\texport type messageActionChatReturnYou = {\n\t\t_: 'messageActionChatReturnYou',\n\t\tusers?: Array<number>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Dialog\n */\nexport type Dialog = Dialog.dialog | Dialog.dialogFolder;\n\nexport namespace Dialog {\n  export type dialog = {\n\t\t_: 'dialog',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpinned?: true,\n\t\t\tunread_mark?: true,\n\t\t}>,\n\t\tpeer: Peer,\n\t\ttop_message: number,\n\t\tread_inbox_max_id: number,\n\t\tread_outbox_max_id: number,\n\t\tunread_count: number,\n\t\tunread_mentions_count: number,\n\t\tnotify_settings: PeerNotifySettings,\n\t\tpts?: number,\n\t\tdraft?: DraftMessage,\n\t\tfolder_id?: number,\n\t\tindex?: number,\n\t\tpeerId?: number,\n\t\ttopMessage?: any,\n\t\tmigratedTo?: number\n\t};\n\n\texport type dialogFolder = {\n\t\t_: 'dialogFolder',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpinned?: true,\n\t\t}>,\n\t\tfolder: Folder,\n\t\tpeer: Peer,\n\t\ttop_message: number,\n\t\tunread_muted_peers_count: number,\n\t\tunread_unmuted_peers_count: number,\n\t\tunread_muted_messages_count: number,\n\t\tunread_unmuted_messages_count: number,\n\t\tindex?: number,\n\t\tpeerId?: number,\n\t\tfolder_id?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Photo\n */\nexport type Photo = Photo.photoEmpty | Photo.photo;\n\nexport namespace Photo {\n  export type photoEmpty = {\n\t\t_: 'photoEmpty',\n\t\tid: string\n\t};\n\n\texport type photo = {\n\t\t_: 'photo',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\thas_stickers?: true,\n\t\t}>,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tfile_reference: Uint8Array | number[],\n\t\tdate: number,\n\t\tsizes: Array<PhotoSize>,\n\t\tvideo_sizes?: Array<VideoSize>,\n\t\tdc_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PhotoSize\n */\nexport type PhotoSize = PhotoSize.photoSizeEmpty | PhotoSize.photoSize | PhotoSize.photoCachedSize | PhotoSize.photoStrippedSize | PhotoSize.photoSizeProgressive | PhotoSize.photoPathSize;\n\nexport namespace PhotoSize {\n  export type photoSizeEmpty = {\n\t\t_: 'photoSizeEmpty',\n\t\ttype: string\n\t};\n\n\texport type photoSize = {\n\t\t_: 'photoSize',\n\t\ttype: string,\n\t\tw: number,\n\t\th: number,\n\t\tsize: number\n\t};\n\n\texport type photoCachedSize = {\n\t\t_: 'photoCachedSize',\n\t\ttype: string,\n\t\tw: number,\n\t\th: number,\n\t\tbytes: Uint8Array\n\t};\n\n\texport type photoStrippedSize = {\n\t\t_: 'photoStrippedSize',\n\t\ttype: string,\n\t\tbytes: Uint8Array\n\t};\n\n\texport type photoSizeProgressive = {\n\t\t_: 'photoSizeProgressive',\n\t\ttype: string,\n\t\tw: number,\n\t\th: number,\n\t\tsizes: Array<number>,\n\t\tsize?: number\n\t};\n\n\texport type photoPathSize = {\n\t\t_: 'photoPathSize',\n\t\ttype: string,\n\t\tbytes: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/GeoPoint\n */\nexport type GeoPoint = GeoPoint.geoPointEmpty | GeoPoint.geoPoint;\n\nexport namespace GeoPoint {\n  export type geoPointEmpty = {\n\t\t_: 'geoPointEmpty'\n\t};\n\n\texport type geoPoint = {\n\t\t_: 'geoPoint',\n\t\tflags?: number,\n\t\tlong: number,\n\t\tlat: number,\n\t\taccess_hash: string,\n\t\taccuracy_radius?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/auth.SentCode\n */\nexport type AuthSentCode = AuthSentCode.authSentCode;\n\nexport namespace AuthSentCode {\n  export type authSentCode = {\n\t\t_: 'auth.sentCode',\n\t\tflags?: number,\n\t\ttype: AuthSentCodeType,\n\t\tphone_code_hash: string,\n\t\tnext_type?: AuthCodeType,\n\t\ttimeout?: number,\n\t\tphone_number?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/auth.Authorization\n */\nexport type AuthAuthorization = AuthAuthorization.authAuthorization | AuthAuthorization.authAuthorizationSignUpRequired;\n\nexport namespace AuthAuthorization {\n  export type authAuthorization = {\n\t\t_: 'auth.authorization',\n\t\tflags?: number,\n\t\ttmp_sessions?: number,\n\t\tuser: User\n\t};\n\n\texport type authAuthorizationSignUpRequired = {\n\t\t_: 'auth.authorizationSignUpRequired',\n\t\tflags?: number,\n\t\tterms_of_service?: HelpTermsOfService\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/auth.ExportedAuthorization\n */\nexport type AuthExportedAuthorization = AuthExportedAuthorization.authExportedAuthorization;\n\nexport namespace AuthExportedAuthorization {\n  export type authExportedAuthorization = {\n\t\t_: 'auth.exportedAuthorization',\n\t\tid: number,\n\t\tbytes: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputNotifyPeer\n */\nexport type InputNotifyPeer = InputNotifyPeer.inputNotifyPeer | InputNotifyPeer.inputNotifyUsers | InputNotifyPeer.inputNotifyChats | InputNotifyPeer.inputNotifyBroadcasts;\n\nexport namespace InputNotifyPeer {\n  export type inputNotifyPeer = {\n\t\t_: 'inputNotifyPeer',\n\t\tpeer: InputPeer\n\t};\n\n\texport type inputNotifyUsers = {\n\t\t_: 'inputNotifyUsers'\n\t};\n\n\texport type inputNotifyChats = {\n\t\t_: 'inputNotifyChats'\n\t};\n\n\texport type inputNotifyBroadcasts = {\n\t\t_: 'inputNotifyBroadcasts'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputPeerNotifySettings\n */\nexport type InputPeerNotifySettings = InputPeerNotifySettings.inputPeerNotifySettings;\n\nexport namespace InputPeerNotifySettings {\n  export type inputPeerNotifySettings = {\n\t\t_: 'inputPeerNotifySettings',\n\t\tflags?: number,\n\t\tshow_previews?: boolean,\n\t\tsilent?: boolean,\n\t\tmute_until?: number,\n\t\tsound?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PeerNotifySettings\n */\nexport type PeerNotifySettings = PeerNotifySettings.peerNotifySettings;\n\nexport namespace PeerNotifySettings {\n  export type peerNotifySettings = {\n\t\t_: 'peerNotifySettings',\n\t\tflags?: number,\n\t\tshow_previews?: boolean,\n\t\tsilent?: boolean,\n\t\tmute_until?: number,\n\t\tsound?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PeerSettings\n */\nexport type PeerSettings = PeerSettings.peerSettings;\n\nexport namespace PeerSettings {\n  export type peerSettings = {\n\t\t_: 'peerSettings',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\treport_spam?: true,\n\t\t\tadd_contact?: true,\n\t\t\tblock_contact?: true,\n\t\t\tshare_contact?: true,\n\t\t\tneed_contacts_exception?: true,\n\t\t\treport_geo?: true,\n\t\t\tautoarchived?: true,\n\t\t\tinvite_members?: true,\n\t\t}>,\n\t\tgeo_distance?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/WallPaper\n */\nexport type WallPaper = WallPaper.wallPaper | WallPaper.wallPaperNoFile;\n\nexport namespace WallPaper {\n  export type wallPaper = {\n\t\t_: 'wallPaper',\n\t\tid: string,\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcreator?: true,\n\t\t\tdefault?: true,\n\t\t\tpattern?: true,\n\t\t\tdark?: true,\n\t\t}>,\n\t\taccess_hash: string,\n\t\tslug: string,\n\t\tdocument: Document,\n\t\tsettings?: WallPaperSettings\n\t};\n\n\texport type wallPaperNoFile = {\n\t\t_: 'wallPaperNoFile',\n\t\tid: string,\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tdefault?: true,\n\t\t\tdark?: true,\n\t\t}>,\n\t\tsettings?: WallPaperSettings\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ReportReason\n */\nexport type ReportReason = ReportReason.inputReportReasonSpam | ReportReason.inputReportReasonViolence | ReportReason.inputReportReasonPornography | ReportReason.inputReportReasonChildAbuse | ReportReason.inputReportReasonOther | ReportReason.inputReportReasonCopyright | ReportReason.inputReportReasonGeoIrrelevant | ReportReason.inputReportReasonFake;\n\nexport namespace ReportReason {\n  export type inputReportReasonSpam = {\n\t\t_: 'inputReportReasonSpam'\n\t};\n\n\texport type inputReportReasonViolence = {\n\t\t_: 'inputReportReasonViolence'\n\t};\n\n\texport type inputReportReasonPornography = {\n\t\t_: 'inputReportReasonPornography'\n\t};\n\n\texport type inputReportReasonChildAbuse = {\n\t\t_: 'inputReportReasonChildAbuse'\n\t};\n\n\texport type inputReportReasonOther = {\n\t\t_: 'inputReportReasonOther'\n\t};\n\n\texport type inputReportReasonCopyright = {\n\t\t_: 'inputReportReasonCopyright'\n\t};\n\n\texport type inputReportReasonGeoIrrelevant = {\n\t\t_: 'inputReportReasonGeoIrrelevant'\n\t};\n\n\texport type inputReportReasonFake = {\n\t\t_: 'inputReportReasonFake'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/UserFull\n */\nexport type UserFull = UserFull.userFull;\n\nexport namespace UserFull {\n  export type userFull = {\n\t\t_: 'userFull',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tblocked?: true,\n\t\t\tphone_calls_available?: true,\n\t\t\tphone_calls_private?: true,\n\t\t\tcan_pin_message?: true,\n\t\t\thas_scheduled?: true,\n\t\t\tvideo_calls_available?: true,\n\t\t}>,\n\t\tuser: User,\n\t\tabout?: string,\n\t\tsettings: PeerSettings,\n\t\tprofile_photo?: Photo,\n\t\tnotify_settings: PeerNotifySettings,\n\t\tbot_info?: BotInfo,\n\t\tpinned_msg_id?: number,\n\t\tcommon_chats_count: number,\n\t\tfolder_id?: number,\n\t\tttl_period?: number,\n\t\trAbout?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Contact\n */\nexport type Contact = Contact.contact;\n\nexport namespace Contact {\n  export type contact = {\n\t\t_: 'contact',\n\t\tuser_id: number,\n\t\tmutual: boolean\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ImportedContact\n */\nexport type ImportedContact = ImportedContact.importedContact;\n\nexport namespace ImportedContact {\n  export type importedContact = {\n\t\t_: 'importedContact',\n\t\tuser_id: number,\n\t\tclient_id: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ContactStatus\n */\nexport type ContactStatus = ContactStatus.contactStatus;\n\nexport namespace ContactStatus {\n  export type contactStatus = {\n\t\t_: 'contactStatus',\n\t\tuser_id: number,\n\t\tstatus: UserStatus\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/contacts.Contacts\n */\nexport type ContactsContacts = ContactsContacts.contactsContactsNotModified | ContactsContacts.contactsContacts;\n\nexport namespace ContactsContacts {\n  export type contactsContactsNotModified = {\n\t\t_: 'contacts.contactsNotModified'\n\t};\n\n\texport type contactsContacts = {\n\t\t_: 'contacts.contacts',\n\t\tcontacts: Array<Contact>,\n\t\tsaved_count: number,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/contacts.ImportedContacts\n */\nexport type ContactsImportedContacts = ContactsImportedContacts.contactsImportedContacts;\n\nexport namespace ContactsImportedContacts {\n  export type contactsImportedContacts = {\n\t\t_: 'contacts.importedContacts',\n\t\timported: Array<ImportedContact>,\n\t\tpopular_invites: Array<PopularContact>,\n\t\tretry_contacts: Array<string>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/contacts.Blocked\n */\nexport type ContactsBlocked = ContactsBlocked.contactsBlocked | ContactsBlocked.contactsBlockedSlice;\n\nexport namespace ContactsBlocked {\n  export type contactsBlocked = {\n\t\t_: 'contacts.blocked',\n\t\tblocked: Array<PeerBlocked>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type contactsBlockedSlice = {\n\t\t_: 'contacts.blockedSlice',\n\t\tcount: number,\n\t\tblocked: Array<PeerBlocked>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.Dialogs\n */\nexport type MessagesDialogs = MessagesDialogs.messagesDialogs | MessagesDialogs.messagesDialogsSlice | MessagesDialogs.messagesDialogsNotModified;\n\nexport namespace MessagesDialogs {\n  export type messagesDialogs = {\n\t\t_: 'messages.dialogs',\n\t\tdialogs: Array<Dialog>,\n\t\tmessages: Array<Message>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type messagesDialogsSlice = {\n\t\t_: 'messages.dialogsSlice',\n\t\tcount: number,\n\t\tdialogs: Array<Dialog>,\n\t\tmessages: Array<Message>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type messagesDialogsNotModified = {\n\t\t_: 'messages.dialogsNotModified',\n\t\tcount: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.Messages\n */\nexport type MessagesMessages = MessagesMessages.messagesMessages | MessagesMessages.messagesMessagesSlice | MessagesMessages.messagesChannelMessages | MessagesMessages.messagesMessagesNotModified;\n\nexport namespace MessagesMessages {\n  export type messagesMessages = {\n\t\t_: 'messages.messages',\n\t\tmessages: Array<Message>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type messagesMessagesSlice = {\n\t\t_: 'messages.messagesSlice',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tinexact?: true,\n\t\t}>,\n\t\tcount: number,\n\t\tnext_rate?: number,\n\t\toffset_id_offset?: number,\n\t\tmessages: Array<Message>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type messagesChannelMessages = {\n\t\t_: 'messages.channelMessages',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tinexact?: true,\n\t\t}>,\n\t\tpts: number,\n\t\tcount: number,\n\t\toffset_id_offset?: number,\n\t\tmessages: Array<Message>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type messagesMessagesNotModified = {\n\t\t_: 'messages.messagesNotModified',\n\t\tcount: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.Chats\n */\nexport type MessagesChats = MessagesChats.messagesChats | MessagesChats.messagesChatsSlice;\n\nexport namespace MessagesChats {\n  export type messagesChats = {\n\t\t_: 'messages.chats',\n\t\tchats: Array<Chat>\n\t};\n\n\texport type messagesChatsSlice = {\n\t\t_: 'messages.chatsSlice',\n\t\tcount: number,\n\t\tchats: Array<Chat>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.ChatFull\n */\nexport type MessagesChatFull = MessagesChatFull.messagesChatFull;\n\nexport namespace MessagesChatFull {\n  export type messagesChatFull = {\n\t\t_: 'messages.chatFull',\n\t\tfull_chat: ChatFull,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.AffectedHistory\n */\nexport type MessagesAffectedHistory = MessagesAffectedHistory.messagesAffectedHistory;\n\nexport namespace MessagesAffectedHistory {\n  export type messagesAffectedHistory = {\n\t\t_: 'messages.affectedHistory',\n\t\tpts: number,\n\t\tpts_count: number,\n\t\toffset: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessagesFilter\n */\nexport type MessagesFilter = MessagesFilter.inputMessagesFilterEmpty | MessagesFilter.inputMessagesFilterPhotos | MessagesFilter.inputMessagesFilterVideo | MessagesFilter.inputMessagesFilterPhotoVideo | MessagesFilter.inputMessagesFilterDocument | MessagesFilter.inputMessagesFilterUrl | MessagesFilter.inputMessagesFilterGif | MessagesFilter.inputMessagesFilterVoice | MessagesFilter.inputMessagesFilterMusic | MessagesFilter.inputMessagesFilterChatPhotos | MessagesFilter.inputMessagesFilterPhoneCalls | MessagesFilter.inputMessagesFilterRoundVoice | MessagesFilter.inputMessagesFilterRoundVideo | MessagesFilter.inputMessagesFilterMyMentions | MessagesFilter.inputMessagesFilterGeo | MessagesFilter.inputMessagesFilterContacts | MessagesFilter.inputMessagesFilterPinned;\n\nexport namespace MessagesFilter {\n  export type inputMessagesFilterEmpty = {\n\t\t_: 'inputMessagesFilterEmpty'\n\t};\n\n\texport type inputMessagesFilterPhotos = {\n\t\t_: 'inputMessagesFilterPhotos'\n\t};\n\n\texport type inputMessagesFilterVideo = {\n\t\t_: 'inputMessagesFilterVideo'\n\t};\n\n\texport type inputMessagesFilterPhotoVideo = {\n\t\t_: 'inputMessagesFilterPhotoVideo'\n\t};\n\n\texport type inputMessagesFilterDocument = {\n\t\t_: 'inputMessagesFilterDocument'\n\t};\n\n\texport type inputMessagesFilterUrl = {\n\t\t_: 'inputMessagesFilterUrl'\n\t};\n\n\texport type inputMessagesFilterGif = {\n\t\t_: 'inputMessagesFilterGif'\n\t};\n\n\texport type inputMessagesFilterVoice = {\n\t\t_: 'inputMessagesFilterVoice'\n\t};\n\n\texport type inputMessagesFilterMusic = {\n\t\t_: 'inputMessagesFilterMusic'\n\t};\n\n\texport type inputMessagesFilterChatPhotos = {\n\t\t_: 'inputMessagesFilterChatPhotos'\n\t};\n\n\texport type inputMessagesFilterPhoneCalls = {\n\t\t_: 'inputMessagesFilterPhoneCalls',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tmissed?: true,\n\t\t}>\n\t};\n\n\texport type inputMessagesFilterRoundVoice = {\n\t\t_: 'inputMessagesFilterRoundVoice'\n\t};\n\n\texport type inputMessagesFilterRoundVideo = {\n\t\t_: 'inputMessagesFilterRoundVideo'\n\t};\n\n\texport type inputMessagesFilterMyMentions = {\n\t\t_: 'inputMessagesFilterMyMentions'\n\t};\n\n\texport type inputMessagesFilterGeo = {\n\t\t_: 'inputMessagesFilterGeo'\n\t};\n\n\texport type inputMessagesFilterContacts = {\n\t\t_: 'inputMessagesFilterContacts'\n\t};\n\n\texport type inputMessagesFilterPinned = {\n\t\t_: 'inputMessagesFilterPinned'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Update\n */\nexport type Update = Update.updateNewMessage | Update.updateMessageID | Update.updateDeleteMessages | Update.updateUserTyping | Update.updateChatUserTyping | Update.updateChatParticipants | Update.updateUserStatus | Update.updateUserName | Update.updateUserPhoto | Update.updateNewEncryptedMessage | Update.updateEncryptedChatTyping | Update.updateEncryption | Update.updateEncryptedMessagesRead | Update.updateChatParticipantAdd | Update.updateChatParticipantDelete | Update.updateDcOptions | Update.updateNotifySettings | Update.updateServiceNotification | Update.updatePrivacy | Update.updateUserPhone | Update.updateReadHistoryInbox | Update.updateReadHistoryOutbox | Update.updateWebPage | Update.updateReadMessagesContents | Update.updateChannelTooLong | Update.updateChannel | Update.updateNewChannelMessage | Update.updateReadChannelInbox | Update.updateDeleteChannelMessages | Update.updateChannelMessageViews | Update.updateChatParticipantAdmin | Update.updateNewStickerSet | Update.updateStickerSetsOrder | Update.updateStickerSets | Update.updateSavedGifs | Update.updateBotInlineQuery | Update.updateBotInlineSend | Update.updateEditChannelMessage | Update.updateBotCallbackQuery | Update.updateEditMessage | Update.updateInlineBotCallbackQuery | Update.updateReadChannelOutbox | Update.updateDraftMessage | Update.updateReadFeaturedStickers | Update.updateRecentStickers | Update.updateConfig | Update.updatePtsChanged | Update.updateChannelWebPage | Update.updateDialogPinned | Update.updatePinnedDialogs | Update.updateBotWebhookJSON | Update.updateBotWebhookJSONQuery | Update.updateBotShippingQuery | Update.updateBotPrecheckoutQuery | Update.updatePhoneCall | Update.updateLangPackTooLong | Update.updateLangPack | Update.updateFavedStickers | Update.updateChannelReadMessagesContents | Update.updateContactsReset | Update.updateChannelAvailableMessages | Update.updateDialogUnreadMark | Update.updateMessagePoll | Update.updateChatDefaultBannedRights | Update.updateFolderPeers | Update.updatePeerSettings | Update.updatePeerLocated | Update.updateNewScheduledMessage | Update.updateDeleteScheduledMessages | Update.updateTheme | Update.updateGeoLiveViewed | Update.updateLoginToken | Update.updateMessagePollVote | Update.updateDialogFilter | Update.updateDialogFilterOrder | Update.updateDialogFilters | Update.updatePhoneCallSignalingData | Update.updateChannelMessageForwards | Update.updateReadChannelDiscussionInbox | Update.updateReadChannelDiscussionOutbox | Update.updatePeerBlocked | Update.updateChannelUserTyping | Update.updatePinnedMessages | Update.updatePinnedChannelMessages | Update.updateChat | Update.updateGroupCallParticipants | Update.updateGroupCall | Update.updatePeerHistoryTTL | Update.updateChatParticipant | Update.updateChannelParticipant | Update.updateBotStopped | Update.updateGroupCallConnection | Update.updateBotCommands | Update.updateNewDiscussionMessage | Update.updateDeleteDiscussionMessages | Update.updateChannelReload;\n\nexport namespace Update {\n  export type updateNewMessage = {\n\t\t_: 'updateNewMessage',\n\t\tmessage: Message,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateMessageID = {\n\t\t_: 'updateMessageID',\n\t\tid: number,\n\t\trandom_id: string\n\t};\n\n\texport type updateDeleteMessages = {\n\t\t_: 'updateDeleteMessages',\n\t\tmessages: Array<number>,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateUserTyping = {\n\t\t_: 'updateUserTyping',\n\t\tuser_id: number,\n\t\taction: SendMessageAction\n\t};\n\n\texport type updateChatUserTyping = {\n\t\t_: 'updateChatUserTyping',\n\t\tchat_id: number,\n\t\tfrom_id: Peer,\n\t\taction: SendMessageAction\n\t};\n\n\texport type updateChatParticipants = {\n\t\t_: 'updateChatParticipants',\n\t\tparticipants: ChatParticipants\n\t};\n\n\texport type updateUserStatus = {\n\t\t_: 'updateUserStatus',\n\t\tuser_id: number,\n\t\tstatus: UserStatus\n\t};\n\n\texport type updateUserName = {\n\t\t_: 'updateUserName',\n\t\tuser_id: number,\n\t\tfirst_name: string,\n\t\tlast_name: string,\n\t\tusername: string\n\t};\n\n\texport type updateUserPhoto = {\n\t\t_: 'updateUserPhoto',\n\t\tuser_id: number,\n\t\tdate: number,\n\t\tphoto: UserProfilePhoto,\n\t\tprevious: boolean\n\t};\n\n\texport type updateNewEncryptedMessage = {\n\t\t_: 'updateNewEncryptedMessage',\n\t\tmessage: EncryptedMessage,\n\t\tqts: number\n\t};\n\n\texport type updateEncryptedChatTyping = {\n\t\t_: 'updateEncryptedChatTyping',\n\t\tchat_id: number\n\t};\n\n\texport type updateEncryption = {\n\t\t_: 'updateEncryption',\n\t\tchat: EncryptedChat,\n\t\tdate: number\n\t};\n\n\texport type updateEncryptedMessagesRead = {\n\t\t_: 'updateEncryptedMessagesRead',\n\t\tchat_id: number,\n\t\tmax_date: number,\n\t\tdate: number\n\t};\n\n\texport type updateChatParticipantAdd = {\n\t\t_: 'updateChatParticipantAdd',\n\t\tchat_id: number,\n\t\tuser_id: number,\n\t\tinviter_id: number,\n\t\tdate: number,\n\t\tversion: number\n\t};\n\n\texport type updateChatParticipantDelete = {\n\t\t_: 'updateChatParticipantDelete',\n\t\tchat_id: number,\n\t\tuser_id: number,\n\t\tversion: number\n\t};\n\n\texport type updateDcOptions = {\n\t\t_: 'updateDcOptions',\n\t\tdc_options: Array<DcOption>\n\t};\n\n\texport type updateNotifySettings = {\n\t\t_: 'updateNotifySettings',\n\t\tpeer: NotifyPeer,\n\t\tnotify_settings: PeerNotifySettings\n\t};\n\n\texport type updateServiceNotification = {\n\t\t_: 'updateServiceNotification',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpopup?: true,\n\t\t}>,\n\t\tinbox_date?: number,\n\t\ttype: string,\n\t\tmessage: string,\n\t\tmedia: MessageMedia,\n\t\tentities: Array<MessageEntity>\n\t};\n\n\texport type updatePrivacy = {\n\t\t_: 'updatePrivacy',\n\t\tkey: PrivacyKey,\n\t\trules: Array<PrivacyRule>\n\t};\n\n\texport type updateUserPhone = {\n\t\t_: 'updateUserPhone',\n\t\tuser_id: number,\n\t\tphone: string\n\t};\n\n\texport type updateReadHistoryInbox = {\n\t\t_: 'updateReadHistoryInbox',\n\t\tflags?: number,\n\t\tfolder_id?: number,\n\t\tpeer: Peer,\n\t\tmax_id: number,\n\t\tstill_unread_count: number,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateReadHistoryOutbox = {\n\t\t_: 'updateReadHistoryOutbox',\n\t\tpeer: Peer,\n\t\tmax_id: number,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateWebPage = {\n\t\t_: 'updateWebPage',\n\t\twebpage: WebPage,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateReadMessagesContents = {\n\t\t_: 'updateReadMessagesContents',\n\t\tmessages: Array<number>,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateChannelTooLong = {\n\t\t_: 'updateChannelTooLong',\n\t\tflags?: number,\n\t\tchannel_id: number,\n\t\tpts?: number\n\t};\n\n\texport type updateChannel = {\n\t\t_: 'updateChannel',\n\t\tchannel_id: number\n\t};\n\n\texport type updateNewChannelMessage = {\n\t\t_: 'updateNewChannelMessage',\n\t\tmessage: Message,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateReadChannelInbox = {\n\t\t_: 'updateReadChannelInbox',\n\t\tflags?: number,\n\t\tfolder_id?: number,\n\t\tchannel_id: number,\n\t\tmax_id: number,\n\t\tstill_unread_count: number,\n\t\tpts: number\n\t};\n\n\texport type updateDeleteChannelMessages = {\n\t\t_: 'updateDeleteChannelMessages',\n\t\tchannel_id: number,\n\t\tmessages: Array<number>,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateChannelMessageViews = {\n\t\t_: 'updateChannelMessageViews',\n\t\tchannel_id: number,\n\t\tid: number,\n\t\tviews: number\n\t};\n\n\texport type updateChatParticipantAdmin = {\n\t\t_: 'updateChatParticipantAdmin',\n\t\tchat_id: number,\n\t\tuser_id: number,\n\t\tis_admin: boolean,\n\t\tversion: number\n\t};\n\n\texport type updateNewStickerSet = {\n\t\t_: 'updateNewStickerSet',\n\t\tstickerset: MessagesStickerSet\n\t};\n\n\texport type updateStickerSetsOrder = {\n\t\t_: 'updateStickerSetsOrder',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tmasks?: true,\n\t\t}>,\n\t\torder: Array<string>\n\t};\n\n\texport type updateStickerSets = {\n\t\t_: 'updateStickerSets'\n\t};\n\n\texport type updateSavedGifs = {\n\t\t_: 'updateSavedGifs'\n\t};\n\n\texport type updateBotInlineQuery = {\n\t\t_: 'updateBotInlineQuery',\n\t\tflags?: number,\n\t\tquery_id: string,\n\t\tuser_id: number,\n\t\tquery: string,\n\t\tgeo?: GeoPoint,\n\t\tpeer_type?: InlineQueryPeerType,\n\t\toffset: string\n\t};\n\n\texport type updateBotInlineSend = {\n\t\t_: 'updateBotInlineSend',\n\t\tflags?: number,\n\t\tuser_id: number,\n\t\tquery: string,\n\t\tgeo?: GeoPoint,\n\t\tid: string,\n\t\tmsg_id?: InputBotInlineMessageID\n\t};\n\n\texport type updateEditChannelMessage = {\n\t\t_: 'updateEditChannelMessage',\n\t\tmessage: Message,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateBotCallbackQuery = {\n\t\t_: 'updateBotCallbackQuery',\n\t\tflags?: number,\n\t\tquery_id: string,\n\t\tuser_id: number,\n\t\tpeer: Peer,\n\t\tmsg_id: number,\n\t\tchat_instance: string,\n\t\tdata?: Uint8Array,\n\t\tgame_short_name?: string\n\t};\n\n\texport type updateEditMessage = {\n\t\t_: 'updateEditMessage',\n\t\tmessage: Message,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateInlineBotCallbackQuery = {\n\t\t_: 'updateInlineBotCallbackQuery',\n\t\tflags?: number,\n\t\tquery_id: string,\n\t\tuser_id: number,\n\t\tmsg_id: InputBotInlineMessageID,\n\t\tchat_instance: string,\n\t\tdata?: Uint8Array,\n\t\tgame_short_name?: string\n\t};\n\n\texport type updateReadChannelOutbox = {\n\t\t_: 'updateReadChannelOutbox',\n\t\tchannel_id: number,\n\t\tmax_id: number\n\t};\n\n\texport type updateDraftMessage = {\n\t\t_: 'updateDraftMessage',\n\t\tpeer: Peer,\n\t\tdraft: DraftMessage,\n\t\tlocal?: boolean,\n\t\tthreadId?: number\n\t};\n\n\texport type updateReadFeaturedStickers = {\n\t\t_: 'updateReadFeaturedStickers'\n\t};\n\n\texport type updateRecentStickers = {\n\t\t_: 'updateRecentStickers'\n\t};\n\n\texport type updateConfig = {\n\t\t_: 'updateConfig'\n\t};\n\n\texport type updatePtsChanged = {\n\t\t_: 'updatePtsChanged'\n\t};\n\n\texport type updateChannelWebPage = {\n\t\t_: 'updateChannelWebPage',\n\t\tchannel_id: number,\n\t\twebpage: WebPage,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateDialogPinned = {\n\t\t_: 'updateDialogPinned',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpinned?: true,\n\t\t}>,\n\t\tfolder_id?: number,\n\t\tpeer: DialogPeer\n\t};\n\n\texport type updatePinnedDialogs = {\n\t\t_: 'updatePinnedDialogs',\n\t\tflags?: number,\n\t\tfolder_id?: number,\n\t\torder?: Array<DialogPeer>\n\t};\n\n\texport type updateBotWebhookJSON = {\n\t\t_: 'updateBotWebhookJSON',\n\t\tdata: DataJSON\n\t};\n\n\texport type updateBotWebhookJSONQuery = {\n\t\t_: 'updateBotWebhookJSONQuery',\n\t\tquery_id: string,\n\t\tdata: DataJSON,\n\t\ttimeout: number\n\t};\n\n\texport type updateBotShippingQuery = {\n\t\t_: 'updateBotShippingQuery',\n\t\tquery_id: string,\n\t\tuser_id: number,\n\t\tpayload: Uint8Array,\n\t\tshipping_address: PostAddress\n\t};\n\n\texport type updateBotPrecheckoutQuery = {\n\t\t_: 'updateBotPrecheckoutQuery',\n\t\tflags?: number,\n\t\tquery_id: string,\n\t\tuser_id: number,\n\t\tpayload: Uint8Array,\n\t\tinfo?: PaymentRequestedInfo,\n\t\tshipping_option_id?: string,\n\t\tcurrency: string,\n\t\ttotal_amount: string\n\t};\n\n\texport type updatePhoneCall = {\n\t\t_: 'updatePhoneCall',\n\t\tphone_call: PhoneCall\n\t};\n\n\texport type updateLangPackTooLong = {\n\t\t_: 'updateLangPackTooLong',\n\t\tlang_code: string\n\t};\n\n\texport type updateLangPack = {\n\t\t_: 'updateLangPack',\n\t\tdifference: LangPackDifference\n\t};\n\n\texport type updateFavedStickers = {\n\t\t_: 'updateFavedStickers'\n\t};\n\n\texport type updateChannelReadMessagesContents = {\n\t\t_: 'updateChannelReadMessagesContents',\n\t\tchannel_id: number,\n\t\tmessages: Array<number>\n\t};\n\n\texport type updateContactsReset = {\n\t\t_: 'updateContactsReset'\n\t};\n\n\texport type updateChannelAvailableMessages = {\n\t\t_: 'updateChannelAvailableMessages',\n\t\tchannel_id: number,\n\t\tavailable_min_id: number\n\t};\n\n\texport type updateDialogUnreadMark = {\n\t\t_: 'updateDialogUnreadMark',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tunread?: true,\n\t\t}>,\n\t\tpeer: DialogPeer\n\t};\n\n\texport type updateMessagePoll = {\n\t\t_: 'updateMessagePoll',\n\t\tflags?: number,\n\t\tpoll_id: string,\n\t\tpoll?: Poll,\n\t\tresults: PollResults\n\t};\n\n\texport type updateChatDefaultBannedRights = {\n\t\t_: 'updateChatDefaultBannedRights',\n\t\tpeer: Peer,\n\t\tdefault_banned_rights: ChatBannedRights,\n\t\tversion: number\n\t};\n\n\texport type updateFolderPeers = {\n\t\t_: 'updateFolderPeers',\n\t\tfolder_peers: Array<FolderPeer>,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updatePeerSettings = {\n\t\t_: 'updatePeerSettings',\n\t\tpeer: Peer,\n\t\tsettings: PeerSettings\n\t};\n\n\texport type updatePeerLocated = {\n\t\t_: 'updatePeerLocated',\n\t\tpeers: Array<PeerLocated>\n\t};\n\n\texport type updateNewScheduledMessage = {\n\t\t_: 'updateNewScheduledMessage',\n\t\tmessage: Message\n\t};\n\n\texport type updateDeleteScheduledMessages = {\n\t\t_: 'updateDeleteScheduledMessages',\n\t\tpeer: Peer,\n\t\tmessages: Array<number>\n\t};\n\n\texport type updateTheme = {\n\t\t_: 'updateTheme',\n\t\ttheme: Theme\n\t};\n\n\texport type updateGeoLiveViewed = {\n\t\t_: 'updateGeoLiveViewed',\n\t\tpeer: Peer,\n\t\tmsg_id: number\n\t};\n\n\texport type updateLoginToken = {\n\t\t_: 'updateLoginToken'\n\t};\n\n\texport type updateMessagePollVote = {\n\t\t_: 'updateMessagePollVote',\n\t\tpoll_id: string,\n\t\tuser_id: number,\n\t\toptions: Array<Uint8Array>,\n\t\tqts: number\n\t};\n\n\texport type updateDialogFilter = {\n\t\t_: 'updateDialogFilter',\n\t\tflags?: number,\n\t\tid: number,\n\t\tfilter?: DialogFilter\n\t};\n\n\texport type updateDialogFilterOrder = {\n\t\t_: 'updateDialogFilterOrder',\n\t\torder: Array<number>\n\t};\n\n\texport type updateDialogFilters = {\n\t\t_: 'updateDialogFilters'\n\t};\n\n\texport type updatePhoneCallSignalingData = {\n\t\t_: 'updatePhoneCallSignalingData',\n\t\tphone_call_id: string,\n\t\tdata: Uint8Array\n\t};\n\n\texport type updateChannelMessageForwards = {\n\t\t_: 'updateChannelMessageForwards',\n\t\tchannel_id: number,\n\t\tid: number,\n\t\tforwards: number\n\t};\n\n\texport type updateReadChannelDiscussionInbox = {\n\t\t_: 'updateReadChannelDiscussionInbox',\n\t\tflags?: number,\n\t\tchannel_id: number,\n\t\ttop_msg_id: number,\n\t\tread_max_id: number,\n\t\tbroadcast_id?: number,\n\t\tbroadcast_post?: number\n\t};\n\n\texport type updateReadChannelDiscussionOutbox = {\n\t\t_: 'updateReadChannelDiscussionOutbox',\n\t\tchannel_id: number,\n\t\ttop_msg_id: number,\n\t\tread_max_id: number\n\t};\n\n\texport type updatePeerBlocked = {\n\t\t_: 'updatePeerBlocked',\n\t\tpeer_id: Peer,\n\t\tblocked: boolean\n\t};\n\n\texport type updateChannelUserTyping = {\n\t\t_: 'updateChannelUserTyping',\n\t\tflags?: number,\n\t\tchannel_id: number,\n\t\ttop_msg_id?: number,\n\t\tfrom_id: Peer,\n\t\taction: SendMessageAction\n\t};\n\n\texport type updatePinnedMessages = {\n\t\t_: 'updatePinnedMessages',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpinned?: true,\n\t\t}>,\n\t\tpeer: Peer,\n\t\tmessages: Array<number>,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updatePinnedChannelMessages = {\n\t\t_: 'updatePinnedChannelMessages',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpinned?: true,\n\t\t}>,\n\t\tchannel_id: number,\n\t\tmessages: Array<number>,\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n\n\texport type updateChat = {\n\t\t_: 'updateChat',\n\t\tchat_id: number\n\t};\n\n\texport type updateGroupCallParticipants = {\n\t\t_: 'updateGroupCallParticipants',\n\t\tcall: InputGroupCall,\n\t\tparticipants: Array<GroupCallParticipant>,\n\t\tversion: number\n\t};\n\n\texport type updateGroupCall = {\n\t\t_: 'updateGroupCall',\n\t\tchat_id: number,\n\t\tcall: GroupCall\n\t};\n\n\texport type updatePeerHistoryTTL = {\n\t\t_: 'updatePeerHistoryTTL',\n\t\tflags?: number,\n\t\tpeer: Peer,\n\t\tttl_period?: number\n\t};\n\n\texport type updateChatParticipant = {\n\t\t_: 'updateChatParticipant',\n\t\tflags?: number,\n\t\tchat_id: number,\n\t\tdate: number,\n\t\tactor_id: number,\n\t\tuser_id: number,\n\t\tprev_participant?: ChatParticipant,\n\t\tnew_participant?: ChatParticipant,\n\t\tinvite?: ExportedChatInvite,\n\t\tqts: number\n\t};\n\n\texport type updateChannelParticipant = {\n\t\t_: 'updateChannelParticipant',\n\t\tflags?: number,\n\t\tchannel_id: number,\n\t\tdate: number,\n\t\tactor_id: number,\n\t\tuser_id: number,\n\t\tprev_participant?: ChannelParticipant,\n\t\tnew_participant?: ChannelParticipant,\n\t\tinvite?: ExportedChatInvite,\n\t\tqts: number\n\t};\n\n\texport type updateBotStopped = {\n\t\t_: 'updateBotStopped',\n\t\tuser_id: number,\n\t\tdate: number,\n\t\tstopped: boolean,\n\t\tqts: number\n\t};\n\n\texport type updateGroupCallConnection = {\n\t\t_: 'updateGroupCallConnection',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpresentation?: true,\n\t\t}>,\n\t\tparams: DataJSON\n\t};\n\n\texport type updateBotCommands = {\n\t\t_: 'updateBotCommands',\n\t\tpeer: Peer,\n\t\tbot_id: number,\n\t\tcommands: Array<BotCommand>\n\t};\n\n\texport type updateNewDiscussionMessage = {\n\t\t_: 'updateNewDiscussionMessage',\n\t\tmessage?: Message\n\t};\n\n\texport type updateDeleteDiscussionMessages = {\n\t\t_: 'updateDeleteDiscussionMessages',\n\t\tmessages?: number[],\n\t\tchannel_id?: number\n\t};\n\n\texport type updateChannelReload = {\n\t\t_: 'updateChannelReload',\n\t\tchannel_id?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/updates.State\n */\nexport type UpdatesState = UpdatesState.updatesState;\n\nexport namespace UpdatesState {\n  export type updatesState = {\n\t\t_: 'updates.state',\n\t\tpts: number,\n\t\tqts: number,\n\t\tdate: number,\n\t\tseq: number,\n\t\tunread_count: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/updates.Difference\n */\nexport type UpdatesDifference = UpdatesDifference.updatesDifferenceEmpty | UpdatesDifference.updatesDifference | UpdatesDifference.updatesDifferenceSlice | UpdatesDifference.updatesDifferenceTooLong;\n\nexport namespace UpdatesDifference {\n  export type updatesDifferenceEmpty = {\n\t\t_: 'updates.differenceEmpty',\n\t\tdate: number,\n\t\tseq: number\n\t};\n\n\texport type updatesDifference = {\n\t\t_: 'updates.difference',\n\t\tnew_messages: Array<Message>,\n\t\tnew_encrypted_messages: Array<EncryptedMessage>,\n\t\tother_updates: Array<Update>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>,\n\t\tstate: UpdatesState\n\t};\n\n\texport type updatesDifferenceSlice = {\n\t\t_: 'updates.differenceSlice',\n\t\tnew_messages: Array<Message>,\n\t\tnew_encrypted_messages: Array<EncryptedMessage>,\n\t\tother_updates: Array<Update>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>,\n\t\tintermediate_state: UpdatesState\n\t};\n\n\texport type updatesDifferenceTooLong = {\n\t\t_: 'updates.differenceTooLong',\n\t\tpts: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Updates\n */\nexport type Updates = Updates.updatesTooLong | Updates.updateShortMessage | Updates.updateShortChatMessage | Updates.updateShort | Updates.updatesCombined | Updates.updates | Updates.updateShortSentMessage;\n\nexport namespace Updates {\n  export type updatesTooLong = {\n\t\t_: 'updatesTooLong'\n\t};\n\n\texport type updateShortMessage = {\n\t\t_: 'updateShortMessage',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tout?: true,\n\t\t\tmentioned?: true,\n\t\t\tmedia_unread?: true,\n\t\t\tsilent?: true,\n\t\t}>,\n\t\tid: number,\n\t\tuser_id: number,\n\t\tmessage: string,\n\t\tpts: number,\n\t\tpts_count: number,\n\t\tdate: number,\n\t\tfwd_from?: MessageFwdHeader,\n\t\tvia_bot_id?: number,\n\t\treply_to?: MessageReplyHeader,\n\t\tentities?: Array<MessageEntity>,\n\t\tttl_period?: number\n\t};\n\n\texport type updateShortChatMessage = {\n\t\t_: 'updateShortChatMessage',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tout?: true,\n\t\t\tmentioned?: true,\n\t\t\tmedia_unread?: true,\n\t\t\tsilent?: true,\n\t\t}>,\n\t\tid: number,\n\t\tfrom_id: number,\n\t\tchat_id: number,\n\t\tmessage: string,\n\t\tpts: number,\n\t\tpts_count: number,\n\t\tdate: number,\n\t\tfwd_from?: MessageFwdHeader,\n\t\tvia_bot_id?: number,\n\t\treply_to?: MessageReplyHeader,\n\t\tentities?: Array<MessageEntity>,\n\t\tttl_period?: number\n\t};\n\n\texport type updateShort = {\n\t\t_: 'updateShort',\n\t\tupdate: Update,\n\t\tdate: number\n\t};\n\n\texport type updatesCombined = {\n\t\t_: 'updatesCombined',\n\t\tupdates: Array<Update>,\n\t\tusers: Array<User>,\n\t\tchats: Array<Chat>,\n\t\tdate: number,\n\t\tseq_start: number,\n\t\tseq: number\n\t};\n\n\texport type updates = {\n\t\t_: 'updates',\n\t\tupdates: Array<Update>,\n\t\tusers: Array<User>,\n\t\tchats: Array<Chat>,\n\t\tdate: number,\n\t\tseq: number\n\t};\n\n\texport type updateShortSentMessage = {\n\t\t_: 'updateShortSentMessage',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tout?: true,\n\t\t}>,\n\t\tid: number,\n\t\tpts: number,\n\t\tpts_count: number,\n\t\tdate: number,\n\t\tmedia?: MessageMedia,\n\t\tentities?: Array<MessageEntity>,\n\t\tttl_period?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/photos.Photos\n */\nexport type PhotosPhotos = PhotosPhotos.photosPhotos | PhotosPhotos.photosPhotosSlice;\n\nexport namespace PhotosPhotos {\n  export type photosPhotos = {\n\t\t_: 'photos.photos',\n\t\tphotos: Array<Photo>,\n\t\tusers: Array<User>\n\t};\n\n\texport type photosPhotosSlice = {\n\t\t_: 'photos.photosSlice',\n\t\tcount: number,\n\t\tphotos: Array<Photo>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/photos.Photo\n */\nexport type PhotosPhoto = PhotosPhoto.photosPhoto;\n\nexport namespace PhotosPhoto {\n  export type photosPhoto = {\n\t\t_: 'photos.photo',\n\t\tphoto: Photo,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/upload.File\n */\nexport type UploadFile = UploadFile.uploadFile | UploadFile.uploadFileCdnRedirect;\n\nexport namespace UploadFile {\n  export type uploadFile = {\n\t\t_: 'upload.file',\n\t\ttype: StorageFileType,\n\t\tmtime: number,\n\t\tbytes: Uint8Array\n\t};\n\n\texport type uploadFileCdnRedirect = {\n\t\t_: 'upload.fileCdnRedirect',\n\t\tdc_id: number,\n\t\tfile_token: Uint8Array,\n\t\tencryption_key: Uint8Array,\n\t\tencryption_iv: Uint8Array,\n\t\tfile_hashes: Array<FileHash>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/DcOption\n */\nexport type DcOption = DcOption.dcOption;\n\nexport namespace DcOption {\n  export type dcOption = {\n\t\t_: 'dcOption',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tipv6?: true,\n\t\t\tmedia_only?: true,\n\t\t\ttcpo_only?: true,\n\t\t\tcdn?: true,\n\t\t\tstatic?: true,\n\t\t}>,\n\t\tid: number,\n\t\tip_address: string,\n\t\tport: number,\n\t\tsecret?: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Config\n */\nexport type Config = Config.config;\n\nexport namespace Config {\n  export type config = {\n\t\t_: 'config',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tphonecalls_enabled?: true,\n\t\t\tdefault_p2p_contacts?: true,\n\t\t\tpreload_featured_stickers?: true,\n\t\t\tignore_phone_entities?: true,\n\t\t\trevoke_pm_inbox?: true,\n\t\t\tblocked_mode?: true,\n\t\t\tpfs_enabled?: true,\n\t\t}>,\n\t\tdate: number,\n\t\texpires: number,\n\t\ttest_mode: boolean,\n\t\tthis_dc: number,\n\t\tdc_options: Array<DcOption>,\n\t\tdc_txt_domain_name: string,\n\t\tchat_size_max: number,\n\t\tmegagroup_size_max: number,\n\t\tforwarded_count_max: number,\n\t\tonline_update_period_ms: number,\n\t\toffline_blur_timeout_ms: number,\n\t\toffline_idle_timeout_ms: number,\n\t\tonline_cloud_timeout_ms: number,\n\t\tnotify_cloud_delay_ms: number,\n\t\tnotify_default_delay_ms: number,\n\t\tpush_chat_period_ms: number,\n\t\tpush_chat_limit: number,\n\t\tsaved_gifs_limit: number,\n\t\tedit_time_limit: number,\n\t\trevoke_time_limit: number,\n\t\trevoke_pm_time_limit: number,\n\t\trating_e_decay: number,\n\t\tstickers_recent_limit: number,\n\t\tstickers_faved_limit: number,\n\t\tchannels_read_media_period: number,\n\t\ttmp_sessions?: number,\n\t\tpinned_dialogs_count_max: number,\n\t\tpinned_infolder_count_max: number,\n\t\tcall_receive_timeout_ms: number,\n\t\tcall_ring_timeout_ms: number,\n\t\tcall_connect_timeout_ms: number,\n\t\tcall_packet_timeout_ms: number,\n\t\tme_url_prefix: string,\n\t\tautoupdate_url_prefix?: string,\n\t\tgif_search_username?: string,\n\t\tvenue_search_username?: string,\n\t\timg_search_username?: string,\n\t\tstatic_maps_provider?: string,\n\t\tcaption_length_max: number,\n\t\tmessage_length_max: number,\n\t\twebfile_dc_id: number,\n\t\tsuggested_lang_code?: string,\n\t\tlang_pack_version?: number,\n\t\tbase_lang_pack_version?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/NearestDc\n */\nexport type NearestDc = NearestDc.nearestDc;\n\nexport namespace NearestDc {\n  export type nearestDc = {\n\t\t_: 'nearestDc',\n\t\tcountry: string,\n\t\tthis_dc: number,\n\t\tnearest_dc: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.AppUpdate\n */\nexport type HelpAppUpdate = HelpAppUpdate.helpAppUpdate | HelpAppUpdate.helpNoAppUpdate;\n\nexport namespace HelpAppUpdate {\n  export type helpAppUpdate = {\n\t\t_: 'help.appUpdate',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcan_not_skip?: true,\n\t\t}>,\n\t\tid: number,\n\t\tversion: string,\n\t\ttext: string,\n\t\tentities: Array<MessageEntity>,\n\t\tdocument?: Document,\n\t\turl?: string,\n\t\tsticker?: Document\n\t};\n\n\texport type helpNoAppUpdate = {\n\t\t_: 'help.noAppUpdate'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.InviteText\n */\nexport type HelpInviteText = HelpInviteText.helpInviteText;\n\nexport namespace HelpInviteText {\n  export type helpInviteText = {\n\t\t_: 'help.inviteText',\n\t\tmessage: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/EncryptedChat\n */\nexport type EncryptedChat = EncryptedChat.encryptedChatEmpty | EncryptedChat.encryptedChatWaiting | EncryptedChat.encryptedChatRequested | EncryptedChat.encryptedChat | EncryptedChat.encryptedChatDiscarded;\n\nexport namespace EncryptedChat {\n  export type encryptedChatEmpty = {\n\t\t_: 'encryptedChatEmpty',\n\t\tid: number\n\t};\n\n\texport type encryptedChatWaiting = {\n\t\t_: 'encryptedChatWaiting',\n\t\tid: number,\n\t\taccess_hash: string,\n\t\tdate: number,\n\t\tadmin_id: number,\n\t\tparticipant_id: number\n\t};\n\n\texport type encryptedChatRequested = {\n\t\t_: 'encryptedChatRequested',\n\t\tflags?: number,\n\t\tfolder_id?: number,\n\t\tid: number,\n\t\taccess_hash: string,\n\t\tdate: number,\n\t\tadmin_id: number,\n\t\tparticipant_id: number,\n\t\tg_a: Uint8Array\n\t};\n\n\texport type encryptedChat = {\n\t\t_: 'encryptedChat',\n\t\tid: number,\n\t\taccess_hash: string,\n\t\tdate: number,\n\t\tadmin_id: number,\n\t\tparticipant_id: number,\n\t\tg_a_or_b: Uint8Array,\n\t\tkey_fingerprint: string\n\t};\n\n\texport type encryptedChatDiscarded = {\n\t\t_: 'encryptedChatDiscarded',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\thistory_deleted?: true,\n\t\t}>,\n\t\tid: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputEncryptedChat\n */\nexport type InputEncryptedChat = InputEncryptedChat.inputEncryptedChat;\n\nexport namespace InputEncryptedChat {\n  export type inputEncryptedChat = {\n\t\t_: 'inputEncryptedChat',\n\t\tchat_id: number,\n\t\taccess_hash: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/EncryptedFile\n */\nexport type EncryptedFile = EncryptedFile.encryptedFileEmpty | EncryptedFile.encryptedFile;\n\nexport namespace EncryptedFile {\n  export type encryptedFileEmpty = {\n\t\t_: 'encryptedFileEmpty'\n\t};\n\n\texport type encryptedFile = {\n\t\t_: 'encryptedFile',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tsize: number,\n\t\tdc_id: number,\n\t\tkey_fingerprint: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputEncryptedFile\n */\nexport type InputEncryptedFile = InputEncryptedFile.inputEncryptedFileEmpty | InputEncryptedFile.inputEncryptedFileUploaded | InputEncryptedFile.inputEncryptedFile | InputEncryptedFile.inputEncryptedFileBigUploaded;\n\nexport namespace InputEncryptedFile {\n  export type inputEncryptedFileEmpty = {\n\t\t_: 'inputEncryptedFileEmpty'\n\t};\n\n\texport type inputEncryptedFileUploaded = {\n\t\t_: 'inputEncryptedFileUploaded',\n\t\tid: string,\n\t\tparts: number,\n\t\tmd5_checksum: string,\n\t\tkey_fingerprint: number\n\t};\n\n\texport type inputEncryptedFile = {\n\t\t_: 'inputEncryptedFile',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputEncryptedFileBigUploaded = {\n\t\t_: 'inputEncryptedFileBigUploaded',\n\t\tid: string,\n\t\tparts: number,\n\t\tkey_fingerprint: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/EncryptedMessage\n */\nexport type EncryptedMessage = EncryptedMessage.encryptedMessage | EncryptedMessage.encryptedMessageService;\n\nexport namespace EncryptedMessage {\n  export type encryptedMessage = {\n\t\t_: 'encryptedMessage',\n\t\trandom_id: string,\n\t\tchat_id: number,\n\t\tdate: number,\n\t\tbytes: Uint8Array,\n\t\tfile: EncryptedFile\n\t};\n\n\texport type encryptedMessageService = {\n\t\t_: 'encryptedMessageService',\n\t\trandom_id: string,\n\t\tchat_id: number,\n\t\tdate: number,\n\t\tbytes: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.DhConfig\n */\nexport type MessagesDhConfig = MessagesDhConfig.messagesDhConfigNotModified | MessagesDhConfig.messagesDhConfig;\n\nexport namespace MessagesDhConfig {\n  export type messagesDhConfigNotModified = {\n\t\t_: 'messages.dhConfigNotModified',\n\t\trandom: Uint8Array\n\t};\n\n\texport type messagesDhConfig = {\n\t\t_: 'messages.dhConfig',\n\t\tg: number,\n\t\tp: Uint8Array,\n\t\tversion: number,\n\t\trandom: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.SentEncryptedMessage\n */\nexport type MessagesSentEncryptedMessage = MessagesSentEncryptedMessage.messagesSentEncryptedMessage | MessagesSentEncryptedMessage.messagesSentEncryptedFile;\n\nexport namespace MessagesSentEncryptedMessage {\n  export type messagesSentEncryptedMessage = {\n\t\t_: 'messages.sentEncryptedMessage',\n\t\tdate: number\n\t};\n\n\texport type messagesSentEncryptedFile = {\n\t\t_: 'messages.sentEncryptedFile',\n\t\tdate: number,\n\t\tfile: EncryptedFile\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputDocument\n */\nexport type InputDocument = InputDocument.inputDocumentEmpty | InputDocument.inputDocument;\n\nexport namespace InputDocument {\n  export type inputDocumentEmpty = {\n\t\t_: 'inputDocumentEmpty'\n\t};\n\n\texport type inputDocument = {\n\t\t_: 'inputDocument',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tfile_reference: Uint8Array | number[]\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Document\n */\nexport type Document = Document.documentEmpty | Document.document;\n\nexport namespace Document {\n  export type documentEmpty = {\n\t\t_: 'documentEmpty',\n\t\tid: string\n\t};\n\n\texport type document = {\n\t\t_: 'document',\n\t\tflags?: number,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tfile_reference: Uint8Array | number[],\n\t\tdate: number,\n\t\tmime_type: string,\n\t\tsize: number,\n\t\tthumbs?: Array<PhotoSize.photoSize | PhotoSize.photoCachedSize | PhotoSize.photoStrippedSize | PhotoSize.photoPathSize>,\n\t\tvideo_thumbs?: Array<VideoSize>,\n\t\tdc_id: number,\n\t\tattributes: Array<DocumentAttribute>,\n\t\ttype?: 'gif' | 'sticker' | 'audio' | 'voice' | 'video' | 'round' | 'photo' | 'pdf',\n\t\th?: number,\n\t\tw?: number,\n\t\tfile_name?: string,\n\t\tfileName?: string,\n\t\tfile?: File,\n\t\tduration?: number,\n\t\taudioTitle?: string,\n\t\taudioPerformer?: string,\n\t\tsticker?: number,\n\t\tstickerEmoji?: string,\n\t\tstickerEmojiRaw?: string,\n\t\tstickerSetInput?: InputStickerSet.inputStickerSetID,\n\t\tpFlags?: Partial<{\n\t\t\tstickerThumbConverted?: true,\n\t\t}>,\n\t\tstickerCachedThumbs?: {[toneIndex: number]: {url: string, w: number, h: number}},\n\t\tanimated?: boolean,\n\t\tsupportsStreaming?: boolean\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.Support\n */\nexport type HelpSupport = HelpSupport.helpSupport;\n\nexport namespace HelpSupport {\n  export type helpSupport = {\n\t\t_: 'help.support',\n\t\tphone_number: string,\n\t\tuser: User\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/NotifyPeer\n */\nexport type NotifyPeer = NotifyPeer.notifyPeer | NotifyPeer.notifyUsers | NotifyPeer.notifyChats | NotifyPeer.notifyBroadcasts;\n\nexport namespace NotifyPeer {\n  export type notifyPeer = {\n\t\t_: 'notifyPeer',\n\t\tpeer: Peer\n\t};\n\n\texport type notifyUsers = {\n\t\t_: 'notifyUsers'\n\t};\n\n\texport type notifyChats = {\n\t\t_: 'notifyChats'\n\t};\n\n\texport type notifyBroadcasts = {\n\t\t_: 'notifyBroadcasts'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SendMessageAction\n */\nexport type SendMessageAction = SendMessageAction.sendMessageTypingAction | SendMessageAction.sendMessageCancelAction | SendMessageAction.sendMessageRecordVideoAction | SendMessageAction.sendMessageUploadVideoAction | SendMessageAction.sendMessageRecordAudioAction | SendMessageAction.sendMessageUploadAudioAction | SendMessageAction.sendMessageUploadPhotoAction | SendMessageAction.sendMessageUploadDocumentAction | SendMessageAction.sendMessageGeoLocationAction | SendMessageAction.sendMessageChooseContactAction | SendMessageAction.sendMessageGamePlayAction | SendMessageAction.sendMessageRecordRoundAction | SendMessageAction.sendMessageUploadRoundAction | SendMessageAction.speakingInGroupCallAction | SendMessageAction.sendMessageHistoryImportAction;\n\nexport namespace SendMessageAction {\n  export type sendMessageTypingAction = {\n\t\t_: 'sendMessageTypingAction'\n\t};\n\n\texport type sendMessageCancelAction = {\n\t\t_: 'sendMessageCancelAction'\n\t};\n\n\texport type sendMessageRecordVideoAction = {\n\t\t_: 'sendMessageRecordVideoAction'\n\t};\n\n\texport type sendMessageUploadVideoAction = {\n\t\t_: 'sendMessageUploadVideoAction',\n\t\tprogress: number\n\t};\n\n\texport type sendMessageRecordAudioAction = {\n\t\t_: 'sendMessageRecordAudioAction'\n\t};\n\n\texport type sendMessageUploadAudioAction = {\n\t\t_: 'sendMessageUploadAudioAction',\n\t\tprogress: number\n\t};\n\n\texport type sendMessageUploadPhotoAction = {\n\t\t_: 'sendMessageUploadPhotoAction',\n\t\tprogress: number\n\t};\n\n\texport type sendMessageUploadDocumentAction = {\n\t\t_: 'sendMessageUploadDocumentAction',\n\t\tprogress: number\n\t};\n\n\texport type sendMessageGeoLocationAction = {\n\t\t_: 'sendMessageGeoLocationAction'\n\t};\n\n\texport type sendMessageChooseContactAction = {\n\t\t_: 'sendMessageChooseContactAction'\n\t};\n\n\texport type sendMessageGamePlayAction = {\n\t\t_: 'sendMessageGamePlayAction'\n\t};\n\n\texport type sendMessageRecordRoundAction = {\n\t\t_: 'sendMessageRecordRoundAction'\n\t};\n\n\texport type sendMessageUploadRoundAction = {\n\t\t_: 'sendMessageUploadRoundAction',\n\t\tprogress: number\n\t};\n\n\texport type speakingInGroupCallAction = {\n\t\t_: 'speakingInGroupCallAction'\n\t};\n\n\texport type sendMessageHistoryImportAction = {\n\t\t_: 'sendMessageHistoryImportAction',\n\t\tprogress: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/contacts.Found\n */\nexport type ContactsFound = ContactsFound.contactsFound;\n\nexport namespace ContactsFound {\n  export type contactsFound = {\n\t\t_: 'contacts.found',\n\t\tmy_results: Array<Peer>,\n\t\tresults: Array<Peer>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputPrivacyKey\n */\nexport type InputPrivacyKey = InputPrivacyKey.inputPrivacyKeyStatusTimestamp | InputPrivacyKey.inputPrivacyKeyChatInvite | InputPrivacyKey.inputPrivacyKeyPhoneCall | InputPrivacyKey.inputPrivacyKeyPhoneP2P | InputPrivacyKey.inputPrivacyKeyForwards | InputPrivacyKey.inputPrivacyKeyProfilePhoto | InputPrivacyKey.inputPrivacyKeyPhoneNumber | InputPrivacyKey.inputPrivacyKeyAddedByPhone;\n\nexport namespace InputPrivacyKey {\n  export type inputPrivacyKeyStatusTimestamp = {\n\t\t_: 'inputPrivacyKeyStatusTimestamp'\n\t};\n\n\texport type inputPrivacyKeyChatInvite = {\n\t\t_: 'inputPrivacyKeyChatInvite'\n\t};\n\n\texport type inputPrivacyKeyPhoneCall = {\n\t\t_: 'inputPrivacyKeyPhoneCall'\n\t};\n\n\texport type inputPrivacyKeyPhoneP2P = {\n\t\t_: 'inputPrivacyKeyPhoneP2P'\n\t};\n\n\texport type inputPrivacyKeyForwards = {\n\t\t_: 'inputPrivacyKeyForwards'\n\t};\n\n\texport type inputPrivacyKeyProfilePhoto = {\n\t\t_: 'inputPrivacyKeyProfilePhoto'\n\t};\n\n\texport type inputPrivacyKeyPhoneNumber = {\n\t\t_: 'inputPrivacyKeyPhoneNumber'\n\t};\n\n\texport type inputPrivacyKeyAddedByPhone = {\n\t\t_: 'inputPrivacyKeyAddedByPhone'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PrivacyKey\n */\nexport type PrivacyKey = PrivacyKey.privacyKeyStatusTimestamp | PrivacyKey.privacyKeyChatInvite | PrivacyKey.privacyKeyPhoneCall | PrivacyKey.privacyKeyPhoneP2P | PrivacyKey.privacyKeyForwards | PrivacyKey.privacyKeyProfilePhoto | PrivacyKey.privacyKeyPhoneNumber | PrivacyKey.privacyKeyAddedByPhone;\n\nexport namespace PrivacyKey {\n  export type privacyKeyStatusTimestamp = {\n\t\t_: 'privacyKeyStatusTimestamp'\n\t};\n\n\texport type privacyKeyChatInvite = {\n\t\t_: 'privacyKeyChatInvite'\n\t};\n\n\texport type privacyKeyPhoneCall = {\n\t\t_: 'privacyKeyPhoneCall'\n\t};\n\n\texport type privacyKeyPhoneP2P = {\n\t\t_: 'privacyKeyPhoneP2P'\n\t};\n\n\texport type privacyKeyForwards = {\n\t\t_: 'privacyKeyForwards'\n\t};\n\n\texport type privacyKeyProfilePhoto = {\n\t\t_: 'privacyKeyProfilePhoto'\n\t};\n\n\texport type privacyKeyPhoneNumber = {\n\t\t_: 'privacyKeyPhoneNumber'\n\t};\n\n\texport type privacyKeyAddedByPhone = {\n\t\t_: 'privacyKeyAddedByPhone'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputPrivacyRule\n */\nexport type InputPrivacyRule = InputPrivacyRule.inputPrivacyValueAllowContacts | InputPrivacyRule.inputPrivacyValueAllowAll | InputPrivacyRule.inputPrivacyValueAllowUsers | InputPrivacyRule.inputPrivacyValueDisallowContacts | InputPrivacyRule.inputPrivacyValueDisallowAll | InputPrivacyRule.inputPrivacyValueDisallowUsers | InputPrivacyRule.inputPrivacyValueAllowChatParticipants | InputPrivacyRule.inputPrivacyValueDisallowChatParticipants;\n\nexport namespace InputPrivacyRule {\n  export type inputPrivacyValueAllowContacts = {\n\t\t_: 'inputPrivacyValueAllowContacts'\n\t};\n\n\texport type inputPrivacyValueAllowAll = {\n\t\t_: 'inputPrivacyValueAllowAll'\n\t};\n\n\texport type inputPrivacyValueAllowUsers = {\n\t\t_: 'inputPrivacyValueAllowUsers',\n\t\tusers: Array<InputUser>\n\t};\n\n\texport type inputPrivacyValueDisallowContacts = {\n\t\t_: 'inputPrivacyValueDisallowContacts'\n\t};\n\n\texport type inputPrivacyValueDisallowAll = {\n\t\t_: 'inputPrivacyValueDisallowAll'\n\t};\n\n\texport type inputPrivacyValueDisallowUsers = {\n\t\t_: 'inputPrivacyValueDisallowUsers',\n\t\tusers: Array<InputUser>\n\t};\n\n\texport type inputPrivacyValueAllowChatParticipants = {\n\t\t_: 'inputPrivacyValueAllowChatParticipants',\n\t\tchats: Array<number>\n\t};\n\n\texport type inputPrivacyValueDisallowChatParticipants = {\n\t\t_: 'inputPrivacyValueDisallowChatParticipants',\n\t\tchats: Array<number>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PrivacyRule\n */\nexport type PrivacyRule = PrivacyRule.privacyValueAllowContacts | PrivacyRule.privacyValueAllowAll | PrivacyRule.privacyValueAllowUsers | PrivacyRule.privacyValueDisallowContacts | PrivacyRule.privacyValueDisallowAll | PrivacyRule.privacyValueDisallowUsers | PrivacyRule.privacyValueAllowChatParticipants | PrivacyRule.privacyValueDisallowChatParticipants;\n\nexport namespace PrivacyRule {\n  export type privacyValueAllowContacts = {\n\t\t_: 'privacyValueAllowContacts'\n\t};\n\n\texport type privacyValueAllowAll = {\n\t\t_: 'privacyValueAllowAll'\n\t};\n\n\texport type privacyValueAllowUsers = {\n\t\t_: 'privacyValueAllowUsers',\n\t\tusers: Array<number>\n\t};\n\n\texport type privacyValueDisallowContacts = {\n\t\t_: 'privacyValueDisallowContacts'\n\t};\n\n\texport type privacyValueDisallowAll = {\n\t\t_: 'privacyValueDisallowAll'\n\t};\n\n\texport type privacyValueDisallowUsers = {\n\t\t_: 'privacyValueDisallowUsers',\n\t\tusers: Array<number>\n\t};\n\n\texport type privacyValueAllowChatParticipants = {\n\t\t_: 'privacyValueAllowChatParticipants',\n\t\tchats: Array<number>\n\t};\n\n\texport type privacyValueDisallowChatParticipants = {\n\t\t_: 'privacyValueDisallowChatParticipants',\n\t\tchats: Array<number>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.PrivacyRules\n */\nexport type AccountPrivacyRules = AccountPrivacyRules.accountPrivacyRules;\n\nexport namespace AccountPrivacyRules {\n  export type accountPrivacyRules = {\n\t\t_: 'account.privacyRules',\n\t\trules: Array<PrivacyRule>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/AccountDaysTTL\n */\nexport type AccountDaysTTL = AccountDaysTTL.accountDaysTTL;\n\nexport namespace AccountDaysTTL {\n  export type accountDaysTTL = {\n\t\t_: 'accountDaysTTL',\n\t\tdays: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/DocumentAttribute\n */\nexport type DocumentAttribute = DocumentAttribute.documentAttributeImageSize | DocumentAttribute.documentAttributeAnimated | DocumentAttribute.documentAttributeSticker | DocumentAttribute.documentAttributeVideo | DocumentAttribute.documentAttributeAudio | DocumentAttribute.documentAttributeFilename | DocumentAttribute.documentAttributeHasStickers;\n\nexport namespace DocumentAttribute {\n  export type documentAttributeImageSize = {\n\t\t_: 'documentAttributeImageSize',\n\t\tw: number,\n\t\th: number\n\t};\n\n\texport type documentAttributeAnimated = {\n\t\t_: 'documentAttributeAnimated'\n\t};\n\n\texport type documentAttributeSticker = {\n\t\t_: 'documentAttributeSticker',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tmask?: true,\n\t\t}>,\n\t\talt: string,\n\t\tstickerset: InputStickerSet,\n\t\tmask_coords?: MaskCoords\n\t};\n\n\texport type documentAttributeVideo = {\n\t\t_: 'documentAttributeVideo',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tround_message?: true,\n\t\t\tsupports_streaming?: true,\n\t\t}>,\n\t\tduration: number,\n\t\tw: number,\n\t\th: number\n\t};\n\n\texport type documentAttributeAudio = {\n\t\t_: 'documentAttributeAudio',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tvoice?: true,\n\t\t}>,\n\t\tduration: number,\n\t\ttitle?: string,\n\t\tperformer?: string,\n\t\twaveform?: Uint8Array\n\t};\n\n\texport type documentAttributeFilename = {\n\t\t_: 'documentAttributeFilename',\n\t\tfile_name: string\n\t};\n\n\texport type documentAttributeHasStickers = {\n\t\t_: 'documentAttributeHasStickers'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.Stickers\n */\nexport type MessagesStickers = MessagesStickers.messagesStickersNotModified | MessagesStickers.messagesStickers;\n\nexport namespace MessagesStickers {\n  export type messagesStickersNotModified = {\n\t\t_: 'messages.stickersNotModified'\n\t};\n\n\texport type messagesStickers = {\n\t\t_: 'messages.stickers',\n\t\thash: number,\n\t\tstickers: Array<Document>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StickerPack\n */\nexport type StickerPack = StickerPack.stickerPack;\n\nexport namespace StickerPack {\n  export type stickerPack = {\n\t\t_: 'stickerPack',\n\t\temoticon: string,\n\t\tdocuments: Array<string>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.AllStickers\n */\nexport type MessagesAllStickers = MessagesAllStickers.messagesAllStickersNotModified | MessagesAllStickers.messagesAllStickers;\n\nexport namespace MessagesAllStickers {\n  export type messagesAllStickersNotModified = {\n\t\t_: 'messages.allStickersNotModified'\n\t};\n\n\texport type messagesAllStickers = {\n\t\t_: 'messages.allStickers',\n\t\thash: number,\n\t\tsets: Array<StickerSet>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.AffectedMessages\n */\nexport type MessagesAffectedMessages = MessagesAffectedMessages.messagesAffectedMessages;\n\nexport namespace MessagesAffectedMessages {\n  export type messagesAffectedMessages = {\n\t\t_: 'messages.affectedMessages',\n\t\tpts: number,\n\t\tpts_count: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/WebPage\n */\nexport type WebPage = WebPage.webPageEmpty | WebPage.webPagePending | WebPage.webPage | WebPage.webPageNotModified;\n\nexport namespace WebPage {\n  export type webPageEmpty = {\n\t\t_: 'webPageEmpty',\n\t\tid: string\n\t};\n\n\texport type webPagePending = {\n\t\t_: 'webPagePending',\n\t\tid: string,\n\t\tdate: number\n\t};\n\n\texport type webPage = {\n\t\t_: 'webPage',\n\t\tflags?: number,\n\t\tid: string,\n\t\turl: string,\n\t\tdisplay_url: string,\n\t\thash: number,\n\t\ttype?: string,\n\t\tsite_name?: string,\n\t\ttitle?: string,\n\t\tdescription?: string,\n\t\tphoto?: Photo,\n\t\tembed_url?: string,\n\t\tembed_type?: string,\n\t\tembed_width?: number,\n\t\tembed_height?: number,\n\t\tduration?: number,\n\t\tauthor?: string,\n\t\tdocument?: Document,\n\t\tcached_page?: Page,\n\t\tattributes?: Array<WebPageAttribute>\n\t};\n\n\texport type webPageNotModified = {\n\t\t_: 'webPageNotModified',\n\t\tflags?: number,\n\t\tcached_page_views?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Authorization\n */\nexport type Authorization = Authorization.authorization;\n\nexport namespace Authorization {\n  export type authorization = {\n\t\t_: 'authorization',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcurrent?: true,\n\t\t\tofficial_app?: true,\n\t\t\tpassword_pending?: true,\n\t\t}>,\n\t\thash: string,\n\t\tdevice_model: string,\n\t\tplatform: string,\n\t\tsystem_version: string,\n\t\tapi_id: number,\n\t\tapp_name: string,\n\t\tapp_version: string,\n\t\tdate_created: number,\n\t\tdate_active: number,\n\t\tip: string,\n\t\tcountry: string,\n\t\tregion: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.Authorizations\n */\nexport type AccountAuthorizations = AccountAuthorizations.accountAuthorizations;\n\nexport namespace AccountAuthorizations {\n  export type accountAuthorizations = {\n\t\t_: 'account.authorizations',\n\t\tauthorizations: Array<Authorization>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.Password\n */\nexport type AccountPassword = AccountPassword.accountPassword;\n\nexport namespace AccountPassword {\n  export type accountPassword = {\n\t\t_: 'account.password',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\thas_recovery?: true,\n\t\t\thas_secure_values?: true,\n\t\t\thas_password?: true,\n\t\t}>,\n\t\tcurrent_algo?: PasswordKdfAlgo,\n\t\tsrp_B?: Uint8Array,\n\t\tsrp_id?: string,\n\t\thint?: string,\n\t\temail_unconfirmed_pattern?: string,\n\t\tnew_algo: PasswordKdfAlgo,\n\t\tnew_secure_algo: SecurePasswordKdfAlgo,\n\t\tsecure_random: Uint8Array,\n\t\tpending_reset_date?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.PasswordSettings\n */\nexport type AccountPasswordSettings = AccountPasswordSettings.accountPasswordSettings;\n\nexport namespace AccountPasswordSettings {\n  export type accountPasswordSettings = {\n\t\t_: 'account.passwordSettings',\n\t\tflags?: number,\n\t\temail?: string,\n\t\tsecure_settings?: SecureSecretSettings\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.PasswordInputSettings\n */\nexport type AccountPasswordInputSettings = AccountPasswordInputSettings.accountPasswordInputSettings;\n\nexport namespace AccountPasswordInputSettings {\n  export type accountPasswordInputSettings = {\n\t\t_: 'account.passwordInputSettings',\n\t\tflags?: number,\n\t\tnew_algo?: PasswordKdfAlgo,\n\t\tnew_password_hash?: Uint8Array,\n\t\thint?: string,\n\t\temail?: string,\n\t\tnew_secure_settings?: SecureSecretSettings\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/auth.PasswordRecovery\n */\nexport type AuthPasswordRecovery = AuthPasswordRecovery.authPasswordRecovery;\n\nexport namespace AuthPasswordRecovery {\n  export type authPasswordRecovery = {\n\t\t_: 'auth.passwordRecovery',\n\t\temail_pattern: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ReceivedNotifyMessage\n */\nexport type ReceivedNotifyMessage = ReceivedNotifyMessage.receivedNotifyMessage;\n\nexport namespace ReceivedNotifyMessage {\n  export type receivedNotifyMessage = {\n\t\t_: 'receivedNotifyMessage',\n\t\tid: number,\n\t\tflags?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ExportedChatInvite\n */\nexport type ExportedChatInvite = ExportedChatInvite.chatInviteExported;\n\nexport namespace ExportedChatInvite {\n  export type chatInviteExported = {\n\t\t_: 'chatInviteExported',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\trevoked?: true,\n\t\t\tpermanent?: true,\n\t\t}>,\n\t\tlink: string,\n\t\tadmin_id: number,\n\t\tdate: number,\n\t\tstart_date?: number,\n\t\texpire_date?: number,\n\t\tusage_limit?: number,\n\t\tusage?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatInvite\n */\nexport type ChatInvite = ChatInvite.chatInviteAlready | ChatInvite.chatInvite | ChatInvite.chatInvitePeek;\n\nexport namespace ChatInvite {\n  export type chatInviteAlready = {\n\t\t_: 'chatInviteAlready',\n\t\tchat: Chat\n\t};\n\n\texport type chatInvite = {\n\t\t_: 'chatInvite',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tchannel?: true,\n\t\t\tbroadcast?: true,\n\t\t\tpublic?: true,\n\t\t\tmegagroup?: true,\n\t\t}>,\n\t\ttitle: string,\n\t\tphoto: Photo,\n\t\tparticipants_count: number,\n\t\tparticipants?: Array<User>\n\t};\n\n\texport type chatInvitePeek = {\n\t\t_: 'chatInvitePeek',\n\t\tchat: Chat,\n\t\texpires: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputStickerSet\n */\nexport type InputStickerSet = InputStickerSet.inputStickerSetEmpty | InputStickerSet.inputStickerSetID | InputStickerSet.inputStickerSetShortName | InputStickerSet.inputStickerSetAnimatedEmoji | InputStickerSet.inputStickerSetDice;\n\nexport namespace InputStickerSet {\n  export type inputStickerSetEmpty = {\n\t\t_: 'inputStickerSetEmpty'\n\t};\n\n\texport type inputStickerSetID = {\n\t\t_: 'inputStickerSetID',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputStickerSetShortName = {\n\t\t_: 'inputStickerSetShortName',\n\t\tshort_name: string\n\t};\n\n\texport type inputStickerSetAnimatedEmoji = {\n\t\t_: 'inputStickerSetAnimatedEmoji'\n\t};\n\n\texport type inputStickerSetDice = {\n\t\t_: 'inputStickerSetDice',\n\t\temoticon: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StickerSet\n */\nexport type StickerSet = StickerSet.stickerSet;\n\nexport namespace StickerSet {\n  export type stickerSet = {\n\t\t_: 'stickerSet',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tarchived?: true,\n\t\t\tofficial?: true,\n\t\t\tmasks?: true,\n\t\t\tanimated?: true,\n\t\t}>,\n\t\tinstalled_date?: number,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\ttitle: string,\n\t\tshort_name: string,\n\t\tthumbs?: Array<PhotoSize>,\n\t\tthumb_dc_id?: number,\n\t\tthumb_version?: number,\n\t\tcount: number,\n\t\thash: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.StickerSet\n */\nexport type MessagesStickerSet = MessagesStickerSet.messagesStickerSet;\n\nexport namespace MessagesStickerSet {\n  export type messagesStickerSet = {\n\t\t_: 'messages.stickerSet',\n\t\tset: StickerSet,\n\t\tpacks: Array<StickerPack>,\n\t\tdocuments: Array<Document>,\n\t\trefreshTime?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/BotCommand\n */\nexport type BotCommand = BotCommand.botCommand;\n\nexport namespace BotCommand {\n  export type botCommand = {\n\t\t_: 'botCommand',\n\t\tcommand: string,\n\t\tdescription: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/BotInfo\n */\nexport type BotInfo = BotInfo.botInfo;\n\nexport namespace BotInfo {\n  export type botInfo = {\n\t\t_: 'botInfo',\n\t\tuser_id: number,\n\t\tdescription: string,\n\t\tcommands: Array<BotCommand>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/KeyboardButton\n */\nexport type KeyboardButton = KeyboardButton.keyboardButton | KeyboardButton.keyboardButtonUrl | KeyboardButton.keyboardButtonCallback | KeyboardButton.keyboardButtonRequestPhone | KeyboardButton.keyboardButtonRequestGeoLocation | KeyboardButton.keyboardButtonSwitchInline | KeyboardButton.keyboardButtonGame | KeyboardButton.keyboardButtonBuy | KeyboardButton.keyboardButtonUrlAuth | KeyboardButton.inputKeyboardButtonUrlAuth | KeyboardButton.keyboardButtonRequestPoll;\n\nexport namespace KeyboardButton {\n  export type keyboardButton = {\n\t\t_: 'keyboardButton',\n\t\ttext: string\n\t};\n\n\texport type keyboardButtonUrl = {\n\t\t_: 'keyboardButtonUrl',\n\t\ttext: string,\n\t\turl: string\n\t};\n\n\texport type keyboardButtonCallback = {\n\t\t_: 'keyboardButtonCallback',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\trequires_password?: true,\n\t\t}>,\n\t\ttext: string,\n\t\tdata: Uint8Array\n\t};\n\n\texport type keyboardButtonRequestPhone = {\n\t\t_: 'keyboardButtonRequestPhone',\n\t\ttext: string\n\t};\n\n\texport type keyboardButtonRequestGeoLocation = {\n\t\t_: 'keyboardButtonRequestGeoLocation',\n\t\ttext: string\n\t};\n\n\texport type keyboardButtonSwitchInline = {\n\t\t_: 'keyboardButtonSwitchInline',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tsame_peer?: true,\n\t\t}>,\n\t\ttext: string,\n\t\tquery: string\n\t};\n\n\texport type keyboardButtonGame = {\n\t\t_: 'keyboardButtonGame',\n\t\ttext: string\n\t};\n\n\texport type keyboardButtonBuy = {\n\t\t_: 'keyboardButtonBuy',\n\t\ttext: string\n\t};\n\n\texport type keyboardButtonUrlAuth = {\n\t\t_: 'keyboardButtonUrlAuth',\n\t\tflags?: number,\n\t\ttext: string,\n\t\tfwd_text?: string,\n\t\turl: string,\n\t\tbutton_id: number\n\t};\n\n\texport type inputKeyboardButtonUrlAuth = {\n\t\t_: 'inputKeyboardButtonUrlAuth',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\trequest_write_access?: true,\n\t\t}>,\n\t\ttext: string,\n\t\tfwd_text?: string,\n\t\turl: string,\n\t\tbot: InputUser\n\t};\n\n\texport type keyboardButtonRequestPoll = {\n\t\t_: 'keyboardButtonRequestPoll',\n\t\tflags?: number,\n\t\tquiz?: boolean,\n\t\ttext: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/KeyboardButtonRow\n */\nexport type KeyboardButtonRow = KeyboardButtonRow.keyboardButtonRow;\n\nexport namespace KeyboardButtonRow {\n  export type keyboardButtonRow = {\n\t\t_: 'keyboardButtonRow',\n\t\tbuttons: Array<KeyboardButton>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ReplyMarkup\n */\nexport type ReplyMarkup = ReplyMarkup.replyKeyboardHide | ReplyMarkup.replyKeyboardForceReply | ReplyMarkup.replyKeyboardMarkup | ReplyMarkup.replyInlineMarkup;\n\nexport namespace ReplyMarkup {\n  export type replyKeyboardHide = {\n\t\t_: 'replyKeyboardHide',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tselective?: true,\n\t\t}>,\n\t\tmid?: number\n\t};\n\n\texport type replyKeyboardForceReply = {\n\t\t_: 'replyKeyboardForceReply',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tsingle_use?: true,\n\t\t\tselective?: true,\n\t\t\thidden?: true,\n\t\t}>,\n\t\tplaceholder?: string,\n\t\tmid?: number,\n\t\tfromId?: number\n\t};\n\n\texport type replyKeyboardMarkup = {\n\t\t_: 'replyKeyboardMarkup',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tresize?: true,\n\t\t\tsingle_use?: true,\n\t\t\tselective?: true,\n\t\t\thidden?: true,\n\t\t}>,\n\t\trows: Array<KeyboardButtonRow>,\n\t\tplaceholder?: string,\n\t\tmid?: number,\n\t\tfromId?: number\n\t};\n\n\texport type replyInlineMarkup = {\n\t\t_: 'replyInlineMarkup',\n\t\trows: Array<KeyboardButtonRow>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageEntity\n */\nexport type MessageEntity = MessageEntity.messageEntityUnknown | MessageEntity.messageEntityMention | MessageEntity.messageEntityHashtag | MessageEntity.messageEntityBotCommand | MessageEntity.messageEntityUrl | MessageEntity.messageEntityEmail | MessageEntity.messageEntityBold | MessageEntity.messageEntityItalic | MessageEntity.messageEntityCode | MessageEntity.messageEntityPre | MessageEntity.messageEntityTextUrl | MessageEntity.messageEntityMentionName | MessageEntity.inputMessageEntityMentionName | MessageEntity.messageEntityPhone | MessageEntity.messageEntityCashtag | MessageEntity.messageEntityUnderline | MessageEntity.messageEntityStrike | MessageEntity.messageEntityBlockquote | MessageEntity.messageEntityBankCard | MessageEntity.messageEntityEmoji | MessageEntity.messageEntityHighlight | MessageEntity.messageEntityLinebreak | MessageEntity.messageEntityCaret;\n\nexport namespace MessageEntity {\n  export type messageEntityUnknown = {\n\t\t_: 'messageEntityUnknown',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityMention = {\n\t\t_: 'messageEntityMention',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityHashtag = {\n\t\t_: 'messageEntityHashtag',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityBotCommand = {\n\t\t_: 'messageEntityBotCommand',\n\t\toffset: number,\n\t\tlength: number,\n\t\tunsafe?: boolean\n\t};\n\n\texport type messageEntityUrl = {\n\t\t_: 'messageEntityUrl',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityEmail = {\n\t\t_: 'messageEntityEmail',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityBold = {\n\t\t_: 'messageEntityBold',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityItalic = {\n\t\t_: 'messageEntityItalic',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityCode = {\n\t\t_: 'messageEntityCode',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityPre = {\n\t\t_: 'messageEntityPre',\n\t\toffset: number,\n\t\tlength: number,\n\t\tlanguage: string\n\t};\n\n\texport type messageEntityTextUrl = {\n\t\t_: 'messageEntityTextUrl',\n\t\toffset: number,\n\t\tlength: number,\n\t\turl: string\n\t};\n\n\texport type messageEntityMentionName = {\n\t\t_: 'messageEntityMentionName',\n\t\toffset: number,\n\t\tlength: number,\n\t\tuser_id: number\n\t};\n\n\texport type inputMessageEntityMentionName = {\n\t\t_: 'inputMessageEntityMentionName',\n\t\toffset: number,\n\t\tlength: number,\n\t\tuser_id: InputUser\n\t};\n\n\texport type messageEntityPhone = {\n\t\t_: 'messageEntityPhone',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityCashtag = {\n\t\t_: 'messageEntityCashtag',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityUnderline = {\n\t\t_: 'messageEntityUnderline',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityStrike = {\n\t\t_: 'messageEntityStrike',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityBlockquote = {\n\t\t_: 'messageEntityBlockquote',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityBankCard = {\n\t\t_: 'messageEntityBankCard',\n\t\toffset: number,\n\t\tlength: number\n\t};\n\n\texport type messageEntityEmoji = {\n\t\t_: 'messageEntityEmoji',\n\t\toffset?: number,\n\t\tlength?: number,\n\t\tunicode?: string\n\t};\n\n\texport type messageEntityHighlight = {\n\t\t_: 'messageEntityHighlight',\n\t\toffset?: number,\n\t\tlength?: number\n\t};\n\n\texport type messageEntityLinebreak = {\n\t\t_: 'messageEntityLinebreak',\n\t\toffset?: number,\n\t\tlength?: number\n\t};\n\n\texport type messageEntityCaret = {\n\t\t_: 'messageEntityCaret',\n\t\toffset?: number,\n\t\tlength?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputChannel\n */\nexport type InputChannel = InputChannel.inputChannelEmpty | InputChannel.inputChannel | InputChannel.inputChannelFromMessage;\n\nexport namespace InputChannel {\n  export type inputChannelEmpty = {\n\t\t_: 'inputChannelEmpty'\n\t};\n\n\texport type inputChannel = {\n\t\t_: 'inputChannel',\n\t\tchannel_id: number,\n\t\taccess_hash: string\n\t};\n\n\texport type inputChannelFromMessage = {\n\t\t_: 'inputChannelFromMessage',\n\t\tpeer: InputPeer,\n\t\tmsg_id: number,\n\t\tchannel_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/contacts.ResolvedPeer\n */\nexport type ContactsResolvedPeer = ContactsResolvedPeer.contactsResolvedPeer;\n\nexport namespace ContactsResolvedPeer {\n  export type contactsResolvedPeer = {\n\t\t_: 'contacts.resolvedPeer',\n\t\tpeer: Peer,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageRange\n */\nexport type MessageRange = MessageRange.messageRange;\n\nexport namespace MessageRange {\n  export type messageRange = {\n\t\t_: 'messageRange',\n\t\tmin_id: number,\n\t\tmax_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/updates.ChannelDifference\n */\nexport type UpdatesChannelDifference = UpdatesChannelDifference.updatesChannelDifferenceEmpty | UpdatesChannelDifference.updatesChannelDifferenceTooLong | UpdatesChannelDifference.updatesChannelDifference;\n\nexport namespace UpdatesChannelDifference {\n  export type updatesChannelDifferenceEmpty = {\n\t\t_: 'updates.channelDifferenceEmpty',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tfinal?: true,\n\t\t}>,\n\t\tpts: number,\n\t\ttimeout?: number\n\t};\n\n\texport type updatesChannelDifferenceTooLong = {\n\t\t_: 'updates.channelDifferenceTooLong',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tfinal?: true,\n\t\t}>,\n\t\ttimeout?: number,\n\t\tdialog: Dialog,\n\t\tmessages: Array<Message>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type updatesChannelDifference = {\n\t\t_: 'updates.channelDifference',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tfinal?: true,\n\t\t}>,\n\t\tpts: number,\n\t\ttimeout?: number,\n\t\tnew_messages: Array<Message>,\n\t\tother_updates: Array<Update>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChannelMessagesFilter\n */\nexport type ChannelMessagesFilter = ChannelMessagesFilter.channelMessagesFilterEmpty | ChannelMessagesFilter.channelMessagesFilter;\n\nexport namespace ChannelMessagesFilter {\n  export type channelMessagesFilterEmpty = {\n\t\t_: 'channelMessagesFilterEmpty'\n\t};\n\n\texport type channelMessagesFilter = {\n\t\t_: 'channelMessagesFilter',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\texclude_new_messages?: true,\n\t\t}>,\n\t\tranges: Array<MessageRange>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChannelParticipant\n */\nexport type ChannelParticipant = ChannelParticipant.channelParticipant | ChannelParticipant.channelParticipantSelf | ChannelParticipant.channelParticipantCreator | ChannelParticipant.channelParticipantAdmin | ChannelParticipant.channelParticipantBanned | ChannelParticipant.channelParticipantLeft;\n\nexport namespace ChannelParticipant {\n  export type channelParticipant = {\n\t\t_: 'channelParticipant',\n\t\tuser_id: number,\n\t\tdate: number\n\t};\n\n\texport type channelParticipantSelf = {\n\t\t_: 'channelParticipantSelf',\n\t\tuser_id: number,\n\t\tinviter_id: number,\n\t\tdate: number\n\t};\n\n\texport type channelParticipantCreator = {\n\t\t_: 'channelParticipantCreator',\n\t\tflags?: number,\n\t\tuser_id: number,\n\t\tadmin_rights: ChatAdminRights,\n\t\trank?: string\n\t};\n\n\texport type channelParticipantAdmin = {\n\t\t_: 'channelParticipantAdmin',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcan_edit?: true,\n\t\t\tself?: true,\n\t\t}>,\n\t\tuser_id: number,\n\t\tinviter_id?: number,\n\t\tpromoted_by: number,\n\t\tdate: number,\n\t\tadmin_rights: ChatAdminRights,\n\t\trank?: string\n\t};\n\n\texport type channelParticipantBanned = {\n\t\t_: 'channelParticipantBanned',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tleft?: true,\n\t\t}>,\n\t\tpeer: Peer,\n\t\tkicked_by: number,\n\t\tdate: number,\n\t\tbanned_rights: ChatBannedRights\n\t};\n\n\texport type channelParticipantLeft = {\n\t\t_: 'channelParticipantLeft',\n\t\tpeer: Peer\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChannelParticipantsFilter\n */\nexport type ChannelParticipantsFilter = ChannelParticipantsFilter.channelParticipantsRecent | ChannelParticipantsFilter.channelParticipantsAdmins | ChannelParticipantsFilter.channelParticipantsKicked | ChannelParticipantsFilter.channelParticipantsBots | ChannelParticipantsFilter.channelParticipantsBanned | ChannelParticipantsFilter.channelParticipantsSearch | ChannelParticipantsFilter.channelParticipantsContacts | ChannelParticipantsFilter.channelParticipantsMentions;\n\nexport namespace ChannelParticipantsFilter {\n  export type channelParticipantsRecent = {\n\t\t_: 'channelParticipantsRecent'\n\t};\n\n\texport type channelParticipantsAdmins = {\n\t\t_: 'channelParticipantsAdmins'\n\t};\n\n\texport type channelParticipantsKicked = {\n\t\t_: 'channelParticipantsKicked',\n\t\tq: string\n\t};\n\n\texport type channelParticipantsBots = {\n\t\t_: 'channelParticipantsBots'\n\t};\n\n\texport type channelParticipantsBanned = {\n\t\t_: 'channelParticipantsBanned',\n\t\tq: string\n\t};\n\n\texport type channelParticipantsSearch = {\n\t\t_: 'channelParticipantsSearch',\n\t\tq: string\n\t};\n\n\texport type channelParticipantsContacts = {\n\t\t_: 'channelParticipantsContacts',\n\t\tq: string\n\t};\n\n\texport type channelParticipantsMentions = {\n\t\t_: 'channelParticipantsMentions',\n\t\tflags?: number,\n\t\tq?: string,\n\t\ttop_msg_id?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/channels.ChannelParticipants\n */\nexport type ChannelsChannelParticipants = ChannelsChannelParticipants.channelsChannelParticipants | ChannelsChannelParticipants.channelsChannelParticipantsNotModified;\n\nexport namespace ChannelsChannelParticipants {\n  export type channelsChannelParticipants = {\n\t\t_: 'channels.channelParticipants',\n\t\tcount: number,\n\t\tparticipants: Array<ChannelParticipant>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type channelsChannelParticipantsNotModified = {\n\t\t_: 'channels.channelParticipantsNotModified'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/channels.ChannelParticipant\n */\nexport type ChannelsChannelParticipant = ChannelsChannelParticipant.channelsChannelParticipant;\n\nexport namespace ChannelsChannelParticipant {\n  export type channelsChannelParticipant = {\n\t\t_: 'channels.channelParticipant',\n\t\tparticipant: ChannelParticipant,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.TermsOfService\n */\nexport type HelpTermsOfService = HelpTermsOfService.helpTermsOfService;\n\nexport namespace HelpTermsOfService {\n  export type helpTermsOfService = {\n\t\t_: 'help.termsOfService',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpopup?: true,\n\t\t}>,\n\t\tid: DataJSON,\n\t\ttext: string,\n\t\tentities: Array<MessageEntity>,\n\t\tmin_age_confirm?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.SavedGifs\n */\nexport type MessagesSavedGifs = MessagesSavedGifs.messagesSavedGifsNotModified | MessagesSavedGifs.messagesSavedGifs;\n\nexport namespace MessagesSavedGifs {\n  export type messagesSavedGifsNotModified = {\n\t\t_: 'messages.savedGifsNotModified'\n\t};\n\n\texport type messagesSavedGifs = {\n\t\t_: 'messages.savedGifs',\n\t\thash: number,\n\t\tgifs: Array<Document>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputBotInlineMessage\n */\nexport type InputBotInlineMessage = InputBotInlineMessage.inputBotInlineMessageMediaAuto | InputBotInlineMessage.inputBotInlineMessageText | InputBotInlineMessage.inputBotInlineMessageMediaGeo | InputBotInlineMessage.inputBotInlineMessageMediaVenue | InputBotInlineMessage.inputBotInlineMessageMediaContact | InputBotInlineMessage.inputBotInlineMessageGame | InputBotInlineMessage.inputBotInlineMessageMediaInvoice;\n\nexport namespace InputBotInlineMessage {\n  export type inputBotInlineMessageMediaAuto = {\n\t\t_: 'inputBotInlineMessageMediaAuto',\n\t\tflags?: number,\n\t\tmessage: string,\n\t\tentities?: Array<MessageEntity>,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type inputBotInlineMessageText = {\n\t\t_: 'inputBotInlineMessageText',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tno_webpage?: true,\n\t\t}>,\n\t\tmessage: string,\n\t\tentities?: Array<MessageEntity>,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type inputBotInlineMessageMediaGeo = {\n\t\t_: 'inputBotInlineMessageMediaGeo',\n\t\tflags?: number,\n\t\tgeo_point: InputGeoPoint,\n\t\theading?: number,\n\t\tperiod?: number,\n\t\tproximity_notification_radius?: number,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type inputBotInlineMessageMediaVenue = {\n\t\t_: 'inputBotInlineMessageMediaVenue',\n\t\tflags?: number,\n\t\tgeo_point: InputGeoPoint,\n\t\ttitle: string,\n\t\taddress: string,\n\t\tprovider: string,\n\t\tvenue_id: string,\n\t\tvenue_type: string,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type inputBotInlineMessageMediaContact = {\n\t\t_: 'inputBotInlineMessageMediaContact',\n\t\tflags?: number,\n\t\tphone_number: string,\n\t\tfirst_name: string,\n\t\tlast_name: string,\n\t\tvcard: string,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type inputBotInlineMessageGame = {\n\t\t_: 'inputBotInlineMessageGame',\n\t\tflags?: number,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type inputBotInlineMessageMediaInvoice = {\n\t\t_: 'inputBotInlineMessageMediaInvoice',\n\t\tflags?: number,\n\t\ttitle: string,\n\t\tdescription: string,\n\t\tphoto?: InputWebDocument,\n\t\tinvoice: Invoice,\n\t\tpayload: Uint8Array,\n\t\tprovider: string,\n\t\tprovider_data: DataJSON,\n\t\treply_markup?: ReplyMarkup\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputBotInlineResult\n */\nexport type InputBotInlineResult = InputBotInlineResult.inputBotInlineResult | InputBotInlineResult.inputBotInlineResultPhoto | InputBotInlineResult.inputBotInlineResultDocument | InputBotInlineResult.inputBotInlineResultGame;\n\nexport namespace InputBotInlineResult {\n  export type inputBotInlineResult = {\n\t\t_: 'inputBotInlineResult',\n\t\tflags?: number,\n\t\tid: string,\n\t\ttype: string,\n\t\ttitle?: string,\n\t\tdescription?: string,\n\t\turl?: string,\n\t\tthumb?: InputWebDocument,\n\t\tcontent?: InputWebDocument,\n\t\tsend_message: InputBotInlineMessage\n\t};\n\n\texport type inputBotInlineResultPhoto = {\n\t\t_: 'inputBotInlineResultPhoto',\n\t\tid: string,\n\t\ttype: string,\n\t\tphoto: InputPhoto,\n\t\tsend_message: InputBotInlineMessage\n\t};\n\n\texport type inputBotInlineResultDocument = {\n\t\t_: 'inputBotInlineResultDocument',\n\t\tflags?: number,\n\t\tid: string,\n\t\ttype: string,\n\t\ttitle?: string,\n\t\tdescription?: string,\n\t\tdocument: InputDocument,\n\t\tsend_message: InputBotInlineMessage\n\t};\n\n\texport type inputBotInlineResultGame = {\n\t\t_: 'inputBotInlineResultGame',\n\t\tid: string,\n\t\tshort_name: string,\n\t\tsend_message: InputBotInlineMessage\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/BotInlineMessage\n */\nexport type BotInlineMessage = BotInlineMessage.botInlineMessageMediaAuto | BotInlineMessage.botInlineMessageText | BotInlineMessage.botInlineMessageMediaGeo | BotInlineMessage.botInlineMessageMediaVenue | BotInlineMessage.botInlineMessageMediaContact | BotInlineMessage.botInlineMessageMediaInvoice;\n\nexport namespace BotInlineMessage {\n  export type botInlineMessageMediaAuto = {\n\t\t_: 'botInlineMessageMediaAuto',\n\t\tflags?: number,\n\t\tmessage: string,\n\t\tentities?: Array<MessageEntity>,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type botInlineMessageText = {\n\t\t_: 'botInlineMessageText',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tno_webpage?: true,\n\t\t}>,\n\t\tmessage: string,\n\t\tentities?: Array<MessageEntity>,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type botInlineMessageMediaGeo = {\n\t\t_: 'botInlineMessageMediaGeo',\n\t\tflags?: number,\n\t\tgeo: GeoPoint,\n\t\theading?: number,\n\t\tperiod?: number,\n\t\tproximity_notification_radius?: number,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type botInlineMessageMediaVenue = {\n\t\t_: 'botInlineMessageMediaVenue',\n\t\tflags?: number,\n\t\tgeo: GeoPoint,\n\t\ttitle: string,\n\t\taddress: string,\n\t\tprovider: string,\n\t\tvenue_id: string,\n\t\tvenue_type: string,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type botInlineMessageMediaContact = {\n\t\t_: 'botInlineMessageMediaContact',\n\t\tflags?: number,\n\t\tphone_number: string,\n\t\tfirst_name: string,\n\t\tlast_name: string,\n\t\tvcard: string,\n\t\treply_markup?: ReplyMarkup\n\t};\n\n\texport type botInlineMessageMediaInvoice = {\n\t\t_: 'botInlineMessageMediaInvoice',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tshipping_address_requested?: true,\n\t\t\ttest?: true,\n\t\t}>,\n\t\ttitle: string,\n\t\tdescription: string,\n\t\tphoto?: WebDocument,\n\t\tcurrency: string,\n\t\ttotal_amount: string,\n\t\treply_markup?: ReplyMarkup\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/BotInlineResult\n */\nexport type BotInlineResult = BotInlineResult.botInlineResult | BotInlineResult.botInlineMediaResult;\n\nexport namespace BotInlineResult {\n  export type botInlineResult = {\n\t\t_: 'botInlineResult',\n\t\tflags?: number,\n\t\tid: string,\n\t\ttype: string,\n\t\ttitle?: string,\n\t\tdescription?: string,\n\t\turl?: string,\n\t\tthumb?: WebDocument,\n\t\tcontent?: WebDocument,\n\t\tsend_message: BotInlineMessage\n\t};\n\n\texport type botInlineMediaResult = {\n\t\t_: 'botInlineMediaResult',\n\t\tflags?: number,\n\t\tid: string,\n\t\ttype: string,\n\t\tphoto?: Photo,\n\t\tdocument?: Document,\n\t\ttitle?: string,\n\t\tdescription?: string,\n\t\tsend_message: BotInlineMessage\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.BotResults\n */\nexport type MessagesBotResults = MessagesBotResults.messagesBotResults;\n\nexport namespace MessagesBotResults {\n  export type messagesBotResults = {\n\t\t_: 'messages.botResults',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tgallery?: true,\n\t\t}>,\n\t\tquery_id: string,\n\t\tnext_offset?: string,\n\t\tswitch_pm?: InlineBotSwitchPM,\n\t\tresults: Array<BotInlineResult>,\n\t\tcache_time: number,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ExportedMessageLink\n */\nexport type ExportedMessageLink = ExportedMessageLink.exportedMessageLink;\n\nexport namespace ExportedMessageLink {\n  export type exportedMessageLink = {\n\t\t_: 'exportedMessageLink',\n\t\tlink: string,\n\t\thtml: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageFwdHeader\n */\nexport type MessageFwdHeader = MessageFwdHeader.messageFwdHeader;\n\nexport namespace MessageFwdHeader {\n  export type messageFwdHeader = {\n\t\t_: 'messageFwdHeader',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\timported?: true,\n\t\t}>,\n\t\tfrom_id?: Peer,\n\t\tfrom_name?: string,\n\t\tdate: number,\n\t\tchannel_post?: number,\n\t\tpost_author?: string,\n\t\tsaved_from_peer?: Peer,\n\t\tsaved_from_msg_id?: number,\n\t\tpsa_type?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/auth.CodeType\n */\nexport type AuthCodeType = AuthCodeType.authCodeTypeSms | AuthCodeType.authCodeTypeCall | AuthCodeType.authCodeTypeFlashCall;\n\nexport namespace AuthCodeType {\n  export type authCodeTypeSms = {\n\t\t_: 'auth.codeTypeSms'\n\t};\n\n\texport type authCodeTypeCall = {\n\t\t_: 'auth.codeTypeCall'\n\t};\n\n\texport type authCodeTypeFlashCall = {\n\t\t_: 'auth.codeTypeFlashCall'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/auth.SentCodeType\n */\nexport type AuthSentCodeType = AuthSentCodeType.authSentCodeTypeApp | AuthSentCodeType.authSentCodeTypeSms | AuthSentCodeType.authSentCodeTypeCall | AuthSentCodeType.authSentCodeTypeFlashCall;\n\nexport namespace AuthSentCodeType {\n  export type authSentCodeTypeApp = {\n\t\t_: 'auth.sentCodeTypeApp',\n\t\tlength: number\n\t};\n\n\texport type authSentCodeTypeSms = {\n\t\t_: 'auth.sentCodeTypeSms',\n\t\tlength: number\n\t};\n\n\texport type authSentCodeTypeCall = {\n\t\t_: 'auth.sentCodeTypeCall',\n\t\tlength: number\n\t};\n\n\texport type authSentCodeTypeFlashCall = {\n\t\t_: 'auth.sentCodeTypeFlashCall',\n\t\tpattern: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.BotCallbackAnswer\n */\nexport type MessagesBotCallbackAnswer = MessagesBotCallbackAnswer.messagesBotCallbackAnswer;\n\nexport namespace MessagesBotCallbackAnswer {\n  export type messagesBotCallbackAnswer = {\n\t\t_: 'messages.botCallbackAnswer',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\talert?: true,\n\t\t\thas_url?: true,\n\t\t\tnative_ui?: true,\n\t\t}>,\n\t\tmessage?: string,\n\t\turl?: string,\n\t\tcache_time: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.MessageEditData\n */\nexport type MessagesMessageEditData = MessagesMessageEditData.messagesMessageEditData;\n\nexport namespace MessagesMessageEditData {\n  export type messagesMessageEditData = {\n\t\t_: 'messages.messageEditData',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcaption?: true,\n\t\t}>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputBotInlineMessageID\n */\nexport type InputBotInlineMessageID = InputBotInlineMessageID.inputBotInlineMessageID;\n\nexport namespace InputBotInlineMessageID {\n  export type inputBotInlineMessageID = {\n\t\t_: 'inputBotInlineMessageID',\n\t\tdc_id: number,\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InlineBotSwitchPM\n */\nexport type InlineBotSwitchPM = InlineBotSwitchPM.inlineBotSwitchPM;\n\nexport namespace InlineBotSwitchPM {\n  export type inlineBotSwitchPM = {\n\t\t_: 'inlineBotSwitchPM',\n\t\ttext: string,\n\t\tstart_param: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.PeerDialogs\n */\nexport type MessagesPeerDialogs = MessagesPeerDialogs.messagesPeerDialogs;\n\nexport namespace MessagesPeerDialogs {\n  export type messagesPeerDialogs = {\n\t\t_: 'messages.peerDialogs',\n\t\tdialogs: Array<Dialog>,\n\t\tmessages: Array<Message>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>,\n\t\tstate: UpdatesState\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/TopPeer\n */\nexport type TopPeer = TopPeer.topPeer;\n\nexport namespace TopPeer {\n  export type topPeer = {\n\t\t_: 'topPeer',\n\t\tpeer: Peer,\n\t\trating: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/TopPeerCategory\n */\nexport type TopPeerCategory = TopPeerCategory.topPeerCategoryBotsPM | TopPeerCategory.topPeerCategoryBotsInline | TopPeerCategory.topPeerCategoryCorrespondents | TopPeerCategory.topPeerCategoryGroups | TopPeerCategory.topPeerCategoryChannels | TopPeerCategory.topPeerCategoryPhoneCalls | TopPeerCategory.topPeerCategoryForwardUsers | TopPeerCategory.topPeerCategoryForwardChats;\n\nexport namespace TopPeerCategory {\n  export type topPeerCategoryBotsPM = {\n\t\t_: 'topPeerCategoryBotsPM'\n\t};\n\n\texport type topPeerCategoryBotsInline = {\n\t\t_: 'topPeerCategoryBotsInline'\n\t};\n\n\texport type topPeerCategoryCorrespondents = {\n\t\t_: 'topPeerCategoryCorrespondents'\n\t};\n\n\texport type topPeerCategoryGroups = {\n\t\t_: 'topPeerCategoryGroups'\n\t};\n\n\texport type topPeerCategoryChannels = {\n\t\t_: 'topPeerCategoryChannels'\n\t};\n\n\texport type topPeerCategoryPhoneCalls = {\n\t\t_: 'topPeerCategoryPhoneCalls'\n\t};\n\n\texport type topPeerCategoryForwardUsers = {\n\t\t_: 'topPeerCategoryForwardUsers'\n\t};\n\n\texport type topPeerCategoryForwardChats = {\n\t\t_: 'topPeerCategoryForwardChats'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/TopPeerCategoryPeers\n */\nexport type TopPeerCategoryPeers = TopPeerCategoryPeers.topPeerCategoryPeers;\n\nexport namespace TopPeerCategoryPeers {\n  export type topPeerCategoryPeers = {\n\t\t_: 'topPeerCategoryPeers',\n\t\tcategory: TopPeerCategory,\n\t\tcount: number,\n\t\tpeers: Array<TopPeer>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/contacts.TopPeers\n */\nexport type ContactsTopPeers = ContactsTopPeers.contactsTopPeersNotModified | ContactsTopPeers.contactsTopPeers | ContactsTopPeers.contactsTopPeersDisabled;\n\nexport namespace ContactsTopPeers {\n  export type contactsTopPeersNotModified = {\n\t\t_: 'contacts.topPeersNotModified'\n\t};\n\n\texport type contactsTopPeers = {\n\t\t_: 'contacts.topPeers',\n\t\tcategories: Array<TopPeerCategoryPeers>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n\n\texport type contactsTopPeersDisabled = {\n\t\t_: 'contacts.topPeersDisabled'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/DraftMessage\n */\nexport type DraftMessage = DraftMessage.draftMessageEmpty | DraftMessage.draftMessage;\n\nexport namespace DraftMessage {\n  export type draftMessageEmpty = {\n\t\t_: 'draftMessageEmpty',\n\t\tflags?: number,\n\t\tdate?: number\n\t};\n\n\texport type draftMessage = {\n\t\t_: 'draftMessage',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tno_webpage?: true,\n\t\t}>,\n\t\treply_to_msg_id?: number,\n\t\tmessage: string,\n\t\tentities?: Array<MessageEntity>,\n\t\tdate: number,\n\t\trReply?: string,\n\t\trMessage?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.FeaturedStickers\n */\nexport type MessagesFeaturedStickers = MessagesFeaturedStickers.messagesFeaturedStickersNotModified | MessagesFeaturedStickers.messagesFeaturedStickers;\n\nexport namespace MessagesFeaturedStickers {\n  export type messagesFeaturedStickersNotModified = {\n\t\t_: 'messages.featuredStickersNotModified',\n\t\tcount: number\n\t};\n\n\texport type messagesFeaturedStickers = {\n\t\t_: 'messages.featuredStickers',\n\t\thash: number,\n\t\tcount: number,\n\t\tsets: Array<StickerSetCovered>,\n\t\tunread: Array<string>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.RecentStickers\n */\nexport type MessagesRecentStickers = MessagesRecentStickers.messagesRecentStickersNotModified | MessagesRecentStickers.messagesRecentStickers;\n\nexport namespace MessagesRecentStickers {\n  export type messagesRecentStickersNotModified = {\n\t\t_: 'messages.recentStickersNotModified'\n\t};\n\n\texport type messagesRecentStickers = {\n\t\t_: 'messages.recentStickers',\n\t\thash: number,\n\t\tpacks: Array<StickerPack>,\n\t\tstickers: Array<Document>,\n\t\tdates: Array<number>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.ArchivedStickers\n */\nexport type MessagesArchivedStickers = MessagesArchivedStickers.messagesArchivedStickers;\n\nexport namespace MessagesArchivedStickers {\n  export type messagesArchivedStickers = {\n\t\t_: 'messages.archivedStickers',\n\t\tcount: number,\n\t\tsets: Array<StickerSetCovered>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.StickerSetInstallResult\n */\nexport type MessagesStickerSetInstallResult = MessagesStickerSetInstallResult.messagesStickerSetInstallResultSuccess | MessagesStickerSetInstallResult.messagesStickerSetInstallResultArchive;\n\nexport namespace MessagesStickerSetInstallResult {\n  export type messagesStickerSetInstallResultSuccess = {\n\t\t_: 'messages.stickerSetInstallResultSuccess'\n\t};\n\n\texport type messagesStickerSetInstallResultArchive = {\n\t\t_: 'messages.stickerSetInstallResultArchive',\n\t\tsets: Array<StickerSetCovered>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StickerSetCovered\n */\nexport type StickerSetCovered = StickerSetCovered.stickerSetCovered | StickerSetCovered.stickerSetMultiCovered;\n\nexport namespace StickerSetCovered {\n  export type stickerSetCovered = {\n\t\t_: 'stickerSetCovered',\n\t\tset: StickerSet,\n\t\tcover: Document\n\t};\n\n\texport type stickerSetMultiCovered = {\n\t\t_: 'stickerSetMultiCovered',\n\t\tset: StickerSet,\n\t\tcovers: Array<Document>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MaskCoords\n */\nexport type MaskCoords = MaskCoords.maskCoords;\n\nexport namespace MaskCoords {\n  export type maskCoords = {\n\t\t_: 'maskCoords',\n\t\tn: number,\n\t\tx: number,\n\t\ty: number,\n\t\tzoom: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputStickeredMedia\n */\nexport type InputStickeredMedia = InputStickeredMedia.inputStickeredMediaPhoto | InputStickeredMedia.inputStickeredMediaDocument;\n\nexport namespace InputStickeredMedia {\n  export type inputStickeredMediaPhoto = {\n\t\t_: 'inputStickeredMediaPhoto',\n\t\tid: InputPhoto\n\t};\n\n\texport type inputStickeredMediaDocument = {\n\t\t_: 'inputStickeredMediaDocument',\n\t\tid: InputDocument\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Game\n */\nexport type Game = Game.game;\n\nexport namespace Game {\n  export type game = {\n\t\t_: 'game',\n\t\tflags?: number,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tshort_name: string,\n\t\ttitle: string,\n\t\tdescription: string,\n\t\tphoto: Photo,\n\t\tdocument?: Document\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputGame\n */\nexport type InputGame = InputGame.inputGameID | InputGame.inputGameShortName;\n\nexport namespace InputGame {\n  export type inputGameID = {\n\t\t_: 'inputGameID',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputGameShortName = {\n\t\t_: 'inputGameShortName',\n\t\tbot_id: InputUser,\n\t\tshort_name: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/HighScore\n */\nexport type HighScore = HighScore.highScore;\n\nexport namespace HighScore {\n  export type highScore = {\n\t\t_: 'highScore',\n\t\tpos: number,\n\t\tuser_id: number,\n\t\tscore: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.HighScores\n */\nexport type MessagesHighScores = MessagesHighScores.messagesHighScores;\n\nexport namespace MessagesHighScores {\n  export type messagesHighScores = {\n\t\t_: 'messages.highScores',\n\t\tscores: Array<HighScore>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/RichText\n */\nexport type RichText = RichText.textEmpty | RichText.textPlain | RichText.textBold | RichText.textItalic | RichText.textUnderline | RichText.textStrike | RichText.textFixed | RichText.textUrl | RichText.textEmail | RichText.textConcat | RichText.textSubscript | RichText.textSuperscript | RichText.textMarked | RichText.textPhone | RichText.textImage | RichText.textAnchor;\n\nexport namespace RichText {\n  export type textEmpty = {\n\t\t_: 'textEmpty'\n\t};\n\n\texport type textPlain = {\n\t\t_: 'textPlain',\n\t\ttext: string\n\t};\n\n\texport type textBold = {\n\t\t_: 'textBold',\n\t\ttext: RichText\n\t};\n\n\texport type textItalic = {\n\t\t_: 'textItalic',\n\t\ttext: RichText\n\t};\n\n\texport type textUnderline = {\n\t\t_: 'textUnderline',\n\t\ttext: RichText\n\t};\n\n\texport type textStrike = {\n\t\t_: 'textStrike',\n\t\ttext: RichText\n\t};\n\n\texport type textFixed = {\n\t\t_: 'textFixed',\n\t\ttext: RichText\n\t};\n\n\texport type textUrl = {\n\t\t_: 'textUrl',\n\t\ttext: RichText,\n\t\turl: string,\n\t\twebpage_id: string\n\t};\n\n\texport type textEmail = {\n\t\t_: 'textEmail',\n\t\ttext: RichText,\n\t\temail: string\n\t};\n\n\texport type textConcat = {\n\t\t_: 'textConcat',\n\t\ttexts: Array<RichText>\n\t};\n\n\texport type textSubscript = {\n\t\t_: 'textSubscript',\n\t\ttext: RichText\n\t};\n\n\texport type textSuperscript = {\n\t\t_: 'textSuperscript',\n\t\ttext: RichText\n\t};\n\n\texport type textMarked = {\n\t\t_: 'textMarked',\n\t\ttext: RichText\n\t};\n\n\texport type textPhone = {\n\t\t_: 'textPhone',\n\t\ttext: RichText,\n\t\tphone: string\n\t};\n\n\texport type textImage = {\n\t\t_: 'textImage',\n\t\tdocument_id: string,\n\t\tw: number,\n\t\th: number\n\t};\n\n\texport type textAnchor = {\n\t\t_: 'textAnchor',\n\t\ttext: RichText,\n\t\tname: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PageBlock\n */\nexport type PageBlock = PageBlock.pageBlockUnsupported | PageBlock.pageBlockTitle | PageBlock.pageBlockSubtitle | PageBlock.pageBlockAuthorDate | PageBlock.pageBlockHeader | PageBlock.pageBlockSubheader | PageBlock.pageBlockParagraph | PageBlock.pageBlockPreformatted | PageBlock.pageBlockFooter | PageBlock.pageBlockDivider | PageBlock.pageBlockAnchor | PageBlock.pageBlockList | PageBlock.pageBlockBlockquote | PageBlock.pageBlockPullquote | PageBlock.pageBlockPhoto | PageBlock.pageBlockVideo | PageBlock.pageBlockCover | PageBlock.pageBlockEmbed | PageBlock.pageBlockEmbedPost | PageBlock.pageBlockCollage | PageBlock.pageBlockSlideshow | PageBlock.pageBlockChannel | PageBlock.pageBlockAudio | PageBlock.pageBlockKicker | PageBlock.pageBlockTable | PageBlock.pageBlockOrderedList | PageBlock.pageBlockDetails | PageBlock.pageBlockRelatedArticles | PageBlock.pageBlockMap;\n\nexport namespace PageBlock {\n  export type pageBlockUnsupported = {\n\t\t_: 'pageBlockUnsupported'\n\t};\n\n\texport type pageBlockTitle = {\n\t\t_: 'pageBlockTitle',\n\t\ttext: RichText\n\t};\n\n\texport type pageBlockSubtitle = {\n\t\t_: 'pageBlockSubtitle',\n\t\ttext: RichText\n\t};\n\n\texport type pageBlockAuthorDate = {\n\t\t_: 'pageBlockAuthorDate',\n\t\tauthor: RichText,\n\t\tpublished_date: number\n\t};\n\n\texport type pageBlockHeader = {\n\t\t_: 'pageBlockHeader',\n\t\ttext: RichText\n\t};\n\n\texport type pageBlockSubheader = {\n\t\t_: 'pageBlockSubheader',\n\t\ttext: RichText\n\t};\n\n\texport type pageBlockParagraph = {\n\t\t_: 'pageBlockParagraph',\n\t\ttext: RichText\n\t};\n\n\texport type pageBlockPreformatted = {\n\t\t_: 'pageBlockPreformatted',\n\t\ttext: RichText,\n\t\tlanguage: string\n\t};\n\n\texport type pageBlockFooter = {\n\t\t_: 'pageBlockFooter',\n\t\ttext: RichText\n\t};\n\n\texport type pageBlockDivider = {\n\t\t_: 'pageBlockDivider'\n\t};\n\n\texport type pageBlockAnchor = {\n\t\t_: 'pageBlockAnchor',\n\t\tname: string\n\t};\n\n\texport type pageBlockList = {\n\t\t_: 'pageBlockList',\n\t\titems: Array<PageListItem>\n\t};\n\n\texport type pageBlockBlockquote = {\n\t\t_: 'pageBlockBlockquote',\n\t\ttext: RichText,\n\t\tcaption: RichText\n\t};\n\n\texport type pageBlockPullquote = {\n\t\t_: 'pageBlockPullquote',\n\t\ttext: RichText,\n\t\tcaption: RichText\n\t};\n\n\texport type pageBlockPhoto = {\n\t\t_: 'pageBlockPhoto',\n\t\tflags?: number,\n\t\tphoto_id: string,\n\t\tcaption: PageCaption,\n\t\turl?: string,\n\t\twebpage_id?: string\n\t};\n\n\texport type pageBlockVideo = {\n\t\t_: 'pageBlockVideo',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tautoplay?: true,\n\t\t\tloop?: true,\n\t\t}>,\n\t\tvideo_id: string,\n\t\tcaption: PageCaption\n\t};\n\n\texport type pageBlockCover = {\n\t\t_: 'pageBlockCover',\n\t\tcover: PageBlock\n\t};\n\n\texport type pageBlockEmbed = {\n\t\t_: 'pageBlockEmbed',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tfull_width?: true,\n\t\t\tallow_scrolling?: true,\n\t\t}>,\n\t\turl?: string,\n\t\thtml?: string,\n\t\tposter_photo_id?: string,\n\t\tw?: number,\n\t\th?: number,\n\t\tcaption: PageCaption\n\t};\n\n\texport type pageBlockEmbedPost = {\n\t\t_: 'pageBlockEmbedPost',\n\t\turl: string,\n\t\twebpage_id: string,\n\t\tauthor_photo_id: string,\n\t\tauthor: string,\n\t\tdate: number,\n\t\tblocks: Array<PageBlock>,\n\t\tcaption: PageCaption\n\t};\n\n\texport type pageBlockCollage = {\n\t\t_: 'pageBlockCollage',\n\t\titems: Array<PageBlock>,\n\t\tcaption: PageCaption\n\t};\n\n\texport type pageBlockSlideshow = {\n\t\t_: 'pageBlockSlideshow',\n\t\titems: Array<PageBlock>,\n\t\tcaption: PageCaption\n\t};\n\n\texport type pageBlockChannel = {\n\t\t_: 'pageBlockChannel',\n\t\tchannel: Chat\n\t};\n\n\texport type pageBlockAudio = {\n\t\t_: 'pageBlockAudio',\n\t\taudio_id: string,\n\t\tcaption: PageCaption\n\t};\n\n\texport type pageBlockKicker = {\n\t\t_: 'pageBlockKicker',\n\t\ttext: RichText\n\t};\n\n\texport type pageBlockTable = {\n\t\t_: 'pageBlockTable',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tbordered?: true,\n\t\t\tstriped?: true,\n\t\t}>,\n\t\ttitle: RichText,\n\t\trows: Array<PageTableRow>\n\t};\n\n\texport type pageBlockOrderedList = {\n\t\t_: 'pageBlockOrderedList',\n\t\titems: Array<PageListOrderedItem>\n\t};\n\n\texport type pageBlockDetails = {\n\t\t_: 'pageBlockDetails',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\topen?: true,\n\t\t}>,\n\t\tblocks: Array<PageBlock>,\n\t\ttitle: RichText\n\t};\n\n\texport type pageBlockRelatedArticles = {\n\t\t_: 'pageBlockRelatedArticles',\n\t\ttitle: RichText,\n\t\tarticles: Array<PageRelatedArticle>\n\t};\n\n\texport type pageBlockMap = {\n\t\t_: 'pageBlockMap',\n\t\tgeo: GeoPoint,\n\t\tzoom: number,\n\t\tw: number,\n\t\th: number,\n\t\tcaption: PageCaption\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PhoneCallDiscardReason\n */\nexport type PhoneCallDiscardReason = PhoneCallDiscardReason.phoneCallDiscardReasonMissed | PhoneCallDiscardReason.phoneCallDiscardReasonDisconnect | PhoneCallDiscardReason.phoneCallDiscardReasonHangup | PhoneCallDiscardReason.phoneCallDiscardReasonBusy;\n\nexport namespace PhoneCallDiscardReason {\n  export type phoneCallDiscardReasonMissed = {\n\t\t_: 'phoneCallDiscardReasonMissed'\n\t};\n\n\texport type phoneCallDiscardReasonDisconnect = {\n\t\t_: 'phoneCallDiscardReasonDisconnect'\n\t};\n\n\texport type phoneCallDiscardReasonHangup = {\n\t\t_: 'phoneCallDiscardReasonHangup'\n\t};\n\n\texport type phoneCallDiscardReasonBusy = {\n\t\t_: 'phoneCallDiscardReasonBusy'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/DataJSON\n */\nexport type DataJSON = DataJSON.dataJSON;\n\nexport namespace DataJSON {\n  export type dataJSON = {\n\t\t_: 'dataJSON',\n\t\tdata: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/LabeledPrice\n */\nexport type LabeledPrice = LabeledPrice.labeledPrice;\n\nexport namespace LabeledPrice {\n  export type labeledPrice = {\n\t\t_: 'labeledPrice',\n\t\tlabel: string,\n\t\tamount: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Invoice\n */\nexport type Invoice = Invoice.invoice;\n\nexport namespace Invoice {\n  export type invoice = {\n\t\t_: 'invoice',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\ttest?: true,\n\t\t\tname_requested?: true,\n\t\t\tphone_requested?: true,\n\t\t\temail_requested?: true,\n\t\t\tshipping_address_requested?: true,\n\t\t\tflexible?: true,\n\t\t\tphone_to_provider?: true,\n\t\t\temail_to_provider?: true,\n\t\t}>,\n\t\tcurrency: string,\n\t\tprices: Array<LabeledPrice>,\n\t\tmax_tip_amount?: string,\n\t\tsuggested_tip_amounts?: Array<string>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PaymentCharge\n */\nexport type PaymentCharge = PaymentCharge.paymentCharge;\n\nexport namespace PaymentCharge {\n  export type paymentCharge = {\n\t\t_: 'paymentCharge',\n\t\tid: string,\n\t\tprovider_charge_id: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PostAddress\n */\nexport type PostAddress = PostAddress.postAddress;\n\nexport namespace PostAddress {\n  export type postAddress = {\n\t\t_: 'postAddress',\n\t\tstreet_line1: string,\n\t\tstreet_line2: string,\n\t\tcity: string,\n\t\tstate: string,\n\t\tcountry_iso2: string,\n\t\tpost_code: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PaymentRequestedInfo\n */\nexport type PaymentRequestedInfo = PaymentRequestedInfo.paymentRequestedInfo;\n\nexport namespace PaymentRequestedInfo {\n  export type paymentRequestedInfo = {\n\t\t_: 'paymentRequestedInfo',\n\t\tflags?: number,\n\t\tname?: string,\n\t\tphone?: string,\n\t\temail?: string,\n\t\tshipping_address?: PostAddress\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PaymentSavedCredentials\n */\nexport type PaymentSavedCredentials = PaymentSavedCredentials.paymentSavedCredentialsCard;\n\nexport namespace PaymentSavedCredentials {\n  export type paymentSavedCredentialsCard = {\n\t\t_: 'paymentSavedCredentialsCard',\n\t\tid: string,\n\t\ttitle: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/WebDocument\n */\nexport type WebDocument = WebDocument.webDocument | WebDocument.webDocumentNoProxy;\n\nexport namespace WebDocument {\n  export type webDocument = {\n\t\t_: 'webDocument',\n\t\turl: string,\n\t\taccess_hash: string,\n\t\tsize: number,\n\t\tmime_type: string,\n\t\tattributes: Array<DocumentAttribute>\n\t};\n\n\texport type webDocumentNoProxy = {\n\t\t_: 'webDocumentNoProxy',\n\t\turl: string,\n\t\tsize: number,\n\t\tmime_type: string,\n\t\tattributes: Array<DocumentAttribute>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputWebDocument\n */\nexport type InputWebDocument = InputWebDocument.inputWebDocument;\n\nexport namespace InputWebDocument {\n  export type inputWebDocument = {\n\t\t_: 'inputWebDocument',\n\t\turl: string,\n\t\tsize: number,\n\t\tmime_type: string,\n\t\tattributes: Array<DocumentAttribute>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputWebFileLocation\n */\nexport type InputWebFileLocation = InputWebFileLocation.inputWebFileLocation | InputWebFileLocation.inputWebFileGeoPointLocation;\n\nexport namespace InputWebFileLocation {\n  export type inputWebFileLocation = {\n\t\t_: 'inputWebFileLocation',\n\t\turl: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputWebFileGeoPointLocation = {\n\t\t_: 'inputWebFileGeoPointLocation',\n\t\tgeo_point: InputGeoPoint,\n\t\taccess_hash: string,\n\t\tw: number,\n\t\th: number,\n\t\tzoom: number,\n\t\tscale: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/upload.WebFile\n */\nexport type UploadWebFile = UploadWebFile.uploadWebFile;\n\nexport namespace UploadWebFile {\n  export type uploadWebFile = {\n\t\t_: 'upload.webFile',\n\t\tsize: number,\n\t\tmime_type: string,\n\t\tfile_type: StorageFileType,\n\t\tmtime: number,\n\t\tbytes: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/payments.PaymentForm\n */\nexport type PaymentsPaymentForm = PaymentsPaymentForm.paymentsPaymentForm;\n\nexport namespace PaymentsPaymentForm {\n  export type paymentsPaymentForm = {\n\t\t_: 'payments.paymentForm',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcan_save_credentials?: true,\n\t\t\tpassword_missing?: true,\n\t\t}>,\n\t\tform_id: string,\n\t\tbot_id: number,\n\t\tinvoice: Invoice,\n\t\tprovider_id: number,\n\t\turl: string,\n\t\tnative_provider?: string,\n\t\tnative_params?: DataJSON,\n\t\tsaved_info?: PaymentRequestedInfo,\n\t\tsaved_credentials?: PaymentSavedCredentials,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/payments.ValidatedRequestedInfo\n */\nexport type PaymentsValidatedRequestedInfo = PaymentsValidatedRequestedInfo.paymentsValidatedRequestedInfo;\n\nexport namespace PaymentsValidatedRequestedInfo {\n  export type paymentsValidatedRequestedInfo = {\n\t\t_: 'payments.validatedRequestedInfo',\n\t\tflags?: number,\n\t\tid?: string,\n\t\tshipping_options?: Array<ShippingOption>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/payments.PaymentResult\n */\nexport type PaymentsPaymentResult = PaymentsPaymentResult.paymentsPaymentResult | PaymentsPaymentResult.paymentsPaymentVerificationNeeded;\n\nexport namespace PaymentsPaymentResult {\n  export type paymentsPaymentResult = {\n\t\t_: 'payments.paymentResult',\n\t\tupdates: Updates\n\t};\n\n\texport type paymentsPaymentVerificationNeeded = {\n\t\t_: 'payments.paymentVerificationNeeded',\n\t\turl: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/payments.PaymentReceipt\n */\nexport type PaymentsPaymentReceipt = PaymentsPaymentReceipt.paymentsPaymentReceipt;\n\nexport namespace PaymentsPaymentReceipt {\n  export type paymentsPaymentReceipt = {\n\t\t_: 'payments.paymentReceipt',\n\t\tflags?: number,\n\t\tdate: number,\n\t\tbot_id: number,\n\t\tprovider_id: number,\n\t\ttitle: string,\n\t\tdescription: string,\n\t\tphoto?: WebDocument,\n\t\tinvoice: Invoice,\n\t\tinfo?: PaymentRequestedInfo,\n\t\tshipping?: ShippingOption,\n\t\ttip_amount?: string,\n\t\tcurrency: string,\n\t\ttotal_amount: string,\n\t\tcredentials_title: string,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/payments.SavedInfo\n */\nexport type PaymentsSavedInfo = PaymentsSavedInfo.paymentsSavedInfo;\n\nexport namespace PaymentsSavedInfo {\n  export type paymentsSavedInfo = {\n\t\t_: 'payments.savedInfo',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\thas_saved_credentials?: true,\n\t\t}>,\n\t\tsaved_info?: PaymentRequestedInfo\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputPaymentCredentials\n */\nexport type InputPaymentCredentials = InputPaymentCredentials.inputPaymentCredentialsSaved | InputPaymentCredentials.inputPaymentCredentials | InputPaymentCredentials.inputPaymentCredentialsApplePay | InputPaymentCredentials.inputPaymentCredentialsGooglePay;\n\nexport namespace InputPaymentCredentials {\n  export type inputPaymentCredentialsSaved = {\n\t\t_: 'inputPaymentCredentialsSaved',\n\t\tid: string,\n\t\ttmp_password: Uint8Array\n\t};\n\n\texport type inputPaymentCredentials = {\n\t\t_: 'inputPaymentCredentials',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tsave?: true,\n\t\t}>,\n\t\tdata: DataJSON\n\t};\n\n\texport type inputPaymentCredentialsApplePay = {\n\t\t_: 'inputPaymentCredentialsApplePay',\n\t\tpayment_data: DataJSON\n\t};\n\n\texport type inputPaymentCredentialsGooglePay = {\n\t\t_: 'inputPaymentCredentialsGooglePay',\n\t\tpayment_token: DataJSON\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.TmpPassword\n */\nexport type AccountTmpPassword = AccountTmpPassword.accountTmpPassword;\n\nexport namespace AccountTmpPassword {\n  export type accountTmpPassword = {\n\t\t_: 'account.tmpPassword',\n\t\ttmp_password: Uint8Array,\n\t\tvalid_until: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ShippingOption\n */\nexport type ShippingOption = ShippingOption.shippingOption;\n\nexport namespace ShippingOption {\n  export type shippingOption = {\n\t\t_: 'shippingOption',\n\t\tid: string,\n\t\ttitle: string,\n\t\tprices: Array<LabeledPrice>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputStickerSetItem\n */\nexport type InputStickerSetItem = InputStickerSetItem.inputStickerSetItem;\n\nexport namespace InputStickerSetItem {\n  export type inputStickerSetItem = {\n\t\t_: 'inputStickerSetItem',\n\t\tflags?: number,\n\t\tdocument: InputDocument,\n\t\temoji: string,\n\t\tmask_coords?: MaskCoords\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputPhoneCall\n */\nexport type InputPhoneCall = InputPhoneCall.inputPhoneCall;\n\nexport namespace InputPhoneCall {\n  export type inputPhoneCall = {\n\t\t_: 'inputPhoneCall',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PhoneCall\n */\nexport type PhoneCall = PhoneCall.phoneCallEmpty | PhoneCall.phoneCallWaiting | PhoneCall.phoneCallRequested | PhoneCall.phoneCallAccepted | PhoneCall.phoneCall | PhoneCall.phoneCallDiscarded;\n\nexport namespace PhoneCall {\n  export type phoneCallEmpty = {\n\t\t_: 'phoneCallEmpty',\n\t\tid: string\n\t};\n\n\texport type phoneCallWaiting = {\n\t\t_: 'phoneCallWaiting',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tvideo?: true,\n\t\t}>,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tdate: number,\n\t\tadmin_id: number,\n\t\tparticipant_id: number,\n\t\tprotocol: PhoneCallProtocol,\n\t\treceive_date?: number\n\t};\n\n\texport type phoneCallRequested = {\n\t\t_: 'phoneCallRequested',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tvideo?: true,\n\t\t}>,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tdate: number,\n\t\tadmin_id: number,\n\t\tparticipant_id: number,\n\t\tg_a_hash: Uint8Array,\n\t\tprotocol: PhoneCallProtocol\n\t};\n\n\texport type phoneCallAccepted = {\n\t\t_: 'phoneCallAccepted',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tvideo?: true,\n\t\t}>,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tdate: number,\n\t\tadmin_id: number,\n\t\tparticipant_id: number,\n\t\tg_b: Uint8Array,\n\t\tprotocol: PhoneCallProtocol\n\t};\n\n\texport type phoneCall = {\n\t\t_: 'phoneCall',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tp2p_allowed?: true,\n\t\t\tvideo?: true,\n\t\t}>,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tdate: number,\n\t\tadmin_id: number,\n\t\tparticipant_id: number,\n\t\tg_a_or_b: Uint8Array,\n\t\tkey_fingerprint: string,\n\t\tprotocol: PhoneCallProtocol,\n\t\tconnections: Array<PhoneConnection>,\n\t\tstart_date: number\n\t};\n\n\texport type phoneCallDiscarded = {\n\t\t_: 'phoneCallDiscarded',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tneed_rating?: true,\n\t\t\tneed_debug?: true,\n\t\t\tvideo?: true,\n\t\t}>,\n\t\tid: string,\n\t\treason?: PhoneCallDiscardReason,\n\t\tduration?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PhoneConnection\n */\nexport type PhoneConnection = PhoneConnection.phoneConnection | PhoneConnection.phoneConnectionWebrtc;\n\nexport namespace PhoneConnection {\n  export type phoneConnection = {\n\t\t_: 'phoneConnection',\n\t\tid: string,\n\t\tip: string,\n\t\tipv6: string,\n\t\tport: number,\n\t\tpeer_tag: Uint8Array\n\t};\n\n\texport type phoneConnectionWebrtc = {\n\t\t_: 'phoneConnectionWebrtc',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tturn?: true,\n\t\t\tstun?: true,\n\t\t}>,\n\t\tid: string,\n\t\tip: string,\n\t\tipv6: string,\n\t\tport: number,\n\t\tusername: string,\n\t\tpassword: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PhoneCallProtocol\n */\nexport type PhoneCallProtocol = PhoneCallProtocol.phoneCallProtocol;\n\nexport namespace PhoneCallProtocol {\n  export type phoneCallProtocol = {\n\t\t_: 'phoneCallProtocol',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tudp_p2p?: true,\n\t\t\tudp_reflector?: true,\n\t\t}>,\n\t\tmin_layer: number,\n\t\tmax_layer: number,\n\t\tlibrary_versions: Array<string>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/phone.PhoneCall\n */\nexport type PhonePhoneCall = PhonePhoneCall.phonePhoneCall;\n\nexport namespace PhonePhoneCall {\n  export type phonePhoneCall = {\n\t\t_: 'phone.phoneCall',\n\t\tphone_call: PhoneCall,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/upload.CdnFile\n */\nexport type UploadCdnFile = UploadCdnFile.uploadCdnFileReuploadNeeded | UploadCdnFile.uploadCdnFile;\n\nexport namespace UploadCdnFile {\n  export type uploadCdnFileReuploadNeeded = {\n\t\t_: 'upload.cdnFileReuploadNeeded',\n\t\trequest_token: Uint8Array\n\t};\n\n\texport type uploadCdnFile = {\n\t\t_: 'upload.cdnFile',\n\t\tbytes: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/CdnPublicKey\n */\nexport type CdnPublicKey = CdnPublicKey.cdnPublicKey;\n\nexport namespace CdnPublicKey {\n  export type cdnPublicKey = {\n\t\t_: 'cdnPublicKey',\n\t\tdc_id: number,\n\t\tpublic_key: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/CdnConfig\n */\nexport type CdnConfig = CdnConfig.cdnConfig;\n\nexport namespace CdnConfig {\n  export type cdnConfig = {\n\t\t_: 'cdnConfig',\n\t\tpublic_keys: Array<CdnPublicKey>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/LangPackString\n */\nexport type LangPackString = LangPackString.langPackString | LangPackString.langPackStringPluralized | LangPackString.langPackStringDeleted;\n\nexport namespace LangPackString {\n  export type langPackString = {\n\t\t_: 'langPackString',\n\t\tkey: string,\n\t\tvalue: string\n\t};\n\n\texport type langPackStringPluralized = {\n\t\t_: 'langPackStringPluralized',\n\t\tflags?: number,\n\t\tkey: string,\n\t\tzero_value?: string,\n\t\tone_value?: string,\n\t\ttwo_value?: string,\n\t\tfew_value?: string,\n\t\tmany_value?: string,\n\t\tother_value: string\n\t};\n\n\texport type langPackStringDeleted = {\n\t\t_: 'langPackStringDeleted',\n\t\tkey: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/LangPackDifference\n */\nexport type LangPackDifference = LangPackDifference.langPackDifference;\n\nexport namespace LangPackDifference {\n  export type langPackDifference = {\n\t\t_: 'langPackDifference',\n\t\tlang_code: string,\n\t\tfrom_version: number,\n\t\tversion: number,\n\t\tstrings: Array<LangPackString>,\n\t\tlocal?: boolean,\n\t\tappVersion?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/LangPackLanguage\n */\nexport type LangPackLanguage = LangPackLanguage.langPackLanguage;\n\nexport namespace LangPackLanguage {\n  export type langPackLanguage = {\n\t\t_: 'langPackLanguage',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tofficial?: true,\n\t\t\trtl?: true,\n\t\t\tbeta?: true,\n\t\t}>,\n\t\tname: string,\n\t\tnative_name: string,\n\t\tlang_code: string,\n\t\tbase_lang_code?: string,\n\t\tplural_code: string,\n\t\tstrings_count: number,\n\t\ttranslated_count: number,\n\t\ttranslations_url: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChannelAdminLogEventAction\n */\nexport type ChannelAdminLogEventAction = ChannelAdminLogEventAction.channelAdminLogEventActionChangeTitle | ChannelAdminLogEventAction.channelAdminLogEventActionChangeAbout | ChannelAdminLogEventAction.channelAdminLogEventActionChangeUsername | ChannelAdminLogEventAction.channelAdminLogEventActionChangePhoto | ChannelAdminLogEventAction.channelAdminLogEventActionToggleInvites | ChannelAdminLogEventAction.channelAdminLogEventActionToggleSignatures | ChannelAdminLogEventAction.channelAdminLogEventActionUpdatePinned | ChannelAdminLogEventAction.channelAdminLogEventActionEditMessage | ChannelAdminLogEventAction.channelAdminLogEventActionDeleteMessage | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantJoin | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantLeave | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantInvite | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantToggleBan | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantToggleAdmin | ChannelAdminLogEventAction.channelAdminLogEventActionChangeStickerSet | ChannelAdminLogEventAction.channelAdminLogEventActionTogglePreHistoryHidden | ChannelAdminLogEventAction.channelAdminLogEventActionDefaultBannedRights | ChannelAdminLogEventAction.channelAdminLogEventActionStopPoll | ChannelAdminLogEventAction.channelAdminLogEventActionChangeLinkedChat | ChannelAdminLogEventAction.channelAdminLogEventActionChangeLocation | ChannelAdminLogEventAction.channelAdminLogEventActionToggleSlowMode | ChannelAdminLogEventAction.channelAdminLogEventActionStartGroupCall | ChannelAdminLogEventAction.channelAdminLogEventActionDiscardGroupCall | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantMute | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantUnmute | ChannelAdminLogEventAction.channelAdminLogEventActionToggleGroupCallSetting | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantJoinByInvite | ChannelAdminLogEventAction.channelAdminLogEventActionExportedInviteDelete | ChannelAdminLogEventAction.channelAdminLogEventActionExportedInviteRevoke | ChannelAdminLogEventAction.channelAdminLogEventActionExportedInviteEdit | ChannelAdminLogEventAction.channelAdminLogEventActionParticipantVolume | ChannelAdminLogEventAction.channelAdminLogEventActionChangeHistoryTTL;\n\nexport namespace ChannelAdminLogEventAction {\n  export type channelAdminLogEventActionChangeTitle = {\n\t\t_: 'channelAdminLogEventActionChangeTitle',\n\t\tprev_value: string,\n\t\tnew_value: string\n\t};\n\n\texport type channelAdminLogEventActionChangeAbout = {\n\t\t_: 'channelAdminLogEventActionChangeAbout',\n\t\tprev_value: string,\n\t\tnew_value: string\n\t};\n\n\texport type channelAdminLogEventActionChangeUsername = {\n\t\t_: 'channelAdminLogEventActionChangeUsername',\n\t\tprev_value: string,\n\t\tnew_value: string\n\t};\n\n\texport type channelAdminLogEventActionChangePhoto = {\n\t\t_: 'channelAdminLogEventActionChangePhoto',\n\t\tprev_photo: Photo,\n\t\tnew_photo: Photo\n\t};\n\n\texport type channelAdminLogEventActionToggleInvites = {\n\t\t_: 'channelAdminLogEventActionToggleInvites',\n\t\tnew_value: boolean\n\t};\n\n\texport type channelAdminLogEventActionToggleSignatures = {\n\t\t_: 'channelAdminLogEventActionToggleSignatures',\n\t\tnew_value: boolean\n\t};\n\n\texport type channelAdminLogEventActionUpdatePinned = {\n\t\t_: 'channelAdminLogEventActionUpdatePinned',\n\t\tmessage: Message\n\t};\n\n\texport type channelAdminLogEventActionEditMessage = {\n\t\t_: 'channelAdminLogEventActionEditMessage',\n\t\tprev_message: Message,\n\t\tnew_message: Message\n\t};\n\n\texport type channelAdminLogEventActionDeleteMessage = {\n\t\t_: 'channelAdminLogEventActionDeleteMessage',\n\t\tmessage: Message\n\t};\n\n\texport type channelAdminLogEventActionParticipantJoin = {\n\t\t_: 'channelAdminLogEventActionParticipantJoin'\n\t};\n\n\texport type channelAdminLogEventActionParticipantLeave = {\n\t\t_: 'channelAdminLogEventActionParticipantLeave'\n\t};\n\n\texport type channelAdminLogEventActionParticipantInvite = {\n\t\t_: 'channelAdminLogEventActionParticipantInvite',\n\t\tparticipant: ChannelParticipant\n\t};\n\n\texport type channelAdminLogEventActionParticipantToggleBan = {\n\t\t_: 'channelAdminLogEventActionParticipantToggleBan',\n\t\tprev_participant: ChannelParticipant,\n\t\tnew_participant: ChannelParticipant\n\t};\n\n\texport type channelAdminLogEventActionParticipantToggleAdmin = {\n\t\t_: 'channelAdminLogEventActionParticipantToggleAdmin',\n\t\tprev_participant: ChannelParticipant,\n\t\tnew_participant: ChannelParticipant\n\t};\n\n\texport type channelAdminLogEventActionChangeStickerSet = {\n\t\t_: 'channelAdminLogEventActionChangeStickerSet',\n\t\tprev_stickerset: InputStickerSet,\n\t\tnew_stickerset: InputStickerSet\n\t};\n\n\texport type channelAdminLogEventActionTogglePreHistoryHidden = {\n\t\t_: 'channelAdminLogEventActionTogglePreHistoryHidden',\n\t\tnew_value: boolean\n\t};\n\n\texport type channelAdminLogEventActionDefaultBannedRights = {\n\t\t_: 'channelAdminLogEventActionDefaultBannedRights',\n\t\tprev_banned_rights: ChatBannedRights,\n\t\tnew_banned_rights: ChatBannedRights\n\t};\n\n\texport type channelAdminLogEventActionStopPoll = {\n\t\t_: 'channelAdminLogEventActionStopPoll',\n\t\tmessage: Message\n\t};\n\n\texport type channelAdminLogEventActionChangeLinkedChat = {\n\t\t_: 'channelAdminLogEventActionChangeLinkedChat',\n\t\tprev_value: number,\n\t\tnew_value: number\n\t};\n\n\texport type channelAdminLogEventActionChangeLocation = {\n\t\t_: 'channelAdminLogEventActionChangeLocation',\n\t\tprev_value: ChannelLocation,\n\t\tnew_value: ChannelLocation\n\t};\n\n\texport type channelAdminLogEventActionToggleSlowMode = {\n\t\t_: 'channelAdminLogEventActionToggleSlowMode',\n\t\tprev_value: number,\n\t\tnew_value: number\n\t};\n\n\texport type channelAdminLogEventActionStartGroupCall = {\n\t\t_: 'channelAdminLogEventActionStartGroupCall',\n\t\tcall: InputGroupCall\n\t};\n\n\texport type channelAdminLogEventActionDiscardGroupCall = {\n\t\t_: 'channelAdminLogEventActionDiscardGroupCall',\n\t\tcall: InputGroupCall\n\t};\n\n\texport type channelAdminLogEventActionParticipantMute = {\n\t\t_: 'channelAdminLogEventActionParticipantMute',\n\t\tparticipant: GroupCallParticipant\n\t};\n\n\texport type channelAdminLogEventActionParticipantUnmute = {\n\t\t_: 'channelAdminLogEventActionParticipantUnmute',\n\t\tparticipant: GroupCallParticipant\n\t};\n\n\texport type channelAdminLogEventActionToggleGroupCallSetting = {\n\t\t_: 'channelAdminLogEventActionToggleGroupCallSetting',\n\t\tjoin_muted: boolean\n\t};\n\n\texport type channelAdminLogEventActionParticipantJoinByInvite = {\n\t\t_: 'channelAdminLogEventActionParticipantJoinByInvite',\n\t\tinvite: ExportedChatInvite\n\t};\n\n\texport type channelAdminLogEventActionExportedInviteDelete = {\n\t\t_: 'channelAdminLogEventActionExportedInviteDelete',\n\t\tinvite: ExportedChatInvite\n\t};\n\n\texport type channelAdminLogEventActionExportedInviteRevoke = {\n\t\t_: 'channelAdminLogEventActionExportedInviteRevoke',\n\t\tinvite: ExportedChatInvite\n\t};\n\n\texport type channelAdminLogEventActionExportedInviteEdit = {\n\t\t_: 'channelAdminLogEventActionExportedInviteEdit',\n\t\tprev_invite: ExportedChatInvite,\n\t\tnew_invite: ExportedChatInvite\n\t};\n\n\texport type channelAdminLogEventActionParticipantVolume = {\n\t\t_: 'channelAdminLogEventActionParticipantVolume',\n\t\tparticipant: GroupCallParticipant\n\t};\n\n\texport type channelAdminLogEventActionChangeHistoryTTL = {\n\t\t_: 'channelAdminLogEventActionChangeHistoryTTL',\n\t\tprev_value: number,\n\t\tnew_value: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChannelAdminLogEvent\n */\nexport type ChannelAdminLogEvent = ChannelAdminLogEvent.channelAdminLogEvent;\n\nexport namespace ChannelAdminLogEvent {\n  export type channelAdminLogEvent = {\n\t\t_: 'channelAdminLogEvent',\n\t\tid: string,\n\t\tdate: number,\n\t\tuser_id: number,\n\t\taction: ChannelAdminLogEventAction\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/channels.AdminLogResults\n */\nexport type ChannelsAdminLogResults = ChannelsAdminLogResults.channelsAdminLogResults;\n\nexport namespace ChannelsAdminLogResults {\n  export type channelsAdminLogResults = {\n\t\t_: 'channels.adminLogResults',\n\t\tevents: Array<ChannelAdminLogEvent>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChannelAdminLogEventsFilter\n */\nexport type ChannelAdminLogEventsFilter = ChannelAdminLogEventsFilter.channelAdminLogEventsFilter;\n\nexport namespace ChannelAdminLogEventsFilter {\n  export type channelAdminLogEventsFilter = {\n\t\t_: 'channelAdminLogEventsFilter',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tjoin?: true,\n\t\t\tleave?: true,\n\t\t\tinvite?: true,\n\t\t\tban?: true,\n\t\t\tunban?: true,\n\t\t\tkick?: true,\n\t\t\tunkick?: true,\n\t\t\tpromote?: true,\n\t\t\tdemote?: true,\n\t\t\tinfo?: true,\n\t\t\tsettings?: true,\n\t\t\tpinned?: true,\n\t\t\tedit?: true,\n\t\t\tdelete?: true,\n\t\t\tgroup_call?: true,\n\t\t\tinvites?: true,\n\t\t}>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PopularContact\n */\nexport type PopularContact = PopularContact.popularContact;\n\nexport namespace PopularContact {\n  export type popularContact = {\n\t\t_: 'popularContact',\n\t\tclient_id: string,\n\t\timporters: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.FavedStickers\n */\nexport type MessagesFavedStickers = MessagesFavedStickers.messagesFavedStickersNotModified | MessagesFavedStickers.messagesFavedStickers;\n\nexport namespace MessagesFavedStickers {\n  export type messagesFavedStickersNotModified = {\n\t\t_: 'messages.favedStickersNotModified'\n\t};\n\n\texport type messagesFavedStickers = {\n\t\t_: 'messages.favedStickers',\n\t\thash: number,\n\t\tpacks: Array<StickerPack>,\n\t\tstickers: Array<Document>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/RecentMeUrl\n */\nexport type RecentMeUrl = RecentMeUrl.recentMeUrlUnknown | RecentMeUrl.recentMeUrlUser | RecentMeUrl.recentMeUrlChat | RecentMeUrl.recentMeUrlChatInvite | RecentMeUrl.recentMeUrlStickerSet;\n\nexport namespace RecentMeUrl {\n  export type recentMeUrlUnknown = {\n\t\t_: 'recentMeUrlUnknown',\n\t\turl: string\n\t};\n\n\texport type recentMeUrlUser = {\n\t\t_: 'recentMeUrlUser',\n\t\turl: string,\n\t\tuser_id: number\n\t};\n\n\texport type recentMeUrlChat = {\n\t\t_: 'recentMeUrlChat',\n\t\turl: string,\n\t\tchat_id: number\n\t};\n\n\texport type recentMeUrlChatInvite = {\n\t\t_: 'recentMeUrlChatInvite',\n\t\turl: string,\n\t\tchat_invite: ChatInvite\n\t};\n\n\texport type recentMeUrlStickerSet = {\n\t\t_: 'recentMeUrlStickerSet',\n\t\turl: string,\n\t\tset: StickerSetCovered\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.RecentMeUrls\n */\nexport type HelpRecentMeUrls = HelpRecentMeUrls.helpRecentMeUrls;\n\nexport namespace HelpRecentMeUrls {\n  export type helpRecentMeUrls = {\n\t\t_: 'help.recentMeUrls',\n\t\turls: Array<RecentMeUrl>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputSingleMedia\n */\nexport type InputSingleMedia = InputSingleMedia.inputSingleMedia;\n\nexport namespace InputSingleMedia {\n  export type inputSingleMedia = {\n\t\t_: 'inputSingleMedia',\n\t\tflags?: number,\n\t\tmedia: InputMedia,\n\t\trandom_id: string,\n\t\tmessage: string,\n\t\tentities?: Array<MessageEntity>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/WebAuthorization\n */\nexport type WebAuthorization = WebAuthorization.webAuthorization;\n\nexport namespace WebAuthorization {\n  export type webAuthorization = {\n\t\t_: 'webAuthorization',\n\t\thash: string,\n\t\tbot_id: number,\n\t\tdomain: string,\n\t\tbrowser: string,\n\t\tplatform: string,\n\t\tdate_created: number,\n\t\tdate_active: number,\n\t\tip: string,\n\t\tregion: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.WebAuthorizations\n */\nexport type AccountWebAuthorizations = AccountWebAuthorizations.accountWebAuthorizations;\n\nexport namespace AccountWebAuthorizations {\n  export type accountWebAuthorizations = {\n\t\t_: 'account.webAuthorizations',\n\t\tauthorizations: Array<WebAuthorization>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputMessage\n */\nexport type InputMessage = InputMessage.inputMessageID | InputMessage.inputMessageReplyTo | InputMessage.inputMessagePinned | InputMessage.inputMessageCallbackQuery;\n\nexport namespace InputMessage {\n  export type inputMessageID = {\n\t\t_: 'inputMessageID',\n\t\tid: number\n\t};\n\n\texport type inputMessageReplyTo = {\n\t\t_: 'inputMessageReplyTo',\n\t\tid: number\n\t};\n\n\texport type inputMessagePinned = {\n\t\t_: 'inputMessagePinned'\n\t};\n\n\texport type inputMessageCallbackQuery = {\n\t\t_: 'inputMessageCallbackQuery',\n\t\tid: number,\n\t\tquery_id: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputDialogPeer\n */\nexport type InputDialogPeer = InputDialogPeer.inputDialogPeer | InputDialogPeer.inputDialogPeerFolder;\n\nexport namespace InputDialogPeer {\n  export type inputDialogPeer = {\n\t\t_: 'inputDialogPeer',\n\t\tpeer: InputPeer\n\t};\n\n\texport type inputDialogPeerFolder = {\n\t\t_: 'inputDialogPeerFolder',\n\t\tfolder_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/DialogPeer\n */\nexport type DialogPeer = DialogPeer.dialogPeer | DialogPeer.dialogPeerFolder;\n\nexport namespace DialogPeer {\n  export type dialogPeer = {\n\t\t_: 'dialogPeer',\n\t\tpeer: Peer\n\t};\n\n\texport type dialogPeerFolder = {\n\t\t_: 'dialogPeerFolder',\n\t\tfolder_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.FoundStickerSets\n */\nexport type MessagesFoundStickerSets = MessagesFoundStickerSets.messagesFoundStickerSetsNotModified | MessagesFoundStickerSets.messagesFoundStickerSets;\n\nexport namespace MessagesFoundStickerSets {\n  export type messagesFoundStickerSetsNotModified = {\n\t\t_: 'messages.foundStickerSetsNotModified'\n\t};\n\n\texport type messagesFoundStickerSets = {\n\t\t_: 'messages.foundStickerSets',\n\t\thash: number,\n\t\tsets: Array<StickerSetCovered>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/FileHash\n */\nexport type FileHash = FileHash.fileHash;\n\nexport namespace FileHash {\n  export type fileHash = {\n\t\t_: 'fileHash',\n\t\toffset: number,\n\t\tlimit: number,\n\t\thash: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputClientProxy\n */\nexport type InputClientProxy = InputClientProxy.inputClientProxy;\n\nexport namespace InputClientProxy {\n  export type inputClientProxy = {\n\t\t_: 'inputClientProxy',\n\t\taddress: string,\n\t\tport: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.TermsOfServiceUpdate\n */\nexport type HelpTermsOfServiceUpdate = HelpTermsOfServiceUpdate.helpTermsOfServiceUpdateEmpty | HelpTermsOfServiceUpdate.helpTermsOfServiceUpdate;\n\nexport namespace HelpTermsOfServiceUpdate {\n  export type helpTermsOfServiceUpdateEmpty = {\n\t\t_: 'help.termsOfServiceUpdateEmpty',\n\t\texpires: number\n\t};\n\n\texport type helpTermsOfServiceUpdate = {\n\t\t_: 'help.termsOfServiceUpdate',\n\t\texpires: number,\n\t\tterms_of_service: HelpTermsOfService\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputSecureFile\n */\nexport type InputSecureFile = InputSecureFile.inputSecureFileUploaded | InputSecureFile.inputSecureFile;\n\nexport namespace InputSecureFile {\n  export type inputSecureFileUploaded = {\n\t\t_: 'inputSecureFileUploaded',\n\t\tid: string,\n\t\tparts: number,\n\t\tmd5_checksum: string,\n\t\tfile_hash: Uint8Array,\n\t\tsecret: Uint8Array\n\t};\n\n\texport type inputSecureFile = {\n\t\t_: 'inputSecureFile',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureFile\n */\nexport type SecureFile = SecureFile.secureFileEmpty | SecureFile.secureFile;\n\nexport namespace SecureFile {\n  export type secureFileEmpty = {\n\t\t_: 'secureFileEmpty'\n\t};\n\n\texport type secureFile = {\n\t\t_: 'secureFile',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tsize: number,\n\t\tdc_id: number,\n\t\tdate: number,\n\t\tfile_hash: Uint8Array,\n\t\tsecret: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureData\n */\nexport type SecureData = SecureData.secureData;\n\nexport namespace SecureData {\n  export type secureData = {\n\t\t_: 'secureData',\n\t\tdata: Uint8Array,\n\t\tdata_hash: Uint8Array,\n\t\tsecret: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecurePlainData\n */\nexport type SecurePlainData = SecurePlainData.securePlainPhone | SecurePlainData.securePlainEmail;\n\nexport namespace SecurePlainData {\n  export type securePlainPhone = {\n\t\t_: 'securePlainPhone',\n\t\tphone: string\n\t};\n\n\texport type securePlainEmail = {\n\t\t_: 'securePlainEmail',\n\t\temail: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureValueType\n */\nexport type SecureValueType = SecureValueType.secureValueTypePersonalDetails | SecureValueType.secureValueTypePassport | SecureValueType.secureValueTypeDriverLicense | SecureValueType.secureValueTypeIdentityCard | SecureValueType.secureValueTypeInternalPassport | SecureValueType.secureValueTypeAddress | SecureValueType.secureValueTypeUtilityBill | SecureValueType.secureValueTypeBankStatement | SecureValueType.secureValueTypeRentalAgreement | SecureValueType.secureValueTypePassportRegistration | SecureValueType.secureValueTypeTemporaryRegistration | SecureValueType.secureValueTypePhone | SecureValueType.secureValueTypeEmail;\n\nexport namespace SecureValueType {\n  export type secureValueTypePersonalDetails = {\n\t\t_: 'secureValueTypePersonalDetails'\n\t};\n\n\texport type secureValueTypePassport = {\n\t\t_: 'secureValueTypePassport'\n\t};\n\n\texport type secureValueTypeDriverLicense = {\n\t\t_: 'secureValueTypeDriverLicense'\n\t};\n\n\texport type secureValueTypeIdentityCard = {\n\t\t_: 'secureValueTypeIdentityCard'\n\t};\n\n\texport type secureValueTypeInternalPassport = {\n\t\t_: 'secureValueTypeInternalPassport'\n\t};\n\n\texport type secureValueTypeAddress = {\n\t\t_: 'secureValueTypeAddress'\n\t};\n\n\texport type secureValueTypeUtilityBill = {\n\t\t_: 'secureValueTypeUtilityBill'\n\t};\n\n\texport type secureValueTypeBankStatement = {\n\t\t_: 'secureValueTypeBankStatement'\n\t};\n\n\texport type secureValueTypeRentalAgreement = {\n\t\t_: 'secureValueTypeRentalAgreement'\n\t};\n\n\texport type secureValueTypePassportRegistration = {\n\t\t_: 'secureValueTypePassportRegistration'\n\t};\n\n\texport type secureValueTypeTemporaryRegistration = {\n\t\t_: 'secureValueTypeTemporaryRegistration'\n\t};\n\n\texport type secureValueTypePhone = {\n\t\t_: 'secureValueTypePhone'\n\t};\n\n\texport type secureValueTypeEmail = {\n\t\t_: 'secureValueTypeEmail'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureValue\n */\nexport type SecureValue = SecureValue.secureValue;\n\nexport namespace SecureValue {\n  export type secureValue = {\n\t\t_: 'secureValue',\n\t\tflags?: number,\n\t\ttype: SecureValueType,\n\t\tdata?: SecureData,\n\t\tfront_side?: SecureFile,\n\t\treverse_side?: SecureFile,\n\t\tselfie?: SecureFile,\n\t\ttranslation?: Array<SecureFile>,\n\t\tfiles?: Array<SecureFile>,\n\t\tplain_data?: SecurePlainData,\n\t\thash: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputSecureValue\n */\nexport type InputSecureValue = InputSecureValue.inputSecureValue;\n\nexport namespace InputSecureValue {\n  export type inputSecureValue = {\n\t\t_: 'inputSecureValue',\n\t\tflags?: number,\n\t\ttype: SecureValueType,\n\t\tdata?: SecureData,\n\t\tfront_side?: InputSecureFile,\n\t\treverse_side?: InputSecureFile,\n\t\tselfie?: InputSecureFile,\n\t\ttranslation?: Array<InputSecureFile>,\n\t\tfiles?: Array<InputSecureFile>,\n\t\tplain_data?: SecurePlainData\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureValueHash\n */\nexport type SecureValueHash = SecureValueHash.secureValueHash;\n\nexport namespace SecureValueHash {\n  export type secureValueHash = {\n\t\t_: 'secureValueHash',\n\t\ttype: SecureValueType,\n\t\thash: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureValueError\n */\nexport type SecureValueError = SecureValueError.secureValueErrorData | SecureValueError.secureValueErrorFrontSide | SecureValueError.secureValueErrorReverseSide | SecureValueError.secureValueErrorSelfie | SecureValueError.secureValueErrorFile | SecureValueError.secureValueErrorFiles | SecureValueError.secureValueError | SecureValueError.secureValueErrorTranslationFile | SecureValueError.secureValueErrorTranslationFiles;\n\nexport namespace SecureValueError {\n  export type secureValueErrorData = {\n\t\t_: 'secureValueErrorData',\n\t\ttype: SecureValueType,\n\t\tdata_hash: Uint8Array,\n\t\tfield: string,\n\t\ttext: string\n\t};\n\n\texport type secureValueErrorFrontSide = {\n\t\t_: 'secureValueErrorFrontSide',\n\t\ttype: SecureValueType,\n\t\tfile_hash: Uint8Array,\n\t\ttext: string\n\t};\n\n\texport type secureValueErrorReverseSide = {\n\t\t_: 'secureValueErrorReverseSide',\n\t\ttype: SecureValueType,\n\t\tfile_hash: Uint8Array,\n\t\ttext: string\n\t};\n\n\texport type secureValueErrorSelfie = {\n\t\t_: 'secureValueErrorSelfie',\n\t\ttype: SecureValueType,\n\t\tfile_hash: Uint8Array,\n\t\ttext: string\n\t};\n\n\texport type secureValueErrorFile = {\n\t\t_: 'secureValueErrorFile',\n\t\ttype: SecureValueType,\n\t\tfile_hash: Uint8Array,\n\t\ttext: string\n\t};\n\n\texport type secureValueErrorFiles = {\n\t\t_: 'secureValueErrorFiles',\n\t\ttype: SecureValueType,\n\t\tfile_hash: Array<Uint8Array>,\n\t\ttext: string\n\t};\n\n\texport type secureValueError = {\n\t\t_: 'secureValueError',\n\t\ttype: SecureValueType,\n\t\thash: Uint8Array,\n\t\ttext: string\n\t};\n\n\texport type secureValueErrorTranslationFile = {\n\t\t_: 'secureValueErrorTranslationFile',\n\t\ttype: SecureValueType,\n\t\tfile_hash: Uint8Array,\n\t\ttext: string\n\t};\n\n\texport type secureValueErrorTranslationFiles = {\n\t\t_: 'secureValueErrorTranslationFiles',\n\t\ttype: SecureValueType,\n\t\tfile_hash: Array<Uint8Array>,\n\t\ttext: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureCredentialsEncrypted\n */\nexport type SecureCredentialsEncrypted = SecureCredentialsEncrypted.secureCredentialsEncrypted;\n\nexport namespace SecureCredentialsEncrypted {\n  export type secureCredentialsEncrypted = {\n\t\t_: 'secureCredentialsEncrypted',\n\t\tdata: Uint8Array,\n\t\thash: Uint8Array,\n\t\tsecret: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.AuthorizationForm\n */\nexport type AccountAuthorizationForm = AccountAuthorizationForm.accountAuthorizationForm;\n\nexport namespace AccountAuthorizationForm {\n  export type accountAuthorizationForm = {\n\t\t_: 'account.authorizationForm',\n\t\tflags?: number,\n\t\trequired_types: Array<SecureRequiredType>,\n\t\tvalues: Array<SecureValue>,\n\t\terrors: Array<SecureValueError>,\n\t\tusers: Array<User>,\n\t\tprivacy_policy_url?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.SentEmailCode\n */\nexport type AccountSentEmailCode = AccountSentEmailCode.accountSentEmailCode;\n\nexport namespace AccountSentEmailCode {\n  export type accountSentEmailCode = {\n\t\t_: 'account.sentEmailCode',\n\t\temail_pattern: string,\n\t\tlength: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.DeepLinkInfo\n */\nexport type HelpDeepLinkInfo = HelpDeepLinkInfo.helpDeepLinkInfoEmpty | HelpDeepLinkInfo.helpDeepLinkInfo;\n\nexport namespace HelpDeepLinkInfo {\n  export type helpDeepLinkInfoEmpty = {\n\t\t_: 'help.deepLinkInfoEmpty'\n\t};\n\n\texport type helpDeepLinkInfo = {\n\t\t_: 'help.deepLinkInfo',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tupdate_app?: true,\n\t\t}>,\n\t\tmessage: string,\n\t\tentities?: Array<MessageEntity>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SavedContact\n */\nexport type SavedContact = SavedContact.savedPhoneContact;\n\nexport namespace SavedContact {\n  export type savedPhoneContact = {\n\t\t_: 'savedPhoneContact',\n\t\tphone: string,\n\t\tfirst_name: string,\n\t\tlast_name: string,\n\t\tdate: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.Takeout\n */\nexport type AccountTakeout = AccountTakeout.accountTakeout;\n\nexport namespace AccountTakeout {\n  export type accountTakeout = {\n\t\t_: 'account.takeout',\n\t\tid: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PasswordKdfAlgo\n */\nexport type PasswordKdfAlgo = PasswordKdfAlgo.passwordKdfAlgoUnknown | PasswordKdfAlgo.passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow;\n\nexport namespace PasswordKdfAlgo {\n  export type passwordKdfAlgoUnknown = {\n\t\t_: 'passwordKdfAlgoUnknown'\n\t};\n\n\texport type passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow = {\n\t\t_: 'passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow',\n\t\tsalt1: Uint8Array,\n\t\tsalt2: Uint8Array,\n\t\tg: number,\n\t\tp: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecurePasswordKdfAlgo\n */\nexport type SecurePasswordKdfAlgo = SecurePasswordKdfAlgo.securePasswordKdfAlgoUnknown | SecurePasswordKdfAlgo.securePasswordKdfAlgoPBKDF2HMACSHA512iter100000 | SecurePasswordKdfAlgo.securePasswordKdfAlgoSHA512;\n\nexport namespace SecurePasswordKdfAlgo {\n  export type securePasswordKdfAlgoUnknown = {\n\t\t_: 'securePasswordKdfAlgoUnknown'\n\t};\n\n\texport type securePasswordKdfAlgoPBKDF2HMACSHA512iter100000 = {\n\t\t_: 'securePasswordKdfAlgoPBKDF2HMACSHA512iter100000',\n\t\tsalt: Uint8Array\n\t};\n\n\texport type securePasswordKdfAlgoSHA512 = {\n\t\t_: 'securePasswordKdfAlgoSHA512',\n\t\tsalt: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureSecretSettings\n */\nexport type SecureSecretSettings = SecureSecretSettings.secureSecretSettings;\n\nexport namespace SecureSecretSettings {\n  export type secureSecretSettings = {\n\t\t_: 'secureSecretSettings',\n\t\tsecure_algo: SecurePasswordKdfAlgo,\n\t\tsecure_secret: Uint8Array,\n\t\tsecure_secret_id: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputCheckPasswordSRP\n */\nexport type InputCheckPasswordSRP = InputCheckPasswordSRP.inputCheckPasswordEmpty | InputCheckPasswordSRP.inputCheckPasswordSRP;\n\nexport namespace InputCheckPasswordSRP {\n  export type inputCheckPasswordEmpty = {\n\t\t_: 'inputCheckPasswordEmpty'\n\t};\n\n\texport type inputCheckPasswordSRP = {\n\t\t_: 'inputCheckPasswordSRP',\n\t\tsrp_id: string,\n\t\tA: Uint8Array,\n\t\tM1: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/SecureRequiredType\n */\nexport type SecureRequiredType = SecureRequiredType.secureRequiredType | SecureRequiredType.secureRequiredTypeOneOf;\n\nexport namespace SecureRequiredType {\n  export type secureRequiredType = {\n\t\t_: 'secureRequiredType',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tnative_names?: true,\n\t\t\tselfie_required?: true,\n\t\t\ttranslation_required?: true,\n\t\t}>,\n\t\ttype: SecureValueType\n\t};\n\n\texport type secureRequiredTypeOneOf = {\n\t\t_: 'secureRequiredTypeOneOf',\n\t\ttypes: Array<SecureRequiredType>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.PassportConfig\n */\nexport type HelpPassportConfig = HelpPassportConfig.helpPassportConfigNotModified | HelpPassportConfig.helpPassportConfig;\n\nexport namespace HelpPassportConfig {\n  export type helpPassportConfigNotModified = {\n\t\t_: 'help.passportConfigNotModified'\n\t};\n\n\texport type helpPassportConfig = {\n\t\t_: 'help.passportConfig',\n\t\thash: number,\n\t\tcountries_langs: DataJSON\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputAppEvent\n */\nexport type InputAppEvent = InputAppEvent.inputAppEvent;\n\nexport namespace InputAppEvent {\n  export type inputAppEvent = {\n\t\t_: 'inputAppEvent',\n\t\ttime: number,\n\t\ttype: string,\n\t\tpeer: string,\n\t\tdata: JSONValue\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/JSONObjectValue\n */\nexport type JSONObjectValue = JSONObjectValue.jsonObjectValue;\n\nexport namespace JSONObjectValue {\n  export type jsonObjectValue = {\n\t\t_: 'jsonObjectValue',\n\t\tkey: string,\n\t\tvalue: JSONValue\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/JSONValue\n */\nexport type JSONValue = JSONValue.jsonNull | JSONValue.jsonBool | JSONValue.jsonNumber | JSONValue.jsonString | JSONValue.jsonArray | JSONValue.jsonObject;\n\nexport namespace JSONValue {\n  export type jsonNull = {\n\t\t_: 'jsonNull'\n\t};\n\n\texport type jsonBool = {\n\t\t_: 'jsonBool',\n\t\tvalue: boolean\n\t};\n\n\texport type jsonNumber = {\n\t\t_: 'jsonNumber',\n\t\tvalue: number\n\t};\n\n\texport type jsonString = {\n\t\t_: 'jsonString',\n\t\tvalue: string\n\t};\n\n\texport type jsonArray = {\n\t\t_: 'jsonArray',\n\t\tvalue: Array<JSONValue>\n\t};\n\n\texport type jsonObject = {\n\t\t_: 'jsonObject',\n\t\tvalue: Array<JSONObjectValue>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PageTableCell\n */\nexport type PageTableCell = PageTableCell.pageTableCell;\n\nexport namespace PageTableCell {\n  export type pageTableCell = {\n\t\t_: 'pageTableCell',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\theader?: true,\n\t\t\talign_center?: true,\n\t\t\talign_right?: true,\n\t\t\tvalign_middle?: true,\n\t\t\tvalign_bottom?: true,\n\t\t}>,\n\t\ttext?: RichText,\n\t\tcolspan?: number,\n\t\trowspan?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PageTableRow\n */\nexport type PageTableRow = PageTableRow.pageTableRow;\n\nexport namespace PageTableRow {\n  export type pageTableRow = {\n\t\t_: 'pageTableRow',\n\t\tcells: Array<PageTableCell>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PageCaption\n */\nexport type PageCaption = PageCaption.pageCaption;\n\nexport namespace PageCaption {\n  export type pageCaption = {\n\t\t_: 'pageCaption',\n\t\ttext: RichText,\n\t\tcredit: RichText\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PageListItem\n */\nexport type PageListItem = PageListItem.pageListItemText | PageListItem.pageListItemBlocks;\n\nexport namespace PageListItem {\n  export type pageListItemText = {\n\t\t_: 'pageListItemText',\n\t\ttext: RichText\n\t};\n\n\texport type pageListItemBlocks = {\n\t\t_: 'pageListItemBlocks',\n\t\tblocks: Array<PageBlock>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PageListOrderedItem\n */\nexport type PageListOrderedItem = PageListOrderedItem.pageListOrderedItemText | PageListOrderedItem.pageListOrderedItemBlocks;\n\nexport namespace PageListOrderedItem {\n  export type pageListOrderedItemText = {\n\t\t_: 'pageListOrderedItemText',\n\t\tnum: string,\n\t\ttext: RichText\n\t};\n\n\texport type pageListOrderedItemBlocks = {\n\t\t_: 'pageListOrderedItemBlocks',\n\t\tnum: string,\n\t\tblocks: Array<PageBlock>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PageRelatedArticle\n */\nexport type PageRelatedArticle = PageRelatedArticle.pageRelatedArticle;\n\nexport namespace PageRelatedArticle {\n  export type pageRelatedArticle = {\n\t\t_: 'pageRelatedArticle',\n\t\tflags?: number,\n\t\turl: string,\n\t\twebpage_id: string,\n\t\ttitle?: string,\n\t\tdescription?: string,\n\t\tphoto_id?: string,\n\t\tauthor?: string,\n\t\tpublished_date?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Page\n */\nexport type Page = Page.page;\n\nexport namespace Page {\n  export type page = {\n\t\t_: 'page',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpart?: true,\n\t\t\trtl?: true,\n\t\t\tv2?: true,\n\t\t}>,\n\t\turl: string,\n\t\tblocks: Array<PageBlock>,\n\t\tphotos: Array<Photo>,\n\t\tdocuments: Array<Document>,\n\t\tviews?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.SupportName\n */\nexport type HelpSupportName = HelpSupportName.helpSupportName;\n\nexport namespace HelpSupportName {\n  export type helpSupportName = {\n\t\t_: 'help.supportName',\n\t\tname: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.UserInfo\n */\nexport type HelpUserInfo = HelpUserInfo.helpUserInfoEmpty | HelpUserInfo.helpUserInfo;\n\nexport namespace HelpUserInfo {\n  export type helpUserInfoEmpty = {\n\t\t_: 'help.userInfoEmpty'\n\t};\n\n\texport type helpUserInfo = {\n\t\t_: 'help.userInfo',\n\t\tmessage: string,\n\t\tentities: Array<MessageEntity>,\n\t\tauthor: string,\n\t\tdate: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PollAnswer\n */\nexport type PollAnswer = PollAnswer.pollAnswer;\n\nexport namespace PollAnswer {\n  export type pollAnswer = {\n\t\t_: 'pollAnswer',\n\t\ttext: string,\n\t\toption: Uint8Array\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Poll\n */\nexport type Poll = Poll.poll;\n\nexport namespace Poll {\n  export type poll = {\n\t\t_: 'poll',\n\t\tid: string,\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tclosed?: true,\n\t\t\tpublic_voters?: true,\n\t\t\tmultiple_choice?: true,\n\t\t\tquiz?: true,\n\t\t}>,\n\t\tquestion: string,\n\t\tanswers: Array<PollAnswer>,\n\t\tclose_period?: number,\n\t\tclose_date?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PollAnswerVoters\n */\nexport type PollAnswerVoters = PollAnswerVoters.pollAnswerVoters;\n\nexport namespace PollAnswerVoters {\n  export type pollAnswerVoters = {\n\t\t_: 'pollAnswerVoters',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tchosen?: true,\n\t\t\tcorrect?: true,\n\t\t}>,\n\t\toption: Uint8Array,\n\t\tvoters: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PollResults\n */\nexport type PollResults = PollResults.pollResults;\n\nexport namespace PollResults {\n  export type pollResults = {\n\t\t_: 'pollResults',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tmin?: true,\n\t\t}>,\n\t\tresults?: Array<PollAnswerVoters>,\n\t\ttotal_voters?: number,\n\t\trecent_voters?: Array<number>,\n\t\tsolution?: string,\n\t\tsolution_entities?: Array<MessageEntity>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatOnlines\n */\nexport type ChatOnlines = ChatOnlines.chatOnlines;\n\nexport namespace ChatOnlines {\n  export type chatOnlines = {\n\t\t_: 'chatOnlines',\n\t\tonlines: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsURL\n */\nexport type StatsURL = StatsURL.statsURL;\n\nexport namespace StatsURL {\n  export type statsURL = {\n\t\t_: 'statsURL',\n\t\turl: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatAdminRights\n */\nexport type ChatAdminRights = ChatAdminRights.chatAdminRights;\n\nexport namespace ChatAdminRights {\n  export type chatAdminRights = {\n\t\t_: 'chatAdminRights',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tchange_info?: true,\n\t\t\tpost_messages?: true,\n\t\t\tedit_messages?: true,\n\t\t\tdelete_messages?: true,\n\t\t\tban_users?: true,\n\t\t\tinvite_users?: true,\n\t\t\tpin_messages?: true,\n\t\t\tadd_admins?: true,\n\t\t\tanonymous?: true,\n\t\t\tmanage_call?: true,\n\t\t\tother?: true,\n\t\t}>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatBannedRights\n */\nexport type ChatBannedRights = ChatBannedRights.chatBannedRights;\n\nexport namespace ChatBannedRights {\n  export type chatBannedRights = {\n\t\t_: 'chatBannedRights',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tview_messages?: true,\n\t\t\tsend_messages?: true,\n\t\t\tsend_media?: true,\n\t\t\tsend_stickers?: true,\n\t\t\tsend_gifs?: true,\n\t\t\tsend_games?: true,\n\t\t\tsend_inline?: true,\n\t\t\tembed_links?: true,\n\t\t\tsend_polls?: true,\n\t\t\tchange_info?: true,\n\t\t\tinvite_users?: true,\n\t\t\tpin_messages?: true,\n\t\t}>,\n\t\tuntil_date: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputWallPaper\n */\nexport type InputWallPaper = InputWallPaper.inputWallPaper | InputWallPaper.inputWallPaperSlug | InputWallPaper.inputWallPaperNoFile;\n\nexport namespace InputWallPaper {\n  export type inputWallPaper = {\n\t\t_: 'inputWallPaper',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputWallPaperSlug = {\n\t\t_: 'inputWallPaperSlug',\n\t\tslug: string\n\t};\n\n\texport type inputWallPaperNoFile = {\n\t\t_: 'inputWallPaperNoFile',\n\t\tid: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.WallPapers\n */\nexport type AccountWallPapers = AccountWallPapers.accountWallPapersNotModified | AccountWallPapers.accountWallPapers;\n\nexport namespace AccountWallPapers {\n  export type accountWallPapersNotModified = {\n\t\t_: 'account.wallPapersNotModified'\n\t};\n\n\texport type accountWallPapers = {\n\t\t_: 'account.wallPapers',\n\t\thash: number,\n\t\twallpapers: Array<WallPaper>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/CodeSettings\n */\nexport type CodeSettings = CodeSettings.codeSettings;\n\nexport namespace CodeSettings {\n  export type codeSettings = {\n\t\t_: 'codeSettings',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tallow_flashcall?: true,\n\t\t\tcurrent_number?: true,\n\t\t\tallow_app_hash?: true,\n\t\t}>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/WallPaperSettings\n */\nexport type WallPaperSettings = WallPaperSettings.wallPaperSettings;\n\nexport namespace WallPaperSettings {\n  export type wallPaperSettings = {\n\t\t_: 'wallPaperSettings',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tblur?: true,\n\t\t\tmotion?: true,\n\t\t}>,\n\t\tbackground_color?: number,\n\t\tsecond_background_color?: number,\n\t\tthird_background_color?: number,\n\t\tfourth_background_color?: number,\n\t\tintensity?: number,\n\t\trotation?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/AutoDownloadSettings\n */\nexport type AutoDownloadSettings = AutoDownloadSettings.autoDownloadSettings;\n\nexport namespace AutoDownloadSettings {\n  export type autoDownloadSettings = {\n\t\t_: 'autoDownloadSettings',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tdisabled?: true,\n\t\t\tvideo_preload_large?: true,\n\t\t\taudio_preload_next?: true,\n\t\t\tphonecalls_less_data?: true,\n\t\t}>,\n\t\tphoto_size_max: number,\n\t\tvideo_size_max: number,\n\t\tfile_size_max: number,\n\t\tvideo_upload_maxbitrate: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.AutoDownloadSettings\n */\nexport type AccountAutoDownloadSettings = AccountAutoDownloadSettings.accountAutoDownloadSettings;\n\nexport namespace AccountAutoDownloadSettings {\n  export type accountAutoDownloadSettings = {\n\t\t_: 'account.autoDownloadSettings',\n\t\tlow: AutoDownloadSettings,\n\t\tmedium: AutoDownloadSettings,\n\t\thigh: AutoDownloadSettings\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/EmojiKeyword\n */\nexport type EmojiKeyword = EmojiKeyword.emojiKeyword | EmojiKeyword.emojiKeywordDeleted;\n\nexport namespace EmojiKeyword {\n  export type emojiKeyword = {\n\t\t_: 'emojiKeyword',\n\t\tkeyword: string,\n\t\temoticons: Array<string>\n\t};\n\n\texport type emojiKeywordDeleted = {\n\t\t_: 'emojiKeywordDeleted',\n\t\tkeyword: string,\n\t\temoticons: Array<string>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/EmojiKeywordsDifference\n */\nexport type EmojiKeywordsDifference = EmojiKeywordsDifference.emojiKeywordsDifference;\n\nexport namespace EmojiKeywordsDifference {\n  export type emojiKeywordsDifference = {\n\t\t_: 'emojiKeywordsDifference',\n\t\tlang_code: string,\n\t\tfrom_version: number,\n\t\tversion: number,\n\t\tkeywords: Array<EmojiKeyword>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/EmojiURL\n */\nexport type EmojiURL = EmojiURL.emojiURL;\n\nexport namespace EmojiURL {\n  export type emojiURL = {\n\t\t_: 'emojiURL',\n\t\turl: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/EmojiLanguage\n */\nexport type EmojiLanguage = EmojiLanguage.emojiLanguage;\n\nexport namespace EmojiLanguage {\n  export type emojiLanguage = {\n\t\t_: 'emojiLanguage',\n\t\tlang_code: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Folder\n */\nexport type Folder = Folder.folder;\n\nexport namespace Folder {\n  export type folder = {\n\t\t_: 'folder',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tautofill_new_broadcasts?: true,\n\t\t\tautofill_public_groups?: true,\n\t\t\tautofill_new_correspondents?: true,\n\t\t}>,\n\t\tid: number,\n\t\ttitle: string,\n\t\tphoto?: ChatPhoto\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputFolderPeer\n */\nexport type InputFolderPeer = InputFolderPeer.inputFolderPeer;\n\nexport namespace InputFolderPeer {\n  export type inputFolderPeer = {\n\t\t_: 'inputFolderPeer',\n\t\tpeer: InputPeer,\n\t\tfolder_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/FolderPeer\n */\nexport type FolderPeer = FolderPeer.folderPeer;\n\nexport namespace FolderPeer {\n  export type folderPeer = {\n\t\t_: 'folderPeer',\n\t\tpeer: Peer,\n\t\tfolder_id: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.SearchCounter\n */\nexport type MessagesSearchCounter = MessagesSearchCounter.messagesSearchCounter;\n\nexport namespace MessagesSearchCounter {\n  export type messagesSearchCounter = {\n\t\t_: 'messages.searchCounter',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tinexact?: true,\n\t\t}>,\n\t\tfilter: MessagesFilter,\n\t\tcount: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/UrlAuthResult\n */\nexport type UrlAuthResult = UrlAuthResult.urlAuthResultRequest | UrlAuthResult.urlAuthResultAccepted | UrlAuthResult.urlAuthResultDefault;\n\nexport namespace UrlAuthResult {\n  export type urlAuthResultRequest = {\n\t\t_: 'urlAuthResultRequest',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\trequest_write_access?: true,\n\t\t}>,\n\t\tbot: User,\n\t\tdomain: string\n\t};\n\n\texport type urlAuthResultAccepted = {\n\t\t_: 'urlAuthResultAccepted',\n\t\turl: string\n\t};\n\n\texport type urlAuthResultDefault = {\n\t\t_: 'urlAuthResultDefault'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChannelLocation\n */\nexport type ChannelLocation = ChannelLocation.channelLocationEmpty | ChannelLocation.channelLocation;\n\nexport namespace ChannelLocation {\n  export type channelLocationEmpty = {\n\t\t_: 'channelLocationEmpty'\n\t};\n\n\texport type channelLocation = {\n\t\t_: 'channelLocation',\n\t\tgeo_point: GeoPoint,\n\t\taddress: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PeerLocated\n */\nexport type PeerLocated = PeerLocated.peerLocated | PeerLocated.peerSelfLocated;\n\nexport namespace PeerLocated {\n  export type peerLocated = {\n\t\t_: 'peerLocated',\n\t\tpeer: Peer,\n\t\texpires: number,\n\t\tdistance: number\n\t};\n\n\texport type peerSelfLocated = {\n\t\t_: 'peerSelfLocated',\n\t\texpires: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/RestrictionReason\n */\nexport type RestrictionReason = RestrictionReason.restrictionReason;\n\nexport namespace RestrictionReason {\n  export type restrictionReason = {\n\t\t_: 'restrictionReason',\n\t\tplatform: string,\n\t\treason: string,\n\t\ttext: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputTheme\n */\nexport type InputTheme = InputTheme.inputTheme | InputTheme.inputThemeSlug;\n\nexport namespace InputTheme {\n  export type inputTheme = {\n\t\t_: 'inputTheme',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n\n\texport type inputThemeSlug = {\n\t\t_: 'inputThemeSlug',\n\t\tslug: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/Theme\n */\nexport type Theme = Theme.theme;\n\nexport namespace Theme {\n  export type theme = {\n\t\t_: 'theme',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcreator?: true,\n\t\t\tdefault?: true,\n\t\t}>,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tslug: string,\n\t\ttitle: string,\n\t\tdocument?: Document,\n\t\tsettings?: ThemeSettings,\n\t\tinstalls_count: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.Themes\n */\nexport type AccountThemes = AccountThemes.accountThemesNotModified | AccountThemes.accountThemes;\n\nexport namespace AccountThemes {\n  export type accountThemesNotModified = {\n\t\t_: 'account.themesNotModified'\n\t};\n\n\texport type accountThemes = {\n\t\t_: 'account.themes',\n\t\thash: number,\n\t\tthemes: Array<Theme>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/auth.LoginToken\n */\nexport type AuthLoginToken = AuthLoginToken.authLoginToken | AuthLoginToken.authLoginTokenMigrateTo | AuthLoginToken.authLoginTokenSuccess;\n\nexport namespace AuthLoginToken {\n  export type authLoginToken = {\n\t\t_: 'auth.loginToken',\n\t\texpires: number,\n\t\ttoken: Uint8Array\n\t};\n\n\texport type authLoginTokenMigrateTo = {\n\t\t_: 'auth.loginTokenMigrateTo',\n\t\tdc_id: number,\n\t\ttoken: Uint8Array\n\t};\n\n\texport type authLoginTokenSuccess = {\n\t\t_: 'auth.loginTokenSuccess',\n\t\tauthorization: AuthAuthorization\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.ContentSettings\n */\nexport type AccountContentSettings = AccountContentSettings.accountContentSettings;\n\nexport namespace AccountContentSettings {\n  export type accountContentSettings = {\n\t\t_: 'account.contentSettings',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tsensitive_enabled?: true,\n\t\t\tsensitive_can_change?: true,\n\t\t}>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.InactiveChats\n */\nexport type MessagesInactiveChats = MessagesInactiveChats.messagesInactiveChats;\n\nexport namespace MessagesInactiveChats {\n  export type messagesInactiveChats = {\n\t\t_: 'messages.inactiveChats',\n\t\tdates: Array<number>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/BaseTheme\n */\nexport type BaseTheme = BaseTheme.baseThemeClassic | BaseTheme.baseThemeDay | BaseTheme.baseThemeNight | BaseTheme.baseThemeTinted | BaseTheme.baseThemeArctic;\n\nexport namespace BaseTheme {\n  export type baseThemeClassic = {\n\t\t_: 'baseThemeClassic'\n\t};\n\n\texport type baseThemeDay = {\n\t\t_: 'baseThemeDay'\n\t};\n\n\texport type baseThemeNight = {\n\t\t_: 'baseThemeNight'\n\t};\n\n\texport type baseThemeTinted = {\n\t\t_: 'baseThemeTinted'\n\t};\n\n\texport type baseThemeArctic = {\n\t\t_: 'baseThemeArctic'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputThemeSettings\n */\nexport type InputThemeSettings = InputThemeSettings.inputThemeSettings;\n\nexport namespace InputThemeSettings {\n  export type inputThemeSettings = {\n\t\t_: 'inputThemeSettings',\n\t\tflags?: number,\n\t\tbase_theme: BaseTheme,\n\t\taccent_color: number,\n\t\tmessage_top_color?: number,\n\t\tmessage_bottom_color?: number,\n\t\twallpaper?: InputWallPaper,\n\t\twallpaper_settings?: WallPaperSettings\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ThemeSettings\n */\nexport type ThemeSettings = ThemeSettings.themeSettings;\n\nexport namespace ThemeSettings {\n  export type themeSettings = {\n\t\t_: 'themeSettings',\n\t\tflags?: number,\n\t\tbase_theme: BaseTheme,\n\t\taccent_color: number,\n\t\tmessage_top_color?: number,\n\t\tmessage_bottom_color?: number,\n\t\twallpaper?: WallPaper\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/WebPageAttribute\n */\nexport type WebPageAttribute = WebPageAttribute.webPageAttributeTheme;\n\nexport namespace WebPageAttribute {\n  export type webPageAttributeTheme = {\n\t\t_: 'webPageAttributeTheme',\n\t\tflags?: number,\n\t\tdocuments?: Array<Document>,\n\t\tsettings?: ThemeSettings\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageUserVote\n */\nexport type MessageUserVote = MessageUserVote.messageUserVote | MessageUserVote.messageUserVoteInputOption | MessageUserVote.messageUserVoteMultiple;\n\nexport namespace MessageUserVote {\n  export type messageUserVote = {\n\t\t_: 'messageUserVote',\n\t\tuser_id: number,\n\t\toption: Uint8Array,\n\t\tdate: number\n\t};\n\n\texport type messageUserVoteInputOption = {\n\t\t_: 'messageUserVoteInputOption',\n\t\tuser_id: number,\n\t\tdate: number\n\t};\n\n\texport type messageUserVoteMultiple = {\n\t\t_: 'messageUserVoteMultiple',\n\t\tuser_id: number,\n\t\toptions: Array<Uint8Array>,\n\t\tdate: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.VotesList\n */\nexport type MessagesVotesList = MessagesVotesList.messagesVotesList;\n\nexport namespace MessagesVotesList {\n  export type messagesVotesList = {\n\t\t_: 'messages.votesList',\n\t\tflags?: number,\n\t\tcount: number,\n\t\tvotes: Array<MessageUserVote>,\n\t\tusers: Array<User>,\n\t\tnext_offset?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/BankCardOpenUrl\n */\nexport type BankCardOpenUrl = BankCardOpenUrl.bankCardOpenUrl;\n\nexport namespace BankCardOpenUrl {\n  export type bankCardOpenUrl = {\n\t\t_: 'bankCardOpenUrl',\n\t\turl: string,\n\t\tname: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/payments.BankCardData\n */\nexport type PaymentsBankCardData = PaymentsBankCardData.paymentsBankCardData;\n\nexport namespace PaymentsBankCardData {\n  export type paymentsBankCardData = {\n\t\t_: 'payments.bankCardData',\n\t\ttitle: string,\n\t\topen_urls: Array<BankCardOpenUrl>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/DialogFilter\n */\nexport type DialogFilter = DialogFilter.dialogFilter;\n\nexport namespace DialogFilter {\n  export type dialogFilter = {\n\t\t_: 'dialogFilter',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcontacts?: true,\n\t\t\tnon_contacts?: true,\n\t\t\tgroups?: true,\n\t\t\tbroadcasts?: true,\n\t\t\tbots?: true,\n\t\t\texclude_muted?: true,\n\t\t\texclude_read?: true,\n\t\t\texclude_archived?: true,\n\t\t}>,\n\t\tid: number,\n\t\ttitle: string,\n\t\temoticon?: string,\n\t\tpinned_peers: Array<InputPeer>,\n\t\tinclude_peers: Array<InputPeer>,\n\t\texclude_peers: Array<InputPeer>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/DialogFilterSuggested\n */\nexport type DialogFilterSuggested = DialogFilterSuggested.dialogFilterSuggested;\n\nexport namespace DialogFilterSuggested {\n  export type dialogFilterSuggested = {\n\t\t_: 'dialogFilterSuggested',\n\t\tfilter: DialogFilter,\n\t\tdescription: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsDateRangeDays\n */\nexport type StatsDateRangeDays = StatsDateRangeDays.statsDateRangeDays;\n\nexport namespace StatsDateRangeDays {\n  export type statsDateRangeDays = {\n\t\t_: 'statsDateRangeDays',\n\t\tmin_date: number,\n\t\tmax_date: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsAbsValueAndPrev\n */\nexport type StatsAbsValueAndPrev = StatsAbsValueAndPrev.statsAbsValueAndPrev;\n\nexport namespace StatsAbsValueAndPrev {\n  export type statsAbsValueAndPrev = {\n\t\t_: 'statsAbsValueAndPrev',\n\t\tcurrent: number,\n\t\tprevious: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsPercentValue\n */\nexport type StatsPercentValue = StatsPercentValue.statsPercentValue;\n\nexport namespace StatsPercentValue {\n  export type statsPercentValue = {\n\t\t_: 'statsPercentValue',\n\t\tpart: number,\n\t\ttotal: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsGraph\n */\nexport type StatsGraph = StatsGraph.statsGraphAsync | StatsGraph.statsGraphError | StatsGraph.statsGraph;\n\nexport namespace StatsGraph {\n  export type statsGraphAsync = {\n\t\t_: 'statsGraphAsync',\n\t\ttoken: string\n\t};\n\n\texport type statsGraphError = {\n\t\t_: 'statsGraphError',\n\t\terror: string\n\t};\n\n\texport type statsGraph = {\n\t\t_: 'statsGraph',\n\t\tflags?: number,\n\t\tjson: DataJSON,\n\t\tzoom_token?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageInteractionCounters\n */\nexport type MessageInteractionCounters = MessageInteractionCounters.messageInteractionCounters;\n\nexport namespace MessageInteractionCounters {\n  export type messageInteractionCounters = {\n\t\t_: 'messageInteractionCounters',\n\t\tmsg_id: number,\n\t\tviews: number,\n\t\tforwards: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/stats.BroadcastStats\n */\nexport type StatsBroadcastStats = StatsBroadcastStats.statsBroadcastStats;\n\nexport namespace StatsBroadcastStats {\n  export type statsBroadcastStats = {\n\t\t_: 'stats.broadcastStats',\n\t\tperiod: StatsDateRangeDays,\n\t\tfollowers: StatsAbsValueAndPrev,\n\t\tviews_per_post: StatsAbsValueAndPrev,\n\t\tshares_per_post: StatsAbsValueAndPrev,\n\t\tenabled_notifications: StatsPercentValue,\n\t\tgrowth_graph: StatsGraph,\n\t\tfollowers_graph: StatsGraph,\n\t\tmute_graph: StatsGraph,\n\t\ttop_hours_graph: StatsGraph,\n\t\tinteractions_graph: StatsGraph,\n\t\tiv_interactions_graph: StatsGraph,\n\t\tviews_by_source_graph: StatsGraph,\n\t\tnew_followers_by_source_graph: StatsGraph,\n\t\tlanguages_graph: StatsGraph,\n\t\trecent_message_interactions: Array<MessageInteractionCounters>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.PromoData\n */\nexport type HelpPromoData = HelpPromoData.helpPromoDataEmpty | HelpPromoData.helpPromoData;\n\nexport namespace HelpPromoData {\n  export type helpPromoDataEmpty = {\n\t\t_: 'help.promoDataEmpty',\n\t\texpires: number\n\t};\n\n\texport type helpPromoData = {\n\t\t_: 'help.promoData',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tproxy?: true,\n\t\t}>,\n\t\texpires: number,\n\t\tpeer: Peer,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>,\n\t\tpsa_type?: string,\n\t\tpsa_message?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/VideoSize\n */\nexport type VideoSize = VideoSize.videoSize;\n\nexport namespace VideoSize {\n  export type videoSize = {\n\t\t_: 'videoSize',\n\t\tflags?: number,\n\t\ttype: string,\n\t\tw: number,\n\t\th: number,\n\t\tsize: number,\n\t\tvideo_start_ts?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsGroupTopPoster\n */\nexport type StatsGroupTopPoster = StatsGroupTopPoster.statsGroupTopPoster;\n\nexport namespace StatsGroupTopPoster {\n  export type statsGroupTopPoster = {\n\t\t_: 'statsGroupTopPoster',\n\t\tuser_id: number,\n\t\tmessages: number,\n\t\tavg_chars: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsGroupTopAdmin\n */\nexport type StatsGroupTopAdmin = StatsGroupTopAdmin.statsGroupTopAdmin;\n\nexport namespace StatsGroupTopAdmin {\n  export type statsGroupTopAdmin = {\n\t\t_: 'statsGroupTopAdmin',\n\t\tuser_id: number,\n\t\tdeleted: number,\n\t\tkicked: number,\n\t\tbanned: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/StatsGroupTopInviter\n */\nexport type StatsGroupTopInviter = StatsGroupTopInviter.statsGroupTopInviter;\n\nexport namespace StatsGroupTopInviter {\n  export type statsGroupTopInviter = {\n\t\t_: 'statsGroupTopInviter',\n\t\tuser_id: number,\n\t\tinvitations: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/stats.MegagroupStats\n */\nexport type StatsMegagroupStats = StatsMegagroupStats.statsMegagroupStats;\n\nexport namespace StatsMegagroupStats {\n  export type statsMegagroupStats = {\n\t\t_: 'stats.megagroupStats',\n\t\tperiod: StatsDateRangeDays,\n\t\tmembers: StatsAbsValueAndPrev,\n\t\tmessages: StatsAbsValueAndPrev,\n\t\tviewers: StatsAbsValueAndPrev,\n\t\tposters: StatsAbsValueAndPrev,\n\t\tgrowth_graph: StatsGraph,\n\t\tmembers_graph: StatsGraph,\n\t\tnew_members_by_source_graph: StatsGraph,\n\t\tlanguages_graph: StatsGraph,\n\t\tmessages_graph: StatsGraph,\n\t\tactions_graph: StatsGraph,\n\t\ttop_hours_graph: StatsGraph,\n\t\tweekdays_graph: StatsGraph,\n\t\ttop_posters: Array<StatsGroupTopPoster>,\n\t\ttop_admins: Array<StatsGroupTopAdmin>,\n\t\ttop_inviters: Array<StatsGroupTopInviter>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/GlobalPrivacySettings\n */\nexport type GlobalPrivacySettings = GlobalPrivacySettings.globalPrivacySettings;\n\nexport namespace GlobalPrivacySettings {\n  export type globalPrivacySettings = {\n\t\t_: 'globalPrivacySettings',\n\t\tflags?: number,\n\t\tarchive_and_mute_new_noncontact_peers?: boolean\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.CountryCode\n */\nexport type HelpCountryCode = HelpCountryCode.helpCountryCode;\n\nexport namespace HelpCountryCode {\n  export type helpCountryCode = {\n\t\t_: 'help.countryCode',\n\t\tflags?: number,\n\t\tcountry_code: string,\n\t\tprefixes?: Array<string>,\n\t\tpatterns?: Array<string>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.Country\n */\nexport type HelpCountry = HelpCountry.helpCountry;\n\nexport namespace HelpCountry {\n  export type helpCountry = {\n\t\t_: 'help.country',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\thidden?: true,\n\t\t}>,\n\t\tiso2: string,\n\t\tdefault_name: string,\n\t\tname?: string,\n\t\tcountry_codes: Array<HelpCountryCode>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/help.CountriesList\n */\nexport type HelpCountriesList = HelpCountriesList.helpCountriesListNotModified | HelpCountriesList.helpCountriesList;\n\nexport namespace HelpCountriesList {\n  export type helpCountriesListNotModified = {\n\t\t_: 'help.countriesListNotModified'\n\t};\n\n\texport type helpCountriesList = {\n\t\t_: 'help.countriesList',\n\t\tcountries: Array<HelpCountry>,\n\t\thash: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageViews\n */\nexport type MessageViews = MessageViews.messageViews;\n\nexport namespace MessageViews {\n  export type messageViews = {\n\t\t_: 'messageViews',\n\t\tflags?: number,\n\t\tviews?: number,\n\t\tforwards?: number,\n\t\treplies?: MessageReplies\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.MessageViews\n */\nexport type MessagesMessageViews = MessagesMessageViews.messagesMessageViews;\n\nexport namespace MessagesMessageViews {\n  export type messagesMessageViews = {\n\t\t_: 'messages.messageViews',\n\t\tviews: Array<MessageViews>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.DiscussionMessage\n */\nexport type MessagesDiscussionMessage = MessagesDiscussionMessage.messagesDiscussionMessage;\n\nexport namespace MessagesDiscussionMessage {\n  export type messagesDiscussionMessage = {\n\t\t_: 'messages.discussionMessage',\n\t\tflags?: number,\n\t\tmessages: Array<Message>,\n\t\tmax_id?: number,\n\t\tread_inbox_max_id?: number,\n\t\tread_outbox_max_id?: number,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageReplyHeader\n */\nexport type MessageReplyHeader = MessageReplyHeader.messageReplyHeader;\n\nexport namespace MessageReplyHeader {\n  export type messageReplyHeader = {\n\t\t_: 'messageReplyHeader',\n\t\tflags?: number,\n\t\treply_to_msg_id: number,\n\t\treply_to_peer_id?: Peer,\n\t\treply_to_top_id?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/MessageReplies\n */\nexport type MessageReplies = MessageReplies.messageReplies;\n\nexport namespace MessageReplies {\n  export type messageReplies = {\n\t\t_: 'messageReplies',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tcomments?: true,\n\t\t}>,\n\t\treplies: number,\n\t\treplies_pts: number,\n\t\trecent_repliers?: Array<Peer>,\n\t\tchannel_id?: number,\n\t\tmax_id?: number,\n\t\tread_max_id?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/PeerBlocked\n */\nexport type PeerBlocked = PeerBlocked.peerBlocked;\n\nexport namespace PeerBlocked {\n  export type peerBlocked = {\n\t\t_: 'peerBlocked',\n\t\tpeer_id: Peer,\n\t\tdate: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/stats.MessageStats\n */\nexport type StatsMessageStats = StatsMessageStats.statsMessageStats;\n\nexport namespace StatsMessageStats {\n  export type statsMessageStats = {\n\t\t_: 'stats.messageStats',\n\t\tviews_graph: StatsGraph\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/GroupCall\n */\nexport type GroupCall = GroupCall.groupCallDiscarded | GroupCall.groupCall;\n\nexport namespace GroupCall {\n  export type groupCallDiscarded = {\n\t\t_: 'groupCallDiscarded',\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tduration: number\n\t};\n\n\texport type groupCall = {\n\t\t_: 'groupCall',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tjoin_muted?: true,\n\t\t\tcan_change_join_muted?: true,\n\t\t\tjoin_date_asc?: true,\n\t\t\tschedule_start_subscribed?: true,\n\t\t\tcan_start_video?: true,\n\t\t}>,\n\t\tid: string,\n\t\taccess_hash: string,\n\t\tparticipants_count: number,\n\t\ttitle?: string,\n\t\tstream_dc_id?: number,\n\t\trecord_start_date?: number,\n\t\tschedule_date?: number,\n\t\tunmuted_video_count?: number,\n\t\tunmuted_video_limit: number,\n\t\tversion: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InputGroupCall\n */\nexport type InputGroupCall = InputGroupCall.inputGroupCall;\n\nexport namespace InputGroupCall {\n  export type inputGroupCall = {\n\t\t_: 'inputGroupCall',\n\t\tid: string,\n\t\taccess_hash: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/GroupCallParticipant\n */\nexport type GroupCallParticipant = GroupCallParticipant.groupCallParticipant;\n\nexport namespace GroupCallParticipant {\n  export type groupCallParticipant = {\n\t\t_: 'groupCallParticipant',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tmuted?: true,\n\t\t\tleft?: true,\n\t\t\tcan_self_unmute?: true,\n\t\t\tjust_joined?: true,\n\t\t\tversioned?: true,\n\t\t\tmin?: true,\n\t\t\tmuted_by_you?: true,\n\t\t\tvolume_by_admin?: true,\n\t\t\tself?: true,\n\t\t\tvideo_joined?: true,\n\t\t}>,\n\t\tpeer: Peer,\n\t\tdate: number,\n\t\tactive_date?: number,\n\t\tsource: number,\n\t\tvolume?: number,\n\t\tabout?: string,\n\t\traise_hand_rating?: string,\n\t\tvideo?: GroupCallParticipantVideo,\n\t\tpresentation?: GroupCallParticipantVideo\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/phone.GroupCall\n */\nexport type PhoneGroupCall = PhoneGroupCall.phoneGroupCall;\n\nexport namespace PhoneGroupCall {\n  export type phoneGroupCall = {\n\t\t_: 'phone.groupCall',\n\t\tcall: GroupCall,\n\t\tparticipants: Array<GroupCallParticipant>,\n\t\tparticipants_next_offset: string,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/phone.GroupParticipants\n */\nexport type PhoneGroupParticipants = PhoneGroupParticipants.phoneGroupParticipants;\n\nexport namespace PhoneGroupParticipants {\n  export type phoneGroupParticipants = {\n\t\t_: 'phone.groupParticipants',\n\t\tcount: number,\n\t\tparticipants: Array<GroupCallParticipant>,\n\t\tnext_offset: string,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>,\n\t\tversion: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/InlineQueryPeerType\n */\nexport type InlineQueryPeerType = InlineQueryPeerType.inlineQueryPeerTypeSameBotPM | InlineQueryPeerType.inlineQueryPeerTypePM | InlineQueryPeerType.inlineQueryPeerTypeChat | InlineQueryPeerType.inlineQueryPeerTypeMegagroup | InlineQueryPeerType.inlineQueryPeerTypeBroadcast;\n\nexport namespace InlineQueryPeerType {\n  export type inlineQueryPeerTypeSameBotPM = {\n\t\t_: 'inlineQueryPeerTypeSameBotPM'\n\t};\n\n\texport type inlineQueryPeerTypePM = {\n\t\t_: 'inlineQueryPeerTypePM'\n\t};\n\n\texport type inlineQueryPeerTypeChat = {\n\t\t_: 'inlineQueryPeerTypeChat'\n\t};\n\n\texport type inlineQueryPeerTypeMegagroup = {\n\t\t_: 'inlineQueryPeerTypeMegagroup'\n\t};\n\n\texport type inlineQueryPeerTypeBroadcast = {\n\t\t_: 'inlineQueryPeerTypeBroadcast'\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.HistoryImport\n */\nexport type MessagesHistoryImport = MessagesHistoryImport.messagesHistoryImport;\n\nexport namespace MessagesHistoryImport {\n  export type messagesHistoryImport = {\n\t\t_: 'messages.historyImport',\n\t\tid: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.HistoryImportParsed\n */\nexport type MessagesHistoryImportParsed = MessagesHistoryImportParsed.messagesHistoryImportParsed;\n\nexport namespace MessagesHistoryImportParsed {\n  export type messagesHistoryImportParsed = {\n\t\t_: 'messages.historyImportParsed',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpm?: true,\n\t\t\tgroup?: true,\n\t\t}>,\n\t\ttitle?: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.AffectedFoundMessages\n */\nexport type MessagesAffectedFoundMessages = MessagesAffectedFoundMessages.messagesAffectedFoundMessages;\n\nexport namespace MessagesAffectedFoundMessages {\n  export type messagesAffectedFoundMessages = {\n\t\t_: 'messages.affectedFoundMessages',\n\t\tpts: number,\n\t\tpts_count: number,\n\t\toffset: number,\n\t\tmessages: Array<number>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatInviteImporter\n */\nexport type ChatInviteImporter = ChatInviteImporter.chatInviteImporter;\n\nexport namespace ChatInviteImporter {\n  export type chatInviteImporter = {\n\t\t_: 'chatInviteImporter',\n\t\tuser_id: number,\n\t\tdate: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.ExportedChatInvites\n */\nexport type MessagesExportedChatInvites = MessagesExportedChatInvites.messagesExportedChatInvites;\n\nexport namespace MessagesExportedChatInvites {\n  export type messagesExportedChatInvites = {\n\t\t_: 'messages.exportedChatInvites',\n\t\tcount: number,\n\t\tinvites: Array<ExportedChatInvite>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.ExportedChatInvite\n */\nexport type MessagesExportedChatInvite = MessagesExportedChatInvite.messagesExportedChatInvite | MessagesExportedChatInvite.messagesExportedChatInviteReplaced;\n\nexport namespace MessagesExportedChatInvite {\n  export type messagesExportedChatInvite = {\n\t\t_: 'messages.exportedChatInvite',\n\t\tinvite: ExportedChatInvite,\n\t\tusers: Array<User>\n\t};\n\n\texport type messagesExportedChatInviteReplaced = {\n\t\t_: 'messages.exportedChatInviteReplaced',\n\t\tinvite: ExportedChatInvite,\n\t\tnew_invite: ExportedChatInvite,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.ChatInviteImporters\n */\nexport type MessagesChatInviteImporters = MessagesChatInviteImporters.messagesChatInviteImporters;\n\nexport namespace MessagesChatInviteImporters {\n  export type messagesChatInviteImporters = {\n\t\t_: 'messages.chatInviteImporters',\n\t\tcount: number,\n\t\timporters: Array<ChatInviteImporter>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/ChatAdminWithInvites\n */\nexport type ChatAdminWithInvites = ChatAdminWithInvites.chatAdminWithInvites;\n\nexport namespace ChatAdminWithInvites {\n  export type chatAdminWithInvites = {\n\t\t_: 'chatAdminWithInvites',\n\t\tadmin_id: number,\n\t\tinvites_count: number,\n\t\trevoked_invites_count: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.ChatAdminsWithInvites\n */\nexport type MessagesChatAdminsWithInvites = MessagesChatAdminsWithInvites.messagesChatAdminsWithInvites;\n\nexport namespace MessagesChatAdminsWithInvites {\n  export type messagesChatAdminsWithInvites = {\n\t\t_: 'messages.chatAdminsWithInvites',\n\t\tadmins: Array<ChatAdminWithInvites>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/messages.CheckedHistoryImportPeer\n */\nexport type MessagesCheckedHistoryImportPeer = MessagesCheckedHistoryImportPeer.messagesCheckedHistoryImportPeer;\n\nexport namespace MessagesCheckedHistoryImportPeer {\n  export type messagesCheckedHistoryImportPeer = {\n\t\t_: 'messages.checkedHistoryImportPeer',\n\t\tconfirm_text: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/phone.JoinAsPeers\n */\nexport type PhoneJoinAsPeers = PhoneJoinAsPeers.phoneJoinAsPeers;\n\nexport namespace PhoneJoinAsPeers {\n  export type phoneJoinAsPeers = {\n\t\t_: 'phone.joinAsPeers',\n\t\tpeers: Array<Peer>,\n\t\tchats: Array<Chat>,\n\t\tusers: Array<User>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/phone.ExportedGroupCallInvite\n */\nexport type PhoneExportedGroupCallInvite = PhoneExportedGroupCallInvite.phoneExportedGroupCallInvite;\n\nexport namespace PhoneExportedGroupCallInvite {\n  export type phoneExportedGroupCallInvite = {\n\t\t_: 'phone.exportedGroupCallInvite',\n\t\tlink: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/GroupCallParticipantVideoSourceGroup\n */\nexport type GroupCallParticipantVideoSourceGroup = GroupCallParticipantVideoSourceGroup.groupCallParticipantVideoSourceGroup;\n\nexport namespace GroupCallParticipantVideoSourceGroup {\n  export type groupCallParticipantVideoSourceGroup = {\n\t\t_: 'groupCallParticipantVideoSourceGroup',\n\t\tsemantics: string,\n\t\tsources: Array<number>\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/GroupCallParticipantVideo\n */\nexport type GroupCallParticipantVideo = GroupCallParticipantVideo.groupCallParticipantVideo;\n\nexport namespace GroupCallParticipantVideo {\n  export type groupCallParticipantVideo = {\n\t\t_: 'groupCallParticipantVideo',\n\t\tflags?: number,\n\t\tpFlags?: Partial<{\n\t\t\tpaused?: true,\n\t\t}>,\n\t\tendpoint: string,\n\t\tsource_groups: Array<GroupCallParticipantVideoSourceGroup>,\n\t\taudio_source?: number\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/stickers.SuggestedShortName\n */\nexport type StickersSuggestedShortName = StickersSuggestedShortName.stickersSuggestedShortName;\n\nexport namespace StickersSuggestedShortName {\n  export type stickersSuggestedShortName = {\n\t\t_: 'stickers.suggestedShortName',\n\t\tshort_name: string\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/BotCommandScope\n */\nexport type BotCommandScope = BotCommandScope.botCommandScopeDefault | BotCommandScope.botCommandScopeUsers | BotCommandScope.botCommandScopeChats | BotCommandScope.botCommandScopeChatAdmins | BotCommandScope.botCommandScopePeer | BotCommandScope.botCommandScopePeerAdmins | BotCommandScope.botCommandScopePeerUser;\n\nexport namespace BotCommandScope {\n  export type botCommandScopeDefault = {\n\t\t_: 'botCommandScopeDefault'\n\t};\n\n\texport type botCommandScopeUsers = {\n\t\t_: 'botCommandScopeUsers'\n\t};\n\n\texport type botCommandScopeChats = {\n\t\t_: 'botCommandScopeChats'\n\t};\n\n\texport type botCommandScopeChatAdmins = {\n\t\t_: 'botCommandScopeChatAdmins'\n\t};\n\n\texport type botCommandScopePeer = {\n\t\t_: 'botCommandScopePeer',\n\t\tpeer: InputPeer\n\t};\n\n\texport type botCommandScopePeerAdmins = {\n\t\t_: 'botCommandScopePeerAdmins',\n\t\tpeer: InputPeer\n\t};\n\n\texport type botCommandScopePeerUser = {\n\t\t_: 'botCommandScopePeerUser',\n\t\tpeer: InputPeer,\n\t\tuser_id: InputUser\n\t};\n}\n\n/**\n * @link https://core.telegram.org/type/account.ResetPasswordResult\n */\nexport type AccountResetPasswordResult = AccountResetPasswordResult.accountResetPasswordFailedWait | AccountResetPasswordResult.accountResetPasswordRequestedWait | AccountResetPasswordResult.accountResetPasswordOk;\n\nexport namespace AccountResetPasswordResult {\n  export type accountResetPasswordFailedWait = {\n\t\t_: 'account.resetPasswordFailedWait',\n\t\tretry_date: number\n\t};\n\n\texport type accountResetPasswordRequestedWait = {\n\t\t_: 'account.resetPasswordRequestedWait',\n\t\tuntil_date: number\n\t};\n\n\texport type accountResetPasswordOk = {\n\t\t_: 'account.resetPasswordOk'\n\t};\n}\n\nexport interface ConstructorDeclMap {\n\t'error': Error.error,\n\t'inputPeerEmpty': InputPeer.inputPeerEmpty,\n\t'inputPeerSelf': InputPeer.inputPeerSelf,\n\t'inputPeerChat': InputPeer.inputPeerChat,\n\t'inputUserEmpty': InputUser.inputUserEmpty,\n\t'inputUserSelf': InputUser.inputUserSelf,\n\t'inputPhoneContact': InputContact.inputPhoneContact,\n\t'inputFile': InputFile.inputFile,\n\t'inputMediaEmpty': InputMedia.inputMediaEmpty,\n\t'inputMediaUploadedPhoto': InputMedia.inputMediaUploadedPhoto,\n\t'inputMediaPhoto': InputMedia.inputMediaPhoto,\n\t'inputMediaGeoPoint': InputMedia.inputMediaGeoPoint,\n\t'inputMediaContact': InputMedia.inputMediaContact,\n\t'inputChatPhotoEmpty': InputChatPhoto.inputChatPhotoEmpty,\n\t'inputChatUploadedPhoto': InputChatPhoto.inputChatUploadedPhoto,\n\t'inputChatPhoto': InputChatPhoto.inputChatPhoto,\n\t'inputGeoPointEmpty': InputGeoPoint.inputGeoPointEmpty,\n\t'inputGeoPoint': InputGeoPoint.inputGeoPoint,\n\t'inputPhotoEmpty': InputPhoto.inputPhotoEmpty,\n\t'inputPhoto': InputPhoto.inputPhoto,\n\t'inputFileLocation': InputFileLocation.inputFileLocation,\n\t'peerUser': Peer.peerUser,\n\t'peerChat': Peer.peerChat,\n\t'storage.fileUnknown': StorageFileType.storageFileUnknown,\n\t'storage.filePartial': StorageFileType.storageFilePartial,\n\t'storage.fileJpeg': StorageFileType.storageFileJpeg,\n\t'storage.fileGif': StorageFileType.storageFileGif,\n\t'storage.filePng': StorageFileType.storageFilePng,\n\t'storage.filePdf': StorageFileType.storageFilePdf,\n\t'storage.fileMp3': StorageFileType.storageFileMp3,\n\t'storage.fileMov': StorageFileType.storageFileMov,\n\t'storage.fileMp4': StorageFileType.storageFileMp4,\n\t'storage.fileWebp': StorageFileType.storageFileWebp,\n\t'userEmpty': User.userEmpty,\n\t'userProfilePhotoEmpty': UserProfilePhoto.userProfilePhotoEmpty,\n\t'userProfilePhoto': UserProfilePhoto.userProfilePhoto,\n\t'userStatusEmpty': UserStatus.userStatusEmpty,\n\t'userStatusOnline': UserStatus.userStatusOnline,\n\t'userStatusOffline': UserStatus.userStatusOffline,\n\t'chatEmpty': Chat.chatEmpty,\n\t'chat': Chat.chat,\n\t'chatForbidden': Chat.chatForbidden,\n\t'chatFull': ChatFull.chatFull,\n\t'chatParticipant': ChatParticipant.chatParticipant,\n\t'chatParticipantsForbidden': ChatParticipants.chatParticipantsForbidden,\n\t'chatParticipants': ChatParticipants.chatParticipants,\n\t'chatPhotoEmpty': ChatPhoto.chatPhotoEmpty,\n\t'chatPhoto': ChatPhoto.chatPhoto,\n\t'messageEmpty': Message.messageEmpty,\n\t'message': Message.message,\n\t'messageService': Message.messageService,\n\t'messageMediaEmpty': MessageMedia.messageMediaEmpty,\n\t'messageMediaPhoto': MessageMedia.messageMediaPhoto,\n\t'messageMediaGeo': MessageMedia.messageMediaGeo,\n\t'messageMediaContact': MessageMedia.messageMediaContact,\n\t'messageMediaUnsupported': MessageMedia.messageMediaUnsupported,\n\t'messageActionEmpty': MessageAction.messageActionEmpty,\n\t'messageActionChatCreate': MessageAction.messageActionChatCreate,\n\t'messageActionChatEditTitle': MessageAction.messageActionChatEditTitle,\n\t'messageActionChatEditPhoto': MessageAction.messageActionChatEditPhoto,\n\t'messageActionChatDeletePhoto': MessageAction.messageActionChatDeletePhoto,\n\t'messageActionChatAddUser': MessageAction.messageActionChatAddUser,\n\t'messageActionChatDeleteUser': MessageAction.messageActionChatDeleteUser,\n\t'dialog': Dialog.dialog,\n\t'photoEmpty': Photo.photoEmpty,\n\t'photo': Photo.photo,\n\t'photoSizeEmpty': PhotoSize.photoSizeEmpty,\n\t'photoSize': PhotoSize.photoSize,\n\t'photoCachedSize': PhotoSize.photoCachedSize,\n\t'geoPointEmpty': GeoPoint.geoPointEmpty,\n\t'geoPoint': GeoPoint.geoPoint,\n\t'auth.sentCode': AuthSentCode.authSentCode,\n\t'auth.authorization': AuthAuthorization.authAuthorization,\n\t'auth.exportedAuthorization': AuthExportedAuthorization.authExportedAuthorization,\n\t'inputNotifyPeer': InputNotifyPeer.inputNotifyPeer,\n\t'inputNotifyUsers': InputNotifyPeer.inputNotifyUsers,\n\t'inputNotifyChats': InputNotifyPeer.inputNotifyChats,\n\t'inputPeerNotifySettings': InputPeerNotifySettings.inputPeerNotifySettings,\n\t'peerNotifySettings': PeerNotifySettings.peerNotifySettings,\n\t'peerSettings': PeerSettings.peerSettings,\n\t'wallPaper': WallPaper.wallPaper,\n\t'inputReportReasonSpam': ReportReason.inputReportReasonSpam,\n\t'inputReportReasonViolence': ReportReason.inputReportReasonViolence,\n\t'inputReportReasonPornography': ReportReason.inputReportReasonPornography,\n\t'inputReportReasonChildAbuse': ReportReason.inputReportReasonChildAbuse,\n\t'inputReportReasonOther': ReportReason.inputReportReasonOther,\n\t'userFull': UserFull.userFull,\n\t'contact': Contact.contact,\n\t'importedContact': ImportedContact.importedContact,\n\t'contactStatus': ContactStatus.contactStatus,\n\t'contacts.contactsNotModified': ContactsContacts.contactsContactsNotModified,\n\t'contacts.contacts': ContactsContacts.contactsContacts,\n\t'contacts.importedContacts': ContactsImportedContacts.contactsImportedContacts,\n\t'contacts.blocked': ContactsBlocked.contactsBlocked,\n\t'contacts.blockedSlice': ContactsBlocked.contactsBlockedSlice,\n\t'messages.dialogs': MessagesDialogs.messagesDialogs,\n\t'messages.dialogsSlice': MessagesDialogs.messagesDialogsSlice,\n\t'messages.messages': MessagesMessages.messagesMessages,\n\t'messages.messagesSlice': MessagesMessages.messagesMessagesSlice,\n\t'messages.chats': MessagesChats.messagesChats,\n\t'messages.chatFull': MessagesChatFull.messagesChatFull,\n\t'messages.affectedHistory': MessagesAffectedHistory.messagesAffectedHistory,\n\t'inputMessagesFilterEmpty': MessagesFilter.inputMessagesFilterEmpty,\n\t'inputMessagesFilterPhotos': MessagesFilter.inputMessagesFilterPhotos,\n\t'inputMessagesFilterVideo': MessagesFilter.inputMessagesFilterVideo,\n\t'inputMessagesFilterPhotoVideo': MessagesFilter.inputMessagesFilterPhotoVideo,\n\t'inputMessagesFilterDocument': MessagesFilter.inputMessagesFilterDocument,\n\t'inputMessagesFilterUrl': MessagesFilter.inputMessagesFilterUrl,\n\t'inputMessagesFilterGif': MessagesFilter.inputMessagesFilterGif,\n\t'updateNewMessage': Update.updateNewMessage,\n\t'updateMessageID': Update.updateMessageID,\n\t'updateDeleteMessages': Update.updateDeleteMessages,\n\t'updateUserTyping': Update.updateUserTyping,\n\t'updateChatUserTyping': Update.updateChatUserTyping,\n\t'updateChatParticipants': Update.updateChatParticipants,\n\t'updateUserStatus': Update.updateUserStatus,\n\t'updateUserName': Update.updateUserName,\n\t'updateUserPhoto': Update.updateUserPhoto,\n\t'updates.state': UpdatesState.updatesState,\n\t'updates.differenceEmpty': UpdatesDifference.updatesDifferenceEmpty,\n\t'updates.difference': UpdatesDifference.updatesDifference,\n\t'updates.differenceSlice': UpdatesDifference.updatesDifferenceSlice,\n\t'updatesTooLong': Updates.updatesTooLong,\n\t'updateShortMessage': Updates.updateShortMessage,\n\t'updateShortChatMessage': Updates.updateShortChatMessage,\n\t'updateShort': Updates.updateShort,\n\t'updatesCombined': Updates.updatesCombined,\n\t'updates': Updates.updates,\n\t'photos.photos': PhotosPhotos.photosPhotos,\n\t'photos.photosSlice': PhotosPhotos.photosPhotosSlice,\n\t'photos.photo': PhotosPhoto.photosPhoto,\n\t'upload.file': UploadFile.uploadFile,\n\t'dcOption': DcOption.dcOption,\n\t'config': Config.config,\n\t'nearestDc': NearestDc.nearestDc,\n\t'help.appUpdate': HelpAppUpdate.helpAppUpdate,\n\t'help.noAppUpdate': HelpAppUpdate.helpNoAppUpdate,\n\t'help.inviteText': HelpInviteText.helpInviteText,\n\t'updateNewEncryptedMessage': Update.updateNewEncryptedMessage,\n\t'updateEncryptedChatTyping': Update.updateEncryptedChatTyping,\n\t'updateEncryption': Update.updateEncryption,\n\t'updateEncryptedMessagesRead': Update.updateEncryptedMessagesRead,\n\t'encryptedChatEmpty': EncryptedChat.encryptedChatEmpty,\n\t'encryptedChatWaiting': EncryptedChat.encryptedChatWaiting,\n\t'encryptedChatRequested': EncryptedChat.encryptedChatRequested,\n\t'encryptedChat': EncryptedChat.encryptedChat,\n\t'encryptedChatDiscarded': EncryptedChat.encryptedChatDiscarded,\n\t'inputEncryptedChat': InputEncryptedChat.inputEncryptedChat,\n\t'encryptedFileEmpty': EncryptedFile.encryptedFileEmpty,\n\t'encryptedFile': EncryptedFile.encryptedFile,\n\t'inputEncryptedFileEmpty': InputEncryptedFile.inputEncryptedFileEmpty,\n\t'inputEncryptedFileUploaded': InputEncryptedFile.inputEncryptedFileUploaded,\n\t'inputEncryptedFile': InputEncryptedFile.inputEncryptedFile,\n\t'inputEncryptedFileLocation': InputFileLocation.inputEncryptedFileLocation,\n\t'encryptedMessage': EncryptedMessage.encryptedMessage,\n\t'encryptedMessageService': EncryptedMessage.encryptedMessageService,\n\t'messages.dhConfigNotModified': MessagesDhConfig.messagesDhConfigNotModified,\n\t'messages.dhConfig': MessagesDhConfig.messagesDhConfig,\n\t'messages.sentEncryptedMessage': MessagesSentEncryptedMessage.messagesSentEncryptedMessage,\n\t'messages.sentEncryptedFile': MessagesSentEncryptedMessage.messagesSentEncryptedFile,\n\t'inputFileBig': InputFile.inputFileBig,\n\t'inputEncryptedFileBigUploaded': InputEncryptedFile.inputEncryptedFileBigUploaded,\n\t'updateChatParticipantAdd': Update.updateChatParticipantAdd,\n\t'updateChatParticipantDelete': Update.updateChatParticipantDelete,\n\t'updateDcOptions': Update.updateDcOptions,\n\t'inputMediaUploadedDocument': InputMedia.inputMediaUploadedDocument,\n\t'inputMediaDocument': InputMedia.inputMediaDocument,\n\t'messageMediaDocument': MessageMedia.messageMediaDocument,\n\t'inputDocumentEmpty': InputDocument.inputDocumentEmpty,\n\t'inputDocument': InputDocument.inputDocument,\n\t'inputDocumentFileLocation': InputFileLocation.inputDocumentFileLocation,\n\t'documentEmpty': Document.documentEmpty,\n\t'document': Document.document,\n\t'help.support': HelpSupport.helpSupport,\n\t'notifyPeer': NotifyPeer.notifyPeer,\n\t'notifyUsers': NotifyPeer.notifyUsers,\n\t'notifyChats': NotifyPeer.notifyChats,\n\t'updateNotifySettings': Update.updateNotifySettings,\n\t'sendMessageTypingAction': SendMessageAction.sendMessageTypingAction,\n\t'sendMessageCancelAction': SendMessageAction.sendMessageCancelAction,\n\t'sendMessageRecordVideoAction': SendMessageAction.sendMessageRecordVideoAction,\n\t'sendMessageUploadVideoAction': SendMessageAction.sendMessageUploadVideoAction,\n\t'sendMessageRecordAudioAction': SendMessageAction.sendMessageRecordAudioAction,\n\t'sendMessageUploadAudioAction': SendMessageAction.sendMessageUploadAudioAction,\n\t'sendMessageUploadPhotoAction': SendMessageAction.sendMessageUploadPhotoAction,\n\t'sendMessageUploadDocumentAction': SendMessageAction.sendMessageUploadDocumentAction,\n\t'sendMessageGeoLocationAction': SendMessageAction.sendMessageGeoLocationAction,\n\t'sendMessageChooseContactAction': SendMessageAction.sendMessageChooseContactAction,\n\t'contacts.found': ContactsFound.contactsFound,\n\t'updateServiceNotification': Update.updateServiceNotification,\n\t'userStatusRecently': UserStatus.userStatusRecently,\n\t'userStatusLastWeek': UserStatus.userStatusLastWeek,\n\t'userStatusLastMonth': UserStatus.userStatusLastMonth,\n\t'updatePrivacy': Update.updatePrivacy,\n\t'inputPrivacyKeyStatusTimestamp': InputPrivacyKey.inputPrivacyKeyStatusTimestamp,\n\t'privacyKeyStatusTimestamp': PrivacyKey.privacyKeyStatusTimestamp,\n\t'inputPrivacyValueAllowContacts': InputPrivacyRule.inputPrivacyValueAllowContacts,\n\t'inputPrivacyValueAllowAll': InputPrivacyRule.inputPrivacyValueAllowAll,\n\t'inputPrivacyValueAllowUsers': InputPrivacyRule.inputPrivacyValueAllowUsers,\n\t'inputPrivacyValueDisallowContacts': InputPrivacyRule.inputPrivacyValueDisallowContacts,\n\t'inputPrivacyValueDisallowAll': InputPrivacyRule.inputPrivacyValueDisallowAll,\n\t'inputPrivacyValueDisallowUsers': InputPrivacyRule.inputPrivacyValueDisallowUsers,\n\t'privacyValueAllowContacts': PrivacyRule.privacyValueAllowContacts,\n\t'privacyValueAllowAll': PrivacyRule.privacyValueAllowAll,\n\t'privacyValueAllowUsers': PrivacyRule.privacyValueAllowUsers,\n\t'privacyValueDisallowContacts': PrivacyRule.privacyValueDisallowContacts,\n\t'privacyValueDisallowAll': PrivacyRule.privacyValueDisallowAll,\n\t'privacyValueDisallowUsers': PrivacyRule.privacyValueDisallowUsers,\n\t'account.privacyRules': AccountPrivacyRules.accountPrivacyRules,\n\t'accountDaysTTL': AccountDaysTTL.accountDaysTTL,\n\t'updateUserPhone': Update.updateUserPhone,\n\t'documentAttributeImageSize': DocumentAttribute.documentAttributeImageSize,\n\t'documentAttributeAnimated': DocumentAttribute.documentAttributeAnimated,\n\t'documentAttributeSticker': DocumentAttribute.documentAttributeSticker,\n\t'documentAttributeVideo': DocumentAttribute.documentAttributeVideo,\n\t'documentAttributeAudio': DocumentAttribute.documentAttributeAudio,\n\t'documentAttributeFilename': DocumentAttribute.documentAttributeFilename,\n\t'messages.stickersNotModified': MessagesStickers.messagesStickersNotModified,\n\t'messages.stickers': MessagesStickers.messagesStickers,\n\t'stickerPack': StickerPack.stickerPack,\n\t'messages.allStickersNotModified': MessagesAllStickers.messagesAllStickersNotModified,\n\t'messages.allStickers': MessagesAllStickers.messagesAllStickers,\n\t'updateReadHistoryInbox': Update.updateReadHistoryInbox,\n\t'updateReadHistoryOutbox': Update.updateReadHistoryOutbox,\n\t'messages.affectedMessages': MessagesAffectedMessages.messagesAffectedMessages,\n\t'updateWebPage': Update.updateWebPage,\n\t'webPageEmpty': WebPage.webPageEmpty,\n\t'webPagePending': WebPage.webPagePending,\n\t'webPage': WebPage.webPage,\n\t'messageMediaWebPage': MessageMedia.messageMediaWebPage,\n\t'authorization': Authorization.authorization,\n\t'account.authorizations': AccountAuthorizations.accountAuthorizations,\n\t'account.password': AccountPassword.accountPassword,\n\t'account.passwordSettings': AccountPasswordSettings.accountPasswordSettings,\n\t'account.passwordInputSettings': AccountPasswordInputSettings.accountPasswordInputSettings,\n\t'auth.passwordRecovery': AuthPasswordRecovery.authPasswordRecovery,\n\t'inputMediaVenue': InputMedia.inputMediaVenue,\n\t'messageMediaVenue': MessageMedia.messageMediaVenue,\n\t'receivedNotifyMessage': ReceivedNotifyMessage.receivedNotifyMessage,\n\t'chatInviteExported': ExportedChatInvite.chatInviteExported,\n\t'chatInviteAlready': ChatInvite.chatInviteAlready,\n\t'chatInvite': ChatInvite.chatInvite,\n\t'messageActionChatJoinedByLink': MessageAction.messageActionChatJoinedByLink,\n\t'updateReadMessagesContents': Update.updateReadMessagesContents,\n\t'inputStickerSetEmpty': InputStickerSet.inputStickerSetEmpty,\n\t'inputStickerSetID': InputStickerSet.inputStickerSetID,\n\t'inputStickerSetShortName': InputStickerSet.inputStickerSetShortName,\n\t'stickerSet': StickerSet.stickerSet,\n\t'messages.stickerSet': MessagesStickerSet.messagesStickerSet,\n\t'user': User.user,\n\t'botCommand': BotCommand.botCommand,\n\t'botInfo': BotInfo.botInfo,\n\t'keyboardButton': KeyboardButton.keyboardButton,\n\t'keyboardButtonRow': KeyboardButtonRow.keyboardButtonRow,\n\t'replyKeyboardHide': ReplyMarkup.replyKeyboardHide,\n\t'replyKeyboardForceReply': ReplyMarkup.replyKeyboardForceReply,\n\t'replyKeyboardMarkup': ReplyMarkup.replyKeyboardMarkup,\n\t'inputPeerUser': InputPeer.inputPeerUser,\n\t'inputUser': InputUser.inputUser,\n\t'messageEntityUnknown': MessageEntity.messageEntityUnknown,\n\t'messageEntityMention': MessageEntity.messageEntityMention,\n\t'messageEntityHashtag': MessageEntity.messageEntityHashtag,\n\t'messageEntityBotCommand': MessageEntity.messageEntityBotCommand,\n\t'messageEntityUrl': MessageEntity.messageEntityUrl,\n\t'messageEntityEmail': MessageEntity.messageEntityEmail,\n\t'messageEntityBold': MessageEntity.messageEntityBold,\n\t'messageEntityItalic': MessageEntity.messageEntityItalic,\n\t'messageEntityCode': MessageEntity.messageEntityCode,\n\t'messageEntityPre': MessageEntity.messageEntityPre,\n\t'messageEntityTextUrl': MessageEntity.messageEntityTextUrl,\n\t'updateShortSentMessage': Updates.updateShortSentMessage,\n\t'inputChannelEmpty': InputChannel.inputChannelEmpty,\n\t'inputChannel': InputChannel.inputChannel,\n\t'peerChannel': Peer.peerChannel,\n\t'inputPeerChannel': InputPeer.inputPeerChannel,\n\t'channel': Chat.channel,\n\t'channelForbidden': Chat.channelForbidden,\n\t'contacts.resolvedPeer': ContactsResolvedPeer.contactsResolvedPeer,\n\t'channelFull': ChatFull.channelFull,\n\t'messageRange': MessageRange.messageRange,\n\t'messages.channelMessages': MessagesMessages.messagesChannelMessages,\n\t'messageActionChannelCreate': MessageAction.messageActionChannelCreate,\n\t'updateChannelTooLong': Update.updateChannelTooLong,\n\t'updateChannel': Update.updateChannel,\n\t'updateNewChannelMessage': Update.updateNewChannelMessage,\n\t'updateReadChannelInbox': Update.updateReadChannelInbox,\n\t'updateDeleteChannelMessages': Update.updateDeleteChannelMessages,\n\t'updateChannelMessageViews': Update.updateChannelMessageViews,\n\t'updates.channelDifferenceEmpty': UpdatesChannelDifference.updatesChannelDifferenceEmpty,\n\t'updates.channelDifferenceTooLong': UpdatesChannelDifference.updatesChannelDifferenceTooLong,\n\t'updates.channelDifference': UpdatesChannelDifference.updatesChannelDifference,\n\t'channelMessagesFilterEmpty': ChannelMessagesFilter.channelMessagesFilterEmpty,\n\t'channelMessagesFilter': ChannelMessagesFilter.channelMessagesFilter,\n\t'channelParticipant': ChannelParticipant.channelParticipant,\n\t'channelParticipantSelf': ChannelParticipant.channelParticipantSelf,\n\t'channelParticipantCreator': ChannelParticipant.channelParticipantCreator,\n\t'channelParticipantsRecent': ChannelParticipantsFilter.channelParticipantsRecent,\n\t'channelParticipantsAdmins': ChannelParticipantsFilter.channelParticipantsAdmins,\n\t'channelParticipantsKicked': ChannelParticipantsFilter.channelParticipantsKicked,\n\t'channels.channelParticipants': ChannelsChannelParticipants.channelsChannelParticipants,\n\t'channels.channelParticipant': ChannelsChannelParticipant.channelsChannelParticipant,\n\t'chatParticipantCreator': ChatParticipant.chatParticipantCreator,\n\t'chatParticipantAdmin': ChatParticipant.chatParticipantAdmin,\n\t'updateChatParticipantAdmin': Update.updateChatParticipantAdmin,\n\t'messageActionChatMigrateTo': MessageAction.messageActionChatMigrateTo,\n\t'messageActionChannelMigrateFrom': MessageAction.messageActionChannelMigrateFrom,\n\t'channelParticipantsBots': ChannelParticipantsFilter.channelParticipantsBots,\n\t'help.termsOfService': HelpTermsOfService.helpTermsOfService,\n\t'updateNewStickerSet': Update.updateNewStickerSet,\n\t'updateStickerSetsOrder': Update.updateStickerSetsOrder,\n\t'updateStickerSets': Update.updateStickerSets,\n\t'messages.savedGifsNotModified': MessagesSavedGifs.messagesSavedGifsNotModified,\n\t'messages.savedGifs': MessagesSavedGifs.messagesSavedGifs,\n\t'updateSavedGifs': Update.updateSavedGifs,\n\t'inputBotInlineMessageMediaAuto': InputBotInlineMessage.inputBotInlineMessageMediaAuto,\n\t'inputBotInlineMessageText': InputBotInlineMessage.inputBotInlineMessageText,\n\t'inputBotInlineResult': InputBotInlineResult.inputBotInlineResult,\n\t'botInlineMessageMediaAuto': BotInlineMessage.botInlineMessageMediaAuto,\n\t'botInlineMessageText': BotInlineMessage.botInlineMessageText,\n\t'botInlineResult': BotInlineResult.botInlineResult,\n\t'messages.botResults': MessagesBotResults.messagesBotResults,\n\t'updateBotInlineQuery': Update.updateBotInlineQuery,\n\t'updateBotInlineSend': Update.updateBotInlineSend,\n\t'inputMessagesFilterVoice': MessagesFilter.inputMessagesFilterVoice,\n\t'inputMessagesFilterMusic': MessagesFilter.inputMessagesFilterMusic,\n\t'inputPrivacyKeyChatInvite': InputPrivacyKey.inputPrivacyKeyChatInvite,\n\t'privacyKeyChatInvite': PrivacyKey.privacyKeyChatInvite,\n\t'exportedMessageLink': ExportedMessageLink.exportedMessageLink,\n\t'messageFwdHeader': MessageFwdHeader.messageFwdHeader,\n\t'updateEditChannelMessage': Update.updateEditChannelMessage,\n\t'messageActionPinMessage': MessageAction.messageActionPinMessage,\n\t'auth.codeTypeSms': AuthCodeType.authCodeTypeSms,\n\t'auth.codeTypeCall': AuthCodeType.authCodeTypeCall,\n\t'auth.codeTypeFlashCall': AuthCodeType.authCodeTypeFlashCall,\n\t'auth.sentCodeTypeApp': AuthSentCodeType.authSentCodeTypeApp,\n\t'auth.sentCodeTypeSms': AuthSentCodeType.authSentCodeTypeSms,\n\t'auth.sentCodeTypeCall': AuthSentCodeType.authSentCodeTypeCall,\n\t'auth.sentCodeTypeFlashCall': AuthSentCodeType.authSentCodeTypeFlashCall,\n\t'keyboardButtonUrl': KeyboardButton.keyboardButtonUrl,\n\t'keyboardButtonCallback': KeyboardButton.keyboardButtonCallback,\n\t'keyboardButtonRequestPhone': KeyboardButton.keyboardButtonRequestPhone,\n\t'keyboardButtonRequestGeoLocation': KeyboardButton.keyboardButtonRequestGeoLocation,\n\t'keyboardButtonSwitchInline': KeyboardButton.keyboardButtonSwitchInline,\n\t'replyInlineMarkup': ReplyMarkup.replyInlineMarkup,\n\t'messages.botCallbackAnswer': MessagesBotCallbackAnswer.messagesBotCallbackAnswer,\n\t'updateBotCallbackQuery': Update.updateBotCallbackQuery,\n\t'messages.messageEditData': MessagesMessageEditData.messagesMessageEditData,\n\t'updateEditMessage': Update.updateEditMessage,\n\t'inputBotInlineMessageMediaGeo': InputBotInlineMessage.inputBotInlineMessageMediaGeo,\n\t'inputBotInlineMessageMediaVenue': InputBotInlineMessage.inputBotInlineMessageMediaVenue,\n\t'inputBotInlineMessageMediaContact': InputBotInlineMessage.inputBotInlineMessageMediaContact,\n\t'botInlineMessageMediaGeo': BotInlineMessage.botInlineMessageMediaGeo,\n\t'botInlineMessageMediaVenue': BotInlineMessage.botInlineMessageMediaVenue,\n\t'botInlineMessageMediaContact': BotInlineMessage.botInlineMessageMediaContact,\n\t'inputBotInlineResultPhoto': InputBotInlineResult.inputBotInlineResultPhoto,\n\t'inputBotInlineResultDocument': InputBotInlineResult.inputBotInlineResultDocument,\n\t'botInlineMediaResult': BotInlineResult.botInlineMediaResult,\n\t'inputBotInlineMessageID': InputBotInlineMessageID.inputBotInlineMessageID,\n\t'updateInlineBotCallbackQuery': Update.updateInlineBotCallbackQuery,\n\t'inlineBotSwitchPM': InlineBotSwitchPM.inlineBotSwitchPM,\n\t'messages.peerDialogs': MessagesPeerDialogs.messagesPeerDialogs,\n\t'topPeer': TopPeer.topPeer,\n\t'topPeerCategoryBotsPM': TopPeerCategory.topPeerCategoryBotsPM,\n\t'topPeerCategoryBotsInline': TopPeerCategory.topPeerCategoryBotsInline,\n\t'topPeerCategoryCorrespondents': TopPeerCategory.topPeerCategoryCorrespondents,\n\t'topPeerCategoryGroups': TopPeerCategory.topPeerCategoryGroups,\n\t'topPeerCategoryChannels': TopPeerCategory.topPeerCategoryChannels,\n\t'topPeerCategoryPeers': TopPeerCategoryPeers.topPeerCategoryPeers,\n\t'contacts.topPeersNotModified': ContactsTopPeers.contactsTopPeersNotModified,\n\t'contacts.topPeers': ContactsTopPeers.contactsTopPeers,\n\t'messageEntityMentionName': MessageEntity.messageEntityMentionName,\n\t'inputMessageEntityMentionName': MessageEntity.inputMessageEntityMentionName,\n\t'inputMessagesFilterChatPhotos': MessagesFilter.inputMessagesFilterChatPhotos,\n\t'updateReadChannelOutbox': Update.updateReadChannelOutbox,\n\t'updateDraftMessage': Update.updateDraftMessage,\n\t'draftMessageEmpty': DraftMessage.draftMessageEmpty,\n\t'draftMessage': DraftMessage.draftMessage,\n\t'messageActionHistoryClear': MessageAction.messageActionHistoryClear,\n\t'messages.featuredStickersNotModified': MessagesFeaturedStickers.messagesFeaturedStickersNotModified,\n\t'messages.featuredStickers': MessagesFeaturedStickers.messagesFeaturedStickers,\n\t'updateReadFeaturedStickers': Update.updateReadFeaturedStickers,\n\t'messages.recentStickersNotModified': MessagesRecentStickers.messagesRecentStickersNotModified,\n\t'messages.recentStickers': MessagesRecentStickers.messagesRecentStickers,\n\t'updateRecentStickers': Update.updateRecentStickers,\n\t'messages.archivedStickers': MessagesArchivedStickers.messagesArchivedStickers,\n\t'messages.stickerSetInstallResultSuccess': MessagesStickerSetInstallResult.messagesStickerSetInstallResultSuccess,\n\t'messages.stickerSetInstallResultArchive': MessagesStickerSetInstallResult.messagesStickerSetInstallResultArchive,\n\t'stickerSetCovered': StickerSetCovered.stickerSetCovered,\n\t'updateConfig': Update.updateConfig,\n\t'updatePtsChanged': Update.updatePtsChanged,\n\t'inputMediaPhotoExternal': InputMedia.inputMediaPhotoExternal,\n\t'inputMediaDocumentExternal': InputMedia.inputMediaDocumentExternal,\n\t'stickerSetMultiCovered': StickerSetCovered.stickerSetMultiCovered,\n\t'maskCoords': MaskCoords.maskCoords,\n\t'documentAttributeHasStickers': DocumentAttribute.documentAttributeHasStickers,\n\t'inputStickeredMediaPhoto': InputStickeredMedia.inputStickeredMediaPhoto,\n\t'inputStickeredMediaDocument': InputStickeredMedia.inputStickeredMediaDocument,\n\t'game': Game.game,\n\t'inputBotInlineResultGame': InputBotInlineResult.inputBotInlineResultGame,\n\t'inputBotInlineMessageGame': InputBotInlineMessage.inputBotInlineMessageGame,\n\t'messageMediaGame': MessageMedia.messageMediaGame,\n\t'inputMediaGame': InputMedia.inputMediaGame,\n\t'inputGameID': InputGame.inputGameID,\n\t'inputGameShortName': InputGame.inputGameShortName,\n\t'keyboardButtonGame': KeyboardButton.keyboardButtonGame,\n\t'messageActionGameScore': MessageAction.messageActionGameScore,\n\t'highScore': HighScore.highScore,\n\t'messages.highScores': MessagesHighScores.messagesHighScores,\n\t'updates.differenceTooLong': UpdatesDifference.updatesDifferenceTooLong,\n\t'updateChannelWebPage': Update.updateChannelWebPage,\n\t'messages.chatsSlice': MessagesChats.messagesChatsSlice,\n\t'textEmpty': RichText.textEmpty,\n\t'textPlain': RichText.textPlain,\n\t'textBold': RichText.textBold,\n\t'textItalic': RichText.textItalic,\n\t'textUnderline': RichText.textUnderline,\n\t'textStrike': RichText.textStrike,\n\t'textFixed': RichText.textFixed,\n\t'textUrl': RichText.textUrl,\n\t'textEmail': RichText.textEmail,\n\t'textConcat': RichText.textConcat,\n\t'pageBlockUnsupported': PageBlock.pageBlockUnsupported,\n\t'pageBlockTitle': PageBlock.pageBlockTitle,\n\t'pageBlockSubtitle': PageBlock.pageBlockSubtitle,\n\t'pageBlockAuthorDate': PageBlock.pageBlockAuthorDate,\n\t'pageBlockHeader': PageBlock.pageBlockHeader,\n\t'pageBlockSubheader': PageBlock.pageBlockSubheader,\n\t'pageBlockParagraph': PageBlock.pageBlockParagraph,\n\t'pageBlockPreformatted': PageBlock.pageBlockPreformatted,\n\t'pageBlockFooter': PageBlock.pageBlockFooter,\n\t'pageBlockDivider': PageBlock.pageBlockDivider,\n\t'pageBlockAnchor': PageBlock.pageBlockAnchor,\n\t'pageBlockList': PageBlock.pageBlockList,\n\t'pageBlockBlockquote': PageBlock.pageBlockBlockquote,\n\t'pageBlockPullquote': PageBlock.pageBlockPullquote,\n\t'pageBlockPhoto': PageBlock.pageBlockPhoto,\n\t'pageBlockVideo': PageBlock.pageBlockVideo,\n\t'pageBlockCover': PageBlock.pageBlockCover,\n\t'pageBlockEmbed': PageBlock.pageBlockEmbed,\n\t'pageBlockEmbedPost': PageBlock.pageBlockEmbedPost,\n\t'pageBlockCollage': PageBlock.pageBlockCollage,\n\t'pageBlockSlideshow': PageBlock.pageBlockSlideshow,\n\t'webPageNotModified': WebPage.webPageNotModified,\n\t'inputPrivacyKeyPhoneCall': InputPrivacyKey.inputPrivacyKeyPhoneCall,\n\t'privacyKeyPhoneCall': PrivacyKey.privacyKeyPhoneCall,\n\t'sendMessageGamePlayAction': SendMessageAction.sendMessageGamePlayAction,\n\t'phoneCallDiscardReasonMissed': PhoneCallDiscardReason.phoneCallDiscardReasonMissed,\n\t'phoneCallDiscardReasonDisconnect': PhoneCallDiscardReason.phoneCallDiscardReasonDisconnect,\n\t'phoneCallDiscardReasonHangup': PhoneCallDiscardReason.phoneCallDiscardReasonHangup,\n\t'phoneCallDiscardReasonBusy': PhoneCallDiscardReason.phoneCallDiscardReasonBusy,\n\t'updateDialogPinned': Update.updateDialogPinned,\n\t'updatePinnedDialogs': Update.updatePinnedDialogs,\n\t'dataJSON': DataJSON.dataJSON,\n\t'updateBotWebhookJSON': Update.updateBotWebhookJSON,\n\t'updateBotWebhookJSONQuery': Update.updateBotWebhookJSONQuery,\n\t'labeledPrice': LabeledPrice.labeledPrice,\n\t'invoice': Invoice.invoice,\n\t'inputMediaInvoice': InputMedia.inputMediaInvoice,\n\t'paymentCharge': PaymentCharge.paymentCharge,\n\t'messageActionPaymentSentMe': MessageAction.messageActionPaymentSentMe,\n\t'messageMediaInvoice': MessageMedia.messageMediaInvoice,\n\t'postAddress': PostAddress.postAddress,\n\t'paymentRequestedInfo': PaymentRequestedInfo.paymentRequestedInfo,\n\t'keyboardButtonBuy': KeyboardButton.keyboardButtonBuy,\n\t'messageActionPaymentSent': MessageAction.messageActionPaymentSent,\n\t'paymentSavedCredentialsCard': PaymentSavedCredentials.paymentSavedCredentialsCard,\n\t'webDocument': WebDocument.webDocument,\n\t'inputWebDocument': InputWebDocument.inputWebDocument,\n\t'inputWebFileLocation': InputWebFileLocation.inputWebFileLocation,\n\t'upload.webFile': UploadWebFile.uploadWebFile,\n\t'payments.paymentForm': PaymentsPaymentForm.paymentsPaymentForm,\n\t'payments.validatedRequestedInfo': PaymentsValidatedRequestedInfo.paymentsValidatedRequestedInfo,\n\t'payments.paymentResult': PaymentsPaymentResult.paymentsPaymentResult,\n\t'payments.paymentReceipt': PaymentsPaymentReceipt.paymentsPaymentReceipt,\n\t'payments.savedInfo': PaymentsSavedInfo.paymentsSavedInfo,\n\t'inputPaymentCredentialsSaved': InputPaymentCredentials.inputPaymentCredentialsSaved,\n\t'inputPaymentCredentials': InputPaymentCredentials.inputPaymentCredentials,\n\t'account.tmpPassword': AccountTmpPassword.accountTmpPassword,\n\t'shippingOption': ShippingOption.shippingOption,\n\t'updateBotShippingQuery': Update.updateBotShippingQuery,\n\t'updateBotPrecheckoutQuery': Update.updateBotPrecheckoutQuery,\n\t'inputStickerSetItem': InputStickerSetItem.inputStickerSetItem,\n\t'updatePhoneCall': Update.updatePhoneCall,\n\t'inputPhoneCall': InputPhoneCall.inputPhoneCall,\n\t'phoneCallEmpty': PhoneCall.phoneCallEmpty,\n\t'phoneCallWaiting': PhoneCall.phoneCallWaiting,\n\t'phoneCallRequested': PhoneCall.phoneCallRequested,\n\t'phoneCallAccepted': PhoneCall.phoneCallAccepted,\n\t'phoneCall': PhoneCall.phoneCall,\n\t'phoneCallDiscarded': PhoneCall.phoneCallDiscarded,\n\t'phoneConnection': PhoneConnection.phoneConnection,\n\t'phoneCallProtocol': PhoneCallProtocol.phoneCallProtocol,\n\t'phone.phoneCall': PhonePhoneCall.phonePhoneCall,\n\t'inputMessagesFilterPhoneCalls': MessagesFilter.inputMessagesFilterPhoneCalls,\n\t'messageActionPhoneCall': MessageAction.messageActionPhoneCall,\n\t'inputMessagesFilterRoundVoice': MessagesFilter.inputMessagesFilterRoundVoice,\n\t'inputMessagesFilterRoundVideo': MessagesFilter.inputMessagesFilterRoundVideo,\n\t'sendMessageRecordRoundAction': SendMessageAction.sendMessageRecordRoundAction,\n\t'sendMessageUploadRoundAction': SendMessageAction.sendMessageUploadRoundAction,\n\t'upload.fileCdnRedirect': UploadFile.uploadFileCdnRedirect,\n\t'upload.cdnFileReuploadNeeded': UploadCdnFile.uploadCdnFileReuploadNeeded,\n\t'upload.cdnFile': UploadCdnFile.uploadCdnFile,\n\t'cdnPublicKey': CdnPublicKey.cdnPublicKey,\n\t'cdnConfig': CdnConfig.cdnConfig,\n\t'pageBlockChannel': PageBlock.pageBlockChannel,\n\t'langPackString': LangPackString.langPackString,\n\t'langPackStringPluralized': LangPackString.langPackStringPluralized,\n\t'langPackStringDeleted': LangPackString.langPackStringDeleted,\n\t'langPackDifference': LangPackDifference.langPackDifference,\n\t'langPackLanguage': LangPackLanguage.langPackLanguage,\n\t'updateLangPackTooLong': Update.updateLangPackTooLong,\n\t'updateLangPack': Update.updateLangPack,\n\t'channelParticipantAdmin': ChannelParticipant.channelParticipantAdmin,\n\t'channelParticipantBanned': ChannelParticipant.channelParticipantBanned,\n\t'channelParticipantsBanned': ChannelParticipantsFilter.channelParticipantsBanned,\n\t'channelParticipantsSearch': ChannelParticipantsFilter.channelParticipantsSearch,\n\t'channelAdminLogEventActionChangeTitle': ChannelAdminLogEventAction.channelAdminLogEventActionChangeTitle,\n\t'channelAdminLogEventActionChangeAbout': ChannelAdminLogEventAction.channelAdminLogEventActionChangeAbout,\n\t'channelAdminLogEventActionChangeUsername': ChannelAdminLogEventAction.channelAdminLogEventActionChangeUsername,\n\t'channelAdminLogEventActionChangePhoto': ChannelAdminLogEventAction.channelAdminLogEventActionChangePhoto,\n\t'channelAdminLogEventActionToggleInvites': ChannelAdminLogEventAction.channelAdminLogEventActionToggleInvites,\n\t'channelAdminLogEventActionToggleSignatures': ChannelAdminLogEventAction.channelAdminLogEventActionToggleSignatures,\n\t'channelAdminLogEventActionUpdatePinned': ChannelAdminLogEventAction.channelAdminLogEventActionUpdatePinned,\n\t'channelAdminLogEventActionEditMessage': ChannelAdminLogEventAction.channelAdminLogEventActionEditMessage,\n\t'channelAdminLogEventActionDeleteMessage': ChannelAdminLogEventAction.channelAdminLogEventActionDeleteMessage,\n\t'channelAdminLogEventActionParticipantJoin': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantJoin,\n\t'channelAdminLogEventActionParticipantLeave': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantLeave,\n\t'channelAdminLogEventActionParticipantInvite': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantInvite,\n\t'channelAdminLogEventActionParticipantToggleBan': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantToggleBan,\n\t'channelAdminLogEventActionParticipantToggleAdmin': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantToggleAdmin,\n\t'channelAdminLogEvent': ChannelAdminLogEvent.channelAdminLogEvent,\n\t'channels.adminLogResults': ChannelsAdminLogResults.channelsAdminLogResults,\n\t'channelAdminLogEventsFilter': ChannelAdminLogEventsFilter.channelAdminLogEventsFilter,\n\t'topPeerCategoryPhoneCalls': TopPeerCategory.topPeerCategoryPhoneCalls,\n\t'pageBlockAudio': PageBlock.pageBlockAudio,\n\t'popularContact': PopularContact.popularContact,\n\t'messageActionScreenshotTaken': MessageAction.messageActionScreenshotTaken,\n\t'messages.favedStickersNotModified': MessagesFavedStickers.messagesFavedStickersNotModified,\n\t'messages.favedStickers': MessagesFavedStickers.messagesFavedStickers,\n\t'updateFavedStickers': Update.updateFavedStickers,\n\t'updateChannelReadMessagesContents': Update.updateChannelReadMessagesContents,\n\t'inputMessagesFilterMyMentions': MessagesFilter.inputMessagesFilterMyMentions,\n\t'updateContactsReset': Update.updateContactsReset,\n\t'channelAdminLogEventActionChangeStickerSet': ChannelAdminLogEventAction.channelAdminLogEventActionChangeStickerSet,\n\t'messageActionCustomAction': MessageAction.messageActionCustomAction,\n\t'inputPaymentCredentialsApplePay': InputPaymentCredentials.inputPaymentCredentialsApplePay,\n\t'inputMessagesFilterGeo': MessagesFilter.inputMessagesFilterGeo,\n\t'inputMessagesFilterContacts': MessagesFilter.inputMessagesFilterContacts,\n\t'updateChannelAvailableMessages': Update.updateChannelAvailableMessages,\n\t'channelAdminLogEventActionTogglePreHistoryHidden': ChannelAdminLogEventAction.channelAdminLogEventActionTogglePreHistoryHidden,\n\t'inputMediaGeoLive': InputMedia.inputMediaGeoLive,\n\t'messageMediaGeoLive': MessageMedia.messageMediaGeoLive,\n\t'recentMeUrlUnknown': RecentMeUrl.recentMeUrlUnknown,\n\t'recentMeUrlUser': RecentMeUrl.recentMeUrlUser,\n\t'recentMeUrlChat': RecentMeUrl.recentMeUrlChat,\n\t'recentMeUrlChatInvite': RecentMeUrl.recentMeUrlChatInvite,\n\t'recentMeUrlStickerSet': RecentMeUrl.recentMeUrlStickerSet,\n\t'help.recentMeUrls': HelpRecentMeUrls.helpRecentMeUrls,\n\t'channels.channelParticipantsNotModified': ChannelsChannelParticipants.channelsChannelParticipantsNotModified,\n\t'messages.messagesNotModified': MessagesMessages.messagesMessagesNotModified,\n\t'inputSingleMedia': InputSingleMedia.inputSingleMedia,\n\t'webAuthorization': WebAuthorization.webAuthorization,\n\t'account.webAuthorizations': AccountWebAuthorizations.accountWebAuthorizations,\n\t'inputMessageID': InputMessage.inputMessageID,\n\t'inputMessageReplyTo': InputMessage.inputMessageReplyTo,\n\t'inputMessagePinned': InputMessage.inputMessagePinned,\n\t'messageEntityPhone': MessageEntity.messageEntityPhone,\n\t'messageEntityCashtag': MessageEntity.messageEntityCashtag,\n\t'messageActionBotAllowed': MessageAction.messageActionBotAllowed,\n\t'inputDialogPeer': InputDialogPeer.inputDialogPeer,\n\t'dialogPeer': DialogPeer.dialogPeer,\n\t'messages.foundStickerSetsNotModified': MessagesFoundStickerSets.messagesFoundStickerSetsNotModified,\n\t'messages.foundStickerSets': MessagesFoundStickerSets.messagesFoundStickerSets,\n\t'fileHash': FileHash.fileHash,\n\t'webDocumentNoProxy': WebDocument.webDocumentNoProxy,\n\t'inputClientProxy': InputClientProxy.inputClientProxy,\n\t'help.termsOfServiceUpdateEmpty': HelpTermsOfServiceUpdate.helpTermsOfServiceUpdateEmpty,\n\t'help.termsOfServiceUpdate': HelpTermsOfServiceUpdate.helpTermsOfServiceUpdate,\n\t'inputSecureFileUploaded': InputSecureFile.inputSecureFileUploaded,\n\t'inputSecureFile': InputSecureFile.inputSecureFile,\n\t'inputSecureFileLocation': InputFileLocation.inputSecureFileLocation,\n\t'secureFileEmpty': SecureFile.secureFileEmpty,\n\t'secureFile': SecureFile.secureFile,\n\t'secureData': SecureData.secureData,\n\t'securePlainPhone': SecurePlainData.securePlainPhone,\n\t'securePlainEmail': SecurePlainData.securePlainEmail,\n\t'secureValueTypePersonalDetails': SecureValueType.secureValueTypePersonalDetails,\n\t'secureValueTypePassport': SecureValueType.secureValueTypePassport,\n\t'secureValueTypeDriverLicense': SecureValueType.secureValueTypeDriverLicense,\n\t'secureValueTypeIdentityCard': SecureValueType.secureValueTypeIdentityCard,\n\t'secureValueTypeInternalPassport': SecureValueType.secureValueTypeInternalPassport,\n\t'secureValueTypeAddress': SecureValueType.secureValueTypeAddress,\n\t'secureValueTypeUtilityBill': SecureValueType.secureValueTypeUtilityBill,\n\t'secureValueTypeBankStatement': SecureValueType.secureValueTypeBankStatement,\n\t'secureValueTypeRentalAgreement': SecureValueType.secureValueTypeRentalAgreement,\n\t'secureValueTypePassportRegistration': SecureValueType.secureValueTypePassportRegistration,\n\t'secureValueTypeTemporaryRegistration': SecureValueType.secureValueTypeTemporaryRegistration,\n\t'secureValueTypePhone': SecureValueType.secureValueTypePhone,\n\t'secureValueTypeEmail': SecureValueType.secureValueTypeEmail,\n\t'secureValue': SecureValue.secureValue,\n\t'inputSecureValue': InputSecureValue.inputSecureValue,\n\t'secureValueHash': SecureValueHash.secureValueHash,\n\t'secureValueErrorData': SecureValueError.secureValueErrorData,\n\t'secureValueErrorFrontSide': SecureValueError.secureValueErrorFrontSide,\n\t'secureValueErrorReverseSide': SecureValueError.secureValueErrorReverseSide,\n\t'secureValueErrorSelfie': SecureValueError.secureValueErrorSelfie,\n\t'secureValueErrorFile': SecureValueError.secureValueErrorFile,\n\t'secureValueErrorFiles': SecureValueError.secureValueErrorFiles,\n\t'secureCredentialsEncrypted': SecureCredentialsEncrypted.secureCredentialsEncrypted,\n\t'account.authorizationForm': AccountAuthorizationForm.accountAuthorizationForm,\n\t'account.sentEmailCode': AccountSentEmailCode.accountSentEmailCode,\n\t'messageActionSecureValuesSentMe': MessageAction.messageActionSecureValuesSentMe,\n\t'messageActionSecureValuesSent': MessageAction.messageActionSecureValuesSent,\n\t'help.deepLinkInfoEmpty': HelpDeepLinkInfo.helpDeepLinkInfoEmpty,\n\t'help.deepLinkInfo': HelpDeepLinkInfo.helpDeepLinkInfo,\n\t'savedPhoneContact': SavedContact.savedPhoneContact,\n\t'account.takeout': AccountTakeout.accountTakeout,\n\t'inputTakeoutFileLocation': InputFileLocation.inputTakeoutFileLocation,\n\t'updateDialogUnreadMark': Update.updateDialogUnreadMark,\n\t'messages.dialogsNotModified': MessagesDialogs.messagesDialogsNotModified,\n\t'inputWebFileGeoPointLocation': InputWebFileLocation.inputWebFileGeoPointLocation,\n\t'contacts.topPeersDisabled': ContactsTopPeers.contactsTopPeersDisabled,\n\t'inputReportReasonCopyright': ReportReason.inputReportReasonCopyright,\n\t'passwordKdfAlgoUnknown': PasswordKdfAlgo.passwordKdfAlgoUnknown,\n\t'securePasswordKdfAlgoUnknown': SecurePasswordKdfAlgo.securePasswordKdfAlgoUnknown,\n\t'securePasswordKdfAlgoPBKDF2HMACSHA512iter100000': SecurePasswordKdfAlgo.securePasswordKdfAlgoPBKDF2HMACSHA512iter100000,\n\t'securePasswordKdfAlgoSHA512': SecurePasswordKdfAlgo.securePasswordKdfAlgoSHA512,\n\t'secureSecretSettings': SecureSecretSettings.secureSecretSettings,\n\t'passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow': PasswordKdfAlgo.passwordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow,\n\t'inputCheckPasswordEmpty': InputCheckPasswordSRP.inputCheckPasswordEmpty,\n\t'inputCheckPasswordSRP': InputCheckPasswordSRP.inputCheckPasswordSRP,\n\t'secureValueError': SecureValueError.secureValueError,\n\t'secureValueErrorTranslationFile': SecureValueError.secureValueErrorTranslationFile,\n\t'secureValueErrorTranslationFiles': SecureValueError.secureValueErrorTranslationFiles,\n\t'secureRequiredType': SecureRequiredType.secureRequiredType,\n\t'secureRequiredTypeOneOf': SecureRequiredType.secureRequiredTypeOneOf,\n\t'help.passportConfigNotModified': HelpPassportConfig.helpPassportConfigNotModified,\n\t'help.passportConfig': HelpPassportConfig.helpPassportConfig,\n\t'inputAppEvent': InputAppEvent.inputAppEvent,\n\t'jsonObjectValue': JSONObjectValue.jsonObjectValue,\n\t'jsonNull': JSONValue.jsonNull,\n\t'jsonBool': JSONValue.jsonBool,\n\t'jsonNumber': JSONValue.jsonNumber,\n\t'jsonString': JSONValue.jsonString,\n\t'jsonArray': JSONValue.jsonArray,\n\t'jsonObject': JSONValue.jsonObject,\n\t'inputNotifyBroadcasts': InputNotifyPeer.inputNotifyBroadcasts,\n\t'notifyBroadcasts': NotifyPeer.notifyBroadcasts,\n\t'textSubscript': RichText.textSubscript,\n\t'textSuperscript': RichText.textSuperscript,\n\t'textMarked': RichText.textMarked,\n\t'textPhone': RichText.textPhone,\n\t'textImage': RichText.textImage,\n\t'pageBlockKicker': PageBlock.pageBlockKicker,\n\t'pageTableCell': PageTableCell.pageTableCell,\n\t'pageTableRow': PageTableRow.pageTableRow,\n\t'pageBlockTable': PageBlock.pageBlockTable,\n\t'pageCaption': PageCaption.pageCaption,\n\t'pageListItemText': PageListItem.pageListItemText,\n\t'pageListItemBlocks': PageListItem.pageListItemBlocks,\n\t'pageListOrderedItemText': PageListOrderedItem.pageListOrderedItemText,\n\t'pageListOrderedItemBlocks': PageListOrderedItem.pageListOrderedItemBlocks,\n\t'pageBlockOrderedList': PageBlock.pageBlockOrderedList,\n\t'pageBlockDetails': PageBlock.pageBlockDetails,\n\t'pageRelatedArticle': PageRelatedArticle.pageRelatedArticle,\n\t'pageBlockRelatedArticles': PageBlock.pageBlockRelatedArticles,\n\t'pageBlockMap': PageBlock.pageBlockMap,\n\t'page': Page.page,\n\t'inputPrivacyKeyPhoneP2P': InputPrivacyKey.inputPrivacyKeyPhoneP2P,\n\t'privacyKeyPhoneP2P': PrivacyKey.privacyKeyPhoneP2P,\n\t'textAnchor': RichText.textAnchor,\n\t'help.supportName': HelpSupportName.helpSupportName,\n\t'help.userInfoEmpty': HelpUserInfo.helpUserInfoEmpty,\n\t'help.userInfo': HelpUserInfo.helpUserInfo,\n\t'messageActionContactSignUp': MessageAction.messageActionContactSignUp,\n\t'updateMessagePoll': Update.updateMessagePoll,\n\t'pollAnswer': PollAnswer.pollAnswer,\n\t'poll': Poll.poll,\n\t'pollAnswerVoters': PollAnswerVoters.pollAnswerVoters,\n\t'pollResults': PollResults.pollResults,\n\t'inputMediaPoll': InputMedia.inputMediaPoll,\n\t'messageMediaPoll': MessageMedia.messageMediaPoll,\n\t'chatOnlines': ChatOnlines.chatOnlines,\n\t'statsURL': StatsURL.statsURL,\n\t'photoStrippedSize': PhotoSize.photoStrippedSize,\n\t'chatAdminRights': ChatAdminRights.chatAdminRights,\n\t'chatBannedRights': ChatBannedRights.chatBannedRights,\n\t'updateChatDefaultBannedRights': Update.updateChatDefaultBannedRights,\n\t'inputWallPaper': InputWallPaper.inputWallPaper,\n\t'inputWallPaperSlug': InputWallPaper.inputWallPaperSlug,\n\t'channelParticipantsContacts': ChannelParticipantsFilter.channelParticipantsContacts,\n\t'channelAdminLogEventActionDefaultBannedRights': ChannelAdminLogEventAction.channelAdminLogEventActionDefaultBannedRights,\n\t'channelAdminLogEventActionStopPoll': ChannelAdminLogEventAction.channelAdminLogEventActionStopPoll,\n\t'account.wallPapersNotModified': AccountWallPapers.accountWallPapersNotModified,\n\t'account.wallPapers': AccountWallPapers.accountWallPapers,\n\t'codeSettings': CodeSettings.codeSettings,\n\t'wallPaperSettings': WallPaperSettings.wallPaperSettings,\n\t'autoDownloadSettings': AutoDownloadSettings.autoDownloadSettings,\n\t'account.autoDownloadSettings': AccountAutoDownloadSettings.accountAutoDownloadSettings,\n\t'emojiKeyword': EmojiKeyword.emojiKeyword,\n\t'emojiKeywordDeleted': EmojiKeyword.emojiKeywordDeleted,\n\t'emojiKeywordsDifference': EmojiKeywordsDifference.emojiKeywordsDifference,\n\t'emojiURL': EmojiURL.emojiURL,\n\t'emojiLanguage': EmojiLanguage.emojiLanguage,\n\t'inputPrivacyKeyForwards': InputPrivacyKey.inputPrivacyKeyForwards,\n\t'privacyKeyForwards': PrivacyKey.privacyKeyForwards,\n\t'inputPrivacyKeyProfilePhoto': InputPrivacyKey.inputPrivacyKeyProfilePhoto,\n\t'privacyKeyProfilePhoto': PrivacyKey.privacyKeyProfilePhoto,\n\t'inputPhotoFileLocation': InputFileLocation.inputPhotoFileLocation,\n\t'inputPhotoLegacyFileLocation': InputFileLocation.inputPhotoLegacyFileLocation,\n\t'inputPeerPhotoFileLocation': InputFileLocation.inputPeerPhotoFileLocation,\n\t'inputStickerSetThumb': InputFileLocation.inputStickerSetThumb,\n\t'folder': Folder.folder,\n\t'dialogFolder': Dialog.dialogFolder,\n\t'inputDialogPeerFolder': InputDialogPeer.inputDialogPeerFolder,\n\t'dialogPeerFolder': DialogPeer.dialogPeerFolder,\n\t'inputFolderPeer': InputFolderPeer.inputFolderPeer,\n\t'folderPeer': FolderPeer.folderPeer,\n\t'updateFolderPeers': Update.updateFolderPeers,\n\t'inputUserFromMessage': InputUser.inputUserFromMessage,\n\t'inputChannelFromMessage': InputChannel.inputChannelFromMessage,\n\t'inputPeerUserFromMessage': InputPeer.inputPeerUserFromMessage,\n\t'inputPeerChannelFromMessage': InputPeer.inputPeerChannelFromMessage,\n\t'inputPrivacyKeyPhoneNumber': InputPrivacyKey.inputPrivacyKeyPhoneNumber,\n\t'privacyKeyPhoneNumber': PrivacyKey.privacyKeyPhoneNumber,\n\t'topPeerCategoryForwardUsers': TopPeerCategory.topPeerCategoryForwardUsers,\n\t'topPeerCategoryForwardChats': TopPeerCategory.topPeerCategoryForwardChats,\n\t'channelAdminLogEventActionChangeLinkedChat': ChannelAdminLogEventAction.channelAdminLogEventActionChangeLinkedChat,\n\t'messages.searchCounter': MessagesSearchCounter.messagesSearchCounter,\n\t'keyboardButtonUrlAuth': KeyboardButton.keyboardButtonUrlAuth,\n\t'inputKeyboardButtonUrlAuth': KeyboardButton.inputKeyboardButtonUrlAuth,\n\t'urlAuthResultRequest': UrlAuthResult.urlAuthResultRequest,\n\t'urlAuthResultAccepted': UrlAuthResult.urlAuthResultAccepted,\n\t'urlAuthResultDefault': UrlAuthResult.urlAuthResultDefault,\n\t'inputPrivacyValueAllowChatParticipants': InputPrivacyRule.inputPrivacyValueAllowChatParticipants,\n\t'inputPrivacyValueDisallowChatParticipants': InputPrivacyRule.inputPrivacyValueDisallowChatParticipants,\n\t'privacyValueAllowChatParticipants': PrivacyRule.privacyValueAllowChatParticipants,\n\t'privacyValueDisallowChatParticipants': PrivacyRule.privacyValueDisallowChatParticipants,\n\t'messageEntityUnderline': MessageEntity.messageEntityUnderline,\n\t'messageEntityStrike': MessageEntity.messageEntityStrike,\n\t'messageEntityBlockquote': MessageEntity.messageEntityBlockquote,\n\t'updatePeerSettings': Update.updatePeerSettings,\n\t'channelLocationEmpty': ChannelLocation.channelLocationEmpty,\n\t'channelLocation': ChannelLocation.channelLocation,\n\t'peerLocated': PeerLocated.peerLocated,\n\t'updatePeerLocated': Update.updatePeerLocated,\n\t'channelAdminLogEventActionChangeLocation': ChannelAdminLogEventAction.channelAdminLogEventActionChangeLocation,\n\t'inputReportReasonGeoIrrelevant': ReportReason.inputReportReasonGeoIrrelevant,\n\t'channelAdminLogEventActionToggleSlowMode': ChannelAdminLogEventAction.channelAdminLogEventActionToggleSlowMode,\n\t'auth.authorizationSignUpRequired': AuthAuthorization.authAuthorizationSignUpRequired,\n\t'payments.paymentVerificationNeeded': PaymentsPaymentResult.paymentsPaymentVerificationNeeded,\n\t'inputStickerSetAnimatedEmoji': InputStickerSet.inputStickerSetAnimatedEmoji,\n\t'updateNewScheduledMessage': Update.updateNewScheduledMessage,\n\t'updateDeleteScheduledMessages': Update.updateDeleteScheduledMessages,\n\t'restrictionReason': RestrictionReason.restrictionReason,\n\t'inputTheme': InputTheme.inputTheme,\n\t'inputThemeSlug': InputTheme.inputThemeSlug,\n\t'theme': Theme.theme,\n\t'account.themesNotModified': AccountThemes.accountThemesNotModified,\n\t'account.themes': AccountThemes.accountThemes,\n\t'updateTheme': Update.updateTheme,\n\t'inputPrivacyKeyAddedByPhone': InputPrivacyKey.inputPrivacyKeyAddedByPhone,\n\t'privacyKeyAddedByPhone': PrivacyKey.privacyKeyAddedByPhone,\n\t'updateGeoLiveViewed': Update.updateGeoLiveViewed,\n\t'updateLoginToken': Update.updateLoginToken,\n\t'auth.loginToken': AuthLoginToken.authLoginToken,\n\t'auth.loginTokenMigrateTo': AuthLoginToken.authLoginTokenMigrateTo,\n\t'auth.loginTokenSuccess': AuthLoginToken.authLoginTokenSuccess,\n\t'account.contentSettings': AccountContentSettings.accountContentSettings,\n\t'messages.inactiveChats': MessagesInactiveChats.messagesInactiveChats,\n\t'baseThemeClassic': BaseTheme.baseThemeClassic,\n\t'baseThemeDay': BaseTheme.baseThemeDay,\n\t'baseThemeNight': BaseTheme.baseThemeNight,\n\t'baseThemeTinted': BaseTheme.baseThemeTinted,\n\t'baseThemeArctic': BaseTheme.baseThemeArctic,\n\t'inputWallPaperNoFile': InputWallPaper.inputWallPaperNoFile,\n\t'wallPaperNoFile': WallPaper.wallPaperNoFile,\n\t'inputThemeSettings': InputThemeSettings.inputThemeSettings,\n\t'themeSettings': ThemeSettings.themeSettings,\n\t'webPageAttributeTheme': WebPageAttribute.webPageAttributeTheme,\n\t'updateMessagePollVote': Update.updateMessagePollVote,\n\t'messageUserVote': MessageUserVote.messageUserVote,\n\t'messageUserVoteInputOption': MessageUserVote.messageUserVoteInputOption,\n\t'messageUserVoteMultiple': MessageUserVote.messageUserVoteMultiple,\n\t'messages.votesList': MessagesVotesList.messagesVotesList,\n\t'keyboardButtonRequestPoll': KeyboardButton.keyboardButtonRequestPoll,\n\t'messageEntityBankCard': MessageEntity.messageEntityBankCard,\n\t'bankCardOpenUrl': BankCardOpenUrl.bankCardOpenUrl,\n\t'payments.bankCardData': PaymentsBankCardData.paymentsBankCardData,\n\t'peerSelfLocated': PeerLocated.peerSelfLocated,\n\t'dialogFilter': DialogFilter.dialogFilter,\n\t'dialogFilterSuggested': DialogFilterSuggested.dialogFilterSuggested,\n\t'updateDialogFilter': Update.updateDialogFilter,\n\t'updateDialogFilterOrder': Update.updateDialogFilterOrder,\n\t'updateDialogFilters': Update.updateDialogFilters,\n\t'statsDateRangeDays': StatsDateRangeDays.statsDateRangeDays,\n\t'statsAbsValueAndPrev': StatsAbsValueAndPrev.statsAbsValueAndPrev,\n\t'statsPercentValue': StatsPercentValue.statsPercentValue,\n\t'statsGraphAsync': StatsGraph.statsGraphAsync,\n\t'statsGraphError': StatsGraph.statsGraphError,\n\t'statsGraph': StatsGraph.statsGraph,\n\t'messageInteractionCounters': MessageInteractionCounters.messageInteractionCounters,\n\t'stats.broadcastStats': StatsBroadcastStats.statsBroadcastStats,\n\t'inputMediaDice': InputMedia.inputMediaDice,\n\t'messageMediaDice': MessageMedia.messageMediaDice,\n\t'inputStickerSetDice': InputStickerSet.inputStickerSetDice,\n\t'help.promoDataEmpty': HelpPromoData.helpPromoDataEmpty,\n\t'help.promoData': HelpPromoData.helpPromoData,\n\t'videoSize': VideoSize.videoSize,\n\t'updatePhoneCallSignalingData': Update.updatePhoneCallSignalingData,\n\t'chatInvitePeek': ChatInvite.chatInvitePeek,\n\t'statsGroupTopPoster': StatsGroupTopPoster.statsGroupTopPoster,\n\t'statsGroupTopAdmin': StatsGroupTopAdmin.statsGroupTopAdmin,\n\t'statsGroupTopInviter': StatsGroupTopInviter.statsGroupTopInviter,\n\t'stats.megagroupStats': StatsMegagroupStats.statsMegagroupStats,\n\t'globalPrivacySettings': GlobalPrivacySettings.globalPrivacySettings,\n\t'phoneConnectionWebrtc': PhoneConnection.phoneConnectionWebrtc,\n\t'help.countryCode': HelpCountryCode.helpCountryCode,\n\t'help.country': HelpCountry.helpCountry,\n\t'help.countriesListNotModified': HelpCountriesList.helpCountriesListNotModified,\n\t'help.countriesList': HelpCountriesList.helpCountriesList,\n\t'messageViews': MessageViews.messageViews,\n\t'updateChannelMessageForwards': Update.updateChannelMessageForwards,\n\t'photoSizeProgressive': PhotoSize.photoSizeProgressive,\n\t'messages.messageViews': MessagesMessageViews.messagesMessageViews,\n\t'updateReadChannelDiscussionInbox': Update.updateReadChannelDiscussionInbox,\n\t'updateReadChannelDiscussionOutbox': Update.updateReadChannelDiscussionOutbox,\n\t'messages.discussionMessage': MessagesDiscussionMessage.messagesDiscussionMessage,\n\t'messageReplyHeader': MessageReplyHeader.messageReplyHeader,\n\t'messageReplies': MessageReplies.messageReplies,\n\t'updatePeerBlocked': Update.updatePeerBlocked,\n\t'peerBlocked': PeerBlocked.peerBlocked,\n\t'updateChannelUserTyping': Update.updateChannelUserTyping,\n\t'inputMessageCallbackQuery': InputMessage.inputMessageCallbackQuery,\n\t'channelParticipantLeft': ChannelParticipant.channelParticipantLeft,\n\t'channelParticipantsMentions': ChannelParticipantsFilter.channelParticipantsMentions,\n\t'updatePinnedMessages': Update.updatePinnedMessages,\n\t'updatePinnedChannelMessages': Update.updatePinnedChannelMessages,\n\t'inputMessagesFilterPinned': MessagesFilter.inputMessagesFilterPinned,\n\t'stats.messageStats': StatsMessageStats.statsMessageStats,\n\t'messageActionGeoProximityReached': MessageAction.messageActionGeoProximityReached,\n\t'photoPathSize': PhotoSize.photoPathSize,\n\t'speakingInGroupCallAction': SendMessageAction.speakingInGroupCallAction,\n\t'groupCallDiscarded': GroupCall.groupCallDiscarded,\n\t'groupCall': GroupCall.groupCall,\n\t'inputGroupCall': InputGroupCall.inputGroupCall,\n\t'messageActionGroupCall': MessageAction.messageActionGroupCall,\n\t'messageActionInviteToGroupCall': MessageAction.messageActionInviteToGroupCall,\n\t'groupCallParticipant': GroupCallParticipant.groupCallParticipant,\n\t'updateChat': Update.updateChat,\n\t'updateGroupCallParticipants': Update.updateGroupCallParticipants,\n\t'updateGroupCall': Update.updateGroupCall,\n\t'phone.groupCall': PhoneGroupCall.phoneGroupCall,\n\t'phone.groupParticipants': PhoneGroupParticipants.phoneGroupParticipants,\n\t'inlineQueryPeerTypeSameBotPM': InlineQueryPeerType.inlineQueryPeerTypeSameBotPM,\n\t'inlineQueryPeerTypePM': InlineQueryPeerType.inlineQueryPeerTypePM,\n\t'inlineQueryPeerTypeChat': InlineQueryPeerType.inlineQueryPeerTypeChat,\n\t'inlineQueryPeerTypeMegagroup': InlineQueryPeerType.inlineQueryPeerTypeMegagroup,\n\t'inlineQueryPeerTypeBroadcast': InlineQueryPeerType.inlineQueryPeerTypeBroadcast,\n\t'channelAdminLogEventActionStartGroupCall': ChannelAdminLogEventAction.channelAdminLogEventActionStartGroupCall,\n\t'channelAdminLogEventActionDiscardGroupCall': ChannelAdminLogEventAction.channelAdminLogEventActionDiscardGroupCall,\n\t'channelAdminLogEventActionParticipantMute': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantMute,\n\t'channelAdminLogEventActionParticipantUnmute': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantUnmute,\n\t'channelAdminLogEventActionToggleGroupCallSetting': ChannelAdminLogEventAction.channelAdminLogEventActionToggleGroupCallSetting,\n\t'inputPaymentCredentialsGooglePay': InputPaymentCredentials.inputPaymentCredentialsGooglePay,\n\t'messages.historyImport': MessagesHistoryImport.messagesHistoryImport,\n\t'sendMessageHistoryImportAction': SendMessageAction.sendMessageHistoryImportAction,\n\t'messages.historyImportParsed': MessagesHistoryImportParsed.messagesHistoryImportParsed,\n\t'inputReportReasonFake': ReportReason.inputReportReasonFake,\n\t'messages.affectedFoundMessages': MessagesAffectedFoundMessages.messagesAffectedFoundMessages,\n\t'messageActionSetMessagesTTL': MessageAction.messageActionSetMessagesTTL,\n\t'updatePeerHistoryTTL': Update.updatePeerHistoryTTL,\n\t'updateChatParticipant': Update.updateChatParticipant,\n\t'updateChannelParticipant': Update.updateChannelParticipant,\n\t'updateBotStopped': Update.updateBotStopped,\n\t'chatInviteImporter': ChatInviteImporter.chatInviteImporter,\n\t'messages.exportedChatInvites': MessagesExportedChatInvites.messagesExportedChatInvites,\n\t'messages.exportedChatInvite': MessagesExportedChatInvite.messagesExportedChatInvite,\n\t'messages.exportedChatInviteReplaced': MessagesExportedChatInvite.messagesExportedChatInviteReplaced,\n\t'messages.chatInviteImporters': MessagesChatInviteImporters.messagesChatInviteImporters,\n\t'chatAdminWithInvites': ChatAdminWithInvites.chatAdminWithInvites,\n\t'messages.chatAdminsWithInvites': MessagesChatAdminsWithInvites.messagesChatAdminsWithInvites,\n\t'channelAdminLogEventActionParticipantJoinByInvite': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantJoinByInvite,\n\t'channelAdminLogEventActionExportedInviteDelete': ChannelAdminLogEventAction.channelAdminLogEventActionExportedInviteDelete,\n\t'channelAdminLogEventActionExportedInviteRevoke': ChannelAdminLogEventAction.channelAdminLogEventActionExportedInviteRevoke,\n\t'channelAdminLogEventActionExportedInviteEdit': ChannelAdminLogEventAction.channelAdminLogEventActionExportedInviteEdit,\n\t'channelAdminLogEventActionParticipantVolume': ChannelAdminLogEventAction.channelAdminLogEventActionParticipantVolume,\n\t'channelAdminLogEventActionChangeHistoryTTL': ChannelAdminLogEventAction.channelAdminLogEventActionChangeHistoryTTL,\n\t'messages.checkedHistoryImportPeer': MessagesCheckedHistoryImportPeer.messagesCheckedHistoryImportPeer,\n\t'inputGroupCallStream': InputFileLocation.inputGroupCallStream,\n\t'phone.joinAsPeers': PhoneJoinAsPeers.phoneJoinAsPeers,\n\t'phone.exportedGroupCallInvite': PhoneExportedGroupCallInvite.phoneExportedGroupCallInvite,\n\t'inputBotInlineMessageMediaInvoice': InputBotInlineMessage.inputBotInlineMessageMediaInvoice,\n\t'botInlineMessageMediaInvoice': BotInlineMessage.botInlineMessageMediaInvoice,\n\t'messageActionGroupCallScheduled': MessageAction.messageActionGroupCallScheduled,\n\t'groupCallParticipantVideoSourceGroup': GroupCallParticipantVideoSourceGroup.groupCallParticipantVideoSourceGroup,\n\t'groupCallParticipantVideo': GroupCallParticipantVideo.groupCallParticipantVideo,\n\t'updateGroupCallConnection': Update.updateGroupCallConnection,\n\t'stickers.suggestedShortName': StickersSuggestedShortName.stickersSuggestedShortName,\n\t'botCommandScopeDefault': BotCommandScope.botCommandScopeDefault,\n\t'botCommandScopeUsers': BotCommandScope.botCommandScopeUsers,\n\t'botCommandScopeChats': BotCommandScope.botCommandScopeChats,\n\t'botCommandScopeChatAdmins': BotCommandScope.botCommandScopeChatAdmins,\n\t'botCommandScopePeer': BotCommandScope.botCommandScopePeer,\n\t'botCommandScopePeerAdmins': BotCommandScope.botCommandScopePeerAdmins,\n\t'botCommandScopePeerUser': BotCommandScope.botCommandScopePeerUser,\n\t'account.resetPasswordFailedWait': AccountResetPasswordResult.accountResetPasswordFailedWait,\n\t'account.resetPasswordRequestedWait': AccountResetPasswordResult.accountResetPasswordRequestedWait,\n\t'account.resetPasswordOk': AccountResetPasswordResult.accountResetPasswordOk,\n\t'updateBotCommands': Update.updateBotCommands,\n\t'messageEntityEmoji': MessageEntity.messageEntityEmoji,\n\t'messageEntityHighlight': MessageEntity.messageEntityHighlight,\n\t'messageEntityLinebreak': MessageEntity.messageEntityLinebreak,\n\t'messageEntityCaret': MessageEntity.messageEntityCaret,\n\t'messageActionChatLeave': MessageAction.messageActionChatLeave,\n\t'messageActionChannelDeletePhoto': MessageAction.messageActionChannelDeletePhoto,\n\t'messageActionChannelEditTitle': MessageAction.messageActionChannelEditTitle,\n\t'messageActionChannelEditPhoto': MessageAction.messageActionChannelEditPhoto,\n\t'messageActionChannelEditVideo': MessageAction.messageActionChannelEditVideo,\n\t'messageActionChatEditVideo': MessageAction.messageActionChatEditVideo,\n\t'messageActionChatAddUsers': MessageAction.messageActionChatAddUsers,\n\t'messageActionChatJoined': MessageAction.messageActionChatJoined,\n\t'messageActionChatReturn': MessageAction.messageActionChatReturn,\n\t'messageActionChatJoinedYou': MessageAction.messageActionChatJoinedYou,\n\t'messageActionChatReturnYou': MessageAction.messageActionChatReturnYou,\n\t'updateNewDiscussionMessage': Update.updateNewDiscussionMessage,\n\t'updateDeleteDiscussionMessages': Update.updateDeleteDiscussionMessages,\n\t'updateChannelReload': Update.updateChannelReload,\n}\n\nexport type InvokeAfterMsg = {\n\tmsg_id: string,\n\tquery: any\n};\n\nexport type InvokeAfterMsgs = {\n\tmsg_ids: Array<string>,\n\tquery: any\n};\n\nexport type AuthSendCode = {\n\tphone_number: string,\n\tapi_id: number,\n\tapi_hash: string,\n\tsettings: CodeSettings\n};\n\nexport type AuthSignUp = {\n\tphone_number: string,\n\tphone_code_hash: string,\n\tfirst_name: string,\n\tlast_name: string\n};\n\nexport type AuthSignIn = {\n\tphone_number: string,\n\tphone_code_hash: string,\n\tphone_code: string\n};\n\nexport type AuthLogOut = {\n\n};\n\nexport type AuthResetAuthorizations = {\n\n};\n\nexport type AuthExportAuthorization = {\n\tdc_id: number\n};\n\nexport type AuthImportAuthorization = {\n\tid: number,\n\tbytes: Uint8Array\n};\n\nexport type AuthBindTempAuthKey = {\n\tperm_auth_key_id: string,\n\tnonce: string,\n\texpires_at: number,\n\tencrypted_message: Uint8Array\n};\n\nexport type AccountRegisterDevice = {\n\tflags?: number,\n\tno_muted?: boolean,\n\ttoken_type: number,\n\ttoken: string,\n\tapp_sandbox: boolean,\n\tsecret: Uint8Array,\n\tother_uids: Array<number>\n};\n\nexport type AccountUnregisterDevice = {\n\ttoken_type: number,\n\ttoken: string,\n\tother_uids: Array<number>\n};\n\nexport type AccountUpdateNotifySettings = {\n\tpeer: InputNotifyPeer,\n\tsettings: InputPeerNotifySettings\n};\n\nexport type AccountGetNotifySettings = {\n\tpeer: InputNotifyPeer\n};\n\nexport type AccountResetNotifySettings = {\n\n};\n\nexport type AccountUpdateProfile = {\n\tflags?: number,\n\tfirst_name?: string,\n\tlast_name?: string,\n\tabout?: string\n};\n\nexport type AccountUpdateStatus = {\n\toffline: boolean\n};\n\nexport type AccountGetWallPapers = {\n\thash: number\n};\n\nexport type AccountReportPeer = {\n\tpeer: InputPeer,\n\treason: ReportReason,\n\tmessage: string\n};\n\nexport type UsersGetUsers = {\n\tid: Array<InputUser>\n};\n\nexport type UsersGetFullUser = {\n\tid: InputUser\n};\n\nexport type ContactsGetContactIDs = {\n\thash: number\n};\n\nexport type ContactsGetStatuses = {\n\n};\n\nexport type ContactsGetContacts = {\n\thash: number\n};\n\nexport type ContactsImportContacts = {\n\tcontacts: Array<InputContact>\n};\n\nexport type ContactsDeleteContacts = {\n\tid: Array<InputUser>\n};\n\nexport type ContactsDeleteByPhones = {\n\tphones: Array<string>\n};\n\nexport type ContactsBlock = {\n\tid: InputPeer\n};\n\nexport type ContactsUnblock = {\n\tid: InputPeer\n};\n\nexport type ContactsGetBlocked = {\n\toffset: number,\n\tlimit: number\n};\n\nexport type MessagesGetMessages = {\n\tid: Array<InputMessage>\n};\n\nexport type MessagesGetDialogs = {\n\tflags?: number,\n\texclude_pinned?: boolean,\n\tfolder_id?: number,\n\toffset_date: number,\n\toffset_id: number,\n\toffset_peer: InputPeer,\n\tlimit: number,\n\thash: number\n};\n\nexport type MessagesGetHistory = {\n\tpeer: InputPeer,\n\toffset_id: number,\n\toffset_date: number,\n\tadd_offset: number,\n\tlimit: number,\n\tmax_id: number,\n\tmin_id: number,\n\thash: number\n};\n\nexport type MessagesSearch = {\n\tflags?: number,\n\tpeer: InputPeer,\n\tq: string,\n\tfrom_id?: InputPeer,\n\ttop_msg_id?: number,\n\tfilter: MessagesFilter,\n\tmin_date: number,\n\tmax_date: number,\n\toffset_id: number,\n\tadd_offset: number,\n\tlimit: number,\n\tmax_id: number,\n\tmin_id: number,\n\thash: number\n};\n\nexport type MessagesReadHistory = {\n\tpeer: InputPeer,\n\tmax_id: number\n};\n\nexport type MessagesDeleteHistory = {\n\tflags?: number,\n\tjust_clear?: boolean,\n\trevoke?: boolean,\n\tpeer: InputPeer,\n\tmax_id: number\n};\n\nexport type MessagesDeleteMessages = {\n\tflags?: number,\n\trevoke?: boolean,\n\tid: Array<number>\n};\n\nexport type MessagesReceivedMessages = {\n\tmax_id: number\n};\n\nexport type MessagesSetTyping = {\n\tflags?: number,\n\tpeer: InputPeer,\n\ttop_msg_id?: number,\n\taction: SendMessageAction\n};\n\nexport type MessagesSendMessage = {\n\tflags?: number,\n\tno_webpage?: boolean,\n\tsilent?: boolean,\n\tbackground?: boolean,\n\tclear_draft?: boolean,\n\tpeer: InputPeer,\n\treply_to_msg_id?: number,\n\tmessage: string,\n\trandom_id: string,\n\treply_markup?: ReplyMarkup,\n\tentities?: Array<MessageEntity>,\n\tschedule_date?: number\n};\n\nexport type MessagesSendMedia = {\n\tflags?: number,\n\tsilent?: boolean,\n\tbackground?: boolean,\n\tclear_draft?: boolean,\n\tpeer: InputPeer,\n\treply_to_msg_id?: number,\n\tmedia: InputMedia,\n\tmessage: string,\n\trandom_id: string,\n\treply_markup?: ReplyMarkup,\n\tentities?: Array<MessageEntity>,\n\tschedule_date?: number\n};\n\nexport type MessagesForwardMessages = {\n\tflags?: number,\n\tsilent?: boolean,\n\tbackground?: boolean,\n\twith_my_score?: boolean,\n\tfrom_peer: InputPeer,\n\tid: Array<number>,\n\trandom_id: Array<string>,\n\tto_peer: InputPeer,\n\tschedule_date?: number\n};\n\nexport type MessagesReportSpam = {\n\tpeer: InputPeer\n};\n\nexport type MessagesGetPeerSettings = {\n\tpeer: InputPeer\n};\n\nexport type MessagesReport = {\n\tpeer: InputPeer,\n\tid: Array<number>,\n\treason: ReportReason,\n\tmessage: string\n};\n\nexport type MessagesGetChats = {\n\tid: Array<number>\n};\n\nexport type MessagesGetFullChat = {\n\tchat_id: number\n};\n\nexport type MessagesEditChatTitle = {\n\tchat_id: number,\n\ttitle: string\n};\n\nexport type MessagesEditChatPhoto = {\n\tchat_id: number,\n\tphoto: InputChatPhoto\n};\n\nexport type MessagesAddChatUser = {\n\tchat_id: number,\n\tuser_id: InputUser,\n\tfwd_limit: number\n};\n\nexport type MessagesDeleteChatUser = {\n\tflags?: number,\n\trevoke_history?: boolean,\n\tchat_id: number,\n\tuser_id: InputUser\n};\n\nexport type MessagesCreateChat = {\n\tusers: Array<InputUser>,\n\ttitle: string\n};\n\nexport type UpdatesGetState = {\n\n};\n\nexport type UpdatesGetDifference = {\n\tflags?: number,\n\tpts: number,\n\tpts_total_limit?: number,\n\tdate: number,\n\tqts: number\n};\n\nexport type PhotosUpdateProfilePhoto = {\n\tid: InputPhoto\n};\n\nexport type PhotosUploadProfilePhoto = {\n\tflags?: number,\n\tfile?: InputFile,\n\tvideo?: InputFile,\n\tvideo_start_ts?: number\n};\n\nexport type PhotosDeletePhotos = {\n\tid: Array<InputPhoto>\n};\n\nexport type UploadSaveFilePart = {\n\tfile_id: string,\n\tfile_part: number,\n\tbytes: Uint8Array\n};\n\nexport type UploadGetFile = {\n\tflags?: number,\n\tprecise?: boolean,\n\tcdn_supported?: boolean,\n\tlocation: InputFileLocation,\n\toffset: number,\n\tlimit: number\n};\n\nexport type HelpGetConfig = {\n\n};\n\nexport type HelpGetNearestDc = {\n\n};\n\nexport type HelpGetAppUpdate = {\n\tsource: string\n};\n\nexport type HelpGetInviteText = {\n\n};\n\nexport type PhotosGetUserPhotos = {\n\tuser_id: InputUser,\n\toffset: number,\n\tmax_id: string,\n\tlimit: number\n};\n\nexport type MessagesGetDhConfig = {\n\tversion: number,\n\trandom_length: number\n};\n\nexport type MessagesRequestEncryption = {\n\tuser_id: InputUser,\n\trandom_id: number,\n\tg_a: Uint8Array\n};\n\nexport type MessagesAcceptEncryption = {\n\tpeer: InputEncryptedChat,\n\tg_b: Uint8Array,\n\tkey_fingerprint: string\n};\n\nexport type MessagesDiscardEncryption = {\n\tflags?: number,\n\tdelete_history?: boolean,\n\tchat_id: number\n};\n\nexport type MessagesSetEncryptedTyping = {\n\tpeer: InputEncryptedChat,\n\ttyping: boolean\n};\n\nexport type MessagesReadEncryptedHistory = {\n\tpeer: InputEncryptedChat,\n\tmax_date: number\n};\n\nexport type MessagesSendEncrypted = {\n\tflags?: number,\n\tsilent?: boolean,\n\tpeer: InputEncryptedChat,\n\trandom_id: string,\n\tdata: Uint8Array\n};\n\nexport type MessagesSendEncryptedFile = {\n\tflags?: number,\n\tsilent?: boolean,\n\tpeer: InputEncryptedChat,\n\trandom_id: string,\n\tdata: Uint8Array,\n\tfile: InputEncryptedFile\n};\n\nexport type MessagesSendEncryptedService = {\n\tpeer: InputEncryptedChat,\n\trandom_id: string,\n\tdata: Uint8Array\n};\n\nexport type MessagesReceivedQueue = {\n\tmax_qts: number\n};\n\nexport type MessagesReportEncryptedSpam = {\n\tpeer: InputEncryptedChat\n};\n\nexport type UploadSaveBigFilePart = {\n\tfile_id: string,\n\tfile_part: number,\n\tfile_total_parts: number,\n\tbytes: Uint8Array\n};\n\nexport type InitConnection = {\n\tflags?: number,\n\tapi_id: number,\n\tdevice_model: string,\n\tsystem_version: string,\n\tapp_version: string,\n\tsystem_lang_code: string,\n\tlang_pack: string,\n\tlang_code: string,\n\tproxy?: InputClientProxy,\n\tparams?: JSONValue,\n\tquery: any\n};\n\nexport type HelpGetSupport = {\n\n};\n\nexport type MessagesReadMessageContents = {\n\tid: Array<number>\n};\n\nexport type AccountCheckUsername = {\n\tusername: string\n};\n\nexport type AccountUpdateUsername = {\n\tusername: string\n};\n\nexport type ContactsSearch = {\n\tq: string,\n\tlimit: number\n};\n\nexport type AccountGetPrivacy = {\n\tkey: InputPrivacyKey\n};\n\nexport type AccountSetPrivacy = {\n\tkey: InputPrivacyKey,\n\trules: Array<InputPrivacyRule>\n};\n\nexport type AccountDeleteAccount = {\n\treason: string\n};\n\nexport type AccountGetAccountTTL = {\n\n};\n\nexport type AccountSetAccountTTL = {\n\tttl: AccountDaysTTL\n};\n\nexport type InvokeWithLayer = {\n\tlayer: number,\n\tquery: any\n};\n\nexport type ContactsResolveUsername = {\n\tusername: string\n};\n\nexport type AccountSendChangePhoneCode = {\n\tphone_number: string,\n\tsettings: CodeSettings\n};\n\nexport type AccountChangePhone = {\n\tphone_number: string,\n\tphone_code_hash: string,\n\tphone_code: string\n};\n\nexport type MessagesGetStickers = {\n\temoticon: string,\n\thash: number\n};\n\nexport type MessagesGetAllStickers = {\n\thash: number\n};\n\nexport type AccountUpdateDeviceLocked = {\n\tperiod: number\n};\n\nexport type AuthImportBotAuthorization = {\n\tflags?: number,\n\tapi_id: number,\n\tapi_hash: string,\n\tbot_auth_token: string\n};\n\nexport type MessagesGetWebPagePreview = {\n\tflags?: number,\n\tmessage: string,\n\tentities?: Array<MessageEntity>\n};\n\nexport type AccountGetAuthorizations = {\n\n};\n\nexport type AccountResetAuthorization = {\n\thash: string\n};\n\nexport type AccountGetPassword = {\n\n};\n\nexport type AccountGetPasswordSettings = {\n\tpassword: InputCheckPasswordSRP\n};\n\nexport type AccountUpdatePasswordSettings = {\n\tpassword: InputCheckPasswordSRP,\n\tnew_settings: AccountPasswordInputSettings\n};\n\nexport type AuthCheckPassword = {\n\tpassword: InputCheckPasswordSRP\n};\n\nexport type AuthRequestPasswordRecovery = {\n\n};\n\nexport type AuthRecoverPassword = {\n\tflags?: number,\n\tcode: string,\n\tnew_settings?: AccountPasswordInputSettings\n};\n\nexport type InvokeWithoutUpdates = {\n\tquery: any\n};\n\nexport type MessagesExportChatInvite = {\n\tflags?: number,\n\tlegacy_revoke_permanent?: boolean,\n\tpeer: InputPeer,\n\texpire_date?: number,\n\tusage_limit?: number\n};\n\nexport type MessagesCheckChatInvite = {\n\thash: string\n};\n\nexport type MessagesImportChatInvite = {\n\thash: string\n};\n\nexport type MessagesGetStickerSet = {\n\tstickerset: InputStickerSet\n};\n\nexport type MessagesInstallStickerSet = {\n\tstickerset: InputStickerSet,\n\tarchived: boolean\n};\n\nexport type MessagesUninstallStickerSet = {\n\tstickerset: InputStickerSet\n};\n\nexport type MessagesStartBot = {\n\tbot: InputUser,\n\tpeer: InputPeer,\n\trandom_id: string,\n\tstart_param: string\n};\n\nexport type HelpGetAppChangelog = {\n\tprev_app_version: string\n};\n\nexport type MessagesGetMessagesViews = {\n\tpeer: InputPeer,\n\tid: Array<number>,\n\tincrement: boolean\n};\n\nexport type ChannelsReadHistory = {\n\tchannel: InputChannel,\n\tmax_id: number\n};\n\nexport type ChannelsDeleteMessages = {\n\tchannel: InputChannel,\n\tid: Array<number>\n};\n\nexport type ChannelsDeleteUserHistory = {\n\tchannel: InputChannel,\n\tuser_id: InputUser\n};\n\nexport type ChannelsReportSpam = {\n\tchannel: InputChannel,\n\tuser_id: InputUser,\n\tid: Array<number>\n};\n\nexport type ChannelsGetMessages = {\n\tchannel: InputChannel,\n\tid: Array<InputMessage>\n};\n\nexport type ChannelsGetParticipants = {\n\tchannel: InputChannel,\n\tfilter: ChannelParticipantsFilter,\n\toffset: number,\n\tlimit: number,\n\thash: number\n};\n\nexport type ChannelsGetParticipant = {\n\tchannel: InputChannel,\n\tparticipant: InputPeer\n};\n\nexport type ChannelsGetChannels = {\n\tid: Array<InputChannel>\n};\n\nexport type ChannelsGetFullChannel = {\n\tchannel: InputChannel\n};\n\nexport type ChannelsCreateChannel = {\n\tflags?: number,\n\tbroadcast?: boolean,\n\tmegagroup?: boolean,\n\tfor_import?: boolean,\n\ttitle: string,\n\tabout: string,\n\tgeo_point?: InputGeoPoint,\n\taddress?: string\n};\n\nexport type ChannelsEditAdmin = {\n\tchannel: InputChannel,\n\tuser_id: InputUser,\n\tadmin_rights: ChatAdminRights,\n\trank: string\n};\n\nexport type ChannelsEditTitle = {\n\tchannel: InputChannel,\n\ttitle: string\n};\n\nexport type ChannelsEditPhoto = {\n\tchannel: InputChannel,\n\tphoto: InputChatPhoto\n};\n\nexport type ChannelsCheckUsername = {\n\tchannel: InputChannel,\n\tusername: string\n};\n\nexport type ChannelsUpdateUsername = {\n\tchannel: InputChannel,\n\tusername: string\n};\n\nexport type ChannelsJoinChannel = {\n\tchannel: InputChannel\n};\n\nexport type ChannelsLeaveChannel = {\n\tchannel: InputChannel\n};\n\nexport type ChannelsInviteToChannel = {\n\tchannel: InputChannel,\n\tusers: Array<InputUser>\n};\n\nexport type ChannelsDeleteChannel = {\n\tchannel: InputChannel\n};\n\nexport type UpdatesGetChannelDifference = {\n\tflags?: number,\n\tforce?: boolean,\n\tchannel: InputChannel,\n\tfilter: ChannelMessagesFilter,\n\tpts: number,\n\tlimit: number\n};\n\nexport type MessagesEditChatAdmin = {\n\tchat_id: number,\n\tuser_id: InputUser,\n\tis_admin: boolean\n};\n\nexport type MessagesMigrateChat = {\n\tchat_id: number\n};\n\nexport type MessagesSearchGlobal = {\n\tflags?: number,\n\tfolder_id?: number,\n\tq: string,\n\tfilter: MessagesFilter,\n\tmin_date: number,\n\tmax_date: number,\n\toffset_rate: number,\n\toffset_peer: InputPeer,\n\toffset_id: number,\n\tlimit: number\n};\n\nexport type MessagesReorderStickerSets = {\n\tflags?: number,\n\tmasks?: boolean,\n\torder: Array<string>\n};\n\nexport type MessagesGetDocumentByHash = {\n\tsha256: Uint8Array,\n\tsize: number,\n\tmime_type: string\n};\n\nexport type MessagesGetSavedGifs = {\n\thash: number\n};\n\nexport type MessagesSaveGif = {\n\tid: InputDocument,\n\tunsave: boolean\n};\n\nexport type MessagesGetInlineBotResults = {\n\tflags?: number,\n\tbot: InputUser,\n\tpeer: InputPeer,\n\tgeo_point?: InputGeoPoint,\n\tquery: string,\n\toffset: string\n};\n\nexport type MessagesSetInlineBotResults = {\n\tflags?: number,\n\tgallery?: boolean,\n\tprivate?: boolean,\n\tquery_id: string,\n\tresults: Array<InputBotInlineResult>,\n\tcache_time: number,\n\tnext_offset?: string,\n\tswitch_pm?: InlineBotSwitchPM\n};\n\nexport type MessagesSendInlineBotResult = {\n\tflags?: number,\n\tsilent?: boolean,\n\tbackground?: boolean,\n\tclear_draft?: boolean,\n\thide_via?: boolean,\n\tpeer: InputPeer,\n\treply_to_msg_id?: number,\n\trandom_id: string,\n\tquery_id: string,\n\tid: string,\n\tschedule_date?: number\n};\n\nexport type ChannelsExportMessageLink = {\n\tflags?: number,\n\tgrouped?: boolean,\n\tthread?: boolean,\n\tchannel: InputChannel,\n\tid: number\n};\n\nexport type ChannelsToggleSignatures = {\n\tchannel: InputChannel,\n\tenabled: boolean\n};\n\nexport type AuthResendCode = {\n\tphone_number: string,\n\tphone_code_hash: string\n};\n\nexport type AuthCancelCode = {\n\tphone_number: string,\n\tphone_code_hash: string\n};\n\nexport type MessagesGetMessageEditData = {\n\tpeer: InputPeer,\n\tid: number\n};\n\nexport type MessagesEditMessage = {\n\tflags?: number,\n\tno_webpage?: boolean,\n\tpeer: InputPeer,\n\tid: number,\n\tmessage?: string,\n\tmedia?: InputMedia,\n\treply_markup?: ReplyMarkup,\n\tentities?: Array<MessageEntity>,\n\tschedule_date?: number\n};\n\nexport type MessagesEditInlineBotMessage = {\n\tflags?: number,\n\tno_webpage?: boolean,\n\tid: InputBotInlineMessageID,\n\tmessage?: string,\n\tmedia?: InputMedia,\n\treply_markup?: ReplyMarkup,\n\tentities?: Array<MessageEntity>\n};\n\nexport type MessagesGetBotCallbackAnswer = {\n\tflags?: number,\n\tgame?: boolean,\n\tpeer: InputPeer,\n\tmsg_id: number,\n\tdata?: Uint8Array,\n\tpassword?: InputCheckPasswordSRP\n};\n\nexport type MessagesSetBotCallbackAnswer = {\n\tflags?: number,\n\talert?: boolean,\n\tquery_id: string,\n\tmessage?: string,\n\turl?: string,\n\tcache_time: number\n};\n\nexport type ContactsGetTopPeers = {\n\tflags?: number,\n\tcorrespondents?: boolean,\n\tbots_pm?: boolean,\n\tbots_inline?: boolean,\n\tphone_calls?: boolean,\n\tforward_users?: boolean,\n\tforward_chats?: boolean,\n\tgroups?: boolean,\n\tchannels?: boolean,\n\toffset: number,\n\tlimit: number,\n\thash: number\n};\n\nexport type ContactsResetTopPeerRating = {\n\tcategory: TopPeerCategory,\n\tpeer: InputPeer\n};\n\nexport type MessagesGetPeerDialogs = {\n\tpeers: Array<InputDialogPeer>\n};\n\nexport type MessagesSaveDraft = {\n\tflags?: number,\n\tno_webpage?: boolean,\n\treply_to_msg_id?: number,\n\tpeer: InputPeer,\n\tmessage: string,\n\tentities?: Array<MessageEntity>\n};\n\nexport type MessagesGetAllDrafts = {\n\n};\n\nexport type MessagesGetFeaturedStickers = {\n\thash: number\n};\n\nexport type MessagesReadFeaturedStickers = {\n\tid: Array<string>\n};\n\nexport type MessagesGetRecentStickers = {\n\tflags?: number,\n\tattached?: boolean,\n\thash: number\n};\n\nexport type MessagesSaveRecentSticker = {\n\tflags?: number,\n\tattached?: boolean,\n\tid: InputDocument,\n\tunsave: boolean\n};\n\nexport type MessagesClearRecentStickers = {\n\tflags?: number,\n\tattached?: boolean\n};\n\nexport type MessagesGetArchivedStickers = {\n\tflags?: number,\n\tmasks?: boolean,\n\toffset_id: string,\n\tlimit: number\n};\n\nexport type AccountSendConfirmPhoneCode = {\n\thash: string,\n\tsettings: CodeSettings\n};\n\nexport type AccountConfirmPhone = {\n\tphone_code_hash: string,\n\tphone_code: string\n};\n\nexport type ChannelsGetAdminedPublicChannels = {\n\tflags?: number,\n\tby_location?: boolean,\n\tcheck_limit?: boolean\n};\n\nexport type MessagesGetMaskStickers = {\n\thash: number\n};\n\nexport type MessagesGetAttachedStickers = {\n\tmedia: InputStickeredMedia\n};\n\nexport type AuthDropTempAuthKeys = {\n\texcept_auth_keys: Array<string>\n};\n\nexport type MessagesSetGameScore = {\n\tflags?: number,\n\tedit_message?: boolean,\n\tforce?: boolean,\n\tpeer: InputPeer,\n\tid: number,\n\tuser_id: InputUser,\n\tscore: number\n};\n\nexport type MessagesSetInlineGameScore = {\n\tflags?: number,\n\tedit_message?: boolean,\n\tforce?: boolean,\n\tid: InputBotInlineMessageID,\n\tuser_id: InputUser,\n\tscore: number\n};\n\nexport type MessagesGetGameHighScores = {\n\tpeer: InputPeer,\n\tid: number,\n\tuser_id: InputUser\n};\n\nexport type MessagesGetInlineGameHighScores = {\n\tid: InputBotInlineMessageID,\n\tuser_id: InputUser\n};\n\nexport type MessagesGetCommonChats = {\n\tuser_id: InputUser,\n\tmax_id: number,\n\tlimit: number\n};\n\nexport type MessagesGetAllChats = {\n\texcept_ids: Array<number>\n};\n\nexport type HelpSetBotUpdatesStatus = {\n\tpending_updates_count: number,\n\tmessage: string\n};\n\nexport type MessagesGetWebPage = {\n\turl: string,\n\thash: number\n};\n\nexport type MessagesToggleDialogPin = {\n\tflags?: number,\n\tpinned?: boolean,\n\tpeer: InputDialogPeer\n};\n\nexport type MessagesReorderPinnedDialogs = {\n\tflags?: number,\n\tforce?: boolean,\n\tfolder_id: number,\n\torder: Array<InputDialogPeer>\n};\n\nexport type MessagesGetPinnedDialogs = {\n\tfolder_id: number\n};\n\nexport type BotsSendCustomRequest = {\n\tcustom_method: string,\n\tparams: DataJSON\n};\n\nexport type BotsAnswerWebhookJSONQuery = {\n\tquery_id: string,\n\tdata: DataJSON\n};\n\nexport type UploadGetWebFile = {\n\tlocation: InputWebFileLocation,\n\toffset: number,\n\tlimit: number\n};\n\nexport type PaymentsGetPaymentForm = {\n\tflags?: number,\n\tpeer: InputPeer,\n\tmsg_id: number,\n\ttheme_params?: DataJSON\n};\n\nexport type PaymentsGetPaymentReceipt = {\n\tpeer: InputPeer,\n\tmsg_id: number\n};\n\nexport type PaymentsValidateRequestedInfo = {\n\tflags?: number,\n\tsave?: boolean,\n\tpeer: InputPeer,\n\tmsg_id: number,\n\tinfo: PaymentRequestedInfo\n};\n\nexport type PaymentsSendPaymentForm = {\n\tflags?: number,\n\tform_id: string,\n\tpeer: InputPeer,\n\tmsg_id: number,\n\trequested_info_id?: string,\n\tshipping_option_id?: string,\n\tcredentials: InputPaymentCredentials,\n\ttip_amount?: string\n};\n\nexport type AccountGetTmpPassword = {\n\tpassword: InputCheckPasswordSRP,\n\tperiod: number\n};\n\nexport type PaymentsGetSavedInfo = {\n\n};\n\nexport type PaymentsClearSavedInfo = {\n\tflags?: number,\n\tcredentials?: boolean,\n\tinfo?: boolean\n};\n\nexport type MessagesSetBotShippingResults = {\n\tflags?: number,\n\tquery_id: string,\n\terror?: string,\n\tshipping_options?: Array<ShippingOption>\n};\n\nexport type MessagesSetBotPrecheckoutResults = {\n\tflags?: number,\n\tsuccess?: boolean,\n\tquery_id: string,\n\terror?: string\n};\n\nexport type StickersCreateStickerSet = {\n\tflags?: number,\n\tmasks?: boolean,\n\tanimated?: boolean,\n\tuser_id: InputUser,\n\ttitle: string,\n\tshort_name: string,\n\tthumb?: InputDocument,\n\tstickers: Array<InputStickerSetItem>,\n\tsoftware?: string\n};\n\nexport type StickersRemoveStickerFromSet = {\n\tsticker: InputDocument\n};\n\nexport type StickersChangeStickerPosition = {\n\tsticker: InputDocument,\n\tposition: number\n};\n\nexport type StickersAddStickerToSet = {\n\tstickerset: InputStickerSet,\n\tsticker: InputStickerSetItem\n};\n\nexport type MessagesUploadMedia = {\n\tpeer: InputPeer,\n\tmedia: InputMedia\n};\n\nexport type PhoneGetCallConfig = {\n\n};\n\nexport type PhoneRequestCall = {\n\tflags?: number,\n\tvideo?: boolean,\n\tuser_id: InputUser,\n\trandom_id: number,\n\tg_a_hash: Uint8Array,\n\tprotocol: PhoneCallProtocol\n};\n\nexport type PhoneAcceptCall = {\n\tpeer: InputPhoneCall,\n\tg_b: Uint8Array,\n\tprotocol: PhoneCallProtocol\n};\n\nexport type PhoneConfirmCall = {\n\tpeer: InputPhoneCall,\n\tg_a: Uint8Array,\n\tkey_fingerprint: string,\n\tprotocol: PhoneCallProtocol\n};\n\nexport type PhoneReceivedCall = {\n\tpeer: InputPhoneCall\n};\n\nexport type PhoneDiscardCall = {\n\tflags?: number,\n\tvideo?: boolean,\n\tpeer: InputPhoneCall,\n\tduration: number,\n\treason: PhoneCallDiscardReason,\n\tconnection_id: string\n};\n\nexport type PhoneSetCallRating = {\n\tflags?: number,\n\tuser_initiative?: boolean,\n\tpeer: InputPhoneCall,\n\trating: number,\n\tcomment: string\n};\n\nexport type PhoneSaveCallDebug = {\n\tpeer: InputPhoneCall,\n\tdebug: DataJSON\n};\n\nexport type UploadGetCdnFile = {\n\tfile_token: Uint8Array,\n\toffset: number,\n\tlimit: number\n};\n\nexport type UploadReuploadCdnFile = {\n\tfile_token: Uint8Array,\n\trequest_token: Uint8Array\n};\n\nexport type HelpGetCdnConfig = {\n\n};\n\nexport type LangpackGetLangPack = {\n\tlang_pack: string,\n\tlang_code: string\n};\n\nexport type LangpackGetStrings = {\n\tlang_pack: string,\n\tlang_code: string,\n\tkeys: Array<string>\n};\n\nexport type LangpackGetDifference = {\n\tlang_pack: string,\n\tlang_code: string,\n\tfrom_version: number\n};\n\nexport type LangpackGetLanguages = {\n\tlang_pack: string\n};\n\nexport type ChannelsEditBanned = {\n\tchannel: InputChannel,\n\tparticipant: InputPeer,\n\tbanned_rights: ChatBannedRights\n};\n\nexport type ChannelsGetAdminLog = {\n\tflags?: number,\n\tchannel: InputChannel,\n\tq: string,\n\tevents_filter?: ChannelAdminLogEventsFilter,\n\tadmins?: Array<InputUser>,\n\tmax_id: string,\n\tmin_id: string,\n\tlimit: number\n};\n\nexport type UploadGetCdnFileHashes = {\n\tfile_token: Uint8Array,\n\toffset: number\n};\n\nexport type MessagesSendScreenshotNotification = {\n\tpeer: InputPeer,\n\treply_to_msg_id: number,\n\trandom_id: string\n};\n\nexport type ChannelsSetStickers = {\n\tchannel: InputChannel,\n\tstickerset: InputStickerSet\n};\n\nexport type MessagesGetFavedStickers = {\n\thash: number\n};\n\nexport type MessagesFaveSticker = {\n\tid: InputDocument,\n\tunfave: boolean\n};\n\nexport type ChannelsReadMessageContents = {\n\tchannel: InputChannel,\n\tid: Array<number>\n};\n\nexport type ContactsResetSaved = {\n\n};\n\nexport type MessagesGetUnreadMentions = {\n\tpeer: InputPeer,\n\toffset_id: number,\n\tadd_offset: number,\n\tlimit: number,\n\tmax_id: number,\n\tmin_id: number\n};\n\nexport type ChannelsDeleteHistory = {\n\tchannel: InputChannel,\n\tmax_id: number\n};\n\nexport type HelpGetRecentMeUrls = {\n\treferer: string\n};\n\nexport type ChannelsTogglePreHistoryHidden = {\n\tchannel: InputChannel,\n\tenabled: boolean\n};\n\nexport type MessagesReadMentions = {\n\tpeer: InputPeer\n};\n\nexport type MessagesGetRecentLocations = {\n\tpeer: InputPeer,\n\tlimit: number,\n\thash: number\n};\n\nexport type MessagesSendMultiMedia = {\n\tflags?: number,\n\tsilent?: boolean,\n\tbackground?: boolean,\n\tclear_draft?: boolean,\n\tpeer: InputPeer,\n\treply_to_msg_id?: number,\n\tmulti_media: Array<InputSingleMedia>,\n\tschedule_date?: number\n};\n\nexport type MessagesUploadEncryptedFile = {\n\tpeer: InputEncryptedChat,\n\tfile: InputEncryptedFile\n};\n\nexport type AccountGetWebAuthorizations = {\n\n};\n\nexport type AccountResetWebAuthorization = {\n\thash: string\n};\n\nexport type AccountResetWebAuthorizations = {\n\n};\n\nexport type MessagesSearchStickerSets = {\n\tflags?: number,\n\texclude_featured?: boolean,\n\tq: string,\n\thash: number\n};\n\nexport type UploadGetFileHashes = {\n\tlocation: InputFileLocation,\n\toffset: number\n};\n\nexport type HelpGetTermsOfServiceUpdate = {\n\n};\n\nexport type HelpAcceptTermsOfService = {\n\tid: DataJSON\n};\n\nexport type AccountGetAllSecureValues = {\n\n};\n\nexport type AccountGetSecureValue = {\n\ttypes: Array<SecureValueType>\n};\n\nexport type AccountSaveSecureValue = {\n\tvalue: InputSecureValue,\n\tsecure_secret_id: string\n};\n\nexport type AccountDeleteSecureValue = {\n\ttypes: Array<SecureValueType>\n};\n\nexport type UsersSetSecureValueErrors = {\n\tid: InputUser,\n\terrors: Array<SecureValueError>\n};\n\nexport type AccountGetAuthorizationForm = {\n\tbot_id: number,\n\tscope: string,\n\tpublic_key: string\n};\n\nexport type AccountAcceptAuthorization = {\n\tbot_id: number,\n\tscope: string,\n\tpublic_key: string,\n\tvalue_hashes: Array<SecureValueHash>,\n\tcredentials: SecureCredentialsEncrypted\n};\n\nexport type AccountSendVerifyPhoneCode = {\n\tphone_number: string,\n\tsettings: CodeSettings\n};\n\nexport type AccountVerifyPhone = {\n\tphone_number: string,\n\tphone_code_hash: string,\n\tphone_code: string\n};\n\nexport type AccountSendVerifyEmailCode = {\n\temail: string\n};\n\nexport type AccountVerifyEmail = {\n\temail: string,\n\tcode: string\n};\n\nexport type HelpGetDeepLinkInfo = {\n\tpath: string\n};\n\nexport type ContactsGetSaved = {\n\n};\n\nexport type ChannelsGetLeftChannels = {\n\toffset: number\n};\n\nexport type AccountInitTakeoutSession = {\n\tflags?: number,\n\tcontacts?: boolean,\n\tmessage_users?: boolean,\n\tmessage_chats?: boolean,\n\tmessage_megagroups?: boolean,\n\tmessage_channels?: boolean,\n\tfiles?: boolean,\n\tfile_max_size?: number\n};\n\nexport type AccountFinishTakeoutSession = {\n\tflags?: number,\n\tsuccess?: boolean\n};\n\nexport type MessagesGetSplitRanges = {\n\n};\n\nexport type InvokeWithMessagesRange = {\n\trange: MessageRange,\n\tquery: any\n};\n\nexport type InvokeWithTakeout = {\n\ttakeout_id: string,\n\tquery: any\n};\n\nexport type MessagesMarkDialogUnread = {\n\tflags?: number,\n\tunread?: boolean,\n\tpeer: InputDialogPeer\n};\n\nexport type MessagesGetDialogUnreadMarks = {\n\n};\n\nexport type ContactsToggleTopPeers = {\n\tenabled: boolean\n};\n\nexport type MessagesClearAllDrafts = {\n\n};\n\nexport type HelpGetAppConfig = {\n\n};\n\nexport type HelpSaveAppLog = {\n\tevents: Array<InputAppEvent>\n};\n\nexport type HelpGetPassportConfig = {\n\thash: number\n};\n\nexport type LangpackGetLanguage = {\n\tlang_pack: string,\n\tlang_code: string\n};\n\nexport type MessagesUpdatePinnedMessage = {\n\tflags?: number,\n\tsilent?: boolean,\n\tunpin?: boolean,\n\tpm_oneside?: boolean,\n\tpeer: InputPeer,\n\tid: number\n};\n\nexport type AccountConfirmPasswordEmail = {\n\tcode: string\n};\n\nexport type AccountResendPasswordEmail = {\n\n};\n\nexport type AccountCancelPasswordEmail = {\n\n};\n\nexport type HelpGetSupportName = {\n\n};\n\nexport type HelpGetUserInfo = {\n\tuser_id: InputUser\n};\n\nexport type HelpEditUserInfo = {\n\tuser_id: InputUser,\n\tmessage: string,\n\tentities: Array<MessageEntity>\n};\n\nexport type AccountGetContactSignUpNotification = {\n\n};\n\nexport type AccountSetContactSignUpNotification = {\n\tsilent: boolean\n};\n\nexport type AccountGetNotifyExceptions = {\n\tflags?: number,\n\tcompare_sound?: boolean,\n\tpeer?: InputNotifyPeer\n};\n\nexport type MessagesSendVote = {\n\tpeer: InputPeer,\n\tmsg_id: number,\n\toptions: Array<Uint8Array>\n};\n\nexport type MessagesGetPollResults = {\n\tpeer: InputPeer,\n\tmsg_id: number\n};\n\nexport type MessagesGetOnlines = {\n\tpeer: InputPeer\n};\n\nexport type MessagesGetStatsURL = {\n\tflags?: number,\n\tdark?: boolean,\n\tpeer: InputPeer,\n\tparams: string\n};\n\nexport type MessagesEditChatAbout = {\n\tpeer: InputPeer,\n\tabout: string\n};\n\nexport type MessagesEditChatDefaultBannedRights = {\n\tpeer: InputPeer,\n\tbanned_rights: ChatBannedRights\n};\n\nexport type AccountGetWallPaper = {\n\twallpaper: InputWallPaper\n};\n\nexport type AccountUploadWallPaper = {\n\tfile: InputFile,\n\tmime_type: string,\n\tsettings: WallPaperSettings\n};\n\nexport type AccountSaveWallPaper = {\n\twallpaper: InputWallPaper,\n\tunsave: boolean,\n\tsettings: WallPaperSettings\n};\n\nexport type AccountInstallWallPaper = {\n\twallpaper: InputWallPaper,\n\tsettings: WallPaperSettings\n};\n\nexport type AccountResetWallPapers = {\n\n};\n\nexport type AccountGetAutoDownloadSettings = {\n\n};\n\nexport type AccountSaveAutoDownloadSettings = {\n\tflags?: number,\n\tlow?: boolean,\n\thigh?: boolean,\n\tsettings: AutoDownloadSettings\n};\n\nexport type MessagesGetEmojiKeywords = {\n\tlang_code: string\n};\n\nexport type MessagesGetEmojiKeywordsDifference = {\n\tlang_code: string,\n\tfrom_version: number\n};\n\nexport type MessagesGetEmojiKeywordsLanguages = {\n\tlang_codes: Array<string>\n};\n\nexport type MessagesGetEmojiURL = {\n\tlang_code: string\n};\n\nexport type FoldersEditPeerFolders = {\n\tfolder_peers: Array<InputFolderPeer>\n};\n\nexport type FoldersDeleteFolder = {\n\tfolder_id: number\n};\n\nexport type MessagesGetSearchCounters = {\n\tpeer: InputPeer,\n\tfilters: Array<MessagesFilter>\n};\n\nexport type ChannelsGetGroupsForDiscussion = {\n\n};\n\nexport type ChannelsSetDiscussionGroup = {\n\tbroadcast: InputChannel,\n\tgroup: InputChannel\n};\n\nexport type MessagesRequestUrlAuth = {\n\tflags?: number,\n\tpeer?: InputPeer,\n\tmsg_id?: number,\n\tbutton_id?: number,\n\turl?: string\n};\n\nexport type MessagesAcceptUrlAuth = {\n\tflags?: number,\n\twrite_allowed?: boolean,\n\tpeer?: InputPeer,\n\tmsg_id?: number,\n\tbutton_id?: number,\n\turl?: string\n};\n\nexport type MessagesHidePeerSettingsBar = {\n\tpeer: InputPeer\n};\n\nexport type ContactsAddContact = {\n\tflags?: number,\n\tadd_phone_privacy_exception?: boolean,\n\tid: InputUser,\n\tfirst_name: string,\n\tlast_name: string,\n\tphone: string\n};\n\nexport type ContactsAcceptContact = {\n\tid: InputUser\n};\n\nexport type ChannelsEditCreator = {\n\tchannel: InputChannel,\n\tuser_id: InputUser,\n\tpassword: InputCheckPasswordSRP\n};\n\nexport type ContactsGetLocated = {\n\tflags?: number,\n\tbackground?: boolean,\n\tgeo_point: InputGeoPoint,\n\tself_expires?: number\n};\n\nexport type ChannelsEditLocation = {\n\tchannel: InputChannel,\n\tgeo_point: InputGeoPoint,\n\taddress: string\n};\n\nexport type ChannelsToggleSlowMode = {\n\tchannel: InputChannel,\n\tseconds: number\n};\n\nexport type MessagesGetScheduledHistory = {\n\tpeer: InputPeer,\n\thash: number\n};\n\nexport type MessagesGetScheduledMessages = {\n\tpeer: InputPeer,\n\tid: Array<number>\n};\n\nexport type MessagesSendScheduledMessages = {\n\tpeer: InputPeer,\n\tid: Array<number>\n};\n\nexport type MessagesDeleteScheduledMessages = {\n\tpeer: InputPeer,\n\tid: Array<number>\n};\n\nexport type AccountUploadTheme = {\n\tflags?: number,\n\tfile: InputFile,\n\tthumb?: InputFile,\n\tfile_name: string,\n\tmime_type: string\n};\n\nexport type AccountCreateTheme = {\n\tflags?: number,\n\tslug: string,\n\ttitle: string,\n\tdocument?: InputDocument,\n\tsettings?: InputThemeSettings\n};\n\nexport type AccountUpdateTheme = {\n\tflags?: number,\n\tformat: string,\n\ttheme: InputTheme,\n\tslug?: string,\n\ttitle?: string,\n\tdocument?: InputDocument,\n\tsettings?: InputThemeSettings\n};\n\nexport type AccountSaveTheme = {\n\ttheme: InputTheme,\n\tunsave: boolean\n};\n\nexport type AccountInstallTheme = {\n\tflags?: number,\n\tdark?: boolean,\n\tformat?: string,\n\ttheme?: InputTheme\n};\n\nexport type AccountGetTheme = {\n\tformat: string,\n\ttheme: InputTheme,\n\tdocument_id: string\n};\n\nexport type AccountGetThemes = {\n\tformat: string,\n\thash: number\n};\n\nexport type AuthExportLoginToken = {\n\tapi_id: number,\n\tapi_hash: string,\n\texcept_ids: Array<number>\n};\n\nexport type AuthImportLoginToken = {\n\ttoken: Uint8Array\n};\n\nexport type AuthAcceptLoginToken = {\n\ttoken: Uint8Array\n};\n\nexport type AccountSetContentSettings = {\n\tflags?: number,\n\tsensitive_enabled?: boolean\n};\n\nexport type AccountGetContentSettings = {\n\n};\n\nexport type ChannelsGetInactiveChannels = {\n\n};\n\nexport type AccountGetMultiWallPapers = {\n\twallpapers: Array<InputWallPaper>\n};\n\nexport type MessagesGetPollVotes = {\n\tflags?: number,\n\tpeer: InputPeer,\n\tid: number,\n\toption?: Uint8Array,\n\toffset?: string,\n\tlimit: number\n};\n\nexport type MessagesToggleStickerSets = {\n\tflags?: number,\n\tuninstall?: boolean,\n\tarchive?: boolean,\n\tunarchive?: boolean,\n\tstickersets: Array<InputStickerSet>\n};\n\nexport type PaymentsGetBankCardData = {\n\tnumber: string\n};\n\nexport type MessagesGetDialogFilters = {\n\n};\n\nexport type MessagesGetSuggestedDialogFilters = {\n\n};\n\nexport type MessagesUpdateDialogFilter = {\n\tflags?: number,\n\tid: number,\n\tfilter?: DialogFilter\n};\n\nexport type MessagesUpdateDialogFiltersOrder = {\n\torder: Array<number>\n};\n\nexport type StatsGetBroadcastStats = {\n\tflags?: number,\n\tdark?: boolean,\n\tchannel: InputChannel\n};\n\nexport type StatsLoadAsyncGraph = {\n\tflags?: number,\n\ttoken: string,\n\tx?: string\n};\n\nexport type StickersSetStickerSetThumb = {\n\tstickerset: InputStickerSet,\n\tthumb: InputDocument\n};\n\nexport type BotsSetBotCommands = {\n\tscope: BotCommandScope,\n\tlang_code: string,\n\tcommands: Array<BotCommand>\n};\n\nexport type MessagesGetOldFeaturedStickers = {\n\toffset: number,\n\tlimit: number,\n\thash: number\n};\n\nexport type HelpGetPromoData = {\n\n};\n\nexport type HelpHidePromoData = {\n\tpeer: InputPeer\n};\n\nexport type PhoneSendSignalingData = {\n\tpeer: InputPhoneCall,\n\tdata: Uint8Array\n};\n\nexport type StatsGetMegagroupStats = {\n\tflags?: number,\n\tdark?: boolean,\n\tchannel: InputChannel\n};\n\nexport type AccountGetGlobalPrivacySettings = {\n\n};\n\nexport type AccountSetGlobalPrivacySettings = {\n\tsettings: GlobalPrivacySettings\n};\n\nexport type HelpDismissSuggestion = {\n\tpeer: InputPeer,\n\tsuggestion: string\n};\n\nexport type HelpGetCountriesList = {\n\tlang_code: string,\n\thash: number\n};\n\nexport type MessagesGetReplies = {\n\tpeer: InputPeer,\n\tmsg_id: number,\n\toffset_id: number,\n\toffset_date: number,\n\tadd_offset: number,\n\tlimit: number,\n\tmax_id: number,\n\tmin_id: number,\n\thash: number\n};\n\nexport type MessagesGetDiscussionMessage = {\n\tpeer: InputPeer,\n\tmsg_id: number\n};\n\nexport type MessagesReadDiscussion = {\n\tpeer: InputPeer,\n\tmsg_id: number,\n\tread_max_id: number\n};\n\nexport type ContactsBlockFromReplies = {\n\tflags?: number,\n\tdelete_message?: boolean,\n\tdelete_history?: boolean,\n\treport_spam?: boolean,\n\tmsg_id: number\n};\n\nexport type StatsGetMessagePublicForwards = {\n\tchannel: InputChannel,\n\tmsg_id: number,\n\toffset_rate: number,\n\toffset_peer: InputPeer,\n\toffset_id: number,\n\tlimit: number\n};\n\nexport type StatsGetMessageStats = {\n\tflags?: number,\n\tdark?: boolean,\n\tchannel: InputChannel,\n\tmsg_id: number\n};\n\nexport type MessagesUnpinAllMessages = {\n\tpeer: InputPeer\n};\n\nexport type PhoneCreateGroupCall = {\n\tflags?: number,\n\tpeer: InputPeer,\n\trandom_id: number,\n\ttitle?: string,\n\tschedule_date?: number\n};\n\nexport type PhoneJoinGroupCall = {\n\tflags?: number,\n\tmuted?: boolean,\n\tvideo_stopped?: boolean,\n\tcall: InputGroupCall,\n\tjoin_as: InputPeer,\n\tinvite_hash?: string,\n\tparams: DataJSON\n};\n\nexport type PhoneLeaveGroupCall = {\n\tcall: InputGroupCall,\n\tsource: number\n};\n\nexport type PhoneInviteToGroupCall = {\n\tcall: InputGroupCall,\n\tusers: Array<InputUser>\n};\n\nexport type PhoneDiscardGroupCall = {\n\tcall: InputGroupCall\n};\n\nexport type PhoneToggleGroupCallSettings = {\n\tflags?: number,\n\treset_invite_hash?: boolean,\n\tcall: InputGroupCall,\n\tjoin_muted?: boolean\n};\n\nexport type PhoneGetGroupCall = {\n\tcall: InputGroupCall,\n\tlimit: number\n};\n\nexport type PhoneGetGroupParticipants = {\n\tcall: InputGroupCall,\n\tids: Array<InputPeer>,\n\tsources: Array<number>,\n\toffset: string,\n\tlimit: number\n};\n\nexport type PhoneCheckGroupCall = {\n\tcall: InputGroupCall,\n\tsources: Array<number>\n};\n\nexport type MessagesDeleteChat = {\n\tchat_id: number\n};\n\nexport type MessagesDeletePhoneCallHistory = {\n\tflags?: number,\n\trevoke?: boolean\n};\n\nexport type MessagesCheckHistoryImport = {\n\timport_head: string\n};\n\nexport type MessagesInitHistoryImport = {\n\tpeer: InputPeer,\n\tfile: InputFile,\n\tmedia_count: number\n};\n\nexport type MessagesUploadImportedMedia = {\n\tpeer: InputPeer,\n\timport_id: string,\n\tfile_name: string,\n\tmedia: InputMedia\n};\n\nexport type MessagesStartHistoryImport = {\n\tpeer: InputPeer,\n\timport_id: string\n};\n\nexport type MessagesGetExportedChatInvites = {\n\tflags?: number,\n\trevoked?: boolean,\n\tpeer: InputPeer,\n\tadmin_id: InputUser,\n\toffset_date?: number,\n\toffset_link?: string,\n\tlimit: number\n};\n\nexport type MessagesGetExportedChatInvite = {\n\tpeer: InputPeer,\n\tlink: string\n};\n\nexport type MessagesEditExportedChatInvite = {\n\tflags?: number,\n\trevoked?: boolean,\n\tpeer: InputPeer,\n\tlink: string,\n\texpire_date?: number,\n\tusage_limit?: number\n};\n\nexport type MessagesDeleteRevokedExportedChatInvites = {\n\tpeer: InputPeer,\n\tadmin_id: InputUser\n};\n\nexport type MessagesDeleteExportedChatInvite = {\n\tpeer: InputPeer,\n\tlink: string\n};\n\nexport type MessagesGetAdminsWithInvites = {\n\tpeer: InputPeer\n};\n\nexport type MessagesGetChatInviteImporters = {\n\tpeer: InputPeer,\n\tlink: string,\n\toffset_date: number,\n\toffset_user: InputUser,\n\tlimit: number\n};\n\nexport type MessagesSetHistoryTTL = {\n\tpeer: InputPeer,\n\tperiod: number\n};\n\nexport type AccountReportProfilePhoto = {\n\tpeer: InputPeer,\n\tphoto_id: InputPhoto,\n\treason: ReportReason,\n\tmessage: string\n};\n\nexport type ChannelsConvertToGigagroup = {\n\tchannel: InputChannel\n};\n\nexport type MessagesCheckHistoryImportPeer = {\n\tpeer: InputPeer\n};\n\nexport type PhoneToggleGroupCallRecord = {\n\tflags?: number,\n\tstart?: boolean,\n\tcall: InputGroupCall,\n\ttitle?: string\n};\n\nexport type PhoneEditGroupCallParticipant = {\n\tflags?: number,\n\tcall: InputGroupCall,\n\tparticipant: InputPeer,\n\tmuted?: boolean,\n\tvolume?: number,\n\traise_hand?: boolean,\n\tvideo_stopped?: boolean,\n\tvideo_paused?: boolean,\n\tpresentation_paused?: boolean\n};\n\nexport type PhoneEditGroupCallTitle = {\n\tcall: InputGroupCall,\n\ttitle: string\n};\n\nexport type PhoneGetGroupCallJoinAs = {\n\tpeer: InputPeer\n};\n\nexport type PhoneExportGroupCallInvite = {\n\tflags?: number,\n\tcan_self_unmute?: boolean,\n\tcall: InputGroupCall\n};\n\nexport type PhoneToggleGroupCallStartSubscription = {\n\tcall: InputGroupCall,\n\tsubscribed: boolean\n};\n\nexport type PhoneStartScheduledGroupCall = {\n\tcall: InputGroupCall\n};\n\nexport type PhoneSaveDefaultGroupCallJoinAs = {\n\tpeer: InputPeer,\n\tjoin_as: InputPeer\n};\n\nexport type PhoneJoinGroupCallPresentation = {\n\tcall: InputGroupCall,\n\tparams: DataJSON\n};\n\nexport type PhoneLeaveGroupCallPresentation = {\n\tcall: InputGroupCall\n};\n\nexport type StickersCheckShortName = {\n\tshort_name: string\n};\n\nexport type StickersSuggestShortName = {\n\ttitle: string\n};\n\nexport type BotsResetBotCommands = {\n\tscope: BotCommandScope,\n\tlang_code: string\n};\n\nexport type BotsGetBotCommands = {\n\tscope: BotCommandScope,\n\tlang_code: string\n};\n\nexport type AccountResetPassword = {\n\n};\n\nexport type AccountDeclinePasswordReset = {\n\n};\n\nexport type AuthCheckRecoveryPassword = {\n\tcode: string\n};\n\nexport interface MethodDeclMap {\n\t'invokeAfterMsg': {req: InvokeAfterMsg, res: any},\n\t'invokeAfterMsgs': {req: InvokeAfterMsgs, res: any},\n\t'auth.sendCode': {req: AuthSendCode, res: AuthSentCode},\n\t'auth.signUp': {req: AuthSignUp, res: AuthAuthorization},\n\t'auth.signIn': {req: AuthSignIn, res: AuthAuthorization},\n\t'auth.logOut': {req: AuthLogOut, res: boolean},\n\t'auth.resetAuthorizations': {req: AuthResetAuthorizations, res: boolean},\n\t'auth.exportAuthorization': {req: AuthExportAuthorization, res: AuthExportedAuthorization},\n\t'auth.importAuthorization': {req: AuthImportAuthorization, res: AuthAuthorization},\n\t'auth.bindTempAuthKey': {req: AuthBindTempAuthKey, res: boolean},\n\t'account.registerDevice': {req: AccountRegisterDevice, res: boolean},\n\t'account.unregisterDevice': {req: AccountUnregisterDevice, res: boolean},\n\t'account.updateNotifySettings': {req: AccountUpdateNotifySettings, res: boolean},\n\t'account.getNotifySettings': {req: AccountGetNotifySettings, res: PeerNotifySettings},\n\t'account.resetNotifySettings': {req: AccountResetNotifySettings, res: boolean},\n\t'account.updateProfile': {req: AccountUpdateProfile, res: User},\n\t'account.updateStatus': {req: AccountUpdateStatus, res: boolean},\n\t'account.getWallPapers': {req: AccountGetWallPapers, res: AccountWallPapers},\n\t'account.reportPeer': {req: AccountReportPeer, res: boolean},\n\t'users.getUsers': {req: UsersGetUsers, res: Array<User>},\n\t'users.getFullUser': {req: UsersGetFullUser, res: UserFull},\n\t'contacts.getContactIDs': {req: ContactsGetContactIDs, res: Array<number>},\n\t'contacts.getStatuses': {req: ContactsGetStatuses, res: Array<ContactStatus>},\n\t'contacts.getContacts': {req: ContactsGetContacts, res: ContactsContacts},\n\t'contacts.importContacts': {req: ContactsImportContacts, res: ContactsImportedContacts},\n\t'contacts.deleteContacts': {req: ContactsDeleteContacts, res: Updates},\n\t'contacts.deleteByPhones': {req: ContactsDeleteByPhones, res: boolean},\n\t'contacts.block': {req: ContactsBlock, res: boolean},\n\t'contacts.unblock': {req: ContactsUnblock, res: boolean},\n\t'contacts.getBlocked': {req: ContactsGetBlocked, res: ContactsBlocked},\n\t'messages.getMessages': {req: MessagesGetMessages, res: MessagesMessages},\n\t'messages.getDialogs': {req: MessagesGetDialogs, res: MessagesDialogs},\n\t'messages.getHistory': {req: MessagesGetHistory, res: MessagesMessages},\n\t'messages.search': {req: MessagesSearch, res: MessagesMessages},\n\t'messages.readHistory': {req: MessagesReadHistory, res: MessagesAffectedMessages},\n\t'messages.deleteHistory': {req: MessagesDeleteHistory, res: MessagesAffectedHistory},\n\t'messages.deleteMessages': {req: MessagesDeleteMessages, res: MessagesAffectedMessages},\n\t'messages.receivedMessages': {req: MessagesReceivedMessages, res: Array<ReceivedNotifyMessage>},\n\t'messages.setTyping': {req: MessagesSetTyping, res: boolean},\n\t'messages.sendMessage': {req: MessagesSendMessage, res: Updates},\n\t'messages.sendMedia': {req: MessagesSendMedia, res: Updates},\n\t'messages.forwardMessages': {req: MessagesForwardMessages, res: Updates},\n\t'messages.reportSpam': {req: MessagesReportSpam, res: boolean},\n\t'messages.getPeerSettings': {req: MessagesGetPeerSettings, res: PeerSettings},\n\t'messages.report': {req: MessagesReport, res: boolean},\n\t'messages.getChats': {req: MessagesGetChats, res: MessagesChats},\n\t'messages.getFullChat': {req: MessagesGetFullChat, res: MessagesChatFull},\n\t'messages.editChatTitle': {req: MessagesEditChatTitle, res: Updates},\n\t'messages.editChatPhoto': {req: MessagesEditChatPhoto, res: Updates},\n\t'messages.addChatUser': {req: MessagesAddChatUser, res: Updates},\n\t'messages.deleteChatUser': {req: MessagesDeleteChatUser, res: Updates},\n\t'messages.createChat': {req: MessagesCreateChat, res: Updates},\n\t'updates.getState': {req: UpdatesGetState, res: UpdatesState},\n\t'updates.getDifference': {req: UpdatesGetDifference, res: UpdatesDifference},\n\t'photos.updateProfilePhoto': {req: PhotosUpdateProfilePhoto, res: PhotosPhoto},\n\t'photos.uploadProfilePhoto': {req: PhotosUploadProfilePhoto, res: PhotosPhoto},\n\t'photos.deletePhotos': {req: PhotosDeletePhotos, res: Array<string>},\n\t'upload.saveFilePart': {req: UploadSaveFilePart, res: boolean},\n\t'upload.getFile': {req: UploadGetFile, res: UploadFile},\n\t'help.getConfig': {req: HelpGetConfig, res: Config},\n\t'help.getNearestDc': {req: HelpGetNearestDc, res: NearestDc},\n\t'help.getAppUpdate': {req: HelpGetAppUpdate, res: HelpAppUpdate},\n\t'help.getInviteText': {req: HelpGetInviteText, res: HelpInviteText},\n\t'photos.getUserPhotos': {req: PhotosGetUserPhotos, res: PhotosPhotos},\n\t'messages.getDhConfig': {req: MessagesGetDhConfig, res: MessagesDhConfig},\n\t'messages.requestEncryption': {req: MessagesRequestEncryption, res: EncryptedChat},\n\t'messages.acceptEncryption': {req: MessagesAcceptEncryption, res: EncryptedChat},\n\t'messages.discardEncryption': {req: MessagesDiscardEncryption, res: boolean},\n\t'messages.setEncryptedTyping': {req: MessagesSetEncryptedTyping, res: boolean},\n\t'messages.readEncryptedHistory': {req: MessagesReadEncryptedHistory, res: boolean},\n\t'messages.sendEncrypted': {req: MessagesSendEncrypted, res: MessagesSentEncryptedMessage},\n\t'messages.sendEncryptedFile': {req: MessagesSendEncryptedFile, res: MessagesSentEncryptedMessage},\n\t'messages.sendEncryptedService': {req: MessagesSendEncryptedService, res: MessagesSentEncryptedMessage},\n\t'messages.receivedQueue': {req: MessagesReceivedQueue, res: Array<string>},\n\t'messages.reportEncryptedSpam': {req: MessagesReportEncryptedSpam, res: boolean},\n\t'upload.saveBigFilePart': {req: UploadSaveBigFilePart, res: boolean},\n\t'initConnection': {req: InitConnection, res: any},\n\t'help.getSupport': {req: HelpGetSupport, res: HelpSupport},\n\t'messages.readMessageContents': {req: MessagesReadMessageContents, res: MessagesAffectedMessages},\n\t'account.checkUsername': {req: AccountCheckUsername, res: boolean},\n\t'account.updateUsername': {req: AccountUpdateUsername, res: User},\n\t'contacts.search': {req: ContactsSearch, res: ContactsFound},\n\t'account.getPrivacy': {req: AccountGetPrivacy, res: AccountPrivacyRules},\n\t'account.setPrivacy': {req: AccountSetPrivacy, res: AccountPrivacyRules},\n\t'account.deleteAccount': {req: AccountDeleteAccount, res: boolean},\n\t'account.getAccountTTL': {req: AccountGetAccountTTL, res: AccountDaysTTL},\n\t'account.setAccountTTL': {req: AccountSetAccountTTL, res: boolean},\n\t'invokeWithLayer': {req: InvokeWithLayer, res: any},\n\t'contacts.resolveUsername': {req: ContactsResolveUsername, res: ContactsResolvedPeer},\n\t'account.sendChangePhoneCode': {req: AccountSendChangePhoneCode, res: AuthSentCode},\n\t'account.changePhone': {req: AccountChangePhone, res: User},\n\t'messages.getStickers': {req: MessagesGetStickers, res: MessagesStickers},\n\t'messages.getAllStickers': {req: MessagesGetAllStickers, res: MessagesAllStickers},\n\t'account.updateDeviceLocked': {req: AccountUpdateDeviceLocked, res: boolean},\n\t'auth.importBotAuthorization': {req: AuthImportBotAuthorization, res: AuthAuthorization},\n\t'messages.getWebPagePreview': {req: MessagesGetWebPagePreview, res: MessageMedia},\n\t'account.getAuthorizations': {req: AccountGetAuthorizations, res: AccountAuthorizations},\n\t'account.resetAuthorization': {req: AccountResetAuthorization, res: boolean},\n\t'account.getPassword': {req: AccountGetPassword, res: AccountPassword},\n\t'account.getPasswordSettings': {req: AccountGetPasswordSettings, res: AccountPasswordSettings},\n\t'account.updatePasswordSettings': {req: AccountUpdatePasswordSettings, res: boolean},\n\t'auth.checkPassword': {req: AuthCheckPassword, res: AuthAuthorization},\n\t'auth.requestPasswordRecovery': {req: AuthRequestPasswordRecovery, res: AuthPasswordRecovery},\n\t'auth.recoverPassword': {req: AuthRecoverPassword, res: AuthAuthorization},\n\t'invokeWithoutUpdates': {req: InvokeWithoutUpdates, res: any},\n\t'messages.exportChatInvite': {req: MessagesExportChatInvite, res: ExportedChatInvite},\n\t'messages.checkChatInvite': {req: MessagesCheckChatInvite, res: ChatInvite},\n\t'messages.importChatInvite': {req: MessagesImportChatInvite, res: Updates},\n\t'messages.getStickerSet': {req: MessagesGetStickerSet, res: MessagesStickerSet},\n\t'messages.installStickerSet': {req: MessagesInstallStickerSet, res: MessagesStickerSetInstallResult},\n\t'messages.uninstallStickerSet': {req: MessagesUninstallStickerSet, res: boolean},\n\t'messages.startBot': {req: MessagesStartBot, res: Updates},\n\t'help.getAppChangelog': {req: HelpGetAppChangelog, res: Updates},\n\t'messages.getMessagesViews': {req: MessagesGetMessagesViews, res: MessagesMessageViews},\n\t'channels.readHistory': {req: ChannelsReadHistory, res: boolean},\n\t'channels.deleteMessages': {req: ChannelsDeleteMessages, res: MessagesAffectedMessages},\n\t'channels.deleteUserHistory': {req: ChannelsDeleteUserHistory, res: MessagesAffectedHistory},\n\t'channels.reportSpam': {req: ChannelsReportSpam, res: boolean},\n\t'channels.getMessages': {req: ChannelsGetMessages, res: MessagesMessages},\n\t'channels.getParticipants': {req: ChannelsGetParticipants, res: ChannelsChannelParticipants},\n\t'channels.getParticipant': {req: ChannelsGetParticipant, res: ChannelsChannelParticipant},\n\t'channels.getChannels': {req: ChannelsGetChannels, res: MessagesChats},\n\t'channels.getFullChannel': {req: ChannelsGetFullChannel, res: MessagesChatFull},\n\t'channels.createChannel': {req: ChannelsCreateChannel, res: Updates},\n\t'channels.editAdmin': {req: ChannelsEditAdmin, res: Updates},\n\t'channels.editTitle': {req: ChannelsEditTitle, res: Updates},\n\t'channels.editPhoto': {req: ChannelsEditPhoto, res: Updates},\n\t'channels.checkUsername': {req: ChannelsCheckUsername, res: boolean},\n\t'channels.updateUsername': {req: ChannelsUpdateUsername, res: boolean},\n\t'channels.joinChannel': {req: ChannelsJoinChannel, res: Updates},\n\t'channels.leaveChannel': {req: ChannelsLeaveChannel, res: Updates},\n\t'channels.inviteToChannel': {req: ChannelsInviteToChannel, res: Updates},\n\t'channels.deleteChannel': {req: ChannelsDeleteChannel, res: Updates},\n\t'updates.getChannelDifference': {req: UpdatesGetChannelDifference, res: UpdatesChannelDifference},\n\t'messages.editChatAdmin': {req: MessagesEditChatAdmin, res: boolean},\n\t'messages.migrateChat': {req: MessagesMigrateChat, res: Updates},\n\t'messages.searchGlobal': {req: MessagesSearchGlobal, res: MessagesMessages},\n\t'messages.reorderStickerSets': {req: MessagesReorderStickerSets, res: boolean},\n\t'messages.getDocumentByHash': {req: MessagesGetDocumentByHash, res: Document},\n\t'messages.getSavedGifs': {req: MessagesGetSavedGifs, res: MessagesSavedGifs},\n\t'messages.saveGif': {req: MessagesSaveGif, res: boolean},\n\t'messages.getInlineBotResults': {req: MessagesGetInlineBotResults, res: MessagesBotResults},\n\t'messages.setInlineBotResults': {req: MessagesSetInlineBotResults, res: boolean},\n\t'messages.sendInlineBotResult': {req: MessagesSendInlineBotResult, res: Updates},\n\t'channels.exportMessageLink': {req: ChannelsExportMessageLink, res: ExportedMessageLink},\n\t'channels.toggleSignatures': {req: ChannelsToggleSignatures, res: Updates},\n\t'auth.resendCode': {req: AuthResendCode, res: AuthSentCode},\n\t'auth.cancelCode': {req: AuthCancelCode, res: boolean},\n\t'messages.getMessageEditData': {req: MessagesGetMessageEditData, res: MessagesMessageEditData},\n\t'messages.editMessage': {req: MessagesEditMessage, res: Updates},\n\t'messages.editInlineBotMessage': {req: MessagesEditInlineBotMessage, res: boolean},\n\t'messages.getBotCallbackAnswer': {req: MessagesGetBotCallbackAnswer, res: MessagesBotCallbackAnswer},\n\t'messages.setBotCallbackAnswer': {req: MessagesSetBotCallbackAnswer, res: boolean},\n\t'contacts.getTopPeers': {req: ContactsGetTopPeers, res: ContactsTopPeers},\n\t'contacts.resetTopPeerRating': {req: ContactsResetTopPeerRating, res: boolean},\n\t'messages.getPeerDialogs': {req: MessagesGetPeerDialogs, res: MessagesPeerDialogs},\n\t'messages.saveDraft': {req: MessagesSaveDraft, res: boolean},\n\t'messages.getAllDrafts': {req: MessagesGetAllDrafts, res: Updates},\n\t'messages.getFeaturedStickers': {req: MessagesGetFeaturedStickers, res: MessagesFeaturedStickers},\n\t'messages.readFeaturedStickers': {req: MessagesReadFeaturedStickers, res: boolean},\n\t'messages.getRecentStickers': {req: MessagesGetRecentStickers, res: MessagesRecentStickers},\n\t'messages.saveRecentSticker': {req: MessagesSaveRecentSticker, res: boolean},\n\t'messages.clearRecentStickers': {req: MessagesClearRecentStickers, res: boolean},\n\t'messages.getArchivedStickers': {req: MessagesGetArchivedStickers, res: MessagesArchivedStickers},\n\t'account.sendConfirmPhoneCode': {req: AccountSendConfirmPhoneCode, res: AuthSentCode},\n\t'account.confirmPhone': {req: AccountConfirmPhone, res: boolean},\n\t'channels.getAdminedPublicChannels': {req: ChannelsGetAdminedPublicChannels, res: MessagesChats},\n\t'messages.getMaskStickers': {req: MessagesGetMaskStickers, res: MessagesAllStickers},\n\t'messages.getAttachedStickers': {req: MessagesGetAttachedStickers, res: Array<StickerSetCovered>},\n\t'auth.dropTempAuthKeys': {req: AuthDropTempAuthKeys, res: boolean},\n\t'messages.setGameScore': {req: MessagesSetGameScore, res: Updates},\n\t'messages.setInlineGameScore': {req: MessagesSetInlineGameScore, res: boolean},\n\t'messages.getGameHighScores': {req: MessagesGetGameHighScores, res: MessagesHighScores},\n\t'messages.getInlineGameHighScores': {req: MessagesGetInlineGameHighScores, res: MessagesHighScores},\n\t'messages.getCommonChats': {req: MessagesGetCommonChats, res: MessagesChats},\n\t'messages.getAllChats': {req: MessagesGetAllChats, res: MessagesChats},\n\t'help.setBotUpdatesStatus': {req: HelpSetBotUpdatesStatus, res: boolean},\n\t'messages.getWebPage': {req: MessagesGetWebPage, res: WebPage},\n\t'messages.toggleDialogPin': {req: MessagesToggleDialogPin, res: boolean},\n\t'messages.reorderPinnedDialogs': {req: MessagesReorderPinnedDialogs, res: boolean},\n\t'messages.getPinnedDialogs': {req: MessagesGetPinnedDialogs, res: MessagesPeerDialogs},\n\t'bots.sendCustomRequest': {req: BotsSendCustomRequest, res: DataJSON},\n\t'bots.answerWebhookJSONQuery': {req: BotsAnswerWebhookJSONQuery, res: boolean},\n\t'upload.getWebFile': {req: UploadGetWebFile, res: UploadWebFile},\n\t'payments.getPaymentForm': {req: PaymentsGetPaymentForm, res: PaymentsPaymentForm},\n\t'payments.getPaymentReceipt': {req: PaymentsGetPaymentReceipt, res: PaymentsPaymentReceipt},\n\t'payments.validateRequestedInfo': {req: PaymentsValidateRequestedInfo, res: PaymentsValidatedRequestedInfo},\n\t'payments.sendPaymentForm': {req: PaymentsSendPaymentForm, res: PaymentsPaymentResult},\n\t'account.getTmpPassword': {req: AccountGetTmpPassword, res: AccountTmpPassword},\n\t'payments.getSavedInfo': {req: PaymentsGetSavedInfo, res: PaymentsSavedInfo},\n\t'payments.clearSavedInfo': {req: PaymentsClearSavedInfo, res: boolean},\n\t'messages.setBotShippingResults': {req: MessagesSetBotShippingResults, res: boolean},\n\t'messages.setBotPrecheckoutResults': {req: MessagesSetBotPrecheckoutResults, res: boolean},\n\t'stickers.createStickerSet': {req: StickersCreateStickerSet, res: MessagesStickerSet},\n\t'stickers.removeStickerFromSet': {req: StickersRemoveStickerFromSet, res: MessagesStickerSet},\n\t'stickers.changeStickerPosition': {req: StickersChangeStickerPosition, res: MessagesStickerSet},\n\t'stickers.addStickerToSet': {req: StickersAddStickerToSet, res: MessagesStickerSet},\n\t'messages.uploadMedia': {req: MessagesUploadMedia, res: MessageMedia},\n\t'phone.getCallConfig': {req: PhoneGetCallConfig, res: DataJSON},\n\t'phone.requestCall': {req: PhoneRequestCall, res: PhonePhoneCall},\n\t'phone.acceptCall': {req: PhoneAcceptCall, res: PhonePhoneCall},\n\t'phone.confirmCall': {req: PhoneConfirmCall, res: PhonePhoneCall},\n\t'phone.receivedCall': {req: PhoneReceivedCall, res: boolean},\n\t'phone.discardCall': {req: PhoneDiscardCall, res: Updates},\n\t'phone.setCallRating': {req: PhoneSetCallRating, res: Updates},\n\t'phone.saveCallDebug': {req: PhoneSaveCallDebug, res: boolean},\n\t'upload.getCdnFile': {req: UploadGetCdnFile, res: UploadCdnFile},\n\t'upload.reuploadCdnFile': {req: UploadReuploadCdnFile, res: Array<FileHash>},\n\t'help.getCdnConfig': {req: HelpGetCdnConfig, res: CdnConfig},\n\t'langpack.getLangPack': {req: LangpackGetLangPack, res: LangPackDifference},\n\t'langpack.getStrings': {req: LangpackGetStrings, res: Array<LangPackString>},\n\t'langpack.getDifference': {req: LangpackGetDifference, res: LangPackDifference},\n\t'langpack.getLanguages': {req: LangpackGetLanguages, res: Array<LangPackLanguage>},\n\t'channels.editBanned': {req: ChannelsEditBanned, res: Updates},\n\t'channels.getAdminLog': {req: ChannelsGetAdminLog, res: ChannelsAdminLogResults},\n\t'upload.getCdnFileHashes': {req: UploadGetCdnFileHashes, res: Array<FileHash>},\n\t'messages.sendScreenshotNotification': {req: MessagesSendScreenshotNotification, res: Updates},\n\t'channels.setStickers': {req: ChannelsSetStickers, res: boolean},\n\t'messages.getFavedStickers': {req: MessagesGetFavedStickers, res: MessagesFavedStickers},\n\t'messages.faveSticker': {req: MessagesFaveSticker, res: boolean},\n\t'channels.readMessageContents': {req: ChannelsReadMessageContents, res: boolean},\n\t'contacts.resetSaved': {req: ContactsResetSaved, res: boolean},\n\t'messages.getUnreadMentions': {req: MessagesGetUnreadMentions, res: MessagesMessages},\n\t'channels.deleteHistory': {req: ChannelsDeleteHistory, res: boolean},\n\t'help.getRecentMeUrls': {req: HelpGetRecentMeUrls, res: HelpRecentMeUrls},\n\t'channels.togglePreHistoryHidden': {req: ChannelsTogglePreHistoryHidden, res: Updates},\n\t'messages.readMentions': {req: MessagesReadMentions, res: MessagesAffectedHistory},\n\t'messages.getRecentLocations': {req: MessagesGetRecentLocations, res: MessagesMessages},\n\t'messages.sendMultiMedia': {req: MessagesSendMultiMedia, res: Updates},\n\t'messages.uploadEncryptedFile': {req: MessagesUploadEncryptedFile, res: EncryptedFile},\n\t'account.getWebAuthorizations': {req: AccountGetWebAuthorizations, res: AccountWebAuthorizations},\n\t'account.resetWebAuthorization': {req: AccountResetWebAuthorization, res: boolean},\n\t'account.resetWebAuthorizations': {req: AccountResetWebAuthorizations, res: boolean},\n\t'messages.searchStickerSets': {req: MessagesSearchStickerSets, res: MessagesFoundStickerSets},\n\t'upload.getFileHashes': {req: UploadGetFileHashes, res: Array<FileHash>},\n\t'help.getTermsOfServiceUpdate': {req: HelpGetTermsOfServiceUpdate, res: HelpTermsOfServiceUpdate},\n\t'help.acceptTermsOfService': {req: HelpAcceptTermsOfService, res: boolean},\n\t'account.getAllSecureValues': {req: AccountGetAllSecureValues, res: Array<SecureValue>},\n\t'account.getSecureValue': {req: AccountGetSecureValue, res: Array<SecureValue>},\n\t'account.saveSecureValue': {req: AccountSaveSecureValue, res: SecureValue},\n\t'account.deleteSecureValue': {req: AccountDeleteSecureValue, res: boolean},\n\t'users.setSecureValueErrors': {req: UsersSetSecureValueErrors, res: boolean},\n\t'account.getAuthorizationForm': {req: AccountGetAuthorizationForm, res: AccountAuthorizationForm},\n\t'account.acceptAuthorization': {req: AccountAcceptAuthorization, res: boolean},\n\t'account.sendVerifyPhoneCode': {req: AccountSendVerifyPhoneCode, res: AuthSentCode},\n\t'account.verifyPhone': {req: AccountVerifyPhone, res: boolean},\n\t'account.sendVerifyEmailCode': {req: AccountSendVerifyEmailCode, res: AccountSentEmailCode},\n\t'account.verifyEmail': {req: AccountVerifyEmail, res: boolean},\n\t'help.getDeepLinkInfo': {req: HelpGetDeepLinkInfo, res: HelpDeepLinkInfo},\n\t'contacts.getSaved': {req: ContactsGetSaved, res: Array<SavedContact>},\n\t'channels.getLeftChannels': {req: ChannelsGetLeftChannels, res: MessagesChats},\n\t'account.initTakeoutSession': {req: AccountInitTakeoutSession, res: AccountTakeout},\n\t'account.finishTakeoutSession': {req: AccountFinishTakeoutSession, res: boolean},\n\t'messages.getSplitRanges': {req: MessagesGetSplitRanges, res: Array<MessageRange>},\n\t'invokeWithMessagesRange': {req: InvokeWithMessagesRange, res: any},\n\t'invokeWithTakeout': {req: InvokeWithTakeout, res: any},\n\t'messages.markDialogUnread': {req: MessagesMarkDialogUnread, res: boolean},\n\t'messages.getDialogUnreadMarks': {req: MessagesGetDialogUnreadMarks, res: Array<DialogPeer>},\n\t'contacts.toggleTopPeers': {req: ContactsToggleTopPeers, res: boolean},\n\t'messages.clearAllDrafts': {req: MessagesClearAllDrafts, res: boolean},\n\t'help.getAppConfig': {req: HelpGetAppConfig, res: JSONValue},\n\t'help.saveAppLog': {req: HelpSaveAppLog, res: boolean},\n\t'help.getPassportConfig': {req: HelpGetPassportConfig, res: HelpPassportConfig},\n\t'langpack.getLanguage': {req: LangpackGetLanguage, res: LangPackLanguage},\n\t'messages.updatePinnedMessage': {req: MessagesUpdatePinnedMessage, res: Updates},\n\t'account.confirmPasswordEmail': {req: AccountConfirmPasswordEmail, res: boolean},\n\t'account.resendPasswordEmail': {req: AccountResendPasswordEmail, res: boolean},\n\t'account.cancelPasswordEmail': {req: AccountCancelPasswordEmail, res: boolean},\n\t'help.getSupportName': {req: HelpGetSupportName, res: HelpSupportName},\n\t'help.getUserInfo': {req: HelpGetUserInfo, res: HelpUserInfo},\n\t'help.editUserInfo': {req: HelpEditUserInfo, res: HelpUserInfo},\n\t'account.getContactSignUpNotification': {req: AccountGetContactSignUpNotification, res: boolean},\n\t'account.setContactSignUpNotification': {req: AccountSetContactSignUpNotification, res: boolean},\n\t'account.getNotifyExceptions': {req: AccountGetNotifyExceptions, res: Updates},\n\t'messages.sendVote': {req: MessagesSendVote, res: Updates},\n\t'messages.getPollResults': {req: MessagesGetPollResults, res: Updates},\n\t'messages.getOnlines': {req: MessagesGetOnlines, res: ChatOnlines},\n\t'messages.getStatsURL': {req: MessagesGetStatsURL, res: StatsURL},\n\t'messages.editChatAbout': {req: MessagesEditChatAbout, res: boolean},\n\t'messages.editChatDefaultBannedRights': {req: MessagesEditChatDefaultBannedRights, res: Updates},\n\t'account.getWallPaper': {req: AccountGetWallPaper, res: WallPaper},\n\t'account.uploadWallPaper': {req: AccountUploadWallPaper, res: WallPaper},\n\t'account.saveWallPaper': {req: AccountSaveWallPaper, res: boolean},\n\t'account.installWallPaper': {req: AccountInstallWallPaper, res: boolean},\n\t'account.resetWallPapers': {req: AccountResetWallPapers, res: boolean},\n\t'account.getAutoDownloadSettings': {req: AccountGetAutoDownloadSettings, res: AccountAutoDownloadSettings},\n\t'account.saveAutoDownloadSettings': {req: AccountSaveAutoDownloadSettings, res: boolean},\n\t'messages.getEmojiKeywords': {req: MessagesGetEmojiKeywords, res: EmojiKeywordsDifference},\n\t'messages.getEmojiKeywordsDifference': {req: MessagesGetEmojiKeywordsDifference, res: EmojiKeywordsDifference},\n\t'messages.getEmojiKeywordsLanguages': {req: MessagesGetEmojiKeywordsLanguages, res: Array<EmojiLanguage>},\n\t'messages.getEmojiURL': {req: MessagesGetEmojiURL, res: EmojiURL},\n\t'folders.editPeerFolders': {req: FoldersEditPeerFolders, res: Updates},\n\t'folders.deleteFolder': {req: FoldersDeleteFolder, res: Updates},\n\t'messages.getSearchCounters': {req: MessagesGetSearchCounters, res: Array<MessagesSearchCounter>},\n\t'channels.getGroupsForDiscussion': {req: ChannelsGetGroupsForDiscussion, res: MessagesChats},\n\t'channels.setDiscussionGroup': {req: ChannelsSetDiscussionGroup, res: boolean},\n\t'messages.requestUrlAuth': {req: MessagesRequestUrlAuth, res: UrlAuthResult},\n\t'messages.acceptUrlAuth': {req: MessagesAcceptUrlAuth, res: UrlAuthResult},\n\t'messages.hidePeerSettingsBar': {req: MessagesHidePeerSettingsBar, res: boolean},\n\t'contacts.addContact': {req: ContactsAddContact, res: Updates},\n\t'contacts.acceptContact': {req: ContactsAcceptContact, res: Updates},\n\t'channels.editCreator': {req: ChannelsEditCreator, res: Updates},\n\t'contacts.getLocated': {req: ContactsGetLocated, res: Updates},\n\t'channels.editLocation': {req: ChannelsEditLocation, res: boolean},\n\t'channels.toggleSlowMode': {req: ChannelsToggleSlowMode, res: Updates},\n\t'messages.getScheduledHistory': {req: MessagesGetScheduledHistory, res: MessagesMessages},\n\t'messages.getScheduledMessages': {req: MessagesGetScheduledMessages, res: MessagesMessages},\n\t'messages.sendScheduledMessages': {req: MessagesSendScheduledMessages, res: Updates},\n\t'messages.deleteScheduledMessages': {req: MessagesDeleteScheduledMessages, res: Updates},\n\t'account.uploadTheme': {req: AccountUploadTheme, res: Document},\n\t'account.createTheme': {req: AccountCreateTheme, res: Theme},\n\t'account.updateTheme': {req: AccountUpdateTheme, res: Theme},\n\t'account.saveTheme': {req: AccountSaveTheme, res: boolean},\n\t'account.installTheme': {req: AccountInstallTheme, res: boolean},\n\t'account.getTheme': {req: AccountGetTheme, res: Theme},\n\t'account.getThemes': {req: AccountGetThemes, res: AccountThemes},\n\t'auth.exportLoginToken': {req: AuthExportLoginToken, res: AuthLoginToken},\n\t'auth.importLoginToken': {req: AuthImportLoginToken, res: AuthLoginToken},\n\t'auth.acceptLoginToken': {req: AuthAcceptLoginToken, res: Authorization},\n\t'account.setContentSettings': {req: AccountSetContentSettings, res: boolean},\n\t'account.getContentSettings': {req: AccountGetContentSettings, res: AccountContentSettings},\n\t'channels.getInactiveChannels': {req: ChannelsGetInactiveChannels, res: MessagesInactiveChats},\n\t'account.getMultiWallPapers': {req: AccountGetMultiWallPapers, res: Array<WallPaper>},\n\t'messages.getPollVotes': {req: MessagesGetPollVotes, res: MessagesVotesList},\n\t'messages.toggleStickerSets': {req: MessagesToggleStickerSets, res: boolean},\n\t'payments.getBankCardData': {req: PaymentsGetBankCardData, res: PaymentsBankCardData},\n\t'messages.getDialogFilters': {req: MessagesGetDialogFilters, res: Array<DialogFilter>},\n\t'messages.getSuggestedDialogFilters': {req: MessagesGetSuggestedDialogFilters, res: Array<DialogFilterSuggested>},\n\t'messages.updateDialogFilter': {req: MessagesUpdateDialogFilter, res: boolean},\n\t'messages.updateDialogFiltersOrder': {req: MessagesUpdateDialogFiltersOrder, res: boolean},\n\t'stats.getBroadcastStats': {req: StatsGetBroadcastStats, res: StatsBroadcastStats},\n\t'stats.loadAsyncGraph': {req: StatsLoadAsyncGraph, res: StatsGraph},\n\t'stickers.setStickerSetThumb': {req: StickersSetStickerSetThumb, res: MessagesStickerSet},\n\t'bots.setBotCommands': {req: BotsSetBotCommands, res: boolean},\n\t'messages.getOldFeaturedStickers': {req: MessagesGetOldFeaturedStickers, res: MessagesFeaturedStickers},\n\t'help.getPromoData': {req: HelpGetPromoData, res: HelpPromoData},\n\t'help.hidePromoData': {req: HelpHidePromoData, res: boolean},\n\t'phone.sendSignalingData': {req: PhoneSendSignalingData, res: boolean},\n\t'stats.getMegagroupStats': {req: StatsGetMegagroupStats, res: StatsMegagroupStats},\n\t'account.getGlobalPrivacySettings': {req: AccountGetGlobalPrivacySettings, res: GlobalPrivacySettings},\n\t'account.setGlobalPrivacySettings': {req: AccountSetGlobalPrivacySettings, res: GlobalPrivacySettings},\n\t'help.dismissSuggestion': {req: HelpDismissSuggestion, res: boolean},\n\t'help.getCountriesList': {req: HelpGetCountriesList, res: HelpCountriesList},\n\t'messages.getReplies': {req: MessagesGetReplies, res: MessagesMessages},\n\t'messages.getDiscussionMessage': {req: MessagesGetDiscussionMessage, res: MessagesDiscussionMessage},\n\t'messages.readDiscussion': {req: MessagesReadDiscussion, res: boolean},\n\t'contacts.blockFromReplies': {req: ContactsBlockFromReplies, res: Updates},\n\t'stats.getMessagePublicForwards': {req: StatsGetMessagePublicForwards, res: MessagesMessages},\n\t'stats.getMessageStats': {req: StatsGetMessageStats, res: StatsMessageStats},\n\t'messages.unpinAllMessages': {req: MessagesUnpinAllMessages, res: MessagesAffectedHistory},\n\t'phone.createGroupCall': {req: PhoneCreateGroupCall, res: Updates},\n\t'phone.joinGroupCall': {req: PhoneJoinGroupCall, res: Updates},\n\t'phone.leaveGroupCall': {req: PhoneLeaveGroupCall, res: Updates},\n\t'phone.inviteToGroupCall': {req: PhoneInviteToGroupCall, res: Updates},\n\t'phone.discardGroupCall': {req: PhoneDiscardGroupCall, res: Updates},\n\t'phone.toggleGroupCallSettings': {req: PhoneToggleGroupCallSettings, res: Updates},\n\t'phone.getGroupCall': {req: PhoneGetGroupCall, res: PhoneGroupCall},\n\t'phone.getGroupParticipants': {req: PhoneGetGroupParticipants, res: PhoneGroupParticipants},\n\t'phone.checkGroupCall': {req: PhoneCheckGroupCall, res: Array<number>},\n\t'messages.deleteChat': {req: MessagesDeleteChat, res: boolean},\n\t'messages.deletePhoneCallHistory': {req: MessagesDeletePhoneCallHistory, res: MessagesAffectedFoundMessages},\n\t'messages.checkHistoryImport': {req: MessagesCheckHistoryImport, res: MessagesHistoryImportParsed},\n\t'messages.initHistoryImport': {req: MessagesInitHistoryImport, res: MessagesHistoryImport},\n\t'messages.uploadImportedMedia': {req: MessagesUploadImportedMedia, res: MessageMedia},\n\t'messages.startHistoryImport': {req: MessagesStartHistoryImport, res: boolean},\n\t'messages.getExportedChatInvites': {req: MessagesGetExportedChatInvites, res: MessagesExportedChatInvites},\n\t'messages.getExportedChatInvite': {req: MessagesGetExportedChatInvite, res: MessagesExportedChatInvite},\n\t'messages.editExportedChatInvite': {req: MessagesEditExportedChatInvite, res: MessagesExportedChatInvite},\n\t'messages.deleteRevokedExportedChatInvites': {req: MessagesDeleteRevokedExportedChatInvites, res: boolean},\n\t'messages.deleteExportedChatInvite': {req: MessagesDeleteExportedChatInvite, res: boolean},\n\t'messages.getAdminsWithInvites': {req: MessagesGetAdminsWithInvites, res: MessagesChatAdminsWithInvites},\n\t'messages.getChatInviteImporters': {req: MessagesGetChatInviteImporters, res: MessagesChatInviteImporters},\n\t'messages.setHistoryTTL': {req: MessagesSetHistoryTTL, res: Updates},\n\t'account.reportProfilePhoto': {req: AccountReportProfilePhoto, res: boolean},\n\t'channels.convertToGigagroup': {req: ChannelsConvertToGigagroup, res: Updates},\n\t'messages.checkHistoryImportPeer': {req: MessagesCheckHistoryImportPeer, res: MessagesCheckedHistoryImportPeer},\n\t'phone.toggleGroupCallRecord': {req: PhoneToggleGroupCallRecord, res: Updates},\n\t'phone.editGroupCallParticipant': {req: PhoneEditGroupCallParticipant, res: Updates},\n\t'phone.editGroupCallTitle': {req: PhoneEditGroupCallTitle, res: Updates},\n\t'phone.getGroupCallJoinAs': {req: PhoneGetGroupCallJoinAs, res: PhoneJoinAsPeers},\n\t'phone.exportGroupCallInvite': {req: PhoneExportGroupCallInvite, res: PhoneExportedGroupCallInvite},\n\t'phone.toggleGroupCallStartSubscription': {req: PhoneToggleGroupCallStartSubscription, res: Updates},\n\t'phone.startScheduledGroupCall': {req: PhoneStartScheduledGroupCall, res: Updates},\n\t'phone.saveDefaultGroupCallJoinAs': {req: PhoneSaveDefaultGroupCallJoinAs, res: boolean},\n\t'phone.joinGroupCallPresentation': {req: PhoneJoinGroupCallPresentation, res: Updates},\n\t'phone.leaveGroupCallPresentation': {req: PhoneLeaveGroupCallPresentation, res: Updates},\n\t'stickers.checkShortName': {req: StickersCheckShortName, res: boolean},\n\t'stickers.suggestShortName': {req: StickersSuggestShortName, res: StickersSuggestedShortName},\n\t'bots.resetBotCommands': {req: BotsResetBotCommands, res: boolean},\n\t'bots.getBotCommands': {req: BotsGetBotCommands, res: Array<BotCommand>},\n\t'account.resetPassword': {req: AccountResetPassword, res: AccountResetPasswordResult},\n\t'account.declinePasswordReset': {req: AccountDeclinePasswordReset, res: boolean},\n\t'auth.checkRecoveryPassword': {req: AuthCheckRecoveryPassword, res: boolean},\n}\n\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport AvatarElement from \"../../components/avatar\";\nimport DialogsContextMenu from \"../../components/dialogsContextMenu\";\nimport { horizontalMenu } from \"../../components/horizontalMenu\";\nimport { attachContextMenuListener, putPreloader } from \"../../components/misc\";\nimport { ripple } from \"../../components/ripple\";\n//import Scrollable from \"../../components/scrollable\";\nimport Scrollable, { ScrollableX, SliceSides } from \"../../components/scrollable\";\nimport { formatDateAccordingToTodayNew } from \"../../helpers/date\";\nimport { isSafari } from \"../../helpers/userAgent\";\nimport { logger, LogTypes } from \"../logger\";\nimport { RichTextProcessor } from \"../richtextprocessor\";\nimport rootScope from \"../rootScope\";\nimport apiUpdatesManager from \"./apiUpdatesManager\";\nimport appPeersManager from './appPeersManager';\nimport appImManager from \"./appImManager\";\nimport appMessagesManager, { Dialog } from \"./appMessagesManager\";\nimport {MyDialogFilter as DialogFilter} from \"../storages/filters\";\nimport appStateManager, { State } from \"./appStateManager\";\nimport appUsersManager from \"./appUsersManager\";\nimport Button from \"../../components/button\";\nimport SetTransition from \"../../components/singleTransition\";\nimport appDraftsManager, { MyDraftMessage } from \"./appDraftsManager\";\nimport DEBUG, { MOUNT_CLASS_TO } from \"../../config/debug\";\nimport appNotificationsManager from \"./appNotificationsManager\";\nimport PeerTitle from \"../../components/peerTitle\";\nimport I18n, { FormatterArguments, i18n, LangPackKey, _i18n } from \"../langPack\";\nimport findUpTag from \"../../helpers/dom/findUpTag\";\nimport { LazyLoadQueueIntersector } from \"../../components/lazyLoadQueue\";\nimport lottieLoader from \"../lottieLoader\";\nimport { wrapLocalSticker } from \"../../components/wrappers\";\nimport AppEditFolderTab from \"../../components/sidebarLeft/tabs/editFolder\";\nimport appSidebarLeft, { SettingSection } from \"../../components/sidebarLeft\";\nimport { attachClickEvent } from \"../../helpers/dom/clickEvent\";\nimport positionElementByIndex from \"../../helpers/dom/positionElementByIndex\";\nimport replaceContent from \"../../helpers/dom/replaceContent\";\nimport ConnectionStatusComponent from \"../../components/connectionStatus\";\nimport appChatsManager from \"./appChatsManager\";\nimport { renderImageFromUrlPromise } from \"../../helpers/dom/renderImageFromUrl\";\nimport { fastRafPromise } from \"../../helpers/schedulers\";\nimport appPhotosManager from \"./appPhotosManager\";\nimport SortedUserList from \"../../components/sortedUserList\";\n\nexport type DialogDom = {\n  avatarEl: AvatarElement,\n  captionDiv: HTMLDivElement,\n  titleSpan: HTMLSpanElement,\n  titleSpanContainer: HTMLSpanElement,\n  statusSpan: HTMLSpanElement,\n  lastTimeSpan: HTMLSpanElement,\n  unreadMessagesSpan: HTMLSpanElement,\n  lastMessageSpan: HTMLSpanElement,\n  containerEl: HTMLElement,\n  listEl: HTMLLIElement,\n  muteAnimationTimeout?: number\n};\n\n//const testScroll = false;\n//let testTopSlice = 1;\n\nexport class AppDialogsManager {\n  private chatList: HTMLUListElement;\n\n  private doms: {[peerId: number]: DialogDom} = {};\n\n  private chatsContainer = document.getElementById('chatlist-container') as HTMLDivElement;\n  private chatsPreloader: HTMLElement;\n\n  private loadDialogsPromise: Promise<any>;\n\n  private scroll: Scrollable = null;\n  \n  private log = logger('DIALOGS', LogTypes.Log | LogTypes.Error | LogTypes.Warn | LogTypes.Debug);\n\n  private contextMenu = new DialogsContextMenu();\n\n  public chatLists: {[filterId: number]: HTMLUListElement} = {};\n  public scrollables: {[filterId: number]: Scrollable} = {};\n  public filterId: number;\n  private folders: {[k in 'menu' | 'container' | 'menuScrollContainer']: HTMLElement} = {\n    menu: document.getElementById('folders-tabs'),\n    menuScrollContainer: null,\n    container: document.getElementById('folders-container')\n  };\n  private filtersRendered: {\n    [filterId: string]: {\n      menu: HTMLElement, \n      container: HTMLElement,\n      unread: HTMLElement,\n      title: HTMLElement\n    }\n  } = {};\n  private showFiltersPromise: Promise<void>;\n  private allUnreadCount: HTMLElement;\n\n  private accumulateArchivedTimeout: number;\n\n  //private topOffsetIndex = 0;\n\n  private sliceTimeout: number;\n  private reorderDialogsTimeout: number;\n\n  private lastActiveElements: Set<HTMLElement> = new Set();\n\n  private offsets: {top: number, bottom: number} = {top: 0, bottom: 0};\n  loadContacts: () => void;\n\n  constructor() {\n    this.chatsPreloader = putPreloader(null, true);\n\n    this.allUnreadCount = this.folders.menu.querySelector('.badge');\n    \n    this.folders.menuScrollContainer = this.folders.menu.parentElement;\n\n    const bottomPart = document.createElement('div');\n    bottomPart.classList.add('connection-status-bottom');\n    bottomPart.append(this.folders.container);\n\n    /* if(isTouchSupported && isSafari) {\n      let allowUp: boolean, allowDown: boolean, slideBeginY: number;\n      const container = this.scroll.container;\n      container.addEventListener('touchstart', (event) => {\n        allowUp = container.scrollTop > 0;\n        allowDown = (container.scrollTop < container.scrollHeight - container.clientHeight);\n        // @ts-ignore\n        slideBeginY = event.pageY;\n      });\n      \n      container.addEventListener('touchmove', (event: any) => {\n        var up = (event.pageY > slideBeginY);\n        var down = (event.pageY < slideBeginY);\n        slideBeginY = event.pageY;\n        if((up && allowUp) || (down && allowDown)) {\n          event.stopPropagation();\n        } else if(up || down) {\n          event.preventDefault();\n        }\n      });\n    } */\n\n    this.filterId = 0;\n    this.addFilter({\n      id: this.filterId,\n      title: '',\n      titleEl: i18n('ChatList.Filter.AllChats'),\n      orderIndex: 0\n    });\n\n    this.chatList = this.chatLists[this.filterId];\n    this.scroll = this.scrollables[this.filterId];\n\n    /* if(testScroll) {\n      let i = 0;\n      let add = () => {\n        let li = document.createElement('li');\n        li.dataset.id = '' + i;\n        li.id = '' + i;\n        li.innerHTML = `<div class=\"rp\"><avatar-element style=\"background-color: rgb(166, 149, 231); font-size: 0px;\"><img src=\"assets/img/pepe.jpg\"></avatar-element><div class=\"user-caption\"><p><span class=\"user-title\">${i}</span><span><span class=\"message-status\"></span><span class=\"message-time\">18:33</span></span></p><p><span class=\"user-last-message\"><b>-_-_-_-: </b>qweasd</span><span></span></p></div></div>`;\n        i++;\n        this.scroll.append(li);\n      };\n      for(let i = 0; i < 500; ++i) {\n        add();\n      }\n      (window as any).addElement = add;\n    } */\n\n    rootScope.addEventListener('user_update', (userId) => {\n      //console.log('updating user:', user, dialog);\n      \n      const dom = this.getDialogDom(userId);\n      if(dom && !appUsersManager.isBot(userId) && userId !== rootScope.myId) {\n        const user = appUsersManager.getUser(userId);\n        const online = user.status?._ === 'userStatusOnline';\n        dom.avatarEl.classList.toggle('is-online', online);\n      }\n    });\n\n    /* rootScope.$on('dialog_top', (e) => {\n      const dialog = e;\n\n      this.setLastMessage(dialog);\n      this.setDialogPosition(dialog);\n\n      this.setFiltersUnreadCount();\n    }); */\n\n    rootScope.addEventListener('dialog_flush', (e) => {\n      const peerId: number = e.peerId;\n      const dialog = appMessagesManager.getDialogOnly(peerId);\n      if(dialog) {\n        this.setLastMessage(dialog);\n        this.validateForFilter();\n        this.setFiltersUnreadCount();\n      }\n    });\n\n    rootScope.addEventListener('dialogs_multiupdate', (e) => {\n      const dialogs = e;\n\n      for(const id in dialogs) {\n        const dialog = dialogs[id];\n        this.updateDialog(dialog);\n      }\n\n      this.validateForFilter();\n      this.setFiltersUnreadCount();\n    });\n\n    rootScope.addEventListener('dialog_drop', (e) => {\n      const {peerId} = e;\n\n      this.deleteDialog(peerId);\n      this.setFiltersUnreadCount();\n    });\n\n    rootScope.addEventListener('dialog_unread', (e) => {\n      const info = e;\n\n      const dialog = appMessagesManager.getDialogOnly(info.peerId);\n      if(dialog) {\n        this.setUnreadMessages(dialog);\n        this.validateForFilter();\n        this.setFiltersUnreadCount();\n      }\n    });\n\n    rootScope.addEventListener('dialog_notify_settings', (dialog) => {\n      this.setUnreadMessages(dialog); // \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u044d\u0442\u043e \u043d\u0435 \u043d\u0443\u0436\u043d\u043e, \u043d\u043e \u043d\u0443\u0436\u043d\u043e \u043c\u0435\u043d\u044f\u0442\u044c is-muted\n    });\n\n    rootScope.addEventListener('dialog_draft', (e) => {\n      const dialog = appMessagesManager.getDialogOnly(e.peerId);\n      if(dialog) {\n        this.updateDialog(dialog);\n      }\n    });\n\n    rootScope.addEventListener('peer_changed', (e) => {\n      const peerId = e;\n\n      //const perf = performance.now();\n      for(const element of this.lastActiveElements) {\n        if(+element.dataset.peerId !== peerId) {\n          element.classList.remove('active');\n          this.lastActiveElements.delete(element);\n        }\n      }\n\n      const elements = Array.from(document.querySelectorAll(`[data-autonomous=\"0\"] li[data-peer-id=\"${peerId}\"]`)) as HTMLElement[];\n      elements.forEach(element => {\n        element.classList.add('active');\n        this.lastActiveElements.add(element);\n      });\n      //this.log('peer_changed total time:', performance.now() - perf);\n    });\n\n    rootScope.addEventListener('filter_update', (e) => {\n      const filter: DialogFilter = e;\n      if(!this.filtersRendered[filter.id]) {\n        this.addFilter(filter);\n        return;\n      } else if(filter.id === this.filterId) { // \u044d\u0442\u043e \u043d\u0435\u0442 \u0442\u0443\u0442 \u0441\u043c\u044b\u0441\u043b\u0430 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c, \u0442\u0430\u043a \u043a\u0430\u043a \u0431\u0443\u0434\u0435\u0442 dialogs_multiupdate\n        //this.validateForFilter();\n        const folder = appMessagesManager.dialogsStorage.getFolder(filter.id);\n        this.validateForFilter();\n        for(let i = 0, length = folder.length; i < length; ++i) {\n          const dialog = folder[i];\n          this.updateDialog(dialog);\n        }\n        this.setFiltersUnreadCount();\n      }\n\n      const elements = this.filtersRendered[filter.id];\n      elements.title.innerHTML = RichTextProcessor.wrapEmojiText(filter.title);\n    });\n\n    rootScope.addEventListener('filter_delete', (e) => {\n      const filter: DialogFilter = e;\n      const elements = this.filtersRendered[filter.id];\n      if(!elements) return;\n\n      // set tab\n      //(this.folders.menu.firstElementChild.children[Math.max(0, filter.id - 2)] as HTMLElement).click();\n      (this.folders.menu.firstElementChild as HTMLElement).click();\n\n      elements.container.remove();\n      elements.menu.remove();\n      \n      delete this.chatLists[filter.id];\n      delete this.scrollables[filter.id];\n      delete this.filtersRendered[filter.id];\n\n      if(Object.keys(this.filtersRendered).length <= 1) {\n        this.folders.menuScrollContainer.classList.add('hide');\n      }\n    });\n\n    rootScope.addEventListener('filter_order', (e) => {\n      const order = e;\n      \n      const containerToAppend = this.folders.menu as HTMLElement;\n      order.forEach((filterId) => {\n        const filter = appMessagesManager.filtersStorage.filters[filterId];\n        const renderedFilter = this.filtersRendered[filterId];\n\n        positionElementByIndex(renderedFilter.menu, containerToAppend, filter.orderIndex);\n        positionElementByIndex(renderedFilter.container, this.folders.container, filter.orderIndex);\n      });\n\n      /* if(this.filterId) {\n        const tabIndex = order.indexOf(this.filterId) + 1;\n        selectTab.prevId = tabIndex;\n      } */\n    });\n\n    rootScope.addEventListener('peer_typings', (e) => {\n      const {peerId, typings} = e;\n\n      const dialog = appMessagesManager.getDialogOnly(peerId);\n      if(!dialog) return;\n\n      if(typings.length) {\n        this.setTyping(dialog);\n      } else {\n        this.unsetTyping(dialog);\n      }\n    });\n\n    rootScope.addEventListener('state_cleared', () => {\n      //setTimeout(() => \n      appStateManager.getState().then((state) => {\n        appUsersManager.clear();\n        appChatsManager.clear();\n        \n        const filtersStorage = appMessagesManager.filtersStorage;\n        const filters = filtersStorage.filters;\n        for(const filterId in filters) { // delete filters\n          rootScope.dispatchEvent('updateDialogFilter', {\n            _: 'updateDialogFilter',\n            id: +filterId,\n          });\n        }\n\n        appMessagesManager.clear();\n\n        /* const clearPromises: Promise<any>[] = [];\n        for(const name in appStateManager.storagesResults) {\n          const results = appStateManager.storagesResults[name as keyof AppStateManager['storages']];\n          const storage = appStateManager.storages[name as keyof AppStateManager['storages']];\n          results.length = 0;\n          clearPromises.push(storage.clear());\n        } */\n\n        this.validateForFilter();\n\n        this.onStateLoaded(state);\n      })//, 5000);\n    });\n\n    const foldersScrollable = new ScrollableX(this.folders.menuScrollContainer);\n    bottomPart.prepend(this.folders.menuScrollContainer);\n    const selectTab = horizontalMenu(this.folders.menu, this.folders.container, (id, tabContent) => {\n      /* if(id !== 0) {\n        id += 1;\n      } */\n\n      id = +tabContent.dataset.filterId || 0;\n\n      if(this.filterId === id) return;\n\n      this.chatLists[id].innerHTML = '';\n      this.filterId = id;\n      this.onTabChange();\n    }, () => {\n      for(const folderId in this.chatLists) {\n        if(+folderId !== this.filterId) {\n          this.chatLists[folderId].innerHTML = '';\n        }\n      }\n    }, undefined, foldersScrollable);\n\n    //selectTab(0);\n    (this.folders.menu.firstElementChild as HTMLElement).click();\n    appMessagesManager.construct();\n    appStateManager.getState().then((state) => {\n      return this.onStateLoaded(state);\n    }).then(() => {\n      //return;\n      \n      const isLoadedMain = appMessagesManager.dialogsStorage.isDialogsLoaded(0);\n      const isLoadedArchive = appMessagesManager.dialogsStorage.isDialogsLoaded(1);\n      const wasLoaded = isLoadedMain || isLoadedArchive;\n      const a: Promise<any> = isLoadedMain ? Promise.resolve() : appMessagesManager.getConversationsAll('', 0);\n      const b: Promise<any> = isLoadedArchive ? Promise.resolve() : appMessagesManager.getConversationsAll('', 1);\n      a.finally(() => {\n        b.then(() => {\n          this.accumulateArchivedUnread();\n\n          if(wasLoaded) {\n            (apiUpdatesManager.updatesState.syncLoading || Promise.resolve()).then(() => {\n              appMessagesManager.refreshConversations();\n            });\n          }\n        });\n      });\n    });\n\n    new ConnectionStatusComponent(this.chatsContainer);\n    this.chatsContainer.append(bottomPart);\n\n    setTimeout(() => {\n      lottieLoader.loadLottieWorkers();\n    }, 200);\n  }\n\n  private async onStateLoaded(state: State) {\n    appNotificationsManager.getNotifyPeerTypeSettings();\n      \n    const renderFiltersPromise = appMessagesManager.filtersStorage.getDialogFilters().then((filters) => {\n      for(const filter of filters) {\n        this.addFilter(filter);\n      }\n    });\n\n    if(state.filters && Object.keys(state.filters).length) {\n      await renderFiltersPromise;\n      if(this.showFiltersPromise) {\n        await this.showFiltersPromise;\n      }\n    }\n\n    if(appStateManager.storagesResults.dialogs.length) {\n      appDraftsManager.addMissedDialogs();\n    }\n\n    return this.onChatsScroll();\n  }\n\n  /* private getOffset(side: 'top' | 'bottom'): {index: number, pos: number} {\n    if(!this.scroll.loadedAll[side]) {\n      const element = (side === 'top' ? this.chatList.firstElementChild : this.chatList.lastElementChild) as HTMLElement;\n      if(element) {\n        const peerId = +element.dataset.peerId;\n        const dialog = appMessagesManager.getDialogByPeerId(peerId);\n        return {index: dialog[0].index, pos: dialog[1]};\n      }\n    }\n\n    return {index: 0, pos: -1};\n  } */\n  private getOffsetIndex(side: 'top' | 'bottom') {\n    return {index: this.scroll.loadedAll[side] ? 0 : this.offsets[side]};\n  }\n\n  private isDialogMustBeInViewport(dialog: Dialog) {\n    if(dialog.migratedTo !== undefined) return false;\n    //return true;\n    const topOffset = this.getOffsetIndex('top');\n    const bottomOffset = this.getOffsetIndex('bottom');\n    \n    if(!topOffset.index && !bottomOffset.index) {\n      return true;\n    }\n    \n    const index = dialog.index;\n    return (!topOffset.index || index <= topOffset.index) && (!bottomOffset.index || index >= bottomOffset.index);\n  }\n\n  private deleteDialog(peerId: number) {\n    const dom = this.getDialogDom(peerId);\n    if(dom) {\n      dom.listEl.remove();\n      delete this.doms[peerId];\n\n      this.onListLengthChange();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private updateDialog(dialog: Dialog) {\n    if(!dialog) {\n      return;\n    }\n\n    if(this.isDialogMustBeInViewport(dialog)) {\n      if(!this.doms.hasOwnProperty(dialog.peerId)) {\n        const ret = this.addDialogNew({dialog});\n        if(ret) {\n          const idx = appMessagesManager.getDialogByPeerId(dialog.peerId)[1];\n          positionElementByIndex(ret.dom.listEl, this.chatList, idx);\n          this.onListLengthChange();\n        } else {\n          return;\n        }\n      }\n    } else {\n      this.deleteDialog(dialog.peerId);\n      return;\n    }\n\n    /* const topOffset = this.getOffset('top');\n    if(topOffset.index && dialog.index > topOffset.index) {\n      const dom = this.getDialogDom(dialog.peerId);\n      if(dom) {\n        dom.listEl.remove();\n        delete this.doms[dialog.peerId];\n      }\n\n      return;\n    }\n\n    if(!this.doms.hasOwnProperty(dialog.peerId)) {\n      this.addDialogNew({dialog});\n    } */\n\n    if(this.getDialogDom(dialog.peerId)) {\n      this.setLastMessage(dialog);\n      this.reorderDialogs();\n    }\n  }\n\n  public onTabChange = () => {\n    this.doms = {};\n    this.scroll = this.scrollables[this.filterId];\n    this.scroll.loadedAll.top = true;\n    this.scroll.loadedAll.bottom = false;\n    this.offsets.top = this.offsets.bottom = 0;\n    this.loadDialogsPromise = undefined;\n    this.chatList = this.chatLists[this.filterId];\n    this.onChatsScroll();\n  };\n\n  private setFilterUnreadCount(filterId: number, folder?: Dialog[]) {\n    const unreadSpan = filterId === 0 ? this.allUnreadCount : this.filtersRendered[filterId]?.unread;\n    if(!unreadSpan) {\n      return;\n    }\n\n    folder = folder || appMessagesManager.dialogsStorage.getFolder(filterId);\n    let mutedCount = 0;\n    let notMutedCount = 0;\n    folder.forEach(dialog => {\n      const isMuted = appNotificationsManager.isPeerLocalMuted(dialog.peerId, true);\n\n      if(isMuted && filterId === 0) {\n        return;\n      }\n\n      const value = +!!dialog.unread_count || +dialog.pFlags.unread_mark || 0; // * unread_mark can be undefined\n      if(isMuted) mutedCount += value;\n      else notMutedCount += value;\n    });\n    \n    unreadSpan.classList.toggle('badge-gray', mutedCount && !notMutedCount);\n    \n    const sum = mutedCount + notMutedCount;\n    unreadSpan.innerText = sum ? '' + sum : '';\n  }\n\n  private setFiltersUnreadCount() {\n    for(const filterId in this.filtersRendered) {\n      this.setFilterUnreadCount(+filterId);\n    }\n\n    this.setFilterUnreadCount(0);\n  }\n\n  /**\n   * \u0423\u0434\u0430\u043b\u0438\u0442 \u043d\u0435\u043f\u043e\u0434\u0445\u043e\u0434\u044f\u0449\u0438\u0435 \u0447\u0430\u0442\u044b \u0438\u0437 \u0441\u043f\u0438\u0441\u043a\u0430, \u043d\u043e \u043d\u0435 \u0434\u043e\u0431\u0430\u0432\u0438\u0442 \u0438\u0445(!)\n   */\n  private validateForFilter() {\n    // !WARNING, \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u044d\u0442\u043e \u0431\u044b\u043b\u043e \u0437\u0430\u0447\u0435\u043c-\u0442\u043e, \u043d\u043e \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0439 \u0438\u0441\u043f\u0440\u0430\u0432\u0438\u043b \u0430\u0440\u0445\u0438\u0432\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435\n    //if(this.filterId === 0) return;\n\n    const folder = appMessagesManager.dialogsStorage.getFolder(this.filterId);\n    for(const _peerId in this.doms) {\n      const peerId = +_peerId;\n\n      // \u0435\u0441\u043b\u0438 \u0431\u043e\u043b\u044c\u0448\u0435 \u043d\u0435 \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442 \u043f\u043e \u0444\u0438\u043b\u044c\u0442\u0440\u0443, \u0443\u0434\u0430\u043b\u044f\u0435\u043c\n      if(folder.findIndex((dialog) => dialog.peerId === peerId) === -1) {\n        this.deleteDialog(peerId);\n      }\n    }\n  }\n\n  public generateScrollable(list: HTMLUListElement, filterId: number) {\n    const scrollable = new Scrollable(null, 'CL', 500);\n    scrollable.container.addEventListener('scroll', this.onChatsRegularScroll);\n    scrollable.container.dataset.filterId = '' + filterId;\n    scrollable.onScrolledTop = this.onChatsScrollTop;\n    scrollable.onScrolledBottom = this.onChatsScroll;\n    scrollable.setVirtualContainer(list);\n\n    this.chatLists[filterId] = list;\n    this.scrollables[filterId] = scrollable;\n\n    return scrollable;\n  }\n\n  private addFilter(filter: Pick<DialogFilter, 'title' | 'id' | 'orderIndex'> & Partial<{titleEl: HTMLElement}>) {\n    if(this.filtersRendered[filter.id]) return;\n\n    const menuTab = document.createElement('div');\n    menuTab.classList.add('menu-horizontal-div-item');\n    const span = document.createElement('span');\n    const titleSpan = document.createElement('span');\n    titleSpan.classList.add('text-super');\n    if(filter.titleEl) titleSpan.append(filter.titleEl);\n    else titleSpan.innerHTML = RichTextProcessor.wrapEmojiText(filter.title);\n    const unreadSpan = document.createElement('div');\n    unreadSpan.classList.add('badge', 'badge-20', 'badge-primary');\n    const i = document.createElement('i');\n    span.append(titleSpan, unreadSpan, i);\n    menuTab.append(span);\n    ripple(menuTab);\n\n    const containerToAppend = this.folders.menu as HTMLElement;\n    positionElementByIndex(menuTab, containerToAppend, filter.orderIndex);\n    //containerToAppend.append(li);\n\n    const ul = this.createChatList();\n    const scrollable = this.generateScrollable(ul, filter.id);\n\n    scrollable.container.classList.add('chatlist-parts');\n\n    /* const parts = document.createElement('div');\n    parts.classList.add('chatlist-parts'); */\n    \n    const top = document.createElement('div');\n    top.classList.add('chatlist-top');\n    \n    const bottom = document.createElement('div');\n    bottom.classList.add('chatlist-bottom');\n\n    top.append(ul);\n    scrollable.container.append(top, bottom);\n    /* parts.append(top, bottom);\n    scrollable.container.append(parts); */\n    \n    const div = scrollable.container;\n    //this.folders.container.append(div);\n    positionElementByIndex(scrollable.container, this.folders.container, filter.orderIndex);\n\n    this.setListClickListener(ul, null, true);\n\n    this.filtersRendered[filter.id] = {\n      menu: menuTab,\n      container: div,\n      unread: unreadSpan,\n      title: titleSpan\n    };\n\n    if(!this.showFiltersPromise && Object.keys(this.filtersRendered).length > 1) {\n      this.showFiltersPromise = new Promise<void>((resolve) => {\n        window.setTimeout(() => {\n          this.showFiltersPromise = undefined;\n          if(Object.keys(this.filtersRendered).length > 1) {\n            this.folders.menuScrollContainer.classList.remove('hide');\n            this.setFiltersUnreadCount();\n          }\n          resolve();\n        }, 0);\n      });\n    }\n  }\n\n  private loadDialogs(side: SliceSides) {\n    /* if(testScroll) {\n      return;\n    } */\n    \n    if(this.loadDialogsPromise/*  || 1 === 1 */) return this.loadDialogsPromise;\n\n    const promise = new Promise<void>(async(resolve) => {\n      if(!this.chatList.childElementCount) {\n        const container = this.chatList.parentElement;\n        container.append(this.chatsPreloader);\n      }\n  \n      //return;\n  \n      const filterId = this.filterId;\n      let loadCount = 30/*this.chatsLoadCount */;\n      let offsetIndex = 0;\n      \n      const {index: currentOffsetIndex} = this.getOffsetIndex(side);\n      if(currentOffsetIndex) {\n        if(side === 'top') {\n          const storage = appMessagesManager.dialogsStorage.getFolder(filterId);\n          const index = storage.findIndex(dialog => dialog.index <= currentOffsetIndex);\n          const needIndex = Math.max(0, index - loadCount);\n          loadCount = index - needIndex;\n          offsetIndex = storage[needIndex].index + 1;\n        } else {\n          offsetIndex = currentOffsetIndex;\n        }\n      }\n      \n      //let offset = storage[storage.length - 1]?.index || 0;\n  \n      try {\n        //console.time('getDialogs time');\n  \n        const getConversationPromise = (this.filterId > 1 ? appUsersManager.getContacts() as Promise<any> : Promise.resolve()).then(() => {\n          return appMessagesManager.getConversations('', offsetIndex, loadCount, filterId);\n        });\n  \n        const result = await getConversationPromise;\n  \n        if(this.loadDialogsPromise !== promise) {\n          return;\n        }\n  \n        //console.timeEnd('getDialogs time');\n  \n        // * loaded all\n        //if(!result.dialogs.length || this.chatList.childElementCount === result.count) {\n        // !result.dialogs.length \u043d\u0435 \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442, \u0442\u0430\u043a \u043a\u0430\u043a \u043f\u0440\u0438 \u0441\u0443\u043f\u0435\u0440\u0434\u0440\u0435\u0432\u043d\u043e\u043c \u0434\u0438\u0430\u043b\u043e\u0433\u0435 getConversations \u0435\u0433\u043e \u043d\u0435 \u0432\u044b\u0434\u0430\u0441\u0442.\n        //if(this.chatList.childElementCount === result.count) {\n        if(side === 'bottom') {\n          if(result.isEnd) {\n            this.scroll.loadedAll[side] = true;\n          }\n        } else {\n          const storage = appMessagesManager.dialogsStorage.getFolder(filterId);\n          if(!result.dialogs.length || (storage.length && storage[0].index < offsetIndex)) {\n            this.scroll.loadedAll[side] = true;\n          }\n        }\n        \n        if(result.dialogs.length) {\n          const dialogs = side === 'top' ? result.dialogs.slice().reverse() : result.dialogs;\n  \n          dialogs.forEach((dialog) => {\n            this.addDialogNew({\n              dialog,\n              append: side === 'bottom'\n            });\n          });\n        }\n\n        const offsetDialog = result.dialogs[side === 'top' ? 0 : result.dialogs.length - 1];\n        if(offsetDialog) {\n          this.offsets[side] = offsetDialog.index;\n        }\n\n        this.onListLengthChange();\n  \n        this.log.debug('getDialogs ' + loadCount + ' dialogs by offset:', offsetIndex, result, this.chatList.childElementCount);\n  \n        setTimeout(() => {\n          this.scroll.onScroll();\n        }, 0);\n      } catch(err) {\n        this.log.error(err);\n      }\n      \n      this.chatsPreloader.remove();\n      resolve();\n    }).finally(() => {\n      this.loadDialogsPromise = undefined;\n    });\n\n    return this.loadDialogsPromise = promise;\n  }\n\n  private generateEmptyPlaceholder(options: {\n    title: LangPackKey,\n    subtitle?: LangPackKey,\n    subtitleArgs?: FormatterArguments,\n    classNameType: string\n  }) {\n    const BASE_CLASS = 'empty-placeholder';\n    const container = document.createElement('div');\n    container.classList.add(BASE_CLASS, BASE_CLASS + '-' + options.classNameType);\n    \n    const header = document.createElement('div');\n    header.classList.add(BASE_CLASS + '-header');\n    _i18n(header, options.title);\n\n    const subtitle = document.createElement('div');\n    subtitle.classList.add(BASE_CLASS + '-subtitle');\n    if(options.subtitle) {\n      _i18n(subtitle, options.subtitle, options.subtitleArgs);\n    }\n\n    container.append(header, subtitle);\n\n    return {container, header, subtitle};\n  }\n\n  private checkIfPlaceholderNeeded() {\n    if(this.filterId === 1) {\n      return;\n    }\n\n    const part = this.chatList.parentElement as HTMLElement;\n    let placeholderContainer = (Array.from(part.children) as HTMLElement[]).find(el => el.matches('.empty-placeholder'));\n    const needPlaceholder = this.scroll.loadedAll.bottom && !this.chatList.childElementCount/*  || true */;\n    // this.chatList.style.display = 'none';\n\n    if(needPlaceholder && placeholderContainer) {\n      return;\n    } else if(!needPlaceholder) {\n      if(placeholderContainer) {\n        part.classList.remove('with-placeholder');\n        placeholderContainer.remove();\n      }\n\n      return;\n    }\n\n    let placeholder: ReturnType<AppDialogsManager['generateEmptyPlaceholder']>;\n    if(!this.filterId) {\n      placeholder = this.generateEmptyPlaceholder({\n        title: 'ChatList.Main.EmptyPlaceholder.Title',\n        classNameType: 'dialogs'\n      });\n      \n      placeholderContainer = placeholder.container;\n      \n      const img = document.createElement('img');\n      img.classList.add('empty-placeholder-dialogs-icon');\n      \n      Promise.all([\n        appUsersManager.getContacts().then(users => {\n          let key: LangPackKey, args: FormatterArguments;\n\n          if(users.length) {\n            key = 'ChatList.Main.EmptyPlaceholder.Subtitle';\n            args = [i18n('Contacts.Count', [users.length])];\n          } else {\n            key = 'ChatList.Main.EmptyPlaceholder.SubtitleNoContacts';\n            args = [];\n          }\n\n          const subtitleEl = new I18n.IntlElement({\n            key,\n            args,\n            element: placeholder.subtitle\n          });\n        }),\n        renderImageFromUrlPromise(img, 'assets/img/EmptyChats.svg'),\n        fastRafPromise()\n      ]).then(() => {\n        placeholderContainer.classList.add('visible');\n      });\n\n      placeholderContainer.prepend(img);\n    } else {\n      placeholder = this.generateEmptyPlaceholder({\n        title: 'FilterNoChatsToDisplay',\n        subtitle: 'FilterNoChatsToDisplayInfo',\n        classNameType: 'folder'\n      });\n\n      placeholderContainer = placeholder.container;\n\n      placeholderContainer.prepend(wrapLocalSticker({\n        emoji: '\ud83d\udcc2',\n        width: 128,\n        height: 128\n      }).container)\n\n      const button = Button('btn-primary btn-color-primary btn-control tgico', {\n        text: 'FilterHeaderEdit',\n        icon: 'settings'\n      });\n\n      attachClickEvent(button, () => {\n        new AppEditFolderTab(appSidebarLeft).open(appMessagesManager.filtersStorage.filters[this.filterId]);\n      });\n\n      placeholderContainer.append(button);\n    }\n\n    part.append(placeholderContainer);\n    part.classList.add('with-placeholder');\n  }\n\n  private onListLengthChange = () => {\n    return;\n\n    this.checkIfPlaceholderNeeded();\n\n    if(this.filterId > 0) return;\n    const bottom = this.chatList.parentElement.nextElementSibling as HTMLElement;\n\n    if(bottom.childElementCount) return;\n\n    bottom.parentElement.classList.add('with-contacts');\n\n    const section = new SettingSection({\n      name: 'Contacts',\n      noDelimiter: true,\n      fakeGradientDelimiter: true\n    });\n\n    section.container.classList.add('hide');\n\n    appUsersManager.getContacts(undefined, undefined, 'online').then(contacts => {\n      const sortedUserList = new SortedUserList({avatarSize: 42, new: true});\n      this.loadContacts = () => {\n        const pageCount = appPhotosManager.windowH / 60 | 0;\n        const arr = contacts.splice(0, pageCount);\n\n        arr.forEach((peerId) => {\n          sortedUserList.add(peerId);\n        });\n\n        if(!contacts.length) {\n          this.loadContacts = undefined;\n        }\n      };\n\n      this.loadContacts();\n\n      const list = sortedUserList.list;\n      list.classList.add('chatlist-new');\n      this.setListClickListener(list);\n      section.content.append(list);\n      section.container.classList.remove('hide');\n    });\n\n    bottom.append(section.container);\n  };\n\n  public onChatsRegularScroll = () => {\n    if(this.sliceTimeout) clearTimeout(this.sliceTimeout);\n    this.sliceTimeout = window.setTimeout(() => {\n      this.sliceTimeout = undefined;\n      \n      if(this.reorderDialogsTimeout) {\n        this.onChatsRegularScroll();\n        return;\n      }\n\n      if(!this.chatList.childElementCount) {\n        return;\n      }\n\n      /* const observer = new IntersectionObserver((entries) => {\n        const \n      });\n\n      Array.from(this.chatList.children).forEach(el => {\n        observer.observe(el);\n      }); */\n\n      const scrollTopWas = this.scroll.scrollTop;\n\n      const firstElementChild = this.chatList.firstElementChild;\n      const rectContainer = this.scroll.container.getBoundingClientRect();\n      const rectTarget = firstElementChild.getBoundingClientRect();\n      const children = Array.from(this.scroll.splitUp.children) as HTMLElement[];\n\n      // const padding = 8;\n      // const offsetTop = this.folders.container.offsetTop;\n      let offsetTop = this.scroll.splitUp.offsetTop;\n      if(offsetTop && scrollTopWas < offsetTop) offsetTop -= scrollTopWas;\n      // const offsetTop = scrollTopWas < padding ? padding - scrollTopWas : 0;\n      const firstY = rectContainer.y + offsetTop;\n      const lastY = rectContainer.y/*  - 8 */; // 8px - .chatlist padding-bottom\n      \n      const firstElement = findUpTag(document.elementFromPoint(Math.ceil(rectTarget.x), Math.ceil(firstY + 1)), firstElementChild.tagName) as HTMLElement;\n      const lastElement = findUpTag(document.elementFromPoint(Math.ceil(rectTarget.x), Math.floor(lastY + rectContainer.height - 1)), firstElementChild.tagName) as HTMLElement;\n\n      //alert('got element:' + rect.y);\n\n      if(!firstElement || !lastElement) {\n        return;\n      }\n\n      //alert('got element:' + !!firstElement);\n\n      const firstElementRect = firstElement.getBoundingClientRect();\n      const elementOverflow = firstElementRect.y - firstY;\n\n      const sliced: HTMLElement[] = [];\n      const firstIndex = children.indexOf(firstElement);\n      const lastIndex = children.indexOf(lastElement);\n\n      const saveLength = 10;\n\n      const sliceFromStart = isSafari ? [] : children.slice(0, Math.max(0, firstIndex - saveLength));\n      const sliceFromEnd = children.slice(lastIndex + saveLength);\n\n      /* if(sliceFromStart.length !== sliceFromEnd.length) {\n        console.log('not equal', sliceFromStart.length, sliceFromEnd.length);\n      }\n\n      if(sliceFromStart.length > sliceFromEnd.length) {\n        const diff = sliceFromStart.length - sliceFromEnd.length;\n        sliceFromStart.splice(0, diff);\n      } else if(sliceFromEnd.length > sliceFromStart.length) {\n        const diff = sliceFromEnd.length - sliceFromStart.length;\n        sliceFromEnd.splice(sliceFromEnd.length - diff, diff);\n      } */\n\n      if(sliceFromStart.length) {\n        this.scroll.loadedAll.top = false;\n      }\n\n      if(sliceFromEnd.length) {\n        this.scroll.loadedAll.bottom = false;\n      }\n\n      sliced.push(...sliceFromStart);\n      sliced.push(...sliceFromEnd);\n\n      sliced.forEach(el => {\n        const peerId = +el.dataset.peerId;\n        this.deleteDialog(peerId);\n      });\n\n      this.setOffsets();\n\n      //this.log('[slicer] elements', firstElement, lastElement, rect, sliced, sliceFromStart.length, sliceFromEnd.length);\n\n      //this.log('[slicer] reset scrollTop', this.scroll.scrollTop, firstElement.offsetTop, firstElementRect.y, rect.y, elementOverflow);\n\n      //alert('left length:' + children.length);\n\n      this.scroll.scrollTop = firstElement.offsetTop - elementOverflow;\n      /* const firstElementRect = firstElement.getBoundingClientRect();\n      const scrollTop =  */\n\n      //this.scroll.scrollIntoView(firstElement, false);\n    }, 200);\n  };\n\n  private setOffsets() {\n    const firstDialog = this.getDialogFromElement(this.chatList.firstElementChild as HTMLElement);\n    const lastDialog = this.getDialogFromElement(this.chatList.lastElementChild as HTMLElement);\n\n    this.offsets.top = firstDialog.index;\n    this.offsets.bottom = lastDialog.index;\n  }\n\n  private getDialogFromElement(element: HTMLElement) {\n    return appMessagesManager.getDialogOnly(+element.dataset.peerId);\n  }\n\n  public onChatsScrollTop = () => {\n    this.onChatsScroll('top');\n  };\n  \n  public onChatsScroll = (side: SliceSides = 'bottom') => {\n    if(this.scroll.loadedAll[side]) {\n      if(this.loadContacts) {\n        this.loadContacts();\n      }\n\n      return;\n    } else if(this.loadDialogsPromise) return this.loadDialogsPromise;\n\n    this.log('onChatsScroll', side);\n    return this.loadDialogs(side);\n  };\n\n  public setListClickListener(list: HTMLUListElement, onFound?: () => void, withContext = false, autonomous = false, openInner = false) {\n    let lastActiveListElement: HTMLElement;\n\n    const setPeerFunc = (openInner ? appImManager.setInnerPeer : appImManager.setPeer).bind(appImManager);\n\n    list.dataset.autonomous = '' + +autonomous;\n    list.addEventListener('mousedown', (e) => {\n      if(e.button !== 0) return;\n      //cancelEvent(e);\n\n      this.log('dialogs click list');\n      const target = e.target as HTMLElement;\n      const elem = findUpTag(target, 'LI');\n\n      if(!elem) {\n        return;\n      }\n\n      if(autonomous) {\n        const sameElement = lastActiveListElement === elem;\n        if(lastActiveListElement && !sameElement) {\n          lastActiveListElement.classList.remove('active');\n        }\n\n        if(elem) {\n          elem.classList.add('active');\n          lastActiveListElement = elem;\n          this.lastActiveElements.add(elem);\n        }\n      }\n\n      if(elem) {\n        if(onFound) onFound();\n\n        const peerId = +elem.dataset.peerId;\n        const lastMsgId = +elem.dataset.mid || undefined;\n\n        setPeerFunc(peerId, lastMsgId);\n      } else {\n        setPeerFunc(0);\n      }\n    }, {capture: true});\n\n    if(DEBUG) {\n      list.addEventListener('dblclick', (e) => {\n        const li = findUpTag(e.target, 'LI');\n        if(li) {\n          const peerId = +li.dataset.peerId;\n          this.log('debug dialog:', appMessagesManager.getDialogByPeerId(peerId));\n        }\n      });\n    }\n\n    if(withContext) {\n      attachContextMenuListener(list, this.contextMenu.onContextMenu);\n    }\n  }\n\n  public createChatList(options: {\n    // avatarSize?: number,\n    // handheldsSize?: number,\n    // size?: number,\n    new?: boolean\n  } = {}) {\n    const list = document.createElement('ul');\n    list.classList.add('chatlist'/* , \n      'chatlist-avatar-' + (options.avatarSize || 54) *//* , 'chatlist-' + (options.size || 72) */);\n\n    if(options.new) {\n      list.classList.add('chatlist-new');\n    }\n\n    /* if(options.handheldsSize) {\n      list.classList.add('chatlist-handhelds-' + options.handheldsSize);\n    } */\n\n    return list;\n  }\n\n  private reorderDialogs() {\n    //const perf = performance.now();\n    if(this.reorderDialogsTimeout) {\n      window.cancelAnimationFrame(this.reorderDialogsTimeout);\n    }\n    \n    this.reorderDialogsTimeout = window.requestAnimationFrame(() => {\n      this.reorderDialogsTimeout = 0;\n      const dialogs = appMessagesManager.dialogsStorage.getFolder(this.filterId);\n\n      const currentOrder = (Array.from(this.chatList.children) as HTMLElement[]).map(el => +el.dataset.peerId);\n\n      const {index} = this.getOffsetIndex('top');\n      const pos = dialogs.findIndex(dialog => dialog.index <= index);\n\n      const offset = Math.max(0, pos);\n      dialogs.forEach((dialog, index) => {\n        const dom = this.getDialogDom(dialog.peerId);\n        if(!dom) {\n          return;\n        }\n  \n        const needIndex = index - offset;\n        if(needIndex > currentOrder.length) {\n          this.deleteDialog(dialog.peerId);\n          return;\n        }\n\n        const peerIdByIndex = currentOrder[needIndex];\n  \n        if(peerIdByIndex !== dialog.peerId) {\n          if(positionElementByIndex(dom.listEl, this.chatList, needIndex)) {\n            this.log.debug('setDialogPosition:', dialog, dom, peerIdByIndex, needIndex);\n          }\n        }\n      });\n  \n      //this.log('Reorder time:', performance.now() - perf);\n    });\n  }\n\n  public setLastMessage(dialog: Dialog, lastMessage?: any, dom?: DialogDom, highlightWord?: string) {\n    ///////console.log('setlastMessage:', lastMessage);\n    if(!dom) {\n      dom = this.getDialogDom(dialog.peerId);\n\n      if(!dom) {\n        //this.log.error('no dom for dialog:', dialog, lastMessage, dom, highlightWord);\n        return;\n      }\n    }\n\n    let draftMessage: MyDraftMessage;\n    if(!lastMessage) {\n      if(dialog.draft && dialog.draft._ === 'draftMessage') {\n        draftMessage = dialog.draft;\n      }\n      \n      lastMessage = appMessagesManager.getMessageByPeer(dialog.peerId, dialog.top_message);\n    }\n\n    if(lastMessage._ === 'messageEmpty'/*  || (lastMessage._ === 'messageService' && !lastMessage.rReply) */) {\n      dom.lastMessageSpan.innerHTML = '';\n      dom.lastTimeSpan.innerHTML = '';\n      delete dom.listEl.dataset.mid;\n      return;\n    }\n\n    let peer = dialog.peer;\n    let peerId = dialog.peerId;\n    //let peerId = appMessagesManager.getMessagePeer(lastMessage);\n\n    //console.log('setting last message:', lastMessage);\n\n    /* if(!dom.lastMessageSpan.classList.contains('user-typing')) */ {\n\n      dom.lastMessageSpan.textContent = '';\n      if(highlightWord && lastMessage.message) {\n        dom.lastMessageSpan.append(appMessagesManager.wrapMessageForReply(lastMessage, undefined, undefined, false, highlightWord));\n      } else if(draftMessage) {\n        dom.lastMessageSpan.append(appMessagesManager.wrapMessageForReply(draftMessage));\n      } else if(!lastMessage.deleted) {\n        dom.lastMessageSpan.append(appMessagesManager.wrapMessageForReply(lastMessage));\n      }\n  \n      /* if(lastMessage.from_id === auth.id) { // You:  */\n      if(draftMessage) {\n        const bold = document.createElement('b');\n        bold.classList.add('danger');\n        bold.append(i18n('Draft'));\n        bold.append(': ');\n        dom.lastMessageSpan.prepend(bold);\n      } else if(peer._ !== 'peerUser' && peerId !== lastMessage.fromId && !lastMessage.action) {\n        const sender = appPeersManager.getPeer(lastMessage.fromId);\n        if(sender && sender.id) {\n          const senderBold = document.createElement('b');\n\n          if(sender.id === rootScope.myId) {\n            senderBold.append(i18n('FromYou'));\n          } else {\n            //str = sender.first_name || sender.last_name || sender.username;\n            senderBold.append(new PeerTitle({\n              peerId: lastMessage.fromId,\n              onlyFirstName: true,\n            }).element);\n          }\n\n          senderBold.append(': ');\n          //console.log(sender, senderBold.innerText);\n          dom.lastMessageSpan.prepend(senderBold);\n        } //////// else console.log('no sender', lastMessage, peerId);\n      }\n    }\n\n    if(!lastMessage.deleted || draftMessage/*  && lastMessage._ !== 'draftMessage' */) {\n      const date = draftMessage ? Math.max(draftMessage.date, lastMessage.date || 0) : lastMessage.date;\n      dom.lastTimeSpan.textContent = '';\n      dom.lastTimeSpan.append(formatDateAccordingToTodayNew(new Date(date * 1000)));\n    } else dom.lastTimeSpan.textContent = '';\n\n    if(this.doms[peerId] === dom) {\n      this.setUnreadMessages(dialog);\n    } else { // means search\n      dom.listEl.dataset.mid = lastMessage.mid;\n    }\n  }\n\n  private setUnreadMessages(dialog: Dialog) {\n    const dom = this.getDialogDom(dialog.peerId);\n\n    if(dialog.folder_id === 1) {\n      this.accumulateArchivedUnread();\n    }\n\n    if(!dom) {\n      //this.log.error('setUnreadMessages no dom!', dialog);\n      return;\n    }\n\n    const isMuted = appNotificationsManager.isPeerLocalMuted(dialog.peerId, true);\n    const wasMuted = dom.listEl.classList.contains('is-muted');\n    if(isMuted !== wasMuted) {\n      SetTransition(dom.listEl, 'is-muted', isMuted, 200);\n    }\n\n    const lastMessage = dialog.draft && dialog.draft._ === 'draftMessage' ? \n      dialog.draft : \n      appMessagesManager.getMessageByPeer(dialog.peerId, dialog.top_message);\n    if(lastMessage._ !== 'messageEmpty' && !lastMessage.deleted && \n      lastMessage.pFlags.out && lastMessage.peerId !== rootScope.myId/*  && \n      dialog.read_outbox_max_id */) { // maybe comment, 06.20.2020\n      const outgoing = (lastMessage.pFlags && lastMessage.pFlags.unread)\n        /*  && dialog.read_outbox_max_id !== 0 */; // maybe uncomment, 31.01.2020\n    \n      //console.log('outgoing', outgoing, lastMessage);\n  \n      if(outgoing) {\n        dom.statusSpan.classList.remove('tgico-checks');\n        dom.statusSpan.classList.add('tgico-check');\n      } else {\n        dom.statusSpan.classList.remove('tgico-check');\n        dom.statusSpan.classList.add('tgico-checks');\n      }\n    } else dom.statusSpan.classList.remove('tgico-check', 'tgico-checks');\n\n    dom.unreadMessagesSpan.innerText = '';\n\n    const filter = appMessagesManager.filtersStorage.filters[this.filterId];\n    let isPinned: boolean;\n    if(filter) {\n      isPinned = filter.pinned_peers.findIndex(peerId => peerId === dialog.peerId) !== -1;\n    } else {\n      isPinned = !!dialog.pFlags.pinned;\n    }\n\n    if(isPinned) {\n      dom.unreadMessagesSpan.classList.add('tgico-chatspinned', 'tgico');\n    } else {\n      dom.unreadMessagesSpan.classList.remove('tgico-chatspinned', 'tgico');\n    }\n\n    if(dialog.unread_count || dialog.pFlags.unread_mark) {\n      //dom.unreadMessagesSpan.innerText = '' + (dialog.unread_count ? formatNumber(dialog.unread_count, 1) : ' ');\n      dom.unreadMessagesSpan.innerText = '' + (dialog.unread_count || ' ');\n      dom.unreadMessagesSpan.classList.add('unread');\n    } else {\n      dom.unreadMessagesSpan.classList.remove('unread');\n    }\n  }\n\n  private accumulateArchivedUnread() {\n    if(this.accumulateArchivedTimeout) return;\n    this.accumulateArchivedTimeout = window.setTimeout(() => {\n      this.accumulateArchivedTimeout = 0;\n      const dialogs = appMessagesManager.dialogsStorage.getFolder(1);\n      const sum = dialogs.reduce((acc, dialog) => acc + dialog.unread_count, 0);\n      rootScope.dispatchEvent('dialogs_archived_unread', {count: sum});\n    }, 0);\n  }\n\n  private getDialogDom(peerId: number) {\n    return this.doms[peerId];\n  }\n\n  public addDialogNew(options: {\n    dialog: Dialog | number,\n    container?: HTMLUListElement | Scrollable | false,\n    drawStatus?: boolean,\n    rippleEnabled?: boolean,\n    onlyFirstName?: boolean,\n    meAsSaved?: boolean,\n    append?: boolean,\n    avatarSize?: number,\n    autonomous?: boolean,\n    lazyLoadQueue?: LazyLoadQueueIntersector,\n  }) {\n    return this.addDialog(options.dialog, options.container, options.drawStatus, options.rippleEnabled, options.onlyFirstName, options.meAsSaved, options.append, options.avatarSize, options.autonomous, options.lazyLoadQueue);\n  }\n\n  public addDialog(_dialog: Dialog | number, container?: HTMLUListElement | Scrollable | false, drawStatus = true, rippleEnabled = true, onlyFirstName = false, meAsSaved = true, append = true, avatarSize = 54, autonomous = !!container, lazyLoadQueue?: LazyLoadQueueIntersector) {\n    let dialog: Dialog;\n    \n    if(typeof(_dialog) === 'number') {\n      let originalDialog = appMessagesManager.getDialogOnly(_dialog);\n      if(!originalDialog) {\n        originalDialog = {\n          peerId: _dialog,\n          peer: appPeersManager.getOutputPeer(_dialog),\n          pFlags: {}\n        } as any;\n      }\n\n      dialog = originalDialog;\n    } else {\n      dialog = _dialog;\n    }\n\n    const peerId: number = dialog.peerId;\n\n    if(container === undefined) {\n      if(this.doms[peerId] || dialog.migratedTo !== undefined) return;\n\n      const filter = appMessagesManager.filtersStorage.filters[this.filterId];\n      if((filter && !appMessagesManager.filtersStorage.testDialogForFilter(dialog, filter)) || (!filter && this.filterId !== dialog.folder_id)) {\n        return;\n      }\n    }\n\n    const avatarEl = new AvatarElement();\n    avatarEl.lazyLoadQueue = lazyLoadQueue;\n    avatarEl.setAttribute('dialog', meAsSaved ? '1' : '0');\n    avatarEl.setAttribute('peer', '' + peerId);\n    avatarEl.classList.add('dialog-avatar', 'avatar-' + avatarSize);\n\n    if(drawStatus && peerId !== rootScope.myId && dialog.peer) {\n      const peer = dialog.peer;\n      \n      switch(peer._) {\n        case 'peerUser':\n          const user = appUsersManager.getUser(peerId);\n          //console.log('found user', user);\n  \n          if(user.status && user.status._ === 'userStatusOnline') {\n            avatarEl.classList.add('is-online');\n          }\n  \n          break;\n        default:\n          break;\n      }\n    }\n\n    const captionDiv = document.createElement('div');\n    captionDiv.classList.add('user-caption');\n\n    const titleSpanContainer = document.createElement('span');\n    titleSpanContainer.classList.add('user-title');\n\n    const peerTitle = new PeerTitle({\n      peerId,\n      dialog: meAsSaved,\n      onlyFirstName,\n      plainText: false\n    });\n\n    titleSpanContainer.append(peerTitle.element);\n    //p.classList.add('')\n\n    // \u0432 \u0434\u0440\u0443\u0433\u0438\u0445 \u0441\u043b\u0443\u0447\u0430\u044f\u0445 \u0438\u043a\u043e\u043d\u043a\u0430 \u0432\u0435\u0440\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 \u043d\u0435 \u043d\u0443\u0436\u043d\u0430 (\u0430 \u043f\u0435\u0440\u0432\u044b\u0439 - \u044d\u0442\u043e \u0433\u043b\u0430\u0432\u043d\u044b\u0435 \u0447\u0430\u0442\u043b\u0438\u0441\u0442\u044b)\n    //if(!container) {\n      const peer = appPeersManager.getPeer(peerId);\n\n      // for muted icon\n      titleSpanContainer.classList.add('tgico'); // * \u044d\u0442\u0430 \u0441\u0442\u0440\u043e\u043a\u0430 \u0431\u0443\u0434\u0435\u0442 \u0430\u043a\u0442\u0443\u0430\u043b\u044c\u043d\u0430 \u0442\u043e\u043b\u044c\u043a\u043e \u0434\u043b\u044f !container, \u043d\u043e \u043b\u0430\u0434\u043d\u043e\n\n      if(peer?.pFlags?.verified) {\n        titleSpanContainer.classList.add('is-verified');\n        titleSpanContainer.append(generateVerifiedIcon());\n      }\n    //}\n    \n    const span = document.createElement('span');\n    span.classList.add('user-last-message');\n    span.setAttribute('dir', 'auto');\n\n    //captionDiv.append(titleSpan);\n    //captionDiv.append(span);\n\n    const li = document.createElement('li');\n    if(rippleEnabled) {\n      ripple(li);\n    }\n\n    li.append(avatarEl, captionDiv);\n    li.dataset.peerId = '' + peerId;\n\n    const statusSpan = document.createElement('span');\n    statusSpan.classList.add('message-status');\n\n    const lastTimeSpan = document.createElement('span');\n    lastTimeSpan.classList.add('message-time');\n\n    const unreadMessagesSpan = document.createElement('div');\n    unreadMessagesSpan.className = 'dialog-subtitle-badge badge badge-24';\n\n    const titleP = document.createElement('p');\n    titleP.classList.add('dialog-title');\n\n    const rightSpan = document.createElement('span');\n    rightSpan.classList.add('dialog-title-details');\n    rightSpan.append(statusSpan, lastTimeSpan);\n    titleP.append(titleSpanContainer, rightSpan);\n\n    const messageP = document.createElement('p');\n    messageP.classList.add('dialog-subtitle');\n    messageP.append(span, unreadMessagesSpan);\n\n    captionDiv.append(titleP, messageP);\n\n    const dom: DialogDom = {\n      avatarEl,\n      captionDiv,\n      titleSpan: peerTitle.element,\n      titleSpanContainer,\n      statusSpan,\n      lastTimeSpan,\n      unreadMessagesSpan,\n      lastMessageSpan: span,\n      containerEl: li,\n      listEl: li\n    };\n\n    /* let good = false;\n    for(const folderId in this.chatLists) {\n      if(this.chatLists[folderId] === container) {\n        good = true;\n      }\n    } */\n    const method: 'append' | 'prepend' = append ? 'append' : 'prepend';\n    if(container === undefined/*  || good */) {\n      this.scroll[method](li);\n\n      this.doms[dialog.peerId] = dom;\n\n      /* if(container) {\n        container.append(li);\n      } */\n\n      const isMuted = appNotificationsManager.isPeerLocalMuted(dialog.peerId, true);\n      if(isMuted) {\n        li.classList.add('is-muted');\n      }\n\n      this.setLastMessage(dialog);\n    } else if(container) {\n      container[method](li);\n    }\n\n    if(!autonomous && appImManager.chat?.peerId === peerId) {\n      li.classList.add('active');\n      this.lastActiveElements.add(li);\n    } \n    \n    return {dom, dialog};\n  }\n\n  public setTyping(dialog: Dialog) {\n    const dom = this.getDialogDom(dialog.peerId);\n    if(!dom) {\n      return;\n    }\n\n    let typingElement = dom.lastMessageSpan.querySelector('.peer-typing-container') as HTMLElement;\n    if(typingElement) {\n      appImManager.getPeerTyping(dialog.peerId, typingElement);\n    } else {\n      typingElement = appImManager.getPeerTyping(dialog.peerId);\n      replaceContent(dom.lastMessageSpan, typingElement);\n      dom.lastMessageSpan.classList.add('user-typing');\n    }\n  }\n\n  public unsetTyping(dialog: Dialog) {\n    const dom = this.getDialogDom(dialog.peerId);\n    if(!dom) {\n      return;\n    }\n\n    dom.lastMessageSpan.classList.remove('user-typing');\n    this.setLastMessage(dialog, null, dom);\n  }\n}\n\nexport function generateVerifiedIcon() {\n  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n  svg.setAttributeNS(null, 'viewBox', '0 0 24 24');\n  svg.setAttributeNS(null, 'width', '24');\n  svg.setAttributeNS(null, 'height', '24');\n  svg.classList.add('verified-icon');\n\n  const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');\n  use.setAttributeNS(null, 'href', '#verified-background');\n  use.classList.add('verified-background');\n\n  const use2 = document.createElementNS('http://www.w3.org/2000/svg', 'use');\n  use2.setAttributeNS(null, 'href', '#verified-check');\n  use2.classList.add('verified-check');\n\n  svg.append(use, use2);\n\n  return svg;\n}\n\nconst appDialogsManager = new AppDialogsManager();\nMOUNT_CLASS_TO.appDialogsManager = appDialogsManager;\nexport default appDialogsManager;\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport { FileURLType, getFileNameByLocation, getFileURL } from '../../helpers/fileName';\nimport { safeReplaceArrayInObject, defineNotNumerableProperties, isObject } from '../../helpers/object';\nimport { Document, InputFileLocation, PhotoSize } from '../../layer';\nimport referenceDatabase, { ReferenceContext } from '../mtproto/referenceDatabase';\nimport opusDecodeController from '../opusDecodeController';\nimport { RichTextProcessor } from '../richtextprocessor';\nimport webpWorkerController from '../webp/webpWorkerController';\nimport appDownloadManager, { DownloadBlob } from './appDownloadManager';\nimport appPhotosManager from './appPhotosManager';\nimport blur from '../../helpers/blur';\nimport apiManager from '../mtproto/mtprotoworker';\nimport { MOUNT_CLASS_TO } from '../../config/debug';\nimport { getFullDate } from '../../helpers/date';\n\nexport type MyDocument = Document.document;\n\n// TODO: \u0435\u0441\u043b\u0438 \u0437\u0430\u043b\u0438\u0442\u044c \u043a\u0430\u0440\u0442\u0438\u043d\u043a\u0443 \u0444\u0430\u0439\u043b\u043e\u043c, \u0430 \u043f\u043e\u0442\u043e\u043c \u043f\u0435\u0440\u0435\u0437\u0430\u0439\u0442\u0438 \u0432 \u0434\u0438\u0430\u043b\u043e\u0433 - \u043f\u0440\u0435\u0432\u044c\u044e\u0448\u043a\u0430 \u0437\u0430\u043d\u043e\u0432\u043e \u0441\u043a\u0430\u0447\u0430\u0435\u0442\u0441\u044f\n\nexport class AppDocsManager {\n  private docs: {[docId: string]: MyDocument} = {};\n  private savingLottiePreview: {[docId: string]: true} = {};\n\n  constructor() {\n    apiManager.onServiceWorkerFail = this.onServiceWorkerFail;\n  }\n\n  public onServiceWorkerFail = () => {\n    for(const id in this.docs) {\n      const doc = this.docs[id];\n\n      if(doc.supportsStreaming) {\n        delete doc.supportsStreaming;\n        const cacheContext = appDownloadManager.getCacheContext(doc);\n        delete cacheContext.url;\n      }\n    }\n  };\n\n  public saveDoc(doc: Document, context?: ReferenceContext): MyDocument {\n    if(doc._ === 'documentEmpty') {\n      return undefined;\n    }\n\n    const oldDoc = this.docs[doc.id];\n\n    if(doc.file_reference) { // * because we can have a new object w/o the file_reference while sending\n      safeReplaceArrayInObject('file_reference', oldDoc, doc);\n      referenceDatabase.saveContext(doc.file_reference, context);\n    }\n    \n    //console.log('saveDoc', apiDoc, this.docs[apiDoc.id]);\n    // if(oldDoc) {\n    //   //if(doc._ !== 'documentEmpty' && doc._ === d._) {\n    //     if(doc.thumbs) {\n    //       if(!oldDoc.thumbs) oldDoc.thumbs = doc.thumbs;\n    //       /* else if(apiDoc.thumbs[0].bytes && !d.thumbs[0].bytes) {\n    //         d.thumbs.unshift(apiDoc.thumbs[0]);\n    //       } else if(d.thumbs[0].url) { // fix for converted thumb in safari\n    //         apiDoc.thumbs[0] = d.thumbs[0];\n    //       } */\n    //     }\n\n    //   //}\n\n    //   return oldDoc;\n\n    //   //return Object.assign(d, apiDoc, context);\n    //   //return context ? Object.assign(d, context) : d;\n    // }\n\n    if(!oldDoc) {\n      this.docs[doc.id] = doc;\n    }\n\n    // * exclude from state\n    // defineNotNumerableProperties(doc, [/* 'thumbs',  */'type', 'h', 'w', 'file_name', \n    // 'file', 'duration', 'downloaded', 'url', 'audioTitle', \n    // 'audioPerformer', 'sticker', 'stickerEmoji', 'stickerEmojiRaw', \n    // 'stickerSetInput', 'stickerThumbConverted', 'animated', 'supportsStreaming']);\n\n    doc.attributes.forEach(attribute => {\n      switch(attribute._) {\n        case 'documentAttributeFilename':\n          doc.file_name = RichTextProcessor.wrapPlainText(attribute.file_name);\n          doc.fileName = RichTextProcessor.wrapEmojiText(attribute.file_name);\n          break;\n\n        case 'documentAttributeAudio':\n          doc.duration = attribute.duration;\n          doc.audioTitle = RichTextProcessor.wrapEmojiText(attribute.title);\n          doc.audioPerformer = RichTextProcessor.wrapEmojiText(attribute.performer);\n          doc.type = attribute.pFlags.voice && doc.mime_type === 'audio/ogg' ? 'voice' : 'audio';\n          /* if(apiDoc.type === 'audio') {\n            apiDoc.supportsStreaming = true;\n          } */\n          break;\n\n        case 'documentAttributeVideo':\n          doc.duration = attribute.duration;\n          doc.w = attribute.w;\n          doc.h = attribute.h;\n          //apiDoc.supportsStreaming = attribute.pFlags?.supports_streaming/*  && apiDoc.size > 524288 */;\n          if(/* apiDoc.thumbs &&  */attribute.pFlags.round_message) {\n            doc.type = 'round';\n          } else /* if(apiDoc.thumbs) */ {\n            doc.type = 'video';\n          }\n          break;\n\n        case 'documentAttributeSticker':\n          if(attribute.alt !== undefined) {\n            doc.stickerEmojiRaw = attribute.alt;\n            doc.stickerEmoji = RichTextProcessor.wrapRichText(doc.stickerEmojiRaw, {noLinks: true, noLinebreaks: true});\n          }\n\n          if(attribute.stickerset) {\n            if(attribute.stickerset._ === 'inputStickerSetEmpty') {\n              delete attribute.stickerset;\n            } else if(attribute.stickerset._ === 'inputStickerSetID') {\n              doc.stickerSetInput = attribute.stickerset;\n            }\n          }\n\n          // * there can be no thumbs, then it is a document\n          if(/* apiDoc.thumbs &&  */doc.mime_type === 'image/webp' && (doc.thumbs || webpWorkerController.isWebpSupported())) {\n            doc.type = 'sticker';\n            doc.sticker = 1;\n          }\n          break;\n\n        case 'documentAttributeImageSize':\n          doc.type = 'photo';\n          doc.w = attribute.w;\n          doc.h = attribute.h;\n          break;\n\n        case 'documentAttributeAnimated':\n          if((doc.mime_type === 'image/gif' || doc.mime_type === 'video/mp4')/*  && apiDoc.thumbs */) {\n            doc.type = 'gif';\n          }\n\n          doc.animated = true;\n          break;\n      }\n    });\n    \n    if(!doc.mime_type) {\n      switch(doc.type) {\n        case 'gif':\n        case 'video':\n        case 'round':\n          doc.mime_type = 'video/mp4';\n          break;\n        case 'sticker':\n          doc.mime_type = 'image/webp';\n          break;\n        case 'audio':\n          doc.mime_type = 'audio/mpeg';\n          break;\n        case 'voice':\n          doc.mime_type = 'audio/ogg';\n          break;\n        default:\n          doc.mime_type = 'application/octet-stream';\n          break;\n      }\n    }\n\n    if(doc.mime_type === 'application/pdf') {\n      doc.type = 'pdf';\n    }\n\n    if(doc.type === 'voice' || doc.type === 'round') {\n      // browser will identify extension\n      doc.file_name = doc.fileName = doc.type + '_' + getFullDate(new Date(doc.date * 1000), {monthAsNumber: true, leadingZero: true}).replace(/[:\\.]/g, '-').replace(', ', '_');\n    }\n\n    if(apiManager.isServiceWorkerOnline()) {\n      if((doc.type === 'gif' && doc.size > 8e6) || doc.type === 'audio' || doc.type === 'video') {\n        doc.supportsStreaming = true;\n        \n        const cacheContext = appDownloadManager.getCacheContext(doc);\n        if(!cacheContext.url) {\n          cacheContext.url = this.getFileURL(doc);\n        }\n      }\n    }\n\n    // for testing purposes\n    // doc.supportsStreaming = false;\n    // doc.url = ''; // * this will break upload urls\n    \n    if(!doc.file_name) {\n      doc.file_name = doc.fileName = '';\n    }\n\n    if(doc.mime_type === 'application/x-tgsticker' && doc.file_name === 'AnimatedSticker.tgs') {\n      doc.type = 'sticker';\n      doc.animated = true;\n      doc.sticker = 2;\n    }\n\n    /* if(!doc.url) {\n      doc.url = this.getFileURL(doc);\n    } */\n\n    if(oldDoc) {\n      return Object.assign(oldDoc, doc);\n    }\n\n    return doc;\n  }\n  \n  public getDoc(docId: string | MyDocument): MyDocument {\n    return isObject(docId) && typeof(docId) !== 'string' ? docId as any : this.docs[docId as string] as any;\n  }\n\n  public getMediaInput(doc: MyDocument) {\n    return {\n      _: 'inputMediaDocument',\n      id: {\n        _: 'inputDocument',\n        id: doc.id,\n        access_hash: doc.access_hash,\n        file_reference: doc.file_reference\n      },\n      ttl_seconds: 0\n    };\n  }\n\n  public getInput(doc: MyDocument, thumbSize?: string): InputFileLocation.inputDocumentFileLocation {\n    return {\n      _: 'inputDocumentFileLocation',\n      id: doc.id,\n      access_hash: doc.access_hash,\n      file_reference: doc.file_reference,\n      thumb_size: thumbSize\n    };\n  }\n\n  public getFileDownloadOptions(doc: MyDocument, thumb?: PhotoSize.photoSize, queueId?: number, onlyCache?: boolean) {\n    const inputFileLocation = this.getInput(doc, thumb?.type);\n\n    let mimeType: string;\n    if(thumb) {\n      mimeType = doc.sticker ? 'image/webp' : 'image/jpeg'/* doc.mime_type */;\n    } else {\n      mimeType = doc.mime_type || 'application/octet-stream';\n    }\n\n    return {\n      dcId: doc.dc_id, \n      location: inputFileLocation, \n      size: thumb ? thumb.size : doc.size, \n      mimeType,\n      fileName: doc.file_name,\n      queueId,\n      onlyCache\n    };\n  }\n\n  public getFileURL(doc: MyDocument, download = false, thumb?: PhotoSize.photoSize) {\n    let type: FileURLType;\n    if(download) {\n      type = 'download';\n    } else if(thumb) {\n      type = 'thumb';\n    } else if(doc.supportsStreaming) {\n      type = 'stream';\n    } else {\n      type = 'document';\n    }\n\n    return getFileURL(type, this.getFileDownloadOptions(doc, thumb));\n  }\n\n  public getThumbURL(doc: MyDocument, thumb: PhotoSize.photoSize | PhotoSize.photoCachedSize | PhotoSize.photoStrippedSize) {\n    let promise: Promise<any> = Promise.resolve();\n\n    const cacheContext = appDownloadManager.getCacheContext(doc, thumb.type);\n    if(!cacheContext.url) {\n      if('bytes' in thumb) {\n        promise = blur(appPhotosManager.getPreviewURLFromBytes(thumb.bytes, !!doc.sticker)).then(url => {\n          cacheContext.url = url;\n        }) as any;\n      } else {\n        //return this.getFileURL(doc, false, thumb);\n        promise = appPhotosManager.preloadPhoto(doc, thumb) as any;\n      }\n    }\n\n    return {thumb, cacheContext, promise};\n  }\n\n  public getThumb(doc: MyDocument, tryNotToUseBytes = true) {\n    const thumb = appPhotosManager.choosePhotoSize(doc, 0, 0, !tryNotToUseBytes);\n    if(thumb._ === 'photoSizeEmpty') return null;\n    return this.getThumbURL(doc, thumb as any);\n  }\n\n  public getInputFileName(doc: MyDocument, thumbSize?: string) {\n    return getFileNameByLocation(this.getInput(doc, thumbSize), {fileName: doc.file_name});\n  }\n\n  public downloadDoc(doc: MyDocument, queueId?: number, onlyCache?: boolean): DownloadBlob {\n    const fileName = this.getInputFileName(doc);\n\n    let download: DownloadBlob = appDownloadManager.getDownload(fileName);\n    if(download) {\n      return download;\n    }\n\n    const downloadOptions = this.getFileDownloadOptions(doc, undefined, queueId, onlyCache);\n    download = appDownloadManager.download(downloadOptions);\n\n    const cacheContext = appDownloadManager.getCacheContext(doc);\n    const originalPromise = download;\n    originalPromise.then((blob) => {\n      cacheContext.url = URL.createObjectURL(blob);\n      cacheContext.downloaded = blob.size;\n    }, () => {});\n    \n    if(doc.type === 'voice' && !opusDecodeController.isPlaySupported()) {\n      download = originalPromise.then(async(blob) => {\n        const reader = new FileReader();\n  \n        await new Promise<void>((resolve, reject) => {\n          reader.onloadend = (e) => {\n            const uint8 = new Uint8Array(e.target.result as ArrayBuffer);\n            //console.log('sending uint8 to decoder:', uint8);\n            opusDecodeController.decode(uint8).then(result => {\n              cacheContext.url = result.url;\n              resolve();\n            }, (err) => {\n              delete cacheContext.downloaded;\n              reject(err);\n            });\n          };\n    \n          reader.readAsArrayBuffer(blob);\n        });\n  \n        return blob;\n      });\n    }\n\n    return download;\n  }\n\n  public saveLottiePreview(doc: MyDocument, canvas: HTMLCanvasElement, toneIndex: number) {\n    const key = doc.id + '-' + toneIndex;\n    if(this.savingLottiePreview[key]/*  || true */) return;\n\n    if(!doc.stickerCachedThumbs) {\n      defineNotNumerableProperties(doc, ['stickerCachedThumbs']);\n      doc.stickerCachedThumbs = {};\n    }\n\n    const thumb = doc.stickerCachedThumbs[toneIndex];\n    if(thumb && thumb.w >= canvas.width && thumb.h >= canvas.height) {\n      return;\n    }\n\n    /* if(doc.thumbs.find(t => t._ === 'photoStrippedSize') \n      || (doc.stickerCachedThumb || (doc.stickerSavedThumbWidth >= canvas.width && doc.stickerSavedThumbHeight >= canvas.height))) {\n      return;\n    } */\n\n    this.savingLottiePreview[key] = true;\n    canvas.toBlob((blob) => {\n      //console.log('got lottie preview', doc, blob, URL.createObjectURL(blob));\n\n      const thumb = {\n        url: URL.createObjectURL(blob),\n        w: canvas.width,\n        h: canvas.height\n      };\n\n      doc.stickerCachedThumbs[toneIndex] = thumb;\n\n      delete this.savingLottiePreview[key];\n      \n      /* const reader = new FileReader();\n      reader.onloadend = (e) => {\n        const uint8 = new Uint8Array(e.target.result as ArrayBuffer);\n        const thumb: PhotoSize.photoStrippedSize = {\n          _: 'photoStrippedSize',\n          bytes: uint8,\n          type: 'i'\n        };\n\n        doc.stickerSavedThumbWidth = canvas.width;\n        doc.stickerSavedThumbHeight = canvas.width;\n\n        defineNotNumerableProperties(thumb, ['url']);\n        thumb.url = URL.createObjectURL(blob);\n        doc.thumbs.findAndSplice(t => t._ === thumb._);\n        doc.thumbs.unshift(thumb);\n\n        if(!webpWorkerController.isWebpSupported()) {\n          doc.pFlags.stickerThumbConverted = true;\n        }\n\n        delete this.savingLottiePreview[doc.id];\n      };\n      reader.readAsArrayBuffer(blob); */\n    });\n  }\n\n  public saveDocFile(doc: MyDocument, queueId?: number) {\n    /* const options = this.getFileDownloadOptions(doc, undefined, queueId);\n    return appDownloadManager.downloadToDisc(options, doc.file_name); */\n    const promise = this.downloadDoc(doc, queueId);\n    promise.then(() => {\n      const cacheContext = appDownloadManager.getCacheContext(doc);\n      appDownloadManager.createDownloadAnchor(cacheContext.url, doc.file_name);\n    });\n    return promise;\n  }\n}\n\nconst appDocsManager = new AppDocsManager();\nMOUNT_CLASS_TO.appDocsManager = appDocsManager;\nexport default appDocsManager;\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport { LazyLoadQueueBase } from \"../../components/lazyLoadQueue\";\nimport ProgressivePreloader from \"../../components/preloader\";\nimport { CancellablePromise, deferredPromise } from \"../../helpers/cancellablePromise\";\nimport { formatTime, tsNow } from \"../../helpers/date\";\nimport { createPosterForVideo } from \"../../helpers/files\";\nimport { copy, getObjectKeysAndSort } from \"../../helpers/object\";\nimport { randomLong } from \"../../helpers/random\";\nimport { splitStringByLength, limitSymbols, escapeRegExp } from \"../../helpers/string\";\nimport { Chat, ChatFull, Dialog as MTDialog, DialogPeer, DocumentAttribute, InputMedia, InputMessage, InputPeerNotifySettings, InputSingleMedia, Message, MessageAction, MessageEntity, MessageFwdHeader, MessageMedia, MessageReplies, MessageReplyHeader, MessagesDialogs, MessagesFilter, MessagesMessages, MethodDeclMap, NotifyPeer, PeerNotifySettings, PhotoSize, SendMessageAction, Update, Photo, Updates, ReplyMarkup, InputPeer } from \"../../layer\";\nimport { InvokeApiOptions } from \"../../types\";\nimport I18n, { i18n, join, langPack, LangPackKey, _i18n } from \"../langPack\";\nimport { logger, LogTypes } from \"../logger\";\nimport type { ApiFileManager } from '../mtproto/apiFileManager';\n//import apiManager from '../mtproto/apiManager';\nimport apiManager from '../mtproto/mtprotoworker';\nimport referenceDatabase, { ReferenceContext } from \"../mtproto/referenceDatabase\";\nimport serverTimeManager from \"../mtproto/serverTimeManager\";\nimport { RichTextProcessor } from \"../richtextprocessor\";\nimport rootScope from \"../rootScope\";\nimport DialogsStorage from \"../storages/dialogs\";\nimport FiltersStorage from \"../storages/filters\";\n//import { telegramMeWebService } from \"../mtproto/mtproto\";\nimport apiUpdatesManager from \"./apiUpdatesManager\";\nimport appChatsManager from \"./appChatsManager\";\nimport appDocsManager, { MyDocument } from \"./appDocsManager\";\nimport appDownloadManager from \"./appDownloadManager\";\nimport appPeersManager from \"./appPeersManager\";\nimport appPhotosManager, { MyPhoto } from \"./appPhotosManager\";\nimport appPollsManager from \"./appPollsManager\";\nimport appStateManager from \"./appStateManager\";\nimport appUsersManager from \"./appUsersManager\";\nimport appWebPagesManager from \"./appWebPagesManager\";\nimport appDraftsManager from \"./appDraftsManager\";\nimport { getFileNameByLocation } from \"../../helpers/fileName\";\nimport appProfileManager from \"./appProfileManager\";\nimport DEBUG, { MOUNT_CLASS_TO } from \"../../config/debug\";\nimport SlicedArray, { Slice, SliceEnd } from \"../../helpers/slicedArray\";\nimport appNotificationsManager, { NotifyOptions } from \"./appNotificationsManager\";\nimport PeerTitle from \"../../components/peerTitle\";\nimport { forEachReverse } from \"../../helpers/array\";\nimport htmlToDocumentFragment from \"../../helpers/dom/htmlToDocumentFragment\";\nimport htmlToSpan from \"../../helpers/dom/htmlToSpan\";\nimport { REPLIES_PEER_ID } from \"../mtproto/mtproto_config\";\nimport formatCallDuration from \"../../helpers/formatCallDuration\";\nimport appAvatarsManager from \"./appAvatarsManager\";\nimport telegramMeWebManager from \"../mtproto/telegramMeWebManager\";\nimport { getMiddleware } from \"../../helpers/middleware\";\nimport assumeType from \"../../helpers/assumeType\";\n\n//console.trace('include');\n// TODO: \u0435\u0441\u043b\u0438 \u0443\u0434\u0430\u043b\u0438\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0432 \u043d\u0435\u043f\u0440\u043e\u0433\u0440\u0443\u0436\u0435\u043d\u043d\u043e\u043c \u0434\u0438\u0430\u043b\u043e\u0433\u0435, \u0442\u043e \u043f\u0440\u0438 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0438, \u0438\u0437-\u0437\u0430 \u0441\u0442\u0435\u0439\u0442\u0430, \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0432 \u0447\u0430\u0442\u043b\u0438\u0441\u0442\u0435 \u043d\u0435 \u0431\u0443\u0434\u0435\u0442\n// TODO: \u0435\u0441\u043b\u0438 \u0443\u0434\u0430\u043b\u0438\u0442\u044c \u0434\u0438\u0430\u043b\u043e\u0433 \u043d\u0430\u0445\u043e\u0434\u044f\u0441\u044c \u0432 \u043f\u0430\u043f\u043a\u0435, \u0442\u043e \u043e\u043d \u043d\u0435 \u0443\u0434\u0430\u043b\u0438\u0442\u0441\u044f \u0438\u0437 \u043f\u0430\u043f\u043a\u0438 \u0438 \u0431\u0443\u0434\u0435\u0442 \u0432\u0438\u0434\u0435\u043d \u0432 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430\u0445\n\nconst APITIMEOUT = 0;\n\nexport type HistoryStorage = {\n  count: number | null,\n  history: SlicedArray,\n\n  maxId?: number,\n  readPromise?: Promise<void>,\n  readMaxId?: number,\n  readOutboxMaxId?: number,\n  triedToReadMaxId?: number,\n\n  maxOutId?: number,\n  reply_markup?: Exclude<ReplyMarkup, ReplyMarkup.replyInlineMarkup>\n};\n\nexport type HistoryResult = {\n  count: number,\n  history: Slice,\n  offsetIdOffset?: number,\n};\n\nexport type Dialog = MTDialog.dialog;\n\nexport type MyMessage = Message.message | Message.messageService;\nexport type MyInputMessagesFilter = 'inputMessagesFilterEmpty' \n  | 'inputMessagesFilterPhotos' \n  | 'inputMessagesFilterPhotoVideo' \n  | 'inputMessagesFilterVideo' \n  | 'inputMessagesFilterDocument' \n  | 'inputMessagesFilterVoice' \n  | 'inputMessagesFilterRoundVoice' \n  | 'inputMessagesFilterRoundVideo' \n  | 'inputMessagesFilterMusic' \n  | 'inputMessagesFilterUrl' \n  | 'inputMessagesFilterMyMentions'\n  | 'inputMessagesFilterChatPhotos'\n  | 'inputMessagesFilterPinned';\n\nexport type PinnedStorage = Partial<{\n  promise: Promise<PinnedStorage>,\n  count: number,\n  maxId: number\n}>;\nexport type MessagesStorage = {\n  //generateIndex: (message: any) => void\n  [mid: string]: any\n};\n\nexport type MyMessageActionType = Message.messageService['action']['_'];\n\ntype PendingAfterMsg = Partial<InvokeApiOptions & {\n  afterMessageId: string,\n  messageId: string\n}>;\n\nexport class AppMessagesManager {\n  private static MESSAGE_ID_INCREMENT = 0x10000;\n  private static MESSAGE_ID_OFFSET = 0xFFFFFFFF;\n\n  private messagesStorageByPeerId: {[peerId: string]: MessagesStorage};\n  public groupedMessagesStorage: {[groupId: string]: MessagesStorage}; // will be used for albums\n  private scheduledMessagesStorage: {[peerId: string]: MessagesStorage};\n  private historiesStorage: {\n    [peerId: string]: HistoryStorage\n  };\n  private threadsStorage: {\n    [peerId: string]: {\n      [threadId: string]: HistoryStorage\n    }\n  };\n  private searchesStorage: {\n    [peerId: string]: Partial<{\n      [inputFilter in MyInputMessagesFilter]: {\n        count?: number,\n        history: number[]\n      }\n    }>\n  };\n  public pinnedMessages: {[peerId: string]: PinnedStorage};\n\n  public threadsServiceMessagesIdsStorage: {[peerId_threadId: string]: number};\n  private threadsToReplies: {\n    [peerId_threadId: string]: string;\n  };\n\n  private pendingByRandomId: {\n    [randomId: string]: {\n      peerId: number,\n      tempId: number,\n      threadId: number,\n      storage: MessagesStorage\n    }\n  } = {};\n  private pendingByMessageId: {[mid: string]: string} = {};\n  private pendingAfterMsgs: {[peerId: string]: PendingAfterMsg} = {};\n  public pendingTopMsgs: {[peerId: string]: number} = {};\n  private tempNum = 0;\n  private tempFinalizeCallbacks: {\n    [tempId: string]: {\n      [callbackName: string]: Partial<{\n        deferred: CancellablePromise<void>, \n        callback: (message: any) => Promise<any>\n      }>\n    }\n  } = {};\n  \n  private sendSmthLazyLoadQueue = new LazyLoadQueueBase(1);\n\n  private needSingleMessages: {[peerId: string]: number[]} = {};\n  private fetchSingleMessagesPromise: Promise<void> = null;\n\n  private maxSeenId = 0;\n\n  public migratedFromTo: {[peerId: number]: number} = {};\n  public migratedToFrom: {[peerId: number]: number} = {};\n\n  private newMessagesHandleTimeout = 0;\n  private newMessagesToHandle: {[peerId: string]: Set<number>} = {};\n  private newDialogsHandlePromise: Promise<any>;\n  private newDialogsToHandle: {[peerId: string]: Dialog} = {};\n  public newUpdatesAfterReloadToHandle: {[peerId: string]: Set<Update>} = {};\n\n  private notificationsHandlePromise = 0;\n  private notificationsToHandle: {[peerId: string]: {\n    fwdCount: number,\n    fromId: number,\n    topMessage?: MyMessage\n  }} = {};\n\n  private reloadConversationsPromise: Promise<void>;\n  private reloadConversationsPeers: Set<number> = new Set();\n\n  public log = logger('MESSAGES', LogTypes.Error | LogTypes.Debug | LogTypes.Log | LogTypes.Warn);\n\n  public dialogsStorage: DialogsStorage;\n  public filtersStorage: FiltersStorage;\n\n  private groupedTempId = 0;\n\n  private typings: {[peerId: string]: {type: SendMessageAction['_'], timeout?: number}} = {};\n\n  private middleware: ReturnType<typeof getMiddleware>;\n\n  constructor() {\n    this.clear();\n\n    rootScope.addMultipleEventsListeners({\n      updateMessageID: this.onUpdateMessageId,\n\n      updateNewDiscussionMessage: this.onUpdateNewMessage,\n      updateNewMessage: this.onUpdateNewMessage,\n      updateNewChannelMessage: this.onUpdateNewMessage,\n\n      updateDialogUnreadMark: this.onUpdateDialogUnreadMark,\n\n      updateEditMessage: this.onUpdateEditMessage,\n      updateEditChannelMessage: this.onUpdateEditMessage,\n\n      updateReadChannelDiscussionInbox: this.onUpdateReadHistory,\n      updateReadChannelDiscussionOutbox: this.onUpdateReadHistory,\n      updateReadHistoryInbox: this.onUpdateReadHistory,\n      updateReadHistoryOutbox: this.onUpdateReadHistory,\n      updateReadChannelInbox: this.onUpdateReadHistory,\n      updateReadChannelOutbox: this.onUpdateReadHistory,\n\n      updateChannelReadMessagesContents: this.onUpdateReadMessagesContents,\n      updateReadMessagesContents: this.onUpdateReadMessagesContents,\n\n      updateChannelAvailableMessages: this.onUpdateChannelAvailableMessages,\n\n      updateDeleteMessages: this.onUpdateDeleteMessages,\n      updateDeleteChannelMessages: this.onUpdateDeleteMessages,\n\n      updateChannel: this.onUpdateChannel,\n\n      updateChannelReload: this.onUpdateChannelReload,\n\n      updateChannelMessageViews: this.onUpdateChannelMessageViews,\n\n      updateServiceNotification: this.onUpdateServiceNotification,\n\n      updatePinnedMessages: this.onUpdatePinnedMessages,\n      updatePinnedChannelMessages: this.onUpdatePinnedMessages,\n\n      updateNotifySettings: this.onUpdateNotifySettings,\n\n      updateNewScheduledMessage: this.onUpdateNewScheduledMessage,\n\n      updateDeleteScheduledMessages: this.onUpdateDeleteScheduledMessages\n    });\n\n    // ! Invalidate notify settings, can optimize though\n    rootScope.addEventListener('notify_peer_type_settings', ({key, settings}) => {\n      this.getConversationsAll().then(dialogs => {\n        let filterFunc: (dialog: Dialog) => boolean;\n        if(key === 'notifyUsers') filterFunc = (dialog) => dialog.peerId > 0;\n        else if(key === 'notifyBroadcasts') filterFunc = (dialog) => appChatsManager.isBroadcast(-dialog.peerId);\n        else filterFunc = (dialog) => appPeersManager.isAnyGroup(dialog.peerId);\n\n        dialogs\n        .filter(filterFunc)\n        .forEach(dialog => {\n          rootScope.dispatchEvent('dialog_notify_settings', dialog);\n        });\n      });\n    });\n\n    rootScope.addEventListener('webpage_updated', (e) => {\n      const eventData = e;\n      eventData.msgs.forEach((mid) => {\n        const message = this.getMessageById(mid) as Message.message;\n        if(!message) return;\n        message.media = {\n          _: 'messageMediaWebPage', \n          webpage: appWebPagesManager.getWebPage(eventData.id)\n        };\n\n        const peerId = this.getMessagePeer(message);\n        const storage = this.getMessagesStorage(peerId);\n        rootScope.dispatchEvent('message_edit', {\n          storage,\n          peerId,\n          mid\n        });\n      });\n    });\n\n    rootScope.addEventListener('draft_updated', (e) => {\n      const {peerId, threadId, draft} = e;\n\n      if(threadId) return;\n\n      const dialog = this.getDialogOnly(peerId);\n      if(dialog && !threadId) {\n        dialog.draft = draft;\n        this.dialogsStorage.generateIndexForDialog(dialog);\n        this.dialogsStorage.pushDialog(dialog);\n\n        rootScope.dispatchEvent('dialog_draft', {\n          peerId,\n          draft,\n          index: dialog.index\n        });\n      } else {\n        this.reloadConversation(peerId);\n      }\n    });\n    \n    appStateManager.getState().then(state => {\n      if(state.maxSeenMsgId) {\n        this.maxSeenId = state.maxSeenMsgId;\n      }\n    });\n  }\n\n  public clear() {\n    if(this.middleware) {\n      this.middleware.clean();\n    } else {\n      this.middleware = getMiddleware();\n    }\n\n    this.messagesStorageByPeerId = {};\n    this.groupedMessagesStorage = {};\n    this.scheduledMessagesStorage = {};\n    this.historiesStorage = {};\n    this.threadsStorage = {};\n    this.searchesStorage = {};\n    this.pinnedMessages = {};\n    this.threadsServiceMessagesIdsStorage = {};\n    this.threadsToReplies = {};\n\n    this.dialogsStorage && this.dialogsStorage.clear();\n    this.filtersStorage && this.filtersStorage.clear();\n  }\n\n  public construct() {\n    this.filtersStorage = new FiltersStorage(this, appPeersManager, appUsersManager, appNotificationsManager, appStateManager, apiUpdatesManager, /* apiManager, */ rootScope);\n    this.dialogsStorage = new DialogsStorage(this, appChatsManager, appPeersManager, appUsersManager, appDraftsManager, appNotificationsManager, appStateManager, apiUpdatesManager, serverTimeManager);\n  }\n\n  public getInputEntities(entities: MessageEntity[]) {\n    const sendEntites = copy(entities);\n    sendEntites.forEach((entity) => {\n      if(entity._ === 'messageEntityMentionName') {\n        (entity as any as MessageEntity.inputMessageEntityMentionName)._ = 'inputMessageEntityMentionName';\n        (entity as any as MessageEntity.inputMessageEntityMentionName).user_id = appUsersManager.getUserInput(entity.user_id);\n      }\n    });\n    return sendEntites;\n  }\n\n  public invokeAfterMessageIsSent(tempId: number, callbackName: string, callback: (message: any) => Promise<any>) {\n    const finalize = this.tempFinalizeCallbacks[tempId] ?? (this.tempFinalizeCallbacks[tempId] = {});\n    const obj = finalize[callbackName] ?? (finalize[callbackName] = {deferred: deferredPromise<void>()});\n\n    obj.callback = callback;\n\n    return obj.deferred;\n  }\n\n  public editMessage(message: any, text: string, options: Partial<{\n    noWebPage: true,\n    newMedia: any,\n    scheduleDate: number,\n    entities: MessageEntity[]\n  }> = {}): Promise<void> {\n    /* if(!this.canEditMessage(messageId)) {\n      return Promise.reject({type: 'MESSAGE_EDIT_FORBIDDEN'});\n    } */\n\n    const {mid, peerId} = message;\n\n    if(message.pFlags.is_outgoing) {\n      return this.invokeAfterMessageIsSent(mid, 'edit', (message) => {\n        //this.log('invoke editMessage callback', message);\n        return this.editMessage(message, text, options);\n      });\n    }\n\n    let entities = options.entities || [];\n    if(text) {\n      text = RichTextProcessor.parseMarkdown(text, entities);\n    }\n\n    const schedule_date = options.scheduleDate || (message.pFlags.is_scheduled ? message.date : undefined);\n    return apiManager.invokeApi('messages.editMessage', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      id: message.id,\n      message: text,\n      media: options.newMedia,\n      entities: entities.length ? this.getInputEntities(entities) : undefined,\n      no_webpage: options.noWebPage,\n      schedule_date\n    }).then((updates) => {\n      apiUpdatesManager.processUpdateMessage(updates);\n    }, (error) => {\n      this.log.error('editMessage error:', error);\n      \n      if(error && error.type === 'MESSAGE_NOT_MODIFIED') {\n        error.handled = true;\n        return;\n      }\n      if(error && error.type === 'MESSAGE_EMPTY') {\n        error.handled = true;\n      }\n      return Promise.reject(error);\n    });\n  }\n\n  public sendText(peerId: number, text: string, options: Partial<{\n    entities: any[],\n    replyToMsgId: number,\n    threadId: number,\n    viaBotId: number,\n    queryId: string,\n    resultId: string,\n    noWebPage: true,\n    reply_markup: any,\n    clearDraft: true,\n    webPage: any,\n    scheduleDate: number,\n    silent: true\n  }> = {}) {\n    if(typeof(text) !== 'string' || !text.length) {\n      return;\n    }\n\n    //this.checkSendOptions(options);\n\n    if(options.threadId && !options.replyToMsgId) {\n      options.replyToMsgId = options.threadId;\n    }\n\n    const MAX_LENGTH = rootScope.config.message_length_max;\n    if(text.length > MAX_LENGTH) {\n      const splitted = splitStringByLength(text, MAX_LENGTH);\n      text = splitted[0];\n\n      if(splitted.length > 1) {\n        delete options.webPage;\n      }\n\n      for(let i = 1; i < splitted.length; ++i) {\n        setTimeout(() => {\n          this.sendText(peerId, splitted[i], options);\n        }, i);\n      }\n    }\n\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\n\n    let entities = options.entities || [];\n    if(!options.viaBotId) {\n      text = RichTextProcessor.parseMarkdown(text, entities);\n      //entities = RichTextProcessor.mergeEntities(entities, RichTextProcessor.parseEntities(text));\n    }\n\n    let sendEntites = this.getInputEntities(entities);\n    if(!sendEntites.length) {\n      sendEntites = undefined;\n    }\n\n    const message = this.generateOutgoingMessage(peerId, options);\n    message.entities = entities;\n    message.message = text;\n\n    const replyToMsgId = options.replyToMsgId ? this.getServerMessageId(options.replyToMsgId) : undefined;\n    const isChannel = appPeersManager.isChannel(peerId);\n\n    if(options.webPage) {\n      message.media = {\n        _: 'messageMediaWebPage',\n        webpage: options.webPage\n      };\n    }\n\n    const toggleError = (on: any) => {\n      if(on) {\n        message.error = true;\n      } else {\n        delete message.error;\n      }\n      rootScope.dispatchEvent('messages_pending');\n    };\n\n    message.send = () => {\n      toggleError(false);\n      const sentRequestOptions: PendingAfterMsg = {};\n      if(this.pendingAfterMsgs[peerId]) {\n        sentRequestOptions.afterMessageId = this.pendingAfterMsgs[peerId].messageId;\n      }\n\n      let apiPromise: any;\n      if(options.viaBotId) {\n        apiPromise = apiManager.invokeApiAfter('messages.sendInlineBotResult', {\n          peer: appPeersManager.getInputPeerById(peerId),\n          random_id: message.random_id,\n          reply_to_msg_id: replyToMsgId || undefined,\n          query_id: options.queryId,\n          id: options.resultId,\n          clear_draft: options.clearDraft\n        }, sentRequestOptions);\n      } else {\n        apiPromise = apiManager.invokeApiAfter('messages.sendMessage', {\n          no_webpage: options.noWebPage,\n          peer: appPeersManager.getInputPeerById(peerId),\n          message: text,\n          random_id: message.random_id,\n          reply_to_msg_id: replyToMsgId || undefined,\n          entities: sendEntites,\n          clear_draft: options.clearDraft,\n          schedule_date: options.scheduleDate || undefined,\n          silent: options.silent\n        }, sentRequestOptions);\n      }\n\n      /* function is<T>(value: any, condition: boolean): value is T {\n        return condition;\n      } */\n\n      //this.log('sendText', message.mid);\n      apiPromise.then((updates: Updates) => {\n        //this.log('sendText sent', message.mid);\n        //if(is<Updates.updateShortSentMessage>(updates, updates._ === 'updateShortSentMessage')) {\n        if(updates._ === 'updateShortSentMessage') {\n          //assumeType<Updates.updateShortSentMessage>(updates);\n          message.date = updates.date;\n          message.id = updates.id;\n          message.media = updates.media;\n          message.entities = updates.entities;\n          this.wrapMessageEntities(message);\n          if(updates.pFlags.out) {\n            message.pFlags.out = true;\n          }\n\n          // * override with new updates\n          updates = {\n            _: 'updates',\n            users: [],\n            chats: [],\n            seq: 0,\n            updates: [{\n              _: 'updateMessageID',\n              random_id: message.random_id,\n              id: updates.id\n            }, {\n              _: options.scheduleDate ? 'updateNewScheduledMessage' : (isChannel ? 'updateNewChannelMessage' : 'updateNewMessage'),\n              message: message,\n              pts: updates.pts,\n              pts_count: updates.pts_count\n            }]\n          } as any;\n        } else if((updates as Updates.updates).updates) {\n          (updates as Updates.updates).updates.forEach((update) => {\n            if(update._ === 'updateDraftMessage') {\n              update.local = true;\n            }\n          });\n        }\n        // Testing bad situations\n        // var upd = angular.copy(updates)\n        // updates.updates.splice(0, 1)\n\n        apiUpdatesManager.processUpdateMessage(updates);\n\n        // $timeout(function () {\n        // ApiUpdatesManager.processUpdateMessage(upd)\n        // }, 5000)\n      }, (/* error: any */) => {\n        toggleError(true);\n      }).finally(() => {\n        if(this.pendingAfterMsgs[peerId] === sentRequestOptions) {\n          delete this.pendingAfterMsgs[peerId];\n        }\n      });\n\n      this.pendingAfterMsgs[peerId] = sentRequestOptions;\n    }\n\n    this.beforeMessageSending(message, {\n      isScheduled: !!options.scheduleDate || undefined, \n      threadId: options.threadId,\n      clearDraft: options.clearDraft\n    });\n  }\n\n  public sendFile(peerId: number, file: File | Blob | MyDocument, options: Partial<{\n    isRoundMessage: true,\n    isVoiceMessage: true,\n    isGroupedItem: true,\n    isMedia: true,\n\n    replyToMsgId: number,\n    threadId: number,\n    groupId: string,\n    caption: string,\n    entities: MessageEntity[],\n    width: number,\n    height: number,\n    objectURL: string,\n    thumbBlob: Blob,\n    thumbURL: string,\n    duration: number,\n    background: true,\n    silent: true,\n    clearDraft: true,\n    scheduleDate: number,\n\n    waveform: Uint8Array,\n  }> = {}) {\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\n\n    //this.checkSendOptions(options);\n\n    const message = this.generateOutgoingMessage(peerId, options);\n    const replyToMsgId = options.replyToMsgId ? this.getServerMessageId(options.replyToMsgId) : undefined;\n\n    let attachType: string, apiFileName: string;\n\n    const fileType = 'mime_type' in file ? file.mime_type : file.type;\n    const fileName = file instanceof File ? file.name : '';\n    const isDocument = !(file instanceof File) && !(file instanceof Blob);\n    let caption = options.caption || '';\n\n    this.log('sendFile', file, fileType);\n\n    const entities = options.entities || [];\n    if(caption) {\n      caption = RichTextProcessor.parseMarkdown(caption, entities);\n    }\n\n    const attributes: DocumentAttribute[] = [];\n\n    const isPhoto = ['image/jpeg', 'image/png', 'image/bmp'].indexOf(fileType) >= 0;\n\n    let photo: MyPhoto, document: MyDocument;\n\n    let actionName: SendMessageAction['_'];\n    if(isDocument) { // maybe it's a sticker or gif\n      attachType = 'document';\n      apiFileName = '';\n    } else if(fileType.indexOf('audio/') === 0 || ['video/ogg'].indexOf(fileType) >= 0) {\n      attachType = 'audio';\n      apiFileName = 'audio.' + (fileType.split('/')[1] === 'ogg' ? 'ogg' : 'mp3');\n      actionName = 'sendMessageUploadAudioAction';\n\n      if(options.isVoiceMessage) {\n        attachType = 'voice';\n        message.pFlags.media_unread = true;\n      }\n\n      let attribute: DocumentAttribute.documentAttributeAudio = {\n        _: 'documentAttributeAudio',\n        pFlags: {\n          voice: options.isVoiceMessage\n        },\n        waveform: options.waveform,\n        duration: options.duration || 0\n      };\n\n      attributes.push(attribute);\n    } else if(!options.isMedia) {\n      attachType = 'document';\n      apiFileName = 'document.' + fileType.split('/')[1];\n      actionName = 'sendMessageUploadDocumentAction';\n    } else if(isPhoto) {\n      attachType = 'photo';\n      apiFileName = 'photo.' + fileType.split('/')[1];\n      actionName = 'sendMessageUploadPhotoAction';\n\n      const photoSize = {\n        _: 'photoSize',\n        w: options.width,\n        h: options.height,\n        type: 'full',\n        location: null,\n        size: file.size\n      } as PhotoSize.photoSize;\n\n      photo = {\n        _: 'photo',\n        id: '' + message.id,\n        sizes: [photoSize],\n        w: options.width,\n        h: options.height\n      } as any;\n\n      const cacheContext = appDownloadManager.getCacheContext(photo, photoSize.type);\n      cacheContext.downloaded = file.size;\n      cacheContext.url = options.objectURL || '';\n      \n      photo = appPhotosManager.savePhoto(photo);\n    } else if(fileType.indexOf('video/') === 0) {\n      attachType = 'video';\n      apiFileName = 'video.mp4';\n      actionName = 'sendMessageUploadVideoAction';\n\n      let videoAttribute: DocumentAttribute.documentAttributeVideo = {\n        _: 'documentAttributeVideo',\n        pFlags: {\n          round_message: options.isRoundMessage\n        }, \n        duration: options.duration,\n        w: options.width,\n        h: options.height\n      };\n\n      attributes.push(videoAttribute);\n    } else {\n      attachType = 'document';\n      apiFileName = 'document.' + fileType.split('/')[1];\n      actionName = 'sendMessageUploadDocumentAction';\n    }\n\n    attributes.push({_: 'documentAttributeFilename', file_name: fileName || apiFileName});\n\n    if(['document', 'video', 'audio', 'voice'].indexOf(attachType) !== -1 && !isDocument) {\n      const thumbs: PhotoSize[] = [];\n      document = {\n        _: 'document',\n        id: '' + message.id,\n        duration: options.duration,\n        attributes,\n        w: options.width,\n        h: options.height,\n        thumbs,\n        mime_type: fileType,\n        size: file.size\n      } as any;\n\n      const cacheContext = appDownloadManager.getCacheContext(document);\n      cacheContext.downloaded = file.size;\n      cacheContext.url = options.objectURL || '';\n\n      let thumb: PhotoSize.photoSize;\n      if(isPhoto) {\n        attributes.push({\n          _: 'documentAttributeImageSize',\n          w: options.width,\n          h: options.height\n        });\n\n        thumb = {\n          _: 'photoSize',\n          w: options.width,\n          h: options.height,\n          type: 'full',\n          size: file.size\n        };\n      } else if(attachType === 'video') {\n        if(options.thumbURL) {\n          thumb = {\n            _: 'photoSize',\n            w: options.width,\n            h: options.height,\n            type: 'full',\n            size: options.thumbBlob.size\n          };\n\n          const thumbCacheContext = appDownloadManager.getCacheContext(document, thumb.type);\n          thumbCacheContext.downloaded = thumb.size;\n          thumbCacheContext.url = options.thumbURL;\n        }\n      }\n\n      if(thumb) {\n        thumbs.push(thumb);\n      }\n\n      /* if(thumbs.length) {\n        const thumb = thumbs[0] as PhotoSize.photoSize;\n        const docThumb = appPhotosManager.getDocumentCachedThumb(document.id);\n        docThumb.downloaded = thumb.size;\n        docThumb.url = thumb.url;\n      } */\n      \n      document = appDocsManager.saveDoc(document);\n    }\n\n    this.log('sendFile', attachType, apiFileName, file.type, options);\n\n    const preloader = isDocument ? undefined : new ProgressivePreloader({\n      attachMethod: 'prepend',\n      tryAgainOnFail: false,\n      isUpload: true\n    });\n\n    const sentDeferred = deferredPromise<InputMedia>();\n\n    if(preloader) {\n      preloader.attachPromise(sentDeferred);\n      sentDeferred.cancel = () => {\n        const error = new Error('Download canceled');\n        error.name = 'AbortError';\n        sentDeferred.reject(error);\n      };\n\n      sentDeferred.catch(err => {\n        if(err.name === 'AbortError' && !uploaded) {\n          this.log('cancelling upload', media);\n\n          sentDeferred.reject(err);\n          this.cancelPendingMessage(message.random_id);\n          this.setTyping(peerId, {_: 'sendMessageCancelAction'});\n\n          if(uploadPromise?.cancel) {\n            uploadPromise.cancel();\n          }\n        }\n      });\n    }\n\n    const media = isDocument ? undefined : {\n      _: photo ? 'messageMediaPhoto' : 'messageMediaDocument',\n      pFlags: {},\n      preloader,\n      photo,\n      document,\n      promise: sentDeferred\n    };\n\n    message.entities = entities;\n    message.message = caption;\n    message.media = isDocument ? {\n      _: 'messageMediaDocument',\n      pFlags: {},\n      document: file \n    } : media;\n\n    const toggleError = (on: boolean) => {\n      if(on) {\n        message.error = true;\n      } else {\n        delete message.error;\n      }\n\n      rootScope.dispatchEvent('messages_pending');\n    };\n\n    let uploaded = false,\n      uploadPromise: ReturnType<ApiFileManager['uploadFile']> = null;\n\n    message.send = () => {\n      if(isDocument) {\n        const {id, access_hash, file_reference} = file as MyDocument;\n\n        const inputMedia: InputMedia = {\n          _: 'inputMediaDocument',\n          id: {\n            _: 'inputDocument',\n            id,\n            access_hash,\n            file_reference\n          }\n        };\n        \n        sentDeferred.resolve(inputMedia);\n      } else if(file instanceof File || file instanceof Blob) {\n        const load = () => {\n          if(!uploaded || message.error) {\n            uploaded = false;\n            uploadPromise = appDownloadManager.upload(file);\n            sentDeferred.notifyAll({done: 0, total: file.size});\n          }\n\n          let thumbUploadPromise: typeof uploadPromise;\n          if(attachType === 'video' && options.objectURL) {\n            thumbUploadPromise = new Promise((resolve, reject) => {\n              const blobPromise = options.thumbBlob ? Promise.resolve(options.thumbBlob) : createPosterForVideo(options.objectURL);\n              blobPromise.then(blob => {\n                if(!blob) {\n                  resolve(null);\n                } else {\n                  appDownloadManager.upload(blob).then(resolve, reject);\n                }\n              }, reject);\n            });\n          }\n  \n          uploadPromise && uploadPromise.then(async(inputFile) => {\n            /* if(DEBUG) {\n              this.log('appMessagesManager: sendFile uploaded:', inputFile);\n            } */\n\n            delete message.media.preloader;\n\n            inputFile.name = apiFileName;\n            uploaded = true;\n            let inputMedia: InputMedia;\n            switch(attachType) {\n              case 'photo':\n                inputMedia = {\n                  _: 'inputMediaUploadedPhoto', \n                  file: inputFile\n                };\n                break;\n\n              default:\n                inputMedia = {\n                  _: 'inputMediaUploadedDocument', \n                  file: inputFile, \n                  mime_type: fileType, \n                  attributes\n                };\n            }\n\n            if(thumbUploadPromise) {\n              try {\n                const inputFile = await thumbUploadPromise;\n                (inputMedia as InputMedia.inputMediaUploadedDocument).thumb = inputFile;\n              } catch(err) {\n                this.log.error('sendFile thumb upload error:', err);\n              }\n            }\n            \n            sentDeferred.resolve(inputMedia);\n          }, (/* error */) => {\n            toggleError(true);\n          });\n  \n          uploadPromise.addNotifyListener((progress: {done: number, total: number}) => {\n            /* if(DEBUG) {\n              this.log('upload progress', progress);\n            } */\n\n            const percents = Math.max(1, Math.floor(100 * progress.done / progress.total));\n            if(actionName) {\n              this.setTyping(peerId, {_: actionName, progress: percents | 0});\n            }\n            sentDeferred.notifyAll(progress);\n          });\n\n          return sentDeferred;\n        };\n\n        if(options.isGroupedItem) {\n          load();\n        } else {\n          this.sendSmthLazyLoadQueue.push({\n            load\n          });\n        }\n      }\n\n      return sentDeferred;\n    };\n\n    this.beforeMessageSending(message, {\n      isGroupedItem: options.isGroupedItem, \n      isScheduled: !!options.scheduleDate || undefined, \n      threadId: options.threadId,\n      clearDraft: options.clearDraft\n    });\n\n    if(!options.isGroupedItem) {\n      sentDeferred.then(inputMedia => {\n        this.setTyping(peerId, {_: 'sendMessageCancelAction'});\n\n        return apiManager.invokeApi('messages.sendMedia', {\n          background: options.background,\n          peer: appPeersManager.getInputPeerById(peerId),\n          media: inputMedia,\n          message: caption,\n          random_id: message.random_id,\n          reply_to_msg_id: replyToMsgId,\n          schedule_date: options.scheduleDate,\n          silent: options.silent,\n          entities,\n          clear_draft: options.clearDraft\n        }).then((updates) => {\n          apiUpdatesManager.processUpdateMessage(updates);\n        }, (error) => {\n          if(attachType === 'photo' &&\n            error.code === 400 &&\n            (error.type === 'PHOTO_INVALID_DIMENSIONS' ||\n            error.type === 'PHOTO_SAVE_FILE_INVALID')) {\n            error.handled = true;\n            attachType = 'document';\n            message.send();\n            return;\n          }\n\n          toggleError(true);\n        });\n      });\n    }\n\n    return {message, promise: sentDeferred};\n  }\n\n  public async sendAlbum(peerId: number, files: File[], options: Partial<{\n    isMedia: true,\n    entities: MessageEntity[],\n    replyToMsgId: number,\n    threadId: number,\n    caption: string,\n    sendFileDetails: Partial<{\n      duration: number,\n      width: number,\n      height: number,\n      objectURL: string,\n      thumbBlob: Blob,\n      thumbURL: string\n    }>[],\n    silent: true,\n    clearDraft: true,\n    scheduleDate: number\n  }> = {}) {\n    //this.checkSendOptions(options);\n\n    if(options.threadId && !options.replyToMsgId) {\n      options.replyToMsgId = options.threadId;\n    }\n\n    if(files.length === 1) {\n      return this.sendFile(peerId, files[0], {...options, ...options.sendFileDetails[0]});\n    }\n\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\n    const replyToMsgId = options.replyToMsgId ? this.getServerMessageId(options.replyToMsgId) : undefined;\n\n    let caption = options.caption || '';\n    let entities = options.entities || [];\n    if(caption) {\n      caption = RichTextProcessor.parseMarkdown(caption, entities);\n    }\n\n    this.log('sendAlbum', files, options);\n\n    const groupId = '' + ++this.groupedTempId;\n\n    const messages = files.map((file, idx) => {\n      const details = options.sendFileDetails[idx];\n      const o: any = {\n        isGroupedItem: true,\n        isMedia: options.isMedia,\n        scheduleDate: options.scheduleDate,\n        silent: options.silent,\n        replyToMsgId,\n        threadId: options.threadId,\n        groupId,\n        ...details\n      };\n\n      if(idx === 0) {\n        o.caption = caption;\n        o.entities = entities;\n        //o.replyToMsgId = replyToMsgId;\n      }\n\n      return this.sendFile(peerId, file, o).message;\n    });\n\n    if(options.threadId) {\n      appDraftsManager.syncDraft(peerId, options.threadId);\n    } else {\n      appDraftsManager.saveDraft(peerId, options.threadId, null, {notify: true});  \n    }\n    \n    // * test pending\n    //return;\n\n    const toggleError = (message: any, on: boolean) => {\n      if(on) {\n        message.error = true;\n      } else {\n        delete message.error;\n      }\n\n      rootScope.dispatchEvent('messages_pending');\n    };\n\n    const inputPeer = appPeersManager.getInputPeerById(peerId);\n    const invoke = (multiMedia: any[]) => {\n      this.setTyping(peerId, {_: 'sendMessageCancelAction'});\n\n      this.sendSmthLazyLoadQueue.push({\n        load: () => {\n          return apiManager.invokeApi('messages.sendMultiMedia', {\n            peer: inputPeer,\n            multi_media: multiMedia,\n            reply_to_msg_id: replyToMsgId,\n            schedule_date: options.scheduleDate,\n            silent: options.silent,\n            clear_draft: options.clearDraft\n          }).then((updates) => {\n            apiUpdatesManager.processUpdateMessage(updates);\n          }, (error) => {\n            messages.forEach(message => toggleError(message, true));\n          });\n        }\n      });\n    };\n\n    const promises: Promise<InputSingleMedia>[] = messages.map((message, idx) => {\n      return (message.send() as Promise<InputMedia>).then((inputMedia: InputMedia) => {\n        return apiManager.invokeApi('messages.uploadMedia', {\n          peer: inputPeer,\n          media: inputMedia\n        });\n      })\n      .then(messageMedia => {\n        let inputMedia: any;\n        if(messageMedia._ === 'messageMediaPhoto') {\n          const photo = appPhotosManager.savePhoto(messageMedia.photo);\n          inputMedia = appPhotosManager.getInput(photo);\n        } else if(messageMedia._ === 'messageMediaDocument') {\n          const doc = appDocsManager.saveDoc(messageMedia.document);\n          inputMedia = appDocsManager.getMediaInput(doc);\n        }\n\n        const inputSingleMedia: InputSingleMedia = {\n          _: 'inputSingleMedia',\n          media: inputMedia,\n          random_id: message.random_id,\n          message: caption,\n          entities\n        };\n\n        // * only 1 caption for all inputs\n        if(caption) {\n          caption = '';\n          entities = [];\n        }\n\n        return inputSingleMedia;\n      }).catch((err: any) => {\n        if(err.name === 'AbortError') {\n          return null;\n        }\n\n        this.log.error('sendAlbum upload item error:', err, message);\n        toggleError(message, true);\n        throw err;\n      });\n    });\n\n    Promise.all(promises).then(inputs => {\n      invoke(inputs.filter(Boolean));\n    });\n  }\n\n  public sendOther(peerId: number, inputMedia: any, options: Partial<{\n    replyToMsgId: number,\n    threadId: number,\n    viaBotId: number,\n    reply_markup: any,\n    clearDraft: true,\n    queryId: string\n    resultId: string,\n    scheduleDate: number,\n    silent: true\n  }> = {}) {\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\n\n    //this.checkSendOptions(options);\n    const message = this.generateOutgoingMessage(peerId, options);\n    const replyToMsgId = options.replyToMsgId ? this.getServerMessageId(options.replyToMsgId) : undefined;\n\n    let media;\n    switch(inputMedia._) {\n      case 'inputMediaPoll': {\n        inputMedia.poll.id = message.id;\n        appPollsManager.savePoll(inputMedia.poll, {\n          _: 'pollResults',\n          flags: 4,\n          total_voters: 0,\n          pFlags: {},\n        });\n\n        const {poll, results} = appPollsManager.getPoll('' + message.id);\n        media = {\n          _: 'messageMediaPoll',\n          poll,\n          results\n        };\n\n        break;\n      }\n      /* case 'inputMediaPhoto':\n        media = {\n          _: 'messageMediaPhoto',\n          photo: appPhotosManager.getPhoto(inputMedia.id.id),\n          caption: inputMedia.caption || ''\n        };\n        break;\n\n      case 'inputMediaDocument':\n        var doc = appDocsManager.getDoc(inputMedia.id.id);\n        if(doc.sticker && doc.stickerSetInput) {\n          appStickersManager.pushPopularSticker(doc.id);\n        }\n        media = {\n          _: 'messageMediaDocument',\n          'document': doc,\n          caption: inputMedia.caption || ''\n        };\n        break;\n\n      case 'inputMediaContact':\n        media = {\n          _: 'messageMediaContact',\n          phone_number: inputMedia.phone_number,\n          first_name: inputMedia.first_name,\n          last_name: inputMedia.last_name,\n          user_id: 0\n        };\n        break;\n\n      case 'inputMediaGeoPoint':\n        media = {\n          _: 'messageMediaGeo',\n          geo: {\n            _: 'geoPoint',\n            'lat': inputMedia.geo_point['lat'],\n            'long': inputMedia.geo_point['long']\n          }\n        };\n        break;\n\n      case 'inputMediaVenue':\n        media = {\n          _: 'messageMediaVenue',\n          geo: {\n            _: 'geoPoint',\n            'lat': inputMedia.geo_point['lat'],\n            'long': inputMedia.geo_point['long']\n          },\n          title: inputMedia.title,\n          address: inputMedia.address,\n          provider: inputMedia.provider,\n          venue_id: inputMedia.venue_id\n        };\n        break;\n\n      case 'messageMediaPending':\n        media = inputMedia;\n        break; */\n    }\n\n    message.media = media;\n\n    let toggleError = (on: boolean) => {\n      /* const historyMessage = this.messagesForHistory[messageId];\n      if (on) {\n        message.error = true\n        if (historyMessage) {\n          historyMessage.error = true\n        }\n      } else {\n        delete message.error\n        if (historyMessage) {\n          delete historyMessage.error\n        }\n      } */\n      rootScope.dispatchEvent('messages_pending');\n    };\n\n    message.send = () => {\n      const sentRequestOptions: PendingAfterMsg = {};\n      if(this.pendingAfterMsgs[peerId]) {\n        sentRequestOptions.afterMessageId = this.pendingAfterMsgs[peerId].messageId;\n      }\n\n      let apiPromise: Promise<any>;\n      if(options.viaBotId) {\n        apiPromise = apiManager.invokeApiAfter('messages.sendInlineBotResult', {\n          peer: appPeersManager.getInputPeerById(peerId),\n          random_id: message.random_id,\n          reply_to_msg_id: replyToMsgId || undefined,\n          query_id: options.queryId,\n          id: options.resultId,\n          clear_draft: options.clearDraft\n        }, sentRequestOptions);\n      } else {\n        apiPromise = apiManager.invokeApiAfter('messages.sendMedia', {\n          peer: appPeersManager.getInputPeerById(peerId),\n          media: inputMedia,\n          random_id: message.random_id,\n          reply_to_msg_id: replyToMsgId || undefined,\n          message: '',\n          clear_draft: options.clearDraft,\n          schedule_date: options.scheduleDate,\n          silent: options.silent\n        }, sentRequestOptions);\n      }\n\n      apiPromise.then((updates) => {\n        if(updates.updates) {\n          updates.updates.forEach((update: any) => {\n            if(update._ === 'updateDraftMessage') {\n              update.local = true\n            }\n          });\n        }\n\n        apiUpdatesManager.processUpdateMessage(updates);\n      }, (error) => {\n        toggleError(true);\n      }).finally(() => {\n        if(this.pendingAfterMsgs[peerId] === sentRequestOptions) {\n          delete this.pendingAfterMsgs[peerId];\n        }\n      });\n      this.pendingAfterMsgs[peerId] = sentRequestOptions;\n    }\n\n    this.beforeMessageSending(message, {\n      isScheduled: !!options.scheduleDate || undefined, \n      threadId: options.threadId,\n      clearDraft: options.clearDraft\n    });\n  }\n\n  /* private checkSendOptions(options: Partial<{\n    scheduleDate: number\n  }>) {\n    if(options.scheduleDate) {\n      const minTimestamp = (Date.now() / 1000 | 0) + 10;\n      if(options.scheduleDate <= minTimestamp) {\n        delete options.scheduleDate;\n      }\n    }\n  } */\n\n  private beforeMessageSending(message: any, options: Partial<{\n    isGroupedItem: true, \n    isScheduled: true, \n    threadId: number, \n    clearDraft: true\n  }> = {}) {\n    const messageId = message.id;\n    const peerId = this.getMessagePeer(message);\n    const storage = options.isScheduled ? this.getScheduledMessagesStorage(peerId) : this.getMessagesStorage(peerId);\n\n    if(options.isScheduled) {\n      //if(!options.isGroupedItem) {\n      this.saveMessages([message], {storage, isScheduled: true, isOutgoing: true});\n      setTimeout(() => {\n        rootScope.dispatchEvent('scheduled_new', {peerId, mid: messageId});\n      }, 0);\n    } else {\n      /* if(options.threadId && this.threadsStorage[peerId]) {\n        delete this.threadsStorage[peerId][options.threadId];\n      } */\n      const storages: HistoryStorage[] = [\n        this.getHistoryStorage(peerId),\n        options.threadId ? this.getHistoryStorage(peerId, options.threadId) : undefined\n      ];\n\n      for(const storage of storages) {\n        if(storage) {\n          storage.history.unshift(messageId);\n        }\n      }\n\n      //if(!options.isGroupedItem) {\n      this.saveMessages([message], {storage, isOutgoing: true});\n      setTimeout(() => {\n        this.setDialogTopMessage(message);\n        rootScope.dispatchEvent('history_append', {storage, peerId, mid: messageId});\n      }, 0);\n    }\n\n    if(!options.isGroupedItem && options.clearDraft) {\n      if(options.threadId) {\n        appDraftsManager.syncDraft(peerId, options.threadId);\n      } else {\n        appDraftsManager.saveDraft(peerId, options.threadId, null, {notify: true});  \n      }\n    }\n    \n    this.pendingByRandomId[message.random_id] = {\n      peerId, \n      tempId: messageId, \n      threadId: options.threadId, \n      storage\n    };\n\n    if(!options.isGroupedItem && message.send) {\n      setTimeout(message.send, 0);\n      //setTimeout(message.send, 4000);\n      //setTimeout(message.send, 7000);\n    }\n  }\n\n  private generateOutgoingMessage(peerId: number, options: Partial<{\n    scheduleDate: number,\n    replyToMsgId: number,\n    threadId: number,\n    viaBotId: number,\n    groupId: string,\n    reply_markup: any,\n  }>) {\n    if(options.threadId && !options.replyToMsgId) {\n      options.replyToMsgId = options.threadId;\n    }\n\n    const message: any = {\n      _: 'message',\n      id: this.generateTempMessageId(peerId),\n      from_id: this.generateFromId(peerId),\n      peer_id: appPeersManager.getOutputPeer(peerId),\n      pFlags: this.generateFlags(peerId),\n      date: options.scheduleDate || (tsNow(true) + serverTimeManager.serverTimeOffset),\n      message: '',\n      grouped_id: options.groupId,\n      random_id: randomLong(),\n      reply_to: this.generateReplyHeader(options.replyToMsgId, options.threadId),\n      via_bot_id: options.viaBotId,\n      reply_markup: options.reply_markup,\n      replies: this.generateReplies(peerId),\n      views: appPeersManager.isBroadcast(peerId) && 1,\n      pending: true,\n    };\n\n    return message;\n  }\n\n  private generateReplyHeader(replyToMsgId: number, replyToTopId?: number) {\n    const header = {\n      _: 'messageReplyHeader',\n      reply_to_msg_id: replyToMsgId || replyToTopId,\n    } as MessageReplyHeader;\n\n    if(replyToTopId && header.reply_to_msg_id !== replyToTopId) {\n      header.reply_to_top_id = replyToTopId;\n    }\n\n    return header;\n  }\n\n  private generateReplies(peerId: number) {\n    let replies: MessageReplies.messageReplies;\n    if(appPeersManager.isBroadcast(peerId)) {\n      const channelFull = appProfileManager.chatsFull[-peerId] as ChatFull.channelFull;\n      if(channelFull?.linked_chat_id) {\n        replies = {\n          _: 'messageReplies',\n          flags: 1,\n          pFlags: {\n            comments: true\n          },\n          channel_id: channelFull.linked_chat_id,\n          replies: 0,\n          replies_pts: 0\n        };\n      }\n    }\n\n    return replies;\n  }\n\n  /**\n   * Generate correct from_id according to anonymous or broadcast\n   */\n  private generateFromId(peerId: number) {\n    if(peerId < 0 && (appPeersManager.isBroadcast(peerId) || appPeersManager.getPeer(peerId).admin_rights?.pFlags?.anonymous)) {\n      return undefined;\n    } else {\n      return appPeersManager.getOutputPeer(appUsersManager.getSelf().id);\n    }\n  }\n\n  private generateFlags(peerId: number) {\n    const pFlags: any = {};\n    const fromId = appUsersManager.getSelf().id;\n    if(peerId !== fromId) {\n      pFlags.out = true;\n\n      if(!appPeersManager.isChannel(peerId) && !appUsersManager.isBot(peerId)) {\n        pFlags.unread = true;\n      }\n    }\n\n    if(appPeersManager.isBroadcast(peerId)) {\n      pFlags.post = true;\n    }\n\n    return pFlags;\n  }\n\n  private generateForwardHeader(peerId: number, originalMessage: Message.message) {\n    const myId = appUsersManager.getSelf().id;\n    if(originalMessage.fromId === myId && originalMessage.peerId === myId && !originalMessage.fwd_from) {\n      return;\n    }\n\n    const fwdHeader: MessageFwdHeader.messageFwdHeader = {\n      _: 'messageFwdHeader',\n      flags: 0,\n      date: originalMessage.date\n    };\n\n    if(originalMessage.fwd_from) {\n      fwdHeader.from_id = originalMessage.fwd_from.from_id;\n      fwdHeader.from_name = originalMessage.fwd_from.from_name;\n      fwdHeader.post_author = originalMessage.fwd_from.post_author;\n    } else {\n      fwdHeader.from_id = appPeersManager.getOutputPeer(originalMessage.fromId);\n      fwdHeader.post_author = originalMessage.post_author;\n    }\n\n    if(appPeersManager.isBroadcast(originalMessage.peerId)) {\n      if(originalMessage.post_author) {\n        fwdHeader.post_author = originalMessage.post_author;\n      }\n\n      fwdHeader.channel_post = originalMessage.id;\n    }\n    \n    // * there is no way to detect whether user profile is hidden\n    if(peerId === myId) {\n      fwdHeader.saved_from_msg_id = originalMessage.id;\n      fwdHeader.saved_from_peer = appPeersManager.getOutputPeer(originalMessage.peerId);\n    }\n\n    return fwdHeader;\n  }\n\n  public generateFakeAvatarMessage(peerId: number, photo: Photo) {\n    const maxId = Number.MAX_SAFE_INTEGER;\n    const message = {\n      _: 'messageService',\n      action: {\n        _: 'messageActionChannelEditPhoto',\n        photo\n      },\n      mid: maxId,\n      peerId,\n      date: (photo as Photo.photo).date,\n      fromId: peerId\n    } as Message.messageService;\n\n    this.getMessagesStorage(peerId)[maxId] = message;\n    return message;\n  }\n\n  public setDialogTopMessage(message: MyMessage, dialog: MTDialog.dialog = this.getDialogOnly(message.peerId)) {\n    if(dialog) {\n      dialog.top_message = message.mid;\n      \n      const historyStorage = this.getHistoryStorage(message.peerId);\n      historyStorage.maxId = message.mid;\n\n      this.dialogsStorage.generateIndexForDialog(dialog, false, message);\n\n      this.scheduleHandleNewDialogs(message.peerId, dialog);\n    }\n  }\n\n  public cancelPendingMessage(randomId: string) {\n    const pendingData = this.pendingByRandomId[randomId];\n\n    /* if(DEBUG) {\n      this.log('cancelPendingMessage', randomId, pendingData);\n    } */\n\n    if(pendingData) {\n      const {peerId, tempId, storage} = pendingData;\n      const historyStorage = this.getHistoryStorage(peerId);\n\n      apiUpdatesManager.processLocalUpdate({\n        _: 'updateDeleteMessages',\n        messages: [tempId],\n        pts: undefined,\n        pts_count: undefined\n      });\n\n      historyStorage.history.delete(tempId);\n\n      delete this.pendingByRandomId[randomId];\n      delete storage[tempId];\n\n      return true;\n    }\n\n    return false;\n  }\n\n  public async refreshConversations() {\n    const limit = 200, outDialogs: Dialog[] = [];\n    for(let folderId = 0; folderId < 2; ++folderId) {\n      let offsetDate = 0;\n      for(;;) {\n        const {dialogs, isEnd} = await this.getTopMessages(limit, folderId, offsetDate);\n  \n        if(dialogs.length) {\n          outDialogs.push(...dialogs as Dialog[]);\n          const dialog = dialogs[dialogs.length - 1];\n\n          // * get peerId and mid manually, because dialog can be migrated peer and it won't be saved\n          const peerId = appPeersManager.getPeerId(dialog.peer);\n          const mid = this.generateMessageId(dialog.top_message);\n          offsetDate = this.getMessageByPeer(peerId, mid).date;\n\n          if(!offsetDate) {\n            console.error('refreshConversations: got no offsetDate', dialog);\n            break;\n          }\n        }\n        \n        if(isEnd) {\n          break;\n        }\n      }\n    }\n\n    let obj: {[peerId: string]: Dialog} = {};\n    outDialogs.forEach(dialog => {\n      obj[dialog.peerId] = dialog;\n    });\n    rootScope.dispatchEvent('dialogs_multiupdate', obj);\n\n    return outDialogs;\n  }\n\n  public async getConversationsAll(query = '', folderId = 0) {\n    const limit = 200, outDialogs: Dialog[] = [];\n    for(; folderId < 2; ++folderId) {\n      let offsetIndex = 0;\n      for(;;) {\n        const {dialogs} = await appMessagesManager.getConversations(query, offsetIndex, limit, folderId);\n  \n        if(dialogs.length) {\n          outDialogs.push(...dialogs);\n          offsetIndex = dialogs[dialogs.length - 1].index || 0;\n        } else {\n          break;\n        }\n      }\n    }\n\n    return outDialogs;\n  }\n\n  public getConversations(query = '', offsetIndex?: number, limit = 20, folderId = 0) {\n    return this.dialogsStorage.getDialogs(query, offsetIndex, limit, folderId);\n  }\n\n  public getReadMaxIdIfUnread(peerId: number, threadId?: number) {\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\n    if(threadId) {\n      const chatHistoryStorage = this.getHistoryStorage(peerId);\n      const readMaxId = Math.max(chatHistoryStorage.readMaxId ?? 0, historyStorage.readMaxId);\n      const message = this.getMessageByPeer(peerId, historyStorage.maxId); // usually message is missing, so pFlags.out won't be there anyway\n      return !message.pFlags.out && readMaxId < historyStorage.maxId ? readMaxId : 0;\n    } else {\n      const message = this.getMessageByPeer(peerId, historyStorage.maxId);\n      const readMaxId = peerId > 0 ? Math.max(historyStorage.readMaxId, historyStorage.readOutboxMaxId) : historyStorage.readMaxId;\n      return !message.pFlags.out && readMaxId < historyStorage.maxId ? readMaxId : 0;\n    }\n  }\n\n  // public lolSet = new Set();\n  public getTopMessages(limit: number, folderId: number, offsetDate?: number) {\n    //const dialogs = this.dialogsStorage.getFolder(folderId);\n    let offsetId = 0;\n    let offsetPeerId = 0;\n    let offsetIndex = 0;\n\n    if(offsetDate === undefined) {\n      offsetDate = this.dialogsStorage.getOffsetDate(folderId);\n    }\n\n    if(offsetDate) {\n      offsetIndex = offsetDate * 0x10000;\n      offsetDate += serverTimeManager.serverTimeOffset;\n    }\n\n    const middleware = this.middleware.get();\n\n    // ! \u0412\u041d\u0418\u041c\u0410\u041d\u0418\u0415: \u041e\u0427\u0415\u041d\u042c \u0421\u041b\u041e\u0416\u041d\u0410\u042f \u041b\u041e\u0413\u0418\u041a\u0410:\n    // ! \u0435\u0441\u043b\u0438 \u0434\u0435\u043b\u0430\u0442\u044c \u0437\u0430\u043f\u0440\u043e\u0441 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u043f\u043e \u043f\u0430\u043f\u043a\u0435 0, \u043f\u043e\u0442\u043e\u043c \u043f\u043e \u043f\u0430\u043f\u043a\u0435 1, \u043f\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0443 0 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432\u0435 \u0431\u0443\u0434\u0435\u0442 \u043e\u0434\u0438\u043d \u0438 \u0442\u043e\u0442 \u0436\u0435 \u0434\u0438\u0430\u043b\u043e\u0433, \u0441 dialog.pFlags.pinned, \u041b\u041e\u041b???\n    // ! \u0442.\u0435., \u0441 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u043c folder_id: 1, \u0438 exclude_pinned: 0, \u0432 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0435 \u0431\u0443\u0434\u0443\u0442 \u0435\u0449\u0451 \u0438 \u0437\u0430\u043a\u0440\u0435\u043f\u043b\u0451\u043d\u043d\u044b\u0435 \u0441 \u043f\u0430\u043f\u043a\u0438 0\n    return apiManager.invokeApiSingle('messages.getDialogs', {\n      folder_id: folderId,\n      offset_date: offsetDate,\n      offset_id: offsetId,\n      offset_peer: appPeersManager.getInputPeerById(offsetPeerId),\n      limit,\n      hash: 0\n    }, {\n      //timeout: APITIMEOUT,\n      noErrorBox: true\n    }).then((dialogsResult) => {\n      if(!middleware() || dialogsResult._ === 'messages.dialogsNotModified') return null;\n\n      if(DEBUG) {\n        this.log('messages.getDialogs result:', dialogsResult.dialogs, {...dialogsResult.dialogs[0]});\n      }\n\n      /* if(!offsetDate) {\n        telegramMeWebService.setAuthorized(true);\n      } */\n\n      // can reset pinned order here\n      if(!offsetId && !offsetDate && !offsetPeerId) {\n        this.dialogsStorage.resetPinnedOrder(folderId);\n      }\n\n      if(!offsetDate) {\n        telegramMeWebManager.setAuthorized(true);\n      }\n\n      appUsersManager.saveApiUsers(dialogsResult.users);\n      appChatsManager.saveApiChats(dialogsResult.chats);\n      this.saveMessages(dialogsResult.messages);\n\n      let maxSeenIdIncremented = offsetDate ? true : false;\n      let hasPrepend = false;\n      const noIdsDialogs: {[peerId: number]: Dialog} = {};\n      forEachReverse((dialogsResult.dialogs as Dialog[]), dialog => {\n        //const d = Object.assign({}, dialog);\n        // ! \u043d\u0443\u0436\u043d\u043e \u043f\u0435\u0440\u0435\u0434\u0430\u0432\u0430\u0442\u044c folderId, \u0442\u0430\u043a \u043a\u0430\u043a \u043f\u043e \u043f\u0430\u043f\u043a\u0435 !== 0 \u043d\u0435\u0442 \u0441\u0432\u043e\u0439\u0441\u0442\u0432\u0430 folder_id\n        this.dialogsStorage.saveDialog(dialog, dialog.folder_id ?? folderId, true);\n\n        if(!maxSeenIdIncremented &&\n          !appPeersManager.isChannel(dialog.peerId || appPeersManager.getPeerId(dialog.peer))) {\n          this.incrementMaxSeenId(dialog.top_message);\n          maxSeenIdIncremented = true;\n        }\n\n        if(dialog.peerId === undefined) {\n          return;\n        }\n\n        // if(!folderId && !dialog.folder_id) {\n        //   this.lolSet.add(dialog.peerId);\n        // }\n\n        /* if(dialog.peerId === -1213511294) {\n          this.log.error('lun bot', folderId, d);\n        } */\n\n        if(offsetIndex && dialog.index > offsetIndex) {\n          this.scheduleHandleNewDialogs(dialog.peerId, dialog);\n          hasPrepend = true;\n        }\n\n        // ! \u044d\u0442\u043e \u043c\u043e\u0436\u0435\u0442 \u0441\u043b\u0443\u0447\u0438\u0442\u044c\u0441\u044f, \u0435\u0441\u043b\u0438 \u0437\u0430\u043f\u0440\u043e\u0441 \u0438\u0434\u0451\u0442 \u043d\u0435 \u043f\u043e \u043f\u0430\u043f\u043a\u0435 0, \u0430 \u043f\u043e 1. \u043f\u043e\u0447\u0435\u043c\u0443-\u0442\u043e read'\u043e\u0432 \u043d\u0435\u0442\n        // ! \u0432 \u0438\u0442\u043e\u0433\u0435, \u0447\u0442\u043e\u0431\u044b \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c 1 \u0434\u0438\u0430\u043b\u043e\u0433, \u0434\u0435\u043b\u0430\u0435\u0442\u0441\u044f \u043f\u0435\u0440\u0432\u044b\u0439 \u0437\u0430\u043f\u0440\u043e\u0441 \u043f\u043e \u043f\u0430\u043f\u043a\u0435 0, \u043f\u043e\u0442\u043e\u043c \u0437\u0430\u043f\u0440\u043e\u0441 \u0434\u043b\u044f \u0430\u0440\u0445\u0438\u0432\u043d\u044b\u0445 \u043f\u043e \u043f\u0430\u043f\u043a\u0435 1, \u0438 \u043f\u043e\u0442\u043e\u043c \u0435\u0449\u0451 \u043f\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u0430\u0440\u0445\u0438\u0432\u043d\u043e\u0433\u043e \u0434\u0438\u0430\u043b\u043e\u0433\u0430\n        if(!this.getServerMessageId(dialog.read_inbox_max_id) && !this.getServerMessageId(dialog.read_outbox_max_id)) {\n          noIdsDialogs[dialog.peerId] = dialog;\n\n          this.log.error('noIdsDialogs', dialog);\n\n          /* if(dialog.peerId === -1213511294) {\n            this.log.error('lun bot', folderId);\n          } */\n        }\n      });\n\n      if(Object.keys(noIdsDialogs).length) {\n        //setTimeout(() => { // test bad situation\n          this.reloadConversation(Object.keys(noIdsDialogs).map(id => +id)).then(() => {\n            rootScope.dispatchEvent('dialogs_multiupdate', noIdsDialogs);\n  \n            for(let peerId in noIdsDialogs) {\n              rootScope.dispatchEvent('dialog_unread', {peerId: +peerId});\n            }\n          });\n        //}, 10e3);\n      }\n\n      const count = (dialogsResult as MessagesDialogs.messagesDialogsSlice).count;\n\n      // exclude empty draft dialogs\n      const dialogs = this.dialogsStorage.getFolder(folderId, false);\n      let dialogsLength = 0;\n      for(let i = 0, length = dialogs.length; i < length; ++i) {\n        if(this.getServerMessageId(dialogs[i].top_message)) {\n          ++dialogsLength;\n        }\n      }\n\n      const isEnd = /* limit > dialogsResult.dialogs.length || */ \n        !count || \n        dialogsLength >= count ||\n        !dialogsResult.dialogs.length;\n      if(isEnd) {\n        this.dialogsStorage.setDialogsLoaded(folderId, true);\n      }\n\n      if(hasPrepend) {\n        this.scheduleHandleNewDialogs();\n      } else {\n        rootScope.dispatchEvent('dialogs_multiupdate', {});\n      }\n\n      return {\n        isEnd, \n        count, \n        dialogs: (dialogsResult as MessagesDialogs.messagesDialogsSlice).dialogs\n      };\n    });\n  }\n\n  public forwardMessages(peerId: number, fromPeerId: number, mids: number[], options: Partial<{\n    withMyScore: true,\n    silent: true,\n    scheduleDate: number\n  }> = {}) {\n    peerId = appPeersManager.getPeerMigratedTo(peerId) || peerId;\n    mids = mids.slice().sort((a, b) => a - b);\n\n    const groups: {\n      [groupId: string]: {\n        tempId: string,\n        messages: any[]\n      }\n    } = {};\n\n    const newMessages = mids.map(mid => {\n      const originalMessage: Message.message = this.getMessageByPeer(fromPeerId, mid);\n      const message: Message.message = this.generateOutgoingMessage(peerId, options);\n      message.fwd_from = this.generateForwardHeader(peerId, originalMessage);\n\n      (['entities', 'forwards', 'message', 'media', 'reply_markup', 'views'] as any as Array<keyof MyMessage>).forEach(key => {\n        // @ts-ignore\n        message[key] = originalMessage[key];\n      });\n\n      const document = (message.media as MessageMedia.messageMediaDocument)?.document as MyDocument;\n      if(document) {\n        const types: MyDocument['type'][] = ['round', 'voice'];\n        if(types.includes(document.type)) {\n          (message as MyMessage).pFlags.media_unread = true;\n        }\n      }\n\n      if(originalMessage.grouped_id) {\n        const group = groups[originalMessage.grouped_id] ?? (groups[originalMessage.grouped_id] = {tempId: '' + ++this.groupedTempId, messages: []});\n        group.messages.push(message);\n      }\n\n      return message;\n    });\n\n    for(const groupId in groups) {\n      const group = groups[groupId];\n      if(group.messages.length > 1) {\n        group.messages.forEach(message => {\n          message.grouped_id = group.tempId;\n        });\n      }\n    }\n\n    newMessages.forEach(message => {\n      this.beforeMessageSending(message, {\n        isScheduled: !!options.scheduleDate || undefined\n      });\n    });\n\n    const sentRequestOptions: PendingAfterMsg = {};\n    if(this.pendingAfterMsgs[peerId]) {\n      sentRequestOptions.afterMessageId = this.pendingAfterMsgs[peerId].messageId;\n    }\n\n    const promise = /* true ? Promise.resolve() :  */apiManager.invokeApiAfter('messages.forwardMessages', {\n      from_peer: appPeersManager.getInputPeerById(fromPeerId),\n      id: mids.map(mid => this.getServerMessageId(mid)),\n      random_id: newMessages.map(message => message.random_id),\n      to_peer: appPeersManager.getInputPeerById(peerId),\n      with_my_score: options.withMyScore,\n      silent: options.silent,\n      schedule_date: options.scheduleDate\n    }, sentRequestOptions).then((updates) => {\n      this.log('forwardMessages updates:', updates);\n      apiUpdatesManager.processUpdateMessage(updates);\n    }).finally(() => {\n      if(this.pendingAfterMsgs[peerId] === sentRequestOptions) {\n        delete this.pendingAfterMsgs[peerId];\n      }\n    });\n\n    this.pendingAfterMsgs[peerId] = sentRequestOptions;\n    return promise;\n  }\n\n  public getMessageFromStorage(storage: MessagesStorage, messageId: number) {\n    return storage && storage[messageId] || {\n      _: 'messageEmpty',\n      id: messageId,\n      deleted: true,\n      pFlags: {}\n    };\n  }\n\n  private createMessageStorage() {\n    const storage: MessagesStorage = {} as any;\n    \n    /* let num = 0;\n    Object.defineProperty(storage, 'num', {\n      get: () => ++num,\n      set: (_num: number) => num = _num, \n      enumerable: false\n    });\n\n    Object.defineProperty(storage, 'generateIndex', {\n      value: (message: any) => {\n        if(message.index === undefined) {\n          message.index = (message.date * 0x10000) + (storage.num & 0xFFFF);\n        }\n      },\n      enumerable: false\n    }); */\n\n    return storage;\n  }\n\n  public getMessagesStorage(peerId: number) {\n    return this.messagesStorageByPeerId[peerId] ?? (this.messagesStorageByPeerId[peerId] = this.createMessageStorage());\n  }\n\n  public getMessageById(messageId: number) {\n    for(const peerId in this.messagesStorageByPeerId) {\n      if(appPeersManager.isChannel(+peerId)) {\n        continue;\n      }\n\n      const message = this.messagesStorageByPeerId[peerId][messageId];\n      if(message) {\n        return message;\n      }\n    }\n\n    return this.getMessageFromStorage(null, messageId);\n  }\n\n  public getMessageByPeer(peerId: number, messageId: number) {\n    if(!peerId) {\n      return this.getMessageById(messageId);\n    }\n\n    return this.getMessageFromStorage(this.getMessagesStorage(peerId), messageId);\n  }\n\n  public getMessagePeer(message: any): number {\n    const toId = message.peer_id && appPeersManager.getPeerId(message.peer_id) || 0;\n\n    return toId;\n  }\n\n  public getDialogByPeerId(peerId: number): [Dialog, number] | [] {\n    return this.dialogsStorage.getDialog(peerId);\n  }\n\n  public getDialogOnly(peerId: number) {\n    return this.dialogsStorage.getDialogOnly(peerId);\n  }\n\n  public reloadConversation(peerId?: number | number[]) {\n    if(peerId !== undefined) {\n      [].concat(peerId).forEach(peerId => {\n        if(!this.reloadConversationsPeers.has(peerId)) {\n          this.reloadConversationsPeers.add(peerId);\n          //this.log('will reloadConversation', peerId);\n        }\n      });\n    }\n\n    if(this.reloadConversationsPromise) return this.reloadConversationsPromise;\n    return this.reloadConversationsPromise = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        const peers = Array.from(this.reloadConversationsPeers).map(peerId => appPeersManager.getInputDialogPeerById(peerId));\n        this.reloadConversationsPeers.clear();\n\n        apiManager.invokeApi('messages.getPeerDialogs', {peers}).then((result) => {\n          this.dialogsStorage.applyDialogs(result);\n          resolve();\n        }, reject).finally(() => {\n          this.reloadConversationsPromise = null;\n\n          if(this.reloadConversationsPeers.size) {\n            this.reloadConversation();\n          }\n        });\n      }, 0);\n    });\n  }\n\n  private doFlushHistory(peer: InputPeer, just_clear?: boolean, revoke?: boolean): Promise<true> {\n    return apiManager.invokeApiSingle('messages.deleteHistory', {\n      just_clear,\n      revoke,\n      peer,\n      max_id: 0\n    }).then((affectedHistory) => {\n      apiUpdatesManager.processUpdateMessage({\n        _: 'updateShort',\n        update: {\n          _: 'updatePts',\n          pts: affectedHistory.pts,\n          pts_count: affectedHistory.pts_count\n        }\n      });\n\n      if(!affectedHistory.offset) {\n        return true;\n      }\n\n      return this.doFlushHistory(peer, just_clear, revoke);\n    });\n  }\n\n  public async flushHistory(peerId: number, justClear?: boolean, revoke?: boolean) {\n    if(appPeersManager.isChannel(peerId)) {\n      const promise = this.getHistory(peerId, 0, 1);\n\n      const historyResult = promise instanceof Promise ? await promise : promise;\n\n      const channelId = -peerId;\n      const maxId = historyResult.history[0] || 0;\n      return apiManager.invokeApiSingle('channels.deleteHistory', {\n        channel: appChatsManager.getChannelInput(channelId),\n        max_id: this.getServerMessageId(maxId)\n      }).then(() => {\n        apiUpdatesManager.processLocalUpdate({\n          _: 'updateChannelAvailableMessages',\n          channel_id: channelId,\n          available_min_id: maxId\n        });\n\n        return true;\n      });\n    }\n\n    return this.doFlushHistory(appPeersManager.getInputPeerById(peerId), justClear, revoke).then(() => {\n      delete this.historiesStorage[peerId];\n      delete this.messagesStorageByPeerId[peerId];\n      delete this.scheduledMessagesStorage[peerId];\n      delete this.threadsStorage[peerId];\n      delete this.searchesStorage[peerId];\n      delete this.pinnedMessages[peerId];\n      delete this.pendingAfterMsgs[peerId];\n      delete this.pendingTopMsgs[peerId];\n      delete this.needSingleMessages[peerId];\n      \n      if(justClear) {\n        rootScope.dispatchEvent('dialog_flush', {peerId});\n      } else {\n        delete this.notificationsToHandle[peerId];\n        delete this.typings[peerId];\n        this.reloadConversationsPeers.delete(peerId);\n\n        this.dialogsStorage.dropDialog(peerId);\n        rootScope.dispatchEvent('dialog_drop', {peerId});\n      }\n    });\n  }\n\n  public hidePinnedMessages(peerId: number) {\n    return Promise.all([\n      appStateManager.getState(),\n      this.getPinnedMessage(peerId)\n    ])\n    .then(([state, pinned]) => {\n      state.hiddenPinnedMessages[peerId] = pinned.maxId;\n      rootScope.dispatchEvent('peer_pinned_hidden', {peerId, maxId: pinned.maxId});\n    });\n  }\n\n  public getPinnedMessage(peerId: number) {\n    const p = this.pinnedMessages[peerId] ?? (this.pinnedMessages[peerId] = {});\n    if(p.promise) return p.promise;\n    else if(p.maxId) return Promise.resolve(p);\n\n    return p.promise = this.getSearch({\n      peerId, \n      inputFilter: {_: 'inputMessagesFilterPinned'},\n      maxId: 0,\n      limit: 1\n    }).then(result => {\n      p.count = result.count;\n      p.maxId = result.history[0]?.mid;\n      return p;\n    }).finally(() => {\n      delete p.promise;\n    });\n  }\n\n  public updatePinnedMessage(peerId: number, mid: number, unpin?: boolean, silent?: boolean, pm_oneside?: boolean) {\n    return apiManager.invokeApi('messages.updatePinnedMessage', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      unpin,\n      silent,\n      pm_oneside,\n      id: this.getServerMessageId(mid)\n    }).then(updates => {\n      //this.log('pinned updates:', updates);\n      apiUpdatesManager.processUpdateMessage(updates);\n    });\n  }\n\n  public unpinAllMessages(peerId: number): Promise<boolean> {\n    return apiManager.invokeApiSingle('messages.unpinAllMessages', {\n      peer: appPeersManager.getInputPeerById(peerId)\n    }).then(affectedHistory => {\n      apiUpdatesManager.processUpdateMessage({\n        _: 'updateShort',\n        update: {\n          _: 'updatePts',\n          pts: affectedHistory.pts,\n          pts_count: affectedHistory.pts_count\n        }\n      });\n\n      if(!affectedHistory.offset) {\n        const storage = this.getMessagesStorage(peerId);\n        for(const mid in storage) {\n          const message = storage[mid];\n          if(message.pFlags.pinned) {\n            delete message.pFlags.pinned;\n          }\n        }\n\n        rootScope.dispatchEvent('peer_pinned_messages', {peerId, unpinAll: true});\n        delete this.pinnedMessages[peerId];\n\n        return true;\n      }\n\n      return this.unpinAllMessages(peerId);\n    });\n  }\n\n  public getAlbumText(grouped_id: string) {\n    const group = this.groupedMessagesStorage[grouped_id];\n    let foundMessages = 0, message: string, totalEntities: MessageEntity[], entities: MessageEntity[];\n    for(const i in group) {\n      const m = group[i];\n      if(m.message) {\n        if(++foundMessages > 1) break;\n        message = m.message;\n        totalEntities = m.totalEntities;\n        entities = m.entities;\n      }  \n    }\n\n    if(foundMessages > 1) {\n      message = undefined;\n      totalEntities = undefined;\n      entities = undefined;\n    }\n\n    return {message, entities, totalEntities};\n  }\n\n  public getMidsByAlbum(grouped_id: string) {\n    return getObjectKeysAndSort(this.groupedMessagesStorage[grouped_id], 'asc');\n    //return Object.keys(this.groupedMessagesStorage[grouped_id]).map(id => +id).sort((a, b) => a - b);\n  }\n\n  public getMidsByMessage(message: any) {\n    if(message?.grouped_id) return this.getMidsByAlbum(message.grouped_id);\n    else return [message.mid];\n  }\n\n  public filterMessages(message: any, verify: (message: MyMessage) => boolean) {\n    const out: MyMessage[] = [];\n    if(message.grouped_id) {\n      const storage = this.groupedMessagesStorage[message.grouped_id];\n      for(const mid in storage) {\n        const message = storage[mid];\n        if(verify(message)) {\n          out.push(message);\n        }\n      }\n    } else {\n      if(verify(message)) {\n        out.push(message);\n      }\n    }\n\n    return out;\n  }\n\n  public generateTempMessageId(peerId: number) {\n    const dialog = this.getDialogOnly(peerId);\n    return this.generateMessageId(dialog?.top_message || 0, true);\n  }\n\n  public generateMessageId(messageId: number, temp = false) {\n    const q = AppMessagesManager.MESSAGE_ID_OFFSET;\n    const num = temp ? ++this.tempNum : 0;\n    if(messageId >= q) {\n      if(temp) {\n        return messageId + (num & (AppMessagesManager.MESSAGE_ID_INCREMENT - 1));\n      }\n\n      return messageId;\n    }\n\n    return q + (messageId * AppMessagesManager.MESSAGE_ID_INCREMENT + (num & (AppMessagesManager.MESSAGE_ID_INCREMENT - 1)));\n  }\n\n  /**\n   * * will ignore outgoing offset\n   */\n  public getServerMessageId(messageId: number) {\n    const q = AppMessagesManager.MESSAGE_ID_OFFSET;\n    if(messageId < q) { // id 0 -> mid 0xFFFFFFFF, so 0xFFFFFFFF must convert to 0\n      return messageId;\n    }\n\n    const l = AppMessagesManager.MESSAGE_ID_INCREMENT - 1;\n    const used = messageId & l;\n    if(used !== l) {\n      messageId -= used + 1;\n    }\n\n    return (messageId - q) / AppMessagesManager.MESSAGE_ID_INCREMENT;\n  }\n\n  public incrementMessageId(messageId: number, increment: number) {\n    return this.generateMessageId(this.getServerMessageId(messageId) + increment);\n  }\n\n  public saveMessages(messages: any[], options: Partial<{\n    storage: MessagesStorage,\n    isScheduled: true,\n    isOutgoing: true,\n    //isNew: boolean, // * new - from update\n  }> = {}) {\n    //let groups: Set<string>;\n    messages.forEach((message) => {\n      if(message.pFlags === undefined) {\n        message.pFlags = {};\n      }\n\n      if(message._ === 'messageEmpty') {\n        return;\n      }\n\n      // * exclude from state\n      // defineNotNumerableProperties(message, ['rReply', 'mid', 'savedFrom', 'fwdFromId', 'fromId', 'peerId', 'reply_to_mid', 'viaBotId']);\n\n      const peerId = this.getMessagePeer(message);\n      const storage = options.storage || this.getMessagesStorage(peerId);\n      const isChannel = message.peer_id._ === 'peerChannel';\n      const channelId = isChannel ? -peerId : 0;\n      const isBroadcast = isChannel && appChatsManager.isBroadcast(channelId);\n\n      if(options.isScheduled) {\n        message.pFlags.is_scheduled = true;\n      }\n\n      if(options.isOutgoing) {\n        message.pFlags.is_outgoing = true;\n      }\n      \n      const mid = this.generateMessageId(message.id);\n      message.mid = mid;\n\n      if(message.grouped_id) {\n        const storage = this.groupedMessagesStorage[message.grouped_id] ?? (this.groupedMessagesStorage[message.grouped_id] = {});\n        storage[mid] = message;\n      }\n\n      const dialog = this.getDialogOnly(peerId);\n      if(dialog && mid) {\n        if(mid > dialog[message.pFlags.out\n          ? 'read_outbox_max_id'\n          : 'read_inbox_max_id']) {\n          message.pFlags.unread = true;\n        }\n      }\n      // this.log(dT(), 'msg unread', mid, apiMessage.pFlags.out, dialog && dialog[apiMessage.pFlags.out ? 'read_outbox_max_id' : 'read_inbox_max_id'])\n\n      if(message.reply_to) {\n        if(message.reply_to.reply_to_msg_id) {\n          message.reply_to.reply_to_msg_id = message.reply_to_mid = this.generateMessageId(message.reply_to.reply_to_msg_id);\n        } \n\n        if(message.reply_to.reply_to_top_id) message.reply_to.reply_to_top_id = this.generateMessageId(message.reply_to.reply_to_top_id);\n      }\n\n      if(message.replies) {\n        if(message.replies.max_id) message.replies.max_id = this.generateMessageId(message.replies.max_id);\n        if(message.replies.read_max_id) message.replies.read_max_id = this.generateMessageId(message.replies.read_max_id);\n      }\n\n      const overwriting = !!peerId;\n      if(!overwriting) {\n        message.date -= serverTimeManager.serverTimeOffset;\n      }\n      \n      //storage.generateIndex(message);\n      const myId = appUsersManager.getSelf().id;\n\n      message.peerId = peerId;\n      if(peerId === myId/*  && !message.from_id && !message.fwd_from */) {\n        message.fromId = message.fwd_from ? (message.fwd_from.from_id ? appPeersManager.getPeerId(message.fwd_from.from_id) : 0) : myId;\n      } else {\n        //message.fromId = message.pFlags.post || (!message.pFlags.out && !message.from_id) ? peerId : appPeersManager.getPeerId(message.from_id);\n        message.fromId = message.pFlags.post || !message.from_id ? peerId : appPeersManager.getPeerId(message.from_id);\n      }\n\n      const fwdHeader = message.fwd_from as MessageFwdHeader;\n      if(fwdHeader) {\n        //if(peerId === myID) {\n          if(fwdHeader.saved_from_msg_id) fwdHeader.saved_from_msg_id = this.generateMessageId(fwdHeader.saved_from_msg_id);\n          if(fwdHeader.channel_post) fwdHeader.channel_post = this.generateMessageId(fwdHeader.channel_post);\n\n          const peer = fwdHeader.saved_from_peer || fwdHeader.from_id;\n          const msgId = fwdHeader.saved_from_msg_id || fwdHeader.channel_post;\n          if(peer && msgId) {\n            const savedFromPeerId = appPeersManager.getPeerId(peer);\n            const savedFromMid = this.generateMessageId(msgId);\n            message.savedFrom = savedFromPeerId + '_' + savedFromMid;\n          }\n\n          /* if(peerId < 0 || peerId === myID) {\n            message.fromId = appPeersManager.getPeerID(!message.from_id || deepEqual(message.from_id, fwdHeader.from_id) ? fwdHeader.from_id : message.from_id);\n          } */\n        /* } else {\n          apiMessage.fwdPostID = fwdHeader.channel_post;\n        } */\n\n        message.fwdFromId = appPeersManager.getPeerId(fwdHeader.from_id);\n\n        if(!overwriting) {\n          fwdHeader.date -= serverTimeManager.serverTimeOffset;\n        }\n      }\n\n      if(message.via_bot_id > 0) {\n        message.viaBotId = message.via_bot_id;\n      }\n\n      const mediaContext: ReferenceContext = {\n        type: 'message',\n        peerId,\n        messageId: mid\n      };\n\n      if(message.media) {\n        switch(message.media._) {\n          case 'messageMediaEmpty':\n            delete message.media;\n            break;\n          case 'messageMediaPhoto':\n            if(message.media.ttl_seconds) {\n              message.media = {_: 'messageMediaUnsupportedWeb'};\n            } else {\n              message.media.photo = appPhotosManager.savePhoto(message.media.photo, mediaContext);\n            }\n\n            if(!message.media.photo) { // * found this bug on test DC\n              delete message.media;\n            }\n            \n            break;\n          case 'messageMediaPoll':\n            message.media.poll = appPollsManager.savePoll(message.media.poll, message.media.results);\n            break;\n          case 'messageMediaDocument':\n            if(message.media.ttl_seconds) {\n              message.media = {_: 'messageMediaUnsupportedWeb'};\n            } else {\n              message.media.document = appDocsManager.saveDoc(message.media.document, mediaContext); // 11.04.2020 warning\n            }\n\n            break;\n          case 'messageMediaWebPage':\n            message.media.webpage = appWebPagesManager.saveWebPage(message.media.webpage, message.mid, mediaContext);\n            break;\n          /*case 'messageMediaGame':\n            AppGamesManager.saveGame(apiMessage.media.game, apiMessage.mid, mediaContext);\n            apiMessage.media.handleMessage = true;\n            break; */\n          case 'messageMediaInvoice':\n            message.media = {_: 'messageMediaUnsupportedWeb'};\n            break;\n        }\n      }\n\n      if(message.action) {\n        const action = message.action;\n        let migrateFrom: number;\n        let migrateTo: number;\n        const suffix = message.fromId === appUsersManager.getSelf().id ? 'You' : '';\n        switch(action._) {\n          //case 'messageActionChannelEditPhoto':\n          case 'messageActionChatEditPhoto':\n            action.photo = appPhotosManager.savePhoto(action.photo, mediaContext);\n            if(action.photo.video_sizes) {\n              action._ = isBroadcast ? 'messageActionChannelEditVideo' : 'messageActionChatEditVideo';\n            } else {\n              if(isBroadcast) { // ! messageActionChannelEditPhoto \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \u043f\u0440\u0438\u043d\u0446\u0438\u043f\u0435, \u044d\u0442\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0432\u043e\u0434\u0430.\n                action._ = 'messageActionChannelEditPhoto';\n              }\n            }\n            break;\n          \n          case 'messageActionGroupCall': {\n            //assumeType<MessageAction.messageActionGroupCall>(action);\n\n            let type: string;\n            if(action.duration === undefined) {\n              type = 'started';\n              if(peerId !== message.fromId) {\n                type += '_by' + suffix;\n              }\n            } else {\n              type = 'ended_by' + suffix;\n            }\n\n            action.type = type;\n\n            break;\n          }\n\n          case 'messageActionChatEditTitle':\n            /* if(options.isNew) {\n              const chat = appChatsManager.getChat(-peerId);\n              chat.title = action.title;\n              appChatsManager.saveApiChat(chat, true);\n            } */\n            \n            if(isBroadcast) {\n              action._ = 'messageActionChannelEditTitle';\n            }\n            break;\n\n          case 'messageActionChatDeletePhoto':\n            if(isBroadcast) {\n              action._ = 'messageActionChannelDeletePhoto';\n            }\n            break;\n\n          case 'messageActionChatAddUser':\n            if(action.users.length === 1) {\n              action.user_id = action.users[0];\n              if(message.fromId === action.user_id) {\n                if(isChannel) {\n                  action._ = 'messageActionChatJoined' + suffix;\n                } else {\n                  action._ = 'messageActionChatReturn' + suffix;\n                }\n              }\n            } else if(action.users.length > 1) {\n              action._ = 'messageActionChatAddUsers';\n            }\n            break;\n\n          case 'messageActionChatDeleteUser':\n            if(message.fromId === action.user_id) {\n              action._ = 'messageActionChatLeave' + suffix;\n            }\n            break;\n\n          case 'messageActionChannelMigrateFrom':\n            migrateFrom = -action.chat_id;\n            migrateTo = -channelId;\n            break\n\n          case 'messageActionChatMigrateTo':\n            migrateFrom = -channelId;\n            migrateTo = -action.channel_id;\n            break;\n\n          case 'messageActionHistoryClear':\n            //apiMessage.deleted = true;\n            message.clear_history = true;\n            delete message.pFlags.out;\n            delete message.pFlags.unread;\n            break;\n\n          case 'messageActionPhoneCall':\n            action.type = \n              (message.pFlags.out ? 'out_' : 'in_') +\n              (\n                action.reason._ === 'phoneCallDiscardReasonMissed' ||\n                action.reason._ === 'phoneCallDiscardReasonBusy'\n                   ? 'missed'\n                   : 'ok'\n              );\n            break;\n        }\n        \n        if(migrateFrom &&\n            migrateTo &&\n            !this.migratedFromTo[migrateFrom] &&\n            !this.migratedToFrom[migrateTo]) {\n          this.migrateChecks(migrateFrom, migrateTo);\n        }\n      }\n\n      /* if(message.grouped_id) {\n        if(!groups) {\n          groups = new Set();\n        }\n\n        groups.add(message.grouped_id);\n      } else {\n        message.rReply = this.getRichReplyText(message);\n      } */\n\n      if(message.message && message.message.length && !message.totalEntities) {\n        this.wrapMessageEntities(message);  \n      }\n\n      storage[mid] = message;\n    });\n\n    /* if(groups) {\n      for(const groupId of groups) {\n        const mids = this.groupedMessagesStorage[groupId];\n        for(const mid in mids) {\n          const message = this.groupedMessagesStorage[groupId][mid];\n          message.rReply = this.getRichReplyText(message);\n        }\n      }\n    } */\n  }\n\n  private wrapMessageEntities(message: any) {\n    const apiEntities = message.entities ? message.entities.slice() : [];\n    message.message = RichTextProcessor.fixEmoji(message.message, apiEntities);\n\n    const myEntities = RichTextProcessor.parseEntities(message.message);\n    message.totalEntities = RichTextProcessor.mergeEntities(apiEntities, myEntities); // ! only in this order, otherwise bold and emoji formatting won't work\n  }\n\n  public wrapMessageForReply(message: any, text: string, usingMids: number[], plain: true, highlightWord?: string): string;\n  public wrapMessageForReply(message: any, text?: string, usingMids?: number[], plain?: false, highlightWord?: string): DocumentFragment;\n  public wrapMessageForReply(message: any, text: string = message.message, usingMids?: number[], plain?: boolean, highlightWord?: string): DocumentFragment | string {\n    const parts: (HTMLElement | string)[] = [];\n\n    const addPart = (langKey: LangPackKey, part?: string | HTMLElement, text?: string) => {\n      if(langKey) {\n        part = plain ? I18n.format(langKey, true) : i18n(langKey);\n      }\n      \n      if(plain) {\n        parts.push(part);\n      } else {\n        const el = document.createElement('i');\n        if(typeof(part) === 'string') el.innerHTML = part;\n        else el.append(part);\n        parts.push(el);\n      }\n\n      if(text) {\n        parts.push(', ');\n      }\n    };\n\n    if(message.media) {\n      let usingFullAlbum = true;\n      if(message.grouped_id) {\n        if(usingMids) {\n          const mids = this.getMidsByMessage(message);\n          if(usingMids.length === mids.length) {\n            for(const mid of mids) {\n              if(!usingMids.includes(mid)) {\n                usingFullAlbum = false;\n                break;\n              }\n            }\n          } else {\n            usingFullAlbum = false;\n          }\n        }\n\n        if(usingFullAlbum) {\n          text = this.getAlbumText(message.grouped_id).message;\n          addPart('AttachAlbum', undefined, text);\n        }\n      } else {\n        usingFullAlbum = false;\n      }\n\n      if(!usingFullAlbum) {\n        const media = message.media;\n        switch(media._) {\n          case 'messageMediaPhoto':\n            addPart('AttachPhoto', undefined, message.message);\n            break;\n          case 'messageMediaDice':\n            addPart(undefined, plain ? media.emoticon : RichTextProcessor.wrapEmojiText(media.emoticon));\n            break;\n          case 'messageMediaVenue': {\n            const text = plain ? media.title : RichTextProcessor.wrapEmojiText(media.title);\n            addPart('AttachLocation', undefined, text);\n            parts.push(htmlToDocumentFragment(text) as any);\n            break;\n          }\n          case 'messageMediaGeo':\n            addPart('AttachLocation');\n            break;\n          case 'messageMediaGeoLive':\n            addPart('AttachLiveLocation');\n            break;\n          case 'messageMediaPoll':\n            addPart(undefined, plain ? '\ud83d\udcca' + ' ' + (media.poll.question || 'poll') : media.poll.rReply);\n            break;\n          case 'messageMediaContact':\n            addPart('AttachContact');\n            break;\n          case 'messageMediaGame': {\n            const prefix = '\ud83c\udfae' + ' ';\n            addPart(undefined, plain ? prefix + media.game.title : RichTextProcessor.wrapEmojiText(prefix + media.game.title));\n            break;\n          }\n          case 'messageMediaDocument':\n            let document = media.document;\n  \n            if(document.type === 'video') {\n              addPart('AttachVideo', undefined, message.message);\n            } else if(document.type === 'voice') {\n              addPart('AttachAudio', undefined, message.message);\n            } else if(document.type === 'gif') {\n              addPart('AttachGif', undefined, message.message);\n            } else if(document.type === 'round') {\n              addPart('AttachRound', undefined, message.message);\n            } else if(document.type === 'sticker') {\n              addPart(undefined, ((plain ? document.stickerEmojiRaw : document.stickerEmoji) || '') + 'Sticker');\n              text = '';\n            } else {\n              addPart(undefined, plain ? document.file_name : RichTextProcessor.wrapEmojiText(document.file_name), message.message);\n            }\n  \n            break;\n  \n          default:\n            //messageText += media._;\n            ///////this.log.warn('Got unknown media type!', message);\n            break;\n        }\n      } \n    }\n\n    if(message.action) {\n      const actionWrapped = this.wrapMessageActionTextNew(message, plain);\n      if(actionWrapped) {\n        addPart(undefined, actionWrapped);\n      }\n    }\n\n    if(text) {\n      text = limitSymbols(text, 100);\n\n      if(plain) {\n        parts.push(text);\n      } else {\n        let entities = RichTextProcessor.parseEntities(text.replace(/\\n/g, ' '));\n\n        if(highlightWord) {\n          highlightWord = highlightWord.trim();\n          if(!entities) entities = [];\n          let found = false;\n          let match: any;\n          let regExp = new RegExp(escapeRegExp(highlightWord), 'gi');\n          while((match = regExp.exec(text)) !== null) {\n            entities.push({_: 'messageEntityHighlight', length: highlightWord.length, offset: match.index});\n            found = true;\n          }\n      \n          if(found) {\n            entities.sort((a, b) => a.offset - b.offset);\n          }\n        }\n\n        const messageWrapped = RichTextProcessor.wrapRichText(text, {\n          noLinebreaks: true, \n          entities, \n          noLinks: true,\n          noTextFormat: true\n        });\n  \n        parts.push(htmlToDocumentFragment(messageWrapped) as any);\n      }\n    }\n\n    if(plain) {\n      return parts.join('');\n    } else {\n      const fragment = document.createDocumentFragment();\n      fragment.append(...parts);\n      return fragment;\n    }\n  }\n\n  public getSenderToPeerText(message: MyMessage) {\n    let senderTitle = '', peerTitle: string;\n    \n    senderTitle = message.pFlags.out ? 'You' : appPeersManager.getPeerTitle(message.fromId, false, false);\n    peerTitle = appPeersManager.isAnyGroup(message.peerId) || (message.pFlags.out && message.peerId !== rootScope.myId) ? \n      appPeersManager.getPeerTitle(message.peerId, false, false) : \n      '';\n\n    if(peerTitle) {\n      senderTitle += ' \u279d ' + peerTitle;\n    }\n\n    return senderTitle;\n  }\n\n  public wrapMessageActionTextNew(message: any, plain: true): string;\n  public wrapMessageActionTextNew(message: any, plain?: false): HTMLElement;\n  public wrapMessageActionTextNew(message: any, plain: boolean): HTMLElement | string;\n  public wrapMessageActionTextNew(message: any, plain?: boolean): HTMLElement | string {\n    const element: HTMLElement = plain ? undefined : document.createElement('span');\n    const action = message.action as MessageAction;\n\n    // this.log('message action:', action);\n\n    if((action as MessageAction.messageActionCustomAction).message) {\n      if(plain) {\n        return RichTextProcessor.wrapPlainText(message.message);\n      } else {\n        element.innerHTML = RichTextProcessor.wrapRichText((action as MessageAction.messageActionCustomAction).message, {noLinebreaks: true});\n        return element;\n      }\n    } else {\n      let _ = action._;\n      //let suffix = '';\n      let langPackKey: LangPackKey;\n      let args: any[];\n\n      const getNameDivHTML = (peerId: number, plain: boolean) => {\n        return plain ? appPeersManager.getPeerTitle(peerId, plain) + ' ' : (new PeerTitle({peerId})).element;\n      };\n\n      switch(action._) {\n        case 'messageActionPhoneCall': {\n          _ += '.' + (action as any).type;\n\n          args = [formatCallDuration(action.duration)];\n          break;\n        }\n\n        case 'messageActionGroupCall': {\n          _ += '.' + (action as any).type;\n\n          args = [];\n          if(!_.endsWith('You')) {\n            args.push(getNameDivHTML(message.fromId, plain));\n          }\n\n          args.push(formatCallDuration(action.duration));\n          break;\n        }\n\n        case 'messageActionInviteToGroupCall': {\n          const peerIds = [message.fromId, action.users[0]];\n          let a = 'ActionGroupCall';\n          const myId = appUsersManager.getSelf().id;\n          if(peerIds[0] === myId) a += 'You';\n          a += 'Invited';\n          if(peerIds[1] === myId) a += 'You';\n          peerIds.findAndSplice(peerId => peerId === myId);\n\n          langPackKey = a as LangPackKey;\n          args = peerIds.map(peerId => getNameDivHTML(peerId, plain));\n          break;\n        }\n\n        case 'messageActionGroupCallScheduled': {\n          const today = new Date();\n          const date = new Date(action.schedule_date * 1000);\n          const daysToStart = (date.getTime() - today.getTime()) / 86400e3;\n          const tomorrowDate = new Date(today);\n          tomorrowDate.setDate(tomorrowDate.getDate() + 1);\n\n          langPackKey = 'ChatList.Service.VoiceChatScheduled';\n          const myId = appUsersManager.getSelf().id;\n          if(message.fromId === myId) {\n            langPackKey += 'You';\n          }\n\n          let k: LangPackKey, _args: any[] = [];\n          if(daysToStart < 1 && date.getDate() === today.getDate()) {\n            k = 'TodayAtFormattedWithToday';\n          } else if(daysToStart < 2 && date.getDate() === tomorrowDate.getDate()) {\n            k = 'Time.TomorrowAt';\n          } else {\n            k = 'formatDateAtTime';\n            _args.push(new I18n.IntlDateElement({\n              date, \n              options: {\n                day: '2-digit',\n                month: '2-digit',\n                year: '2-digit'\n              }\n            }).element);\n          }\n\n          _args.push(formatTime(date));\n          const t = i18n(k, _args);\n          args = [t];\n\n          break;\n        }\n\n        case 'messageActionChatCreate': {\n          const myId = appUsersManager.getSelf().id;\n          if(message.fromId === myId) {\n            _ += 'You';\n          } else {\n            args = [getNameDivHTML(message.fromId, plain)];\n          }\n          \n          break;\n        }\n\n        case 'messageActionPinMessage':\n        case 'messageActionContactSignUp':\n        case 'messageActionChatReturn':\n        case 'messageActionChatLeave':\n        case 'messageActionChatJoined':\n        case 'messageActionChatEditPhoto':\n        case 'messageActionChatDeletePhoto':\n        case 'messageActionChatEditVideo':\n        case 'messageActionChatJoinedByLink':\n        case 'messageActionChannelEditVideo':\n        case 'messageActionChannelDeletePhoto': {\n          args = [getNameDivHTML(message.fromId, plain)];\n          break;\n        }\n\n        case 'messageActionChannelEditTitle':\n        case 'messageActionChatEditTitle': {\n          args = [];\n          if(action._ === 'messageActionChatEditTitle') {\n            args.push(getNameDivHTML(message.fromId, plain));\n          }\n\n          args.push(plain ? action.title : htmlToSpan(RichTextProcessor.wrapEmojiText(action.title)));\n          break;\n        }\n\n        case 'messageActionChatDeleteUser':\n        case 'messageActionChatAddUsers':\n        case 'messageActionChatAddUser': {\n          const users: number[] = (action as MessageAction.messageActionChatAddUser).users \n            || [(action as MessageAction.messageActionChatDeleteUser).user_id];\n\n          args = [getNameDivHTML(message.fromId, plain)];\n\n          if(users.length > 1) {\n            if(plain) {\n              args.push(...users.map((userId: number) => (getNameDivHTML(userId, true) as string).trim()).join(', '));\n            } else {\n              const fragment = document.createElement('span');\n              fragment.append(\n                ...join(\n                  users.map((userId: number) => getNameDivHTML(userId, false)) as HTMLElement[],\n                  false\n                )\n              );\n              args.push(fragment);\n            }\n          } else {\n            args.push(getNameDivHTML(users[0], plain));\n          }\n\n          break;\n        }\n\n        case 'messageActionBotAllowed': {\n          const anchorHTML = RichTextProcessor.wrapRichText(action.domain, {\n            entities: [{\n              _: 'messageEntityUrl',\n              length: action.domain.length,\n              offset: 0\n            }]\n          });\n\n          const node = htmlToSpan(anchorHTML);\n\n          args = [node];\n          break;\n        }\n\n        default:\n          langPackKey = (langPack[_] || `[${action._}]`) as any;\n          break;\n      }\n\n      if(!langPackKey) {\n        langPackKey = langPack[_];\n        if(langPackKey === undefined) {\n          langPackKey = '[' + _ + ']' as any;\n        }\n      }\n\n      if(plain) {\n        return I18n.format(langPackKey, true, args);\n      } else {\n        return _i18n(element, langPackKey, args);\n      }\n\n      //str = !langPackKey || langPackKey[0].toUpperCase() === langPackKey[0] ? langPackKey : getNameDivHTML(message.fromId) + langPackKey + (suffix ? ' ' : '');\n    }\n  }\n\n  public editPeerFolders(peerIds: number[], folderId: number) {\n    apiManager.invokeApi('folders.editPeerFolders', {\n      folder_peers: peerIds.map(peerId => {\n        return {\n          _: 'inputFolderPeer',\n          peer: appPeersManager.getInputPeerById(peerId),\n          folder_id: folderId\n        };\n      })\n    }).then(updates => {\n      //this.log('editPeerFolders updates:', updates);\n      apiUpdatesManager.processUpdateMessage(updates); // WARNING! \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0442\u0443\u0442 \u043d\u0443\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c channelId, \u0438 \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c \u0430\u043f\u0434\u0435\u0439\u0442 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043a\u0430\u043d\u0430\u043b\u0430 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\n    });\n  }\n\n  public toggleDialogPin(peerId: number, filterId?: number) {\n    if(filterId > 1) {\n      return this.filtersStorage.toggleDialogPin(peerId, filterId);\n    }\n\n    const dialog = this.getDialogOnly(peerId);\n    if(!dialog) return Promise.reject();\n\n    const pinned = dialog.pFlags?.pinned ? undefined : true;\n\n    if(pinned) {\n      const max = filterId === 1 ? rootScope.config.pinned_infolder_count_max : rootScope.config.pinned_dialogs_count_max;\n      if(this.dialogsStorage.getPinnedOrders(filterId).length >= max) {\n        return Promise.reject({type: 'PINNED_DIALOGS_TOO_MUCH'});\n      }\n    }\n\n    return apiManager.invokeApi('messages.toggleDialogPin', {\n      peer: appPeersManager.getInputDialogPeerById(peerId),\n      pinned\n    }).then(bool => {\n      if(bool) {\n        const pFlags: Update.updateDialogPinned['pFlags'] = pinned ? {pinned} : {};\n        apiUpdatesManager.saveUpdate({\n          _: 'updateDialogPinned',\n          peer: appPeersManager.getDialogPeer(peerId),\n          folder_id: filterId,\n          pFlags\n        });\n      }\n    });\n  }\n\n  public markDialogUnread(peerId: number, read?: true) {\n    const dialog = this.getDialogOnly(peerId);\n    if(!dialog) return Promise.reject();\n\n    const unread = read || dialog.pFlags?.unread_mark ? undefined : true;\n    return apiManager.invokeApi('messages.markDialogUnread', {\n      peer: appPeersManager.getInputDialogPeerById(peerId),\n      unread\n    }).then(bool => {\n      if(bool) {\n        const pFlags: Update.updateDialogUnreadMark['pFlags'] = unread ? {unread} : {};\n        this.onUpdateDialogUnreadMark({\n          _: 'updateDialogUnreadMark',\n          peer: appPeersManager.getDialogPeer(peerId),\n          pFlags\n        });\n      }\n    });\n  }\n\n  public migrateChecks(migrateFrom: number, migrateTo: number) {\n    if(!this.migratedFromTo[migrateFrom] &&\n      !this.migratedToFrom[migrateTo] &&\n      appChatsManager.hasChat(-migrateTo)) {\n      const fromChat = appChatsManager.getChat(-migrateFrom);\n      if(fromChat &&\n        fromChat.migrated_to &&\n        fromChat.migrated_to.channel_id === -migrateTo) {\n          this.migratedFromTo[migrateFrom] = migrateTo;\n          this.migratedToFrom[migrateTo] = migrateFrom;\n\n        //setTimeout(() => {\n          rootScope.dispatchEvent('dialog_migrate', {migrateFrom, migrateTo});\n\n          const dropped = this.dialogsStorage.dropDialog(migrateFrom);\n          if(dropped.length) {\n            rootScope.dispatchEvent('dialog_drop', {peerId: migrateFrom, dialog: dropped[0]});\n          }\n        //}, 100);\n      }\n    }\n  }\n\n  private canMessageBeEdited(message: any, kind: 'text' | 'poll') {\n    if(message.pFlags.is_outgoing) {\n      return false;\n    }\n\n    const goodMedias = [\n      'messageMediaPhoto',\n      'messageMediaDocument',\n      'messageMediaWebPage'\n    ];\n\n    if(kind === 'poll') {\n      goodMedias.push('messageMediaPoll');\n    }\n\n    if(message._ !== 'message' ||\n        message.deleted ||\n        message.fwd_from ||\n        message.via_bot_id ||\n        message.media && goodMedias.indexOf(message.media._) === -1 ||\n        message.fromId && appUsersManager.isBot(message.fromId)) {\n      return false;\n    }\n    \n    if(message.media &&\n        message.media._ === 'messageMediaDocument' &&\n        (message.media.document.sticker || message.media.document.type === 'round')) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public canEditMessage(message: any, kind: 'text' | 'poll' = 'text') {\n    if(!message || !this.canMessageBeEdited(message, kind)) {\n      return false;\n    }\n\n    // * second rule for saved messages, because there is no 'out' flag\n    if(/* message.pFlags.out ||  */this.getMessagePeer(message) === appUsersManager.getSelf().id) {\n      return true;\n    }\n\n    if((message.date < (tsNow(true) - rootScope.config.edit_time_limit) && \n      message.media?._ !== 'messageMediaPoll') || !message.pFlags.out) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public canDeleteMessage(message: any) {\n    return message && (\n      message.peerId > 0 \n      || message.fromId === rootScope.myId \n      || appChatsManager.getChat(message.peerId)._ === 'chat' \n      || appChatsManager.hasRights(message.peerId, 'delete_messages')\n    ) && !message.pFlags.is_outgoing;\n  }\n\n  public getReplyKeyboard(peerId: number) {\n    return this.getHistoryStorage(peerId).reply_markup;\n  }\n\n  public mergeReplyKeyboard(historyStorage: HistoryStorage, message: Message.messageService | Message.message) {\n    // this.log('merge', message.mid, message.reply_markup, historyStorage.reply_markup)\n    let messageReplyMarkup = (message as Message.message).reply_markup;\n    if(!messageReplyMarkup &&\n      !message.pFlags?.out &&\n      !(message as Message.messageService).action) {\n      return false;\n    }\n\n    if(messageReplyMarkup?._ === 'replyInlineMarkup') {\n      return false;\n    }\n\n    const lastReplyMarkup = historyStorage.reply_markup;\n    if(messageReplyMarkup) {\n      if(lastReplyMarkup && lastReplyMarkup.mid >= message.mid) {\n        return false;\n      }\n\n      if(messageReplyMarkup.pFlags.selective) {\n        return false;\n      }\n\n      if(historyStorage.maxOutId &&\n        message.mid < historyStorage.maxOutId &&\n        (messageReplyMarkup as ReplyMarkup.replyKeyboardMarkup | ReplyMarkup.replyKeyboardForceReply).pFlags.single_use) {\n        (messageReplyMarkup as ReplyMarkup.replyKeyboardMarkup | ReplyMarkup.replyKeyboardForceReply).pFlags.hidden = true;\n      }\n\n      messageReplyMarkup.mid = message.mid;\n      /* messageReplyMarkup = Object.assign({\n        mid: message.mid\n      }, messageReplyMarkup); */\n\n      if(messageReplyMarkup._ !== 'replyKeyboardHide') {\n        messageReplyMarkup.fromId = appPeersManager.getPeerId(message.from_id);\n      }\n\n      historyStorage.reply_markup = messageReplyMarkup;\n      // this.log('set', historyStorage.reply_markup)\n      return true;\n    }\n\n    if(message.pFlags.out) {\n      if(lastReplyMarkup) {\n        assumeType<ReplyMarkup.replyKeyboardMarkup>(lastReplyMarkup);\n        if(lastReplyMarkup.pFlags.single_use &&\n          !lastReplyMarkup.pFlags.hidden &&\n          (message.mid > lastReplyMarkup.mid || message.pFlags.is_outgoing) &&\n          (message as Message.message).message) {\n          lastReplyMarkup.pFlags.hidden = true;\n          // this.log('set', historyStorage.reply_markup)\n          return true;\n        }\n      } else if(!historyStorage.maxOutId ||\n        message.mid > historyStorage.maxOutId) {\n        historyStorage.maxOutId = message.mid;\n      }\n    }\n\n    assumeType<Message.messageService>(message);\n    if(message.action?._ === 'messageActionChatDeleteUser' &&\n      (lastReplyMarkup\n        ? message.action.user_id === (lastReplyMarkup as ReplyMarkup.replyKeyboardMarkup).fromId\n        : appUsersManager.isBot(message.action.user_id)\n      )\n    ) {\n      historyStorage.reply_markup = {\n        _: 'replyKeyboardHide',\n        mid: message.mid,\n        pFlags: {}\n      };\n      // this.log('set', historyStorage.reply_markup)\n      return true;\n    }\n\n    return false;\n  }\n\n  public getSearchStorage(peerId: number, inputFilter: MyInputMessagesFilter) {\n    if(!this.searchesStorage[peerId]) this.searchesStorage[peerId] = {};\n    if(!this.searchesStorage[peerId][inputFilter]) this.searchesStorage[peerId][inputFilter] = {history: []};\n    return this.searchesStorage[peerId][inputFilter];\n  }\n\n  public getSearchCounters(peerId: number, filters: MessagesFilter[], canCache = true) {\n    const func = (canCache ? apiManager.invokeApiCacheable : apiManager.invokeApi).bind(apiManager);\n    return func('messages.getSearchCounters', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      filters\n    });\n  }\n\n  public getSearch({peerId, query, inputFilter, maxId, limit, nextRate, backLimit, threadId, folderId, minDate, maxDate}: {\n    peerId?: number,\n    maxId?: number,\n    limit?: number,\n    nextRate?: number,\n    backLimit?: number,\n    threadId?: number,\n    folderId?: number,\n    query?: string,\n    inputFilter?: {\n      _: MyInputMessagesFilter\n    },\n    minDate?: number,\n    maxDate?: number\n  }): Promise<{\n    count: number,\n    next_rate: number,\n    offset_id_offset: number,\n    history: MyMessage[]\n  }> {\n    if(!peerId) peerId = 0;\n    if(!query) query = '';\n    if(!inputFilter) inputFilter = {_: 'inputMessagesFilterEmpty'};\n    if(limit === undefined) limit = 20;\n    if(!nextRate) nextRate = 0;\n    if(!backLimit) backLimit = 0;\n\n    minDate = minDate ? minDate / 1000 | 0 : 0;\n    maxDate = maxDate ? maxDate / 1000 | 0 : 0;\n\n    const foundMsgs: Message.message[] = [];\n\n    //this.log('search', maxId);\n\n    if(backLimit) {\n      limit += backLimit;\n    }\n\n    //const beta = inputFilter._ === 'inputMessagesFilterPinned' && !backLimit;\n    const beta = false;\n\n    let storage: {\n      count?: number;\n      history: SlicedArray;\n    };\n\n    // * \u043a\u043e\u0441\u0442\u044b\u043b\u044c \u0434\u043b\u044f limit 1, \u0435\u0441\u043b\u0438 \u043d\u0443\u0436\u043d\u043e \u0438 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435, \u0438 \u0443\u0437\u043d\u0430\u0442\u044c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439\n    if(peerId && !backLimit && !maxId && !query && limit !== 1 && !threadId/*  && inputFilter._ !== 'inputMessagesFilterPinned' */) {\n      storage = beta ? \n        this.getSearchStorage(peerId, inputFilter._) as any : \n        this.getHistoryStorage(peerId);\n      let filtering = true;\n\n      const history = /* maxId ? storage.history.slice(storage.history.indexOf(maxId) + 1) :  */storage.history;\n\n      if(storage !== undefined && history.length) {\n        const neededContents: {\n          [messageMediaType: string]: boolean\n        } = {},\n          neededDocTypes: string[] = [], \n          excludeDocTypes: string[] = []/* ,\n          neededFlags: string[] = [] */;\n\n        switch(inputFilter._) {\n          case 'inputMessagesFilterPhotos':\n            neededContents['messageMediaPhoto'] = true;\n            break;\n\n          case 'inputMessagesFilterPhotoVideo':\n            neededContents['messageMediaPhoto'] = true;\n            neededContents['messageMediaDocument'] = true;\n            neededDocTypes.push('video');\n            break;\n\n          case 'inputMessagesFilterVideo':\n            neededContents['messageMediaDocument'] = true;\n            neededDocTypes.push('video');\n            break;\n\n          case 'inputMessagesFilterDocument':\n            neededContents['messageMediaDocument'] = true;\n            excludeDocTypes.push('video');\n            break;\n\n          case 'inputMessagesFilterVoice':\n            neededContents['messageMediaDocument'] = true;\n            neededDocTypes.push('voice');\n            break;\n\n          case 'inputMessagesFilterRoundVoice':\n            neededContents['messageMediaDocument'] = true;\n            neededDocTypes.push('round', 'voice');\n            break;\n\n          case 'inputMessagesFilterRoundVideo':\n            neededContents['messageMediaDocument'] = true;\n            neededDocTypes.push('round');\n            break;\n\n          case 'inputMessagesFilterMusic':\n            neededContents['messageMediaDocument'] = true;\n            neededDocTypes.push('audio');\n            break;\n\n          case 'inputMessagesFilterUrl':\n            neededContents['url'] = true;\n            break;\n\n          case 'inputMessagesFilterChatPhotos':\n            neededContents['avatar'] = true;\n            break;\n\n          /* case 'inputMessagesFilterPinned':\n            neededFlags.push('pinned');\n            break; */\n\n          /* case 'inputMessagesFilterMyMentions':\n            neededContents['mentioned'] = true;\n            break; */\n\n          default:\n            filtering = false;\n            break;\n            /* return Promise.resolve({\n              count: 0,\n              next_rate: 0,\n              history: [] as number[]\n            }); */\n        }\n\n        if(filtering) {\n          const storage = this.getMessagesStorage(peerId);\n          for(let i = 0, length = history.length; i < length; i++) {\n            const message = storage[history.slice[i]];\n\n            if(!message) continue;\n  \n            //|| (neededContents['mentioned'] && message.totalEntities.find((e: any) => e._ === 'messageEntityMention'));\n  \n            let found = false;\n            if(message.media && neededContents[message.media._] && !message.fwd_from) {\n              if(message.media._ === 'messageMediaDocument') {\n                if((neededDocTypes.length && !neededDocTypes.includes(message.media.document.type)) \n                  || excludeDocTypes.includes(message.media.document.type)) {\n                  continue;\n                }\n              }\n  \n              found = true;\n            } else if(neededContents['url'] && message.message) {\n              const goodEntities = ['messageEntityTextUrl', 'messageEntityUrl'];\n              if((message.totalEntities as MessageEntity[]).find(e => goodEntities.includes(e._)) || RichTextProcessor.matchUrl(message.message)) {\n                found = true;\n              }\n            } else if(neededContents['avatar'] && message.action && ['messageActionChannelEditPhoto', 'messageActionChatEditPhoto', 'messageActionChannelEditVideo', 'messageActionChatEditVideo'].includes(message.action._)) {\n              found = true;\n            }/*  else if(neededFlags.find(flag => message.pFlags[flag])) {\n              found = true;\n            } */\n  \n            if(found) {\n              foundMsgs.push(message);\n              if(foundMsgs.length >= limit) {\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if(foundMsgs.length) {\n      if(foundMsgs.length < limit && (beta ? storage.count !== storage.history.length : true)) {\n        maxId = foundMsgs[foundMsgs.length - 1].mid;\n        limit = limit - foundMsgs.length;\n      } else {\n        return Promise.resolve({\n          count: beta ? storage.count : 0,\n          next_rate: 0,\n          offset_id_offset: 0,\n          history: foundMsgs\n        });\n      }\n    } else if(beta && storage?.count) {\n      return Promise.resolve({\n        count: storage.count,\n        next_rate: 0,\n        offset_id_offset: 0,\n        history: []\n      });\n    }\n\n    const canCache = false && (['inputMessagesFilterChatPhotos', 'inputMessagesFilterPinned'] as MyInputMessagesFilter[]).includes(inputFilter._);\n    const method = (canCache ? apiManager.invokeApiCacheable : apiManager.invokeApi).bind(apiManager);\n\n    let apiPromise: Promise<any>;\n    if(peerId && !nextRate && folderId === undefined/*  || !query */) {\n      apiPromise = method('messages.search', {\n        peer: appPeersManager.getInputPeerById(peerId),\n        q: query || '',\n        filter: inputFilter as any as MessagesFilter,\n        min_date: minDate,\n        max_date: maxDate,\n        limit,\n        offset_id: this.getServerMessageId(maxId) || 0,\n        add_offset: backLimit ? -backLimit : 0,\n        max_id: 0,\n        min_id: 0,\n        hash: 0,\n        top_msg_id: this.getServerMessageId(threadId) || 0\n      }, {\n        //timeout: APITIMEOUT,\n        noErrorBox: true\n      });\n    } else {\n      //var offsetDate = 0;\n      let offsetPeerId = 0;\n      let offsetId = 0;\n      let offsetMessage = maxId && this.getMessageByPeer(peerId, maxId);\n\n      if(offsetMessage && offsetMessage.date) {\n        //offsetDate = offsetMessage.date + serverTimeManager.serverTimeOffset;\n        offsetId = offsetMessage.id;\n        offsetPeerId = this.getMessagePeer(offsetMessage);\n      }\n\n      apiPromise = method('messages.searchGlobal', {\n        q: query,\n        filter: inputFilter as any as MessagesFilter,\n        min_date: minDate,\n        max_date: maxDate,\n        offset_rate: nextRate,\n        offset_peer: appPeersManager.getInputPeerById(offsetPeerId),\n        offset_id: offsetId,\n        limit,\n        folder_id: folderId\n      }, {\n        //timeout: APITIMEOUT,\n        noErrorBox: true\n      });\n    }\n\n    return apiPromise.then((searchResult: any) => {\n      appUsersManager.saveApiUsers(searchResult.users);\n      appChatsManager.saveApiChats(searchResult.chats);\n      this.saveMessages(searchResult.messages);\n\n      /* if(beta && storage && (!maxId || storage.history[storage.history.length - 1] === maxId)) {\n        const storage = this.getSearchStorage(peerId, inputFilter._);\n        const add = (searchResult.messages.map((m: any) => m.mid) as number[]).filter(mid => storage.history.indexOf(mid) === -1);\n        storage.history.push(...add);\n        storage.history.sort((a, b) => b - a);\n        storage.count = searchResult.count;\n      } */\n\n      if(DEBUG) {\n        this.log('getSearch result:', inputFilter, searchResult);\n      }\n\n      const foundCount: number = searchResult.count || (foundMsgs.length + searchResult.messages.length);\n\n      searchResult.messages.forEach((message: any) => {\n        const peerId = this.getMessagePeer(message);\n        if(peerId < 0) {\n          const chat = appChatsManager.getChat(-peerId);\n          if(chat.migrated_to) {\n            this.migrateChecks(peerId, -chat.migrated_to.channel_id);\n          }\n        }\n\n        foundMsgs.push(message);\n      });\n\n      return {\n        count: foundCount,\n        offset_id_offset: searchResult.offset_id_offset || 0,\n        next_rate: searchResult.next_rate,\n        history: foundMsgs\n      };\n    });\n  }\n\n  public subscribeRepliesThread(peerId: number, mid: number) {\n    const repliesKey = peerId + '_' + mid;\n    for(const threadKey in this.threadsToReplies) {\n      if(this.threadsToReplies[threadKey] === repliesKey) return;\n    }\n\n    this.getDiscussionMessage(peerId, mid);\n  }\n\n  public generateThreadServiceStartMessage(message: Message.message) {\n    const threadKey = message.peerId + '_' + message.mid;\n    if(this.threadsServiceMessagesIdsStorage[threadKey]) return;\n\n    const maxMessageId = this.getServerMessageId(Math.max(...this.getMidsByMessage(message)));\n    const serviceStartMessage: Message.messageService = {\n      _: 'messageService',\n      pFlags: {\n        is_single: true\n      },\n      id: this.generateMessageId(maxMessageId, true),\n      date: message.date,\n      from_id: {_: 'peerUser', user_id: 0}/* message.from_id */,\n      peer_id: message.peer_id,\n      action: {\n        _: 'messageActionCustomAction',\n        message: 'Discussion started'\n      },\n      reply_to: this.generateReplyHeader(message.id)\n    };\n\n    this.saveMessages([serviceStartMessage], {isOutgoing: true});\n    this.threadsServiceMessagesIdsStorage[threadKey] = serviceStartMessage.mid;\n  } \n\n  public getDiscussionMessage(peerId: number, mid: number) {\n    return apiManager.invokeApiSingle('messages.getDiscussionMessage', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      msg_id: this.getServerMessageId(mid)\n    }).then(result => {\n      appChatsManager.saveApiChats(result.chats);\n      appUsersManager.saveApiUsers(result.users);\n      this.saveMessages(result.messages);\n\n      const message = this.filterMessages(result.messages[0], message => !!(message as Message.message).replies)[0] as Message.message;\n      const threadKey = message.peerId + '_' + message.mid;\n\n      this.generateThreadServiceStartMessage(message);\n      \n      const historyStorage = this.getHistoryStorage(message.peerId, message.mid);\n      result.max_id = historyStorage.maxId = this.generateMessageId(result.max_id) || 0;\n      result.read_inbox_max_id = historyStorage.readMaxId = this.generateMessageId(result.read_inbox_max_id ?? message.mid);\n      result.read_outbox_max_id = historyStorage.readOutboxMaxId = this.generateMessageId(result.read_outbox_max_id) || 0;\n\n      this.threadsToReplies[threadKey] = peerId + '_' + mid;\n\n      return message;\n    });\n  }\n\n  private handleNewMessage(peerId: number, mid: number) {\n    if(this.newMessagesToHandle[peerId] === undefined) {\n      this.newMessagesToHandle[peerId] = new Set();\n    }\n\n    this.newMessagesToHandle[peerId].add(mid);\n    if(!this.newMessagesHandleTimeout) {\n      this.newMessagesHandleTimeout = window.setTimeout(this.handleNewMessages, 0);\n    }\n  }\n\n  handleNewMessages = () => {\n    clearTimeout(this.newMessagesHandleTimeout);\n    this.newMessagesHandleTimeout = 0;\n\n    rootScope.dispatchEvent('history_multiappend', this.newMessagesToHandle);\n    this.newMessagesToHandle = {};\n  };\n\n  handleNewDialogs = () => {\n    let newMaxSeenId = 0;\n    const obj = this.newDialogsToHandle;\n    for(const peerId in obj) {\n      const dialog = obj[peerId];\n      if(!dialog) {\n        this.reloadConversation(+peerId);\n        delete obj[peerId];\n      } else {\n        this.dialogsStorage.pushDialog(dialog);\n        if(!appPeersManager.isChannel(+peerId)) {\n          newMaxSeenId = Math.max(newMaxSeenId, dialog.top_message || 0);\n        }\n      }\n    }\n\n    //this.log('after order:', this.dialogsStorage[0].map(d => d.peerId));\n\n    if(newMaxSeenId !== 0) {\n      this.incrementMaxSeenId(newMaxSeenId);\n    }\n\n    rootScope.dispatchEvent('dialogs_multiupdate', obj);\n    this.newDialogsToHandle = {};\n  };\n\n  public scheduleHandleNewDialogs(peerId?: number, dialog?: Dialog) {\n    if(peerId !== undefined) {\n      this.newDialogsToHandle[peerId] = dialog;\n    }\n\n    if(this.newDialogsHandlePromise) return this.newDialogsHandlePromise;\n    return this.newDialogsHandlePromise = new Promise((resolve) => {\n      setTimeout(() => {\n        this.newDialogsHandlePromise = undefined;\n        this.handleNewDialogs();\n      }, 0);\n    });\n  }\n\n  public deleteMessages(peerId: number, mids: number[], revoke?: boolean) {\n    let promise: Promise<any>;\n\n    const localMessageIds = mids.map(mid => this.getServerMessageId(mid));\n\n    if(peerId < 0 && appPeersManager.isChannel(peerId)) {\n      const channelId = -peerId;\n      const channel = appChatsManager.getChat(channelId);\n      if(!channel.pFlags.creator && !(channel.pFlags.editor && channel.pFlags.megagroup)) {\n        const goodMsgIds: number[] = [];\n        if(channel.pFlags.editor || channel.pFlags.megagroup) {\n          mids.forEach((msgId, i) => {\n            const message = this.getMessageByPeer(peerId, mids[i]);\n            if(message.pFlags.out) {\n              goodMsgIds.push(msgId);\n            }\n          });\n        }\n\n        if(!goodMsgIds.length) {\n          return;\n        }\n\n        mids = goodMsgIds;\n      }\n\n      promise = apiManager.invokeApi('channels.deleteMessages', {\n        channel: appChatsManager.getChannelInput(channelId),\n        id: localMessageIds\n      }).then((affectedMessages) => {\n        apiUpdatesManager.processLocalUpdate({\n          _: 'updateDeleteChannelMessages',\n          channel_id: channelId,\n          messages: mids,\n          pts: affectedMessages.pts,\n          pts_count: affectedMessages.pts_count\n        });\n      });\n    } else {\n      promise = apiManager.invokeApi('messages.deleteMessages', {\n        revoke,\n        id: localMessageIds\n      }).then((affectedMessages) => {\n        apiUpdatesManager.processLocalUpdate({\n          _: 'updateDeleteMessages',\n          messages: mids,\n          pts: affectedMessages.pts,\n          pts_count: affectedMessages.pts_count\n        });\n      });\n    }\n\n    return promise;\n  }\n\n  // TODO: cancel notification by peer when this function is being called\n  public readHistory(peerId: number, maxId = 0, threadId?: number, force = false) {\n    // return Promise.resolve();\n    // console.trace('start read')\n    this.log('readHistory:', peerId, maxId, threadId);\n    if(!this.getReadMaxIdIfUnread(peerId, threadId) && !force) {\n      this.log('readHistory: isn\\'t unread');\n      return Promise.resolve();\n    }\n\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\n\n    if(historyStorage.triedToReadMaxId >= maxId) {\n      return Promise.resolve();\n    }\n\n    let apiPromise: Promise<any>;\n    if(threadId) {\n      if(!historyStorage.readPromise) {\n        apiPromise = apiManager.invokeApi('messages.readDiscussion', {\n          peer: appPeersManager.getInputPeerById(peerId),\n          msg_id: this.getServerMessageId(threadId),\n          read_max_id: this.getServerMessageId(maxId)\n        });\n      }\n\n      apiUpdatesManager.processLocalUpdate({\n        _: 'updateReadChannelDiscussionInbox',\n        channel_id: -peerId,\n        top_msg_id: threadId,\n        read_max_id: maxId\n      });\n    } else if(appPeersManager.isChannel(peerId)) {\n      if(!historyStorage.readPromise) {\n        apiPromise = apiManager.invokeApi('channels.readHistory', {\n          channel: appChatsManager.getChannelInput(-peerId),\n          max_id: this.getServerMessageId(maxId)\n        });\n      }\n\n      apiUpdatesManager.processLocalUpdate({\n        _: 'updateReadChannelInbox',\n        max_id: maxId,\n        channel_id: -peerId,\n        still_unread_count: undefined,\n        pts: undefined\n      });\n    } else {\n      if(!historyStorage.readPromise) {\n        apiPromise = apiManager.invokeApi('messages.readHistory', {\n          peer: appPeersManager.getInputPeerById(peerId),\n          max_id: this.getServerMessageId(maxId)\n        }).then((affectedMessages) => {\n          apiUpdatesManager.processUpdateMessage({\n            _: 'updateShort',\n            update: {\n              _: 'updatePts',\n              pts: affectedMessages.pts,\n              pts_count: affectedMessages.pts_count\n            }\n          });\n        });\n      }\n\n      apiUpdatesManager.processLocalUpdate({\n        _: 'updateReadHistoryInbox',\n        max_id: maxId,\n        peer: appPeersManager.getOutputPeer(peerId),\n        still_unread_count: undefined,\n        pts: undefined,\n        pts_count: undefined\n      });\n    }\n\n    appNotificationsManager.soundReset(appPeersManager.getPeerString(peerId));\n\n    if(historyStorage.readPromise) {\n      return historyStorage.readPromise;\n    }\n\n    historyStorage.triedToReadMaxId = maxId;\n\n    apiPromise.finally(() => {\n      delete historyStorage.readPromise;\n\n      this.log('readHistory: promise finally', maxId, historyStorage.readMaxId);\n\n      if(historyStorage.readMaxId > maxId) {\n        this.readHistory(peerId, historyStorage.readMaxId, threadId, true);\n      }\n    });\n\n    return historyStorage.readPromise = apiPromise;\n  }\n\n  public readAllHistory(peerId: number, threadId?: number, force = false) {\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\n    if(historyStorage.maxId) {\n      this.readHistory(peerId, historyStorage.maxId, threadId, force); // lol\n    }\n  }\n\n  public readMessages(peerId: number, msgIds: number[]) {\n    msgIds = msgIds.map(mid => this.getServerMessageId(mid));\n    if(peerId < 0 && appPeersManager.isChannel(peerId)) {\n      const channelId = -peerId;\n      apiManager.invokeApi('channels.readMessageContents', {\n        channel: appChatsManager.getChannelInput(channelId),\n        id: msgIds\n      }).then(() => {\n        apiUpdatesManager.processLocalUpdate({\n          _: 'updateChannelReadMessagesContents',\n          channel_id: channelId,\n          messages: msgIds\n        });\n      });\n    } else {\n      apiManager.invokeApi('messages.readMessageContents', {\n        id: msgIds\n      }).then((affectedMessages) => {\n        apiUpdatesManager.processLocalUpdate({\n          _: 'updateReadMessagesContents',\n          messages: msgIds,\n          pts: affectedMessages.pts,\n          pts_count: affectedMessages.pts_count\n        });\n      });\n    }\n  }\n\n  public getHistoryStorage(peerId: number, threadId?: number) {\n    if(threadId) {\n      //threadId = this.getLocalMessageId(threadId);\n      if(!this.threadsStorage[peerId]) this.threadsStorage[peerId] = {};\n      return this.threadsStorage[peerId][threadId] ?? (this.threadsStorage[peerId][threadId] = {count: null, history: new SlicedArray()});\n    }\n\n    return this.historiesStorage[peerId] ?? (this.historiesStorage[peerId] = {count: null, history: new SlicedArray()});\n  }\n\n  private handleNotifications = () => {\n    window.clearTimeout(this.notificationsHandlePromise);\n    this.notificationsHandlePromise = 0;\n\n    //var timeout = $rootScope.idle.isIDLE && StatusManager.isOtherDeviceActive() ? 30000 : 1000;\n    //const timeout = 1000;\n\n    for(const _peerId in this.notificationsToHandle) {\n      const peerId = +_peerId;\n\n      if(rootScope.peerId === peerId && !rootScope.idle.isIDLE) {\n        continue;\n      }\n\n      const notifyPeerToHandle = this.notificationsToHandle[peerId];\n\n      Promise.all([\n        appNotificationsManager.getNotifyPeerTypeSettings(),\n        appNotificationsManager.getNotifySettings(appPeersManager.getInputNotifyPeerById(peerId, true))\n      ]).then(([_, peerTypeNotifySettings]) => {\n        const topMessage = notifyPeerToHandle.topMessage;\n        if(appNotificationsManager.isPeerLocalMuted(peerId, true) || !topMessage.pFlags.unread) {\n          return;\n        }\n\n        //setTimeout(() => {\n          if(topMessage.pFlags.unread) {\n            this.notifyAboutMessage(topMessage, {\n              fwdCount: notifyPeerToHandle.fwdCount,\n              peerTypeNotifySettings\n            });\n          }\n        //}, timeout);\n      });\n    }\n\n    this.notificationsToHandle = {};\n  };\n\n  private onUpdateMessageId = (update: Update.updateMessageID) => {\n    const randomId = update.random_id;\n    const pendingData = this.pendingByRandomId[randomId];\n    //this.log('AMM updateMessageID:', update, pendingData);\n    if(pendingData) {\n      const {peerId, tempId, threadId, storage} = pendingData;\n      //const mid = update.id;\n      const mid = this.generateMessageId(update.id);\n      const message = this.getMessageFromStorage(storage, mid);\n      if(!message.deleted) {\n        [this.getHistoryStorage(peerId), threadId ? this.getHistoryStorage(peerId, threadId) : undefined]\n        .filter(Boolean)\n        .forEach(storage => {\n          storage.history.delete(tempId);\n        });\n\n        this.finalizePendingMessageCallbacks(storage, tempId, mid);\n      } else {\n        this.pendingByMessageId[mid] = randomId;\n      }\n    }\n  };\n\n  private onUpdateNewMessage = (update: Update.updateNewDiscussionMessage | Update.updateNewMessage | Update.updateNewChannelMessage) => {\n    const message = update.message as MyMessage;\n    const peerId = this.getMessagePeer(message);\n    const storage = this.getMessagesStorage(peerId);\n    const dialog = this.getDialogOnly(peerId);\n\n    // * local update\n    const isLocalThreadUpdate = update._ === 'updateNewDiscussionMessage';\n\n    // * temporary save the message for info (peerId, reply mids...)\n    this.saveMessages([message], {storage: {}});\n\n    const threadKey = this.getThreadKey(message);\n    const threadId = threadKey ? +threadKey.split('_')[1] : undefined;\n    if(threadId && !isLocalThreadUpdate && this.threadsStorage[peerId] && this.threadsStorage[peerId][threadId]) {\n      const update = {\n        _: 'updateNewDiscussionMessage',\n        message\n      } as Update.updateNewDiscussionMessage;\n\n      this.onUpdateNewMessage(update);\n    }\n\n    if(!dialog && !isLocalThreadUpdate) {\n      let good = true;\n      if(peerId < 0) {\n        good = appChatsManager.isInChat(-peerId);\n      }\n\n      if(good) {\n        const set = this.newUpdatesAfterReloadToHandle[peerId] ?? (this.newUpdatesAfterReloadToHandle[peerId] = new Set());\n        if(set.has(update)) {\n          this.log.error('here we go again', peerId);\n          return;\n        }\n\n        this.scheduleHandleNewDialogs(peerId);\n        set.add(update);\n      }\n\n      return;\n    }\n\n    /* if(update._ === 'updateNewChannelMessage') {\n      const chat = appChatsManager.getChat(-peerId);\n      if(chat.pFlags && (chat.pFlags.left || chat.pFlags.kicked)) {\n        return;\n      }\n    } */\n\n    this.saveMessages([message], {storage});\n    // this.log.warn(dT(), 'message unread', message.mid, message.pFlags.unread)\n\n    /* if((message as Message.message).grouped_id) {\n      this.log('updateNewMessage', message);\n    } */\n\n    const pendingMessage = this.checkPendingMessage(message);\n    const historyStorage = this.getHistoryStorage(peerId, isLocalThreadUpdate ? threadId : undefined);\n\n    if(!isLocalThreadUpdate) {\n      this.updateMessageRepliesIfNeeded(message);\n    }\n\n    if(historyStorage.history.findSlice(message.mid)) {\n      return false;\n    }\n\n    // * catch situation with disconnect. if message's id is lower than we already have (in bottom end slice), will sort it\n    const firstSlice = historyStorage.history.first;\n    if(firstSlice.isEnd(SliceEnd.Bottom)) {\n      let i = 0;\n      for(const length = firstSlice.length; i < length; ++i) {\n        if(message.mid > firstSlice[i]) {\n          break;\n        }\n      }\n\n      firstSlice.splice(i, 0, message.mid);\n    } else {\n      historyStorage.history.unshift(message.mid);\n    }\n\n    if(historyStorage.count !== null) {\n      historyStorage.count++;\n    }\n\n    if(this.mergeReplyKeyboard(historyStorage, message)) {\n      rootScope.dispatchEvent('history_reply_markup', {peerId});\n    }\n\n    const fromId = message.fromId;\n    if(fromId > 0 && !message.pFlags.out && message.from_id) {\n      appUsersManager.forceUserOnline(fromId, message.date);\n\n      const action: SendMessageAction = {\n        _: 'sendMessageCancelAction'\n      };\n\n      let update: Update.updateUserTyping | Update.updateChatUserTyping | Update.updateChannelUserTyping;\n      if(peerId > 0) {\n        update = {\n          _: 'updateUserTyping',\n          action,\n          user_id: fromId\n        };\n      } else if(appPeersManager.isChannel(peerId)) {\n        update = {\n          _: 'updateChannelUserTyping',\n          action,\n          channel_id: -peerId,\n          from_id: appPeersManager.getOutputPeer(fromId),\n          top_msg_id: threadId ? this.getServerMessageId(threadId) : undefined\n        };\n      } else {\n        update = {\n          _: 'updateChatUserTyping',\n          action,\n          chat_id: -peerId,\n          from_id: appPeersManager.getOutputPeer(fromId)\n        };\n      }\n\n      apiUpdatesManager.processLocalUpdate(update);\n    }\n\n    if(!pendingMessage) {\n      this.handleNewMessage(peerId, message.mid);\n    }\n\n    if(isLocalThreadUpdate) {\n      return;\n    }\n    \n    const inboxUnread = !message.pFlags.out && message.pFlags.unread;\n    if(dialog) {\n      this.setDialogTopMessage(message, dialog);\n      if(inboxUnread) {\n        dialog.unread_count++;\n      }\n    }\n\n    if(inboxUnread/*  && ($rootScope.selectedPeerID != peerID || $rootScope.idle.isIDLE) */) {\n      const notifyPeer = peerId;\n      let notifyPeerToHandle = this.notificationsToHandle[notifyPeer];\n      if(notifyPeerToHandle === undefined) {\n        notifyPeerToHandle = this.notificationsToHandle[notifyPeer] = {\n          fwdCount: 0,\n          fromId: 0\n        };\n      }\n\n      if(notifyPeerToHandle.fromId !== fromId) {\n        notifyPeerToHandle.fromId = fromId;\n        notifyPeerToHandle.fwdCount = 0;\n      }\n\n      if((message as Message.message).fwd_from) {\n        notifyPeerToHandle.fwdCount++;\n      }\n\n      notifyPeerToHandle.topMessage = message;\n\n      if(!this.notificationsHandlePromise) {\n        this.notificationsHandlePromise = window.setTimeout(this.handleNotifications, 0);\n      }\n    }\n  };\n\n  private onUpdateDialogUnreadMark = (update: Update.updateDialogUnreadMark) => {\n    //this.log('updateDialogUnreadMark', update);\n    const peerId = appPeersManager.getPeerId((update.peer as DialogPeer.dialogPeer).peer);\n    const dialog = this.getDialogOnly(peerId);\n\n    if(!dialog) {\n      this.scheduleHandleNewDialogs(peerId);\n    } else {\n      if(!update.pFlags.unread) {\n        delete dialog.pFlags.unread_mark;\n      } else {\n        dialog.pFlags.unread_mark = true;\n      }\n\n      rootScope.dispatchEvent('dialogs_multiupdate', {[peerId]: dialog});\n      this.dialogsStorage.setDialogToState(dialog);\n    }\n  };\n\n  private onUpdateEditMessage = (update: Update.updateEditMessage | Update.updateEditChannelMessage) => {\n    const message = update.message as MyMessage;\n    const peerId = this.getMessagePeer(message);\n    const mid = this.generateMessageId(message.id);\n    const storage = this.getMessagesStorage(peerId);\n    if(storage[mid] === undefined) {\n      return;\n    }\n\n    // console.trace(dT(), 'edit message', message)\n    \n    const oldMessage = this.getMessageFromStorage(storage, mid);\n    this.saveMessages([message], {storage});\n    const newMessage = this.getMessageFromStorage(storage, mid);\n\n    this.handleEditedMessage(oldMessage, newMessage);\n\n    const dialog = this.getDialogOnly(peerId);\n    const isTopMessage = dialog && dialog.top_message === mid;\n    if((message as Message.message).clear_history) {\n      if(isTopMessage) {\n        rootScope.dispatchEvent('dialog_flush', {peerId});\n      }\n    } else {\n      rootScope.dispatchEvent('message_edit', {\n        storage,\n        peerId,\n        mid\n      });\n\n      if(isTopMessage || (message as Message.message).grouped_id) {\n        const updatedDialogs: {[peerId: number]: Dialog} = {};\n        updatedDialogs[peerId] = dialog;\n        rootScope.dispatchEvent('dialogs_multiupdate', updatedDialogs);\n        this.dialogsStorage.setDialogToState(dialog);\n      }\n    }\n  };\n\n  private onUpdateReadHistory = (update: Update.updateReadChannelDiscussionInbox | Update.updateReadChannelDiscussionOutbox \n    | Update.updateReadHistoryInbox | Update.updateReadHistoryOutbox \n    | Update.updateReadChannelInbox | Update.updateReadChannelOutbox) => {\n    const channelId = (update as Update.updateReadChannelInbox).channel_id;\n    const maxId = this.generateMessageId((update as Update.updateReadChannelInbox).max_id || (update as Update.updateReadChannelDiscussionInbox).read_max_id);\n    const threadId = this.generateMessageId((update as Update.updateReadChannelDiscussionInbox).top_msg_id);\n    const peerId = channelId ? -channelId : appPeersManager.getPeerId((update as Update.updateReadHistoryInbox).peer);\n\n    const isOut = update._ === 'updateReadHistoryOutbox' || update._ === 'updateReadChannelOutbox' || update._ === 'updateReadChannelDiscussionOutbox' ? true : undefined;\n\n    const storage = this.getMessagesStorage(peerId);\n    const history = getObjectKeysAndSort(storage, 'desc');\n    const foundDialog = this.getDialogOnly(peerId);\n    const stillUnreadCount = (update as Update.updateReadChannelInbox).still_unread_count;\n    let newUnreadCount = 0;\n    let foundAffected = false;\n\n    //this.log.warn(dT(), 'read', peerId, isOut ? 'out' : 'in', maxId)\n\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\n\n    if(peerId > 0 && isOut) {\n      appUsersManager.forceUserOnline(peerId);\n    }\n\n    if(threadId) {\n      const repliesKey = this.threadsToReplies[peerId + '_' + threadId];\n      if(repliesKey) {\n        const [peerId, mid] = repliesKey.split('_').map(n => +n);\n        this.updateMessage(peerId, mid, 'replies_updated');\n      }\n    }\n\n    for(let i = 0, length = history.length; i < length; i++) {\n      const messageId = history[i];\n      if(messageId > maxId) {\n        continue;\n      }\n      \n      const message = storage[messageId];\n\n      if(message.pFlags.out !== isOut) {\n        continue;\n      }\n\n      if(!message.pFlags.unread) {\n        break;\n      }\n\n      if(threadId) {\n        const replyTo = message.reply_to as MessageReplyHeader;\n        if(!replyTo || (replyTo.reply_to_top_id || replyTo.reply_to_msg_id) !== threadId) {\n          continue;\n        }\n      }\n      \n      // this.log.warn('read', messageId, message.pFlags.unread, message)\n      if(message.pFlags.unread) {\n        delete message.pFlags.unread;\n        if(!foundAffected) {\n          foundAffected = true;\n        }\n\n        if(!message.pFlags.out && !threadId && foundDialog && stillUnreadCount === undefined) {\n          newUnreadCount = --foundDialog.unread_count;\n        }\n        \n        appNotificationsManager.cancel('msg' + messageId);\n      }\n    }\n\n    if(isOut) historyStorage.readOutboxMaxId = maxId;\n    else historyStorage.readMaxId = maxId;\n\n    if(!threadId && foundDialog) {\n      if(isOut) foundDialog.read_outbox_max_id = maxId;\n      else foundDialog.read_inbox_max_id = maxId;\n\n      if(!isOut) {\n        if(newUnreadCount < 0 || !this.getReadMaxIdIfUnread(peerId)) {\n          foundDialog.unread_count = 0;\n        } else if(newUnreadCount && foundDialog.top_message > maxId) {\n          foundDialog.unread_count = newUnreadCount;\n        }\n      }\n      \n      rootScope.dispatchEvent('dialog_unread', {peerId});\n      this.dialogsStorage.setDialogToState(foundDialog);\n    }\n\n    if(foundAffected) {\n      rootScope.dispatchEvent('messages_read');\n    }\n\n    if(!threadId && channelId) {\n      const threadKeyPart = peerId + '_';\n      for(const threadKey in this.threadsToReplies) {\n        if(threadKey.indexOf(threadKeyPart) === 0) {\n          const [peerId, mid] = this.threadsToReplies[threadKey].split('_').map(n => +n);\n          rootScope.dispatchEvent('replies_updated', this.getMessageByPeer(peerId, mid));\n        }\n      }\n    }\n  };\n\n  private onUpdateReadMessagesContents = (update: Update.updateChannelReadMessagesContents | Update.updateReadMessagesContents) => {\n    const channelId = (update as Update.updateChannelReadMessagesContents).channel_id;\n    const mids = (update as Update.updateReadMessagesContents).messages.map(id => this.generateMessageId(id));\n    const peerId = channelId ? -channelId : this.getMessageById(mids[0]).peerId;\n    for(const mid of mids) {\n      const message = this.getMessageByPeer(peerId, mid);\n      if(!message.deleted) {\n        delete message.pFlags.media_unread;\n        this.setDialogToStateIfMessageIsTop(message);\n      }\n    }\n\n    rootScope.dispatchEvent('messages_media_read', {peerId, mids});\n  };\n\n  private onUpdateChannelAvailableMessages = (update: Update.updateChannelAvailableMessages) => {\n    const channelId: number = update.channel_id;\n    const messages: number[] = [];\n    const peerId: number = -channelId;\n    const history = this.getHistoryStorage(peerId).history.slice;\n    if(history.length) {\n      history.forEach((msgId: number) => {\n        if(!update.available_min_id || msgId <= update.available_min_id) {\n          messages.push(msgId);\n        }\n      });\n    }\n\n    (update as any as Update.updateDeleteChannelMessages).messages = messages;\n    this.onUpdateDeleteMessages(update as any as Update.updateDeleteChannelMessages);\n  };\n\n  private onUpdateDeleteMessages = (update: Update.updateDeleteMessages | Update.updateDeleteChannelMessages) => {\n    const channelId: number = (update as Update.updateDeleteChannelMessages).channel_id;\n    //const messages = (update as any as Update.updateDeleteChannelMessages).messages;\n    const messages = (update as any as Update.updateDeleteChannelMessages).messages.map(id => this.generateMessageId(id));\n    const peerId: number = channelId ? -channelId : this.getMessageById(messages[0]).peerId;\n    \n    if(!peerId) {\n      return;\n    }\n\n    apiManager.clearCache('messages.getSearchCounters', (params) => {\n      return appPeersManager.getPeerId(params.peer) === peerId;\n    });\n\n    const threadKeys: Set<string> = new Set();\n    for(const mid of messages) {\n      const message = this.getMessageByPeer(peerId, mid);\n      const threadKey = this.getThreadKey(message);\n      if(threadKey && this.threadsStorage[peerId] && this.threadsStorage[peerId][+threadKey.split('_')[1]]) {\n        threadKeys.add(threadKey);\n      }\n    }\n    \n    const historyUpdated = this.handleDeletedMessages(peerId, this.getMessagesStorage(peerId), messages);\n\n    const threadsStorages = Array.from(threadKeys).map(threadKey => {\n      const splitted = threadKey.split('_');\n      return this.getHistoryStorage(+splitted[0], +splitted[1]);\n    });\n\n    [this.getHistoryStorage(peerId)].concat(threadsStorages).forEach(historyStorage => {\n      for(const mid in historyUpdated.msgs) {\n        historyStorage.history.delete(+mid);\n      }\n      if(historyUpdated.count &&\n        historyStorage.count !== null &&\n        historyStorage.count > 0) {\n        historyStorage.count -= historyUpdated.count;\n        if(historyStorage.count < 0) {\n          historyStorage.count = 0;\n        }\n      }\n    });\n\n    rootScope.dispatchEvent('history_delete', {peerId, msgs: historyUpdated.msgs});\n\n    const foundDialog = this.getDialogOnly(peerId);\n    if(foundDialog) {\n      if(historyUpdated.unread) {\n        foundDialog.unread_count -= historyUpdated.unread;\n\n        rootScope.dispatchEvent('dialog_unread', {peerId});\n      }\n\n      if(historyUpdated.msgs[foundDialog.top_message]) {\n        this.reloadConversation(peerId);\n      }\n    }\n  };\n\n  private onUpdateChannel = (update: Update.updateChannel) => {\n    const channelId: number = update.channel_id;\n    const peerId = -channelId;\n    const channel: Chat.channel = appChatsManager.getChat(channelId);\n\n    const needDialog = appChatsManager.isInChat(channelId);\n    \n    const canViewHistory = !!channel.username || !channel.pFlags.left;\n    const hasHistory = this.historiesStorage[peerId] !== undefined;\n    \n    if(canViewHistory !== hasHistory) {\n      delete this.historiesStorage[peerId];\n      rootScope.dispatchEvent('history_forbidden', peerId);\n    }\n    \n    const dialog = this.getDialogOnly(peerId);\n    if(!!dialog !== needDialog) {\n      if(needDialog) {\n        this.reloadConversation(-channelId);\n      } else {\n        if(dialog) {\n          this.dialogsStorage.dropDialog(peerId);\n          rootScope.dispatchEvent('dialog_drop', {peerId, dialog});\n        }\n      }\n    }\n  };\n\n  private onUpdateChannelReload = (update: Update.updateChannelReload) => {\n    const channelId = update.channel_id;\n    const peerId = -channelId;\n\n    this.dialogsStorage.dropDialog(peerId);\n\n    delete this.historiesStorage[peerId];\n    this.reloadConversation(-channelId).then(() => {\n      rootScope.dispatchEvent('history_reload', peerId);\n    });\n  };\n  \n  private onUpdateChannelMessageViews = (update: Update.updateChannelMessageViews) => {\n    const views = update.views;\n    //const mid = update.id;\n    const mid = this.generateMessageId(update.id);\n    const message = this.getMessageByPeer(-update.channel_id, mid);\n    if(!message.deleted && message.views && message.views < views) {\n      message.views = views;\n      rootScope.dispatchEvent('message_views', {mid, views});\n    }\n  };\n\n  private onUpdateServiceNotification = (update: Update.updateServiceNotification) => {\n    //this.log('updateServiceNotification', update);\n    const fromId = 777000;\n    const peerId = fromId;\n    const messageId = this.generateTempMessageId(peerId);\n    const message: any = {\n      _: 'message',\n      id: messageId,\n      from_id: appPeersManager.getOutputPeer(fromId),\n      peer_id: appPeersManager.getOutputPeer(peerId),\n      pFlags: {unread: true},\n      date: (update.inbox_date || tsNow(true)) + serverTimeManager.serverTimeOffset,\n      message: update.message,\n      media: update.media,\n      entities: update.entities\n    };\n    if(!appUsersManager.hasUser(fromId)) {\n      appUsersManager.saveApiUsers([{\n        _: 'user',\n        id: fromId,\n        pFlags: {verified: true},\n        access_hash: 0,\n        first_name: 'Telegram',\n        phone: '42777'\n      }]);\n    }\n    this.saveMessages([message], {isOutgoing: true});\n\n    if(update.inbox_date) {\n      this.pendingTopMsgs[peerId] = messageId;\n      this.onUpdateNewMessage({\n        _: 'updateNewMessage',\n        message\n      } as any);\n    }\n  };\n\n  private onUpdatePinnedMessages = (update: Update.updatePinnedMessages | Update.updatePinnedChannelMessages) => {\n    const channelId = update._ === 'updatePinnedChannelMessages' ? update.channel_id : undefined;\n    const peerId = channelId ? -channelId : appPeersManager.getPeerId((update as Update.updatePinnedMessages).peer);\n\n    /* const storage = this.getSearchStorage(peerId, 'inputMessagesFilterPinned');\n    if(storage.count !== storage.history.length) {\n      if(storage.count !== undefined) {\n        delete this.searchesStorage[peerId]['inputMessagesFilterPinned'];  \n      }\n\n      rootScope.broadcast('peer_pinned_messages', peerId);\n      break;\n    } */\n\n    const messages = update.messages.map(id => this.generateMessageId(id)); \n\n    const storage = this.getMessagesStorage(peerId);\n    const missingMessages = messages.filter(mid => !storage[mid]);\n    const getMissingPromise = missingMessages.length ? Promise.all(missingMessages.map(mid => this.wrapSingleMessage(peerId, mid))) : Promise.resolve();\n    getMissingPromise.finally(() => {\n      const werePinned = update.pFlags?.pinned;\n      if(werePinned) {\n        for(const mid of messages) {\n          //storage.history.push(mid);\n          const message = storage[mid];\n          message.pFlags.pinned = true;\n        }\n\n        /* if(this.pinnedMessages[peerId]?.maxId) {\n          const maxMid = Math.max(...messages);\n          this.pinnedMessages\n        } */\n\n        //storage.history.sort((a, b) => b - a);\n      } else {\n        for(const mid of messages) {\n          //storage.history.findAndSplice(_mid => _mid === mid);\n          const message = storage[mid];\n          delete message.pFlags.pinned;\n        }\n      }\n\n      /* const info = this.pinnedMessages[peerId];\n      if(info) {\n        info.count += messages.length * (werePinned ? 1 : -1);\n      } */\n  \n      delete this.pinnedMessages[peerId];\n      appStateManager.getState().then(state => {\n        delete state.hiddenPinnedMessages[peerId];\n        rootScope.dispatchEvent('peer_pinned_messages', {peerId, mids: messages, pinned: werePinned});\n      });\n    });\n  };\n\n  private onUpdateNotifySettings = (update: Update.updateNotifySettings) => {\n    const {peer, notify_settings} = update;\n    if(peer._ === 'notifyPeer') {\n      const peerId = appPeersManager.getPeerId((peer as NotifyPeer.notifyPeer).peer);\n    \n      const dialog = this.getDialogOnly(peerId);\n      if(dialog) {\n        dialog.notify_settings = notify_settings;\n        rootScope.dispatchEvent('dialog_notify_settings', dialog);\n        this.dialogsStorage.setDialogToState(dialog);\n      }\n    }\n  };\n\n  private onUpdateNewScheduledMessage = (update: Update.updateNewScheduledMessage) => {\n    const message = update.message as MyMessage;\n    const peerId = this.getMessagePeer(message);\n\n    const storage = this.scheduledMessagesStorage[peerId];\n    if(storage) {\n      const mid = this.generateMessageId(message.id);\n\n      const oldMessage = this.getMessageFromStorage(storage, mid);\n      this.saveMessages([message], {storage, isScheduled: true});\n      const newMessage = this.getMessageFromStorage(storage, mid);\n\n      if(!oldMessage.deleted) {\n        this.handleEditedMessage(oldMessage, newMessage);\n        rootScope.dispatchEvent('message_edit', {storage, peerId, mid: message.mid});\n      } else {\n        const pendingMessage = this.checkPendingMessage(message);\n        if(!pendingMessage) {\n          rootScope.dispatchEvent('scheduled_new', {peerId, mid: message.mid});\n        }\n      }\n    }\n  };\n\n  private onUpdateDeleteScheduledMessages = (update: Update.updateDeleteScheduledMessages) => {\n    const peerId = appPeersManager.getPeerId(update.peer);\n\n    const storage = this.scheduledMessagesStorage[peerId];\n    if(storage) {\n      const mids = update.messages.map(id => this.generateMessageId(id));\n      this.handleDeletedMessages(peerId, storage, mids);\n\n      rootScope.dispatchEvent('scheduled_delete', {peerId, mids});\n    }\n  };\n\n  public setDialogToStateIfMessageIsTop(message: any) {\n    const dialog = this.getDialogOnly(message.peerId);\n    if(dialog && dialog.top_message === message.mid) {\n      this.dialogsStorage.setDialogToState(dialog);\n    }\n  }\n\n  private updateMessageRepliesIfNeeded(threadMessage: MyMessage) {\n    try { // * \u043d\u0430 \u0432\u0441\u044f\u043a\u0438\u0439 \u0441\u043b\u0443\u0447\u0430\u0439, \u0441\u043a\u043e\u0440\u0435\u0435 \u0432\u0441\u0435\u0433\u043e \u044d\u0442\u043e \u043d\u0435 \u043f\u043e\u043d\u0430\u0434\u043e\u0431\u0438\u0442\u0441\u044f\n      const threadKey = this.getThreadKey(threadMessage);\n      if(threadKey) {\n        const repliesKey = this.threadsToReplies[threadKey];\n        if(repliesKey) {\n          const [peerId, mid] = repliesKey.split('_').map(n => +n);\n\n          this.updateMessage(peerId, mid, 'replies_updated');\n        }\n      }\n    } catch(err) {\n      this.log.error('incrementMessageReplies err', err, threadMessage);\n    }\n  }\n\n  private getThreadKey(threadMessage: MyMessage) {\n    let threadKey = '';\n    if(threadMessage.peerId < 0 && threadMessage.reply_to) {\n      const threadId = threadMessage.reply_to.reply_to_top_id || threadMessage.reply_to.reply_to_msg_id;\n      threadKey = threadMessage.peerId + '_' + threadId;\n    }\n\n    return threadKey;\n  }\n\n  public updateMessage(peerId: number, mid: number, broadcastEventName?: 'replies_updated'): Promise<Message.message> {\n    const promise: Promise<Message.message> = this.wrapSingleMessage(peerId, mid, true).then(() => {\n      const message = this.getMessageByPeer(peerId, mid);\n\n      if(broadcastEventName) {\n        rootScope.dispatchEvent(broadcastEventName, message);\n      }\n\n      return message;\n    });\n    \n    return promise;\n  }\n\n  private checkPendingMessage(message: any) {\n    const randomId = this.pendingByMessageId[message.mid];\n    let pendingMessage: any;\n    if(randomId) {\n      const pendingData = this.pendingByRandomId[randomId];\n      if(pendingMessage = this.finalizePendingMessage(randomId, message)) {\n        rootScope.dispatchEvent('history_update', {storage: pendingData.storage, peerId: message.peerId, mid: message.mid});\n      }\n\n      delete this.pendingByMessageId[message.mid];\n    }\n\n    return pendingMessage;\n  }\n\n  public mutePeer(peerId: number, mute?: boolean) {\n    const settings: InputPeerNotifySettings = {\n      _: 'inputPeerNotifySettings'\n    };\n\n    if(mute === undefined) {\n      mute = !appNotificationsManager.isPeerLocalMuted(peerId, false);\n    }\n    \n    settings.mute_until = mute ? 0x7FFFFFFF : 0;\n\n    return appNotificationsManager.updateNotifySettings({\n      _: 'inputNotifyPeer',\n      peer: appPeersManager.getInputPeerById(peerId)\n    }, settings);\n  }\n\n  public canWriteToPeer(peerId: number, threadId?: number) {\n    if(peerId < 0) {\n      //const isChannel = appPeersManager.isChannel(peerId);\n      const hasRights = /* isChannel &&  */appChatsManager.hasRights(-peerId, 'send_messages', undefined, !!threadId); \n      return /* !isChannel ||  */hasRights;\n    } else {\n      return appUsersManager.canSendToUser(peerId);\n    }\n  }\n\n  public finalizePendingMessage(randomId: string, finalMessage: any) {\n    const pendingData = this.pendingByRandomId[randomId];\n    // this.log('pdata', randomID, pendingData)\n\n    if(pendingData) {\n      const {peerId, tempId, threadId, storage} = pendingData;\n\n      [this.getHistoryStorage(peerId), threadId ? this.getHistoryStorage(peerId, threadId) : undefined]\n      .filter(Boolean)\n      .forEach(storage => {\n        storage.history.delete(tempId);\n      });\n\n      // this.log('pending', randomID, historyStorage.pending)\n\n      const message = this.getMessageFromStorage(storage, tempId);\n      if(!message.deleted) {\n        delete message.pFlags.is_outgoing;\n        delete message.pending;\n        delete message.error;\n        delete message.random_id;\n        delete message.send;\n\n        rootScope.dispatchEvent('messages_pending');\n      }\n      \n      delete this.pendingByRandomId[randomId];\n\n      this.finalizePendingMessageCallbacks(storage, tempId, finalMessage.mid);\n\n      return message;\n    }\n\n    return false;\n  }\n\n  public finalizePendingMessageCallbacks(storage: MessagesStorage, tempId: number, mid: number) {\n    const message = this.getMessageFromStorage(storage, mid);\n    const callbacks = this.tempFinalizeCallbacks[tempId];\n    //this.log.warn(callbacks, tempId);\n    if(callbacks !== undefined) {\n      for(const name in callbacks) {\n        const {deferred, callback} = callbacks[name];\n        //this.log(`finalizePendingMessageCallbacks: will invoke ${name} callback`);\n        callback(message).then(deferred.resolve, deferred.reject);\n      }\n\n      delete this.tempFinalizeCallbacks[tempId];\n    }\n\n    // set cached url to media\n    if(message.media) {\n      if(message.media.photo) {\n        const photo = appPhotosManager.getPhoto('' + tempId);\n        if(/* photo._ !== 'photoEmpty' */photo) {\n          const newPhoto = message.media.photo as MyPhoto;\n          const newPhotoSize = newPhoto.sizes[newPhoto.sizes.length - 1];\n          const cacheContext = appDownloadManager.getCacheContext(newPhoto, newPhotoSize.type);\n          const oldCacheContext = appDownloadManager.getCacheContext(photo, 'full');\n          Object.assign(cacheContext, oldCacheContext);\n\n          const photoSize = newPhoto.sizes[newPhoto.sizes.length - 1] as PhotoSize.photoSize;\n\n          const downloadOptions = appPhotosManager.getPhotoDownloadOptions(newPhoto, photoSize);\n          const fileName = getFileNameByLocation(downloadOptions.location);\n          appDownloadManager.fakeDownload(fileName, oldCacheContext.url);\n        }\n      } else if(message.media.document) {\n        const doc = appDocsManager.getDoc('' + tempId);\n        if(doc) {\n          if(/* doc._ !== 'documentEmpty' &&  */doc.type && doc.type !== 'sticker') {\n            const newDoc = message.media.document;\n            const cacheContext = appDownloadManager.getCacheContext(newDoc);\n            const oldCacheContext = appDownloadManager.getCacheContext(doc);\n            Object.assign(cacheContext, oldCacheContext);\n\n            const fileName = appDocsManager.getInputFileName(newDoc);\n            appDownloadManager.fakeDownload(fileName, oldCacheContext.url);\n          }\n        }\n      } else if(message.media.poll) {\n        delete appPollsManager.polls[tempId];\n        delete appPollsManager.results[tempId];\n      }\n    }\n\n    const tempMessage = this.getMessageFromStorage(storage, tempId);\n    delete storage[tempId];\n    \n    this.handleReleasingMessage(tempMessage);\n\n    rootScope.dispatchEvent('message_sent', {storage, tempId, tempMessage, mid});\n  }\n\n  public incrementMaxSeenId(maxId: number) {\n    if(!maxId || !(!this.maxSeenId || maxId > this.maxSeenId)) {\n      return false;\n    }\n\n    this.maxSeenId = maxId;\n    appStateManager.pushToState('maxSeenMsgId', maxId);\n\n    apiManager.invokeApi('messages.receivedMessages', {\n      max_id: this.getServerMessageId(maxId)\n    });\n  }\n\n  private notifyAboutMessage(message: MyMessage, options: Partial<{\n    fwdCount: number,\n    peerTypeNotifySettings: PeerNotifySettings\n  }> = {}) {\n    const peerId = this.getMessagePeer(message);\n    const notification: NotifyOptions = {};\n    const peerString = appPeersManager.getPeerString(peerId);\n    let notificationMessage: string;\n\n    if(options.peerTypeNotifySettings.show_previews) {\n      if(message._ === 'message' && message.fwd_from && options.fwdCount) {\n        notificationMessage = I18n.format('Notifications.Forwarded', true, [options.fwdCount]);\n      } else {\n        notificationMessage = this.wrapMessageForReply(message, undefined, undefined, true);\n      }\n    } else {\n      notificationMessage = I18n.format('Notifications.New', true);\n    }\n\n    notification.title = appPeersManager.getPeerTitle(peerId, true);\n    if(peerId < 0 && message.fromId !== message.peerId) {\n      notification.title = appPeersManager.getPeerTitle(message.fromId, true) +\n        ' @ ' +\n        notification.title;\n    }\n\n    notification.title = RichTextProcessor.wrapPlainText(notification.title);\n\n    notification.onclick = () => {\n      rootScope.dispatchEvent('history_focus', {peerId, mid: message.mid});\n    };\n\n    notification.message = notificationMessage;\n    notification.key = 'msg' + message.mid;\n    notification.tag = peerString;\n    notification.silent = true;//message.pFlags.silent || false;\n\n    const peerPhoto = appPeersManager.getPeerPhoto(peerId);\n    if(peerPhoto) {\n      appAvatarsManager.loadAvatar(peerId, peerPhoto, 'photo_small').loadPromise.then(url => {\n        if(message.pFlags.unread) {\n          notification.image = url;\n          appNotificationsManager.notify(notification);\n        }\n      });\n    } else {\n      appNotificationsManager.notify(notification);\n    }\n  }\n\n  public getScheduledMessagesStorage(peerId: number) {\n    return this.scheduledMessagesStorage[peerId] ?? (this.scheduledMessagesStorage[peerId] = this.createMessageStorage());\n  }\n\n  public getScheduledMessages(peerId: number): Promise<number[]> {\n    if(!this.canWriteToPeer(peerId)) return Promise.resolve([]);\n\n    const storage = this.getScheduledMessagesStorage(peerId);\n    if(Object.keys(storage).length) {\n      return Promise.resolve(Object.keys(storage).map(id => +id));\n    }\n\n    return apiManager.invokeApiSingle('messages.getScheduledHistory', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      hash: 0\n    }).then(historyResult => {\n      if(historyResult._ !== 'messages.messagesNotModified') {\n        appUsersManager.saveApiUsers(historyResult.users);\n        appChatsManager.saveApiChats(historyResult.chats);\n        \n        const storage = this.getScheduledMessagesStorage(peerId);\n        this.saveMessages(historyResult.messages, {storage, isScheduled: true});\n        return Object.keys(storage).map(id => +id);\n      }\n      \n      return [];\n    });\n  }\n\n  public sendScheduledMessages(peerId: number, mids: number[]) {\n    return apiManager.invokeApi('messages.sendScheduledMessages', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      id: mids.map(mid => this.getServerMessageId(mid))\n    }).then(updates => {\n      apiUpdatesManager.processUpdateMessage(updates);\n    });\n  }\n\n  public deleteScheduledMessages(peerId: number, mids: number[]) {\n    return apiManager.invokeApi('messages.deleteScheduledMessages', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      id: mids.map(mid => this.getServerMessageId(mid))\n    }).then(updates => {\n      apiUpdatesManager.processUpdateMessage(updates);\n    });\n  }\n\n  public getMessageWithReplies(message: Message.message) {\n    if(message.peerId !== REPLIES_PEER_ID) {\n      message = this.filterMessages(message, message => !!(message as Message.message).replies)[0] as any;\n      if(!(message && message.replies && message.replies.pFlags.comments && message.replies.channel_id !== 777)) {\n        return;\n      }\n    }\n\n    return message;\n  }\n\n  public isFetchIntervalNeeded(peerId: number) {\n    return peerId < 0 && !appChatsManager.isInChat(peerId);\n  }\n\n  public async getNewHistory(peerId: number, threadId?: number) {\n    if(!this.isFetchIntervalNeeded(peerId)) {\n      return;\n    }\n\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\n    const slice = historyStorage.history.slice;\n    if(!slice.isEnd(SliceEnd.Bottom)) {\n      return;\n    }\n\n    delete historyStorage.maxId;\n    slice.unsetEnd(SliceEnd.Bottom);\n\n    // if there is no id - then request by first id because cannot request by id 0 with backLimit\n    let historyResult = this.getHistory(peerId, slice[0] ?? 1, 0, 50, threadId);\n    if(historyResult instanceof Promise) {\n      historyResult = await historyResult;\n    }\n\n    for(let i = 0, length = historyResult.history.length; i < length; ++i) {\n      this.handleNewMessage(peerId, historyResult.history[i]);\n    }\n\n    return historyStorage;\n  }\n\n  /**\n   * * https://core.telegram.org/api/offsets, offset_id is inclusive\n   */\n  public getHistory(peerId: number, maxId = 0, limit: number, backLimit?: number, threadId?: number): Promise<HistoryResult> | HistoryResult {\n    const historyStorage = this.getHistoryStorage(peerId, threadId);\n\n    let offset = 0;\n    /* \n    let offsetFound = true;\n\n    if(maxId) {\n      offsetFound = false;\n      for(; offset < historyStorage.history.length; offset++) {\n        if(maxId > historyStorage.history.slice[offset]) {\n          offsetFound = true;\n          break;\n        }\n      }\n    }\n\n    if(offsetFound && (\n      historyStorage.count !== null && historyStorage.history.length === historyStorage.count ||\n      historyStorage.history.length >= offset + limit\n      )) {\n      if(backLimit) {\n        backLimit = Math.min(offset, backLimit);\n        offset = Math.max(0, offset - backLimit);\n        limit += backLimit;\n      } else {\n        limit = limit;\n      }\n\n      const history = historyStorage.history.slice.slice(offset, offset + limit);\n      return {\n        count: historyStorage.count,\n        history: history,\n        offsetIdOffset: offset\n      };\n    }\n\n    if(offsetFound) {\n      offset = 0;\n    } */\n\n    if(backLimit) {\n      offset = -backLimit;\n      limit += backLimit;\n\n      /* return this.requestHistory(reqPeerId, maxId, limit, offset, undefined, threadId).then((historyResult) => {\n        historyStorage.count = (historyResult as MessagesMessages.messagesMessagesSlice).count || historyResult.messages.length;\n\n        const history = (historyResult.messages as MyMessage[]).map(message => message.mid);\n        return {\n          count: historyStorage.count,\n          history,\n          offsetIdOffset: (historyResult as MessagesMessages.messagesMessagesSlice).offset_id_offset || 0\n        };\n      }); */\n    }\n\n    const haveSlice = historyStorage.history.sliceMe(maxId, offset, limit);\n    if(haveSlice && (haveSlice.slice.length === limit || (haveSlice.fulfilled & SliceEnd.Both) === SliceEnd.Both)) {\n      return {\n        count: historyStorage.count,\n        history: haveSlice.slice,\n        offsetIdOffset: haveSlice.offsetIdOffset\n      }; \n    }\n\n    return this.fillHistoryStorage(peerId, maxId, limit, offset, historyStorage, threadId).then(() => {\n      const slice = historyStorage.history.sliceMe(maxId, offset, limit);\n      return {\n        count: historyStorage.count,\n        history: slice?.slice || historyStorage.history.constructSlice(),\n        offsetIdOffset: slice?.offsetIdOffset || historyStorage.count\n      };\n    });\n  }\n\n  public fillHistoryStorage(peerId: number, offset_id: number, limit: number, add_offset: number, historyStorage: HistoryStorage, threadId?: number): Promise<void> {\n    return this.requestHistory(peerId, offset_id, limit, add_offset, undefined, threadId).then((historyResult) => {\n      const {offset_id_offset, count, messages} = historyResult as MessagesMessages.messagesMessagesSlice;\n\n      historyStorage.count = count || messages.length;\n      const offsetIdOffset = offset_id_offset || 0;\n\n      const topWasMeantToLoad = add_offset < 0 ? limit + add_offset : limit;\n\n      const isTopEnd = offsetIdOffset >= (historyStorage.count - topWasMeantToLoad) || historyStorage.count < topWasMeantToLoad;\n      const isBottomEnd = !offsetIdOffset || (add_offset < 0 && (offsetIdOffset + add_offset) <= 0);\n\n      /* if(!maxId && historyResult.messages.length) {\n        maxId = this.incrementMessageId((historyResult.messages[0] as MyMessage).mid, 1);\n      }\n\n      const wasTotalCount = historyStorage.history.length; */\n\n      const mids = messages.map((message) => {\n        if(this.mergeReplyKeyboard(historyStorage, message as MyMessage)) {\n          rootScope.dispatchEvent('history_reply_markup', {peerId});\n        }\n\n        return (message as MyMessage).mid;\n      });\n\n      // * add bound manually. \n      // * offset_id will be inclusive only if there is 'add_offset' <= -1 (-1 - will only include the 'offset_id')\n      if(offset_id && !mids.includes(offset_id) && offsetIdOffset < historyStorage.count) {\n        let i = 0;\n        for(const length = mids.length; i < length; ++i) {\n          if(offset_id > mids[i]) {\n            break;\n          }\n        }\n\n        mids.splice(i, 0, offset_id);\n      }\n      \n      const slice = historyStorage.history.insertSlice(mids) || historyStorage.history.slice;\n      if(isTopEnd) {\n        slice.setEnd(SliceEnd.Top);\n      }\n  \n      if(isBottomEnd) {\n        slice.setEnd(SliceEnd.Bottom);\n        historyStorage.maxId = slice[0]; // ! WARNING\n      }\n      \n      /* const isBackLimit = offset < 0 && -offset !== fullLimit;\n      if(isBackLimit) {\n        return;\n      }\n\n      const totalCount = historyStorage.history.length;\n      fullLimit -= (totalCount - wasTotalCount);\n\n      const migratedNextPeer = this.migratedFromTo[peerId];\n      const migratedPrevPeer = this.migratedToFrom[peerId]\n      const isMigrated = migratedNextPeer !== undefined || migratedPrevPeer !== undefined;\n\n      if(isMigrated) {\n        historyStorage.count = Math.max(historyStorage.count, totalCount) + 1;\n      }\n\n      if(fullLimit > 0) {\n        maxId = historyStorage.history.slice[totalCount - 1];\n        if(isMigrated) {\n          if(!historyResult.messages.length) {\n            if(migratedPrevPeer) {\n              maxId = 0;\n              peerId = migratedPrevPeer;\n            } else {\n              historyStorage.count = totalCount;\n              return true;\n            }\n          }\n\n          return this.fillHistoryStorage(peerId, maxId, fullLimit, historyStorage, threadId);\n        } else if(totalCount < historyStorage.count) {\n          return this.fillHistoryStorage(peerId, maxId, fullLimit, offset, historyStorage, threadId);\n        }\n      } */\n    });\n  }\n\n  public requestHistory(peerId: number, maxId: number, limit = 0, offset = 0, offsetDate = 0, threadId = 0): Promise<Exclude<MessagesMessages, MessagesMessages.messagesMessagesNotModified>> {\n    //console.trace('requestHistory', peerId, maxId, limit, offset);\n\n    //rootScope.broadcast('history_request');\n\n    const options: any = {\n      peer: appPeersManager.getInputPeerById(peerId),\n      offset_id: this.getServerMessageId(maxId) || 0,\n      offset_date: offsetDate,\n      add_offset: offset,\n      limit,\n      max_id: 0,\n      min_id: 0,\n      hash: 0\n    };\n\n    if(threadId) {\n      options.msg_id = this.getServerMessageId(threadId) || 0;\n    }\n\n    const promise: ReturnType<AppMessagesManager['requestHistory']> = apiManager.invokeApiSingle(threadId ? 'messages.getReplies' : 'messages.getHistory', options, {\n      //timeout: APITIMEOUT,\n      noErrorBox: true\n    }) as any;\n\n    return promise.then((historyResult) => {\n      if(DEBUG) {\n        this.log('requestHistory result:', peerId, historyResult, maxId, limit, offset);\n      }\n\n      appUsersManager.saveApiUsers(historyResult.users);\n      appChatsManager.saveApiChats(historyResult.chats);\n      this.saveMessages(historyResult.messages);\n\n      if(appPeersManager.isChannel(peerId)) {\n        apiUpdatesManager.addChannelState(-peerId, (historyResult as MessagesMessages.messagesChannelMessages).pts);\n      }\n\n      let length = historyResult.messages.length, count = (historyResult as MessagesMessages.messagesMessagesSlice).count;\n      if(length && historyResult.messages[length - 1].deleted) {\n        historyResult.messages.splice(length - 1, 1);\n        length--;\n        count--;\n      }\n\n      // will load more history if last message is album grouped (because it can be not last item)\n      // historyResult.messages: desc sorted\n      const historyStorage = this.getHistoryStorage(peerId, threadId);\n      const oldestMessage: Message.message = historyResult.messages[length - 1] as any;\n      if(length && oldestMessage.grouped_id) {\n        const foundSlice = historyStorage.history.findSlice(oldestMessage.mid);\n        if(foundSlice && (foundSlice.slice.length + historyResult.messages.length) < count) {\n          return this.requestHistory(peerId, oldestMessage.mid, 10, 0, offsetDate, threadId).then((_historyResult) => {\n            return historyResult;\n          });\n        }\n      }\n\n      return historyResult;\n    }, (error) => {\n      switch (error.type) {\n        case 'CHANNEL_PRIVATE':\n          let channel = appChatsManager.getChat(-peerId);\n          channel = {_: 'channelForbidden', access_hash: channel.access_hash, title: channel.title};\n          apiUpdatesManager.processUpdateMessage({\n            _: 'updates',\n            updates: [{\n              _: 'updateChannel',\n              channel_id: -peerId\n            }],\n            chats: [channel],\n            users: []\n          });\n          break;\n      }\n\n      throw error;\n    });\n  }\n\n  public fetchSingleMessages() {\n    if(this.fetchSingleMessagesPromise) {\n      return this.fetchSingleMessagesPromise;\n    }\n\n    return this.fetchSingleMessagesPromise = new Promise((resolve) => {\n      setTimeout(() => {\n        let promises: Promise<void>[] = [];\n        \n        for(const peerId in this.needSingleMessages) {\n          const mids = this.needSingleMessages[peerId];\n          delete this.needSingleMessages[peerId];\n    \n          const msgIds: InputMessage[] = mids.map((msgId: number) => {\n            return {\n              _: 'inputMessageID',\n              id: this.getServerMessageId(msgId)\n            };\n          });\n    \n          let promise: Promise<MethodDeclMap['channels.getMessages']['res'] | MethodDeclMap['messages.getMessages']['res']>;\n          if(+peerId < 0 && appPeersManager.isChannel(+peerId)) {\n            promise = apiManager.invokeApiSingle('channels.getMessages', {\n              channel: appChatsManager.getChannelInput(-+peerId),\n              id: msgIds\n            });\n          } else {\n            promise = apiManager.invokeApiSingle('messages.getMessages', {\n              id: msgIds\n            });\n          }\n    \n          promises.push(promise.then(getMessagesResult => {\n            if(getMessagesResult._ !== 'messages.messagesNotModified') {\n              appUsersManager.saveApiUsers(getMessagesResult.users);\n              appChatsManager.saveApiChats(getMessagesResult.chats);\n              this.saveMessages(getMessagesResult.messages);\n            }\n    \n            rootScope.dispatchEvent('messages_downloaded', {peerId: +peerId, mids});\n          }));\n        }\n\n        Promise.all(promises).finally(() => {\n          this.fetchSingleMessagesPromise = null;\n          if(Object.keys(this.needSingleMessages).length) this.fetchSingleMessages();\n          resolve();\n        });\n      }, 0);\n    });\n  }\n\n  public wrapSingleMessage(peerId: number, msgId: number, overwrite = false): Promise<void> {\n    if(!this.getMessageByPeer(peerId, msgId).deleted && !overwrite) {\n      rootScope.dispatchEvent('messages_downloaded', {peerId, mids: [msgId]});\n      return Promise.resolve();\n    } else if(!this.needSingleMessages[peerId] || this.needSingleMessages[peerId].indexOf(msgId) === -1) {\n      (this.needSingleMessages[peerId] ?? (this.needSingleMessages[peerId] = [])).push(msgId);\n      return this.fetchSingleMessages();\n    } else if(this.fetchSingleMessagesPromise) {\n      return this.fetchSingleMessagesPromise;\n    }\n  }\n\n  public setTyping(peerId: number, action: SendMessageAction): Promise<boolean> {\n    let typing = this.typings[peerId];\n    if(!rootScope.myId || \n      !peerId || \n      !this.canWriteToPeer(peerId) || \n      peerId === rootScope.myId ||\n      typing?.type === action._\n    ) {\n      return Promise.resolve(false);\n    }\n\n    if(typing?.timeout) {\n      clearTimeout(typing.timeout);\n    }\n\n    typing = this.typings[peerId] = {\n      type: action._\n    };\n\n    return apiManager.invokeApi('messages.setTyping', {\n      peer: appPeersManager.getInputPeerById(peerId),\n      action\n    }).finally(() => {\n      if(typing === this.typings[peerId]) {\n        typing.timeout = window.setTimeout(() => {\n          delete this.typings[peerId];\n        }, 6000);\n      }\n    });\n  }\n\n  private handleReleasingMessage(message: MyMessage) {\n    if('media' in message) {\n      // @ts-ignore\n      const c = message.media.webpage || message.media;\n      const smth: Photo.photo | MyDocument = c.photo || c.document;\n\n      if(smth?.file_reference) {\n        referenceDatabase.deleteContext(smth.file_reference, {type: 'message', peerId: message.peerId, messageId: message.mid});\n      }\n\n      if('webpage' in message.media) {\n        appWebPagesManager.deleteWebPageFromPending(message.media.webpage, message.mid);\n      }\n    }\n  }\n\n  private handleDeletedMessages(peerId: number, storage: MessagesStorage, messages: number[]) {\n    const history: {\n      count: number, \n      unread: number, \n      msgs: {[mid: number]: true},\n      albums?: {[groupId: string]: Set<number>},\n    } = {count: 0, unread: 0, msgs: {}} as any;\n\n    for(const mid of messages) {\n      const message: MyMessage = this.getMessageFromStorage(storage, mid);\n      if(message.deleted) continue;\n\n      this.handleReleasingMessage(message);\n\n      this.updateMessageRepliesIfNeeded(message);\n\n      if(!message.pFlags.out && !message.pFlags.is_outgoing && message.pFlags.unread) {\n        history.unread++;\n        appNotificationsManager.cancel('msg' + mid);\n      }\n      history.count++;\n      history.msgs[mid] = true;\n\n      message.deleted = true;\n\n      if(message._ !== 'messageService' && message.grouped_id) {\n        const groupedStorage = this.groupedMessagesStorage[message.grouped_id];\n        if(groupedStorage) {\n          delete groupedStorage[mid];\n\n          if(!history.albums) history.albums = {};\n          (history.albums[message.grouped_id] || (history.albums[message.grouped_id] = new Set())).add(mid);\n\n          if(!Object.keys(groupedStorage).length) {\n            delete history.albums;\n            delete this.groupedMessagesStorage[message.grouped_id];\n          }\n        }\n      }\n\n      delete storage[mid];\n\n      const peerMessagesToHandle = this.newMessagesToHandle[peerId];\n      if(peerMessagesToHandle && peerMessagesToHandle.has(mid)) {\n        peerMessagesToHandle.delete(mid);\n      }\n    }\n\n    if(history.albums) {\n      for(const groupId in history.albums) {\n        rootScope.dispatchEvent('album_edit', {peerId, groupId, deletedMids: [...history.albums[groupId]]});\n        /* const mids = this.getMidsByAlbum(groupId);\n        if(mids.length) {\n          const mid = Math.max(...mids);\n          rootScope.$broadcast('message_edit', {peerId, mid, justMedia: false});\n        } */\n      }\n    }\n\n    return history;\n  }\n  \n  private handleEditedMessage(oldMessage: any, newMessage: any) {\n    if(oldMessage.media?.webpage) {\n      appWebPagesManager.deleteWebPageFromPending(oldMessage.media.webpage, oldMessage.mid);\n    }\n  }\n}\n\nconst appMessagesManager = new AppMessagesManager();\nMOUNT_CLASS_TO.appMessagesManager = appMessagesManager;\nexport default appMessagesManager;\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport { formatPhoneNumber } from \"../../components/misc\";\nimport { MOUNT_CLASS_TO } from \"../../config/debug\";\nimport { filterUnique } from \"../../helpers/array\";\nimport cleanSearchText from \"../../helpers/cleanSearchText\";\nimport cleanUsername from \"../../helpers/cleanUsername\";\nimport { tsNow } from \"../../helpers/date\";\nimport { safeReplaceObject, isObject } from \"../../helpers/object\";\nimport { InputUser, User as MTUser, UserProfilePhoto, UserStatus } from \"../../layer\";\nimport I18n, { i18n, LangPackKey } from \"../langPack\";\n//import apiManager from '../mtproto/apiManager';\nimport apiManager from '../mtproto/mtprotoworker';\nimport { REPLIES_PEER_ID } from \"../mtproto/mtproto_config\";\nimport serverTimeManager from \"../mtproto/serverTimeManager\";\nimport { RichTextProcessor } from \"../richtextprocessor\";\nimport rootScope from \"../rootScope\";\nimport SearchIndex from \"../searchIndex\";\nimport apiUpdatesManager from \"./apiUpdatesManager\";\nimport appChatsManager from \"./appChatsManager\";\nimport appPeersManager from \"./appPeersManager\";\nimport appStateManager from \"./appStateManager\";\n\n// TODO: updateUserBlocked\n\nexport type User = MTUser.user;\n\nexport class AppUsersManager {\n  private storage = appStateManager.storages.users;\n  \n  private users: {[userId: number]: User};\n  private usernames: {[username: string]: number};\n  private contactsIndex: SearchIndex<number>;\n  private contactsFillPromise: Promise<Set<number>>;\n  private contactsList: Set<number>;\n  private updatedContactsList: boolean;\n  \n  private getTopPeersPromise: Promise<number[]>;\n\n  constructor() {\n    this.clear(true);\n\n    setInterval(this.updateUsersStatuses, 60000);\n\n    rootScope.addEventListener('state_synchronized', this.updateUsersStatuses);\n\n    rootScope.addMultipleEventsListeners({\n      updateUserStatus: (update) => {\n        const userId = update.user_id;\n        const user = this.users[userId];\n        if(user) {\n          user.status = update.status;\n          if(user.status) {\n            if('expires' in user.status) {\n              user.status.expires -= serverTimeManager.serverTimeOffset;\n            }\n\n            if('was_online' in user.status) {\n              user.status.was_online -= serverTimeManager.serverTimeOffset;\n            }\n          }\n\n          //user.sortStatus = this.getUserStatusForSort(user.status);\n          rootScope.dispatchEvent('user_update', userId);\n          this.setUserToStateIfNeeded(user);\n        } //////else console.warn('No user by id:', userId);\n      },\n\n      updateUserPhoto: (update) => {\n        const userId = update.user_id;\n        const user = this.users[userId];\n        if(user) {\n          this.forceUserOnline(userId);\n\n          if(update.photo._ === 'userProfilePhotoEmpty') {\n            delete user.photo;\n          } else {\n            user.photo = safeReplaceObject(user.photo, update.photo);\n          }\n\n          this.setUserToStateIfNeeded(user);\n\n          rootScope.dispatchEvent('user_update', userId);\n          rootScope.dispatchEvent('avatar_update', userId);\n        } else console.warn('No user by id:', userId);\n      },\n\n      updateUserName: (update) => {\n        const userId = update.user_id;\n        const user = this.users[userId];\n        if(user) {\n          this.forceUserOnline(userId);\n          \n          this.saveApiUser(Object.assign({}, user, {\n            first_name: update.first_name,\n            last_name: update.last_name,\n            username: update.username\n          }), true);\n        }\n      }\n    });\n\n    /* case 'updateContactLink':\n    this.onContactUpdated(update.user_id, update.my_link._ === 'contactLinkContact');\n    break; */\n\n    rootScope.addEventListener('language_change', (e) => {\n      const userId = this.getSelf().id;\n      this.contactsIndex.indexObject(userId, this.getUserSearchText(userId));\n    });\n\n    appStateManager.getState().then((state) => {\n      const users = appStateManager.storagesResults.users;\n      if(users.length) {\n        for(let i = 0, length = users.length; i < length; ++i) {\n          const user = users[i];\n          if(user) {\n            this.users[user.id] = user;\n          }\n        }\n      }\n\n      const contactsList = state.contactsList;\n      if(contactsList && Array.isArray(contactsList)) {\n        contactsList.forEach(userId => {\n          this.pushContact(userId);\n        });\n\n        if(contactsList.length) {\n          this.contactsFillPromise = Promise.resolve(this.contactsList);\n        }\n      }\n\n      appStateManager.addEventListener('peerNeeded', (peerId: number) => {\n        if(peerId < 0 || this.storage.getFromCache(peerId)) {\n          return;\n        }\n\n        this.storage.set({\n          [peerId]: this.getUser(peerId)\n        });\n      });\n\n      appStateManager.addEventListener('peerUnneeded', (peerId: number) => {\n        if(peerId < 0 || !this.storage.getFromCache(peerId)) {\n          return;\n        }\n\n        this.storage.delete(peerId);\n      });\n    });\n  }\n\n  public clear(init = false) {\n    if(!init) {\n      const users = appStateManager.storagesResults.users;\n      for(const _userId in this.users) {\n        const userId = +_userId;\n        if(!userId) continue;\n        if(!appStateManager.isPeerNeeded(userId)) {\n          const user = this.users[userId];\n          if(user.username) {\n            delete this.usernames[cleanUsername(user.username)];\n          }\n\n          users.findAndSplice((user) => user.id === userId);\n          this.storage.delete(userId);\n          delete this.users[userId];\n        }\n      }\n    } else {\n      this.users = {};\n      this.usernames = {};\n    }\n    \n    this.contactsIndex = new SearchIndex();\n    this.contactsFillPromise = undefined;\n    this.contactsList = new Set();\n    this.updatedContactsList = false;\n  }\n\n  private onContactsModified() {\n    const contactsList = [...this.contactsList];\n    appStateManager.pushToState('contactsList', contactsList);\n  }\n\n  public fillContacts() {\n    if(this.contactsFillPromise && this.updatedContactsList) {\n      return this.contactsFillPromise;\n    }\n\n    this.updatedContactsList = true;\n\n    const promise = apiManager.invokeApi('contacts.getContacts').then((result) => {\n      if(result._ === 'contacts.contacts') {\n        this.saveApiUsers(result.users);\n\n        result.contacts.forEach((contact) => {\n          this.pushContact(contact.user_id);\n        });\n\n        this.onContactsModified();\n      }\n\n      this.contactsFillPromise = promise;\n\n      return this.contactsList;\n    });\n\n    return this.contactsFillPromise || (this.contactsFillPromise = promise);\n  }\n\n  public resolveUsername(username: string) {\n    if(username[0] === '@') {\n      username = username.slice(1);\n    }\n\n    username = username.toLowerCase();\n    if(this.usernames[username]) {\n      return Promise.resolve(this.users[this.usernames[username]]);\n    }\n\n    return apiManager.invokeApi('contacts.resolveUsername', {username}).then(resolvedPeer => {\n      this.saveApiUsers(resolvedPeer.users);\n      appChatsManager.saveApiChats(resolvedPeer.chats);\n\n      return appPeersManager.getPeer(appPeersManager.getPeerId(resolvedPeer.peer));\n    });\n  }\n\n  public pushContact(userId: number) {\n    this.contactsList.add(userId);\n    this.contactsIndex.indexObject(userId, this.getUserSearchText(userId));\n    appStateManager.requestPeer(userId, 'contacts');\n  }\n\n  public getUserSearchText(id: number) {\n    const user = this.users[id];\n    if(!user) {\n      return '';\n    }\n\n    const arr: string[] = [\n      user.first_name,\n      user.last_name,\n      user.phone,\n      user.username,\n      user.pFlags.self ? I18n.format('SavedMessages', true) : '',\n      user.pFlags.self ? 'Saved Messages' : ''\n    ];\n\n    return arr.filter(Boolean).join(' ');\n  }\n\n  public getContacts(query?: string, includeSaved = false, sortBy: 'name' | 'online' | 'none' = 'name') {\n    return this.fillContacts().then(_contactsList => {\n      let contactsList = [..._contactsList];\n      if(query) {\n        const results = this.contactsIndex.search(query);\n        const filteredContactsList = [...contactsList].filter(id => results.has(id));\n\n        contactsList = filteredContactsList;\n      }\n\n      if(sortBy === 'name') {\n        contactsList.sort((userId1, userId2) => {\n          const sortName1 = (this.users[userId1] || {}).sortName || '';\n          const sortName2 = (this.users[userId2] || {}).sortName || '';\n          return sortName1.localeCompare(sortName2);\n        });\n      } else if(sortBy === 'online') {\n        contactsList.sort((userId1, userId2) => {\n          const status1 = appUsersManager.getUserStatusForSort(appUsersManager.getUser(userId1).status);\n          const status2 = appUsersManager.getUserStatusForSort(appUsersManager.getUser(userId2).status);\n          return status2 - status1;\n        });\n      }\n\n      contactsList.findAndSplice(p => p === rootScope.myId);\n      if(includeSaved) {\n        if(this.testSelfSearch(query)) {\n          contactsList.unshift(rootScope.myId);\n        }\n      }\n\n      return contactsList;\n    });\n  }\n\n  public toggleBlock(peerId: number, block: boolean) {\n    return apiManager.invokeApiSingle(block ? 'contacts.block' : 'contacts.unblock', {\n      id: appPeersManager.getInputPeerById(peerId)\n    }).then(value => {\n      if(value) {\n        apiUpdatesManager.processLocalUpdate({\n          _: 'updatePeerBlocked',\n          peer_id: appPeersManager.getOutputPeer(peerId),\n          blocked: block\n        });\n      }\n\n      return value;\n    });\n  }\n\n  public testSelfSearch(query: string) {\n    const user = this.getSelf();\n    const index = new SearchIndex();\n    index.indexObject(user.id, this.getUserSearchText(user.id));\n    return index.search(query).has(user.id);\n  }\n\n  public saveApiUsers(apiUsers: any[], override?: boolean) {\n    apiUsers.forEach((user) => this.saveApiUser(user, override));\n  }\n\n  public saveApiUser(user: MTUser, override?: boolean) {\n    if(user._ === 'userEmpty') return;\n\n    const userId = user.id;\n    const oldUser = this.users[userId];\n\n    // ! commented block can affect performance !\n    // if(oldUser && !override) {\n    //   console.log('saveApiUser same');\n    //   return;\n    // }\n\n    if(user.pFlags === undefined) {\n      user.pFlags = {};\n    }\n\n    if(user.pFlags.min && oldUser !== undefined) {\n      return;\n    }\n\n    // * exclude from state\n    // defineNotNumerableProperties(user, ['initials', 'num', 'rFirstName', 'rFullName', 'rPhone', 'sortName', 'sortStatus']);\n\n    const fullName = user.first_name + ' ' + (user.last_name || '');\n    if(user.username) {\n      const searchUsername = cleanUsername(user.username);\n      this.usernames[searchUsername] = userId;\n    }\n\n    user.sortName = user.pFlags.deleted ? '' : cleanSearchText(fullName, false);\n\n    user.initials = RichTextProcessor.getAbbreviation(fullName);\n\n    if(user.status) {\n      if((user.status as UserStatus.userStatusOnline).expires) {\n        (user.status as UserStatus.userStatusOnline).expires -= serverTimeManager.serverTimeOffset;\n      }\n\n      if((user.status as UserStatus.userStatusOffline).was_online) {\n        (user.status as UserStatus.userStatusOffline).was_online -= serverTimeManager.serverTimeOffset;\n      }\n    }\n\n    //user.sortStatus = user.pFlags.bot ? -1 : this.getUserStatusForSort(user.status);\n\n    let changedPhoto = false, changedTitle = false;\n    if(oldUser === undefined) {\n      this.users[userId] = user;\n    } else {\n      if(user.first_name !== oldUser.first_name \n        || user.last_name !== oldUser.last_name \n        || user.username !== oldUser.username) {\n        changedTitle = true;\n      }\n\n      const oldPhotoId = (oldUser.photo as UserProfilePhoto.userProfilePhoto)?.photo_id;\n      const newPhotoId = (user.photo as UserProfilePhoto.userProfilePhoto)?.photo_id;\n      if(oldPhotoId !== newPhotoId) {\n        changedPhoto = true;\n      }\n\n      /* if(user.pFlags.bot && user.bot_info_version !== oldUser.bot_info_version) {\n        \n      } */\n\n      safeReplaceObject(oldUser, user);\n      rootScope.dispatchEvent('user_update', userId);\n    }\n\n    if(changedPhoto) {\n      rootScope.dispatchEvent('avatar_update', user.id);\n    }\n\n    if(changedTitle) {\n      rootScope.dispatchEvent('peer_title_edit', user.id);\n    }\n\n    this.setUserToStateIfNeeded(user);\n  }\n\n  public setUserToStateIfNeeded(user: User) {\n    if(appStateManager.isPeerNeeded(user.id)) {\n      this.storage.set({\n        [user.id]: user\n      });\n    }\n  }\n\n  public formatUserPhone(phone: string) {\n    return '+' + formatPhoneNumber(phone).formatted;\n  }\n\n  public getUserStatusForSort(status: User['status'] | number) {\n    if(typeof(status) === 'number') {\n      status = this.getUser(status).status;\n    }\n\n    if(status) {\n      const expires = status._ === 'userStatusOnline' ? status.expires : (status._ === 'userStatusOffline' ? status.was_online : 0);\n      if(expires) {\n        return expires;\n      }\n\n      /* const timeNow = tsNow(true);\n      switch(status._) {\n        case 'userStatusRecently':\n          return timeNow - 86400 * 3;\n        case 'userStatusLastWeek':\n          return timeNow - 86400 * 7;\n        case 'userStatusLastMonth':\n          return timeNow - 86400 * 30;\n      } */\n      switch(status._) {\n        case 'userStatusRecently':\n          return 3;\n        case 'userStatusLastWeek':\n          return 2;\n        case 'userStatusLastMonth':\n          return 1;\n      }\n    }\n\n    return 0;\n  }\n\n  public getUser(id: any): User {\n    if(isObject(id)) {\n      return id;\n    }\n\n    return this.users[id] || {id: id, pFlags: {deleted: true}, access_hash: ''} as User;\n  }\n\n  public getSelf() {\n    return this.getUser(rootScope.myId);\n  }\n\n  public getUserStatusString(userId: number): HTMLElement {\n    let key: LangPackKey;\n    let args: any[];\n\n    switch(userId) {\n      case REPLIES_PEER_ID:\n        key = 'Peer.RepliesNotifications';\n        break;\n      case 777000:\n        key = 'Peer.ServiceNotifications';\n        break;\n      default: {\n        if(this.isBot(userId)) {\n          key = 'Bot';\n          break;\n        }\n\n        const user = this.getUser(userId);\n        if(!user) {\n          key = '' as any;\n          break;\n        }\n\n        if(user.pFlags.support) {\n          key = 'SupportStatus';\n          break;\n        }\n\n        switch(user.status?._) {\n          case 'userStatusRecently': {\n            key = 'Lately';\n            break;\n          }\n    \n          case 'userStatusLastWeek': {\n            key = 'WithinAWeek';\n            break;\n          }\n    \n          case 'userStatusLastMonth': {\n            key = 'WithinAMonth';\n            break;\n          }\n          \n          case 'userStatusOffline': {\n            const date = user.status.was_online;\n            const now = Date.now() / 1000;\n            \n            if((now - date) < 60) {\n              key = 'Peer.Status.justNow';\n            } else if((now - date) < 3600) {\n              key = 'Peer.Status.minAgo';\n              const c = (now - date) / 60 | 0;\n              args = [c];\n            } else if(now - date < 86400) {\n              key = 'LastSeen.HoursAgo';\n              const c = (now - date) / 3600 | 0;\n              args = [c];\n            } else {\n              key = 'Peer.Status.LastSeenAt';\n              const d = new Date(date * 1000);\n              args = [('0' + d.getDate()).slice(-2) + '.' + ('0' + (d.getMonth() + 1)).slice(-2), \n                ('0' + d.getHours()).slice(-2) + ':' + ('0' + d.getMinutes()).slice(-2)];\n            }\n            \n            break;\n          }\n    \n          case 'userStatusOnline': {\n            key = 'Online';\n            break;\n          }\n    \n          default: {\n            key = 'ALongTimeAgo';\n            break;\n          }\n        }\n\n        break;\n      }\n    }\n    \n    return i18n(key, args);\n  }\n\n  public isBot(id: number) {\n    return this.users[id] && this.users[id].pFlags.bot;\n  }\n\n  public isContact(id: number) {\n    return this.contactsList.has(id) || (this.users[id] && this.users[id].pFlags.contact);\n  }\n  \n  public isRegularUser(id: number) {\n    const user = this.users[id];\n    return user && !this.isBot(id) && !user.pFlags.deleted && !user.pFlags.support;\n  }\n\n  public isNonContactUser(id: number) {\n    return this.isRegularUser(id) && !this.isContact(id) && id !== rootScope.myId;\n  }\n\n  public hasUser(id: number, allowMin?: boolean) {\n    const user = this.users[id];\n    return isObject(user) && (allowMin || !user.pFlags.min);\n  }\n\n  public canSendToUser(id: number) {\n    const user = this.getUser(id);\n    return !user.pFlags.deleted && user.username !== 'replies';\n  }\n\n  public getUserPhoto(id: number) {\n    const user = this.getUser(id);\n\n    return user && user.photo || {\n      _: 'userProfilePhotoEmpty'\n    };\n  }\n\n  public getUserString(id: number) {\n    const user = this.getUser(id);\n    return 'u' + id + (user.access_hash ? '_' + user.access_hash : '');\n  }\n\n  public getUserInput(id: number): InputUser {\n    const user = this.getUser(id);\n    if(user.pFlags && user.pFlags.self) {\n      return {_: 'inputUserSelf'};\n    }\n\n    return {\n      _: 'inputUser',\n      user_id: id,\n      access_hash: user.access_hash\n    };\n  }\n\n  public updateUsersStatuses = () => {\n    const timestampNow = tsNow(true);\n    for(const i in this.users) {\n      const user = this.users[i];\n\n      if(user.status &&\n        user.status._ === 'userStatusOnline' &&\n        user.status.expires < timestampNow) {\n\n        user.status = {_: 'userStatusOffline', was_online: user.status.expires};\n        rootScope.dispatchEvent('user_update', user.id);\n\n        this.setUserToStateIfNeeded(user);\n      }\n    }\n  };\n\n  public forceUserOnline(id: number, eventTimestamp?: number) {\n    if(this.isBot(id)) {\n      return;\n    }\n\n    const timestamp = tsNow(true);\n    const onlineTimeFor = 60;\n    if(eventTimestamp) {\n      if((timestamp - eventTimestamp) >= onlineTimeFor) {\n        return;\n      }\n    } else if(apiUpdatesManager.updatesState.syncLoading) {\n      return;\n    }\n\n    const user = this.getUser(id);\n    if(user &&\n      user.status &&\n      user.status._ !== 'userStatusOnline' &&\n      user.status._ !== 'userStatusEmpty' &&\n      !user.pFlags.support &&\n      !user.pFlags.deleted) {\n\n      user.status = {\n        _: 'userStatusOnline',\n        expires: timestamp + onlineTimeFor\n      };\n      \n      //user.sortStatus = this.getUserStatusForSort(user.status);\n      rootScope.dispatchEvent('user_update', id);\n\n      this.setUserToStateIfNeeded(user);\n    }\n  }\n\n  /* function importContact (phone, firstName, lastName) {\n      return MtpApiManager.invokeApi('contacts.importContacts', {\n        contacts: [{\n          _: 'inputPhoneContact',\n          client_id: '1',\n          phone: phone,\n          first_name: firstName,\n          last_name: lastName\n        }],\n        replace: false\n      }).then(function (importedContactsResult) {\n        saveApiUsers(importedContactsResult.users)\n\n        var foundUserID = false\n        angular.forEach(importedContactsResult.imported, function (importedContact) {\n          onContactUpdated(foundUserID = importedContact.user_id, true)\n        })\n\n        return foundUserID || false\n      })\n  }\n\n  function importContacts (contacts) {\n    var inputContacts = [],\n      i\n    var j\n\n    for (i = 0; i < contacts.length; i++) {\n      for (j = 0; j < contacts[i].phones.length; j++) {\n        inputContacts.push({\n          _: 'inputPhoneContact',\n          client_id: (i << 16 | j).toString(10),\n          phone: contacts[i].phones[j],\n          first_name: contacts[i].first_name,\n          last_name: contacts[i].last_name\n        })\n      }\n    }\n\n    return MtpApiManager.invokeApi('contacts.importContacts', {\n      contacts: inputContacts,\n      replace: false\n    }).then(function (importedContactsResult) {\n      saveApiUsers(importedContactsResult.users)\n\n      var result = []\n      angular.forEach(importedContactsResult.imported, function (importedContact) {\n        onContactUpdated(importedContact.user_id, true)\n        result.push(importedContact.user_id)\n      })\n\n      return result\n    })\n  } */\n\n  /* public deleteContacts(userIds: number[]) {\n    var ids: any[] = [];\n    userIds.forEach((userId) => {\n      ids.push(this.getUserInput(userId));\n    })\n\n    return apiManager.invokeApi('contacts.deleteContacts', {\n      id: ids\n    }).then(() => {\n      userIds.forEach((userId) => {\n        this.onContactUpdated(userId, false);\n      });\n    });\n  } */\n\n  public getTopPeers(): Promise<number[]> {\n    if(this.getTopPeersPromise) return this.getTopPeersPromise;\n\n    return this.getTopPeersPromise = appStateManager.getState().then((state) => {\n      if(state?.topPeers?.length) {\n        return state.topPeers;\n      }\n\n      return apiManager.invokeApi('contacts.getTopPeers', {\n        correspondents: true,\n        offset: 0,\n        limit: 15,\n        hash: 0,\n      }).then((result) => {\n        let peerIds: number[] = [];\n        if(result._ === 'contacts.topPeers') {\n          //console.log(result);\n          this.saveApiUsers(result.users);\n          appChatsManager.saveApiChats(result.chats);\n\n          if(result.categories.length) {\n            peerIds = result.categories[0].peers.map((topPeer) => {\n              const peerId = appPeersManager.getPeerId(topPeer.peer);\n              appStateManager.requestPeer(peerId, 'topPeer');\n              return peerId;\n            });\n          }\n        }\n  \n        appStateManager.pushToState('topPeers', peerIds);\n  \n        return peerIds;\n      });\n    });\n  }\n\n  public getBlocked(offset = 0, limit = 0) {\n    return apiManager.invokeApiSingle('contacts.getBlocked', {offset, limit}).then(contactsBlocked => {\n      this.saveApiUsers(contactsBlocked.users);\n      appChatsManager.saveApiChats(contactsBlocked.chats);\n      const count = contactsBlocked._ === 'contacts.blocked' ? contactsBlocked.users.length + contactsBlocked.chats.length : contactsBlocked.count;\n\n      const peerIds = contactsBlocked.users.map(u => u.id).concat(contactsBlocked.chats.map(c => -c.id));\n\n      return {count, peerIds};\n    });\n  }\n\n  /* public searchContacts(query: string, limit = 20) {\n    return Promise.all([\n      this.getContacts(query),\n      apiManager.invokeApi('contacts.search', {\n        q: query,\n        limit\n      })\n    ]).then(results => {\n      const [myContacts, peers] = results;\n\n      this.saveApiUsers(peers.users);\n      appChatsManager.saveApiChats(peers.chats);\n\n      // * contacts.search returns duplicates in my_results\n      const myResults = new Set(myContacts.concat(peers.my_results.map(p => appPeersManager.getPeerID(p))));\n\n      const out = {\n        my_results: [...myResults].slice(0, limit),\n        results: peers.results.map(p => appPeersManager.getPeerID(p))\n      };\n\n      return out;\n    });\n  } */\n  public searchContacts(query: string, limit = 20) {\n    return apiManager.invokeApiCacheable('contacts.search', {\n      q: query,\n      limit\n    }, {cacheSeconds: 60}).then(peers => {\n      this.saveApiUsers(peers.users);\n      appChatsManager.saveApiChats(peers.chats);\n\n      const out = {\n        my_results: filterUnique(peers.my_results.map(p => appPeersManager.getPeerId(p))), // ! contacts.search returns duplicates in my_results\n        results: peers.results.map(p => appPeersManager.getPeerId(p))\n      };\n\n      return out;\n    });\n  }\n\n  private onContactUpdated(userId: number, isContact: boolean) {\n    const curIsContact = this.isContact(userId);\n    if(isContact !== curIsContact) {\n      if(isContact) {\n        this.pushContact(userId);\n      } else {\n        this.contactsList.delete(userId);\n      }\n\n      this.onContactsModified();\n\n      rootScope.dispatchEvent('contacts_update', userId);\n    }\n  }\n\n  public updateUsername(username: string) {\n    return apiManager.invokeApi('account.updateUsername', {\n      username\n    }).then((user) => {\n      this.saveApiUser(user);\n    });\n  }\n\n  public setUserStatus(userId: number, offline: boolean) {\n    if(this.isBot(userId)) {\n      return;\n    }\n\n    const user = this.users[userId];\n    if(user) {\n      const status: any = offline ? {\n        _: 'userStatusOffline',\n        was_online: tsNow(true)\n      } : {\n        _: 'userStatusOnline',\n        expires: tsNow(true) + 500\n      };\n\n      user.status = status;\n      //user.sortStatus = this.getUserStatusForSort(user.status);\n      rootScope.dispatchEvent('user_update', userId);\n    }\n  }\n\n  public addContact(userId: number, first_name: string, last_name: string, phone: string, showPhone?: true) {\n    return apiManager.invokeApi('contacts.addContact', {\n      id: this.getUserInput(userId),\n      first_name,\n      last_name,\n      phone,\n      add_phone_privacy_exception: showPhone\n    }).then((updates) => {\n      apiUpdatesManager.processUpdateMessage(updates, {override: true});\n\n      this.onContactUpdated(userId, true);\n    });\n  }\n\n  public deleteContacts(userIds: number[]) {\n    return apiManager.invokeApi('contacts.deleteContacts', {\n      id: userIds.map(userId => this.getUserInput(userId))\n    }).then((updates) => {\n      apiUpdatesManager.processUpdateMessage(updates, {override: true});\n\n      userIds.forEach(userId => {\n        this.onContactUpdated(userId, false);\n      });\n    });\n  }\n}\n\nconst appUsersManager = new AppUsersManager();\nMOUNT_CLASS_TO.appUsersManager = appUsersManager;\nexport default appUsersManager\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n * \n * Originally from:\n * https://github.com/zhukov/webogram\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\n * https://github.com/zhukov/webogram/blob/master/LICENSE\n */\n\nimport Config from './config';\n\nimport emojiRegExp from '../vendor/emoji/regex';\nimport { encodeEmoji, toCodePoints } from '../vendor/emoji';\nimport { MessageEntity } from '../layer';\nimport { encodeEntities } from '../helpers/string';\nimport { isSafari } from '../helpers/userAgent';\nimport { MOUNT_CLASS_TO } from '../config/debug';\nimport IS_EMOJI_SUPPORTED from '../helpers/emojiSupport';\n\nconst EmojiHelper = {\n  emojiMap: (code: string) => { return code; },\n  shortcuts: [] as any,\n  emojis: [] as any\n};\n\nconst emojiData = Config.Emoji;\n\nconst alphaCharsRegExp = 'a-z' +\n  '\\\\u00c0-\\\\u00d6\\\\u00d8-\\\\u00f6\\\\u00f8-\\\\u00ff' + // Latin-1\n  '\\\\u0100-\\\\u024f' + // Latin Extended A and B\n  '\\\\u0253\\\\u0254\\\\u0256\\\\u0257\\\\u0259\\\\u025b\\\\u0263\\\\u0268\\\\u026f\\\\u0272\\\\u0289\\\\u028b' + // IPA Extensions\n  '\\\\u02bb' + // Hawaiian\n  '\\\\u0300-\\\\u036f' + // Combining diacritics\n  '\\\\u1e00-\\\\u1eff' + // Latin Extended Additional (mostly for Vietnamese)\n  '\\\\u0400-\\\\u04ff\\\\u0500-\\\\u0527' + // Cyrillic\n  '\\\\u2de0-\\\\u2dff\\\\ua640-\\\\ua69f' + // Cyrillic Extended A/B\n  '\\\\u0591-\\\\u05bf\\\\u05c1-\\\\u05c2\\\\u05c4-\\\\u05c5\\\\u05c7' +\n  '\\\\u05d0-\\\\u05ea\\\\u05f0-\\\\u05f4' + // Hebrew\n  '\\\\ufb1d-\\\\ufb28\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40-\\\\ufb41' +\n  '\\\\ufb43-\\\\ufb44\\\\ufb46-\\\\ufb4f' + // Hebrew Pres. Forms\n  '\\\\u0610-\\\\u061a\\\\u0620-\\\\u065f\\\\u066e-\\\\u06d3\\\\u06d5-\\\\u06dc' +\n  '\\\\u06de-\\\\u06e8\\\\u06ea-\\\\u06ef\\\\u06fa-\\\\u06fc\\\\u06ff' + // Arabic\n  '\\\\u0750-\\\\u077f\\\\u08a0\\\\u08a2-\\\\u08ac\\\\u08e4-\\\\u08fe' + // Arabic Supplement and Extended A\n  '\\\\ufb50-\\\\ufbb1\\\\ufbd3-\\\\ufd3d\\\\ufd50-\\\\ufd8f\\\\ufd92-\\\\ufdc7\\\\ufdf0-\\\\ufdfb' + // Pres. Forms A\n  '\\\\ufe70-\\\\ufe74\\\\ufe76-\\\\ufefc' + // Pres. Forms B\n  '\\\\u200c' + // Zero-Width Non-Joiner\n  '\\\\u0e01-\\\\u0e3a\\\\u0e40-\\\\u0e4e' + // Thai\n  '\\\\u1100-\\\\u11ff\\\\u3130-\\\\u3185\\\\uA960-\\\\uA97F\\\\uAC00-\\\\uD7AF\\\\uD7B0-\\\\uD7FF' + // Hangul (Korean)\n  '\\\\u3003\\\\u3005\\\\u303b' + // Kanji/Han iteration marks\n  '\\\\uff21-\\\\uff3a\\\\uff41-\\\\uff5a' + // full width Alphabet\n  '\\\\uff66-\\\\uff9f' + // half width Katakana\n  '\\\\uffa1-\\\\uffdc'; // half width Hangul (Korean)\nconst alphaNumericRegExp = '0-9\\_' + alphaCharsRegExp;\nconst domainAddChars = '\\u00b7';\n// Based on Regular Expression for URL validation by Diego Perini\nconst urlAlphanumericRegExpPart = '[' + alphaCharsRegExp + '0-9]';\nconst urlProtocolRegExpPart = '((?:https?|ftp)://|mailto:)?';\nconst urlRegExp = urlProtocolRegExpPart +\n  // user:pass authentication\n  '(?:' + urlAlphanumericRegExpPart + '{1,64}(?::' + urlAlphanumericRegExpPart + '{0,64})?@)?' +\n  '(?:' +\n  // sindresorhus/ip-regexp\n  '(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])(?:\\\\.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])){3}' +\n  '|' +\n  // host name\n  urlAlphanumericRegExpPart + '[' + alphaCharsRegExp + domainAddChars + '0-9\\-]{0,64}' +\n  // domain name\n  '(?:\\\\.' + urlAlphanumericRegExpPart + '[' + alphaCharsRegExp + domainAddChars + '0-9\\-]{0,64}){0,10}' +\n  // TLD identifier\n  '(?:\\\\.(xn--[0-9a-z]{2,16}|[' + alphaCharsRegExp + ']{2,24}))' +\n  ')' +\n  // port number\n  '(?::\\\\d{2,5})?' +\n  // resource path\n  '(?:/(?:\\\\S{0,255}[^\\\\s.;,(\\\\[\\\\]{}<>\"\\'])?)?';\nconst urlProtocolRegExp = new RegExp('^' + urlProtocolRegExpPart.slice(0, -1), 'i');\nconst urlAnyProtocolRegExp = /^((?:.+?):\\/\\/|mailto:)/;\nconst usernameRegExp = '[a-zA-Z\\\\d_]{5,32}';\nconst botCommandRegExp = '\\\\/([a-zA-Z\\\\d_]{1,32})(?:@(' + usernameRegExp + '))?(\\\\b|$)';\nconst fullRegExp = new RegExp('(^| )(@)(' + usernameRegExp + ')|(' + urlRegExp + ')|(\\\\n)|(' + emojiRegExp + ')|(^|[\\\\s\\\\(\\\\]])(#[' + alphaNumericRegExp + ']{2,64})|(^|\\\\s)' + botCommandRegExp, 'i');\nconst emailRegExp = /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n//const markdownTestRegExp = /[`_*@~]/;\nconst markdownRegExp = /(^|\\s|\\n)(````?)([\\s\\S]+?)(````?)([\\s\\n\\.,:?!;]|$)|(^|\\s|\\x01)(`|~~|\\*\\*|__|_-_)([^\\n]+?)\\7([\\x01\\s\\.,:?!;]|$)|@(\\d+)\\s*\\((.+?)\\)|(\\[(.+?)\\]\\((.+?)\\))/m;\nconst siteHashtags: {[siteName: string]: string} = {\n  Telegram: 'tg://search_hashtag?hashtag={1}',\n  Twitter: 'https://twitter.com/hashtag/{1}',\n  Instagram: 'https://instagram.com/explore/tags/{1}/',\n  'Google Plus': 'https://plus.google.com/explore/{1}'\n};\n\nconst siteMentions: {[siteName: string]: string} = {\n  Telegram: '#/im?p=%40{1}',\n  Twitter: 'https://twitter.com/{1}',\n  Instagram: 'https://instagram.com/{1}/',\n  GitHub: 'https://github.com/{1}'\n};\nconst markdownEntities: {[markdown: string]: MessageEntity['_']} = {\n  '`': 'messageEntityCode',\n  '``': 'messageEntityPre',\n  '**': 'messageEntityBold',\n  '__': 'messageEntityItalic',\n  '~~': 'messageEntityStrike',\n  '_-_': 'messageEntityUnderline'\n};\n\nconst passConflictingEntities: Set<MessageEntity['_']> = new Set([\n  'messageEntityEmoji',\n  'messageEntityLinebreak',\n  'messageEntityCaret'\n]);\nfor(let i in markdownEntities) {\n  passConflictingEntities.add(markdownEntities[i]);\n}\n\nnamespace RichTextProcessor {\n  export const emojiSupported = IS_EMOJI_SUPPORTED;\n\n  export function getEmojiSpritesheetCoords(emojiCode: string) {\n    let unified = encodeEmoji(emojiCode).replace(/-?fe0f/g, '');\n  \n    /* if(unified === '1f441-200d-1f5e8') {\n      //unified = '1f441-fe0f-200d-1f5e8-fe0f';\n      unified = '1f441-fe0f-200d-1f5e8';\n    } */\n  \n    if(!emojiData.hasOwnProperty(unified) \n      // && !emojiData.hasOwnProperty(unified.replace(/-?fe0f$/, ''))\n    ) {\n      //console.error('lol', unified);\n      return null;\n    }\n  \n    return unified;\n  }\n\n  export function parseEntities(text: string) {\n    let match: any;\n    let raw = text;\n    const entities: MessageEntity[] = [];\n    let matchIndex;\n    let rawOffset = 0;\n    // var start = tsNow()\n    fullRegExp.lastIndex = 0;\n    while((match = raw.match(fullRegExp))) {\n      matchIndex = rawOffset + match.index;\n  \n      //console.log('parseEntities match:', match);\n  \n      if(match[3]) { // mentions\n        entities.push({\n          _: 'messageEntityMention',\n          offset: matchIndex + match[1].length,\n          length: match[2].length + match[3].length\n        });\n      } else if(match[4]) {\n        if(emailRegExp.test(match[4])) { // email\n          entities.push({\n            _: 'messageEntityEmail',\n            offset: matchIndex,\n            length: match[4].length\n          });\n        } else {\n          let url: string;\n          let protocol = match[5];\n          const tld = match[6];\n          // let excluded = '';\n          if(tld) { // URL\n            if(!protocol && (tld.substr(0, 4) === 'xn--' || Config.TLD.indexOf(tld.toLowerCase()) !== -1)) {\n              protocol = 'http://';\n            }\n  \n            if(protocol) {\n              const balanced = checkBrackets(match[4]);\n              if(balanced.length !== match[4].length) {\n                // excluded = match[4].substring(balanced.length);\n                match[4] = balanced;\n              }\n  \n              url = (match[5] ? '' : protocol) + match[4];\n            }\n          } else { // IP address\n            url = (match[5] ? '' : 'http://') + match[4];\n          }\n  \n          if(url) {\n            entities.push({\n              _: 'messageEntityUrl',\n              offset: matchIndex,\n              length: match[4].length\n            });\n          }\n        }\n      } else if(match[7]) { // New line\n        entities.push({\n          _: 'messageEntityLinebreak',\n          offset: matchIndex,\n          length: 1\n        });\n      } else if(match[8]) { // Emoji\n        //console.log('hit', match[8]);\n        const emojiCoords = getEmojiSpritesheetCoords(match[8]);\n        if(emojiCoords) {\n          entities.push({\n            _: 'messageEntityEmoji',\n            offset: matchIndex,\n            length: match[8].length,\n            unicode: emojiCoords\n          });\n        }\n      } else if(match[11]) { // Hashtag\n        entities.push({\n          _: 'messageEntityHashtag',\n          offset: matchIndex + (match[10] ? match[10].length : 0),\n          length: match[11].length\n        });\n      } else if(match[13]) { // Bot command\n        entities.push({\n          _: 'messageEntityBotCommand',\n          offset: matchIndex + (match[11] ? match[11].length : 0) + (match[12] ? match[12].length : 0),\n          length: 1 + match[13].length + (match[14] ? 1 + match[14].length : 0),\n          unsafe: true\n        });\n      }\n  \n      raw = raw.substr(match.index + match[0].length);\n      rawOffset += match.index + match[0].length;\n    }\n  \n    // if (entities.length) {\n    //   console.log('parse entities', text, entities.slice())\n    // }\n    return entities;\n  }\n\n  /* export function parseEmojis(text: string) {\n    return text.replace(/:([a-z0-9\\-\\+\\*_]+?):/gi, function (all, shortcut) {\n      var emojiCode = EmojiHelper.shortcuts[shortcut]\n      if (emojiCode !== undefined) {\n        return EmojiHelper.emojis[emojiCode][0]\n      }\n      return all\n    })\n  } */\n\n  export function parseMarkdown(text: string, currentEntities: MessageEntity[], noTrim?: boolean): string {\n  \u00a0 /* if(!markdownTestRegExp.test(text)) {\n      return noTrim ? text : text.trim();\n    } */\n\n    const entities: MessageEntity[] = [];\n    let pushedEntity = false;\n    const pushEntity = (entity: MessageEntity) => !findConflictingEntity(currentEntities, entity) ? (entities.push(entity), pushedEntity = true) : pushedEntity = false;\n\n    let raw = text;\n    let match;\n    let newText: any = [];\n    let rawOffset = 0;\n    while(match = raw.match(markdownRegExp)) {\n      const matchIndex = rawOffset + match.index;\n      newText.push(raw.substr(0, match.index));\n      let text = (match[3] || match[8] || match[11] || match[13]);\n      rawOffset -= text.length;\n      //text = text.replace(/^\\s+|\\s+$/g, '');\n      rawOffset += text.length;\n\n      let entity: MessageEntity;\n      pushedEntity = false;\n      if(text.match(/^`*$/)) {\n        newText.push(match[0]);\n      } else if(match[3]) { // pre\n        entity = {\n          _: 'messageEntityPre',\n          language: '',\n          offset: matchIndex + match[1].length,\n          length: text.length\n        };\n\n        if(pushEntity(entity)) {\n          if(match[5] === '\\n') {\n            match[5] = '';\n            rawOffset -= 1;\n          }\n  \n          newText.push(match[1] + text + match[5]);\n          \n          rawOffset -= match[2].length + match[4].length;\n        }\n      } else if(match[7]) { // code|italic|bold\n        const isSOH = match[6] === '\\x01';\n\n        entity = {\n          _: markdownEntities[match[7]] as (MessageEntity.messageEntityBold | MessageEntity.messageEntityCode | MessageEntity.messageEntityItalic)['_'],\n          //offset: matchIndex + match[6].length,\n          offset: matchIndex + (isSOH ? 0 : match[6].length),\n          length: text.length\n        };\n\n        if(pushEntity(entity)) {\n          if(!isSOH) {\n            newText.push(match[6] + text + match[9]);\n          } else {\n            newText.push(text);\n          }\n  \n          rawOffset -= match[7].length * 2 + (isSOH ? 2 : 0);\n        }\n      } else if(match[11]) { // custom mention\n        entity = {\n          _: 'messageEntityMentionName',\n          user_id: +match[10],\n          offset: matchIndex,\n          length: text.length\n        };\n        \n        if(pushEntity(entity)) {\n          newText.push(text);\n          \n          rawOffset -= match[0].length - text.length;\n        }\n      } else if(match[12]) { // text url\n        entity = {\n          _: 'messageEntityTextUrl',\n          url: match[14],\n          offset: matchIndex,\n          length: text.length\n        };\n        \n        if(pushEntity(entity)) {\n          newText.push(text);\n\n          rawOffset -= match[12].length - text.length;\n        }\n      }\n\n      if(!pushedEntity) {\n        newText.push(match[0]);\n      }\n\n      raw = raw.substr(match.index + match[0].length);\n      rawOffset += match.index + match[0].length;\n    }\n\n    newText.push(raw);\n    newText = newText.join('');\n    if(!newText.replace(/\\s+/g, '').length) {\n      newText = text;\n      entities.splice(0, entities.length);\n    }\n\n    if(!entities.length && !noTrim) {\n      newText = newText.trim();\n    }\n\n    mergeEntities(currentEntities, entities);\n    combineSameEntities(currentEntities);\n\n    return newText;\n  }\n\n  export function findConflictingEntity(currentEntities: MessageEntity[], newEntity: MessageEntity) {\n    return currentEntities.find(currentEntity => {\n      const isConflictingTypes = newEntity._ === currentEntity._ || \n        (!passConflictingEntities.has(newEntity._) && !passConflictingEntities.has(currentEntity._));\n\n      if(!isConflictingTypes) {\n        return false;\n      }\n\n      const isConflictingOffset = newEntity.offset >= currentEntity.offset && \n        (newEntity.length + newEntity.offset) <= (currentEntity.length + currentEntity.offset);\n\n      return isConflictingOffset;\n    });\n  }\n\n  export function mergeEntities(currentEntities: MessageEntity[], newEntities: MessageEntity[]) {\n    const filtered = newEntities.filter(e => {\n      return !findConflictingEntity(currentEntities, e);\n    });\n\n    currentEntities.push(...filtered);\n    currentEntities.sort((a, b) => a.offset - b.offset);\n    return currentEntities;\n  }\n\n  export function combineSameEntities(entities: MessageEntity[]) {\n    //entities = entities.slice();\n    for(let i = 0; i < entities.length; ++i) {\n      const entity = entities[i];\n\n      let nextEntityIdx = -1;\n      do {\n        nextEntityIdx = entities.findIndex((e, _i) => _i !== i && e._ === entity._ && (e.offset - entity.length) === entity.offset);\n        if(nextEntityIdx !== -1) {\n          const nextEntity = entities[nextEntityIdx];\n          entity.length += nextEntity.length;\n          entities.splice(nextEntityIdx, 1);\n        }\n      } while(nextEntityIdx !== -1);\n    }\n    //return entities;\n  }\n\n  export function wrapRichText(text: string, options: Partial<{\n    entities: MessageEntity[],\n    contextSite: string,\n    highlightUsername: string,\n    noLinks: true,\n    noLinebreaks: true,\n    noCommands: true,\n    wrappingDraft: true,\n    //mustWrapEmoji: boolean,\n    fromBot: boolean,\n    noTextFormat: true,\n    passEntities: Partial<{\n      [_ in MessageEntity['_']]: boolean\n    }>,\n\n    contextHashtag?: string,\n  }> = {}) {\n    if(!text) {\n      return '';\n    }\n\n    const lol: {\n      part: string,\n      offset: number\n    }[] = [];\n    const entities = options.entities || parseEntities(text);\n\n    const passEntities: typeof options.passEntities = options.passEntities || {};\n    const contextSite = options.contextSite || 'Telegram';\n    const contextExternal = contextSite !== 'Telegram';\n\n    const insertPart = (entity: MessageEntity, startPart: string, endPart?: string) => {\n      lol.push({part: startPart, offset: entity.offset});\n\n      if(endPart) {\n        lol.unshift({part: endPart, offset: entity.offset + entity.length});\n      }\n    };\n\n    for(let i = 0, length = entities.length; i < length; ++i) {\n      const entity = entities[i];\n      switch(entity._) {\n        case 'messageEntityBold': {\n          if(!options.noTextFormat) {\n            if(options.wrappingDraft) {\n              insertPart(entity, '<span style=\"font-weight: bold;\">', '</span>');\n            } else {\n              insertPart(entity, '<strong>', '</strong>');\n            }\n          }\n\n          break;\n        }\n\n        case 'messageEntityItalic': {\n          if(!options.noTextFormat) {\n            if(options.wrappingDraft) {\n              insertPart(entity, '<span style=\"font-style: italic;\">', '</span>');\n            } else {\n              insertPart(entity, '<em>', '</em>');\n            }\n          }\n\n          break;\n        }\n\n        case 'messageEntityStrike': {\n          if(options.wrappingDraft) {\n            const styleName = isSafari ? 'text-decoration' : 'text-decoration-line';\n            insertPart(entity, `<span style=\"${styleName}: line-through;\">`, '</span>');\n          } else {\n            insertPart(entity, '<del>', '</del>');\n          }\n\n          break;\n        }\n\n        case 'messageEntityUnderline': {\n          if(options.wrappingDraft) {\n            const styleName = isSafari ? 'text-decoration' : 'text-decoration-line';\n            insertPart(entity, `<span style=\"${styleName}: underline;\">`, '</span>');\n          } else {\n            insertPart(entity, '<u>', '</u>');\n          }\n\n          break;\n        }\n          \n        case 'messageEntityCode': {\n          if(options.wrappingDraft) {\n            insertPart(entity, '<span style=\"font-family: monospace;\">', '</span>');\n          } else {\n            insertPart(entity, '<code>', '</code>');\n          }\n          \n          break;\n        }\n          \n        case 'messageEntityPre': {\n          if(!options.noTextFormat) {\n            insertPart(entity, `<pre><code${entity.language ? ' class=\"language-' + encodeEntities(entity.language) + '\"' : ''}>`, '</code></pre>');\n          }\n          \n          break;\n        }\n\n        case 'messageEntityHighlight': {\n          insertPart(entity, '<i class=\"text-highlight\">', '</i>');\n          break;\n        }\n\n        case 'messageEntityBotCommand': {\n          // if(!(options.noLinks || options.noCommands || contextExternal)/*  && !entity.unsafe */) {\n          if(!options.noLinks && passEntities[entity._]) {\n            const entityText = text.substr(entity.offset, entity.length);\n            let command = entityText.substr(1);\n            let bot: string | boolean;\n            let atPos: number;\n            if((atPos = command.indexOf('@')) !== -1) {\n              bot = command.substr(atPos + 1);\n              command = command.substr(0, atPos);\n            } else {\n              bot = options.fromBot;\n            }\n\n            insertPart(entity, `<a href=\"${encodeEntities('tg://bot_command?command=' + encodeURIComponent(command) + (bot ? '&bot=' + encodeURIComponent(bot) : ''))}\" ${contextExternal ? '' : 'onclick=\"execBotCommand(this)\"'}>`, `</a>`);\n          }\n\n          break;\n        }\n\n        case 'messageEntityEmoji': {\n          //if(!(options.wrappingDraft && emojiSupported)) { // * fix safari emoji\n          if(!emojiSupported) { // no wrapping needed\n            // if(emojiSupported) { // ! contenteditable=\"false\" \u043d\u0443\u0436\u0435\u043d \u0434\u043b\u044f \u043f\u043e\u043b\u044f \u0432\u0432\u043e\u0434\u0430, \u0438\u043d\u0430\u0447\u0435 \u0442\u0430\u043c \u0431\u0443\u0434\u0435\u0442 \u043c\u0435\u043d\u044f\u0442\u044c\u0441\u044f \u0448\u0440\u0438\u0444\u0442 \u0432 Safari, \u0438\u043b\u0438 \u0436\u0435 \u0440\u0435\u043d\u0434\u0435\u0440\u0438\u0442\u044c \u0441\u043c\u0430\u0439\u043b\u0438\u043a \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e, \u0431\u0435\u0437 \u043a\u043e\u043d\u0442\u0435\u0439\u043d\u0435\u0440\u0430\n            //   insertPart(entity, '<span class=\"emoji\">', '</span>');\n            // } else {\n              insertPart(entity, `<img src=\"assets/img/emoji/${entity.unicode}.png\" alt=\"`, `\" class=\"emoji\">`);\n            // }\n          }/*  else if(options.mustWrapEmoji) {\n            insertPart(entity, '<span class=\"emoji\">', '</span>');\n          } */\n          /* if(!emojiSupported) {\n            insertPart(entity, `<img src=\"assets/img/emoji/${entity.unicode}.png\" alt=\"`, `\" class=\"emoji\">`);\n          } */\n\n          break;\n        }\n        \n        case 'messageEntityCaret': {\n          insertPart(entity, '<span class=\"composer-sel\"></span>');\n          break;\n        }\n\n        /* case 'messageEntityLinebreak': {\n          if(options.noLinebreaks) {\n            insertPart(entity, ' ');\n          } else {\n            insertPart(entity, '<br/>');\n          }\n          \n          break;\n        } */\n\n        case 'messageEntityUrl':\n        case 'messageEntityTextUrl': {\n          if(!(options.noLinks && !passEntities[entity._])) {\n            const entityText = text.substr(entity.offset, entity.length);\n\n            // let inner: string;\n            let url: string = (entity as MessageEntity.messageEntityTextUrl).url || entityText;\n            let masked = false;\n            let onclick: string;\n\n            const wrapped = wrapUrl(url, true);\n            url = wrapped.url;\n            onclick = wrapped.onclick;\n\n            if(entity._ === 'messageEntityTextUrl') {\n              const nextEntity = entities[i + 1];\n              if(nextEntity?._ === 'messageEntityUrl' && \n                nextEntity.length === entity.length && \n                nextEntity.offset === entity.offset) {\n                i++;\n              }\n\n              if(url !== entityText) {\n                masked = true;\n              }\n            } else {\n              //inner = encodeEntities(replaceUrlEncodings(entityText));\n            }\n\n            const currentContext = url[0] === '#';\n            if(!onclick && masked && !currentContext) {\n              onclick = 'showMaskedAlert';\n            }\n\n            const href = (currentContext || typeof electronHelpers === 'undefined') \n              ? encodeEntities(url)\n              : `javascript:electronHelpers.openExternal('${encodeEntities(url)}');`;\n\n            const target = (currentContext || typeof electronHelpers !== 'undefined')\n              ? '' : ' target=\"_blank\" rel=\"noopener noreferrer\"';\n\n            insertPart(entity, `<a class=\"anchor-url\" href=\"${href}\"${target}${onclick ? `onclick=\"${onclick}(this)\"` : ''}>`, '</a>');\n          }\n\n          break;\n        }\n\n        case 'messageEntityEmail': {\n          if(!options.noLinks) {\n            const entityText = text.substr(entity.offset, entity.length);\n            insertPart(entity, `<a href=\"${encodeEntities('mailto:' + entityText)}\" target=\"_blank\" rel=\"noopener noreferrer\">`, '</a>');\n          }\n\n          break;\n        }\n          \n        case 'messageEntityHashtag': {\n          const contextUrl = !options.noLinks && siteHashtags[contextSite];\n          if(contextUrl) {\n            const entityText = text.substr(entity.offset, entity.length);\n            const hashtag = entityText.substr(1);\n            insertPart(entity, `<a class=\"anchor-hashtag\" href=\"${contextUrl.replace('{1}', encodeURIComponent(hashtag))}\"${contextExternal ? ' target=\"_blank\" rel=\"noopener noreferrer\"' : ' onclick=\"searchByHashtag(this)\"'}>`, '</a>');\n          }\n\n          break;\n        }\n\n        case 'messageEntityMentionName': {\n          if(!(options.noLinks && !passEntities[entity._])) {\n            insertPart(entity, `<a href=\"#/im?p=${encodeURIComponent(entity.user_id)}\" class=\"follow\" data-follow=\"${entity.user_id}\">`, '</a>');\n          }\n\n          break;\n        }\n\n        case 'messageEntityMention': {\n          const contextUrl = !options.noLinks && siteMentions[contextSite];\n          if(contextUrl) {\n            const entityText = text.substr(entity.offset, entity.length);\n            const username = entityText.substr(1);\n\n            insertPart(entity, `<a class=\"mention\" href=\"${contextUrl.replace('{1}', encodeURIComponent(username))}\"${contextExternal ? ' target=\"_blank\" rel=\"noopener noreferrer\"' : ''}>`, '</a>');\n          }\n          \n          break;\n        }\n      }\n    }\n\n    lol.sort((a, b) => a.offset - b.offset);\n\n    const arr: string[] = [];\n    let usedLength = 0;\n    for(const {part, offset} of lol) {\n      if(offset > usedLength) {\n        arr.push(encodeEntities(text.slice(usedLength, offset)));\n        usedLength = offset;\n      }\n\n      arr.push(part);\n    }\n\n    if(usedLength < text.length) {\n      arr.push(encodeEntities(text.slice(usedLength)));\n    }\n\n    return arr.join('');\n  }\n\n  export function fixEmoji(text: string, entities?: MessageEntity[]) {\n    /* if(!emojiSupported) {\n      return text;\n    } */\n    // '$`\\ufe0f'\n\n    text = text.replace(/[\\u2640\\u2642\\u2764](?!\\ufe0f)/g, (match, offset, string) => {\n      if(entities) {\n        const length = match.length;\n\n        offset += length;\n        entities.forEach(entity => {\n          const end = entity.offset + entity.length;\n          if(end === offset) { // current entity\n            entity.length += length;\n          } else if(end > offset) {\n            entity.offset += length;\n          }\n        });\n      }\n      \n      // console.log([match, offset, string]);\n      return match + '\\ufe0f';\n    });\n\n    return text;\n  }\n\n  export function wrapDraftText(text: string, options: Partial<{\n    entities: MessageEntity[]\n  }> = {}) {\n    if(!text) {\n      return '';\n    }\n\n    return wrapRichText(text, {\n      entities: options.entities, \n      noLinks: true,\n      wrappingDraft: true,\n      passEntities: {\n        messageEntityTextUrl: true,\n        messageEntityMentionName: true\n      }\n    });\n  }\n\n  export function checkBrackets(url: string) {\n    var urlLength = url.length;\n    var urlOpenBrackets = url.split('(').length - 1;\n    var urlCloseBrackets = url.split(')').length - 1;\n    while(urlCloseBrackets > urlOpenBrackets &&\n      url.charAt(urlLength - 1) === ')') {\n      url = url.substr(0, urlLength - 1)\n      urlCloseBrackets--;\n      urlLength--;\n    }\n    if(urlOpenBrackets > urlCloseBrackets) {\n      url = url.replace(/\\)+$/, '');\n    }\n    return url;\n  }\n  \n  export function replaceUrlEncodings(urlWithEncoded: string) {\n    return urlWithEncoded.replace(/(%[A-Z\\d]{2})+/g, (str) => {\n      try {\n        return decodeURIComponent(str);\n      } catch (e) {\n        return str;\n      }\n    });\n  }\n  \n  export function wrapPlainText(text: string) {\n    if(emojiSupported) {\n      return text;\n    }\n  \n    if(!text || !text.length) {\n      return '';\n    }\n  \n    text = text.replace(/\\ufe0f/g, '');\n    var match;\n    var raw = text;\n    const arr: string[] = [];\n    let emojiTitle;\n    fullRegExp.lastIndex = 0;\n    while((match = raw.match(fullRegExp))) {\n      arr.push(raw.substr(0, match.index))\n      if(match[8]) {\n        // @ts-ignore\n        const emojiCode = EmojiHelper.emojiMap[match[8]];\n        if(emojiCode &&\n        // @ts-ignore\n          (emojiTitle = emojiData[emojiCode][1][0])) {\n          arr.push(':' + emojiTitle + ':');\n        } else {\n          arr.push(match[0]);\n        }\n      } else {\n        arr.push(match[0]);\n      }\n  \n      raw = raw.substr(match.index + match[0].length);\n    }\n    arr.push(raw);\n    return arr.join('');\n  }\n\n  export function wrapEmojiText(text: string) {\n    if(!text) return '';\n  \n    let entities = parseEntities(text).filter(e => e._ === 'messageEntityEmoji');\n    return wrapRichText(text, {entities});\n  }\n\n  export function wrapUrl(url: string, unsafe?: number | boolean): {url: string, onclick: string} {\n    if(!matchUrlProtocol(url)) {\n      url = 'https://' + url;\n    }\n  \n    let tgMeMatch;\n    let telescoPeMatch;\n    let onclick: string;\n    /* if(unsafe === 2) {\n      url = 'tg://unsafe_url?url=' + encodeURIComponent(url);\n    } else  */if((tgMeMatch = url.match(/^(?:https?:\\/\\/)?t(?:elegram)?\\.me\\/(.+)/))) {\n      const fullPath = tgMeMatch[1];\n      const path = fullPath.split('/');\n      switch(path[0]) {\n        case 'joinchat':\n        case 'addstickers':\n          onclick = path[0];\n          break;\n  \n        /* case 'joinchat':\n          onclick = 'joinchat';\n          url = 'tg://join?invite=' + path[1];\n          break;\n  \n        case 'addstickers':\n          onclick = 'addstickers';\n          url = 'tg://addstickers?set=' + path[1];\n          break; */\n  \n        default:\n          if(path[1] && path[1].match(/^\\d+$/)) {               // https://t.me/.+/[0-9]+ (channel w/ username)\n            if(path[0] === 'c' && path[2]) {                    // https://t.me/c/111111111/111 (channel w/o username)\n              url = '#/im?p=' + path[1] + '&post=' + path[2];\n            } else {                                            // https://t.me/durov/151 (channel w/ username)\n              url = siteMentions['Telegram'].replace('{1}', path[0] + '&post=' + path[1]);\n            }\n          } else if(path.length === 1) {\n            const domainQuery = path[0].split('?');\n            const domain = domainQuery[0];\n            const query = domainQuery[1];\n\n            if(domain === 'iv') {\n              const match = (query || '').match(/url=([^&=]+)/);\n              if(match) {\n                url = match[1];\n                try {\n                  url = decodeURIComponent(url);\n                } catch (e) {}\n  \n                return wrapUrl(url, unsafe);\n              }\n            }\n  \n            url = siteMentions['Telegram'].replace('{1}', domain + (query ? '&' + query : ''));\n            //url = 'tg://resolve?domain=' + domain + (query ? '&' + query : '');\n          }\n\n          break;\n      }\n    } else if((telescoPeMatch = url.match(/^(?:https?:\\/\\/)?telesco\\.pe\\/([^/?]+)\\/(\\d+)/))) {\n      url = 'tg://resolve?domain=' + telescoPeMatch[1] + '&post=' + telescoPeMatch[2];\n    }/*  else if(unsafe) {\n      url = 'tg://unsafe_url?url=' + encodeURIComponent(url);\n    } */\n  \n    return {url, onclick};\n  }\n\n  export function matchUrlProtocol(text: string) {\n    return !text ? null : text.match(urlAnyProtocolRegExp);\n  }\n  \n  export function matchUrl(text: string) {\n    return !text ? null : text.match(urlRegExp);\n  }\n\n  export function matchEmail(text: string) {\n    return !text ? null : text.match(emailRegExp);\n  }\n\n  export function getAbbreviation(str: string, onlyFirst = false) {\n    const splitted = str.trim().split(' ');\n    if(!splitted[0]) return '';\n\n    const first = [...splitted[0]][0];\n\n    if(onlyFirst || splitted.length === 1) return wrapEmojiText(first);\n\n    const last = [...splitted[splitted.length - 1]][0];\n\n    return wrapEmojiText(first + last);\n  }\n\n  export function isUsernameValid(username: string) {\n    return ((username.length >= 5 && username.length <= 32) || !username.length) && /^[a-zA-Z0-9_]*$/.test(username);\n  }\n\n  export function getEmojiEntityFromEmoji(emoji: string): MessageEntity.messageEntityEmoji {\n    return {\n      _: 'messageEntityEmoji',\n      offset: 0,\n      length: emoji.length,\n      unicode: toCodePoints(emoji).join('-').replace(/-?fe0f/g, '')\n    };\n  }\n\n  export function wrapSingleEmoji(emoji: string) {\n    return wrapRichText(emoji, {\n      entities: [getEmojiEntityFromEmoji(emoji)]\n    });\n  }\n}\n\nMOUNT_CLASS_TO.RichTextProcessor = RichTextProcessor;\n\nexport {RichTextProcessor};\nexport default RichTextProcessor;\n\n", "[{\n  \"predicate\": \"document\",\n  \"params\": [\n    {\"name\": \"thumbs\", \"type\": \"Array<PhotoSize.photoSize | PhotoSize.photoCachedSize | PhotoSize.photoStrippedSize | PhotoSize.photoPathSize>\"},\n    {\"name\": \"type\", \"type\": \"'gif' | 'sticker' | 'audio' | 'voice' | 'video' | 'round' | 'photo' | 'pdf'\"},\n    {\"name\": \"h\", \"type\": \"number\"},\n    {\"name\": \"w\", \"type\": \"number\"},\n    {\"name\": \"file_name\", \"type\": \"string\"},\n    {\"name\": \"fileName\", \"type\": \"string\"},\n    {\"name\": \"file\", \"type\": \"File\"},\n    {\"name\": \"duration\", \"type\": \"number\"},\n    {\"name\": \"audioTitle\", \"type\": \"string\"},\n    {\"name\": \"audioPerformer\", \"type\": \"string\"},\n    {\"name\": \"sticker\", \"type\": \"number\"},\n    {\"name\": \"stickerEmoji\", \"type\": \"string\"},\n    {\"name\": \"stickerEmojiRaw\", \"type\": \"string\"},\n    {\"name\": \"stickerSetInput\", \"type\": \"InputStickerSet.inputStickerSetID\"},\n    {\"name\": \"stickerThumbConverted\", \"type\": \"true\"},\n    {\"name\": \"stickerCachedThumbs\", \"type\": \"{[toneIndex: number]: {url: string, w: number, h: number}}\"},\n    {\"name\": \"animated\", \"type\": \"boolean\"},\n    {\"name\": \"supportsStreaming\", \"type\": \"boolean\"}\n  ]\n}, {\n  \"predicate\": \"photoSizeProgressive\",\n  \"params\": [\n    {\"name\": \"size\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"dialog\",\n  \"params\": [\n    {\"name\": \"index\", \"type\": \"number\"},\n    {\"name\": \"peerId\", \"type\": \"number\"},\n    {\"name\": \"topMessage\", \"type\": \"any\"},\n    {\"name\": \"migratedTo\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"dialogFolder\",\n  \"params\": [\n    {\"name\": \"index\", \"type\": \"number\"},\n    {\"name\": \"peerId\", \"type\": \"number\"},\n    {\"name\": \"folder_id\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"message\",\n  \"params\": [\n    {\"name\": \"mid\", \"type\": \"number\"},\n    {\"name\": \"deleted\", \"type\": \"boolean\"},\n    {\"name\": \"peerId\", \"type\": \"number\"},\n    {\"name\": \"fromId\", \"type\": \"number\"},\n    {\"name\": \"grouped_id\", \"type\": \"string\"},\n    {\"name\": \"random_id\", \"type\": \"string\"},\n    {\"name\": \"unread\", \"type\": \"true\"},\n    {\"name\": \"is_outgoing\", \"type\": \"true\"},\n    {\"name\": \"rReply\", \"type\": \"string\"},\n    {\"name\": \"viaBotId\", \"type\": \"number\"},\n    {\"name\": \"clear_history\", \"type\": \"boolean\"}\n  ]\n}, {\n  \"predicate\": \"messageService\",\n  \"params\": [\n    {\"name\": \"mid\", \"type\": \"number\"},\n    {\"name\": \"deleted\", \"type\": \"boolean\"},\n    {\"name\": \"peerId\", \"type\": \"number\"},\n    {\"name\": \"fromId\", \"type\": \"number\"},\n    {\"name\": \"unread\", \"type\": \"true\"},\n    {\"name\": \"is_outgoing\", \"type\": \"true\"},\n    {\"name\": \"rReply\", \"type\": \"string\"},\n    {\"name\": \"viaBotId\", \"type\": \"number\"},\n    {\"name\": \"is_single\", \"type\": \"true\"}\n  ]\n}, {\n  \"predicate\": \"messageEmpty\",\n  \"params\": [\n    {\"name\": \"deleted\", \"type\": \"boolean\"}\n  ]\n}, {\n  \"predicate\": \"userFull\",\n  \"params\": [\n    {\"name\": \"rAbout\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"messageEntityEmoji\",\n  \"params\": [\n    {\"name\": \"offset\", \"type\": \"number\"},\n    {\"name\": \"length\", \"type\": \"number\"},\n    {\"name\": \"unicode\", \"type\": \"string\"}\n  ],\n  \"type\": \"MessageEntity\"\n}, {\n  \"predicate\": \"messageEntityHighlight\",\n  \"params\": [\n    {\"name\": \"offset\", \"type\": \"number\"},\n    {\"name\": \"length\", \"type\": \"number\"}\n  ],\n  \"type\": \"MessageEntity\"\n}, {\n  \"predicate\": \"messageEntityLinebreak\",\n  \"params\": [\n    {\"name\": \"offset\", \"type\": \"number\"},\n    {\"name\": \"length\", \"type\": \"number\"}\n  ],\n  \"type\": \"MessageEntity\"\n}, {\n  \"predicate\": \"messageEntityCaret\",\n  \"params\": [\n    {\"name\": \"offset\", \"type\": \"number\"},\n    {\"name\": \"length\", \"type\": \"number\"}\n  ],\n  \"type\": \"MessageEntity\"\n}, {\n  \"predicate\": \"messageEntityBotCommand\",\n  \"params\": [\n    {\"name\": \"unsafe\", \"type\": \"boolean\"}\n  ]\n}, {\n  \"predicate\": \"user\",\n  \"params\": [\n    {\"name\": \"initials\", \"type\": \"string\"},\n    {\"name\": \"sortName\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"auth.sentCode\",\n  \"params\": [\n    {\"name\": \"phone_number\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"draftMessage\",\n  \"params\": [\n    {\"name\": \"rReply\", \"type\": \"string\"},\n    {\"name\": \"rMessage\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"chat\",\n  \"params\": [\n    {\"name\": \"initials\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"chatForbidden\",\n  \"params\": [\n    {\"name\": \"initials\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"channel\",\n  \"params\": [\n    {\"name\": \"initials\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"channelForbidden\",\n  \"params\": [\n    {\"name\": \"initials\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"messageActionChatLeave\",\n  \"params\": [\n    {\"name\": \"user_id\", \"type\": \"number\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChannelDeletePhoto\",\n  \"params\": [],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChannelEditTitle\",\n  \"params\": [\n    {\"name\": \"title\", \"type\": \"string\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChannelEditPhoto\",\n  \"params\": [\n    {\"name\": \"photo\", \"type\": \"Photo\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChannelEditVideo\",\n  \"params\": [\n    {\"name\": \"photo\", \"type\": \"Photo\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChatEditVideo\",\n  \"params\": [\n    {\"name\": \"photo\", \"type\": \"Photo\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChatAddUsers\",\n  \"params\": [\n    {\"name\": \"users\", \"type\": \"Array<number>\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChatJoined\",\n  \"params\": [\n    {\"name\": \"users\", \"type\": \"Array<number>\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChatReturn\",\n  \"params\": [\n    {\"name\": \"users\", \"type\": \"Array<number>\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChatJoinedYou\",\n  \"params\": [\n    {\"name\": \"users\", \"type\": \"Array<number>\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"messageActionChatReturnYou\",\n  \"params\": [\n    {\"name\": \"users\", \"type\": \"Array<number>\"}\n  ],\n  \"type\": \"MessageAction\"\n}, {\n  \"predicate\": \"langPackDifference\",\n  \"params\": [\n    {\"name\": \"local\", \"type\": \"boolean\"},\n    {\"name\": \"appVersion\", \"type\": \"string\"}\n  ]\n}, {\n  \"predicate\": \"updateNewDiscussionMessage\",\n  \"params\": [\n    {\"name\": \"message\", \"type\": \"Message\"}\n  ],\n  \"type\": \"Update\"\n}, {\n  \"predicate\": \"updateDeleteDiscussionMessages\",\n  \"params\": [\n    {\"name\": \"messages\", \"type\": \"number[]\"},\n    {\"name\": \"channel_id\", \"type\": \"number\"}\n  ],\n  \"type\": \"Update\"\n}, {\n  \"predicate\": \"updateDraftMessage\",\n  \"params\": [\n    {\"name\": \"local\", \"type\": \"boolean\"},\n    {\"name\": \"threadId\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"updateChannelReload\",\n  \"params\": [\n    {\"name\": \"channel_id\", \"type\": \"number\"}\n  ],\n  \"type\": \"Update\"\n}, {\n  \"predicate\": \"messages.stickerSet\",\n  \"params\": [\n    {\"name\": \"refreshTime\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"replyKeyboardHide\",\n  \"params\": [\n    {\"name\": \"mid\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"replyKeyboardForceReply\",\n  \"params\": [\n    {\"name\": \"mid\", \"type\": \"number\"},\n    {\"name\": \"hidden\", \"type\": \"true\"},\n    {\"name\": \"fromId\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"replyKeyboardMarkup\",\n  \"params\": [\n    {\"name\": \"mid\", \"type\": \"number\"},\n    {\"name\": \"hidden\", \"type\": \"true\"},\n    {\"name\": \"fromId\", \"type\": \"number\"}\n  ]\n}, {\n  \"predicate\": \"inputDocumentFileLocation\",\n  \"params\": [\n    {\"name\": \"checkedReference\", \"type\": \"boolean\"}\n  ]\n}]", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n.chatlist-container {\n  position: relative;\n\n  .search-group-recent.search-group {\n    @include respond-to(handhelds) {\n      padding: 2px 0 0;\n    }\n  }\n\n  .search-group {\n    width: 100%;\n    padding: 1rem 0 .5rem;\n    margin-bottom: 17px;\n\n    @include respond-to(handhelds) {\n      margin-bottom: 0;\n    }\n\n    &__name {\n      color: var(--secondary-text-color);\n      padding: 0 23px;\n      padding-bottom: 1rem;\n      font-weight: 500;\n      user-select: none;\n\n      @include respond-to(handhelds) {\n        padding: 5px 9px 0 16px;\n        font-size: 15px;\n      }\n    }\n\n    &-contacts {\n      border-bottom: 1px solid var(--border-color);\n\n      @include respond-to(handhelds) {\n        padding: 0px 0 2px;\n      }\n\n      // .search-group__name {\n      //   padding-bottom: 17px;\n        \n      //   @include respond-to(handhelds) {\n      //     padding-bottom: 0;\n      //   }\n      // }\n    }\n\n    &-people.search-group-contacts {\n      padding: 5px 0 5px !important;\n    }\n\n    &:last-child {\n      border-bottom: none;\n    }\n  }\n\n  .search-super {\n    .search-group {\n      margin-bottom: 0px;\n      padding: 4px 0 0;\n\n      &__name {\n        padding-top: 1rem;\n        display: flex;\n        justify-content: space-between;\n      }\n    }\n  }\n\n}\n\nul.chatlist {\n  padding: 0 .5rem/*  .5rem */;\n\n  @include respond-to(handhelds) {\n    // padding: 0 0 .5rem;\n    padding: 0;\n  }\n}\n\n.chatlist {\n  //--avatarSize: 54px;\n  //--height: 72px;\n  margin: 0;\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  width: 100%;\n  background-color: var(--surface-color);\n\n  user-select: none;\n  -webkit-user-select: none; /* disable selection/Copy of UIWebView */\n  -webkit-touch-callout: none; /* disable the IOS popup when long-press on a link */\n\n  /* &.chatlist-avatar-48 {\n    --avatarSize: 48px;\n  }\n\n  @include respond-to(handhelds) {\n    &.chatlist-handhelds-66 {\n      --height: 66px;\n    }\n  } */\n\n  li {\n    //height: var(--height);\n    height: 72px;\n    //max-height: var(--height);\n    border-radius: $border-radius-medium;\n    display: flex;\n    align-items: flex-start; // TODO: \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c \u0440\u0430\u0437\u043d\u0438\u0446\u0443 \u0432 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438 \u0441 align-items: center;\n    flex-direction: row;\n    position: relative;\n    cursor: pointer;\n    padding: .5625rem;\n    /* padding-top: calc((var(--height) - var(--avatarSize)) / 2);\n    padding-bottom: calc((var(--height) - var(--avatarSize)) / 2);\n    padding-right: 8.5px;\n    padding-left: 8.5px; */\n    overflow: hidden;\n\n    @include respond-to(handhelds) {\n      border-radius: 0;\n    }\n\n    @include hover-background-effect();\n\n    &.is-muted {\n      .user-title {\n        &:after {\n          flex: 0 0 auto;\n          content: $tgico-nosound;\n          color: var(--chatlist-pinned-color);\n          font-size: 1.125rem;\n          margin-left: .125rem;\n        }\n      }\n\n      body:not(.animation-level-0) & {\n        &.animating {\n          &:not(.backwards) {\n            .user-title:after {\n              animation: fade-in-opacity .2s ease-in-out forwards;\n            }\n          }\n  \n          &.backwards .user-title:after {\n            animation: fade-in-backwards-opacity .2s ease-in-out forwards;\n          }\n        }\n      }\n    }\n\n    p {\n      margin: 0;\n      display: flex;\n      justify-content: space-between;\n      flex-direction: row;\n      align-items: flex-start;\n      height: 27px;\n    }\n\n    a {\n      color: inherit;\n    }\n\n    .text-highlight {\n      color: var(--primary-text-color);\n    }\n\n    /* img.emoji {\n      margin-right: .25rem;\n      margin-left: .25rem;\n\n      &:first-child {\n        margin-left: 0;\n      }\n    } */\n\n    &.menu-open {\n      background: var(--light-secondary-text-color);\n    }\n\n    @include respond-to(not-handhelds) {\n      &.active {\n        //background: var(--light-secondary-text-color);\n        background: var(--primary-color) !important;\n\n        .user-caption,\n        .tgico-chatspinned:before,\n        //.user-title:after,\n        .user-title,\n        .message-status,\n        .text-highlight {\n          color: #fff;\n        }\n\n        b {\n          color: #fff !important;\n        }\n\n        .user-title:after {\n          color: rgba(255, 255, 255, .7);\n        }\n\n        .verified-background {\n          fill: #fff !important;\n        }\n\n        .verified-check {\n          fill: var(--primary-color) !important;\n        }\n\n        .dialog-avatar.is-online:after {\n          background-color: #fff;\n          border-color: var(--primary-color);\n        }\n\n        .badge.unread {\n          background-color: #fff !important;\n          color: var(--primary-color);\n        }\n\n        .peer-typing-container {\n          --color: #fff;\n        }\n      }\n    }\n  }\n\n  /* .user-title,\n  .dialog-title-details,\n  .user-last-message */li span {\n    //display: inline-block;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    //margin: .1rem 0;\n    line-height: 27px;\n  }\n\n  .peer-typing-container {\n    --color: var(--secondary-text-color);\n\n    .peer-typing-text {\n      display: inline-flex;\n      transform: translateY(-2px);\n    }\n  }\n\n  .dialog {\n    &-title {\n      &-details {\n        font-size: .75rem;\n        padding: 1px 0px 0px 0px;\n        flex: 0 0 auto;\n        margin-left: .5rem;\n      }\n    }\n    \n    &-subtitle {\n      margin-top: -3px;\n\n      &-badge {\n        &:not(:empty), &.tgico-pinnedchat {\n          margin-left: .5rem;\n        }\n\n        &.unread {\n          transition: none;\n        }\n      }\n    }\n  }\n\n  .dialog-avatar {\n    flex: 0 0 auto;\n  }\n\n  .user-caption {\n    max-width: 100%;\n    max-height: 100%;\n    overflow: hidden;\n    color: var(--secondary-text-color);\n    flex: 1 1 auto;\n    padding: .0625rem .4375rem .0625rem .5625rem;\n  }\n\n  .dialog-avatar, .user-caption {\n    pointer-events: none;\n    position: relative; // for z-index\n  }\n\n  .user-title {\n    display: flex !important;\n    align-items: center;\n\n    img.emoji {\n      vertical-align: top;\n      margin-top: 4px;\n      width: 18px;\n      height: 18px;\n    }\n\n    /* span.emoji {\n      &:first-of-type:not(:first-child) {\n        margin-left: .125rem;\n      }\n    } */\n\n    .verified-icon {\n      flex: 0 0 auto;\n      width: 20px;\n      height: 20px;\n      margin-left: .125rem;\n    }\n  }\n\n  .user-last-message {\n    img.emoji {\n      width: 20px;\n      height: 20px;\n      margin-top: -3px;\n    }\n\n    span.emoji {\n      font-size: 1.2rem;\n      margin: 0 .125rem;\n      overflow: visible;\n      //margin-top: -1.5px;\n    }\n  }\n\n  .user-title, .user-last-message {\n    i {\n      font-style: normal;\n      //color: var(--primary-color);\n    }\n  }\n\n  .message-status {\n    margin-right: .1rem;\n    //margin-top: .3rem;\n    margin-top: -.3rem;\n    display: inline-block;\n    vertical-align: middle;\n\n    &[class*=\" tgico-\"] {\n      color: var(--chatlist-status-color);\n      font-size: 1.25rem;\n    }\n\n    &:before {\n      vertical-align: middle;\n    }\n  }\n\n  .message-time {\n    vertical-align: middle;\n  }\n\n  .dialog-subtitle-badge {\n    margin-top: 4px;\n    margin-right: -3px;\n    margin-left: .25rem;\n    flex: 0 0 auto;\n  }\n\n  .tgico-chatspinned {\n    background: transparent;\n    position: relative;\n\n    &:before {\n      color: var(--chatlist-pinned-color);\n      transition: opacity .2s ease-in-out;\n      opacity: 1;\n      position: absolute;\n      top: 0;\n      left: 0;\n    }\n\n    &.unread {\n      &:before {\n        opacity: 0;\n      }\n    }\n  }\n\n  .unread, li.is-muted.backwards .unread {\n    background-color: var(--chatlist-status-color);\n  }\n\n  li.is-muted .unread {\n    background-color: var(--secondary-color);\n  }\n\n  &-parts {\n    /* width: 100%;\n    min-height: 100%;\n    display: flex;\n    flex-direction: column; */\n\n    &.with-contacts {\n      .chatlist-top:not(.with-placeholder) {\n        height: auto;\n        padding-bottom: .5rem;\n      }\n\n      .chatlist-top.with-placeholder {\n        height: 24.125rem;\n  \n        .empty-placeholder-dialogs {\n          top: 50%;\n        }\n      }\n    }\n  }\n\n  // do not set position: relative here. will break chatlist slicing.\n  &-top {\n    // flex: 0 0 auto;\n    height: 100%;\n  }\n\n  &-bottom {\n    // flex: 1 1 auto;\n    max-height: 36.375rem;\n\n    .sidebar-left-section {\n      padding-bottom: 0;\n    }\n\n    .chatlist-new {\n      padding: 0;\n      margin-top: -.5rem;\n\n      li {\n        height: 3.5rem;\n      }\n\n      .user-caption {\n        padding-left: 1.125rem;\n      }\n\n      .dialog-subtitle {\n        margin-top: .0625rem;\n      }\n    }\n  }\n\n  // * supernew correct layout\n  &-new {\n    li {\n      height: 4.5rem;\n      padding: 0 .75rem;\n      align-items: center;\n    }\n\n    .user-caption {\n      padding-left: .75rem;\n    }\n\n    p {\n      height: auto !important;\n    }\n\n    span {\n      line-height: var(--line-height) !important;\n    }\n\n    .dialog-subtitle {\n      margin-top: .125rem;\n    }\n\n    .user-last-message {\n      font-size: .875rem;\n    }\n  }\n}\n\n// use together like class=\"chatlist-container contacts-container\"\n.contacts-container, .search-group-contacts {\n  li {\n    padding: .75rem;\n\n    @include respond-to(handhelds) {\n      height: 66px;\n      padding-top: 9px;\n      padding-bottom: 9px;\n    }\n  }\n\n  .user-caption {\n    padding: 1px 3.5px 1px 13px;\n\n    @include respond-to(handhelds) {\n      padding: 0 4px 0 14px;\n    }\n  }\n\n  .user-title, b, .user-last-message b {\n    font-weight: normal;\n  }\n\n  p {\n    height: 24px;\n\n    @include respond-to(handhelds) {\n      height: 26px;\n    }\n  }\n\n  span.user-last-message {\n    font-size: 14px;\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n#column-left {\n  //display: flex;\n  flex-direction: column;\n  flex: 1 1 auto;\n  min-width: 18rem;\n  max-width: calc(#{$large-screen} / 4);\n\n  @include respond-to(handhelds) {\n    width: 100%;\n    max-width: 100%;\n\n    body:not(.is-left-column-shown) & {\n      transform: translate3d(-25vw, 0, 0);\n      filter: brightness(80%);\n    }\n  }\n\n  @include respond-to(not-handhelds) {\n    overflow: visible;\n\n    &:after {\n      position: absolute;\n      content: \" \";\n      display: block;\n      height: 100vh;\n      width: 1px;\n      background-color: var(--border-color);\n      right: -1px;\n      top: 0;\n      z-index: 2;\n    }\n  }\n  \n  @include respond-to(floating-left-sidebar) {\n    display: flex;\n    position: fixed;\n    left: 0;\n    top: 0;\n    /* height: calc(var(--vh, 1vh) * 100);\n    min-height: calc(var(--vh, 1vh) * 100) !important; */\n    width: 26.5rem;\n    transform: translate3d(-5rem, 0, 0);\n    transition: transform var(--layer-transition);\n    max-width: unset;\n    \n    body.animation-level-0 & {\n      transition: none;\n    }\n\n    body.is-left-column-shown & {\n      transform: translateZ(0);\n    }\n  }\n\n  @include respond-to(no-floating-left-sidebar) {\n    display: flex;\n  }\n\n  @include respond-to(before-medium-screens) {\n    flex: 2;\n  }\n\n  // ! WARNING, \u041e\u0427\u0415\u041d\u042c \u041a\u0420\u0423\u0422\u041e\u0419 \u041a\u041e\u0421\u0422\u042b\u041b\u042c - \u0424\u0418\u041a\u0421 \u0427\u0401\u0420\u041d\u041e\u0419 \u0420\u0410\u041c\u041a\u0418 \u0423 \u041a\u0410\u0420\u0422\u0418\u041d\u041e\u041a \u0421 \u0425\u0412\u041e\u0421\u0422\u0418\u041a\u041e\u041c\n  html.is-safari & {\n    @include respond-to(large-screens) {\n      max-width: calc(#{$large-screen} / 4 - 1.25px);\n    }\n  }\n\n  .item-main {\n    --menu-size: 3rem;\n  }\n\n  .menu-horizontal-scrollable {\n    --scrollable-size: var(--menu-size);\n    z-index: 1;\n    background-color: var(--surface-color);\n    position: relative;\n    top: unset;\n    \n    @include respond-to(handhelds) {\n      box-shadow: 0px 1px 5px -1px rgba(0, 0, 0, .16);\n    }\n\n    .scrollable {\n      position: relative;\n    }\n\n    .menu-horizontal-div {\n      position: relative !important;\n      justify-content: flex-start;\n      z-index: 0;\n\n      &-item {\n        flex: 0 0 auto;\n        min-width: 3rem;\n        border-top-left-radius: 6px;\n        border-top-right-radius: 6px;\n\n        > span {\n          overflow: visible;\n\n          i {\n            bottom: calc(-.6875rem - 2px);\n            /* padding-right: 1rem !important;\n\t          margin-left: -.5rem !important; */\n          }\n        }\n      }\n\n      &__stripe {\n        display: none;\n      }\n    }\n\n    .badge {\n      margin-left: 5px;\n      //line-height: inherit !important;\n    }\n\n    &:not(.hide) + #folders-container {\n      height: calc(100% - var(--menu-size));\n      position: relative;\n\n      .scrollable {\n        padding-top: .5rem;\n      }\n\n      /* .chatlist {\n        top: .5rem;\n      } */\n    }\n  }\n\n  .folders-tabs-scrollable {\n    .menu-horizontal-div-item:first-child {\n      margin-left: .6875rem;\n  \n      @include respond-to(handhelds) {\n        margin-left: .1875rem;\n      }\n    }\n  }\n\n  .item-main {\n    .input-search {\n      /* &-input {\n        --paddingLeft: 0px;\n        padding-left: calc(42px - var(--border-width) + var(--paddingLeft));\n      } */\n\n      .selector-user {\n        height: 30px;\n        position: absolute!important;\n        left: 6px;\n        top: 6px;\n        z-index: 1;\n        margin-left: 0;\n      }\n\n      &.is-picked {\n        .input-search-input {\n          padding-left: calc(var(--paddingLeft) + 12px - var(--border-width));\n        }\n\n        .tgico-close {\n          display: block !important;\n        }\n      }\n      \n      &.is-picked-twice {\n        .selector-user:first-of-type {\n          width: 30px;\n        }\n\n        .selector-user:last-of-type {\n          left: 38px;\n        }\n      }\n    }\n  \n    .search-helper {\n      display: flex;\n      margin-left: 28px;\n\n      @include respond-to(handhelds) {\n       margin-left: 20px;\n      }\n\n      .selector-user {\n        margin-top: 7px;\n        font-size: 14px;\n\n        @include hover() {\n          background-color: var(--light-primary-color);\n        }\n\n        &-avatar:after {\n          display: none !important;\n        }\n      }\n    }\n    \n    .search-super-tabs-scrollable { \n      position: relative !important; \n\n      &:before {\n        display: none;\n      }\n\n      .menu-horizontal-div-item {\n        flex: 1 0 auto !important;\n      }\n    }\n\n    .search-super {\n      .preloader {\n        height: 100%;\n        top: 50%;\n        transform: translate(-50%, -50%);\n      }\n    }\n  }\n\n  #chatlist-container {\n    max-height: 100%;\n    overflow: hidden;\n    position: relative;\n    background-color: var(--surface-color);\n  }\n\n  #folders-container {\n    .scrollable-y {\n      background-color: transparent;\n      position: absolute;\n      \n      &.active { // fix safari 14.0.2 scrollHeight\n        display: block;\n      }\n    }\n  }\n\n  .sidebar-slider {\n    height: 100%;\n  }\n\n  .sidebar-header__btn-container {\n    position: relative;\n    width: 2.5rem;\n    height: 2.5rem;\n    flex: 0 0 auto;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n\n    > .btn-icon {\n      visibility: hidden;\n      opacity: 0;\n      position: absolute;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      left: 0;\n      transition: .2s opacity, .15s background-color;\n      z-index: 2;\n      margin: 0;\n\n      body.animation-level-0 &, body.animation-level-0 &:before {\n        transition: none;\n      }\n\n      &.is-visible {\n        //margin-top: 1px;\n        opacity: 1;\n        visibility: visible;\n      }\n    }\n\n    @include respond-to(handhelds) {\n      .btn-menu {\n        margin-top: -.25rem;\n      }\n    }\n  }\n\n  .sidebar-tools-button {\n    width: 100%;\n    \n    .btn-menu {\n      width: 300px;\n  \n      .archived-count {\n        justify-self: flex-end;\n        margin-left: .625rem;\n  \n        @include respond-to(handhelds) {\n          font-weight: 600;\n        }\n      }\n  \n      .btn-menu-item {\n        padding-right: 1rem;\n      }\n  \n      .archived-count:empty {\n        display: none;\n      }\n    }\n  }\n\n  .search-group-people {\n    .chatlist {\n      display: flex;\n      flex-direction: row;\n      padding-left: 4px;\n      margin-top: -1px;\n      padding-bottom: 1px;\n    }\n\n    li {\n      height: 98px;\n      border-radius: 10px;\n      max-width: 78px;\n      width: 78px;\n      align-items: center;\n      display: flex;\n      flex-direction: column;\n      padding: 12px 0 0 !important;\n      margin: 0 5px 0 0;\n      flex: 0 0 auto;\n\n      @include respond-to(handhelds) {\n        width: 77px;\n        max-width: 77px;\n      }\n    }\n\n    .dialog-title-details, .dialog-subtitle {\n      display: none;\n    }\n\n    .user-caption {\n      max-width: 65px;\n      padding: 2px 0px 9px;\n      font-size: 12px;\n\n      @include respond-to(handhelds) {\n        max-width: 56px;\n      }\n    }\n\n    .search-group-scrollable {\n      position: relative;\n      \n      @include respond-to(handhelds) {\n        margin-left: -7px;\n        margin-top: 4px;\n      }\n      \n      > .scrollable {\n        position: relative;\n      }\n    }\n  }\n\n  .item-main .sidebar-content {\n    .btn-menu {\n      bottom: calc(100% + 10px);\n    }\n\n    .btn-corner {\n      &:not(.menu-open) .tgico-newchat_filled, \n      &.menu-open .tgico-close {\n        animation: grow-icon .4s forwards ease-in-out !important;\n        visibility: visible !important;\n      }\n\n      @include respond-to(handhelds) {\n        --size: 54px;\n        bottom: 14px;\n        right: 14px;\n\n        position: fixed !important;\n        z-index: 1;\n      }\n\n      /* html:not(.no-touch) & {\n        transform: translateZ(0);\n      } */\n      &:not(.is-hidden) {\n        transform: translateZ(0);\n      }\n    }\n\n    /* html.no-touch &:hover .btn-corner:not(.is-hidden) {\n      transform: translateZ(0);\n    } */\n  }\n\n  .connection-status {\n    width: 100%;\n    padding: 0 .5rem .5rem;\n    overflow: hidden;\n    flex: 0 0 auto;\n    \n    &:not(.is-shown) {\n      .connection-status-button {\n        display: none;\n      }\n    }\n\n    &.is-shown {\n      &.animating {\n        .connection-status-button, & + .connection-status-bottom {\n          transition: transform var(--layer-transition);\n        }\n      }\n\n      &:not(.backwards) {\n        .connection-status-button {\n          transform: translateY(0);\n        }\n\n        & + .connection-status-bottom {\n          transform: translateY(64px);\n        }\n      }\n\n      &:not(.animating):not(.backwards) {\n        & + .connection-status-bottom {\n          height: calc(100% - 64px);\n        }\n      }\n    }\n\n    &-button {\n      color: #2e3939;\n      align-self: center;\n      cursor: default;\n      padding-left: 4.5rem;\n      text-align: left;\n      height: 3.5rem;\n\n      .force-reconnect {\n        cursor: pointer;\n        text-decoration: underline;\n        color: inherit;\n      }\n\n      transform: translateY(-100%);\n\n      .preloader-container {\n        right: auto;\n        left: 1rem;\n        width: 1.5rem;\n        height: 1.5rem;\n\n        .preloader-path-new {\n          stroke: #2e3939;\n        }\n      }\n    }\n\n    &-bottom {\n      position: absolute;\n      left: 0;\n      top: 0;\n      bottom: 0;\n      right: 0;\n      overflow: hidden;\n      background-color: var(--surface-color);\n\n      transform: translateY(0);\n      height: 100%;\n\n      /* transform: translateY(64px);\n      height: calc(100% - 64px); */\n    }\n  }\n\n  .input-wrapper {\n    width: 420px;\n    margin: 0 auto;\n    flex: 0 0 auto;\n    padding: 0 1.25rem;\n    max-width: 100%;\n\n    @include respond-to(handhelds) {\n      width: 100%;\n      padding: 0 1rem;\n    }\n  }\n}\n\n#search-container {\n  display: flex;\n\n  .scrollable-y {\n    position: relative;\n  }\n}\n\n.new-channel-container, .new-group-container, .edit-profile-container {\n  .sidebar-content {\n    flex-direction: column;\n  }\n\n  .chatlist-container {\n    flex: 1 1 auto;\n  }\n\n  .caption {\n    font-size: 0.875rem;\n    margin-top: 14px;\n    margin-left: 23px;\n    color: var(--secondary-text-color);\n    padding-right: 24px;\n  }\n}\n\n.language-container {\n  .sidebar-left-section {\n    padding-bottom: .5rem;\n  }\n}\n\n.new-group-container {\n  .search-group {\n    margin-top: .5rem;\n  }\n}\n\n.edit-folder-container {\n  .chatlist {\n    padding: 0;\n  }\n\n  .folder-categories {\n    .folder-category-button {\n      &:nth-child(n+2) {\n        pointer-events: none;\n      }\n    }\n  }\n}\n\n.new-group-members {\n  padding: 1.5rem 0 .4375rem;\n\n  .search-group__name {\n    text-transform: capitalize;\n  }\n}\n\n.settings-container {\n  .profile {\n    &-button {\n      @include respond-to(handhelds) {\n        border-radius: 0;\n      }\n    }\n\n    &-buttons {\n      margin-top: 1.1875rem;\n      width: 100%;\n      padding: 0 .4375rem;\n\n      @include respond-to(handhelds) {\n        margin-top: .6875rem;\n        padding: 0;\n      }\n    }\n  }\n}\n\n.edit-profile-container {\n  .caption {\n    margin-top: 1.0625rem;\n    margin-left: 1.4375rem;\n    line-height: var(--line-height);\n    padding-bottom: 1.4375rem;\n\n    @include respond-to(handhelds) {\n      padding-right: 24px;\n    }\n  }\n\n  .sidebar-left-h2 {\n    padding: 0 1.4375rem;\n    padding-bottom: 1.5rem;\n  }\n\n  hr {\n    margin-bottom: 1rem;\n  }\n\n  .scroll-wrapper {\n    width: 100%;\n  }\n}\n\n.chat-folders-container, .edit-folder-container {\n  user-select: none;\n\n  .sticker-container {\n    width: 86px;\n    height: 86px;\n    margin: 1px auto 29px;\n    flex: 0 0 auto;\n    position: relative;\n  }\n\n  .caption {\n    text-align: center;\n    color: var(--secondary-text-color);\n    font-size: 14px;\n    line-height: var(--line-height);\n    max-width: 20rem;\n    margin: 0 auto;\n  }\n}\n\n.chat-folders-container {\n  .sidebar-left-section {\n    &:not(:last-child) {\n      padding-bottom: 0;\n    }\n\n    &:last-child {\n      padding-bottom: .5rem;\n    }\n\n    /* &-name {\n      padding-top: .5rem;\n      padding-bottom: .5rem;\n    } */\n  }\n\n  .row {\n    .btn-primary {\n      height: 30px;\n      padding: 0 12px;\n      font-size: 15px;\n      width: auto;\n      transition: width 0.2s;\n      margin: 0;\n      position: absolute;\n      right: 1rem;\n      top: 50%;\n      transform: translateY(-50%);\n      border-radius: 15px;\n\n      body.animation-level-0 & {\n        transition: none;\n      }\n    }\n  }\n}\n\n.edit-folder-container {\n  .caption {\n    margin-bottom: 18px;\n  }\n\n  @include respond-to(handhelds) {\n    .input-wrapper {\n      width: 100%;\n      padding: 0 16px;\n    }\n  }\n\n  .input-wrapper {\n    margin-bottom: .125rem !important;\n  }\n\n  .sidebar-left-section {\n    padding-bottom: 0rem;\n\n    &:last-child {\n      padding-bottom: .5rem;\n    }\n  }\n}\n\n.folder-list {\n  li {\n    padding: 9px 12px;\n    height: 50px;\n  }\n\n  .user-caption {\n    padding: 3px 28px 6px 27px;\n  }  \n\n  p span {\n    font-weight: normal;\n  }\n}\n\n.folder-categories {\n  .checkbox-field {\n    position: absolute;\n    right: 1.125rem !important;\n  }\n}\n\n.folder-category-button {\n  height: 50px;\n}\n\n.popup-forward, .included-chatlist-container {\n  .selector {\n    .chatlist {\n      li {\n        padding: 7px .75rem !important;\n        height: 3.75rem;\n      }\n  \n      .user-caption {\n        padding: 0px 0px 0 14px;\n        margin-top: -2px;\n      }\n  \n      .user-last-message {\n        font-size: 15px;\n        margin-top: 2px;\n      }\n    }\n  }\n}\n\n.included-chatlist-container {\n  .sidebar-left-section {\n    padding-bottom: 0;\n\n    &:first-child {\n      padding-top: 0;\n    }\n    \n    &:last-child {\n      padding-bottom: .5rem;\n    }\n\n    .chatlist {\n      padding: 0;\n    }\n  }\n\n  .selector {\n    .chatlist {\n      .checkbox {\n        margin-top: 10px;\n      }\n\n      [type=\"checkbox\"] + span {\n        padding-left: 26px;\n      }\n    }\n  }\n}\n\n.search-group-recent {\n  .search-group__name {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n\n  .btn-icon {\n    //@include respond-to(handhelds) {\n      font-size: 22px;\n    //}\n  }\n\n  @include respond-to(handhelds) {\n    li {\n      height: 62px;\n      padding-top: 7px;\n      padding-bottom: 7px;\n    }\n\n    .user-caption {\n      margin-top: -2px;\n    }\n\n    .user-title {\n      font-weight: 500 !important;\n    }\n\n    .dialog-avatar {\n      --size: 46px;\n      --multiplier: 1.173913;\n    }\n  }\n}\n\n@include respond-to(handhelds) {\n  .search-group-recent.search-group.search-group-contacts ul {\n    margin-top: 0;\n  }\n\n  .search-group.search-group-contacts ul, .search-group.search-group-messages ul {\n    margin-top: 7px;\n  }\n\n  .search-group.search-group-messages {\n    margin-top: -6px;\n  }\n}\n\n@include respond-to(not-handhelds) {\n  .search-group-recent.search-group.search-group-contacts {\n    padding: 0px 0 7px;\n  }\n}\n\n.sidebar-left {\n  &-section {\n    /* padding-bottom: .75rem;\n\n    @include respond-to(handhelds) {\n      padding-bottom: .5rem;\n    } */\n    user-select: none;\n    padding: .5rem 0 1rem;\n\n    &.with-fake-delimiter {\n      padding-top: 0;\n    }\n\n    @include respond-to(handhelds) {\n      padding-bottom: .5rem;\n    }\n  \n    &-content {\n      @include respond-to(not-handhelds) {\n        margin: 0 .5rem;\n      }\n\n      > .btn-primary {\n        margin: 0;\n      }\n\n      > .checkbox-field {\n        .checkbox-box {\n          left: auto;\n        }\n      }\n\n      @include respond-to(handhelds) {\n        > .checkbox-ripple, \n        > .btn-primary {\n          border-radius: 0;\n        }\n      }\n    }\n  \n    &-name {\n      padding: 1rem;\n\n      @include respond-to(handhelds) {\n        padding: .5rem 1rem;\n        font-size: .875rem;\n      }\n    }\n\n    &-caption {\n      margin-top: 1rem;\n      font-size: 1rem;\n      color: var(--secondary-text-color);\n      line-height: var(--line-height);\n      padding: 0 1rem;\n\n      @include respond-to(handhelds) {\n        margin: .5rem;\n        font-size: .875rem;\n      }\n    }\n\n    .checkbox-field, .radio-field {\n      margin: 0;\n    }\n\n    // * comment later\n    &:first-child:not(.no-delimiter) {\n      padding-top: 0;\n    }\n\n    .checkbox-field {\n      display: flex;\n      align-items: center;\n      height: 3.5rem;\n      padding: 0 1.125rem;\n    }\n\n    &-disabled {\n      pointer-events: none !important;\n      opacity: .25;\n    }\n\n    .media-sticker-wrapper {\n      width: 86px;\n      height: 86px;\n      margin: 1px auto 29px;\n      flex: 0 0 auto;\n      position: relative;\n    }\n  }\n\n  &-h2 {\n    color: var(--primary-color);\n    font-size: 16px;\n    font-weight: 500;\n  }\n}\n\n.general-settings-container {\n  user-select: none;\n\n  .sidebar-left-section {\n    padding-bottom: 0;\n  }\n\n  .sidebar-left-section:last-child {\n    padding-bottom: .5rem;\n  }\n}\n\n.two-step-verification {\n  .sidebar-left-section { // * main tab verified with mockup\n    &:first-child { // ! refactor is needed\n      padding-top: 0;\n    }\n\n    &-caption {\n      text-align: center;\n      max-width: 342px;\n      margin-left: auto;\n      margin-right: auto;\n      margin-bottom: 1.125rem;\n    }\n  }\n\n  &-main {\n    .btn-primary + .btn-primary {\n      margin-top: .125rem !important;\n    }\n  }\n\n  .btn-primary:not(.btn-transparent) {\n    text-transform: uppercase;\n  }\n\n  .media-sticker-wrapper {\n    width: 168px;\n    height: 168px;\n    margin: .625rem auto 1.1875rem;\n  }\n\n  .input-wrapper .btn-primary:first-child:last-child {\n    margin-top: .25rem;\n  }\n\n  &-enter-password {\n    .media-sticker-wrapper {\n      margin: 1.125rem auto 1.8125rem;\n      width: 157px;\n      height: 157px;\n    }\n  }\n\n  &-hint {\n    .media-sticker-wrapper {\n      width: 160px;\n      height: 160px;\n      margin: .5rem auto 2.25rem;\n    }\n  }\n\n  &-email {\n    .media-sticker-wrapper {\n      width: 160px;\n      height: 160px;\n      margin: .5625rem auto 2.1875rem;\n    }\n  }\n\n  &-set {\n    .media-sticker-wrapper {\n      width: 160px;\n      height: 160px;\n      margin: 1rem auto 1.3125rem;\n\n      .rlottie, .rlottie-vector {\n        left: .625rem;\n      }\n    }\n  }\n}\n\n.dont-u-dare-block-me {\n  .sidebar-left-section.no-delimiter {\n    padding-top: .75rem;\n  }\n\n  .sidebar-left-section {\n    padding: 0 0 .5rem;\n  }\n\n  /* .privacy-navigation-container {\n    .sidebar-left-section-name + .row {\n      margin-top: -5px; // ! just to match mockup.\n    }\n  } */\n}\n\n.privacy-tab {\n  // * just to match mockup\n  @include respond-to(not-handhelds) {\n    .sidebar-left-section:first-child {\n      padding-bottom: 1.125rem;\n    }\n  }\n\n  form {\n    padding-bottom: .0625rem;\n  }\n}\n\n.active-sessions-container {\n  .row {\n    margin-top: 0;\n    padding-top: 1rem;\n    padding-bottom: .9375rem;\n\n    &-title-row {\n      align-items: flex-end;\n    }\n\n    &-title:first-child {\n      font-weight: 500;\n    }\n\n    &-title-right {\n      font-size: .75rem;\n      color: var(--secondary-text-color);\n      line-height: 1.5;\n    }\n\n    &-midtitle, &-subtitle {\n      white-space: nowrap;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n  }\n\n  .sidebar-left-section:first-child {\n    padding-bottom: 0;\n\n    .row-title {\n      font-weight: 500;\n    }\n  }\n}\n\n.blocked-users-container {\n  li {\n    height: 66px;\n    padding-top: 9px;\n    padding-bottom: 9px;\n  }\n\n  .user-caption {\n    padding-left: .75rem;\n  }\n\n  .dialog-subtitle {\n    margin-top: -.375rem;\n    font-size: .875rem;\n  }\n\n  ul {\n    margin-top: .3125rem;\n    \n    @include respond-to(not-handhelds) {\n      padding: 0 .6875rem;\n    }\n  }\n}\n\n.notifications-container {\n  .sidebar-left-section {\n    padding-bottom: 0;\n  }\n}\n\n.range-setting-selector {\n  padding: 1rem .875rem;\n\n  &-details {\n    display: flex;\n    justify-content: space-between;\n    margin-bottom: 1rem;\n  }\n\n  &-name {\n    color: var(--primary-text-color);\n  }\n\n  &-value {\n    color: var(--secondary-text-color);\n  }\n\n  .progress-line {\n    --height: 2px;\n    --border-radius: 4px;\n    background-color: #e6ecf0;\n    \n    &__filled {\n      background-color: var(--primary-color);\n    }\n    \n    &__seek {\n      --thumb-color: var(--primary-color);\n      --thumb-size: 12px;\n    }\n  }\n}\n\n.background-container {\n  .grid {\n    padding: 0 .5rem .5rem;\n\n    &-item {\n      &:after {\n        content: \" \";\n        display: block;\n        position: absolute;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        border: 3px solid var(--primary-color);\n        opacity: 0;\n        transition: opacity .2s ease-in-out;\n      }\n\n      &.active {\n        &:after {\n          opacity: 1;\n        }\n\n        .grid-item-media {\n          transform: scale(.91);\n        }\n      }\n\n      &-media {\n        transition: transform .2s ease-in-out;\n        transform: scale(1);\n      }\n    }\n\n    .media-photo {\n      width: 100%;\n      height: 100%;\n      object-fit: cover;\n    }\n\n    .preloader-container {\n      z-index: 1;\n    }\n  }\n}\n\n.background-image-container {\n  .sidebar-left-section {\n    padding-bottom: .5rem;\n  }\n}\n\n.empty-placeholder {\n  // left: 50%;\n  // transform: translate(-50%, -50%);\n  // position: absolute;\n  top: 40%;\n  transform: translateY(-50%);\n  text-align: center;\n  line-height: var(--line-height);\n  user-select: none;\n  width: 21rem !important;\n  margin: 0 auto;\n  padding: 0 1rem;\n  position: relative;\n  \n  .media-sticker-wrapper {\n    width: 128px;\n    height: 128px;\n    margin: 0 auto 1.9375rem;\n    position: relative;\n  }\n\n  &-header {\n    font-size: 1.25rem;\n    font-weight: 500;\n  }\n\n  &-subtitle {\n    color: var(--secondary-text-color);\n    font-size: .875rem;\n    margin-top: .375rem;\n  }\n\n  .btn-control {\n    margin-top: 1.75rem;\n    padding: 0 1.0625rem 0 .8125rem;\n\n    &:before {\n      margin-right: .625rem;\n    }\n  }\n\n  &-dialogs {\n    opacity: 0;\n\n    @include animation-level(2) {\n      transition: opacity .2s ease-in-out;  \n    }\n\n    &-icon {\n      margin-bottom: 1.0625rem;\n    }\n\n    &.visible {\n      opacity: 1;\n    }\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n#column-right {\n  position: relative;\n  overflow: unset;\n\n  @include respond-to(only-small-screens) {\n    box-shadow: 0 0.25rem 0.5rem 0.1rem rgba(0, 0, 0, .2);\n  }\n\n  @include respond-to(handhelds) {\n    body:not(.is-right-column-shown) & {\n      transform: translate3d(100vw, 0, 0);\n    }\n  }\n\n  @include respond-to(not-handhelds) {\n    width: calc(var(--right-column-width));\n    transition: transform var(--transition-standard-out);\n    position: absolute;\n    right: 0;\n    z-index: 3;\n    transform: translate3d(var(--right-column-width), 0, 0);\n    //transform: translate3d(calc(var(--right-column-width) + 1px), 0, 0);\n  \n    .sidebar-content {\n      min-width: var(--right-column-width);\n    }\n  \n    /* &:not(.active) {\n      border-left-width: 0;\n    } */\n  \n    body.is-right-column-shown:not(.is-left-column-shown) & {\n      transition: transform var(--transition-standard-in);\n      transform: translate3d(0, 0, 0);\n    }\n\n    body.animation-level-0 & {\n\t\t\ttransition: none;\n\t\t}\n\n    /* &:before {\n      position: absolute;\n      content: \" \";\n      display: block;\n      //height: 56px;\n      height: 100vh;\n      width: 1px;\n      background-color: var(--border-color);\n      left: 0px;\n      top: 0;\n    } */\n  }\n\n  @include respond-to(medium-screens) {\n    width: calc(var(--right-column-width) + 1px);\n    transform: translate3d(calc(var(--right-column-width) + 1px), 0, 0);\n    border-left: 1px solid var(--border-color);\n  }\n\n  /* @include respond-to(medium-screens) {\n    border-left: 1px solid var(--border-color);\n  } */\n\n  /* body.is-forward-active & {\n    z-index: 4;\n  } */\n\n  .sidebar-header {\n    flex: 0 0 auto;\n\n    .sidebar-close-button.tgico:before {\n      content: $tgico-left;\n\n      @include respond-to(not-handhelds) {\n        content: $tgico-close;\n      }\n    }\n  }\n\n  #search-private-container {\n    .chatlist-container {\n      position: relative;\n      flex: 1 1 auto;\n    }\n  }\n\n  /* #forward-container {\n    z-index: 5;\n  } */\n\n  .sidebar-search {\n    display: none;\n\n    &.active {\n      display: flex;\n    }\n  }\n\n  .input-wrapper {\n    width: 100%;\n    max-width: 100%;\n  }\n}\n\n.shared-media-container {\n  //background-color: var(--background-color-true) !important;\n  /* .search-super {\n    top: 100%;\n    min-height: calc((var(--vh, 1vh) * 100) - 100% - 56px);\n\n    &.sliding {\n      max-height: calc((var(--vh, 1vh) * 100) - 100% - 56px);\n    }\n  } */\n  .scrollable:not(.no-parallax) {\n    perspective: 0px;\n    perspective-origin: left top;\n\n    &.parallax {\n      perspective: 1px;\n    }\n  }\n\n  .search-super {\n    top: 100%;\n    min-height: calc((var(--vh, 1vh) * 100) - 56px);\n  }\n\n  .sidebar-header .transition {\n    flex-grow: 1;\n\n    .transition-item {\n      display: flex;\n      align-items: center;\n    }\n  }\n\n  .btn-corner {\n    &.menu-open:before {\n      content: $tgico-close;\n    }\n\n    @include respond-to(handhelds) {\n      width: 54px;\n      height: 54px;\n      bottom: 14px;\n      right: 14px;\n\n      position: fixed !important;\n      z-index: 1;\n    }\n  }\n\n  &.can-add-members {\n    //@include respond-to(handhelds) {\n      .btn-corner:not(.is-hidden) {\n        transform: translateZ(0);\n      }\n    //}\n\n    /* @include hover() {\n      .btn-corner:not(.is-hidden) {\n        transform: translateZ(0);\n      }\n    } */\n  }\n}\n\n.search-super {\n  width: 100%;\n  max-width: 100%;\n  position: absolute;\n  min-height: 100%;\n  display: flex;\n  flex-direction: column;\n  background-color: var(--surface-color);\n\n  .search-group__show-more {\n    color: var(--primary-color);\n    cursor: pointer;\n    font-weight: 400;\n  }\n\n  .search-super-month-name {\n    border-top: 1px solid var(--border-color);\n    padding: 24px 0px 0px 24px;\n    font-weight: 500;\n    color: var(--secondary-text-color);\n\n    @include respond-to(handhelds) {\n      padding: 18px 0px 0px 16px;\n    }\n  }\n\n  /* &.sliding {\n    max-height: 100%;\n  } */\n\n  &.sliding {\n    max-height: none !important;\n  }\n\n  &-tabs {\n    width: auto;\n    flex: 1 1 auto;\n    \n    //margin-top: 36px;\n    /* i {\n      padding-right: 1.5rem !important;\n\t    margin-left: -.75rem !important;\n    } */\n  }\n\n  &-tabs-scrollable {\n    box-shadow: none !important;\n    position: -webkit-sticky !important;\n\t  position: sticky !important;\n    //top: -1px;\n    top: 0px;\n    z-index: 2;\n    background-color: var(--surface-color);\n\n    &:before {\n      position: absolute;\n      width: 100%;\n      height: 1px;\n      left: 0;\n      top: 0;\n      background-color: inherit;\n      display: block;\n      content: \" \";\n      z-index: -1;\n\n      .search-super.is-full-viewport & {\n        top: -1px;\n      }\n    }\n\n    .scrollable {\n      position: relative;\n      display: flex;\n    }\n  }\n\n  &-tabs-container {\n    //min-height: 100%;\n    min-height: calc(100% - 49px);\n    grid-template-rows: 100%;\n    flex: 1 1 auto;\n    //position: absolute; // FIX THE SAFARI!\n    //position: relative;\n    /* width: 500%;\n    margin-left: -100%;\n */\n    /* > div {\n      height: 0;\n    \n      &.active {\n        height: auto;\n      }\n    } */\n\n    > div {\n      //height: 100%;\n      position: relative;\n      min-height: 150px;\n\n      /* > div:not(:empty) + .content-empty {\n        display: none;\n      } */\n\n      > div:first-child {\n        transform: translateY(0);\n\n        // * fix saving scroll on tab switching, when FROM tab has height < 100vh, and another is scrolled less than the FROM tab's height\n        // * adding 1 extra pixel for scroll\n        min-height: calc(100vh - 111px);\n      }\n    }\n\n    /* .scrollable-y {\n      height: auto;\n      position: absolute !important;\n    } */\n\n    /* > div > div:not(.scroll-padding) {\n      height: 100%;\n    } */\n\n    .preloader {\n      padding: 0;\n      position: absolute !important;\n      top: 100px;\n      transform: translate(-50%);\n\n      > svg {\n        height: 50px;\n        width: 50px;\n      }\n    }\n  }\n\n  &-month:first-of-type &-month-name {\n    display: none;\n  }\n\n  .document-name, .audio-title, .title {\n    display: flex;\n    justify-content: space-between;\n  }\n\n  .sent-time {\n    flex: 0 0 auto;\n    margin-left: 8px;\n    margin-top: 3px;\n    font-size: 12px;\n    color: var(--secondary-text-color);\n  }\n\n  &-content-media {\n    .search-super-month-name {\n      border: none;\n      padding: 9px 0px 7px 24px;\n    }\n\n    .video-time {\n      position: absolute;\n      left: 5px;\n      top: 4px;\n      height: 18px;\n      border-radius: 4px;\n      background-color: var(--message-time-background);\n      padding: 0px 6px 0px 5px;\n      z-index: 1;\n      font-size: 12px;\n      color: white;\n      line-height: 18px;\n    }\n\n    .grid-item {\n      overflow: hidden;\n    }\n\n    /* span.video-play {\n      background-color: var(--message-time-background);\n      color: #fff;\n      text-align: center;\n      font-size: 34px;\n      line-height: 60px;\n      cursor: pointer;\n    } */\n  }\n\n  &-content-media &-month {\n    &-items {\n      width: 100%;\n      padding-top: 1px;\n\n      display: grid;\n      grid-template-columns: repeat(3,1fr);\n      grid-auto-rows: 1fr;\n      grid-gap: 1px;\n    }\n  }\n\n  &-content-files {\n    // padding: 8px 20px;\n    .search-super-month-items {\n      padding: 8px 24px 16px 20px;\n\n      @include respond-to(handhelds) {\n        padding: 8px 16px 8px 12px;\n      }\n    }\n\n    .document {\n      padding-left: 60px;\n      // padding-right: 1rem;\n      //height: 54px;\n      height: calc(48px + 1.5rem);\n\n      &-ico, &-download {\n        width: 48px;\n        height: 48px;\n        border-radius: 5px !important;\n      }\n\n      /* & + .document {\n        margin-top: 1.5rem;\n      } */\n    }\n\n    .document-name {\n      font-weight: normal;\n\n      width: 100%;\n      max-width: 100%;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n  }\n\n  &-content-links {\n    // padding: 0 24px 15px 15px;\n\n    .search-super-item {\n      display: flex;\n      flex-direction: column;\n      margin-top: 20px;\n      margin-left: 5px;\n      padding-bottom: 2px;\n      //padding-bottom: 10px;\n      position: relative;\n      padding-left: 60px;\n      overflow: hidden;\n      //min-height: 48px;\n      min-height: 58px;\n\n      .preview {\n        height: 3rem;\n        width: 3rem;\n        border-radius: .375rem;\n        overflow: hidden;\n        position: absolute;\n        left: 0;\n        top: 0;\n\n        &.empty {\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          font-size: 2rem;\n          color: #fff;\n          text-transform: uppercase;\n          background-color: var(--primary-color);\n        }\n\n        .media-photo {\n          object-fit: cover;\n          width: 100%;\n          height: 100%;\n        }\n      }\n\n      .url {\n        white-space: nowrap;\n        text-overflow: ellipsis;\n        overflow: hidden;\n        font-size: 14px;\n        margin-top: -1px;\n      }\n    }\n\n    .title {\n      font-size: 16px;\n      margin-top: 2px;\n    }\n\n    .subtitle {\n      font-size: 14px;\n      max-width: 310px;\n\n      &.sender {\n        margin-top: 2px;\n      }\n    }\n\n    .search-super-month-items {\n      padding: 0 24px 15px 15px;\n    \n      @include respond-to(handhelds) {\n        padding: 0 16px 15px 7px;\n      }\n    }\n\n  }\n\n  &-content-music, &-content-voice {\n    .search-super-month-items {\n      padding: 20px 15px 0px 20px;\n\n      @include respond-to(handhelds) {\n        padding: 20px 15px 0px 12px;\n      }\n    }\n\n    .audio {\n      /* min-height: 58px; */\n      justify-content: unset;\n      margin-bottom: 1.5rem;\n\n      @include respond-to(not-handhelds) {\n        max-width: 377px;\n      }\n\n      &.audio-show-progress .audio-subtitle {\n        overflow: visible;\n      }\n\n      /* &-no-subtitle {\n        padding-bottom: 16px;\n      } */\n    }\n  }\n\n  &-content-members {\n    .chatlist {\n      padding-top: .5rem;\n      padding-bottom: .5rem;\n\n      li {\n        padding: .75rem;\n      }\n\n      .user-caption {\n        padding-left: .75rem;\n      }\n\n      .dialog-subtitle {\n        font-size: .875rem;\n        margin-top: -.375rem;\n      }\n    }\n  }\n}\n\n#search-container {\n  .search-super-content-music {\n    .audio:not(.audio-show-progress) .audio-time {\n      display: none;\n    }\n  }\n  \n  .search-group.is-short {\n    li:nth-child(n + 4) {\n      display: none;\n    }\n  }\n}\n\n#stickers-container {\n  .sticker-sets {\n    display: flex;\n    flex-direction: column;\n    margin-top: 16px;\n  }\n\n  .sticker-set {\n    display: flex;\n    flex-direction: column;\n    height: 140px;\n    cursor: pointer;\n\n    &-name {\n      font-weight: 500;\n    }\n\n    &-count {\n      font-size: 14px;\n      color: var(--secondary-text-color);  \n    }\n\n    &-header {\n      display: flex;\n      padding-left: 16px;\n      padding-bottom: 12px;\n      justify-content: space-between;\n  \n    }\n\n    &-button {\n      height: 30px;\n      padding-left: 12px;\n      padding-right: 13px;\n      margin-right: 16px;\n      font-size: 15px;\n      border-radius: 16px;\n      font-weight: 400;\n      width: auto;\n      transition: width 0.2s;\n\n      &.gray {\n        background: #F1F3F4;\n        color: var(--secondary-text-color);\n      }\n    }\n\n    &-stickers {\n      display: flex;\n      justify-content: space-around;\n    }\n\n    &-sticker {\n      width: 68px;\n      height: 68px;\n      position: relative;\n      //padding: 0 5px;  \n\n      &:hover {\n        border-radius: 12px;\n        background-color: var(--light-secondary-text-color);\n      }\n\n      img {\n        max-width: 100%;\n        max-height: 100%;\n      }\n    }\n  }\n}\n\n#poll-results-container {\n  .poll-results {\n    display: flex;\n    flex-direction: column;\n    position: relative;\n    width: 100%;\n  \n    &-answer {\n      color: var(--secondary-text-color);\n      padding: 0 16px 8px 16px;\n      margin: 0;\n      font-weight: 500;\n      justify-content: space-between;\n      display: flex;\n      font-size: 15px;\n      user-select: none;\n\n      @include respond-to(not-handhelds) {\n        padding: 0 24px 8px 24px;\n      }\n    }\n\n    &-more {\n      padding-top: 13px;\n      padding-bottom: 13px;\n      cursor: pointer;\n      user-select: none;\n      position: relative;\n\n      @include respond-to(not-handhelds) {\n        padding-left: 8px;\n      }\n\n      .tgico-down {\n        float: left;\n        padding-right: 32px;\n        padding-left: 16.5px;\n        font-size: 24px;\n        color: var(--secondary-text-color);\n      }\n    }\n\n    h3 {\n      padding: 0 16px;\n      margin-top: 15px;\n      font-size: 20px;\n      margin-bottom: 16px;\n\n      @include respond-to(not-handhelds) {\n        padding: 0 24px;\n      }\n    }\n  \n    hr {\n      margin-bottom: 15px;\n      margin-top: 7px;\n    }\n  \n    .user-caption {\n      padding: 3px 28px 6px;\n    }\n\n    .user-title {\n      font-weight: normal;\n    }\n  \n    li {\n      height: 50px;\n      padding: 9px;\n\n      @include respond-to(not-handhelds) {\n        padding: 9px 12px;\n      }\n    }\n  }\n}\n\n#search-gifs-container {\n  .gifs-masonry {\n    margin-top: -2.5px;\n  }\n}\n\n.edit-peer-container {\n  .input-wrapper {\n    padding: 0 .75rem;\n    margin-bottom: .5625rem;\n  }\n\n  .sidebar-left-section {\n    padding: 0 0 .5rem;\n  }\n\n  .chatlist-new {\n    padding: 0;\n  }\n}\n\n.edit-contact-container {\n  .input-wrapper {\n    margin-top: 1.8125rem;\n    padding-bottom: 1rem;\n  }\n\n  .avatar-placeholder {\n    filter: none !important;\n  }\n\n  .avatar-edit {\n    margin-bottom: 1.375rem !important;\n  }\n\n  .profile-name {\n    font-size: 1.5rem;\n    line-height: 1.3125;\n  }\n}\n\n.group-type-container {\n  .sidebar-left-section-caption {\n    font-size: .875rem;\n    margin-top: .8125rem;\n  }\n\n  .input-wrapper {\n    margin-top: .875rem;\n  }\n}\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n.menu-horizontal-scrollable {\n  --scrollable-size: 3.5rem;\n  height: var(--scrollable-size);\n  \n  &:after {\n    content: \" \";\n    position: absolute;\n    height: 1px;\n    border-bottom: 1px solid var(--border-color);\n    bottom: 0;\n    left: 0;\n    right: 0;\n    z-index: -1;\n  }\n\n  .menu-horizontal-div {\n    border-bottom: none;\n  }\n}\n\n.menu-horizontal-div {\n  --size: var(--scrollable-size, 3.5rem);\n  width: 100%;\n  display: flex;\n  justify-content: space-around;\n  align-items: center;\n  flex-direction: row;\n  position: relative;\n  z-index: 2;\n  user-select: none;\n\n  color: var(--secondary-text-color);\n  border-bottom: 1px solid var(--border-color);\n\n  &-item {\n    height: var(--size);\n    padding: 0 1rem;\n    cursor: pointer;\n    text-align: center;\n    flex: 1 1 auto;\n    font-size: 1rem;\n    font-weight: 500;\n    position: relative;\n    transition: none !important;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    line-height: var(--line-height);\n    border-radius: 0;\n\n    @include hover-background-effect();\n\n    &.active {\n      color: var(--primary-color);\n\n      i {\n        opacity: 1;\n      }\n\n      .c-ripple__circle {\n        background-color: var(--light-primary-color);\n      }\n  \n      @include hover-background-effect(primary);\n\n      .badge {\n        background-color: var(--primary-color);\n      }\n    }\n\n    > span {\n      position: relative;\n      display: inline-flex;\n      align-items: center;\n      overflow: visible;\n    }\n  }\n\n  i {\n    position: absolute;\n    bottom: calc(-.625rem - 7px);\n    left: 0;\n    opacity: 0;\n    background-color: var(--primary-color);\n    height: .1875rem;\n    width: 100%;\n    border-radius: .1875rem .1875rem 0 0;\n    pointer-events: none;\n    /* padding-right: .5rem;\n    margin-left: -.25rem; */\n    box-sizing: content-box;\n    transform-origin: left;\n    z-index: 1;\n\n    &.animate {\n      transition: transform var(--tabs-transition);\n    }\n  }\n}\n\n.tabs-container {\n  min-width: 100%;\n  width: 100%;\n  display: grid;\n  //grid-template-columns: 1fr;\n  grid-template-columns: 100%;\n  grid-template-rows: 100%;\n\n  /* @include respond-to(not-handhelds) {\n    overflow-x: hidden;\n  } */\n\n  // &.animated {\n  //   transition: .3s transform;\n  // }\n  \n  > div {\n    // * can't define these rules because of old firefox, though they don't work\n    //height: 100%;\n    //max-height: 100%;\n    //width: 100%;\n    //max-width: 100%;\n    \n    display: none;\n    flex-direction: column;\n    position: relative;\n    grid-row-start: 1;\n    grid-column-start: 1;\n    background-color: var(--background-color);\n    //z-index: 1;\n\n    body.animation-level-0 & {\n      transition: none !important;\n    }\n    \n    //@include respond-to(not-handhelds) {\n      overflow: hidden;\n    //}\n\n    &.active {\n      display: flex;\n    }\n    \n    /* > div:not(.scroll-padding) {\n      width: 100%;\n      max-width: 100%;\n      //overflow: hidden;\n      position: relative;\n    } */\n  }\n\n  /* &[data-animation=\"tabs\"] {\n    & > div {\n      --width: 100%;\n      transition: transform var(--tabs-transition);\n      transform: translateZ(0);\n\n      &.from {\n        animation: slide-tabs-from var(--tabs-transition) forwards;\n      }\n\n      &.to {\n        transform: translate3d(var(--width), 0, 0);\n        animation: slide-tabs-to var(--tabs-transition) forwards;\n      }\n    }\n\n    &.backwards > div {\n      &.from {\n        animation: slide-tabs-backwards-from var(--tabs-transition) forwards;\n      }\n\n      &.to {\n        transform: translate3d(calc(var(--width) * -1), 0, 0);\n        animation: slide-tabs-backwards-to var(--tabs-transition) forwards;\n      }\n    }\n  } */\n  \n  &[data-animation=\"tabs\"] > div {\n    transition: transform var(--tabs-transition);\n  }\n\n  &[data-animation=\"navigation\"] > div {\n    transition: transform var(--tabs-transition), filter var(--tabs-transition);\n  }\n}\n\n/* @keyframes slide-tabs-from {\n  to {\n    transform: translate3d(calc(var(--width) * -1), 0, 0);\n  }\n}\n\n@keyframes slide-tabs-to {\n  to {\n    transform: translateZ(0);\n  }\n}\n\n@keyframes slide-tabs-backwards-from {\n  to {\n    transform: translate3d(var(--width), 0, 0);\n  }\n}\n\n@keyframes slide-tabs-backwards-to {\n  to {\n    transform: translateZ(0);\n  }\n} */\n", "/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\n$placeholder-color: #9e9e9e;\n$border-radius: 8px;\n$border-radius-medium: 10px;\n$border-radius-big: 12px;\n\n$hover-alpha: .08;\n\n//$small-screen: 720px;\n$small-screen: 600px;\n//$small-screen: 900px;\n$medium-screen: 1275px;\n$large-screen: 1680px;\n//$large-screen: 16800px;\n\n$floating-left-sidebar: 925px;\n$messages-container-width: 728px;\n\n$chat-input-size: 3.375rem;\n$chat-input-handhelds-size: 2.875rem;\n$chat-padding: .8125rem;\n$chat-padding-handhelds: .5rem;\n$chat-input-inner-padding: .5rem;\n$chat-input-inner-padding-handhelds: .25rem;\n\n@function hover-color($color) {\n  @return rgba($color, $hover-alpha);\n}\n\n/* @mixin safari-overflow() {\n  html.is-safari & {\n    -webkit-mask-image: -webkit-radial-gradient(circle, white 100%, black 100%);\n    @content;\n  }\n} */\n\n@import \"mixins/hover\";\n@import \"mixins/respondTo\";\n@import \"mixins/textOverflow\";\n@import \"mixins/animationLevel\";\n\n:root {\n  --vh: 1vh;\n  --z-below: -1;\n  --hover-alpha: #{$hover-alpha};\n\n  --transition-standard-easing: cubic-bezier(.4, .0, .2, 1);\n  --transition-standard-in-time: .3s;\n  --transition-standard-out-time: .25s;\n  --transition-standard-in: var(--transition-standard-in-time) var(--transition-standard-easing);\n  --transition-standard-out: var(--transition-standard-out-time) var(--transition-standard-easing);\n  \n  --pm-transition: .2s ease-in-out;\n  --layer-transition: .2s cubic-bezier(.4, .0, .2, 1);\n  --slide-header-transition: .4s ease-in-out;\n  --tabs-transition: .25s ease-in-out;\n  --btn-menu-transition: .2s cubic-bezier(.4, 0, .2, 1);\n  --esg-transition: var(--btn-menu-transition);\n  --popup-transition-function: cubic-bezier(.4, 0, .2, 1);\n  --popup-transition-time: .15s;\n  //--layer-transition: .3s cubic-bezier(.33, 1, .68, 1);\n  //--layer-transition: none;\n  --btn-corner-transition: .2s cubic-bezier(.34, 1.56, .64, 1);\n  --message-handhelds-margin: 5.5625rem;\n  --message-beside-button-margin: 2.875rem;\n  --message-time-background: rgba(0, 0, 0, .35);\n  --message-highlightning-color: hsla(85.5319, 36.9171%, 40.402%, .4);//rgba(77, 142, 80, .4);\n  --messages-container-width: #{$messages-container-width};\n  --messages-text-size: 16px;\n  --messages-secondary-text-size: calc(var(--messages-text-size) - 1px);\n  --line-height: 1.3125;\n  --esg-sticker-size: 80px;\n  --disabled-opacity: .3;\n\n  // https://github.com/overtake/TelegramSwift/blob/5cc7d2475fe4738a6aa0486c23eaf80a89d33b97/submodules/TGUIKit/TGUIKit/PresentationTheme.swift#L2054\n  --peer-avatar-red-top: #ff885e;\n  --peer-avatar-red-bottom: #ff516a;\n  --peer-avatar-orange-top: #ffcd6a;\n  --peer-avatar-orange-bottom: #ffa85c;\n  --peer-avatar-violet-top: #82b1ff;\n  --peer-avatar-violet-bottom: #665fff;\n  --peer-avatar-green-top: #a0de7e;\n  --peer-avatar-green-bottom: #54cb68;\n  --peer-avatar-cyan-top: #53edd6;\n  --peer-avatar-cyan-bottom: #28c9b7;\n  --peer-avatar-blue-top: #72d5fd;\n  --peer-avatar-blue-bottom: #2a9ef1;\n  --peer-avatar-pink-top: #e0a2f3;\n  --peer-avatar-pink-bottom: #d669ed;\n\n  @include respond-to(handhelds) {\n    --right-column-width: 100vw;\n    --esg-sticker-size: 68px;\n\n    --chat-input-size: #{$chat-input-handhelds-size};\n    --chat-input-padding: #{$chat-padding-handhelds};\n    --chat-input-inner-padding: #{$chat-input-inner-padding-handhelds};\n  }\n\n  @include respond-to(not-handhelds) {\n    --right-column-width: calc(#{$large-screen} / 4);\n\n    --chat-input-size: #{$chat-input-size};\n    --chat-input-padding: #{$chat-padding};\n    --chat-input-inner-padding: #{$chat-input-inner-padding};\n  }\n\n  @include respond-to(esg-bottom) {\n    --chat-input-size: #{$chat-input-handhelds-size};\n    --chat-input-inner-padding: #{$chat-input-inner-padding-handhelds};\n  }\n\n  @include respond-to(only-medium-screens) {\n    --right-column-width: 25vw;\n  }\n}\n\n@mixin splitColor($property, $color, $light: true, $dark: true) {\n  --#{$property}: #{$color};\n\n  @if $light != false {\n    --light-#{$property}: #{hover-color($color)};\n  }\n\n  @if $dark != false {\n    --dark-#{$property}: #{darken($color, $hover-alpha * 100)};\n  }\n}\n\n:root {\n  // * Day theme\n  --body-background-color: #fff;\n  --background-color-true: #f4f4f5;\n  --background-color: #fff;\n  --border-color: #dfe1e5;\n  --surface-color: #fff;\n  --scrollbar-color: rgba(0, 0, 0, .2);\n\n  --input-search-background-color: #fff;\n  --input-search-border-color: #dfe1e5;\n\n  @include splitColor(primary-color, #3390ec, true, true);\n  --primary-text-color: #000;\n\n  --secondary-color: #c4c9cc;\n  @include splitColor(secondary-text-color, #707579, true, false);\n\n  @include splitColor(danger-color, #df3f40, true, false);\n\n  --avatar-online-color: #0ac630;\n  --avatar-color-top: var(--peer-avatar-blue-top);\n  --avatar-color-bottom: var(--peer-avatar-blue-bottom);\n  --chatlist-status-color: var(--avatar-online-color);\n  --chatlist-pinned-color: #a2abb2;\n  --badge-text-color: #fff;\n  --link-color: #00488f;\n  --ripple-color: rgba(0, 0, 0, .08);\n  --poll-circle-color: var(--border-color);\n\n  --message-background-color: var(--surface-color);\n  --message-checkbox-color: #61c642;\n  --message-checkbox-border-color: #fff;\n  --message-secondary-color: var(--secondary-color);\n\n  @include splitColor(message-out-background-color, #eeffde, true, true);\n  --message-out-link-color: var(--link-color);\n  --message-out-primary-color: #4fae4e;\n  --message-out-status-color: var(--message-out-primary-color);\n  --message-out-audio-play-button-color: #fff;\n\n  // * Day theme end\n}\n\nhtml.night {\n//:root {\n  // * Night theme\n  --body-background-color: #181818;\n  --background-color-true: #181818;\n  --background-color: #212121;\n  --border-color: #0f0f0f;\n  --surface-color: #212121;\n  --scrollbar-color: rgba(255, 255, 255, .2);\n\n  --input-search-background-color: #181818;\n  --input-search-border-color: #2f2f2f;\n\n  @include splitColor(primary-color, #8774E1, true, true);\n  --primary-text-color: #fff;\n\n  --secondary-color: #707579;\n  @include splitColor(secondary-text-color, #aaaaaa, true, false);\n\n  @include splitColor(danger-color, #ff595a, true, false);\n\n  --avatar-online-color: #0ac630;\n  --avatar-color-top: var(--peer-avatar-violet-top);\n  --avatar-color-bottom: var(--peer-avatar-violet-bottom);\n  --chatlist-status-color: var(--primary-color);\n  --chatlist-pinned-color: var(--secondary-color);\n  --badge-text-color: #fff;\n  --link-color: var(--primary-color);\n  --ripple-color: rgba(255, 255, 255, .08);\n  --poll-circle-color: #fff;\n\n  --message-background-color: var(--surface-color);\n  --message-checkbox-color: var(--primary-color);\n  --message-checkbox-border-color: #fff;\n  --message-secondary-color: var(--secondary-color);\n\n  //@include splitColor(message-out-background-color, #ae582d, true, true);\n  @include splitColor(message-out-background-color, #8774E1, true, true);\n  --message-out-link-color: #fff;\n  --message-out-primary-color: #fff;\n  --message-out-status-color: rgba(255, 255, 255, .6);\n  --message-out-audio-play-button-color: var(--message-out-background-color);\n  // * Night theme end\n}\n\n@import \"partials/ico\";\n@import \"partials/input\";\n@import \"partials/button\";\n@import \"partials/animatedIcon\";\n@import \"partials/autocompleteHelper\";\n@import \"partials/autocompletePeerHelper\";\n@import \"partials/badge\";\n@import \"partials/checkbox\";\n@import \"partials/chatlist\";\n@import \"partials/chat\";\n@import \"partials/chatTopbar\";\n@import \"partials/chatBubble\";\n@import \"partials/chatPinned\";\n@import \"partials/chatMarkupTooltip\";\n@import \"partials/chatStickersHelper\";\n@import \"partials/chatEmojiHelper\";\n@import \"partials/chatSearch\";\n@import \"partials/chatDrop\";\n@import \"partials/crop\";\n@import \"partials/sidebar\";\n@import \"partials/profile\";\n@import \"partials/slider\";\n@import \"partials/leftSidebar\";\n@import \"partials/rightSidebar\";\n@import \"partials/mediaViewer\";\n@import \"partials/ckin\";\n@import \"partials/emojiDropdown\";\n@import \"partials/scrollable\";\n@import \"partials/selector\";\n@import \"partials/gifsMasonry\";\n@import \"partials/preloader\";\n@import \"partials/ripple\";\n@import \"partials/avatar\";\n@import \"partials/document\";\n@import \"partials/audio\";\n@import \"partials/quizHint\";\n@import \"partials/peerTyping\";\n@import \"partials/poll\";\n@import \"partials/transition\";\n@import \"partials/row\";\n@import \"partials/colorPicker\";\n@import \"partials/replyKeyboard\";\n\n@import \"partials/popups/popup\";\n@import \"partials/popups/editAvatar\";\n@import \"partials/popups/mediaAttacher\";\n@import \"partials/popups/peer\";\n@import \"partials/popups/stickers\";\n@import \"partials/popups/datePicker\";\n@import \"partials/popups/createPoll\";\n@import \"partials/popups/forward\"; \n@import \"partials/popups/instanceDeactivated\";\n@import \"partials/popups/joinChatInvite\";\n\n@import \"partials/pages/pages\";\n@import \"partials/pages/authCode\";\n@import \"partials/pages/chats\";\n@import \"partials/pages/password\";\n\n/* cyrillic */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 400;\n  font-display: swap;\n  src: local('Roboto'), local('Roboto-Regular'), url(assets/fonts/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format('woff2');\n  unicode-range:U + 0400-045F, U + 0490-0491, U + 04B0-04B1, U + 2116\n}\n\n/* latin-ext */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 400;\n  font-display: swap;\n  src: local('Roboto'), local('Roboto-Regular'), url(assets/fonts/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format('woff2');\n  unicode-range:U + 0100-024F, U + 0259, U + 1E00-1EFF, U + 2020, U + 20A0-20AB, U + 20AD-20CF, U + 2113, U + 2C60-2C7F, U + A720-A7FF\n}\n\n/* latin */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 400;\n  font-display: swap;\n  src: local('Roboto'), local('Roboto-Regular'), url(assets/fonts/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format('woff2');\n  unicode-range:U + 0000-00FF, U + 0131, U + 0152-0153, U + 02BB-02BC, U + 02C6, U + 02DA, U + 02DC, U + 2000-206F, U + 2074, U + 20AC, U + 2122, U + 2191, U + 2193, U + 2212, U + 2215, U + FEFF, U + FFFD\n}\n\n/* cyrillic */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 500;\n  font-display: swap;\n  src: local('Roboto Medium'), local('Roboto-Medium'), url(assets/fonts/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format('woff2');\n  unicode-range:U + 0400-045F, U + 0490-0491, U + 04B0-04B1, U + 2116\n}\n\n/* latin-ext */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 500;\n  font-display: swap;\n  src: local('Roboto Medium'), local('Roboto-Medium'), url(assets/fonts/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format('woff2');\n  unicode-range:U + 0100-024F, U + 0259, U + 1E00-1EFF, U + 2020, U + 20A0-20AB, U + 20AD-20CF, U + 2113, U + 2C60-2C7F, U + A720-A7FF\n}\n\n/* latin */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 500;\n  font-display: swap;\n  src: local('Roboto Medium'), local('Roboto-Medium'), url(assets/fonts/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format('woff2');\n  unicode-range:U + 0000-00FF, U + 0131, U + 0152-0153, U + 02BB-02BC, U + 02C6, U + 02DA, U + 02DC, U + 2000-206F, U + 2074, U + 20AC, U + 2122, U + 2191, U + 2193, U + 2212, U + 2215, U + FEFF, U + FFFD\n}\n\n// !!! FIX FOR [contenteditable] Ctrl+B, due to font-weight: 500;\n\n/* cyrillic */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 700;\n  font-display: swap;\n  src: local('Roboto Medium'), local('Roboto-Medium'), url(assets/fonts/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format('woff2');\n  unicode-range:U + 0400-045F, U + 0490-0491, U + 04B0-04B1, U + 2116\n}\n\n/* latin-ext */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 700;\n  font-display: swap;\n  src: local('Roboto Medium'), local('Roboto-Medium'), url(assets/fonts/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format('woff2');\n  unicode-range:U + 0100-024F, U + 0259, U + 1E00-1EFF, U + 2020, U + 20A0-20AB, U + 20AD-20CF, U + 2113, U + 2C60-2C7F, U + A720-A7FF\n}\n\n/* latin */\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 700;\n  font-display: swap;\n  src: local('Roboto Medium'), local('Roboto-Medium'), url(assets/fonts/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format('woff2');\n  unicode-range:U + 0000-00FF, U + 0131, U + 0152-0153, U + 02BB-02BC, U + 02C6, U + 02DA, U + 02DC, U + 2000-206F, U + 2074, U + 20AC, U + 2122, U + 2191, U + 2193, U + 2212, U + 2215, U + FEFF, U + FFFD\n}\n\nhtml, body {\n  height: 100%;\n  width: 100%;\n  margin: 0;\n  padding: 0;\n  \n  @include respond-to(handhelds) {\n    overflow: hidden;\n    height: calc(var(--vh, 1vh) * 100);\n  }\n\n  /* @include respond-to(handhelds) {\n    //overflow-y: auto;\n    height: 100%;\n    min-height: 100%;\n    min-width: 100%;\n  }\n\n  @include respond-to(not-handhelds) {\n    width: 100%;\n    height: 100%;\n  } */\n}\n\nhtml.is-ios {\n  //&, body {\n    position: fixed; // fix iOS fullscreen scroll\n  //}\n}\n\n@supports(padding: unquote('max(0px)')) {\n  html {\n    padding: 0 unquote('min(16px, env(safe-area-inset-right))') 0 unquote('min(16px, env(safe-area-inset-left))');\n  }\n}\n\nhtml {\n  font-size: 16px;\n  //overflow: hidden;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-size-adjust: 100%;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  //text-rendering: optimizeSpeed;\n}\n\nbody {\n  //touch-action: pan-x pan-y;\n  background-color: var(--body-background-color);\n  color: var(--primary-text-color);\n}\n\nbody.deactivated {\n  animation: grayscale-in var(--transition-standard-in) forwards;\n}\n\nbody.deactivated-backwards {\n  animation: grayscale-out var(--transition-standard-out) forwards;\n}\n\n@keyframes grayscale-in {\n  0% {\n    filter: grayscale(0);\n  }\n\n  100% {\n    filter: grayscale(1);\n  }\n}\n\n@keyframes grayscale-out {\n  0% {\n    filter: grayscale(1);\n  }\n\n  100% {\n    filter: grayscale(0);\n  }\n}\n\n/* body {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  min-height: 0!important;\n} */\n\na {\n  color: var(--link-color);\n}\n\nbutton, input, optgroup, select, textarea, html {\n  font-family: \"Roboto\", -apple-system, apple color emoji, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif;\n}\n\ninput, textarea, button, select, a, div {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n\n.whole {\n  min-height: 100%;\n  width: 100%;\n  //min-width: 100%;\n  margin: 0 auto;\n  max-width: $large-screen;\n\n  //@include respond-to(not-handhelds) {\n    height: 100%;\n  //}\n}\n\n.disable-hover/* ,\n.disable-hover * */ {\n  pointer-events: none !important;\n}\n\n@include respond-to(not-handhelds) {\n  .only-handhelds {\n    display: none !important;\n  }\n}\n\n.container {\n  margin: 0 auto;\n}\n\nh1, h2, h3, h4, h5, h6 {\n  font-weight: 500;\n}\n\nh4 {\n  font-size: 2rem;\n  //margin: 1.5rem 0 1rem 0;\n  margin: 22px 0 14px;\n  line-height: 110%;\n\n  @include respond-to(handhelds) {\n    font-size: 20px;\n    margin: 2px 0 8px;\n  }\n}\n\ninput, [contenteditable=true] {\n  caret-color: var(--primary-color);\n  color: var(--primary-text-color);\n  background-color: transparent;\n}\n\ninput, textarea {\n\t-webkit-appearance: none;\n}\n\n/* input:-webkit-autofill,\ninput:-webkit-autofill:hover,\ninput:-webkit-autofill:focus,\ninput:-webkit-autofill:active {\n  transition: background-color 5000s ease-in-out 0s;\n} */\n\n.subtitle {\n  /* font-weight: 500; */\n  color: var(--secondary-text-color);\n  line-height: 1.35;\n}\n\n.danger {\n  color: var(--danger-color) !important;\n\n  .c-ripple__circle {\n    background-color: var(--light-danger-color);\n  }\n}\n\n.blue, .primary {\n  color: var(--primary-color) !important;\n\n  .c-ripple__circle {\n    background-color: var(--light-primary-color);\n  }\n}\n\n.blue:before, .primary:before, .danger:before {\n  color: inherit !important;\n}\n\n.bg-warning {\n  background: #fed85a !important;\n}\n\n.contextmenu {\n\tposition: fixed !important;\n\tright: auto !important;\n  bottom: auto !important;\n  width: auto !important;\n  z-index: 4 !important;\n}\n\n.preloader {\n  width: 50px;\n  height: 50px;\n  \n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  \n  // ! do not change it to &-path\n  .preloader-path {\n    stroke: var(--primary-color);\n  }\n}\n\n@keyframes thumbnail-fade-in-opacity {\n  0% {\n    opacity: 0;\n  }\n\n  to {\n    opacity: .8;\n  }\n}\n\n@keyframes fade-in-opacity {\n  0% {\n    opacity: 0;\n  }\n\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fade-out-opacity {\n  0% {\n    opacity: 1;\n  }\n\n  to {\n    opacity: 0;\n  }\n}\n\n@keyframes fade-in-backwards-opacity {\n  0% {\n    opacity: 1;\n  }\n  100% {\n    opacity: 0;\n  }\n}\n\n@keyframes fade-out-backwards-opacity {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n@keyframes fade-in-opacity-fade-out-opacity {\n  0% {\n    opacity: 0;\n  }\n\n  10% {\n    opacity: 1;\n  }\n\n  50% {\n    opacity: 1;\n  }\n\n  to {\n    opacity: 0;\n  }\n}\n\n.toast {\n  position: fixed;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  padding: .5rem 1rem;\n  background-color: rgba(0, 0, 0, .66);\n  color: #fff;\n  font-size: 1rem;\n  border-radius: $border-radius-medium;\n  animation: fade-in-opacity-fade-out-opacity 3s linear forwards;\n  z-index: 5;\n  max-width: 22.5rem;\n\n  b {\n    color: inherit;\n  }\n}\n\nhr {\n  width: 100%;\n  border: none;\n  border-top: 1px solid var(--border-color);\n  margin: 0;\n  padding-bottom: .5rem;\n}\n\n.user-title, b/* , .user-last-message b */ {\n  color: var(--primary-text-color);\n  font-weight: bolder;\n  //font-weight: 500;\n  //font-weight: normal;\n}\n\n.user-last-message b {\n  font-weight: 400;\n  //margin-right: .25rem;\n}\n\n.avatar-edit {\n  position: relative;\n  border-radius: 50%;\n  cursor: pointer;\n  overflow: hidden;\n\n  &-canvas {\n    max-width: 100%;\n    max-height: 100%;\n    width: 100%;\n    height: 100%;\n    background-color: var(--primary-color);\n  }\n\n  .tgico-cameraadd {\n    position: absolute;\n    font-size: 48px;\n\t  line-height: 48px;\n    top: 50%;\n    left: 50%;\n    transform: translateY(-50%) translateX(-50%);\n    z-index: 2;\n    color: #fff;\n  }\n\n  .avatar-placeholder {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    filter: brightness(0.7);\n  }\n}\n\n.select-wrapper {\n  max-height: 23.5rem;\n  /* height: auto; */\n  position: absolute;\n  width: 100%;\n  top: calc(100% + .5rem);\n  left: 0;\n  overflow: hidden;\n  background-color: var(--surface-color);\n  z-index: 3;\n  border-radius: $border-radius-medium;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: wrap;\n  transition: opacity .2s ease-out, transform .2s ease-out;\n  transform: scale(.95);\n  transform-origin: top center;\n  opacity: 0;\n\n  &.active {\n    transform: scale(1);\n    opacity: 1;\n  }\n  \n  ul {\n    margin: .5rem 0;\n  }\n  \n  li {\n    /* display: flex; */\n    align-items: center;\n    padding: 0 1rem;\n    justify-content: space-between;\n    height: 3.5rem;\n    cursor: pointer;\n    /* font-weight: 500; */\n    \n    text-align: left;\n    display: grid;\n    grid-template-columns: calc(26px + 2rem) 1fr 80px;\n    \n    @include hover-background-effect();\n  }\n  \n  // +2 px bc of whitespace\n  .emoji {\n    height: 26px;\n    width: 26px;\n    font-size: 26px;\n    line-height: 1;\n  }\n\n  .scrollable {\n    position: relative;\n  }\n}\n\n.phone-code {\n  color: $placeholder-color;\n  text-align: right;\n}\n\n// this dimensions will be used for monkey business\n.auth-image {\n  width: 166px;\n  height: 166px;\n  margin: 0 auto 18px;\n  position: relative;\n  \n  @include respond-to(handhelds) {\n    width: 120px;\n    height: 120px;\n  }\n}\n\n/* .phone-wrapper {\n  display: flex;\n  align-items: ;\n} */\n\n.phone-edit {\n  display: inline-block;\n  width: 24px;\n  height: 24px;\n  margin-left: .4rem;\n  opacity: .5;\n  transition: .2s opacity;\n  cursor: pointer;\n  font-size: 1.5rem;\n  \n  @include respond-to(handhelds) {\n    margin-top: -14px;\n  }\n  \n  @include hover() {\n    opacity: 1;\n  }\n}\n\nspan.emoji {\n  display: inline !important;\n  vertical-align: unset !important;\n  //line-height: 1em;\n  //font-size: 1em;\n\n  font-family: apple color emoji,segoe ui emoji,noto color emoji,android emoji,emojisymbols,emojione mozilla,twemoji mozilla,segoe ui symbol;\n  line-height: 1 !important;\n}\n\nimg.emoji {\n  width: 18px;\n  height: 18px;\n  margin: 0 .125rem;\n\n  display: inline-block;\n  /* width: 100%;\n  height: 100%; */\n  max-width: 100%;\n  max-height: 100%;\n  vertical-align: middle;\n}\n\n[contenteditable=true] {\n  user-select: text;\n  outline: none;\n  cursor: text;\n}\n\n[contenteditable][data-placeholder] {\n  &:empty:before {\n    content: attr(data-placeholder);\n    color: #a2acb4;\n    display: block; /* For Firefox By Ariel Flesler */\n    pointer-events: none;\n  }\n}\n\n.sticky_sentinel {\n  position: absolute;\n  left: 0;\n  right: 0; /* needs dimensions */\n  visibility: hidden;\n  pointer-events: none;\n}\n\n.super-stickers {\n  width: 100%;\n\tdisplay: grid;\n\tgrid-template-columns: repeat(auto-fill, var(--esg-sticker-size)); // 64px\n\tgrid-column-gap: 1px;\n\tjustify-content: space-between;\n}\n\n.super-sticker {\n  @include hover-background-effect() {\n    border-radius: 10px;\n  }\n  \n  /* &:nth-child(5n+5) {\n    margin-right: 0;\n  } */\n  \n  /* > img, > .rlottie {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n  }\n\n  > img {\n    object-fit: contain;\n    \n    @include animation-level(2) {\n      animation: fade-in-opacity .2s ease forwards;\n    }\n  } */\n}\n\n.fade-in-transition {\n  opacity: 1;\n  transition: opacity .2s ease;\n}\n\n.show-more {\n  padding-top: 13px;\n  padding-bottom: 13px;\n  cursor: pointer;\n  user-select: none;\n  position: relative;\n\n  @include respond-to(not-handhelds) {\n    padding-left: 8px;\n  }\n\n  .tgico-down {\n    float: left;\n    padding-right: 32px;\n    padding-left: 16px;\n    font-size: 24px;\n    color: var(--secondary-text-color);\n  }\n}\n\n// .message .audio .preloader-container {\n// \t@include respond-to(handhelds) {\n// \t\twidth: 30px;\n// \t\theight: 30px;\n// \t\tleft: 2px;\n// \t}\n// }\n\n.content-empty {\n  color: var(--secondary-text-color);\n}\n\n@keyframes grow-icon {\n  0% {\n    transform: scale(.5);\n    opacity: .8;\n  }\n\n  50% {\n    transform: scale(1.1);\n    opacity: 1;\n  }\n\n  100% {\n    transform: scale(1);\n  }\n}\n\n@keyframes hide-icon {\n  from {\n    transform: scale(1);\n    opacity: .4;\n  }\n\n  to {\n    transform: scale(.5);\n    opacity: 0;\n  }\n}\n\n.popup-disable-password, .popup-skip-email {\n  .popup-description {\n    max-width: 284px;\n  }\n}\n\n.grid {\n  width: 100%;\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-auto-rows: 1fr;\n  grid-gap: .25rem;\n\n  &-item {\n    height: 0;\n    padding-bottom: 100%;\n    //overflow: hidden;\n    position: relative;\n    cursor: pointer;\n    user-select: none;\n    \n    &-media {\n      position: absolute;\n      left: 0;\n      top: 0;\n      width: 100%;\n      height: 100%;\n      object-fit: cover;\n    }\n  }\n}\n\n.animated-super {\n  &-row {\n    --translateY: 100%;\n    position: absolute;\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    transition: transform var(--pm-transition), opacity var(--pm-transition);\n\n    body.animation-level-0 & {\n      transition: none;\n    }\n\n    /* &:not(.is-hiding) {\n      transform: none !important;\n    } */\n\n    &.is-hiding {\n      opacity: 0;\n\n      &.from-top {\n        transform: translate3d(0, calc(var(--translateY) * -1), 0);\n        //transform: translateY(calc(var(--translateY) * -1));\n        //transform: translateY(-100%);\n      }\n\n      &.from-bottom {\n        transform: translate3d(0, var(--translateY), 0);\n        //transform: translateY(var(--translateY));\n        //transform: translateY(100%);\n      }\n      \n      /* &.backwards {\n        opacity: 1;\n        transform: translateY(0) !important;\n      } */\n    }\n  }\n}\n\n.animated-counter {\n  display: inline-flex;\n\n  &-decimal {\n    position: relative;\n\n    &-placeholder {\n      color: transparent;\n    }\n\n    &-wrapper {\n      position: absolute;\n      left: 0;\n      top: 0;\n      bottom: 0;\n      right: 0;\n    }\n\n    /* &:not(:first-child) {\n      .animated-super {\n        &-row {\n          &.is-hiding {\n            &.from-top {\n              transform: translateY(100%);\n            }\n      \n            &.from-bottom {\n              transform: translateY(-100%);\n            }\n          }\n        }\n      }\n    } */\n  }\n\n  /* &.from-top {\n    .animated-super-row.is-hiding {\n      &.from-top {\n        transform: translateY(100%) !important;\n      }\n    }\n  } */\n}\n\n// *:not(input):not(textarea) {\n//   -webkit-user-select: none; /* disable selection/Copy of UIWebView */\n//   -webkit-touch-callout: none; /* disable the IOS popup when long-press on a link */\n// }   \n\nmiddle-ellipsis-element {\n  width: 100%;\n\toverflow: hidden;\n\tdisplay: block;\n}\n\n.album-item {\n  &-media {\n    width: 100%;\n    height: 100%;\n  }\n}\n\n.hover-effect {\n  @include hover-background-effect();\n}\n\n.progress-ring {\n  position: absolute;\n  top: 0;\n  left: 0;\n  pointer-events: none;\n\n  &__circle {\n    transition: stroke-dashoffset;\n    stroke-linecap: round;\n  }\n}\n\n.rlottie, .rlottie-vector {\n  left: 0;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  position: absolute;\n  max-width: 100%;\n  max-height: 100%;\n  width: 100%;\n  height: 100%;\n}\n\n.rlottie.fade-in {\n  @include animation-level(2) {\n    animation: fade-in-opacity .2s ease-in-out forwards;\n  }\n}\n\n.rlottie-vector {\n  fill: rgba(0, 0, 0, .08);\n}\n\n.media-photo, .media-video, .media-sticker, .media-round {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n\n  @include animation-level(2) {\n    &.fade-in {\n      animation: fade-in-opacity .2s ease-in-out forwards;\n    }\n  \n    &.fade-out {\n      animation: fade-out-opacity .2s ease-in-out forwards;\n    }\n  }\n}\n\n.media-photo.thumbnail {\n  @include animation-level(2) {\n    &.fade-in {\n      animation: thumbnail-fade-in-opacity .2s ease-in-out forwards;\n    }\n  }\n}\n\n.media-video {\n  z-index: 1; // * overflow media-photo\n}\n\n.media-sticker {\n  margin: auto;\n  object-fit: contain;\n  width: 100%;\n  height: 100%;\n  max-width: 100%;\n  max-height: 100%;\n}\n\n.media-round {\n  max-width: 200px;\n  max-height: 200px;\n  z-index: 1;\n\n  canvas {\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    position: relative;\n  }\n\n  .video-time {\n    padding: 1px 6px 2px;\n    background-color: rgba(0, 0, 0, .23) !important;\n  }\n\n  &.is-paused .video-time {\n    &:after {\n      content: $tgico-nosound;\n      padding-left: .25rem;\n      display: flex;\n      align-items: center;\n      font-size: 1.125rem;\n    }\n  }\n}\n\n.gradient-delimiter {\n  width: 100%;\n  height: .75rem;\n  background-color: var(--background-color-true);\n  position: relative;\n\n  &:before {\n    content: \" \";\n    position: absolute;\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    background: linear-gradient(180deg, rgba(0, 0, 0, .06) 0%, rgba(0, 0, 0, 0) 20%, rgba(0, 0, 0, 0) 94%, rgba(0, 0, 0, .06) 100%);\n  }\n}\n\n// ! TEMPORARY\n.tgico-reply:before, \n.tgico-attach:before,\n.tgico-saved:before,\n.tgico-phone:before,\n.tgico-admin:before,\n.tgico-message:before,\n.tgico-fontsize:before,\n.tgico-forward:before {\n  font-size: 20px !important;\n  padding: 0 2px;\n}\n\n.stealthy {\n  left: 0;\n  margin: 0;\n  max-height: 1px;\n  max-width: 1px;\n  opacity: 0;\n  outline: none;\n  overflow: hidden;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  z-index: -1;\n}\n\n.verified-check {\n  fill: #fff;\n}\n\n.verified-background {\n  fill: #33a8e5;\n}\n\n.navigable-list {\n  .active {\n    background-color: var(--light-secondary-text-color);\n    border-radius: inherit;\n  }\n}\n\n.super-emojis {\n  // ! No chrome 56 support\n  display: grid;\n  grid-column-gap: 2.44px;\n  grid-template-columns: repeat(auto-fill, 2.625rem);\n  justify-content: space-between;\n\n  font-size: 2.125rem;\n  line-height: 2.125rem;\n\n  .super-emoji {\n    display: inline-block;\n    margin: 0 .0625rem;\n    padding: .25rem;\n    line-height: inherit;\n    border-radius: $border-radius;\n    cursor: pointer;\n    user-select: none;\n    vertical-align: middle;\n    \n    width: 2.625rem;\n    height: 2.625rem;\n\n    html:not(.emoji-supported) & {\n      position: relative;\n    }\n\n    .emoji-placeholder {\n      position: absolute;\n      left: 7px;\n      top: 7px;\n      width: 1.75rem;\n      height: 1.75rem;\n      border-radius: 50%;\n      background-color: var(--light-secondary-text-color);\n      pointer-events: none;\n\n      @include animation-level(2) {\n        opacity: 0;\n        transition: opacity .2s ease-in-out;\n      }\n    }\n\n    @include animation-level(2) {\n      img {\n        opacity: 1;\n        transition: opacity .2s ease-in-out;\n      }\n    }\n    \n    .emoji {\n      width: 100%;\n      height: 100%;\n      vertical-align: unset;\n      margin: 0;\n    }\n    \n    @include hover-background-effect();\n  }\n}\n\n.tgico-char {\n  &:before {\n    font-family: \"Roboto\" !important;\n    font-weight: 500;\n    width: 1.5rem;\n    text-align: center;\n  }\n\n  &.z:before {\n    content: \"Z\";\n  }\n\n  &.w:before {\n    content: \"W\";\n  }\n}\n"], "buggy_code_start_loc": [871, 275, 59, 22, 578, 20, 11, 204, 29, 39, 14, 510, 3135, 38, 95, 2629, 264, 751, 8, 401, 832, 711, 150, 1215], "buggy_code_end_loc": [873, 276, 60, 300, 622, 21, 114, 205, 579, 40, 83, 511, 3135, 1060, 205, 2630, 297, 786, 8, 401, 1192, 740, 156, 1216], "fixing_code_start_loc": [871, 275, 59, 23, 578, 20, 10, 204, 29, 39, 15, 510, 3136, 38, 96, 2629, 264, 751, 9, 402, 833, 711, 150, 1214], "fixing_code_end_loc": [872, 276, 60, 303, 633, 21, 97, 205, 576, 40, 94, 511, 3137, 1141, 206, 2630, 293, 786, 10, 485, 1201, 712, 156, 1214], "type": "CWE-79", "message": "Telegram Web K Alpha 0.6.1 allows XSS via a document name.", "other": {"cve": {"id": "CVE-2021-37596", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-30T14:15:18.700", "lastModified": "2021-08-09T13:59:15.233", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Telegram Web K Alpha 0.6.1 allows XSS via a document name."}, {"lang": "es", "value": "Telegram Web K Alpha versi\u00f3n 0.6.1, permite un ataque de tipo XSS por medio de un nombre de documento"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:telegram:web_k_alpha:0.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "4AC1A1C4-67F1-47E2-BB71-4C78E315A659"}]}]}], "references": [{"url": "https://github.com/morethanwords/tweb/commit/11d2fe01363889f20c8baa2217ed4aad445c5551", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/morethanwords/tweb/commit/11d2fe01363889f20c8baa2217ed4aad445c5551"}}